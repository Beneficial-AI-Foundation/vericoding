"vc-description": ">When no more interesting kata can be resolved, I just choose to\
  \ create the new kata, to solve their own, to enjoy the process  --myjinxin2015\
  \ said\n\n# Description:\n \n Give you two arrays `arr1` and `arr2`. They have the\
  \ same length(length>=2). The elements of two arrays always be integer.\n \n Sort\
  \ `arr1` according to the ascending order of arr2; Sort `arr2` according to the\
  \ ascending order of arr1. Description is not easy to understand, for example:\n\
  \ ```\n arr1=[5,4,3,2,1], \n arr2=[6,5,7,8,9]\n ```\n Let us try to sorting arr1.\
  \ \n First, we need know the ascending order of arr2:\n ```\n [5,6,7,8,9]\n ```\n\
  \ We can see, after sort arr2 to ascending order, some elements' index are changed:\n\
  \ ```\n unsort arr2      ascending order arr2\n [6,5,7,8,9]--->      [5,6,7,8,9]\n\
  \ \n index0(6)  --->      index1\n index1(5)  --->      index0\n index2(7)     \
  \       index2(no change)\n index3(8)            index3(no change)\n index4(9) \
  \           index4(no change)\n ```\n So, wo need according to these changes to\
  \ sorting arr1:\n ```\n unsort arr1          sorted arr1\n [5,4,3,2,1]--->     \
  \ [4,5,3,2,1]\n \n index0(5)  --->      index1\n index1(4)  --->      index0\n index2(3)\
  \            index2(no change)\n index3(2)            index3(no change)\n index4(1)\
  \            index4(no change)\n \n So: sorted arr1= [4,5,3,2,1]\n ```\n And then,\
  \ we sorting arr2 with the same process:\n ```\n unsort arr1      ascending order\
  \ arr1\n [5,4,3,2,1]--->      [1,2,3,4,5]\n \n index0(5)  --->      index4\n index1(4)\
  \  --->      index3\n index2(3)            index2(no change)\n index3(2)  ---> \
  \     index1\n index4(1)  --->      index0\n \n unsort arr2          sorted arr2\n\
  \ [6,5,7,8,9]--->      [9,8,7,5,6]\n \n index0(6)  --->      index4\n index1(5)\
  \  --->      index3\n index2(7)            index2(no change)\n index3(8)  ---> \
  \     index1\n index4(9)  --->      index0\n \n So: sorted arr2= [9,8,7,5,6]\n \n\
  \ ```\n Finally, returns the sorted arrays by a 2D array: `[sorted arr1, sorted\
  \ arr2]`\n \n Note: In ascending order sorting process(not the final sort), if some\
  \ elements have same value, sort them according to their index; You can modify the\
  \ original array, but I advise you not to do that. ;-)\n\n```if:haskell\n Note:\
  \ In Haskell, you are expected to return a tuple of arrays, and good luck trying\
  \ to modifiy the original array. :]\n```\n\n# Some Examples and explain\n\n```\n\
  sortArrays([5,4,3,2,1],[6,5,7,8,9]) should return\n[[4,5,3,2,1],[9,8,7,5,6]]\n\n\
  sortArrays([2,1,3,4,5],[5,6,7,8,9]) should return\n[[2,1,3,4,5],[6,5,7,8,9]]\n\n\
  sortArrays([5,6,9,2,6,5],[3,6,7,4,8,1]) should return\n[[5,5,2,6,9,6],[4,3,1,6,8,7]]\n\
  ```"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def sortArrays (arr1 arr2 : List Int) : List Int × List Int :=\n\
  \  sorry\n"
"vc-theorems": "theorem sort_arrays_length_preservation\n  (arr1 arr2 : List Int)\n\
  \  (h : arr1.length = arr2.length)\n  (result := sortArrays arr1 arr2) :\n  result.1.length\
  \ = arr1.length ∧ result.2.length = arr2.length :=\n  sorry\n\n\ntheorem sort_arrays_ordering\n\
  \  (arr1 arr2 : List Int)\n  (h : arr1.length = arr2.length)\n  (result := sortArrays\
  \ arr1 arr2)\n  (i j : Fin arr1.length)\n  (h1 : (sortArrays arr1 arr2).1.length\
  \ = arr1.length) \n  (h2 : (sortArrays arr1 arr2).2.length = arr2.length) :\n  let\
  \ i' : Fin (sortArrays arr1 arr2).1.length := ⟨i.val, by rw [h1]; exact i.isLt⟩\n\
  \  let j' : Fin (sortArrays arr1 arr2).1.length := ⟨j.val, by rw [h1]; exact j.isLt⟩\n\
  \  (arr2[i] ≤ arr2[j]) = ((sortArrays arr1 arr2).1[i'] ≤ (sortArrays arr1 arr2).1[j'])\
  \ ∧\n  (arr1[i] ≤ arr1[j]) = ((sortArrays arr1 arr2).2[i'] ≤ (sortArrays arr1 arr2).2[j'])\
  \ :=\n  sorry\n\n\ntheorem sort_arrays_elements_preserved\n  (arr1 arr2 : List Int)\n\
  \  (h : arr1.length = arr2.length)\n  (result := sortArrays arr1 arr2) : \n  ∀ x,\
  \ result.1.foldr (fun y acc => if y = x then acc + 1 else acc) 0 = \n       arr1.foldr\
  \ (fun y acc => if y = x then acc + 1 else acc) 0 ∧\n       result.2.foldr (fun\
  \ y acc => if y = x then acc + 1 else acc) 0 = \n       arr2.foldr (fun y acc =>\
  \ if y = x then acc + 1 else acc) 0 :=\n  sorry\n\n\ntheorem sort_arrays_identical_lists\n\
  \  (arr : List Int)\n  (result := sortArrays arr arr) :\n  result.1 = result.2 :=\n\
  \  sorry\n\n/--\ninfo: [[4, 5, 3, 2, 1], [9, 8, 7, 5, 6]]\n-/\n#guard_msgs in\n\
  #eval sort_arrays #[5, 4, 3, 2, 1] #[6, 5, 7, 8, 9]\n\n/--\ninfo: [[2, 1, 3, 4,\
  \ 5], [6, 5, 7, 8, 9]]\n-/\n#guard_msgs in\n#eval sort_arrays #[2, 1, 3, 4, 5] #[5,\
  \ 6, 7, 8, 9]\n\n/--\ninfo: [[5, 5, 2, 6, 9, 6], [4, 3, 1, 6, 8, 7]]\n-/\n#guard_msgs\
  \ in\n#eval sort_arrays #[5, 6, 9, 2, 6, 5] #[3, 6, 7, 4, 8, 1]\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
