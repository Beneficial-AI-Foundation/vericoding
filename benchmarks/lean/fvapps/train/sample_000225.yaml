"vc-description": "Given an array of integers A with even length, return true if and\
  \ only if it is possible to reorder it such that A[2 * i + 1] = 2 * A[2 * i] for\
  \ every 0 <= i < len(A) / 2.\n\n\n\n\n\n\n\n\n \nExample 1:\nInput: A = [3,1,3,6]\n\
  Output: false\n\nExample 2:\nInput: A = [2,1,2,6]\nOutput: false\n\nExample 3:\n\
  Input: A = [4,-2,2,-4]\nOutput: true\nExplanation: We can take two groups, [-2,-4]\
  \ and [2,4] to form [-2,-4,2,4] or [2,4,-2,-4].\n\nExample 4:\nInput: A = [1,2,4,16,8,4]\n\
  Output: false\n\n \nConstraints:\n\n0 <= A.length <= 3 * 104\nA.length is even.\n\
  -105 <= A[i] <= 105"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def can_reorder_doubled (lst : List Int) : Bool := sorry\n\ndef\
  \ count_occurrences (n : Int) (lst : List Int) : Nat :=\n  lst.foldl (fun acc x\
  \ => if x = n then acc + 1 else acc) 0\n"
"vc-theorems": "theorem reorder_doubled_count_property (lst : List Int) :\n  can_reorder_doubled\
  \ lst = true → lst ≠ [] →\n    ∀ n ∈ lst, n ≠ 0 →\n      (2 * n) ∈ lst ∧ count_occurrences\
  \ (2 * n) lst ≥ count_occurrences n lst := sorry\n\n\ntheorem single_numbers_not_doubled\
  \ {numbers : List Int} (h : ∀ n ∈ numbers, n ≠ 0) :\n  can_reorder_doubled (numbers\
  \ ++ [0]) = false := sorry\n\n\ntheorem empty_list_property :\n  can_reorder_doubled\
  \ [] = true := sorry\n\n\ntheorem all_zeros_property (n : Nat) :\n  can_reorder_doubled\
  \ (List.replicate n 0) = true := sorry\n\n/--\ninfo: False\n-/\n#guard_msgs in\n\
  #eval can_reorder_doubled [3, 1, 3, 6]\n\n/--\ninfo: True\n-/\n#guard_msgs in\n\
  #eval can_reorder_doubled [4, -2, 2, -4]\n\n/--\ninfo: False\n-/\n#guard_msgs in\n\
  #eval can_reorder_doubled [1, 2, 4, 16, 8, 4]\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
