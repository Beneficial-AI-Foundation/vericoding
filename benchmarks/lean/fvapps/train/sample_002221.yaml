"vc-description": "Fennec and Snuke are playing a board game.\nOn the board, there\
  \ are N cells numbered 1 through N, and N-1 roads, each connecting two cells. Cell\
  \ a_i is adjacent to Cell b_i through the i-th road. Every cell can be reached from\
  \ every other cell by repeatedly traveling to an adjacent cell. In terms of graph\
  \ theory, the graph formed by the cells and the roads is a tree.\nInitially, Cell\
  \ 1 is painted black, and Cell N is painted white. The other cells are not yet colored.\n\
  Fennec (who goes first) and Snuke (who goes second) alternately paint an uncolored\
  \ cell.\nMore specifically, each player performs the following action in her/his\
  \ turn:\n - Fennec: selects an uncolored cell that is adjacent to a black cell,\
  \ and paints it black.\n - Snuke: selects an uncolored cell that is adjacent to\
  \ a white cell, and paints it white.\nA player loses when she/he cannot paint a\
  \ cell. Determine the winner of the game when Fennec and Snuke play optimally.\n\
  \n-----Constraints-----\n - 2 \\leq N \\leq 10^5\n - 1 \\leq a_i, b_i \\leq N\n\
  \ - The given graph is a tree.\n\n-----Input-----\nInput is given from Standard\
  \ Input in the following format:\nN\na_1 b_1\n:\na_{N-1} b_{N-1}\n\n-----Output-----\n\
  If Fennec wins, print Fennec; if Snuke wins, print Snuke.\n\n-----Sample Input-----\n\
  7\n3 6\n1 2\n3 1\n7 4\n5 7\n1 4\n\n-----Sample Output-----\nFennec\n\nFor example,\
  \ if Fennec first paints Cell 2 black, she will win regardless of Snuke's moves."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def solve_tree_coloring (n : Nat) (edges : List (Nat × Nat)) :\
  \ String := sorry\n\ndef is_valid_tree (n : Nat) (edges : List (Nat × Nat)) : Bool\
  \ := sorry\n"
"vc-theorems": "theorem tree_coloring_result_valid (n : Nat) (edges : List (Nat ×\
  \ Nat)) :\n  is_valid_tree n edges → \n  solve_tree_coloring n edges = \"Fennec\"\
  \ ∨ solve_tree_coloring n edges = \"Snuke\" := sorry\n\n\ntheorem invalid_tree_error\
  \ (n : Nat) (edges : List (Nat × Nat)) :\n  ¬is_valid_tree n edges →\n  solve_tree_coloring\
  \ n edges = \"Error\" := sorry\n\n\ntheorem line_graph_valid_result (n : Nat) (h\
  \ : n ≥ 2) :\n  let edges := List.map (fun i => (i, i+1)) (List.range (n-1))\n \
  \ solve_tree_coloring n edges = \"Fennec\" ∨ solve_tree_coloring n edges = \"Snuke\"\
  \ := sorry\n\n\ntheorem basic_case_1 :\n  solve_tree_coloring 4 [(1,4), (4,2), (2,3)]\
  \ = \"Snuke\" := sorry\n\n\ntheorem basic_case_2 :\n  solve_tree_coloring 7 [(3,6),\
  \ (1,2), (3,1), (7,4), (5,7), (1,4)] = \"Fennec\" := sorry\n\n/--\ninfo: 'Fennec'\n\
  -/\n#guard_msgs in\n#eval solve_tree_coloring 7 [(3, 6), (1, 2), (3, 1), (7, 4),\
  \ (5, 7), (1, 4)]\n\n/--\ninfo: 'Snuke'\n-/\n#guard_msgs in\n#eval solve_tree_coloring\
  \ 4 [(1, 4), (4, 2), (2, 3)]\n"
"vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded"
