"vc-description": "# Convert a linked list to a string\n\n## Related Kata\n\nAlthough\
  \ this Kata is not part of an official Series, you may also want to try out [Parse\
  \ a linked list from a string](https://www.codewars.com/kata/582c5382f000e535100001a7)\
  \ if you enjoyed this Kata.\n\n## Preloaded\n\nPreloaded for you is a class, struct\
  \ or derived data type `Node` (depending on the language) used to construct linked\
  \ lists in this Kata:\n\n```python\nclass Node():\n    def __init__(self, data,\
  \ next = None):\n        self.data = data\n        self.next = next\n```\n\n~~~if:objc\n\
  *NOTE: In Objective-C, the* `Node` *struct is placed on top of your main solution\
  \ because there is a \"double-import\" bug in the Preloaded section at the time\
  \ of writing (which cannot be fixed on my end).  Attempts to modify it (e.g. to\
  \ cheat the tests in some way) will likely result in a test crash so it is not recommended\
  \ for you to modify that section ;)*\n~~~\n\n~~~if:c\n*NOTE: In C, the* `Node` *struct\
  \ is placed on top of your main solution (and the [Sample] Test Cases) because the\
  \ compiler complains about not recognizing the* `Node` *datatype even after adding\
  \ it to the Preloaded section.  Attempts to modify it (e.g. to cheat the tests in\
  \ some way) will likely result in a test crash so it is not recommended for you\
  \ to modify that section ;)*\n~~~\n\nIf you are attempting this Kata in NASM then\
  \ note that the code example shown directly above may not be relevant; please refer\
  \ to the Sample Tests (written in C) for the exact definition of the `Node` structure.\n\
  \n## Prerequisites\n\nThis Kata assumes that you are already familiar with the idea\
  \ of a linked list.  If you do not know what that is, you may want to read up on\
  \ [this article on Wikipedia](https://en.wikipedia.org/wiki/Linked_list).  Specifically,\
  \ the linked lists this Kata is referring to are **singly linked lists**, where\
  \ the value of a specific node is stored in its `data`/`$data`/`Data` property,\
  \ the reference to the next node is stored in its `next`/`$next`/`Next`/`next_node`\
  \ property and the terminator for a list is `null`/`NULL`/`None`/`nil`/`nullptr`/`null()`.\n\
  \n## Task\n\n*If you are attempting this Kata in NASM, the code examples shown below\
  \ may not be relevant at all - please refer to the Sample Tests (written in C) for\
  \ the exact requirements.*\n\nCreate a function `stringify` which accepts an argument\
  \ `list`/`$list` and returns a string representation of the list.  The string representation\
  \ of the list starts with the value of the current `Node`, specified by its `data`/`$data`/`Data`\
  \ property, followed by a whitespace character, an arrow and another whitespace\
  \ character (`\" -> \"`), followed by the rest of the list.  The end of the string\
  \ representation of a list must always end with `null`/`NULL`/`None`/`nil`/`nullptr`/`null()`\
  \ (all caps or all lowercase depending on the language you are undertaking this\
  \ Kata in).  For example, given the following list:\n\n```python\nNode(1, Node(2,\
  \ Node(3)))\n```\n\n... its string representation would be:\n\n```python\n\"1 ->\
  \ 2 -> 3 -> None\"\n```\n\nAnd given the following linked list:\n\n```python\nNode(0,\
  \ Node(1, Node(4, Node(9, Node(16)))))\n```\n\n... its string representation would\
  \ be:\n\n```python\n\"0 -> 1 -> 4 -> 9 -> 16 -> None\"\n```\n\nNote that `null`/`NULL`/`None`/`nil`/`nullptr`/`null()`\
  \ itself is also considered a valid linked list.  In that case, its string representation\
  \ would simply be `\"null\"`/`\"NULL\"`/`\"None\"`/`\"nil\"`/`\"nullptr\"`/`@\"\
  NULL\"`/`\"null()\"` (again, depending on the language).\n\nFor the simplicity of\
  \ this Kata, you may assume that any `Node` in this Kata may only contain **non-negative\
  \ integer** values.  For example, you will not encounter a `Node` whose `data`/`$data`/`Data`\
  \ property is `\"Hello World\"`.\n\nEnjoy, and don't forget to check out my other\
  \ Kata Series :D\n\n~~~if:fortran\n*NOTE: In Fortran, your returned string is* **not**\
  \ *permitted to contain any leading and/or trailing whitespace.*\n~~~"
"vc-preamble": "import Imports.AllImports\n\ndef stringify {α : Type} [ToString α]\
  \ : Node α → String :=\n  sorry\n\n\ndef make_linked_list {α : Type} : List α →\
  \ Node α :=\n  sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def splitOnStr (s : String) (sep : String) : List String :=\n \
  \ sorry\n"
"vc-theorems": "theorem stringify_matches_list_structure {α : Type} [ToString α] (items\
  \ : List α) :\n  let ll := make_linked_list items\n  let result := stringify ll\n\
  \  let parts := splitOnStr result \" -> \"\n  if items.isEmpty then\n    result\
  \ = \"None\"\n  else\n    parts.getLast! = \"None\" ∧\n    parts.length - 1 = items.length\
  \ ∧\n    parts.take items.length = items.map ToString.toString :=\n  sorry\n\n\n\
  theorem stringify_outputs_well_formed {α : Type} [ToString α] (items : List α) :\n\
  \  let ll := make_linked_list items\n  let result := stringify ll\n  let parts :=\
  \ splitOnStr result \" -> \"\n  result.endsWith \"None\" ∧\n  parts.all (·.trim\
  \ ≠ \"\") ∧\n  (if items.isEmpty then\n    parts.length = 1\n  else\n    parts.length\
  \ = items.length + 1) :=\n  sorry\n\n/--\ninfo: 'None'\n-/\n#guard_msgs in\n#eval\
  \ stringify None\n\n/--\ninfo: '1 -> None'\n-/\n#guard_msgs in\n#eval stringify\
  \ Node(1)\n\n/--\ninfo: '1 -> 2 -> 3 -> None'\n-/\n#guard_msgs in\n#eval stringify\
  \ Node(1, Node(2, Node(3)))\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
