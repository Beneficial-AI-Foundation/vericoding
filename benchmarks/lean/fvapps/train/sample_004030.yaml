"vc-description": "Write a function that merges two sorted arrays into a single one.\
  \ The arrays only contain integers. Also, the final outcome must be sorted and not\
  \ have any duplicate."
"vc-preamble": "import Imports.AllImports\n\ndef isSorted (l : List Int) : Prop :=\n\
  \  ∀ i j, i < j → j < l.length → l[i]! ≤ l[j]!\n\n\ndef noDuplicates (l : List Int)\
  \ : Prop :=\n  ∀ x i j, i < j → j < l.length → l[i]! = x → l[j]! ≠ x\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def mergeArrays (a b : List Int) : List Int := sorry\n\ntheorem\
  \ merge_arrays_is_sorted (a b : List Int) (h₁ : isSorted a) (h₂ : isSorted b) :\
  \ \n  isSorted (mergeArrays a b) := sorry\n"
"vc-theorems": "theorem merge_arrays_no_duplicates (a b : List Int) :\n  noDuplicates\
  \ (mergeArrays a b) := sorry\n\n\ntheorem merge_arrays_contains_all (a b : List\
  \ Int) :\n  ∀ x, (x ∈ a ∨ x ∈ b) ↔ x ∈ mergeArrays a b := sorry\n\n\ntheorem merge_arrays_length_bound\
  \ (a b : List Int) :\n  (mergeArrays a b).length ≤ a.length + b.length := sorry\n\
  \n\ntheorem merge_arrays_self_idempotent (a : List Int) (h : isSorted a) :\n  mergeArrays\
  \ a a = (a.toArray.qsort (· ≤ ·)).toList := sorry\n\n\ntheorem merge_arrays_empty_identity\
  \ (a : List Int) (h : isSorted a) :\n  mergeArrays a [] = (a.toArray.qsort (· ≤\
  \ ·)).toList ∧ \n  mergeArrays [] a = (a.toArray.qsort (· ≤ ·)).toList := sorry\n\
  \n/--\ninfo: [1, 2, 3, 4, 5, 6]\n-/\n#guard_msgs in\n#eval merge_arrays #[1, 3,\
  \ 5] #[2, 4, 6]\n\n/--\ninfo: [2, 4, 6, 8]\n-/\n#guard_msgs in\n#eval merge_arrays\
  \ #[2, 4, 8] #[2, 4, 6]\n\n/--\ninfo: [1, 2, 3]\n-/\n#guard_msgs in\n#eval merge_arrays\
  \ #[1, 2, 3] #[]\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
