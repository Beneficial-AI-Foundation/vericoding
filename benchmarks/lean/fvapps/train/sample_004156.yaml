"vc-description": "Write a function `generatePairs` that accepts an integer argument\
  \ `n` and generates an array containing the pairs of integers `[a, b]` that satisfy\
  \ the following conditions:\n```\n0 <= a <= b <= n\n```\n\nThe pairs should be sorted\
  \ by increasing values of `a` then increasing values of `b`.\n\nFor example, `generatePairs(2)`\
  \ should return\n```\n[ [0, 0], [0, 1], [0, 2], [1, 1], [1, 2], [2, 2] ]\n```"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def generate_pairs (n : Nat) : List (Nat × Nat) := sorry\n\ntheorem\
  \ generate_pairs_valid_bounds {n : Nat} :\n  ∀ p, p ∈ generate_pairs n → \n    (Prod.fst\
  \ p ≤ Prod.snd p) ∧ (Prod.snd p ≤ n) := sorry\n"
"vc-theorems": "theorem generate_pairs_unique {n : Nat} :\n  ∀ p₁ p₂, p₁ ∈ generate_pairs\
  \ n → p₂ ∈ generate_pairs n →\n    p₁ = p₂ ∨ p₁ ≠ p₂ := sorry\n\n\ntheorem generate_pairs_length\
  \ {n : Nat} :\n  (generate_pairs n).length = (n + 1) * (n + 2) / 2 := sorry\n\n\n\
  theorem generate_pairs_ordered {n : Nat} :\n  ∀ p₁ p₂, p₁ ∈ generate_pairs n → p₂\
  \ ∈ generate_pairs n →\n    (generate_pairs n).indexOf p₁ < (generate_pairs n).indexOf\
  \ p₂ →\n    p₁.1 < p₂.1 ∨ (p₁.1 = p₂.1 ∧ p₁.2 ≤ p₂.2) := sorry\n\n/--\ninfo: [[0,\
  \ 0], [0, 1], [0, 2], [1, 1], [1, 2], [2, 2]]\n-/\n#guard_msgs in\n#eval generate_pairs\
  \ 2\n\n/--\ninfo: [[0, 0]]\n-/\n#guard_msgs in\n#eval generate_pairs 0\n\n/--\n\
  info: [[0, 0], [0, 1], [1, 1]]\n-/\n#guard_msgs in\n#eval generate_pairs 1\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
