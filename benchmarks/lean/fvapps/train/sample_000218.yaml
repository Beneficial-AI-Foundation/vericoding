"vc-description": "A sequence X_1, X_2, ..., X_n is fibonacci-like if:\n\nn >= 3\n\
  X_i + X_{i+1} = X_{i+2} for all i + 2 <= n\n\nGiven a strictly increasing array A\
  \ of positive integers forming a sequence, find the length of the longest fibonacci-like\
  \ subsequence of A.  If one does not exist, return 0.\n(Recall that a subsequence\
  \ is derived from another sequence A by deleting any number of elements (including\
  \ none) from A, without changing the order of the remaining elements.  For example,\
  \ [3, 5, 8] is a subsequence of [3, 4, 5, 6, 7, 8].)\n \n\n\nExample 1:\nInput:\
  \ [1,2,3,4,5,6,7,8]\nOutput: 5\nExplanation:\nThe longest subsequence that is fibonacci-like:\
  \ [1,2,3,5,8].\n\nExample 2:\nInput: [1,3,7,11,12,14,18]\nOutput: 3\nExplanation:\n\
  The longest subsequence that is fibonacci-like:\n[1,11,12], [3,11,14] or [7,11,18].\n\
  \n \nNote:\n\n3 <= A.length <= 1000\n1 <= A[0] < A[1] < ... < A[A.length - 1] <=\
  \ 10^9\n(The time limit has been reduced by 50% for submissions in Java, C, and\
  \ C++.)"
"vc-preamble": "import Imports.AllImports\n\ndef List.isSorted (xs : List Nat) : Bool\
  \ :=\n  match xs with\n  | [] => true\n  | [_] => true\n  | x :: y :: xs => (x <\
  \ y) && isSorted (y::xs)\n\n\ndef listGet (xs : List Nat) (i : Nat) : Option Nat\
  \ :=\n  xs.get? i\n\n\ndef isFibonacciSeq (seq : List Nat) : Bool :=\n  if seq.length\
  \ ≤ 2 then true\n  else\n    let rec checkFib (i : Nat) (fuel : Nat) : Bool :=\n\
  \      if fuel = 0 then false\n      else if i ≥ seq.length then true\n      else\
  \ if i < 2 then checkFib (i+1) (fuel-1)\n      else match listGet seq i, listGet\
  \ seq (i-1), listGet seq (i-2) with\n        | some x, some y, some z => x == y\
  \ + z && checkFib (i+1) (fuel-1)\n        | _, _, _ => false\n    checkFib 0 seq.length\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def lenLongestFibSubseq (A : List Nat) : Nat :=\n  sorry\n"
"vc-theorems": "theorem result_bounds {A : List Nat} : \n  let result := lenLongestFibSubseq\
  \ A\n  result = 0 ∨ (result ≥ 3 ∧ result ≤ A.length) :=\n  sorry\n\n\ntheorem input_strictly_increasing\
  \ {A : List Nat} :\n  A.isSorted = true → ∀ i, i > 0 → i < A.length → \n  match\
  \ listGet A i, listGet A (i-1) with\n  | some x, some y => x > y\n  | _, _ => true\
  \ :=\n  sorry\n \n\ntheorem fibonacci_subsequence_exists {A : List Nat} :\n  let\
  \ result := lenLongestFibSubseq A\n  A.isSorted = true →\n  result ≥ 3 →\n  ∃ subseq\
  \ : List Nat,\n    subseq.length = result ∧ \n    isFibonacciSeq subseq = true ∧\n\
  \    ∀ x, x ∈ subseq → x ∈ A :=\n  sorry\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval\
  \ lenLongestFibSubseq [1, 2, 3, 4, 5, 6, 7, 8]\n\n/--\ninfo: 3\n-/\n#guard_msgs\
  \ in\n#eval lenLongestFibSubseq [1, 3, 7, 11, 12, 14, 18]\n\n/--\ninfo: 0\n-/\n\
  #guard_msgs in\n#eval lenLongestFibSubseq [1, 2, 4, 8]\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded"
