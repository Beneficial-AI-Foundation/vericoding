"vc-description": "Given an array of integers arr, a lucky integer is an integer which\
  \ has a frequency in the array equal to its value.\nReturn a lucky integer in the\
  \ array. If there are multiple lucky integers return the largest of them. If there\
  \ is no lucky integer return -1.\n \nExample 1:\nInput: arr = [2,2,3,4]\nOutput:\
  \ 2\nExplanation: The only lucky number in the array is 2 because frequency[2] ==\
  \ 2.\n\nExample 2:\nInput: arr = [1,2,2,3,3,3]\nOutput: 3\nExplanation: 1, 2 and\
  \ 3 are all lucky numbers, return the largest of them.\n\nExample 3:\nInput: arr\
  \ = [2,2,2,3,3]\nOutput: -1\nExplanation: There are no lucky numbers in the array.\n\
  \nExample 4:\nInput: arr = [5]\nOutput: -1\n\nExample 5:\nInput: arr = [7,7,7,7,7,7,7]\n\
  Output: 7\n\n \nConstraints:\n\n1 <= arr.length <= 500\n1 <= arr[i] <= 500"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def find_lucky (arr : List Nat) : Int := sorry\n\ntheorem find_lucky_lower_bound\
  \ (arr : List Nat) : \n  find_lucky arr ≥ -1 := sorry\n"
"vc-theorems": "theorem find_lucky_freq_match (arr : List Nat) :\n  find_lucky arr\
  \ ≠ -1 → \n  (arr.countP (· = (find_lucky arr).toNat)) = (find_lucky arr).toNat\
  \ := sorry \n\n\ntheorem find_lucky_is_max (arr : List Nat) (n : Nat) :\n  n ∈ arr\
  \ → \n  (arr.countP (· = n)) = n →\n  n ≤ (find_lucky arr).toNat := sorry\n\n/--\n\
  info: 2\n-/\n#guard_msgs in\n#eval find_lucky [2, 2, 3, 4]\n\n/--\ninfo: 3\n-/\n\
  #guard_msgs in\n#eval find_lucky [1, 2, 2, 3, 3, 3]\n\n/--\ninfo: -1\n-/\n#guard_msgs\
  \ in\n#eval find_lucky [2, 2, 2, 3, 3]\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible"
