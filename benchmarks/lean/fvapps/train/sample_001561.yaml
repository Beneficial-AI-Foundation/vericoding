"vc-description": "My little sister came back home from school with the following\
  \ task:\ngiven a squared sheet of paper she has to cut it in pieces\nwhich, when\
  \ assembled, give squares the sides of which form\nan increasing sequence of numbers.\n\
  At the beginning it was lot of fun but little by little we were tired of seeing\
  \ the pile of torn paper.\nSo we decided to write a program that could help us and\
  \ protects trees.\n\n## Task\n\nGiven a positive integral number n, return a **strictly\
  \ increasing** sequence (list/array/string depending on the language) of numbers,\
  \ so that the sum of the squares is equal to n².\n\nIf there are multiple solutions\
  \ (and there will be), return as far as possible the result with the largest possible\
  \ values:\n\n## Examples\n\n`decompose(11)` must return `[1,2,4,10]`. Note that\
  \ there are actually two ways to decompose 11²,\n11² = 121 = 1 + 4 + 16 + 100 =\
  \ 1² + 2² + 4² + 10² but don't return `[2,6,9]`, since 9 is smaller than 10.\n\n\
  For `decompose(50)` don't return `[1, 1, 4, 9, 49]` but `[1, 3, 5, 8, 49]` since\
  \ `[1, 1, 4, 9, 49]`\ndoesn't form a strictly increasing sequence.\n\n## Note\n\
  Neither `[n]` nor `[1,1,1,…,1]` are valid solutions. If no valid solution exists,\
  \ return `nil`, `null`, `Nothing`, `None` (depending on the language) or `\"[]\"\
  ` (C) ,`{}` (C++), `[]` (Swift, Go).\n\nThe function \"decompose\" will take a positive\
  \ integer n \nand return the decomposition of N = n² as:\n\n- [x1 ... xk]\nor\n\
  - \"x1 ... xk\"\nor\n- Just [x1 ... xk]\nor\n- Some [x1 ... xk]\nor\n- {x1 ... xk}\n\
  or\n- \"[x1,x2, ... ,xk]\"\n\ndepending on the language (see \"Sample tests\")\n\
  \n# Note for Bash\n```\ndecompose 50 returns \"1,3,5,8,49\"\ndecompose 4  returns\
  \ \"Nothing\"\n```\n# Hint\n\nVery often `xk` will be `n-1`."
"vc-preamble": "import Imports.AllImports\n\ndef decompose (n : Nat) : Option (List\
  \ Nat) := sorry\n\ndef list_sum : List Nat → Nat \n  | [] => 0\n  | (h::t) => h\
  \ + list_sum t\n\n\ndef list_sorted : List Nat → Bool\n  | [] => true\n  | [_] =>\
  \ true\n  | (a::b::rest) => a ≤ b && list_sorted (b::rest)\n\n\ndef list_all (l\
  \ : List Nat) (p : Nat → Bool) : Bool := \n  List.all l p\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def square (n : Nat) : Nat := n * n\n\ntheorem decompose_valid\
  \ (n : Nat) (result : List Nat) :\n  decompose n = some result →\n  (list_sum (List.map\
  \ square result) = n * n) ∧\n  list_sorted result = true ∧\n  list_all result (λ\
  \ x => x > 0) = true ∧\n  list_all result (λ x => x < n) = true := sorry\n"
"vc-theorems": "theorem decompose_2_impossible :\n  decompose 2 = none := sorry\n\n\
  \ntheorem decompose_3_impossible :\n  decompose 3 = none := sorry\n\n/--\ninfo:\
  \ [1, 2, 4, 10]\n-/\n#guard_msgs in\n#eval decompose 11\n\n/--\ninfo: [1, 3, 5,\
  \ 8, 49]\n-/\n#guard_msgs in\n#eval decompose 50\n\n/--\ninfo: None\n-/\n#guard_msgs\
  \ in\n#eval decompose 4\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
