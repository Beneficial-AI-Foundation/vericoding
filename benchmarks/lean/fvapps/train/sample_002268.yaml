"vc-description": "Recently you have bought a snow walking robot and brought it home.\
  \ Suppose your home is a cell $(0, 0)$ on an infinite grid.\n\nYou also have the\
  \ sequence of instructions of this robot. It is written as the string $s$ consisting\
  \ of characters 'L', 'R', 'U' and 'D'. If the robot is in the cell $(x, y)$ right\
  \ now, he can move to one of the adjacent cells (depending on the current instruction).\
  \  If the current instruction is 'L', then the robot can move to the left to $(x\
  \ - 1, y)$;  if the current instruction is 'R', then the robot can move to the right\
  \ to $(x + 1, y)$;  if the current instruction is 'U', then the robot can move to\
  \ the top to $(x, y + 1)$;  if the current instruction is 'D', then the robot can\
  \ move to the bottom to $(x, y - 1)$. \n\nYou've noticed the warning on the last\
  \ page of the manual: if the robot visits some cell (except $(0, 0)$) twice then\
  \ it breaks.\n\nSo the sequence of instructions is valid if the robot starts in\
  \ the cell $(0, 0)$, performs the given instructions, visits no cell other than\
  \ $(0, 0)$ two or more times and ends the path in the cell $(0, 0)$. Also cell $(0,\
  \ 0)$ should be visited at most two times: at the beginning and at the end (if the\
  \ path is empty then it is visited only once). For example, the following sequences\
  \ of instructions are considered valid: \"UD\", \"RL\", \"UUURULLDDDDLDDRRUU\",\
  \ and the following are considered invalid: \"U\" (the endpoint is not $(0, 0)$)\
  \ and \"UUDD\" (the cell $(0, 1)$ is visited twice).\n\nThe initial sequence of\
  \ instructions, however, might be not valid. You don't want your robot to break\
  \ so you decided to reprogram it in the following way: you will remove some (possibly,\
  \ all or none) instructions from the initial sequence of instructions, then rearrange\
  \ the remaining instructions as you wish and turn on your robot to move. \n\nYour\
  \ task is to remove as few instructions from the initial sequence as possible and\
  \ rearrange the remaining ones so that the sequence is valid. Report the valid sequence\
  \ of the maximum length you can obtain.\n\nNote that you can choose any order of\
  \ remaining instructions (you don't need to minimize the number of swaps or any\
  \ other similar metric).\n\nYou have to answer $q$ independent test cases.\n\n\n\
  -----Input-----\n\nThe first line of the input contains one integer $q$ ($1 \\le\
  \ q \\le 2 \\cdot 10^4$) — the number of test cases.\n\nThe next $q$ lines contain\
  \ test cases. The $i$-th test case is given as the string $s$ consisting of at least\
  \ $1$ and no more than $10^5$ characters 'L', 'R', 'U' and 'D' — the initial sequence\
  \ of instructions.\n\nIt is guaranteed that the sum of $|s|$ (where $|s|$ is the\
  \ length of $s$) does not exceed $10^5$ over all test cases ($\\sum |s| \\le 10^5$).\n\
  \n\n-----Output-----\n\nFor each test case print the answer on it. In the first\
  \ line print the maximum number of remaining instructions. In the second line print\
  \ the valid sequence of remaining instructions $t$ the robot has to perform. The\
  \ moves are performed from left to right in the order of the printed sequence. If\
  \ there are several answers, you can print any. If the answer is $0$, you are allowed\
  \ to print an empty line (but you can don't print it).\n\n\n-----Example-----\n\
  Input\n6\nLRU\nDURLDRUDRULRDURDDL\nLRUDDLRUDRUL\nLLLLRRRR\nURDUR\nLLL\n\nOutput\n\
  2\nLR\n14\nRUURDDDDLLLUUR\n12\nULDDDRRRUULL\n2\nLR\n2\nUD\n0\n\n\n\n\n-----Note-----\n\
  \nThere are only two possible answers in the first test case: \"LR\" and \"RL\"\
  .\n\nThe picture corresponding to the second test case: [Image] Note that the direction\
  \ of traverse does not matter \n\nAnother correct answer to the third test case:\
  \ \"URDDLLLUURDR\"."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def solve (s : String) : Nat × String := sorry\n\ntheorem solve_output_structure\
  \ (s : String) : \n  let result := solve s\n  (result.1 = result.2.length) ∧ \n\
  \  (∀ c, c ∈ result.2.data → c = 'L' ∨ c = 'R' ∨ c = 'U' ∨ c = 'D') := sorry\n"
"vc-theorems": "theorem solve_output_balanced (s : String) :\n  let result := solve\
  \ s\n  let path := result.2\n  (path.data.count 'L' = path.data.count 'R') ∧\n \
  \ (path.data.count 'U' = path.data.count 'D') := sorry\n\n\ntheorem solve_output_length_bounds\
  \ (s : String) :\n  let result := solve s\n  let l := s.data.count 'L'\n  let r\
  \ := s.data.count 'R'\n  let u := s.data.count 'U'\n  let d := s.data.count 'D'\n\
  \  (result.1 ≤ 2 * min l r + 2 * min u d) ∧\n  (result.1 % 2 = 0) := sorry\n\n\n\
  theorem solve_empty_conditions (s : String) :\n  let result := solve s\n  let l\
  \ := s.data.count 'L'\n  let r := s.data.count 'R'\n  let u := s.data.count 'U'\n\
  \  let d := s.data.count 'D'\n  (min l r = 0 ∧ min u d = 0 → result = (0, \"\"))\
  \ ∧\n  (¬(min l r = 0 ∧ min u d = 0) → result.1 > 0) := sorry\n\n/--\ninfo: (2,\
  \ 'LR')\n-/\n#guard_msgs in\n#eval solve \"LRU\"\n\n/--\ninfo: (0, '')\n-/\n#guard_msgs\
  \ in\n#eval solve \"LLL\"\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
