"vc-description": "You are at the top left cell $(1, 1)$ of an $n \\times m$ labyrinth.\
  \ Your goal is to get to the bottom right cell $(n, m)$. You can only move right\
  \ or down, one cell per step. Moving right from a cell $(x, y)$ takes you to the\
  \ cell $(x, y + 1)$, while moving down takes you to the cell $(x + 1, y)$.\n\nSome\
  \ cells of the labyrinth contain rocks. When you move to a cell with rock, the rock\
  \ is pushed to the next cell in the direction you're moving. If the next cell contains\
  \ a rock, it gets pushed further, and so on.\n\nThe labyrinth is surrounded by impenetrable\
  \ walls, thus any move that would put you or any rock outside of the labyrinth is\
  \ illegal.\n\nCount the number of different legal paths you can take from the start\
  \ to the goal modulo $10^9 + 7$. Two paths are considered different if there is\
  \ at least one cell that is visited in one path, but not visited in the other.\n\
  \n\n-----Input-----\n\nThe first line contains two integers $n, m$ — dimensions\
  \ of the labyrinth ($1 \\leq n, m \\leq 2000$).\n\nNext $n$ lines describe the labyrinth.\
  \ Each of these lines contains $m$ characters. The $j$-th character of the $i$-th\
  \ of these lines is equal to \"R\" if the cell $(i, j)$ contains a rock, or \".\"\
  \ if the cell $(i, j)$ is empty.\n\nIt is guaranteed that the starting cell $(1,\
  \ 1)$ is empty.\n\n\n-----Output-----\n\nPrint a single integer — the number of\
  \ different legal paths from $(1, 1)$ to $(n, m)$ modulo $10^9 + 7$.\n\n\n-----Examples-----\n\
  Input\n1 1\n.\n\nOutput\n1\n\nInput\n2 3\n...\n..R\n\nOutput\n0\n\nInput\n4 4\n\
  ...R\n.RR.\n.RR.\nR...\n\nOutput\n4\n\n\n\n-----Note-----\n\nIn the first sample\
  \ case we can't (and don't have to) move, hence the only path consists of a single\
  \ cell $(1, 1)$.\n\nIn the second sample case the goal is blocked and is unreachable.\n\
  \nIllustrations for the third sample case can be found here: https://assets.codeforces.com/rounds/1225/index.html"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def count_paths (n m : Nat) (grid : Grid) : Nat :=\n  sorry\n"
"vc-theorems": "theorem count_paths_dimensions {n m : Nat} {grid : Grid} \n  (h1 :\
  \ grid.length = n)\n  (h2 : ∀ (row : List Char), row ∈ grid → row.length = m) :\n\
  \  let result := count_paths n m grid\n  0 ≤ result ∧ result ≤ 10^9+7 :=\nsorry\n\
  \n\ntheorem count_paths_blocked_start_end {n m : Nat} {grid : Grid}\n  (h1 : grid.length\
  \ = n) \n  (h2 : ∀ (row : List Char), row ∈ grid → row.length = m)\n  (h3 : (grid.get!\
  \ 0).get! 0 = 'R' ∨ (grid.get! (n-1)).get! (m-1) = 'R') :\n  count_paths n m grid\
  \ = 0 :=\nsorry\n\n\ntheorem count_paths_single_row {n : Nat} \n  (grid : Grid)\n\
  \  (h1 : grid.length = 1)\n  (h2 : (grid.get! 0).length = n)\n  (h3 : ∀ i < n, (grid.get!\
  \ 0).get! i = '.') :\n  count_paths 1 n grid = 1 :=\nsorry\n\n\ntheorem count_paths_single_col\
  \ {n : Nat}\n  (grid : Grid) \n  (h1 : grid.length = n)\n  (h2 : ∀ (row : List Char),\
  \ row ∈ grid → row.length = 1)\n  (h3 : ∀ i < n, (grid.get! i).get! 0 = '.') :\n\
  \  count_paths n 1 grid = 1 :=\nsorry\n\n\ntheorem count_paths_modulo {n m : Nat}\
  \ {grid : Grid}\n  (h1 : grid.length = n)\n  (h2 : ∀ (row : List Char), row ∈ grid\
  \ → row.length = m) :\n  let result := count_paths n m grid\n  0 ≤ result ∧ result\
  \ < 10^9+7 :=\nsorry\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval count_paths 1 1\
  \ [\".\"]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval count_paths 2 3 [\"...\", \"\
  ..R\"]\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval count_paths 4 4 [\"...R\", \"\
  .RR.\", \".RR.\", \"R...\"]\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
