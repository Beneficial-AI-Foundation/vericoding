"vc-description": "In the spirit of the holidays, Saitama has given Genos two grid\
  \ paths of length n (a weird gift even by Saitama's standards). A grid path is an\
  \ ordered sequence of neighbouring squares in an infinite grid. Two squares are\
  \ neighbouring if they share a side.\n\nOne example of a grid path is (0, 0) → (0,\
  \ 1) → (0, 2) → (1, 2) → (1, 1) → (0, 1) → ( - 1, 1). Note that squares in this\
  \ sequence might be repeated, i.e. path has self intersections.\n\nMovement within\
  \ a grid path is restricted to adjacent squares within the sequence. That is, from\
  \ the i-th square, one can only move to the (i - 1)-th or (i + 1)-th squares of\
  \ this path. Note that there is only a single valid move from the first and last\
  \ squares of a grid path. Also note, that even if there is some j-th square of the\
  \ path that coincides with the i-th square, only moves to (i - 1)-th and (i + 1)-th\
  \ squares are available. For example, from the second square in the above sequence,\
  \ one can only move to either the first or third squares.\n\nTo ensure that movement\
  \ is not ambiguous, the two grid paths will not have an alternating sequence of\
  \ three squares. For example, a contiguous subsequence (0, 0) → (0, 1) → (0, 0)\
  \ cannot occur in a valid grid path.\n\nOne marble is placed on the first square\
  \ of each grid path. Genos wants to get both marbles to the last square of each\
  \ grid path. However, there is a catch. Whenever he moves one marble, the other\
  \ marble will copy its movement if possible. For instance, if one marble moves east,\
  \ then the other marble will try and move east as well. By try, we mean if moving\
  \ east is a valid move, then the marble will move east.\n\nMoving north increases\
  \ the second coordinate by 1, while moving south decreases it by 1. Similarly, moving\
  \ east increases first coordinate by 1, while moving west decreases it.\n\nGiven\
  \ these two valid grid paths, Genos wants to know if it is possible to move both\
  \ marbles to the ends of their respective paths. That is, if it is possible to move\
  \ the marbles such that both marbles rest on the last square of their respective\
  \ paths.\n\n\n-----Input-----\n\nThe first line of the input contains a single integer\
  \ n (2 ≤ n ≤ 1 000 000) — the length of the paths.\n\nThe second line of the input\
  \ contains a string consisting of n - 1 characters (each of which is either 'N',\
  \ 'E', 'S', or 'W') — the first grid path. The characters can be thought of as the\
  \ sequence of moves needed to traverse the grid path. For example, the example path\
  \ in the problem statement can be expressed by the string \"NNESWW\".\n\nThe third\
  \ line of the input contains a string of n - 1 characters (each of which is either\
  \ 'N', 'E', 'S', or 'W') — the second grid path.\n\n\n-----Output-----\n\nPrint\
  \ \"YES\" (without quotes) if it is possible for both marbles to be at the end position\
  \ at the same time. Print \"NO\" (without quotes) otherwise. In both cases, the\
  \ answer is case-insensitive.\n\n\n-----Examples-----\nInput\n7\nNNESWW\nSWSWSW\n\
  \nOutput\nYES\n\nInput\n3\nNN\nSS\n\nOutput\nNO\n\n\n\n-----Note-----\n\nIn the\
  \ first sample, the first grid path is the one described in the statement. Moreover,\
  \ the following sequence of moves will get both marbles to the end: NNESWWSWSW.\n\
  \nIn the second sample, no sequence of moves can get both marbles to the end."
"vc-preamble": "import Imports.AllImports\n\ndef flipDir : Direction → Direction \n\
  \  | Direction.N => Direction.S\n  | Direction.S => Direction.N\n  | Direction.E\
  \ => Direction.W\n  | Direction.W => Direction.E\n\n\ndef flipPath (path : List\
  \ Direction) : List Direction :=\n  path.map flipDir\n\n\ndef opposite (d : Direction)\
  \ : Direction :=\n  flipDir d\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def solvable (p1 p2 : List Direction) : Bool :=\n  sorry\n"
"vc-theorems": "theorem solvable_with_self_inverse (path : List Direction) :\n  ¬(solvable\
  \ path (flipPath path)) := by sorry\n\n\ntheorem solvable_symmetry (path : List\
  \ Direction) :\n  let rev := (path.reverse.map opposite)\n  solvable path rev =\
  \ solvable rev path := by sorry\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval solvable\
  \ \"NNESWW\" \"SWSWSW\"\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval solvable\
  \ \"NN\" \"SS\"\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval solvable \"ES\" \"\
  NW\"\n"
"vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded"
