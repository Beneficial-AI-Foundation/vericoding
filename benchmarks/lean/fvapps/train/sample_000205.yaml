"vc-description": "There are N piles of stones arranged in a row.  The i-th pile has\
  \ stones[i] stones.\nA move consists of merging exactly K consecutive piles into\
  \ one pile, and the cost of this move is equal to the total number of stones in\
  \ these K piles.\nFind the minimum cost to merge all piles of stones into one pile. \
  \ If it is impossible, return -1.\n \n\nExample 1:\nInput: stones = [3,2,4,1], K\
  \ = 2\nOutput: 20\nExplanation: \nWe start with [3, 2, 4, 1].\nWe merge [3, 2] for\
  \ a cost of 5, and we are left with [5, 4, 1].\nWe merge [4, 1] for a cost of 5,\
  \ and we are left with [5, 5].\nWe merge [5, 5] for a cost of 10, and we are left\
  \ with [10].\nThe total cost was 20, and this is the minimum possible.\n\n\nExample\
  \ 2:\nInput: stones = [3,2,4,1], K = 3\nOutput: -1\nExplanation: After any merge\
  \ operation, there are 2 piles left, and we can't merge anymore.  So the task is\
  \ impossible.\n\n\nExample 3:\nInput: stones = [3,5,1,2,6], K = 3\nOutput: 25\n\
  Explanation: \nWe start with [3, 5, 1, 2, 6].\nWe merge [5, 1, 2] for a cost of\
  \ 8, and we are left with [3, 8, 6].\nWe merge [3, 8, 6] for a cost of 17, and we\
  \ are left with [17].\nThe total cost was 25, and this is the minimum possible.\n\
  \n \nNote:\n\n1 <= stones.length <= 30\n2 <= K <= 30\n1 <= stones[i] <= 100"
"vc-preamble": "import Imports.AllImports\n\ndef List.sum (xs : List Nat) : Nat :=\n\
  \  match xs with\n  | [] => 0\n  | x::xs => x + List.sum xs\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def merge_stones (stones : List Nat) (k : Nat) : Int :=\n  sorry\n"
"vc-theorems": "theorem merge_stones_impossible (stones : List Nat) (k : Nat)\n  (h\
  \ : (stones.length - 1) % (k - 1) ≠ 0) :\n  merge_stones stones k = -1 :=\n  sorry\n\
  \n\ntheorem merge_stones_possible_nonneg (stones : List Nat) (k : Nat) \n  (h :\
  \ (stones.length - 1) % (k - 1) = 0) :\n  merge_stones stones k ≥ 0 :=\n  sorry\n\
  \n\ntheorem merge_stones_bounded (stones : List Nat) (k : Nat)\n  (h : (stones.length\
  \ - 1) % (k - 1) = 0) :\n  ∃ bound : Nat, merge_stones stones k ≤ bound :=\n  sorry\n\
  \n\ntheorem merge_stones_single_stone (k : Nat) :\n  merge_stones [1] k = 0 :=\n\
  \  sorry\n\n\ntheorem merge_stones_two_stones :\n  merge_stones [1,1] 2 = 2 :=\n\
  \  sorry\n\n/--\ninfo: 20\n-/\n#guard_msgs in\n#eval merge_stones [3, 2, 4, 1] 2\n\
  \n/--\ninfo: -1\n-/\n#guard_msgs in\n#eval merge_stones [3, 2, 4, 1] 3\n\n/--\n\
  info: 25\n-/\n#guard_msgs in\n#eval merge_stones [3, 5, 1, 2, 6] 3\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
