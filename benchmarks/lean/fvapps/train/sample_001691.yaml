"vc-description": "# Task\n\nYou are given a `chessBoard`, a 2d integer array that\
  \ contains only `0` or `1`. `0` represents a chess piece and `1` represents a empty\
  \ grid. It's always square shape.\n\nYour task is to count the number of squares\
  \ made of empty grids.\n\nThe smallest size of the square is `2 x 2`. The biggest\
  \ size of the square is `n x n`, where `n` is the size of chess board. \n\nA square\
  \ can overlap the part of other squares. For example:\n\nIf\n\n```\nchessBoard=[\n\
  \  [1,1,1],\n  [1,1,1],\n  [1,1,1]\n]\n```\n\n...there are four 2 x 2 squares in\
  \ the chess board:\n\n```\n[1,1, ]  [ ,1,1]  [ , , ]  [ , , ]\n[1,1, ]  [ ,1,1]\
  \  [1,1, ]  [ ,1,1]\n[ , , ]  [ , , ]  [1,1, ]  [ ,1,1]\n```\n\nAnd one 3 x 3 square:\n\
  ```\n[1,1,1]\n[1,1,1]\n[1,1,1]\n```\n\nYour output should be an object/dict. Each\
  \ item in it should be: `size:number`, where size is the square's size, and number\
  \ is the number of squares. \n\nFor example, if there are four `2 x 2` squares and\
  \ one `3 x 3` square in the chess board, the output should be: `{2:4,3:1}` (or any\
  \ equivalent hash structure in your language). The order of items is not important,\
  \ `{3:1,2:4}` is also a valid output.\n\nIf there is no square in the chess board,\
  \ just return `{}`.\n\n# Note\n\n```if:javascript\n- `2 <= chessBoard.length <=\
  \ 400`\n```\n```if:python\n- `2 <= chessBoard.length <= 120`\n```\n```if:ruby\n\
  - `2 <= chessBoard.length <= 130`\n```\n```if:java\n- `2 <= chessBoard.length <=\
  \ 250`\n```\n```if:haskell\n- `2 <= chessBoard.length <= 120`\n```\n```if:csharp\n\
  - `2 <= chessBoard.Length <= 220`\n```\n\n- `5` fixed testcases\n\n- `100` random\
  \ testcases, testing for correctness of solution\n\n- `100` random testcases, testing\
  \ for performance of code\n\n- All inputs are valid.\n\n- Pay attention to code\
  \ performance.\n\n- If my reference solution gives the wrong result in the random\
  \ tests, please let me know(post an issue). \n\n# Example\n\nFor \n```\nchessBoard\
  \ = [\n  [1,1],\n  [1,1]\n]\n```\n\nthe output should be `{2:1}`.\n\n\nFor \n```\n\
  chessBoard = [\n  [0,1],\n  [1,1]\n]\n```\n\nthe output should be `{}`.\n\nFor \n\
  ```\nchessBoard = [\n  [1,1,1],\n  [1,1,1],\n  [1,1,1]\n]\n```\n\nthe output should\
  \ be `{2:4,3:1}`.\n\nFor \n```\nchessBoard = [\n  [1,1,1],\n  [1,0,1],\n  [1,1,1]\n\
  ]\n```\n\nthe output should be `{}`."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def count (board : List (List Int)) : List SquareCount := sorry\n\
  \ntheorem count_square_ones_board \n  {n : Nat} (h : n ≥ 2)\n  (board : List (List\
  \ Int))\n  (h_board : board.length = n ∧ ∀ row ∈ board, row.length = n)\n  (h_ones\
  \ : ∀ i j, i < n → j < n → board[i]![j]! = 1) :\n  ∀ size, 2 ≤ size → size ≤ n →\
  \ \n    let result := count board\n    ∃ sc ∈ result, sc.size = size ∧ sc.count\
  \ = (n - size + 1) ^ 2 := sorry\n"
"vc-theorems": "theorem count_preserves_input\n  {rows cols : Nat} (h : rows ≥ 1 ∧\
  \ cols ≥ 1)\n  (board : List (List Int)) \n  (h_board : board.length = rows ∧ ∀\
  \ row ∈ board, row.length = cols) :\n  let board' := board\n  count board = count\
  \ board' ∧ board = board' := sorry\n\n/--\ninfo: {2: 1}\n-/\n#guard_msgs in\n#eval\
  \ count [[1, 1], [1, 1]]\n\n/--\ninfo: {2: 4, 3: 1}\n-/\n#guard_msgs in\n#eval count\
  \ [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\n\n/--\ninfo: {}\n-/\n#guard_msgs in\n#eval\
  \ count [[1, 1, 1], [1, 0, 1], [1, 1, 1]]\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
