"vc-description": "If you like Taco Bell, you will be familiar with their signature\
  \ doritos locos taco. They're very good.\n\n\nWhy can't everything be a taco? We're\
  \ going to attempt that here, turning every word we find into the taco bell recipe\
  \ with each ingredient.\n\n\nWe want to input a word as a string, and return a list\
  \ representing that word as a taco.\n\n***Key***\n\nall vowels (except 'y') = beef\n\
  \nt = tomato\n\nl = lettuce\n\nc = cheese\n\ng = guacamole\n\ns = salsa\n\n  \n\
  ***NOTE***    \nWe do not care about case here. 'S' is therefore equivalent to 's'\
  \ in our taco.\n  \nIgnore all other letters; we don't want our taco uneccesarily\
  \ clustered or else it will be too difficult to eat.\n\nNote that no matter what\
  \ ingredients are passed, our taco will always have a shell."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def tacofy (word : String) : List String := sorry\n\ndef VALID_INGREDIENTS\
  \ : List String := [\"tomato\", \"lettuce\", \"cheese\", \"guacamole\", \"salsa\"\
  , \"beef\"]\n"
"vc-theorems": "theorem tacofy_always_has_shells (word : String) :\n  let result :=\
  \ tacofy word\n  result.head? = some \"shell\" ∧ \n  result.getLast? = some \"shell\"\
  \ ∧\n  result.length ≥ 2 := sorry \n\n\ntheorem tacofy_valid_ingredients (word :\
  \ String) :\n  let result := tacofy word\n  let middle := result.drop 1 |>.dropLast\n\
  \  ∀ ing ∈ middle, ing ∈ VALID_INGREDIENTS := sorry\n\n/--\ninfo: ['shell', 'shell']\n\
  -/\n#guard_msgs in\n#eval tacofy \"\"\n\n/--\ninfo: ['shell', 'beef', 'guacamole',\
  \ 'lettuce', 'shell']\n-/\n#guard_msgs in\n#eval tacofy \"ogl\"\n\n/--\ninfo: ['shell',\
  \ 'beef', 'tomato', 'lettuce', 'cheese', 'guacamole', 'salsa', 'shell']\n-/\n#guard_msgs\
  \ in\n#eval tacofy \"abtlcgs\"\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
