"vc-description": "You have an array arr of length n where arr[i] = (2 * i) + 1 for\
  \ all valid values of i (i.e. 0 <= i < n).\nIn one operation, you can select two\
  \ indices x and y where 0 <= x, y < n and subtract 1 from arr[x] and add 1 to arr[y] (i.e.\
  \ perform arr[x] -=1 and arr[y] += 1). The goal is to make all the elements of the\
  \ array equal. It is guaranteed that all the elements of the array can be made equal\
  \ using some operations.\nGiven an integer n, the length of the array. Return the\
  \ minimum number of operations needed to make all the elements of arr equal.\n \n\
  Example 1:\nInput: n = 3\nOutput: 2\nExplanation: arr = [1, 3, 5]\nFirst operation\
  \ choose x = 2 and y = 0, this leads arr to be [2, 3, 4]\nIn the second operation\
  \ choose x = 2 and y = 0 again, thus arr = [3, 3, 3].\n\nExample 2:\nInput: n =\
  \ 6\nOutput: 9\n\n \nConstraints:\n\n1 <= n <= 10^4"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def minOperations (n : Nat) : Nat :=\n  sorry\n"
"vc-theorems": "theorem minOperations_nonnegative (n : Nat) :\n  minOperations n ≥\
  \ 0 := sorry\n\n\ntheorem minOperations_one_zero :\n  minOperations 1 = 0 := sorry\
  \  \n\n\ntheorem minOperations_positive (n : Nat) :\n  n > 1 → minOperations n >\
  \ 0 := sorry\n\n\ntheorem minOperations_upper_bound (n : Nat) :\n  minOperations\
  \ n ≤ n * n := sorry\n\n\ntheorem minOperations_approximates_nsquare_div_4 (n :\
  \ Nat) (d : Float) :\n  d = Float.abs (Float.ofNat (minOperations n) - Float.ofNat\
  \ (n * n) / 4) →\n  d < 1 := sorry\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval min_operations\
  \ 3\n\n/--\ninfo: 9\n-/\n#guard_msgs in\n#eval min_operations 6\n\n/--\ninfo: 0\n\
  -/\n#guard_msgs in\n#eval min_operations 1\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded"
