"vc-description": "Recently, Duff has been practicing weight lifting. As a hard practice,\
  \ Malek gave her a task. He gave her a sequence of weights. Weight of i-th of them\
  \ is 2^{w}_{i} pounds. In each step, Duff can lift some of the remaining weights\
  \ and throw them away. She does this until there's no more weight left. Malek asked\
  \ her to minimize the number of steps. [Image] \n\nDuff is a competitive programming\
  \ fan. That's why in each step, she can only lift and throw away a sequence of weights\
  \ 2^{a}_1, ..., 2^{a}_{k} if and only if there exists a non-negative integer x such\
  \ that 2^{a}_1 + 2^{a}_2 + ... + 2^{a}_{k} = 2^{x}, i. e. the sum of those numbers\
  \ is a power of two.\n\nDuff is a competitive programming fan, but not a programmer.\
  \ That's why she asked for your help. Help her minimize the number of steps. \n\n\
  \n-----Input-----\n\nThe first line of input contains integer n (1 ≤ n ≤ 10^6),\
  \ the number of weights.\n\nThe second line contains n integers w_1, ..., w_{n}\
  \ separated by spaces (0 ≤ w_{i} ≤ 10^6 for each 1 ≤ i ≤ n), the powers of two forming\
  \ the weights values.\n\n\n-----Output-----\n\nPrint the minimum number of steps\
  \ in a single line.\n\n\n-----Examples-----\nInput\n5\n1 1 2 3 3\n\nOutput\n2\n\n\
  Input\n4\n0 1 2 3\n\nOutput\n4\n\n\n\n-----Note-----\n\nIn the first sample case:\
  \ One optimal way would be to throw away the first three in the first step and the\
  \ rest in the second step. Also, it's not possible to do it in one step because\
  \ their sum is not a power of two.\n\nIn the second sample case: The only optimal\
  \ way is to throw away one weight in each step. It's not possible to do it in less\
  \ than 4 steps because there's no subset of weights with more than one weight and\
  \ sum equal to a power of two."
"vc-preamble": "import Imports.AllImports\n\ndef min_steps_to_lift (n : Nat) (weights\
  \ : List Nat) : Nat := sorry\n\ntheorem min_steps_nonneg (n : Nat) (weights : List\
  \ Nat) : \n  min_steps_to_lift n weights ≥ 0 := sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def count_odd_frequencies (weights : List Nat) : Nat :=\n  let\
  \ freqs := weights.foldl (fun acc x => \n    match acc.find? (fun p => p.1 = x)\
  \ with\n    | some p => acc.erase p ++ [(p.1, p.2 + 1)]\n    | none => acc ++ [(x,\
  \ 1)]\n    ) []\n  (freqs.filter (fun p => p.2 % 2 = 1)).length\n"
"vc-theorems": "theorem min_steps_upper_bound (n : Nat) (weights : List Nat) :\n \
  \ min_steps_to_lift n weights ≤ n := sorry\n\n\ntheorem min_steps_odd_freq_bound\
  \ (n : Nat) (weights : List Nat) :\n  min_steps_to_lift n weights ≥ count_odd_frequencies\
  \ weights := sorry\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval min_steps_to_lift\
  \ 5 [1, 1, 2, 3, 3]\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval min_steps_to_lift\
  \ 4 [0, 1, 2, 3]\n\n/--\ninfo: 11\n-/\n#guard_msgs in\n#eval min_steps_to_lift 13\
  \ [92, 194, 580495, 0, 10855, 41704, 13, 96429, 33, 213, 0, 92, 140599]\n"
"vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded"
