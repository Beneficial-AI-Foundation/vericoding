"vc-description": "Given an array of integers A, find the number of triples of indices\
  \ (i, j, k) such that:\n\n0 <= i < A.length\n0 <= j < A.length\n0 <= k < A.length\n\
  A[i] & A[j] & A[k] == 0, where & represents the bitwise-AND operator.\n\n \nExample\
  \ 1:\nInput: [2,1,3]\nOutput: 12\nExplanation: We could choose the following i,\
  \ j, k triples:\n(i=0, j=0, k=1) : 2 & 2 & 1\n(i=0, j=1, k=0) : 2 & 1 & 2\n(i=0,\
  \ j=1, k=1) : 2 & 1 & 1\n(i=0, j=1, k=2) : 2 & 1 & 3\n(i=0, j=2, k=1) : 2 & 3 &\
  \ 1\n(i=1, j=0, k=0) : 1 & 2 & 2\n(i=1, j=0, k=1) : 1 & 2 & 1\n(i=1, j=0, k=2) :\
  \ 1 & 2 & 3\n(i=1, j=1, k=0) : 1 & 1 & 2\n(i=1, j=2, k=0) : 1 & 3 & 2\n(i=2, j=0,\
  \ k=1) : 3 & 2 & 1\n(i=2, j=1, k=0) : 3 & 1 & 2\n\n \nNote:\n\n1 <= A.length <=\
  \ 1000\n0 <= A[i] < 2^16"
"vc-preamble": "import Imports.AllImports\n\ndef sum_of_prime_factors (n : Int) :\
  \ Int :=\n  sorry\n\n-- Basic properties\n\ndef is_prime (n : Int) : Prop :=\n \
  \ n > 1 ∧ ∀ k, 2 ≤ k → k < n → ¬(n % k = 0)\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def pow (base exp : Int) : Int :=\n  sorry\n"
"vc-theorems": "theorem sum_prime_factors_positive {n : Int} (h : n ≥ 2) : \n  sum_of_prime_factors\
  \ n > 0 ∧ sum_of_prime_factors n ≤ n :=\nsorry\n\n\ntheorem sum_prime_factors_nonpositive\
  \ {n : Int} (h : n ≤ 1) :\n  sum_of_prime_factors n = 0 :=\nsorry\n\n-- For prime\
  \ numbers\n\ntheorem sum_prime_factors_of_prime {n : Int} (h : is_prime n) :\n \
  \ sum_of_prime_factors n = n :=\nsorry\n\n-- For prime powers\n\ntheorem sum_prime_factors_of_prime_power\
  \ {p k : Int}\n  (hp : is_prime p) (hk : k > 0) :\n  sum_of_prime_factors (pow p\
  \ k) = p :=\nsorry\n\n-- For products\n\ntheorem sum_prime_factors_of_product {a\
  \ b : Int} (ha : a ≥ 2) (hb : b ≥ 2) :\n  sum_of_prime_factors (a * b) ≤ sum_of_prime_factors\
  \ a + sum_of_prime_factors b :=\nsorry"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded"
