vc-description: |-
  Given an array of integers A, find the number of triples of indices (i, j, k) such that:

  0 <= i < A.length
  0 <= j < A.length
  0 <= k < A.length
  A[i] & A[j] & A[k] == 0, where & represents the bitwise-AND operator.

   
  Example 1:
  Input: [2,1,3]
  Output: 12
  Explanation: We could choose the following i, j, k triples:
  (i=0, j=0, k=1) : 2 & 2 & 1
  (i=0, j=1, k=0) : 2 & 1 & 2
  (i=0, j=1, k=1) : 2 & 1 & 1
  (i=0, j=1, k=2) : 2 & 1 & 3
  (i=0, j=2, k=1) : 2 & 3 & 1
  (i=1, j=0, k=0) : 1 & 2 & 2
  (i=1, j=0, k=1) : 1 & 2 & 1
  (i=1, j=0, k=2) : 1 & 2 & 3
  (i=1, j=1, k=0) : 1 & 1 & 2
  (i=1, j=2, k=0) : 1 & 3 & 2
  (i=2, j=0, k=1) : 3 & 2 & 1
  (i=2, j=1, k=0) : 3 & 1 & 2

   
  Note:

  1 <= A.length <= 1000
  0 <= A[i] < 2^16
vc-preamble: |
  import Imports.AllImports

  def sum_of_prime_factors (n : Int) : Int :=
    sorry

  -- Basic properties

  def is_prime (n : Int) : Prop :=
    n > 1 ∧ ∀ k, 2 ≤ k → k < n → ¬(n % k = 0)
vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>
vc-definitions: |
  def pow (base exp : Int) : Int :=
    sorry
vc-theorems: |-
  theorem sum_prime_factors_positive {n : Int} (h : n ≥ 2) : 
    sum_of_prime_factors n > 0 ∧ sum_of_prime_factors n ≤ n :=
  sorry


  theorem sum_prime_factors_nonpositive {n : Int} (h : n ≤ 1) :
    sum_of_prime_factors n = 0 :=
  sorry

  -- For prime numbers

  theorem sum_prime_factors_of_prime {n : Int} (h : is_prime n) :
    sum_of_prime_factors n = n :=
  sorry

  -- For prime powers

  theorem sum_prime_factors_of_prime_power {p k : Int}
    (hp : is_prime p) (hk : k > 0) :
    sum_of_prime_factors (pow p k) = p :=
  sorry

  -- For products

  theorem sum_prime_factors_of_product {a b : Int} (ha : a ≥ 2) (hb : b ≥ 2) :
    sum_of_prime_factors (a * b) ≤ sum_of_prime_factors a + sum_of_prime_factors b :=
  sorry
vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: guarded
