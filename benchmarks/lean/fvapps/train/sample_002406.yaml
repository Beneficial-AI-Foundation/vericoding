"vc-description": "The count-and-say sequence is the sequence of integers with the\
  \ first five terms as following:\n\n1.     1\n2.     11\n3.     21\n4.     1211\n\
  5.     111221\n\n\n\n1 is read off as \"one 1\" or 11.\n11 is read off as \"two\
  \ 1s\" or 21.\n21 is read off as \"one 2, then one 1\" or 1211.\n\n\n\nGiven an\
  \ integer n, generate the nth term of the count-and-say sequence.\n\n\n\nNote: Each\
  \ term of the sequence of integers will be represented as a string.\n\n\nExample\
  \ 1:\n\nInput: 1\nOutput: \"1\"\n\n\n\nExample 2:\n\nInput: 4\nOutput: \"1211\""
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def countAndSay (n: Nat) : String :=\n  sorry\n"
"vc-theorems": "theorem countAndSay_one : countAndSay 1 = \"1\" :=\n  sorry\n\n/--\
  \ Every output is a string of nonzero length -/\n\ntheorem countAndSay_nonempty\
  \ (n: Nat) (h: n > 0) : \n  (countAndSay n).length > 0 :=\n  sorry\n\n/-- The output\
  \ only contains ASCII digits -/\n\ntheorem countAndSay_digits_only (n: Nat) (h:\
  \ n > 0) : \n  ∀ p: String.Pos, \n    '0' ≤ (countAndSay n).get p ∧ (countAndSay\
  \ n).get p ≤ '9' :=\n  sorry\n\n/-- Each count-and-say result follows from the previous\
  \ number -/\n\ntheorem countAndSay_inductive_step (n: Nat) (h: n > 1) :\n  ∃ counts\
  \ digits: List Nat, \n    counts.length = digits.length ∧ \n    (∀ d ∈ digits, d\
  \ ≤ 9) ∧\n    (∀ c ∈ counts, c > 0) ∧\n    countAndSay n = String.join (List.map\
  \ (λ (p: Nat × Nat) => toString p.1 ++ toString p.2) \n                        \
  \                (List.zip counts digits)) :=\n  sorry\n\n/--\ninfo: '1'\n-/\n#guard_msgs\
  \ in\n#eval count_and_say 1\n\n/--\ninfo: '1211'\n-/\n#guard_msgs in\n#eval count_and_say\
  \ 4\n\n/--\ninfo: '111221'\n-/\n#guard_msgs in\n#eval count_and_say 5\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
