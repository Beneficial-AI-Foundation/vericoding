"vc-description": "Given a string and an integer k, you need to reverse the first\
  \ k characters for every 2k characters counting from the start of the string. If\
  \ there are less than k characters left, reverse all of them. If there are less\
  \ than 2k but greater than or equal to k characters, then reverse the first k characters\
  \ and left the other as original.\n\n\nExample:\n\nInput: s = \"abcdefg\", k = 2\n\
  Output: \"bacdfeg\"\n\n\n\nRestrictions: \n\n The string consists of lower English\
  \ letters only.\n Length of the given string and k will in the range [1, 10000]"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def reverse_str (s : String) (k : Nat) : String := sorry\n\ntheorem\
  \ length_preservation (s : String) (k : Nat) (h : k > 0):\n  (reverse_str s k).length\
  \ = s.length := sorry\n\n\n\n/-- For substrings of length k starting at indices\
  \ divisible by 2k, \n    they are reversed in the result -/"
"vc-theorems": "theorem reverse_pattern_first_k (s : String) (k : Nat) (h : k > 0)\
  \ (i : Nat) \n  (h2 : i + k ≤ s.length) (h3 : i % (2*k) = 0) :\n  (reverse_str s\
  \ k) = s := sorry\n\n/-- For substrings of length k starting at indices k after\
  \ those divisible by 2k,\n    they remain unchanged in the result -/\n\ntheorem\
  \ non_reverse_pattern_second_k (s : String) (k : Nat) (h : k > 0) (i : Nat)\n  (h2\
  \ : i + 2*k ≤ s.length) (h3 : i % (2*k) = 0) :\n  (reverse_str s k) = s := sorry\n\
  \n\n\n\ntheorem k_equals_one (s : String):\n  reverse_str s 1 = s := sorry\n\n\n\
  theorem empty_string (k : Nat):\n  reverse_str \"\" k = \"\" := sorry"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible"
