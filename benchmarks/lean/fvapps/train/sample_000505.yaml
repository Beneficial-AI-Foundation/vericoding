"vc-description": "Almir had a small sequence $A_1, A_2, \\ldots, A_N$. He decided\
  \ to make $K$ copies of this sequence and concatenate them, forming a sequence $X_1,\
  \ X_2, \\ldots, X_{NK}$; for each valid $i$ and $j$ ($0 \\le j < K$), $X_{j \\cdot\
  \ N + i} = A_i$.\nFor example, if $A = (1, 2, 3)$ and $K = 4$, the final sequence\
  \ is $X = (1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3)$.\nA pair $(i, j)$, where $1 \\le\
  \ i < j \\le N$, is an inversion if $X_i > X_j$. Find the number of inversions in\
  \ the final sequence $X$.\n\n-----Input-----\n- The first line of the input contains\
  \ a single integer $T$ denoting the number of test cases. The description of $T$\
  \ test cases follows.\n- The first line of each test case contains two space-separated\
  \ integers $N$ and $K$.\n- The second line contains $N$ space-separated integers\
  \ $A_1, A_2, \\ldots, A_N$.\n\n-----Output-----\nFor each test case, print a single\
  \ line containing one integer ― the number of inversions in the sequence $X$.\n\n\
  -----Constraints-----\n- $1 \\le T \\le 1,000$\n- $1 \\le N \\le 100$\n- $1 \\le\
  \ K \\le 10^6$\n- $1 \\le A_i \\le 10^9$ for each valid $i$\n\n-----Subtasks-----\n\
  Subtask #1 (100 points): original constraints\n\n-----Example Input-----\n2\n3 3\n\
  2 1 3\n4 100\n99 2 1000 24\n\n-----Example Output-----\n12\n30000"
"vc-preamble": "import Imports.AllImports\n\ndef count_inversions (arr : List Nat)\
  \ (n : Nat) (m : Nat) : Nat := sorry\n\ntheorem count_inversions_non_negative (arr\
  \ : List Nat) (n : Nat) (m : Nat) :\n  count_inversions arr n m ≥ 0 := sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def sorted (xs : List Nat) : Prop :=\n  ∀ i j, i < j → i < xs.length\
  \ → j < xs.length → \n    xs[i]! ≤ xs[j]!\n"
"vc-theorems": "theorem count_inversions_sorted_zero (arr : List Nat) (n : Nat) (m\
  \ : Nat) :\n  sorted arr → count_inversions arr n m = 0 := sorry\n\n\ntheorem count_inversions_scale_invariant\
  \ (arr : List Nat) (n : Nat) (m : Nat) :\n  count_inversions arr n m = count_inversions\
  \ (List.map (· * 2) arr) n m := sorry\n\n\ntheorem count_inversions_monotone (arr\
  \ : List Nat) (n : Nat) (m1 m2 : Nat) :\n  m1 ≤ m2 → count_inversions arr n m1 ≤\
  \ count_inversions arr n m2 := sorry\n\n\ntheorem count_inversions_single_element\
  \ (n m : Nat) (a : Nat) :\n  count_inversions [a] n m = 0 := sorry\n\n\ntheorem\
  \ count_inversions_same_elements (n m a : Nat) :\n  count_inversions [a,a,a] n m\
  \ = 0 := sorry\n\n/--\ninfo: 12\n-/\n#guard_msgs in\n#eval count_inversions [2,\
  \ 1, 3] 3 3\n\n/--\ninfo: 30000\n-/\n#guard_msgs in\n#eval count_inversions [99,\
  \ 2, 1000, 24] 4 100\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
