"vc-description": "Unicode Transformation Format – 8-bit\nAs the name suggests UTF-8\
  \ was designed to encode data in a stream of bytes.\n\nIt works by splitting the\
  \ bits up in multiples of eight. This is achieved by inserting headers to mark in\
  \ how many bytes the bits were split. If the bits need to be split in two, the header\
  \ `110` is added as prefix leaving five bits of the byte for the rest of the data.\
  \ Followed by a continuation byte.\n\nA continuation byte always start with `10`\
  \ leaving six bits for data.\nFor a three-way split: the header `1110` is added\
  \ with two continuation bytes and for four: `11110` with three continuation bytes.\
  \ The number of ones at the start of the first byte denotes the number of bytes\
  \ the data was split in.\n# Task\nYour task is to write two functions:\n1. `to_utf8_binary`:\
  \ which encodes a string to a bitstring using UTF-8 encoding.\n2. `from_utf8_binary`:\
  \ which does the reverse.\n\n- Layout of UTF-8 byte sequences:\n```\n# BYTES  FIRST\
  \ CODE POINT  LAST CODE POINT    BYTE 1      BYTE 2      BYTE 3      BYTE 4\n  \
  \  1                   0              127    0xxxxxxx  \n    2                 128\
  \             2047    110xxxxx    10xxxxxx\n    3                2048          \
  \  65535    1110xxxx    10xxxxxx    10xxxxxx  \n    4               65536      \
  \    1114111    11110xxx    10xxxxxx    10xxxxxx    10xxxxxx\n```\n\n# Examples\n\
  ```\nENCODE\n A  -> 1000001         -> 01000001\n 八 -> 101000101101011 -> 1110-0101\
  \ 10-000101 10-101011\n \nDECODE\n 110-00010 10-100111                     -> 10100111\
  \          -> §\n 11110-000 10-010000 10-001010 10-001100 -> 10000001010001100 ->\
  \ \U0001028C\n```\n* Spaces and hyphens just for clarity\n- https://en.wikipedia.org/wiki/UTF-8#Encoding"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def to_utf8_binary (s : String) : String := sorry\ndef from_utf8_binary\
  \ (s : String) : String := sorry\n"
"vc-theorems": "theorem utf8_roundtrip (s : String) :\n  let binary := to_utf8_binary\
  \ s\n  (∀ c ∈ binary.data, c = '0' ∨ c = '1') ∧\n  binary.length % 8 = 0 ∧\n  from_utf8_binary\
  \ binary = s := sorry\n\n\ntheorem single_codepoint_length (n : Nat) (h : n ≤ 0x10FFFF)\
  \ :\n  let s := Char.toString (Char.ofNat n)\n  let binary := to_utf8_binary s\n\
  \  binary.length = 8 ∨ binary.length = 16 ∨ binary.length = 24 ∨ binary.length =\
  \ 32 := sorry\n\n\ntheorem single_codepoint_roundtrip (n : Nat) (h : n ≤ 0x10FFFF)\
  \ :\n  let s := Char.toString (Char.ofNat n)\n  let binary := to_utf8_binary s\n\
  \  from_utf8_binary binary = s := sorry\n\n\ntheorem empty_strings :\n  to_utf8_binary\
  \ \"\" = \"\" ∧\n  from_utf8_binary \"\" = \"\" := sorry\n\n/--\ninfo: test1_input\n\
  -/\n#guard_msgs in\n#eval from_utf8_binary test1_result\n\n/--\ninfo: test2_input\n\
  -/\n#guard_msgs in\n#eval from_utf8_binary test2_result\n\n/--\ninfo: test3_input\n\
  -/\n#guard_msgs in\n#eval from_utf8_binary test3_result\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
