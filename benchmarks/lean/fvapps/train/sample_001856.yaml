"vc-description": "A kingdom consists of a king, his children, his grandchildren,\
  \ and so on. Every once in a while, someone in the family dies or a child is born.\n\
  The kingdom has a well-defined order of inheritance that consists of the king as\
  \ the first member. Let's define the recursive function Successor(x, curOrder),\
  \ which given a person x and the inheritance order so far, returns who should be\
  \ the next person after x in the order of inheritance.\nSuccessor(x, curOrder):\n\
  \    if x has no children or all of x's children are in curOrder:\n        if x\
  \ is the king return null\n        else return Successor(x's parent, curOrder)\n\
  \    else return x's oldest child who's not in curOrder\n\nFor example, assume we\
  \ have a kingdom that consists of the king, his children Alice and Bob (Alice is\
  \ older than Bob), and finally Alice's son Jack.\n\nIn the beginning, curOrder will\
  \ be [\"king\"].\nCalling Successor(king, curOrder) will return Alice, so we append\
  \ to curOrder to get [\"king\", \"Alice\"].\nCalling Successor(Alice, curOrder)\
  \ will return Jack, so we append to curOrder to get [\"king\", \"Alice\", \"Jack\"\
  ].\nCalling Successor(Jack, curOrder) will return Bob, so we append to curOrder\
  \ to get [\"king\", \"Alice\", \"Jack\", \"Bob\"].\nCalling Successor(Bob, curOrder)\
  \ will return null. Thus the order of inheritance will be [\"king\", \"Alice\",\
  \ \"Jack\", \"Bob\"].\n\nUsing the above function, we can always obtain a unique\
  \ order of inheritance.\nImplement the ThroneInheritance class:\n\nThroneInheritance(string\
  \ kingName) Initializes an object of the ThroneInheritance class. The name of the\
  \ king is given as part of the constructor.\nvoid birth(string parentName, string\
  \ childName) Indicates that parentName gave birth to childName.\nvoid death(string\
  \ name) Indicates the death of name. The death of the person doesn't affect the\
  \ Successor function nor the current inheritance order. You can treat it as just\
  \ marking the person as dead.\nstring[] getInheritanceOrder() Returns a list representing\
  \ the current order of inheritance excluding dead people.\n\n \nExample 1:\nInput\n\
  [\"ThroneInheritance\", \"birth\", \"birth\", \"birth\", \"birth\", \"birth\", \"\
  birth\", \"getInheritanceOrder\", \"death\", \"getInheritanceOrder\"]\n[[\"king\"\
  ], [\"king\", \"andy\"], [\"king\", \"bob\"], [\"king\", \"catherine\"], [\"andy\"\
  , \"matthew\"], [\"bob\", \"alex\"], [\"bob\", \"asha\"], [null], [\"bob\"], [null]]\n\
  Output\n[null, null, null, null, null, null, null, [\"king\", \"andy\", \"matthew\"\
  , \"bob\", \"alex\", \"asha\", \"catherine\"], null, [\"king\", \"andy\", \"matthew\"\
  , \"alex\", \"asha\", \"catherine\"]]\n\nExplanation\nThroneInheritance t= new ThroneInheritance(\"\
  king\"); // order: king\nt.birth(\"king\", \"andy\"); // order: king > andy\nt.birth(\"\
  king\", \"bob\"); // order: king > andy > bob\nt.birth(\"king\", \"catherine\");\
  \ // order: king > andy > bob > catherine\nt.birth(\"andy\", \"matthew\"); // order:\
  \ king > andy > matthew > bob > catherine\nt.birth(\"bob\", \"alex\"); // order:\
  \ king > andy > matthew > bob > alex > catherine\nt.birth(\"bob\", \"asha\"); //\
  \ order: king > andy > matthew > bob > alex > asha > catherine\nt.getInheritanceOrder();\
  \ // return [\"king\", \"andy\", \"matthew\", \"bob\", \"alex\", \"asha\", \"catherine\"\
  ]\nt.death(\"bob\"); // order: king > andy > matthew > bob > alex > asha > catherine\n\
  t.getInheritanceOrder(); // return [\"king\", \"andy\", \"matthew\", \"alex\", \"\
  asha\", \"catherine\"]\n\n \nConstraints:\n\n1 <= kingName.length, parentName.length,\
  \ childName.length, name.length <= 15\nkingName, parentName, childName, and name\
  \ consist of lowercase English letters only.\nAll arguments childName and kingName\
  \ are distinct.\nAll name arguments of death will be passed to either the constructor\
  \ or as childName to birth first.\nFor each call to birth(parentName, childName),\
  \ it is guaranteed that parentName is alive.\nAt most 105 calls will be made to\
  \ birth and death.\nAt most 10 calls will be made to getInheritanceOrder."
"vc-preamble": "import Imports.AllImports\n\ndef birth (t : ThroneInheritance) (parent\
  \ child : String) : ThroneInheritance := sorry\n\ndef death (t : ThroneInheritance)\
  \ (name : String) : ThroneInheritance := sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def getInheritanceOrder (t : ThroneInheritance) : List String :=\
  \ sorry\n\ntheorem new_kingdom_order (kingName : String) :\n  getInheritanceOrder\
  \ ⟨kingName⟩ = [kingName] := sorry \n"
"vc-theorems": "theorem single_birth_order (kingName childName : String) (h : kingName\
  \ ≠ childName) :\n  let t := birth ⟨kingName⟩ kingName childName\n  getInheritanceOrder\
  \ t = [kingName, childName] := sorry\n\n\ntheorem multiple_children_order (kingName\
  \ : String) (children : List String) \n  (h1 : children.length > 0)\n  (h2 : ∀ c\
  \ ∈ children, kingName ≠ c)\n  (h3 : List.Nodup children) :\n  let init := ⟨kingName⟩\n\
  \  let final := children.foldl (fun t c => birth t kingName c) init\n  getInheritanceOrder\
  \ final = kingName :: children := sorry\n\n\ntheorem death_removes_from_order (kingName\
  \ childName : String) (h : kingName ≠ childName) :\n  let t1 := birth ⟨kingName⟩\
  \ kingName childName\n  let t2 := death t1 childName\n  getInheritanceOrder t2 =\
  \ [kingName] := sorry\n\n\ntheorem deaths_and_births (kingName : String) (children\
  \ deaths : List String)\n  (h1 : children.length > 0)\n  (h2 : deaths.length ≤ 2)\n\
  \  (h3 : ∀ c ∈ children, kingName ≠ c)  \n  (h4 : List.Nodup children) :\n  let\
  \ init := ⟨kingName⟩\n  let afterBirths := children.foldl (fun t c => birth t kingName\
  \ c) init\n  let final := deaths.foldl (fun t d => death t d) afterBirths\n  let\
  \ order := getInheritanceOrder final\n  (kingName ∉ deaths → kingName ∈ order) ∧\n\
  \  (∀ c ∈ children, c ∉ deaths → c ∈ order) ∧\n  (∀ c ∈ children, c ∈ deaths → c\
  \ ∉ order) := sorry"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
