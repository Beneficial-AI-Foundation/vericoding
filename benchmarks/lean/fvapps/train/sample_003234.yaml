"vc-description": "This kata focuses on the Numpy python package and you can read\
  \ up on the Numpy array manipulation functions here: https://docs.scipy.org/doc/numpy-1.13.0/reference/routines.array-manipulation.html\n\
  \nYou will get two integers `N` and `M`. You must return an array with two sub-arrays\
  \ with numbers in ranges `[0, N / 2)` and `[N / 2, N)` respectively, each of them\
  \ being rotated `M` times.\n\n```\nreorder(10, 1)   =>  [[4, 0, 1, 2, 3], [9, 5,\
  \ 6, 7, 8]]\nreorder(10, 3)   =>  [[2, 3, 4, 0, 1], [7, 8, 9, 5, 6]]\nreorder(10,\
  \ 97)  =>  [[3, 4, 0, 1, 2], [8, 9, 5, 6, 7]]\n```"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def reorder (n : Nat) (m : Nat) : (List Nat × List Nat) :=\n  sorry\n"
"vc-theorems": "theorem reorder_output_size {n m : Nat} (h : 2 ∣ n) (h2 : n ≥ 2) :\n\
  \  let result := reorder n m\n  List.length result.1 = n/2 ∧ List.length result.2\
  \ = n/2 :=\nsorry\n\n\ntheorem reorder_partitions {n m : Nat} (h : 2 ∣ n) (h2 :\
  \ n ≥ 2) :\n  let result := reorder n m\n  let flattened := result.1 ++ result.2\n\
  \  List.Perm flattened (List.range n) :=\nsorry\n\n\ntheorem reorder_mod_equiv {n\
  \ m : Nat} (h : 2 ∣ n) (h2 : n ≥ 2) :\n  reorder n m = reorder n (m % (n/2)) :=\n\
  sorry\n\n\ntheorem reorder_halves_bound {n m : Nat} (h : 2 ∣ n) (h2 : n ≥ 2) :\n\
  \  let result := reorder n m\n  (∀ x ∈ result.1, x < n/2) ∧ \n  (∀ x ∈ result.2,\
  \ x ≥ n/2) :=\nsorry\n\n/--\ninfo: [[4, 0, 1, 2, 3], [9, 5, 6, 7, 8]]\n-/\n#guard_msgs\
  \ in\n#eval reorder 10 1\n\n/--\ninfo: [[2, 3, 4, 0, 1], [7, 8, 9, 5, 6]]\n-/\n\
  #guard_msgs in\n#eval reorder 10 3\n\n/--\ninfo: [[3, 4, 0, 1, 2], [8, 9, 5, 6,\
  \ 7]]\n-/\n#guard_msgs in\n#eval reorder 10 97\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
