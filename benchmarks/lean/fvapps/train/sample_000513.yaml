"vc-description": "Given an Array of length  $N$  containing elements $Ai$ ( i = 1\
  \ to n ) . You have to handle $Q$ queries on this array . Each Query is of two types\
  \ k=(1 or 2). \nType 1:- $k$ $l$ $r$ in which you have to tell whether the product\
  \ of numbers in range l to r results in a perfect square or not. if product of numbers\
  \ in range $l$ to$r$ is a perfect square then simply output YES else output NO.\n\
  Type 2:- $k$ $i$ $val$ Multiply the value present at index $i$ with $val$.\nNote#1:\
  \ 1 based indexing in each query.\nNote#2: Values of prime factors of all numbers\
  \ $val$ and $Ai$ is between 2 to 100 only.\n\n-----Input:-----\n- First line will\
  \ contain $N$, denoting the size of the array. Then the next line follow. \n- N\
  \ integers  $Ai - An$.\n- Third line will contain $Q$, denoting the number of queries.\
  \ Then the next $Q$ lines follow -description of each query. \n- Each query consists\
  \ of either type 1 or type 2 and each query gives you three elements either\n-{$k$\
  \ $l$ $r$} or {$k$ $i$ $val$}\n\n-----Output:-----\nFor each  Query of Type 1 Output\
  \ either \"YES\" or \"NO\" Without Quotes.\n\n-----Constraints-----\n- $1 \\leq\
  \ N \\leq 20000$\n- $1 \\leq Q \\leq 20000$\n- $2 \\leq Ai \\leq 1000000$\n- $1\
  \ \\leq i ,l,r \\leq N$\n- $1 \\leq val \\leq 1000000$\n- $1 \\leq l \\leq r$\n\n\
  -----Subtasks-----\nSubtask 1 :-40 points \n- Values of prime factors of all numbers\
  \ $val$ and $Ai$ is between 2 to 40 only.\nSubtask 2 :- 60 points\n- Original Constraints\
  \ \n\n-----Sample Input:-----\n4\n2 2 3 4\n4\n1 1 2\n1 3 4\n2 3 3\n1 1 4\n\n-----Sample\
  \ Output:-----\nYES\nNO\nYES\n\n-----EXPLANATION:-----\n-Query 1 :- product of numbers\
  \ in range 1 to 2=2 * 2=4 (perfect square so YES)\n-Query 2:- product of numbers\
  \ in range 3 to 4 = 3 * 4 = 12 (not perfect square so NO)\n-Query 3:- multiply number\
  \ at index3 with 3 so number at index 3= 3*3 = 9 .\n-Query 4:- product of numbers\
  \ in range 1 to 4 = 2 * 2 * 9 * 4 = 144 (perfect square so YES)"
"vc-preamble": "import Imports.AllImports\n\ndef perfect_square_range_query (arr :\
  \ List Nat) (queries : List (Nat × Nat × Nat)) : List String :=\nsorry\n\n\ndef\
  \ is_perfect_square (n : Nat) : Bool := \nsorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def product_range (arr : List Nat) (s e : Nat) : Nat :=\nsorry\n"
"vc-theorems": "theorem query_response_format \n  (arr : List Nat) (queries : List\
  \ (Nat × Nat × Nat)) :\n  let result := perfect_square_range_query arr queries\n\
  \  let type_1_count := (queries.filter (fun q => q.fst = 1)).length\n  result.length\
  \ = type_1_count ∧ \n  result.all (fun r => r = \"YES\" ∨ r = \"NO\") := \nsorry\n\
  \n\ntheorem array_update_consistency\n  (arr : List Nat) (queries : List (Nat ×\
  \ Nat × Nat)) (i : Nat) (h : i < queries.length) :\n  let result := perfect_square_range_query\
  \ arr queries\n  let q := queries[i]'h \n  (q.fst = 1 → \n    let product := product_range\
  \ arr (q.2.1 - 1) (q.2.2)\n    (result[i]? = some \"YES\") = is_perfect_square product)\
  \ := \nsorry\n\n\ntheorem single_element_range\n  (arr : List Nat) (i : Nat) (h\
  \ : i < arr.length) :\n  let queries := List.range arr.length |>.map (fun i => (1,\
  \ i+1, i+1))\n  let result := perfect_square_range_query arr queries\n  result[i]?\
  \ = some (if is_perfect_square (arr[i]'h) then \"YES\" else \"NO\") :=\nsorry"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded"
