"vc-description": "There are n cities connected by m flights. Each fight starts from\
  \ city u and arrives at v with a price w.\n\nNow given all the cities and fights,\
  \ together with starting city src and the destination dst, your task is to find\
  \ the cheapest price from src to dst with up to k stops. If there is no such route,\
  \ output -1.\n\n\nExample 1:\nInput: \nn = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]\n\
  src = 0, dst = 2, k = 1\nOutput: 200\nExplanation: \nThe graph looks like this:\n\
  \n\nThe cheapest price from city 0 to city 2 with at most 1 stop costs 200, as marked\
  \ red in the picture.\n\n\nExample 2:\nInput: \nn = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]\n\
  src = 0, dst = 2, k = 0\nOutput: 500\nExplanation: \nThe graph looks like this:\n\
  \n\nThe cheapest price from city 0 to city 2 with at most 0 stop costs 500, as marked\
  \ blue in the picture.\n\nNote:\n\n\n       The number of nodes n will be in range\
  \ [1, 100], with nodes labeled from 0 to n - 1.\n       The size of flights will\
  \ be in range [0, n * (n - 1) / 2].\n       The format of each flight will be (src,\
  \ dst, price).\n       The price of each flight will be in the range [1, 10000].\n\
  \       k is in the range of [0, n - 1].\n       There will not be any duplicated flights\
  \ or self cycles."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def find_cheapest_price (n: Nat) (flights: List Flight) (src: Nat)\
  \ (dst: Nat) (k: Nat) : Int :=\nsorry\n"
"vc-theorems": "theorem price_non_negative\n  (n: Nat) (flights: List Flight) (src\
  \ dst k: Nat)\n  (h1: src < n) (h2: dst < n) (h3: src ≠ dst) :\n  let price := find_cheapest_price\
  \ n flights src dst k\n  price = -1 ∨ price ≥ 0 :=\nsorry\n\n\ntheorem increasing_stops_never_increases_price\
  \ \n  (n: Nat) (flights: List Flight) (src dst k1 k2: Nat)\n  (h1: src < n) (h2:\
  \ dst < n) (h3: src ≠ dst) (h4: k1 < k2) :\n  let price1 := find_cheapest_price\
  \ n flights src dst k1\n  let price2 := find_cheapest_price n flights src dst k2\n\
  \  price1 ≠ -1 → price2 ≠ -1 → price2 ≤ price1 :=\nsorry\n\n\ntheorem direct_flights_independent_of_k\n\
  \  (n: Nat) (flights: List Flight) (src dst: Nat)\n  (h1: src < n) (h2: dst < n)\
  \ (h3: src ≠ dst)\n  (h4: ∃ f ∈ flights, f.src = src ∧ f.dst = dst) :\n  let direct_price\
  \ := find_cheapest_price n flights src dst 0\n  let min_direct := List.foldl (fun\
  \ acc f => \n    if f.src = src ∧ f.dst = dst \n    then min acc f.price\n    else\
  \ acc) 0 flights\n  direct_price ≠ -1 → direct_price = min_direct :=\nsorry\n\n\n\
  theorem triangular_path_property\n  (n: Nat) (flights: List Flight) (src dst k:\
  \ Nat)\n  (h1: src < n) (h2: dst < n) (h3: src ≠ dst) (h4: k > 0)\n  (h5: ∃ f ∈\
  \ flights, f.src = src ∨ f.dst = dst) :\n  let price := find_cheapest_price n flights\
  \ src dst k\n  let min_edge := List.foldl (fun acc f =>\n    if f.src = src ∨ f.dst\
  \ = dst\n    then min acc f.price \n    else acc) 0 flights\n  price ≠ -1 ∧ min_edge\
  \ > 0 → price ≥ min_edge :=\nsorry\n\n/--\ninfo: 200\n-/\n#guard_msgs in\n#eval\
  \ find_cheapest_price 3 [[0, 1, 100], [1, 2, 100], [0, 2, 500]] 0 2 1\n\n/--\ninfo:\
  \ 500\n-/\n#guard_msgs in\n#eval find_cheapest_price n flights src dst 0\n\n/--\n\
  info: 500\n-/\n#guard_msgs in\n#eval find_cheapest_price 4 [[0, 1, 100], [1, 2,\
  \ 100], [2, 3, 100], [0, 3, 500]] 0 3 1\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
