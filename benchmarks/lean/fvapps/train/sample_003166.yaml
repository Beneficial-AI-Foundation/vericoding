"vc-description": "Consider an array containing cats and dogs. Each dog can catch\
  \ only one cat, but cannot catch a cat that is more than `n` elements away. Your\
  \ task will be to return the maximum number of cats that can be caught.\n\nFor example:\n\
  ```Haskell\nsolve(['D','C','C','D','C'], 2) = 2, because the dog at index 0 (D0)\
  \ catches C1 and D3 catches C4. \nsolve(['C','C','D','D','C','D'], 2) = 3, because\
  \ D2 catches C0, D3 catches C1 and D5 catches C4.\nsolve(['C','C','D','D','C','D'],\
  \ 1) = 2, because D2 catches C1, D3 catches C4. C0 cannot be caught because n ==\
  \ 1.\nsolve(['D','C','D','D','C'], 1) = 2, too many dogs, so all cats get caught!\n\
  ```\n\nDo not modify the input array. \n\nMore examples in the test cases. Good\
  \ luck!"
"vc-preamble": "import Imports.AllImports\n\ndef solve (arr : List Char) (reach :\
  \ Nat) : Nat :=\n  sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def numChar (c : Char) (arr : List Char) : Nat :=\n  sorry\n\n\n\
  \n\n\n\n\n\n\n\n"
"vc-theorems": "theorem solve_empty {reach : Nat} :\n  solve [] reach = 0 :=\n  sorry\n\
  \n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval solve [\"D\", \"C\", \"C\", \"D\", \"\
  C\"] 1\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval solve [\"C\", \"C\", \"D\", \"\
  D\", \"C\", \"D\"] 2\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval solve [\"C\", \"\
  C\", \"D\", \"D\", \"C\", \"D\"] 1\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible"
