"vc-description": "The fusc function is defined recursively as follows:\n\n    1.\
  \ fusc(0) = 0\n    2. fusc(1) = 1\n    3. fusc(2 * n) = fusc(n)\n    4. fusc(2 *\
  \ n + 1) = fusc(n) + fusc(n + 1)\n    \n\nThe 4 rules above are sufficient to determine\
  \ the value of `fusc` for any non-negative input `n`. For example, let's say you\
  \ want to compute `fusc(10)`. \n\n1. `fusc(10) = fusc(5)`, by rule 3.\n2. `fusc(5)\
  \ = fusc(2) + fusc(3)`, by rule 4.\n3. `fusc(2) = fusc(1)`, by rule 3.\n4. `fusc(1)\
  \ = 1`, by rule 2.\n5. `fusc(3) = fusc(1) + fusc(2)` by rule 4.\n6. `fusc(1)` and\
  \ `fusc(2)` have already been computed are both equal to `1`.\n\nPutting these results\
  \ together `fusc(10) = fusc(5) = fusc(2) + fusc(3) = 1 + 2 = 3`\n\nYour job is to\
  \ produce the code for the `fusc` function. In this kata, your function will be\
  \ tested with small values of `n`, so you should not need to be concerned about\
  \ stack overflow or timeouts. \n\nHint: Use recursion.\n\nWhen done, move on to\
  \ [Part 2](http://www.codewars.com/kata/the-fusc-function-part-2)."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def fusc (n : Nat) : Nat := sorry\n\ntheorem fusc_non_negative\
  \ (n : Nat) : fusc n ≥ 0 := sorry\n"
"vc-theorems": "theorem fusc_even_reduce (n : Nat) (h : n > 0) (h2 : n % 2 = 0) :\
  \ \n  fusc n = fusc (n / 2) := sorry\n\n\ntheorem fusc_odd_sum (n : Nat) (h : n\
  \ % 2 = 1) :\n  fusc n = fusc (n / 2) + fusc (n / 2 + 1) := sorry\n\n\ntheorem fusc_base_cases\
  \ :\n  fusc 0 = 0 ∧ fusc 1 = 1 := sorry\n\n\ntheorem fusc_monotonic_bound (n : Nat)\
  \ :\n  fusc n ≤ n := sorry\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval fusc 0\n\n\
  /--\ninfo: 1\n-/\n#guard_msgs in\n#eval fusc 1\n\n/--\ninfo: 3\n-/\n#guard_msgs\
  \ in\n#eval fusc 10\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
