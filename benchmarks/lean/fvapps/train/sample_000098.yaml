"vc-description": "Lee was cleaning his house for the party when he found a messy\
  \ string under the carpets. Now he'd like to make it clean accurately and in a stylish\
  \ way...\n\nThe string $s$ he found is a binary string of length $n$ (i. e. string\
  \ consists only of 0-s and 1-s).\n\nIn one move he can choose two consecutive characters\
  \ $s_i$ and $s_{i+1}$, and if $s_i$ is 1 and $s_{i + 1}$ is 0, he can erase exactly\
  \ one of them (he can choose which one to erase but he can't erase both characters\
  \ simultaneously). The string shrinks after erasing.\n\nLee can make an arbitrary\
  \ number of moves (possibly zero) and he'd like to make the string $s$ as clean\
  \ as possible. He thinks for two different strings $x$ and $y$, the shorter string\
  \ is cleaner, and if they are the same length, then the lexicographically smaller\
  \ string is cleaner.\n\nNow you should answer $t$ test cases: for the $i$-th test\
  \ case, print the cleanest possible string that Lee can get by doing some number\
  \ of moves.\n\nSmall reminder: if we have two strings $x$ and $y$ of the same length\
  \ then $x$ is lexicographically smaller than $y$ if there is a position $i$ such\
  \ that $x_1 = y_1$, $x_2 = y_2$,..., $x_{i - 1} = y_{i - 1}$ and $x_i < y_i$.\n\n\
  \n-----Input-----\n\nThe first line contains the integer $t$ ($1 \\le t \\le 10^4$) —\
  \ the number of test cases. \n\nNext $2t$ lines contain test cases — one per two\
  \ lines.\n\nThe first line of each test case contains the integer $n$ ($1 \\le n\
  \ \\le 10^5$) — the length of the string $s$.\n\nThe second line contains the binary\
  \ string $s$. The string $s$ is a string of length $n$ which consists only of zeroes\
  \ and ones.\n\nIt's guaranteed that sum of $n$ over test cases doesn't exceed $10^5$.\n\
  \n\n-----Output-----\n\nPrint $t$ answers — one per test case.\n\nThe answer to\
  \ the $i$-th test case is the cleanest string Lee can get after doing some number\
  \ of moves (possibly zero).\n\n\n-----Example-----\nInput\n5\n10\n0001111111\n4\n\
  0101\n8\n11001101\n10\n1110000000\n1\n1\n\nOutput\n0001111111\n001\n01\n0\n1\n\n\
  \n\n-----Note-----\n\nIn the first test case, Lee can't perform any moves.\n\nIn\
  \ the second test case, Lee should erase $s_2$.\n\nIn the third test case, Lee can\
  \ make moves, for example, in the following order: 11001101 $\\rightarrow$ 1100101 $\\\
  rightarrow$ 110101 $\\rightarrow$ 10101 $\\rightarrow$ 1101 $\\rightarrow$ 101 $\\\
  rightarrow$ 01."
"vc-preamble": "import Imports.AllImports\n\ndef clean_binary_string (n : Nat) (s\
  \ : String) : String := sorry\n\ndef string_of_zeros (n : Nat) : String := sorry"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def string_of_ones (n : Nat) : String := sorry\n\ntheorem clean_preserves_all_zeros\
  \ (n : Nat) : \n  clean_binary_string n (string_of_zeros n) = string_of_zeros n\
  \ := sorry\n"
"vc-theorems": "theorem clean_preserves_all_ones (n : Nat) :\n  clean_binary_string\
  \ n (string_of_ones n) = string_of_ones n := sorry\n\n\ntheorem clean_preserves_monotonic_transitions\
  \ (n : Nat) (s : String) :\n  s = \"0001\" ∨ s = \"0011\" ∨ s = \"0111\" → clean_binary_string\
  \ n s = s := sorry \n\n\ntheorem clean_shortens_alternating (n : Nat) :\n  clean_binary_string\
  \ 4 \"0101\" = \"001\" := sorry\n\n\ntheorem clean_shortens_complex_pattern (n :\
  \ Nat) :\n  clean_binary_string 8 \"11001101\" = \"01\" := sorry\n\n\ntheorem clean_reduces_to_minimal\
  \ (n : Nat) :\n  clean_binary_string 6 \"100110\" = \"0\" := sorry\n\n/--\ninfo:\
  \ '0001111111'\n-/\n#guard_msgs in\n#eval clean_binary_string 10 \"0001111111\"\n\
  \n/--\ninfo: '001'\n-/\n#guard_msgs in\n#eval clean_binary_string 4 \"0101\"\n\n\
  /--\ninfo: '01'\n-/\n#guard_msgs in\n#eval clean_binary_string 8 \"11001101\"\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
