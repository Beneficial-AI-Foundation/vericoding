"vc-description": "A tree is a graph with n vertices and exactly n - 1 edges; this\
  \ graph should meet the following condition: there exists exactly one shortest (by\
  \ number of edges) path between any pair of its vertices.\n\nA subtree of a tree\
  \ T is a tree with both vertices and edges as subsets of vertices and edges of T.\n\
  \nYou're given a tree with n vertices. Consider its vertices numbered with integers\
  \ from 1 to n. Additionally an integer is written on every vertex of this tree.\
  \ Initially the integer written on the i-th vertex is equal to v_{i}. In one move\
  \ you can apply the following operation:  Select the subtree of the given tree that\
  \ includes the vertex with number 1.  Increase (or decrease) by one all the integers\
  \ which are written on the vertices of that subtree. \n\nCalculate the minimum number\
  \ of moves that is required to make all the integers written on the vertices of\
  \ the given tree equal to zero.\n\n\n-----Input-----\n\nThe first line of the input\
  \ contains n (1 ≤ n ≤ 10^5). Each of the next n - 1 lines contains two integers\
  \ a_{i} and b_{i} (1 ≤ a_{i}, b_{i} ≤ n; a_{i} ≠ b_{i}) indicating there's an edge\
  \ between vertices a_{i} and b_{i}. It's guaranteed that the input graph is a tree.\
  \ \n\nThe last line of the input contains a list of n space-separated integers v_1,\
  \ v_2, ..., v_{n} (|v_{i}| ≤ 10^9).\n\n\n-----Output-----\n\nPrint the minimum number\
  \ of operations needed to solve the task.\n\nPlease, do not write the %lld specifier\
  \ to read or write 64-bit integers in С++. It is preferred to use the cin, cout\
  \ streams or the %I64d specifier.\n\n\n-----Examples-----\nInput\n3\n1 2\n1 3\n\
  1 -1 1\n\nOutput\n3"
"vc-preamble": "import Imports.AllImports\n\ndef solve_tree_zeros (n : Nat) (edges\
  \ : List (Nat × Nat)) (values : List Int) : Nat :=\n  sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def list_max (l : List Nat) : Nat :=\n  match l with\n  | [] =>\
  \ 0\n  | [x] => x\n  | x::xs => Nat.max x (list_max xs)\n"
"vc-theorems": "theorem solve_tree_zeros_nonnegative (n : Nat) (edges : List (Nat\
  \ × Nat)) (values : List Int) :\n  solve_tree_zeros n edges values ≥ 0 := \n  sorry\n\
  \n\ntheorem solve_tree_zeros_finite (n : Nat) (edges : List (Nat × Nat)) (values\
  \ : List Int) :\n  ∃ (k : Nat), solve_tree_zeros n edges values = k :=\n  sorry\n\
  \n\ntheorem solve_tree_zeros_bounds (n : Nat) (edges : List (Nat × Nat)) (values\
  \ : List Int) :\n  solve_tree_zeros n edges values ≥ list_max (values.map Int.natAbs)\
  \ :=\n  sorry\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval solve_tree_zeros 3 [(1,\
  \ 2), (1, 3)] [1, -1, 1]\n\n/--\ninfo: 8\n-/\n#guard_msgs in\n#eval solve_tree_zeros\
  \ 5 [(2, 3), (4, 5), (2, 5), (1, 3)] [0, 2, 1, 4, 3]\n\n/--\ninfo: 18\n-/\n#guard_msgs\
  \ in\n#eval solve_tree_zeros 10 [(5, 6), (8, 2), (9, 3), (4, 1), (6, 10), (9, 8),\
  \ (7, 10), (7, 4), (5, 2)] [0, -6, -9, -1, -5, -4, -2, -7, -8, -3]\n"
"vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded"
