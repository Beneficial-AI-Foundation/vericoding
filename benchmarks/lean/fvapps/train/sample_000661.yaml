"vc-description": "You are given two integer sequences $A_1, A_2, \\ldots, A_N$ and\
  \ $B_1, B_2, \\ldots, B_M$. For any two sequences $U_1, U_2, \\ldots, U_p$ and $V_1,\
  \ V_2, \\ldots, V_q$, we define\nScore(U,V)=∑i=1p∑j=1qUi⋅Vj.Score(U,V)=∑i=1p∑j=1qUi⋅Vj.Score(U,\
  \ V) = \\sum_{i=1}^p \\sum_{j=1}^q  U_i \\cdot V_j \\,.\nYou should process $Q$\
  \ queries of three types:\n- $1$ $L$ $R$ $X$: Add $X$ to each of the elements $A_L,\
  \ A_{L+1}, \\ldots, A_R$.\n- $2$ $L$ $R$ $X$: Add $X$ to each of the elements $B_L,\
  \ B_{L+1}, \\ldots, B_R$.\n- $3$: Print $Score(A, B)$ modulo $998,244,353$.\n\n\
  -----Input-----\n- The first line of the input contains a single integer $T$ denoting\
  \ the number of test cases. The description of $T$ test cases follows.\n- The first\
  \ line of each test case contains two integers, $N$ and $M$, denoting the length\
  \ of $A$ and $B$ respectively.\n- The second line contains $N$ integers, elements\
  \ of $A$.\n- The third line contains $M$ integers, elements of $B$.\n- The next\
  \ line will contain an integer, $Q$, number of queries.\n- Each of the next $Q$\
  \ lines will contain one of $3$ kinds of updates as mentioned in the statement\n\
  It’s guaranteed that each update is a valid update operation.\n\n-----Output-----\n\
  For each query of the third type, print a single line containing one integer - the\
  \ answer to that query.\n\n-----Constraints-----\n- $1 \\le T \\le 10$\n- $2 \\\
  le N, M, Q \\le 10^5$\n- $0 \\le |A_i|, |B_i|, |X| \\le 10^5$\n\n-----Example Input-----\n\
  1\n3 4\n2 -1 5\n3 3 2 4\n6\n3\n1 2 3 -2\n3\n1 1 3 1\n2 2 4 2\n3\n\n-----Example\
  \ Output-----\n72\n24\n90\n\n-----Explanation-----\nBefore the first operation,\
  \ $A = [2, -1, 5],\\ B = [3, 3, 2, 4]$\nSo, for the first operation,\n$Score(A,\\\
  \ B) = 2*3 + 2*3 + 2*2 + 2*4$ $+ (-1)*3$ $+ (-1)*3$ $+ (-1)*2$ $+$ $(-1)*4$ $+ \
  \ 5*3$ $+ 5*3$ $+ 5*2$ $+ 5*4$ $= 72.$\nAfter the second query $A = [2, -3, 3]$,\
  \ $B = [3, 3, 2, 4]$\nSo, for the third query, $Score(A, B) = 2*3 + 2*3 + 2*2$ $+\
  \ 2*4$ $+ (-3)*3$ $+ (-3)*3$ $+ (-3)*2$ $+ (-3)*4$ $+  3*3$ $+ 3*3$ $+ 3*2$ $+ 3*4$\
  \ $= 24$."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def MOD : Int := 998244353\n\ndef process_array_queries (n m :\
  \ Nat) (a b : List Int) (queries : List (List Int)) : List Int :=\n  sorry\n"
"vc-theorems": "theorem process_array_queries_result_length \n  (n m : Nat) (a b :\
  \ List Int) (queries : List (List Int)) :\n  queries.all (fun q => q.length > 0)\
  \ →\n  (process_array_queries n m a b queries).length = \n    (queries.filter (fun\
  \ q => match q.head? with | some 3 => true | _ => false)).length :=\n  sorry\n\n\
  \ntheorem process_array_queries_result_bounds\n  (n m : Nat) (a b : List Int) (queries\
  \ : List (List Int)) \n  (h : queries.all (fun q => q.length > 0)) :\n  (process_array_queries\
  \ n m a b queries).all (fun x => 0 ≤ x ∧ x < MOD) :=\n  sorry\n\n\ntheorem process_array_queries_symmetry\
  \ \n  (n m : Nat) (a b : List Int) (queries : List (List Int))\n  (h1 : queries.length\
  \ > 0)\n  (h2 : match (queries.get! (queries.length - 1)).head? with | some 3 =>\
  \ true | _ => false) :\n  let swapped_queries := queries.map (fun q => match q.head?\
  \ with \n    | some 1 => 2::q.tail\n    | some 2 => 1::q.tail\n    | _ => q)\n \
  \ (process_array_queries n m a b queries).getLast! = \n  (process_array_queries\
  \ m n b a swapped_queries).getLast! :=\n  sorry\n\n\ntheorem process_array_queries_dot_product\n\
  \  (a b : List Int)\n  (h1 : a.length > 0)\n  (h2 : b.length > 0) :\n  (process_array_queries\
  \ a.length b.length a b [[3]]).head! =\n  (a.foldl (fun (acc : Int) (x : Int) =>\
  \ \n    b.foldl (fun (acc2 : Int) (y : Int) => (acc2 + ((x * y) % MOD)) % MOD) acc)\
  \ 0) :=\n  sorry"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded"
