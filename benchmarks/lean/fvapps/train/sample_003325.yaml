"vc-description": "Your task is to create a new implementation of `modpow` so that\
  \ it computes `(x^y)%n` for large `y`. The problem with the current implementation\
  \ is that the output of `Math.pow` is so large on our inputs that it won't fit in\
  \ a 64-bit float.\n\nYou're also going to need to be efficient, because we'll be\
  \ testing some pretty big numbers."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def powerMod (b e m : Nat) : Nat :=\n  sorry\n"
"vc-theorems": "theorem powermod_range (b e m : Nat) (h : m ≥ 2) :\n  let r := powerMod\
  \ b e m\n  0 ≤ r ∧ r < m :=\n  sorry\n\n\ntheorem powermod_zero_exp (base m : Nat)\
  \ (h : base ≥ 1) (h' : m ≥ 2) :\n  powerMod base 0 m = 1 :=\n  sorry\n\n\ntheorem\
  \ powermod_identity (b m : Nat) (h : b ≥ 1) (h' : m ≥ 2) :\n  powerMod b 1 m = b\
  \ % m :=\n  sorry\n\n\ntheorem powermod_multiplicative (b e m : Nat) \n  (h1 : b\
  \ ≥ 1) (h2 : e ≥ 1) (h3 : m ≥ 2) :\n  (powerMod b e m * powerMod b (e + 1) m) %\
  \ m = powerMod b (e + e + 1) m :=\n  sorry\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n\
  #eval power_mod 11 10 300\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval power_mod 5\
  \ 100000000 19\n\n/--\ninfo: 26\n-/\n#guard_msgs in\n#eval power_mod 9 193125 37\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
