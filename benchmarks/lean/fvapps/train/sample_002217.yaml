"vc-description": "We start with a permutation $a_1, a_2, \\ldots, a_n$ and with an\
  \ empty array $b$. We apply the following operation $k$ times.\n\nOn the $i$-th\
  \ iteration, we select an index $t_i$ ($1 \\le t_i \\le n-i+1$), remove $a_{t_i}$\
  \ from the array, and append one of the numbers $a_{t_i-1}$ or $a_{t_i+1}$ (if $t_i-1$\
  \ or $t_i+1$ are within the array bounds) to the right end of the array $b$. Then\
  \ we move elements $a_{t_i+1}, \\ldots, a_n$ to the left in order to fill in the\
  \ empty space.\n\nYou are given the initial permutation $a_1, a_2, \\ldots, a_n$\
  \ and the resulting array $b_1, b_2, \\ldots, b_k$. All elements of an array $b$\
  \ are distinct. Calculate the number of possible sequences of indices $t_1, t_2,\
  \ \\ldots, t_k$ modulo $998\\,244\\,353$.\n\n\n-----Input-----\n\nEach test contains\
  \ multiple test cases. The first line contains an integer $t$ ($1 \\le t \\le 100\\\
  ,000$), denoting the number of test cases, followed by a description of the test\
  \ cases.\n\nThe first line of each test case contains two integers $n, k$ ($1 \\\
  le k < n \\le 200\\,000$): sizes of arrays $a$ and $b$.\n\nThe second line of each\
  \ test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le n$):\
  \ elements of $a$. All elements of $a$ are distinct.\n\nThe third line of each test\
  \ case contains $k$ integers $b_1, b_2, \\ldots, b_k$ ($1 \\le b_i \\le n$): elements\
  \ of $b$. All elements of $b$ are distinct.\n\nThe sum of all $n$ among all test\
  \ cases is guaranteed to not exceed $200\\,000$.\n\n\n-----Output-----\n\nFor each\
  \ test case print one integer: the number of possible sequences modulo $998\\,244\\\
  ,353$.\n\n\n-----Example-----\nInput\n3\n5 3\n1 2 3 4 5\n3 2 5\n4 3\n4 3 2 1\n4\
  \ 3 1\n7 4\n1 4 7 3 6 2 5\n3 2 4 5\n\nOutput\n2\n0\n4\n\n\n\n-----Note-----\n\n\
  $\\require{cancel}$\n\nLet's denote as $a_1 a_2 \\ldots \\cancel{a_i} \\underline{a_{i+1}}\
  \ \\ldots a_n \\rightarrow a_1 a_2 \\ldots a_{i-1} a_{i+1} \\ldots a_{n-1}$ an operation\
  \ over an element with index $i$: removal of element $a_i$ from array $a$ and appending\
  \ element $a_{i+1}$ to array $b$.\n\nIn the first example test, the following two\
  \ options can be used to produce the given array $b$:  $1 2 \\underline{3} \\cancel{4}\
  \ 5 \\rightarrow 1 \\underline{2} \\cancel{3} 5 \\rightarrow 1 \\cancel{2} \\underline{5}\
  \ \\rightarrow 1 2$; $(t_1, t_2, t_3) = (4, 3, 2)$;  $1 2 \\underline{3} \\cancel{4}\
  \ 5 \\rightarrow \\cancel{1} \\underline{2} 3 5 \\rightarrow 2 \\cancel{3} \\underline{5}\
  \ \\rightarrow 1 5$; $(t_1, t_2, t_3) = (4, 1, 2)$. \n\nIn the second example test,\
  \ it is impossible to achieve the given array no matter the operations used. That's\
  \ because, on the first application, we removed the element next to $4$, namely\
  \ number $3$, which means that it couldn't be added to array $b$ on the second step.\n\
  \nIn the third example test, there are four options to achieve the given array $b$:\
  \  $1 4 \\cancel{7} \\underline{3} 6 2 5 \\rightarrow 1 4 3 \\cancel{6} \\underline{2}\
  \ 5 \\rightarrow \\cancel{1} \\underline{4} 3 2 5 \\rightarrow 4 3 \\cancel{2} \\\
  underline{5} \\rightarrow 4 3 5$; $1 4 \\cancel{7} \\underline{3} 6 2 5 \\rightarrow\
  \ 1 4 3 \\cancel{6} \\underline{2} 5 \\rightarrow 1 \\underline{4} \\cancel{3} 2\
  \ 5 \\rightarrow 1 4 \\cancel{2} \\underline{5} \\rightarrow 1 4 5$; $1 4 7 \\underline{3}\
  \ \\cancel{6} 2 5 \\rightarrow 1 4 7 \\cancel{3} \\underline{2} 5 \\rightarrow \\\
  cancel{1} \\underline{4} 7 2 5 \\rightarrow 4 7 \\cancel{2} \\underline{5} \\rightarrow\
  \ 4 7 5$; $1 4 7 \\underline{3} \\cancel{6} 2 5 \\rightarrow 1 4 7 \\cancel{3} \\\
  underline{2} 5 \\rightarrow 1 \\underline{4} \\cancel{7} 2 5 \\rightarrow 1 4 \\\
  cancel{2} \\underline{5} \\rightarrow 1 4 5$;"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def MOD := 998244353\n\ndef solve (n k : Nat) (a b : List Nat)\
  \ : Nat :=\n  sorry\n"
"vc-theorems": "theorem solve_bounds {n k : Nat} {a b : List Nat}\n    (h1 : n > 0)\n\
  \    (h2 : k > 0)\n    (h3 : k ≤ n)\n    (h4 : k ≤ 100)\n    (h5 : n ≤ 100) \n \
  \   (h6 : a.length = n)\n    (h7 : b.length = k)\n    (h8 : ∀ x ∈ a, 1 ≤ x ∧ x ≤\
  \ n)\n    (h9 : ∀ x ∈ b, 1 ≤ x ∧ x ≤ n) :\n    let result := solve n k a b\n   \
  \ 0 ≤ result ∧ result < MOD :=\n  sorry\n\n\ntheorem solve_minimal_case {n : Nat}\
  \ {a b : List Nat}\n    (h1 : n > 0)\n    (h2 : n ≤ 5)\n    (h3 : a.length = n)\n\
  \    (h4 : b.length = 1)\n    (h5 : ∀ x ∈ a, 1 ≤ x ∧ x ≤ n)\n    (h6 : ∀ x ∈ b,\
  \ 1 ≤ x ∧ x ≤ n) :\n    let result := solve n 1 a b\n    result = 0 ∨ result = 1\
  \ ∨ result = 2 :=\n  sorry\n\n\ntheorem solve_edge_case_one {a b : List Nat}\n \
  \   (h1 : a.length = 1)\n    (h2 : b.length = 1)\n    (h3 : ∀ x ∈ a, x = 1)\n  \
  \  (h4 : ∀ x ∈ b, x = 1) :\n    let result := solve 1 1 a b\n    0 ≤ result ∧ result\
  \ < MOD :=\n  sorry\n\n\ntheorem solve_edge_case_two_one {a b : List Nat}\n    (h1\
  \ : a.length = 2)\n    (h2 : b.length = 1)\n    (h3 : ∀ x ∈ a, 1 ≤ x ∧ x ≤ 2)\n\
  \    (h4 : ∀ x ∈ b, 1 ≤ x ∧ x ≤ 2) :\n    let result := solve 2 1 a b\n    0 ≤ result\
  \ ∧ result < MOD :=\n  sorry\n\n\ntheorem solve_edge_case_two_two {a b : List Nat}\n\
  \    (h1 : a.length = 2)\n    (h2 : b.length = 2)\n    (h3 : ∀ x ∈ a, 1 ≤ x ∧ x\
  \ ≤ 2)\n    (h4 : ∀ x ∈ b, 1 ≤ x ∧ x ≤ 2) :\n    let result := solve 2 2 a b\n \
  \   0 ≤ result ∧ result < MOD :=\n  sorry\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n\
  #eval solve 5 3 [1, 2, 3, 4, 5] [3, 2, 5]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n\
  #eval solve 4 3 [4, 3, 2, 1] [4, 3, 1]\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval\
  \ solve 7 4 [1, 4, 7, 3, 6, 2, 5] [3, 2, 4, 5]\n"
"vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded"
