"vc-description": "A grammar is a set of rules that let us define a language. These\
  \ are called **production rules** and can be derived into many different tools.\
  \ One of them is **String Rewriting Systems** (also called Semi-Thue Systems or\
  \ Markov Algorithms). Ignoring technical details, they are a set of rules that substitute\
  \ ocurrences in a given string by other strings. \n\nThe rules have the following\
  \ format:\n\n```\nstr1 -> str2\n```\n\nWe define a rule application as the substitution\
  \ of a substring following a rule. If this substring appears more than once, only\
  \ one of this occurences is substituted and any of them is equally valid as an option:\n\
  \n```python\n'a' -> 'c' # Substitution rule\n\n'aba' # Base string\n'cba' # One\
  \ application on position 0\n'abc' # One application on position 2\n'cbc' # Two\
  \ applications\n```\n\nAnother valid example of rule application would be the following:\n\
  \n```python\n# Rules\n'l' -> 'de'\n'm' -> 'col'\n'rr' -> 'wakr'\n'akr' -> 'ars'\n\
  \n# Application\n'mrr' # Starting string\n'colrr' # Second rule\n'coderr' # First\
  \ rule\n'codewakr' # Third rule\n'codewars' # Last rule \n```\nNote that this example\
  \ is exhaustive, but Semi-Thue Systems can be potentially infinite:\n\n```python\n\
  # Rules\n'a' -> 'aa'\n\n# Application\n'a' # Starting string\n'aa' # First application\n\
  'aaa' # Second application\n...\n```\n\nThe so called **Word Problem** is to decide\
  \ whether or not a string can be derived from another using these rules. This is\
  \ an **undecidable problem**, but if we restrict it to a certain number of applications,\
  \ we can give it a solution.\n\nYour task is to write a function that solves the\
  \ word problem given a maximum number of rule applications. \n\n**Python:** The\
  \ rules are given as tuples where the left and the right handside of the rule correspond\
  \ to the first and the second element respectively.\n\n**Notes:** \n* Two rules\
  \ can have the same left handside and a different right handside.\n* You do not\
  \ have to worry too much about performance yet. A simple, funtional answer will\
  \ be enough."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def word_problem (rules : List (String × String)) (from_str to_str\
  \ : String) (applications : Nat) : Bool :=\n  sorry\n"
"vc-theorems": "theorem word_problem_returns_bool (rules : List (String × String))\
  \ (from_str to_str : String) (applications : Nat) :\n  word_problem rules from_str\
  \ to_str applications = true ∨ word_problem rules from_str to_str applications =\
  \ false :=\n  sorry\n\n\ntheorem word_problem_zero_applications (rules : List (String\
  \ × String)) (from_str to_str : String) :\n  word_problem rules from_str to_str\
  \ 0 = (from_str = to_str) :=\n  sorry\n\n\ntheorem word_problem_equal_strings (rules\
  \ : List (String × String)) (str : String) (n : Nat) :\n  n > 0 → word_problem rules\
  \ str str n = true :=\n  sorry\n\n\ntheorem word_problem_impossible_match (rules\
  \ : List (String × String)) (from_str impossible : String) (n : Nat) :\n  n > 0\
  \ →\n  String.length impossible > String.length from_str + n →\n  word_problem rules\
  \ from_str impossible n = false :=\n  sorry\n\n\ntheorem word_problem_single_rule\
  \ (from_str to_str : String) :\n  word_problem [(from_str, to_str)] from_str to_str\
  \ 1 = true :=\n  sorry\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval word_problem\
  \ [(\"a\", \"b\")] \"a\" \"b\" 1\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval word_problem\
  \ [(\"l\", \"de\"), (\"m\", \"col\"), (\"rr\", \"wakr\"), (\"akr\", \"ars\")] \"\
  mrr\" \"codewars\" 4\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval word_problem\
  \ [(\"a\", \"b\"), (\"b\", \"c\")] \"a\" \"d\" 2\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
