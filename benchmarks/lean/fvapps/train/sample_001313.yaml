"vc-description": "Vision has finally made it to Wakanda to get his MindStone extracted.\
  \ The MindStone was linked to his brain in a highly sophisticated manner and Shuri\
  \ had to solve a complex problem to extract the stone. The MindStone had $n$ integers\
  \ inscribed in it and Shuri needs to apply the prefix sum operation on the array\
  \ $k$ times to extract the stone.\nFormally, given $n$ integers $A[1], A[2] .....\
  \ A[n]$ and a number $k$, apply the operation\n$A[i] = \\sum_{j=1}^{i} A[j]$\non\
  \ the array $k$ times.\nFinally Shuri needs to apply $modulo$ $(10^9 + 7)$ operation\
  \ to each element of the array. Can you help Shuri accomplish this task before Thanos\
  \ gets to them?\n\n-----Input:-----\n- First line of the input consists of two space\
  \ separated integers $n$ and $k$. \n- Second line contains $n$ space separated integers\
  \ $A[1] .. A[n]$.\n\n-----Output:-----\nIn a single line print $n$ space separated\
  \ integers, the values of the resultant array after applying all the operations.\n\
  \n-----Constraints-----\n- $1 \\leq n \\leq 1000$\n- $1 \\leq k \\leq 10^{12}$\n\
  - $1 \\leq A[i] \\leq 10^9$\n\n-----Subtasks-----\n- 20 Points: $1 \\leq k \\leq\
  \ 1000$\n- 30 Points: $1 \\leq k \\leq 1000000$\n- 50 Points: Original Constraints\n\
  \n-----Sample Input:-----\n$4$ $2$\n$3$ $4$ $1$ $5$\n\n-----Sample Output:-----\n\
  $3$ $10$ $18$ $31$\n\n-----EXPLANATION:-----\nAfter applying the prefix sum operation\
  \ once the array becomes -> $3$ $7$ $8$ $13$\nAfter applying the prefix sum operation\
  \ for the second time, the array becomes -> $3$ $10$ $18$ $31$\nAfter applying $modulo$\
  \ $(10^9 +7)$ operation, array becomes -> $3$ $10$ $18$ $31$"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def MOD := 1000000007\n\ndef solve_mindstone (n : Nat) (k : Nat)\
  \ (arr : List Nat) : List Nat :=\n  sorry\n"
"vc-theorems": "theorem solve_mindstone_length {n k : Nat} {arr : List Nat} \n  (h1\
  \ : 1 ≤ n) (h2 : n ≤ 100) (h3 : k ≤ 10) \n  (h4 : ∀ x ∈ arr, x ≤ 100000) :\n  List.length\
  \ (solve_mindstone n k (List.take n arr)) = List.length (List.take n arr) :=\n \
  \ sorry\n\n\ntheorem solve_mindstone_mod_range {n k : Nat} {arr : List Nat}\n  (h1\
  \ : 1 ≤ n) (h2 : n ≤ 100) (h3 : k ≤ 10)\n  (h4 : ∀ x ∈ arr, x ≤ 100000) :\n  ∀ x\
  \ ∈ solve_mindstone n k arr, x < MOD :=\n  sorry\n\n\ntheorem solve_mindstone_k_zero\
  \ {n : Nat} {arr : List Nat}\n  (h1 : 1 ≤ n) (h2 : n ≤ 100)\n  (h4 : ∀ x ∈ arr,\
  \ x ≤ 100000) :\n  solve_mindstone n 0 arr = List.map (fun x => x % MOD) arr :=\n\
  \  sorry\n\n\ntheorem solve_mindstone_k_one {n : Nat} {arr : List Nat}\n  (h1 :\
  \ 1 ≤ n) (h2 : n ≤ 100)\n  (h4 : ∀ x ∈ arr, x ≤ 100000) :\n  solve_mindstone n 1\
  \ arr = \n    let rec prefix_sum (acc : Nat) : List Nat → List Nat\n      | [] =>\
  \ []\n      | (x::xs) => ((acc + x) % MOD) :: prefix_sum ((acc + x) % MOD) xs\n\
  \    prefix_sum 0 arr :=\n  sorry\n\n\ntheorem solve_mindstone_monotonic {n k :\
  \ Nat} {arr : List Nat}\n  (h1 : 1 ≤ k) (h2 : k ≤ 5)\n  (h3 : ∀ x ∈ arr, x ≤ 10)\
  \ :\n  ∀ i j, i < j → j < List.length (solve_mindstone n k arr) → \n    List.get!\
  \ (solve_mindstone n k arr) i ≤ List.get! (solve_mindstone n k arr) j :=\n  sorry"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded"
