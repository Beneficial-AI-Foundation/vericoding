"vc-description": "Given a 2D grid of 0s and 1s, return the number of elements in the\
  \ largest square subgrid that has all 1s on its border, or 0 if such a subgrid doesn't\
  \ exist in the grid.\n \nExample 1:\nInput: grid = [[1,1,1],[1,0,1],[1,1,1]]\nOutput:\
  \ 9\n\nExample 2:\nInput: grid = [[1,1,0,0]]\nOutput: 1\n\n \nConstraints:\n\n1\
  \ <= grid.length <= 100\n1 <= grid[0].length <= 100\ngrid[i][j] is 0 or 1"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def largest1BorderedSquare (grid : List (List Nat)) : Nat := sorry\n\
  \ntheorem all_zeros (n : Nat) (h : n ≥ 1) : \n  let grid := List.replicate n (List.replicate\
  \ n 0)\n  largest1BorderedSquare grid = 0 := sorry\n"
"vc-theorems": "theorem all_ones (n : Nat) (h : n ≥ 1) :\n  let grid := List.replicate\
  \ n (List.replicate n 1) \n  largest1BorderedSquare grid = n * n := sorry\n\n\n\
  theorem perfect_square_2x2 (grid : List (List Nat)) \n  (h1 : grid.length = 2)\n\
  \  (h2 : ∀ row ∈ grid, row.length = 2)\n  (h3 : ∀ row ∈ grid, ∀ x ∈ row, x = 0 ∨\
  \ x = 1) :\n  let result := largest1BorderedSquare grid\n  result * result = result\
  \ := sorry\n\n\ntheorem bounds_3x3 (grid : List (List Nat))\n  (h1 : grid.length\
  \ = 3)\n  (h2 : ∀ row ∈ grid, row.length = 3)\n  (h3 : ∀ row ∈ grid, ∀ x ∈ row,\
  \ x = 0 ∨ x = 1) :\n  let result := largest1BorderedSquare grid\n  let maxPossible\
  \ := (min grid.length (grid.head?.getD []).length) ^ 2\n  0 ≤ result ∧ result ≤\
  \ maxPossible := sorry\n\n/--\ninfo: 9\n-/\n#guard_msgs in\n#eval largest1BorderedSquare\
  \ [[1, 1, 1], [1, 0, 1], [1, 1, 1]]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval largest1BorderedSquare\
  \ [[1, 1, 0, 0]]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval largest1BorderedSquare\
  \ [[0, 0], [0, 0]]\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
