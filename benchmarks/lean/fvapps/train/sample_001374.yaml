"vc-description": "Chef has just learned a new data structure - Fenwick tree. This\
  \ data structure holds information about array of N elements and can process two\
  \ types of operations:\n\n- Add some value to ith element of the array\n- Calculate\
  \ sum of all elements on any prefix of the array\n\nBoth operations take O(log N)\
  \ time. This data structure is also well known for its low memory usage. To be more\
  \ precise, it needs exactly the same amount of memory as that of array.\n\nGiven\
  \ some array A, first we build data structure in some other array T. Ti stores the\
  \ sum of the elements Astart, Astart + 1, ..., Ai. Index start is calculated with\
  \ formula start = Fdown(i) = (i & (i + 1)). Here \"&\" denotes bitwise AND operation.\n\
  So, in order to find a sum of elements A0, A1, ..., AL you start with index L and\
  \ calculate sum of TL + TFdown(L)-1 + TFdown(Fdown(L)-1)-1 + ... + TFdown(Fdown(...(Fdown(L)-1)-1)-1.\
  \ Usually it is performed with cycle that goes from L down to 0 with function Fdown\
  \ and sums some elements from T. Chef wants to verify that the time complexity to\
  \ calculate sum of A0, A1, A2, ..., AL is O(log L). In order to do so, he wonders\
  \ how many times he has to access array T to calculate this sum. Help him to find\
  \ this out.\nSince Chef works with really big indices. The value of L can be very\
  \ large and is provided to you in binary representation as concatenation of strings\
  \ L1, L2 repeated N times and string L3.\n\n-----Input-----\nThe first line of the\
  \ input contains an integer T denoting the number of test cases. The description\
  \ of T test cases follows.\nThe only line of each test case contains three non-empty\
  \ strings L1, L2, L3 and an integer N. Strings will contain only characters 0 and\
  \ 1. To obtain binary representation of index L concatenate L1 with L2 repeated\
  \ N times and with L3. You are guaranteed that the index will be positive.\n\n-----Output-----\n\
  For each test case, output a single line containing number of times Fenwick tree\
  \ data structure will access array T in order to compute sum of A0, A1, A2, ...,\
  \ AL.\n\n-----Constraints-----\n- 1 ≤ T ≤ 300\n- 1 ≤ Length(Li) ≤ 1000\n- 1 ≤ N\
  \ ≤ 106\n\n-----Subtasks-----\n- Subtask #1 (20 points): |L1| + |L2| * N + |L3|\
  \ ≤ 60\n- Subtask #2 (30 points): 1 ≤ T ≤ 30, 1 ≤ N ≤ 100\n- Subtask #3 (50 points):\
  \ No additional constraints\n\n-----Example-----\nInput:\n4\n001 100 011 4\n1000\
  \ 1101 100 3\n1010 001 101 4\n010 101 000 4\n\nOutput:\n6\n12\n8\n10"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def count_fenwick_accesses (l1 l2 l3: String) (n: Nat) : Nat :=\
  \ sorry\n\ndef is_valid_binary (s: String) : Bool := sorry \n"
"vc-theorems": "theorem count_fenwick_result_nonnegative (l1 l2 l3: String) (n: Nat)\
  \ :\n  count_fenwick_accesses l1 l2 l3 n ≥ 0 := sorry\n\n\ntheorem count_fenwick_valid_input\
  \ (l1 l2 l3: String) (n: Nat) :\n  is_valid_binary l1 ∧ is_valid_binary l2 ∧ is_valid_binary\
  \ l3 := sorry\n\n\ntheorem count_fenwick_result_bounded (l1 l2 l3: String) (n: Nat)\
  \ :\n  count_fenwick_accesses l1 l2 l3 n ≤ l1.length + n * l2.length + l3.length\
  \ := sorry\n\n\ntheorem count_fenwick_deterministic (l1 l2 l3: String) (n: Nat)\
  \ :\n  count_fenwick_accesses l1 l2 l3 n = count_fenwick_accesses l1 l2 l3 n :=\
  \ sorry\n\n\ntheorem count_fenwick_all_zeros (n: Nat) :\n  count_fenwick_accesses\
  \ \"0\" \"0\" \"0\" n = 0 := sorry\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval count_fenwick_accesses\
  \ \"001\" \"100\" \"011\" 4\n\n/--\ninfo: 12\n-/\n#guard_msgs in\n#eval count_fenwick_accesses\
  \ \"1000\" \"1101\" \"100\" 3\n\n/--\ninfo: 8\n-/\n#guard_msgs in\n#eval count_fenwick_accesses\
  \ \"1010\" \"001\" \"101\" 4\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
