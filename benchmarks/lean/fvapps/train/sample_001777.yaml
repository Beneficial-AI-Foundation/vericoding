"vc-description": "There are n cities numbered from 0 to n-1. Given the array edges where\
  \ edges[i] = [fromi, toi, weighti] represents a bidirectional and weighted edge\
  \ between cities fromi and toi, and given the integer distanceThreshold.\nReturn\
  \ the city with the smallest number of cities that are reachable through some path\
  \ and whose distance is at most distanceThreshold, If there are multiple such cities,\
  \ return the city with the greatest number.\nNotice that the distance of a path\
  \ connecting cities i and j is equal to the sum of the edges' weights along that\
  \ path.\n \nExample 1:\n\nInput: n = 4, edges = [[0,1,3],[1,2,1],[1,3,4],[2,3,1]],\
  \ distanceThreshold = 4\nOutput: 3\nExplanation: The figure above describes the\
  \ graph. \nThe neighboring cities at a distanceThreshold = 4 for each city are:\n\
  City 0 -> [City 1, City 2] \nCity 1 -> [City 0, City 2, City 3] \nCity 2 -> [City\
  \ 0, City 1, City 3] \nCity 3 -> [City 1, City 2] \nCities 0 and 3 have 2 neighboring\
  \ cities at a distanceThreshold = 4, but we have to return city 3 since it has the\
  \ greatest number.\n\nExample 2:\n\nInput: n = 5, edges = [[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]],\
  \ distanceThreshold = 2\nOutput: 0\nExplanation: The figure above describes the\
  \ graph. \nThe neighboring cities at a distanceThreshold = 2 for each city are:\n\
  City 0 -> [City 1] \nCity 1 -> [City 0, City 4] \nCity 2 -> [City 3, City 4] \n\
  City 3 -> [City 2, City 4]\nCity 4 -> [City 1, City 2, City 3] \nThe city 0 has\
  \ 1 neighboring city at a distanceThreshold = 2.\n\n \nConstraints:\n\n2 <= n <=\
  \ 100\n1 <= edges.length <= n * (n - 1) / 2\nedges[i].length == 3\n0 <= fromi <\
  \ toi < n\n1 <= weighti, distanceThreshold <= 10^4\nAll pairs (fromi, toi) are distinct."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def findCityWithSmallestReachable (n : Nat) (edges : List (Nat\
  \ × Nat × Nat)) (threshold : Nat) : Nat :=\n  sorry\n"
"vc-theorems": "theorem valid_index_result (n : Nat) (edges : List (Nat × Nat × Nat))\
  \ (threshold : Nat)\n  (h1 : n > 0)\n  (h2 : ∀ e ∈ edges, e.1 < n ∧ e.2.1 < n)\n\
  \  (h3 : ∀ e ∈ edges, e.2.2 > 0)\n  (h4 : ∀ e ∈ edges, e.1 ≠ e.2.1) : \n  let result\
  \ := findCityWithSmallestReachable n edges threshold\n  result < n :=\n  sorry\n\
  \n\ntheorem symmetric_result (n : Nat) (edges : List (Nat × Nat × Nat)) (threshold\
  \ : Nat)\n  (h1 : n > 0)\n  (h2 : ∀ e ∈ edges, e.1 < n ∧ e.2.1 < n)\n  (h3 : ∀ e\
  \ ∈ edges, e.2.2 > 0)\n  (h4 : ∀ e ∈ edges, e.1 ≠ e.2.1) :\n  let swappedEdges :=\
  \ edges.map (fun e => (e.2.1, e.1, e.2.2))\n  findCityWithSmallestReachable n edges\
  \ threshold = \n  findCityWithSmallestReachable n swappedEdges threshold :=\n  sorry\n\
  \n\ntheorem single_vertex_empty_graph :\n  findCityWithSmallestReachable 1 [] 1\
  \ = 0 :=\n  sorry\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval find_city_with_smallest_reachable\
  \ 4 [[0, 1, 3], [1, 2, 1], [1, 3, 4], [2, 3, 1]] 4\n\n/--\ninfo: 0\n-/\n#guard_msgs\
  \ in\n#eval find_city_with_smallest_reachable 5 [[0, 1, 2], [0, 4, 8], [1, 2, 3],\
  \ [1, 4, 2], [2, 3, 1], [3, 4, 1]] 2\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
