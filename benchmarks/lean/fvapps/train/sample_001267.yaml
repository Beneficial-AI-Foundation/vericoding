"vc-description": "You are given two positive integers $N$ and $K$, where $K \\le\
  \ N$. Find a sequence $A_1, A_2, \\ldots, A_N$ such that:\n- for each valid $i$,\
  \ $A_i$ is either $i$ or $-i$\n- there are exactly $K$ values of $i$ such that $1\
  \ \\le i \\le N$ and $A_1 + A_2 + \\ldots + A_i > 0$\nIf there are multiple solutions,\
  \ you may print any one of them. It can be proved that at least one solution always\
  \ exists.\n\n-----Input-----\n- The first line of the input contains a single integer\
  \ $T$ denoting the number of test cases. The description of $T$ test cases follows.\n\
  - The first and only line of each test case contains two space-separated integers\
  \ $N$ and $K$.\n\n-----Output-----\nFor each test case, print a single line containing\
  \ $N$ space-separated integers $A_1, A_2, \\ldots, A_N$.\n\n-----Constraints-----\n\
  - $1 \\le T \\le 1,000$\n- $1 \\le K \\le N \\le 1,000$\n\n-----Subtasks-----\n\
  Subtask #1 (10 points): $N \\le 10$\nSubtask #2 (90 points): original constraints\n\
  \n-----Example Input-----\n1\n3 3\n\n-----Example Output-----\n1 2 3"
"vc-preamble": "import Imports.AllImports\n\ndef List.size {α} : List α → Nat\n  |\
  \ [] => 0\n  | _::xs => 1 + xs.size\n\n\ndef sequence_generator (n k : Nat) : List\
  \ Int :=\n  sorry\n\n\ndef count_positive_prefixes (seq : List Int) : Nat :=\n \
  \ sorry\n\n\ndef sumList (xs : List Int) : Int :=\n  sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def Int.abs (i : Int) : Nat :=\n  sorry\n"
"vc-theorems": "theorem sequence_length (n k : Nat) (h1 : n > 0) (h2 : k ≤ 100) :\n\
  \  (sequence_generator n k).size = n :=\n  sorry\n\n\ntheorem sequence_elements\
  \ (n k : Nat) (h1 : n > 0) (h2 : k ≤ 100) (h3 : i < n) :\n  let seq := sequence_generator\
  \ n k\n  ∀ i : Nat, i < n → Int.abs (seq.get ⟨i, sorry⟩) = i + 1 :=\n  sorry\n\n\
  \ntheorem positive_prefix_count (n k : Nat) (h1 : n > 0) (h2 : k ≤ 100) :\n  count_positive_prefixes\
  \ (sequence_generator n k) ≤ min k n :=\n  sorry\n\n\ntheorem all_positive_case\
  \ (n : Nat) (h : n > 0) :\n  let seq := sequence_generator n n\n  (∀ i : Nat, i\
  \ < n → seq.get ⟨i, sorry⟩ > 0) ∧\n  seq = List.map (Int.ofNat ∘ Nat.succ) (List.range\
  \ n) :=\n  sorry\n\n\ntheorem all_negative_case (n : Nat) (h : n > 0) :\n  let seq\
  \ := sequence_generator n 0\n  (∀ i : Nat, i < n → seq.get ⟨i, sorry⟩ < 0) ∧\n \
  \ seq = List.map (fun i => -Int.ofNat (i + 1)) (List.range n) :=\n  sorry\n\n/--\n\
  info: [1, 2, 3]\n-/\n#guard_msgs in\n#eval sequence_generator 3 3\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
