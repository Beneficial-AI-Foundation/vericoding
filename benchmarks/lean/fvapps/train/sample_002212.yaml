"vc-description": "For an array $b$ of length $m$ we define the function $f$ as  $\
  \ f(b) = \\begin{cases} b[1] & \\quad \\text{if } m = 1 \\\\ f(b[1] \\oplus b[2],b[2]\
  \ \\oplus b[3],\\dots,b[m-1] \\oplus b[m]) & \\quad \\text{otherwise,} \\end{cases}\
  \ $ \n\nwhere $\\oplus$ is bitwise exclusive OR.\n\nFor example, $f(1,2,4,8)=f(1\\\
  oplus2,2\\oplus4,4\\oplus8)=f(3,6,12)=f(3\\oplus6,6\\oplus12)=f(5,10)=f(5\\oplus10)=f(15)=15$\n\
  \nYou are given an array $a$ and a few queries. Each query is represented as two\
  \ integers $l$ and $r$. The answer is the maximum value of $f$ on all continuous\
  \ subsegments of the array $a_l, a_{l+1}, \\ldots, a_r$.\n\n\n-----Input-----\n\n\
  The first line contains a single integer $n$ ($1 \\le n \\le 5000$) — the length\
  \ of $a$.\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$ ($0 \\\
  le a_i \\le 2^{30}-1$) — the elements of the array.\n\nThe third line contains a\
  \ single integer $q$ ($1 \\le q \\le 100\\,000$) — the number of queries.\n\nEach\
  \ of the next $q$ lines contains a query represented as two integers $l$, $r$ ($1\
  \ \\le l \\le r \\le n$).\n\n\n-----Output-----\n\nPrint $q$ lines — the answers\
  \ for the queries.\n\n\n-----Examples-----\nInput\n3\n8 4 1\n2\n2 3\n1 2\n\nOutput\n\
  5\n12\n\nInput\n6\n1 2 4 8 16 32\n4\n1 6\n2 5\n3 4\n1 2\n\nOutput\n60\n30\n12\n\
  3\n\n\n\n-----Note-----\n\nIn first sample in both queries the maximum value of\
  \ the function is reached on the subsegment that is equal to the whole segment.\n\
  \nIn second sample, optimal segment for first query are $[3,6]$, for second query\
  \ — $[2,5]$, for third — $[3,4]$, for fourth — $[1,2]$."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def solve_f_max (a : List Nat) (queries : List (Nat × Nat)) : List\
  \ Nat :=\n  sorry\n"
"vc-theorems": "theorem solve_f_max_length {a : List Nat} {queries : List (Nat × Nat)}\n\
  \    (h_valid : ∀ q ∈ queries, q.1 ≤ q.2 ∧ q.2 ≤ a.length) :\n    (solve_f_max a\
  \ queries).length = queries.length :=\n  sorry\n\n\ntheorem solve_f_max_nonnegative\
  \ {a : List Nat} {queries : List (Nat × Nat)}\n    (h_valid : ∀ q ∈ queries, q.1\
  \ ≤ q.2 ∧ q.2 ≤ a.length) :\n    ∀ x ∈ solve_f_max a queries, x ≥ 0 :=\n  sorry\n\
  \n\ntheorem solve_f_max_greater_than_elements {a : List Nat} {queries : List (Nat\
  \ × Nat)}\n    (h_valid : ∀ q ∈ queries, q.1 ≤ q.2 ∧ q.2 ≤ a.length) :\n    ∀ (res\
  \ : Nat) (q : Nat × Nat),\n      res ∈ solve_f_max a queries →\n      q ∈ queries\
  \ →\n      ∀ x ∈ (List.take (q.2 - q.1 + 1) (List.drop (q.1 - 1) a)),\n      res\
  \ ≥ x :=\n  sorry\n\n\ntheorem solve_f_max_single_element {a : List Nat} :\n   \
  \ let queries := List.map (fun i => (i+1, i+1)) (List.range a.length)\n    solve_f_max\
  \ a queries = a :=\n  sorry\n\n/--\ninfo: [5, 12]\n-/\n#guard_msgs in\n#eval solve_f_max\
  \ [8, 4, 1] [(2, 3), (1, 2)]\n\n/--\ninfo: [60, 30, 12, 3]\n-/\n#guard_msgs in\n\
  #eval solve_f_max [1, 2, 4, 8, 16, 32] [(1, 6), (2, 5), (3, 4), (1, 2)]\n"
"vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded"
