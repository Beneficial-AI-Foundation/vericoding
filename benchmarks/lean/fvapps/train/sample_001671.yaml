"vc-description": "We need a system that can learn facts about family relationships,\
  \ check their consistency and answer queries about them.\n\n# The task\n\n~~~if:javascript\n\
  Create a class `Family` with the following methods. All arguments are strings: names\
  \ of persons. Upon the first use of a name, that name is added to the family.\n\n\
  * `male(name)` and `female(name)` returning `boolean`\n\n Define the gender (corresponding\
  \ to the method name) of the given person. Return `false` when these assignments\
  \ cannot be made because of conflicts with earlier registered information.\n  \n\
  * `isMale(name)` and `isFemale(name)` returning `boolean`\n\n Return `true` when\
  \ the person has the said gender. When no gender was assigned, both methods should\
  \ return `false`\n \n* `setParent(childName, parentName)` returning `boolean`\n\n\
  \ Defines the child-parent relationship between two persons. Returns `false` when\
  \ the relationship cannot be made because of conflicts with earlier registered information.\n\
  \n* `getParents(name)` and `getChildren(name)` returning `array` of `string`\n \n\
  \ Return the names of the person's parents/children in alphabetical order\n~~~\n\
  ~~~if:python\nCreate a class `Family` with the following methods. All arguments\
  \ are strings: names of persons. Upon the first use of a name, that name is added\
  \ to the family.\n\n* `male(name)` and `female(name)` returning `boolean`\n\n Define\
  \ the gender (corresponding to the method name) of the given person. Return `False`\
  \ when these assignments cannot be made because of conflicts with earlier registered\
  \ information.\n  \n* `is_male(name)` and `is_female(name)` returning `boolean`\n\
  \n Return `True` when the person has the said gender. When no gender was assigned,\
  \ both methods should return `False`\n \n* `set_parent_of(child_name, parent_name)`\
  \ returning `boolean`\n\n Defines the child-parent relationship between two persons.\
  \ Returns `False` when the relationship cannot be made because of conflicts with\
  \ earlier registered information.\n\n* `get_parents_of(name)` and `get_children_of(name)`\
  \ returning `list` of `string`\n \n Return the names of the person's parents/children\
  \ in alphabetical order\n~~~\n~~~if:java\nCreate a class `Family` with the following\
  \ methods. All arguments are names of persons. Upon the first use of a name, that\
  \ name is added to the family.\n\n* `boolean male(String name)` and `boolean female(String\
  \ name)`\n\n Define the gender (corresponding to the method name) of the given person.\
  \ Return `false` when these assignments cannot be made because of conflicts with\
  \ earlier registered information.\n  \n* `boolean isMale(String name)` and `boolean\
  \ isFemale(String name)`\n\n Return `true` when the person has the said gender.\
  \ When no gender was assigned, both methods should return `false`\n \n* `boolean\
  \ setParent(String childName, String parentName)`\n\n Defines the child-parent relationship\
  \ between two persons. Returns `false` when the relationship cannot be made because\
  \ of conflicts with earlier registered information.\n\n* `List getParents(String\
  \ name)` and `List getChildren(String name)`\n \n Return the names of the person's\
  \ parents/children in alphabetical order\n~~~\n~~~if:php\nCreate a class `Family`\
  \ with the following methods. All arguments are names of persons. Upon the first\
  \ use of a name, that name is added to the family.\n\n* `male(string $name): bool`\
  \ and `female(string $name): bool`\n\n Define the gender (corresponding to the method\
  \ name) of the given person. Return `false` when these assignments cannot be made\
  \ because of conflicts with earlier registered information.\n  \n* `isMale(string\
  \ $name): bool` and `isFemale(string $name): bool`\n\n Return `true` when the person\
  \ has the said gender. When no gender was assigned, both methods should return `false`\n\
  \ \n* `setParent(string $child_name, string $parent_name): bool`\n\n Defines the\
  \ child-parent relationship between two persons. Returns `false` when the relationship\
  \ cannot be made because of conflicts with earlier registered information.\n\n*\
  \ `getParents(string $name): array` and `getChildren(string $name): array`\n \n\
  \ Return the names of the person's parents/children in alphabetical order\n~~~\n\
  \n# Deducing information\n\nWhen things can be implied from given information, it\
  \ should be done.\n\nFor instance, a parent's gender can be determined as soon as\
  \ the other parent's gender becomes known:\n\n```python\nfam = Family()\nfam.set_parent_of(\"\
  Vera\", \"George\")\nfam.set_parent_of(\"Vera\", \"Vanessa\")\nfam.female(\"Vanessa\"\
  )\nfam.female(\"George\");  # False, because:\nfam.is_male(\"George\"); # ...this\
  \ is True.\n```\n\n~~~if:javascript,java,php\nAlso `setParentOf` can return `false`.\
  \ For example, if the relationship would infer that one becomes their own ancestor:\n\
  ~~~\n~~~if:python\nAlso `set_parent_of` can return `False`. For example, if the\
  \ relationship would infer that one becomes their own ancestor:\n~~~\n\n```python\n\
  fam = Family()\nfam.set_parent_of(\"Vera\", \"George\")\nfam.set_parent_of(\"George\"\
  , \"Vera\") # False\n```\n\n# Details, rules, assumptions\n\nAlthough the task relates\
  \ to genealogy, the rules of this kata are not claimed to be realistic. Several\
  \ simplifications and rules apply, which may not hold in real life: \n\n- Strings\
  \ are case sensitive, but there are no tests playing around with \"Peter\", \"PETER\"\
  \ and \"PeTeR\".\n- People are uniquely identified by their name. For instance,\
  \ there are no two different people called \"Jim\" in the same family.\n- Once a\
  \ person has an assigned gender, it cannot be changed.\n- No gender conclusions\
  \ should be made from personal names: \"Bob\" could well be a woman and \"Susan\"\
  \ a man.\n- People cannot have more than one mother and one father.\n- The terms\
  \ \"parents\" and \"children\" refer to the relatives in the immediate previous/next\
  \ generations only, not to more remote ancestors or descendants.\n- Incest may occur,\
  \ so, for example, one's parent may at the same time be their grandparent.\n- One\
  \ cannot be their own ancestor.\n- Age is not accounted for. Even if some incestuous\
  \ relationships would infer that one's parent is more than 5 generations older,\
  \ it should be allowed.\n- In case a name's first occurrence is in a call of one\
  \ of the two gender querying methods, the return value will always be false, as\
  \ that new person does not have a known gender.\n- In case a name's first occurrence\
  \ is in a call of one of the two relation querying methods, the return value will\
  \ always be an empty array/list, as there are no relationships known yet in which\
  \ that new person participates.\n- For the reasons in the preceding two bullet points\
  \ it should not matter whether you actually store that name in these cases in your\
  \ data structure, or not. In the latter case you would only store it at the next\
  \ occasion when that name is mentioned in a call of one of the three other methods,\
  \ that actually *add* information. The described interface has no way to query the\
  \ difference between these two possible implementations, so you can choose freely.\n\
  \n# Example\n\nConsider the following family graph:\n\n\n  .dot { height: 49px;\
  \ width: 100px; background-color: #666; border-radius: 50%;\n      border: #aaa\
  \ 1px solid ; display: flex; align-items: center; justify-content: center; }\n \
  \ table.tight { border-spacing: 0px; border-collapse: separate; width: 250px}\n\
  \  table.tight td { padding: 0px; min-width: 25px; height: 25px; }\n  .up { border-top:\
  \ #aaa 1px solid; }\n  .right { border-right: #aaa 1px solid; }\n  .red { color:\
  \ #ea6 }\n\n\n\nDylan (m)\n\nMorgan (f)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFrank (m)\n\
  \nJuly\n\nJennifer\n\n\n\n\n\n\n\n\n\n\n\n\nJoy\n\n\n\n\nIt could be created step\
  \ by step with the following code — the expected return value for each method call\
  \ is indicated in comments:\n\n```python\nfam = Family()\nfam.set_parent_of(\"Frank\"\
  , \"Morgan\")       # True\nfam.set_parent_of(\"Frank\", \"Dylan\")        # True\n\
  fam.male(\"Dylan\")                          # True\nfam.male(\"Dylan\")       \
  \                   # True, no conflict\nfam.set_parent_of(\"Joy\", \"Frank\") \
  \         # True\nfam.male(\"Frank\")                          # True\nfam.male(\"\
  Morgan\")                         # False\n# (Morgan is a woman because she both\
  \ is Frank's parent, but not his father) \nfam.set_parent_of(\"July\", \"Morgan\"\
  )        # True\n# (The preceding assertion was rejected, so there is no conflict)\n\
  fam.is_male(\"Joy\") or fam.is_female(\"Joy\") # False\n# (We know Joy is Frank's\
  \ child, but we can't derive Joy's gender)\nfam.get_children_of(\"Morgan\")    \
  \          # [\"Frank\", \"July\"]\nfam.set_parent_of(\"Jennifer\", \"Morgan\")\
  \    # True\nfam.get_children_of(\"Morgan\")              # [\"Frank\", \"Jennifer\"\
  , \"July\"]\nfam.get_children_of(\"Dylan\")               # [\"Frank\"]\n# (That\
  \ is all we know for sure)\nfam.get_parents_of(\"Frank\")                # [\"Dylan\"\
  , \"Morgan\"]\nfam.set_parent_of(\"Morgan\", \"Frank\")       # False\n# (It is\
  \ impossible to be the parent of your parent)\n```\n\nHave fun!"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def mkFamily : Family := {\n  male := fun _ => false,\n  female\
  \ := fun _ => false,\n  get_parents_of := fun _ => [],\n  get_children_of := fun\
  \ _ => [],\n  set_parent_of := fun _ _ => false,\n  is_male := fun _ => false,\n\
  \  is_female := fun _ => false\n}\n\nvariable (f : Family)\n"
"vc-theorems": "theorem male_female_exclusive (name : String) :\n  ¬(f.male name =\
  \ true ∧ f.female name = true) :=\nsorry\n\n\ntheorem male_idempotent (name : String)\
  \ :\n  f.male name = true → f.male name = true ∧ f.female name = false :=\nsorry\n\
  \n\ntheorem female_idempotent (name : String) :\n  f.female name = true → f.female\
  \ name = true ∧ f.male name = false :=\nsorry\n\n\ntheorem empty_relationships (name\
  \ : String) :\n  f.get_parents_of name = [] ∧ \n  f.get_children_of name = [] ∧\n\
  \  f.is_male name = false ∧\n  f.is_female name = false :=\nsorry\n\n\ntheorem parent_child_relationship\
  \ (parent child : String) :\n  parent ≠ child →\n  (f.set_parent_of child parent\
  \ = true → \n    (parent ∈ f.get_parents_of child ∧\n     child ∈ f.get_children_of\
  \ parent ∧\n     (f.get_parents_of child).length ≤ 2)) ∧\n  (f.set_parent_of child\
  \ parent = false →\n    parent ∉ f.get_parents_of child ∧\n    child ∉ f.get_children_of\
  \ parent) :=\nsorry\n\n\ntheorem gender_deduction (parent1 parent2 child : String)\
  \ :\n  parent1 ≠ parent2 ∧ parent1 ≠ child ∧ parent2 ≠ child →\n  f.set_parent_of\
  \ child parent1 = true ∧ f.set_parent_of child parent2 = true →\n  f.male parent1\
  \ = true →\n  f.is_female parent2 = true ∧\n  f.is_male parent1 ≠ f.is_male parent2\
  \ ∧ \n  f.is_female parent1 ≠ f.is_female parent2 :=\nsorry\n\n\ntheorem no_cyclic_relationships\
  \ (names : List String) :\n  names.length ≥ 3 →\n  names.Nodup →\n  (∀ (i : Nat),\
  \ i < names.length - 1 → \n    f.set_parent_of (names[i]!) (names[i+1]!) = true)\
  \ →\n  f.set_parent_of (names[names.length - 1]!) (names[0]!) = false :=\nsorry"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
