"vc-description": "Given two arrays nums1 and nums2.\nReturn the maximum dot product between non-empty\
  \ subsequences of nums1 and nums2 with the same length.\nA subsequence of a array\
  \ is a new array which is formed from the original array by deleting some (can be\
  \ none) of the characters without disturbing the relative positions of the remaining\
  \ characters. (ie, [2,3,5] is a subsequence of [1,2,3,4,5] while [1,5,3] is not).\n\
   \nExample 1:\nInput: nums1 = [2,1,-2,5], nums2 = [3,0,-6]\nOutput: 18\nExplanation:\
  \ Take subsequence [2,-2] from nums1 and subsequence [3,-6] from nums2.\nTheir dot\
  \ product is (2*3 + (-2)*(-6)) = 18.\nExample 2:\nInput: nums1 = [3,-2], nums2 =\
  \ [2,-6,7]\nOutput: 21\nExplanation: Take subsequence [3] from nums1 and subsequence\
  \ [7] from nums2.\nTheir dot product is (3*7) = 21.\nExample 3:\nInput: nums1 =\
  \ [-1,-1], nums2 = [1,1]\nOutput: -1\nExplanation: Take subsequence [-1] from nums1\
  \ and subsequence [1] from nums2.\nTheir dot product is -1.\n \nConstraints:\n\n\
  1 <= nums1.length, nums2.length <= 500\n-1000 <= nums1[i], nums2[i] <= 1000"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def max_dot_product (nums1 nums2 : List Int) : Int := sorry\n\n\
  theorem max_dot_product_bounds \n  (nums1 nums2 : List Int) :\n  let min_product\
  \ := (List.map (fun x => List.map (fun y => x * y) nums2) nums1).join.minimum?\n\
  \  let max_product := (List.map (fun x => List.map (fun y => x * y) nums2) nums1).join.maximum?\n\
  \  match min_product, max_product with\n  | some min, some max => \n    max_dot_product\
  \ nums1 nums2 ≥ min ∧ \n    max_dot_product nums1 nums2 ≤ nums1.length * max\n \
  \ | _, _ => True := sorry\n"
"vc-theorems": "theorem max_dot_product_reverse_invariant\n  (nums1 nums2 : List Int)\
  \ :\n  max_dot_product nums1 nums2 = max_dot_product nums1.reverse nums2.reverse\
  \ := sorry\n\n\ntheorem max_dot_product_neg_invariant\n  (nums1 nums2 : List Int)\
  \ :\n  max_dot_product nums1 nums2 = \n    - (max_dot_product (nums1.map (fun x\
  \ => -x)) (nums2.map (fun x => -x))) := sorry\n\n\ntheorem max_dot_product_monotonic\n\
  \  (nums1 nums2 : List Int) :\n  let big_num := max (nums1.maximum?.getD 0) (nums2.maximum?.getD\
  \ 0) + 100\n  max_dot_product (nums1 ++ [big_num]) (nums2 ++ [big_num]) ≥ \n   \
  \ max_dot_product nums1 nums2 := sorry\n\n/--\ninfo: 18\n-/\n#guard_msgs in\n#eval\
  \ max_dot_product [2, 1, -2, 5] [3, 0, -6]\n\n/--\ninfo: 21\n-/\n#guard_msgs in\n\
  #eval max_dot_product [3, -2] [2, -6, 7]\n\n/--\ninfo: -1\n-/\n#guard_msgs in\n\
  #eval max_dot_product [-1, -1] [1, 1]\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
