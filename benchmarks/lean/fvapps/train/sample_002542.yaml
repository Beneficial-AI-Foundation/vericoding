"vc-description": "Help a fruit packer sort out the bad apples. \n\nThere are 7 varieties\
  \ of apples, all packaged as pairs and stacked in a fruit box. Some of the apples\
  \ are spoiled. The fruit packer will have to make sure the spoiled apples are either\
  \ removed from the fruit box or replaced. Below is the breakdown:\n\nApple varieties\
  \ are represented with numbers, `1 to 7`\n\nA fruit package is represented with\
  \ a 2 element array `[4,3]`\n\nA fruit package with one bad apple, or a bad package,\
  \ is represented with `[2,0]` or `[0,2]`\n\nA fruit package with two bad apples,\
  \ or a rotten package, is represented with `[0,0]`\n\nA fruit box is represented\
  \ with:\n\n```\n[ [ 1, 3 ],\n  [ 7, 6 ],\n  [ 7, 2 ],\n  [ 1, 3 ],\n  [ 0, 2 ],\n\
  \  [ 4, 5 ],\n  [ 0, 3 ],\n  [ 7, 6 ] ]\n\n```\n\nWrite a program to clear the fruit\
  \ box off bad apples. \n\nThe INPUT will be a fruit box represented with a 2D array:\
  \ `[[1,3],[7,6],[7,2],[1,3],[0,2],[4,5],[0,3],[7,6]]`\n\nThe OUTPUT should be the\
  \ fruit box void of bad apples: `[[1,3],[7,6],[7,2],[1,3],[2,3],[4,5],[7,6]]`\n\n\
  Conditions to be met:\n\n1.A bad package should have the bad apple replaced if there\
  \ is another bad package with a good apple to spare. Else, the bad package should\
  \ be discarded.\n\n2.The order of the packages in the fruit box should be preserved.\
  \ Repackaging happens from the top of the fruit box `index = 0` to the bottom `nth\
  \ index`. Also note how fruits in a package are ordered when repacking. Example\
  \ shown in INPUT/OUPUT above.\n\n3.Rotten packages should be discarded. \n\n4.There\
  \ can be packages with the same variety of apples, e.g `[1,1]`, this is not a problem."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def bad_apples (apples : List (Nat × Nat)) : List (List Nat) :=\n\
  \  sorry\n"
"vc-theorems": "theorem bad_apples_output_structure (apples : List (Nat × Nat)) :\n\
  \  let result := bad_apples apples\n  -- Output is list of lists with exactly 2\
  \ elements\n  ∀ sublist ∈ result, sublist.length = 2 := by\n  sorry\n\n\ntheorem\
  \ bad_apples_no_zeros (apples : List (Nat × Nat)) :\n  let result := bad_apples\
  \ apples\n  -- No zeros in output lists\n  ∀ sublist ∈ result, ∀ x ∈ sublist, x\
  \ ≠ 0 := by\n  sorry\n\n\ntheorem bad_apples_values_subset (apples : List (Nat ×\
  \ Nat)) :\n  let result := bad_apples apples\n  let input_values := (apples.map\
  \ (fun p => [p.1, p.2])).join.filter (fun n => n ≠ 0)\n  -- Output values come from\
  \ input\n  ∀ sublist ∈ result, ∀ x ∈ sublist, x ∈ input_values := by\n  sorry\n\n\
  \ntheorem bad_apples_length (apples : List (Nat × Nat)) :\n  let result := bad_apples\
  \ apples\n  -- Output no longer than input\n  result.length ≤ apples.length := by\n\
  \  sorry\n\n\ntheorem bad_apples_all_zeros (apples : List (Nat × Nat)) :\n  (∀ p\
  \ ∈ apples, p.1 = 0 ∧ p.2 = 0) →\n  -- All zero pairs give empty result  \n  bad_apples\
  \ apples = [] := by\n  sorry\n\n\ntheorem bad_apples_value_counts (apples : List\
  \ (Nat × Nat)) (x : Nat) :\n  let result := bad_apples apples\n  -- Output value\
  \ counts don't exceed input counts\n  x ≠ 0 →\n  let input_count := (apples.map\
  \ (fun p => [p.1, p.2])).join.filter (fun n => n = x) |>.length\n  let output_count\
  \ := result.join.filter (fun n => n = x) |>.length\n  output_count ≤ input_count\
  \ := by\n  sorry\n\n/--\ninfo: []\n-/\n#guard_msgs in\n#eval bad_apples []\n\n/--\n\
  info: expected\n-/\n#guard_msgs in\n#eval bad_apples [[1, 3], [7, 6], [7, 2], [1,\
  \ 3], [0, 2], [4, 5], [0, 3], [7, 6]]\n\n/--\ninfo: []\n-/\n#guard_msgs in\n#eval\
  \ bad_apples [[0, 0], [0, 0]]\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
