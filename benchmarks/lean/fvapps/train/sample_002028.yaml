"vc-description": "You are given an array consisting of n non-negative integers a_1,\
  \ a_2, ..., a_{n}.\n\nYou are going to destroy integers in the array one by one.\
  \ Thus, you are given the permutation of integers from 1 to n defining the order\
  \ elements of the array are destroyed.\n\nAfter each element is destroyed you have\
  \ to find out the segment of the array, such that it contains no destroyed elements\
  \ and the sum of its elements is maximum possible. The sum of elements in the empty\
  \ segment is considered to be 0.\n\n\n-----Input-----\n\nThe first line of the input\
  \ contains a single integer n (1 ≤ n ≤ 100 000) — the length of the array.\n\nThe\
  \ second line contains n integers a_1, a_2, ..., a_{n} (0 ≤ a_{i} ≤ 10^9). \n\n\
  The third line contains a permutation of integers from 1 to n — the order used to\
  \ destroy elements.\n\n\n-----Output-----\n\nPrint n lines. The i-th line should\
  \ contain a single integer — the maximum possible sum of elements on the segment\
  \ containing no destroyed elements, after first i operations are performed.\n\n\n\
  -----Examples-----\nInput\n4\n1 3 2 5\n3 4 1 2\n\nOutput\n5\n4\n3\n0\n\nInput\n\
  5\n1 2 3 4 5\n4 2 3 5 1\n\nOutput\n6\n5\n5\n1\n0\n\nInput\n8\n5 5 4 4 6 6 5 5\n\
  5 2 8 7 1 3 4 6\n\nOutput\n18\n16\n11\n8\n8\n6\n6\n0\n\n\n\n-----Note-----\n\nConsider\
  \ the first sample:   Third element is destroyed. Array is now 1 3  *  5. Segment\
  \ with maximum sum 5 consists of one integer 5.  Fourth element is destroyed. Array\
  \ is now 1 3  *   * . Segment with maximum sum 4 consists of two integers 1 3. \
  \ First element is destroyed. Array is now  *  3  *   * . Segment with maximum sum\
  \ 3 consists of one integer 3.  Last element is destroyed. At this moment there\
  \ are no valid nonempty segments left in this array, so the answer is equal to 0."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def solve_array_destroy (n : Nat) (nums : List Nat) (destroy_order\
  \ : List Nat) : List Nat := sorry\n\ndef list_sum (l : List Nat) : Nat :=\n  match\
  \ l with \n  | [] => 0\n  | x::xs => x + list_sum xs\n"
"vc-theorems": "theorem solve_array_destroy_output_valid \n  (n : Nat) (nums destroy_order\
  \ : List Nat)\n  (h1 : n > 0) (h2 : n ≤ 100)\n  (h3 : ∀ x ∈ nums, 1 ≤ x ∧ x ≤ 1000)\n\
  \  (h4 : destroy_order.length = n)\n  (h5 : ∀ x ∈ destroy_order, 1 ≤ x ∧ x ≤ n)\n\
  \  (h6 : ∀ i j, i < j → i < destroy_order.length → j < destroy_order.length → \n\
  \        destroy_order.get! i ≠ destroy_order.get! j) :\n  let result := solve_array_destroy\
  \ n nums destroy_order\n  result.length = n ∧ \n  (result.length > 0 → result.get?\
  \ (result.length - 1) = some 0) ∧\n  (∀ x ∈ result, x ≥ 0) ∧\n  (∀ i < result.length\
  \ - 1, match result.get? i, result.get? (i+1) with\n    | some x, some y => x ≥\
  \ y\n    | _, _ => True) := sorry\n\n\ntheorem solve_array_destroy_adjacent_valid\n\
  \  (n : Nat) (nums destroy_order : List Nat)\n  (h1 : n ≥ 2) (h2 : n ≤ 20)\n  (h3\
  \ : ∀ x ∈ nums, 1 ≤ x ∧ x ≤ 100)\n  (h4 : destroy_order.length = n)\n  (h5 : ∀ x\
  \ ∈ destroy_order, 1 ≤ x ∧ x ≤ n)\n  (h6 : ∀ i j, i < j → i < destroy_order.length\
  \ → j < destroy_order.length → \n        destroy_order.get! i ≠ destroy_order.get!\
  \ j) :\n  let result := solve_array_destroy n nums destroy_order\n  result.length\
  \ = n ∧\n  (result.length > 0 → result.get? (result.length - 1) = some 0) := sorry\n\
  \n\ntheorem solve_array_destroy_max_bound\n  (n : Nat) (nums destroy_order : List\
  \ Nat)\n  (h1 : n > 0) (h2 : n ≤ 50)\n  (h3 : ∀ x ∈ nums, 1 ≤ x ∧ x ≤ 1000)\n  (h4\
  \ : destroy_order.length = n)\n  (h5 : ∀ x ∈ destroy_order, 1 ≤ x ∧ x ≤ n)\n  (h6\
  \ : ∀ i j, i < j → i < destroy_order.length → j < destroy_order.length → \n    \
  \    destroy_order.get! i ≠ destroy_order.get! j) :\n  let result := solve_array_destroy\
  \ n nums destroy_order\n  result.length = n ∧\n  ∀ x ∈ result, x ≤ list_sum nums\
  \ := sorry"
"vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded"
