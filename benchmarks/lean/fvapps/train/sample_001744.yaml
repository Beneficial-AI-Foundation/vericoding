"vc-description": "On an N x N grid, each square grid[i][j] represents the elevation\
  \ at that point (i,j).\n\nNow rain starts to fall. At time t, the depth of the water\
  \ everywhere is t. You can swim from a square to another 4-directionally adjacent\
  \ square if and only if the elevation of both squares individually are at most t.\
  \ You can swim infinite distance in zero time. Of course, you must stay within the\
  \ boundaries of the grid during your swim.\n\nYou start at the top left square (0,\
  \ 0). What is the least time until you can reach the bottom right square (N-1, N-1)?\n\
  \nExample 1:\n\n\nInput: [[0,2],[1,3]]\nOutput: 3\nExplanation:\nAt time 0, you\
  \ are in grid location (0, 0).\nYou cannot go anywhere else because 4-directionally\
  \ adjacent neighbors have a higher elevation than t = 0.\n\nYou cannot reach point\
  \ (1, 1) until time 3.\nWhen the depth of water is 3, we can swim anywhere inside\
  \ the grid.\n\n\nExample 2:\n\n\nInput: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]\n\
  Output: 16\nExplanation:\n 0  1  2  3  4\n24 23 22 21  5\n12 13 14 15 16\n11 17\
  \ 18 19 20\n10  9  8  7  6\n\nThe final route is marked in bold.\nWe need to wait\
  \ until time 16 so that (0, 0) and (4, 4) are connected.\n\n\nNote:\n\n\n      \
  \ 2 <= N <= 50.\n       grid[i][j] is a permutation of [0, ..., N*N - 1]."
"vc-preamble": "import Imports.AllImports\n\ndef Matrix (α : Type) := List (List α)\n\
  \ndef swim_time (grid : Matrix Nat) : Nat := sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def can_reach (t : Nat) (grid : Matrix Nat) (i j : Nat) (visited\
  \ : List (Nat × Nat)) : Bool := sorry\n\ntheorem swim_time_non_negative (grid :\
  \ Matrix Nat) : \n  swim_time grid ≥ 0 := sorry\n"
"vc-theorems": "theorem swim_time_bounds {grid : Matrix Nat} (h : grid.length > 0)\
  \ :\n  swim_time grid ≥ (grid.head!.head!) ∧\n  swim_time grid ≥ (grid.getLast!.getLast!)\
  \ ∧\n  swim_time grid ≤ grid.length * grid.length := sorry\n\n\ntheorem swim_time_monotonic\
  \ {grid grid2 : Matrix Nat} {i j : Nat}\n  (h1 : i < grid.length)\n  (h2 : j < grid.length)\n\
  \  (h3 : ∀ x y, x ≠ i ∨ y ≠ j → \n    (grid.get! x).get! y = (grid2.get! x).get!\
  \ y)\n  (h4 : (grid2.get! i).get! j = (grid.get! i).get! j + 1) :\n  swim_time grid2\
  \ ≥ swim_time grid := sorry\n\n\ntheorem swim_time_path_exists (grid : Matrix Nat)\
  \ : \n  can_reach (swim_time grid) grid 0 0 [] = true := sorry\n\n/--\ninfo: 3\n\
  -/\n#guard_msgs in\n#eval swim_time [[0, 2], [1, 3]]\n\n/--\ninfo: 16\n-/\n#guard_msgs\
  \ in\n#eval swim_time [[0, 1, 2, 3, 4], [24, 23, 22, 21, 5], [12, 13, 14, 15, 16],\
  \ [11, 17, 18, 19, 20], [10, 9, 8, 7, 6]]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n\
  #eval swim_time [[0, 1], [2, 3]]\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
