"vc-description": "You and your $n - 1$ friends have found an array of integers $a_1,\
  \ a_2, \\dots, a_n$. You have decided to share it in the following way: All $n$\
  \ of you stand in a line in a particular order. Each minute, the person at the front\
  \ of the line chooses either the first or the last element of the array, removes\
  \ it, and keeps it for himself. He then gets out of line, and the next person in\
  \ line continues the process.\n\nYou are standing in the $m$-th position in the\
  \ line. Before the process starts, you may choose up to $k$ different people in\
  \ the line, and persuade them to always take either the first or the last element\
  \ in the array on their turn (for each person his own choice, not necessarily equal\
  \ for all people), no matter what the elements themselves are. Once the process\
  \ starts, you cannot persuade any more people, and you cannot change the choices\
  \ for the people you already persuaded.\n\nSuppose that you're doing your choices\
  \ optimally. What is the greatest integer $x$ such that, no matter what are the\
  \ choices of the friends you didn't choose to control, the element you will take\
  \ from the array will be greater than or equal to $x$?\n\nPlease note that the friends\
  \ you don't control may do their choice arbitrarily, and they will not necessarily\
  \ take the biggest element available.\n\n\n-----Input-----\n\nThe input consists\
  \ of multiple test cases. The first line contains a single integer $t$ ($1 \\le\
  \ t \\le 1000$)  — the number of test cases. The description of the test cases follows.\n\
  \nThe first line of each test case contains three space-separated integers $n$,\
  \ $m$ and $k$ ($1 \\le m \\le n \\le 3500$, $0 \\le k \\le n - 1$)  — the number\
  \ of elements in the array, your position in line and the number of people whose\
  \ choices you can fix.\n\nThe second line of each test case contains $n$ positive\
  \ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 10^9$)  — elements of the array.\n\
  \nIt is guaranteed that the sum of $n$ over all test cases does not exceed $3500$.\n\
  \n\n-----Output-----\n\nFor each test case, print the largest integer $x$ such that\
  \ you can guarantee to obtain at least $x$.\n\n\n-----Example-----\nInput\n4\n6\
  \ 4 2\n2 9 2 3 8 5\n4 4 1\n2 13 60 4\n4 1 3\n1 2 2 1\n2 2 0\n1 2\n\nOutput\n8\n\
  4\n1\n1\n\n\n\n-----Note-----\n\nIn the first test case, an optimal strategy is\
  \ to force the first person to take the last element and the second person to take\
  \ the first element.  the first person will take the last element ($5$) because\
  \ he or she was forced by you to take the last element. After this turn the remaining\
  \ array will be $[2, 9, 2, 3, 8]$;  the second person will take the first element\
  \ ($2$) because he or she was forced by you to take the first element. After this\
  \ turn the remaining array will be $[9, 2, 3, 8]$;  if the third person will choose\
  \ to take the first element ($9$), at your turn the remaining array will be $[2,\
  \ 3, 8]$ and you will take $8$ (the last element);  if the third person will choose\
  \ to take the last element ($8$), at your turn the remaining array will be $[9,\
  \ 2, 3]$ and you will take $9$ (the first element). \n\nThus, this strategy guarantees\
  \ to end up with at least $8$. We can prove that there is no strategy that guarantees\
  \ to end up with at least $9$. Hence, the answer is $8$.\n\nIn the second test case,\
  \ an optimal strategy is to force the first person to take the first element. Then,\
  \ in the worst case, both the second and the third person will take the first element:\
  \ you will end up with $4$."
"vc-preamble": "import Imports.AllImports\n\ndef solve (n m k : Nat) (arr : List Nat)\
  \ : Nat := sorry\n\ndef listMin (l : List Nat) : Nat :=\n  match l with\n  | []\
  \ => 0\n  | x::xs => List.foldl min x xs\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def listMax (l : List Nat) : Nat :=\n  match l with\n  | [] =>\
  \ 0\n  | x::xs => List.foldl max x xs\n"
"vc-theorems": "theorem solve_result_in_bounds {n m k : Nat} {arr : List Nat} \n \
  \ (h1 : arr.length ≥ m) (h2 : m ≤ n) (h3 : arr ≠ []) :\n  let result := solve n\
  \ m k arr\n  listMin arr ≤ result ∧ result ≤ listMax arr := sorry\n\n\ntheorem solve_k_zero\
  \ {n m : Nat} {arr : List Nat} \n  (h1 : arr.length ≥ m) (h2 : m ≤ n) :\n  solve\
  \ n m 0 arr = \n    listMin (List.map \n      (fun i => max (arr[i]!) (arr[arr.length\
  \ - i - 1]!))\n      (List.range m)) := sorry\n\n\ntheorem solve_k_large {n m k\
  \ : Nat} {arr : List Nat}\n  (h1 : arr.length ≥ m) (h2 : m ≤ n) (h3 : k ≥ m-1) (h4\
  \ : m > 0) :\n  solve n m k arr = \n    listMax (List.map \n      (fun i => max\
  \ (arr[i]!) (arr[arr.length - i - 1]!))\n      (List.range m)) := sorry\n\n\ntheorem\
  \ solve_empty_error {n m : Nat} :\n  solve n m 0 [] = 0 := sorry  \n\n\ntheorem\
  \ solve_negative_k {n m k : Nat} {arr : List Nat}\n  (h1 : arr.length ≥ m) (h2 :\
  \ m ≤ n) :\n  solve n m 0 arr = solve n m k arr := sorry\n\n\ntheorem solve_very_large_k\
  \ {n m k : Nat} {arr : List Nat}\n  (h1 : arr.length ≥ m) (h2 : m ≤ n) (h3 : k ≥\
  \ m-1) :\n  solve n m k arr = solve n m (m-1) arr := sorry\n\n/--\ninfo: 8\n-/\n\
  #guard_msgs in\n#eval solve 6 4 2 [2, 9, 2, 3, 8, 5]\n\n/--\ninfo: 4\n-/\n#guard_msgs\
  \ in\n#eval solve 4 4 1 [2, 13, 60, 4]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval\
  \ solve 4 1 3 [1, 2, 2, 1]\n"
"vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded"
