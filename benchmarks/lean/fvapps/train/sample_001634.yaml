"vc-description": "Once you complete this kata, there is a [15x15 Version](http://www.codewars.com/kata/15x15-nonogram-solver)\
  \ that you can try.\nAnd once you complete that, you can do the [Multisize Version](https://www.codewars.com/kata/5a5519858803853691000069)\
  \ which goes up to 50x50.\n\n# Description\n\nFor this kata, you will be making\
  \ a Nonogram solver. :)\n\nIf you don't know what Nonograms are, you can [look at\
  \ some instructions](https://www.puzzle-nonograms.com/faq.php) and also [try out\
  \ some Nonograms here.](https://www.puzzle-nonograms.com/)\n\nFor this kata, you\
  \ will only have to solve 5x5 Nonograms. :)\n\n# Instructions\n\nYou need to complete\
  \ the Nonogram class and the solve method:\n```python\nclass Nonogram:\n\n    def\
  \ __init__(self, clues):\n        pass\n\n    def solve(self):\n        pass\n```\n\
  \nYou will be given the clues and you should return the solved puzzle. All the puzzles\
  \ will be solveable so you will not need to worry about that.\n\n```if:python\n\
  The clues will be a tuple of the horizontal clues, then the vertical clues, which\
  \ will contain the individual clues. For example, for the Nonogram:\n```\n\n```if:java\n\
  The clues will be a three dimensional array of the horizontal clues, then the vertical\
  \ clues, which will contain the individual clues. For example, for the Nonogram:\n\
  ```\n\n```\n    |   |   | 1 |   |   |\n    | 1 |   | 1 |   |   |\n    | 1 | 4 |\
  \ 1 | 3 | 1 |\n-------------------------\n  1 |   |   |   |   |   |\n-------------------------\n\
  \  2 |   |   |   |   |   |\n-------------------------\n  3 |   |   |   |   |   |\n\
  -------------------------\n2 1 |   |   |   |   |   |\n-------------------------\n\
  \  4 |   |   |   |   |   |\n-------------------------\n```\nThe clues are on the\
  \ top and the left of the puzzle, so in this case:\n```if:python\nThe horizontal\
  \ clues are: `((1, 1), (4,), (1, 1, 1), (3,), (1,))`, and the vertical clues are:\
  \ `((1,), (2,), (3,), (2, 1), (4,))`. The horizontal clues are given from left to\
  \ right. If there is more than one clue for the same column, the upper clue is given\
  \ first. The vertical clues are given from top to bottom. If there is more than\
  \ one clue for the same row, the leftmost clue is given first.\n\nTherefore, the\
  \ clue given to the `__init__` method would be `(((1, 1), (4,), (1, 1, 1), (3,),\
  \ (1,)), ((1,), (2,), (3,), (2, 1), (4,)))`. You are given the horizontal clues\
  \ first then the vertical clues second.\n\n```\n\n```if:java\nThe horizontal clues\
  \ are: `{{1, 1}, {4}, {1, 1, 1}, {3}, {1}}`, and the vertical clues are: `{{1},\
  \ {2}, {3}, {2, 1}, {4}}`. The horizontal clues are given from left to right. If\
  \ there is more than one clue for the same column, the upper clue is given first.\
  \ The vertical clues are given from top to bottom. If there is more than one clue\
  \ for the same row, the leftmost clue is given first.\n\nTherefore, the clue given\
  \ to the `solve` method would be `{{{1, 1}, {4}, {1, 1, 1}, {3}, {1}},\n       \
  \             {{1}, {2}, {3}, {2, 1}, {4}}}`. You are given the horizontal clues\
  \ first then the vertical clues second.\n\n```\n\n```if:python\nYou should return\
  \ a tuple of the rows as your answer. In this case, the solved Nonogram looks like:\n\
  \n```\n```if:java\nYou should return a two-dimensional array as your answer. In\
  \ this case, the solved Nonogram looks like:\n\n```\n\n```\n    |   |   | 1 |  \
  \ |   |\n    | 1 |   | 1 |   |   |\n    | 1 | 4 | 1 | 3 | 1 |\n-------------------------\n\
  \  1 |   |   | # |   |   |\n-------------------------\n  2 | # | # |   |   |   |\n\
  -------------------------\n  3 |   | # | # | # |   |\n-------------------------\n\
  2 1 | # | # |   | # |   |\n-------------------------\n  4 |   | # | # | # | # |\n\
  -------------------------\n```\n\n```if:python\nIn the tuple, you should use 0 for\
  \ a unfilled square and 1 for a filled square. Therefore, in this case, you should\
  \ return:\n~~~\n((0, 0, 1, 0, 0),\n (1, 1, 0, 0, 0),\n (0, 1, 1, 1, 0),\n (1, 1,\
  \ 0, 1, 0),\n (0, 1, 1, 1, 1))\n~~~\n\n```\n\n```if:java\nIn the two-dimensional\
  \ array, you should use 0 for a unfilled square and 1 for a filled square. Therefore,\
  \ in this case, you should return:\n~~~\n{{0, 0, 1, 0, 0},\n {1, 1, 0, 0, 0},\n\
  \ {0, 1, 1, 1, 0},\n {1, 1, 0, 1, 0},\n {0, 1, 1, 1, 1}}\n~~~\n\n```\nGood Luck!!\n\
  \nIf there is anything that is unclear or confusing, just let me know :)"
"vc-preamble": "import Imports.AllImports\n\ndef find_min_index (lst : List Int) :\
  \ Int := sorry\ndef find_max_index (lst : List Int) : Int := sorry\n\ndef find_second_max\
  \ (lst : List Int) : Option Int := sorry\n\ndef minimum (lst : List Int) : Option\
  \ Int := lst.foldl (fun min x => match min with \n  | none => some x\n  | some m\
  \ => if x < m then some x else some m) none\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def maximum (lst : List Int) : Option Int := lst.foldl (fun max\
  \ x => match max with\n  | none => some x  \n  | some m => if x > m then some x\
  \ else some m) none\n"
"vc-theorems": "theorem min_index_empty (lst : List Int) : \n  lst = [] → find_min_index\
  \ lst = -1 := sorry\n\n\ntheorem min_index_valid (lst : List Int) (result : Int)\
  \ :\n  result = find_min_index lst → \n  result ≠ -1 →\n  (∃ min : Int, minimum\
  \ lst = some min ∧\n   0 ≤ result ∧ result < lst.length ∧\n   lst.get ⟨result.toNat,\
  \ sorry⟩ = min ∧\n   lst.count min = 1) := sorry\n\ntheorem min_index_duplicate\
  \ (lst : List Int) :\n  find_min_index lst = -1 →\n  lst ≠ [] →\n  (∃ min : Int,\
  \ minimum lst = some min ∧ lst.count min > 1) := sorry\n\n\ntheorem max_index_empty\
  \ (lst : List Int) :\n  lst = [] → find_max_index lst = -1 := sorry\n\n\ntheorem\
  \ max_index_valid (lst : List Int) (result : Int) :\n  result = find_max_index lst\
  \ →\n  result ≠ -1 →\n  (∃ max : Int, maximum lst = some max ∧\n   0 ≤ result ∧\
  \ result < lst.length ∧\n   lst.get ⟨result.toNat, sorry⟩ = max ∧\n   lst.count\
  \ max = 1) := sorry\n\ntheorem max_index_duplicate (lst : List Int) :\n  find_max_index\
  \ lst = -1 →\n  lst ≠ [] →\n  (∃ max : Int, maximum lst = some max ∧ lst.count max\
  \ > 1) := sorry\n\n\ntheorem second_max_short (lst : List Int) :\n  lst.length <\
  \ 2 → find_second_max lst = none := sorry\n\n\ntheorem second_max_valid (lst : List\
  \ Int) (result : Int) :\n  find_second_max lst = some result →\n  (∃ max : Int,\
  \ maximum lst = some max ∧\n   result < max ∧\n   (∀ x, x ∈ lst → ¬(result < x ∧\
  \ x < max)) ∧\n   result ∈ lst) := sorry\n\ntheorem second_max_none (lst : List\
  \ Int) :\n  find_second_max lst = none →\n  lst.length ≥ 2 →\n  (∃ x : Int, ∀ y\
  \ ∈ lst, y = x) := sorry\n\n\ntheorem results_from_input (lst : List Int) :\n  let\
  \ min_idx := find_min_index lst\n  let max_idx := find_max_index lst\n  let second\
  \ := find_second_max lst\n  (min_idx ≠ -1 → (∃ x, lst.get ⟨min_idx.toNat, sorry⟩\
  \ = x ∧ x ∈ lst)) ∧\n  (max_idx ≠ -1 → (∃ x, lst.get ⟨max_idx.toNat, sorry⟩ = x\
  \ ∧ x ∈ lst)) ∧\n  (second.isSome → (Option.get! second) ∈ lst) := sorry\n\n/--\n\
  info: 4\n-/\n#guard_msgs in\n#eval find_second_max [4, 1, 2, 3, 5]\n\n/--\ninfo:\
  \ None\n-/\n#guard_msgs in\n#eval find_second_max [1, 1, 1, 1, 1]\n\n/--\ninfo:\
  \ 2\n-/\n#guard_msgs in\n#eval find_second_max [1, 2, 3, 3]\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
