"vc-description": "The Quark Codejam's number QC(n, m) represents the number of ways\
  \ to partition a set of n things into m nonempty subsets. For example, there are\
  \ seven ways to split a four-element set into two parts:\n\n{1, 2, 3} ∪ {4}, {1,\
  \ 2, 4} ∪ {3}, {1, 3, 4} ∪ {2}, {2, 3, 4} ∪ {1},\n\n{1, 2} ∪ {3, 4}, {1, 3} ∪ {2,\
  \ 4}, {1, 4} ∪ {2, 3}.\n\nWe can compute QC(n, m) using the recurrence,\n\nQC(n,\
  \ m) = mQC(n − 1, m) + QC(n − 1, m − 1), for integers 1 < m < n.\n\nbut your task\
  \ is a somewhat different: given integers n and m, compute the parity of QC(n, m),\
  \ i.e. QC(n, m) mod 2.\n\nExample : \n\nQC(4, 2) mod 2 = 1. \nWrite a program that\
  \ reads two positive integers n and m, computes QC(n, m) mod 2, and writes the\n\
  \nresult.\n\n-----Input-----\nThe input begins with a single positive integer on\
  \ a line by itself indicating the number of the cases. This line is followed by\
  \ the input cases.\n\nThe input consists two integers n and m separated by a space,\
  \ with 1 ≤ m ≤ n ≤ 1000000000.\n\n-----Output-----\nFor each test case, print the\
  \ output.\n\nThe output should be the integer S(n, m) mod 2.\nSample Input\n1\n\n\
  4 2\nSample Output\n1"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def solve_QC_parity (n : Nat) (k : Nat) : Nat :=\n  sorry\n"
"vc-theorems": "theorem solve_QC_parity_binary (n k : Nat) (h : k ≤ n) :\n  solve_QC_parity\
  \ n k = 0 ∨ solve_QC_parity n k = 1 :=\n  sorry\n\n\ntheorem solve_QC_parity_single\
  \ (n : Nat) (h : n > 0) :\n  solve_QC_parity n 1 = 1 :=\n  sorry\n\n\ntheorem solve_QC_parity_full\
  \ (n : Nat) (h : n > 0) :\n  solve_QC_parity n n = 1 :=\n  sorry\n\n/--\ninfo: 1\n\
  -/\n#guard_msgs in\n#eval solve_QC_parity 4 2\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n\
  #eval solve_QC_parity 5 2\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_QC_parity\
  \ 6 3\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible"
