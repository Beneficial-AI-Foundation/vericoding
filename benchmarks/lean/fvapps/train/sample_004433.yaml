"vc-description": "The aim of the kata is to decompose `n!` (factorial n) into its\
  \ prime factors.\n\nExamples:\n```\nn = 12; decomp(12) -> \"2^10 * 3^5 * 5^2 * 7\
  \ * 11\"\nsince 12! is divisible by 2 ten times, by 3 five times, by 5 two times\
  \ and by 7 and 11 only once.\n\nn = 22; decomp(22) -> \"2^19 * 3^9 * 5^4 * 7^3 *\
  \ 11^2 * 13 * 17 * 19\"\n\nn = 25; decomp(25) -> 2^22 * 3^10 * 5^6 * 7^3 * 11^2\
  \ * 13 * 17 * 19 * 23\n```\n\nPrime numbers should be in increasing order. When\
  \ the exponent of a prime is 1 don't put the exponent.\n\nNotes\n\n- the function\
  \ is `decomp(n)` and should return the decomposition of `n!` into its prime factors\
  \ in increasing order of the primes, as a string.\n- factorial can be a very big\
  \ number (`4000! has 12674 digits`, n will go from 300 to 4000).\n- In Fortran -\
  \ as in any other language - the returned string is not permitted to contain any\
  \ redundant trailing whitespace: you can use `dynamically allocated character strings`."
"vc-preamble": "import Imports.AllImports\n\ndef dec (n : Nat) : List PrimeFactor\
  \ := sorry\n\ndef decomp (n : Nat) : String := sorry\n\n\ndef splitString (s : String)\
  \ (sep : String) : List String := sorry\ndef contains (s : String) (sub : String)\
  \ : Bool := sorry\n\ndef toNat! (s : String) : Nat := sorry\ndef sorted (l : List\
  \ Nat) : Bool := sorry"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def distinct (l : List Nat) : Bool := sorry\n\ntheorem dec_reconstruction\
  \ {n : Nat} (h : n ≥ 2) :\n  let factors := dec n\n  let reconstructed := factors.foldl\
  \ (fun acc f => acc * f.prime^f.power) 1\n  reconstructed = n := sorry \n"
"vc-theorems": "theorem dec_primes {n : Nat} (h : n ≥ 2) :\n  let factors := dec n\n\
  \  ∀ f ∈ factors, \n    ∀ i : Nat, 2 ≤ i → i * i ≤ f.prime → f.prime % i ≠ 0 :=\
  \ sorry\n\n\ntheorem decomp_format {n : Nat} (h : n ≥ 2) :\n  let result := decomp\
  \ n\n  let factors := splitString result \" * \"\n  ∀ f ∈ factors, \n    (contains\
  \ f \"^\" → \n      let parts := splitString f \"^\"\n      (parts.length = 2) ∧\
  \ \n      let base := parts.head!\n      let power := parts.get! 1\n      toNat!\
  \ base > 0 ∧ toNat! power > 0) ∧\n    (¬contains f \"^\" → toNat! f > 0) := sorry\n\
  \n\ntheorem decomp_ascending {n : Nat} (h : n ≥ 2) :\n  let result := decomp n\n\
  \  let factors := splitString result \" * \"\n  let bases := factors.map (fun f\
  \ => \n    if contains f \"^\" \n    then toNat! (splitString f \"^\").head!\n \
  \   else toNat! f)\n  sorted bases := sorry\n\n\ntheorem decomp_unique {n : Nat}\
  \ (h : n ≥ 2) :\n  let result := decomp n\n  let factors := splitString result \"\
  \ * \"\n  let bases := factors.map (fun f => \n    if contains f \"^\" \n    then\
  \ toNat! (splitString f \"^\").head!\n    else toNat! f)\n  distinct bases := sorry"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
