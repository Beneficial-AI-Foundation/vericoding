"vc-description": "Given an absolute path for a file (Unix-style), simplify it.\n\n\
  For example,\npath = \"/home/\", => \"/home\"\npath = \"/a/./b/../../c/\", => \"\
  /c\"\n\nCorner Cases:\n\n\n       Did you consider the case where path = \"/../\"\
  ?\n       In this case, you should return \"/\".\n       Another corner case is\
  \ the path might contain multiple slashes '/' together, such as \"/home//foo/\"\
  .\n       In this case, you should ignore redundant slashes and return \"/home/foo\"\
  ."
"vc-preamble": "import Imports.AllImports\n\ndef simplify_path (s : String) : String\
  \ := sorry\n\ndef is_valid_path_segment (s : String) : Bool := sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def splitString (s : String) (c : Char) : List String := sorry\n\
  \ntheorem dot_references_resolve \n  {segments : List String}\n  (valid_segs : ∀\
  \ s ∈ segments, s = \".\" ∨ s = \"..\" ∨ is_valid_path_segment s) :\n  let path\
  \ := \"/\" ++ String.intercalate \"/\" segments\n  let result := simplify_path path\n\
  \  result.startsWith \"/\" ∧ \".\" ∉ splitString result '/'\n  := sorry\n"
"vc-theorems": "theorem redundant_slashes\n  (slashes : String)\n  (h : ∀ c ∈ slashes.toList,\
  \ c = '/') : \n  simplify_path slashes = \"/\"\n  := sorry\n\n\ntheorem idempotent\n\
  \  {segments : List String}\n  (valid_segs : ∀ s ∈ segments, is_valid_path_segment\
  \ s) :\n  let path := \"/\" ++ String.intercalate \"/\" segments\n  let once :=\
  \ simplify_path path\n  simplify_path once = once\n  := sorry\n\n\ntheorem root_path\
  \ :\n  simplify_path \"/\" = \"/\"\n  := sorry\n\n/--\ninfo: '/home'\n-/\n#guard_msgs\
  \ in\n#eval simplify_path \"/home/\"\n\n/--\ninfo: '/c'\n-/\n#guard_msgs in\n#eval\
  \ simplify_path \"/a/./b/../../c/\"\n\n/--\ninfo: '/home/foo'\n-/\n#guard_msgs in\n\
  #eval simplify_path \"/home//foo/\"\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
