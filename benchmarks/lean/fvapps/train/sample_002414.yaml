"vc-description": "Given an integer array, you need to find one continuous subarray\
  \ that if you only sort this subarray in ascending order, then the whole array will\
  \ be sorted in ascending order, too.  \n\nYou need to find the shortest such subarray\
  \ and output its length.\n\nExample 1:\n\nInput: [2, 6, 4, 8, 10, 9, 15]\nOutput:\
  \ 5\nExplanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the\
  \ whole array sorted in ascending order.\n\n\n\nNote:\n\nThen length of the input\
  \ array is in range [1, 10,000].\nThe input array may contain duplicates, so ascending\
  \ order here means ."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def find_unsorted_subarray (nums : List Int) : Nat := sorry\n\n\
  theorem empty_or_single_element_list \n  (nums : List Int) (h : nums.length ≤ 1)\
  \ : \n  find_unsorted_subarray nums = 0 := sorry\n"
"vc-theorems": "theorem sorted_list_returns_zero \n  (nums : List Int) \n  (h : ∀\
  \ (i j : Fin nums.length), i.val < j.val → nums[i] ≤ nums[j]) :\n  find_unsorted_subarray\
  \ nums = 0 := sorry\n\n\ntheorem reverse_sorted_list \n  (nums : List Int) \n  (h1\
  \ : nums.length ≥ 2)\n  (h2 : ∀ (i j : Fin nums.length), i.val < j.val → nums[i]\
  \ ≥ nums[j])\n  (h3 : ∃ (i j : Fin nums.length), nums[i] > nums[j]) :\n  find_unsorted_subarray\
  \ nums = nums.length := sorry\n\n\ntheorem result_length_bounds\n  (nums : List\
  \ Int) \n  (h : nums.length ≥ 3) :\n  0 ≤ find_unsorted_subarray nums ∧ find_unsorted_subarray\
  \ nums ≤ nums.length := sorry\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval find_unsorted_subarray\
  \ [2, 6, 4, 8, 10, 9, 15]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval find_unsorted_subarray\
  \ [1, 2, 3, 4, 5]\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval find_unsorted_subarray\
  \ [5, 4, 3, 2, 1]\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
