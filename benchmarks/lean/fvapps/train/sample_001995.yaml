"vc-description": "You are given n strings s_1, s_2, ..., s_{n} consisting of characters\
  \ 0 and 1. m operations are performed, on each of them you concatenate two existing\
  \ strings into a new one. On the i-th operation the concatenation s_{a}_{i}s_{b}_{i}\
  \ is saved into a new string s_{n} + i (the operations are numbered starting from\
  \ 1). After each operation you need to find the maximum positive integer k such\
  \ that all possible strings consisting of 0 and 1 of length k (there are 2^{k} such\
  \ strings) are substrings of the new string. If there is no such k, print 0.\n\n\
  \n-----Input-----\n\nThe first line contains single integer n (1 ≤ n ≤ 100) — the\
  \ number of strings. The next n lines contain strings s_1, s_2, ..., s_{n} (1 ≤\
  \ |s_{i}| ≤ 100), one per line. The total length of strings is not greater than\
  \ 100.\n\nThe next line contains single integer m (1 ≤ m ≤ 100) — the number of\
  \ operations. m lines follow, each of them contains two integers a_{i} abd b_{i}\
  \ (1 ≤ a_{i}, b_{i} ≤ n + i - 1) — the number of strings that are concatenated to\
  \ form s_{n} + i.\n\n\n-----Output-----\n\nPrint m lines, each should contain one\
  \ integer — the answer to the question after the corresponding operation.\n\n\n\
  -----Example-----\nInput\n5\n01\n10\n101\n11111\n0\n3\n1 2\n6 5\n4 4\n\nOutput\n\
  1\n2\n0\n\n\n\n-----Note-----\n\nOn the first operation, a new string \"0110\" is\
  \ created. For k = 1 the two possible binary strings of length k are \"0\" and \"\
  1\", they are substrings of the new string. For k = 2 and greater there exist strings\
  \ of length k that do not appear in this string (for k = 2 such string is \"00\"\
  ). So the answer is 1.\n\nOn the second operation the string \"01100\" is created.\
  \ Now all strings of length k = 2 are present.\n\nOn the third operation the string\
  \ \"1111111111\" is created. There is no zero, so the answer is 0."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def BinaryString := String\n\ndef solve_binary_string_concat (strings\
  \ : List BinaryString) (operations : List (Nat × Nat)) : List Nat := sorry\n"
"vc-theorems": "theorem solve_binary_string_concat_basic_properties \n  (strings :\
  \ List BinaryString) \n  (operations : List (Nat × Nat))\n  (h1 : strings.length\
  \ ≥ 2)\n  (h2 : strings.length ≤ 5) \n  (h3 : operations.length ≥ 1)\n  (h4 : operations.length\
  \ ≤ 3)\n  (h5 : ∀ s ∈ strings, s.length ≥ 1)\n  (h6 : ∀ s ∈ strings, s.length ≤\
  \ 20)\n  (h7 : ∀ s ∈ strings, ∀ c ∈ s.data, c = '0' ∨ c = '1')\n  (h8 : ∀ op ∈ operations,\
  \ op.1 ≥ 1 ∧ op.1 ≤ strings.length ∧ op.2 ≥ 1 ∧ op.2 ≤ strings.length) :\n  let\
  \ result := solve_binary_string_concat strings operations\n  (∀ x ∈ result, x ≥\
  \ 0) ∧\n  (result.length = operations.length) ∧\n  (∀ x ∈ result, x ≤ 20) := sorry\n\
  \n\ntheorem solve_binary_string_concat_all_zeros\n  (strings : List BinaryString)\n\
  \  (h1 : strings.length ≥ 2)\n  (h2 : strings.length ≤ 5)\n  (h3 : ∀ s ∈ strings,\
  \ s = \"0\") :\n  solve_binary_string_concat strings [(1,2)] = [0] := sorry\n\n\n\
  theorem solve_binary_string_concat_all_ones\n  (strings : List BinaryString)\n \
  \ (h1 : strings.length ≥ 2)\n  (h2 : strings.length ≤ 5)\n  (h3 : ∀ s ∈ strings,\
  \ s = \"1\") :\n  solve_binary_string_concat strings [(1,2)] = [0] := sorry\n\n\
  /--\ninfo: [1, 2, 0]\n-/\n#guard_msgs in\n#eval solve_binary_string_concat [\"01\"\
  , \"10\", \"101\", \"11111\", \"0\"] [(1, 2), (6, 5), (4, 4)]\n\n/--\ninfo: [1,\
  \ 1, 1, 2, 1, 2]\n-/\n#guard_msgs in\n#eval solve_binary_string_concat [\"01\",\
  \ \"1\", \"0011\", \"0\", \"01\"] [(5, 5), (3, 2), (4, 2), (6, 7), (5, 1), (9, 7)]\n\
  \n/--\ninfo: [1]\n-/\n#guard_msgs in\n#eval solve_binary_string_concat [\"0\", \"\
  1\"] [(1, 2)]\n"
"vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded"
