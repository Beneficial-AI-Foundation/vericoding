"vc-description": "This Kata is a continuation of [Part 1](http://www.codewars.com/kata/the-fusc-function-part-1).\
  \ The `fusc` function is defined recursively as follows:\n\n    fusc(0) = 0\n  \
  \  fusc(1) = 1\n    fusc(2n) = fusc(n)\n    fusc(2n + 1) = fusc(n) + fusc(n + 1)\n\
  \    \nYour job is to produce the code for the `fusc` function. In this kata, your\
  \ function will be tested with large values of `n` more than 1000 bits (in JS and\
  \ PHP: at most 52 bits), so you should be concerned about stack overflow and timeouts.\n\
  \nMethod suggestion:\n\nImagine that instead of `fusc(n)`, you were to implement\
  \ `fib(n)`, which returns the n'th Fibonacci number.\n\nThe function is recursively\
  \ defined by:\n\n```\n1.    fib(0) = 1\n2.    fib(1) = 1\n3.    fib(n + 2) = fib(n)\
  \ + fib(n + 1), if n + 2 > 1\n```\nIf one translates the above definition directly\
  \ into a recursive function, the result is not very efficient. One can try memoization,\
  \ but that requires lots of space and is not necessary. So, first step is to try\
  \ and find a _tail recursive_ definition. In order to do that we try to write both\
  \ sides of equation 3) on the same form. Currently, the left side of the equation\
  \ contains a single term, whereas the right side is the sum of two terms. A first\
  \ attempt is to add `fib(n + 1)` to both sides of the equation:\n```\n3.    fib(n\
  \ + 1) + fib(n + 2) = fib(n) + 2 * fib(n + 1)\n```\nThe two sides of the equation\
  \ look much more alike, but there is still an essential difference, which is the\
  \ coefficient of the second term of each side. On the left side of the equation,\
  \ it is `1`  and, on the right, it is `2`. To remedy this, we can introduce a variable\
  \ `b`:\n```\n3.    fib(n + 1) + b * fib(n + 2) = b * fib(n) + (b + 1) * fib(n +\
  \ 1)\n```\nWe notice that the coefficients of the first term are not the same (`1`\
  \ on the left and `b` on the right), so we introduce a variable `a`:\n```\n3.  \
  \  a * fib(n + 1) + b * fib(n + 2) = b * fib(n) + (a + b) * fib(n + 1)\n```\nNow\
  \ the two sides have the same form (call it `F`), which we can define as: \n\n```F(a,\
  \ b, n) = a * fib(n) + b * fib(n + 1)```\n\nIn fact, we can write equation 3) as:\n\
  ```\n3.    F(a, b, n + 1) = F(b, a + b, n)\n```\nWe also have, by definition of\
  \ `F` and `fib`:\n```\n4.    F(a, b, 0) = a * fib(0) + b * fib(1) = a + b\n```\n\
  Also, by definition of `F`: \n```\n5.    fib(n) = F(1, 0, n)\n```\n\nThe next step\
  \ is to translate the above into code:\n```\ndef fib(n):\n\n    def F(a, b, n):\n\
  \        if n == 0: return a + b    # see 4. above\n        return F(b, a + b, n\
  \ - 1)  # see 3. above\n\n    return F(1, 0, n)              # see 5. above\n```\n\
  \nThe final step (optional for languages that support tail call optimization) is\
  \ to replace the tail recursive function `F` with a loop:\n```\ndef fib(n):\n  \
  \  a, b = 1, 0                    # see 5. above\n    while n > 0:\n        a, b,\
  \ n = b, a + b, n - 1  # see 3. above\n    return a + b .                 # see\
  \ 4. above\n```\nVoila! Now, go do the same with `fusc`."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def fusc (n : Nat) : Nat := sorry\n\n@[simp]"
"vc-theorems": "theorem fusc_zero : fusc 0 = 0 := sorry\n\n@[simp] \n\ntheorem fusc_one\
  \ : fusc 1 = 1 := sorry\n\ntheorem fusc_non_negative (n : Nat) : \n  fusc n â‰¥ 0\
  \ := sorry\n\n\ntheorem fusc_double (n : Nat) :\n  fusc (2 * n) = fusc n := sorry\
  \ \n\n\ntheorem fusc_odd (n : Nat) :\n  fusc (2 * n + 1) = fusc n + fusc (n + 1)\
  \ := sorry\n\n\ntheorem fusc_consecutive_coprime (n : Nat) :\n  Nat.gcd (fusc n)\
  \ (fusc (n + 1)) = 1 := sorry\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval fusc 0\n\
  \n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval fusc 1\n\n/--\ninfo: 21\n-/\n#guard_msgs\
  \ in\n#eval fusc 85\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible"
