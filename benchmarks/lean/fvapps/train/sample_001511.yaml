"vc-description": "A matrix B (consisting of integers) of dimension N × N is said\
  \ to be good if there exists an array A (consisting of integers) such that B[i][j]\
  \  = |A[i] - A[j]|, where |x| denotes absolute value of integer x.\nYou are given\
  \ a partially filled matrix B of dimension N × N. Q of the entries of this matrix\
  \ are filled by either 0 or 1. You have to identify whether it is possible to fill\
  \ the remaining entries of matrix B (the entries can be filled by any integer, not\
  \ necessarily by 0 or 1) such that the resulting fully filled matrix B is good.\n\
  \n-----Input-----\nThe first line of the input contains an integer T denoting the\
  \ number of test cases. \nThe first line of each test case contains two space separated\
  \ integers N, Q.\nEach of the next Q lines contain three space separated integers\
  \ i, j, val, which means that B[i][j] is filled with value val.\n\n-----Output-----\n\
  For each test case, output \"yes\" or \"no\" (without quotes) in a single line corresponding\
  \ to the answer of the problem.\n\n-----Constraints-----\n- 1 ≤ T ≤ 106\n- 2 ≤ N\
  \ ≤ 105\n- 1 ≤ Q ≤ 106\n- 1 ≤ i, j ≤ N\n- 0 ≤ val ≤ 1\n- Sum of each of N, Q over\
  \ all test cases doesn't exceed 106\n\n-----Subtasks-----\n- Subtask #1 (40 points)\
  \ 2 ≤ N ≤ 103, 1 ≤ Q ≤ 103, Sum of each of N, Q over all test cases doesn't exceed\
  \ 104\n- Subtask #2 (60 points) Original Constraints\n\n-----Example-----\nInput\n\
  4\n2 2\n1 1 0\n1 2 1\n2 3\n1 1 0\n1 2 1\n2 1 0\n3 2\n2 2 0\n2 3 1\n3 3\n1 2 1\n\
  2 3 1\n1 3 1\n\nOutput\nyes\nno\nyes\nno\n\n-----Explanation-----\nExample 1. You\
  \ can fill the entries of matrix B as follows. \n\n0 1\n1 0\nThis matrix corresponds\
  \ to the array A = [1, 2].\n\nExample 2. It is impossible to fill the remaining\
  \ entries of matrix B such that the resulting matrix is good, as B[1][2] = 1 and\
  \ B[2][1] = 0, which is impossible."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def checkGoodMatrix (n : Nat) (entries : List (Nat × Nat × Nat))\
  \ : String := sorry \n\ntheorem check_good_matrix_result_is_yes_or_no (n : Nat)\
  \ (entries : List (Nat × Nat × Nat)) : \n  let result := checkGoodMatrix n entries\n\
  \  result = \"yes\" ∨ result = \"no\" := sorry\n"
"vc-theorems": "theorem empty_matrix_is_good (n : Nat) :\n  checkGoodMatrix n [] =\
  \ \"yes\" := sorry\n\n\ntheorem self_zero_entries_valid (n i : Nat) (h : i ≤ n)\
  \ :\n  checkGoodMatrix n [(i, i, 0)] = \"yes\" := sorry\n\n\ntheorem self_one_entries_invalid\
  \ (n i : Nat) (h : i ≤ n) :\n  checkGoodMatrix n [(i, i, 1)] = \"no\" := sorry\n\
  \n\ntheorem symmetric_entries_zero_valid (n : Nat) (h : n ≥ 2) :\n  checkGoodMatrix\
  \ n [(1, 2, 0), (2, 1, 0)] = \"yes\" := sorry\n\n\ntheorem symmetric_entries_one_invalid\
  \ (n : Nat) (h : n ≥ 2) :\n  checkGoodMatrix n [(1, 2, 1), (2, 1, 0)] = \"no\" :=\
  \ sorry\n\n/--\ninfo: 'yes'\n-/\n#guard_msgs in\n#eval check_good_matrix 2 [[1,\
  \ 1, 0], [1, 2, 1]]\n\n/--\ninfo: 'no'\n-/\n#guard_msgs in\n#eval check_good_matrix\
  \ 2 [[1, 1, 0], [1, 2, 1], [2, 1, 0]]\n\n/--\ninfo: 'yes'\n-/\n#guard_msgs in\n\
  #eval check_good_matrix 3 [[2, 2, 0], [2, 3, 1]]\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
