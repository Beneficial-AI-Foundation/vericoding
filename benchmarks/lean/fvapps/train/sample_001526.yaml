"vc-description": "Devu loves to play with his dear mouse Jerry.  One day they play\
  \ a game on 2 dimensional grid of dimensions n * n (n ≥ 2). Jerry is currently at\
  \ coordinates (sx, sy) and wants to move to location (ex, ey) where cheese is placed\
  \ by Devu. Also Devu is very cunning and has placed a bomb at location (bx, by).\
  \ All these three locations are distinct. \n\nIn a single move, Jerry can go either\
  \ up, down, left or right in the grid such that it never goes out of the grid. Also,\
  \ it has to avoid the bomb. Find out minimum number of moves Jerry needs. It is\
  \ guaranteed that it is always possible to do so.\n\n-----Input-----\n- The first\
  \ line of the input contains an integer T denoting the number of test cases. The\
  \ description of T test cases follows.\"\n- The first line of each test case contains\
  \ seven space separated integers n, sx, sy , ex, ey, bx, by. \n\n-----Output-----\n\
  - For each test case, output a single line containing an integer corresponding to\
  \ minimum number of moves Jerry needs.\n\n-----Constraints-----\n- 1 ≤ T ≤ 1000\n\
  - 2 ≤ n ≤ 20\n-  1 ≤ sx, sy , ex, ey, bx, by ≤ n \n- No two or more poitns in the\
  \ three points are same.\n\n-----Example-----\nInput:\n2\n2 1 1 2 2 1 2\n3 1 1 1\
  \ 3 1 2\n\nOutput:\n2\n4\n\n-----Explanation-----\nExample case 1. ...\nJerry will\
  \ move directly (1, 1) to (2, 1) and then to (2, 2) in total 2 moves.\n\nExample\
  \ case 2. ..."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def abs (x : Int) : Int := if x < 0 then -x else x\n\ndef min_moves_to_cheese\
  \ (n : Int) (sx sy ex ey blockx blocky : Int) : Int := sorry\n"
"vc-theorems": "theorem min_moves_manhattan_lower_bound \n  (n : Int) (sx sy ex ey\
  \ blockx blocky : Int)\n  (h1 : n ≥ 2) (h2 : sx ≥ 1) (h3 : sy ≥ 1) (h4 : ex ≥ 1)\
  \ (h5 : ey ≥ 1) \n  (h6 : blockx ≥ 1) (h7 : blocky ≥ 1)\n  (h8 : sx ≤ 100) (h9 :\
  \ sy ≤ 100) (h10 : ex ≤ 100) (h11 : ey ≤ 100)\n  (h12 : blockx ≤ 100) (h13 : blocky\
  \ ≤ 100) :\n  min_moves_to_cheese n sx sy ex ey blockx blocky ≥ (abs (sx - ex) +\
  \ abs (sy - ey)) := sorry\n\n\ntheorem min_moves_manhattan_upper_bound\n  (n : Int)\
  \ (sx sy ex ey blockx blocky : Int)\n  (h1 : n ≥ 2) (h2 : sx ≥ 1) (h3 : sy ≥ 1)\
  \ (h4 : ex ≥ 1) (h5 : ey ≥ 1)\n  (h6 : blockx ≥ 1) (h7 : blocky ≥ 1)\n  (h8 : sx\
  \ ≤ 100) (h9 : sy ≤ 100) (h10 : ex ≤ 100) (h11 : ey ≤ 100)\n  (h12 : blockx ≤ 100)\
  \ (h13 : blocky ≤ 100) :\n  min_moves_to_cheese n sx sy ex ey blockx blocky ≤ (abs\
  \ (sx - ex) + abs (sy - ey) + 2) := sorry\n\n\ntheorem max_detour_implies_blocked_path\n\
  \  (n : Int) (sx sy ex ey blockx blocky : Int)\n  (h1 : n ≥ 2) (h2 : sx ≥ 1) (h3\
  \ : sy ≥ 1) (h4 : ex ≥ 1) (h5 : ey ≥ 1)\n  (h6 : blockx ≥ 1) (h7 : blocky ≥ 1)\n\
  \  (h8 : sx ≤ 100) (h9 : sy ≤ 100) (h10 : ex ≤ 100) (h11 : ey ≤ 100)\n  (h12 : blockx\
  \ ≤ 100) (h13 : blocky ≤ 100)\n  (h14 : min_moves_to_cheese n sx sy ex ey blockx\
  \ blocky = abs (sx - ex) + abs (sy - ey) + 2) :\n  ((sx = ex ∧ ex = blockx ∧ min\
  \ sy ey < blocky ∧ blocky < max sy ey) ∨\n   (sy = ey ∧ ey = blocky ∧ min sx ex\
  \ < blockx ∧ blockx < max sx ex)) := sorry\n\n\ntheorem diagonal_manhattan_distance\n\
  \  (n : Int) (sx sy ex ey : Int)\n  (h1 : n ≥ 2) (h2 : sx ≥ 1) (h3 : sy ≥ 1) (h4\
  \ : ex ≥ 1) (h5 : ey ≥ 1)\n  (h6 : sx ≤ 100) (h7 : sy ≤ 100) (h8 : ex ≤ 100) (h9\
  \ : ey ≤ 100)\n  (h10 : sx ≠ ex) (h11 : sy ≠ ey) :\n  min_moves_to_cheese n sx sy\
  \ ex ey 1 1 = abs (sx - ex) + abs (sy - ey) := sorry\n\n/--\ninfo: 2\n-/\n#guard_msgs\
  \ in\n#eval min_moves_to_cheese 2 1 1 2 2 1 2\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n\
  #eval min_moves_to_cheese 3 1 1 1 3 1 2\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval\
  \ min_moves_to_cheese 4 1 1 4 1 2 1\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded"
