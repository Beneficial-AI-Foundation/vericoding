"vc-description": "In Scala, an underscore may be used to create a partially applied\
  \ version of an infix operator using placeholder syntax. For example, `(_ * 3)`\
  \ is a function that multiplies its input by 3. With a bit of manipulation, this\
  \ idea can be extended to work on any arbitrary expression.\n\nCreate an value/object\
  \ named `x` that acts as a placeholder in an arithmetic expression. The placeholder\
  \ should support the four basic integer arithmetic operations: addition, subtraction,\
  \ multiplication, and integral (floor) division. When the expression with placeholders\
  \ is called, it should fill the placeholders in the expression from left to right\
  \ (regardless of operator precedence) with the values it is given.\n\nHere are a\
  \ few examples:\n```\ncalling (x + 3)       with [1]   gives 1 + 3             \
  \  = 4\ncalling (10 - x)      with [4]   gives 10 - 4              = 6\ncalling\
  \ (x + 2 * x)   with [1 3] gives 1 + 2 * 3   = 1 + 6 = 7\ncalling ((x + 2) * x)\
  \ with [1 3] gives (1 + 2) * 3 = 3 * 3 = 9\ncalling (4 * (x / 2)) with [5]   gives\
  \ 4 * (5 / 2) = 4 * 2 = 8\n```\n\nAll inputs and outputs to/from the expression\
  \ will be integer types. All expressions tested in this kata will be valid, i.e.\
  \ there will be no division by zero and the number of values passed in will always\
  \ be the same as the number of placeholders.\n\nNote: `eval` and `exec` are disabled"
"vc-preamble": "import Imports.AllImports\n\ndef x : List Int → Int := sorry\n\ndef\
  \ add : Int → Int → Int := fun a b => a + b\n\n\ndef sub : Int → Int → Int := fun\
  \ a b => a - b\n\ndef mul : Int → Int → Int := fun a b => a * b\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def div : Int → Int → Int := fun a b => a / b\n\naxiom placeholder_identity\
  \ (args : List Int) (h : args.length > 0) :\n  x args = args.head!\n\naxiom placeholder_binary_ops_forward\
  \ (a b : Int) :\n  (add (x [a]) b) = add a b ∧\n  (sub (x [a]) b) = sub a b ∧ \n\
  \  (mul (x [a]) b) = mul a b\n\naxiom placeholder_binary_ops_reverse (a b : Int)\
  \ :\n  add b (x [a]) = add b a ∧\n  sub b (x [a]) = sub b a ∧\n  mul b (x [a]) =\
  \ mul b a\n\naxiom placeholder_binary_ops_div (a b : Int) :\n  b ≠ 0 → div (x [a])\
  \ b = div a b\n\naxiom placeholder_binary_ops_div_reverse (a b : Int) :\n  a ≠ 0\
  \ → div b (x [a]) = div b a\n\naxiom placeholder_chaining (args : List Int) (h :\
  \ args.length > 1) :\n  add (x [args.head!]) (x [args.tail.head!]) = add args.head!\
  \ args.tail.head! ∧\n  mul (x [args.head!]) (x [args.tail.head!]) = mul args.head!\
  \ args.tail.head! ∧ \n  add (x [args.head!]) (mul 2 (x [args.tail.head!])) = add\
  \ args.head! (mul 2 args.tail.head!)\n\naxiom placeholder_constant_folding (a :\
  \ Int) :\n  add (add 2 3) (x [a]) = add 5 a ∧\n  add (mul 2 3) (x [a]) = add 6 a"
"vc-theorems": ""
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
