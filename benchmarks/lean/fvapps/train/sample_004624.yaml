"vc-description": "A list of integers is sorted in “Wave” order if alternate items\
  \ are not less than their immediate neighbors (thus the other alternate items are\
  \ not greater than their immediate neighbors).\n\nThus, the array `[4, 1, 7, 5,\
  \ 6, 2, 3]` is in **Wave** order because 4 >= 1, then 1 <= 7, then 7 >= 5, then\
  \ 5 <= 6, then 6 >= 2, and finally 2 <= 3.\n\nThe wave-sorted lists has to begin\
  \ with an element not less than the next, so `[1, 4, 5, 3]` is not sorted in Wave\
  \ because 1 < 4\n\nYour task is to implement a function that takes a list of integers\
  \ and sorts it into wave order in place; your function shouldn't return anything.\n\
  \nNote:\n- The resulting array shouldn't necessarily match anyone in the tests,\
  \ a function just checks if the array is now wave sorted."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def waveSort (arr : List Int) : List Int := sorry\n\ndef isWaveSorted\
  \ (arr : List Int) : Bool := sorry\n"
"vc-theorems": "theorem waveSort_preservation (arr : List Int) :\n  let result :=\
  \ waveSort arr\n  List.length result = List.length arr ∧ \n  result.toArray = arr.toArray\
  \ ∧ \n  isWaveSorted result := sorry\n\n\ntheorem waveSort_alternating (arr : List\
  \ Int) :\n  arr.length ≥ 2 →\n  let result := waveSort arr\n  ∀ i, 1 ≤ i → i < result.length\
  \ → i % 2 = 1 →\n    (result[i]! ≤ result[i-1]! ∧\n     (i + 1 < result.length →\
  \ result[i]! ≤ result[i+1]!)) := sorry\n\n\ntheorem waveSort_small_arrays (arr :\
  \ List Int) :\n  arr.length ≤ 1 →\n  waveSort arr = arr := sorry"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
