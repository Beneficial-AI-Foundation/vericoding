"vc-description": "A move consists of taking a point (x, y) and transforming it to\
  \ either (x, x+y) or (x+y, y).\n\nGiven a starting point (sx, sy) and a target point\
  \ (tx, ty), return True if and only if a sequence of moves exists to transform the\
  \ point (sx, sy) to (tx, ty). Otherwise, return False.\n\n\nExamples:\nInput: sx\
  \ = 1, sy = 1, tx = 3, ty = 5\nOutput: True\nExplanation:\nOne series of moves that\
  \ transforms the starting point to the target is:\n(1, 1) -> (1, 2)\n(1, 2) -> (3,\
  \ 2)\n(3, 2) -> (3, 5)\n\nInput: sx = 1, sy = 1, tx = 2, ty = 2\nOutput: False\n\
  \nInput: sx = 1, sy = 1, tx = 1, ty = 1\nOutput: True\n\n\n\nNote:\n\n\n       sx,\
  \ sy, tx, ty will all be integers in the range [1, 10^9]."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def can_transform_point (sx sy tx ty : Nat) : Bool := sorry \n\n\
  theorem same_point_always_true {sx sy : Nat} : \n  can_transform_point sx sy sx\
  \ sy = true := sorry\n"
"vc-theorems": "theorem target_less_than_start_always_false {sx sy tx ty : Nat} :\n\
  \  (tx < sx ∨ ty < sy) → can_transform_point sx sy tx ty = false := sorry\n\n\n\
  theorem no_valid_moves_if_too_far {sx sy tx ty : Nat} :\n  (sx > tx ∧ sy > ty) →\
  \ can_transform_point sx sy tx ty = false := sorry\n\n/--\ninfo: True\n-/\n#guard_msgs\
  \ in\n#eval can_transform_point 1 1 3 5\n\n/--\ninfo: False\n-/\n#guard_msgs in\n\
  #eval can_transform_point 1 1 2 2\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval\
  \ can_transform_point 1 1 1 1\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
