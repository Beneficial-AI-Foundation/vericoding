"vc-description": "This is an easier version of the next problem. In this version,\
  \ $q = 0$.\n\nA sequence of integers is called nice if its elements are arranged\
  \ in blocks like in $[3, 3, 3, 4, 1, 1]$. Formally, if two elements are equal, everything\
  \ in between must also be equal.\n\nLet's define difficulty of a sequence as a minimum\
  \ possible number of elements to change to get a nice sequence. However, if you\
  \ change at least one element of value $x$ to value $y$, you must also change all\
  \ other elements of value $x$ into $y$ as well. For example, for $[3, 3, 1, 3, 2,\
  \ 1, 2]$ it isn't allowed to change first $1$ to $3$ and second $1$ to $2$. You\
  \ need to leave $1$'s untouched or change them to the same value.\n\nYou are given\
  \ a sequence of integers $a_1, a_2, \\ldots, a_n$ and $q$ updates.\n\nEach update\
  \ is of form \"$i$ $x$\" — change $a_i$ to $x$. Updates are not independent (the\
  \ change stays for the future).\n\nPrint the difficulty of the initial sequence\
  \ and of the sequence after every update.\n\n\n-----Input-----\n\nThe first line\
  \ contains integers $n$ and $q$ ($1 \\le n \\le 200\\,000$, $q = 0$), the length\
  \ of the sequence and the number of the updates.\n\nThe second line contains $n$\
  \ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le 200\\,000$), the initial sequence.\n\
  \nEach of the following $q$ lines contains integers $i_t$ and $x_t$ ($1 \\le i_t\
  \ \\le n$, $1 \\le x_t \\le 200\\,000$), the position and the new value for this\
  \ position.\n\n\n-----Output-----\n\nPrint $q+1$ integers, the answer for the initial\
  \ sequence and the answer after every update.\n\n\n-----Examples-----\nInput\n5\
  \ 0\n3 7 3 7 3\n\nOutput\n2\n\nInput\n10 0\n1 2 1 2 3 1 1 1 50 1\n\nOutput\n4\n\n\
  Input\n6 0\n6 6 3 3 4 4\n\nOutput\n0\n\nInput\n7 0\n3 3 1 3 2 1 2\n\nOutput\n4"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def find_min_changes (arr : List Nat) : Nat :=\nsorry\n"
"vc-theorems": "theorem output_bounds {arr : List Nat} : \n  0 ≤ find_min_changes\
  \ arr ∧ find_min_changes arr ≤ arr.length :=\nsorry\n\n\ntheorem identical_elements\
  \ {n : Nat} {arr : List Nat} : \n  arr = List.replicate arr.length n → find_min_changes\
  \ arr = 0 :=\nsorry \n\n\ntheorem increasing_sequence {arr : List Nat} :\n  let\
  \ sorted_unique := arr.eraseDups\n  find_min_changes sorted_unique ≤ sorted_unique.length\
  \ - 1 :=\nsorry\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval find_min_changes [3,\
  \ 7, 3, 7, 3]\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval find_min_changes [1, 2,\
  \ 1, 2, 3, 1, 1, 1, 50, 1]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval find_min_changes\
  \ [6, 6, 3, 3, 4, 4]\n"
"vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded"
