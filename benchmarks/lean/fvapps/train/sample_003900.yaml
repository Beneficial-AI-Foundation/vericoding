"vc-description": "Write a function that takes an integer and returns an array `[A,\
  \ B, C]`, where `A` is the number of multiples of 3 (but not 5) below the given\
  \ integer, `B` is the number of multiples of 5 (but not 3) below the given integer\
  \ and `C` is the number of multiples of 3 and 5 below the given integer. \n\nFor\
  \ example, `solution(20)` should return `[5, 2, 1]`\n\n~~~if:r\n```r\n# in R, returns\
  \ a numeric vector\nsolution(20)\n[1] 5 2 1\n\nclass(solution(20))\n[1] \"numeric\"\
  \n```\n~~~"
"vc-preamble": "import Imports.AllImports\n\ndef solution (n : Nat) : Array Nat :=\
  \ sorry\n\ndef isMultipleOf3 (x : Nat) : Bool := x % 3 == 0"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def isMultipleOf5 (x : Nat) : Bool := x % 5 == 0\n\n-- Output format\
  \ properties "
"vc-theorems": "theorem solution_output_format (n : Nat) (h : n > 0) : \n  (solution\
  \ n).size = 3 ∧ \n  ∀ i < 3, (solution n)[i]! ≥ 0 := sorry\n\n-- Sum matches total\
  \ multiples\n\ntheorem solution_sum_matches_multiples (n : Nat) (h : n > 0) :\n\
  \  let result := solution n\n  let total := result[0]! + result[1]! + result[2]!\n\
  \  let multiples := (List.range n).filter (fun x => isMultipleOf3 x || isMultipleOf5\
  \ x)\n  total = multiples.length := sorry\n\n-- Components match exclusive counts\n\
  \ntheorem solution_component_counts (n : Nat) (h : n > 0) :\n  let result := solution\
  \ n\n  let only3 := (List.range n).filter (fun x => isMultipleOf3 x && !isMultipleOf5\
  \ x)\n  let only5 := (List.range n).filter (fun x => isMultipleOf5 x && !isMultipleOf3\
  \ x)\n  let both := (List.range n).filter (fun x => isMultipleOf3 x && isMultipleOf5\
  \ x)\n  result[0]! = only3.length ∧\n  result[1]! = only5.length ∧  \n  result[2]!\
  \ = both.length := sorry\n\n-- Edge cases\n\ntheorem solution_edge_cases :\n  solution\
  \ 1 = #[0, 0, 0] ∧\n  solution 3 = #[0, 0, 0] ∧\n  solution 4 = #[1, 0, 0] := sorry"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
