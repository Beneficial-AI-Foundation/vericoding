"vc-description": "The legendary Farmer John is throwing a huge party, and animals\
  \ from all over the world are hanging out at his house. His guests are hungry, so\
  \ he instructs his cow Bessie to bring out the snacks! Moo!\n\nThere are $n$ snacks\
  \ flavors, numbered with integers $1, 2, \\ldots, n$. Bessie has $n$ snacks, one\
  \ snack of each flavor. Every guest has exactly two favorite flavors. The procedure\
  \ for eating snacks will go as follows:  First, Bessie will line up the guests in\
  \ some way.  Then in this order, guests will approach the snacks one by one.  Each\
  \ guest in their turn will eat all remaining snacks of their favorite flavor. In\
  \ case no favorite flavors are present when a guest goes up, they become very sad.\
  \  \n\nHelp Bessie to minimize the number of sad guests by lining the guests in\
  \ an optimal way.\n\n\n-----Input-----\n\nThe first line contains integers $n$ and\
  \ $k$ ($2 \\le n \\le 10^5$, $1 \\le k \\le 10^5$), the number of snacks and the\
  \ number of guests. \n\nThe $i$-th of the following $k$ lines contains two integers\
  \ $x_i$ and $y_i$ ($1 \\le x_i, y_i \\le n$, $x_i \\ne y_i$), favorite snack flavors\
  \ of the $i$-th guest.\n\n\n-----Output-----\n\nOutput one integer, the smallest\
  \ possible number of sad guests.\n\n\n-----Examples-----\nInput\n5 4\n1 2\n4 3\n\
  1 4\n3 4\n\nOutput\n1\n\nInput\n6 5\n2 3\n2 1\n3 4\n6 5\n4 5\n\nOutput\n0\n\n\n\n\
  -----Note-----\n\nIn the first example, Bessie can order the guests like this: $3,\
  \ 1, 2, 4$. Guest $3$ goes first and eats snacks $1$ and $4$. Then the guest $1$\
  \ goes and eats the snack $2$ only, because the snack $1$ has already been eaten.\
  \ Similarly, the guest $2$ goes up and eats the snack $3$ only. All the snacks are\
  \ gone, so the guest $4$ will be sad. \n\nIn the second example, one optimal ordering\
  \ is $2, 1, 3, 5, 4$. All the guests will be satisfied."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def min_sad_guests (n k : Nat) (fav_pairs : List (Nat × Nat)) :\
  \ Nat :=\nsorry\n\n\n\n\n"
"vc-theorems": "theorem min_sad_guests_single_person {k : Nat} (h : k ≥ 1) :\n  min_sad_guests\
  \ 1 k [] = k :=\nsorry\n\n\ntheorem min_sad_guests_empty_pairs {n k : Nat} (h1 :\
  \ n ≥ 1) (h2 : k ≥ 1) :\n  min_sad_guests n k [] = k :=\nsorry\n\n\ntheorem min_sad_guests_edge_cases_1\
  \ :\n  min_sad_guests 1 1 [] = 1 :=\nsorry\n\n\ntheorem min_sad_guests_edge_cases_2\
  \ :\n  min_sad_guests 2 1 [(1,2)] = 0 :=\nsorry\n\n\ntheorem min_sad_guests_edge_cases_3\
  \ :\n  min_sad_guests 3 2 [(1,2), (2,3)] = 0 :=\nsorry\n\n/--\ninfo: 1\n-/\n#guard_msgs\
  \ in\n#eval min_sad_guests 5 4 [(1, 2), (4, 3), (1, 4), (3, 4)]\n\n/--\ninfo: 0\n\
  -/\n#guard_msgs in\n#eval min_sad_guests 6 5 [(2, 3), (2, 1), (3, 4), (6, 5), (4,\
  \ 5)]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval min_sad_guests 2 1 [(1, 2)]\n"
"vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded_and_plausible"
