"vc-description": "A permutation of length n is an array of size n consisting of n\
  \ distinct integers in the range [1, n]. For example, (3, 2, 4, 1) is a permutation\
  \ of length 4, but (3, 3, 1, 4) and (2, 3, 4, 5) are not, as (3, 3, 1, 4) contains\
  \ duplicate elements, and (2, 3, 4, 5) contains elements not in range [1,4].\nA\
  \ permutation p of length n is good if and only if for any 1 ≤ i ≤ n, pi ≠ i.\n\
  Please find the lexicographically smallest good permutation p.\nDefinition for \"\
  lexicographically smaller\":\nFor two permutations p and q, we say that p is lexicographically\
  \ smaller than q if and only if there exists a index 1 ≤ l ≤ n such that:\n- For\
  \ any 1 ≤ i < l, pi = qi. Note that if l = 1, this constraint means nothing.\n-\
  \ and, pl < ql.\n\nFor example, (2, 3, 1, 4) < (2, 3, 4, 1) < (3, 4, 1, 2). The\
  \ lexicographically smallest permutation is, of course, (1, 2, ..., n), though this\
  \ one is not good.\n\n-----Input-----\nFirst line of the input contains an integer\
  \ T denoting number of test cases.\nFor each test case, the only line contains an\
  \ integer n.\n\n-----Output-----\nFor each test case, output the lexicographically\
  \ smallest good permutation of length n. It's guaranteed that this permutation exists.\n\
  \n-----Constraints-----\n- 1 ≤ T ≤ 10\n- 2 ≤ n ≤ 105\n\n-----Subtasks-----\n- Subtask\
  \ #1 (17 points): 2 ≤ n ≤ 9\n- Subtask #2 (83 points): Original Constraints\n\n\
  -----Example-----\nInput:\n4\n2\n3\n5\n6\n\nOutput:\n2 1\n2 3 1\n2 1 4 5 3\n2 1\
  \ 4 3 6 5\n\n-----Explanation-----\nExample case 1. The only good permutation of\
  \ length 2 is (2, 1).\nExample case 2. Consider all permutations of length 3, they\
  \ are(in lexicographically order):\n- p = (1, 2, 3), it's not good since p[1] =\
  \ 1, p[2] = 2 and p[3] = 3;\n- p = (1, 3, 2), it's not good since p[1] = 1;\n- p\
  \ = (2, 1, 3), it's not good since p[3] = 3;\n- p = (2, 3, 1), it's good since p[1]\
  \ ≠ 1, p[2] ≠ 2 and p[3] ≠ 3;\n- p = (3, 1, 2), it's good since p[1] ≠ 1, p[2] ≠\
  \ 2 and p[3] ≠ 3;\n- p = (3, 2, 1), it's not good since p[2] = 2.\nThus the minimum\
  \ good one is (2, 3, 1).\nExample case 3. Consider two good permutations for third\
  \ test case: p=(2, 1, 4, 5, 3) and q=(2, 4, 1, 5, 3), then p < q. You can check\
  \ lexicographically condition as follows. Find the first index where the entries\
  \ of two permutations are different, and compare those entries. For example, in\
  \ this case, the first position where the entries differ is index 2. You can see\
  \ that p[2] < q[2], as 1 < 4, so p is lexicographically smaller than q."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def find_smallest_good_perm (n: Nat) : String :=\n  sorry\n"
"vc-theorems": "theorem good_perm_single_element :\n  find_smallest_good_perm 1 =\
  \ \"1\" :=\n  sorry\n\n\ntheorem good_perm_two_elements :  \n  find_smallest_good_perm\
  \ 2 = \"2 1\" :=\n  sorry \n\n\ntheorem good_perm_three_elements : \n  find_smallest_good_perm\
  \ 3 = \"2 3 1\" :=  \n  sorry\n\n\ntheorem good_perm_five_elements :\n  find_smallest_good_perm\
  \ 5 = \"2 1 4 5 3\" :=\n  sorry\n\n\ntheorem good_perm_six_elements :\n  find_smallest_good_perm\
  \ 6 = \"2 1 4 3 6 5\" :=\n  sorry\n\n\ntheorem good_perm_basic_properties (n: Nat)\
  \ (h: n > 0) (h2: n ≤ 100) :\n  let result := find_smallest_good_perm n\n  let nums\
  \ := (result.split (· = ' ')).map String.toNat!\n  nums.length = n ∧ \n  nums.Nodup\
  \ ∧\n  nums.all (λ x => 1 ≤ x ∧ x ≤ n) ∧\n  (n > 1 → nums.get! 0 = 2) ∧\n  (n =\
  \ 1 → result = \"1\") :=\n  sorry\n\n/--\ninfo: '2 1'\n-/\n#guard_msgs in\n#eval\
  \ find_smallest_good_perm 2\n\n/--\ninfo: '2 3 1'\n-/\n#guard_msgs in\n#eval find_smallest_good_perm\
  \ 3\n\n/--\ninfo: '2 1 4 5 3'\n-/\n#guard_msgs in\n#eval find_smallest_good_perm\
  \ 5\n\n/--\ninfo: '2 1 4 3 6 5'\n-/\n#guard_msgs in\n#eval find_smallest_good_perm\
  \ 6\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
