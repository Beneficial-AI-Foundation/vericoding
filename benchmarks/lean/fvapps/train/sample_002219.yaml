"vc-description": "You are working for the Gryzzl company, headquartered in Pawnee,\
  \ Indiana.\n\nThe new national park has been opened near Pawnee recently and you\
  \ are to implement a geolocation system, so people won't get lost. The concept you\
  \ developed is innovative and minimalistic. There will be $n$ antennas located somewhere\
  \ in the park. When someone would like to know their current location, their Gryzzl\
  \ hologram phone will communicate with antennas and obtain distances from a user's\
  \ current location to all antennas.\n\nKnowing those distances and antennas locations\
  \ it should be easy to recover a user's location... Right? Well, almost. The only\
  \ issue is that there is no way to distinguish antennas, so you don't know, which\
  \ distance corresponds to each antenna. Your task is to find a user's location given\
  \ as little as all antennas location and an unordered multiset of distances.\n\n\
  \n-----Input-----\n\nThe first line of input contains a single integer $n$ ($2 \\\
  leq n \\leq 10^5$) which is the number of antennas.\n\nThe following $n$ lines contain\
  \ coordinates of antennas, $i$-th line contain two integers $x_i$ and $y_i$ ($0\
  \ \\leq x_i,y_i \\leq 10^8$). It is guaranteed that no two antennas coincide.\n\n\
  The next line of input contains integer $m$ ($1 \\leq n \\cdot m \\leq 10^5$), which\
  \ is the number of queries to determine the location of the user.\n\nFollowing $m$\
  \ lines contain $n$ integers $0 \\leq d_1 \\leq d_2 \\leq \\dots \\leq d_n \\leq\
  \ 2 \\cdot 10^{16}$ each. These integers form a multiset of squared distances from\
  \ unknown user's location $(x;y)$ to antennas.\n\nFor all test cases except the\
  \ examples it is guaranteed that all user's locations $(x;y)$ were chosen uniformly\
  \ at random, independently from each other among all possible integer locations\
  \ having $0 \\leq x, y \\leq 10^8$.\n\n\n-----Output-----\n\nFor each query output\
  \ $k$, the number of possible a user's locations matching the given input and then\
  \ output the list of these locations in lexicographic order.\n\nIt is guaranteed\
  \ that the sum of all $k$ over all points does not exceed $10^6$.\n\n\n-----Examples-----\n\
  Input\n3\n0 0\n0 1\n1 0\n1\n1 1 2\n\nOutput\n1 1 1 \n\nInput\n4\n0 0\n0 1\n1 0\n\
  1 1\n2\n0 1 1 2\n2 5 5 8\n\nOutput\n4 0 0 0 1 1 0 1 1 \n4 -1 -1 -1 2 2 -1 2 2 \n\
  \n\n\n-----Note-----\n\nAs you see in the second example, although initially a user's\
  \ location is picked to have non-negative coordinates, you have to output all possible\
  \ integer locations."
"vc-preamble": "import Imports.AllImports\n\ndef solve_gryzzl_location (coords : List\
  \ (Int × Int)) (queries : List (List Int)) : List String :=\n  sorry\n\n\ndef getMaximumD\
  \ (l : List Int) : Int :=\n  match l.maximum? with\n  | some x => x\n  | none =>\
  \ 0\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def getMinimumD (l : List Int) : Int :=\n  match l.minimum? with\n\
  \  | some x => x\n  | none => 0\n"
"vc-theorems": "theorem antenna_coords_basic_types {coords : List (Int × Int)} \n\
  \  {queries : List (List Int)} \n  (h1 : coords.length ≥ 2)\n  (h2 : queries.length\
  \ > 0) :\n  let result := solve_gryzzl_location coords queries\n  result.length\
  \ = queries.length\n  := sorry\n\n\ntheorem antenna_coord_result_format {coords\
  \ : List (Int × Int)}\n  {queries : List (List Int)}\n  (h1 : coords.length ≥ 2)\n\
  \  (h2 : queries.length > 0)\n  (minX maxX minY maxY : Int) :\n  let result := solve_gryzzl_location\
  \ coords queries\n  let coordsX := coords.map Prod.fst\n  let coordsY := coords.map\
  \ Prod.snd\n  let queryMax := getMaximumD (queries.map getMaximumD)\n  minX = getMinimumD\
  \ coordsX - queryMax ∧\n  maxX = getMaximumD coordsX + queryMax ∧\n  minY = getMinimumD\
  \ coordsY - queryMax ∧\n  maxY = getMaximumD coordsY + queryMax →\n  ∀ res ∈ result,\n\
  \    let nums := res.split (· = ' ')\n    let count := nums.length\n    nums.length\
  \ ≥ 1 ∧\n    -- Coordinate range checks\n    ∀ i, i < count →\n      let x := -1\
  \  -- placeholder since we can't parse string to int\n      let y := -1  -- placeholder\
  \ since we can't parse string to int\n      minX - 1 ≤ x ∧ x ≤ maxX + 1 ∧\n    \
  \  minY - 1 ≤ y ∧ y ≤ maxY + 1\n  := sorry\n\n\ntheorem sqrt_distance_property {coords\
  \ : List (Int × Int)}\n  (h1 : coords.length ≥ 2) :\n  let (x1, y1) := coords[0]!\n\
  \  let (x2, y2) := coords[1]!\n  let d := (x2 - x1)^2 + (y2 - y1)^2\n  let result\
  \ := solve_gryzzl_location coords [List.replicate coords.length d]\n  result.length\
  \ = 1\n  := sorry"
"vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded"
