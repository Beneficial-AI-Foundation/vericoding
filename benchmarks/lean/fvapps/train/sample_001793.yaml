"vc-description": "We run a preorder depth first search on the root of a binary tree.\n\
  At each node in this traversal, we output D dashes (where D is the depth of this\
  \ node), then we output the value of this node.  (If the depth of a node is D, the\
  \ depth of its immediate child is D+1.  The depth of the root node is 0.)\nIf a\
  \ node has only one child, that child is guaranteed to be the left child.\nGiven\
  \ the output S of this traversal, recover the tree and return its root.\n \nExample\
  \ 1:\n\nInput: \"1-2--3--4-5--6--7\"\nOutput: [1,2,5,3,4,6,7]\n\n\nExample 2:\n\n\
  Input: \"1-2--3---4-5--6---7\"\nOutput: [1,2,5,3,null,6,null,4,null,7]\n\n\n \n\n\
  Example 3:\n\nInput: \"1-401--349---90--88\"\nOutput: [1,401,null,349,88,90]\n\n\
  \n \nNote:\n\nThe number of nodes in the original tree is between 1 and 1000.\n\
  Each node will have a value between 1 and 10^9."
"vc-preamble": "import Imports.AllImports\n\ndef valid_preorder_string (s : String)\
  \ : Bool := sorry\n\ndef depth_never_skips (s : String) : Bool := sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def toArray {α : Type} [Inhabited α] (t : BinTree α) : Array (Option\
  \ α) := sorry \n\n/-- If a string is in valid preorder format, then its depths should\
  \ never skip levels -/"
"vc-theorems": "theorem valid_implies_no_depth_skips (s : String) :\n  valid_preorder_string\
  \ s → depth_never_skips s := sorry\n\n/-- When converting tree to array, it's always\
  \ non-empty -/\n\ntheorem tree_to_array_nonempty {α : Type} [Inhabited α] (t : BinTree\
  \ α) :\n  (toArray t).size > 0 := sorry\n\n/-- When converting a tree to array,\
  \ the root always exists -/\n\ntheorem tree_to_array_root_exists {α : Type} [Inhabited\
  \ α] (t : BinTree α) :\n  Option.isSome ((toArray t)[0]'(sorry)) := sorry\n\n/--\
  \ In array form, if left child is None then right child must be None -/  \n\ntheorem\
  \ array_child_property {α : Type} [Inhabited α] (t : BinTree α) \n  (i : Nat) (h1\
  \ : 1 ≤ i) (h2 : i < (toArray t).size - 1) (h3 : i % 2 = 1) :\n  Option.isNone ((toArray\
  \ t)[i]'(sorry)) → Option.isNone ((toArray t)[i+1]'(sorry)) := sorry\n\n/--\ninfo:\
  \ [1, 2, 5, 3, 4, 6, 7]\n-/\n#guard_msgs in\n#eval to_array recoverFromPreorder(\"\
  1-2--3--4-5--6--7\")\n\n/--\ninfo: [1, 2, 5, 3, None, 6, None, 4, None, 7]\n-/\n\
  #guard_msgs in\n#eval to_array recoverFromPreorder(\"1-2--3---4-5--6---7\")\n\n\
  /--\ninfo: [1, 401, None, 349, 88, 90]\n-/\n#guard_msgs in\n#eval to_array recoverFromPreorder(\"\
  1-401--349---90--88\")\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
