"vc-description": "You are given an unweighted tree with N$N$ nodes (numbered 1$1$\
  \ through N$N$). Let's denote the distance between any two nodes p$p$ and q$q$ by\
  \ d(p,q)$d(p, q)$.\nYou should answer Q$Q$ queries. In each query, you are given\
  \ parameters a$a$, da$d_a$, b$b$, db$d_b$, and you should find a node x$x$ such\
  \ that d(x,a)=da$d(x, a) = d_a$ and d(x,b)=db$d(x, b) = d_b$, or determine that\
  \ there is no such node.\n\n-----Input-----\n- The first line of the input contains\
  \ a single integer T$T$ denoting the number of test cases. The description of T$T$\
  \ test cases follows.\n- The first line of each test case contains two space-separated\
  \ integers N$N$ and Q$Q$.\n- Each of the next N−1$N-1$ lines contains two space-separated\
  \ integers u$u$ and v$v$ denoting that nodes u$u$ and v$v$ are connected by an edge.\n\
  - Each of the next Q$Q$ lines contains four space-separated integers a$a$, da$d_a$,\
  \ b$b$ and db$d_b$ describing a query.\n\n-----Output-----\nFor each query, print\
  \ a single line containing one integer ― the number of a node satisfying the given\
  \ requirements, or −1$-1$ if no such node exists.\nIf there are multiple solutions,\
  \ you may output any one.\n\n-----Constraints-----\n- 1≤T≤1,000$1 \\le T \\le 1,000$\n\
  - 1≤N,Q≤106$1 \\le N, Q \\le 10^6$\n- 1≤u,v≤N$1 \\le u, v \\le N$\n- the graph on\
  \ the input is a tree\n- 1≤a,b≤N$1 \\le a, b \\le N$\n- 1≤da,db<N$1 \\le d_a, d_b\
  \ < N$\n- the sum of N$N$ over all test cases does not exceed 106$10^6$\n- the sum\
  \ of Q$Q$ over all test cases does not exceed 106$10^6$\n\n-----Subtasks-----\n\
  Subtask #1 (50 points):\n- 1≤N,Q≤1,000$1 \\le N, Q \\le 1,000$\n- the sum of N$N$\
  \ over all test cases does not exceed 1,000$1,000$\n- the sum of Q$Q$ over all test\
  \ cases does not exceed 1,000$1,000$\nSubtask #2 (50 points): original constraints\n\
  \n-----Example Input-----\n1\n5 3\n1 2\n2 3\n3 4\n3 5\n2 1 4 1\n2 2 4 2\n1 1 2 1\n\
  \n-----Example Output-----\n3\n5\n-1"
"vc-preamble": "import Imports.AllImports\n\ndef find_nodes_with_distance (t : Tree)\
  \ (node : Nat) (dist : Nat) : List Nat :=\n  sorry\n\n\ndef resolve_query (t : Tree)\
  \ (a b c d : Nat) : Int :=\n  sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def resolve_queries (t : Tree) (qs : List (Nat × Nat × Nat × Nat))\
  \ : List Int :=\n  sorry\n"
"vc-theorems": "theorem queries_results_length_matches {t : Tree} {qs : List (Nat\
  \ × Nat × Nat × Nat)} :\n  let results := resolve_queries t qs\n  List.length results\
  \ = List.length qs := sorry\n\n\ntheorem results_are_valid_nodes_or_neg_one {t :\
  \ Tree} {qs : List (Nat × Nat × Nat × Nat)} :\n  let results := resolve_queries\
  \ t qs\n  ∀ r ∈ results, r = -1 ∨ (1 ≤ Int.toNat r ∧ Int.toNat r ≤ t.n) := sorry\n\
  \n\ntheorem zero_distance_to_self {t : Tree} {node : Nat} :\n  node ≤ t.n →\n  find_nodes_with_distance\
  \ t node 0 = [node] := sorry\n\n\ntheorem zero_distance_query {t : Tree} {a b :\
  \ Nat} :\n  a ≤ t.n →\n  b ≤ t.n →\n  resolve_query t a 0 b 0 = if a = b then Int.ofNat\
  \ a else -1 := sorry\n\n\ntheorem nodes_at_distance_unique {t : Tree} {node dist\
  \ : Nat} :\n  node ≤ t.n →\n  let nodes := find_nodes_with_distance t node dist\n\
  \  List.Nodup nodes := sorry\n\n\ntheorem nodes_at_distance_valid {t : Tree} {node\
  \ dist : Nat} :\n  node ≤ t.n →\n  let nodes := find_nodes_with_distance t node\
  \ dist\n  ∀ n ∈ nodes, 1 ≤ n ∧ n ≤ t.n := sorry"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded"
