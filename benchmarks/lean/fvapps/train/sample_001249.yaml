"vc-description": "Chef and his friend Miron were getting bored and decided to play\
  \ a game. \nMiron thinks of a sequence of  N  integers (A1, A2, …., AN) and gives\
  \ Chef a matrix B, where Bi,j = |Ai - Aj|. He further tells Chef that A1 = 0. The\
  \ game is for Chef to guess the sequence that Miron thought of. \nBut Miron is an\
  \ adversarial player. Every time Chef tries to guess the sequence, he makes a change\
  \ to the matrix. He makes such a change Q times. Each time, he replaces an entry\
  \ in some row and the corresponding column with a new one leaving Chef to guess\
  \ the sequence after each change. \nChef needs a friend to help him against such\
  \ an adversarial player. Can you be that friend and help Chef find a suitable sequence\
  \ A for the initial matrix B and also after each change Miron makes? \nNote that\
  \ if several answers exist, then print the lexicographically smallest answer. Further,\
  \ the numbers in the sequence can be negative.\n\n-----Input-----\n\nThe first line\
  \ contains two space-separated integers N, Q. Each of the N subsequent lines contains\
  \ N space-separated integers, denoting the matrix B.\n\nQ queries follow. Each query\
  \ has two lines. The first line of each query contains an integer p, denoting the\
  \ number of row and column that is changed. The second line of each query contains\
  \ N space-separated integers F1, F2, F3, ... FN, denoting the new values to the\
  \ corresponding cells of the matrix (you should make the following assignments Bi,p\
  \ = Bp,i = Fi for all valid i). \n\n-----Output-----\nPrint Q + 1 lines which contain\
  \ N space-separated integers, Miron's initial array and Miron's array after each\
  \ query.\n\n-----Constraints-----\n- 3 ≤ N ≤  1000 \n- 1 ≤ Q ≤  1000 \n- 0 ≤ Bi,j\
  \ ≤  5000 \n- 1 ≤ p ≤  n \n- 0 ≤ Fi ≤  5000 \n- it's guaranteed there's always an\
  \ answer\n\n-----Example-----\nInput:\n3 2\n0 1 2\n1 0 1\n2 1 0\n1\n0 4 3\n2\n4\
  \ 0 7\nOutput:\n0 -1 -2\n0 -4 -3\n0 -4 3\n\n-----Explanation-----\nExample case\
  \ 1. Initially, sequence {0, 1, 2} is also suitable, but {0, -1, -2} is lexicografically\
  \ smaller."
"vc-preamble": "import Imports.AllImports\n\ndef make_symmetric_zero_diag (B : List\
  \ (List Nat)) : List (List Nat) := sorry\n\ndef solve (N: Nat) (Q: Nat) (B: List\
  \ (List Nat)) (queries: List (Nat × List Nat)) : List (List Nat) := sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def get_A (B: List (List Int)) : List Int := sorry\n\ndef update_B\
  \ (B: List (List Nat)) (p: Nat) (R: List Nat) : List (List Nat) := sorry\n"
"vc-theorems": "theorem solve_shape_correct {N Q: Nat} {B: List (List Nat)} {queries:\
  \ List (Nat × List Nat)}\n  (h1: N = 3)\n  (h2: List.length B = N)\n  (h3: ∀ row\
  \ ∈ B, List.length row = N) \n  (h4: List.length queries ≥ 1)\n  (h5: List.length\
  \ queries ≤ 3)\n  : let result := solve N Q B queries\n    List.length result =\
  \ List.length queries + 1 ∧ \n    ∀ row ∈ result, List.length row = N := sorry\n\
  \n\ntheorem distances_preserved {A: List Int} {N: Nat}\n  (h1: List.length A = N)\n\
  \  (h2: N = 3)\n  : let B := List.map (λ i => List.map (λ j => Int.natAbs (A.get\
  \ ⟨i, by sorry⟩ - A.get ⟨j, by sorry⟩)) (List.range N)) (List.range N)\n    let\
  \ reconstructed := get_A (B.map (List.map Int.ofNat))\n    ∀ (i j : Fin reconstructed.length),\
  \ \n    Int.natAbs (reconstructed.get i - reconstructed.get j) = (B.get ⟨i.val,\
  \ by sorry⟩).get ⟨j.val, by sorry⟩ := sorry\n\n\ntheorem update_B_symmetric {N p:\
  \ Nat} {R: List Nat}\n  (h1: N ≥ 2)\n  (h2: N ≤ 5)\n  (h3: p < N)\n  (h4: List.length\
  \ R ≥ N)\n  : let B := List.replicate N (List.replicate N 0)\n    let updated :=\
  \ update_B B p (List.take N R)\n    ∀ (i j : Fin N),\n    (updated.get ⟨i.val, by\
  \ sorry⟩).get ⟨j.val, by sorry⟩ = \n    (updated.get ⟨j.val, by sorry⟩).get ⟨i.val,\
  \ by sorry⟩ := sorry"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded"
