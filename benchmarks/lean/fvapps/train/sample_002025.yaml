"vc-description": "You are given a string s, consisting of lowercase English letters,\
  \ and the integer m.\n\nOne should choose some symbols from the given string so\
  \ that any contiguous subsegment of length m has at least one selected symbol. Note\
  \ that here we choose positions of symbols, not the symbols themselves.\n\nThen\
  \ one uses the chosen symbols to form a new string. All symbols from the chosen\
  \ position should be used, but we are allowed to rearrange them in any order.\n\n\
  Formally, we choose a subsequence of indices 1 ≤ i_1 < i_2 < ... < i_{t} ≤ |s|.\
  \ The selected sequence must meet the following condition: for every j such that\
  \ 1 ≤ j ≤ |s| - m + 1, there must be at least one selected index that belongs to\
  \ the segment [j,  j + m - 1], i.e. there should exist a k from 1 to t, such that\
  \ j ≤ i_{k} ≤ j + m - 1.\n\nThen we take any permutation p of the selected indices\
  \ and form a new string s_{i}_{p}_1s_{i}_{p}_2... s_{i}_{p}_{t}.\n\nFind the lexicographically\
  \ smallest string, that can be obtained using this procedure.\n\n\n-----Input-----\n\
  \nThe first line of the input contains a single integer m (1 ≤ m ≤ 100 000).\n\n\
  The second line contains the string s consisting of lowercase English letters. It\
  \ is guaranteed that this string is non-empty and its length doesn't exceed 100\
  \ 000. It is also guaranteed that the number m doesn't exceed the length of the\
  \ string s.\n\n\n-----Output-----\n\nPrint the single line containing the lexicographically\
  \ smallest string, that can be obtained using the procedure described above.\n\n\
  \n-----Examples-----\nInput\n3\ncbabc\n\nOutput\na\n\nInput\n2\nabcab\n\nOutput\n\
  aab\n\nInput\n3\nbcabcbaccba\n\nOutput\naaabb\n\n\n\n-----Note-----\n\nIn the first\
  \ sample, one can choose the subsequence {3} and form a string \"a\".\n\nIn the\
  \ second sample, one can choose the subsequence {1, 2, 4} (symbols on this positions\
  \ are 'a', 'b' and 'a') and rearrange the chosen symbols to form a string \"aab\"\
  ."
"vc-preamble": "import Imports.AllImports\n\ndef findSmallestSubstring (m : Nat) (s\
  \ : String) : String := sorry\n\ntheorem find_smallest_substring_lowercase (m :\
  \ Nat) (s : String) : \n  let r := findSmallestSubstring m s\n  ∀ c ∈ r.data, c.isLower\
  \ ∨ r = \"\" := sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def isSorted (l : List Char) : Prop :=\n  ∀ i j, i < j → j < l.length\
  \ → l[i]! ≤ l[j]!\n"
"vc-theorems": "theorem find_smallest_substring_sorted (m : Nat) (s : String) :\n\
  \  let r := findSmallestSubstring m s\n  isSorted r.data ∨ r = \"\" := sorry\n\n\
  \ntheorem find_smallest_substring_length (m : Nat) (s : String) :\n  let r := findSmallestSubstring\
  \ m s\n  r.length ≤ s.length := sorry\n\n\ntheorem find_smallest_substring_chars_subset\
  \ (m : Nat) (s : String) :\n  let r := findSmallestSubstring m s\n  ∀ c ∈ r.data,\
  \ c ∈ s.data := sorry\n\n\ntheorem find_smallest_substring_alternating (m : Nat)\
  \ :\n  let s := \"ababab\"\n  let r := findSmallestSubstring m s\n  ∀ c ∈ r.data,\
  \ c = 'a' ∨ c = 'b' := sorry\n\n/--\ninfo: 'a'\n-/\n#guard_msgs in\n#eval find_smallest_substring\
  \ 3 \"cbabc\"\n\n/--\ninfo: 'aab'\n-/\n#guard_msgs in\n#eval find_smallest_substring\
  \ 2 \"abcab\"\n\n/--\ninfo: 'aaabb'\n-/\n#guard_msgs in\n#eval find_smallest_substring\
  \ 3 \"bcabcbaccba\"\n"
"vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded"
