"vc-description": "Reverse a linked list from position m to n. Do it in one-pass.\n\
  \nNote: 1 ≤ m ≤ n ≤ length of list.\n\nExample:\n\n\nInput: 1->2->3->4->5->NULL,\
  \ m = 2, n = 4\nOutput: 1->4->3->2->5->NULL"
"vc-preamble": "import Imports.AllImports\n\ndef arrayToLinkedList : List Int → Option\
  \ ListNode := sorry\ndef linkedListToArray : Option ListNode → List Int := sorry\
  \  "
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def reverseBetween : Option ListNode → Nat → Nat → Option ListNode\
  \ := sorry\n\ntheorem reverse_single_element_unchanged \n    {arr : List Int} {i\
  \ : Nat} \n    (h1 : arr ≠ []) \n    (h2 : i ≥ 1) \n    (h3 : i ≤ arr.length) :\n\
  \    linkedListToArray (reverseBetween (arrayToLinkedList arr) i i) = arr := sorry\n"
"vc-theorems": "theorem reverse_entire_list\n    {arr : List Int}\n    (h : arr ≠\
  \ []) :\n    linkedListToArray (reverseBetween (arrayToLinkedList arr) 1 arr.length)\
  \ = arr.reverse := sorry \n\n\ntheorem reverse_between_properties\n    {arr : List\
  \ Int} {m n : Nat}\n    (h1 : arr ≠ [])\n    (h2 : m ≥ 1)\n    (h3 : n ≥ 1)\n  \
  \  (h4 : m ≤ arr.length)\n    (h5 : n ≤ arr.length)\n    (h6 : m ≤ n) :\n    let\
  \ result := linkedListToArray (reverseBetween (arrayToLinkedList arr) m n)\n   \
  \ (result.length = arr.length) ∧\n    (result.take (m-1) = arr.take (m-1)) ∧\n \
  \   (result.drop n = arr.drop n) ∧\n    ((result.drop (m-1)).take (n-m+1)) = ((arr.drop\
  \ (m-1)).take (n-m+1)).reverse := sorry\n\n\ntheorem empty_list : \n    reverseBetween\
  \ none 1 1 = none := sorry\n\n/--\ninfo: [1, 4, 3, 2, 5]\n-/\n#guard_msgs in\n#eval\
  \ linkedListToArray reverseBetween(test1, 2, 4)\n\n/--\ninfo: [1]\n-/\n#guard_msgs\
  \ in\n#eval linkedListToArray reverseBetween(test2, 1, 1)\n\n/--\ninfo: [3, 2, 1]\n\
  -/\n#guard_msgs in\n#eval linkedListToArray reverseBetween(test3, 1, 3)\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
