"vc-description": "A sequence of integers ($a_1, a_2, \\ldots, a_k$) is said to be\
  \ UpDown, if these inequalities hold true:\n- $a_1 \\le a_2$\n- $a_2 \\ge a_3$\n\
  - $a_3 \\le a_4$\nand so on.\nThat is, every even-indexed element should be at least\
  \ as large as its adjacent elements. And every odd-indexed element should be at\
  \ most as large as its adjacent elements. Formally, $a_{2i} \\ge a_{2i+1}$ and $a_{2i+1}\
  \ \\le a_{2i+2}$, for all valid positions.\nA subsegment is a consecutive portion\
  \ of a sequence. That is, a subsegment of ($b_1, b_2, \\ldots, b_k$)  will be of\
  \ the form ($b_i, b_{i+1}, \\ldots, b_j$), for some $i$ and $j$.\nYou are given\
  \ a sequence ($s_1, s_2, \\ldots, s_n$). You can insert at most one integer anywhere\
  \ in this sequence. It could be any integer. After inserting an integer (or choosing\
  \ not to), suppose you have the new sequence ($t_1, t_2, \\ldots, t_m$). Note that\
  \ $m$ will either be $n$+1 or $n$. You want to maximize the length of the longest\
  \ subsegment of ($t_1, t_2, \\ldots, t_m$) which is UpDown, and output the length\
  \ of that.\n\n-----Input-----\n- The first line contains a single integer, $T$,\
  \ which is the number of testcases. The description of each testcase follows.\n\
  - The first line of every testcase contains a single integer, $n$, which is the\
  \ number of integers in the original sequence.\n- The second line contains $n$ integers:\
  \ $s_1, s_2, \\ldots, s_n$, which forms the original sequence.\n\n-----Output-----\n\
  For each testcase output a single line containing one integer, which should be the\
  \ length of the longest UpDown subsegment that you can get after inserting at most\
  \ one integer.\n\n-----Constraints-----\n- $1 \\le T \\le 2$\n- $1 \\le n \\le 10^6$\n\
  - $1 \\le s_i \\le 10^9$\n\n-----Subtasks-----\nSubtask #1 (20 points): $1 \\le\
  \ n \\le 100$\nSubtask #2 (10 points): $1 \\le n \\le 10000$\nSubtask #3 (70 points):\
  \ Original constraints\n\n-----Sample Input-----\n2\n7\n100 1 10 3 20 25 24\n5\n\
  3 3 2 4 1\n\n-----Sample Output-----\n7\n6\n\n-----Explanation-----\nTestcase 1:\
  \ The original sequence is (100, 1, 10, 3, 20, 25, 24). Suppose you insert the element\
  \ 5 between the elements 20 and 25, you will get the new sequence (100, 1, 10, 3,\
  \ 20, 5, 25, 24). The longest UpDown subsegment of this sequence is (1, 10, 3, 20,\
  \ 5, 25, 24), whose length is 7. You can check that you cannot do any better, and\
  \ hence the answer is 7.\nTestcase 2: The original sequence is (3, 3, 2, 4, 1).\
  \ Suppose you insert the element 4 at the end, you will get the new sequence (3,\
  \ 3, 2, 4, 1, 4). This entire sequence is UpDown, and so the longest UpDown subsegment\
  \ of this sequence is (3, 3, 2, 4, 1, 4), whose length is 6. You can check that\
  \ you cannot do any better, and hence the answer is 6."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def find_updown_length (n : Nat) (arr : List Int) : Nat :=\n  sorry\n"
"vc-theorems": "theorem find_updown_length_bounds {n : Nat} {arr : List Int} \n  \
  \  (h_size : arr.length = n) (h_n : n ≥ 2) :\n  let result := find_updown_length\
  \ n arr\n  2 ≤ result ∧ result ≤ n + 1 :=\nsorry\n\n\ntheorem find_updown_length_monotonic\
  \ {n : Nat} {arr : List Int}\n    (h_size : arr.length = n) (h_n : n ≥ 2)\n    (h_monotonic\
  \ : ∀ i, i < n - 1 → arr[i]! < arr[i+1]!) :\n  find_updown_length n arr ≥ n :=\n\
  sorry\n\n\ntheorem find_updown_length_extension {n : Nat} {arr : List Int}\n   \
  \ (h_size : arr.length = n) (h_n : n ≥ 2) :\n  let arr2 := arr.append [arr.getLast!]\n\
  \  find_updown_length (n+1) arr2 ≥ find_updown_length n arr - 1 :=\nsorry\n\n\n\
  theorem find_updown_length_binary {n : Nat} {arr : List Int}\n    (h_size : arr.length\
  \ = n) (h_n : n ≥ 2)\n    (h_binary : ∀ x ∈ arr, x = 1 ∨ x = 2) :\n  find_updown_length\
  \ n arr ≥ (n + 1) / 2 :=\nsorry\n\n/--\ninfo: 7\n-/\n#guard_msgs in\n#eval find_updown_length\
  \ 7 [100, 1, 10, 3, 20, 25, 24]\n\n/--\ninfo: 6\n-/\n#guard_msgs in\n#eval find_updown_length\
  \ 5 [3, 3, 2, 4, 1]\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval find_updown_length\
  \ 4 [1, 2, 1, 3]\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
