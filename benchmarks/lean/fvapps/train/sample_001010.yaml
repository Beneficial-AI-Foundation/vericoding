"vc-description": "Ripul was skilled in the art of lapidary. He used to collect stones\
  \ and convert it into decorative items for sale.  There were n stone shops. Each\
  \ shop was having one exclusive stone of value s[i] , where 1<=i<=n.  If number\
  \ of stones collected are more than 1, then total value will be product of values\
  \ of all the stones he collected. Ripul wants to have maximum value of stones he\
  \ collected. Help Ripul in picking up the subarray which leads to maximum value\
  \ of stones he collected.\n\n-----Input:-----\n- First line will contain $T$, number\
  \ of testcases. Then the testcases follow. \n- The first line of each testcase contains\
  \ an integer $N$, denoting number of elements in the given array.\n- The second\
  \ line contains $N$ space-separated integers $S1$, $S2$, …, $SN$ denoting the value\
  \ of stone in each shop. \n\n-----Output:-----\nFor each testcase, output the maximum\
  \ value of stones possible, the starting index and ending index of the chosen subarray\
  \ (0-based indexing). If there are multiple subarrays with same value, print the\
  \ one with greater starting index. If there are multiple answer subarrays with same\
  \ starting index, print the one with greater ending index. (The answer will fit\
  \ in 64 bit binary number).\n\n-----Constraints-----\n- $1 \\leq T \\leq 10$\n-\
  \ $1 \\leq N \\leq 10^5$\n- $-100 \\leq S[i] \\leq 100$\n\n-----Subtasks-----\n\
  - 30 points : $1 \\leq N \\leq 10^3$\n- 70 points : $1 \\leq N \\leq 10^5$\n\n-----Sample\
  \ Input:-----\n1\n3\n\n1 2 3\n\n-----Sample Output:-----\n6 1 2\n\n-----EXPLANATION:-----\n\
  If Ripul collects all the all the three gems, total value will be 6 (1 * 2 * 3).\n\
  If Ripul collects last two gems, total value will be 6 (1 * 2 * 3).\nSo, he picks\
  \ the subarray with greater starting index."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def find_max_stone_value (N : Nat) (stones : List Int) : Int ×\
  \ Nat × Nat := sorry\n\ntheorem valid_indices {N : Nat} {stones : List Int} (h :\
  \ N > 0) (h2 : stones.length > 0) : \n  let (val, start, finish) := find_max_stone_value\
  \ N stones;\n  0 ≤ start ∧ start ≤ finish ∧ finish < N := sorry\n"
"vc-theorems": "theorem value_matches_slice {N : Nat} {stones : List Int} (h : N >\
  \ 0) (h2 : stones.length > 0) :\n  let (val, start, finish) := find_max_stone_value\
  \ N stones;\n  val = (List.range (finish - start + 1)).foldl (fun acc i => acc *\
  \ stones[start + i]!) 1 := sorry \n\n\ntheorem value_is_maximum {stones : List Int}\
  \ (h : stones.length > 0) :\n  let (val, start, finish) := find_max_stone_value\
  \ (stones.length) stones;\n  ∀ i j, 0 ≤ i → i ≤ j → j < stones.length → \n    val\
  \ ≥ (List.range (j - i + 1)).foldl (fun acc k => acc * stones[i + k]!) 1 := sorry"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded"
