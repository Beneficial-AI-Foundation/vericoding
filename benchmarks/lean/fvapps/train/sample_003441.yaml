"vc-description": "> \n**Note**: This kata is a translation of this (Java) one: http://www.codewars.com/kata/rotate-array.\
  \ I have not translated this first one as usual because I did not solved it, and\
  \ I fear not being able to solve it (Java is **not** my cup of... tea). @cjmcgraw,\
  \ if you want to use my translation on your kata feel free to use it.\n\nCreate\
  \ a function named \"rotate\" that takes an array and returns a new one with the\
  \ elements inside rotated n spaces.\n\nIf n is greater than 0 it should rotate the\
  \ array to the right. If n is less than 0 it should rotate the array to the left.\
  \ If n is 0, then it should return the array unchanged.\n\nExample:\n```python\n\
  data = [1, 2, 3, 4, 5];\n\nrotate(data, 1) # => [5, 1, 2, 3, 4]\nrotate(data, 2)\
  \ # => [4, 5, 1, 2, 3]\nrotate(data, 3) # => [3, 4, 5, 1, 2]\nrotate(data, 4) #\
  \ => [2, 3, 4, 5, 1]\nrotate(data, 5) # => [1, 2, 3, 4, 5]\n\nrotate(data, 0) #\
  \ => [1, 2, 3, 4, 5]\n\nrotate(data, -1) # => [2, 3, 4, 5, 1]\nrotate(data, -2)\
  \ # => [3, 4, 5, 1, 2]\nrotate(data, -3) # => [4, 5, 1, 2, 3]\nrotate(data, -4)\
  \ # => [5, 1, 2, 3, 4]\nrotate(data, -5) # => [1, 2, 3, 4, 5]\n```\n\nFurthermore\
  \ the method should take ANY array of objects and perform this operation on them:\n\
  ```python\nrotate(['a', 'b', 'c'], 1)     # => ['c', 'a', 'b']\nrotate([1.0, 2.0,\
  \ 3.0], 1)     # => [3.0, 1.0, 2.0]\nrotate([True, True, False], 1) # => [False,\
  \ True, True]\n```\n\nFinally the rotation shouldn't be limited by the indices available\
  \ in the array. Meaning that if we exceed the indices of the array it keeps rotating.\n\
  \nExample:\n```python\ndata = [1, 2, 3, 4, 5]\n\nrotate(data, 7)     # => [4, 5,\
  \ 1, 2, 3]\nrotate(data, 11)    # => [5, 1, 2, 3, 4]\nrotate(data, 12478) # => [3,\
  \ 4, 5, 1, 2]\n```"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def rotate {α : Type u} (arr : List α) (n : Int) : List α :=\n\
  \  sorry\n"
"vc-theorems": "theorem rotate_empty {α : Type u} (n : Int) :\n  rotate ([] : List\
  \ α) n = ([] : List α) :=\n  sorry\n\n\ntheorem rotate_length {α : Type u} (arr\
  \ : List α) (n : Int) :\n  arr ≠ [] → List.length (rotate arr n) = List.length arr\
  \ :=\n  sorry\n\n\ntheorem rotate_elements_same {α : Type u} (arr : List α) (n :\
  \ Int) (x : α) :\n  arr ≠ [] → (x ∈ arr ↔ x ∈ rotate arr n) :=\n  sorry\n\n\ntheorem\
  \ rotate_period {α : Type u} (arr : List α) :\n  arr ≠ [] → rotate arr (List.length\
  \ arr) = arr :=\n  sorry\n\n\ntheorem rotate_split {α : Type u} (arr : List α) (n\
  \ : Int) :\n  arr ≠ [] →\n  let normalized := Int.mod n (List.length arr)\n  rotate\
  \ arr n = arr.drop (List.length arr - normalized.toNat) ++ arr.take (List.length\
  \ arr - normalized.toNat) :=\n  sorry\n\n\ntheorem rotate_compose {α : Type u} (arr\
  \ : List α) (n1 n2 : Int) :\n  arr ≠ [] →\n  rotate (rotate arr n1) n2 = rotate\
  \ arr (Int.mod (n1 + n2) (List.length arr)) :=\n  sorry\n\n\ntheorem rotate_inverse\
  \ {α : Type u} (arr : List α) (n : Int) :\n  arr ≠ [] →\n  rotate (rotate arr n)\
  \ (-n) = arr :=\n  sorry\n\n/--\ninfo: ['c', 'a', 'b']\n-/\n#guard_msgs in\n#eval\
  \ rotate [\"a\", \"b\", \"c\"] 1\n\n/--\ninfo: [3.0, 1.0, 2.0]\n-/\n#guard_msgs\
  \ in\n#eval rotate [1.0, 2.0, 3.0] 1\n\n/--\ninfo: [False, True, True]\n-/\n#guard_msgs\
  \ in\n#eval rotate [True, True, False] 1\n\n/--\ninfo: [4, 5, 1, 2, 3]\n-/\n#guard_msgs\
  \ in\n#eval rotate [1, 2, 3, 4, 5] 7\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
