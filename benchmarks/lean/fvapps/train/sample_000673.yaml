"vc-description": "There is crazy man named P29892P. He always tries to do crazy things\
  \ as he thinks. One day he invented a machine and named it as ANGEN. The ANGEN is\
  \ used to perform range operations. The range operation means performing operations\
  \ on range values from {L..R}. At any time it performs operations on values in between\
  \ L to R.\nANGEN can perform following operations\nU I V - Update the value present\
  \ at I  with value V\nA L R - Find the sum between range L and R\nM L R - Find the\
  \ maximum number between L and R\nm L R - Find the minimum number between L and\
  \ R\nS L R - Find second maximum value in between L and R\ns L R - Find second mimimum\
  \ value in between L and R\nIf it is not possible perform operation ANGEN returns\
  \ “NA” with out quotes.\nFor Invalid operations ANGEN returns “!!!” with out quotes.\n\
  Now P29892P challenging his friends and you too, to build his invention with yourown\
  \ code. So it's your time to defeat P29892P by implementing his invention with your\
  \ own ability. Let's go and solve the problem.\n\n-----Input-----\nInput description.\n\
  - The first line of the input contains an integer N denoting the number of integers.\
  \ \n- The next line contains N space separated integers.\"\n- The next line contains\
  \ a single integer Q denoting the number of Questions.\n-  The next Q lines contains\
  \ T Question type , L and R.\n\n-----Output-----\nPrint output for each question\
  \ in separate line.\n\n-----Constraints-----\nShould contain all the constraints\
  \ on the input data that you may have. Format it like:\n- 1 ≤ N ≤ 100000\n- 1 ≤\
  \ values[i] ≤ 1000000000\n- 1 ≤ Q ≤ 10000\n- T in { A..Z, a..z }\n- 1 ≤ L ≤ R ≤\
  \ N\n\n-----Example-----\nInput:\n6\n1 2 5 3 10 6\n6\nA 1 5\nM 1 3\nm 5 6\ns 3 6\n\
  U 1 7\nS 1 2\n\nOutput:\n21\n5\n6\n5\n2\n\n-----Explanation-----\n..."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def process_angen_operations (nums: List Int) (operations: List\
  \ (Char × String × String)) : List String :=\n  sorry\n"
"vc-theorems": "theorem process_operations_basic_props \n  (nums: List Int) \n  (operations:\
  \ List (Char × String × String))\n  (h1: nums.length ≥ 1)\n  (h2: ∀ op ∈ operations,\
  \ \n    (toString op.1 = \"U\" ∨ toString op.1 = \"A\" ∨ toString op.1 = \"M\" ∨\
  \ \n     toString op.1 = \"m\" ∨ toString op.1 = \"S\" ∨ toString op.1 = \"s\")\
  \ ∧\n    ((String.toNat! op.2.1) ≤ nums.length) ∧  \n    ((String.toNat! op.2.2)\
  \ ≤ nums.length) ∧\n    ((String.toNat! op.2.1) ≤ (String.toNat! op.2.2))) :\n \
  \ let results := process_angen_operations nums operations\n  ∀ r ∈ results, r.length\
  \ > 0 :=\nsorry\n\n\ntheorem process_operations_arithmetic \n  (nums: List Int)\n\
  \  (operations: List (Char × String × String))\n  (h1: nums.length ≥ 1)\n  (op:\
  \ Char × String × String)\n  (h2: op ∈ operations)\n  (h3: op.1 = 'A' ∨ op.1 = 'M'\
  \ ∨ op.1 = 'm') :\n  let l := (String.toNat! op.2.1) - 1\n  let r := String.toNat!\
  \ op.2.2\n  let subarray := nums.take r |>.drop l\n  let result := (process_angen_operations\
  \ nums operations)[operations.indexOf op]!\n  match op.1 with\n  | 'A' => result\
  \ = toString (subarray.foldl (· + ·) 0)\n  | 'M' => result = toString (List.maximum?\
  \ subarray |>.get!)\n  | 'm' => result = toString (List.minimum? subarray |>.get!)\n\
  \  | _ => True :=\nsorry\n\n\ntheorem process_invalid_operations\n  (nums: List\
  \ Int)\n  (operations: List (Char × String × String))\n  (h1: nums.length ≥ 1)\n\
  \  (h2: ∀ op ∈ operations, \n    op.1 ≠ 'U' ∧ op.1 ≠ 'A' ∧ op.1 ≠ 'M' ∧ \n    op.1\
  \ ≠ 'm' ∧ op.1 ≠ 'S' ∧ op.1 ≠ 's') :\n  let results := process_angen_operations\
  \ nums operations\n  ∀ r ∈ results, r = \"!!!\" :=\nsorry\n\n\ntheorem process_second_extremes\n\
  \  (nums: List Int)\n  (operations: List (Char × String × String))\n  (h1: nums.length\
  \ ≥ 1) \n  (op: Char × String × String)\n  (h2: op ∈ operations)\n  (h3: op.1 =\
  \ 'S' ∨ op.1 = 's')\n  (h4: (String.toNat! op.2.1) ≤ nums.length)\n  (h5: (String.toNat!\
  \ op.2.2) ≤ nums.length)\n  (h6: (String.toNat! op.2.1) ≤ (String.toNat! op.2.2))\
  \ :\n  let l := (String.toNat! op.2.1) - 1\n  let r := String.toNat! op.2.2\n  let\
  \ subarray := nums.take r |>.drop l\n  let result := (process_angen_operations nums\
  \ operations)[operations.indexOf op]!\n  (List.length subarray < 2 → result = \"\
  NA\") ∧\n  (List.length subarray ≥ 2 →\n    match op.1 with\n    | 's' => result.toInt?\
  \ |>.map (λ x => x ≥ (List.minimum? subarray |>.get!)) |>.getD false\n    | 'S'\
  \ => result.toInt? |>.map (λ x => x ≤ (List.maximum? subarray |>.get!)) |>.getD\
  \ false\n    | _ => True) :=\nsorry\n\n/--\ninfo: expected\n-/\n#guard_msgs in\n\
  #eval process_angen_operations [1, 2, 5, 3, 10, 6] [(\"A\", \"1\", \"5\"), (\"M\"\
  , \"1\", \"3\"), (\"m\", \"5\", \"6\"), (\"s\", \"3\", \"6\"), (\"U\", \"1\", \"\
  7\"), (\"S\", \"1\", \"2\")]\n\n/--\ninfo: ['!!!']\n-/\n#guard_msgs in\n#eval process_angen_operations\
  \ [1, 2, 3] [(\"X\", \"1\", \"2\")]\n\n/--\ninfo: ['NA']\n-/\n#guard_msgs in\n#eval\
  \ process_angen_operations [1, 1, 1] [(\"s\", \"1\", \"3\")]\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
