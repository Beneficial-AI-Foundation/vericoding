"vc-description": "Assume we take a number `x` and perform any one of the following\
  \ operations:\n```Pearl\na) Divide x by 3 (if it is divisible by 3), or\nb) Multiply\
  \ x by 2\n```\nAfter each operation, we write down the result. If we start with\
  \ `9`, we can get a sequence such as:\n```\n[9,3,6,12,4,8] -- 9/3=3 -> 3*2=6 ->\
  \ 6*2=12 -> 12/3=4 -> 4*2=8\n```\nYou will be given a shuffled sequence of integers\
  \ and your task is to reorder them so that they conform to the above sequence. There\
  \ will always be an answer. \n```\nFor the above example:\nsolve([12,3,9,4,6,8])\
  \ = [9,3,6,12,4,8].\n```\n\nMore examples in the test cases. Good luck!"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def solve (arr : List Nat) : Option (List Nat) := sorry\n\ntheorem\
  \ solve_preserves_length {arr : List Nat} {result : List Nat} :\n  solve arr = some\
  \ result → result.length = arr.length := sorry\n"
"vc-theorems": "theorem solve_preserves_elements {arr : List Nat} {result : List Nat}\
  \ :\n  solve arr = some result → \n  ∀ x, x ∈ arr ↔ x ∈ result := sorry\n\n\ntheorem\
  \ solve_adjacent_pairs_rule {arr : List Nat} {result : List Nat} :\n  solve arr\
  \ = some result →\n  ∀ i, i < result.length - 1 → \n    (result[i]! * 2 = result[i+1]!\
  \ ∨ result[i]! = result[i+1]! * 3) := sorry\n\n\ntheorem solve_duplicates {arr :\
  \ List Nat} :\n  ¬arr.Nodup → solve arr = none := sorry \n\n\ntheorem solve_empty\
  \ :\n  solve [] = none := sorry\n\n\ntheorem solve_single (n : Nat) :\n  solve [n]\
  \ = some [n] := sorry\n\n/--\ninfo: [9, 3, 6, 12, 4, 8]\n-/\n#guard_msgs in\n#eval\
  \ solve [12, 3, 9, 4, 6, 8]\n\n/--\ninfo: [2, 4]\n-/\n#guard_msgs in\n#eval solve\
  \ test2\n\n/--\ninfo: [279, 558, 1116, 2232, 744, 1488]\n-/\n#guard_msgs in\n#eval\
  \ solve test3\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
