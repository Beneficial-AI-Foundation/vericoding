"vc-description": "We define the function `f1(n,k)`, as the least multiple of `n`\
  \ that has all its digits less than `k`. \n\nWe define the function `f2(n,k)`, as\
  \ the least multiple of `n` that has all the digits that are less than `k`.\n\n\
  Each digit may occur more than once in both values of `f1(n,k)` and `f2(n,k)`.\n\
  \nThe possible values for `n` and `k` according to these ranges for both functions\
  \ `f1` and `f2` in this kata:\n``` \n1 <= n <= 1.000.000.000.000\n3 <= k <= 9\n\
  ``` \n\nFor example, let's see the value of both functions for `n = 71` and `k =\
  \ 4`:\n``` \nf1(71,4) == 213 # all its digits less than 4\nf2(71,4) == 2130 # 0,1,2,3\
  \ all of them present \n```\nThe integer `76` is the first integer that has the\
  \ same values of `f1` and `f2` for `k = 4`. \n```\nf1(76,4) = f2(76,4) = 10032\n\
  ```\nLet's call these kind of numbers, **forgiving numbers**. (Let's continue with\
  \ the fashion of attributing personality traits to numbers and, of course, an unknown\
  \ one)\nSo, `76` is the smallest forgiving number of order `4`.\nIn the same way,\
  \ `485` is the smallest forgiving number of order `5`.\n\nCreate a function that\
  \ given an integer `n` and the order `k`, will output the higher and closest forgiving\
  \ number to `n` of order `k`.\n\nLet's see some examples:\n```\nfind_f1_eq_f2(500,5)\
  \ == 547\nfind_f1_eq_f2(1600,6) == 1799\nfind_f1_eq_f2(14900,7) == 14996\n```\n\
  If the number `n` is a forgiving itself for a certain order `k`, the function will\
  \ never output the same value, remember, closest and **higher** than `n`.\n\nFor\
  \ example, `3456`, is a forgiving one of order `4`,\n```\nfind_f1_eq_f2(3456,4)\
  \ == 3462\n```\n**Features of the tests:**\n\n* `n` and `k` will be always valid\
  \ and positive integers.\n\n* A total of 8 fixed tests.\n\n* A total of 150 random\
  \ tests in the ranges for `n` and `k` given above.\n\nI'll be waiting your awesome\
  \ solution. :)"
"vc-preamble": "import Imports.AllImports\n\ndef find_f1_eq_f2 (n : Nat) (k : Nat)\
  \ : Nat := sorry\n\ntheorem find_f1_eq_f2_basic_case_1 :\n  find_f1_eq_f2 542 5\
  \ = 547 := sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def appears_in (d : Nat) (n : Nat) : Prop := sorry \n\ntheorem\
  \ find_f1_eq_f2_generates_digits (n k : Nat) (testn := find_f1_eq_f2 n k) :\n  ∃\
  \ m : Nat, ∀ d : Nat, d < k → ∃ i : Nat, i ≤ m ∧ appears_in d (testn * i) := sorry"
"vc-theorems": "theorem find_f1_eq_f2_basic_case_2 :\n  find_f1_eq_f2 1750 6 = 1799\
  \ := sorry\n\n\ntheorem find_f1_eq_f2_greater_than_input (n k : Nat) :\n  find_f1_eq_f2\
  \ n k ≥ n := sorry\n\n\n/--\ninfo: 547\n-/\n#guard_msgs in\n#eval find_f1_eq_f2\
  \ 542 5\n\n/--\ninfo: 1799\n-/\n#guard_msgs in\n#eval find_f1_eq_f2 1750 6\n\n/--\n\
  info: 14996\n-/\n#guard_msgs in\n#eval find_f1_eq_f2 14990 7\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
