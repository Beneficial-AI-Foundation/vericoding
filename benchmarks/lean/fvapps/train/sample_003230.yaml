"vc-description": "In this kata you will be given a random string of letters and tasked\
  \ with returning them as a string of comma-separated sequences sorted alphabetically,\
  \ with each sequence starting with an uppercase character followed by `n-1` lowercase\
  \ characters, where `n` is the letter's alphabet position `1-26`.\n\n## Example\n\
  \n```python\nalpha_seq(\"ZpglnRxqenU\") -> \"Eeeee,Ggggggg,Llllllllllll,Nnnnnnnnnnnnnn,Nnnnnnnnnnnnnn,Pppppppppppppppp,Qqqqqqqqqqqqqqqqq,Rrrrrrrrrrrrrrrrrr,Uuuuuuuuuuuuuuuuuuuuu,Xxxxxxxxxxxxxxxxxxxxxxxx,Zzzzzzzzzzzzzzzzzzzzzzzzzz\"\
  \n```\n\n## Technical Details\n\n- The string will include only letters.\n- The\
  \ first letter of each sequence is uppercase followed by `n-1` lowercase.\n- Each\
  \ sequence is separated with a comma.\n- Return value needs to be a string."
"vc-preamble": "import Imports.AllImports\n\ndef isLower (c : Char) : Bool :=\n  97\
  \ ≤ c.toNat && c.toNat ≤ 122\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def alpha_seq (s : String) : String :=\n  sorry\n"
"vc-theorems": "theorem alpha_seq_parts_sorted {s : String} (h : s ≠ \"\") : \n  let\
  \ parts := s.split (· = ',')\n  ∀ i j, i < j → j < parts.length → \n    let p1 :=\
  \ (parts[i]?.getD \"\")\n    let p2 := (parts[j]?.getD \"\")\n    p1.length > 0\
  \ → p2.length > 0 →\n    (p1.data[0]?.getD ' ').toLower ≤ (p2.data[0]?.getD ' ').toLower\
  \ := by\n  sorry \n\n\ntheorem alpha_seq_parts_capitalized {s : String} (h : s ≠\
  \ \"\") :\n  let parts := s.split (· = ',')\n  ∀ part ∈ parts, part.length > 0 →\
  \ \n    part.data[0]?.getD ' ' = (part.data[0]?.getD ' ').toUpper := by\n  sorry\n\
  \n\ntheorem alpha_seq_parts_rest_lowercase {s : String} (h : s ≠ \"\") :\n  let\
  \ parts := s.split (· = ',')\n  ∀ part ∈ parts, ∀ i, 0 < i → i < part.length → \n\
  \    part.data[i]?.getD ' ' = (part.data[i]?.getD ' ').toLower := by\n  sorry\n\n\
  \ntheorem alpha_seq_parts_length {s : String} (h : s ≠ \"\") :\n  let parts := s.split\
  \ (· = ',')\n  ∀ part ∈ parts, part.length > 0 → \n    part.length = (part.data[0]?.getD\
  \ ' ').toLower.toNat - 96 := by\n  sorry\n\n\ntheorem alpha_seq_parts_same_char\
  \ {s : String} (h : s ≠ \"\") :\n  let parts := s.split (· = ',')\n  ∀ part ∈ parts,\
  \ ∀ i, i < part.length →\n    (part.data[i]?.getD ' ').toLower = (part.data[0]?.getD\
  \ ' ').toLower := by\n  sorry\n\n/--\ninfo: 'A,Bb,Ccc,Ffffff,Ffffff'\n-/\n#guard_msgs\
  \ in\n#eval alpha_seq \"BfcFA\"\n\n/--\ninfo: 'Ggggggg,Llllllllllll,Nnnnnnnnnnnnnn,Pppppppppppppppp,Rrrrrrrrrrrrrrrrrr,Zzzzzzzzzzzzzzzzzzzzzzzzzz'\n\
  -/\n#guard_msgs in\n#eval alpha_seq \"ZpglnR\"\n\n/--\ninfo: 'A,Bb,Ccc'\n-/\n#guard_msgs\
  \ in\n#eval alpha_seq \"Abc\"\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
