"vc-description": "There are n engineers numbered from 1 to n and two arrays: speed and\
  \ efficiency, where speed[i] and efficiency[i] represent the speed and efficiency\
  \ for the i-th engineer respectively. Return the maximum performance of a team composed\
  \ of at most k engineers, since the answer can be a huge number, return this modulo 10^9\
  \ + 7.\nThe performance of a team is the sum of their engineers' speeds multiplied\
  \ by the minimum efficiency among their engineers. \n \nExample 1:\nInput: n = 6,\
  \ speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 2\nOutput: 60\nExplanation:\
  \ \nWe have the maximum performance of the team by selecting engineer 2 (with speed=10\
  \ and efficiency=4) and engineer 5 (with speed=5 and efficiency=7). That is, performance\
  \ = (10 + 5) * min(4, 7) = 60.\n\nExample 2:\nInput: n = 6, speed = [2,10,3,1,5,8],\
  \ efficiency = [5,4,3,9,7,2], k = 3\nOutput: 68\nExplanation:\nThis is the same\
  \ example as the first but k = 3. We can select engineer 1, engineer 2 and engineer\
  \ 5 to get the maximum performance of the team. That is, performance = (2 + 10 +\
  \ 5) * min(5, 4, 7) = 68.\n\nExample 3:\nInput: n = 6, speed = [2,10,3,1,5,8], efficiency\
  \ = [5,4,3,9,7,2], k = 4\nOutput: 72\n\n \nConstraints:\n\n1 <= n <= 10^5\nspeed.length\
  \ == n\nefficiency.length == n\n1 <= speed[i] <= 10^5\n1 <= efficiency[i] <= 10^8\n\
  1 <= k <= n"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def max_performance (n : Nat) (speeds : List Nat) (efficiencies\
  \ : List Nat) (k : Nat) : Nat := sorry\n\ndef MOD := 1000000007\n"
"vc-theorems": "theorem max_performance_mod (n : Nat) (speeds : List Nat) (efficiencies\
  \ : List Nat) (k : Nat) :\n  0 ≤ max_performance n speeds efficiencies k ∧ \n  max_performance\
  \ n speeds efficiencies k < MOD := sorry\n\n\ntheorem max_performance_geq_single_max\
  \ (n : Nat) (speeds : List Nat) (efficiencies : List Nat) (k : Nat)\n  (h1 : speeds.length\
  \ = n) (h2 : efficiencies.length = n) (h3 : k ≤ n) :\n  ∃ maxProd : Nat, \n    maxProd\
  \ = List.foldr (fun i acc => max acc ((speeds.get! i) * (efficiencies.get! i)))\
  \ 0 (List.range n) ∧\n    max_performance n speeds efficiencies k ≥ maxProd := sorry\n\
  \n\ntheorem max_performance_monotone (n : Nat) (speeds : List Nat) (efficiencies\
  \ : List Nat) \n  (k : Nat) (h1 : k > 1) (h2 : k ≤ n) :\n  max_performance n speeds\
  \ efficiencies k ≥ \n  max_performance n speeds efficiencies (k-1) := sorry\n\n\n\
  theorem max_performance_min_case :\n  max_performance 1 [1] [1] 1 = 1 := sorry\n\
  \n\ntheorem max_performance_k_one (n : Nat) (speeds : List Nat) (efficiencies :\
  \ List Nat)\n  (h1 : speeds = [2,1,3]) (h2 : efficiencies = [3,2,1]) (h3 : n = 3)\
  \ :\n  max_performance n speeds efficiencies 1 = 6 := sorry\n\n/--\ninfo: 60\n-/\n\
  #guard_msgs in\n#eval max_performance 6 [2, 10, 3, 1, 5, 8] [5, 4, 3, 9, 7, 2] 2\n\
  \n/--\ninfo: 68\n-/\n#guard_msgs in\n#eval max_performance 6 [2, 10, 3, 1, 5, 8]\
  \ [5, 4, 3, 9, 7, 2] 3\n\n/--\ninfo: 72\n-/\n#guard_msgs in\n#eval max_performance\
  \ 6 [2, 10, 3, 1, 5, 8] [5, 4, 3, 9, 7, 2] 4\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
