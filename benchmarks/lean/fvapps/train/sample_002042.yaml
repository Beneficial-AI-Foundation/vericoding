"vc-description": "Mitya has a rooted tree with $n$ vertices indexed from $1$ to $n$,\
  \ where the root has index $1$. Each vertex $v$ initially had an integer number\
  \ $a_v \\ge 0$ written on it. For every vertex $v$ Mitya has computed $s_v$: the\
  \ sum of all values written on the vertices on the path from vertex $v$ to the root,\
  \ as well as $h_v$ — the depth of vertex $v$, which denotes the number of vertices\
  \ on the path from vertex $v$ to the root. Clearly, $s_1=a_1$ and $h_1=1$.\n\nThen\
  \ Mitya erased all numbers $a_v$, and by accident he also erased all values $s_v$\
  \ for vertices with even depth (vertices with even $h_v$). Your task is to restore\
  \ the values $a_v$ for every vertex, or determine that Mitya made a mistake. In\
  \ case there are multiple ways to restore the values, you're required to find one\
  \ which minimizes the total sum of values $a_v$ for all vertices in the tree.\n\n\
  \n-----Input-----\n\nThe first line contains one integer $n$ — the number of vertices\
  \ in the tree ($2 \\le n \\le 10^5$). The following line contains integers $p_2$,\
  \ $p_3$, ... $p_n$, where $p_i$ stands for the parent of vertex with index $i$ in\
  \ the tree ($1 \\le p_i < i$). The last line contains integer values $s_1$, $s_2$,\
  \ ..., $s_n$ ($-1 \\le s_v \\le 10^9$), where erased values are replaced by $-1$.\n\
  \n\n-----Output-----\n\nOutput one integer — the minimum total sum of all values\
  \ $a_v$ in the original tree, or $-1$ if such tree does not exist.\n\n\n-----Examples-----\n\
  Input\n5\n1 1 1 1\n1 -1 -1 -1 -1\n\nOutput\n1\n\nInput\n5\n1 2 3 1\n1 -1 2 -1 -1\n\
  \nOutput\n2\n\nInput\n3\n1 2\n2 -1 1\n\nOutput\n-1"
"vc-preamble": "import Imports.AllImports\n\ndef is_valid_tree (n : Nat) (parents\
  \ : List Nat) : Bool :=\n  sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def solve_tree_values (n : Nat) (parents : List Nat) (sums : List\
  \ Int) : Int :=\n  sorry\n"
"vc-theorems": "theorem single_node_tree (n : Int) (h : n > 0) :\n  solve_tree_values\
  \ 1 [] [n] = n :=\n  sorry\n\n\ntheorem star_tree_valid (n : Nat) (parents : List\
  \ Nat) (values : List Int)\n  (h1 : n ≥ 2)\n  (h2 : parents.length = n - 1)\n  (h3\
  \ : ∀ p ∈ parents, p = 1)  \n  (h4 : values.length = n)\n  (h5 : is_valid_tree n\
  \ parents = true) :\n  let result := solve_tree_values n parents values\n  if ∃\
  \ v ∈ values, v < 0\n  then result ≥ -1 \n  else result ≥ values.get! 0 :=\n  sorry\n\
  \n\ntheorem path_tree_valid (n : Nat) (parents : List Nat) (values : List Int)\n\
  \  (h1 : n ≥ 2)\n  (h2 : parents.length = n - 1)\n  (h3 : values.length = n)\n \
  \ (h4 : ∀ (i : Nat), i < parents.length → parents.get! i ≤ i + 1)\n  (h5 : is_valid_tree\
  \ n parents = true) :\n  let result := solve_tree_values n parents values\n  if\
  \ ∃ v ∈ values, v < 0\n  then result ≥ -1\n  else result ≥ values.get! 0 :=\n  sorry\n\
  \n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_tree_values 5 [1, 1, 1, 1] [1, -1,\
  \ -1, -1, -1]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_tree_values 5 [1,\
  \ 2, 3, 1] [1, -1, 2, -1, -1]\n\n/--\ninfo: -1\n-/\n#guard_msgs in\n#eval solve_tree_values\
  \ 3 [1, 2] [2, -1, 1]\n"
"vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded"
