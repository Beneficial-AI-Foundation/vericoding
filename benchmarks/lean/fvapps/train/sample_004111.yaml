"vc-description": "*Shamelessly stolen from Here :)*\n\nYour server has sixteen memory\
  \ banks; each memory bank can hold any number of blocks. You must write a routine\
  \ to balance the blocks between the memory banks.\n\nThe reallocation routine operates\
  \ in cycles. In each cycle, it finds the memory bank with the most blocks (ties\
  \ won by the lowest-numbered memory bank) and redistributes those blocks among the\
  \ banks. To do this, it removes all of the blocks from the selected bank, then moves\
  \ to the next (by index) memory bank and inserts one of the blocks. It continues\
  \ doing this until it runs out of blocks; if it reaches the last memory bank, it\
  \ wraps around to the first one.\n\nWe need to know how many redistributions can\
  \ be done before a blocks-in-banks configuration is produced that has been seen\
  \ before.\n\nFor example, imagine a scenario with only four memory banks:\n\n* The\
  \ banks start with 0, 2, 7, and 0 blocks (`[0,2,7,0]`). The third bank has the most\
  \ blocks (7), so it is chosen for redistribution.\n* Starting with the next bank\
  \ (the fourth bank) and then continuing one block at a time, the 7 blocks are spread\
  \ out over the memory banks. The fourth, first, and second banks get two blocks\
  \ each, and the third bank gets one back. The final result looks like this: 2 4\
  \ 1 2.\n* Next, the second bank is chosen because it contains the most blocks (four).\
  \ Because there are four memory banks, each gets one block. The result is: 3 1 2\
  \ 3.\n* Now, there is a tie between the first and fourth memory banks, both of which\
  \ have three blocks. The first bank wins the tie, and its three blocks are distributed\
  \ evenly over the other three banks, leaving it with none: 0 2 3 4.\n* The fourth\
  \ bank is chosen, and its four blocks are distributed such that each of the four\
  \ banks receives one: 1 3 4 1.\n* The third bank is chosen, and the same thing happens:\
  \ 2 4 1 2.\nAt this point, we've reached a state we've seen before: 2 4 1 2 was\
  \ already seen. The infinite loop is detected after the fifth block redistribution\
  \ cycle, and so the answer in this example is 5.\n\nReturn the number of redistribution\
  \ cycles completed before a configuration is produced that has been seen before.\n\
  \nPeople seem to be struggling, so here's a visual walkthrough of the above example:\
  \ http://oi65.tinypic.com/dmshls.jpg\n\nNote: Remember, memory access is very fast.\
  \ Yours should be too.\n\n**Hint for those who are timing out:** Look at the number\
  \ of cycles happening even in the sample tests. That's a _lot_ of different configurations,\
  \ and a lot of different times you're going to be searching for a matching sequence.\
  \ Think of ways to cut down on the time this searching process takes.\n\nPlease\
  \ upvote if you enjoyed! :)"
"vc-preamble": "import Imports.AllImports\n\ndef mem_alloc (banks : List Nat) : Nat\
  \ := sorry\n\ntheorem mem_alloc_positive (banks : List Nat) (h : banks.length =\
  \ 16) :\n  mem_alloc banks > 0 := sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def list_sum (xs : List Nat) : Nat :=\n  xs.foldl (· + ·) 0"
"vc-theorems": "theorem mem_alloc_preserves_input (banks : List Nat) (h : banks.length\
  \ = 16) :\n  mem_alloc banks = mem_alloc banks := sorry\n\n\n\n\ntheorem mem_alloc_deterministic\
  \ (banks : List Nat) (h : banks.length = 16) :\n  mem_alloc banks = mem_alloc banks\
  \ := sorry\n\n\n\n\n/--\ninfo: 70\n-/\n#guard_msgs in\n#eval mem_alloc [5, 1, 10,\
  \ 0, 1, 7, 13, 14, 3, 12, 8, 10, 7, 12, 0, 600]\n\n/--\ninfo: 316\n-/\n#guard_msgs\
  \ in\n#eval mem_alloc [53, 21, 10, 0, 1, 7, 13, 14, 3, 12, 8, 10, 7, 12, 0, 60]\n\
  \n/--\ninfo: 826\n-/\n#guard_msgs in\n#eval mem_alloc [14, 21, 10, 0, 1, 7, 0, 14,\
  \ 3, 12, 8, 10, 17, 12, 0, 19]\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible"
