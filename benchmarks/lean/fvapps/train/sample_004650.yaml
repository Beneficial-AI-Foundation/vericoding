"vc-description": "Given an array `A` and an integer `x`, map each element in the\
  \ array to `F(A[i],x)` then return the xor sum of the resulting array.\n\nwhere\
  \ F(n,x) is defined as follows:\n\nF(n, x) = ^(x)Cx **+** ^(x+1)Cx **+** ^(x+2)Cx\
  \ **+** ... **+** ^(n)Cx\n\nand ^(n)Cx represents [Combination](https://en.m.wikipedia.org/wiki/Combination)\
  \ in mathematics\n\n### Example\n\n```python\na = [7, 4, 11, 6, 5]\nx = 3\n\n# after\
  \ mapping, `a` becomes [F(7,3), F(4,3), F(11,3), F(6,3), F(5,3)]\n\nreturn F(7,3)\
  \ ^ F(4,3) ^ F(11,3) ^ F(6,3) ^ F(5,3)\n#=> 384\n```\n##### e.g\nF(7, 3) = ^(3)C3\
  \ + ^(4)C3 + ^(5)C3  + ^(6)C3 + ^(7)C3\n\n\n## Constraints\n\n**1 <= x <= 10**\n\
  \n**x <= A[i] <= 10^(4)**\n\n**5 <= |A| <= 10^(3)**"
"vc-preamble": "import Imports.AllImports\n\ndef Nat.choose (n k : Nat) : Nat := sorry\n\
  \ndef List.sort (l : List Nat) : List Nat := sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def transform (arr : List Nat) (x : Nat) : Nat := sorry\n\ntheorem\
  \ transform_single_element (n x : Nat) (h : x ≤ n) :\n  transform [n] x = (List.range\
  \ (n - x + 1)).foldl (fun acc i => acc + Nat.choose (i + x) x) 0 :=\nsorry\n"
"vc-theorems": "theorem transform_shuffle (arr : List Nat) (x : Nat) (h : ∀ n ∈ arr,\
  \ n ≥ x) :\n  transform arr x = transform (List.sort arr) x :=\nsorry \n\n\ntheorem\
  \ transform_zero_x (arr : List Nat) :\n  transform arr 0 = List.foldl (fun acc n\
  \ => acc + (n + 1)) 0 arr :=\nsorry\n\n/--\ninfo: 384\n-/\n#guard_msgs in\n#eval\
  \ transform [7, 4, 11, 6, 5] 3\n\n/--\ninfo: 15\n-/\n#guard_msgs in\n#eval transform\
  \ [5, 6, 7] 2\n\n/--\ninfo: 462\n-/\n#guard_msgs in\n#eval transform [10] 5\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
