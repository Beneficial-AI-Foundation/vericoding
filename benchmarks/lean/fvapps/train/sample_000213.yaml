"vc-description": "We have an array A of non-negative integers.\nFor every (contiguous)\
  \ subarray B = [A[i], A[i+1], ..., A[j]] (with i <= j), we take the bitwise OR of\
  \ all the elements in B, obtaining a result A[i] | A[i+1] | ... | A[j].\nReturn\
  \ the number of possible results.  (Results that occur more than once are only counted\
  \ once in the final answer.)\n \n\nExample 1:\nInput: [0]\nOutput: 1\nExplanation:\
  \ \nThere is only one possible result: 0.\n\n\nExample 2:\nInput: [1,1,2]\nOutput:\
  \ 3\nExplanation: \nThe possible subarrays are [1], [1], [2], [1, 1], [1, 2], [1,\
  \ 1, 2].\nThese yield the results 1, 1, 2, 1, 3, 3.\nThere are 3 unique values,\
  \ so the answer is 3.\n\n\nExample 3:\nInput: [1,2,4]\nOutput: 6\nExplanation: \n\
  The possible results are 1, 2, 3, 4, 6, and 7.\n\n\n\n\n \nNote:\n\n1 <= A.length\
  \ <= 50000\n0 <= A[i] <= 10^9"
"vc-preamble": "import Imports.AllImports\n\ndef subarrayBitwiseORs (nums: List Nat)\
  \ : Nat := sorry\n\ntheorem result_is_nonnegative {nums: List Nat} (h: nums ≠ [])\
  \ :\n  subarrayBitwiseORs nums ≥ 0 := sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def countUnique (l: List Nat) : Nat := \n  (List.foldl (fun acc\
  \ x => if acc.contains x then acc else x::acc) [] l).length\n"
"vc-theorems": "theorem result_upper_bound {nums: List Nat} (h: nums ≠ []) :\n  subarrayBitwiseORs\
  \ nums ≤ (nums.length * (nums.length + 1)) / 2 := sorry\n\n\ntheorem single_element_subarray\
  \ {nums: List Nat} (h: nums ≠ []) :\n  subarrayBitwiseORs nums ≥ countUnique nums\
  \ := sorry\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval subarrayBitwiseORs [0]\n\n\
  /--\ninfo: 3\n-/\n#guard_msgs in\n#eval subarrayBitwiseORs [1, 1, 2]\n\n/--\ninfo:\
  \ 6\n-/\n#guard_msgs in\n#eval subarrayBitwiseORs [1, 2, 4]\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
