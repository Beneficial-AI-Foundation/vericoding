"vc-description": "The Fair Nut is going to travel to the Tree Country, in which there\
  \ are $n$ cities. Most of the land of this country is covered by forest. Furthermore,\
  \ the local road system forms a tree (connected graph without cycles). Nut wants\
  \ to rent a car in the city $u$ and go by a simple path to city $v$. He hasn't determined\
  \ the path, so it's time to do it. Note that chosen path can consist of only one\
  \ vertex.\n\nA filling station is located in every city. Because of strange law,\
  \ Nut can buy only $w_i$ liters of gasoline in the $i$-th city. We can assume, that\
  \ he has infinite money. Each road has a length, and as soon as Nut drives through\
  \ this road, the amount of gasoline decreases by length. Of course, Nut can't choose\
  \ a path, which consists of roads, where he runs out of gasoline. He can buy gasoline\
  \ in every visited city, even in the first and the last.\n\nHe also wants to find\
  \ the maximum amount of gasoline that he can have at the end of the path. Help him:\
  \ count it.\n\n\n-----Input-----\n\nThe first line contains a single integer $n$\
  \ ($1 \\leq n \\leq 3 \\cdot 10^5$) — the number of cities.\n\nThe second line contains\
  \ $n$ integers $w_1, w_2, \\ldots, w_n$ ($0 \\leq w_{i} \\leq 10^9$) — the maximum\
  \ amounts of liters of gasoline that Nut can buy in cities.\n\nEach of the next\
  \ $n - 1$ lines describes road and contains three integers $u$, $v$, $c$ ($1 \\\
  leq u, v \\leq n$, $1 \\leq c \\leq 10^9$, $u \\ne v$), where $u$ and $v$ — cities\
  \ that are connected by this road and $c$ — its length.\n\nIt is guaranteed that\
  \ graph of road connectivity is a tree.\n\n\n-----Output-----\n\nPrint one number —\
  \ the maximum amount of gasoline that he can have at the end of the path.\n\n\n\
  -----Examples-----\nInput\n3\n1 3 3\n1 2 2\n1 3 2\n\nOutput\n3\n\nInput\n5\n6 3\
  \ 2 5 0\n1 2 10\n2 3 3\n2 4 1\n1 5 1\n\nOutput\n7\n\n\n\n-----Note-----\n\nThe optimal\
  \ way in the first example is $2 \\to 1 \\to 3$.  [Image] \n\nThe optimal way in\
  \ the second example is $2 \\to 4$.  [Image]"
"vc-preamble": "import Imports.AllImports\n\ndef make_tree_edges (n : Nat) (edge_weights\
  \ : List Nat) : List (Nat × Nat × Nat) :=\nsorry\n\n/-- Helper function to get maximum\
  \ of a list -/\n\ndef list_max (xs : List Nat) : Nat :=\nmatch xs with\n| [] =>\
  \ 0\n| (x::xs) => List.foldl Nat.max x xs\n\n/-- Main solve function signature -/"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def solve (n : Nat) (weights : List Nat) (roads : List (Nat × Nat\
  \ × Nat)) : Nat :=\nsorry\n\n/-- Result of solve is always a natural number -/"
"vc-theorems": "theorem solve_produces_nat (n : Nat) (weights : List Nat) (roads :\
  \ List (Nat × Nat × Nat)) :\n  solve n weights roads ≥ 0 := sorry\n\n/-- Result\
  \ is at least the maximum weight in the input weights -/\n\ntheorem solve_at_least_max_weight\
  \ (n : Nat) (weights : List Nat) (roads : List (Nat × Nat × Nat)) \n  (h : weights\
  \ ≠ []) :\n  solve n weights roads ≥ list_max weights := sorry\n\n/-- For singleton\
  \ input, result equals the single weight -/\n\ntheorem solve_singleton (w : Nat)\
  \ :\n  solve 1 [w] [] = w := sorry\n\n/-- Properties for small cases (n ≤ 3) -/\n\
  \ntheorem solve_small_cases (n : Nat) (weights : List Nat) (h₁ : n ≤ 3) (h₂ : weights.length\
  \ = n)\n  (h₃ : weights ≠ []) :\n  let roads := List.map (fun i => (i + 1, i + 2,\
  \ 1)) (List.range (n-1))\n  solve n weights roads ≥ list_max weights := sorry\n\n\
  /--\ninfo: 3\n-/\n#guard_msgs in\n#eval solve 3 [1, 3, 3] [[1, 2, 2], [1, 3, 2]]\n\
  \n/--\ninfo: 7\n-/\n#guard_msgs in\n#eval solve 5 [6, 3, 2, 5, 0] [[1, 2, 10], [2,\
  \ 3, 3], [2, 4, 1], [1, 5, 1]]\n\n/--\ninfo: 42\n-/\n#guard_msgs in\n#eval solve\
  \ 1 [42] []\n"
"vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded"
