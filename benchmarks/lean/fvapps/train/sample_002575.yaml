"vc-description": "Write a code that receives an array of numbers or strings, goes\
  \ one by one through it while taking one value out, leaving one value in, taking,\
  \ leaving, and back again to the beginning until all values are out.  \nIt's like\
  \ a circle of people who decide that every second person will leave it, until the\
  \ last person is there. So if the last element of the array is taken, the first\
  \ element that's still there, will stay.  \nThe code returns a new re-arranged array\
  \ with the taken values by their order. The first value of the initial array is\
  \ always taken.\n\nExamples:"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def yes_no (arr : List α) : List α := sorry\n\ntheorem yes_no_length_preserved\
  \ {α : Type} (arr : List α) : \n  List.length (yes_no arr) = List.length arr :=\
  \ sorry\n"
"vc-theorems": "theorem yes_no_first_element_preserved {α : Type} [Inhabited α] (arr\
  \ : List α) :\n  arr ≠ [] → List.head! (yes_no arr) = List.head! arr := sorry\n\n\
  \ntheorem yes_no_small_lists {α : Type} [Inhabited α] (arr : List α) :\n  (List.length\
  \ arr ≤ 1 → yes_no arr = arr) ∧\n  (List.length arr = 2 → \n    List.get! (yes_no\
  \ arr) 0 = List.get! arr 0 ∧\n    List.get! (yes_no arr) 1 = List.get! arr 1) :=\
  \ sorry\n\ntheorem yes_no_homogeneous_type {α : Type} (arr : List α) :\n  List.length\
  \ (yes_no arr) = List.length arr := sorry\n\n/--\ninfo: expected1\n-/\n#guard_msgs\
  \ in\n#eval yes_no [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n/--\ninfo: expected2\n-/\n\
  #guard_msgs in\n#eval yes_no [\"this\", \"code\", \"is\", \"right\", \"the\"]\n\n\
  /--\ninfo: expected3\n-/\n#guard_msgs in\n#eval yes_no [\"a\", \"b\"]\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
