"vc-description": "Arkady needs your help again! This time he decided to build his\
  \ own high-speed Internet exchange point. It should consist of n nodes connected\
  \ with minimum possible number of wires into one network (a wire directly connects\
  \ two nodes). Exactly k of the nodes should be exit-nodes, that means that each\
  \ of them should be connected to exactly one other node of the network, while all\
  \ other nodes should be connected to at least two nodes in order to increase the\
  \ system stability.\n\nArkady wants to make the system as fast as possible, so he\
  \ wants to minimize the maximum distance between two exit-nodes. The distance between\
  \ two nodes is the number of wires a package needs to go through between those two\
  \ nodes.\n\nHelp Arkady to find such a way to build the network that the distance\
  \ between the two most distant exit-nodes is as small as possible.\n\n\n-----Input-----\n\
  \nThe first line contains two integers n and k (3 ≤ n ≤ 2·10^5, 2 ≤ k ≤ n - 1) —\
  \ the total number of nodes and the number of exit-nodes.\n\nNote that it is always\
  \ possible to build at least one network with n nodes and k exit-nodes within the\
  \ given constraints.\n\n\n-----Output-----\n\nIn the first line print the minimum\
  \ possible distance between the two most distant exit-nodes. In each of the next\
  \ n - 1 lines print two integers: the ids of the nodes connected by a wire. The\
  \ description of each wire should be printed exactly once. You can print wires and\
  \ wires' ends in arbitrary order. The nodes should be numbered from 1 to n. Exit-nodes\
  \ can have any ids.\n\nIf there are multiple answers, print any of them.\n\n\n-----Examples-----\n\
  Input\n3 2\n\nOutput\n2\n1 2\n2 3\n\nInput\n5 3\n\nOutput\n3\n1 2\n2 3\n3 4\n3 5\n\
  \n\n\n-----Note-----\n\nIn the first example the only network is shown on the left\
  \ picture.\n\nIn the second example one of optimal networks is shown on the right\
  \ picture.\n\nExit-nodes are highlighted. [Image]"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def solve_network (n k : Nat) : NetworkSolution :=\n  sorry\n"
"vc-theorems": "theorem solve_network_valid (n k : Nat) (h1: n ≥ 2) (h2: k ≥ 1) (h3:\
  \ k < n) :\n  let sol := solve_network n k\n  -- Network has valid size\n  (sol.connections.length\
  \ = n - 1) ∧  \n  -- All nodes are in valid range\n  (∀ (u v : Nat), (u, v) ∈ sol.connections\
  \ → u ≤ n ∧ v ≤ n) ∧\n  -- No duplicate connections\n  (∀ (u v : Nat), (u, v) ∈\
  \ sol.connections → (v, u) ∉ sol.connections) ∧\n  -- First node has k children\n\
  \  (sol.connections.filter (fun (p : Nat × Nat) => p.1 = 1)).length = k ∧\n  --\
  \ Other nodes have exactly one parent\n  (∀ v : Nat, v ≠ 1 → v ≤ n → \n    (sol.connections.filter\
  \ (fun p => p.2 = v)).length = 1) :=\n  sorry\n\n\ntheorem solve_network_distance_positive\
  \ (n k : Nat) (h1: n ≥ 2) (h2: k ≥ 1) (h3: k < n) :\n  (solve_network n k).min_dist\
  \ > 0 :=\n  sorry\n\n\ntheorem solve_network_monotone_n (n k : Nat) (h1: n > k +\
  \ 2) (h2: k ≥ 1) :\n  (solve_network n k).min_dist ≥ (solve_network (n-1) k).min_dist\
  \ :=\n  sorry\n\n\ntheorem solve_network_monotone_k (n k : Nat) (h1: n ≥ 2) (h2:\
  \ k > 1) (h3: k < n) :\n  (solve_network n k).min_dist ≤ (solve_network n (k-1)).min_dist\
  \ :=\n  sorry\n\n/--\ninfo: n - 1\n-/\n#guard_msgs in\n#eval len conns\n\n/--\n\
  info: n - 1\n-/\n#guard_msgs in\n#eval len conns\n\n/--\ninfo: n - 1\n-/\n#guard_msgs\
  \ in\n#eval len conns\n"
"vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded"
