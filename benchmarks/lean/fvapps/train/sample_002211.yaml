"vc-description": "Kalila and Dimna are two jackals living in a huge jungle. One day\
  \ they decided to join a logging factory in order to make money. \n\nThe manager\
  \ of logging factory wants them to go to the jungle and cut n trees with heights\
  \ a_1, a_2, ..., a_{n}. They bought a chain saw from a shop. Each time they use\
  \ the chain saw on the tree number i, they can decrease the height of this tree\
  \ by one unit. Each time that Kalila and Dimna use the chain saw, they need to recharge\
  \ it. Cost of charging depends on the id of the trees which have been cut completely\
  \ (a tree is cut completely if its height equal to 0). If the maximum id of a tree\
  \ which has been cut completely is i (the tree that have height a_{i} in the beginning),\
  \ then the cost of charging the chain saw would be b_{i}. If no tree is cut completely,\
  \ Kalila and Dimna cannot charge the chain saw. The chainsaw is charged in the beginning.\
  \ We know that for each i < j, a_{i} < a_{j} and b_{i} > b_{j} and also b_{n} =\
  \ 0 and a_1 = 1. Kalila and Dimna want to cut all the trees completely, with minimum\
  \ cost. \n\nThey want you to help them! Will you?\n\n\n-----Input-----\n\nThe first\
  \ line of input contains an integer n (1 ≤ n ≤ 10^5). The second line of input contains\
  \ n integers a_1, a_2, ..., a_{n} (1 ≤ a_{i} ≤ 10^9). The third line of input contains\
  \ n integers b_1, b_2, ..., b_{n} (0 ≤ b_{i} ≤ 10^9).\n\nIt's guaranteed that a_1\
  \ = 1, b_{n} = 0, a_1 < a_2 < ... < a_{n} and b_1 > b_2 > ... > b_{n}.\n\n\n-----Output-----\n\
  \nThe only line of output must contain the minimum cost of cutting all the trees\
  \ completely.\n\nPlease, do not write the %lld specifier to read or write 64-bit\
  \ integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\
  \n\n-----Examples-----\nInput\n5\n1 2 3 4 5\n5 4 3 2 0\n\nOutput\n25\n\nInput\n\
  6\n1 2 3 10 20 30\n6 5 4 3 2 0\n\nOutput\n138"
"vc-preamble": "import Imports.AllImports\n\ndef min_cost_to_cut_trees (n : Nat) (heights\
  \ : List Nat) (costs : List Nat) : Nat :=\n  sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def sum_list : List Nat → Nat\n  | [] => 0\n  | h::t => h + sum_list\
  \ t  \n"
"vc-theorems": "theorem min_cost_non_negative (n : Nat) (heights : List Nat) (costs\
  \ : List Nat)\n  (h1 : n ≥ 2)\n  (h2 : heights.length = n)\n  (h3 : costs.length\
  \ = n)\n  (h4 : ∀ h ∈ heights, h ≥ 1 ∧ h ≤ 1000)\n  (h5 : ∀ c ∈ costs, c ≤ 1000)\n\
  \  (h6 : costs.head! > costs.getLast!) :\n  min_cost_to_cut_trees n heights costs\
  \ ≥ 0 :=\nsorry\n\n\ntheorem min_cost_upper_bound (n : Nat) (heights : List Nat)\
  \ (costs : List Nat)\n  (h1 : n ≥ 2)\n  (h2 : heights.length = n)\n  (h3 : costs.length\
  \ = n)\n  (h4 : ∀ h ∈ heights, h ≥ 1 ∧ h ≤ 1000)\n  (h5 : ∀ c ∈ costs, c ≤ 1000)\n\
  \  (h6 : costs.head! > costs.getLast!) :\n  min_cost_to_cut_trees n heights costs\
  \ ≤ sum_list (heights.map (· * costs.head!)) :=\nsorry\n\n\ntheorem min_cost_last_worker_bound\
  \ (heights : List Nat) (costs : List Nat)\n  (h1 : heights.length ≥ 2)\n  (h2 :\
  \ ∀ h ∈ heights, h ≥ 1 ∧ h ≤ 100)\n  (h3 : costs.length = heights.length)\n  (h4\
  \ : ∀ c ∈ costs, c ≤ 100) \n  (h5 : costs.head! > costs.getLast!) :\n  min_cost_to_cut_trees\
  \ heights.length heights costs ≥ heights.getLast! * costs.getLast! :=\nsorry\n\n\
  /--\ninfo: 25\n-/\n#guard_msgs in\n#eval min_cost_to_cut_trees 5 [1, 2, 3, 4, 5]\
  \ [5, 4, 3, 2, 0]\n\n/--\ninfo: 138\n-/\n#guard_msgs in\n#eval min_cost_to_cut_trees\
  \ 6 [1, 2, 3, 10, 20, 30] [6, 5, 4, 3, 2, 0]\n"
"vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded"
