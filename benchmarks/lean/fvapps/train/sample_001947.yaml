"vc-description": "Vanya wants to minimize a tree. He can perform the following operation\
  \ multiple times: choose a vertex v, and two disjoint (except for v) paths of equal\
  \ length a_0 = v, a_1, ..., a_{k}, and b_0 = v, b_1, ..., b_{k}. Additionally, vertices\
  \ a_1, ..., a_{k}, b_1, ..., b_{k} must not have any neighbours in the tree other\
  \ than adjacent vertices of corresponding paths. After that, one of the paths may\
  \ be merged into the other, that is, the vertices b_1, ..., b_{k} can be effectively\
  \ erased: [Image] \n\nHelp Vanya determine if it possible to make the tree into\
  \ a path via a sequence of described operations, and if the answer is positive,\
  \ also determine the shortest length of such path.\n\n\n-----Input-----\n\nThe first\
  \ line of input contains the number of vertices n (2 ≤ n ≤ 2·10^5).\n\nNext n -\
  \ 1 lines describe edges of the tree. Each of these lines contains two space-separated\
  \ integers u and v (1 ≤ u, v ≤ n, u ≠ v) — indices of endpoints of the corresponding\
  \ edge. It is guaranteed that the given graph is a tree.\n\n\n-----Output-----\n\
  \nIf it is impossible to obtain a path, print -1. Otherwise, print the minimum number\
  \ of edges in a possible path.\n\n\n-----Examples-----\nInput\n6\n1 2\n2 3\n2 4\n\
  4 5\n1 6\n\nOutput\n3\n\nInput\n7\n1 2\n1 3\n3 4\n1 5\n5 6\n6 7\n\nOutput\n-1\n\n\
  \n\n-----Note-----\n\nIn the first sample case, a path of three edges is obtained\
  \ after merging paths 2 - 1 - 6 and 2 - 4 - 5.\n\nIt is impossible to perform any\
  \ operation in the second sample case. For example, it is impossible to merge paths\
  \ 1 - 3 - 4 and 1 - 5 - 6, since vertex 6 additionally has a neighbour 7 that is\
  \ not present in the corresponding path."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def can_minimize_tree (n : Nat) (edges : List (Nat × Nat)) : Int\
  \ :=\nsorry\n"
"vc-theorems": "theorem result_is_odd_or_minus_one (n : Nat) (edges : List (Nat ×\
  \ Nat)) :\n  let result := can_minimize_tree n edges\n  result = -1 ∨ (result >\
  \ 0 ∧ result % 2 = 1) := by\n  sorry \n\n\ntheorem two_node_tree_is_one (edges :\
  \ List (Nat × Nat)) :\n  can_minimize_tree 2 edges = 1 := by\n  sorry\n\n\ntheorem\
  \ valid_tree_has_n_minus_one_edges (n : Nat) (edges : List (Nat × Nat)) :\n  can_minimize_tree\
  \ n edges ≠ -1 →\n  edges.length = n - 1 := by\n  sorry\n\n\ntheorem valid_tree_is_connected\
  \ (n : Nat) (edges : List (Nat × Nat)) :\n  can_minimize_tree n edges ≠ -1 →\n \
  \ ∀ v : Nat, v ≤ n → ∃ path : List (Nat × Nat),\n    path ⊆ edges ∧\n    (∃ p1,\
  \ path.head? = some p1 ∧ p1.1 = 1) ∧ \n    (∃ p2, path.getLast? = some p2 ∧ p2.2\
  \ = v) := by\n  sorry\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval can_minimize_tree\
  \ 6 [(1, 2), (2, 3), (2, 4), (4, 5), (1, 6)]\n\n/--\ninfo: -1\n-/\n#guard_msgs in\n\
  #eval can_minimize_tree 7 [(1, 2), (1, 3), (3, 4), (1, 5), (5, 6), (6, 7)]\n\n/--\n\
  info: 1\n-/\n#guard_msgs in\n#eval can_minimize_tree 2 [(1, 2)]\n"
"vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded"
