"vc-description": "For every positive integer N, there exists a unique sequence starting\
  \ with 1 and ending with N and such that every number in the sequence is either\
  \ the double of the preceeding number or the double plus 1. \n\nFor example, given\
  \ N = 13, the sequence is [1, 3, 6, 13], because . . . :\n```\n 3 =  2*1 +1\n 6\
  \ =  2*3\n 13 = 2*6 +1\n```\n\nWrite a function that returns this sequence given\
  \ a number N. Try generating the elements of the resulting list in ascending order,\
  \ i.e., without resorting to a list reversal or prependig the elements to a list."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def climb (n : Nat) : List Nat := sorry\n\ntheorem climb_starts_with_one\
  \ {n : Nat} (h : n > 0) :\n  (climb n).head? = some 1 := sorry\n"
"vc-theorems": "theorem climb_ends_with_input {n : Nat} (h : n > 0) :\n  (climb n).getLast?\
  \ = some n := sorry\n\n\ntheorem climb_strictly_increasing {n : Nat} (h : n > 0)\
  \ :\n  ∀ i : Nat, i + 1 < (climb n).length →\n  (climb n)[i]! < (climb n)[i + 1]!\
  \ := sorry\n\n\ntheorem climb_length_logarithmic {n : Nat} (h : n > 0) :\n  (climb\
  \ n).length ≤ 2 * Nat.log2 n + 2 := sorry\n\n\ntheorem climb_invalid_input (n :\
  \ Nat) :\n  n = 0 → climb n = [] := sorry\n\n/--\ninfo: [1]\n-/\n#guard_msgs in\n\
  #eval climb 1\n\n/--\ninfo: [1, 3, 6, 12, 25, 50, 100]\n-/\n#guard_msgs in\n#eval\
  \ climb 100\n\n/--\ninfo: [1, 3, 6, 13, 26, 53, 106, 212, 424, 848, 1697, 3395,\
  \ 6790, 13580, 27160, 54321]\n-/\n#guard_msgs in\n#eval climb 54321\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible"
