"vc-description": "Given a wooden stick of length n units. The stick is labelled from\
  \ 0 to n. For example, a stick of length 6 is labelled as follows:\n\nGiven an integer\
  \ array cuts where cuts[i] denotes a position you should perform a cut at.\nYou\
  \ should perform the cuts in order, you can change the order of the cuts as you\
  \ wish.\nThe cost of one cut is the length of the stick to be cut, the total cost\
  \ is the sum of costs of all cuts. When you cut a stick, it will be split into two\
  \ smaller sticks (i.e. the sum of their lengths is the length of the stick before\
  \ the cut). Please refer to the first example for a better explanation.\nReturn\
  \ the minimum total cost of the cuts.\n \nExample 1:\n\nInput: n = 7, cuts = [1,3,4,5]\n\
  Output: 16\nExplanation: Using cuts order = [1, 3, 4, 5] as in the input leads to\
  \ the following scenario:\n\nThe first cut is done to a rod of length 7 so the cost\
  \ is 7. The second cut is done to a rod of length 6 (i.e. the second part of the\
  \ first cut), the third is done to a rod of length 4 and the last cut is to a rod\
  \ of length 3. The total cost is 7 + 6 + 4 + 3 = 20.\nRearranging the cuts to be\
  \ [3, 5, 1, 4] for example will lead to a scenario with total cost = 16 (as shown\
  \ in the example photo 7 + 4 + 3 + 2 = 16).\nExample 2:\nInput: n = 9, cuts = [5,6,1,4,2]\n\
  Output: 22\nExplanation: If you try the given cuts ordering the cost will be 25.\n\
  There are much ordering with total cost <= 25, for example, the order [4, 6, 5,\
  \ 2, 1] has total cost = 22 which is the minimum possible.\n\n \nConstraints:\n\n\
  2 <= n <= 10^6\n1 <= cuts.length <= min(n - 1, 100)\n1 <= cuts[i] <= n - 1\nAll\
  \ the integers in cuts array are distinct."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def min_cost (n : Nat) (cuts : List Nat) : Nat :=\n  sorry\n"
"vc-theorems": "theorem min_cost_nonnegative (n : Nat) (cuts : List Nat) (h : n ≥\
  \ 2) :\n  min_cost n cuts ≥ 0 :=\nsorry\n\n\ntheorem min_cost_empty (n : Nat) (cuts\
  \ : List Nat) (h : n ≥ 2) :\n  (∀ c ∈ cuts, ¬(0 < c ∧ c < n)) → min_cost n cuts\
  \ = 0 :=\nsorry\n\n\ntheorem min_cost_upper_bound (n : Nat) (cuts : List Nat) (h\
  \ : n ≥ 2) :\n  let valid_cuts := cuts.filter (fun c => 0 < c ∧ c < n)\n  min_cost\
  \ n cuts ≤ n * valid_cuts.length :=\nsorry\n\n\ntheorem min_cost_order_independent\
  \ (n : Nat) (cuts : List Nat) (h : n ≥ 2) :\n  let valid_cuts := cuts.filter (fun\
  \ c => 0 < c ∧ c < n)\n  min_cost n cuts = min_cost n valid_cuts.reverse :=\nsorry\n\
  \n\ntheorem min_cost_single_middle_cut (n : Nat) (h : n > 2) :\n  min_cost n [n\
  \ / 2] = n :=\nsorry\n\n/--\ninfo: 16\n-/\n#guard_msgs in\n#eval min_cost 7 [1,\
  \ 3, 4, 5]\n\n/--\ninfo: 22\n-/\n#guard_msgs in\n#eval min_cost 9 [5, 6, 1, 4, 2]\n\
  \n/--\ninfo: 16\n-/\n#guard_msgs in\n#eval min_cost 7 [1, 3, 4, 5, 0, 7]\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
