"vc-description": "Take the following IPv4 address:  128.32.10.1\nThis address has\
  \ 4 octets where each octet is a single byte (or 8 bits).\n\n* 1st octet 128 has\
  \ the binary representation: 10000000\n* 2nd octet 32 has the binary representation:\
  \ 00100000\n* 3rd octet 10 has the binary representation: 00001010\n* 4th octet\
  \ 1 has the binary representation: 00000001\n\nSo 128.32.10.1 == 10000000.00100000.00001010.00000001\n\
  \nBecause the above IP address has 32 bits, we can represent it as the 32\nbit number:\
  \ 2149583361.\n\nWrite a function ip_to_int32(ip) ( **JS**: `ipToInt32(ip)` ) that\
  \ takes an IPv4 address and returns\na 32 bit number.\n\n```python\n  ip_to_int32(\"\
  128.32.10.1\") => 2149583361\n```"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def ipToInt32 (ip: String) : Nat :=\n  sorry\n"
"vc-theorems": "theorem ipToInt32_in_range (a b c d: Nat)\n  (h1: a ≤ 255) (h2: b\
  \ ≤ 255) (h3: c ≤ 255) (h4: d ≤ 255) :\n  let ip := s!\"{a}.{b}.{c}.{d}\"\n  let\
  \ result := ipToInt32 ip\n  0 ≤ result ∧ result ≤ 4294967295 :=\nsorry\n\n\ntheorem\
  \ ipToInt32_bitwise_composition (a b c d: Nat) \n  (h1: a ≤ 255) (h2: b ≤ 255) (h3:\
  \ c ≤ 255) (h4: d ≤ 255) :\n  let ip := s!\"{a}.{b}.{c}.{d}\"\n  ipToInt32 ip =\
  \ (a <<< 24) + (b <<< 16) + (c <<< 8) + d :=\nsorry\n\n\ntheorem ipToInt32_roundtrip_a\
  \ (a b c d: Nat)\n  (h1: a ≤ 255) (h2: b ≤ 255) (h3: c ≤ 255) (h4: d ≤ 255) :\n\
  \  let ip := s!\"{a}.{b}.{c}.{d}\"\n  let result := ipToInt32 ip\n  a = (result\
  \ >>> 24) &&& 255 :=\nsorry\n\n\ntheorem ipToInt32_roundtrip_b (a b c d: Nat)\n\
  \  (h1: a ≤ 255) (h2: b ≤ 255) (h3: c ≤ 255) (h4: d ≤ 255) :\n  let ip := s!\"{a}.{b}.{c}.{d}\"\
  \n  let result := ipToInt32 ip\n  b = (result >>> 16) &&& 255 :=\nsorry\n\n\ntheorem\
  \ ipToInt32_roundtrip_c (a b c d: Nat)\n  (h1: a ≤ 255) (h2: b ≤ 255) (h3: c ≤ 255)\
  \ (h4: d ≤ 255) :\n  let ip := s!\"{a}.{b}.{c}.{d}\"\n  let result := ipToInt32\
  \ ip\n  c = (result >>> 8) &&& 255 :=\nsorry\n\n\ntheorem ipToInt32_roundtrip_d\
  \ (a b c d: Nat)\n  (h1: a ≤ 255) (h2: b ≤ 255) (h3: c ≤ 255) (h4: d ≤ 255) :\n\
  \  let ip := s!\"{a}.{b}.{c}.{d}\"\n  let result := ipToInt32 ip\n  d = result &&&\
  \ 255 :=\nsorry\n\n/--\ninfo: 2149583361\n-/\n#guard_msgs in\n#eval ip_to_int32\
  \ \"128.32.10.1\"\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval ip_to_int32 \"0.0.0.0\"\
  \n\n/--\ninfo: 4294967295\n-/\n#guard_msgs in\n#eval ip_to_int32 \"255.255.255.255\"\
  \n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
