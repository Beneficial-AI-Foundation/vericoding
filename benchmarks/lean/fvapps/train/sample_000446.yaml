"vc-description": "A frog is crossing a river. The river is divided into x units and\
  \ at each unit there may or may not exist a stone. The frog can jump on a stone,\
  \ but it must not jump into the water.\n\nGiven a list of stones' positions (in\
  \ units) in sorted ascending order, determine if the frog is able to cross the river\
  \ by landing on the last stone. Initially, the frog is on the first stone and assume\
  \ the first jump must be 1 unit.\n\n\nIf the frog's last jump was k units, then\
  \ its next jump must be either k - 1, k, or k + 1 units. Note that the frog can\
  \ only jump in the forward direction.\n\nNote:\n\nThe number of stones is ≥ 2 and\
  \ is < 1,100.\nEach stone's position will be a non-negative integer < 231.\nThe\
  \ first stone's position is always 0.\n\n\n\nExample 1:\n\n[0,1,3,5,6,8,12,17]\n\
  \nThere are a total of 8 stones.\nThe first stone at the 0th unit, second stone\
  \ at the 1st unit,\nthird stone at the 3rd unit, and so on...\nThe last stone at\
  \ the 17th unit.\n\nReturn true. The frog can jump to the last stone by jumping\
  \ \n1 unit to the 2nd stone, then 2 units to the 3rd stone, then \n2 units to the\
  \ 4th stone, then 3 units to the 6th stone, \n4 units to the 7th stone, and 5 units\
  \ to the 8th stone.\n\n\n\nExample 2:\n\n[0,1,2,3,4,8,9,11]\n\nReturn false. There\
  \ is no way to jump to the last stone as \nthe gap between the 5th and 6th stone\
  \ is too large."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def can_cross (stones : List Nat) : Bool := sorry\n\ntheorem empty_stones\
  \ :\n  can_cross [] = false := sorry\n"
"vc-theorems": "theorem single_stone :\n  can_cross [0] = true := sorry\n\n\ntheorem\
  \ stones_start_with_zero {stones : List Nat} (h : stones ≠ []) :\n  stones.head!\
  \ = 0 := sorry \n\n\ntheorem stones_strictly_increasing {stones : List Nat} (i :\
  \ Nat) \n  (h1 : i + 1 < stones.length) :\n  stones[i]! < stones[i+1]! := sorry\n\
  \n\ntheorem return_type_bool (stones : List Nat) :\n  can_cross stones = true ∨\
  \ can_cross stones = false := sorry\n\n\ntheorem invalid_sequences_head {stones\
  \ : List Nat} (h1 : stones.length ≥ 2) \n  (h2 : stones.head! ≠ 0) :\n  can_cross\
  \ stones = false := sorry\n\n\ntheorem invalid_sequences_monotone {stones : List\
  \ Nat} (i : Nat) \n  (h1 : i + 1 < stones.length)\n  (h2 : stones[i]! ≥ stones[i+1]!)\
  \ :\n  can_cross stones = false := sorry\n\n/--\ninfo: True\n-/\n#guard_msgs in\n\
  #eval can_cross [0, 1, 3, 5, 6, 8, 12, 17]\n\n/--\ninfo: False\n-/\n#guard_msgs\
  \ in\n#eval can_cross [0, 1, 2, 3, 4, 8, 9, 11]\n\n/--\ninfo: True\n-/\n#guard_msgs\
  \ in\n#eval can_cross [0, 1, 3, 4, 5, 7, 9, 10, 12]\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
