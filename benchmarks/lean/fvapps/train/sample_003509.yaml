"vc-description": "Make a function **\"add\"** that will be able to sum elements of\
  \ **list** continuously and return a new list of sums.\n\nFor example: \n\n```\n\
  add [1,2,3,4,5] == [1, 3, 6, 10, 15], because it's calculated like \nthis : [1,\
  \ 1 + 2, 1 + 2 + 3, 1 + 2 + 3 + 4, 1 + 2 + 3 + 4 + 5]\n```\n\nIf you want to learn\
  \ more see https://en.wikipedia.org/wiki/Prefix_sum"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def add (nums: List Int) : List Int :=\n  sorry\n\n@[simp]"
"vc-theorems": "theorem add_length_preservation: \n  ∀ (nums: List Int), \n  List.length\
  \ (add nums) = List.length nums := \n  sorry\n\n@[simp]\n\ntheorem add_cumulative_property:\n\
  \  ∀ (nums: List Int),\n  nums ≠ [] →\n  let result := add nums\n  (List.get! result\
  \ 0 = List.get! nums 0) ∧ \n  ∀ (i: Nat), 0 < i → i < nums.length → \n    List.get!\
  \ result i = List.get! result (i-1) + List.get! nums i :=\n  sorry\n\n@[simp]\n\n\
  theorem add_monotonic_for_nonnegative:\n  ∀ (nums: List Int),\n  (∀ x, x ∈ nums\
  \ → 0 ≤ x) →\n  let result := add nums\n  ∀ (i j: Nat), i < j → j < result.length\
  \ → \n    List.get! result i ≤ List.get! result j :=\n  sorry\n\n@[simp]\n\ntheorem\
  \ add_invalid_input:\n  ∀ (s: String), add [] = [] :=\n  sorry\n\nend AddSpec\n\n\
  /--\ninfo: [1, 3, 6, 10, 15]\n-/\n#guard_msgs in\n#eval add [1, 2, 3, 4, 5]\n\n\
  /--\ninfo: [5, 15, 30, 50]\n-/\n#guard_msgs in\n#eval add [5, 10, 15, 20]\n\n/--\n\
  info: [2, 6, 12]\n-/\n#guard_msgs in\n#eval add [2, 4, 6]\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
