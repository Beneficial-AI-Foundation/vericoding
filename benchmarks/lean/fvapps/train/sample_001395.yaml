"vc-description": "Given an integer N, Chef wants to find the smallest positive integer\
  \ M such that the bitwise XOR of M and M+1 is N. If no such M exists output -1.\n\
  \n-----Input-----\nThe first line of input contain an integer T denoting the number\
  \ of test cases. Each of the following T lines contains an integer N for that test\
  \ case.\n\n-----Output-----\nFor each test case, output a single line containing\
  \ the number M or -1 as described above.\n\n-----Constraints-----\n- 1 ≤ T ≤ 5000\n\
  - 1 ≤ N ≤ 230\n\n-----Example-----\nInput:\n1\n3\n\nOutput:\n1\n\n-----Explanation-----First\
  \ Example :  M desired in the problem would be 1. As bitwise XOR of 1 and 2 is equal\
  \ to 3."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def find_smallest_xor_m (n : Nat) : Int :=\nsorry\n\n\n"
"vc-theorems": "theorem find_smallest_xor_m_no_solution (n : Nat) :\n  find_smallest_xor_m\
  \ n = -1 →\n  ∀ m : Nat, m ≤ n + 2 → m ^^^ (m + 1) ≠ n :=\nsorry\n\n\ntheorem find_smallest_xor_m_invalid_inputs\
  \ (n : Int) :\n  n ≤ 0 → find_smallest_xor_m n.toNat = -1 :=\nsorry\n\n/--\ninfo:\
  \ 1\n-/\n#guard_msgs in\n#eval find_smallest_xor_m 3\n\n/--\ninfo: 2\n-/\n#guard_msgs\
  \ in\n#eval find_smallest_xor_m 1\n\n/--\ninfo: -1\n-/\n#guard_msgs in\n#eval find_smallest_xor_m\
  \ 4\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible"
