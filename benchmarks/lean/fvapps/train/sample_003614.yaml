"vc-description": "Write\n```python\nsmaller(arr)\n```\nthat given an array ```arr```,\
  \ you have to return the amount of numbers that are smaller than ```arr[i]``` to\
  \ the right.\n\nFor example:\n```python\nsmaller([5, 4, 3, 2, 1]) == [4, 3, 2, 1,\
  \ 0]\nsmaller([1, 2, 0]) == [1, 1, 0]\n```\n``` haskell\nsmaller [5,4,3,2,1]  `shouldBe`\
  \ [4,3,2,1,0]\nsmaller [1,2,3]      `shouldBe` [0,0,0]\nsmaller [1, 2, 0]    `shouldBe`\
  \ [1, 1, 0]\n```\nIf you've completed this one and you feel like testing your performance\
  \ tuning of this same kata, head over to the much tougher version How many are smaller\
  \ than me II?"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def smaller (arr : List Int) : List Int := sorry\n\ntheorem smaller_length_matches_input\
  \ (arr : List Int) (h : arr ≠ []) :\n  List.length (smaller arr) = List.length arr\
  \ := sorry\n"
"vc-theorems": "theorem smaller_returns_non_negative (arr : List Int) (h : arr ≠ [])\
  \ :\n  ∀ x ∈ smaller arr, x ≥ 0 := sorry\n\n\ntheorem smaller_last_always_zero (arr\
  \ : List Int) (h : arr ≠ []) :\n  List.get! (smaller arr) (List.length arr - 1)\
  \ = 0 := sorry\n\n\ntheorem smaller_count_correct (arr : List Int) (h : arr ≠ [])\
  \ :\n  ∀ i, i < List.length arr →\n    List.get! (smaller arr) i = \n      (List.drop\
  \ (i+1) arr).countP (· < List.get! arr i) := sorry\n\n\n\n\ntheorem smaller_maximum_constraint\
  \ (arr : List Int) (h : arr ≠ []) :\n  ∀ i, i < List.length arr →\n    List.get!\
  \ (smaller arr) i ≤ List.length arr - i - 1 := sorry\n\n/--\ninfo: [4, 3, 2, 1,\
  \ 0]\n-/\n#guard_msgs in\n#eval smaller [5, 4, 3, 2, 1]\n\n/--\ninfo: [1, 1, 0]\n\
  -/\n#guard_msgs in\n#eval smaller [1, 2, 0]\n\n/--\ninfo: [0, 0, 0]\n-/\n#guard_msgs\
  \ in\n#eval smaller [1, 2, 3]\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible"
