"vc-description": "Chef likes toys. His favourite toy is an array of length N. This\
  \ array contains only integers. He plays with this array every day. His favourite\
  \ game with this array is Segment Multiplication. In this game, the second player\
  \ tells the left and right side of a segment and some modulo. The first player should\
  \ find the multiplication of all the integers in this segment of the array modulo\
  \ the given modulus. Chef is playing this game. Of course, he is the first player\
  \ and wants to win all the games. To win any game he should write the correct answer\
  \ for each segment. Although Chef is very clever, he has no time to play games.\
  \ Hence he asks you to help him. Write the program that solves this problem.\n\n\
  -----Input-----\nThe first line of the input contains an integer N denoting the\
  \ number of elements in the given array. Next line contains N integers Ai separated\
  \ with spaces. The third line contains the number of games T. Each of the next T\
  \ lines contain 3 integers Li, Ri and Mi, the left side of the segment, the right\
  \ side of segment and the modulo.\n\n-----Output-----\nFor each game, output a single\
  \ line containing the answer for the respective segment.\n\n-----Constrdaints-----\n\
  - 1 ≤ N ≤ 100,000\n- 1 ≤ Ai ≤ 100\n- 1 ≤ T ≤ 100,000\n- 1 ≤ Li ≤ Ri ≤ N\n- 1 ≤ Mi\
  \ ≤ 109\n\n-----Example-----\nInput:\n5\n1 2 3 4 5\n4\n1 2 3\n2 3 4\n1 1 1\n1 5\
  \ 1000000000\n\nOutput:\n2\n2\n0\n120"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def solve_segment_multiplication (arr : List Nat) (queries : List\
  \ (Nat × Nat × Nat)) : List Nat :=\nsorry\n\n-- Results length matches queries length"
"vc-theorems": "theorem solve_length_matches {arr : List Nat} {queries : List (Nat\
  \ × Nat × Nat)} :\n  (solve_segment_multiplication arr queries).length = queries.length\
  \ :=\nsorry\n\n-- All results are within modulo bounds\n\ntheorem solve_results_within_bounds\
  \ {arr : List Nat} {queries : List (Nat × Nat × Nat)} :\n  ∀ (i : Nat), i < (solve_segment_multiplication\
  \ arr queries).length →\n  ∀ (l r m : Nat), queries.get! i = (l, r, m) →\n  ∃ (result\
  \ : Nat), (solve_segment_multiplication arr queries).get! i = result ∧ result <\
  \ m :=\nsorry\n\n-- m=1 case gives 0\n\ntheorem solve_mod_one {arr : List Nat} {queries\
  \ : List (Nat × Nat × Nat)} :\n  ∀ (i : Nat), i < (solve_segment_multiplication\
  \ arr queries).length →\n  ∀ (l r : Nat), queries.get! i = (l, r, 1) →\n  (solve_segment_multiplication\
  \ arr queries).get! i = 0 :=\nsorry\n\n-- Single element queries give correct modulo\n\
  \ntheorem solve_single_elem {arr : List Nat} {queries : List (Nat × Nat × Nat)}\
  \ :\n  ∀ (i : Nat), i < (solve_segment_multiplication arr queries).length →\n  ∀\
  \ (l m : Nat), queries.get! i = (l, l, m) →\n  (solve_segment_multiplication arr\
  \ queries).get! i = (arr.get! (l-1)) % m :=\nsorry\n\n-- Full array query equals\
  \ product mod m\n\ntheorem solve_full_array {arr : List Nat} {m : Nat} :\n  let\
  \ queries := [(1, arr.length, m)]\n  let result := (solve_segment_multiplication\
  \ arr queries).get! 0\n  let expected := arr.foldl (fun acc x => (acc * x) % m)\
  \ 1\n  result = expected :=\nsorry"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded"
