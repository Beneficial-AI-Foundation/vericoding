"vc-description": "=====Problem Statement=====\nA valid email address meets the following\
  \ criteria:\n\nIt's composed of a username, domain name, and extension assembled\
  \ in this format: username@domain.extension\nThe username starts with an English\
  \ alphabetical character, and any subsequent characters consist of one or more of\
  \ the following: alphanumeric characters, -,., and _.\nThe domain and extension\
  \ contain only English alphabetical characters.\nThe extension is 1, 2, or 3 characters\
  \ in length.\n\nGiven n pairs of names and email addresses as input, print each\
  \ name and email address pair having a valid email address on a new line.\n\nHint:\
  \ Try using Email.utils() to complete this challenge. For example, this code:\n\n\
  import email.utils\nprint email.utils.parseaddr('DOSHI <DOSHI@hackerrank.com>')\n\
  print email.utils.formataddr(('DOSHI', 'DOSHI@hackerrank.com'))\n\nproduces this\
  \ output:\n\n('DOSHI', 'DOSHI@hackerrank.com')\nDOSHI <DOSHI@hackerrank.com>\n\n\
  =====Input Format=====\nThe first line contains a single integer, n, denoting the\
  \ number of email address.\nEach line i of the n subsequent lines contains a name\
  \ and an email address as two space-separated values following this format:\nname\
  \ <user@email.com>\n\n=====Constraints=====\n0<n<100\n\n=====Output Format=====\n\
  Print the space-separated name and email address pairs containing valid email addresses\
  \ only. Each pair must be printed on a new line in the following format:\nname <user@email.com>\n\
  \nYou must print each valid email address in the same order as it was received as\
  \ input."
"vc-preamble": "import Imports.AllImports\n\ndef Email := String\ndef validate_emails\
  \ (emails : List Email) : List Email := sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def isValidEmailFormat (e : Email) : Bool := sorry\n\n/-- For a\
  \ list of valid email addresses, all should be returned unchanged -/"
"vc-theorems": "theorem validate_valid_emails (emails : List Email) \n  (h : ∀ e ∈\
  \ emails, isValidEmailFormat e) :\n  validate_emails emails = emails :=\nsorry\n\
  \n/-- For a list of invalid email addresses, an empty list should be returned -/\n\
  \ntheorem validate_invalid_emails (emails : List Email)\n  (h : ∀ e ∈ emails, ¬\
  \ isValidEmailFormat e) :\n  validate_emails emails = [] := \nsorry\n\n/-- For a\
  \ mixed list of valid and invalid emails, only valid ones should be returned -/\n\
  \ntheorem validate_mixed_emails (emails : List Email)\n  (valid : List Email :=\
  \ emails.filter isValidEmailFormat) :\n  validate_emails emails = valid :=\nsorry\n\
  \n/-- Function should not crash on arbitrary string input -/\n\ntheorem validate_arbitrary_input\
  \ (inputs : List String) :\n  ∃ result, validate_emails inputs = result :=\nsorry\n\
  \n/--\ninfo: ['DEXTER <dexter@hotmail.com>']\n-/\n#guard_msgs in\n#eval validate_emails\
  \ [\"DEXTER <dexter@hotmail.com>\", \"VIRUS <virus!@variable.:p>\"]\n\n/--\ninfo:\
  \ ['ALICE <alice123@gmail.com>']\n-/\n#guard_msgs in\n#eval validate_emails [\"\
  ALICE <alice123@gmail.com>\"]\n\n/--\ninfo: ['CAROL <carol@xyz.com>']\n-/\n#guard_msgs\
  \ in\n#eval validate_emails [\"INVALID <inv@k.>\", \"CAROL <carol@xyz.com>\"]\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
