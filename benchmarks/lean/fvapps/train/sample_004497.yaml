"vc-description": "Similar to the [previous kata](https://www.codewars.com/kata/string-subpattern-recognition-ii/),\
  \ but this time you need to operate with shuffled strings to identify if they are\
  \ composed repeating a subpattern\n\nSince there is no deterministic way to tell\
  \ which pattern was really the original one among all the possible permutations\
  \ of a fitting subpattern, return a subpattern with sorted characters, otherwise\
  \ return the base string with sorted characters (you might consider this case as\
  \ an edge case, with the subpattern being repeated only once and thus equalling\
  \ the original input string).\n\nFor example:\n\n```python\nhas_subpattern(\"a\"\
  ) == \"a\"; #no repeated pattern, just one character\nhas_subpattern(\"aaaa\") ==\
  \ \"a\" #just one character repeated\nhas_subpattern(\"abcd\") == \"abcd\" #base\
  \ pattern equals the string itself, no repetitions\nhas_subpattern(\"babababababababa\"\
  ) == \"ab\" #remember to return the base string sorted\"\nhas_subpattern(\"bbabbaaabbaaaabb\"\
  ) == \"ab\" #same as above, just shuffled\n```\n\nIf you liked it, go for either\
  \ the [previous kata](https://www.codewars.com/kata/string-subpattern-recognition-ii/)\
  \ or the [next kata](https://www.codewars.com/kata/string-subpattern-recognition-iv/)\
  \ of the series!"
"vc-preamble": "import Imports.AllImports\n\ndef String.count (s : String) (c : Char)\
  \ : Nat := sorry\ndef String.toCharArray (s : String) : Array Char := sorry"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def String.fromCharArray (arr : Array Char) : String := sorry\n\
  def has_subpattern (s : String) : String := sorry\n"
"vc-theorems": "theorem output_is_substring (s : String) (h : s.length > 0) :\n  let\
  \ result := has_subpattern s\n  -- Result length less than input length  \n  result.length\
  \ ≤ s.length ∧ \n  -- Result chars are sorted\n  (∀ i j, i < j → i < result.length\
  \ → j < result.length → \n    result.toCharArray[i]! ≤ result.toCharArray[j]!) ∧\n\
  \  -- Result chars come from input  \n  (∀ c, c ∈ result.toCharArray.toList → c\
  \ ∈ s.toCharArray.toList) := sorry\n\n\ntheorem output_pattern_reconstruction (s\
  \ : String) (h : s.length > 0) :\n  let pattern := has_subpattern s\n  let counts_s\
  \ := s.toCharArray.toList.map (fun c => (c, s.count c))\n  let counts_p := pattern.toCharArray.toList.map\
  \ (fun c => (c, pattern.count c))\n  pattern.length > 0 →\n  ∃ ratio : Nat, ∀ (s_c\
  \ p_c : Char) (s_count p_count : Nat),\n    (s_c, s_count) ∈ counts_s →\n    (p_c,\
  \ p_count) ∈ counts_p →\n    s_count = p_count * ratio := sorry \n\n\ntheorem idempotent\
  \ (s : String) (h : s.length > 0) :\n  has_subpattern s = has_subpattern (has_subpattern\
  \ s) := sorry"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
