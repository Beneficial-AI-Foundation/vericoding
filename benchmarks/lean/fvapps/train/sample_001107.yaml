"vc-description": "In a bizarre game of chess ,knight was so drunk, that instead of\
  \ his usual move he started walking straight. In every move Knight jumps on 2n steps\
  \ forward (n is number of block that he had travelled so far from starting) but\
  \ after that he has to take either 1 step forward or backward.\nNow the Knight needs\
  \ to get to position X so King (i.e. You) needs to decide the order of his backward\
  \ or forward step in such a way that he can reach its destination in minimum number\
  \ of steps. Remember he always travels in a straight line and the length of the\
  \ board is infinite.\n\n-----Input-----\nThe first line of the input contains an\
  \ integer T denoting the number of test cases, for each test case enter value X\
  \ ( i.e. destination)\nNote : initially knight is at n = 1.\n\n-----Output-----\n\
  For each test case the output should be string of numbers 1 & 2 where 1 denotes\
  \ backward step and 2 denote the forward step \nNote : for no solution print 0.\n\
  \n-----Constraints-----\n- 1 ≤ T ≤ 100\n- 1 ≤ X ≤ 10^10\n\n-----Example-----\nInput:\n\
  2\n17\n10\nOutput:\n2111\n0\n\n-----Explanation-----\nCase 1 : starting from  n\
  \ = 1 , knight moves to n = 3 ('2') , 5 ('1') , 9 ('1') , 17 ('1') i.e. string printed\
  \ is 2 1 1 1\nCase 2 : no solution is possible"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def solve_knight_steps (n : Nat) : String := sorry\n\ntheorem even_numbers_return_zero\
  \ {n : Nat} (h : n > 0) (h2 : n % 2 = 0) :\n  solve_knight_steps n = \"0\" := sorry\n"
"vc-theorems": "theorem output_contains_valid_moves {n : Nat} (h : n > 0) :\n  ∀ (i\
  \ : String.Pos), i.1 < (solve_knight_steps n).length →\n    let c := (solve_knight_steps\
  \ n).get i\n    c = '0' ∨ c = '1' ∨ c = '2' ∨ c = '3' := sorry\n\n\ntheorem special_cases_one_and_three\
  \ {n : Nat} :\n  (n = 1 → solve_knight_steps n = \"1\") ∧\n  (n = 3 → solve_knight_steps\
  \ n = \"3\") := sorry\n\n\ntheorem path_length_matches_tree_depth {n : Nat} (h :\
  \ n > 0) (h2 : n % 2 = 1) (h3 : n > 3) :\n  String.length (solve_knight_steps n)\
  \ = Nat.log2 n := sorry\n\n\ntheorem result_follows_binary_tree_pattern {n : Nat}\
  \ (h : n > 0) (h2 : n % 2 = 1) (h3 : n > 3) :\n  let result := solve_knight_steps\
  \ n\n  let final_pos := result.foldl \n    (fun pos c => \n      if c = '1' then\
  \ \n        2 * pos - 1\n      else if c = '2' then\n        2 * pos + 1\n     \
  \ else \n        pos) 3\n  final_pos = n := sorry\n\n/--\ninfo: '2111'\n-/\n#guard_msgs\
  \ in\n#eval solve_knight_steps 17\n\n/--\ninfo: '0'\n-/\n#guard_msgs in\n#eval solve_knight_steps\
  \ 10\n\n/--\ninfo: '3'\n-/\n#guard_msgs in\n#eval solve_knight_steps 3\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
