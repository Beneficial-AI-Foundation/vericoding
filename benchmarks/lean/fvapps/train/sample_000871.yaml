"vc-description": "-----Problem Statement-----\nChef has a sequence of N segments:\
  \ [L1, R1], [L2, R2], ..., [LN, RN]. He wants to transform the first segment to\
  \ the last one (with index N). His plan is to do this big deal with a number of\
  \ transformations: firstly he will transform\n\nthe first segment to the second\
  \ one, then to the third one, then to the fourth one, and so on till N-th one.\n\
  \nChef can use operation of a single type: shift one segment border by one unit.\
  \ So, if he has segment [L, R], he can transform it into one of the following segments:\
  \ [L + 1, R] (we will denote such operation with string L+), [L, R + 1] (will be\
  \ denoted as R+), [L - 1, R] (L-), [L, R - 1] (R-). Chef doesn't like empty segments,\
  \ therefore he cannot use any operation that makes a segment empty (L = R).\n\n\
  Chef really wants to transform his segment as fast as possible. Please, help him.\
  \ Find the sequence with minimal number of operations that transforms his segment.\
  \ If there are multiple such sequences pick the lexicographically minimal one.\n\
  \n-----Input-----\nThe first line of the input contains an integer T denoting the\
  \ number of test cases. The description of T test cases follows. \n\nThe first line\
  \ of each test case contains a single integer N denoting the number of segments\
  \ Chef has. \n\nThe following N lines contain pairs of integers. The i-th line contains\
  \ integers Li, Ri, denoting i-th Chef's segment.\n\n-----Output-----\nFor each test\
  \ case print an answer - two lines. The first line should contain the minimal number\
  \ of operations. The second line should contain the sequence of operations\n\nwithout\
  \ any whitespaces.\n\n-----Constraints-----\n- 1 ≤ T, N ≤ 1000.\n- -1000 ≤ Li <\
  \ Ri ≤ 1000.\nThe total sum of N values for all test cases doesn't exceed 1000.\n\
  \n-----Example-----\nInput:\n4\n3\n-1 0\n0 1\n3 5\n1\n0 1\n3\n-2 -1\n-2 -1\n-2 0\n\
  4\n4 6\n3 5\n-1 1\n1 2\n\nOutput:\n9\nR+L+R+L+R+L+R+L+R+\n0\n\n1\nR+\n13\nL-R-L-L-L-L-R-R-R-R-L+R+L+"
"vc-preamble": "import Imports.AllImports\n\ndef Segment := Int × Int \n\ninductive\
  \ Operation\n  | L_plus\n  | L_minus\n  | R_plus \n  | R_minus\n\n\ndef apply_operation\
  \ (s : Segment) (op : Operation) : Segment :=\n  match op with\n  | Operation.L_plus\
  \ => (s.1 + 1, s.2)\n  | Operation.L_minus => (s.1 - 1, s.2) \n  | Operation.R_plus\
  \ => (s.1, s.2 + 1)\n  | Operation.R_minus => (s.1, s.2 - 1)\n  \n\ndef is_valid_segment\
  \ (s : Segment) : Bool :=\n  s.1 < s.2\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def solve (segments : List Segment) : List Operation := sorry\n\
  \ntheorem operations_preserve_validity \n  (segments : List Segment)\n  (h₁ : segments\
  \ ≠ [])\n  (h₂ : ∀ s ∈ segments, is_valid_segment s = true) :\n  let ops := solve\
  \ segments\n  ∀ i, i ≤ ops.length →\n  let curr := List.foldl apply_operation (List.head\
  \ segments h₁) (ops.take i)\n  is_valid_segment curr = true :=\nsorry \n"
"vc-theorems": "theorem reaches_target_segments\n  (segments : List Segment)\n  (h₁\
  \ : segments ≠ [])\n  (h₂ : ∀ s ∈ segments, is_valid_segment s = true) :\n  let\
  \ ops := solve segments\n  ∀ target ∈ segments.tail,\n  ∃ i ≤ ops.length,\n  List.foldl\
  \ apply_operation (List.head segments h₁) (ops.take i) = target :=\nsorry\n\n/--\n\
  info: [9, 'R+L+R+L+R+L+R+L+R+']\n-/\n#guard_msgs in\n#eval solve [[-1, 0], [0, 1],\
  \ [3, 5]]\n\n/--\ninfo: [0, '']\n-/\n#guard_msgs in\n#eval solve [[0, 1]]\n\n/--\n\
  info: [1, 'R+']\n-/\n#guard_msgs in\n#eval solve [[-2, -1], [-2, -1], [-2, 0]]\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
