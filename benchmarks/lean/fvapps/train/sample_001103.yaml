"vc-description": "Consider the following algorithm\norder(arr, i) {\nif length(arr)\
  \ <= 1 {\nreturn arr\n}\nl = []  \nr = []\nn = length(arr) - 1\nfor j in 0, 1, ...,\
  \ n {\nif ( (arr[j] modulo power(2,i+1))  < power(2,i) ) {\nappend arr[j] to l\n\
  }else{\nappend arr[j] to r\n}\n}\nl = order(l, i + 1)\nr = order(r, i + 1)\nc =\
  \ concatenate(l, r)\nreturn c\n}\n\nNote that $concatenate(l, r)$ returns an array\
  \ which is the array $l$, followed by the array $r$. Similarly $power(x,y)$ returns\
  \ $x^y$.\nLet $a$ be the array $a_0,a_1,a_2,a_3, \\ldots,a_n$ where $a_j = j$ for\
  \ each index $j$ and the last index $n = (2^p-1)$ for a fixed integer parameter\
  \ $p$.  Given an integer $p$ and an index $idx$, your task is calculate the element\
  \ at index $idx$ in the array returned by executing $order(a, 0)$.\nFor example,\
  \ suppose $ p = 3$ and $idx = 3$.\n- The initial array is $a = [0, 1, 2, 3, 4, 5,\
  \ 6, 7]$.\n- Executing $order(a, 0)$ first creates two new arrays $l == [0, 2, 4,\
  \ 6]$ and $r == [1, 3, 5, 7]$.\n- Next, $order(l, 1)$ and $order(r, 1)$ are executed.\n\
  - $order(l, 1)$, in turn, executes $order([0, 4], 2)$ and $order([2, 6], 2)$ which\
  \ return $[0, 4]$ and $[2, 6]$, respectively. These are then concatenated, so $order(l,\
  \ 1)$ returns $[0, 4, 2, 6]$.\n- Similarly, $order(r, 1)$ returns $[1, 5, 3, 7]$.\n\
  - These two are concatenated as the final result, so the array returned by $order(a,\
  \ 0)$ is $[0, 4, 2, 6, 1, 5, 3, 7]$.\nSo, if the input is $p = 3$, and $idx = 3$,\
  \ the answer is $6$. If $p = 3$ and $idx = 7$, the answer should be $7$.\n\n-----Input\
  \ Format:-----\n- The first line contains a single integer, $T$, which is the number\
  \ of testcases. The description of each testcase follows.\n- Each testcase is described\
  \ by a single line with two integers: $p$ and $idx$, where $p$ is the parameter\
  \ that determines the length of the array $a$ and $idx$ is the index at which you\
  \ have to report the value in the output of $order(a, 0)$.\n\n-----Output Format:-----\n\
  - You should print the answer in a new line for each testcase, which should be a\
  \ single integer, the element at index $idx$ after executing $order(a, 0)$ for the\
  \ array $a$ defined by the parameter $p$.\n\n-----Constraints:-----\n- $1 \\leq\
  \ T \\leq 10$ \n- $1 \\leq p \\leq 50$\n- $0 \\leq idx \\leq 2^p-1$\n\n-----SUBTASKS:-----\n\
  - Subtask 1: 20% points : $1 \\leq p \\leq 20$\n- Subtask 2: 80% points: Original\
  \ constraints\n\n-----Sample Input:-----\n2\n3 3\n3 7\n\n-----Sample Output:-----\n\
  6\n7\n\n-----Explanation:-----\nBoth the testcases have been explained in the problem\
  \ statement."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def solve_order (p : Nat) (idx : Nat) : Nat := sorry\n\n-- Result\
  \ is within bounds for p bits"
"vc-theorems": "theorem solve_order_bounds (p : Nat) (idx : Nat) (h : idx < 2^p) :\
  \ \n  solve_order p idx < 2^p := sorry\n\n-- Result is involutive \n\ntheorem solve_order_involution\
  \ (p : Nat) (idx : Nat) (h : idx < 2^p) :\n  solve_order p (solve_order p idx) =\
  \ idx := sorry\n\n-- Identity cases preserve 0 and max value\n\ntheorem solve_order_zero\
  \ (p : Nat) :\n  solve_order p 0 = 0 := sorry\n\n\ntheorem solve_order_max (p :\
  \ Nat) :\n  solve_order p (2^p - 1) = 2^p - 1 := sorry\n\n-- Bits preservation\n\
  \ntheorem solve_order_bits_preservation (p : Nat) (idx : Nat) (h : idx < 2^p) :\n\
  \  ∃ k, solve_order p idx < 2^k ∧ k ≤ p := sorry\n\n/--\ninfo: 6\n-/\n#guard_msgs\
  \ in\n#eval solve_order 3 3\n\n/--\ninfo: 7\n-/\n#guard_msgs in\n#eval solve_order\
  \ 3 7\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval solve_order 4 10\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible"
