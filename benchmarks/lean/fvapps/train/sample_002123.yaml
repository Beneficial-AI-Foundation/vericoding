"vc-description": "Sereja loves number sequences very much. That's why he decided\
  \ to make himself a new one following a certain algorithm.\n\nSereja takes a blank\
  \ piece of paper. Then he starts writing out the sequence in m stages. Each time\
  \ he either adds a new number to the end of the sequence or takes l first elements\
  \ of the current sequence and adds them c times to the end. More formally, if we\
  \ represent the current sequence as a_1, a_2, ..., a_{n}, then after we apply the\
  \ described operation, the sequence transforms into a_1, a_2, ..., a_{n}[, a_1,\
  \ a_2, ..., a_{l}] (the block in the square brackets must be repeated c times).\
  \ \n\nA day has passed and Sereja has completed the sequence. He wonders what are\
  \ the values of some of its elements. Help Sereja.\n\n\n-----Input-----\n\nThe first\
  \ line contains integer m (1 ≤ m ≤ 10^5) — the number of stages to build a sequence.\
  \ \n\nNext m lines contain the description of the stages in the order they follow.\
  \ The first number in the line is a type of stage (1 or 2). Type 1 means adding\
  \ one number to the end of the sequence, in this case the line contains integer\
  \ x_{i} (1 ≤ x_{i} ≤ 10^5) — the number to add. Type 2 means copying a prefix of\
  \ length l_{i} to the end c_{i} times, in this case the line further contains two\
  \ integers l_{i}, c_{i} (1 ≤ l_{i} ≤ 10^5, 1 ≤ c_{i} ≤ 10^4), l_{i} is the length\
  \ of the prefix, c_{i} is the number of copyings. It is guaranteed that the length\
  \ of prefix l_{i} is never larger than the current length of the sequence.\n\nThe\
  \ next line contains integer n (1 ≤ n ≤ 10^5) — the number of elements Sereja is\
  \ interested in. The next line contains the numbers of elements of the final sequence\
  \ Sereja is interested in. The numbers are given in the strictly increasing order.\
  \ It is guaranteed that all numbers are strictly larger than zero and do not exceed\
  \ the length of the resulting sequence. Consider the elements of the final sequence\
  \ numbered starting from 1 from the beginning to the end of the sequence.\n\nPlease,\
  \ do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred\
  \ to use the cin, cout streams or the %I64d specifier.\n\n\n-----Output-----\n\n\
  Print the elements that Sereja is interested in, in the order in which their numbers\
  \ occur in the input. \n\n\n-----Examples-----\nInput\n6\n1 1\n1 2\n2 2 1\n1 3\n\
  2 5 2\n1 4\n16\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16\n\nOutput\n1 2 1 2 3 1 2\
  \ 1 2 3 1 2 1 2 3 4"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def build_sequence (stages : List (List Nat)) (indices : List Nat)\
  \ : List Nat :=\n  sorry\n"
"vc-theorems": "theorem append_only_sequence_length \n  (stages : List (List Nat))\
  \ (indices : List Nat)\n  (h1 : ∀ s ∈ stages, s.length = 2 ∧ s[0]! = 1) :\n  (build_sequence\
  \ stages indices).length ≤ indices.length := by\n  sorry\n\n\ntheorem append_only_sequence_elements\n\
  \  (stages : List (List Nat)) (indices : List Nat)\n  (h1 : ∀ s ∈ stages, s.length\
  \ = 2 ∧ s[0]! = 1)\n  (result := build_sequence stages indices)\n  (stage_vals :=\
  \ stages.map (λ s => s[1]!)) :\n  ∀ i < result.length,\n    ∃ j, j ≤ indices[i]!\
  \ ∧\n    result[i]! ∈ stage_vals.take (j + 1) := by\n  sorry"
"vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded"
