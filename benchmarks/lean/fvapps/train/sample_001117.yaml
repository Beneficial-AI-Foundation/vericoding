"vc-description": "Autobots are instructed by Optimus Prime to mobilize in the form\
  \ of a rectangular shape with each Autobot on each vertex of the rectangle region\
  \ on a -”deployment area” (which may consist of one or more regions). This is done\
  \ so as to take care of the inner rectangular area called “region”. However the\
  \ rule states-“no two regions may overlap”.  You have been asked to remove some\
  \ regions from the “deployment area” so the remaining regions do not obscure each\
  \ other. To keep the disturbance to the minimum level, you should remove the minimum\
  \ number of regions to achieve this goal. You may not remove a region and place\
  \ it in another position; all regions you leave in “deployment area” must be in\
  \ their original position.\nWhen you examined the “deployment area”, you noticed\
  \ something very nice. Every region was placed on the deployment area by placing\
  \ each autobot in the four corners. This was done in a very courteous manner since\
  \ each autobot is guarding only the region it is holding. \nThe reason Optimus Prime\
  \ wants your help because you are good at taking down a single region without disturbing\
  \ the rest, even if that region is obscured by many others.\n\n\n-----Input-----\n\
  The first line consists of a single integer T indicating the number of test cases\
  \ (about 25).\nEach test case consists begins with a single integer n indicating\
  \ the number of regions. The next n lines consist of 4 integers x0, x1, y0, and\
  \ y1 satisfying x0 < x1 and y0 < y1. This means the region covers all points (x,y)\
  \ satisfying x0 <= x <= x1 and y0 <= y <= y1.\nAs stated before hand, no corner\
  \ of any region will intersect any other region anywhere. That is, if (x,y) is a\
  \ corner point of one region and another region is described by x0, x1, y0, and\
  \ y1, then we do not have x0 <= x <= x1 and y0 <= y <= y1.\nBounds: 1 <= n <= 100\
  \ and each integer in a region description fits in a signed 32 bit integer.\n\n\
  -----Output-----\nThe output for each test case is a single line containing a single\
  \ integer that is the maximum number of regions that can be left on the wall such\
  \ that no two regions share a common point in the deployment area.\n\n-----Example-----\n\
  Input:\n1\n4\n0 4 0 4\n1 3 1 2\n2 3 1 3\n3 4 1 3\nOutput:\n2"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def get_mininum_value (s1 s2 : String) : Nat :=\n  sorry\n"
"vc-theorems": "theorem get_minimum_value_nonnegative (s1 s2 : String) :\n  get_mininum_value\
  \ s1 s2 ≥ 0 :=\nsorry\n\n\ntheorem get_minimum_value_bounded (s1 s2 : String) :\n\
  \  get_mininum_value s1 s2 ≤ min (s1.length) (s2.length) :=\nsorry\n\n\ntheorem\
  \ get_minimum_value_different_lengths (s1 s2 : String) :\n  s1.length ≠ s2.length\
  \ →\n  get_mininum_value s1 s2 = min (s1.length) (s2.length) :=\nsorry\n\n\ntheorem\
  \ get_minimum_value_identical (s1 s2 : String) :\n  s1 = s2 →\n  get_mininum_value\
  \ s1 s2 = s1.length :=\nsorry\n\n\ntheorem get_minimum_value_first_difference (s1\
  \ s2 : String) :\n  s1.length = s2.length →\n  s1 ≠ s2 →\n  (s1.take (get_mininum_value\
  \ s1 s2) = s2.take (get_mininum_value s1 s2)) ∧\n  (s1.take (get_mininum_value s1\
  \ s2 + 1) ≠ s2.take (get_mininum_value s1 s2 + 1)) :=\nsorry\n\n\ntheorem get_minimum_value_identical_string\
  \ (s : String) :\n  get_mininum_value s s = s.length :=\nsorry"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded"
