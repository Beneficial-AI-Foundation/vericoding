vc-description: |-
  Write

  ```python
  function combine()
  ```

  that combines arrays by alternatingly taking elements passed to it.

  E.g

  ```python
  combine(['a', 'b', 'c'], [1, 2, 3]) == ['a', 1, 'b', 2, 'c', 3]
  combine(['a', 'b', 'c'], [1, 2, 3, 4, 5]) == ['a', 1, 'b', 2, 'c', 3, 4, 5]
  combine(['a', 'b', 'c'], [1, 2, 3, 4, 5], [6, 7], [8]) == ['a', 1, 6, 8, 'b', 2, 7, 'c', 3, 4, 5]
  ```

  Arrays can have different lengths.
vc-preamble: |-
  import Imports.AllImports
vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>
vc-definitions: |
  def combine {α : Type u} (lists : List (List α)) : List α := sorry

  theorem combine_preserves_elements {α : Type u} (lists : List (List α)) (h : lists ≠ []) :
    ∀ (lst : List α), lst ∈ lists → ∀ (x : α), x ∈ lst → x ∈ combine lists := sorry
vc-theorems: |-
  theorem combine_length {α : Type u} (lists : List (List α)) (h : lists ≠ []) :
    let maxLen := (lists.map List.length).maximum?.getD 0
    let minLen := (lists.map (fun l => min l.length maxLen)).foldl (· + ·) 0
    List.length (combine lists) = minLen := sorry


  theorem combine_interleaving {α : Type u} (lists : List (List α)) 
    (h1 : lists ≠ []) (h2 : lists.length ≥ 2)
    (i j : Nat) (hi : i < (lists.map List.length).minimum?.getD 0) (hj : j < lists.length) :
    let minLen := (lists.map List.length).minimum?.getD 0
    (combine lists).get? (i * lists.length + j) = (lists.get? j).bind (fun l => l.get? i) := sorry
vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: guarded
