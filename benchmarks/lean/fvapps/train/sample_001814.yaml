"vc-description": "Given a (singly) linked list with head node root, write a function\
  \ to split the linked list into k consecutive linked list \"parts\".\n\nThe length\
  \ of each part should be as equal as possible: no two parts should have a size differing\
  \ by more than 1.  This may lead to some parts being null.\n\nThe parts should be\
  \ in order of occurrence in the input list, and parts occurring earlier should always\
  \ have a size greater than or equal parts occurring later.\n\nReturn a List of ListNode's\
  \ representing the linked list parts that are formed.\n\n\nExamples\n1->2->3->4,\
  \ k = 5 // 5 equal parts\n[ [1], \n[2],\n[3],\n[4],\nnull ]\n\nExample 1:\n\nInput:\
  \ \nroot = [1, 2, 3], k = 5\nOutput: [[1],[2],[3],[],[]]\nExplanation:\nThe input\
  \ and each element of the output are ListNodes, not arrays.\nFor example, the input\
  \ root has root.val = 1, root.next.val = 2, \\root.next.next.val = 3, and root.next.next.next\
  \ = null.\nThe first element output[0] has output[0].val = 1, output[0].next = null.\n\
  The last element output[4] is null, but it's string representation as a ListNode\
  \ is [].\n\n\n\nExample 2:\n\nInput: \nroot = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k\
  \ = 3\nOutput: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]\nExplanation:\nThe input has\
  \ been split into consecutive parts with size difference at most 1, and earlier\
  \ parts are a larger size than the later parts.\n\n\n\nNote:\nThe length of root\
  \ will be in the range [0, 1000].\nEach value of a node in the input will be an\
  \ integer in the range [0, 999].\nk will be an integer in the range [1, 50]."
"vc-preamble": "import Imports.AllImports\n\ndef create_linked_list {α} (values :\
  \ List α) : Option (Node α) := sorry\n\ndef linked_list_to_list {α} (node : Option\
  \ (Node α)) : List α := sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def split_list_to_parts {α} (head : Option (Node α)) (k : Nat)\
  \ : List (Option (Node α)) := sorry\n\ntheorem split_list_returns_k_parts {α} (values\
  \ : List α) (k : Nat) (h : k > 0) :\n  let head := create_linked_list values\n \
  \ let result := split_list_to_parts head k\n  result.length = k := sorry\n"
"vc-theorems": "theorem split_list_preserves_elements {α} (values : List α) (k : Nat)\
  \ (h : k > 0) :\n  let head := create_linked_list values\n  let result := split_list_to_parts\
  \ head k\n  List.join (result.map linked_list_to_list) = values := sorry\n\n\ntheorem\
  \ split_list_balanced_sizes {α} (values : List α) (k : Nat) (h : k > 0) :\n  let\
  \ head := create_linked_list values\n  let result := split_list_to_parts head k\n\
  \  let non_empty := (result.map linked_list_to_list).filter (fun l => ¬l.isEmpty)\n\
  \  ¬non_empty.isEmpty →\n  (List.maximum? (non_empty.map List.length)).get! - \n\
  \  (List.minimum? (non_empty.map List.length)).get! ≤ 1 := sorry\n\n\ntheorem empty_list_split\
  \ {α} (k : Nat) (h : k > 0) :\n  let result := split_list_to_parts (none : Option\
  \ (Node α)) k\n  result.length = k ∧ \n  result.all (fun x => x.isNone) := sorry\n\
  \n\ntheorem single_part_split {α} (values : List α) (h : values ≠ []) :\n  let head\
  \ := create_linked_list values\n  let result := split_list_to_parts head 1\n  result.length\
  \ = 1 ∧\n  linked_list_to_list result[0]! = values := sorry"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded"
