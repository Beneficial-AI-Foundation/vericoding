"vc-description": "Given a binary tree, return the sum of values of its deepest leaves.\n\
   \nExample 1:\n\nInput: root = [1,2,3,4,5,null,6,7,null,null,null,null,8]\nOutput:\
  \ 15\n\n \nConstraints:\n\nThe number of nodes in the tree is between 1 and 10^4.\n\
  The value of nodes is between 1 and 100."
"vc-preamble": "import Imports.AllImports\n\ndef deepest_leaves_sum (root : TreeNode)\
  \ : Int :=\n  sorry\n\n\ndef makeTree (vals : List Int) : TreeNode :=\n  sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def getDeepestLevel (t : TreeNode) : List Int :=\n  sorry\n"
"vc-theorems": "theorem single_path_tree_deepest_sum {vals : List Int} (h : vals ≠\
  \ []) :\n  let v := vals.head!\n  let root := TreeNode.mk v none none\n  let path\
  \ := vals.tail.foldl (fun acc v => \n    TreeNode.mk v (some acc) none) root\n \
  \ deepest_leaves_sum path = vals.getLast! \n  := sorry\n\n\ntheorem level_order_tree_deepest_sum\
  \ {vals : List Int} (h : vals ≠ []) : \n  let v := vals.head!\n  let root := TreeNode.mk\
  \ v none none\n  deepest_leaves_sum root = (getDeepestLevel (makeTree vals)).foldl\
  \ (· + ·) 0\n  := sorry\n\n\ntheorem single_node_deepest_sum (v : Int) :\n  deepest_leaves_sum\
  \ (TreeNode.mk v none none) = v\n  := sorry\n\n\ntheorem two_level_tree_deepest_sum\
  \ :\n  let root := TreeNode.mk 1 \n    (some (TreeNode.mk 2 none none))\n    (some\
  \ (TreeNode.mk 3 none none))\n  deepest_leaves_sum root = 5\n  := sorry\n\n/--\n\
  info: 15\n-/\n#guard_msgs in\n#eval deepest_leaves_sum TreeNode(1)\n\n/--\ninfo:\
  \ 1\n-/\n#guard_msgs in\n#eval deepest_leaves_sum TreeNode(1)\n\n/--\ninfo: 5\n\
  -/\n#guard_msgs in\n#eval deepest_leaves_sum TreeNode(1)\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
