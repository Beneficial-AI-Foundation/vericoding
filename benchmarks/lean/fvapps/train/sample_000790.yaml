"vc-description": "Chef is frustrated in this lockown. So to overcome this he plans\
  \ to travel various mountains.\nHe is very strange so he sets some conditions for\
  \ $each$ Type 2 query(mentioned below) (i.e. $1$ $i$) : \n- Let Chef has travelled\
  \ till $ith$ mountain from left to right.\n- He does not like to travel the mountain\
  \ with the height ,of which he has travelled till now. More formally, \nLet the\
  \ height of peak on which he is standing is $a_{i}$ then he can only go to the peak\
  \ of height $a_{j}$ \nwhich is greater than $a_{i}$ and nearest to $ith$ mountain\
  \ such that there should be no other peak of same height $a_{j}$ till $a_{i}$(height\
  \ of $ith$ mountain) .\n\n-----Input format:-----\n- \nThe first line contains an\
  \ integer $T$ denoting the number of test cases.\n- \nThe second line of  consist\
  \ of a integer $N$ and $Q$ .\n- \nThe third line contains $N$ not necessarily distinct\
  \ positive integers $a_{0},a_{1}, . . .,a_{n-1}$ denoting the height of \n$N$ mountains.\n\
  - \nThen next $Q$ lines follows where each line consisting of $either$ of $2$ types\
  \ of queries:\nType 1:  $0$ $A$ $B$ i.e. $a_{A} = B$ (where height of $Ath$ mountain\
  \ will be updated to $B$) \nType 2:  $1$ $A$ i.e. you have to answer $a_k$ which\
  \ is greater than $a_{A}$ and nearest to $Ath$ mountain such that there should be\
  \ no other peak of same height $a_{k}$ till $a_{A}$(height of $Ath$ mountain) .\n\
  \n-----Output format:-----\n- For every query of Type 2 there should be an integer\
  \ $a_{k}$ on next  line for the updated array , If no such $a_{k}$ exists then $a_{k}$=\
  \ $-1$ , as query of type 1 will have no output . \n\n-----Constraints:-----\n-\
  \ $1\\leq T \\leq 10^2$\n- $1 \\leq N,Q \\leq 10^4$\n- $0\\leq a_{i} \\leq 10^6$\n\
  - $0\\leq B \\leq 10^6$\n- $0\\leq A \\leq N-1$\n\n-----Subtasks-----\n- \n1 Point\
  \ :   \n$1 \\leq T,N,Q \\leq 10^2$ \n$0\\leq B,a_{i} \\leq 10^2$\n- \n99 Points\
  \ : Orginal   Constraints\n\n-----Example:-----\n\n-----Input:-----\n1\n10 5\n1\
  \ 3 5 4 5 6 7 8  4 5\n1 7\n1 3\n1 1\n0 2 7\n1 3\n\n-----Output:-----\n-1\n6\n5\n\
  5"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def solve_mountain_queries (n : Nat) (mountains : List Nat) (queries\
  \ : List (List Nat)) : List Nat :=\n  sorry\n\n-- Results length matches number\
  \ of type 1 queries"
"vc-theorems": "theorem results_length_matches_type_1_queries (n : Nat) (mountains\
  \ : List Nat) (queries : List (List Nat)) \n  (h1 : n ≥ 2) (h2 : mountains.length\
  \ = n) :\n  (solve_mountain_queries n mountains queries).length = \n    (queries.filter\
  \ (fun q => q.get? 0 = some 1)).length := \n  sorry\n\n-- All results are either\
  \ -1 or higher than queried mountain \n\ntheorem results_valid_height (n : Nat)\
  \ (mountains : List Nat) (queries : List (List Nat)) \n  (h1 : n ≥ 2) (h2 : mountains.length\
  \ = n)\n  (i : Nat) (h3 : i < (solve_mountain_queries n mountains queries).length)\n\
  \  (h4 : i < (queries.filter (fun q => q.get? 0 = some 1)).length) :\n  let result\
  \ := (solve_mountain_queries n mountains queries)[i]'h3\n  let type1Queries := queries.filter\
  \ (fun q => q.get? 0 = some 1)\n  let mountainIdx := (type1Queries[i]?.bind (λ q\
  \ => q.get? 1)).getD 0\n  result = 0 ∨ result > mountains[mountainIdx]?.getD 0 :=\n\
  \  sorry\n\n-- Update query changes mountain height\n\ntheorem update_query_changes_height\
  \ (n : Nat) (mountains : List Nat) (new_height : Nat)\n  (h1 : n ≥ 2) (h2 : mountains.length\
  \ = n) :\n  let update_idx := min 1 (n-1)\n  let queries1 := [[0, update_idx, new_height],\
  \ [1, update_idx]]\n  let queries2 := [[1, update_idx]]\n  let new_mountains :=\
  \ mountains.set update_idx new_height\n  solve_mountain_queries n mountains queries1\
  \ = \n    solve_mountain_queries n new_mountains queries2 :=\n  sorry"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded"
