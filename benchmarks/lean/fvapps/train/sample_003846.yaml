"vc-description": "I'm sure you're familiar with factorials – that is, the product\
  \ of an integer and all the integers below it. \n\nFor example, `5! = 120`, as `5\
  \ * 4 * 3 * 2 * 1 = 120`\n\nYour challenge is to create a function that takes any\
  \ number and returns the number that it is a factorial of. So, if your function\
  \ receives `120`, it should return `\"5!\"` (as a string).\n\nOf course, not every\
  \ number is a factorial of another. In this case, your function would return `\"\
  None\"` (as a string).\n\n### Examples\n\n* `120` will return `\"5!\"`\n* `24` will\
  \ return `\"4!\"`\n* `150` will return `\"None\"`"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def reverse_factorial (n : Int) : String := sorry\n\ntheorem forward_reverse_factorial\
  \ {n : Nat} (h : 1 ≤ n ∧ n ≤ 10) :\n  let factorial := (List.range n).foldl (fun\
  \ x y => x * (y+1)) 1\n  reverse_factorial (Int.ofNat factorial) = s!\"{n}!\" :=\
  \ sorry\n"
"vc-theorems": "theorem nonmatching_numbers_return_none {n : Int} (h : 1 ≤ n ∧ n ≤\
  \ 10000) :\n  ¬(∃ k : Nat, (List.range k).foldl (fun x y => x * (y+1)) 1 = Int.toNat\
  \ n) →\n  reverse_factorial n = \"None\" := sorry\n\n\ntheorem nonpositive_returns_none\
  \ {n : Int} (h : n ≤ 0) :\n  reverse_factorial n = \"None\" := sorry\n\n\ntheorem\
  \ known_factorials :\n  reverse_factorial 1 = \"1!\" ∧\n  reverse_factorial 2 =\
  \ \"2!\" ∧\n  reverse_factorial 6 = \"3!\" := sorry\n\n/--\ninfo: '5!'\n-/\n#guard_msgs\
  \ in\n#eval reverse_factorial 120\n\n/--\ninfo: '10!'\n-/\n#guard_msgs in\n#eval\
  \ reverse_factorial 3628800\n\n/--\ninfo: 'None'\n-/\n#guard_msgs in\n#eval reverse_factorial\
  \ 150\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
