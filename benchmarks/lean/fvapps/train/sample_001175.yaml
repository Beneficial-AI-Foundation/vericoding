"vc-description": "Chef has an array A = (A1, A2, ..., AN), which has N integers in\
  \ it initially. Chef found that for i ≥ 1, if Ai > 0, Ai+1 > 0, and Ai+2 exists,\
  \ then he can decrease both Ai, and Ai+1 by one and increase Ai+2 by one. If Ai+2\
  \ doesn't exist, but Ai > 0, and Ai+1 > 0, then he can decrease both Ai, and Ai+1\
  \ (which will be the currently last two elements of the array) by one and add a\
  \ new element at the end, whose value is 1.\nNow Chef wants to know the number of\
  \ different arrays that he can make from A using this operation as many times as\
  \ he wishes. Help him find this, and because the answer could be very large, he\
  \ is fine with you reporting the answer modulo 109+7.\nTwo arrays are same if they\
  \ have the same number of elements and if each corresponding element is the same.\
  \ For example arrays (2,1,1) and (1,1,2) are different. \n\n-----Input-----\n- The\
  \ first line of the input contains a single integer T denoting the number of test\
  \ cases.\n- The first line contains a single integer N denoting the initial number\
  \ of elements in A.\n- The second line contains N space-separated integers: A1,\
  \ A2, ... , AN. \n\n-----Output-----\nFor each test case, output answer modulo 109+7\
  \ in a single line. \n\n-----Constraints-----\n- 1 ≤ T ≤ 5\n- 1 ≤ N ≤ 50\n- 0 ≤\
  \ Ai ≤ 50\n\n-----Subtasks-----\n- Subtask 1 (20 points) : 1 ≤ N ≤ 8, 0 ≤ Ai ≤ 4\n\
  - Subtask 2 (80 points) : Original constraints\n\n-----Example-----\nInput:\n3\n\
  3\n2 3 1\n2\n2 2\n3\n1 2 3\n\nOutput:\n9\n4\n9\n\n-----Explanation-----\nExample\
  \ case 1.\nWe'll list the various single steps that you can take (ie. in one single\
  \ usage of the operation):\n- (2, 3, 1) → (2, 2, 0, 1)\n- (2, 2, 0, 1) → (1, 1,\
  \ 1, 1)\n- (1, 1, 1, 1) → (1, 1, 0, 0, 1)\n- (1, 1, 0, 0, 1) → (0, 0, 1, 0, 1)\n\
  - (1, 1, 1, 1) → (1, 0, 0, 2)\n- (1, 1, 1, 1) → (0, 0, 2, 1)\n- (2, 3, 1) → (1,\
  \ 2, 2)\n- (1, 2, 2) → (0, 1, 3)\n\nSo all the arrays you can possibly get are:\
  \ \n(2, 3, 1), (2, 2, 0, 1), (1, 1, 1, 1), (1, 1, 0, 0, 1), (0, 0, 1, 0, 1), (1,\
  \ 0, 0, 2), (0, 0, 2, 1), (1, 2, 2), and (0, 1, 3)\nSince there are 9 different\
  \ arrays that you can reach, the answer is 9."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def count_possible_arrays (arr: List Nat) : Nat := sorry\n\ntheorem\
  \ count_possible_arrays_output_range (arr: List Nat) :\n  0 ≤ count_possible_arrays\
  \ arr ∧ count_possible_arrays arr < 1000000007 := sorry\n"
"vc-theorems": "theorem count_possible_arrays_deterministic (arr: List Nat) :\n  count_possible_arrays\
  \ arr = count_possible_arrays arr := sorry\n\n\ntheorem count_possible_arrays_all_zeros\
  \ (arr: List Nat) :\n  (∀ x ∈ arr, x = 0) → count_possible_arrays arr = 1 := sorry\n\
  \n\ntheorem count_possible_arrays_fixed_cases :\n  count_possible_arrays [2,2] =\
  \ 4 ∧\n  count_possible_arrays [2,3,1] = 9 ∧ \n  count_possible_arrays [1,2,3] =\
  \ 9 := sorry\n\n/--\ninfo: 9\n-/\n#guard_msgs in\n#eval count_possible_arrays [2,\
  \ 3, 1]\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval count_possible_arrays [2, 2]\n\
  \n/--\ninfo: 9\n-/\n#guard_msgs in\n#eval count_possible_arrays [1, 2, 3]\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
