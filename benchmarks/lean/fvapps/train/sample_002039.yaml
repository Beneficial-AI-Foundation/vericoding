"vc-description": "There are $n$ startups. Startups can be active or acquired. If\
  \ a startup is acquired, then that means it has exactly one active startup that\
  \ it is following. An active startup can have arbitrarily many acquired startups\
  \ that are following it. An active startup cannot follow any other startup.\n\n\
  The following steps happen until there is exactly one active startup. The following\
  \ sequence of steps takes exactly 1 day.  Two distinct active startups $A$, $B$,\
  \ are chosen uniformly at random.  A fair coin is flipped, and with equal probability,\
  \ $A$ acquires $B$ or $B$ acquires $A$ (i.e. if $A$ acquires $B$, then that means\
  \ $B$'s state changes from active to acquired, and its starts following $A$).  When\
  \ a startup changes from active to acquired, all of its previously acquired startups\
  \ become active. \n\nFor example, the following scenario can happen: Let's say $A$,\
  \ $B$ are active startups. $C$, $D$, $E$ are acquired startups under $A$, and $F$,\
  \ $G$ are acquired startups under $B$: [Image]\n\nActive startups are shown in red.\
  \ \n\nIf $A$ acquires $B$, then the state will be $A$, $F$, $G$ are active startups.\
  \ $C$, $D$, $E$, $B$ are acquired startups under $A$. $F$ and $G$ have no acquired\
  \ startups: $G$ \n\nIf instead, $B$ acquires $A$, then the state will be $B$, $C$,\
  \ $D$, $E$ are active startups. $F$, $G$, $A$ are acquired startups under $B$. $C$,\
  \ $D$, $E$ have no acquired startups: [Image] \n\nYou are given the initial state\
  \ of the startups. For each startup, you are told if it is either acquired or active.\
  \ If it is acquired, you are also given the index of the active startup that it\
  \ is following.\n\nYou're now wondering, what is the expected number of days needed\
  \ for this process to finish with exactly one active startup at the end.\n\nIt can\
  \ be shown the expected number of days can be written as a rational number $P/Q$,\
  \ where $P$ and $Q$ are co-prime integers, and $Q \\not= 0 \\pmod{10^9+7}$. Return\
  \ the value of $P \\cdot Q^{-1}$ modulo $10^9+7$.\n\n\n-----Input-----\n\nThe first\
  \ line contains a single integer $n$ ($2 \\leq n \\leq 500$), the number of startups.\n\
  \nThe next line will contain $n$ space-separated integers $a_1, a_2, \\ldots, a_n$\
  \ ($a_i = -1$ or $1 \\leq a_i \\leq n$). If $a_i = -1$, then that means startup\
  \ $i$ is active. Otherwise, if $1 \\leq a_i \\leq n$, then startup $i$ is acquired,\
  \ and it is currently following startup $a_i$. It is guaranteed if $a_i \\not= -1$,\
  \ then $a_{a_i} =-1$ (that is, all startups that are being followed are active).\n\
  \n\n-----Output-----\n\nPrint a single integer, the expected number of days needed\
  \ for the process to end with exactly one active startup, modulo $10^9+7$.\n\n\n\
  -----Examples-----\nInput\n3\n-1 -1 -1\n\nOutput\n3\n\nInput\n2\n2 -1\n\nOutput\n\
  0\n\nInput\n40\n3 3 -1 -1 4 4 -1 -1 -1 -1 -1 10 10 10 10 10 10 4 20 -1 -1 -1 -1\
  \ -1 -1 -1 -1 -1 -1 -1 -1 -1 3 3 3 3 3 3 3 3\n\nOutput\n755808950\n\n\n\n-----Note-----\n\
  \nIn the first sample, there are three active startups labeled $1$, $2$ and $3$,\
  \ and zero acquired startups. Here's an example of how one scenario can happen \
  \ Startup $1$ acquires startup $2$ (This state can be represented by the array $[-1,\
  \ 1, -1]$)  Startup $3$ acquires startup $1$ (This state can be represented by the\
  \ array $[3, -1, -1]$)  Startup $2$ acquires startup $3$ (This state can be represented\
  \ by the array $[-1, -1, 2]$).  Startup $2$ acquires startup $1$ (This state can\
  \ be represented by the array $[2, -1, 2]$). \n\nAt this point, there is only one\
  \ active startup, and this sequence of steps took $4$ days. It can be shown the\
  \ expected number of days is $3$.\n\nFor the second sample, there is only one active\
  \ startup, so we need zero days.\n\nFor the last sample, remember to take the answer\
  \ modulo $10^9+7$."
"vc-preamble": "import Imports.AllImports\n\ndef solve_startups (n : Nat) (arr : List\
  \ Int) : Nat :=\n  sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def pow (base : Nat) (exp : Nat) (m : Nat) : Nat :=\n  sorry\n\n\
  \n"
"vc-theorems": "theorem result_in_valid_range (n : Nat) (arr : List Int) (h₁ : n >\
  \ 0) (h₂ : arr.length = n) :\n  let result := solve_startups n arr\n  0 ≤ result\
  \ ∧ result < 1000000007 :=\n  sorry\n\n\ntheorem array_length_matches_n (n : Nat)\
  \ (arr : List Int) \n  (h₁ : n > 0) (h₂ : arr.length ≥ 1) :\n  let truncated :=\
  \ (List.replicate n arr.head!).take n\n  let result := solve_startups n truncated\n\
  \  0 ≤ result ∧ result < 1000000007 :=\n  sorry\n\n/--\ninfo: 3\n-/\n#guard_msgs\
  \ in\n#eval solve_startups 3 [-1, -1, -1]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n\
  #eval solve_startups 2 [2, -1]\n\n/--\ninfo: 755808950\n-/\n#guard_msgs in\n#eval\
  \ solve_startups 40 [3, 3, -1, -1, 4, 4, -1, -1, -1, -1, -1, 10, 10, 10, 10, 10,\
  \ 10, 4, 20, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 3, 3, 3, 3,\
  \ 3, 3, 3]\n"
"vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded_and_plausible"
