"vc-description": "Write a function that takes in a binary string and returns the\
  \ equivalent decoded text (the text is ASCII encoded).\n\nEach 8 bits on the binary\
  \ string represent 1 character on the ASCII table.\n\nThe input string will always\
  \ be a valid binary string.\n\nCharacters can be in the range from \"00000000\"\
  \ to \"11111111\" (inclusive)\n\nNote: In the case of an empty binary string your\
  \ function should return an empty string."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def binary_to_string (s : String) : String := sorry\n\ndef is_binary_string\
  \ (s : String) : Bool := sorry\n"
"vc-theorems": "theorem binary_to_string_length \n  (binary : String)\n  (h : is_binary_string\
  \ binary)\n  (h2 : String.length binary % 8 = 0) :\n  String.length (binary_to_string\
  \ binary) = String.length binary / 8 := sorry\n\n\ntheorem binary_to_string_roundtrip\n\
  \  (binary : String)\n  (h : is_binary_string binary)\n  (h2 : String.length binary\
  \ % 8 = 0)\n  (h3 : binary â‰  \"\") :\n  let result := binary_to_string binary\n\
  \  let binary_again := String.join (result.data.map (fun c => \n    String.mk [c]))\n\
  \  binary = binary_again := sorry\n\n/--\ninfo: ''\n-/\n#guard_msgs in\n#eval binary_to_string\
  \ \"\"\n\n/--\ninfo: 'Hello'\n-/\n#guard_msgs in\n#eval binary_to_string \"0100100001100101011011000110110001101111\"\
  \n\n/--\ninfo: '1011'\n-/\n#guard_msgs in\n#eval binary_to_string \"00110001001100000011000100110001\"\
  \n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
