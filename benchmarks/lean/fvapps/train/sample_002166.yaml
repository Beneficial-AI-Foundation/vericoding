vc-description: |-
  There are M chairs arranged in a line. The coordinate of the i-th chair (1 ≤ i ≤ M) is i.
  N people of the Takahashi clan played too much games, and they are all suffering from backaches. They need to sit in chairs and rest, but they are particular about which chairs they sit in. Specifically, the i-th person wishes to sit in a chair whose coordinate is not greater than L_i, or not less than R_i. Naturally, only one person can sit in the same chair.
  It may not be possible for all of them to sit in their favorite chairs, if nothing is done.
  Aoki, who cares for the health of the people of the Takahashi clan, decides to provide additional chairs so that all of them can sit in chairs at their favorite positions.
  Additional chairs can be placed at arbitrary real coordinates. Find the minimum required number of additional chairs.

  -----Constraints-----
   - 1 ≤ N,M ≤ 2 × 10^5
   - 0 ≤ L_i < R_i ≤ M + 1(1 ≤ i ≤ N)
   - All input values are integers.

  -----Input-----
  Input is given from Standard Input in the following format:
  N M
  L_1 R_1
  :
  L_N R_N

  -----Output-----
  Print the minimum required number of additional chairs.

  -----Sample Input-----
  4 4
  0 3
  2 3
  1 3
  3 4

  -----Sample Output-----
  0

  The four people can sit in chairs at the coordinates 3, 2, 1 and 4, respectively, and no more chair is needed.
vc-preamble: |-
  import Imports.AllImports

  def initTree (M : Nat) : LazySegmentTree M := sorry
  def updateTree (M : Nat) : LazySegmentTree M → Nat → Nat → Int → LazySegmentTree M := sorry

  def queryTree (M : Nat) : LazySegmentTree M → Nat → Nat → Int := sorry

  def LV : Nat := sorry
vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>
vc-definitions: |
  def N0 : Nat := sorry
  def INF : Int := sorry
vc-theorems: |
  theorem lst_initialization_invariants {M : Nat} (h : M > 0) (h2 : M ≤ 100) :
    N0 = 2^LV ∧ N0 > 0 := by sorry


  theorem segment_tree_operations_sound {M : Nat} (l r : Nat) (x : Int)
    (h1 : l ≤ r) (h2 : r < M) (h3 : M > 0)
    (h4 : l ≤ 10) (h5 : r ≤ 10) (h6 : x ≥ -100) (h7 : x ≤ 100) :
    let lst := initTree M
    let lst' := updateTree M lst l r x
    let result := queryTree M lst' l r 
    x ≥ 0 → result ≤ INF := by sorry

  /--
  info: 0
  -/
  #guard_msgs in
  #eval solve 4 4 [(0, 3), (2, 3), (1, 3), (3, 4)]

  /--
  info: 2
  -/
  #guard_msgs in
  #eval solve 7 6 [(0, 7), (1, 5), (3, 6), (2, 7), (1, 6), (2, 6), (3, 7)]

  /--
  info: 2
  -/
  #guard_msgs in
  #eval solve 3 1 [(1, 2), (1, 2), (1, 2)]
vc-postamble: |-
  -- Apps difficulty: competition
  -- Assurance level: guarded
