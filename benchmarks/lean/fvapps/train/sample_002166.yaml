"vc-description": "There are M chairs arranged in a line. The coordinate of the i-th\
  \ chair (1 ≤ i ≤ M) is i.\nN people of the Takahashi clan played too much games,\
  \ and they are all suffering from backaches. They need to sit in chairs and rest,\
  \ but they are particular about which chairs they sit in. Specifically, the i-th\
  \ person wishes to sit in a chair whose coordinate is not greater than L_i, or not\
  \ less than R_i. Naturally, only one person can sit in the same chair.\nIt may not\
  \ be possible for all of them to sit in their favorite chairs, if nothing is done.\n\
  Aoki, who cares for the health of the people of the Takahashi clan, decides to provide\
  \ additional chairs so that all of them can sit in chairs at their favorite positions.\n\
  Additional chairs can be placed at arbitrary real coordinates. Find the minimum\
  \ required number of additional chairs.\n\n-----Constraints-----\n - 1 ≤ N,M ≤ 2\
  \ × 10^5\n - 0 ≤ L_i < R_i ≤ M + 1(1 ≤ i ≤ N)\n - All input values are integers.\n\
  \n-----Input-----\nInput is given from Standard Input in the following format:\n\
  N M\nL_1 R_1\n:\nL_N R_N\n\n-----Output-----\nPrint the minimum required number\
  \ of additional chairs.\n\n-----Sample Input-----\n4 4\n0 3\n2 3\n1 3\n3 4\n\n-----Sample\
  \ Output-----\n0\n\nThe four people can sit in chairs at the coordinates 3, 2, 1\
  \ and 4, respectively, and no more chair is needed."
"vc-preamble": "import Imports.AllImports\n\ndef initTree (M : Nat) : LazySegmentTree\
  \ M := sorry\ndef updateTree (M : Nat) : LazySegmentTree M → Nat → Nat → Int → LazySegmentTree\
  \ M := sorry\n\ndef queryTree (M : Nat) : LazySegmentTree M → Nat → Nat → Int :=\
  \ sorry\n\ndef LV : Nat := sorry"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def N0 : Nat := sorry\ndef INF : Int := sorry\n"
"vc-theorems": "theorem lst_initialization_invariants {M : Nat} (h : M > 0) (h2 :\
  \ M ≤ 100) :\n  N0 = 2^LV ∧ N0 > 0 := by sorry\n\n\ntheorem segment_tree_operations_sound\
  \ {M : Nat} (l r : Nat) (x : Int)\n  (h1 : l ≤ r) (h2 : r < M) (h3 : M > 0)\n  (h4\
  \ : l ≤ 10) (h5 : r ≤ 10) (h6 : x ≥ -100) (h7 : x ≤ 100) :\n  let lst := initTree\
  \ M\n  let lst' := updateTree M lst l r x\n  let result := queryTree M lst' l r\
  \ \n  x ≥ 0 → result ≤ INF := by sorry\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval\
  \ solve 4 4 [(0, 3), (2, 3), (1, 3), (3, 4)]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n\
  #eval solve 7 6 [(0, 7), (1, 5), (3, 6), (2, 7), (1, 6), (2, 6), (3, 7)]\n\n/--\n\
  info: 2\n-/\n#guard_msgs in\n#eval solve 3 1 [(1, 2), (1, 2), (1, 2)]\n"
"vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded"
