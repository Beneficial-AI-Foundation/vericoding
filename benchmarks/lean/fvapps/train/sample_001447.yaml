"vc-description": "\tA valid parentheses sequence is a non-empty string where each\
  \ character is either '(' or ')', which satisfies the following constraint:\n\n\
  You can find a way to repeat erasing adjacent pairs of parentheses '()' until it\
  \ becomes empty.\n\n\tFor example, '(())' and '()((()()))' are valid parentheses\
  \ sequences, but ')()(' and '(()' are not.\n\n\tMike has a valid parentheses sequence.\
  \ He really likes everything about his sequence, except the fact that it is quite\
  \ long. So Mike has recently decided that he will replace his parentheses sequence\
  \ with a new one in the near future. But not every valid parentheses sequence will\
  \ satisfy him. To help you understand his requirements we'll introduce the pseudocode\
  \ of function F(S):\n\n\tFUNCTION F( S - a valid parentheses sequence )\n\tBEGIN\n\
  \t\tbalance = 0\n\t\tmax_balance = 0\n\t\tFOR index FROM 1 TO LENGTH(S)\n\t\tBEGIN\n\
  \t\t\tif S[index] == '(' then balance = balance + 1\n\t\t\tif S[index] == ')' then\
  \ balance = balance - 1\n\t\t\tmax_balance = max( max_balance, balance )\n\t\tEND\n\
  \t\tRETURN max_balance\n\tEND\n\n\tIn other words, F(S) is equal to the maximal\
  \ balance over all prefixes of S.\n\n\tLet's denote A as Mike's current parentheses\
  \ sequence, and B as a candidate for a new one. Mike is willing to replace A with\
  \ B if F(A) is equal to F(B). He would also like to choose B with the minimal possible\
  \ length amongst ones satisfying the previous condition. If there are several such\
  \ strings with the minimal possible length, then Mike will choose the least one\
  \ lexicographically, considering '(' to be less than ')'.\n\n\tHelp Mike!\n\n-----Input-----\n\
  \n\tThe first line of the input contains one integer T denoting the number of testcases\
  \ to process.\n\n\tThe only line of each testcase contains one string A denoting\
  \ Mike's parentheses sequence. It is guaranteed that A only consists of the characters\
  \ '(' and ')'. It is also guaranteed that A is a valid parentheses sequence.\n\n\
  -----Output-----\n\n\tThe output should contain exactly T lines, one line per each\
  \ testcase in the order of their appearance. The only line of each testcase should\
  \ contain one string B denoting the valid parentheses sequence that should be chosen\
  \ by Mike to replace A.\n\n-----Constraints-----\n1 ≤ T ≤ 5;\n1 ≤ |A| ≤ 100000(105).\n\
  \n-----Example-----\nInput:\n1\n()((()()))\n\nOutput:\n((()))"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def find_minimal_parentheses (s: String) : String := sorry\n\n\
  def is_balanced (s: String) : Bool := sorry\n"
"vc-theorems": "theorem output_is_balanced (s: String) : \n  let result := find_minimal_parentheses\
  \ s\n  is_balanced result ∧ ∀ c ∈ result.data, c = '(' ∨ c = ')' := sorry\n\n\n\
  theorem output_length_is_even (s: String) :\n  let result := find_minimal_parentheses\
  \ s\n  result.length % 2 = 0 ∧ \n  (result.data.filter (· = '(')).length = (result.data.filter\
  \ (· = ')')).length := sorry\n\n\ntheorem output_is_nested (s: String) :\n  let\
  \ result := find_minimal_parentheses s\n  let n := result.length\n  (∀ (i: Nat),\
  \ i < n/2 → ∃ (p: String.Pos), result.get p = '(') ∧\n  (∀ (i: Nat), n/2 ≤ i ∧ i\
  \ < n → ∃ (p: String.Pos), result.get p = ')') := sorry\n\n/--\ninfo: '((()))'\n\
  -/\n#guard_msgs in\n#eval find_minimal_parentheses \"()((()()))\"\n\n/--\ninfo:\
  \ '(())'\n-/\n#guard_msgs in\n#eval find_minimal_parentheses \"(())\"\n\n/--\ninfo:\
  \ '(((())))'\n-/\n#guard_msgs in\n#eval find_minimal_parentheses \"(((())))\"\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
