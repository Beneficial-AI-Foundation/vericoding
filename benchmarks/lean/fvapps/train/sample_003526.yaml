"vc-description": "In this kata, you need to make a (simplified) LZ78 encoder and\
  \ decoder.\n[LZ78](https://en.wikipedia.org/wiki/LZ77_and_LZ78#LZ78) is a dictionary-based\
  \ compression method created in 1978. You will find a  detailed explanation about\
  \ how it works below.\n\nThe input parameter will always be a non-empty string of\
  \ upper case alphabetical characters. The maximum decoded string length is 1000\
  \ characters.\n\n\n# Instructions\n\n*If anyone has any ideas on how to make the\
  \ instructions shorter / clearer, that would be greatly appreciated.*\n\nIf the\
  \ below explanation is too confusing, just leave a comment and I'll be happy to\
  \ help.\n\n---\n\nThe input is looked at letter by letter.\nEach letter wants to\
  \ be matched with the longest dictionary substring at that current time.\n\nThe\
  \ output is made up of tokens.\nEach token is in the format ``\nwhere `index` is\
  \ the index of the longest dictionary value that matches the current substring\n\
  and `letter` is the current letter being looked at.\n\n\nHere is how the string\
  \ `'ABAABABAABAB'` is encoded:\n\n\n* First, a dictionary is initialised with the\
  \ 0th item pointing to an empty string:\n\n```md\nDictionary      Input        \
  \     Output\n0  |  ''        ABAABABAABAB\n```\n\n* The first letter is `A`. As\
  \ it doesn't appear in the dictionary, we add `A` to the next avaliable index.\n\
  The token `<0, A>` is added to the output:\n\n```md\nDictionary      Input     \
  \        Output\n\n0  |  ''        ABAABABAABAB      <0, A>\n1  |  A         ^\n\
  ```\n\n* The second letter is `B`. It doesn't appear in the dictionary, so we add\
  \ `B` to the next avaliable index.\nThe token `<0, B>` is added to the output:\n\
  \n```md\nDictionary      Input             Output\n\n0  |  ''        ABAABABAABAB\
  \      <0, A> <0, B>\n1  |  A          ^\n2  |  B\n```\n\n* The third letter is\
  \ `A` again: it already appears in the dictionary at position `1`. We add the next\
  \ letter which is also `A`. `AA` doesn't appear in the dictionary, so we add it\
  \ to the next avaliable index.\nThe token `<1, A>` is added to the output:\n\n```md\n\
  Dictionary      Input             Output\n\n0  |  ''        ABAABABAABAB      <0,\
  \ A> <0, B> <1, A>\n1  |  A           ^^\n2  |  B\n3  |  AA\n```\n\n* The next letter\
  \ is `B` again: it already appears in the dictionary at position `2`. We add the\
  \ next letter which is `A`. `BA` doesn't appear in the dictionary, so we add it\
  \ to the next avaliable index.\nThe token `<2, A>` is added to the output:\n\n```md\n\
  Dictionary      Input             Output\n\n0  |  ''        ABAABABAABAB      <0,\
  \ A> <0, B> <1, A> <2, A>\n1  |  A             ^^\n2  |  B\n3  |  AA\n4  |  BA\n\
  ```\n\n* The next letter is `B`: it already appears in the dictionary and at position\
  \ `2`. We add the next letter which is `A`. `BA` already appears in the dictionary\
  \ at position `4`. We add the next letter which is `A`. `BAA` doesn't appear in\
  \ the dictionary, so we add it to the next avaliable index.\nThe token `<4, A>`\
  \ is added to the output:\n\n```md\nDictionary      Input             Output\n\n\
  0  |  ''        ABAABABAABAB      <0, A> <0, B> <1, A> <2, A> <4, A>\n1  |  A  \
  \             ^^^\n2  |  B\n3  |  AA\n4  |  BA\n5  |  BAA\n```\n\n* The next letter\
  \ is `B`. It already appears in the dictionary at position `2`. We add the next\
  \ letter which is `A`. `BA` already appears in the dictionary at position `4`. We\
  \ add the next letter which is `B`. `BAB` doesn't appear in the dictionary, so we\
  \ add it to the next avaliable index.\nThe token `<4, B>` is added to the output:\n\
  \n```md\nDictionary      Input             Output\n\n0  |  ''        ABAABABAABAB\
  \      <0, A> <0, B> <1, A> <2, A> <4, A> <4, B>\n1  |  A                  ^^^\n\
  2  |  B\n3  |  AA\n4  |  BA\n5  |  BAA\n6  |  BAB\n```\n\n* We have now reached\
  \ the end of the string. We have the output tokens: `<0, A> <0, B> <1, A> <2, A>\
  \ <4, A> <4, B>`.\nNow we just return the tokens without the formatting: `'0A0B1A2A4A4B'`\n\
  \n**Note:**\n\nIf the string ends with a match in the dictionary, the last token\
  \ should only contain the index of the dictionary. For example, `'ABAABABAABABAA'`\
  \ (same as the example but with `'AA'` at the end) should return `'0A0B1A2A4A4B3'`\
  \ (note the final `3`).\n\nTo decode, it just works the other way around.\n\n\n\
  # Examples\n\nSome more examples:\n```\nDecoded                               Encoded\n\
  \nABBCBCABABCAABCAABBCAA                0A0B2C3A2A4A6B6\nAAAAAAAAAAAAAAA       \
  \                0A1A2A3A4A\nABCABCABCABCABCABC                    0A0B0C1B3A2C4C7A6\n\
  ABCDDEFGABCDEDBBDEAAEDAEDCDABC        0A0B0C0D4E0F0G1B3D0E4B2D10A1E4A10D9A2C\n```\n\
  \n\nGood luck :)"
"vc-preamble": "import Imports.AllImports\n\ndef encoder (s : String) : String :=\
  \ sorry\ndef decoder (s : String) : String := sorry\n\n-- Helper function to check\
  \ if character is uppercase\n\ndef isUpper (c : Char) : Bool := sorry\n\n-- Helper\
  \ function to check if character is digit\n\ndef isDigit (c : Char) : Bool := sorry\n\
  \n-- Helper function to check if string starts with 0 and uppercase letter"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def startsWithZeroUpper (s : String) : Bool := sorry\n\ntheorem\
  \ encoder_output_format (s : String) (h : s ≠ \"\") : \n  (∀ c, c ∈ s.toList → isDigit\
  \ c ∨ isUpper c) ∧ \n  startsWithZeroUpper (encoder s) := sorry\n"
"vc-theorems": "theorem encoder_length_bounds (s : String) (h : s ≠ \"\") :\n  String.length\
  \ (encoder s) ≤ 3 * String.length s ∧\n  String.length (encoder s) ≥ String.length\
  \ s / 2 := sorry\n\n\ntheorem encoder_decoder_inverse (s : String) (h : s ≠ \"\"\
  ) :\n  decoder (encoder s) = s := sorry"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
