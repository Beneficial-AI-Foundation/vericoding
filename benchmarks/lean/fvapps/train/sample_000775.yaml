"vc-description": "In a cricket game, an over is a set of six valid deliveries of\
  \ balls performed by one player ― the bowler for this over.\nConsider a cricket\
  \ game with a series of $N$ overs (numbered $1$ through $N$) played by $K$ players\
  \ (numbered $1$ through $K$). Each player may be the bowler for at most $L$ overs\
  \ in total, but the same player may not be the bowler for any two consecutive overs.\
  \ Assign exactly one bowler to each over in such a way that these rules are satisfied\
  \ or determine that no such assignment exists.\n\n-----Input-----\n- The first line\
  \ of the input contains a single integer $T$ denoting the number of test cases.\
  \ The description of $T$ test cases follows.\n- The first and only line of each\
  \ test case contains three space-separated integers $N$, $K$ and $L$. \n\n-----Output-----\n\
  For each test case:\n- If there is no valid assignment of bowlers to overs, print\
  \ a single line containing the integer $-1$.\n- Otherwise, print a single line containing\
  \ $N$ space-separated integers. For each valid $i$, the $i$-th of these integers\
  \ should be the number of the player assigned as the bowler for the $i$-th over.\n\
  \n-----Constraints-----\n- $1 \\le T \\le 30$\n- $1 \\le N, K, L \\le 10,000$\n\n\
  -----Example Input-----\n2\n4 3 2\n5 4 1\n\n-----Example Output-----\n1 2 3 2\n\
  -1\n\n-----Explanation-----\nExample case 1: The following is a valid assignment:\n\
  - Bowler 1 bowls the $1$-st over.\n- Bowler 2 bowls the $2$-nd and $4$-th overs.\n\
  - Bowler 3 bowls the $3$-rd over.\nIt is valid since no bowler bowls more than $2$\
  \ overs and each two consecutive overs have different bowlers.\nExample case 2:\
  \ There is no valid assignment in which each of $4$ players bowls at most $1$ over\
  \ out of $5$."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def assign_bowlers (n k l : Nat) : List Nat := sorry\n\ntheorem\
  \ assign_bowlers_properties {n k l : Nat} (h1 : n > 0) (h2 : k > 0) (h3 : l > 0)\
  \ :\n  let result := assign_bowlers n k l\n  (result = List.nil → (k * l < n ∨ (k\
  \ = 1 ∧ n > 1))) ∧\n  (result ≠ List.nil → \n    (result.length = n) ∧\n    (∀ x\
  \ ∈ result, 1 ≤ x ∧ x ≤ k) ∧\n    (∀ i : Fin (n-1), result[i.val]! ≠ result[i.val\
  \ + 1]!) ∧\n    (∀ i : Fin k, (result.count (i.val + 1)) ≤ l)\n  ) := sorry\n"
"vc-theorems": "theorem single_bowler_case (k l : Nat) (h1 : k > 0) (h2 : l > 0) :\n\
  \  assign_bowlers 1 k l = [1] := sorry \n\n\ntheorem impossible_single_bowler (n\
  \ : Nat) (h : n ≥ 2) :\n  assign_bowlers n 1 n = List.nil := sorry\n\n\ntheorem\
  \ capacity_constraint (n k l : Nat) (h1 : n > 0) (h2 : k > 0) (h3 : l > 0) :\n \
  \ k * l < n → assign_bowlers n k l = List.nil := sorry\n\n/--\ninfo: [1, 2, 3, 1]\n\
  -/\n#guard_msgs in\n#eval assign_bowlers 4 3 2\n\n/--\ninfo: -1\n-/\n#guard_msgs\
  \ in\n#eval assign_bowlers 5 4 1\n\n/--\ninfo: [1, 2, 3]\n-/\n#guard_msgs in\n#eval\
  \ assign_bowlers 3 3 1\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
