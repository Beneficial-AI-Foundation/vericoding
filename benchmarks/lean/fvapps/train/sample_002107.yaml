"vc-description": "Bob has a permutation of integers from 1 to n. Denote this permutation\
  \ as p. The i-th element of p will be denoted as p_{i}. For all pairs of distinct\
  \ integers i, j between 1 and n, he wrote the number a_{i}, j = min(p_{i}, p_{j}).\
  \ He writes a_{i}, i = 0 for all integer i from 1 to n.\n\nBob gave you all the\
  \ values of a_{i}, j that he wrote down. Your job is to reconstruct any permutation\
  \ that could have generated these values. The input will be formed so that it is\
  \ guaranteed that there is at least one solution that is consistent with the information\
  \ given.\n\n\n-----Input-----\n\nThe first line of the input will contain a single\
  \ integer n (2 ≤ n ≤ 50).\n\nThe next n lines will contain the values of a_{i},\
  \ j. The j-th number on the i-th line will represent a_{i}, j. The i-th number on\
  \ the i-th line will be 0. It's guaranteed that a_{i}, j = a_{j}, i and there is\
  \ at least one solution consistent with the information given.\n\n\n-----Output-----\n\
  \nPrint n space separated integers, which represents a permutation that could have\
  \ generated these values. If there are multiple possible solutions, print any of\
  \ them.\n\n\n-----Examples-----\nInput\n2\n0 1\n1 0\n\nOutput\n2 1\n\nInput\n5\n\
  0 2 2 1 2\n2 0 4 1 3\n2 4 0 1 3\n1 1 1 0 1\n2 3 3 1 0\n\nOutput\n2 5 4 1 3\n\n\n\
  \n-----Note-----\n\nIn the first case, the answer can be {1, 2} or {2, 1}.\n\nIn\
  \ the second case, another possible answer is {2, 4, 5, 1, 3}."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def solve_permutation (n : Nat) (matrix : List (List Nat)) : List\
  \ Nat := sorry\n\ndef List.sort : List Nat → List Nat := sorry\n\n-- Result is a\
  \ valid permutation"
"vc-theorems": "theorem solve_permutation_valid_perm (n : Nat) (matrix : List (List\
  \ Nat)) \n  (h1 : n ≥ 2)\n  (h2 : matrix.length = n)\n  (h3 : ∀ i < n, (matrix[i]!).length\
  \ = n)\n  (h4 : ∀ i < n, ∀ j < n, i = j → matrix[i]![j]! = 0)\n  (h5 : ∀ i < n,\
  \ ∀ j < n, i ≠ j → matrix[i]![j]! = i + 1) :\n  let result := solve_permutation\
  \ n matrix\n  -- Result has correct length\n  (result.length = n) ∧ \n  -- Result\
  \ contains numbers 1 to n\n  (∀ k, k ∈ result → k > 0 ∧ k ≤ n) ∧\n  -- Result contains\
  \ each number exactly once\n  (∀ k, k ≤ n → (result.filter (λ x => x = k)).length\
  \ = 1) := sorry\n\n\ntheorem solve_permutation_edge_case_2 : \n  (solve_permutation\
  \ 2 [[0, 1], [1, 0]]).sort = [1, 2] := sorry\n\n\ntheorem solve_permutation_edge_case_3\
  \ :\n  (solve_permutation 3 [[0, 2, 2], [1, 0, 1], [1, 1, 0]]).sort = [1, 2, 3]\
  \ := sorry\n\n/--\ninfo: [1, 2]\n-/\n#guard_msgs in\n#eval sorted solve_permutation(n1,\
  \ a1)\n\n/--\ninfo: list(range(1, n2 + 1))\n-/\n#guard_msgs in\n#eval sorted solve_permutation(n2,\
  \ a2)\n\n/--\ninfo: list(range(1, n3 + 1))\n-/\n#guard_msgs in\n#eval sorted solve_permutation(n3,\
  \ a3)\n"
"vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded"
