"vc-description": "Normally, we decompose a number into binary digits by assigning\
  \ it with powers of 2, with a coefficient of `0` or `1` for each term:\n\n`25 =\
  \ 1*16 + 1*8 + 0*4 + 0*2 + 1*1`\n\nThe choice of `0` and `1` is... not very binary.\
  \ We shall perform the *true* binary expansion by expanding with powers of 2, but\
  \ with a coefficient of `1` or `-1` instead:\n\n`25 = 1*16 + 1*8 + 1*4 - 1*2 - 1*1`\n\
  \nNow *this* looks binary.\n\n---\n\nGiven any positive number `n`, expand it using\
  \ the true binary expansion, and return the result as an array, from the most significant\
  \ digit to the least significant digit.\n\n`true_binary(25) == [1,1,1,-1,-1]`\n\n\
  It should be trivial (the proofs are left as an exercise to the reader) to see that:\n\
  \n- Every odd number has infinitely many true binary expansions\n- Every even number\
  \ has no true binary expansions\n\nHence, `n` will always be an odd number, and\
  \ you should return the *least* true binary expansion for any `n`.\n\nAlso, note\
  \ that `n` can be very, very large, so your code should be very efficient."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def true_binary (n : Nat) : List Int := sorry\n\ntheorem true_binary_starts_with_one\
  \ {n : Nat} (h : n % 2 = 1) :\n  match true_binary n with\n  | [] => False \n  |\
  \ x::xs => x = 1\n  := sorry\n"
"vc-theorems": "theorem true_binary_elements_are_ones {n : Nat} (h : n % 2 = 1) :\n\
  \  ∀ x ∈ true_binary n, x = 1 ∨ x = -1 := sorry\n\n\ntheorem true_binary_length\
  \ {n : Nat} (h : n % 2 = 1) :\n  List.length (true_binary n) = Nat.log2 n := sorry\n\
  \n/--\ninfo: [1, 1, 1, -1, -1]\n-/\n#guard_msgs in\n#eval true_binary 25\n\n/--\n\
  info: [1, 1, -1, 1, 1, 1]\n-/\n#guard_msgs in\n#eval true_binary 47\n\n/--\ninfo:\
  \ [1]\n-/\n#guard_msgs in\n#eval true_binary 1\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
