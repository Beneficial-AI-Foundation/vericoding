"vc-description": "Create a function ```sel_number()```, that will select numbers\
  \ that fulfill the following constraints:\n\n1) The numbers should have 2 digits\
  \ at least.\n\n2) They should have their respective digits in increasing order from\
  \ left to right. \nExamples: 789, 479, 12678, have these feature. But 617, 89927\
  \ are not of this type.\nIn general, if ```d1, d2, d3....``` are the digits of a\
  \ certain number ```i``` \nExample:\n```( i = d1d2d3d4d5) so, d1 < d2 < d3 < d4\
  \ < d5```\n\n3) They cannot have digits that occurs twice or more. Example: 8991\
  \ should be discarded.\n\n4) The difference between neighbouring pairs of digits\
  \ cannot exceed certain value. \nExample: If the difference between contiguous digits\
  \ cannot excced 2, so 1345, 23568 and 234578 pass this test. Other numbers like\
  \ 1456, 389, 157 don't belong to that group because in the first number(1456), the\
  \ difference between second and first digit 4 - 1 > 2; in the next one(389), we\
  \ have 8 - 3 > 2; and see by yourself why 157 should be discarded.\nIn general,\
  \ taking the example above of ```i = d1d2d3d4d5```:\n```\nd2 - d1 <= d;\n\nd3 -\
  \ d2 <= d;\n\nd4 - d3 <= d;\n\nd5 - d4 <= d;\n```\nThe function should accept two\
  \ arguments n and d; n is the upper limit of the range to work with(all the numbers\
  \ should be less or equal than n), and d is maximum difference  between every pair\
  \ of its contiguous digits. It's clear that 1 <= d <= 8.\n\nHere we have some cases:\n\
  ```\nsel_number(0,1) = 0 # n = 0, empty range\nsel_number(3, 1) = 0 # n = 3, numbers\
  \ should be higher or equal than 12\nsel_number(13, 1) = 1 # only 12 fulfill the\
  \ requirements\nsel_number(20, 2) = 2 # 12 and 13 are the numbers\nsel_number(30,\
  \ 2) = 4 # 12, 13, 23 and 24 are the selected ones\nsel_number(44, 2) = 6 # 12,\
  \ 13, 23, 24, 34 and 35 are valid ones\nsel_number(50, 3) = 12 # 12, 13, 14, 23,\
  \ 24, 25, 34, 35, 36, 45, 46 and 47 are valid\n```\nCompare the last example with\
  \ this one:\n```\nsel_number(47, 3) = 12 # 12, 13, 14, 23, 24, 25, 34, 35, 36, 45,\
  \ 46 and 47 are valid \n```\n(because the instructions says the value of may be\
  \ included if it fulfills the above constraints of course)\n\nHappy coding!!"
"vc-preamble": "import Imports.AllImports\n\ndef sel_number (n : Nat) (d : Nat) :\
  \ Nat :=\n  sorry\n\n\ndef hasAscendingUniqueDigits (n : Nat) : Bool :=\n  sorry\n\
  \n/-- Helper function to count numbers with ascending unique digits -/"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def countAscendingUnique (n : Nat) : Nat :=\n  sorry\n\n\n"
"vc-theorems": "theorem sel_number_non_negative (n d : Nat) :\n  sel_number n d ≥\
  \ 0 :=\n  sorry\n\n\ntheorem sel_number_under_twelve (n d : Nat) :\n  n < 12 → sel_number\
  \ n d = 0 :=\n  sorry\n\n\ntheorem sel_number_unique_bound (n : Nat) :\n  sel_number\
  \ n 0 ≤ String.length (toString n) :=\n  sorry\n\n/-- Helper function to check if\
  \ digits are ascending and unique -/\n\ntheorem sel_number_monotonic_d (n : Nat)\
  \ :\n  ∀ d₁ d₂ : Nat, d₁ ≤ d₂ → d₂ < 10 → n ≥ 12 → \n    sel_number n d₁ ≤ sel_number\
  \ n d₂ :=\n  sorry\n\n\ntheorem sel_number_monotonic_n (d n₁ n₂ : Nat) :\n  n₁ ≤\
  \ n₂ → n₁ ≥ 12 → d < 10 →\n    sel_number n₁ d ≤ sel_number n₂ d :=\n  sorry\n\n\
  /--\ninfo: 2\n-/\n#guard_msgs in\n#eval sel_number 20 2\n\n/--\ninfo: 0\n-/\n#guard_msgs\
  \ in\n#eval sel_number 0 1\n\n/--\ninfo: 12\n-/\n#guard_msgs in\n#eval sel_number\
  \ 50 3\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible"
