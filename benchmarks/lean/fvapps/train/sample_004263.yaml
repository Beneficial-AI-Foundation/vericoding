"vc-description": "Given an array of one's and zero's that represents a positive binary\
  \ number convert the number to two's complement value.\n\nTwo's complement is the\
  \ way most computers represent positive or negative integers. The most significant\
  \ bit is negative. \n\nExamples:\n\n-8 4 2 1 \n\n[1,1,1,1] = -1\n\n[1,0,0,0] = -8\n\
  \n[1,1,0,1] = -3\n\nTo get the two's complement negative notation of an integer,\
  \ you take the number in binary. \n\nYou then invert the digits, and add one to\
  \ the result. \n\nFor example:\n\n[0,0,1,0] = 2 in base 10\n\n[1,1,0,1] <- Flip\
  \ the bits\n\n   Add 1\n   \n[1,1,1,0] = -2\n\nHowever, the arrays can have varying\
  \ lengths, not just limited to 4."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def positive_to_negative (binary : List Nat) : List Nat := sorry\n\
  \ntheorem output_is_binary (binary : List Nat) \n  (h : binary.all (fun x => x =\
  \ 0 ∨ x = 1)) \n  (h' : binary.length > 0) :\n  (positive_to_negative binary).all\
  \ (fun x => x = 0 ∨ x = 1) ∧ \n  (positive_to_negative binary).length = binary.length\
  \ := sorry\n"
"vc-theorems": "theorem all_zeros_unchanged (binary : List Nat)\n  (h : binary.all\
  \ (fun x => x = 0))\n  (h' : binary.length > 0) :\n  positive_to_negative binary\
  \ = binary := sorry\n\n\ntheorem flips_after_rightmost_one (binary : List Nat)\n\
  \  (h : binary.all (fun x => x = 0 ∨ x = 1))\n  (h' : binary.length > 0) :\n  match\
  \ binary.findIdx? (· = 1) with\n  | none => positive_to_negative binary = binary\n\
  \  | some last_one_idx => \n    (∀ i, i < last_one_idx → \n      (positive_to_negative\
  \ binary).get ⟨i, sorry⟩ = 1 - binary.get ⟨i, sorry⟩) ∧\n    (∀ i, last_one_idx\
  \ < i → i < binary.length →\n      (positive_to_negative binary).get ⟨i, sorry⟩\
  \ = binary.get ⟨i, sorry⟩)\n  := sorry\n\n\ntheorem double_conversion_preserves_magnitude\
  \ (binary : List Nat)\n  (h : binary.all (fun x => x = 0 ∨ x = 1))\n  (h' : binary.length\
  \ ≥ 2)\n  (h'' : binary.head? = some 0) :\n  positive_to_negative (positive_to_negative\
  \ binary) = binary := sorry\n\n/--\ninfo: [0, 0, 0, 0]\n-/\n#guard_msgs in\n#eval\
  \ positive_to_negative [0, 0, 0, 0]\n\n/--\ninfo: [1, 1, 1, 0]\n-/\n#guard_msgs\
  \ in\n#eval positive_to_negative [0, 0, 1, 0]\n\n/--\ninfo: [1, 1, 0, 1]\n-/\n#guard_msgs\
  \ in\n#eval positive_to_negative [0, 0, 1, 1]\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
