"vc-description": "> [Run-length encoding](https://en.wikipedia.org/w/index.php?title=Run-length_encoding)\
  \ (RLE) is a very simple form of data compression in which runs of data (that is,\
  \ sequences in which the same data value occurs in many consecutive data elements)\
  \ are stored as a single data value and count, rather than as the original run.\
  \ Wikipedia\n\n## Task\n\nYour task is to write such a run-length encoding. For\
  \ a given string, return a list (or array) of pairs (or arrays) \n[\n (i1, s1),\n\
  \ (i2, s2),\n …,\n (in, sn)\n], such that one can reconstruct the original string\
  \ by replicating the character sx ix times and concatening all those strings. Your\
  \ run-length encoding should be minimal, ie. for all i the values si and si+1 should\
  \ differ.\n\n## Examples\n\nAs the article states, RLE is a _very_ simple form of\
  \ data compression. It's only suitable for runs of data, as one can see in the following\
  \ example:\n\n```python\nrun_length_encoding(\"hello world!\")\n //=>      [[1,'h'],\
  \ [1,'e'], [2,'l'], [1,'o'], [1,' '], [1,'w'], [1,'o'], [1,'r'], [1,'l'], [1,'d'],\
  \ [1,'!']]\n```\n\nIt's very effective if the same data value occurs in many consecutive\
  \ data elements:\n```python\nrun_length_encoding(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbb\"\
  )\n# => [[34,'a'], [3,'b']]\n```"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def join (chars : List (Nat × String)) : String := sorry\n\ndef\
  \ run_length_encoding (s : String) : List (Nat × String) := sorry\n"
"vc-theorems": "theorem rle_valid_pairs (s : String) :\n  ∀ pair ∈ run_length_encoding\
  \ s,\n  ∃ (n : Nat) (c : String), pair = (n, c) := sorry\n\n\ntheorem rle_positive_counts\
  \ (s : String) :\n  ∀ (n : Nat) (c : String), (n, c) ∈ run_length_encoding s → n\
  \ > 0 := sorry \n\n\ntheorem rle_adjacent_chars_differ (s : String) :\n  ∀ (n₁ n₂\
  \ : Nat) (c₁ c₂ : String),\n  let encoded := run_length_encoding s\n  let pairs\
  \ := List.zip encoded (encoded.tail)\n  ((n₁, c₁), (n₂, c₂)) ∈ pairs → c₁ ≠ c₂ :=\
  \ sorry\n\n\ntheorem rle_decode_matches_input (s : String) :\n  join (run_length_encoding\
  \ s) = s := sorry\n\n\ntheorem rle_empty_string :\n  run_length_encoding \"\" =\
  \ [] := sorry\n\n/--\ninfo: []\n-/\n#guard_msgs in\n#eval run_length_encoding \"\
  \"\n\n/--\ninfo: [[1, 'a'], [1, 'b'], [1, 'c']]\n-/\n#guard_msgs in\n#eval run_length_encoding\
  \ \"abc\"\n\n/--\ninfo: [[34, 'a'], [3, 'b']]\n-/\n#guard_msgs in\n#eval run_length_encoding\
  \ \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbb\"\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
