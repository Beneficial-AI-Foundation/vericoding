"vc-description": "Suppose you have a random list of people standing in a queue. Each\
  \ person is described by a pair of integers (h, k), where h is the height of the\
  \ person and k is the number of people in front of this person who have a height\
  \ greater than or equal to h. Write an algorithm to reconstruct the queue.\n\n\n\
  Note:\nThe number of people is less than 1,100.\n\n\n\n\nExample\n\nInput:\n[[7,0],\
  \ [4,4], [7,1], [5,0], [6,1], [5,2]]\n\nOutput:\n[[5,0], [7,0], [5,2], [6,1], [4,4],\
  \ [7,1]]"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def reconstruct_queue (people : List (Nat × Nat)) : List (Nat ×\
  \ Nat) := sorry \n\ntheorem reconstruct_queue_maintains_length \n  (people : List\
  \ (Nat × Nat)) : \n  List.length (reconstruct_queue people) = List.length people\
  \ := sorry\n\n/-- For any two heights in the input and output list, if we count\
  \ their occurrences,\n    they should be equal -/"
"vc-theorems": "theorem reconstruct_queue_maintains_elements\n  (people : List (Nat\
  \ × Nat)) (h : Nat) :\n  List.countP (fun p => p.1 = h) (reconstruct_queue people)\
  \ = \n  List.countP (fun p => p.1 = h) people := sorry\n\n\ntheorem reconstruct_queue_height_bounds\n\
  \  (people : List (Nat × Nat)) :\n  ∀ p ∈ people, 1 ≤ p.fst ∧ p.fst ≤ 100 := sorry\n\
  \n\ntheorem reconstruct_queue_count_bounds\n  (people : List (Nat × Nat)) :\n  ∀\
  \ p ∈ people, 0 ≤ p.snd ∧ p.snd ≤ 20 := sorry\n\n\ntheorem reconstruct_queue_size_bounds\n\
  \  (people : List (Nat × Nat)) :\n  1 ≤ List.length people ∧ List.length people\
  \ ≤ 20 := sorry"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded"
