"vc-description": "Given a natural number n, we want to know in how many ways we may\
  \ express these numbers as product of other numbers.\n\nFor example the number\n\
  ```python\n 18 = 2 x 9 = 3 x 6 = 2 x 3 x 3 # (we do not consider the product 18\
  \ x 1), (3 ways) \n```\n\nSee this example a bit more complicated,\n```python\n\
  60 = 2 x 30 = 3 x 20 =  4 x 15 = 5 x 12 = 6 x 10 = 2 x 2 x 15 = 2 x 3 x 10 = 2 x\
  \ 5 x 6 =  3 x 4 x 5 = 2 x 2 x 3 x 5 (10 ways)\n```\nWe need the function ```prod_int_part()```,\
  \ that receives a number n, and ouputs the amount of total different products with\
  \ all the products of max length sorted in this way:\n\n1) each product will be\
  \ expressed in a list of its factors in incresing order from left to right\n\n2)\
  \ if there is more than one list-product, these lists should be ordered by the value\
  \ of the first term, if two lists have the same term equal thay should be ordered\
  \ by the value of the second term.\n\nLet's see some cases:\n```python\nprod_int_part(18)\
  \ == [3, [2, 3, 3]]\n\nprod_int_part(60) == [10, [2, 2, 3, 5]\n```\n\nIf we have\
  \ only one list-product with the maximum length, there is no use to have it with\
  \ two nested braces, so the result will be like this case:\n```python\nprod_int_part(54)\
  \ == [6, [2, 3, 3, 3]]\n```\n\nNow, let's see examples when ```n``` cannot be partitioned:\n\
  ```python\nprod_int_part(37) == [0, []]\n\nprod_int_part(61) == [0, []]\n```\nEnjoy\
  \ it!!"
"vc-preamble": "import Imports.AllImports\n\ndef prod_int_part (n: Nat) (min: Nat\
  \ := 2) : Nat × List Nat := sorry\n\ntheorem prod_int_part_output_structure (n:\
  \ Nat) (h: n ≥ 2) : \n  let result := prod_int_part n\n  result.1 ≥ 0 ∧ result.2.all\
  \ (λ x => x ≥ 2) := sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def isPrime (n: Nat) : Bool := sorry\n\ntheorem prime_numbers_return_empty\
  \ (n: Nat) (h: n ≥ 2) :\n  isPrime n → prod_int_part n = (0, []) := sorry\n"
"vc-theorems": "theorem factors_multiply_to_input (n: Nat) (h: n ≥ 2) :\n  let result\
  \ := prod_int_part n\n  result.2 ≠ [] → result.2.foldl (·*·) 1 = n := sorry\n\n\n\
  theorem factors_are_ordered (n: Nat) (h: n ≥ 2) :\n  let result := prod_int_part\
  \ n\n  result.2.length > 1 → \n  ∀ i, i < result.2.length - 1 → \n  result.2[i]!\
  \ ≤ result.2[i+1]! := sorry\n\n\ntheorem min_parameter_respects_boundary (n min:\
  \ Nat) (h1: n ≥ 2) (h2: min ≥ 2) :\n  let result := prod_int_part n min\n  result.2.all\
  \ (λ x => x ≥ min) := sorry\n\n/--\ninfo: [3, [2, 3, 3]]\n-/\n#guard_msgs in\n#eval\
  \ prod_int_part 18\n\n/--\ninfo: [10, [2, 2, 3, 5]]\n-/\n#guard_msgs in\n#eval prod_int_part\
  \ 60\n\n/--\ninfo: [6, [2, 3, 3, 3]]\n-/\n#guard_msgs in\n#eval prod_int_part 54\n\
  \n/--\ninfo: [0, []]\n-/\n#guard_msgs in\n#eval prod_int_part 37\n\n/--\ninfo: [0,\
  \ []]\n-/\n#guard_msgs in\n#eval prod_int_part 61\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
