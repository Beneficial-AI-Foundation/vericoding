"vc-description": "You have to create a method \"compoundArray\" which should take\
  \ as input two int arrays of different length and return one int array with numbers\
  \ of both arrays shuffled one by one. \n```Example: \nInput - {1,2,3,4,5,6} and\
  \ {9,8,7,6} \nOutput - {1,9,2,8,3,7,4,6,5,6}\n```"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def compound_array {α : Type} [DecidableEq α] (a b : List α) :\
  \ List α := sorry\n\ntheorem compound_array_length {α : Type} [DecidableEq α] (a\
  \ b : List α) :\n  (compound_array a b).length = a.length + b.length := sorry\n"
"vc-theorems": "theorem compound_array_preserves_elements {α : Type} [DecidableEq\
  \ α] (a b : List α) (x : α) :\n  (x ∈ a ∨ x ∈ b) ↔ x ∈ compound_array a b := sorry\n\
  \n\ntheorem compound_array_maintains_relative_order {α : Type} [DecidableEq α] (a\
  \ b : List α) :\n  ∀ i j x y, i < j →\n    ((x ∈ a ∧ y ∈ a) → \n      (List.get\
  \ (compound_array a b) i = x ∧ List.get (compound_array a b) j = y) → \n      ∃\
  \ i' j', List.get a i' = x ∧ List.get a j' = y ∧ i' < j') ∧\n    ((x ∈ b ∧ y ∈ b)\
  \ → \n      (List.get (compound_array a b) i = x ∧ List.get (compound_array a b)\
  \ j = y) → \n      ∃ i' j', List.get b i' = x ∧ List.get b j' = y ∧ i' < j') :=\
  \ sorry\n\ntheorem compound_array_empty_list {α : Type} [DecidableEq α] (a : List\
  \ α) :\n  compound_array a [] = a ∧ \n  compound_array [] a = a := sorry\n\n\ntheorem\
  \ compound_array_empty_both {α : Type} [DecidableEq α] :\n  compound_array ([] :\
  \ List α) [] = [] := sorry\n\n/--\ninfo: [1, 9, 2, 8, 3, 7, 4, 6, 5, 6]\n-/\n#guard_msgs\
  \ in\n#eval compound_array [1, 2, 3, 4, 5, 6] [9, 8, 7, 6]\n\n/--\ninfo: [11, 21,\
  \ 12, 22, 23, 24]\n-/\n#guard_msgs in\n#eval compound_array [11, 12] [21, 22, 23,\
  \ 24]\n\n/--\ninfo: []\n-/\n#guard_msgs in\n#eval compound_array [] []\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
