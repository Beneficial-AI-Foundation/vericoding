vc-description: |-
  The Ulam sequence `U` is defined by `u0 = u`, `u1 = v`, with the general term `uN` for `N > 2` given by the least integer expressible uniquely as the sum of two distinct earlier terms. In other words, the next number is always the smallest, unique sum of any two previous terms.

  Complete the function that creates an Ulam Sequence starting with the given `u0` and `u1`, and contains `n` terms.

  ## Example

  The first 10 terms of the sequence `U(u0=1, u1=2)` are: 1, 2, 3, 4, 6, 8, 11, 13, 16, 18.

  Let's see it in details:
  * The first term after the initial 1, 2 is obviously 3, because 1 + 2 = 3
  * The next term is 1 + 3 = 4 (we don't have to worry about 4 = 2 + 2 since it is a sum of a *single term* instead of *distinct terms*)
  * 5 is not a member of the sequence since it is representable in two ways: 1 + 4 and 2 + 3
  * 6 is a memeber, as 2 + 4 = 6
  * etc.


  Description Reference: http://mathworld.wolfram.com/UlamSequence.html

  ---

  Performance version: https://www.codewars.com/kata/ulam-sequences-performance-edition
vc-preamble: |-
  import Imports.AllImports
vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>
vc-definitions: |
  def ulamSequence (u0 u1 n : Nat) : List Nat := sorry

  theorem ulam_sequence_length (u0 u1 n : Nat) (h1: u0 > 0) (h2: u1 > u0) :
    List.length (ulamSequence u0 u1 n) = n := sorry
vc-theorems: |-
  theorem ulam_sequence_first_elements (u0 u1 n : Nat) (h1: u0 > 0) (h2: u1 > u0) (h3: n ≥ 3) :
    ulamSequence u0 u1 n ≠ [] ∧
    (ulamSequence u0 u1 n).get ⟨0, by {rw [ulam_sequence_length u0 u1 n h1 h2]; sorry}⟩ = u0 ∧
    (ulamSequence u0 u1 n).get ⟨1, by {rw [ulam_sequence_length u0 u1 n h1 h2]; sorry}⟩ = u1 := sorry


  theorem ulam_sequence_strictly_increasing (u0 u1 n : Nat) (h1: u0 > 0) (h2: u1 > u0) (h3: n ≥ 3) :
    ∀ i : Fin n, i.val + 1 < n →
      let seq := ulamSequence u0 u1 n
      let h_length := ulam_sequence_length u0 u1 n h1 h2
      (seq.get ⟨i.val, by {rw [h_length]; exact i.isLt}⟩) <
      (seq.get ⟨i.val + 1, by {rw [h_length]; sorry}⟩) := sorry


  theorem ulam_sequence_third_element (u0 u1 n : Nat) (h1: u0 > 0) (h2: u1 > u0) (h3: n ≥ 3) :
    (ulamSequence u0 u1 n).get ⟨2, by {rw [ulam_sequence_length u0 u1 n h1 h2]; sorry}⟩ = u0 + u1 := sorry


  theorem ulam_sequence_unique_sum (u0 u1 n : Nat) (h1: u0 > 0) (h2: u1 > u0) (h3: n ≥ 3) :
    ∀ i : Fin n, 2 ≤ i.val → 
    ∃ (p : Nat × Nat), (∀ q : Nat × Nat,
      let seq := ulamSequence u0 u1 n
      let h_length := ulam_sequence_length u0 u1 n h1 h2
      p.1 < p.2 ∧ 
      p.2 < (seq.get ⟨i.val, by {rw [h_length]; exact i.isLt}⟩) ∧
      p.1 ∈ (List.take i.val seq) ∧ 
      p.2 ∈ (List.take i.val seq) ∧
      p.1 + p.2 = (seq.get ⟨i.val, by {rw [h_length]; exact i.isLt}⟩) ∧
      (q.1 < q.2 ∧ 
       q.2 < (seq.get ⟨i.val, by {rw [h_length]; exact i.isLt}⟩) ∧
       q.1 ∈ (List.take i.val seq) ∧ 
       q.2 ∈ (List.take i.val seq) ∧
       q.1 + q.2 = (seq.get ⟨i.val, by {rw [h_length]; exact i.isLt}⟩) → 
       q = p)) := sorry
vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: guarded
