"vc-description": "The Ulam sequence `U` is defined by `u0 = u`, `u1 = v`, with the\
  \ general term `uN` for `N > 2` given by the least integer expressible uniquely\
  \ as the sum of two distinct earlier terms. In other words, the next number is always\
  \ the smallest, unique sum of any two previous terms.\n\nComplete the function that\
  \ creates an Ulam Sequence starting with the given `u0` and `u1`, and contains `n`\
  \ terms.\n\n## Example\n\nThe first 10 terms of the sequence `U(u0=1, u1=2)` are:\
  \ 1, 2, 3, 4, 6, 8, 11, 13, 16, 18.\n\nLet's see it in details:\n* The first term\
  \ after the initial 1, 2 is obviously 3, because 1 + 2 = 3\n* The next term is 1\
  \ + 3 = 4 (we don't have to worry about 4 = 2 + 2 since it is a sum of a *single\
  \ term* instead of *distinct terms*)\n* 5 is not a member of the sequence since\
  \ it is representable in two ways: 1 + 4 and 2 + 3\n* 6 is a memeber, as 2 + 4 =\
  \ 6\n* etc.\n\n\nDescription Reference: http://mathworld.wolfram.com/UlamSequence.html\n\
  \n---\n\nPerformance version: https://www.codewars.com/kata/ulam-sequences-performance-edition"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def ulamSequence (u0 u1 n : Nat) : List Nat := sorry\n\ntheorem\
  \ ulam_sequence_length (u0 u1 n : Nat) (h1: u0 > 0) (h2: u1 > u0) :\n  List.length\
  \ (ulamSequence u0 u1 n) = n := sorry\n"
"vc-theorems": "theorem ulam_sequence_first_elements (u0 u1 n : Nat) (h1: u0 > 0)\
  \ (h2: u1 > u0) (h3: n ≥ 3) :\n  ulamSequence u0 u1 n ≠ [] ∧\n  (ulamSequence u0\
  \ u1 n).get ⟨0, by {rw [ulam_sequence_length u0 u1 n h1 h2]; sorry}⟩ = u0 ∧\n  (ulamSequence\
  \ u0 u1 n).get ⟨1, by {rw [ulam_sequence_length u0 u1 n h1 h2]; sorry}⟩ = u1 :=\
  \ sorry\n\n\ntheorem ulam_sequence_strictly_increasing (u0 u1 n : Nat) (h1: u0 >\
  \ 0) (h2: u1 > u0) (h3: n ≥ 3) :\n  ∀ i : Fin n, i.val + 1 < n →\n    let seq :=\
  \ ulamSequence u0 u1 n\n    let h_length := ulam_sequence_length u0 u1 n h1 h2\n\
  \    (seq.get ⟨i.val, by {rw [h_length]; exact i.isLt}⟩) <\n    (seq.get ⟨i.val\
  \ + 1, by {rw [h_length]; sorry}⟩) := sorry\n\n\ntheorem ulam_sequence_third_element\
  \ (u0 u1 n : Nat) (h1: u0 > 0) (h2: u1 > u0) (h3: n ≥ 3) :\n  (ulamSequence u0 u1\
  \ n).get ⟨2, by {rw [ulam_sequence_length u0 u1 n h1 h2]; sorry}⟩ = u0 + u1 := sorry\n\
  \n\ntheorem ulam_sequence_unique_sum (u0 u1 n : Nat) (h1: u0 > 0) (h2: u1 > u0)\
  \ (h3: n ≥ 3) :\n  ∀ i : Fin n, 2 ≤ i.val → \n  ∃ (p : Nat × Nat), (∀ q : Nat ×\
  \ Nat,\n    let seq := ulamSequence u0 u1 n\n    let h_length := ulam_sequence_length\
  \ u0 u1 n h1 h2\n    p.1 < p.2 ∧ \n    p.2 < (seq.get ⟨i.val, by {rw [h_length];\
  \ exact i.isLt}⟩) ∧\n    p.1 ∈ (List.take i.val seq) ∧ \n    p.2 ∈ (List.take i.val\
  \ seq) ∧\n    p.1 + p.2 = (seq.get ⟨i.val, by {rw [h_length]; exact i.isLt}⟩) ∧\n\
  \    (q.1 < q.2 ∧ \n     q.2 < (seq.get ⟨i.val, by {rw [h_length]; exact i.isLt}⟩)\
  \ ∧\n     q.1 ∈ (List.take i.val seq) ∧ \n     q.2 ∈ (List.take i.val seq) ∧\n \
  \    q.1 + q.2 = (seq.get ⟨i.val, by {rw [h_length]; exact i.isLt}⟩) → \n     q\
  \ = p)) := sorry"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
