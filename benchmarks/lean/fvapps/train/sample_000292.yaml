"vc-description": "Given a m x n grid. Each cell of the grid has a sign pointing to\
  \ the next cell you should visit if you are currently in this cell. The sign of\
  \ grid[i][j] can be:\n\n1 which means go to the cell to the right. (i.e go from\
  \ grid[i][j] to grid[i][j + 1])\n2 which means go to the cell to the left. (i.e\
  \ go from grid[i][j] to grid[i][j - 1])\n3 which means go to the lower cell. (i.e\
  \ go from grid[i][j] to grid[i + 1][j])\n4 which means go to the upper cell. (i.e\
  \ go from grid[i][j] to grid[i - 1][j])\n\nNotice that there could be some invalid\
  \ signs on the cells of the grid which points outside the grid.\nYou will initially\
  \ start at the upper left cell (0,0). A valid path in the grid is a path which starts\
  \ from the upper left cell (0,0) and ends at the bottom-right cell (m - 1, n - 1)\
  \ following the signs on the grid. The valid path doesn't have to be the shortest.\n\
  You can modify the sign on a cell with cost = 1. You can modify the sign on a cell\
  \ one time only.\nReturn the minimum cost to make the grid have at least one valid\
  \ path.\n \nExample 1:\n\nInput: grid = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]\n\
  Output: 3\nExplanation: You will start at point (0, 0).\nThe path to (3, 3) is as\
  \ follows. (0, 0) --> (0, 1) --> (0, 2) --> (0, 3) change the arrow to down with\
  \ cost = 1 --> (1, 3) --> (1, 2) --> (1, 1) --> (1, 0) change the arrow to down\
  \ with cost = 1 --> (2, 0) --> (2, 1) --> (2, 2) --> (2, 3) change the arrow to\
  \ down with cost = 1 --> (3, 3)\nThe total cost = 3.\n\nExample 2:\n\nInput: grid\
  \ = [[1,1,3],[3,2,2],[1,1,4]]\nOutput: 0\nExplanation: You can follow the path from\
  \ (0, 0) to (2, 2).\n\nExample 3:\n\nInput: grid = [[1,2],[4,3]]\nOutput: 1\n\n\
  Example 4:\nInput: grid = [[2,2,2],[2,2,2]]\nOutput: 3\n\nExample 5:\nInput: grid\
  \ = [[4]]\nOutput: 0\n\n \nConstraints:\n\nm == grid.length\nn == grid[i].length\n\
  1 <= m, n <= 100"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def Grid := List (List Nat)\n\ndef min_cost_to_valid_path (grid:\
  \ Grid) : Int :=\n  sorry\n"
"vc-theorems": "theorem output_constraints (grid: Grid) :\n  let result := min_cost_to_valid_path\
  \ grid\n  result = -1 ∨ result ≥ 0 :=\nsorry\n\n\ntheorem single_cell_case (grid:\
  \ Grid) :\n  grid.length = 1 → \n  (grid.head?.map List.head?).isSome →\n  min_cost_to_valid_path\
  \ grid = 0 :=\nsorry\n\n\ntheorem size_bound (grid: Grid) (h: grid.length ≥ 2) :\n\
  \  let result := min_cost_to_valid_path grid\n  let n := grid.length\n  result =\
  \ -1 ∨ result < n * n :=\nsorry\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval min_cost_to_valid_path\
  \ [[1, 1, 1, 1], [2, 2, 2, 2], [1, 1, 1, 1], [2, 2, 2, 2]]\n\n/--\ninfo: 0\n-/\n\
  #guard_msgs in\n#eval min_cost_to_valid_path [[1, 1, 3], [3, 2, 2], [1, 1, 4]]\n\
  \n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval min_cost_to_valid_path [[1, 2], [4, 3]]\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
