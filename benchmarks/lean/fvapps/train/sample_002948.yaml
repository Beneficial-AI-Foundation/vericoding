"vc-description": "Johnny is a boy who likes to open and close lockers. He loves it\
  \ so much that one day, when school was out, he snuck in just to play with the lockers.\n\
  \nEach locker can either be open or closed. If a locker is closed when Johnny gets\
  \ to it, he opens it, and vice versa.\n\nThe lockers are numbered sequentially,\
  \ starting at 1.\n\nStarting at the first locker, Johnny runs down the row, opening\
  \ each locker.\n\nThen he runs all the way back to the beginning and runs down the\
  \ row again, this time skipping to every other locker. (2,4,6, etc)\n\nThen he runs\
  \ all the way back and runs through again, this time skipping two lockers for every\
  \ locker he opens or closes. (3,6,9, etc)\n\nHe continues this until he has finished\
  \ running past the last locker (i.e. when the number of lockers he skips is greater\
  \ than the number of lockers he has).\n\n------\n\nThe equation could be stated\
  \ as follows: \n\n> Johnny runs down the row of lockers `n` times, starting at the\
  \ first locker each run and skipping `i` lockers as he runs, where `n` is the number\
  \ of lockers there are in total and `i` is the current run.\n    \nThe goal of this\
  \ kata is to determine which lockers are open at the end of Johnny's running. \n\
  \nThe program accepts an integer giving the total number of lockers, and should\
  \ output an array filled with the locker numbers of those which are open at the\
  \ end of his run."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def lockerRun (n : Nat) : List Nat := sorry\n\ntheorem locker_run_returns_positive\
  \ (n : Nat) :\n  ∀ x ∈ lockerRun n, x > 0 := sorry\n"
"vc-theorems": "theorem locker_run_returns_perfect_squares (n : Nat) :\n  ∀ x ∈ lockerRun\
  \ n, ∃ k : Nat, k * k = x := sorry\n\n\ntheorem locker_run_bounded_by_input (n :\
  \ Nat) :\n  ∀ x ∈ lockerRun n, x ≤ n := sorry\n\n\ntheorem locker_run_ascending\
  \ (n : Nat) (i j : Nat) (h1 : i < j) \n    (h2 : i < (lockerRun n).length) (h3 :\
  \ j < (lockerRun n).length) :\n  (lockerRun n)[i]'h2 ≤ (lockerRun n)[j]'h3 := sorry\n\
  \n\ntheorem locker_run_length (n : Nat) :\n  ∃ k : Nat, k * k ≤ n ∧ (k + 1) * (k\
  \ + 1) > n ∧ (lockerRun n).length = k := sorry\n\n\ntheorem locker_run_monotone\
  \ (n₁ n₂ : Nat) : \n  (lockerRun n₁).length ≤ (lockerRun (n₁ + n₂)).length := sorry\n\
  \n\ntheorem locker_run_subset (n₁ n₂ : Nat) :\n  ∀ x ∈ lockerRun n₁, x ∈ lockerRun\
  \ (n₁ + n₂) := sorry\n\n/--\ninfo: [1]\n-/\n#guard_msgs in\n#eval locker_run 1\n\
  \n/--\ninfo: [1, 4]\n-/\n#guard_msgs in\n#eval locker_run 5\n\n/--\ninfo: [1, 4,\
  \ 9]\n-/\n#guard_msgs in\n#eval locker_run 10\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
