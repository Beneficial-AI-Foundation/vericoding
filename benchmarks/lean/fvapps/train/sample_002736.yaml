"vc-description": "JavaScript provides a built-in parseInt method.\n\nIt can be used\
  \ like this:\n\n- `parseInt(\"10\")` returns `10`\n- `parseInt(\"10 apples\")` also\
  \ returns `10`\n\nWe would like it to return `\"NaN\"` (as a string) for the second\
  \ case because the input string is not a valid number.\n\nYou are asked to write\
  \ a `myParseInt` method with the following rules:\n\n- It should make the conversion\
  \ if the given string only contains a single integer value (and possibly spaces\
  \ - including tabs, line feeds... - at both ends)\n- For all other strings (including\
  \ the ones representing float values), it should return NaN\n- It should assume\
  \ that all numbers are not signed and written in base 10"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def my_parse_int (s : String) : String ⊕ Int := sorry\n\ntheorem\
  \ valid_integer_string (s : String) (h : ∀ c ∈ s.data, c.isDigit) : \n  my_parse_int\
  \ s = Sum.inr (String.toInt! s) := sorry\n"
"vc-theorems": "theorem padded_integer_string (s : String) (n : Int) \n  (h : String.toInt!\
  \ (String.trim s) = n) :\n  my_parse_int s = Sum.inr n := sorry\n\n\ntheorem invalid_string\
  \ (s : String) \n  (h : ∃ c ∈ s.data, ¬c.isDigit ∧ ¬c.isWhitespace) :\n  my_parse_int\
  \ s = Sum.inl \"NaN\" := sorry\n\n\ntheorem arbitrary_string (s : String) :\n  (my_parse_int\
  \ s = Sum.inl \"NaN\") ∨ \n  (my_parse_int s = Sum.inr (String.toInt! (String.trim\
  \ s))) := sorry\n\n/--\ninfo: 9\n-/\n#guard_msgs in\n#eval my_parse_int \"9\"\n\n\
  /--\ninfo: 9\n-/\n#guard_msgs in\n#eval my_parse_int \"  9  \"\n\n/--\ninfo: 'NaN'\n\
  -/\n#guard_msgs in\n#eval my_parse_int \"5 friends\"\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
