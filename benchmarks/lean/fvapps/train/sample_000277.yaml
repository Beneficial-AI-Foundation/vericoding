"vc-description": "You have an initial power P, an initial score of 0 points, and\
  \ a bag of tokens.\nEach token can be used at most once, has a value token[i], and\
  \ has potentially two ways to use it.\n\nIf we have at least token[i] power, we\
  \ may play the token face up, losing token[i] power, and gaining 1 point.\nIf we\
  \ have at least 1 point, we may play the token face down, gaining token[i] power,\
  \ and losing 1 point.\n\nReturn the largest number of points we can have after playing\
  \ any number of tokens.\n \n\n\n\nExample 1:\nInput: tokens = [100], P = 50\nOutput:\
  \ 0\n\n\nExample 2:\nInput: tokens = [100,200], P = 150\nOutput: 1\n\n\nExample\
  \ 3:\nInput: tokens = [100,200,300,400], P = 200\nOutput: 2\n\n \nNote:\n\ntokens.length\
  \ <= 1000\n0 <= tokens[i] < 10000\n0 <= P < 10000"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def bagOfTokensScore (tokens: List Nat) (power: Nat) : Nat :=\n\
  \  sorry\n"
"vc-theorems": "theorem score_bounds {tokens: List Nat} {power: Nat} :\n  let score\
  \ := bagOfTokensScore tokens power\n  score ≤ tokens.length ∧ score ≥ 0 :=\n  sorry\n\
  \n\ntheorem sorted_input_permutation {tokens s_tokens: List Nat} {power: Nat} :\n\
  \  s_tokens.Perm tokens →\n  bagOfTokensScore tokens power = bagOfTokensScore s_tokens\
  \ power :=\n  sorry\n\n\ntheorem empty_tokens {tokens: List Nat} {power: Nat} :\n\
  \  tokens = [] → bagOfTokensScore tokens power = 0 :=\n  sorry\n\n\ntheorem single_token\
  \ {token: Nat} {power: Nat} : \n  let score := bagOfTokensScore [token] power\n\
  \  score ≤ 1 ∧ score ≥ 0 ∧ score = (if token ≤ power then 1 else 0) :=\n  sorry\n\
  \n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval bag_of_tokens_score [100] 50\n\n/--\n\
  info: 1\n-/\n#guard_msgs in\n#eval bag_of_tokens_score [100, 200] 150\n\n/--\ninfo:\
  \ 2\n-/\n#guard_msgs in\n#eval bag_of_tokens_score [100, 200, 300, 400] 200\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
