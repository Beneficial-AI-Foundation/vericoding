"vc-description": "Devu loves to play with binary strings a lot. One day he borrowed\
  \ a binary string s of size n from his friend Churu. Before starting to play with\
  \ it, he wants to make sure that string does not contain more than  k consecutive\
  \ equal characters. For achieving that, only kind of operation he is allowed to\
  \ perform is to flip any ith character of the string. \n\nAs Devu is always in hurry\
  \ to meet his girlfriend, he wants you to help him in finding out the minimum number\
  \ of operations he will need. Also he wants you to print one of the possible modified\
  \ string too.\n\n-----Input-----\n- First line of input contains an integer T denoting\
  \ the number of test cases. \n- For each test case, there are two lines. \n- First\
  \ line contains two space separated integers n, k as defined in the problem. \n\
  - Next line contains string s of size n.\n\n-----Output-----\n- For each test case,\
  \ print two lines.\n- First line should contain an integer corresponding to minimum\
  \ number of operations Devu needs.\n- In second line, print one of the possible\
  \ modified strings.\n\n-----Constraints-----\nSubtask #1: 20 points\n- 1 ≤ T ≤ 100,\
  \ 1 ≤ n ≤ 20, 1 ≤ k ≤ n\n\nSubtask #2: 35 points\n- 1 ≤ T ≤ 102, 1 ≤ n ≤ 103, 1\
  \ ≤ k ≤ n\n\nSubtask #3: 45 points\n- 1 ≤ T ≤ 105, 1 ≤ n ≤ 105, 1 ≤ k ≤ n\n- Sum\
  \ of n over all the test cases is ≤ 106 \n\n-----Example-----\nInput:\n3\n2 1\n\
  11\n2 2\n11\n4 1\n1001\n\nOutput:\n1\n10\n0\n11\n2\n1010\n\n-----Explanation-----\n\
  Example case 1: As 1 is occurring twice consecutively, we can convert 11 to 10 in\
  \ a single operation.\nExample case 2: You don't need to modify the string as it\
  \ does not have more than 2 equal consecutive character.\nExample case 3: As 0 is\
  \ occurring twice consecutively, we can convert 1001 to 1010 in a two operations\
  \ (Flip third and fourth character)."
"vc-preamble": "import Imports.AllImports\n\ndef solve_binary_flips (n k : Nat) (s\
  \ : String) : Nat × String := sorry\n\ndef is_alternating (s : String) : Bool :=\
  \ sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def check_consecutive (s : String) (k : Nat) : Bool := sorry\n\n\
  theorem binary_flips_basic_properties {n k : Nat} {s : String} \n  (h1 : n > 0)\
  \ (h2 : k > 0) (h3 : s.length = n) (h4 : ∀ c ∈ s.data, c = '0' ∨ c = '1') :\n  let\
  \ (flips, result) := solve_binary_flips n k s\n  -- Output type properties\n  flips\
  \ ≥ 0 ∧  \n  result.length = n ∧\n  (∀ c ∈ result.data, c = '0' ∨ c = '1') := sorry\n"
"vc-theorems": "theorem k_one_alternating {n : Nat} {s : String}\n  (h1 : n > 0) (h2\
  \ : s.length = n) (h3 : ∀ c ∈ s.data, c = '0' ∨ c = '1') :\n  let (_, result) :=\
  \ solve_binary_flips n 1 s\n  is_alternating result = true := sorry\n\n\ntheorem\
  \ k_gt_one_consecutive {n k : Nat} {s : String}\n  (h1 : n > 0) (h2 : k > 1) (h3\
  \ : s.length = n) (h4 : ∀ c ∈ s.data, c = '0' ∨ c = '1') :\n  let (_, result) :=\
  \ solve_binary_flips n k s  \n  check_consecutive result k = true := sorry\n\n\n\
  theorem k_equals_n_no_flips {n : Nat} {s : String}\n  (h1 : n > 0) (h2 : s.length\
  \ = n) (h3 : ∀ c ∈ s.data, c = '0' ∨ c = '1') :\n  let (flips, result) := solve_binary_flips\
  \ n n s\n  flips = 0 ∧ result = s := sorry"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded"
