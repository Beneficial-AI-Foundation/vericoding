"vc-description": "Bike loves looking for the second maximum element in the sequence.\
  \ The second maximum element in the sequence of distinct numbers x_1, x_2, ...,\
  \ x_{k} (k > 1) is such maximum element x_{j}, that the following inequality holds:\
  \ $x_{j} \\neq \\operatorname{max}_{i = 1}^{k} x_{i}$.\n\nThe lucky number of the\
  \ sequence of distinct positive integers x_1, x_2, ..., x_{k} (k > 1) is the number\
  \ that is equal to the bitwise excluding OR of the maximum element of the sequence\
  \ and the second maximum element of the sequence.\n\nYou've got a sequence of distinct\
  \ positive integers s_1, s_2, ..., s_{n} (n > 1). Let's denote sequence s_{l}, s_{l}\
  \ + 1, ..., s_{r} as s[l..r] (1 ≤ l < r ≤ n). Your task is to find the maximum number\
  \ among all lucky numbers of sequences s[l..r].\n\nNote that as all numbers in sequence\
  \ s are distinct, all the given definitions make sence.\n\n\n-----Input-----\n\n\
  The first line contains integer n (1 < n ≤ 10^5). The second line contains n distinct\
  \ integers s_1, s_2, ..., s_{n} (1 ≤ s_{i} ≤ 10^9).\n\n\n-----Output-----\n\nPrint\
  \ a single integer — the maximum lucky number among all lucky numbers of sequences\
  \ s[l..r].\n\n\n-----Examples-----\nInput\n5\n5 2 1 4 3\n\nOutput\n7\n\nInput\n\
  5\n9 8 3 5 7\n\nOutput\n15\n\n\n\n-----Note-----\n\nFor the first sample you can\
  \ choose s[4..5] = {4, 3} and its lucky number is (4 xor 3) = 7. You can also choose\
  \ s[1..2].\n\nFor the second sample you must choose s[2..5] = {8, 3, 5, 7}."
"vc-preamble": "import Imports.AllImports\n\ndef find_max_lucky_number (nums : List\
  \ Nat) : Nat := sorry\n\ntheorem result_non_negative\n  (nums : List Nat)\n  (h\
  \ : nums.length > 0) :\n  find_max_lucky_number nums ≥ 0 := sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def isSorted (l : List Nat) : Prop :=\n  ∀ i j, i < l.length →\
  \ j < l.length → i < j → l[i]'sorry ≤ l[j]'sorry\n"
"vc-theorems": "theorem result_bounded_by_max_xor\n  (nums : List Nat)\n  (h : nums.length\
  \ > 0) :\n  ∀ max_xor : Nat,\n  (∀ i j, i < nums.length → j < nums.length → i <\
  \ j →\n    (nums[i]'sorry) ^^^ (nums[j]'sorry) ≤ max_xor) →\n  find_max_lucky_number\
  \ nums ≤ max_xor := sorry\n\n\ntheorem single_element_zero\n  (x : Nat) :\n  find_max_lucky_number\
  \ [x] = 0 := sorry\n\n\ntheorem reverse_invariant_unique\n  (nums : List Nat)\n\
  \  (h1 : nums.length ≥ 2)\n  (h2 : ∀ i j, i < nums.length → j < nums.length → i\
  \ ≠ j → nums[i]'sorry ≠ nums[j]'sorry) :\n  find_max_lucky_number nums = find_max_lucky_number\
  \ nums.reverse := sorry\n\n\ntheorem sorted_sequence_maintains_xor_pair\n  (nums\
  \ : List Nat)\n  (h : nums.length ≥ 2)\n  (sorted : List Nat)\n  (h_sorted : isSorted\
  \ sorted) :\n  let result := find_max_lucky_number sorted\n  ∃ i j, i < sorted.length\
  \ ∧ j < sorted.length ∧ i < j ∧\n    result = (sorted[i]'sorry) ^^^ (sorted[j]'sorry)\
  \ := sorry\n\n/--\ninfo: 7\n-/\n#guard_msgs in\n#eval find_max_lucky_number [5,\
  \ 2, 1, 4, 3]\n\n/--\ninfo: 15\n-/\n#guard_msgs in\n#eval find_max_lucky_number\
  \ [9, 8, 3, 5, 7]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval find_max_lucky_number\
  \ [11, 10, 8]\n"
"vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded"
