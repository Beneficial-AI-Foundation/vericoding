"vc-description": "Chef has created a special dividing machine that supports the below\
  \ given operations on an array of positive integers.\nThere are two operations that\
  \ Chef implemented on the machine.\nType 0 Operation\n\nUpdate(L,R):\n\tfor i =\
  \ L to R:\n\t\ta[i] = a[i] / LeastPrimeDivisor(a[i])\n\nType 1 Operation\n\nGet(L,R):\n\
  \tresult = 1\n\tfor i = L to R:\n\t\tresult = max(result, LeastPrimeDivisor(a[i]))\n\
  \treturn result;\n\nThe function LeastPrimeDivisor(x) finds the smallest prime divisor\
  \ of a number. If the number does not have any prime divisors, then it returns 1.\n\
  Chef has provided you an array of size N, on which you have to apply M operations\
  \ using the special machine. Each operation will be one of the above given two types.\
  \ Your task is to implement the special dividing machine operations designed by\
  \ Chef. Chef finds this task quite easy using his machine, do you too?\n\n-----Input-----\n\
  \nThe first line of the input contains an integer T denoting the number of test\
  \ cases. The description of T test cases follows. \nThe first line of each test\
  \ case contains two space-separated integers N, M, denoting the size of array A\
  \ and the number of queries correspondingly.\n\nThe second line of each test case\
  \ contains N space-separated integers A1, A2, ..., AN denoting the initial array\
  \ for dividing machine.\nEach of following M lines contain three space-separated\
  \ integers  type, L, R - the type of operation (0 - Update operation, 1 - Get operation),\
  \ and the arguments of function, respectively\n\n-----Output-----\nFor each test\
  \ case, output answer of each query of type 1 (Get query) separated by space. Each\
  \ test case from the same file should start from the new line.\n\n-----Constraints-----\n\
  - 1 ≤ T ≤ 100\n- 1 ≤ Ai ≤ 106\n- 1 ≤ L ≤ R ≤ N\n- 0 ≤ type ≤ 1\n-  Sum of M over\
  \ all test cases in a single test file does not exceed 106\n\n-----Subtasks-----\n\
  Subtask #1: (10 points) \n- 1 ≤ N, M ≤ 103\n\nSubtask #2: (25 points)\n- 1 ≤ N,\
  \ M ≤ 105\n-  Ai is a prime number. \n\nSubtask #3: (65 points)\n- 1 ≤ N, M ≤ 105\n\
  \n-----Example-----\nInput:\n2\n6 7\n2 5 8 10 3 44\n1 2 6\n0 2 3\n1 2 6\n0 4 6\n\
  1 1 6\n0 1 6\n1 4 6\n2 2\n1 3\n0 2 2\n1 1 2\nOutput:\n5 3 5 11\n1\n\n-----Explanation-----\n\
  Example case 1.The states of array A after each Update-operation:\nA: = [2 1 4 10\
  \ 3 44]\nA: = [2 1 4 5 1 22]\nA: = [1 1 2 1 1 11]"
"vc-preamble": "import Imports.AllImports\n\ndef leastPrimeDivisors (n : Nat) : List\
  \ Nat :=\n  sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def dividing_machine (n m : Nat) (arr : List Nat) (ops : List (List\
  \ Nat)) : List Nat :=\n  sorry\n"
"vc-theorems": "theorem least_prime_divisors_are_prime (n : Nat) : \n  (∀ p ∈ leastPrimeDivisors\
  \ n, p > 1) ∧ \n  (∀ p ∈ leastPrimeDivisors n, ∀ i : Nat, 2 ≤ i ∧ i * i ≤ p → p\
  \ % i ≠ 0) :=\nsorry\n\n\ntheorem dividing_machine_valid_result {n m : Nat} {arr\
  \ : List Nat} {ops : List (List Nat)}\n  (h_ops : ∀ op ∈ ops, op.length = 3 ∧ \n\
  \          (op.get! 0 < 2 ∧ 1 ≤ op.get! 1 ∧ op.get! 1 ≤ op.get! 2 ∧ op.get! 2 ≤\
  \ n)) :\n  (dividing_machine n m arr ops).length = (ops.filter (fun op => op.get!\
  \ 0 = 1)).length ∧ \n  ∀ x ∈ dividing_machine n m arr ops, x ≥ 1 :=\nsorry\n\n\n\
  theorem single_number_valid {x : Nat} (h : x ≥ 1) :\n  let result := dividing_machine\
  \ 1 1 [x] [[1,1,1]]\n  result.length = 1 ∧ result.get! 0 ≥ 1 :=\nsorry\n\n/--\n\
  info: [5, 3, 5, 11]\n-/\n#guard_msgs in\n#eval dividing_machine 6 7 [2, 5, 8, 10,\
  \ 3, 44] [[1, 2, 6], [0, 2, 3], [1, 2, 6], [0, 4, 6], [1, 1, 6], [0, 1, 6], [1,\
  \ 4, 6]]\n\n/--\ninfo: [1]\n-/\n#guard_msgs in\n#eval dividing_machine 2 2 [1, 3]\
  \ [[0, 2, 2], [1, 1, 2]]\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
