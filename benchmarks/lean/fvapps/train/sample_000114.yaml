"vc-description": "Let's call an array $a_1, a_2, \\dots, a_m$ of nonnegative integer\
  \ numbers good if $a_1 + a_2 + \\dots + a_m = 2\\cdot(a_1 \\oplus a_2 \\oplus \\\
  dots \\oplus a_m)$, where $\\oplus$ denotes the bitwise XOR operation.\n\nFor example,\
  \ array $[1, 2, 3, 6]$ is good, as $1 + 2 + 3 + 6 = 12 = 2\\cdot 6 = 2\\cdot (1\\\
  oplus 2 \\oplus 3 \\oplus 6)$. At the same time, array $[1, 2, 1, 3]$ isn't good,\
  \ as $1 + 2 + 1 + 3 = 7 \\neq 2\\cdot 1 = 2\\cdot(1\\oplus 2 \\oplus 1 \\oplus 3)$.\n\
  \nYou are given an array of length $n$: $a_1, a_2, \\dots, a_n$. Append at most\
  \ $3$ elements to it to make it good. Appended elements don't have to be different.\
  \ It can be shown that the solution always exists under the given constraints. If\
  \ there are different solutions, you are allowed to output any of them. Note that\
  \ you don't have to minimize the number of added elements!. So, if an array is good\
  \ already you are allowed to not append elements.\n\n\n-----Input-----\n\nEach test\
  \ contains multiple test cases. The first line contains the number of test cases\
  \ $t$ ($1 \\le t \\le 10\\,000$). The description of the test cases follows.\n\n\
  The first line of each test case contains a single integer $n$ $(1\\le n \\le 10^5)$ —\
  \ the size of the array.\n\nThe second line of each test case contains $n$ integers\
  \ $a_1, a_2, \\dots, a_n$ ($0\\le a_i \\le 10^9$) — the elements of the array.\n\
  \nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\
  \n\n-----Output-----\n\nFor each test case, output two lines.\n\nIn the first line,\
  \ output a single integer $s$ ($0\\le s\\le 3$) — the number of elements you want\
  \ to append.\n\nIn the second line, output $s$ integers $b_1, \\dots, b_s$ ($0\\\
  le b_i \\le 10^{18}$) — the elements you want to append to the array.\n\nIf there\
  \ are different solutions, you are allowed to output any of them.\n\n\n-----Example-----\n\
  Input\n3\n4\n1 2 3 6\n1\n8\n2\n1 1\n\nOutput\n0\n\n2\n4 4\n3\n2 6 2\n\n\n\n-----Note-----\n\
  \nIn the first test case of the example, the sum of all numbers is $12$, and their\
  \ $\\oplus$ is $6$, so the condition is already satisfied.\n\nIn the second test\
  \ case of the example, after adding $4, 4$, the array becomes $[8, 4, 4]$. The sum\
  \ of numbers in it is $16$, $\\oplus$ of numbers in it is $8$."
"vc-preamble": "import Imports.AllImports\n\ndef solve_xor_sum (n : Nat) (arr : List\
  \ Nat) : List Nat := sorry\n\ndef xor_fold (l : List Nat) : Nat :=\n  match l with\n\
  \  | [] => 0\n  | h::t => t.foldl Nat.xor h\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def list_sum (l : List Nat) : Nat := \n  match l with\n  | [] =>\
  \ 0\n  | h::t => h + list_sum t\n"
"vc-theorems": "theorem solve_xor_sum_length {n : Nat} {arr : List Nat} :\n  arr ≠\
  \ [] →\n  let result := solve_xor_sum n arr\n  List.length result = 0 ∨ List.length\
  \ result = 2 := sorry\n\n\ntheorem solve_xor_sum_verifies {n : Nat} {arr : List\
  \ Nat} :\n  arr ≠ [] →\n  let result := solve_xor_sum n arr\n  let full_arr := arr\
  \ ++ result\n  list_sum full_arr = 2 * xor_fold full_arr := sorry\n\n\ntheorem solve_xor_sum_bounds\
  \ {n : Nat} {arr : List Nat} :\n  arr ≠ [] →\n  let result := solve_xor_sum n arr\n\
  \  let total := list_sum arr\n  ∀ x ∈ result, x ≥ 0 ∧ x ≤ 2 * total := sorry\n\n\
  /--\ninfo: []\n-/\n#guard_msgs in\n#eval solve_xor_sum 4 [1, 2, 3, 6]\n\n/--\ninfo:\
  \ 2\n-/\n#guard_msgs in\n#eval len solve_xor_sum(1, [8])\n\n/--\ninfo: 2 * (arr[0]\
  \ ^ arr[1] ^ arr[2])\n-/\n#guard_msgs in\n#eval sum [8] + result\n\n/--\ninfo: 2\
  \ * xor\n-/\n#guard_msgs in\n#eval sum [1, 1] + result\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
