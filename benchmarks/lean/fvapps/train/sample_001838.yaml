"vc-description": "There are a total of n courses you have to take, labeled from 0\
  \ to n-1.\n\nSome courses may have prerequisites, for example to take course 0 you\
  \ have to first take course 1, which is expressed as a pair: [0,1]\n\nGiven the\
  \ total number of courses and a list of prerequisite pairs, return the ordering\
  \ of courses you should take to finish all courses.\n\nThere may be multiple correct\
  \ orders, you just need to return one of them. If it is impossible to finish all\
  \ courses, return an empty array.\n\nExample 1:\n\n\nInput: 2, [[1,0]] \nOutput:\
  \ [0,1]\nExplanation: There are a total of 2 courses to take. To take course 1 you\
  \ should have finished   \n             course 0. So the correct course order is\
  \ [0,1] .\n\nExample 2:\n\n\nInput: 4, [[1,0],[2,0],[3,1],[3,2]]\nOutput: [0,1,2,3]\
  \ or [0,2,1,3]\nExplanation: There are a total of 4 courses to take. To take course\
  \ 3 you should have finished both     \n             courses 1 and 2. Both courses\
  \ 1 and 2 should be taken after you finished course 0. \n             So one correct\
  \ course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] .\n\nNote:\n\n\
  \n       The input prerequisites is a graph represented by a list of edges, not\
  \ adjacency matrices. Read more about how a graph is represented.\n       You may\
  \ assume that there are no duplicate edges in the input prerequisites."
"vc-preamble": "import Imports.AllImports\n\ndef find_course_order (numCourses : Nat)\
  \ (prerequisites : List (Nat × Nat)) : List Nat :=\n  sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def isSorted (l : List Nat) : Prop :=\n  ∀ i j, i < j → j < l.length\
  \ → l[i]! ≤ l[j]!\n"
"vc-theorems": "theorem empty_prerequisites (n : Nat) (h : 0 < n) :\n  let result\
  \ := find_course_order n []\n  (result.length = n) ∧ \n  (isSorted result) ∧\n \
  \ (∀ i < n, i ∈ result) := by\n  sorry\n\n\ntheorem prerequisites_in_range (n :\
  \ Nat) (prereqs : List (Nat × Nat)) (h : 0 < n) :\n  let valid_prereqs := prereqs.filter\
  \ (fun p => p.1 < n ∧ p.2 < n)\n  let result := find_course_order n valid_prereqs\n\
  \  result.length ≠ 0 → \n  (result.length = n) ∧\n  (isSorted result) ∧\n  (∀ i\
  \ < n, i ∈ result) ∧\n  (∀ course, ∀ post pre, \n    course ∈ result →\n    (post,\
  \ pre) ∈ valid_prereqs →\n    post = course → \n    pre ∈ (result.take (result.indexOf\
  \ course))) := by\n  sorry\n\n\ntheorem cycle_detection (n : Nat) (h : 1 < n) :\n\
  \  let cyclic_prereqs := \n    (List.range (n-1)).map (fun i => (i+1, i)) ++ [(0,\
  \ n-1)]\n  find_course_order n cyclic_prereqs = [] := by\n  sorry\n\n\ntheorem linear_chain\
  \ (n : Nat) (h : 0 < n) :\n  let linear_prereqs := \n    (List.range (n-1)).map\
  \ (fun i => (i+1, i))\n  find_course_order n linear_prereqs = List.range n := by\n\
  \  sorry\n\n/--\ninfo: [0, 1]\n-/\n#guard_msgs in\n#eval find_course_order 2 [[1,\
  \ 0]]\n\n/--\ninfo: []\n-/\n#guard_msgs in\n#eval find_course_order 2 [[1, 0], [0,\
  \ 1]]\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
