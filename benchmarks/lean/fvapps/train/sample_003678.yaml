"vc-description": "Related to MrZizoScream's Product Array kata. You might want to\
  \ solve that one first :)\n\n```if:javascript\n**Note:** Node 10 has now been enabled,\
  \ and you can now use its BigInt capabilities if you wish, though your resulting\
  \ array must still contain strings (e.g. \"99999999999\", not 9999999999n)\n\nPre-node\
  \ 10: You will need to use the BigNumber.js library! Please use `.toFixed(0)` or\
  \ `.toPrecision()` to round instead of `.toString(10)`, as the latter is _very_\
  \ slow\n```\n\nThis is an adaptation of a problem I came across on LeetCode. \n\n\
  Given an array of numbers, your task is to return a new array where each index (`new_array[i]`)\
  \ is equal to the product of the original array, except for the number at that index\
  \ (`array[i]`).\n\n**Two things to keep in mind:**\n\n* Zeroes will be making their\
  \ way into some of the arrays you are given\n* O(n^2) solutions will not pass.\n\
  \nExamples:\n\n**Note**: All inputs will be valid arrays of nonzero length.\n\n\
  Have fun! Please upvote if you enjoyed :)"
"vc-preamble": "import Imports.AllImports\n\ndef List.product (l : List Int) : Int\
  \ := sorry \n\ndef product_sans_n (nums : List Int) : List Int := sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def count_zeros (l : List Int) : Nat :=\n  l.filter (· = 0) |>.length\n"
"vc-theorems": "theorem product_sans_n_length {nums : List Int} (h : nums ≠ []) :\
  \ \n  (product_sans_n nums).length = nums.length := sorry\n\n/--\ninfo: [24, 12,\
  \ 8, 6]\n-/\n#guard_msgs in\n#eval product_sans_n [1, 2, 3, 4]\n\n/--\ninfo: [0,\
  \ -18, 0]\n-/\n#guard_msgs in\n#eval product_sans_n [9, 0, -2]\n\n/--\ninfo: [0,\
  \ 0, 0]\n-/\n#guard_msgs in\n#eval product_sans_n [0, -99, 0]\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible"
