"vc-description": "You are given a matrix of integers $A$ with $N$ rows (numbered\
  \ $1$ through $N$) and $M$ columns (numbered $1$ through $M$). Each element of this\
  \ matrix is either $0$ or $1$.\nA move consists of the following steps:\n- Choose\
  \ two different rows $r_1$ and $r_2$ or two different columns $c_1$ and $c_2$.\n\
  - Apply the bitwise OR operation with the second row/column on the first row/column.\
  \ Formally, if you chose two rows, this means you should change $A_{r_1, k}$ to\
  \ $A_{r_1, k} \\lor A_{r_2, k}$ for each $1 \\le k \\le M$; if you chose two columns,\
  \ then you should change $A_{k, c_1}$ to $A_{k, c_1} \\lor A_{k, c_2}$ for each\
  \ $1 \\le k \\le N$.\nFor each element of the matrix, compute the minimum number\
  \ of moves required to make it equal to $1$ or determine that it is impossible.\
  \ Note that these answers are independent, i.e. we are starting with the initial\
  \ matrix for each of them.\n\n-----Input-----\n- The first line of the input contains\
  \ a single integer $T$ denoting the number of test cases. The description of $T$\
  \ test cases follows.\n- The first line of each test case contains two space-separated\
  \ integers $N$ and $M$.\n- $N$ lines follow. For each $i$ ($1 \\le i \\le N$), the\
  \ $i$-th of these lines contains $M$ integers $A_{i, 1}, A_{i, 2}, \\dots, A_{i,\
  \ M}$ NOT separated by spaces.\n\n-----Output-----\nFor each test case, print $N$\
  \ lines. For each valid $i$, the $i$-th of these lines should contain $M$ space-separated\
  \ integers; for each valid $j$, the $j$-th of these integers should be the minimum\
  \ number of moves required to make $A_{i, j}$ equal to $1$, or $-1$ if it is impossible.\n\
  \n-----Constraints-----\n- $1 \\le T \\le 100$\n- $1 \\le N, M \\le 1,000$\n- $A_{i,\
  \ j} \\in \\{0, 1\\}$ for each valid $i, j$\n- the sum of $N \\cdot M$ for all test\
  \ cases does not exceed $1,000,000$\n\n-----Example Input-----\n1\n3 3\n010\n000\n\
  001\n\n-----Example Output-----\n1 0 1\n2 1 1\n1 1 0"
"vc-preamble": "import Imports.AllImports\n\ndef Matrix := List (List Int)\ndef StrMatrix\
  \ := List String\n\n\ndef solve_matrix_moves (n m : Nat) (matrix : StrMatrix) :\
  \ Matrix :=\n  sorry\n\n\ndef replicate_zeros (n : Nat) (m : Nat) : List String\
  \ :=\n  sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def create_matrix_with_one (n m : Nat) : StrMatrix :=\n  sorry\
  \ \n"
"vc-theorems": "theorem matrix_dimensions {n m : Nat} (h1 : 0 < n) (h2 : 0 < m) :\n\
  \  let matrix := replicate_zeros n m\n  let result := solve_matrix_moves n m matrix\n\
  \  result.length = n ∧ \n  ∀ (row : List Int), List.elem row result → row.length\
  \ = m :=\nsorry\n\n\ntheorem matrix_all_zeros {n m : Nat} (h1 : 0 < n) (h2 : 0 <\
  \ m) :\n  let matrix := replicate_zeros n m\n  let result := solve_matrix_moves\
  \ n m matrix\n  ∀ (row : List Int), List.elem row result → \n  ∀ (x : Int), List.elem\
  \ x row → x = -1 :=\nsorry\n\n\ntheorem single_one {n m : Nat} (h1 : 0 < n) (h2\
  \ : 0 < m) :\n  let i := n / 2\n  let j := m / 2\n  let matrix := create_matrix_with_one\
  \ n m\n  let result := solve_matrix_moves n m matrix\n  (List.get! result i |>.get!\
  \ j) = 0 ∧\n  (∀ k, k < m → k ≠ j → (List.get! result i |>.get! k) = 1) ∧\n  (∀\
  \ k, k < n → k ≠ i → (List.get! result k |>.get! j) = 1) :=\nsorry"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded"
