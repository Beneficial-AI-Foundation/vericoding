"vc-description": "You are given a sequence of integers $A_1,A_2,…,A_N$ and a magical\
  \ non-zero integer $x$\nYou have to select a subsegment of sequence A (possibly\
  \ empty), and replace the elements in that subsegment after dividing them by x.\n\
  Formally, replace any one subsegment $A_l, A_{l+1}, ..., A_r$ with $A_l/x, A_{l+1}/x,\
  \ ..., A_r/x$ where $l \\leq r$\nWhat is the minimum possible sum you can obtain?\n\
  Note: The given operation can only be performed once\n\n-----Input -----\n- The\
  \ first line of the input contains two positive integer n denoting the size of array,\
  \ and x\ndenoting the magical integer\n- Next line contains $N$ space separated\
  \ integers\n\n-----Output-----\nSingle line containing one real number, denoting\
  \ the minimum possible sum you can obtain. Your answer will be considered correct\
  \ if its absolute or relative error does not exceed $10^{-2}$\n\n-----Constraints-----\n\
  - $1 \\leq n \\leq 10^3$\n- $1 \\leq |x| \\leq 10^3$\n- $ |A_i| \\leq 10^3$\n\n\
  -----Sample Input-----\n3 2\n1 -2 3\n\n-----Sample Output-----\n0.5\n\n-----Explanation-----\n\
  Array 1 -2 3, selecting subsegment {3}, you get 1 -2 1.5, which gives $sum=0.5$"
"vc-preamble": "import Imports.AllImports\n\ndef List.sum (l : List Int) : Int :=\
  \ \n  match l with\n  | [] => 0\n  | x :: xs => x + List.sum xs\n\n\ndef List.sumFloat\
  \ (l : List Float) : Float :=\n  match l with\n  | [] => 0\n  | x :: xs => x + List.sumFloat\
  \ xs\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def min_sum_after_division (n : Nat) (x : Nat) (arr : List Int)\
  \ : Float := sorry\n\ntheorem min_sum_properties_le_orig_sum {n : Nat} {x : Nat}\
  \ {arr : List Int} \n  (h1 : x ≥ 2) (h2 : arr.length = n) (h3 : arr.length > 0)\
  \ \n  (h4 : x ≠ 0) :\n  min_sum_after_division n x arr ≤ Float.ofInt (List.sum arr)\
  \ := sorry\n"
"vc-theorems": "theorem min_sum_properties_exists_real {n : Nat} {x : Nat} {arr :\
  \ List Int}\n  (h1 : x ≥ 2) (h2 : arr.length = n) (h3 : arr.length > 0) \n  (h4\
  \ : x ≠ 0) :\n  ∃ r : Float, min_sum_after_division n x arr = r := sorry\n\n\ntheorem\
  \ min_sum_properties_le_divided_sum {n : Nat} {x : Nat} {arr : List Int} {i j :\
  \ Nat}\n  (h1 : x ≥ 2) (h2 : arr.length = n) (h3 : arr.length > 0)\n  (h4 : i ≤\
  \ j) (h5 : j < arr.length) (h6 : x ≠ 0) :\n  let divided_section := (arr.drop i).take\
  \ (j-i+1) |>.map (fun a => Float.ofInt a / Float.ofNat x)\n  let divided_sum :=\
  \ Float.ofInt (List.sum (arr.take i)) + \n                    List.sumFloat divided_section\
  \ +\n                    Float.ofInt (List.sum (arr.drop (j+1)))\n  min_sum_after_division\
  \ n x arr ≤ divided_sum := sorry\n\n\ntheorem positive_array_nonneg {n : Nat} {x\
  \ : Nat} {arr : List Int}\n  (h1 : x ≥ 2) (h2 : arr.length = n) (h3 : arr.length\
  \ > 0)\n  (h4 : ∀ a ∈ arr, a ≥ 0) (h5 : x ≠ 0) :\n  min_sum_after_division n x arr\
  \ ≥ 0 := sorry \n\n\ntheorem positive_array_le_sum {n : Nat} {x : Nat} {arr : List\
  \ Int}\n  (h1 : x ≥ 2) (h2 : arr.length = n) (h3 : arr.length > 0) \n  (h4 : ∀ a\
  \ ∈ arr, a ≥ 0) (h5 : x ≠ 0) :\n  min_sum_after_division n x arr ≤ Float.ofInt (List.sum\
  \ arr) := sorry"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded"
