"vc-description": "Chef is given a sequence of prime numbers $A_1, A_2, \\ldots, A_N$.\
  \ This sequence has exactly $2^N$ subsequences. A subsequence of $A$ is good if\
  \ it does not contain any two identical numbers; in particular, the empty sequence\
  \ is good.\nChef has to find the number of good subsequences which contain at most\
  \ $K$ numbers. Since he does not know much about subsequences, help him find the\
  \ answer. This number could be very large, so compute it modulo $1,000,000,007$.\n\
  \n-----Input-----\n- The first line of the input contains two space-separated integers\
  \ $N$ and $K$.\n- The second line contains $N$ space-separated integers $A_1, A_2,\
  \ \\ldots, A_N$.\n\n-----Output-----\nPrint a single line containing one integer\
  \ ― the number of good subsequences with size at most $K$, modulo $1,000,000,007$.\n\
  \n-----Constraints-----\n- $1 \\le K \\le N \\le 10^5$\n- $2 \\le A_i \\le 8,000$\
  \ for each valid $i$\n\n-----Subtasks-----\nSubtask #1 (40 points): $A_1, A_2, \\\
  ldots, A_N$ are pairwise distinct\nSubtask #2 (60 points): original constraints\n\
  \n-----Example Input-----\n5 3\n2 2 3 3 5\n\n-----Example Output-----\n18\n\n-----Explanation-----\n\
  There is $1$ good subsequence with length $0$, $5$ good subsequences with length\
  \ $1$, $8$ good subsequences with length $2$ and $4$ good subsequences with length\
  \ $3$."
"vc-preamble": "import Imports.AllImports\n\ndef List.sum : List Nat → Nat\n| [] =>\
  \ 0\n| (h::t) => h + List.sum t\n\n\ndef solve (arr : List Nat) (n k : Nat) : Nat\
  \ :=\n  sorry\n\n\ndef windowSum (arr : List Nat) (start len : Nat) : Nat :=\n \
  \ (arr.take (start + len)).drop start |>.sum\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def countWindows (arr : List Nat) (n k : Nat) : Nat :=\n  let windows\
  \ := List.range (n - k + 1)\n  windows.filter (fun i => windowSum arr i k = k) |>.length\n"
"vc-theorems": "theorem solve_basic_properties \n  (arr : List Nat) \n  (n k : Nat)\n\
  \  (h1 : ∀ x ∈ arr, x ≤ 1)\n  (h2 : k ≤ n)\n  (h3 : n = arr.length) :\n  let result\
  \ := solve arr n k\n  -- Result is non-negative\n  (result ≥ 0) ∧ \n  -- Result\
  \ does not exceed max possible windows\n  (result ≤ n - k + 1) ∧\n  -- For k=1,\
  \ result equals sum of array\n  (k = 1 → result = List.sum arr) ∧\n  -- For array\
  \ of all 1s, result equals n-k+1\n  ((∀ x ∈ arr, x = 1) → result = n - k + 1) :=\n\
  \  sorry\n\n\ntheorem solve_equals_manual_count\n  (arr : List Nat)\n  (n k : Nat)\
  \ \n  (h1 : ∀ x ∈ arr, x ≤ 1)\n  (h2 : k ≤ n)\n  (h3 : n = arr.length)\n  (h4 :\
  \ n > 0) :\n  solve arr n k = countWindows arr n k :=\n  sorry\n\n/--\ninfo: 1\n\
  -/\n#guard_msgs in\n#eval solve [1, 1, 0, 1] 4 2\n\n/--\ninfo: 2\n-/\n#guard_msgs\
  \ in\n#eval solve [1, 1, 1] 3 2\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval solve\
  \ [1, 1, 1, 1, 1, 0, 1, 1, 1, 1] 10 3\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
