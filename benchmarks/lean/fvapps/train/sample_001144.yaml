"vc-description": "Problem description.\n\nThis problem is simple and will introduce\
  \ you to the Dynamic Programming.\n\nYou will be given an array and a key value.\n\
  \nYou will have to find out the occurrences of the key value depending upon the\
  \ query using Brute Force and Top Down Dynamic Programming.\n\n-----Brute-Force:\
  \ -----\nYou will check the query, and calculate the occurrences.\n\n\n-----DP:\
  \ -----\n\nYou will check the query; check whether the memoized solution is already\
  \ available.\n\nIf the memoized solution is available, no need to calculate the\
  \ number of occurrences again.\n\nIf the memoized solution is not available, then\
  \ calculate the number of  occurrences and memoize it for future use.\n\n-----Pseudo\
  \ Code for DP:-----\ncountOccurences(key,from):\n\nif (from = size of array) then\
  \ \n\treturn 0\nendif\nif dp[from] is availabe then \n\treturn dp[from]\nendif\n\
  if( array[from] == key) then\n\tdp[from] = 1+countOccurences(key,from+1)\nelse\n\
  \tdp[from] = countOccurences(key,from+1)\nendif\t\nreturn dp[from]\n\n\n-----Input:-----\n\
  \nThe first line of input is the number of test cases (t).\n\nThe first line of\
  \ each test case is the number of array elements (n).\n\nThe next will contain n\
  \ space separated integers.\n\nThe next line will have the key element (k).\n\n\
  The next will have number of queries (q).\n\nThe next q lines will contain an integer\
  \ A such that 0<=A < n. \n\nYou have to find out the number of occurrences from\
  \ a to end of the array using both brute force and DP. \n\nEverything will fit into\
  \ the range of int.\n\n-----Output:-----\n\nFor each test case, the output will\
  \ have q lines with 3 space separated integers.\nThe first will be the number of\
  \ occurrences, other will be the loop count/function calls,\nusing brute force and\
  \ the last will be the number of loop count/function calls using DP.\n\n-----Sample\
  \ Input:-----\n1\n10\n1 2 3 1 2 3 1 2 3 1\n3\n5\n2\n4\n6\n8\n2\n\n-----Sample output:-----\n\
  3 8 9\n2 6 1\n1 4 1\n1 2 1\n3 8 1\n\n-----Explanation:-----\n\nFor the first query,\
  \ we have to find the number of occurrences of 3 from index 2.\n\nUsing the brute\
  \ force, the loop will check each element from index 2 to 9. Thus the loop count\
  \ is 8.\n\nUsing DP, the method countOccurences(key,from) will be called like this\
  \ : \n\ncountOccurences(3,2)->countOccurences(3,3)->countOccurences(3,4)->countOccurences(3,5)\n\
  ->countOccurences(3,6)->countOccurences(3,7)->countOccurences(3,8)\n->countOccurences(3,9)->countOccurences(3,10).\n\
  \n\nWhen the countOccurences(3,10) is called, it will return 0. Total 9 function\
  \ calls.\n\nFor the second query, the brute force will do the same as above.\n\n\
  But the DP will check whether solution for countOccurences(3,4) is available or\
  \ not.\n\nAs it was calculated while solving the first query, it won’t solve it\
  \ again and will directly give the answer. \n\nTotal 1 function calls."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def find_key_occurrences (arr : List Int) (key : Int) (queries\
  \ : List Nat) : \n  List (Nat × Nat × Nat) := sorry\n\n-- For each element in result,\
  \ all components are natural numbers"
"vc-theorems": "theorem result_components_natural_numbers (arr : List Int) (key :\
  \ Int) (queries : List Nat) :\n  let result := find_key_occurrences arr key queries\n\
  \  ∀ r ∈ result, r.1 ≥ 0 ∧ r.2.1 ≥ 0 ∧ r.2.2 ≥ 0 :=\nsorry\n\n-- Result length matches\
  \ queries length \n\ntheorem result_length_matches_queries (arr : List Int) (key\
  \ : Int) (queries : List Nat) :\n  let result := find_key_occurrences arr key queries\n\
  \  result.length = queries.length :=\nsorry\n\n-- For monotonically increasing queries,\
  \ occurrences are monotonically decreasing\n\ntheorem monotonic_occurrences (arr\
  \ : List Int) (key : Int) (queries : List Nat) :\n  let result := find_key_occurrences\
  \ arr key queries\n  ∀ i j, i < j → j < queries.length → queries.get! i < queries.get!\
  \ j → \n    (result.get! i).1 ≥ (result.get! j).1 :=\nsorry\n\n-- Second component\
  \ equals array length minus query index\n\ntheorem brute_force_counts (arr : List\
  \ Int) (key : Int) (queries : List Nat) :\n  let result := find_key_occurrences\
  \ arr key queries\n  ∀ i, i < queries.length → \n    (result.get! i).2.1 = arr.length\
  \ - queries.get! i :=\nsorry\n\n-- Third component is at least 1\n\ntheorem dp_counts_positive\
  \ (arr : List Int) (key : Int) (queries : List Nat) :\n  let result := find_key_occurrences\
  \ arr key queries\n  ∀ r ∈ result, r.2.2 ≥ 1 :=\nsorry\n\n-- First component counts\
  \ actual occurrences after query index\n\ntheorem occurrence_count_correct (arr\
  \ : List Int) (key : Int) (queries : List Nat) :\n  let result := find_key_occurrences\
  \ arr key queries\n  ∀ i, i < queries.length →\n    (result.get! i).1 = ((arr.drop\
  \ (queries.get! i)).filter (· = key)).length :=\nsorry"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded"
