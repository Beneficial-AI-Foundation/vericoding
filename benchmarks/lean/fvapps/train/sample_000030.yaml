"vc-description": "You are given a string $s$ of even length $n$. String $s$ is binary,\
  \ in other words, consists only of 0's and 1's.\n\nString $s$ has exactly $\\frac{n}{2}$\
  \ zeroes and $\\frac{n}{2}$ ones ($n$ is even).\n\nIn one operation you can reverse\
  \ any substring of $s$. A substring of a string is a contiguous subsequence of that\
  \ string.\n\nWhat is the minimum number of operations you need to make string $s$\
  \ alternating? A string is alternating if $s_i \\neq s_{i + 1}$ for all $i$. There\
  \ are two types of alternating strings in general: 01010101... or 10101010...\n\n\
  \n-----Input-----\n\nThe first line contains a single integer $t$ ($1 \\le t \\\
  le 1000$) — the number of test cases.\n\nThe first line of each test case contains\
  \ a single integer $n$ ($2 \\le n \\le 10^5$; $n$ is even) — the length of string\
  \ $s$.\n\nThe second line of each test case contains a binary string $s$ of length\
  \ $n$ ($s_i \\in$ {0, 1}). String $s$ has exactly $\\frac{n}{2}$ zeroes and $\\\
  frac{n}{2}$ ones.\n\nIt's guaranteed that the total sum of $n$ over test cases doesn't\
  \ exceed $10^5$.\n\n\n-----Output-----\n\nFor each test case, print the minimum\
  \ number of operations to make $s$ alternating.\n\n\n-----Example-----\nInput\n\
  3\n2\n10\n4\n0110\n8\n11101000\n\nOutput\n0\n1\n2\n\n\n\n-----Note-----\n\nIn the\
  \ first test case, string 10 is already alternating.\n\nIn the second test case,\
  \ we can, for example, reverse the last two elements of $s$ and get: 0110 $\\rightarrow$\
  \ 0101.\n\nIn the third test case, we can, for example, make the following two operations:\
  \   11101000 $\\rightarrow$ 10101100;  10101100 $\\rightarrow$ 10101010."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def solve_string_alternation (n : Nat) (s : String) : Nat := sorry\n\
  \n/-- Main theorem combining several properties of solve_string_alternation:\n \
  \ 1. Output is non-negative\n  2. Output is less than string length \n  3. Output\
  \ relates to number of adjacent duplicates\n-/"
"vc-theorems": "theorem solve_string_alternation_properties (s : String) (n : Nat)\
  \ \n  (h1 : s.length = n) (h2 : n > 0) (h3 : ∀c ∈ s.data, c = '0' ∨ c = '1') :\n\
  \  let result := solve_string_alternation n s\n  let adjacent_same := (List.zip\
  \ s.data s.data.tail).filter (fun p => p.1 = p.2) |>.length\n  (result ≥ 0) ∧ \n\
  \  (result < n) ∧\n  (result = (adjacent_same + adjacent_same % 2) / 2) := sorry\n\
  \n/-- Perfectly alternating strings require no operations -/\n\ntheorem solve_string_alternation_perfect_alt\
  \ (n : Nat) (h : n ≥ 2) :  \n  let s := String.mk (List.map (fun i => if i % 2 =\
  \ 0 then '0' else '1') (List.range n))\n  solve_string_alternation n s = 0 := sorry\n\
  \n/-- For strings of all same characters, result depends on length -/\n\ntheorem\
  \ solve_string_alternation_all_same (n : Nat) (h : n > 0) :\n  let s := String.mk\
  \ (List.replicate n '0')\n  solve_string_alternation n s = ((n-1) + (n-1) % 2) /\
  \ 2 := sorry\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval solve_string_alternation\
  \ 2 \"10\"\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_string_alternation 4\
  \ \"0110\"\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_string_alternation 8\
  \ \"11101000\"\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded"
