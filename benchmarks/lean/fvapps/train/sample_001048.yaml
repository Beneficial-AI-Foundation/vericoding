"vc-description": "$Jaggu$ monkey a friend of $Choota$ $Bheem$ a great warrior of\
  \ $Dholakpur$. He gets everything he wants. Being a friend of $Choota$ $Bheem$ he\
  \ never has to struggle for anything, because of this he is in a great debt of $Choota$\
  \ $Bheem$, he really wants to pay his debt off.\nFinally the time has come to pay\
  \ his debt off, $Jaggu$ is on a magical tree. He wants to collect apples from different\
  \ branches but he is in a hurry. $Botakpur$ has attacked on $Dholakpur$ and $Bheem$\
  \ is severely injured, as been instructed by the village witch, $Bheem$ can only\
  \ be saved by the apples of the magical tree. Each apple is placed in Tree Node\
  \ structure and each apple has some sweetness. Now there's a problem as $Jaggu$\
  \ is also injured so he can only slide downwards and alse is collecting apples in\
  \ his hand so he can't climb. You would be given $Q$ queries. Queries are of 2 type\
  \ :-\n- \nEnding Node Node of $Jaggu$ is given. $format$ - type of query node -(1\
  \ 2)\n- \nSweetness of Apple on a given node is changed. $format$ - type of query\
  \ node new sweetness(2 3 10)\n$Note$: $Jaggu$ is always on the top of tree initially\
  \ in each query.The sweetness is always positive.\nHelp $Jaggu$ in saving $Bheem$\n\
  \n-----Input:-----\n- First line contains $N$ - (number of nodes).  \n- Next line\
  \ contains $N$ integers with space giving sweetness of apple on Nodes $(1 to N)$\n\
  - Next $N-1$ lines contain  $N1$ $N2$ connected nodes.\n- Next line contains single\
  \ integer $Q$ Number of queries\n\n-----Output:-----\n- For each query of type 1,\
  \ print total sweetness of apples. \n\n-----Constraints-----\n- $1 \\leq N \\leq\
  \ 10^4$\n- $2 \\leq Q \\leq 10^4$\n\n-----Sample Input:-----\n10\n10 12 6 8 1 19\
  \ 0 5 13 17\n1 2\n1 3\n1 4\n3 10\n4 8\n8 9\n4 5\n5 7\n5 6\n3\n1 1\n2 3 20\n1 8\n\
  \n-----Sample Output:-----\n10\n23\n\n-----EXPLANATION:-----\nThis sweetness array\
  \ is :\n$[10,2,6,8,1,19,0,5,13,17]$\nThe tree is:\n1   \n\n/  |   \\      \n\n2\
  \    3     4     \n\n/    /    \\      \n\n10     8        5   \n\n/        /  \
  \  \\     \n\n9         7        6"
"vc-preamble": "import Imports.AllImports\n\ndef solve_tree_queries (n : Nat) (sweetness\
  \ : List Int) (edges : List (Nat × Nat))\n  (queries : List QueryType) : List Int\
  \ :=\n  sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def is_tree (n : Nat) (edges : List (Nat × Nat)) : Bool :=\n  sorry\n"
"vc-theorems": "theorem solve_tree_queries_outputs_len {n : Nat} {sweetness : List\
  \ Int} \n  {edges : List (Nat × Nat)} {queries : List QueryType}\n  (h1 : sweetness.length\
  \ = n)\n  (h2 : is_tree n edges = true) :\n  (solve_tree_queries n sweetness edges\
  \ queries).length = \n  (queries.filter (fun q => match q with \n              \
  \             | QueryType.get _ => true\n                           | _ => false)).length\
  \ :=\nsorry \n\n\ntheorem solve_tree_queries_outputs_integers {n : Nat} {sweetness\
  \ : List Int}\n  {edges : List (Nat × Nat)} {queries : List QueryType} \n  {result\
  \ : List Int}\n  (h1 : sweetness.length = n)\n  (h2 : is_tree n edges = true)\n\
  \  (h3 : result = solve_tree_queries n sweetness edges queries) :\n  ∀ x, x ∈ result\
  \ → x ∈ sweetness ∨ ∃ q, q ∈ queries ∧ (\n    match q with\n    | QueryType.update\
  \ _ v => v = x\n    | _ => False\n  ) :=\nsorry\n\n\ntheorem solve_tree_queries_idempotent\
  \ {n : Nat} {sweetness : List Int}\n  {edges : List (Nat × Nat)} {val : Int} {node\
  \ : Nat}\n  (h1 : sweetness.length = n)\n  (h2 : is_tree n edges = true)\n  (h3\
  \ : node ≤ n) :\n  (solve_tree_queries n sweetness edges \n    [QueryType.update\
  \ node val, QueryType.get node]).length = 1 :=\nsorry"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded"
