"vc-description": "Rohit collects coins: he has exactly one coin for every year from\
  \ 1 to n. Naturally, Rohit keeps all the coins in his collection in the order in\
  \ which they were released. Once Rohit's younger brother made a change — he took\
  \ all the coins whose release year dated from l to r inclusively and put them in\
  \ the reverse order. That is, he took a certain segment [l, r] and reversed it.\
  \ At that, the segment's endpoints did not coincide. For example, if n = 8, then\
  \ initially Rohit's coins were kept in the order 1 2 3 4 5 6 7 8. If Rohit's younger\
  \ brother chose the segment [2, 6], then after the reversal the coin order will\
  \ change to 1 6 5 4 3 2 7 8. Rohit suspects that someone else could have spoilt\
  \ the permutation after his brother. Help him to find that out. Check if the given\
  \ permutation can be obtained from the permutation 1 2 … n using exactly one segment\
  \ reversal. If it is possible, find the segment itself.\n\n-----Input:-----\n- The\
  \ first line contains an integer N which is the number of coins in Rohit's collection.\
  \ \n- The second line contains space-separated n integers which are the spoilt sequence\
  \ of coins. It is guaranteed that the given sequence is a permutation, i.e. it contains\
  \ only integers from 1 to n, and every number is used exactly 1 time.\n\n-----Output:-----\n\
  If it is impossible to obtain the given permutation from the original one in exactly\
  \ one action, print 0 0. Otherwise, print two numbers l, r (1 ≤ l < r ≤ n) which\
  \ are the endpoints of the segment that needs to be reversed to obtain from permutation\
  \ 1 2 … n the given one.\n\n-----Constraints-----\n- $1 \\leq N \\leq 1000$\n- $1\
  \ \\leq A[N] \\leq 10^9$\n\n-----Sample Input:-----\n8\n1 6 5 4 3 2 7 8\n\n-----Sample\
  \ Output:-----\n2 6"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def solve (n : Nat) (seq : List Nat) : Nat × Nat := sorry\n\ndef\
  \ isValidAfterReverse (seq : List Nat) (l r : Nat) : Bool := sorry\n"
"vc-theorems": "theorem solve_sorted_sequence {n : Nat} (h : n > 0) :\n  let seq :=\
  \ List.range' 1 n\n  solve n seq = (0, 0) := sorry\n\n\ntheorem solve_reversed_sequence\
  \ {n : Nat} (h : n > 1) :\n  let seq := List.reverse (List.range' 1 n) \n  solve\
  \ n seq = (1, n) := sorry\n\n/--\ninfo: (2, 6)\n-/\n#guard_msgs in\n#eval solve\
  \ 8 [1, 6, 5, 4, 3, 2, 7, 8]\n\n/--\ninfo: (0, 0)\n-/\n#guard_msgs in\n#eval solve\
  \ 4 [1, 2, 3, 4]\n\n/--\ninfo: (1, 3)\n-/\n#guard_msgs in\n#eval solve 3 [3, 2,\
  \ 1]\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible"
