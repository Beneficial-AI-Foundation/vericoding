"vc-description": "\tChef has a cubic die with 6 faces kept on an infinite plane.\
  \ Each face has a distinct integer in the range [1,6] written on it, but the exact\
  \ arrangement of the numbers on the faces of the die is unknown to Chef. Curiosity\
  \ gets the better of Chef and he wants to find out o(1), o(2), ..., o(6), where\
  \ o(i) is the number written opposite to the number i.\n\n\tChef performs the following\
  \ N-1 steps to learn the exact arrangement of the numbers on the die. In the i-th\
  \ step, Chef pushes the die in some direction (there are 4 possible directions),\
  \ and the die rolls 90o in this direction. The picture below demonstrates a die\
  \ and the result that it produced after rolling in each of the 4 directions respectively.\
  \ For this die, we have o(1)=4, o(2)=5, o(3)=6, o(4)=1, o(5)=2, o(6)=3.\n\n\tChef\
  \ records N numbers A1, A2, ..., AN, where Ai is the number written on the top of\
  \ the die before the i-th step. However, the information on the direction in which\
  \ he pushes the die each time are lost. Can you help him determine the arrangement\
  \ of 1-6? You need to output o(1), o(2), ..., o(6). If there are multiple solutions,\
  \ output any one of them.\n\n-----\n\tInput-----\n- The first line of input contains\
  \ a single integer T, the number of test cases.\n- Each test case consists of two\
  \ lines.\n- The first line contains an integer N, and the second line contains N\
  \ space-separated integers A1, A2, ..., AN.\n\n-----\n\tOutput-----\n\n\tFor each\
  \ test case, output one line. If a possible solution exists, then output 6 space-separated\
  \ integers o(1), o(2), ..., o(6); otherwise, output -1.\n\n-----\n\tConstraints-----\n\
  \n- 1 ≤ T, N ≤ 500\n- 1 ≤ Ai ≤ 6\n\n\tSubtask #1 (17 points):\n\n- N ≤ 2\n\n\tSubtask\
  \ #2 (83 points):\n\n- original constraints\n\n-----\n\tExample-----\nInput:\n4\n\
  9\n1 3 4 6 1 3 4 6 1\n10\n1 2 1 3 1 4 1 5 1 6\n6\n1 2 3 4 5 6\n4\n1 3 3 1\n\nOutput:\n\
  2 1 6 5 4 3\n-1\n4 5 6 1 2 3\n-1\n\n-----\n\tExplanation-----\nExample case 1: See\
  \ below.\n\nExample case 2: You can prove that there's no solution.\nExample case\
  \ 3: The solution is not unique. 3 5 1 6 2 4 is another valid solution."
"vc-preamble": "import Imports.AllImports\n\ndef solveDie (n : Nat) (nums : List Nat)\
  \ : List Nat :=\n  sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def isValidConfig (config : List Nat) : Bool :=\n  sorry\n\n/--\
  \ If solveDie returns [0], it indicates no valid configuration exists.\n    Otherwise,\
  \ returns a valid die configuration that works with the input sequence. -/"
"vc-theorems": "theorem die_configuration_theorem (n : Nat) (nums : List Nat) :\n\
  \  let result := solveDie n nums\n  result = [0] ∨ isValidConfig result ∧\n    ∀\
  \ i : Nat, i + 1 < n →\n      nums[i]! ≠ nums[i+1]! ∧\n      nums[i+1]! ≠ result[nums[i]!\
  \ - 1]! :=\n  sorry\n\n/-- If there are adjacent equal numbers in the input sequence,\n\
  \    no valid die configuration exists -/\n\ntheorem adjacent_same_numbers_theorem\
  \ (n : Nat) (nums : List Nat) :\n  (∃ i : Nat, i + 1 < n ∧ nums[i]! = nums[i+1]!)\
  \ →\n  solveDie n nums = [0] :=\n  sorry"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded"
