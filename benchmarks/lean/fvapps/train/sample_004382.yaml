"vc-description": "Simply find the closest value to zero from the list. Notice that\
  \ there are negatives in the list.\n\nList is always not empty and contains only\
  \ integers. Return ```None``` if it is not possible to define only one of such values.\
  \ And of course, we are expecting 0 as closest value to zero.\n\nExamples:\n```code\n\
  [2, 4, -1, -3]  => -1\n[5, 2, -2]      => None\n[5, 2, 2]       => 2\n[13, 0, -6]\
  \     => 0\n```"
"vc-preamble": "import Imports.AllImports\n\ndef abs (x : Int) : Int := \n  if x <\
  \ 0 then -x else x\n\n\ndef minimum (lst : List Int) : Option Int := \n  lst.foldl\
  \ (fun min x => match min with\n    | none => some x\n    | some m => some (if x\
  \ < m then x else m)) none\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def closest (lst : List Int) : Option Int := sorry\n\ntheorem closest_returns_none_or_element\
  \ (lst : List Int) (h : lst ≠ []) :\n  match closest lst with\n  | none => True\n\
  \  | some x => x ∈ lst\n  := sorry\n"
"vc-theorems": "theorem closest_zero (lst : List Int) (h : lst ≠ []) :\n  0 ∈ lst\
  \ → closest lst = some 0 := sorry\n\n\ntheorem closest_none_when_equal_absolutes\
  \ (lst : List Int) (h : lst ≠ []) :\n  match closest lst with\n  | none => ∃ x ∈\
  \ lst, -x ∈ lst\n  | some x => (match minimum (lst.map abs) with\n             \
  \ | none => False\n              | some m => abs x = m) ∧ -x ∉ lst\n  := sorry\n\
  \n\ntheorem closest_is_minimum_absolute (lst : List Int) (h : lst ≠ []) :\n  match\
  \ closest lst with\n  | none => True\n  | some x => match minimum (lst.map abs)\
  \ with\n              | none => False\n              | some m => abs x = m\n  :=\
  \ sorry\n\n/--\ninfo: -1\n-/\n#guard_msgs in\n#eval closest [2, 4, -1, -3]\n\n/--\n\
  info: None\n-/\n#guard_msgs in\n#eval closest [5, 2, -2]\n\n/--\ninfo: 0\n-/\n#guard_msgs\
  \ in\n#eval closest [13, 0, -6]\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
