"vc-description": "Given a rational number n\n\n``` n >= 0, with denominator strictly\
  \ positive```  \n\n- as a string (example: \"2/3\" in Ruby, Python, Clojure, JS,\
  \ CS, Go) \n- or as two strings (example: \"2\" \"3\" in Haskell, Java, CSharp,\
  \ C++, Swift) \n- or as a rational or decimal number (example: 3/4, 0.67 in R) \n\
  - or two integers (Fortran)\n\ndecompose \nthis number as a sum of rationals with\
  \ numerators equal to one and without repetitions\n(2/3 = 1/2 + 1/6 is correct but\
  \ not 2/3 = 1/3 + 1/3, 1/3 is repeated).\n    \nThe algorithm must be \"greedy\"\
  , so at each stage the new rational obtained in the decomposition must have a denominator\
  \ as small as possible. \nIn this manner the sum of a few fractions in the decomposition\
  \ gives a rather good approximation of the rational to decompose.\n    \n2/3 = 1/3\
  \ + 1/3 doesn't fit because of the repetition but also because the first 1/3 has\
  \ a denominator bigger than the one in 1/2 \nin the decomposition 2/3 = 1/2 + 1/6.\n\
  \    \n### Example: \n(You can see other examples in \"Sample Tests:\")\n```\ndecompose(\"\
  21/23\") or \"21\" \"23\" or 21/23 should return \n\n[\"1/2\", \"1/3\", \"1/13\"\
  , \"1/359\", \"1/644046\"] in Ruby, Python, Clojure, JS, CS, Haskell, Go\n\n\"[1/2,\
  \ 1/3, 1/13, 1/359, 1/644046]\" in Java, CSharp, C++\n\n\"1/2,1/3,1/13,1/359,1/644046\"\
  \ in C, Swift, R\n```  \n\n### Notes\n1) The decomposition of 21/23 as\n```\n21/23\
  \ = 1/2 + 1/3 + 1/13 + 1/598 + 1/897\n```\nis exact but don't fulfill our requirement\
  \ because 598 is bigger than 359.\nSame for \n```\n21/23 = 1/2 + 1/3 + 1/23 + 1/46\
  \ + 1/69 (23 is bigger than 13)\nor \n21/23 = 1/2 + 1/3 + 1/15 + 1/110 + 1/253 (15\
  \ is bigger than 13).\n```\n    \n2) The rational given to decompose could be greater\
  \ than one or equal to one, in which case the first \"fraction\" will be an integer\
  \ \n(with an implicit denominator of 1). \n\n3) If the numerator parses to zero\
  \ the function \"decompose\" returns [] (or \"\".\n\n4) The number could also be\
  \ a decimal which can be expressed as a rational. \n\nexamples:\n\n`0.6` in Ruby,\
  \ Python, Clojure,JS, CS, Julia, Go\n  \n`\"66\" \"100\"` in Haskell, Java, CSharp,\
  \ C++, C, Swift, Scala, Kotlin\n\n`0.67` in R.\n\n**Ref:**\nhttp://en.wikipedia.org/wiki/Egyptian_fraction"
"vc-preamble": "import Imports.AllImports\n\ndef Rat.add (a b : Rat) : Rat := sorry\n\
  def Rat.sub (a b : Rat) : Rat := sorry\n\ndef Rat.le (a b : Rat) : Prop := sorry\n\
  def Rat.abs (a : Rat) : Rat := sorry\n\ndef Int.toRat (n : Int) : Rat := sorry\n\
  def Nat.toRat (n : Nat) : Rat := sorry\n\ndef Float.toRat (f : Float) : Rat := sorry\n\
  \ninstance : Add Rat where\n  add := Rat.add\n\ninstance : Sub Rat where\n  sub\
  \ := Rat.sub\n\ninstance : LE Rat where\n  le := Rat.le\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def decompose (f : Rat) : List Rat := sorry\n\n/-- The sum of decomposed\
  \ unit fractions equals the input rational number -/"
"vc-theorems": "theorem decompose_sum_equals_input (f : Rat) (h : Rat.le ⟨0, 1, by\
  \ simp⟩ f) (h2 : Rat.le f ⟨10, 1, by simp⟩) :\n  let parts := decompose f\n  let\
  \ sum_parts := parts.foldl Rat.add ⟨0, 1, by simp⟩\n  Rat.le (Rat.abs (Rat.sub sum_parts\
  \ f)) ⟨1, 100000, by simp⟩ := sorry\n\n/-- For non-whole numbers, decomposition\
  \ yields unique descending unit fractions -/\n\ntheorem decompose_unique_unit_fractions\
  \ (f : Rat) (h : Rat.le ⟨0, 1, by simp⟩ f) (h2 : Rat.le f ⟨10, 1, by simp⟩) :\n\
  \  let parts := decompose f\n  (parts.length > 1) →\n  let unit_fracs := parts.tail\n\
  \  (∀ x ∈ unit_fracs, ∃ (n : Nat) (h : n > 0), x = ⟨1, n, h⟩) ∧ \n  List.Pairwise\
  \ (fun x y => Rat.le y x) unit_fracs ∧\n  List.Nodup unit_fracs := sorry\n\n/--\
  \ Decomposition of whole numbers returns singleton list -/\n\ntheorem decompose_whole_numbers\
  \ (n : Nat) (h : n > 0) (h2 : n ≤ 100) :\n  decompose (Nat.toRat n) = [Nat.toRat\
  \ n] := sorry\n\n/-- Decimal inputs are handled properly -/\n\ntheorem decompose_decimals\
  \ (d : Float) (h : d ≥ 0) (h2 : d ≤ 10) :\n  let result := decompose (Float.toRat\
  \ d)\n  let sum_parts := result.foldl Rat.add ⟨0, 1, by simp⟩\n  Rat.le (Rat.abs\
  \ (Rat.sub sum_parts (Float.toRat d))) ⟨1, 100000, by simp⟩ := sorry\n\n/--\ninfo:\
  \ ['1/2', '1/4']\n-/\n#guard_msgs in\n#eval decompose \"3/4\"\n\n/--\ninfo: ['1/2',\
  \ '1/7', '1/59', '1/5163', '1/53307975']\n-/\n#guard_msgs in\n#eval decompose \"\
  0.66\"\n\n/--\ninfo: ['1/2', '1/4', '1/20']\n-/\n#guard_msgs in\n#eval decompose\
  \ \"4/5\"\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
