"vc-description": "Create a function that takes a Roman numeral as its argument and\
  \ returns its value as a numeric decimal integer. You don't need to validate the\
  \ form of the Roman numeral.\n\nModern Roman numerals are written by expressing\
  \ each decimal digit of the number to be encoded separately, starting with the leftmost\
  \ digit and skipping any 0s. So 1990 is rendered \"MCMXC\" (1000 = M, 900 = CM,\
  \ 90 = XC) and 2008 is rendered \"MMVIII\" (2000 = MM, 8 = VIII). The Roman numeral\
  \ for 1666, \"MDCLXVI\", uses each letter in descending order.\n\nExample:\n\n```python\n\
  solution('XXI') # should return 21\n```\n\n```Elixir\nSolution.decode(\"XXI\") #\
  \ should return 21\n```\n\nHelp:\n```\nSymbol  Value\nI             1\nV       \
  \      5\nX             10\nL             50\nC             100\nD             500\n\
  M             1,000\n```\n\n*Courtesy of rosettacode.org*"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def solution (s : String) : Nat := sorry\n\ndef isValidRoman (s\
  \ : String) : Bool := sorry\n\n\n"
"vc-theorems": "theorem single_repeated_numerals {roman : String} (c : Char)\n  (h1\
  \ : roman.data.all (· = c))\n  (h2 : c ∈ ['M', 'D', 'C', 'L', 'X', 'V', 'I']) :\n\
  \  solution roman = solution (toString c) * roman.length := sorry\n\n\ntheorem subtractive_pairs_less\
  \ :\n  solution \"IV\" < solution \"VI\" ∧\n  solution \"IX\" < solution \"XI\"\
  \ ∧ \n  solution \"XL\" < solution \"LX\" ∧\n  solution \"XC\" < solution \"CX\"\
  \ ∧\n  solution \"CD\" < solution \"DC\" ∧\n  solution \"CM\" < solution \"MC\"\
  \ := sorry"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible"
