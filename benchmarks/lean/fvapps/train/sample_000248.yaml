"vc-description": "There is a one-dimensional garden on the x-axis. The garden starts\
  \ at the point 0 and ends at the point n. (i.e The length of the garden is n).\n\
  There are n + 1 taps located at points [0, 1, ..., n] in the garden.\nGiven an integer\
  \ n and an integer array ranges of length n + 1 where ranges[i] (0-indexed) means\
  \ the i-th tap can water the area [i - ranges[i], i + ranges[i]] if it was open.\n\
  Return the minimum number of taps that should be open to water the whole garden,\
  \ If the garden cannot be watered return -1.\n \nExample 1:\n\nInput: n = 5, ranges\
  \ = [3,4,1,1,0,0]\nOutput: 1\nExplanation: The tap at point 0 can cover the interval\
  \ [-3,3]\nThe tap at point 1 can cover the interval [-3,5]\nThe tap at point 2 can\
  \ cover the interval [1,3]\nThe tap at point 3 can cover the interval [2,4]\nThe\
  \ tap at point 4 can cover the interval [4,4]\nThe tap at point 5 can cover the\
  \ interval [5,5]\nOpening Only the second tap will water the whole garden [0,5]\n\
  \nExample 2:\nInput: n = 3, ranges = [0,0,0,0]\nOutput: -1\nExplanation: Even if\
  \ you activate all the four taps you cannot water the whole garden.\n\nExample 3:\n\
  Input: n = 7, ranges = [1,2,1,0,2,1,0,1]\nOutput: 3\n\nExample 4:\nInput: n = 8,\
  \ ranges = [4,0,0,0,0,0,0,0,4]\nOutput: 2\n\nExample 5:\nInput: n = 8, ranges =\
  \ [4,0,0,0,4,0,0,0,4]\nOutput: 1\n\n \nConstraints:\n\n1 <= n <= 10^4\nranges.length\
  \ == n + 1\n0 <= ranges[i] <= 100"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def minTaps (n: Nat) (ranges: List Nat) : Int :=\n  sorry\n"
"vc-theorems": "theorem empty_ranges_theorem (n: Nat) (h: n ≥ 1) (h2: n ≤ 100):\n\
  \  minTaps n (List.replicate (n+1) 0) = -1 := sorry\n\n\ntheorem full_coverage_theorem\
  \ (n: Nat) (h: n ≥ 1) (h2: n ≤ 100):\n  let ranges := (List.replicate (n+1) 0).set\
  \ 0 n\n  minTaps n ranges = 1 := sorry \n\n\ntheorem alternating_ranges_theorem\
  \ (n: Nat) (h: n ≥ 1) (h2: n ≤ 100):\n  let ranges := List.range (n+1) |>.map (fun\
  \ i => if i % 2 = 0 then 1 else 0)\n  minTaps n ranges = -1 ∨ minTaps n ranges ≥\
  \ n/2 := sorry\n\n\ntheorem basic_properties_theorem (n: Nat) (ranges: List Nat)\
  \ \n  (h: n ≥ 1) (h2: n ≤ 100) (h3: ranges.length = n+1):\n  minTaps n ranges =\
  \ -1 ∨ minTaps n ranges ≥ 1 := sorry\n\n\ntheorem all_zeros_theorem (n: Nat) (ranges:\
  \ List Nat)\n  (h: n ≥ 1) (h2: n ≤ 100) (h3: ranges.length = n+1)\n  (h4: ranges.all\
  \ (fun x => x = 0)):\n  minTaps n ranges = -1 := sorry\n\n/--\ninfo: 1\n-/\n#guard_msgs\
  \ in\n#eval minTaps 5 [3, 4, 1, 1, 0, 0]\n\n/--\ninfo: -1\n-/\n#guard_msgs in\n\
  #eval minTaps 3 [0, 0, 0, 0]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval minTaps\
  \ 7 [1, 2, 1, 0, 2, 1, 0, 1]\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
