"vc-description": "You will have a list of rationals in the form\n\n```\nlst = [ [numer_1,\
  \ denom_1] , ... , [numer_n, denom_n] ]\n```\nor\n```\nlst = [ (numer_1, denom_1)\
  \ , ... , (numer_n, denom_n) ]\n```\n\nwhere all numbers are positive integers.\
  \ You have to produce their sum `N / D` in an irreducible form: this means that\
  \ `N` and `D` have only `1` as a common divisor.\n\nReturn the result in the form:\n\
  \n- `[N, D]` in Ruby, Crystal, Python, Clojure, JS, CS, PHP, Julia\n- `Just \"N\
  \ D\"` in Haskell, PureScript\n- `\"[N, D]\"` in Java, CSharp, TS, Scala, PowerShell,\
  \ Kotlin\n- `\"N/D\"` in Go, Nim\n- `{N, D}` in C++, Elixir\n- `{N, D}` in C\n-\
  \ `Some((N, D))` in Rust\n- `Some \"N D\"` in F#, Ocaml\n- `c(N, D)` in R\n- `(N,\
  \ D)` in Swift\n- `'(N D)` in Racket\n\nIf the result is an integer (`D` evenly\
  \ divides `N`) return:\n\n- an integer in Ruby, Crystal, Elixir, Clojure, Python,\
  \ JS, CS, PHP, R, Julia\n- `Just \"n\"` (Haskell, PureScript)\n- `\"n\"` Java, CSharp,\
  \ TS, Scala, PowerShell, Go, Nim, Kotlin\n- `{n, 1}` in C++\n- `{n, 1}` in C\n-\
  \ `Some((n, 1))` in Rust\n- `Some \"n\"` in F#, Ocaml,\n- `(n, 1)` in Swift\n- `n`\
  \ in Racket \n\nIf the input list is empty, return \n\n- `nil/None/null/Nothing`\
  \ \n- `{0, 1}` in C++\n- `{0, 1}` in C\n- `\"0\"` in Scala, PowerShell, Go, Nim\n\
  - `O` in Racket\n- `\"\"` in Kotlin\n\n\n### Example:\n\n```\n[ [1, 2], [1, 3],\
  \ [1, 4] ]  -->  [13, 12]\n\n    1/2  +  1/3  +  1/4     =      13/12\n```\n\n###\
  \ Note\nSee sample tests for more examples and the form of results."
"vc-preamble": "import Imports.AllImports\n\ndef sumFracts (lst : List (Int × Nat))\
  \ : Option (Int ⊕ (Int × Nat)) := sorry\n\ntheorem sum_fracts_empty : \n  sumFracts\
  \ [] = none := sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def addFractions (f1 f2 : Fraction) : Fraction := sorry\n\ntheorem\
  \ sum_fracts_preserves_value (lst : List (Int × Nat)) (h : ∀ p : Int × Nat, p ∈\
  \ lst → p.2 > 0) :\n  match sumFracts lst with\n  | none => lst = []\n  | some (Sum.inl\
  \ n) => Fraction.mk n 1 = lst.foldr (fun p acc => addFractions acc (Fraction.mk\
  \ p.1 p.2)) (Fraction.mk 0 1)\n  | some (Sum.inr (n,d)) => Fraction.mk n d = lst.foldr\
  \ (fun p acc => addFractions acc (Fraction.mk p.1 p.2)) (Fraction.mk 0 1)\n  :=\
  \ sorry\n"
"vc-theorems": "theorem sum_fracts_single (n : Int) (d : Nat) (h : d > 0) :\n  sumFracts\
  \ [(n,d)] = if d = 1 \n    then some (Sum.inl n)\n    else some (Sum.inr (n,d))\
  \ := sorry\n\n\ntheorem sum_fracts_result_form (lst : List (Int × Nat)) (h : ∀ p\
  \ : Int × Nat, p ∈ lst → p.2 > 0) :\n  match lst with\n  | [] => sumFracts lst =\
  \ none\n  | _ => ∃ n d, (sumFracts lst = some (Sum.inl n) ∧ d = 1) ∨ \n        \
  \        (sumFracts lst = some (Sum.inr (n,d)) ∧ d > 1)\n  := sorry\n\n/--\ninfo:\
  \ [13, 12]\n-/\n#guard_msgs in\n#eval sum_fracts [[1, 2], [1, 3], [1, 4]]\n\n/--\n\
  info: 2\n-/\n#guard_msgs in\n#eval sum_fracts [[1, 3], [5, 3]]\n\n/--\ninfo: None\n\
  -/\n#guard_msgs in\n#eval sum_fracts []\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
