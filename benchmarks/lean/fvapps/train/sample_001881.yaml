"vc-description": "Print a binary tree in an m*n 2D string array following these rules:\
  \ \n\n\nThe row number m should be equal to the height of the given binary tree.\n\
  The column number n should always be an odd number.\nThe root node's value (in string\
  \ format) should be put in the exactly middle of the first row it can be put. The\
  \ column and the row where the root node belongs will separate the rest space into\
  \ two parts (left-bottom part and right-bottom part). You should print the left\
  \ subtree in the left-bottom part and print the right subtree in the right-bottom\
  \ part. The left-bottom part and the right-bottom part should have the same size.\
  \ Even if one subtree is none while the other is not, you don't need to print anything\
  \ for the none subtree but still need to leave the space as large as that for the\
  \ other subtree. However, if two subtrees are none, then you don't need to leave\
  \ space for both of them. \nEach unused space should contain an empty string \"\"\
  .\nPrint the subtrees following the same rules.\n\n\nExample 1:\n\nInput:\n    \
  \ 1\n    /\n   2\nOutput:\n[[\"\", \"1\", \"\"],\n [\"2\", \"\", \"\"]]\n\n\n\n\n\
  Example 2:\n\nInput:\n     1\n    / \\\n   2   3\n    \\\n     4\nOutput:\n[[\"\"\
  , \"\", \"\", \"1\", \"\", \"\", \"\"],\n [\"\", \"2\", \"\", \"\", \"\", \"3\"\
  , \"\"],\n [\"\", \"\", \"4\", \"\", \"\", \"\", \"\"]]\n\n\n\nExample 3:\n\nInput:\n\
  \      1\n     / \\\n    2   5\n   / \n  3 \n / \n4 \nOutput:\n\n[[\"\",  \"\",\
  \  \"\", \"\",  \"\", \"\", \"\", \"1\", \"\",  \"\",  \"\",  \"\",  \"\", \"\"\
  , \"\"]\n [\"\",  \"\",  \"\", \"2\", \"\", \"\", \"\", \"\",  \"\",  \"\",  \"\"\
  ,  \"5\", \"\", \"\", \"\"]\n [\"\",  \"3\", \"\", \"\",  \"\", \"\", \"\", \"\"\
  ,  \"\",  \"\",  \"\",  \"\",  \"\", \"\", \"\"]\n [\"4\", \"\",  \"\", \"\",  \"\
  \", \"\", \"\", \"\",  \"\",  \"\",  \"\",  \"\",  \"\", \"\", \"\"]]\n\n\n\nNote:\n\
  The height of binary tree is in the range of [1, 10]."
"vc-preamble": "import Imports.AllImports\n\ndef TreeNode.val : TreeNode → Nat\n \
  \ | mk v _ _ => v\n\n\ndef print_tree : Option TreeNode → List (List String)\n \
  \ | none => []\n  | some _ => sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def get_tree_height : Option TreeNode → Nat → Nat\n  | none, _\
  \ => 0\n  | some _, _ => sorry\n"
"vc-theorems": "theorem print_tree_props {t : TreeNode} :\n  let result := print_tree\
  \ (some t)\n  -- Result is non-empty list of lists\n  (result.length > 0) ∧\n  --\
  \ All rows have same width\n  (∀ row ∈ result, row.length = result.head!.length)\
  \ ∧\n  -- Width is 2^height - 1\n  (result.head!.length = (2^(get_tree_height (some\
  \ t) 0)) - 1) ∧\n  -- Root in middle of first row\n  (result.head!.get! (result.head!.length/2)\
  \ = toString (TreeNode.val t)) ∧\n  -- Non-empty spots are digits\n  (∀ row ∈ result,\
  \ ∀ x ∈ row, x ≠ \"\" → x.all Char.isDigit) := by\n  sorry\n\n\ntheorem get_tree_height_props\
  \ {t : TreeNode} :\n  -- Height is positive for non-empty trees\n  get_tree_height\
  \ (some t) 0 > 0 ∧\n  -- Height larger than subtrees\n  match t with\n  | TreeNode.mk\
  \ _ l r =>\n    ((l.map (get_tree_height · 0)).getD 0 < get_tree_height (some t)\
  \ 0) ∧\n    ((r.map (get_tree_height · 0)).getD 0 < get_tree_height (some t) 0)\
  \ ∧\n    (l.isNone ∧ r.isNone → get_tree_height (some t) 0 = 1)\n  := by\n  sorry\n\
  \n\ntheorem print_empty_tree :\n  print_tree none = [] := by\n  sorry\n\n/--\ninfo:\
  \ [['', '1', ''], ['2', '', '']]\n-/\n#guard_msgs in\n#eval print_tree TreeNode(1)\n\
  \n/--\ninfo: [['', '', '', '1', '', '', ''], ['', '2', '', '', '', '3', ''], ['',\
  \ '', '4', '', '', '', '']]\n-/\n#guard_msgs in\n#eval print_tree TreeNode(1)\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
