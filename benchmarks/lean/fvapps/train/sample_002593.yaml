vc-description: |-
  Given an integer, if the length of it's digits is a perfect square, return a square block of sqroot(length) * sqroot(length). If not, simply return "Not a perfect square!".

  Examples:

  1212 returns:

  >1212  

  Note: 4 digits so 2 squared (2x2 perfect square). 2 digits on each line.

  123123123 returns: 
  >123123123

  Note: 9 digits so 3 squared (3x3 perfect square). 3 digits on each line.
vc-preamble: |
  import Imports.AllImports

  def squareIt (n : Nat) : String := sorry

  def isPerfectSquare (n : Nat) : Bool := sorry


  def hasEqualRows (s : String) : Bool := sorry

  def isqrt (n : Nat) : Nat := sorry 
vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>
vc-definitions: |
  def splitLines (s : String) : List String := 
    String.splitOn s "\n"
vc-theorems: |
  theorem square_it_properties (n : Nat) : 
    n ≤ 10^12 →
    let digits := toString n
    if isPerfectSquare (digits.length) then
      let result := squareIt n
      result ≠ "Not a perfect square!" ∧ 
      hasEqualRows result ∧
      let sideLength := isqrt (digits.length)
      (splitLines result).length = sideLength ∧
      (∀ row ∈ splitLines result, row.length = sideLength) ∧
      String.join (splitLines result) = digits
    else
      squareIt n = "Not a perfect square!"
    := sorry


  theorem square_it_repeating_ones (n : Nat) (k : Nat) :
    k ≥ 1 →
    k ≤ 4 →
    n = (10^(k*k) - 1)/9 →  -- represents number with k*k ones
    let result := squareIt n
    result ≠ "Not a perfect square!" ∧
    let rows := splitLines result
    ∀ row ∈ rows, match rows.head? with
                  | none => True 
                  | some first => row = first
    := sorry

  /--
  info: '12\n12'
  -/
  #guard_msgs in
  #eval square_it 1212

  /--
  info: '123\n123\n123'
  -/
  #guard_msgs in
  #eval square_it 123123123

  /--
  info: 'Not a perfect square!'
  -/
  #guard_msgs in
  #eval square_it 12345
vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded
