"vc-description": "After Misha's birthday he had many large numbers left, scattered\
  \ across the room. Now it's time to clean up and Misha needs to put them in a basket.\
  \ He ordered this task to his pet robot that agreed to complete the task at certain\
  \ conditions. Before the robot puts a number x to the basket, Misha should answer\
  \ the question: is it possible to choose one or multiple numbers that already are\
  \ in the basket, such that their XOR sum equals x? \n\nIf the answer is positive,\
  \ you also need to give the indexes of these numbers. If there are multiple options\
  \ of choosing numbers, you are allowed to choose any correct option. After Misha's\
  \ answer the robot puts the number to the basket.\n\nInitially the basket is empty.\
  \ Each integer you put in the basket takes some number. The first integer you put\
  \ into the basket take number 0, the second integer takes number 1 and so on.\n\n\
  Misha needs to clean up the place as soon as possible but unfortunately, he isn't\
  \ that good at mathematics. He asks you to help him.\n\n\n-----Input-----\n\nThe\
  \ first line contains number m (1 ≤ m ≤ 2000), showing how many numbers are scattered\
  \ around the room.\n\nThe next m lines contain the numbers in the order in which\
  \ the robot puts them in the basket. Each number is a positive integer strictly\
  \ less than 10^600 that doesn't contain leading zeroes. \n\n\n-----Output-----\n\
  \nFor each number either print a 0 on the corresponding line, if the number cannot\
  \ be represented as a XOR sum of numbers that are in the basket, or print integer\
  \ k showing how many numbers are in the representation and the indexes of these\
  \ numbers. Separate the numbers by spaces. Each number can occur in the representation\
  \ at most once.\n\n\n-----Examples-----\nInput\n7\n7\n6\n5\n4\n3\n2\n1\n\nOutput\n\
  0\n0\n0\n3 0 1 2\n2 1 2\n2 0 2\n2 0 1\n\nInput\n2\n5\n5\n\nOutput\n0\n1 0\n\n\n\n\
  -----Note-----\n\nThe XOR sum of numbers is the result of bitwise sum of numbers\
  \ modulo 2."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def solve_xor_basket (nums: List Nat) : List String :=\n  sorry\n"
"vc-theorems": "theorem result_format {nums: List Nat} (h1: nums.length > 0) \n  (h2:\
  \ ∀ x ∈ nums, 1 ≤ x ∧ x ≤ 1000) :\n  let result := solve_xor_basket nums\n  (result.length\
  \ = nums.length) ∧ \n  (∀ r ∈ result, \n    r = \"0\" ∨ \n    (let parts := r.split\
  \ (· = ' ')\n     let count := parts.head!.toNat!\n     parts.length = count + 1\
  \ ∧\n     (∀ i ∈ parts.tail, \n       let idx := i.toNat!\n       0 ≤ idx ∧ idx\
  \ < nums.length) ∧\n     parts.tail.eraseDups = parts.tail)) :=\n  sorry\n\n\ntheorem\
  \ xor_property {nums: List Nat} (h1: nums.length > 0)\n  (h2: ∀ x ∈ nums, 1 ≤ x\
  \ ∧ x ≤ 1000) :\n  let result := solve_xor_basket nums\n  ∀ i, i < nums.length →\n\
  \    (result[i]? = some \"0\") ∨\n    (∃ parts : List String,\n     parts = (result[i]?).get!.split\
  \ (· = ' ') ∧\n     ∃ indices : List Nat,\n     indices = parts.tail.map (·.toNat!)\
  \ ∧\n     (∀ idx ∈ indices, idx < nums.length) ∧\n     let xor_result := indices.foldl\
  \ (fun acc idx => Nat.xor acc (nums.get! idx)) 0\n     xor_result = nums[i]?) :=\n\
  \  sorry"
"vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded"
