"vc-description": "We have a permutation of the integers from 1 through N, p_1, p_2,\
  \ .., p_N.\nWe also have M pairs of two integers between 1 and N (inclusive), represented\
  \ as (x_1,y_1), (x_2,y_2), .., (x_M,y_M).\nAtCoDeer the deer is going to perform\
  \ the following operation on p as many times as desired so that the number of i\
  \ (1 ≤ i ≤ N) such that p_i = i is maximized:\n - Choose j such that 1 ≤ j ≤ M,\
  \ and swap p_{x_j} and p_{y_j}.\nFind the maximum possible number of i such that\
  \ p_i = i after operations.\n\n-----Constraints-----\n - 2 ≤ N ≤ 10^5\n - 1 ≤ M\
  \ ≤ 10^5\n - p is a permutation of integers from 1 through N.\n - 1 ≤ x_j,y_j ≤\
  \ N\n - x_j ≠ y_j\n - If i ≠ j, \\{x_i,y_i\\} ≠ \\{x_j,y_j\\}.\n - All values in\
  \ input are integers.\n\n-----Input-----\nInput is given from Standard Input in\
  \ the following format:\nN M\np_1 p_2 .. p_N\nx_1 y_1\nx_2 y_2\n:\nx_M y_M\n\n-----Output-----\n\
  Print the maximum possible number of i such that p_i = i after operations.\n\n-----Sample\
  \ Input-----\n5 2\n5 3 1 4 2\n1 3\n5 4\n\n-----Sample Output-----\n2\n\nIf we perform\
  \ the operation by choosing j=1, p becomes 1 3 5 4 2, which is optimal, so the answer\
  \ is 2."
"vc-preamble": "import Imports.AllImports\n\ndef UnionFind.new (n : Nat) : UnionFind\
  \ := sorry\ndef UnionFind.isConnected (uf : UnionFind) (x y : Nat) : Bool := sorry\n\
  \ndef UnionFind.unite (uf : UnionFind) (x y : Nat) : UnionFind := sorry\ndef solve\
  \ (n m : Nat) (p : List Nat) (swaps : List (Nat × Nat)) : Nat := sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def isValidPerm (arr : List Nat) : Bool := sorry\n\ntheorem solve_permutation_property\
  \ (p : List Nat) \n  (h1 : p.length ≤ 20) (h2 : p.length > 0)\n  (h3 : isValidPerm\
  \ (p.map (·-1)) = true) :\n  let n := p.length;\n  let result := solve n 0 p [];\n\
  \  0 ≤ result ∧ result ≤ n := by sorry"
"vc-theorems": "theorem UnionFind_init (n : Nat) (h : 0 < n) (h2 : n ≤ 100) :\n  let\
  \ uf := UnionFind.new n;\n  Array.size (UnionFind.size uf) = n ∧ \n  Array.size\
  \ (UnionFind.parent uf) = n ∧\n  (∀ i, i < n → (UnionFind.size uf)[i]! = 1) ∧\n\
  \  (∀ i, i < n → (UnionFind.parent uf)[i]! = i) := by sorry\n\n\ntheorem UnionFind_reflexive\
  \ (n : Nat) (h : 0 < n) (h2 : n ≤ 100) :\n  let uf := UnionFind.new n;\n  ∀ i, i\
  \ < n → UnionFind.isConnected uf i i = true := by sorry\n\n\ntheorem UnionFind_symmetry\
  \ (n : Nat) (h : 1 < n) (h2 : n ≤ 100) :\n  let uf := UnionFind.new n;\n  ∀ i, i\
  \ < n-1 → \n    let uf' := UnionFind.unite uf i (i+1);\n    UnionFind.isConnected\
  \ uf' i (i+1) = true ∧ \n    UnionFind.isConnected uf' (i+1) i = true := by sorry\n\
  \n\ntheorem solve_no_swaps (n m : Nat) (h1 : 0 < n) (h2 : n ≤ 20) (h3 : m ≤ 10)\
  \ :\n  let p := List.range n;\n  let swaps := [];\n  solve n m (p.map (·+1)) swaps\
  \ = n := by sorry\n\n\ntheorem solve_valid_swaps (n : Nat) (swaps : List (Nat ×\
  \ Nat)) \n  (h1 : 0 < n) (h2 : n ≤ 20) (h3 : swaps.length ≤ 10) :\n  let p := List.range\
  \ n |>.map (·+1);\n  let result := solve n swaps.length p swaps;\n  0 ≤ result ∧\
  \ result ≤ n := by sorry\n\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval solve 5 2\
  \ #[5, 3, 1, 4, 2] #[(1, 3), (5, 4)]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval\
  \ solve 3 2 #[3, 2, 1] #[(1, 2), (2, 3)]\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval\
  \ solve 5 1 #[1, 2, 3, 4, 5] #[(1, 5)]\n"
"vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded"
