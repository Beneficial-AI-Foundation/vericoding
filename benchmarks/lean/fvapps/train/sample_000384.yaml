"vc-description": "Given a non-empty integer array, find the minimum number of moves\
  \ required to make all array elements equal, where a move is incrementing a selected\
  \ element by 1 or decrementing a selected element by 1.\n\nYou may assume the array's\
  \ length is at most 10,000.\n\nExample:\n\nInput:\n[1,2,3]\n\nOutput:\n2\n\nExplanation:\n\
  Only two moves are needed (remember each move increments or decrements one element):\n\
  \n[1,2,3]  =>  [2,2,3]  =>  [2,2,2]"
"vc-preamble": "import Imports.AllImports\n\ndef min_moves_to_equal (nums : List Int)\
  \ : Nat :=\n  sorry\n\n\ndef abs (x : Int) : Nat :=\n  sorry\n\n\ndef sort (nums\
  \ : List Int) : List Int :=\n  sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def median (nums : List Int) : Int :=\n  sorry\n"
"vc-theorems": "theorem min_moves_non_negative (nums : List Int) : \n  0 ≤ min_moves_to_equal\
  \ nums := sorry\n\n\ntheorem min_moves_equal_median (nums : List Int) (h : nums\
  \ ≠ []) : \n  min_moves_to_equal nums = nums.foldl (fun acc x => acc + abs (x -\
  \ median nums)) 0 := sorry\n\n\ntheorem identical_nums_zero_moves (n : Int) (nums\
  \ : List Int) (h : ∀ x ∈ nums, x = n) :\n  min_moves_to_equal nums = 0 := sorry\n\
  \n\ntheorem order_invariant (nums : List Int) :\n  min_moves_to_equal nums = min_moves_to_equal\
  \ (sort nums) := sorry\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval min_moves_to_equal\
  \ [1, 2, 3]\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval min_moves_to_equal [1, 1,\
  \ 1]\n\n/--\ninfo: 16\n-/\n#guard_msgs in\n#eval min_moves_to_equal [1, 10, 2, 9]\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
