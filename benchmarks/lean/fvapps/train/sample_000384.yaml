vc-description: |-
  Given a non-empty integer array, find the minimum number of moves required to make all array elements equal, where a move is incrementing a selected element by 1 or decrementing a selected element by 1.

  You may assume the array's length is at most 10,000.

  Example:

  Input:
  [1,2,3]

  Output:
  2

  Explanation:
  Only two moves are needed (remember each move increments or decrements one element):

  [1,2,3]  =>  [2,2,3]  =>  [2,2,2]
vc-preamble: |
  import Imports.AllImports

  def min_moves_to_equal (nums : List Int) : Nat :=
    sorry


  def abs (x : Int) : Nat :=
    sorry


  def sort (nums : List Int) : List Int :=
    sorry
vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>
vc-definitions: |
  def median (nums : List Int) : Int :=
    sorry
vc-theorems: |
  theorem min_moves_non_negative (nums : List Int) : 
    0 ≤ min_moves_to_equal nums := sorry


  theorem min_moves_equal_median (nums : List Int) (h : nums ≠ []) : 
    min_moves_to_equal nums = nums.foldl (fun acc x => acc + abs (x - median nums)) 0 := sorry


  theorem identical_nums_zero_moves (n : Int) (nums : List Int) (h : ∀ x ∈ nums, x = n) :
    min_moves_to_equal nums = 0 := sorry


  theorem order_invariant (nums : List Int) :
    min_moves_to_equal nums = min_moves_to_equal (sort nums) := sorry

  /--
  info: 2
  -/
  #guard_msgs in
  #eval min_moves_to_equal [1, 2, 3]

  /--
  info: 0
  -/
  #guard_msgs in
  #eval min_moves_to_equal [1, 1, 1]

  /--
  info: 16
  -/
  #guard_msgs in
  #eval min_moves_to_equal [1, 10, 2, 9]
vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded
