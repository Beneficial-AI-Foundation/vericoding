"vc-description": "We are given a linked list with head as the first node.  Let's\
  \ number the nodes in the list: node_1, node_2, node_3, ... etc.\nEach node may\
  \ have a next larger value: for node_i, next_larger(node_i) is the node_j.val such\
  \ that j > i, node_j.val > node_i.val, and j is the smallest possible choice.  If\
  \ such a j does not exist, the next larger value is 0.\nReturn an array of integers answer,\
  \ where answer[i] = next_larger(node_{i+1}).\nNote that in the example inputs (not\
  \ outputs) below, arrays such as [2,1,5] represent the serialization of a linked\
  \ list with a head node value of 2, second node value of 1, and third node value\
  \ of 5.\n \n\nExample 1:\nInput: [2,1,5]\nOutput: [5,5,0]\n\n\nExample 2:\nInput:\
  \ [2,7,4,3,5]\nOutput: [7,0,5,5,0]\n\n\nExample 3:\nInput: [1,7,5,1,9,2,5,1]\nOutput:\
  \ [7,9,9,9,0,5,0,0]\n\n \nNote:\n\n1 <= node.val <= 10^9 for each node in the linked\
  \ list.\nThe given list has length in the range [0, 10000]."
"vc-preamble": "import Imports.AllImports\n\ndef nextLargerNodes (head : Option ListNode)\
  \ : List Nat :=\n  sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def isDecreasing (l : List Nat) : Prop :=\n  ∀ i j, i < j → j <\
  \ l.length → l.get! i ≥ l.get! j\n"
"vc-theorems": "theorem empty_list :\n  nextLargerNodes none = [] ∧\n  nextLargerNodes\
  \ (some (ListNode.mk 0 none)) = [] :=\n  sorry\n\n\ntheorem single_node (v : Nat)\
  \ :\n  nextLargerNodes (some (ListNode.mk v none)) = [0] :=\n  sorry\n\n\ntheorem\
  \ output_length_matches_input {vals : List Nat} {head : Option ListNode} :\n  nextLargerNodes\
  \ head = vals → List.length (nextLargerNodes head) = List.length vals :=\n  sorry\n\
  \n\ntheorem output_zero_or_greater {vals : List Nat} {head : Option ListNode} {i\
  \ : Nat} :\n  i < List.length vals →\n  match (nextLargerNodes head).get? i with\n\
  \  | some x => x = 0 ∨ x > vals.get! i\n  | none => True\n  :=\n  sorry\n\n\ntheorem\
  \ output_values_in_input {vals : List Nat} {head : Option ListNode} {x : Nat} :\n\
  \  x ∈ nextLargerNodes head → x = 0 ∨ x ∈ vals :=\n  sorry\n\n\ntheorem nonzero_has_larger_after\
  \ {vals : List Nat} {head : Option ListNode} {i : Nat} :\n  i < List.length vals\
  \ →\n  (nextLargerNodes head).get! i ≠ 0 →\n  ∃ j, j > i ∧ j < List.length vals\
  \ ∧ vals.get! j ≥ (nextLargerNodes head).get! i :=\n  sorry\n\n\ntheorem decreasing_list_gives_zeros\
  \ {vals : List Nat} {head : Option ListNode} :\n  List.length vals ≥ 2 →\n  isDecreasing\
  \ vals →\n  nextLargerNodes head = List.replicate (List.length vals) 0 :=\n  sorry\n\
  \n/--\ninfo: [5, 5, 0]\n-/\n#guard_msgs in\n#eval nextLargerNodes create_linked_list([2,\
  \ 1, 5])\n\n/--\ninfo: [7, 0, 5, 5, 0]\n-/\n#guard_msgs in\n#eval nextLargerNodes\
  \ create_linked_list([2, 7, 4, 3, 5])\n\n/--\ninfo: [7, 9, 9, 9, 0, 5, 0, 0]\n-/\n\
  #guard_msgs in\n#eval nextLargerNodes create_linked_list([1, 7, 5, 1, 9, 2, 5, 1])\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
