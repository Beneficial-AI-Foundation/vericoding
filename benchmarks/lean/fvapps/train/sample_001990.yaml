"vc-description": "Maxim always goes to the supermarket on Sundays. Today the supermarket\
  \ has a special offer of discount systems.\n\nThere are m types of discounts. We\
  \ assume that the discounts are indexed from 1 to m. To use the discount number\
  \ i, the customer takes a special basket, where he puts exactly q_{i} items he buys.\
  \ Under the terms of the discount system, in addition to the items in the cart the\
  \ customer can receive at most two items from the supermarket for free. The number\
  \ of the \"free items\" (0, 1 or 2) to give is selected by the customer. The only\
  \ condition imposed on the selected \"free items\" is as follows: each of them mustn't\
  \ be more expensive than the cheapest item out of the q_{i} items in the cart.\n\
  \nMaxim now needs to buy n items in the shop. Count the minimum sum of money that\
  \ Maxim needs to buy them, if he use the discount system optimally well.\n\nPlease\
  \ assume that the supermarket has enough carts for any actions. Maxim can use the\
  \ same discount multiple times. Of course, Maxim can buy items without any discounts.\n\
  \n\n-----Input-----\n\nThe first line contains integer m (1 ≤ m ≤ 10^5) — the number\
  \ of discount types. The second line contains m integers: q_1, q_2, ..., q_{m} (1\
  \ ≤ q_{i} ≤ 10^5). \n\nThe third line contains integer n (1 ≤ n ≤ 10^5) — the number\
  \ of items Maxim needs. The fourth line contains n integers: a_1, a_2, ..., a_{n}\
  \ (1 ≤ a_{i} ≤ 10^4) — the items' prices.\n\nThe numbers in the lines are separated\
  \ by single spaces.\n\n\n-----Output-----\n\nIn a single line print a single integer\
  \ — the answer to the problem.\n\n\n-----Examples-----\nInput\n1\n2\n4\n50 50 100\
  \ 100\n\nOutput\n200\n\nInput\n2\n2 3\n5\n50 50 50 50 50\n\nOutput\n150\n\nInput\n\
  1\n1\n7\n1 1 1 1 1 1 1\n\nOutput\n3\n\n\n\n-----Note-----\n\nIn the first sample\
  \ Maxim needs to buy two items that cost 100 and get a discount for two free items\
  \ that cost 50. In that case, Maxim is going to pay 200.\n\nIn the second sample\
  \ the best strategy for Maxim is to buy 3 items and get 2 items for free using the\
  \ discount. In that case, Maxim is going to pay 150."
"vc-preamble": "import Imports.AllImports\n\ndef solve_discount_shopping (n_discounts\
  \ : Nat) (discount_values : List Nat) (n_items : Nat) (item_values : List Nat) :\
  \ Nat :=\n  sorry\n\n\ndef list_sum (l : List Nat) : Nat :=\n  match l with\n  |\
  \ [] => 0\n  | h :: t => h + list_sum t\n\n\ndef list_sort (l : List Nat) : List\
  \ Nat :=\n  sorry\n\n\ndef list_take (n : Nat) (l : List Nat) : List Nat :=\n  match\
  \ n, l with\n  | 0, _ => []\n  | _, [] => []\n  | n+1, h :: t => h :: list_take\
  \ n t\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def list_replicate (n : Nat) (v : Nat) : List Nat :=\n  match n\
  \ with\n  | 0 => []\n  | n+1 => v :: list_replicate n v\n"
"vc-theorems": "theorem discount_shopping_non_negative\n  (n_discounts : Nat)\n  (discount_values\
  \ : List Nat)\n  (n_items : Nat) \n  (item_values : List Nat)\n  (h1 : discount_values.length\
  \ = n_discounts)\n  (h2 : item_values.length = n_items)\n  (h3 : ∀ x ∈ discount_values,\
  \ 1 ≤ x ∧ x ≤ 10)\n  (h4 : ∀ x ∈ item_values, 1 ≤ x ∧ x ≤ 1000)\n  (h5 : 1 ≤ n_discounts\
  \ ∧ n_discounts ≤ 5)\n  (h6 : 1 ≤ n_items ∧ n_items ≤ 20) :\n  0 ≤ solve_discount_shopping\
  \ n_discounts discount_values n_items item_values :=\n  sorry\n\n\ntheorem discount_shopping_upper_bound\n\
  \  (n_discounts : Nat)\n  (discount_values : List Nat)\n  (n_items : Nat)\n  (item_values\
  \ : List Nat)\n  (h1 : discount_values.length = n_discounts)\n  (h2 : item_values.length\
  \ = n_items)\n  (h3 : ∀ x ∈ discount_values, 1 ≤ x ∧ x ≤ 10)\n  (h4 : ∀ x ∈ item_values,\
  \ 1 ≤ x ∧ x ≤ 1000)\n  (h5 : 1 ≤ n_discounts ∧ n_discounts ≤ 5)\n  (h6 : 1 ≤ n_items\
  \ ∧ n_items ≤ 20) :\n  solve_discount_shopping n_discounts discount_values n_items\
  \ item_values ≤ list_sum item_values :=\n  sorry\n\n\ntheorem discount_shopping_min_items\n\
  \  (n_discounts : Nat)\n  (discount_values : List Nat)\n  (n_items : Nat)\n  (item_values\
  \ : List Nat)\n  (h1 : discount_values.length = n_discounts)\n  (h2 : item_values.length\
  \ = n_items)\n  (h3 : ∀ x ∈ discount_values, 1 ≤ x ∧ x ≤ 10)\n  (h4 : ∀ x ∈ item_values,\
  \ 1 ≤ x ∧ x ≤ 1000)\n  (h5 : 1 ≤ n_discounts ∧ n_discounts ≤ 5)\n  (h6 : 1 ≤ n_items\
  \ ∧ n_items ≤ 20) :\n  let sorted_items := list_sort item_values\n  let min_disc\
  \ := match discount_values with\n                  | [] => n_items\n           \
  \       | h :: t => min h n_items\n  let min_items_sum := list_sum (list_take min_disc\
  \ sorted_items)\n  solve_discount_shopping n_discounts discount_values n_items item_values\
  \ ≥ min_items_sum :=\n  sorry\n\n\ntheorem identical_items_result\n  (n_discounts\
  \ : Nat)\n  (n_items : Nat)\n  (item_value : Nat)\n  (h1 : 1 ≤ n_discounts ∧ n_discounts\
  \ ≤ 5)\n  (h2 : 1 ≤ n_items ∧ n_items ≤ 5)\n  (h3 : 1 ≤ item_value ∧ item_value\
  \ ≤ 100) :\n  let discount_values := list_replicate n_discounts 2\n  let item_values\
  \ := list_replicate n_items item_value\n  let result := solve_discount_shopping\
  \ n_discounts discount_values n_items item_values\n  result % item_value = 0 ∧ result\
  \ ≤ item_value * n_items :=\n  sorry\n\n/--\ninfo: 200\n-/\n#guard_msgs in\n#eval\
  \ solve_discount_shopping 1 [2] 4 [50, 50, 100, 100]\n\n/--\ninfo: 150\n-/\n#guard_msgs\
  \ in\n#eval solve_discount_shopping 2 [2, 3] 5 [50, 50, 50, 50, 50]\n\n/--\ninfo:\
  \ 3\n-/\n#guard_msgs in\n#eval solve_discount_shopping 1 [1] 7 [1, 1, 1, 1, 1, 1,\
  \ 1]\n"
"vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded"
