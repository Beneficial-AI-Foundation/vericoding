"vc-description": "# An introduction to propositional logic\n\nLogic and proof theory\
  \ are fields that study the formalization of logical statements and the structure\
  \ of valid proofs. One of the most common ways to represent logical reasonings is\
  \ with **propositional logic**.\n\nA propositional formula is no more than what\
  \ you normally use in your *if statements*, but without functions or predicates.\
  \ The basic unit for these formulas are **literals**. Let's see some examples:\n\
  \n```\nf = p ∧ q\n```\n\nHere ```p``` and ```q``` would be the literals. This formula\
  \ means that *f* evaluates to ```True``` only when both ```p``` **and** ```q```\
  \ are True too. The ```∧``` operator is formally called **conjunction** and is often\
  \ called **and**.\n\n```\nf = p ∨ q\n```\n\nThis formula means that *f* evaluates\
  \ to ```True``` only when any of ```p``` **or** ```q``` are  True. This includes\
  \ the case when both are True. The ```∨``` operator is formally called **disjunction**\
  \ and is often called **or**.\n\n```\nf = ¬p\n```\n\nThe ```¬``` operator is analogous\
  \ to the **not** operation. it evaluates to True only when its argument evaluates\
  \ to False.\n\nNormally, there are also two other operators called **implication**\
  \ and **biconditional**, but we will ignore them for this kata (they can be expressed\
  \ in terms of the other three anyways).\n\nOnce we know this, can construct what\
  \ is called an **interpretation** in order to evaluate a propositional formula.\
  \ This is a fancy name for any structure that tells us which literals are False\
  \ and which ones are True. Normally, interpretations are given as a set:\n\n```python\n\
  p = Literal('p')\nq = Literal('q')\nr = Literal('r')\n\nf = p ∨ q ∨ ¬r\n\ni_1 =\
  \ {p, q} # p and q are True, r is False\ni_2 = {r}    # r is True, p and q are False\n\
  i_3 = {}     # p, q and r are False\n\n# Note: the 'evaluate' function is not given\n\
  evaluate(f, i_1) == True\nevaluate(f, i_2) == False\nevaluate(f, i_3) == True\n\
  ```\n\nAs you can see, if the literal is in the set, we say it evaluates to True,\
  \ else it is False.\n\nAs a final note, an interpretation that makes a formula True\
  \ is called a **model** when all the literals in the set appear in the formula.\n\
  \n# The SAT problem\n\nThis is a famous NP problem that is stated as follows:\n\n\
  > Given a propositional formula *F*, does it exist an interpretation such that it\
  \ evaluates to True? (i.e. is *F* **satisfiable**?)\n\nNumerous algorithms exist\
  \ for this purpose, and your task is to program one of them. Right now, you are\
  \ not supposed to program an efficient algorithm, but I may create a performance\
  \ version if this kata gets good reception :)\n\n# Specification\n\nProgram a ```sat(f:\
  \ Formula)``` function that returns the following:\n- ```False``` if ```f``` is\
  \ not satisfiable.\n- An interpretation that makes ```f``` evaluate to True in the\
  \ case that it is satisfiable.\n\n# Preloaded code\n\nYou are given a class ```Formula```\
  \ that has the following members:\n\n- ```args```: arguments of the operation if\
  \ the formula is not a literal (children nodes of the formula's tree). They are\
  \ given as a list of Formula objects that has one element in the case of the negation\
  \ operator and two or more elements in the case of the conjunction and disjunction\
  \ operators.\n- ```is_literal()```: True if the formula is a literal (i.e. not an\
  \ operation).\n- ```is_and()```: True if the formula is a **conjunction**.\n- ```is_or()```:\
  \ True if the formula is a **disjunction**. \n- ```is_not()```: True if the formula\
  \ is a **negation**. \n\nYou are also given a class ```Literal``` that extends from\
  \ ```Formula``` and has the following members:\n\n- ```name```: string that represents\
  \ the literal. Two literals with the same name **are the same literal**.\n*Note:\
  \ the rest of members are not guaranteed in the case of a literal*\n\nThe ```&```\
  \ operator is overloaded as the conjunction, ```|``` as the disjunction and ```~```\
  \ as the negation. Also, a ```__repr__``` function is given for debugging purposes.\n\
  \n# Extra examples\n\n```\nf = ¬(p ∨ q) # Satisfiable with {}\n```\n```\nf = ¬(p\
  \ ∧ q) # Satisfiable with {p}, {q} and {}\n```\n```\nf = p ∧ (q ∨ r) # Satisfiable\
  \ with {p, q}, {p, r} and {p, q, r}\n```\n```\nf = ¬p ∨ ¬q # Satisfiable with {p},\
  \ {q} and {} (See De Morgan's Laws)\n```\n```\nf = p ∧ ¬p # Not satisfiable\n```"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def sat (f : Formula) : Option Model := sorry\n\ntheorem sat_returns_model_or_false\
  \ (f : Formula) (m : Model) :\n  (sat f = some m) → ∀ s ∈ m, ∃ name, Formula.lit\
  \ name = Formula.lit s\n  := sorry\n"
"vc-theorems": "theorem not_p_and_p_unsatisfiable (p : Formula) :\n  sat (Formula.and\
  \ [p, Formula.not p]) = none \n  := sorry\n\n\ntheorem p_or_not_p_satisfiable (p\
  \ : Formula) :\n  sat (Formula.or [p, Formula.not p]) ≠ none\n  := sorry\n\n/--\n\
  info: False\n-/\n#guard_msgs in\n#eval sat Formula()\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
