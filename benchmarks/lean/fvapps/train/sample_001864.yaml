"vc-description": "We are given two arrays A and B of words.  Each word is a string\
  \ of lowercase letters.\nNow, say that word b is a subset of word a if every letter\
  \ in b occurs in a, including multiplicity.  For example, \"wrr\" is a subset of\
  \ \"warrior\", but is not a subset of \"world\".\nNow say a word a from A is universal\
  \ if for every b in B, b is a subset of a. \nReturn a list of all universal words\
  \ in A.  You can return the words in any order.\n \n\n\n\nExample 1:\nInput: A =\
  \ [\"amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"], B = [\"e\",\"o\"\
  ]\nOutput: [\"facebook\",\"google\",\"leetcode\"]\n\n\nExample 2:\nInput: A = [\"\
  amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"], B = [\"l\",\"e\"]\nOutput:\
  \ [\"apple\",\"google\",\"leetcode\"]\n\n\nExample 3:\nInput: A = [\"amazon\",\"\
  apple\",\"facebook\",\"google\",\"leetcode\"], B = [\"e\",\"oo\"]\nOutput: [\"facebook\"\
  ,\"google\"]\n\n\nExample 4:\nInput: A = [\"amazon\",\"apple\",\"facebook\",\"google\"\
  ,\"leetcode\"], B = [\"lo\",\"eo\"]\nOutput: [\"google\",\"leetcode\"]\n\n\nExample\
  \ 5:\nInput: A = [\"amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"], B\
  \ = [\"ec\",\"oc\",\"ceo\"]\nOutput: [\"facebook\",\"leetcode\"]\n\n \nNote:\n\n\
  1 <= A.length, B.length <= 10000\n1 <= A[i].length, B[i].length <= 10\nA[i] and\
  \ B[i] consist only of lowercase letters.\nAll words in A[i] are unique: there isn't\
  \ i != j with A[i] == A[j]."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def word_subsets (A B: List String) : List String := sorry\n\n\
  def count_char (c: Char) (s: String) : Nat := sorry\n"
"vc-theorems": "theorem word_subsets_result_subset\n  (A B: List String) \n  (result\
  \ := word_subsets A B) :\n  ∀ x, x ∈ result → x ∈ A := sorry\n\n\ntheorem word_subsets_letters_count\n\
  \  (A B: List String) \n  (result := word_subsets A B) :\n  ∀ w ∈ result, ∀ b_word\
  \ ∈ B, ∀ letter : Char, \n  let max_count := (List.map (fun b => count_char letter\
  \ b) B).maximum?\n  match max_count with\n  | some count => count_char letter w\
  \ ≥ count\n  | none => True := sorry\n\n\ntheorem word_subsets_single_word\n  (w:\
  \ String) :\n  let result := word_subsets [w] [(w.get! 0).toString]\n  (count_char\
  \ (w.get! 0) w ≥ 1) →\n  result = [w] := sorry\n\n/--\ninfo: sorted(['facebook',\
  \ 'google', 'leetcode'])\n-/\n#guard_msgs in\n#eval sorted word_subsets(A1, B1)\n\
  \n/--\ninfo: sorted(['apple', 'google', 'leetcode'])\n-/\n#guard_msgs in\n#eval\
  \ sorted word_subsets(A2, B2)\n\n/--\ninfo: sorted(['facebook', 'leetcode'])\n-/\n\
  #guard_msgs in\n#eval sorted word_subsets(A3, B3)\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
