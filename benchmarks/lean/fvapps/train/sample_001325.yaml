"vc-description": "Chef made $N$ pieces of cakes, numbered them $1$ through $N$ and\
  \ arranged them in a row in this order. There are $K$ possible types of flavours\
  \ (numbered $1$ through $K$); for each valid $i$, the $i$-th piece of cake has a\
  \ flavour $A_i$.\nChef wants to select a contiguous subsegment of the pieces of\
  \ cake such that there is at least one flavour which does not occur in that subsegment.\
  \ Find the maximum possible length of such a subsegment of cakes.\n\n-----Input-----\n\
  - The first line of the input contains a single integer $T$ denoting the number\
  \ of test cases. The description of $T$ test cases follows.\n- The first line of\
  \ each test case contains two integers $N$ and $K$.\n- The second line contains\
  \ $N$ space-separated integers $A_1, A_2, \\ldots, A_N$.\n\n-----Output-----\nFor\
  \ each test case, print a single line containing one integer ― the maximum length\
  \ of a valid subsegment.\n\n-----Constraints-----\n- $1 \\le T \\le 1,000$\n- $1\
  \ \\le N \\le 10^5$\n- $2 \\le K \\le 10^5$\n- $1 \\le A_i \\le K$ for each valid\
  \ $i$\n- the sum of $N$ over all test cases does not exceed $10^6$\n\n-----Subtasks-----\n\
  Subtask #1 (50 points):\n- $N \\le 10^3$\n- $K = 2$\n- the sum of $N$ over all test\
  \ cases does not exceed $10^4$\nSubtask #2 (50 points): original constraints\n\n\
  -----Example Input-----\n2\n6 2\n1 1 1 2 2 1\n5 3\n1 1 2 2 1\n\n-----Example Output-----\n\
  3\n5"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def findSmallestCommonMultiple (numbers : List Nat) : Nat := sorry\n\
  def findGreatestCommonFactor (numbers : List Nat) : Nat := sorry\n"
"vc-theorems": "theorem lcm_divisibility {numbers : List Nat} (h : numbers ≠ []) :\
  \ \n  ∀ n ∈ numbers, findSmallestCommonMultiple numbers % n = 0 := sorry\n\n\ntheorem\
  \ lcm_lower_bound {numbers : List Nat} (h : numbers ≠ []) : \n  findSmallestCommonMultiple\
  \ numbers ≥ (List.foldl Nat.max 0 numbers) := sorry\n\n\ntheorem gcf_divides {numbers\
  \ : List Nat} (h : numbers ≠ []) :\n  ∀ n ∈ numbers, n % findGreatestCommonFactor\
  \ numbers = 0 := sorry \n\n\ntheorem gcf_upper_bound {numbers : List Nat} (h : numbers\
  \ ≠ []) :\n  findGreatestCommonFactor numbers ≤ (List.foldl Nat.min (List.head!\
  \ numbers) (List.tail! numbers)) := sorry\n\n\ntheorem lcm_identity (n : Nat) :\n\
  \  findSmallestCommonMultiple [n] = n := sorry\n\n\ntheorem gcf_identity (n : Nat)\
  \ :\n  findGreatestCommonFactor [n] = n := sorry"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded"
