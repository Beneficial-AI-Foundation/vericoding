vc-description: |-
  Background
  There is a message that is circulating via public media that claims a reader can easily read a message where the inner letters of each words is scrambled, as long as the first and last letters remain the same and the word contains all the letters.

  Another example shows that it is quite difficult to read the text where all the letters are reversed rather than scrambled.

  In this kata we will make a generator that generates text in a similar pattern, but instead of scrambled or reversed, ours will be sorted alphabetically

  Requirement
  return a string where:
  1) the first and last characters remain in original place for each word
  2) characters between the first and last characters must be sorted alphabetically
  3) punctuation should remain at the same place as it started, for example: shan't -> sahn't
  Assumptions
  1) words are seperated by single spaces
  2) only spaces separate words, special characters do not,  for example: tik-tak -> tai-ktk
  3) special characters do not take the position of the non special characters, for example: -dcba  ->  -dbca
  4) for this kata puctuation is limited to 4 characters: hyphen(-), apostrophe('), comma(,) and period(.) 
  5) ignore capitalisation


  for reference: http://en.wikipedia.org/wiki/Typoglycemia
vc-preamble: |
  import Imports.AllImports

  def scramble_words (s : String) : String := sorry

  def is_alpha (c : Char) : Bool := sorry
vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>
vc-definitions: |
  def isOrdered (s : List Char) : Prop :=
    ∀ i j, i < j → j < s.length → s[i]! ≤ s[j]!
vc-theorems: |
  theorem scramble_length_preserved (s : String) :
    String.length (scramble_words s) = String.length s := sorry


  theorem first_last_letters_preserved (s : String) (word : String) (h : word.length > 1) 
      (pos_start : String.Pos) (pos_end : String.Pos) :
    is_alpha (word.get pos_start) → 
    is_alpha (word.get pos_end) →
    (scramble_words word).get pos_start = word.get pos_start ∧ 
    (scramble_words word).get pos_end = word.get pos_end := sorry


  theorem middle_chars_sorted (s : String) (h : s.length > 2)
      (pos_start : String.Pos) (pos_end : String.Pos) :
    is_alpha (s.get pos_start) →
    is_alpha (s.get pos_end) →
    let middle := (scramble_words s).data.drop 1 |>.take (s.length - 2)
    isOrdered middle := sorry


  theorem non_alpha_chars_preserved (s : String) :
    s.data.filter (fun c => ¬(is_alpha c)) = 
    (scramble_words s).data.filter (fun c => ¬(is_alpha c)) := sorry

  /--
  info: 'paefilnoorsss'
  -/
  #guard_msgs in
  #eval scramble_words "professionals"

  /--
  info: 'caac-dinrrryg'
  -/
  #guard_msgs in
  #eval scramble_words "card-carrying"

  /--
  info: "you've gotta dacne"
  -/
  #guard_msgs in
  #eval scramble_words "you"ve gotta dance"
vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded
