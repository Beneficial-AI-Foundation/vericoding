"vc-description": "Write a function that flattens an `Array` of `Array` objects into\
  \ a flat `Array`.  Your function must only do one level of flattening.\n\n```python\n\
  flatten [1,2,3] # => [1,2,3]\nflatten [[1,2,3],[\"a\",\"b\",\"c\"],[1,2,3]]  # =>\
  \ [1,2,3,\"a\",\"b\",\"c\",1,2,3]\nflatten [[[1,2,3]]] # => [[1,2,3]]\n```"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def flatten {α : Type} (lst : List (NestedList α)) : List α :=\
  \ sorry\n\ntheorem flatten_preserves_elements {α : Type} (lst : List (NestedList\
  \ α)) :\n  ∀ x ∈ lst, match x with\n  | NestedList.elem v => v ∈ flatten lst\n \
  \ | NestedList.list xs => ∀ y ∈ xs, match y with \n    | NestedList.elem v => v\
  \ ∈ flatten lst\n    | _ => True := sorry\n"
"vc-theorems": "theorem flatten_removes_one_level {α : Type} (lst : List (NestedList\
  \ α)) :\n  ∀ x ∈ lst, match x with\n  | NestedList.list xs => ∀ y ∈ xs, y ≠ NestedList.list\
  \ []\n  | _ => True →\n  ∀ z ∈ flatten lst, ∀ w, z ≠ w := sorry\n\n\ntheorem flatten_order_preserved\
  \ {α : Type} (lst : List (NestedList α)) :\n  flatten lst = lst.foldl (λ acc x =>\
  \ \n    match x with\n    | NestedList.elem v => acc ++ [v]\n    | NestedList.list\
  \ xs => acc ++ flatten xs\n  ) [] := sorry\n\n\ntheorem flatten_identity_flat_list\
  \ {α : Type} (lst : List α) :\n  flatten (lst.map NestedList.elem) = lst := sorry\n\
  \n/--\ninfo: [1, 2, 3, 4, 5, 6]\n-/\n#guard_msgs in\n#eval flatten [[1, 2, 3], [4,\
  \ 5, 6]]\n\n/--\ninfo: [1, 2, 'a', 3, 4]\n-/\n#guard_msgs in\n#eval flatten [[1,\
  \ 2], \"a\", [3, 4]]\n\n/--\ninfo: [[1, 2], 3, 4, 5]\n-/\n#guard_msgs in\n#eval\
  \ flatten [[[1, 2]], [3, 4], 5]\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
