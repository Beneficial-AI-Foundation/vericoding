"vc-description": "Given a binary tree, return the vertical order traversal of its\
  \ nodes values.\nFor each node at position (X, Y), its left and right children respectively will\
  \ be at positions (X-1, Y-1) and (X+1, Y-1).\nRunning a vertical line from X = -infinity\
  \ to X = +infinity, whenever the vertical line touches some nodes, we report the\
  \ values of the nodes in order from top to bottom (decreasing Y coordinates).\n\
  If two nodes have the same position, then the value of the node that is reported\
  \ first is the value that is smaller.\nReturn an list of non-empty reports in order\
  \ of X coordinate.  Every report will have a list of values of nodes.\n \nExample\
  \ 1:\n\n\nInput: [3,9,20,null,null,15,7]\nOutput: [[9],[3,15],[20],[7]]\nExplanation:\
  \ \nWithout loss of generality, we can assume the root node is at position (0, 0):\n\
  Then, the node with value 9 occurs at position (-1, -1);\nThe nodes with values\
  \ 3 and 15 occur at positions (0, 0) and (0, -2);\nThe node with value 20 occurs\
  \ at position (1, -1);\nThe node with value 7 occurs at position (2, -2).\n\n\n\
  Example 2:\n\nInput: [1,2,3,4,5,6,7]\nOutput: [[4],[2],[1,5,6],[3],[7]]\nExplanation:\
  \ \nThe node with value 5 and the node with value 6 have the same position according\
  \ to the given scheme.\nHowever, in the report \"[1,5,6]\", the node value of 5\
  \ comes first since 5 is smaller than 6.\n\n \n\nNote:\n\nThe tree will have between\
  \ 1 and 1000 nodes.\nEach node's value will be between 0 and 1000."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def vertical_traverse : Option TreeNode → List (List Int)\n  |\
  \ none => []\n  | some _ => sorry\n"
"vc-theorems": "theorem vertical_traverse_type_preservation (t : Option TreeNode)\
  \ :\n  ∀ l ∈ vertical_traverse t, l.all (λ x => True) := by sorry\n\n\ntheorem vertical_traverse_elements_integers\
  \ (t : Option TreeNode) :\n  ∀ l ∈ vertical_traverse t, ∀ x ∈ l, True := by sorry\n\
  \n\ntheorem vertical_traverse_empty (t : Option TreeNode) :\n  t = none → vertical_traverse\
  \ t = [] := by sorry\n\n\ntheorem vertical_traverse_single_node (v : Int) :\n  vertical_traverse\
  \ (some (TreeNode.mk v none none)) = [[v]] := by sorry\n\n\ntheorem vertical_traverse_left_linear\
  \ (v1 v2 v3 : Int) :\n  let t3 := TreeNode.mk v3 none none\n  let t2 := TreeNode.mk\
  \ v2 (some t3) none\n  let t1 := TreeNode.mk v1 (some t2) none\n  vertical_traverse\
  \ (some t1) = [[v3], [v2], [v1]] := by sorry\n\n\ntheorem vertical_traverse_right_linear\
  \ (v1 v2 v3 : Int) :\n  let t3 := TreeNode.mk v3 none none\n  let t2 := TreeNode.mk\
  \ v2 none (some t3)\n  let t1 := TreeNode.mk v1 none (some t2)\n  vertical_traverse\
  \ (some t1) = [[v1], [v2], [v3]] := by sorry\n\n/--\ninfo: [[9], [3, 15], [20],\
  \ [7]]\n-/\n#guard_msgs in\n#eval vertical_traverse TreeNode(3)\n\n/--\ninfo: [[4],\
  \ [2], [1, 5, 6], [3], [7]]\n-/\n#guard_msgs in\n#eval vertical_traverse TreeNode(1)\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
