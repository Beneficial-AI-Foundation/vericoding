"vc-description": "Greg has a weighed directed graph, consisting of n vertices. In\
  \ this graph any pair of distinct vertices has an edge between them in both directions.\
  \ Greg loves playing with the graph and now he has invented a new game:  The game\
  \ consists of n steps.  On the i-th step Greg removes vertex number x_{i} from the\
  \ graph. As Greg removes a vertex, he also removes all the edges that go in and\
  \ out of this vertex.  Before executing each step, Greg wants to know the sum of\
  \ lengths of the shortest paths between all pairs of the remaining vertices. The\
  \ shortest path can go through any remaining vertex. In other words, if we assume\
  \ that d(i, v, u) is the shortest path between vertices v and u in the graph that\
  \ formed before deleting vertex x_{i}, then Greg wants to know the value of the\
  \ following sum: $\\sum_{v, u, v \\neq u} d(i, v, u)$. \n\nHelp Greg, print the\
  \ value of the required sum before each step.\n\n\n-----Input-----\n\nThe first\
  \ line contains integer n (1 ≤ n ≤ 500) — the number of vertices in the graph.\n\
  \nNext n lines contain n integers each — the graph adjacency matrix: the j-th number\
  \ in the i-th line a_{ij} (1 ≤ a_{ij} ≤ 10^5, a_{ii} = 0) represents the weight\
  \ of the edge that goes from vertex i to vertex j.\n\nThe next line contains n distinct\
  \ integers: x_1, x_2, ..., x_{n} (1 ≤ x_{i} ≤ n) — the vertices that Greg deletes.\n\
  \n\n-----Output-----\n\nPrint n integers — the i-th number equals the required sum\
  \ before the i-th step.\n\nPlease, do not use the %lld specifier to read or write\
  \ 64-bit integers in C++. It is preferred to use the cin, cout streams of the %I64d\
  \ specifier.\n\n\n-----Examples-----\nInput\n1\n0\n1\n\nOutput\n0 \nInput\n2\n0\
  \ 5\n4 0\n1 2\n\nOutput\n9 0 \nInput\n4\n0 3 1 1\n6 0 400 1\n2 4 0 1\n1 1 1 0\n\
  4 1 2 3\n\nOutput\n17 23 404 0"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def solve_graph_paths (n : Nat) (matrix : List (List Nat)) (vertex_order\
  \ : List Nat) : String :=\n  sorry\n"
"vc-theorems": "theorem solve_graph_paths_output_format \n  (n : Nat) (matrix : List\
  \ (List Nat)) (vertex_order : List Nat)\n  (h1 : 0 < n) (h2 : n ≤ 10)\n  (h3 : matrix.length\
  \ = n)\n  (h4 : ∀ row ∈ matrix, row.length = n)\n  (h5 : ∀ i, i < n → (matrix.get!\
  \ i).get! i = 0)\n  (h6 : vertex_order.length = n)\n  (h7 : ∀ x ∈ vertex_order,\
  \ 0 < x ∧ x ≤ n) :\n  let result := solve_graph_paths n matrix vertex_order\n  let\
  \ values := result.splitOn \" \"\n  values.length = n ∧ \n  ∀ x ∈ values, x.all\
  \ Char.isDigit :=\nsorry\n\n\ntheorem solve_graph_paths_single_vertex \n  (matrix\
  \ : List (List Nat))\n  (h1 : matrix = [[0]]) :\n  solve_graph_paths 1 matrix [1]\
  \ = \"0\" :=\nsorry\n\n\ntheorem solve_graph_paths_symmetric_last_zero\n  (n : Nat)\
  \ (matrix : List (List Nat)) (vertex_order : List Nat)\n  (h1 : 1 < n) (h2 : n ≤\
  \ 10)\n  (h3 : matrix.length = n)\n  (h4 : ∀ row ∈ matrix, row.length = n)\n  (h5\
  \ : ∀ i j, i < n → j < n → (matrix.get! i).get! j = (matrix.get! j).get! i) :\n\
  \  let result := solve_graph_paths n matrix vertex_order\n  let values := (result.splitOn\
  \ \" \").map String.toNat!\n  values.getLast! = 0 :=\nsorry\n\n/--\ninfo: '0'\n\
  -/\n#guard_msgs in\n#eval solve_graph_paths 1 [[0]] [1]\n\n/--\ninfo: '9 0'\n-/\n\
  #guard_msgs in\n#eval solve_graph_paths 2 [[0, 5], [4, 0]] [1, 2]\n\n/--\ninfo:\
  \ '17 23 404 0'\n-/\n#guard_msgs in\n#eval solve_graph_paths 4 [[0, 3, 1, 1], [6,\
  \ 0, 400, 1], [2, 4, 0, 1], [1, 1, 1, 0]] [4, 1, 2, 3]\n"
"vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded"
