"vc-description": "In this kata you are given an array to sort but you're expected\
  \ to start sorting from a specific position of the array (in ascending order) and\
  \ optionally you're given the number of items to sort.\n\n#### Examples:\n\n```python\n\
  sect_sort([1, 2, 5, 7, 4, 6, 3, 9, 8], 2) //=> [1, 2, 3, 4, 5, 6, 7, 8, 9]\nsect_sort([9,\
  \ 7, 4, 2, 5, 3, 1, 8, 6], 2, 5) //=> [9, 7, 1, 2, 3, 4, 5, 8, 6]\n```\n\n#### Documentation:\n\
  \n```python\nsect_sort(array, start, length);\n```\n\n- array - array to sort\n\
  - start - position to begin sorting\n- length - number of items to sort (optional)\n\
  \nif the **length** argument is not passed or is zero, you sort all items to the\
  \ right of the start postiton in the array"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def List.isSorted {α : Type} [Ord α] : List α → Prop := sorry\n\
  \ndef sect_sort (xs : List α) (start : Nat) (length : Option Nat := none) : List\
  \ α :=\n  sorry\n"
"vc-theorems": "theorem sect_sort_length {α : Type} [Ord α] (xs : List α) (start :\
  \ Nat) (length : Option Nat) :\n  List.length (sect_sort xs start length) = List.length\
  \ xs := sorry\n\n\ntheorem sect_sort_prefix {α : Type} [Ord α] (xs : List α) (start\
  \ : Nat) (length : Option Nat) :\n  (sect_sort xs start length).take start = xs.take\
  \ start := sorry\n\n\ntheorem sect_sort_suffix {α : Type} [Ord α] (xs : List α)\
  \ (start : Nat) (length : Option Nat) \n    (h : let endIdx := min (start + (length.getD\
  \ (xs.length - start))) xs.length; True) :\n  let endIdx := min (start + (length.getD\
  \ (xs.length - start))) xs.length\n  (sect_sort xs start length).drop endIdx = xs.drop\
  \ endIdx := sorry\n\n\ntheorem sect_sort_middle_sorted {α : Type} [Ord α] (xs :\
  \ List α) (start : Nat) (length : Option Nat)\n    (h : let endIdx := min (start\
  \ + (length.getD (xs.length - start))) xs.length; True) :\n  let endIdx := min (start\
  \ + (length.getD (xs.length - start))) xs.length\n  List.isSorted ((sect_sort xs\
  \ start length).drop start) := sorry\n\n\ntheorem sect_sort_empty {α : Type} [Ord\
  \ α] (start : Nat) (length : Option Nat) :\n  sect_sort ([] : List α) start length\
  \ = [] := sorry\n\n\ntheorem sect_sort_start_exceeds_length {α : Type} [Ord α] (xs\
  \ : List α) (start : Nat) (length : Option Nat) :\n  start ≥ xs.length → sect_sort\
  \ xs start length = xs := sorry\n\n/--\ninfo: [1, 2, 3, 4, 5, 6, 7, 8, 9]\n-/\n\
  #guard_msgs in\n#eval sect_sort [1, 2, 5, 7, 4, 6, 3, 9, 8] 2\n\n/--\ninfo: [9,\
  \ 7, 1, 2, 3, 4, 5, 8, 6]\n-/\n#guard_msgs in\n#eval sect_sort [9, 7, 4, 2, 5, 3,\
  \ 1, 8, 6] 2 5\n\n/--\ninfo: []\n-/\n#guard_msgs in\n#eval sect_sort [] 0\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
