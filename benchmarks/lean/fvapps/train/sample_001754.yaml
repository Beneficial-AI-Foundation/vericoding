"vc-description": "For an integer n, we call k>=2 a good base of n, if all digits\
  \ of n base k are 1.\nNow given a string representing n, you should return the smallest\
  \ good base of n in string format. \n\nExample 1:\n\nInput: \"13\"\nOutput: \"3\"\
  \nExplanation: 13 base 3 is 111.\n\n\n\nExample 2:\n\nInput: \"4681\"\nOutput: \"\
  8\"\nExplanation: 4681 base 8 is 11111.\n\n\n\nExample 3:\n\nInput: \"1000000000000000000\"\
  \nOutput: \"999999999999999999\"\nExplanation: 1000000000000000000 base 999999999999999999\
  \ is 11.\n\n\n\nNote:\n\nThe range of n is [3, 10^18].\nThe string representing\
  \ n is always valid and will not have leading zeros."
"vc-preamble": "import Imports.AllImports\n\n  def log (base n : Nat) : Nat := sorry\n\
  end Nat\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def smallest_good_base (n : String) : String :=\nsorry\n"
"vc-theorems": "theorem smallest_good_base_result_bounds {n : Nat} (h1 : n ≥ (3 :\
  \ Nat)) (h2 : n ≤ Nat.pow 10 18) :\n  let result := String.toNat! (smallest_good_base\
  \ (toString n))\n  result ≥ (2 : Nat) ∧ result < n :=\nsorry\n\n\ntheorem smallest_good_base_all_ones\
  \ {n : Nat} (h1 : n ≥ (3 : Nat)) (h2 : n ≤ Nat.pow 10 18) :\n  let result := String.toNat!\
  \ (smallest_good_base (toString n))\n  let m := Nat.log result n\n  (Nat.pow result\
  \ (m+1) - 1)/(result - 1) = n :=\nsorry\n\n\ntheorem smallest_good_base_min_input\
  \ :\n  smallest_good_base \"3\" = \"2\" :=\nsorry\n\n\ntheorem smallest_good_base_power_two_minus_one\
  \ :\n  smallest_good_base \"15\" = \"2\" :=\nsorry\n\n/--\ninfo: '3'\n-/\n#guard_msgs\
  \ in\n#eval smallest_good_base \"13\"\n\n/--\ninfo: '8'\n-/\n#guard_msgs in\n#eval\
  \ smallest_good_base \"4681\"\n\n/--\ninfo: '999999999999999999'\n-/\n#guard_msgs\
  \ in\n#eval smallest_good_base \"1000000000000000000\"\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
