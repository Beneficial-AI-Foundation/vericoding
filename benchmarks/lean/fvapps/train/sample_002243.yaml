"vc-description": "The Chef has one long loaf of bread of length 1. He wants to cut\
  \ it into as many little loaves as he can. But he wants to adhere to the following\
  \ rule: At any moment, the length of the longest loaf which he possesses may not\
  \ be larger than the length of shortest one, times some constant factor. Every time,\
  \ he is only allowed to cut exactly one loaf into two shorter ones.\n\n-----Input-----\n\
  One floating-point number, 1 ≤ k ≤ 1.999, meaning the stated constant factor. The\
  \ number will have at most 3 digits after the decimal point.\n\n-----Output-----\n\
  \nFirst, you should output one number n, the maximal achievable number of loaves\
  \ for the given value of the constant factor. Then, you should output any proof\
  \ that this number of loaves is in fact achievable: n-1 descriptions of cutting,\
  \ using the following notation. At each step, you print two numbers: first, the\
  \ index of the loaf that you want to cut into two parts; second, the length of the\
  \ newly created loaf (cut off from the original one). It is assumed that the starting\
  \ loaf has index 0. Each newly created loaf will be given the lowest possible free\
  \ integer index (so, at the ith step this will be i). Each time, the size of size\
  \ of the original loaf will be decreased by the size of the newly created loaf.\n\
  \n-----Example-----\nInput:\n1.5\nOutput:\n4\n0 0.4\n0 0.3\n1 0.2"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def max_loaves (k : Float) : (Nat × List (Nat × Float)) :=\n  sorry\n"
"vc-theorems": "theorem max_loaves_result_is_four (k : Float) \n  (hk : 1 ≤ k ∧ k\
  \ ≤ 10) :\n  (max_loaves k).1 = 4 :=\n  sorry\n\n\ntheorem max_loaves_gives_three_instructions\
  \ (k : Float)\n  (hk : 1 ≤ k ∧ k ≤ 10) :\n  List.length (max_loaves k).2 = 3 :=\n\
  \  sorry\n\n\ntheorem max_loaves_cut_sum_is_point_nine (k : Float)\n  (hk : 1 ≤\
  \ k ∧ k ≤ 10) :\n  let cuts := (max_loaves k).2;\n  let total := (cuts.map (λ x\
  \ => x.2)).foldl (λ x y => x + y) 0;\n  Float.abs (total - 0.9) < 1e-10 :=\n  sorry\n\
  \n\ntheorem max_loaves_cuts_are_decreasing (k : Float)\n  (hk : 1 ≤ k ∧ k ≤ 10)\
  \ :\n  let cuts := (max_loaves k).2;\n  let lengths := cuts.map (λ x => x.2);\n\
  \  ∀ i : Fin (lengths.length - 1),\n    lengths[i] ≥ lengths[i.val + 1] :=\n  sorry\n\
  \n\ntheorem max_loaves_indices_are_valid (k : Float)\n  (hk : 1 ≤ k ∧ k ≤ 10) :\n\
  \  let cuts := (max_loaves k).2;\n  have h_len : List.length cuts = 3 := by exact\
  \ max_loaves_gives_three_instructions k hk;\n  have h0 : 0 < 3 := by exact Nat.zero_lt_succ\
  \ 2\n  have h1 : 1 < 3 := by exact Nat.succ_lt_succ (Nat.zero_lt_succ 1)\n  have\
  \ h2 : 2 < 3 := by exact Nat.lt_succ_self 2\n  have h0' : 0 < List.length cuts :=\
  \ by rw [h_len]; exact h0\n  have h1' : 1 < List.length cuts := by rw [h_len]; exact\
  \ h1\n  have h2' : 2 < List.length cuts := by rw [h_len]; exact h2\n  (cuts.get\
  \ ⟨0, h0'⟩).1 = 0 ∧ \n  (cuts.get ⟨1, h1'⟩).1 = 0 ∧\n  (cuts.get ⟨2, h2'⟩).1 = 1\
  \ :=\n  sorry\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval len instr\n"
"vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded"
