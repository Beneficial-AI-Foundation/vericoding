"vc-description": "# Letterss of Natac\nIn a game I just made up that doesn’t have\
  \ anything to do with any other game that you may or may not have played, you collect\
  \ resources on each turn and then use those resources to build things like roads,\
  \ settlements and cities. If you would like to try other kata about this game, they\
  \ can be found **[here](https://www.codewars.com/collections/59e6938afc3c49005900011f)**\n\
  \n## Task\n\nThis kata asks you to implement a time efficient version of the function\
  \ `play_if_enough(hand, play)` , which takes as input a `hand`, the resources you\
  \ have (a string of letters representing the resources you have), and a `play`,\
  \ (a string of letters representing the resources required to build a certain game\
  \ object), and returns a tuple (list in r) of a boolean value, corresponding to\
  \ whether you have enough resources, and your hand. If you had enough to build the\
  \ object, the returned hand is your resources minus those you used to build the\
  \ object. If not, it is your original hand (the one passed to the function).  \n\
  \nFor example, if it takes 3 ore and 2 grain to build a city, `play` is `”ooogg”`.\
  \ If `hand` is `”ooooogggssbbb”`, then `play_if_enough(hand, play)` returns `(True,\
  \ “oogssbbb”)`. \n\n## Examples\n```python\nplay_if_enough(\"ooooogggssbbb\", \"\
  ooogg\")  => (True, \"oogssbbb\")\nplay_if_enough(\"oogssbbb\", \"bwsg\")      \
  \  => (False, \"oogssbbb\")\nplay_if_enough(\"\", \"bw\")                  => (False,\
  \ \"\")\nplay_if_enough(\"abcdefghij\", \"aa\")        => (False, \"abcdefghij\"\
  )\n\n```\n## Notes: \n1. The order of resources in your hand (or play) is not relevant.\
  \ You can shuffle your hand any way you'd like, so long as you have the same number\
  \ of each resource.\n2. There are 26 different resources, each represented by a\
  \ lower case letter a-z, so a valid hand is a string of lower case letters.\n3.\
  \ A valid play is a string of any number of lower case letters.\n4. You do not have\
  \ to test for whether a hand or play is valid. \n5. A hand can be empty, but a play\
  \ can't. In the event a hand is empty, you don't have the cards to play, so return\
  \ `(False, \"\")`, in the correct data structure for your language, see example\
  \ 4 above.\n6. Tests include hand sizes of up to 150000 elements and play sizes\
  \ up to 10000 elements."
"vc-preamble": "import Imports.AllImports\n\ndef play_if_enough (hand play : String)\
  \ : Bool × String :=\n  sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def String.count (s : String) (c : Char) : Nat :=\n  sorry\n"
"vc-theorems": "theorem play_if_enough_success_length {hand play : String} :\n  let\
  \ res := play_if_enough hand play\n  res.1 → res.2.length = hand.length - play.length\
  \ :=\n  sorry\n\n\ntheorem play_if_enough_success_subset {hand play : String} {c\
  \ : Char} :\n  let res := play_if_enough hand play\n  res.1 → res.2.count c ≤ hand.count\
  \ c :=\n  sorry \n\n\ntheorem play_if_enough_failure_preserves {hand play : String}\
  \ :\n  let res := play_if_enough hand play\n  ¬res.1 → res.2 = hand :=\n  sorry\n\
  \n\ntheorem play_if_enough_empty_succeeds {hand : String} :\n  (play_if_enough hand\
  \ \"\").1 = true :=\n  sorry\n\n\ntheorem play_if_enough_too_long_fails {hand play\
  \ : String} :\n  play.length > hand.length →\n  ¬(play_if_enough hand play).1 :=\n\
  \  sorry\n\n\ntheorem play_if_enough_impossible_preserves {hand : String} :\n  let\
  \ impossible := String.mk (List.replicate (hand.length + 1) 'z')\n  let res := play_if_enough\
  \ hand impossible\n  ¬res.1 ∧ res.2 = hand :=\n  sorry\n\n/--\ninfo: (False, '')\n\
  -/\n#guard_msgs in\n#eval play_if_enough \"\" \"bw\"\n\n/--\ninfo: (True, 'oogssbbb')\n\
  -/\n#guard_msgs in\n#eval play_if_enough \"ooooogggssbbb\" \"ooogg\"\n\n/--\ninfo:\
  \ (False, 'oogssbbb')\n-/\n#guard_msgs in\n#eval play_if_enough \"oogssbbb\" \"\
  bwsg\"\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
