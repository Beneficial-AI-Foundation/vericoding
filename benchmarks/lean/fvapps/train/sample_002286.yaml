"vc-description": "Consider all binary strings of length $m$ ($1 \\le m \\le 60$).\
  \ A binary string is a string that consists of the characters 0 and 1 only. For\
  \ example, 0110 is a binary string, and 012aba is not. Obviously, there are exactly\
  \ $2^m$ such strings in total.\n\nThe string $s$ is lexicographically smaller than\
  \ the string $t$ (both have the same length $m$) if in the first position $i$ from\
  \ the left in which they differ, we have $s[i] < t[i]$. This is exactly the way\
  \ strings are compared in dictionaries and in most modern programming languages\
  \ when comparing them in a standard way. For example, the string 01011 is lexicographically\
  \ smaller than the string 01100, because the first two characters are the same,\
  \ and the third character in the first string is less than that in the second.\n\
  \nWe remove from this set $n$ ($1 \\le n \\le \\min(2^m-1, 100)$) distinct binary\
  \ strings $a_1, a_2, \\ldots, a_n$, each of length $m$. Thus, the set will have\
  \ $k=2^m-n$ strings. Sort all strings of the resulting set in lexicographical ascending\
  \ order (as in the dictionary).\n\nWe number all the strings after sorting from\
  \ $0$ to $k-1$. Print the string whose index is $\\lfloor \\frac{k-1}{2} \\rfloor$\
  \ (such an element is called median), where $\\lfloor x \\rfloor$ is the rounding\
  \ of the number down to the nearest integer.\n\nFor example, if $n=3$, $m=3$ and\
  \ $a=[$010, 111, 001$]$, then after removing the strings $a_i$ and sorting, the\
  \ result will take the form: $[$000, 011, 100, 101, 110$]$. Thus, the desired median\
  \ is 100.\n\n\n-----Input-----\n\nThe first line contains an integer $t$ ($1 \\\
  le t \\le 1000$) — the number of test cases. Then, $t$ test cases follow.\n\nThe\
  \ first line of each test case contains integers $n$ ($1 \\le n \\le \\min(2^m-1,\
  \ 100)$) and $m$ ($1 \\le m \\le 60$), where $n$ is the number of strings to remove,\
  \ and $m$ is the length of binary strings. The next $n$ lines contain $a_1, a_2,\
  \ \\ldots, a_n$ — distinct binary strings of length $m$.\n\nThe total length of\
  \ all given binary strings in all test cases in one test does not exceed $10^5$.\n\
  \n\n-----Output-----\n\nPrint $t$ answers to the test cases. For each test case,\
  \ print a string of length $m$ — the median of the sorted sequence of remaining\
  \ strings in the corresponding test case.\n\n\n-----Example-----\nInput\n5\n3 3\n\
  010\n001\n111\n4 3\n000\n111\n100\n011\n1 1\n1\n1 1\n0\n3 2\n00\n01\n10\n\nOutput\n\
  100\n010\n0\n1\n11\n\n\n\n-----Note-----\n\nThe first test case is explained in\
  \ the statement.\n\nIn the second test case, the result after removing strings and\
  \ sorting is $[$001, 010, 101, 110$]$. Therefore, the desired median is 010."
"vc-preamble": "import Imports.AllImports\n\ndef find_median_binary_string (n m :\
  \ Nat) (removed : List String) : String := sorry\n\ndef isAllZeros (s : String)\
  \ : Bool := sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def stringInList (s : String) (l : List String) : Bool := sorry\n\
  \ndef isBinaryChar (c : Char) : Bool :=\n  c = '0' || c = '1'\n\n/-- The length\
  \ of the output string matches the input length m -/"
"vc-theorems": "theorem find_median_binary_string_length_matches_input\n  {n m : Nat}\
  \ {removed : List String}\n  (h₁ : n < 2^m)\n  (h₂ : n = removed.length) :\n  (find_median_binary_string\
  \ n m removed).length = m := sorry\n\n/-- The output string only contains '0' and\
  \ '1' characters -/\n\ntheorem find_median_binary_string_binary_chars\n  {n m :\
  \ Nat} {removed : List String}\n  (h₁ : n < 2^m)\n  (h₂ : n = removed.length) :\n\
  \  ∀ c, c ∈ (find_median_binary_string n m removed).data → isBinaryChar c := sorry\n\
  \n/-- The output string is not in the list of removed strings -/\n\ntheorem find_median_binary_string_not_in_removed\n\
  \  {n m : Nat} {removed : List String}\n  (h₁ : n < 2^m)\n  (h₂ : n = removed.length)\
  \ :\n  stringInList (find_median_binary_string n m removed) removed = false := sorry\n\
  \n/-- For the minimal case with a single all-zeros string removed,\n    the output\
  \ string has correct length and is not all zeros -/\n\ntheorem find_median_binary_string_minimal_case\n\
  \  {m : Nat} (h : m > 0) :\n  let zeros := String.mk (List.replicate m '0')\n  let\
  \ result := find_median_binary_string 1 m [zeros]\n  (result.length = m) ∧ (isAllZeros\
  \ result = false) := sorry\n\n/--\ninfo: '100'\n-/\n#guard_msgs in\n#eval find_median_binary_string\
  \ 3 3 [\"010\", \"001\", \"111\"]\n\n/--\ninfo: '010'\n-/\n#guard_msgs in\n#eval\
  \ find_median_binary_string 4 3 [\"000\", \"111\", \"100\", \"011\"]\n\n/--\ninfo:\
  \ '0'\n-/\n#guard_msgs in\n#eval find_median_binary_string 1 1 [\"1\"]\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
