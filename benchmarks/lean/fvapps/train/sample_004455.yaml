"vc-description": "Consider a sequence, which is formed by the following rule: next\
  \ term is taken as the smallest possible non-negative integer, which is not yet\
  \ in the sequence, so that `no 3` terms of sequence form an arithmetic progression.\n\
  \n## Example\n\n`f(0) = 0` -- smallest non-negative  \n`f(1) = 1` -- smallest non-negative,\
  \ which is not yet in the sequence  \n`f(2) = 3` -- since `0, 1, 2` form an arithmetic\
  \ progression  \n`f(3) = 4` -- neither of `0, 1, 4`, `0, 3, 4`, `1, 3, 4` form an\
  \ arithmetic progression, so we can take smallest non-negative, which is larger\
  \ than `3`  \n`f(4) = 9` --  `5, 6, 7, 8` are not good, since `1, 3, 5`, `0, 3,\
  \ 6`, `1, 4, 7`, `0, 4, 8` are all valid arithmetic progressions.  \n\netc...\n\n\
  ## The task\n\nWrite a function `f(n)`, which returns the `n-th` member of sequence.\n\
  \n## Limitations\n\nThere are `1000` random tests with `0 <= n <= 10^9`, so you\
  \ should consider algorithmic complexity of your solution."
"vc-preamble": "import Imports.AllImports\n\ndef sequence (n : Nat) : Nat := sorry\n\
  \ntheorem sequence_nonnegative (n : Nat) : \n  sequence n â‰¥ 0 := sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def toBinaryString (n : Nat) : List Nat := sorry\ndef fromBase3\
  \ (digits : List Nat) : Nat := sorry"
"vc-theorems": "theorem sequence_monotonic {n : Nat} (h : n > 0) : \n  sequence n\
  \ > sequence (n - 1) := sorry\n\n/-- Helper functions for binary/base-3 conversion\
  \ -/\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval sequence 0\n\n/--\ninfo: 1\n-/\n\
  #guard_msgs in\n#eval sequence 1\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval sequence\
  \ 2\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval sequence 3\n\n/--\ninfo: 9\n-/\n\
  #guard_msgs in\n#eval sequence 4\n\n/--\ninfo: 7329\n-/\n#guard_msgs in\n#eval sequence\
  \ 334\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible"
