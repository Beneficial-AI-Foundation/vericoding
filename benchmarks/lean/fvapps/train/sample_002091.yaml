"vc-description": "Appleman has a tree with n vertices. Some of the vertices (at least\
  \ one) are colored black and other vertices are colored white.\n\nConsider a set\
  \ consisting of k (0 ≤ k < n) edges of Appleman's tree. If Appleman deletes these\
  \ edges from the tree, then it will split into (k + 1) parts. Note, that each part\
  \ will be a tree with colored vertices.\n\nNow Appleman wonders, what is the number\
  \ of sets splitting the tree in such a way that each resulting part will have exactly\
  \ one black vertex? Find this number modulo 1000000007 (10^9 + 7).\n\n\n-----Input-----\n\
  \nThe first line contains an integer n (2  ≤ n ≤ 10^5) — the number of tree vertices.\
  \ \n\nThe second line contains the description of the tree: n - 1 integers p_0,\
  \ p_1, ..., p_{n} - 2 (0 ≤ p_{i} ≤ i). Where p_{i} means that there is an edge connecting\
  \ vertex (i + 1) of the tree and vertex p_{i}. Consider tree vertices are numbered\
  \ from 0 to n - 1.\n\nThe third line contains the description of the colors of the\
  \ vertices: n integers x_0, x_1, ..., x_{n} - 1 (x_{i} is either 0 or 1). If x_{i}\
  \ is equal to 1, vertex i is colored black. Otherwise, vertex i is colored white.\n\
  \n\n-----Output-----\n\nOutput a single integer — the number of ways to split the\
  \ tree modulo 1000000007 (10^9 + 7).\n\n\n-----Examples-----\nInput\n3\n0 0\n0 1\
  \ 1\n\nOutput\n2\n\nInput\n6\n0 1 1 0 4\n1 1 0 0 1 0\n\nOutput\n1\n\nInput\n10\n\
  0 1 2 1 4 4 4 0 8\n0 0 0 1 0 1 1 0 0 1\n\nOutput\n27"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def MODULO := 1000000007\n\ndef solve_tree_splitting (n : Nat)\
  \ (parents : List Nat) (colors : List Nat) : Nat := sorry\n"
"vc-theorems": "theorem single_node_bounds (n : Nat) (h : 0 < n ∧ n ≤ 10) :\n  let\
  \ parents := List.replicate (n-1) 0\n  let colors := List.replicate n 0\n  let result\
  \ := solve_tree_splitting n parents colors\n  result ≥ 0 ∧ result < MODULO := sorry\n\
  \n\ntheorem chain_tree_bounds (n : Nat) (colors : List Nat)\n    (h1 : 1 < n ∧ n\
  \ ≤ 20)\n    (h2 : ∀ c ∈ colors, c = 0 ∨ c = 1)\n    (h3 : colors.length = n) :\n\
  \  let parents := List.range (n-1)\n  let result := solve_tree_splitting n parents\
  \ colors\n  result ≥ 0 ∧ result < MODULO := sorry\n\n\ntheorem star_tree_bounds\
  \ (n : Nat) (h : 1 < n ∧ n ≤ 20) :\n  let parents := List.replicate (n-1) 0\n  let\
  \ colors := List.map (fun i => i % 2) (List.range n)\n  let result := solve_tree_splitting\
  \ n parents colors\n  result ≥ 0 ∧ result < MODULO := sorry\n\n\ntheorem edge_cases\
  \ :\n  (solve_tree_splitting 2 [0] [0,1] ≥ 0) ∧\n  (solve_tree_splitting 3 [0,0]\
  \ [1,1,1] ≥ 0) ∧\n  (solve_tree_splitting 3 [0,0] [0,0,0] ≥ 0) := sorry\n\n/--\n\
  info: 2\n-/\n#guard_msgs in\n#eval solve_tree_splitting 3 [0, 0] [0, 1, 1]\n\n/--\n\
  info: 1\n-/\n#guard_msgs in\n#eval solve_tree_splitting 6 [0, 1, 1, 0, 4] [1, 1,\
  \ 0, 0, 1, 0]\n\n/--\ninfo: 27\n-/\n#guard_msgs in\n#eval solve_tree_splitting 10\
  \ [0, 1, 2, 1, 4, 4, 4, 0, 8] [0, 0, 0, 1, 0, 1, 1, 0, 0, 1]\n"
"vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded"
