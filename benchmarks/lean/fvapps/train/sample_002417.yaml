"vc-description": "Given a non-empty string s, you may delete at most one character.\
  \  Judge whether you can make it a palindrome.\n\n\nExample 1:\n\nInput: \"aba\"\
  \nOutput: True\n\n\n\nExample 2:\n\nInput: \"abca\"\nOutput: True\nExplanation:\
  \ You could delete the character 'c'.\n\n\n\nNote:\n\nThe string will only contain\
  \ lowercase characters a-z.\nThe maximum length of the string is 50000."
"vc-preamble": "import Imports.AllImports\n\ndef valid_palindrome (s : String) : Bool\
  \ := sorry\n\ndef reverse (s : String) : String := sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def isPalindrome (s : String) : Bool := s == reverse s\n\ntheorem\
  \ palindrome_basic (s : String) :\n  isPalindrome s → valid_palindrome s := \n \
  \ sorry\n"
"vc-theorems": "theorem single_char_palindrome (s : String) :\n  s.length ≤ 1 → valid_palindrome\
  \ s :=\n  sorry\n\n\ntheorem palindrome_remove_char (s : String) :\n  s.length >\
  \ 1 → isPalindrome s → \n  valid_palindrome (s.take (s.length - 1)) :=\n  sorry\n\
  \n\ntheorem nearly_palindrome (s : String) (x : Char) :\n  s.length ≥ 3 →\n  let\
  \ palindrome := s ++ reverse s\n  let middle := palindrome.length / 2\n  let nearly_pal\
  \ := palindrome.take middle ++ String.mk [x] ++ palindrome.drop middle\n  valid_palindrome\
  \ nearly_pal :=\n  sorry\n\n\ntheorem non_palindrome (s : String) :\n  s.length\
  \ ≥ 2 →\n  ¬(isPalindrome s) →\n  (let count := (List.zip s.data (reverse s).data).filter\
  \ (fun p => p.1 ≠ p.2) |>.length\n   count > 2) →\n  ¬(valid_palindrome s) :=\n\
  \  sorry\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval valid_palindrome \"aba\"\n\
  \n/--\ninfo: True\n-/\n#guard_msgs in\n#eval valid_palindrome \"abca\"\n\n/--\n\
  info: False\n-/\n#guard_msgs in\n#eval valid_palindrome \"abc\"\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
