"vc-description": "In this kata, your task is to write a function `to_bytes(n)` (or\
  \ `toBytes(n)` depending on language) that produces a list of bytes that represent\
  \ a given non-negative integer `n`. Each byte in the list is represented by a string\
  \ of `'0'` and `'1'` of length 8. The most significant byte is first in the list.\
  \ The example test cases should provide you with all the details. You may assume\
  \ that the argument `n` is valid."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def to_bytes (n : Nat) : List String := sorry\n\ntheorem to_bytes_length_correct\
  \ : ∀ (n : Nat),\n  ∀ byte ∈ to_bytes n, String.length byte = 8\n  := sorry\n"
"vc-theorems": "theorem to_bytes_valid_bits : ∀ (n : Nat),\n  ∀ byte ∈ to_bytes n,\n\
  \  ∀ c ∈ byte.data,\n  c = '0' ∨ c = '1'\n  := sorry\n\n\ntheorem to_bytes_roundtrip\
  \ : ∀ (n : Nat),\n  let bytes := to_bytes n\n  let recovered := bytes.enum.foldl\n\
  \    (fun acc (i, byte) => acc + (String.toNat! byte) * (256 ^ (bytes.length - 1\
  \ - i)))\n    0\n  recovered = n\n  := sorry\n\n\ntheorem to_bytes_single_byte :\
  \ ∀ (n : Nat),\n  n ≤ 255 →\n  (to_bytes n).length = 1\n  := sorry\n\n\ntheorem\
  \ to_bytes_zero :\n  to_bytes 0 = [\"00000000\"]\n  := sorry\n\n/--\ninfo: ['00000000']\n\
  -/\n#guard_msgs in\n#eval to_bytes 0\n\n/--\ninfo: ['00000001']\n-/\n#guard_msgs\
  \ in\n#eval to_bytes 1\n\n/--\ninfo: ['00000001', '00000001']\n-/\n#guard_msgs in\n\
  #eval to_bytes 257\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
