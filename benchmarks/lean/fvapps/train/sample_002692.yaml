"vc-description": "Simple enough this one - you will be given an array. The values\
  \ in the array will either be numbers or strings, or a mix of both. You will not\
  \ get an empty array, nor a sparse one.\n\nYour job is to return a single array\
  \ that has first the numbers sorted in ascending order, followed by the strings\
  \ sorted in alphabetic order. The values must maintain their original type. \n\n\
  Note that numbers written as strings are strings and must be sorted with the other\
  \ strings."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def db_sort : List α → List α := sorry\n\ndef isSorted [LE α] [Inhabited\
  \ α] (l : List α) : Prop :=\n  ∀ i j, i < j → j < l.length → l[i]! ≤ l[j]!\n"
"vc-theorems": "theorem db_sort_numbers_sorted [LE Int] [Inhabited Int] (arr : List\
  \ Int) : \n  isSorted (db_sort arr) := sorry\n\n\ntheorem db_sort_strings_sorted\
  \ [LE String] [Inhabited String] (arr : List String) :\n  isSorted (db_sort arr)\
  \ := sorry\n\n\ntheorem db_sort_mixed_preserves_length {α} (arr : List α) :\n  List.length\
  \ (db_sort arr) = List.length arr := sorry\n\n\ntheorem db_sort_numbers_before_strings\
  \ (arr : List (Int ⊕ String)) :\n  let result := db_sort arr\n  let nums := result.filter\
  \ (fun x => match x with | Sum.inl _ => true | _ => false)\n  let strs := result.filter\
  \ (fun x => match x with | Sum.inr _ => true | _ => false)\n  ∀ i j, i < j → i <\
  \ nums.length → j ≥ nums.length →\n    (match result[i]? with | some (Sum.inl _)\
  \ => true | _ => false) ∧\n    (match result[j]? with | some (Sum.inr _) => true\
  \ | _ => false) := sorry\n\n\ntheorem db_sort_mixed_numbers_sorted [LE Int] [Inhabited\
  \ Int] (arr : List (Int ⊕ String)) :\n  let result := db_sort arr\n  let nums :=\
  \ result.filter (fun x => match x with | Sum.inl n => true | _ => false)\n  let\
  \ nums_only := nums.map (fun x => match x with | Sum.inl n => n | _ => 0)\n  isSorted\
  \ nums_only := sorry\n\n\ntheorem db_sort_mixed_strings_sorted [LE String] [Inhabited\
  \ String] (arr : List (Int ⊕ String)) :\n  let result := db_sort arr\n  let strs\
  \ := result.filter (fun x => match x with | Sum.inr s => true | _ => false)\n  let\
  \ strs_only := strs.map (fun x => match x with | Sum.inr s => s | _ => \"\")\n \
  \ isSorted strs_only := sorry\n\n\ntheorem db_sort_preserves_elements (arr : List\
  \ (Int ⊕ String)) :\n  List.length (db_sort arr) = List.length arr := sorry\n\n\
  /--\ninfo: [2, 3, 4, 5, 6]\n-/\n#guard_msgs in\n#eval db_sort [6, 2, 3, 4, 5]\n\n\
  /--\ninfo: [0, 2, 2, 'Apple', 'Banana', 'Mango', 'Orange']\n-/\n#guard_msgs in\n\
  #eval db_sort [\"Banana\", \"Orange\", \"Apple\", \"Mango\", 0, 2, 2]\n\n/--\ninfo:\
  \ [1, 1, 1, 1, 1, 1, 2, 2, 3, '1', '2', 'three']\n-/\n#guard_msgs in\n#eval db_sort\
  \ [1, 1, 1, 1, 1, 2, \"1\", \"2\", \"three\", 1, 2, 3]\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
