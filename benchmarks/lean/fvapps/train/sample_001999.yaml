"vc-description": "Petya learned a new programming language CALPAS. A program in this\
  \ language always takes one non-negative integer and returns one non-negative integer\
  \ as well.\n\nIn the language, there are only three commands: apply a bitwise operation\
  \ AND, OR or XOR with a given constant to the current integer. A program can contain\
  \ an arbitrary sequence of these operations with arbitrary constants from 0 to 1023.\
  \ When the program is run, all operations are applied (in the given order) to the\
  \ argument and in the end the result integer is returned.\n\nPetya wrote a program\
  \ in this language, but it turned out to be too long. Write a program in CALPAS\
  \ that does the same thing as the Petya's program, and consists of no more than\
  \ 5 lines. Your program should return the same integer as Petya's program for all\
  \ arguments from 0 to 1023.\n\n\n-----Input-----\n\nThe first line contains an integer\
  \ n (1 ≤ n ≤ 5·10^5) — the number of lines.\n\nNext n lines contain commands. A\
  \ command consists of a character that represents the operation (\"&\", \"|\" or\
  \ \"^\" for AND, OR or XOR respectively), and the constant x_{i} 0 ≤ x_{i} ≤ 1023.\n\
  \n\n-----Output-----\n\nOutput an integer k (0 ≤ k ≤ 5) — the length of your program.\n\
  \nNext k lines must contain commands in the same format as in the input.\n\n\n-----Examples-----\n\
  Input\n3\n| 3\n^ 2\n| 1\n\nOutput\n2\n| 3\n^ 2\n\nInput\n3\n& 1\n& 3\n& 5\n\nOutput\n\
  1\n& 1\n\nInput\n3\n^ 1\n^ 2\n^ 3\n\nOutput\n0\n\n\n\n-----Note-----\n\nYou can\
  \ read about bitwise operations in https://en.wikipedia.org/wiki/Bitwise_operation.\n\
  \nSecond sample:\n\nLet x be an input of the Petya's program. It's output is ((x&1)&3)&5\
  \ = x&(1&3&5) = x&1. So these two programs always give the same outputs."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def Command := String\n\ndef optimize_calpas (cmds : List Command)\
  \ : Nat × List Command :=\n  sorry\n\n/- Result has at most 3 commands -/"
"vc-theorems": "theorem optimize_length_bound {cmds : List Command} :\n  let (n, optimized)\
  \ := optimize_calpas cmds\n  n ≤ 3 ∧ optimized.length = n := by\n  sorry\n\n/- Commands\
  \ are properly formatted -/\n\ntheorem optimize_valid_commands {cmds : List Command}\
  \ :\n  let (n, optimized) := optimize_calpas cmds\n  ∀ cmd ∈ optimized,\n    (cmd.get\
  \ 0 = '|' ∨ cmd.get 0 = '&' ∨ cmd.get 0 = '^') := by\n  sorry\n\n/- Each operation\
  \ appears at most once -/ \n\ntheorem optimize_unique_ops {cmds : List Command}\
  \ :\n  let (n, optimized) := optimize_calpas cmds\n  let ops := optimized.map (fun\
  \ cmd => cmd.get 0)\n  ops.length = ops.eraseDups.length := by\n  sorry\n\n/- Operations\
  \ appear in correct order: |, ^, & -/\n\ntheorem optimize_op_ordering {cmds : List\
  \ Command} :\n  let (n, optimized) := optimize_calpas cmds\n  let ops := optimized.map\
  \ (fun cmd => cmd.get 0)\n  ∀ i j, i < j → j < ops.length →\n    let i' : Fin ops.length\
  \ := ⟨i, by sorry⟩\n    let j' : Fin ops.length := ⟨j, by sorry⟩\n    ((ops.get\
  \ i' = '|' ∧ ops.get j' = '^') →\n     (ops.get i' = '|' ∧ ops.get j' = '&') →\n\
  \     (ops.get i' = '^' ∧ ops.get j' = '&') →\n     i < j) := by\n  sorry"
"vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded"
