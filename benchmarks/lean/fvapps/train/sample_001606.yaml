"vc-description": "# Unflatten a list (Harder than easy)\n\nThis is the harder version\
  \ of Unflatten a list (Easy)\n\nSo you have again to build a method, that creates\
  \ new arrays, that can be flattened!\n\n# Shorter: You have to unflatten a list/an\
  \ array.\n\nYou get an array of integers and have to unflatten it by these rules:\n\
  ```\n- You have to do several runs. The depth is the number of runs, you have to\
  \ do.\n- In every run you have to switch the direction. First run from left, next\
  \ run from right. Next left...\nEvery run has these rules:\n- You start at the first\
  \ number (from the direction).\n- Take for every number x the remainder of the division\
  \ by the number of still available elements (from \n  this position!) to have the\
  \ number for the next decision.\n- If the remainder-value is smaller than 3, take\
  \ this number x (NOT the remainder-Value) direct\n  for the new array and continue\
  \ with the next number.\n- If the remainder-value (e.g. 3) is greater than 2, take\
  \ the next remainder-value-number (e.g. 3)\n  elements/numbers (inclusive the number\
  \ x, NOT the remainder-value) as a sub-array in the new array.\n  Continue with\
  \ the next number/element AFTER this taken elements/numbers.\n- Every sub-array\
  \ in the array is independent and is only one element for the progress on the array.\
  \ \n  For every sub-array you have to follow the same rules for unflatten it.\n\
  \  The direction is always the same as the actual run.\n```\n\nSounds complicated?\
  \ Yeah, thats why, this is the harder version...\nMaybe an example will help.\n\n\
  ```\n Array: [4, 5, 1, 7, 1] Depth: 2 -> [[ 4, [ 5, 1, 7 ] ], 1]\n \nSteps: \nFirst\
  \ run: (start from left side!)\n1. The first number is 4. The number is smaller\
  \ than the number of remaining elements, so it is the remainder-value (4 / 5 ->\
  \ remainder 4).\n   So 4 numbers (4, 5, 1, 7) are added as sub-array in the new\
  \ array.\n2. The next number is 1. It is smaller than 3, so the 1 is added direct\
  \ to the new array.\nNow we have --> [[4, 5, 1, 7], 1]\n\nSecond run: (start from\
  \ right side!)\n1. The last number (first from other side) is 1. So the 1 is added\
  \ direct to the new array.\n2. The next element is the sub-array. So we use the\
  \ rules for this.\n2a.The last number is 7. There are 4 elements in the array. So\
  \ for the next decision you have to\n   take the remainder from 7 / 4 -> 3. So 3\
  \ numbers (5, 1, 7) are added as sub-array in the \n   new array.\n2b.Now there\
  \ is the 4 and only one element last in this array. 4 / 1 -> remainder 0. It is\
  \ smaller\n   than 3. So the 4 is added direct to the new array.\nNow we have -->\
  \ [[ 4, [ 5, 1, 7 ] ], 1]\n```\n\nThe given array will always contain numbers. There\
  \ will only be numbers > 0.\n\n\nHave fun coding it and please don't forget to vote\
  \ and rank this kata! :-) \n\nI have created other katas. Have a look if you like\
  \ coding and challenges."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def find_path_and_nest (lst : List Int) (target : Int) : List Int\
  \ × Int := sorry\n\ntheorem find_path_and_nest_result_structure {lst : List Int}\
  \ {target : Int} \n  (h : lst ≠ []) :\n  let result := find_path_and_nest lst target\n\
  \  result.2 = 0 ∨ result.2 = 1 := sorry\n"
"vc-theorems": "theorem find_path_and_nest_target_not_found {lst : List Int} {target\
  \ : Int}\n  (h1 : lst ≠ []) \n  (h2 : target ∉ lst) :\n  find_path_and_nest lst\
  \ target = ([], 0) := sorry\n\n\ntheorem find_path_and_nest_target_first {lst :\
  \ List Int} {target : Int}\n  (h1 : lst ≠ []) \n  (h2 : lst.head? = some target)\
  \ :\n  find_path_and_nest lst target = ([0], 1) := sorry\n\n\ntheorem find_path_and_nest_target_later\
  \ {lst : List Int} {target : Int}\n  (h1 : lst ≠ []) \n  (h2 : lst.head? ≠ some\
  \ target)\n  (h3 : target ∈ lst.tail) :\n  let result := find_path_and_nest lst\
  \ target\n  result.2 = 1 ∧ \n  result.1.head? = lst.head? ∧\n  result.1.tail.all\
  \ (λ x => x ≥ 0) := sorry\n\n\ntheorem find_path_and_nest_reflexive {lst : List\
  \ Int}\n  (h : lst ≠ []) :\n  find_path_and_nest lst (lst.head?.get!) = ([0], 1)\
  \ := sorry"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded"
