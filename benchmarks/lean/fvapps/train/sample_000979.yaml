"vc-description": "Anmol gained a lot of weight last semester. So this semester, he\
  \ decided to run everyday. There is a very long straight road starting at his hostel.\
  \ There are N poles on the road - P1, P2, P3,..., PN on the road. All the poles\
  \ lie on the same side of his hostel. The distance between Pi and his hostel is\
  \ Di.\nFor 1 ≤ i, j ≤ N, i < j implies Di < Dj\nEveryday, Anmol chooses a pole Pi\
  \ to start running from. He keeps on running until he reaches Pi+K. Whenever he\
  \ reaches a pole (other than the starting pole), he records the distance traveled\
  \ since the last pole.\n\nYou are given the distances recorded by him today. Your\
  \ task is to find the number of distinct values of i such that i + K ≤ N and if\
  \ he starts at Pi and end at Pi+K, he would end up having exactly the same record\
  \ of distances (in the same order).\n\n-----Input-----\n- The first line of the\
  \ input contains an integer T denoting the number of test cases.\n- The first line\
  \ of each test case contains two space separated integers N and K.\n- The next line\
  \ contains N space separated integers D1, D2,..., DN.\n- The next line contains\
  \ K space separated integers representing the distances recorded by Anmol in the\
  \ same order.\n.\n\n-----Output-----\n- For each test case, output a single line\
  \ containing the answer for that test case.\n\n-----Constraints-----\n- 1 ≤ T ≤\
  \ 10\n- 2 ≤ N ≤ 5 x 104\n- 1 ≤ K < N\n- 1 ≤ Di ≤ 106\n\n-----Subtasks-----\n\n-----Subtask\
  \ #1 (20 points)-----\n- 1 ≤ N ≤ 1000\n\n-----Subtask #2 (80 points)-----\n- Original\
  \ constraints\n\n-----Example-----\nInput:\n3\n5 1\n1 5 10 12 14\n5\n5 2\n5 8 13\
  \ 16 21\n3 5\n5 3\n2 6 8 11 16\n2 3 5\n\nOutput:\n1\n2\n1\n\n-----Explanation-----\n\
  Example case 1. If he runs from P2 to P3, he will record (5)\nExample case 2. He\
  \ can start at P1 or P3\nExample case 3. He can start at P2"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def solve_running_patterns (n : Nat) (k : Nat) (distances : List\
  \ Nat) (recorded : List Nat) : Nat :=\n  sorry\n\n/-- The output is a natural number\
  \ between 0 and n-k -/"
"vc-theorems": "theorem solve_running_patterns_bounds (n k : Nat) (distances recorded\
  \ : List Nat) \n    (hn : n ≥ 2) (hk : k > 0) (hk2 : k < n)\n    (hdist : distances.length\
  \ = n)\n    (hdist_sorted : ∀ i j, i < j → j < n → distances.get! i ≤ distances.get!\
  \ j)\n    (hdist_unique : ∀ i j, i < j → j < n → distances.get! i ≠ distances.get!\
  \ j)\n    (hrec : recorded.length = k) :\n    let result := solve_running_patterns\
  \ n k distances recorded\n    0 ≤ result ∧ result ≤ n - k :=\n  sorry\n\n/-- A pattern\
  \ matches against itself at least once -/\n\ntheorem solve_running_patterns_self_match\
  \ (n k : Nat) (distances : List Nat)\n    (hn : n ≥ 3) (hk : k > 0) (hk2 : k < n)\n\
  \    (hdist : distances.length = n)\n    (hdist_sorted : ∀ i j, i < j → j < n →\
  \ distances.get! i ≤ distances.get! j)\n    (hdist_unique : ∀ i j, i < j → j < n\
  \ → distances.get! i ≠ distances.get! j) :\n    let diffs := List.zipWith (fun x\
  \ y => x - y) (distances.drop 1) distances\n    let pattern := List.take k diffs\n\
  \    solve_running_patterns n k distances pattern ≥ 1 :=\n  sorry\n\n/-- Basic cases\
  \ work correctly -/\n\ntheorem solve_running_patterns_basic_cases :\n    solve_running_patterns\
  \ 2 1 [1,2] [1] = 1 ∧ \n    solve_running_patterns 3 1 [1,2,3] [1] = 2 :=\n  sorry\n\
  \n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_running_patterns 5 1 [1, 5, 10,\
  \ 12, 14] [5]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval solve_running_patterns\
  \ 5 2 [5, 8, 13, 16, 21] [3, 5]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval solve_running_patterns\
  \ 5 3 [2, 6, 8, 11, 16] [2, 3, 5]\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded"
