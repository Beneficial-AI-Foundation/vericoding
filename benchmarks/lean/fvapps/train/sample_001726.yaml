"vc-description": "A *[Hamming number][1]* is a positive integer of the form 2*i*3*j*5*k*,\
  \ for some non-negative integers *i*, *j*, and *k*.\n\nWrite a function that computes\
  \ the *n*th smallest Hamming number. \n\nSpecifically:\n\n  - The first smallest\
  \ Hamming number is 1 = 2^(0)3^(0)5^(0)\n  - The second smallest Hamming number\
  \ is 2 = 2^(1)3^(0)5^(0)\n  - The third smallest Hamming number is 3 = 2^(0)3^(1)5^(0)\n\
  \  - The fourth smallest Hamming number is 4 = 2^(2)3^(0)5^(0)\n  - The fifth smallest\
  \ Hamming number is 5 = 2^(0)3^(0)5^(1)\n\nThe 20 smallest Hamming numbers are given\
  \ in example test fixture.\n\nYour code should be able to compute all of the smallest\
  \ 5,000 (Clojure: 2000, NASM: 13282) Hamming numbers without timing out.\n\n[1]:https://en.wikipedia.org/wiki/Regular_number"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def hamming (n : Nat) : Nat :=\n  sorry\n\n\n"
"vc-theorems": "theorem hamming_positive (n : Nat) (h : n > 0) :\n  hamming n > 0\
  \ :=\nsorry\n\n\ntheorem hamming_strictly_increasing (n : Nat) (h : n > 1) :\n \
  \ hamming n > hamming (n-1) :=\nsorry\n\n\ntheorem hamming_monotone (n1 n2 : Nat)\
  \ (h1 : n1 > 0) (h2 : n2 > 0) :\n  n1 ≤ n2 → hamming n1 ≤ hamming n2 :=\nsorry\n\
  \n\ntheorem hamming_first_values :\n  hamming 1 = 1 ∧ hamming 2 = 2 ∧ hamming 3\
  \ = 3 :=\nsorry\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval hamming 1\n\n/--\ninfo:\
  \ 2\n-/\n#guard_msgs in\n#eval hamming 2\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval\
  \ hamming 3\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval hamming 4\n\n/--\ninfo: 5\n\
  -/\n#guard_msgs in\n#eval hamming 5\n\n/--\ninfo: 36\n-/\n#guard_msgs in\n#eval\
  \ hamming 20\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible"
