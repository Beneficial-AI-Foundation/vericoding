"vc-description": "Given two words (beginWord and endWord), and a dictionary's word\
  \ list, find all shortest transformation sequence(s) from beginWord to endWord,\
  \ such that:\n\n\n       Only one letter can be changed at a time\n       Each transformed\
  \ word must exist in the word list. Note that beginWord is not a transformed word.\n\
  \n\nNote:\n\n\n       Return an empty list if there is no such transformation sequence.\n\
  \       All words have the same length.\n       All words contain only lowercase\
  \ alphabetic characters.\n       You may assume no duplicates in the word list.\n\
  \       You may assume beginWord and endWord are non-empty and are not the same.\n\
  \n\nExample 1:\n\n\nInput:\nbeginWord = \"hit\",\nendWord = \"cog\",\nwordList =\
  \ [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n\nOutput:\n[\n  [\"hit\",\"\
  hot\",\"dot\",\"dog\",\"cog\"],\n  [\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]\n]\n\
  \n\nExample 2:\n\n\nInput:\nbeginWord = \"hit\"\nendWord = \"cog\"\nwordList = [\"\
  hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n\nOutput: []\n\nExplanation: The endWord\
  \ \"cog\" is not in wordList, therefore no possible transformation."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def find_word_ladders (begin_word end_word : String) (word_list\
  \ : List String) : List (List String) :=\n  sorry\n"
"vc-theorems": "theorem result_is_list (begin_word end_word : String) (word_list :\
  \ List String) :\n  ∃ result, find_word_ladders begin_word end_word word_list =\
  \ result := by\n  sorry\n\n\ntheorem valid_path_properties (begin_word end_word\
  \ : String) (word_list : List String) :\n  ∀ path ∈ find_word_ladders begin_word\
  \ end_word word_list,\n    path.head? = some begin_word ∧ \n    path.getLast? =\
  \ some end_word ∧\n    (∀ w ∈ path, String.length w = String.length begin_word)\
  \ ∧\n    (∀ i < path.length - 1, \n      let w1 := path.get! i\n      let w2 :=\
  \ path.get! (i+1)\n      let chars1 := w1.data\n      let chars2 := w2.data\n  \
  \    let diffs := (List.zip chars1 chars2).filter (fun p => p.fst ≠ p.snd)\n   \
  \   diffs.length = 1) ∧\n    (∀ w ∈ path.tail, w ∈ word_list) := by\n  sorry\n\n\
  \ntheorem empty_result_when_end_not_in_wordlist (begin_word end_word : String) (word_list\
  \ : List String) :\n  end_word ∉ word_list → find_word_ladders begin_word end_word\
  \ word_list = [] := by\n  sorry\n\n\ntheorem all_paths_same_length (begin_word end_word\
  \ : String) (word_list : List String) :\n  let result := find_word_ladders begin_word\
  \ end_word word_list\n  result ≠ [] → ∃ n : Nat, ∀ path ∈ result, path.length =\
  \ n := by\n  sorry\n\n/--\ninfo: sorted(expected1)\n-/\n#guard_msgs in\n#eval sorted\
  \ find_word_ladders(begin1, end1, wordList1)\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
