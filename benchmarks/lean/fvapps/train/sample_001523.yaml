"vc-description": "In this problem the input will consist of a number of lines of\
  \ English text consisting of the letters of the English alphabet, the punctuation\
  \ marks ' (apostrophe), . (full stop), , (comma), ; (semicolon), :(colon) and white\
  \ space characters (blank, newline).\nYour task is print the words in the text in\
  \ lexicographic order (that is, dictionary order). Each word should appear exactly\
  \ once in your list. You can ignore the case (for instance, \"The\" and \"the\"\
  \ are to be treated as the same word). There should be no uppercase letters in the\
  \ output.\nFor example, consider the following candidate for the input text: \n\
  This is a sample piece of text to illustrate this \nproblem.\n\nThe corresponding\
  \ output would read as:\na\nillustrate\nis\nof\npiece\nproblem\nsample\ntext\nthis\n\
  to\n\n-----Input format-----\n- The first line of input contains a single integer\
  \ $N$, indicating the number of lines in the input.\n- This is followed by $N$ lines\
  \ of input text.\n\n-----Output format-----\n- The first line of output contains\
  \ a single integer $M$ indicating the number of distinct words in the given text.\
  \ \n- The next $M$ lines list out these words in lexicographic order.\n\n-----Constraints-----\n\
  - $1 \\leq N \\leq 10000$\n- There are at most 80 characters in each line.\n- There\
  \ are at the most 1000 distinct words in the given text.\n\n-----Sample Input-----\n\
  2\nThis is a sample piece of text to illustrate this \nproblem. \n\n-----Sample\
  \ Output-----\n10\na\nillustrate\nis\nof\npiece\nproblem\nsample\ntext\nthis\nto"
"vc-preamble": "import Imports.AllImports\n\ndef process_text (lines : List String)\
  \ : List String :=\n  sorry\n\ninductive List.LocalSorted : List String → Prop where\n\
  \  | nil : List.LocalSorted []\n  | single (x : String) : List.LocalSorted [x]\n\
  \  | cons (x y : String) (rest : List String) \n    (h₁ : x ≤ y) (h₂ : List.LocalSorted\
  \ (y::rest)) : \n    List.LocalSorted (x::y::rest)\n\ninductive List.LocalNodup\
  \ : List α → Prop where\n  | nil : List.LocalNodup []\n  | cons (x : α) (xs : List\
  \ α) \n    (h₁ : x ∉ xs) (h₂ : List.LocalNodup xs) : \n    List.LocalNodup (x::xs)\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def words (s : String) : List String :=\n  sorry\n"
"vc-theorems": "theorem process_text_output_properties {lines : List String} :\n \
  \ let result := process_text lines\n  -- First element is length of remaining list\n\
  \  (result.head! = toString (result.tail.length)) ∧ \n  -- Result is sorted\n  result.tail.LocalSorted\
  \ ∧\n  -- All elements are lowercase\n  (∀ x ∈ result.tail, x = x.toLower) ∧\n \
  \ -- No duplicates\n  result.tail.LocalNodup :=\n  sorry\n\n\ntheorem process_text_empty_strings\
  \ {lines : List String} :\n  (∀ x ∈ lines, x = \"\") → \n  process_text lines =\
  \ [\"0\"] :=\n  sorry\n\n\ntheorem process_text_case_insensitive_count {lines :\
  \ List String} \n  (h₁ : ∀ x ∈ lines, x.length > 0)\n  (h₂ : ∀ x ∈ lines, ∀ c ∈\
  \ x.toList, c.isAlpha ∨ c = ' ') :\n  let lines_with_upper := lines ++ (lines.map\
  \ String.toUpper)\n  let result := process_text lines_with_upper\n  let original_words\
  \ := (lines.bind (λ s => words s)).map String.toLower |>.eraseDups\n  result.tail.length\
  \ = original_words.length :=\n  sorry\n\n/--\ninfo: ['0']\n-/\n#guard_msgs in\n\
  #eval process_text [\"\"]\n\n/--\ninfo: ['1', 'the']\n-/\n#guard_msgs in\n#eval\
  \ process_text [\"The THE the\", \"THE\"]\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
