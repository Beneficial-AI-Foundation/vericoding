"vc-description": "Given an array of strings names of size n. You will create n folders\
  \ in your file system such that, at the ith minute, you will create a folder with\
  \ the name names[i].\nSince two files cannot have the same name, if you enter a\
  \ folder name which is previously used, the system will have a suffix addition to\
  \ its name in the form of (k), where, k is the smallest positive integer such that\
  \ the obtained name remains unique.\nReturn an array of strings of length n where\
  \ ans[i] is the actual name the system will assign to the ith folder when you create\
  \ it.\n \nExample 1:\nInput: names = [\"pes\",\"fifa\",\"gta\",\"pes(2019)\"]\n\
  Output: [\"pes\",\"fifa\",\"gta\",\"pes(2019)\"]\nExplanation: Let's see how the\
  \ file system creates folder names:\n\"pes\" --> not assigned before, remains \"\
  pes\"\n\"fifa\" --> not assigned before, remains \"fifa\"\n\"gta\" --> not assigned\
  \ before, remains \"gta\"\n\"pes(2019)\" --> not assigned before, remains \"pes(2019)\"\
  \n\nExample 2:\nInput: names = [\"gta\",\"gta(1)\",\"gta\",\"avalon\"]\nOutput:\
  \ [\"gta\",\"gta(1)\",\"gta(2)\",\"avalon\"]\nExplanation: Let's see how the file\
  \ system creates folder names:\n\"gta\" --> not assigned before, remains \"gta\"\
  \n\"gta(1)\" --> not assigned before, remains \"gta(1)\"\n\"gta\" --> the name is\
  \ reserved, system adds (k), since \"gta(1)\" is also reserved, systems put k =\
  \ 2. it becomes \"gta(2)\"\n\"avalon\" --> not assigned before, remains \"avalon\"\
  \n\nExample 3:\nInput: names = [\"onepiece\",\"onepiece(1)\",\"onepiece(2)\",\"\
  onepiece(3)\",\"onepiece\"]\nOutput: [\"onepiece\",\"onepiece(1)\",\"onepiece(2)\"\
  ,\"onepiece(3)\",\"onepiece(4)\"]\nExplanation: When the last folder is created,\
  \ the smallest positive valid k is 4, and it becomes \"onepiece(4)\".\n\nExample\
  \ 4:\nInput: names = [\"wano\",\"wano\",\"wano\",\"wano\"]\nOutput: [\"wano\",\"\
  wano(1)\",\"wano(2)\",\"wano(3)\"]\nExplanation: Just increase the value of k each\
  \ time you create folder \"wano\".\n\nExample 5:\nInput: names = [\"kaido\",\"kaido(1)\"\
  ,\"kaido\",\"kaido(1)\"]\nOutput: [\"kaido\",\"kaido(1)\",\"kaido(2)\",\"kaido(1)(1)\"\
  ]\nExplanation: Please note that system adds the suffix (k) to current name even\
  \ it contained the same suffix before.\n\n \nConstraints:\n\n1 <= names.length <=\
  \ 5 * 10^4\n1 <= names[i].length <= 20\nnames[i] consists of lower case English\
  \ letters, digits and/or round brackets."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def get_folder_names (names : List String) : List String := sorry\n\
  \ntheorem get_folder_names_output_length \n    (names : List String) :\n    List.length\
  \ (get_folder_names names) = List.length names := sorry\n"
"vc-theorems": "theorem get_folder_names_unique\n    (names : List String) :\n   \
  \ List.Nodup (get_folder_names names) := sorry\n\n\ntheorem get_folder_names_original_preserved\n\
  \    (names : List String)\n    (i : Nat)\n    (h : i < names.length) :\n    let\
  \ out := get_folder_names names\n    have h' : i < out.length := by\n      rw [get_folder_names_output_length\
  \ names]\n      exact h\n    let orig := names[i]'h\n    let gen := out[i]'h'\n\
  \    (∀ (j : Nat) (hj : j < i), names[j]'(Nat.lt_trans hj h) ≠ orig) →\n    (orig\
  \ = gen ∨ ∃ n : Nat, gen = orig ++ \"(\" ++ n.repr ++ \")\") := sorry\n\n/--\ninfo:\
  \ ['pes', 'fifa', 'gta', 'pes(2019)']\n-/\n#guard_msgs in\n#eval get_folder_names\
  \ [\"pes\", \"fifa\", \"gta\", \"pes(2019)\"]\n\n/--\ninfo: ['gta', 'gta(1)', 'gta(2)',\
  \ 'avalon']\n-/\n#guard_msgs in\n#eval get_folder_names [\"gta\", \"gta(1)\", \"\
  gta\", \"avalon\"]\n\n/--\ninfo: ['kaido', 'kaido(1)', 'kaido(2)', 'kaido(1)(1)']\n\
  -/\n#guard_msgs in\n#eval get_folder_names [\"kaido\", \"kaido(1)\", \"kaido\",\
  \ \"kaido(1)\"]\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
