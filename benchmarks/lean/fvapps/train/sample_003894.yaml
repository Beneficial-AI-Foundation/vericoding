"vc-description": "### self_converge\n`Goal`: Given a number (with a minimum of 3\
  \ digits), return the number of iterations it takes to arrive at a derived number\
  \ that converges on to itself, as per the following [Kaprekar][Kaprekar] routine.\
  \ As a learning exercise, come up with a solution that uses recursion. The\nfollowing\
  \ steps would be applicable to a number that originally had\nexactly 4 digits.\n\
  \n0. Initialize a counter to count the number of iterations\n1. Take any four-digit\
  \ number `n`, using at least two different digits.\n2. Arrange the digits in descending\
  \ and then in ascending order to get two four-digit numbers, adding leading zeros\
  \ if necessary. \n    - Add as many zeroes so that the width of the original number\
  \ is maintained.\n3. Subtract the smaller number from the bigger number. Let us\
  \ call this `nseq`.\n4. Check if `nseq` (the remainder) from Step 4 equals the previous\
  \ value of `n`. If not, increment the iteration counter and go back to step 2 and\
  \ perform it on the `nseq`. \n\nIf the number of digits to start with was more than\
  \ 4, convergence occurs on to a `cycle` of numbers. Therefore in Step 5, detect\
  \ this cycle by comparing to not only the previous value, but to all previous values\
  \ of `n`.\n  - If there is a match, then return the count of iterations\n  - If\
  \ the sequence_number collapses to zero, then return -1 \n\n[Kaprekar]: http://mathworld.wolfram.com/KaprekarRoutine.html\n\
  \n### Converge values  \nWhile 3-digit numbers converge to the same unique number\
  \ `k` which is also 3 digits long, all 4-digit numbers also converge to the same\
  \ unique value `k1` which is 4 digits long. However, 5 digit numbers converge to\
  \ any one of the following values: `53955, 59994, 61974, 62964, 63954, 71973, 74943,\
  \ 75933, 82962, 83952`.\n\n### Example\n`1234`  ->   `4`\n```\n1. 4321 - 1234 =\
  \  3087 /   \n2. 8730 - 378  =  8352 /   \n3. 8532 - 2358 =  6174 /   \n4. 7641\
  \ - 1467 =  6174 // same as previous\n```\n`414` -> `5`\n```\n1. 441 - 144 =  297\
  \ /   \n2. 972 - 279 =  693 /   \n3. 963 - 369 =  594 /\n4. 954 - 459 =  495 /\n\
  5. 954 - 459 =  495 // same as previous\n```\n`50000` -> `4`\n```\n1. 50000 - 5\
  \      =  49995 /   \n2. 99954 - 45999  =  53955 /  # first \n3. 95553 - 35559 \
  \ =  59994 /\n4. 99954 - 45999  =  53955 /  # 2nd time\n```"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def self_converge (n : Nat) : Int := sorry\n\ntheorem self_converge_properties\
  \ (n : Nat) \n  (h : n ≥ 1 ∧ n ≤ 999999) : \n  let result := self_converge n\n \
  \ -- Result is non-negative or -1\n  (result ≥ -1) ∧\n  -- Result length is bounded\n\
  \  (result ≠ -1 → result ≤ (Nat.toDigits 10 n).length * 20) ∧\n  -- Function is\
  \ deterministic \n  (self_converge n = result) ∧\n  -- Leading zeros don't affect\
  \ result\n  (self_converge (n * 10) = result) := sorry \n"
"vc-theorems": "theorem all_same_digits_converge (n d : Nat)\n  (h1 : d ≥ 0 ∧ d ≤\
  \ 9)\n  (h2 : ∃ k, n = d * (10^k - 1)/(10-1) ∧ k = 4) :\n  self_converge n = -1\
  \ := sorry\n\n\ntheorem single_digit_converge (n : Nat)\n  (h : n ≥ 1 ∧ n ≤ 9) :\n\
  \  self_converge n = -1 := sorry\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval self_converge\
  \ 4321\n\n/--\ninfo: 7\n-/\n#guard_msgs in\n#eval self_converge 211\n\n/--\ninfo:\
  \ 9\n-/\n#guard_msgs in\n#eval self_converge 90900\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
