"vc-description": "This is the easy version of the problem. The difference between\
  \ the versions is the constraint on $n$ and the required number of operations. You\
  \ can make hacks only if all versions of the problem are solved.\n\nThere are two\
  \ binary strings $a$ and $b$ of length $n$ (a binary string is a string consisting\
  \ of symbols $0$ and $1$). In an operation, you select a prefix of $a$, and simultaneously\
  \ invert the bits in the prefix ($0$ changes to $1$ and $1$ changes to $0$) and\
  \ reverse the order of the bits in the prefix.\n\nFor example, if $a=001011$ and\
  \ you select the prefix of length $3$, it becomes $011011$. Then if you select the\
  \ entire string, it becomes $001001$.\n\nYour task is to transform the string $a$\
  \ into $b$ in at most $3n$ operations. It can be proved that it is always possible.\n\
  \n\n-----Input-----\n\nThe first line contains a single integer $t$ ($1\\le t\\\
  le 1000$)  — the number of test cases. Next $3t$ lines contain descriptions of test\
  \ cases.\n\nThe first line of each test case contains a single integer $n$ ($1\\\
  le n\\le 1000$)  — the length of the binary strings.\n\nThe next two lines contain\
  \ two binary strings $a$ and $b$ of length $n$.\n\nIt is guaranteed that the sum\
  \ of $n$ across all test cases does not exceed $1000$.\n\n\n-----Output-----\n\n\
  For each test case, output an integer $k$ ($0\\le k\\le 3n$), followed by $k$ integers\
  \ $p_1,\\ldots,p_k$ ($1\\le p_i\\le n$). Here $k$ is the number of operations you\
  \ use and $p_i$ is the length of the prefix you flip in the $i$-th operation.\n\n\
  \n-----Example-----\nInput\n5\n2\n01\n10\n5\n01011\n11100\n2\n01\n01\n10\n0110011011\n\
  1000110100\n1\n0\n1\n\nOutput\n3 1 2 1\n6 5 2 5 3 1 2\n0\n9 4 1 2 10 4 1 2 1 5\n\
  1 1\n\n\n\n-----Note-----\n\nIn the first test case, we have $01\\to 11\\to 00\\\
  to 10$.\n\nIn the second test case, we have $01011\\to 00101\\to 11101\\to 01000\\\
  to 10100\\to 00100\\to 11100$.\n\nIn the third test case, the strings are already\
  \ the same. Another solution is to flip the prefix of length $2$, which will leave\
  \ $a$ unchanged."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def solve_binary_transform (n : Nat) (a b : String) : List Nat\
  \ :=\n  sorry\n"
"vc-theorems": "theorem singleton_case_constraints {n : Nat} {a b : String} \n  (h1\
  \ : n = 1)\n  (h2 : a.length = 1) \n  (h3 : b.length = 1)\n  (h4 : ∀ c ∈ a.data,\
  \ c = '0' ∨ c = '1')\n  (h5 : ∀ c ∈ b.data, c = '0' ∨ c = '1') :\n  let result :=\
  \ solve_binary_transform n a b\n  List.length result ≥ 2 ∧ \n  (List.head! result)\
  \ ≤ 3 :=\n  sorry\n\n\ntheorem length_constraints {n : Nat} {a b : String}\n  (h1\
  \ : n > 0)\n  (h2 : a.length = n)\n  (h3 : b.length = n) \n  (h4 : ∀ c ∈ a.data,\
  \ c = '0' ∨ c = '1')\n  (h5 : ∀ c ∈ b.data, c = '0' ∨ c = '1') :\n  let result :=\
  \ solve_binary_transform n a b\n  List.length result = (List.head! result) + 1 ∧\n\
  \  (List.head! result) ≤ 3*n ∧\n  ∀ x ∈ (result.tail), 1 ≤ x ∧ x ≤ n :=\n  sorry"
"vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded"
