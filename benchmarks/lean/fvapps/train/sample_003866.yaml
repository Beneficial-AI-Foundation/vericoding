"vc-description": "The new football league season is coming and the Football Association\
  \ need some help resetting the league standings. Normally the initial league standing\
  \ is done in alphabetical order (from A to Z) but this year the FA have decided\
  \ to freshen it up. \n\nIt has been decided that team who finished first last season\
  \ will begin the next season in first place. Regardless of what letter their club\
  \ begins with. e.g. if Manchester City were in first place last year, they will\
  \ begin the season in position one. All other teams should be in alphabetical order.\
  \ \n\nThe teams will be fed in as an object ({}). The key will be will be their\
  \ position from last season and the value is the club's name e.g. Arsenal. \n\n\
  The output should be an object ({}) with the key as the club's starting position\
  \ for the new season and the value should be club's name e.g. Arsenal.\n\nFor example.\
  \ If in the previous season the standings were:\n\n1:'Leeds United'\n2:'Liverpool'\n\
  3:'Manchester City'\n4:'Coventry'\n5:'Arsenal' \n\nThen the new season standings\
  \ should \n\n1:'Leeds United' (first last season)\n2:'Arsenal' (alphabetical)\n\
  3:'Coventry' (alphabetical) \n4:'Liverpool' (alphabetical) \n5:'Manchester City'\
  \ (alphabetical)"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def premier_league_standings (teams : TeamMap) : TeamMap := sorry\n\
  \ntheorem first_place_always_present (teams : TeamMap) \n  (h : teams.teams.any\
  \ (fun p => p.1 = \"1\")) :\n  let result := premier_league_standings teams\n  result.teams.any\
  \ (fun p => p.1 = \"1\") ∧\n  (result.teams.find? (fun p => p.1 = \"1\")).map Prod.snd\
  \ = \n  (teams.teams.find? (fun p => p.1 = \"1\")).map Prod.snd := sorry\n"
"vc-theorems": "theorem result_is_sorted (teams : TeamMap)\n  (h1 : teams.teams.any\
  \ (fun p => p.1 = \"1\"))\n  (h2 : teams.teams.length ≥ 2) :\n  let result := premier_league_standings\
  \ teams\n  let first_team := (teams.teams.find? (fun p => p.1 = \"1\")).map Prod.snd\n\
  \  let rest_teams := (teams.teams.map Prod.snd).filter (fun x => \n    match first_team\
  \ with\n    | none => true\n    | some ft => x ≠ ft)\n  result.teams.head?.map Prod.snd\
  \ = first_team ∧ \n  match result.teams.tail with\n  | [] => true\n  | xs => ∀ i\
  \ j, i < j → j < xs.length → \n         (xs.get ⟨i, sorry⟩).2 ≤ (xs.get ⟨j, sorry⟩).2\
  \ := sorry\n\n\ntheorem keys_are_sequential (teams : TeamMap)\n  (h : teams.teams.any\
  \ (fun p => p.1 = \"1\")) :\n  let result := premier_league_standings teams\n  ∀\
  \ i, i < result.teams.length → \n  result.teams.any (fun p => p.1 = toString (i\
  \ + 1)) := sorry\n\n\ntheorem no_duplicate_teams (teams : TeamMap)\n  (h : teams.teams.any\
  \ (fun p => p.1 = \"1\")) :\n  let result := premier_league_standings teams\n  (result.teams.map\
  \ Prod.snd).Nodup := sorry\n\n/--\ninfo: {'1': 'Arsenal'}\n-/\n#guard_msgs in\n\
  #eval premier_league_standings {\"1\": \"Arsenal\"}\n\n/--\ninfo: {'1': 'Leeds United',\
  \ '2': 'Accrington Stanley', '3': 'Arsenal'}\n-/\n#guard_msgs in\n#eval premier_league_standings\
  \ {\"2\": \"Arsenal\", \"3\": \"Accrington Stanley\", \"1\": \"Leeds United\"}\n\
  \n/--\ninfo: {'1': 'Leeds United', '2': 'Arsenal', '3': 'Coventry', '4': 'Liverpool',\
  \ '5': 'Manchester City'}\n-/\n#guard_msgs in\n#eval premier_league_standings {\"\
  1\": \"Leeds United\", \"2\": \"Liverpool\", \"3\": \"Manchester City\", \"4\":\
  \ \"Coventry\", \"5\": \"Arsenal\"}\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
