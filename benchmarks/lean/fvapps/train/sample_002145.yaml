"vc-description": "Greg has an array a = a_1, a_2, ..., a_{n} and m operations. Each\
  \ operation looks as: l_{i}, r_{i}, d_{i}, (1 ≤ l_{i} ≤ r_{i} ≤ n). To apply operation\
  \ i to the array means to increase all array elements with numbers l_{i}, l_{i}\
  \ + 1, ..., r_{i} by value d_{i}.\n\nGreg wrote down k queries on a piece of paper.\
  \ Each query has the following form: x_{i}, y_{i}, (1 ≤ x_{i} ≤ y_{i} ≤ m). That\
  \ means that one should apply operations with numbers x_{i}, x_{i} + 1, ..., y_{i}\
  \ to the array.\n\nNow Greg is wondering, what the array a will be after all the\
  \ queries are executed. Help Greg.\n\n\n-----Input-----\n\nThe first line contains\
  \ integers n, m, k (1 ≤ n, m, k ≤ 10^5). The second line contains n integers: a_1,\
  \ a_2, ..., a_{n} (0 ≤ a_{i} ≤ 10^5) — the initial array.\n\nNext m lines contain\
  \ operations, the operation number i is written as three integers: l_{i}, r_{i},\
  \ d_{i}, (1 ≤ l_{i} ≤ r_{i} ≤ n), (0 ≤ d_{i} ≤ 10^5).\n\nNext k lines contain the\
  \ queries, the query number i is written as two integers: x_{i}, y_{i}, (1 ≤ x_{i}\
  \ ≤ y_{i} ≤ m).\n\nThe numbers in the lines are separated by single spaces.\n\n\n\
  -----Output-----\n\nOn a single line print n integers a_1, a_2, ..., a_{n} — the\
  \ array after executing all the queries. Separate the printed numbers by spaces.\n\
  \nPlease, do not use the %lld specifier to read or write 64-bit integers in C++.\
  \ It is preferred to use the cin, cout streams of the %I64d specifier.\n\n\n-----Examples-----\n\
  Input\n3 3 3\n1 2 3\n1 2 1\n1 3 2\n2 3 4\n1 2\n1 3\n2 3\n\nOutput\n9 18 17\n\nInput\n\
  1 1 1\n1\n1 1 1\n1 1\n\nOutput\n2\n\nInput\n4 3 6\n1 2 3 4\n1 2 1\n2 3 2\n3 4 4\n\
  1 2\n1 3\n2 3\n1 2\n1 3\n2 3\n\nOutput\n5 18 31 20"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def solve_array_operations (n : Nat) (m : Nat) (k : Nat) (arr :\
  \ List Nat) (ops : List (Nat × Nat × Nat)) (queries : List (Nat × Nat)) : List Nat\
  \ := sorry \n\ntheorem empty_operations_preserve_array {n m k : Nat} (h1 : 0 < n\
  \ ∧ n ≤ 5) (h2 : 0 < m ∧ m ≤ 5) (h3 : 0 < k ∧ k ≤ 5) :\n  let arr := List.replicate\
  \ n 0\n  let ops := List.replicate m (1,1,0)\n  let queries := List.replicate k\
  \ (1,1)\n  solve_array_operations n m k arr ops queries = arr := \nsorry\n"
"vc-theorems": "theorem sample_case_one :\n  solve_array_operations 3 3 3 [1,2,3]\
  \ [(1,2,1), (1,3,2), (2,3,4)] [(1,2), (1,3), (2,3)] = [9,18,17] :=\nsorry\n\n\n\
  theorem sample_case_two :\n  solve_array_operations 1 1 1 [1] [(1,1,1)] [(1,1)]\
  \ = [2] :=\nsorry\n\n\ntheorem larger_array_case :\n  solve_array_operations 4 3\
  \ 6 [1,2,3,4] [(1,2,1), (2,3,2), (3,4,4)] \n    [(1,2), (1,3), (2,3), (1,2), (1,3),\
  \ (2,3)] = [5,18,31,20] :=\nsorry\n\n/--\ninfo: [9, 18, 17]\n-/\n#guard_msgs in\n\
  #eval solve_array_operations 3 3 3 [1, 2, 3] [(1, 2, 1), (1, 3, 2), (2, 3, 4)] [(1,\
  \ 2), (1, 3), (2, 3)]\n\n/--\ninfo: [2]\n-/\n#guard_msgs in\n#eval solve_array_operations\
  \ 1 1 1 [1] [(1, 1, 1)] [(1, 1)]\n\n/--\ninfo: [5, 18, 31, 20]\n-/\n#guard_msgs\
  \ in\n#eval solve_array_operations 4 3 6 [1, 2, 3, 4] [(1, 2, 1), (2, 3, 2), (3,\
  \ 4, 4)] [(1, 2), (1, 3), (2, 3), (1, 2), (1, 3), (2, 3)]\n"
"vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded"
