vc-description: |-
  Consider the following numbers (where `n!` is `factorial(n)`):
  ```
  u1 = (1 / 1!) * (1!)
  u2 = (1 / 2!) * (1! + 2!)
  u3 = (1 / 3!) * (1! + 2! + 3!)
  ...
  un = (1 / n!) * (1! + 2! + 3! + ... + n!)
  ```

  Which will win: `1 / n!` or `(1! + 2! + 3! + ... + n!)`?

  Are these numbers going to `0` because of `1/n!` or to infinity due
  to the sum of factorials or to another number?

  ## Task
  Calculate `(1 / n!) * (1! + 2! + 3! + ... + n!)` 
  for a given `n`, where `n` is an integer greater or equal to `1`.

  To avoid discussions about rounding, return the result **truncated** to 6 decimal places, for example:
  ```
  1.0000989217538616 will be truncated to 1.000098
  1.2125000000000001 will be truncated to 1.2125
  ```

  ## Remark
  Keep in mind that factorials grow rather rapidly, and you need to handle large inputs.

  ## Hint
  You could try to simplify the expression.
vc-preamble: |
  import Imports.AllImports

  def going (n : Nat) : Float := sorry

  theorem going_range (n : Nat) : 
    1 ≤ going n ∧ going n ≤ 2 := sorry
vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>
vc-definitions: |
  def calc_series (n : Nat) : Float := sorry

  theorem going_matches_calc_series (n : Nat) :
    n ≥ 1 → n ≤ 100 → Float.abs (going n - calc_series n) < 0.000001 := sorry
vc-theorems: |
  theorem going_decimal_places (n : Nat) :
    ∃ k : Nat, k ≤ 6 ∧ going n * Float.ofNat (10^k) = Float.floor (going n * Float.ofNat (10^k)) := sorry


  theorem going_specific_values :
    going 1 = 1.0 ∧ going 5 = 1.275 := sorry

  /--
  info: 1.275
  -/
  #guard_msgs in
  #eval going 5

  /--
  info: 1.2125
  -/
  #guard_msgs in
  #eval going 6

  /--
  info: 1.173214
  -/
  #guard_msgs in
  #eval going 7
vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded
