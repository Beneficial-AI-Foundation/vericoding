"vc-description": "Write a function name `nextPerfectSquare` that returns the first\
  \ perfect square that is greater than its integer argument. A `perfect square` is\
  \ a integer that is equal to some integer squared. For example 16 is a perfect square\
  \ because `16=4*4`. \n```\nexample\n\nn   next perfect sqare\n\n6    9\n36   49\
  \ \n0    1\n-5   0 \n```\n```if-not:csharp\ncaution! the largest number tested is\
  \ closer to `Number.MAX_SAFE_INTEGER`\n```\n```if:csharp\nCaution! The largest number\
  \ test is close to `Int64.MaxValue`\n```"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def next_perfect_square (n: Int) : Int := sorry\n\ntheorem next_perfect_square_non_negative\
  \ (n: Int) : \n  next_perfect_square n ≥ 0 := sorry\n"
"vc-theorems": "theorem next_perfect_square_negative_input (n: Int) : \n  n < 0 →\
  \ next_perfect_square n = 0 := sorry\n\n\ntheorem next_perfect_square_is_perfect\
  \ (n: Int) (h: n ≥ 0) :\n  ∃ m: Int, next_perfect_square n = m * m := sorry\n\n\n\
  theorem next_perfect_square_greater_than_input (n: Int) (h: n ≥ 0) :\n  next_perfect_square\
  \ n > n := sorry\n\n\ntheorem next_perfect_square_is_smallest (n: Int) (h: n ≥ 0)\
  \ :\n  ∀ m: Int, m * m > next_perfect_square n → m * m > n := sorry\n\n\ntheorem\
  \ next_perfect_square_of_perfect_square (n: Int) (h: n ≥ 0) :\n  next_perfect_square\
  \ (n * n) = (n + 1) * (n + 1) := sorry\n\n/--\ninfo: 9\n-/\n#guard_msgs in\n#eval\
  \ next_perfect_square 6\n\n/--\ninfo: 49\n-/\n#guard_msgs in\n#eval next_perfect_square\
  \ 36\n\n/--\ninfo: 0\n-/\n#guard_msgs in\n#eval next_perfect_square -5\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
