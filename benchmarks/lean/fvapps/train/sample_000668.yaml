"vc-description": "The Little Elephant likes permutations. This time he has a permutation\
  \ A[1], A[2], ..., A[N] of numbers 1, 2, ..., N.\n\nHe calls a permutation A good,\
  \ if the number of its inversions is equal to the number of its local inversions.\
  \ The number of inversions is equal to the number of pairs of integers (i; j) such\
  \ that 1 ≤ i < j ≤ N and A[i] > A[j], and the number of local inversions is the\
  \ number of integers i such that 1 ≤ i < N and A[i] > A[i+1].\n\nThe Little Elephant\
  \ has several such permutations. Help him to find for each permutation whether it\
  \ is good or not. Print YES for a corresponding test case if it is good and NO otherwise.\n\
  \n-----Input-----\n\nThe first line of the input contains a single integer T, the\
  \ number of test cases. T test cases follow. The first line of each test case contains\
  \ a single integer N, the size of a permutation. The next line contains N space\
  \ separated integers A[1], A[2], ..., A[N].\n\n-----Output-----\n\nFor each test\
  \ case output a single line containing the answer for the corresponding test case.\
  \ It should be YES if the corresponding permutation is good and NO otherwise.\n\n\
  -----Constraints-----\n1 ≤ T ≤ 474 \n\n1 ≤ N ≤ 100 \n\nIt is guaranteed that the\
  \ sequence A[1], A[2], ..., A[N] is a permutation of numbers 1, 2, ..., N.\n\n-----Example-----\n\
  Input:\n4\n1\n1\n2\n2 1\n3\n3 2 1\n4\n1 3 2 4\n\nOutput:\nYES\nYES\nNO\nYES\n\n\
  -----Explanation-----\nCase 1. Here N = 1, so we have no pairs (i; j) with 1 ≤ i\
  \ < j ≤ N. So the number of inversions is equal to zero. The number of local inversion\
  \ is also equal to zero. Hence this permutation is good.\n\nCase 2. Here N = 2,\
  \ and we have one pair (i; j) with 1 ≤ i < j ≤ N, the pair (1; 2). Since A[1] =\
  \ 2 and A[2] = 1 then A[1] > A[2] and the number of inversions is equal to 1. The\
  \ number of local inversion is also equal to 1 since we have one value of i for\
  \ which 1 ≤ i < N (the value i = 1) and A[i] > A[i+1] for this value of i since\
  \ A[1] > A[2]. Hence this permutation is also good.\n\nCase 3. Here N = 3, and we\
  \ have three pairs (i; j) with 1 ≤ i < j ≤ N. We have A[1] = 3, A[2] = 2, A[3] =\
  \ 1. Hence A[1] > A[2], A[1] > A[3] and A[2] > A[3]. So the number of inversions\
  \ is equal to 3. To count the number of local inversion we should examine inequalities\
  \ A[1] > A[2] and A[2] > A[3]. They both are satisfied in our case, so we have 2\
  \ local inversions. Since 2 ≠ 3 this permutations is not good.\n\nCase 4. Here we\
  \ have only one inversion and it comes from the pair (2; 3) since A[2] = 3 > 2 =\
  \ A[3]. This pair gives also the only local inversion in this permutation. Hence\
  \ the number of inversions equals to the number of local inversions and equals to\
  \ one. So this permutation is good."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def is_good_permutation (n : Nat) (arr : List Nat) : Bool := sorry\n\
  \ntheorem single_element_permutation_valid (n : Nat) :\n  n = 1 → is_good_permutation\
  \ n [1] = true := sorry\n"
"vc-theorems": "theorem basic_properties_sorted (n : Nat) (arr : List Nat) :\n  arr\
  \ = List.range' 1 n → is_good_permutation n arr = true := sorry\n\n\ntheorem small_permutations_valid\
  \ (n : Nat) (arr : List Nat) :\n  n ≤ 2 → arr = List.range' 1 n → is_good_permutation\
  \ n arr = true := sorry \n\n\ntheorem decreasing_sequence_invalid (n : Nat) :\n\
  \  n ≥ 3 → \n  let arr := List.reverse (List.range' 1 n)\n  is_good_permutation\
  \ n arr = false := sorry\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval is_good_permutation\
  \ 1 [1]\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval is_good_permutation 2 [2,\
  \ 1]\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval is_good_permutation 3 [3, 2,\
  \ 1]\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval is_good_permutation 4 [1, 3,\
  \ 2, 4]\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
