"vc-description": "You are given a certain integer, ```n, n > 0```. You have to search\
  \ the partition or partitions, of n, with maximum product value.\n\nLet'see the\
  \ case for ```n = 8```.\n```\nPartition                 Product\n[8]           \
  \               8\n[7, 1]                       7\n[6, 2]                      12\n\
  [6, 1, 1]                    6\n[5, 3]                      15\n[5, 2, 1]      \
  \             10\n[5, 1, 1, 1]                 5\n[4, 4]                      16\n\
  [4, 3, 1]                   12\n[4, 2, 2]                   16\n[4, 2, 1, 1]   \
  \              8\n[4, 1, 1, 1, 1]              4\n[3, 3, 2]                   18\
  \   <---- partition with maximum product value\n[3, 3, 1, 1]                 9\n\
  [3, 2, 2, 1]                12\n[3, 2, 1, 1, 1]              6\n[3, 1, 1, 1, 1,\
  \ 1]           3\n[2, 2, 2, 2]                16\n[2, 2, 2, 1, 1]              8\n\
  [2, 2, 1, 1, 1, 1]           4\n[2, 1, 1, 1, 1, 1, 1]        2\n[1, 1, 1, 1, 1,\
  \ 1, 1, 1]     1\n```\nSo our needed function will work in that way for Python and\
  \ Ruby:\n```\nfind_part_max_prod(8) == [[3, 3, 2], 18]\n```\nFor javascript\n```\n\
  findPartMaxProd(8) --> [[3, 3, 2], 18]\n```\nIf there are more than one partition\
  \ with maximum product value, the function should output the patitions in a length\
  \ sorted way.\nPython and Ruby\n```\nfind_part_max_prod(10) == [[4, 3, 3], [3, 3,\
  \ 2, 2], 36]\n```\nJavascript\n```\nfindPartMaxProd(10) --> [[4, 3, 3], [3, 3, 2,\
  \ 2], 36]\n```\nEnjoy it!"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def findPartMaxProd (n : Nat) : List (List Nat) × Nat := sorry\n\
  \ndef sumList : List Nat → Nat\n  | [] => 0\n  | x::xs => x + sumList xs\n"
"vc-theorems": "theorem find_part_max_prod_output_structure (n : Nat) (h : n > 0)\
  \ (h2 : n ≤ 1000) :\n  let result := findPartMaxProd n\n  if n = 1 then\n    result\
  \ = ([[1]], 1) \n  else if n % 3 = 1 then \n    result.1.length = 2 ∧\n    (∀ x\
  \ ∈ result.1, x.length > 0)\n  else\n    result.1.length = 1 ∧\n    result.1.head?.isSome\
  \ := sorry\n\n\ntheorem find_part_max_prod_sum_equals_input (n : Nat) (h : n > 0)\
  \ (h2 : n ≤ 1000) :\n  let result := findPartMaxProd n\n  ∀ parts ∈ result.1, sumList\
  \ parts = n := sorry\n\n\ntheorem find_part_max_prod_parts_valid (n : Nat) (h :\
  \ n > 0) (h2 : n ≤ 1000) :\n  let result := findPartMaxProd n\n  n = 1 ∨\n  (∀ parts\
  \ ∈ result.1,\n    (∀ x ∈ parts, x = 2 ∨ x = 3 ∨ x = 4) ∧ \n    ((parts.filter (·\
  \ = 4)).length ≤ 1)) := sorry"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
