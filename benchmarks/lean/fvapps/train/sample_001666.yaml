"vc-description": "Ever heard about Dijkstra's shallowest path algorithm? Me neither.\
  \ But I can imagine what it would be.\n\nYou're hiking in the wilderness of Northern\
  \ Canada and you must cross a large river. You have a map of one of the safer places\
  \ to cross the river showing the depths of the water on a rectangular grid. When\
  \ crossing the river you can only move from a cell to one of the (up to 8) neighboring\
  \ cells. You can start anywhere along the left river bank, but you have to stay\
  \ on the map.\n\nAn example of the depths provided on the map is \n\n```\n[[2, 3,\
  \ 2],\n [1, 1, 4],\n [9, 5, 2],\n [1, 4, 4],\n [1, 5, 4],\n [2, 1, 4],\n [5, 1,\
  \ 2],\n [5, 5, 5],\n [8, 1, 9]]\n```\nIf you study these numbers, you'll see that\
  \ there is a path accross the river (from left to right) where the depth never exceeds\
  \ 2. This path can be described by the list of pairs `[(1, 0), (1, 1), (2, 2)]`.\
  \ There are also other paths of equal maximum depth, e.g., `[(1, 0), (1, 1), (0,\
  \ 2)]`. The pairs denote the cells on the path where the first element in each pair\
  \ is the row and the second element is the column of a cell on the path.\n\nYour\
  \ job is to write a function `shallowest_path(river)` that takes a list of lists\
  \ of positive ints (or array of arrays, depending on language) showing the depths\
  \ of the river as shown in the example above and returns a shallowest path (i.e.,\
  \ the maximum depth is minimal) as a list of coordinate pairs (represented as tuples,\
  \ Pairs, or arrays, depending on language) as described above. If there are several\
  \ paths that are equally shallow, the function shall return a shortest such path.\
  \ All depths are given as positive integers."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def shallowest_path (river : List (List Int)) : List (Int × Int)\
  \ := sorry\n\ndef abs (n : Int) : Int := \n  if n < 0 then -n else n\n\n-- Given\
  \ any valid river array:\n-- 1. Path starts at first column\n-- 2. Path ends at\
  \ last column  \n-- 3. Path is contiguous with only adjacent moves allowed\n-- 4.\
  \ All coordinates are valid"
"vc-theorems": "theorem path_properties {river : List (List Int)} (h : river.length\
  \ > 0) (h2 : ∀ (row : List Int), row ∈ river → row.length = (List.head! river).length)\
  \ :\n  let path := shallowest_path river\n  -- Path starts at first column\n  (∀\
  \ p ∈ path, (List.head! path).2 = 0) ∧ \n  -- Path ends at last column\n  ((List.head!\
  \ river).length - 1 = (List.get! path (path.length - 1)).2) ∧\n  -- Path is contiguous\n\
  \  (∀ i < path.length - 1, \n    let p1 := List.get! path i\n    let p2 := List.get!\
  \ path (i+1)\n    abs (p2.1 - p1.1) ≤ 1 ∧ \n    abs (p2.2 - p1.2) ≤ 1 ∧\n    (p2.1\
  \ ≠ p1.1 ∨ p2.2 ≠ p1.2)) ∧\n  -- All coordinates are valid\n  (∀ p ∈ path, p.1 ≥\
  \ 0 ∧ p.1 < river.length ∧ p.2 ≥ 0 ∧ p.2 < (List.head! river).length) :=\n  sorry\n\
  \n-- For a single column river:\n-- Path has length 1 and is at first column\n\n\
  theorem single_column_path {river : List (List Int)} (h : ∀ row ∈ river, row.length\
  \ = 1) :\n  let path := shallowest_path river\n  path.length = 1 ∧ (List.head! path).2\
  \ = 0 :=\n  sorry\n\n-- For a single row river:\n-- All x coordinates are 0 and\
  \ ends at first column \n\ntheorem single_row_path {river : List (List Int)} (h\
  \ : river.length = 1) :\n  let path := shallowest_path river\n  (∀ p ∈ path, p.1\
  \ = 0) ∧ (List.get! path (path.length - 1)).2 = 0 :=\n  sorry\n\n/--\ninfo: [(1,\
  \ 0), (1, 1), (0, 2)]\n-/\n#guard_msgs in\n#eval shallowest_path [[2, 3, 2], [1,\
  \ 1, 4], [9, 5, 2], [1, 4, 4], [1, 5, 4], [2, 1, 4], [5, 1, 2], [5, 5, 5], [8, 1,\
  \ 9]]\n\n/--\ninfo: [(0, 0), (0, 1), (0, 2)]\n-/\n#guard_msgs in\n#eval shallowest_path\
  \ [[1, 2, 1]]\n\n/--\ninfo: [(0, 0)]\n-/\n#guard_msgs in\n#eval shallowest_path\
  \ [[1], [2], [3]]\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
