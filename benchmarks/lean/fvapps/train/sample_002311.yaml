"vc-description": "Given an array of integers nums, you start with an initial positive\
  \ value startValue.\nIn each iteration, you calculate the step by step sum of startValue plus elements\
  \ in nums (from left to right).\nReturn the minimum positive value of startValue\
  \ such that the step by step sum is never less than 1.\n \nExample 1:\nInput: nums\
  \ = [-3,2,-3,4,2]\nOutput: 5\nExplanation: If you choose startValue = 4, in the\
  \ third iteration your step by step sum is less than 1.\n                step by\
  \ step sum\n                startValue = 4 | startValue = 5 | nums\n           \
  \       (4 -3 ) = 1  | (5 -3 ) = 2    |  -3\n                  (1 +2 ) = 3  | (2\
  \ +2 ) = 4    |   2\n                  (3 -3 ) = 0  | (4 -3 ) = 1    |  -3\n   \
  \               (0 +4 ) = 4  | (1 +4 ) = 5    |   4\n                  (4 +2 ) =\
  \ 6  | (5 +2 ) = 7    |   2\n\nExample 2:\nInput: nums = [1,2]\nOutput: 1\nExplanation:\
  \ Minimum start value should be positive. \n\nExample 3:\nInput: nums = [1,-2,-3]\n\
  Output: 5\n\n \nConstraints:\n\n1 <= nums.length <= 100\n-100 <= nums[i] <= 100"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def min_start_value (nums : List Int) : Int := sorry\n\ndef running_sums\
  \ (start : Int) (nums : List Int) : List Int :=\n  match nums with\n  | [] => [start]\n\
  \  | x::xs => let rest := running_sums (start + x) xs\n             start :: rest\n\
  \n\n"
"vc-theorems": "theorem min_start_single_element (x : Int) :\n  let start := min_start_value\
  \ [x]\n  start ≥ 1 ∧ start + x ≥ 1 := sorry\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n\
  #eval min_start_value [-3, 2, -3, 4, 2]\n\n/--\ninfo: 1\n-/\n#guard_msgs in\n#eval\
  \ min_start_value [1, 2]\n\n/--\ninfo: 5\n-/\n#guard_msgs in\n#eval min_start_value\
  \ [1, -2, -3]\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible"
