"vc-description": "# Task\n In ChessLand there is a small but proud chess bishop with\
  \ a recurring dream. \n \n In the dream the bishop finds itself on an `n × m` chessboard\
  \ with mirrors along each edge, and it is not a bishop but a ray of light. This\
  \ ray of light moves only along diagonals (the bishop can't imagine any other types\
  \ of moves even in its dreams), it never stops, and once it reaches an edge or a\
  \ corner of the chessboard it reflects from it and moves on.\n\n Given the initial\
  \ position and the direction of the ray, find its position after `k` steps where\
  \ a step means either moving from one cell to the neighboring one or reflecting\
  \ from a corner of the board.\n\n# Example\n\n For `boardSize = [3, 7], initPosition\
  \ = [1, 2], initDirection = [-1, 1] and k = 13,` the output should be `[0, 1]`.\n\
  \n Here is the bishop's path:\n```\n[1, 2] -> [0, 3] -(reflection from the top edge)\n\
  \         -> [0, 4] -> [1, 5] -> [2, 6] -(reflection from the bottom right corner)\n\
  \         -> [2, 6] ->[1, 5] -> [0, 4] -(reflection from the top edge)\n       \
  \  -> [0, 3] ->[1, 2] -> [2, 1] -(reflection from the bottom edge)\n         ->\
  \ [2, 0] -(reflection from the left edge)\n         -> [1, 0] -> [0, 1]```\n\n ![](https://codefightsuserpics.s3.amazonaws.com/tasks/chessBishopDream/img/example.png?_tm=1472324389202)\n\
  \n# Input/Output\n\n\n - `[input]` integer array `boardSize`\n\n    An array of\
  \ two integers, the number of `rows` and `columns`, respectively. Rows are numbered\
  \ by integers from `0 to boardSize[0] - 1`, columns are numbered by integers from\
  \ `0 to boardSize[1] - 1` (both inclusive).\n\n    Constraints: `1 ≤ boardSize[i]\
  \ ≤ 20.`\n\n\n - `[input]` integer array `initPosition`\n\n    An array of two integers,\
  \ indices of the `row` and the `column` where the bishop initially stands, respectively.\n\
  \n    Constraints:  `0 ≤ initPosition[i] < boardSize[i]`.\n\n\n - `[input]` integer\
  \ array `initDirection`\n\n    An array of two integers representing the initial\
  \ direction of the bishop. \n    \n    If it stands in `(a, b)`, the next cell he'll\
  \ move to is `(a + initDirection[0], b + initDirection[1])` or whichever it'll reflect\
  \ to in case it runs into a mirror immediately.\n\n    Constraints: `initDirection[i]\
  \ ∈ {-1, 1}`.\n\n\n - `[input]` integer `k`\n\n    Constraints: `1 ≤ k ≤ 1000000000`.\n\
  \n\n - `[output]` an integer array\n\n    The position of the bishop after `k` steps."
"vc-preamble": "import Imports.AllImports\n\ndef chessBishopDream (boardSize: List\
  \ Int) (initPos: List Int) (initDir: List Int) (k: Nat) : List Int :=\n  sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def inRange (x: Int) (lower: Int) (upper: Int) : Prop :=\n  lower\
  \ ≤ x ∧ x < upper\n"
"vc-theorems": "theorem bishop_within_boundaries\n  (boardSize: List Int)\n  (initPos:\
  \ List Int) \n  (initDir: List Int)\n  (k: Nat)\n  (h1: boardSize.length = 2)\n\
  \  (h2: initPos.length = 2)\n  (h3: initDir.length = 2)\n  (h4: ∀ x ∈ boardSize,\
  \ 1 ≤ x ∧ x ≤ 100)\n  (h5: ∀ x ∈ initPos, 0 ≤ x ∧ x ≤ 100)\n  (h6: ∀ x ∈ initDir,\
  \ x = -1 ∨ x = 1)\n  (h7: 0 ≤ k ∧ k ≤ 1000) :\n  let result := chessBishopDream\
  \ boardSize initPos initDir k\n  List.length result = 2 ∧\n  (∀ i < 2, inRange (result[i]!)\
  \ 0 (boardSize[i]!)) :=\nsorry\n\n\ntheorem bishop_periodic\n  (boardSize: List\
  \ Int)\n  (initPos: List Int)\n  (initDir: List Int)\n  (h1: boardSize.length =\
  \ 2)\n  (h2: initPos.length = 2)\n  (h3: initDir.length = 2)\n  (h4: ∀ x ∈ boardSize,\
  \ 1 ≤ x ∧ x ≤ 100)\n  (h5: ∀ x ∈ initPos, 0 ≤ x ∧ x ≤ 100)\n  (h6: ∀ x ∈ initDir,\
  \ x = -1 ∨ x = 1) :\n  let period := (4 * boardSize[0]! * boardSize[1]!).toNat\n\
  \  chessBishopDream boardSize initPos initDir period = \n  chessBishopDream boardSize\
  \ initPos initDir 0 :=\nsorry\n\n\ntheorem bishop_reflection\n  (boardSize: List\
  \ Int)\n  (initPos: List Int)\n  (initDir: List Int)\n  (k: Nat)\n  (h1: boardSize.length\
  \ = 2)\n  (h2: initPos.length = 2)\n  (h3: initDir.length = 2)\n  (h4: ∀ x ∈ boardSize,\
  \ 1 ≤ x ∧ x ≤ 100)\n  (h5: ∀ x ∈ initPos, 0 ≤ x ∧ x ≤ 100)\n  (h6: ∀ x ∈ initDir,\
  \ x = -1 ∨ x = 1)\n  (h7: 0 ≤ k ∧ k ≤ 1000) :\n  let result := chessBishopDream\
  \ boardSize initPos initDir k\n  List.length result = 2 ∧\n  (∀ i < 2, result[i]!\
  \ ≤ boardSize[i]!) :=\nsorry\n\n/--\ninfo: [0, 1]\n-/\n#guard_msgs in\n#eval chess_bishop_dream\
  \ [3, 7] [1, 2] [-1, 1] 13\n\n/--\ninfo: [0, 1]\n-/\n#guard_msgs in\n#eval chess_bishop_dream\
  \ [1, 2] [0, 0] [1, 1] 6\n\n/--\ninfo: [1, 0]\n-/\n#guard_msgs in\n#eval chess_bishop_dream\
  \ [2, 2] [1, 0] [1, 1] 12\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
