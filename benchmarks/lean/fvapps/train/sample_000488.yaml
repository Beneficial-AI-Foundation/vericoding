"vc-description": "Given an array of positive integers target and an array initial\
  \ of same size with all zeros.\nReturn the minimum number of operations to form\
  \ a target array from initial if you are allowed to do the following operation:\n\
  \nChoose any subarray from initial and increment each value by one.\n\nThe answer\
  \ is guaranteed to fit within the range of a 32-bit signed integer.\n \nExample\
  \ 1:\nInput: target = [1,2,3,2,1]\nOutput: 3\nExplanation: We need at least 3 operations\
  \ to form the target array from the initial array.\n[0,0,0,0,0] increment 1 from\
  \ index 0 to 4 (inclusive).\n[1,1,1,1,1] increment 1 from index 1 to 3 (inclusive).\n\
  [1,2,2,2,1] increment 1 at index 2.\n[1,2,3,2,1] target array is formed.\n\nExample\
  \ 2:\nInput: target = [3,1,1,2]\nOutput: 4\nExplanation: (initial)[0,0,0,0] -> [1,1,1,1]\
  \ -> [1,1,1,2] -> [2,1,1,2] -> [3,1,1,2] (target).\n\nExample 3:\nInput: target\
  \ = [3,1,5,4,2]\nOutput: 7\nExplanation: (initial)[0,0,0,0,0] -> [1,1,1,1,1] ->\
  \ [2,1,1,1,1] -> [3,1,1,1,1] \n                                  -> [3,1,2,2,2]\
  \ -> [3,1,3,3,2] -> [3,1,4,4,2] -> [3,1,5,4,2] (target).\n\nExample 4:\nInput: target\
  \ = [1,1,1,1]\nOutput: 1\n\n \nConstraints:\n\n1 <= target.length <= 10^5\n1 <=\
  \ target[i] <= 10^5"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def min_number_operations (nums : List Nat) : Nat :=\n  sorry\n"
"vc-theorems": "theorem min_number_operations_non_negative (nums : List Nat) (h :\
  \ nums ≠ []) :\n  min_number_operations nums ≥ 0 := by\n  sorry\n\n\ntheorem min_number_operations_greater_than_first\
  \ (nums : List Nat) (h : nums ≠ []) :\n  min_number_operations nums ≥ nums[0]! :=\
  \ by\n  sorry\n\n\ntheorem min_number_operations_greater_than_max (nums : List Nat)\
  \ (h : nums ≠ []) :\n  min_number_operations nums ≥ List.foldl max 0 nums := by\n\
  \  sorry\n\n\ntheorem min_number_operations_monotonic (nums : List Nat) (h : nums\
  \ ≠ []) \n  (h2 : ∀ i, i + 1 < nums.length → nums[i]! ≤ nums[i+1]!) :\n  min_number_operations\
  \ nums = nums[nums.length - 1]! := by\n  sorry\n\n\ntheorem min_number_operations_constant_list\
  \ (nums : List Nat) (h : nums ≠ []) \n  (h2 : ∀ i, i < nums.length → nums[i]! =\
  \ nums[0]!) : \n  min_number_operations nums = nums[0]! := by\n  sorry\n\n\ntheorem\
  \ min_number_operations_sum_differences (nums : List Nat) (h : nums.length ≥ 2)\
  \ :\n  min_number_operations nums = nums[0]! + \n    (List.range (nums.length-1)).foldr\
  \ \n      (fun i acc => acc + max (nums[i+1]! - nums[i]!) 0) 0 := by\n  sorry\n\n\
  /--\ninfo: 3\n-/\n#guard_msgs in\n#eval min_number_operations [1, 2, 3, 2, 1]\n\n\
  /--\ninfo: 4\n-/\n#guard_msgs in\n#eval min_number_operations [3, 1, 1, 2]\n\n/--\n\
  info: 1\n-/\n#guard_msgs in\n#eval min_number_operations [1, 1, 1, 1]\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded"
