"vc-description": "A string is called a happy prefix if is a non-empty prefix which\
  \ is also a suffix (excluding itself).\nGiven a string s. Return the longest happy\
  \ prefix of s .\nReturn an empty string if no such prefix exists.\n \nExample 1:\n\
  Input: s = \"level\"\nOutput: \"l\"\nExplanation: s contains 4 prefix excluding\
  \ itself (\"l\", \"le\", \"lev\", \"leve\"), and suffix (\"l\", \"el\", \"vel\"\
  , \"evel\"). The largest prefix which is also suffix is given by \"l\".\n\nExample\
  \ 2:\nInput: s = \"ababab\"\nOutput: \"abab\"\nExplanation: \"abab\" is the largest\
  \ prefix which is also suffix. They can overlap in the original string.\n\nExample\
  \ 3:\nInput: s = \"leetcodeleet\"\nOutput: \"leet\"\n\nExample 4:\nInput: s = \"\
  a\"\nOutput: \"\"\n\n \nConstraints:\n\n1 <= s.length <= 10^5\ns contains only lowercase\
  \ English letters."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def longest_prefix (s : String) : String :=\n  sorry\n"
"vc-theorems": "theorem output_is_prefix {s : String} (h : s.length > 0) :\n  (longest_prefix\
  \ s).isPrefixOf s := by\n  sorry\n\n\ntheorem output_is_suffix {s : String} (h :\
  \ s.length > 0) :\n  String.drop s (s.length - (longest_prefix s).length) = longest_prefix\
  \ s := by\n  sorry\n\n\ntheorem output_length_less_than_input {s : String} (h :\
  \ s.length > 0) :\n  (longest_prefix s).length ≤ s.length := by\n  sorry\n\n\ntheorem\
  \ output_matches_input_chars {s : String} (h : s.length > 0) :\n  ∀ c, c ∈ (longest_prefix\
  \ s).data → c ∈ s.data := by\n  sorry\n\n/--\ninfo: 'l'\n-/\n#guard_msgs in\n#eval\
  \ longest_prefix \"level\"\n\n/--\ninfo: 'abab'\n-/\n#guard_msgs in\n#eval longest_prefix\
  \ \"ababab\"\n\n/--\ninfo: 'leet'\n-/\n#guard_msgs in\n#eval longest_prefix \"leetcodeleet\"\
  \n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
