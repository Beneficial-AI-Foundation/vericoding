"vc-description": "Chef had an array A with length N, but some of its elements got\
  \ lost. Now, each element of this array is either unknown (denoted by -1) or a positive\
  \ integer not exceeding K.\nChef decided to restore the array A by replacing each\
  \ unknown element by a positive integer not exceeding K.\nHowever, Chef has M restrictions\
  \ that must hold for the restored array. There are two types of restrictions:\n\n\
  - I L R, meaning that for each i such that L < i ≤ R, the condition Ai - Ai-1 =\
  \ 1 should be satisfied.\n- D L R, meaning that for each i such that L < i  ≤ R,\
  \ the condition Ai - Ai-1 = -1 should be satisfied.\n\nChef would like to know the\
  \ number of ways to restore the array while satisfying all restrictions, modulo\
  \ 109+7.\n\n-----Input-----\n- The first line of the input contains a single integer\
  \ T denoting the number of test cases. The description of T test cases follows.\n\
  - The first line of each test case contains three space-separated integers N, M\
  \ and K.\n- The second line contains N integers A1, A2, ..., AN.\n- Each of the\
  \ following M lines contains one restriction in the form I L R or D L R.\n\n-----Output-----\n\
  For each test case, print a single line containing one integer - the number of ways\
  \ to restore the array modulo 109+7.\n\n-----Constraints-----\n- 1 ≤ T ≤ 10\n- 1\
  \ ≤ N, M ≤ 100,000\n- 1 ≤ K ≤ 1,000,000,000\n- 1 ≤ L < R ≤ N\n- 1 ≤ Ai ≤ K or Ai\
  \ = -1 for each valid i\n- 1 ≤ sum of N over all test cases ≤ 500,000\n- 1 ≤ sum\
  \ of M over all test cases ≤ 500,000\n\n-----Example-----\nInput:\n\n3\n4 2 10\n\
  2 3 5 4\nI 1 2 \nD 3 4\n5 2 10\n-1 -1 -1 -1 -1\nI 1 3\nD 3 5\n6 2 2\n-1 -1 -1 -1\
  \ -1 -1\nI 1 4\nD 4 6\n\nOutput:\n\n1\n8\n0"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def solve_array_restoration (N M K : Nat) (A : List Int) (restrictions\
  \ : List (String × Nat × Nat)) : Nat :=\n  sorry\n"
"vc-theorems": "theorem result_non_negative (N M K : Nat) (A : List Int) \n    (restrictions\
  \ : List (String × Nat × Nat)) :\n  solve_array_restoration N M K A restrictions\
  \ ≥ 0 := sorry\n\n\ntheorem result_within_mod (N M K : Nat) (A : List Int)\n   \
  \ (restrictions : List (String × Nat × Nat)) :\n  solve_array_restoration N M K\
  \ A restrictions < 1000000007 := sorry\n\n\ntheorem invalid_upper_bound (N M K :\
  \ Nat) (A : List Int)\n    (restrictions : List (String × Nat × Nat)) :\n  (∃ x\
  \ ∈ A, x ≠ -1 ∧ x > K) →\n  solve_array_restoration N M K A restrictions = 0 :=\
  \ sorry\n\n\ntheorem invalid_lower_bound (N M K : Nat) (A : List Int)\n    (restrictions\
  \ : List (String × Nat × Nat)) :\n  (∃ x ∈ A, x ≠ -1 ∧ x < 1) →\n  solve_array_restoration\
  \ N M K A restrictions = 0 := sorry\n\n\ntheorem overlapping_opposite_restrictions\
  \ (N M K : Nat) (A : List Int)\n    (restrictions : List (String × Nat × Nat)) :\n\
  \  (∃ i j type1 type2 L1 R1 L2 R2,\n    type1 ≠ type2 ∧\n    max L1 L2 ≤ min R1\
  \ R2 ∧\n    restrictions.get! i = (type1, L1, R1) ∧\n    restrictions.get! j = (type2,\
  \ L2, R2)) →\n  solve_array_restoration N M K A restrictions = 0 := sorry\n\n/--\n\
  info: 1\n-/\n#guard_msgs in\n#eval solve_array_restoration 4 2 10 [2, 3, 5, 4] [(\"\
  I\", 1, 2), (\"D\", 3, 4)]\n\n/--\ninfo: 8\n-/\n#guard_msgs in\n#eval solve_array_restoration\
  \ 5 2 10 [-1, -1, -1, -1, -1] [(\"I\", 1, 3), (\"D\", 3, 5)]\n\n/--\ninfo: 0\n-/\n\
  #guard_msgs in\n#eval solve_array_restoration 6 2 2 [-1, -1, -1, -1, -1, -1] [(\"\
  I\", 1, 4), (\"D\", 4, 6)]\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
