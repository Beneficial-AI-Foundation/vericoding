"vc-description": "__Definition:__ According to Wikipedia, a [complete binary tree](https://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees)\
  \ is a binary tree _\"where every level, except possibly the last, is completely\
  \ filled, and all nodes in the last level are as far left as possible.\"_\n\nThe\
  \ Wikipedia page referenced above also mentions that _\"Binary trees can also be\
  \ stored in breadth-first order as an implicit data structure in arrays, and if\
  \ the tree is a complete binary tree, this method wastes no space.\"_\n\nYour task\
  \ is to write a method (or function) that takes an array (or list, depending on\
  \ language) of integers and, assuming that the array is ordered according to an\
  \ _in-order_ traversal of a complete binary tree, returns an array that contains\
  \ the values of the tree in breadth-first order.\n\n__Example 1:__\nLet the input\
  \ array be `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`. This array contains the values of\
  \ the following complete binary tree. \n\n\n```\n          _ 7_\n        /     \
  \ \\\n       4        9\n     /   \\     / \\\n   2      6   8   10\n  / \\    \
  \ /\n 1   3   5\n```\nIn this example, the input array happens to be sorted, but\
  \ that is _not_ a requirement.\n\n__Output 1:__ The output of the function shall\
  \ be an array containing the values of the nodes of the binary tree read top-to-bottom,\
  \ left-to-right. In this example, the returned array should be:\n\n```[7, 4, 9,\
  \ 2, 6, 8, 10, 1, 3, 5]```\n\n\n__Example 2:__\nLet the input array be `[1, 2, 2,\
  \ 6, 7, 5]`. This array contains the values of the following complete binary tree.\
  \ \n\n\n```\n        6\n      /   \\\n    2       5\n   / \\     /\n  1   2   7\n\
  \ \n```\nNote that an in-order traversal of this tree produces the input array.\n\
  \n__Output 2:__ The output of the function shall be an array containing the values\
  \ of the nodes of the binary tree read top-to-bottom, left-to-right. In this example,\
  \ the returned array should be:\n\n```[6, 2, 5, 1, 2, 7]```"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def complete_binary_tree {α : Type} [Ord α] (arr : List α) : List\
  \ α := sorry\n\ndef isSortedEquivalent {α : Type} [Ord α] (l1 l2 : List α) : Prop\
  \ := sorry \n"
"vc-theorems": "theorem complete_binary_tree_preserves_elements {α : Type} [Ord α]\
  \ (arr : List α) (h : arr ≠ []) :\n  let result := complete_binary_tree arr\n  List.length\
  \ result = List.length arr ∧ \n  isSortedEquivalent result arr := sorry\n\n\ntheorem\
  \ complete_binary_tree_idempotent_length {α : Type} [Ord α] (arr : List α) (h :\
  \ arr ≠ []) :\n  let first := complete_binary_tree arr\n  let second := complete_binary_tree\
  \ first\n  List.length first = List.length arr ∧ \n  List.length second = List.length\
  \ arr := sorry\n\n\ntheorem complete_binary_tree_generic_type {α : Type} [Ord α]\
  \ (arr : List α) (h : arr ≠ []) :\n  List.length (complete_binary_tree arr) = List.length\
  \ arr := sorry\n\n/--\ninfo: [1]\n-/\n#guard_msgs in\n#eval complete_binary_tree\
  \ [1]\n\n/--\ninfo: [4, 2, 6, 1, 3, 5]\n-/\n#guard_msgs in\n#eval complete_binary_tree\
  \ [1, 2, 3, 4, 5, 6]\n\n/--\ninfo: [7, 4, 9, 2, 6, 8, 10, 1, 3, 5]\n-/\n#guard_msgs\
  \ in\n#eval complete_binary_tree [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
