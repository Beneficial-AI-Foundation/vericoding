"vc-description": "An agent called Cypher is decrypting a message, that contains a\
  \ composite number $n$. All divisors of $n$, which are greater than $1$, are placed\
  \ in a circle. Cypher can choose the initial order of numbers in the circle.\n\n\
  In one move Cypher can choose two adjacent numbers in a circle and insert their\
  \ least common multiple between them. He can do that move as many times as needed.\n\
  \nA message is decrypted, if every two adjacent numbers are not coprime. Note that\
  \ for such constraints it's always possible to decrypt the message.\n\nFind the\
  \ minimal number of moves that Cypher should do to decrypt the message, and show\
  \ the initial order of numbers in the circle for that.\n\n\n-----Input-----\n\n\
  The first line contains an integer $t$ $(1 \\le t \\le 100)$ — the number of test\
  \ cases. Next $t$ lines describe each test case.\n\nIn a single line of each test\
  \ case description, there is a single composite number $n$ $(4 \\le n \\le 10^9)$ —\
  \ the number from the message.\n\nIt's guaranteed that the total number of divisors\
  \ of $n$ for all test cases does not exceed $2 \\cdot 10^5$.\n\n\n-----Output-----\n\
  \nFor each test case in the first line output the initial order of divisors, which\
  \ are greater than $1$, in the circle. In the second line output, the minimal number\
  \ of moves needed to decrypt the message.\n\nIf there are different possible orders\
  \ with a correct answer, print any of them.\n\n\n-----Example-----\nInput\n3\n6\n\
  4\n30\n\nOutput\n2 3 6 \n1\n2 4 \n0\n2 30 6 3 15 5 10 \n0\n\n\n\n-----Note-----\n\
  \nIn the first test case $6$ has three divisors, which are greater than $1$: $2,\
  \ 3, 6$. Regardless of the initial order, numbers $2$ and $3$ are adjacent, so it's\
  \ needed to place their least common multiple between them. After that the circle\
  \ becomes $2, 6, 3, 6$, and every two adjacent numbers are not coprime.\n\nIn the\
  \ second test case $4$ has two divisors greater than $1$: $2, 4$, and they are not\
  \ coprime, so any initial order is correct, and it's not needed to place any least\
  \ common multiples.\n\nIn the third test case all divisors of $30$ greater than\
  \ $1$ can be placed in some order so that there are no two adjacent numbers that\
  \ are coprime."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def getPrimeFactors (n : Nat) : List Nat := sorry\ndef solveCipher\
  \ (n : Nat) : List Nat × Nat := sorry\n"
"vc-theorems": "theorem result_factors_product_match {n : Nat} (h : n ≥ 4) (h₂ : n\
  \ ≤ 10^4) \n  (h₃ : (getPrimeFactors n).length ≥ 3) :\n  let result := (solveCipher\
  \ n).fst\n  (∀ x, x ∈ result → n % x = 0) ∧ \n  (∀ x y, x ∈ result → y ∈ result\
  \ → x ≠ y) := sorry\n\n\ntheorem prime_power_handling {n : Nat} (h : n ≥ 4) (h₂\
  \ : n ≤ 10^4)\n  (h₃ : (getPrimeFactors n).length ≥ 3) :\n  let result := solveCipher\
  \ n\n  let distinctFactors := List.eraseDups (getPrimeFactors n)\n  (distinctFactors.length\
  \ = 2 ∧ (getPrimeFactors n).length = 2) →\n    result.snd = 1 ∧\n    let pf := List.eraseDups\
  \ (getPrimeFactors n)\n    (∃ x y z, x ∈ result.fst ∧ y ∈ result.fst ∧ z ∈ result.fst\
  \ ∧ \n      x = List.head! pf ∧ y = List.get! pf 1 ∧ z = (List.head! pf) * (List.get!\
  \ pf 1)) ∧\n  (¬(distinctFactors.length = 2 ∧ (getPrimeFactors n).length = 2)) →\n\
  \    result.snd = 0 := sorry\n\n\ntheorem contains_prime_factors {n : Nat} (h :\
  \ n ≥ 4) (h₂ : n ≤ 10^4)\n  (h₃ : (getPrimeFactors n).length ≥ 3) :\n  let result\
  \ := (solveCipher n).fst\n  let primeFactors := List.eraseDups (getPrimeFactors\
  \ n)\n  ∀ p, p ∈ primeFactors → ∃ x, x ∈ result ∧ x % p = 0 := sorry\n\n/--\ninfo:\
  \ 3\n-/\n#guard_msgs in\n#eval len ans[0]\n\n/--\ninfo: {2, 3, 6}\n-/\n#guard_msgs\
  \ in\n#eval set ans[0]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n#eval len ans[0]\n\n\
  /--\ninfo: {2, 4}\n-/\n#guard_msgs in\n#eval set ans[0]\n\n/--\ninfo: 7\n-/\n#guard_msgs\
  \ in\n#eval len ans[0]\n\n/--\ninfo: {2, 3, 5, 6, 10, 15, 30}\n-/\n#guard_msgs in\n\
  #eval set ans[0]\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
