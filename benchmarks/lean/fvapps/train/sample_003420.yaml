"vc-description": "In this kata, your task is to identify the pattern underlying a\
  \ sequence of numbers. For example, if the sequence is [1, 2, 3, 4, 5], then the\
  \ pattern is [1], since each number in the sequence is equal to the number preceding\
  \ it, plus 1. See the test cases for more examples.\n\nA few more rules :\n\npattern\
  \ may contain negative numbers.\nsequence will always be made of a whole number\
  \ of repetitions of the pattern.\nYour answer must correspond to the shortest form\
  \ of the pattern, e.g. if the pattern is [1], then [1, 1, 1, 1] will not be considered\
  \ a correct answer."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def findPattern (sequence : List Int) : Option (List Int) := sorry\n\
  \ndef differencesSeq (sequence : List Int) : List Int :=\n  (sequence.zip (sequence.drop\
  \ 1)).map (fun (x, y) => y - x)\n"
"vc-theorems": "theorem valid_differences_pattern (sequence : List Int) (h : sequence.length\
  \ ≥ 2) : \n  match findPattern sequence with\n  | none => True \n  | some pattern\
  \ =>\n    let diffs := differencesSeq sequence\n    -- Pattern length divides sequence\
  \ length\n    diffs.length % pattern.length = 0 ∧\n    -- Pattern matches when repeated\n\
  \    let repeatedPattern := List.replicate (diffs.length / pattern.length) pattern\
  \ |>.join\n    List.zip diffs repeatedPattern |>.all (fun (a, b) => a = b)\n  :=\
  \ sorry\n\n\ntheorem minimal_pattern (sequence : List Int) (h : sequence.length\
  \ ≥ 2) :\n  match findPattern sequence with\n  | none => True\n  | some pattern\
  \ =>\n    let diffs := differencesSeq sequence\n    ∀ i : Nat, 1 ≤ i → i < pattern.length\
  \ → diffs.length % i = 0 →\n      let shortPattern := diffs.take i\n      let repeatedShortPattern\
  \ := List.replicate (diffs.length / i) shortPattern |>.join\n      ¬(List.zip diffs\
  \ repeatedShortPattern |>.all (fun (a, b) => a = b))\n  := sorry\n\n\ntheorem arithmetic_sequence_pattern\
  \ (d : Int) (len : Nat) (h₁ : 1 ≤ d ∧ d ≤ 9) (h₂ : 2 ≤ len ∧ len ≤ 100) :\n  let\
  \ arithmetic := List.range len |>.map (fun n => Int.ofNat n * d)\n  match findPattern\
  \ arithmetic with\n  | none => False\n  | some pattern =>\n    pattern.length =\
  \ 1 ∧ pattern.head! = d\n  := sorry\n\n/--\ninfo: [1]\n-/\n#guard_msgs in\n#eval\
  \ find_pattern [1, 2, 3, 4, 5]\n\n/--\ninfo: [1, 1, 1, 1, -1, -1, -1, -1]\n-/\n\
  #guard_msgs in\n#eval find_pattern [1, 2, 3, 4, 5, 4, 3, 2, 1, 2, 3, 4, 5, 4, 3,\
  \ 2, 1]\n\n/--\ninfo: [1, 2, -1, -2, -2, 1, 2, -1, -2]\n-/\n#guard_msgs in\n#eval\
  \ find_pattern [4, 5, 7, 6, 4, 2, 3, 5, 4, 2, 3, 5, 4, 2, 0, 1, 3, 2, 0, 1, 3, 2,\
  \ 0, -2, -1, 1, 0, -2]\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
