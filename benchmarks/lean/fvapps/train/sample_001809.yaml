"vc-description": "Given the root of a binary tree, then value v and depth d, you\
  \ need to add a row of nodes with value v at the given depth d. The root node is\
  \ at depth 1. \n\nThe adding rule is: given a positive integer depth d, for each\
  \ NOT null tree nodes N in depth d-1, create two tree nodes with value v as N's\
  \ left subtree root and right subtree root. And N's original left subtree should\
  \ be the left subtree of the new left subtree root, its original right subtree should\
  \ be the right subtree of the new right subtree root. If depth d is 1 that means\
  \ there is no depth d-1 at all, then create a tree node with value v as the new\
  \ root of the whole original tree, and the original tree is the new root's left\
  \ subtree.\n\nExample 1:\n\nInput: \nA binary tree as following:\n       4\n   \
  \  /   \\\n    2     6\n   / \\   / \n  3   1 5   \n\nv = 1\n\nd = 2\n\nOutput:\
  \ \n       4\n      / \\\n     1   1\n    /     \\\n   2       6\n  / \\     / \n\
  \ 3   1   5   \n\n\n\n\n\nExample 2:\n\nInput: \nA binary tree as following:\n \
  \     4\n     /   \n    2    \n   / \\   \n  3   1    \n\nv = 1\n\nd = 3\n\nOutput:\
  \ \n      4\n     /   \n    2\n   / \\    \n  1   1\n /     \\  \n3       1\n\n\n\
  \nNote:\n\nThe given d is in range [1, maximum depth of the given tree + 1].\nThe\
  \ given binary tree has at least one tree node."
"vc-preamble": "import Imports.AllImports\n\ndef list_to_tree : List Int → TreeNode\
  \ :=\n  sorry\n\n\ndef tree_to_list : TreeNode → List Int :=\n  sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def add_one_row : TreeNode → Int → Int → TreeNode :=\n  sorry\n"
"vc-theorems": "theorem add_one_row_result_nonempty (t : TreeNode) (v : Int) (d :\
  \ Int)\n  (h1 : -100 ≤ v ∧ v ≤ 100) (h2 : 1 ≤ d ∧ d ≤ 3) :\n  ∃ l : List Int, tree_to_list\
  \ (add_one_row t v d) = l ∧ l ≠ [] :=\n  sorry\n\n\ntheorem add_one_row_depth_one\
  \ (t : TreeNode) (v : Int) (orig_val : Int)\n  (h1 : -100 ≤ v ∧ v ≤ 100) (h2 : t\
  \ ≠ TreeNode.leaf) :\n  let result := add_one_row t v 1\n  let result_list := tree_to_list\
  \ result\n  result_list.head? = some v ∧\n  result_list.get? 1 = some orig_val :=\n\
  \  sorry\n\n\ntheorem add_one_row_single_node (val v : Int) (d : Int)\n  (h1 : -100\
  \ ≤ val ∧ val ≤ 100) (h2 : -100 ≤ v ∧ v ≤ 100) (h3 : d = 1 ∨ d = 2) :\n  let t :=\
  \ TreeNode.node val TreeNode.leaf TreeNode.leaf\n  let result := add_one_row t v\
  \ d\n  let result_list := tree_to_list result\n  (d = 1 → result_list.head? = some\
  \ v ∧ result_list.get? 1 = some val) ∧\n  (d = 2 → result_list.head? = some val\
  \ ∧ \n           result_list.get? 1 = some v ∧\n           result_list.get? 2 =\
  \ some v) :=\n  sorry\n\n/--\ninfo: [4, 1, 1, 2, None, None, 6, 3, 1, 5]\n-/\n#guard_msgs\
  \ in\n#eval tree_to_list add_one_row(root1, 1, 2)\n\n/--\ninfo: [4, 2, None, 1,\
  \ 1, 3, None, None, 1]\n-/\n#guard_msgs in\n#eval tree_to_list add_one_row(root2,\
  \ 1, 3)\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
