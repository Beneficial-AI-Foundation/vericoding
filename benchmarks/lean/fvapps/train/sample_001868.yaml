"vc-description": "We are given the root node of a maximum tree: a tree where every\
  \ node has a value greater than any other value in its subtree.\nJust as in the\
  \ previous problem, the given tree was constructed from an list A (root = Construct(A))\
  \ recursively with the following Construct(A) routine:\n\nIf A is empty, return\
  \ null.\nOtherwise, let A[i] be the largest element of A.  Create a root node with\
  \ value A[i].\nThe left child of root will be Construct([A[0], A[1], ..., A[i-1]])\n\
  The right child of root will be Construct([A[i+1], A[i+2], ..., A[A.length - 1]])\n\
  Return root.\n\nNote that we were not given A directly, only a root node root =\
  \ Construct(A).\nSuppose B is a copy of A with the value val appended to it.  It\
  \ is guaranteed that B has unique values.\nReturn Construct(B).\n \nExample 1:\n\
  \nInput: root = [4,1,3,null,null,2], val = 5\nOutput: [5,4,null,1,3,null,null,2]\n\
  Explanation: A = [1,4,2,3], B = [1,4,2,3,5]\n\nExample 2:\n\nInput: root = [5,2,4,null,1],\
  \ val = 3\nOutput: [5,2,4,null,1,null,3]\nExplanation: A = [2,1,5,4], B = [2,1,5,4,3]\n\
  \nExample 3:\n\nInput: root = [5,2,3,null,1], val = 4\nOutput: [5,2,4,null,1,3]\n\
  Explanation: A = [2,1,5,3], B = [2,1,5,3,4]\n\n \nConstraints:\n\n1 <= B.length\
  \ <= 100"
"vc-preamble": "import Imports.AllImports\n\ndef insertIntoMaxTree (root: Option TreeNode)\
  \ (val: Int) : TreeNode :=\n  sorry\n\n\ndef buildTree (vals: List Int) : Option\
  \ TreeNode :=\n  sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def treeToList (t: TreeNode) : List Int :=\n  sorry\n\npartial\
  \ def isMaxTree : TreeNode → Bool \n| TreeNode.node v l r => \n  match l, r with\n\
  \  | none, none => true \n  | some (TreeNode.node lv ll lr), none => v ≥ lv && isMaxTree\
  \ (TreeNode.node lv ll lr)\n  | none, some (TreeNode.node rv rl rr) => v ≥ rv &&\
  \ isMaxTree (TreeNode.node rv rl rr)\n  | some (TreeNode.node lv ll lr), some (TreeNode.node\
  \ rv rl rr) => \n      v ≥ lv && v ≥ rv && \n      isMaxTree (TreeNode.node lv ll\
  \ lr) && \n      isMaxTree (TreeNode.node rv rl rr)\n"
"vc-theorems": "theorem insert_single_node (val: Int) (h: val > 0) : \n  match insertIntoMaxTree\
  \ none val with\n  | TreeNode.node v l r => v = val ∧ l = none ∧ r = none :=\nsorry\n\
  \n\ntheorem insert_maintains_values (vals: List Int) (new_val: Int)\n  (h1: ∀ x,\
  \ x ∈ vals → x > 0)\n  (h2: new_val > 0) \n  (h3: vals ≠ [])\n  (h4: ∀ x y, x ∈\
  \ vals → y ∈ vals → x ≠ y) :\n  let root := buildTree vals\n  let result := insertIntoMaxTree\
  \ root new_val\n  let result_list := treeToList result\n  (∀ x, x ∈ vals → x ∈ result_list)\
  \ ∧ new_val ∈ result_list :=\nsorry"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded"
