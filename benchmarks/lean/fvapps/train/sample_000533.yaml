"vc-description": "Two players are playing a game. The game is played on a sequence\
  \ of positive integer pairs. The players make their moves alternatively. During\
  \ his move the player chooses a pair and decreases the larger integer in the pair\
  \ by a positive multiple of the smaller integer in the pair in such a way that both\
  \ integers in the pair remain positive. If two numbers in some pair become equal\
  \ then the pair is removed from the sequence. The player who can not make any move\
  \ loses (or in another words the player who encounters an empty sequence loses).\
  \ Given the sequence of positive integer pairs determine whether the first player\
  \ can win or not (assuming that both players are playing optimally).\n\n-----Input-----\n\
  The first line of the input contains an integer T denoting the number of test cases.\
  \ The description of T test cases follows.\nEach test starts with an integer N denoting\
  \ the number of pairs. Each of the next N lines contains a pair of positive integers.\
  \ \n\n-----Output-----\nFor each test case, output a single line containing \"YES\"\
  \ if the first player can win and \"NO\" otherwise. \n\n-----Constraints-----\n\
  - 1 ≤ T ≤ 100\n- 1 ≤ N ≤ 100\n- All other integers are between 1 to 108\n- The integers\
  \ in each pair will be different\n\n-----Example-----\nInput:\n3\n1\n2 3\n2\n4 5\n\
  5 6\n2\n2 3\n3 5\n\nOutput:\nNO\nNO\nYES\n\n\n-----Explanation-----\nExample case\
  \ 1. The first player don't have any choice other subtracting 2 from 3. So during\
  \ the turn of the second player integer pair will be (2,1). The second player will\
  \ win by subtracting 1 from 2. \nExample case 2. If the first player choose to move\
  \ (4,5) to (4,1) the second player will make it to (1,1). If the first player choose\
  \ to move (5,6) to (5,1) the second player will make it to (1,1). So regardless\
  \ of the move of the first player, the second will always win.\nExample case 3.\
  \ The first player will select pair (3,5) and make it to (3,2). Now both pairs are\
  \ equal. So whatever the move of second player he will just mirror that move in\
  \ another pair. This will ensure his win."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def can_first_player_win (pairs : List (Nat × Nat)) : String :=\
  \ sorry\n\n-- Theorem declarations"
"vc-theorems": "theorem can_first_player_win_outputs (pairs : List (Nat × Nat))\n\
  \  (h1 : ∀ p ∈ pairs, 1 ≤ p.1 ∧ p.1 ≤ 100 ∧ 1 ≤ p.2 ∧ p.2 ≤ 100)\n  (h2 : 1 ≤ pairs.length\
  \ ∧ pairs.length ≤ 10) :\n  can_first_player_win pairs = \"YES\" ∨ can_first_player_win\
  \ pairs = \"NO\" := sorry\n\n\ntheorem can_first_player_win_commutative (pairs :\
  \ List (Nat × Nat))\n  (h1 : ∀ p ∈ pairs, 1 ≤ p.1 ∧ p.1 ≤ 100 ∧ 1 ≤ p.2 ∧ p.2 ≤\
  \ 100)\n  (h2 : 1 ≤ pairs.length ∧ pairs.length ≤ 10) :\n  can_first_player_win\
  \ pairs = can_first_player_win (pairs.map (fun p => (p.2, p.1))) := sorry\n\n\n\
  theorem can_first_player_win_bases (pairs : List (Nat × Nat))\n  (h1 : ∀ p ∈ pairs,\
  \ p.1 = 1 ∧ 1 ≤ p.2 ∧ p.2 ≤ 100)\n  (h2 : 1 ≤ pairs.length ∧ pairs.length ≤ 10)\
  \ :\n  can_first_player_win pairs = \"YES\" ∨ can_first_player_win pairs = \"NO\"\
  \ := sorry\n\n\ntheorem can_first_player_win_ordering_invariant (pairs permuted\
  \ : List (Nat × Nat))\n  (h1 : ∀ p ∈ pairs, 2 ≤ p.1 ∧ p.1 ≤ 100 ∧ 2 ≤ p.2 ∧ p.2\
  \ ≤ 100)\n  (h2 : 1 ≤ pairs.length ∧ pairs.length ≤ 10)\n  (h3 : ∃ perm : List (Nat\
  \ × Nat) → List (Nat × Nat), perm pairs = permuted) :\n  can_first_player_win pairs\
  \ = can_first_player_win permuted := sorry\n\n/--\ninfo: 'NO'\n-/\n#guard_msgs in\n\
  #eval can_first_player_win [(2, 3)]\n\n/--\ninfo: 'NO'\n-/\n#guard_msgs in\n#eval\
  \ can_first_player_win [(4, 5), (5, 6)]\n\n/--\ninfo: 'YES'\n-/\n#guard_msgs in\n\
  #eval can_first_player_win [(2, 3), (3, 5)]\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
