"vc-description": "A character in UTF8 can be from 1 to 4 bytes long, subjected to\
  \ the following rules:\n\nFor 1-byte character, the first bit is a 0, followed by\
  \ its unicode code.\nFor n-bytes character, the first n-bits are all one's, the\
  \ n+1 bit is 0, followed by n-1 bytes with most significant 2 bits being 10.\n\n\
  This is how the UTF-8 encoding would work:\n\n   Char. number range  |        UTF-8\
  \ octet sequence\n      (hexadecimal)    |              (binary)\n   --------------------+---------------------------------------------\n\
  \   0000 0000-0000 007F | 0xxxxxxx\n   0000 0080-0000 07FF | 110xxxxx 10xxxxxx\n\
  \   0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx\n   0001 0000-0010 FFFF | 11110xxx\
  \ 10xxxxxx 10xxxxxx 10xxxxxx\n\n\nGiven an array of integers representing the data,\
  \ return whether it is a valid utf-8 encoding.\n\n\nNote:\nThe input is an array\
  \ of integers. Only the least significant 8 bits of each integer is used to store\
  \ the data. This means each integer represents only 1 byte of data.\n\n\n\nExample\
  \ 1:\n\ndata = [197, 130, 1], which represents the octet sequence: 11000101 10000010\
  \ 00000001.\n\nReturn true.\nIt is a valid utf-8 encoding for a 2-bytes character\
  \ followed by a 1-byte character.\n\n\n\n\nExample 2:\n\ndata = [235, 140, 4], which\
  \ represented the octet sequence: 11101011 10001100 00000100.\n\nReturn false.\n\
  The first 3 bits are all one's and the 4th bit is 0 means it is a 3-bytes character.\n\
  The next byte is a continuation byte which starts with 10 and that's correct.\n\
  But the second continuation byte does not start with 10, so it is invalid."
"vc-preamble": "import Imports.AllImports\n\ndef isContinuationByte (x : Nat) : Bool\
  \ :=\n  sorry\n\n\ndef countRequiredBytes (firstByte : Nat) : Int :=\n  sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def validUtf8 (data : List Nat) : Bool :=\n  sorry\n"
"vc-theorems": "theorem valid_utf8_property (data : List Nat) (h : ∀ x ∈ data, x ≤\
  \ 255) :\n  validUtf8 data = true →\n  ∃ i : Nat,\n    i < data.length ∧\n    let\
  \ required := countRequiredBytes (data.get ⟨i, sorry⟩)\n    required ≥ 0 ∧\n   \
  \ i + required < data.length ∧\n    ∀ j, i + 1 ≤ j ∧ j ≤ i + required →\n      isContinuationByte\
  \ (data.get ⟨j, sorry⟩) = true :=\n  sorry\n\n\ntheorem valid_utf8_property_contra\
  \ (data : List Nat) (h : ∀ x ∈ data, x ≤ 255) :\n  validUtf8 data = false →\n  ∃\
  \ i : Nat,\n    i < data.length ∧\n    (countRequiredBytes (data.get ⟨i, sorry⟩)\
  \ < 0 ∨\n     i + countRequiredBytes (data.get ⟨i, sorry⟩) ≥ data.length ∨\n   \
  \  ∃ j, i + 1 ≤ j ∧ j ≤ i + countRequiredBytes (data.get ⟨i, sorry⟩) ∧\n       isContinuationByte\
  \ (data.get ⟨j, sorry⟩) = false) :=\n  sorry\n\n\ntheorem ascii_always_valid (data\
  \ : List Nat) (h : ∀ x ∈ data, x ≤ 127) :\n  validUtf8 data = true :=\n  sorry\n\
  \n\ntheorem continuation_bytes_invalid (data : List Nat) (h1 : data ≠ []) \n   \
  \ (h2 : ∀ x ∈ data, x ≥ 128 ∧ x ≤ 191) :\n  validUtf8 data = false :=\n  sorry\n\
  \n/--\ninfo: True\n-/\n#guard_msgs in\n#eval valid_utf8 [197, 130, 1]\n\n/--\ninfo:\
  \ False\n-/\n#guard_msgs in\n#eval valid_utf8 [235, 140, 4]\n\n/--\ninfo: True\n\
  -/\n#guard_msgs in\n#eval valid_utf8 [240, 162, 138, 147]\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
