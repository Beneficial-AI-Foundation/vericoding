vc-description: |-
  Chef is very organised in whatever he does and likes to maintain statistics of his work. Chef has expertise in web development and hence is a regular contributor on a forum. Chef sometimes makes multiple contributions in a single day.. Each day chef makes at least 1 contribution he is assigned a shade of green. The greater the number of contribution in a single day the darker shade of green he gets assigned and vice versa. Your job is to find out the number of days chef is assigned a same shade of green and print the number of times chef is assigned a unique shade of green.

  -----INPUT-----
  The first line of input contains an integer T denoting the number of test cases. T test cases follow.

  The first line of each test case contains an integer N denoting the number of days chef has contributed towards the forum.

  The next line contains N spaced integers the number of contributions chef has made if he has made any.

  -----OUTPUT-----

  The output will contain numbers on separate lines that show the number of individual green shades chef has earned in ascending order of intensity of the shades of green.

  -----CONSTRAINTS-----
  1 <= T <= 25

  5 <= N <= 50

  1 <= Ai <= 50

  -----EXAMPLE-----Input:

  1

  7

  20 6 5 3 3 1 1
  Output:

  1: 2

  3: 2

  5: 1

  6: 1

  20: 1
vc-preamble: |-
  import Imports.AllImports
vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>
vc-definitions: |
  def count_github_shades (contributions: List Nat) : List String := sorry

  def isValidResultString (s: String) : Bool := sorry
vc-theorems: |-
  theorem count_github_shades_result_type {contributions: List Nat} (h: contributions.length > 0) :
    let result := count_github_shades contributions
    result.all (fun x => isValidResultString x) := sorry


  theorem count_github_shades_sorted {contributions: List Nat} (h: contributions.length > 0) :
    let result := count_github_shades contributions
    let nums := result.map (fun x => (x.splitOn ": ").head!.toNat!)
    ∀ i, i + 1 < nums.length → nums[i]! ≤ nums[i+1]! := sorry


  theorem count_github_shades_counts_sum {contributions: List Nat} (h: contributions.length > 0) :
    let result := count_github_shades contributions
    let counts := result.map (fun x => (x.splitOn ": ").getLast!.toNat!)
    counts.foldl (·+·) 0 = contributions.length := sorry


  theorem count_github_shades_unique_values {contributions: List Nat} (h: contributions.length > 0) :
    let result := count_github_shades contributions
    let nums := result.map (fun x => (x.splitOn ": ").head!.toNat!)
    ∀ i j, i < nums.length → j < nums.length → i ≠ j → nums[i]! ≠ nums[j]! := sorry
vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: guarded
