"vc-description": "### Problem Context\n\nThe [Fibonacci](http://en.wikipedia.org/wiki/Fibonacci_number)\
  \ sequence is traditionally used to explain tree recursion.  \n\n```python\ndef\
  \ fibonacci(n):\n    if n in [0, 1]:\n        return n\n    return fibonacci(n -\
  \ 1) + fibonacci(n - 2)\n```\n\nThis algorithm serves welll its educative purpose\
  \ but it's [tremendously inefficient](http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#%_sec_1.2.2),\
  \ not only because of recursion, but because we invoke the fibonacci function twice,\
  \ and the right branch of recursion (i.e. `fibonacci(n-2)`) recalculates all the\
  \ Fibonacci numbers already calculated by the left branch (i.e. `fibonacci(n-1)`).\n\
  \nThis algorithm is so inefficient that the time to calculate any Fibonacci number\
  \ over 50 is simply too much. You may go for a cup of coffee or go take a nap while\
  \ you wait for the answer. But if you try it here in Code Wars you will most likely\
  \ get a code timeout before any answers.\n\nFor this particular Kata we want to\
  \ **implement the memoization solution**. This will be cool because it will let\
  \ us *keep using the tree recursion* algorithm while still keeping it sufficiently\
  \ optimized to get an answer very rapidly.\n\nThe trick of the memoized version\
  \ is that we will keep a cache data structure (most likely an associative array)\
  \ where we will store the Fibonacci numbers as we calculate them. When a Fibonacci\
  \ number is calculated, we first look it up in the cache, if it's not there, we\
  \ calculate it and put it in the cache, otherwise we returned the cached number.\n\
  \nRefactor the function into a recursive Fibonacci function that using  a memoized\
  \ data structure avoids the deficiencies of tree recursion Can you make it so the\
  \ memoization cache is private to this function?"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def fibonacci (n : Nat) : Nat := sorry\n\ndef memoized (f : α →\
  \ β) : α → β := sorry\n\n\n"
"vc-theorems": "theorem fibonacci_matches_recursive (n : Nat) : \n  n ≤ 20 → \n  fibonacci\
  \ n = match n with\n    | 0 => 0\n    | 1 => 1\n    | n+2 => fibonacci (n+1) + fibonacci\
  \ n\n  := sorry\n\n\ntheorem fibonacci_recurrence (n : Nat) :\n  n ≥ 2 → fibonacci\
  \ n = fibonacci (n-1) + fibonacci (n-2) := sorry\n\n\ntheorem fibonacci_nonnegative\
  \ (n : Nat) :\n  fibonacci n ≥ 0 := sorry\n\n\ntheorem fibonacci_base_cases :\n\
  \  fibonacci 0 = 0 ∧ fibonacci 1 = 1 := sorry\n\n\ntheorem fibonacci_monotonic (n\
  \ : Nat) :\n  n > 1 → fibonacci n ≥ fibonacci (n-1) := sorry\n\n/--\ninfo: 190392490709135\n\
  -/\n#guard_msgs in\n#eval fibonacci 70\n\n/--\ninfo: 1548008755920\n-/\n#guard_msgs\
  \ in\n#eval fibonacci 60\n\n/--\ninfo: 12586269025\n-/\n#guard_msgs in\n#eval fibonacci\
  \ 50\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible"
