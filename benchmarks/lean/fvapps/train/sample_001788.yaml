"vc-description": "Under a grammar given below, strings can represent a set of lowercase\
  \ words.  Let's use R(expr) to denote the set of words the expression represents.\n\
  Grammar can best be understood through simple examples:\n\nSingle letters represent\
  \ a singleton set containing that word.\n        \nR(\"a\") = {\"a\"}\nR(\"w\")\
  \ = {\"w\"}\n\n\nWhen we take a comma delimited list of 2 or more expressions, we\
  \ take the union of possibilities.\n        \nR(\"{a,b,c}\") = {\"a\",\"b\",\"c\"\
  }\nR(\"{{a,b},{b,c}}\") = {\"a\",\"b\",\"c\"} (notice the final set only contains\
  \ each word at most once)\n\n\nWhen we concatenate two expressions, we take the\
  \ set of possible concatenations between two words where the first word comes from\
  \ the first expression and the second word comes from the second expression.\n \
  \       \nR(\"{a,b}{c,d}\") = {\"ac\",\"ad\",\"bc\",\"bd\"}\nR(\"a{b,c}{d,e}f{g,h}\"\
  ) = {\"abdfg\", \"abdfh\", \"abefg\", \"abefh\", \"acdfg\", \"acdfh\", \"acefg\"\
  , \"acefh\"}\n\n\n\nFormally, the 3 rules for our grammar:\n\nFor every lowercase\
  \ letter x, we have R(x) = {x}\nFor expressions e_1, e_2, ... , e_k with k >= 2,\
  \ we have R({e_1,e_2,...}) = R(e_1) ∪ R(e_2) ∪ ...\nFor expressions e_1 and e_2,\
  \ we have R(e_1 + e_2) = {a + b for (a, b) in R(e_1) × R(e_2)}, where + denotes\
  \ concatenation, and × denotes the cartesian product.\n\nGiven an expression representing\
  \ a set of words under the given grammar, return the sorted list of words that the\
  \ expression represents.\n \n\nExample 1:\nInput: \"{a,b}{c,{d,e}}\"\nOutput: [\"\
  ac\",\"ad\",\"ae\",\"bc\",\"bd\",\"be\"]\n\n\nExample 2:\nInput: \"{{a,z},a{b,c},{ab,z}}\"\
  \nOutput: [\"a\",\"ab\",\"ac\",\"z\"]\nExplanation: Each distinct word is written\
  \ only once in the final answer.\n\n \nConstraints:\n\n1 <= expression.length <=\
  \ 60\nexpression[i] consists of '{', '}', ','or lowercase English letters.\nThe\
  \ given expression represents a set of words based on the grammar given in the description."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def braceExpansionII (s : String) : List String :=\n  sorry\n"
"vc-theorems": "theorem brace_expansion_result_is_ordered (expr : String) :\n  let\
  \ result := braceExpansionII expr\n  ∀ (i j : Nat) (h1 : i < j) (h2 : j < result.length)\
  \ (h3 : i < result.length), \n    (result.get ⟨i, h3⟩) ≤ (result.get ⟨j, h2⟩) :=\
  \ sorry \n\n\ntheorem brace_expansion_no_duplicates (expr : String) :\n  let result\
  \ := braceExpansionII expr \n  result.length = result.eraseDups.length := sorry\n\
  \n\ntheorem brace_expansion_letters_only (expr : String) :\n  let result := braceExpansionII\
  \ expr\n  result.all (fun s => s.all Char.isAlpha) := sorry\n\n\ntheorem brace_expansion_single_letter\
  \ (c : Char) (h : c.isAlpha) :\n  braceExpansionII (String.mk [c]) = [String.mk\
  \ [c]] := sorry\n\n\ntheorem brace_expansion_nested_braces (expr : String) :\n \
  \ let nested := \"{\" ++ expr ++ \"}\"\n  braceExpansionII expr = braceExpansionII\
  \ nested := sorry\n\n\ntheorem brace_expansion_empty_braces :\n  braceExpansionII\
  \ \"{}\" = [\"\"] := sorry\n\n/--\ninfo: ['ac', 'ad', 'ae', 'bc', 'bd', 'be']\n\
  -/\n#guard_msgs in\n#eval braceExpansionII \"{a,b}{c,{d,e}}\"\n\n/--\ninfo: ['a',\
  \ 'ab', 'ac', 'z']\n-/\n#guard_msgs in\n#eval braceExpansionII \"{{a,z},a{b,c},{ab,z}}\"\
  \n\n/--\ninfo: ['abdfg', 'abdfh', 'abefg', 'abefh', 'acdfg', 'acdfh', 'acefg', 'acefh']\n\
  -/\n#guard_msgs in\n#eval braceExpansionII \"a{b,c}{d,e}f{g,h}\"\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
