"vc-description": "You have a string S consisting of N uppercase English letters.\
  \ You are allowed to perform at most one operation of following kind: Choose any\
  \ position in the string, remove the character at that position and insert it back\
  \ to any other place in the string.\n\nFind the  lexicographically smallest  string\
  \ you can achieve.\n\n-----Input-----\nThe first line of the input contains an integer\
  \ T denoting the number of test cases. The description of T test cases follows.\n\
  The first line of each test case contains the single integer N denoting length of\
  \ string S.\nThe second line contains the string S.\n\n-----Output-----\nFor each\
  \ test case, output a single line containing the answer to the corresponding test\
  \ case.\n\n-----Constraints-----\n- 1 ≤ T ≤ 50\n- 1 ≤ N ≤ 50\n- S will consist of\
  \ uppercase English letters.\n\n-----Example-----\nInput:\n2\n4\nDCBA\n7\nXYZZYZZ\n\
  \nOutput:\nADCB\nXYYZZZZ\n\n-----Explanation-----\nExample case 1. The optimal solution\
  \ here is to choose the last character and put it in the beginning of the string.\
  \ So the answer will be ADCB\nExample case 2. The optimal solution here is to choose\
  \ the 5-th character (1-based index) and put it between the 2-nd and the 3-rd characters.\
  \ So the answer will be XYYZZZZ"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def find_smallest_string (s : String) : String :=\n  sorry\n"
"vc-theorems": "theorem output_length_matches_input (s : String) (h : s.length > 0)\
  \ :\n  (find_smallest_string s).length = s.length :=\nsorry\n\n\ntheorem output_has_same_characters\
  \ (s : String) (h : s.length > 0) :\n  (find_smallest_string s).toList.sorted =\
  \ s.toList.sorted :=\nsorry\n\n\ntheorem output_lexicographically_smaller_or_equal\
  \ (s : String) (h : s.length > 0) :\n  find_smallest_string s ≤ s :=\nsorry\n\n\n\
  theorem result_is_minimal_rearrangement (s : String) (h : s.length > 0)\n    (i\
  \ : Nat) (h1 : i < s.length)\n    (j : Nat) (h2 : j ≤ s.length - 1) :\n  let c :=\
  \ s.data.get ⟨i, h1⟩\n  let remaining := (s.take i) ++ (s.drop (i + 1))\n  let candidate\
  \ := (remaining.take j) ++ String.mk [c] ++ (remaining.drop j)\n  find_smallest_string\
  \ s ≤ candidate :=\nsorry\n\n\ntheorem sorted_string_is_minimal (s : String) (h\
  \ : s.length > 0) :\n  let sorted_s := String.mk (s.toList.sorted)\n  find_smallest_string\
  \ sorted_s = sorted_s :=\nsorry\n\n/--\ninfo: 'ADCB'\n-/\n#guard_msgs in\n#eval\
  \ find_smallest_string \"DCBA\"\n\n/--\ninfo: 'XYYZZZZ'\n-/\n#guard_msgs in\n#eval\
  \ find_smallest_string \"XYZZYZZ\"\n\n/--\ninfo: 'ABC'\n-/\n#guard_msgs in\n#eval\
  \ find_smallest_string \"ABC\"\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
