"vc-description": "Given two arrays `a` and `b` write a function `comp(a, b)` (`compSame(a,\
  \ b)` in Clojure) that checks whether the two arrays have the \"same\" elements,\
  \ with the same multiplicities. \"Same\" means, here, that the elements in `b` are\
  \ the elements in `a` squared, regardless of the order.\n\n## Examples\n## Valid\
  \ arrays\n```\na = [121, 144, 19, 161, 19, 144, 19, 11]  \nb = [121, 14641, 20736,\
  \ 361, 25921, 361, 20736, 361]\n```\n`comp(a, b)` returns true because in `b` 121\
  \ is the square of 11, 14641 is the square of 121, 20736 the square of 144, 361\
  \ the square of 19, 25921 the square of 161, and so on. It gets obvious if we write\
  \ `b`'s elements in terms of squares:\n```\na = [121, 144, 19, 161, 19, 144, 19,\
  \ 11] \nb = [11*11, 121*121, 144*144, 19*19, 161*161, 19*19, 144*144, 19*19]\n```\n\
  ### Invalid arrays\nIf we change the first number to something else, `comp` may\
  \ not return true anymore:\n```\na = [121, 144, 19, 161, 19, 144, 19, 11]  \nb =\
  \ [132, 14641, 20736, 361, 25921, 361, 20736, 361]\n```\n`comp(a,b)` returns false\
  \ because in `b` 132 is not the square of any number of `a`.\n```\na = [121, 144,\
  \ 19, 161, 19, 144, 19, 11]  \nb = [121, 14641, 20736, 36100, 25921, 361, 20736,\
  \ 361]\n```\n`comp(a,b)` returns false because in `b` 36100 is not the square of\
  \ any number of `a`.\n\n## Remarks\n- `a` or `b` might be `[]` (all languages except\
  \ R, Shell).\n- `a` or `b` might be `nil` or `null` or `None` or `nothing` (except\
  \ in Haskell, Elixir, C++, Rust, R, Shell, PureScript). \n\nIf `a` or `b` are `nil`\
  \ (or `null` or `None`), the problem doesn't make sense so return false.\n\n####\
  \ Note for C\nThe two arrays have the same size `(> 0)` given as parameter in function\
  \ `comp`."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def comp : (List Int) → (List Int) → Bool := sorry\n\ntheorem comp_none_inputs\
  \ (l : List Int) : \n  comp [] l = false ∨ comp l [] = false ∨ comp [] [] = false\n\
  \  := sorry\n"
"vc-theorems": "theorem comp_array_squared (arr : List Int) :\n  let squared := arr.map\
  \ (fun x => x * x)\n  comp arr squared = true\n  := sorry\n\n\ntheorem comp_different_lengths\
  \ (arr1 arr2 : List Int) :\n  arr1.length ≠ arr2.length → comp arr1 arr2 = false\n\
  \  := sorry\n\n\ntheorem comp_permutations (arr : List Int) :\n  arr ≠ [] →\n  let\
  \ squared := arr.map (fun x => x * x)\n  let shuffled := squared.reverse\n  comp\
  \ arr shuffled = true\n  := sorry\n\n\ntheorem comp_empty_arrays :\n  comp [] []\
  \ = true ∧ \n  comp [] [1] = false ∧\n  comp [1] [] = false\n  := sorry\n\n/--\n\
  info: True\n-/\n#guard_msgs in\n#eval comp [121, 144, 19, 161, 19, 144, 19, 11]\
  \ [121, 14641, 20736, 361, 25921, 361, 20736, 361]\n\n/--\ninfo: False\n-/\n#guard_msgs\
  \ in\n#eval comp [] [1]\n\n/--\ninfo: False\n-/\n#guard_msgs in\n#eval comp None\
  \ [1, 2, 3]\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
