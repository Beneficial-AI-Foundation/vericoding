"vc-description": "Evlampiy was gifted a rooted tree. The vertices of the tree are\
  \ numbered from $1$ to $n$. Each of its vertices also has an integer $a_i$ written\
  \ on it. For each vertex $i$, Evlampiy calculated $c_i$ — the number of vertices\
  \ $j$ in the subtree of vertex $i$, such that $a_j < a_i$. [Image]Illustration for\
  \ the second example, the first integer is $a_i$ and the integer in parentheses\
  \ is $c_i$\n\nAfter the new year, Evlampiy could not remember what his gift was!\
  \ He remembers the tree and the values of $c_i$, but he completely forgot which\
  \ integers $a_i$ were written on the vertices.\n\nHelp him to restore initial integers!\n\
  \n\n-----Input-----\n\nThe first line contains an integer $n$ $(1 \\leq n \\leq\
  \ 2000)$ — the number of vertices in the tree.\n\nThe next $n$ lines contain descriptions\
  \ of vertices: the $i$-th line contains two integers $p_i$ and $c_i$ ($0 \\leq p_i\
  \ \\leq n$; $0 \\leq c_i \\leq n-1$), where $p_i$ is the parent of vertex $i$ or\
  \ $0$ if vertex $i$ is root, and $c_i$ is the number of vertices $j$ in the subtree\
  \ of vertex $i$, such that $a_j < a_i$.\n\nIt is guaranteed that the values of $p_i$\
  \ describe a rooted tree with $n$ vertices.\n\n\n-----Output-----\n\nIf a solution\
  \ exists, in the first line print \"YES\", and in the second line output $n$ integers\
  \ $a_i$ $(1 \\leq a_i \\leq {10}^{9})$. If there are several solutions, output any\
  \ of them. One can prove that if there is a solution, then there is also a solution\
  \ in which all $a_i$ are between $1$ and $10^9$.\n\nIf there are no solutions, print\
  \ \"NO\".\n\n\n-----Examples-----\nInput\n3\n2 0\n0 2\n2 0\n\nOutput\nYES\n1 2 1\
  \ \nInput\n5\n0 1\n1 3\n2 1\n3 0\n2 0\n\nOutput\nYES\n2 3 2 1 2"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def solve_rooted_tree (n : Nat) (parents_and_counts : List (Nat\
  \ × Nat)) : \n  String × List Nat := sorry\n"
"vc-theorems": "theorem minimal_single_node_case (n : Nat) (parents_and_counts : List\
  \ (Nat × Nat)) :\n  n = 1 → parents_and_counts = [(0,0)] → \n  solve_rooted_tree\
  \ n parents_and_counts = (\"YES\", [1]) := sorry\n\n\ntheorem invalid_counts_yields_no\
  \ (n : Nat) (parents_and_counts : List (Nat × Nat)) :\n  n = 3 → parents_and_counts\
  \ = [(2,3), (3,3), (0,3)] →\n  solve_rooted_tree n parents_and_counts = (\"NO\"\
  , []) := sorry\n\n\ntheorem valid_tree_properties (n : Nat) (parents_and_counts\
  \ : List (Nat × Nat)) \n  (result : String) (nums : List Nat) :\n  n = 3 → parents_and_counts\
  \ = [(2,0), (0,2), (2,0)] →\n  solve_rooted_tree n parents_and_counts = (result,\
  \ nums) →\n  result = \"YES\" ∧ \n  nums.length = n ∧\n  (∀ x ∈ nums, x ∈ [1,2,3])\
  \ := sorry\n\n\ntheorem output_properties (n : Nat) (parents_and_counts : List (Nat\
  \ × Nat)) \n  (result : String) (nums : List Nat) :\n  n = 5 → parents_and_counts\
  \ = [(0,1), (1,3), (2,1), (3,0), (2,0)] →\n  solve_rooted_tree n parents_and_counts\
  \ = (result, nums) →\n  (result = \"YES\" ∨ result = \"NO\") ∧\n  (result = \"YES\"\
  \ → \n    nums.length = n ∧\n    (∀ x ∈ nums, 1 ≤ x ∧ x ≤ n) ∧\n    (∀ x ∈ nums,\
  \ ∀ y ∈ nums, x ≠ y → nums.indexOf x ≠ nums.indexOf y)) := sorry\n\n/--\ninfo: n\n\
  -/\n#guard_msgs in\n#eval len nums\n\n/--\ninfo: n\n-/\n#guard_msgs in\n#eval len\
  \ nums\n"
"vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded"
