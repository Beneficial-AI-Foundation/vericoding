"vc-description": "A tree is an undirected connected graph without cycles.\n\nLet's\
  \ consider a rooted undirected tree with n vertices, numbered 1 through n. There\
  \ are many ways to represent such a tree. One way is to create an array with n integers\
  \ p_1, p_2, ..., p_{n}, where p_{i} denotes a parent of vertex i (here, for convenience\
  \ a root is considered its own parent). [Image] For this rooted tree the array p\
  \ is [2, 3, 3, 2]. \n\nGiven a sequence p_1, p_2, ..., p_{n}, one is able to restore\
  \ a tree:  There must be exactly one index r that p_{r} = r. A vertex r is a root\
  \ of the tree.  For all other n - 1 vertices i, there is an edge between vertex\
  \ i and vertex p_{i}. \n\nA sequence p_1, p_2, ..., p_{n} is called valid if the\
  \ described procedure generates some (any) rooted tree. For example, for n = 3 sequences\
  \ (1,2,2), (2,3,1) and (2,1,3) are not valid.\n\nYou are given a sequence a_1, a_2,\
  \ ..., a_{n}, not necessarily valid. Your task is to change the minimum number of\
  \ elements, in order to get a valid sequence. Print the minimum number of changes\
  \ and an example of a valid sequence after that number of changes. If there are\
  \ many valid sequences achievable in the minimum number of changes, print any of\
  \ them.\n\n\n-----Input-----\n\nThe first line of the input contains an integer\
  \ n (2 ≤ n ≤ 200 000) — the number of vertices in the tree.\n\nThe second line contains\
  \ n integers a_1, a_2, ..., a_{n} (1 ≤ a_{i} ≤ n).\n\n\n-----Output-----\n\nIn the\
  \ first line print the minimum number of elements to change, in order to get a valid\
  \ sequence.\n\nIn the second line, print any valid sequence possible to get from\
  \ (a_1, a_2, ..., a_{n}) in the minimum number of changes. If there are many such\
  \ sequences, any of them will be accepted.\n\n\n-----Examples-----\nInput\n4\n2\
  \ 3 3 4\n\nOutput\n1\n2 3 4 4 \n\nInput\n5\n3 2 2 5 3\n\nOutput\n0\n3 2 2 5 3 \n\
  \nInput\n8\n2 3 5 4 1 6 6 7\n\nOutput\n2\n2 3 7 8 1 6 6 7\n\n\n\n-----Note-----\n\
  \nIn the first sample, it's enough to change one element. In the provided output,\
  \ a sequence represents a tree rooted in a vertex 4 (because p_4 = 4), which you\
  \ can see on the left drawing below. One of other correct solutions would be a sequence\
  \ 2 3 3 2, representing a tree rooted in vertex 3 (right drawing below). On both\
  \ drawings, roots are painted red. [Image] \n\nIn the second sample, the given sequence\
  \ is already valid."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def fix_tree_sequence (n : Nat) (A : List Nat) : Nat × List Nat\
  \ := sorry\n\ndef is_valid_tree (A : List Nat) : Bool := sorry\n"
"vc-theorems": "theorem fix_tree_sequence_properties \n  (n : Nat) \n  (A : List Nat)\n\
  \  (h : A.length = n) :\n  let (changes, result) := fix_tree_sequence n A\n  --\
  \ Result has same length\n  result.length = A.length ∧ \n  -- Changes non-negative\
  \ (implicit for Nat)\n  -- Result is valid tree\n  is_valid_tree result = true ∧\n\
  \  -- Original array unchanged\n  A = A ∧\n  -- Changes matches actual differences\n\
  \  changes = (List.zip A result).foldl (fun acc p => if p.1 = p.2 then acc else\
  \ acc + 1) 0\n  := sorry\n\n\ntheorem already_valid_tree\n  (A : List Nat)\n  (h\
  \ : is_valid_tree A = true) :\n  let (changes, result) := fix_tree_sequence A.length\
  \ A\n  changes = 0 ∧ result = A\n  := sorry"
"vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded"
