"vc-description": "You are given n pairs of numbers. In every pair, the first number\
  \ is always smaller than the second number.\n\n\n\nNow, we define a pair (c, d)\
  \ can follow another pair (a, b) if and only if b < c. Chain of pairs can be formed\
  \ in this fashion. \n\n\n\nGiven a set of pairs, find the length longest chain which\
  \ can be formed. You needn't use up all the given pairs. You can select pairs in\
  \ any order.\n\n\n\nExample 1:\n\nInput: [[1,2], [2,3], [3,4]]\nOutput: 2\nExplanation:\
  \ The longest chain is [1,2] -> [3,4]\n\n\n\nNote:\n\nThe number of given pairs\
  \ will be in the range [1, 1000]."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def find_longest_chain (pairs : List (Int × Int)) : Nat := sorry\n\
  \ntheorem chain_length_bounds (pairs : List (Int × Int)) :\n  pairs ≠ [] →\n  1\
  \ ≤ find_longest_chain pairs ∧ find_longest_chain pairs ≤ pairs.length := sorry\n"
"vc-theorems": "theorem chain_length_invariant_under_list_ordering (pairs₁ pairs₂\
  \ : List (Int × Int)) :\n  pairs₁.length = pairs₂.length → \n  find_longest_chain\
  \ pairs₁ = find_longest_chain pairs₂ := sorry\n\n\ntheorem overlapping_pairs_property\
  \ (pairs : List (Int × Int)) (first : Int × Int) :\n  pairs ≠ [] →\n  let overlapping\
  \ := [(first.1, first.2 + 1)]\n  find_longest_chain (pairs ++ overlapping) ≤ find_longest_chain\
  \ pairs + 1 := sorry\n\n\ntheorem non_overlapping_sequence_length (n : Nat) :\n\
  \  let pairs := List.map (fun i => (Int.ofNat (2 * i), Int.ofNat (2 * i + 1))) (List.range\
  \ n)\n  find_longest_chain pairs = n := sorry\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n\
  #eval find_longest_chain [[1, 2], [2, 3], [3, 4]]\n\n/--\ninfo: 2\n-/\n#guard_msgs\
  \ in\n#eval find_longest_chain [[1, 5], [2, 3], [4, 6]]\n\n/--\ninfo: 4\n-/\n#guard_msgs\
  \ in\n#eval find_longest_chain [[1, 2], [7, 8], [3, 4], [5, 6]]\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
