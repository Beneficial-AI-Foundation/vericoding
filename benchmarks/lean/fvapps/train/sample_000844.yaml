"vc-description": "\"It does not matter how slowly you go as long as you do not stop.\"\
  \ - Confucius\nYou are given an array $A_1, A_2, \\ldots, A_N$ and an integer $K$.\
  \ For each subarray $S = [A_l, A_{l+1}, \\ldots, A_r]$ ($1 \\le l \\le r \\le N$):\n\
  - Let's define an array $B$ as $S$ concatenated with itself $m$ times, where $m$\
  \ is the smallest integer such that $m(r-l+1) \\ge K$.\n- Next, let's sort $B$ and\
  \ define $X = B_K$, i.e. as a $K$-th smallest element of $B$. Note that $|B| \\\
  ge K$.\n- Then, let's define $F$ as the number of occurrences of $X$ in $S$.\n-\
  \ The subarray $S$ is beautiful if $F$ occurs in $S$ at least once.\nFind the number\
  \ of beautiful subarrays of $A$. Two subarrays $A_l, A_{l+1}, \\ldots, A_r$ and\
  \ $A_p, A_{p+1}, \\ldots, A_q$ are different if $l \\neq p$ or $r \\neq q$.\n\n\
  -----Input-----\n- The first line of the input contains a single integer $T$ denoting\
  \ the number of test cases. The description of $T$ test cases follows.\n- The first\
  \ line of each test case contains two space-separated integers $N$ and $K$. \n-\
  \ The second line contains $N$ space-separated integers $A_1, A_2, \\ldots, A_N$.\n\
  \n-----Output-----\nFor each test case, print a single line containing one integer\
  \ - the number of beautiful subarrays.\n\n-----Constraints-----\n- $1 \\le T \\\
  le 5$\n- $1 \\le N \\le 2,000$\n- $1 \\le K \\le 10^9$\n- $1 \\le A_i \\le 2000$\
  \ for each valid $i$\n\n-----Subtasks-----\nSubtask #1 (20 points): $1 \\le N \\\
  le 200$\nSubtask #2 (80 points): original constraints\n\n-----Example Input-----\n\
  1\n3 3\n1 2 3\n\n-----Example Output-----\n3\n\n-----Explanation-----\nExample case\
  \ 1: There are six subarrays of $A$: $[1]$, $[2]$, $[3]$, $[1, 2]$, $[2, 3]$, $[1,\
  \ 2, 3]$. The corresponding arrays $B$ are $[1, 1, 1]$, $[2, 2, 2]$, $[3, 3, 3]$,\
  \ $[1, 2, 1, 2]$, $[2, 3, 2, 3]$, $[1, 2, 3]$.\nThree of the subarrays are beautiful:\
  \ $[1]$, $[1, 2]$ and $[1, 2, 3]$. For these subarrays, $X$ is $1$, $2$ and $3$\
  \ respectively (for example, for $S = [1, 2]$, $B = [1, 2, 1, 2]$ is sorted to $[1,\
  \ 1, 2, 2]$ and $X = 2$ is the $3$-rd element). Then, $F = 1$ for each of these\
  \ subarrays, and each of these subarrays contains $1$."
"vc-preamble": "import Imports.AllImports\n\ndef count_beautiful_subarrays (n k :\
  \ Nat) (arr : List Nat) : Nat :=\n  sorry\n\n\ndef is_valid_array (arr : List Nat)\
  \ (n : Nat) : Bool :=\n  sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def list_sorted (arr : List Nat) : List Nat :=\n  sorry\n"
"vc-theorems": "theorem array_bounds (n k : Nat) (arr : List Nat) :\n  1 ≤ n ∧ n ≤\
  \ 100 ∧\n  1 ≤ k ∧ k ≤ 100 ∧\n  arr.length = n ∧\n  (∀ x ∈ arr, 1 ≤ x ∧ x ≤ 2000)\
  \ →\n  0 ≤ count_beautiful_subarrays n k arr :=\nsorry\n\n\ntheorem single_element_arrays\
  \ (n k : Nat) :\n  1 ≤ n ∧ n ≤ 10 ∧\n  1 ≤ k ∧ k ≤ 10 →\n  n ≤ count_beautiful_subarrays\
  \ n k (List.replicate n 1) :=\nsorry\n\n\ntheorem sorted_vs_unsorted (n k : Nat)\
  \ (arr : List Nat) :\n  1 ≤ n ∧ n ≤ 10 ∧\n  1 ≤ k ∧ k ≤ 10 ∧\n  is_valid_array arr\
  \ n →\n  count_beautiful_subarrays n k (list_sorted arr) = count_beautiful_subarrays\
  \ n k arr :=\nsorry\n\n\ntheorem minimal_case (k : Nat) :\n  1 ≤ k ∧ k ≤ 10 →\n\
  \  count_beautiful_subarrays 1 k [1] = 1 :=\nsorry\n\n/--\ninfo: 3\n-/\n#guard_msgs\
  \ in\n#eval count_beautiful_subarrays 3 3 [1, 2, 3]\n\n/--\ninfo: 1\n-/\n#guard_msgs\
  \ in\n#eval count_beautiful_subarrays 1 1 [1]\n\n/--\ninfo: 2\n-/\n#guard_msgs in\n\
  #eval count_beautiful_subarrays 2 2 [2, 1]\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
