"vc-description": "The Stack Arithmetic Machine\n---------------------------\n\nThis\
  \ time we're going to be writing a stack arithmetic machine, and we're going to\
  \ call it Sam. Essentially, Sam is a very small virtual machine, with a simple intruction\
  \ set, four general registers, and a stack. We've already given a CPU class, which\
  \ gives you read and write access to registers and the stack, through `readReg()`\
  \ and `writeReg()`, and `popStack()` and `writeStack()` respectively. All instructions\
  \ on Sam are 32-bit (Java int), and either interact with the stack, or one of the\
  \ 4 registers; `a`, `b`, `c`, or `d`.\n\nThe CPU API\n-----------\n\nThe CPU instructions\
  \ available through the CPU class, with a bit more detail:\n\n```python\nread_reg(self,\
  \ name): Returns the value of the named register.\nwrite_reg(self, name, value):\
  \ Stores the value into the given register.\n\npop_stack(self): Pops the top element\
  \ of the stack, returning the value.\nwrite_stack(self, value): Pushes an element\
  \ onto the stack.\n```\n\nNote that the registers have a default value of `0` and\
  \  that the sStack is printable (if needed).\n\n\n\nThe Instruction Set\n-------------------\n\
  \nInstructions for same are done in assembly style, and are passed one by one into\
  \ the `Exec|exec|execute` function (depending on your language). Each instruction\
  \ begins with the name of the operation, and is optionally followed by either one\
  \ or two operands. The operands are marked in the table below by either `[reg]`,\
  \ which accepts a register name, or `[reg|int]` which accepts either a register,\
  \ or an immediate integer value.\n\n### Stack Operations\n\n```\npush [reg|int]:\
  \ Pushes a register [reg] or an immediate value [int] to the stack.\n\npop: Pops\
  \ a value of the stack, discarding the value.\n\npop [reg]: Pops a value of the\
  \ stack, into the given register [reg].\n\npushr: Pushes the general registers onto\
  \ the stack, in order. (a, b, c, d)\n\npushrr: Pushes the general registers onto\
  \ the stack, in reverse order. (d, c, b, a)\n\npopr: Pops values off the stack,\
  \ and loads them into the general registers, in order so that the two executions\
  \ `pushr()`  and `popr()` would leave the registers unchanged.\n\npoprr: Pops values\
  \ off the stack, and loads them into the general registers, in order so that the\
  \ two executions `pushr()`  and `poprr()` would invert the values of the registers\
  \ from left to right.\n```\n\n### Misc Operations\n\n```\nmov [reg|int], [reg2]:\
  \ Stores the value from [reg|int] into the register [reg2].\n```\n\n### Arithmetic\
  \ Operations\n\n```\nadd [reg|int]: Pops [reg|int] arguments off the stack, storing\
  \ the sum in register a.\n\nsub [reg|int]: Pops [reg|int] arguments off the stack,\
  \ storing the difference in register a.\n\nmul [reg|int]: Pops [reg|int] arguments\
  \ off the stack, storing the product in register a.\n\ndiv [reg|int]: Pops [reg|int]\
  \ arguments off the stack, storing the quotient in register a.\n\nand [reg|int]:\
  \ Pops [reg|int] arguments off the stack, performing a bit-and operation, and storing\
  \ the result in register a.\n\nor [reg|int] : Pops [reg|int] arguments off the stack,\
  \ performing a bit-or operation, and storing the result in register a.\n\nxor [reg|int]:\
  \ Pops [reg|int] arguments off the stack, performing a bit-xor operation, and storing\
  \ the result in register a.\n```\n\nAll arithmetic operations have 4 variants; they\
  \ may be suffixed with the character `'a'` (`adda`, `xora`), and they may take an\
  \ additional register parameter, which is the destination register. Thus, using\
  \ add as an example:\n```\nadd 5: Adds the top 5 values of the stack, storing the\
  \ result in register a.\n\nadd 5, b: Adds the top 5 values of the stack, storing\
  \ the result in register b instead.\n\nadda 5: Pushes the value of register A onto\
  \ the stack, then adds the top 5 values of the stack, and stores the result in register\
  \ a.\n\nadda 5, b: Pushes the value of register A onto the stack, adds the top 5\
  \ values of the stack, and stores the result in register b.\n```\n\nAll arithmetic\
  \ instructions may also take a register as their first argument, to perform a variable\
  \ number of operation, as follows:\n```\nmov 3, a: Stores the number 3 in register\
  \ a.\nadd a: Adds the top a values of the stack (in this case 3), storing the result\
  \ in register a.\n```"
"vc-preamble": "import Imports.AllImports\n\n  def sum (l: List Int) : Int :=\n  \
  \  match l with\n    | [] => 0\n    | h::t => h + sum t\n\n\n  def prod (l: List\
  \ Int) : Int :=\n    match l with\n    | [] => 1\n    | h::t => h * prod t\n\n\n\
  \  def bitAnd (l: List Int) : Int :=\n    match l with\n    | [] => 0\n    | [x]\
  \ => x\n    | h::t => h\nend List\n\nstructure CPU where\n  regs : String → Int\n\
  \  stack : List Int\n\nstructure Machine where\n  cpu : CPU\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def Machine.execute : Machine → String → Machine :=\n  sorry\n"
"vc-theorems": "theorem arithmetic_operations_stack_add \n  (values : List Int) \n\
  \  (h : values.length ≥ 2 ∧ values.length ≤ 10) :\n  let m : Machine := ⟨⟨λ_ =>\
  \ 0, []⟩⟩\n  let m' := (values.foldl (λ acc v => Machine.execute acc s!\"push {v}\"\
  ) m)\n  let m'' := Machine.execute m' s!\"add {values.length}\"\n  m''.cpu.regs\
  \ \"a\" = values.sum := \n  sorry\n\n\ntheorem arithmetic_operations_stack_mul \n\
  \  (values : List Int)\n  (h : values.length ≥ 2 ∧ values.length ≤ 10) :\n  let\
  \ m : Machine := ⟨⟨λ_ => 0, []⟩⟩\n  let m' := (values.foldl (λ acc v => Machine.execute\
  \ acc s!\"push {v}\") m)\n  let m'' := Machine.execute m' s!\"mul {values.length}\"\
  \n  m''.cpu.regs \"a\" = values.prod :=\n  sorry\n\n\ntheorem arithmetic_operations_stack_and\n\
  \  (values : List Int)\n  (h : values.length ≥ 2 ∧ values.length ≤ 10) :\n  let\
  \ m : Machine := ⟨⟨λ_ => 0, []⟩⟩\n  let m' := (values.foldl (λ acc v => Machine.execute\
  \ acc s!\"push {v}\") m)\n  let m'' := Machine.execute m' s!\"and {values.length}\"\
  \n  m''.cpu.regs \"a\" = values.bitAnd :=\n  sorry\n\n\ntheorem register_operations_mov\n\
  \  (reg : String)\n  (value : Int)\n  (h : reg ∈ [\"a\", \"b\", \"c\", \"d\"]) :\n\
  \  let m : Machine := ⟨⟨λ_ => 0, []⟩⟩\n  let m' := Machine.execute m s!\"mov {value},\
  \ {reg}\"\n  m'.cpu.regs reg = value :=\n  sorry\n\n\ntheorem register_operations_push_pop\n\
  \  (reg : String)\n  (value : Int)\n  (h : reg ∈ [\"a\", \"b\", \"c\", \"d\"]) :\n\
  \  let m : Machine := ⟨⟨λ_ => 0, []⟩⟩\n  let m' := Machine.execute m s!\"mov {value},\
  \ {reg}\"\n  let m'' := Machine.execute m' s!\"push {m'.cpu.regs reg}\"\n  let m'''\
  \ := Machine.execute m'' \"pop a\"\n  m'''.cpu.regs \"a\" = value :=\n  sorry"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
