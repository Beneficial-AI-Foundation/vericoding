"vc-description": "Given a directed, acyclic graph of N nodes.  Find all possible\
  \ paths from node 0 to node N-1, and return them in any order.\n\nThe graph is given\
  \ as follows:  the nodes are 0, 1, ..., graph.length - 1.  graph[i] is a list of\
  \ all nodes j for which the edge (i, j) exists.\n\n\nExample:\nInput: [[1,2], [3],\
  \ [3], []] \nOutput: [[0,1,3],[0,2,3]] \nExplanation: The graph looks like this:\n\
  0--->1\n|    |\nv    v\n2--->3\nThere are two paths: 0 -> 1 -> 3 and 0 -> 2 -> 3.\n\
  \n\nNote:\n\n\n       The number of nodes in the graph will be in the range [2,\
  \ 15].\n       You can print different paths in any order, but you should keep the\
  \ order of nodes inside one path."
"vc-preamble": "import Imports.AllImports\n\ndef Graph := List (List Nat)\n\ndef find_all_paths\
  \ (g: Graph) : List (List Nat) := sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def is_valid_dag (g: Graph) : Bool := sorry\n\ndef verify_paths\
  \ (g: Graph) (paths: List (List Nat)) : Bool := sorry\n"
"vc-theorems": "theorem paths_start_end_valid (g: Graph) (paths: List (List Nat))\
  \ \n  (h: paths = find_all_paths g) (h2: is_valid_dag g = true) :\n  ∀ p ∈ paths,\
  \ p.head? = some 0 ∧ \n               p.getLast? = some (g.length - 1) := sorry\n\
  \n\ntheorem paths_follow_edges (g: Graph) (paths: List (List Nat)) \n  (h: paths\
  \ = find_all_paths g) (h2: is_valid_dag g = true) :\n  ∀ p ∈ paths, ∀ i < p.length\
  \ - 1, \n    (p.get! (i+1)) ∈ (g.get! (p.get! i)) := sorry\n\n\ntheorem paths_are_unique\
  \ (g: Graph) (paths: List (List Nat))\n  (h: paths = find_all_paths g) (h2: is_valid_dag\
  \ g = true) :\n  ∀ p₁ ∈ paths, ∀ p₂ ∈ paths, p₁ = p₂ ∨ p₁ ≠ p₂ := sorry\n\n\ntheorem\
  \ linear_graph_single_path (n: Nat) (h: n ≥ 2) :\n  let g : Graph := List.map (fun\
  \ i => if i < n-1 then [i+1] else []) (List.range n)\n  let paths := find_all_paths\
  \ g\n  paths.length = 1 ∧ paths.head? = some (List.range n) := sorry\n\n\ntheorem\
  \ complete_dag_valid_paths (n: Nat) (h: n ≥ 3) :\n  let g : Graph := List.map (fun\
  \ i => List.filter (fun j => j > i ∧ j < n) (List.range n)) (List.range n)\n  let\
  \ paths := find_all_paths g\n  verify_paths g paths = true := sorry\n\n/--\ninfo:\
  \ sorted(expected1)\n-/\n#guard_msgs in\n#eval sorted find_all_paths(graph1)\n\n\
  /--\ninfo: sorted(expected3)\n-/\n#guard_msgs in\n#eval sorted find_all_paths(graph3)\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
