"vc-description": "Given a list of integers, return the nth smallest integer in the\
  \ list. **Only distinct elements should be considered** when calculating the answer.\
  \ `n` will always be positive (`n > 0`)\n\nIf the nth small integer doesn't exist,\
  \ return `-1` (C++) / `None` (Python) / `nil` (Ruby) / `null` (JavaScript).\n\n\
  Notes:\n* \"indexing\" starts from 1\n* huge lists (of 1 million elements) will\
  \ be tested\n\n## Examples\n\n```python\nnth_smallest([1, 3, 4, 5], 7)        ==>\
  \ None  # n is more than the size of the list\nnth_smallest([4, 3, 4, 5], 4)   \
  \     ==> None  # 4th smallest integer doesn't exist\nnth_smallest([45, -10, 4,\
  \ 5, 4], 4)  ==> 45    # 4th smallest integer is 45\n```\n\nIf you get a timeout,\
  \ just try to resubmit your solution. However, if you ***always*** get a timeout,\
  \ review your code."
"vc-preamble": "import Imports.AllImports\n\ndef nth_smallest (arr : List Int) (n\
  \ : Nat) : Option Int := sorry\n\ndef contains (xs : List Int) (x : Int) : Bool\
  \ := \n  xs.foldl (fun acc y => acc || y == x) false\n\n\ndef countLessThan (xs\
  \ : List Int) (x : Int) : Nat :=\n  xs.foldl (fun acc y => if y < x then acc + 1\
  \ else acc) 0\n\n\ndef uniqueList (xs : List Int) : List Int :=\n  xs.foldl (fun\
  \ acc x => if contains acc x then acc else x::acc) []\n\n\ndef minimum (xs : List\
  \ Int) : Option Int :=\n  xs.foldl (fun acc x => match acc with\n    | none => some\
  \ x\n    | some m => some (min x m)) none\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def maximum (xs : List Int) : Option Int :=\n  xs.foldl (fun acc\
  \ x => match acc with\n    | none => some x\n    | some m => some (max x m)) none\n"
"vc-theorems": "theorem nth_smallest_properties {arr : List Int} {n : Nat} (h : n\
  \ ≥ 1) :\n  match nth_smallest arr n with\n  | none => n > (uniqueList arr).length\n\
  \  | some result =>\n    (n ≤ (uniqueList arr).length) ∧ \n    contains arr result\
  \ ∧ \n    countLessThan (uniqueList arr) result = n-1\n  := sorry\n\n\ntheorem nth_smallest_first\
  \ {arr : List Int} (h : arr ≠ []) :\n  nth_smallest arr 1 = minimum (uniqueList\
  \ arr) := sorry\n\n\ntheorem nth_smallest_last_valid {arr : List Int} (h : arr ≠\
  \ []) : \n  nth_smallest arr (uniqueList arr).length = maximum (uniqueList arr)\
  \ := sorry\n\n\ntheorem nth_smallest_empty :\n  nth_smallest [] 1 = none := sorry\n\
  \n/--\ninfo: 34\n-/\n#guard_msgs in\n#eval nth_smallest [14, 12, 46, 34, 334] 3\n\
  \n/--\ninfo: 4000\n-/\n#guard_msgs in\n#eval nth_smallest [4000] 1\n\n/--\ninfo:\
  \ 0\n-/\n#guard_msgs in\n#eval nth_smallest [14, 12, 46, 0, 334] 1\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
