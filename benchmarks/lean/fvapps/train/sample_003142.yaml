"vc-description": "## TL;DR\n\nGiven a number of vertices `N` and a list of weighted\
  \ directed edges in a directed acyclic graph (each edge is written as `[start, end,\
  \ weight]` where `from < to`), compute the weight of the shortest path from vertex\
  \ `0` to vertex `N - 1`.  If there is no such path, return `-1`.\n\n## Background\n\
  \nA weighted DAG is a directed acyclic graph where each edge has a weight associated\
  \ with it:\n\n\n\n\n\n\n\n\n\n\n\n\n\n1\n5\n3\n1\n5\n\n\n\n\nA\nB\nC\nD\n\n\nIn\
  \ this example, the shortest path from A to D is given by A -> B -> D, which has\
  \ a total weight of 4.\n\nFinding shortest distances in DAGs is made easier by the\
  \ fact that the nodes can be _linearized:_ they can be given an order `A1, A2, ...,\
  \ An` such that edges only point forward (that is, there are no edges from `Aj`\
  \ to `Ai` when `j > i`).  In the example above, the two possible linear orderings\
  \ are `A, B, C, D` and `A, C, B, D.`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1\n\n1\n5\n5\n\
  3\n\n\n\n\n\nA\nB\nC\nD\n\n\n## Your Task\n\nGiven a number `N` (indicating a graph\
  \ with vertices `0, 1, ..., N-1`) and a list of weighted edges `[start, end, weight]`\
  \ for a DAG, where `start < end` for each edge, find the weight (a.k.a. length)\
  \ of the shortest path from node `0` to node `N-1`.\n\nFor example, if the input\
  \ is\n\n```\nN = 4\nedgeList = [\n  [0, 1, 1], [0, 2, 5], [0, 3, 5], [1, 3, 3],\
  \ [2, 3, 1]\n]\n```\n\nthen we have the graph depicted above (with `0 = A`, `1 =\
  \ B`, etc.) and the answer is `4`.\n\nIf there is no path from node `0` to node\
  \ `N-1`, return `-1`.\n\n## Notes and Warnings\n\n**Precondition:** `N` will always\
  \ be greater than 1, and edge weights will always be positive integers.  There may\
  \ be multiple edges going between two nodes.\n\n**Warning:** You will probably need\
  \ to use a dynamic programming solution if you want your solution to run fast enough\
  \ not to time out--that's the whole point of this kata!\n\n\nHowever, a well-written\
  \ general shortest-path algorithm such as Dijkstra's Algorithm may also be fast\
  \ enough to past the soak tests.  (The reason is that the dividing line between\
  \ linear and linearithmic time is hard to define and depends on a variety of external\
  \ factors, so the kata's tests err on the safe side.)"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def shortest (n : Int) (edges : List Edge) : Int :=\n  sorry\n"
"vc-theorems": "theorem shortest_basic_properties (n : Int) (edges : List Edge)\n\
  \  (h1 : n ≥ 2) (h2 : n ≤ 10) (h3 : edges.length ≥ 1) (h4 : edges.length ≤ 20)\n\
  \  (h5 : ∀ e ∈ edges, e.src ≥ 0 ∧ e.src < n ∧ \n                     e.dst ≥ 0 ∧\
  \ e.dst < n ∧ \n                     e.weight ≥ 1 ∧ e.weight ≤ 100 ∧\n         \
  \            e.src ≠ e.dst) :\n  let result := shortest n edges\n  (result = -1\
  \ ∨ result > 0) ∧\n  (∀ e ∈ edges, e.src = 0 ∧ e.dst = n-1 → result ≤ e.weight)\
  \ :=\nsorry\n\n\ntheorem shortest_empty_graph (n : Int)\n  (h1 : n ≥ 2) (h2 : n\
  \ ≤ 10) :\n  shortest n [] = -1 :=\nsorry\n\n\ntheorem shortest_single_direct_edge\
  \ (n : Int) (w : Int)\n  (h1 : n ≥ 2) (h2 : n ≤ 10) (h3 : w ≥ 1) (h4 : w ≤ 100)\
  \ :\n  shortest n [{ src := 0, dst := n-1, weight := w }] = w :=\nsorry\n\n/--\n\
  info: 4\n-/\n#guard_msgs in\n#eval shortest 4 [[0, 1, 1], [0, 2, 5], [0, 3, 5],\
  \ [1, 3, 3], [2, 3, 1]]\n\n/--\ninfo: 12\n-/\n#guard_msgs in\n#eval shortest 3 [[0,\
  \ 1, 7], [1, 2, 5], [0, 2, 12]]\n\n/--\ninfo: -1\n-/\n#guard_msgs in\n#eval shortest\
  \ 5 [[0, 2, 1], [1, 2, 1], [0, 3, 1], [1, 4, 1]]\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
