"vc-description": "Assume that you have $k$ one-dimensional segments $s_1, s_2, \\\
  dots s_k$ (each segment is denoted by two integers — its endpoints). Then you can\
  \ build the following graph on these segments. The graph consists of $k$ vertexes,\
  \ and there is an edge between the $i$-th and the $j$-th vertexes ($i \\neq j$)\
  \ if and only if the segments $s_i$ and $s_j$ intersect (there exists at least one\
  \ point that belongs to both of them).\n\nFor example, if $s_1 = [1, 6], s_2 = [8,\
  \ 20], s_3 = [4, 10], s_4 = [2, 13], s_5 = [17, 18]$, then the resulting graph is\
  \ the following: [Image] \n\nA tree of size $m$ is good if it is possible to choose\
  \ $m$ one-dimensional segments so that the graph built on these segments coincides\
  \ with this tree.\n\nYou are given a tree, you have to find its good subtree with\
  \ maximum possible size. Recall that a subtree is a connected subgraph of a tree.\n\
  \nNote that you have to answer $q$ independent queries.\n\n\n-----Input-----\n\n\
  The first line contains one integer $q$ ($1 \\le q \\le 15 \\cdot 10^4$) — the number\
  \ of the queries. \n\nThe first line of each query contains one integer $n$ ($2\
  \ \\le n \\le 3 \\cdot 10^5$) — the number of vertices in the tree.\n\nEach of the\
  \ next $n - 1$ lines contains two integers $x$ and $y$ ($1 \\le x, y \\le n$) denoting\
  \ an edge between vertices $x$ and $y$. It is guaranteed that the given graph is\
  \ a tree.\n\nIt is guaranteed that the sum of all $n$ does not exceed $3 \\cdot\
  \ 10^5$.\n\n\n-----Output-----\n\nFor each query print one integer — the maximum\
  \ size of a good subtree of the given tree.\n\n\n-----Example-----\nInput\n1\n10\n\
  1 2\n1 3\n1 4\n2 5\n2 6\n3 7\n3 8\n4 9\n4 10\n\nOutput\n8\n\n\n\n-----Note-----\n\
  \nIn the first query there is a good subtree of size $8$. The vertices belonging\
  \ to this subtree are ${9, 4, 10, 2, 5, 1, 6, 3}$."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def find_max_good_subtree (n: Nat) (edges: List (Nat × Nat)) :\
  \ Nat :=\n  sorry\n\n-- For paths"
"vc-theorems": "theorem find_max_good_subtree_path_positive (n: Nat) (h: n > 0) (h2:\
  \ n ≤ 100)\n    (edges: List (Nat × Nat)) (h3: edges = List.map (fun i => (i, i+1))\
  \ (List.range (n-1))) :\n    find_max_good_subtree n edges > 0 :=\n  sorry\n\n\n\
  theorem find_max_good_subtree_small_path (n: Nat) (h: n ≤ 3) (h2: n > 0)\n    (edges:\
  \ List (Nat × Nat)) (h3: edges = List.map (fun i => (i, i+1)) (List.range (n-1)))\
  \ :\n    find_max_good_subtree n edges = n :=\n  sorry\n\n-- For star graphs\n\n\
  theorem find_max_good_subtree_star (n: Nat) (h: n ≥ 2) (h2: n ≤ 50)\n    (edges:\
  \ List (Nat × Nat)) (h3: edges = List.map (fun i => (1, i+1)) (List.range (n-1)))\
  \ :\n    find_max_good_subtree n edges = n :=\n  sorry\n\n-- Basic cases\n\ntheorem\
  \ find_max_good_subtree_single_edge :\n    find_max_good_subtree 2 [(1, 2)] = 2\
  \ :=\n  sorry\n\n\ntheorem find_max_good_subtree_triangle_plus_edge :\n    find_max_good_subtree\
  \ 4 [(1, 2), (2, 3), (3, 1), (2, 4)] = 4 :=\n  sorry\n\n/--\ninfo: 8\n-/\n#guard_msgs\
  \ in\n#eval find_max_good_subtree 10 [[1, 2], [1, 3], [1, 4], [2, 5], [2, 6], [3,\
  \ 7], [3, 8], [4, 9], [4, 10]]\n\n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval find_max_good_subtree\
  \ 3 [[1, 2], [2, 3]]\n\n/--\ninfo: 4\n-/\n#guard_msgs in\n#eval find_max_good_subtree\
  \ 4 [[1, 2], [1, 3], [1, 4]]\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
