"vc-description": "General primality test are often computationally expensive, so\
  \ in the biggest prime number race the idea is to study special sub-families of\
  \ prime number and develop more effective tests for them. \n\n[Mersenne Primes](https://en.wikipedia.org/wiki/Mersenne_prime)\
  \ are prime numbers of the form: Mn = 2^(n) - 1. So far, 49 of them was found between\
  \ M2 (3) and M74,207,281 which contains 22,338,618 digits and is (by September 2015)\
  \ the biggest known prime. It has been found by GIMPS (Great Internet Mersenne Prime\
  \ Search), wich use the test srudied here. (plus heuristics mentionned below)\n\n\
  Lucas and Lehmer have developed a [simple test](https://en.wikipedia.org/wiki/Lucas%E2%80%93Lehmer_primality_test)\
  \ for Mersenne primes: \n\n> for `p` (an odd prime), the Mersenne number Mp is prime\
  \ if and only if `S(p − 1) = 0 mod Mp`,\n\n>where `S(n + 1) = S(n) * S(n) − 2` and\
  \ `S(1) = 4`\n\nThe goal of this kata is to implement this test. Given an integer\
  \ `>=2`, the program should calculate the sequence `S(n)` up to `p-1` and calculate\
  \ the remainder modulo `Mp`, then return `True` or `False` as a result of the test.\
  \ The case `n = 2` should return `True`.\n\nYou should take advantage of the fact\
  \ that:\n\n```k = (k mod 2^n + floor(k/2^n)) mod Mn```\n\nOr in other words, if\
  \ we take the least significant `n` bits of `k`, and add the remaining bits of `k`,\
  \ and then do this repeatedly until at most `n` bits remain, we can compute the\
  \ remainder after dividing `k` by the Mersenne number `2^n−1` without using division.\n\
  \nThis test can be improved using the fact that if `n` is not prime, `2^n-1` will\
  \ not be prime. So in theory you can test for the primality of `n` beforehand. But\
  \ in practice the test for the primality of `n` will rapidly outgrow in difficulty\
  \ the Lucas-Lehmer test. So we can only use heuristics to rule out `n` with small\
  \ factors but not complete factorization algorithm. You don't need to implement\
  \ such heuristics here. \n\nThe rapid growth of `s^2` makes javascript reach its\
  \ integer limit quickly (coherent result for `n = 13`, but not `17`). Whereas python\
  \ seems to be only limited by the execution time limit and let us see that M11,213\
  \ is prime (contains 3376 digits)."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def Nat.sqrt (n : Nat) : Nat := sorry\n\ndef lucas_lehmer (n :\
  \ Nat) : Bool := sorry\n"
"vc-theorems": "theorem lucas_lehmer_returns_bool (n : Nat) : \n  lucas_lehmer n =\
  \ true ∨ lucas_lehmer n = false := sorry\n\n\ntheorem lucas_lehmer_less_than_two\
  \ (n : Nat) :\n  n < 2 → lucas_lehmer n = false := sorry\n\n\ntheorem lucas_lehmer_two\
  \ :\n  lucas_lehmer 2 = true := sorry\n\n\ntheorem lucas_lehmer_even (n : Nat) :\n\
  \  n > 2 → n % 2 = 0 → lucas_lehmer n = false := sorry\n\n\ntheorem lucas_lehmer_composite\
  \ (n : Nat) :\n  n > 2 → (∃ i : Nat, 2 ≤ i ∧ i * i ≤ n ∧ n % i = 0) → \n  lucas_lehmer\
  \ n = false := sorry\n  \n\ntheorem lucas_lehmer_large (n : Nat) :\n  n > 12000\
  \ → lucas_lehmer n = false := sorry\n\n\ntheorem lucas_lehmer_non_positive (n :\
  \ Int) :\n  n ≤ 0 → lucas_lehmer n.natAbs = false := sorry\n\n/--\ninfo: True\n\
  -/\n#guard_msgs in\n#eval lucas_lehmer 2\n\n/--\ninfo: False\n-/\n#guard_msgs in\n\
  #eval lucas_lehmer 4\n\n/--\ninfo: True\n-/\n#guard_msgs in\n#eval lucas_lehmer\
  \ 7\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
