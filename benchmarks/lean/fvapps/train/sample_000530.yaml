"vc-description": "An encoder encodes the first $16$ lowercase English letters using\
  \ $4$ bits each. The first bit (from the left) of the code is $0$ if the letter\
  \ lies among the first $8$ letters, else it is $1$, signifying that it lies among\
  \ the last $8$ letters. The second bit of the code is $0$ if the letter lies among\
  \ the first $4$ letters of those $8$ letters found in the previous step, else it's\
  \ $1$, signifying that it lies among the last $4$ letters of those $8$ letters.\
  \ Similarly, the third and the fourth bit each signify the half in which the letter\
  \ lies. \nFor example, the letter $j$ would be encoded as :\n- Among $(a,b,c,d,e,f,g,h$\
  \ $|$ $i,j,k,l,m,n,o,p)$, $j$ appears in the second half. So the first bit of its\
  \ encoding is $1$.\n- Now, among $(i,j,k,l$ $|$ $m,n,o,p)$, $j$ appears in the first\
  \ half. So the second bit of its encoding is $0$.\n- Now, among $(i,j$ $|$ $k,l)$,\
  \ $j$ appears in the first half. So the third bit of its encoding is $0$.\n- Now,\
  \ among $(i$ $|$ $j)$, $j$ appears in the second half. So the fourth and last bit\
  \ of its encoding is $1$.\nSo $j$'s encoding is $1001$,\nGiven a binary encoded\
  \ string $S$, of length at most $10^5$, decode the string. That is, the first 4\
  \ bits are the encoding of the first letter of the secret message, the next 4 bits\
  \ encode the second letter, and so on. It is guaranteed that the string's length\
  \ is a multiple of 4.\n\n-----Input:-----\n- The first line of the input contains\
  \ an integer $T$, denoting the number of test cases.\n- The first line of each test\
  \ case contains an integer $N$, the length of the encoded string.\n- The second\
  \ line of each test case contains the encoded string $S$.\n\n-----Output:-----\n\
  For each test case, print the decoded string, in a separate line.\n\n-----Constraints-----\n\
  - $1 \\leq T \\leq 10$\n- $4 \\leq N \\leq 10^5$\n- The length of the encoded string\
  \ is a multiple of $4$.\n- $0 \\le S_i \\le 1$\n\n-----Subtasks-----\n- $100$ points\
  \ : Original constraints. \n\n-----Sample Input:-----\n3\n4\n0000\n8\n00001111\n\
  4\n1001\n\n-----Sample Output:-----\na\nap\nj\n\n-----Explanation:-----\n- Sample\
  \ Case $1$ : \nThe first bit is $0$, so the letter lies among the first $8$ letters,\
  \ i.e., among $a,b,c,d,e,f,g,h$. The second bit is $0$, so it lies among the first\
  \ four of these, i.e., among $a,b,c,d$. \nThe third bit is $0$, so it again lies\
  \ in the first half, i.e., it's either $a$ or $b$. Finally, the fourth bit is also\
  \ $0$, so we know that the letter is $a$.\n- Sample Case $2$ : \nEach four bits\
  \ correspond to a character. Just like in sample case $1$, $0000$ is equivalent\
  \ to $a$. Similarly, $1111$ is equivalent to $p$. So, the decoded string is $ap$.\n\
  - Sample Case $3$ : \nThe first bit is $1$, so the letter lies among the last $8$\
  \ letters, i.e., among $i,j,k,l,m,n,o,p$. The second bit is $0$, so it lies among\
  \ the first four of these, i.e., among $i,j,k,l$. \nThe third bit is $0$, so it\
  \ again lies in the first half, i.e., it's either $i$ or $j$. Finally, the fourth\
  \ bit is $1$, so we know that the letter is $j$."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def decode_binary_string (s : String) : String := sorry\n\ntheorem\
  \ decode_binary_chunks {s : String} (h₁: ∀ c ∈ s.data, c = '0' ∨ c = '1')\n  (h₂:\
  \ ∃ n, s.length = 4 * n) :\n  (∀ c ∈ (decode_binary_string s).data, \n    c = 'a'\
  \ ∨ c = 'b' ∨ c = 'c' ∨ c = 'd' ∨ \n    c = 'e' ∨ c = 'f' ∨ c = 'g' ∨ c = 'h' ∨\n\
  \    c = 'i' ∨ c = 'j' ∨ c = 'k' ∨ c = 'l' ∨\n    c = 'm' ∨ c = 'n' ∨ c = 'o' ∨\
  \ c = 'p') := sorry\n"
"vc-theorems": "theorem decode_binary_length {s : String} (h₁: ∀ c ∈ s.data, c = '0'\
  \ ∨ c = '1')\n  (h₂: ∃ n, s.length = 4 * n) :\n  (decode_binary_string s).length\
  \ = s.length / 4 := sorry\n\n\ntheorem single_chunk_maps_to_letter {s : String}\
  \ \n  (h₁: ∀ c ∈ s.data, c = '0' ∨ c = '1')\n  (h₂: s.length = 4) :\n  (decode_binary_string\
  \ s).length = 1 ∧\n  (∃ c ∈ (decode_binary_string s).data,\n    c = 'a' ∨ c = 'b'\
  \ ∨ c = 'c' ∨ c = 'd' ∨ \n    c = 'e' ∨ c = 'f' ∨ c = 'g' ∨ c = 'h' ∨\n    c = 'i'\
  \ ∨ c = 'j' ∨ c = 'k' ∨ c = 'l' ∨\n    c = 'm' ∨ c = 'n' ∨ c = 'o' ∨ c = 'p') :=\
  \ sorry\n\n\ntheorem consistent_mapping {s : String} \n  (h₁: ∀ c ∈ s.data, c =\
  \ '0' ∨ c = '1')\n  (h₂: s.length = 4) :\n  decode_binary_string s = decode_binary_string\
  \ s := sorry\n\n/--\ninfo: 'a'\n-/\n#guard_msgs in\n#eval decode_binary_string \"\
  0000\"\n\n/--\ninfo: 'ap'\n-/\n#guard_msgs in\n#eval decode_binary_string \"00001111\"\
  \n\n/--\ninfo: 'j'\n-/\n#guard_msgs in\n#eval decode_binary_string \"1001\"\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
