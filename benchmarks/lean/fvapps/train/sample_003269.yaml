"vc-description": "A system is transmitting messages in binary, however it is not\
  \ a perfect transmission, and sometimes errors will occur which result in a single\
  \ bit flipping from 0 to 1, or from 1 to 0.\n\nTo resolve this, A 2-dimensional\
  \ Parity Bit Code is used: https://en.wikipedia.org/wiki/Multidimensional_parity-check_code\n\
  \nIn this system, a message is arrayed out on a M x N grid. A 24-bit message could\
  \ be put on a 4x6 grid like so:\n\n\n>1 0 1 0 0 1\n>1 0 0 1 0 0\n>0 1 1 1 0 1\n\
  >1 0 0 0 0 1\n\nThen, Parity bits are computed for each row and for each column,\
  \ equal to 1 if there is an odd number of 1s in the row of column, and 0 if it is\
  \ an even number. The result for the above message looks like:\n\n\n>1 0 1 0 0 1\
  \ 1\n>1 0 0 1 0 0 0\n>0 1 1 1 0 1 0\n>1 0 0 0 0 1 0\n>1 1 0 0 0 1\n\nSince the 1st\
  \ row, and 1st, 2nd and 6th column each have an odd number of 1s in them, and the\
  \ others all do not.\n\nThen the whole message is sent, including the parity bits.\
  \ This is arranged as:\n\n> message + row_parities + column_parities\n> 101001100100011101100001\
  \ + 1000 + 110001\n> 1010011001000111011000011000110001\n\nIf an error occurs in\
  \ transmission, the parity bit for a column and row will be incorrect, which can\
  \ be used to identify and correct the error. If a row parity bit is incorrect, but\
  \ all column bits are correct, then we can assume the row parity bit was the one\
  \ flipped, and likewise if a column is wrong but all rows are correct.\n\n Your\
  \ Task: \n\nCreate a function correct, which takes in integers M and N, and a string\
  \ of bits where the first M\\*N represent the content of the message, the next M\
  \ represent the parity bits for the rows, and the final N represent the parity bits\
  \ for the columns. A single-bit error may or may not have appeared in the bit array.\n\
  \nThe function should check to see if there is a single-bit error in the coded message,\
  \ correct it if it exists, and return the corrected string of bits."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def correct (m n : Nat) (bits : String) : String := sorry\n\ntheorem\
  \ output_length_matches_input \n  (m n : Nat)\n  (bits : String)\n  (h1 : m > 0)\n\
  \  (h2 : n > 0)\n  (h3 : bits.length = m*n + m + n) :\n  (correct m n bits).length\
  \ = bits.length := sorry\n"
"vc-theorems": "theorem output_differs_by_at_most_one_bit\n  (m n : Nat) \n  (bits\
  \ : String)\n  (h1 : m > 0)\n  (h2 : n > 0)\n  (h3 : bits.length = m*n + m + n)\
  \ :\n  let result := correct m n bits\n  let diffs := (List.zip bits.data result.data).filter\
  \ (fun p => p.1 ≠ p.2)\n  diffs.length ≤ 1 := sorry\n\n/--\ninfo: '111'\n-/\n#guard_msgs\
  \ in\n#eval correct 1 1 \"111\"\n\n/--\ninfo: '11111010001'\n-/\n#guard_msgs in\n\
  #eval correct 2 3 \"11011010001\"\n\n/--\ninfo: '111'\n-/\n#guard_msgs in\n#eval\
  \ correct 1 1 \"110\"\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
