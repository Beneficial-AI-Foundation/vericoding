"vc-description": "In an array A containing only 0s and 1s, a K-bit flip consists\
  \ of choosing a (contiguous) subarray of length K and simultaneously changing every\
  \ 0 in the subarray to 1, and every 1 in the subarray to 0.\nReturn the minimum\
  \ number of K-bit flips required so that there is no 0 in the array.  If it is not\
  \ possible, return -1.\n \nExample 1:\nInput: A = [0,1,0], K = 1\nOutput: 2\nExplanation:\
  \ Flip A[0], then flip A[2].\n\n\nExample 2:\nInput: A = [1,1,0], K = 2\nOutput:\
  \ -1\nExplanation: No matter how we flip subarrays of size 2, we can't make the\
  \ array become [1,1,1].\n\n\nExample 3:\nInput: A = [0,0,0,1,0,1,1,0], K = 3\nOutput:\
  \ 3\nExplanation:\nFlip A[0],A[1],A[2]: A becomes [1,1,1,1,0,1,1,0]\nFlip A[4],A[5],A[6]: A\
  \ becomes [1,1,1,1,1,0,0,0]\nFlip A[5],A[6],A[7]: A becomes [1,1,1,1,1,1,1,1]\n\n\
   \n\n\nNote:\n\n1 <= A.length <= 30000\n1 <= K <= A.length"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def A := List Nat \ndef min_k_bit_flips (A : List Nat) (K : Nat)\
  \ : Int :=\n  sorry\n"
"vc-theorems": "theorem min_k_bit_flips_nonnegative_when_possible \n  (A : List Nat)\
  \ (K : Nat) :\n  let result := min_k_bit_flips A K\n  (result ≠ -1) → result ≥ 0\
  \ :=\n  sorry\n\n\ntheorem min_k_bit_flips_bounded_by_length\n  (A : List Nat) (K\
  \ : Nat) :\n  let result := min_k_bit_flips A K\n  (result ≠ -1) → result ≤ (List.length\
  \ A) :=\n  sorry \n\n\ntheorem min_k_bit_flips_k_equals_one_possible\n  (A : List\
  \ Nat) :\n  let result := min_k_bit_flips A 1\n  result ≥ 0 :=\n  sorry\n\n/--\n\
  info: 2\n-/\n#guard_msgs in\n#eval min_k_bit_flips [0, 1, 0] 1\n\n/--\ninfo: -1\n\
  -/\n#guard_msgs in\n#eval min_k_bit_flips [1, 1, 0] 2\n\n/--\ninfo: 3\n-/\n#guard_msgs\
  \ in\n#eval min_k_bit_flips [0, 0, 0, 1, 0, 1, 1, 0] 3\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
