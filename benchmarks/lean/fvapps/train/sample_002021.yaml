"vc-description": "You are given an array $a$ consisting of $n$ non-negative integers.\
  \ You have to choose a non-negative integer $x$ and form a new array $b$ of size\
  \ $n$ according to the following rule: for all $i$ from $1$ to $n$, $b_i = a_i \\\
  oplus x$ ($\\oplus$ denotes the operation bitwise XOR).\n\nAn inversion in the $b$\
  \ array is a pair of integers $i$ and $j$ such that $1 \\le i < j \\le n$ and $b_i\
  \ > b_j$.\n\nYou should choose $x$ in such a way that the number of inversions in\
  \ $b$ is minimized. If there are several options for $x$ — output the smallest one.\n\
  \n\n-----Input-----\n\nFirst line contains a single integer $n$ ($1 \\le n \\le\
  \ 3 \\cdot 10^5$) — the number of elements in $a$.\n\nSecond line contains $n$ space-separated\
  \ integers $a_1$, $a_2$, ..., $a_n$ ($0 \\le a_i \\le 10^9$), where $a_i$ is the\
  \ $i$-th element of $a$.\n\n\n-----Output-----\n\nOutput two integers: the minimum\
  \ possible number of inversions in $b$, and the minimum possible value of $x$, which\
  \ achieves those number of inversions.\n\n\n-----Examples-----\nInput\n4\n0 1 3\
  \ 2\n\nOutput\n1 0\n\nInput\n9\n10 7 9 10 7 5 5 3 5\n\nOutput\n4 14\n\nInput\n3\n\
  8 10 3\n\nOutput\n0 8\n\n\n\n-----Note-----\n\nIn the first sample it is optimal\
  \ to leave the array as it is by choosing $x = 0$.\n\nIn the second sample the selection\
  \ of $x = 14$ results in $b$: $[4, 9, 7, 4, 9, 11, 11, 13, 11]$. It has $4$ inversions:\n\
  \n  $i = 2$, $j = 3$;  $i = 2$, $j = 4$;  $i = 3$, $j = 4$;  $i = 8$, $j = 9$. \n\
  \nIn the third sample the selection of $x = 8$ results in $b$: $[0, 2, 11]$. It\
  \ has no inversions."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def solve_inversions (n : Nat) (arr : List Nat) : Nat × Nat :=\n\
  \  sorry\n"
"vc-theorems": "theorem solve_inversions_output_nat (n : Nat) (arr : List Nat) :\n\
  \  let (inv, out) := solve_inversions n arr\n  Nat.zero ≤ inv ∧ Nat.zero ≤ out :=\n\
  \  sorry\n\n\ntheorem solve_inversions_deterministic (n : Nat) (arr : List Nat)\
  \ :\n  let res1 := solve_inversions n arr\n  let res2 := solve_inversions n arr\n\
  \  res1 = res2 :=\n  sorry\n\nstructure Sorted (l : List Nat) : Prop where\n  sorted\
  \ : ∀ i j, i < j → j < l.length → \n    match l.get? i, l.get? j with\n    | some\
  \ x, some y => x ≤ y\n    | _, _ => True\n\n\ntheorem sorted_array_zero_inversions\
  \ (n : Nat) (arr sorted : List Nat) :\n  Sorted sorted →\n  List.length sorted =\
  \ n →\n  let (inv, _) := solve_inversions n sorted\n  inv = 0 :=\n  sorry\n\n/--\n\
  info: (1, 0)\n-/\n#guard_msgs in\n#eval solve_inversions 4 arr1.copy()\n\n/--\n\
  info: (4, 14)\n-/\n#guard_msgs in\n#eval solve_inversions 9 arr2.copy()\n\n/--\n\
  info: (0, 8)\n-/\n#guard_msgs in\n#eval solve_inversions 3 arr3.copy()\n"
"vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded"
