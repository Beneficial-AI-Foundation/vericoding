"vc-description": "Define a function that takes in two non-negative integers `$a$`\
  \ and `$b$` and returns the last decimal digit of `$a^b$`. Note that `$a$` and `$b$`\
  \ may be very large!\n\nFor example, the last decimal digit of `$9^7$` is `$9$`,\
  \ since `$9^7 = 4782969$`.  The last decimal digit of `$({2^{200}})^{2^{300}}$`,\
  \ which has over `$10^{92}$` decimal digits, is `$6$`.  Also, please take `$0^0$`\
  \ to be `$1$`.\n\nYou may assume that the input will always be valid.\n\n## Examples\n\
  \n```python\nlast_digit(4, 1)                # returns 4\nlast_digit(4, 2)     \
  \           # returns 6\nlast_digit(9, 7)                # returns 9\nlast_digit(10,\
  \ 10 ** 10)        # returns 0\nlast_digit(2 ** 200, 2 ** 300)  # returns 6\n```\n\
  \n___\n\n## Remarks\n\n### JavaScript, C++, R, PureScript\n\nSince these languages\
  \ don't have native arbitrarily large integers, your arguments are going to be strings\
  \ representing non-negative integers instead."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def last_digit (n1 : Nat) (n2 : Nat) : Nat :=\n  sorry\n"
"vc-theorems": "theorem last_digit_range (n1 n2 : Nat) : \n  last_digit n1 n2 ≤ 9\
  \ \n  ∧ last_digit n1 n2 ≥ 0 :=\nsorry\n\n\ntheorem last_digit_zero_exp (n1 : Nat)\
  \ :\n  last_digit n1 0 = 1 :=\nsorry\n\n\ntheorem last_digit_power_one (n1 : Nat)\
  \ :\n  last_digit n1 1 = n1 % 10 :=\nsorry \n\n\ntheorem last_digit_powers_of_ten\
  \ (n1 n2 : Nat) :\n  n1 % 10 = 0 ∧ n2 > 0 → last_digit n1 n2 = 0 :=\nsorry\n\n/--\n\
  info: 4\n-/\n#guard_msgs in\n#eval last_digit 4 1\n\n/--\ninfo: 6\n-/\n#guard_msgs\
  \ in\n#eval last_digit 4 2\n\n/--\ninfo: 9\n-/\n#guard_msgs in\n#eval last_digit\
  \ 9 7\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible"
