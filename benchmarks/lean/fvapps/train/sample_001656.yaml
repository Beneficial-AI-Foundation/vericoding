"vc-description": "# The learning game - Machine Learning #1\nGrowing up you would\
  \ have learnt a lot of things like not to stand in fire, to drink food and eat water\
  \ and not to jump off very tall things But Machines have it difficult they cannot\
  \ learn for themselves we have to tell them what to do, why don't we give them a\
  \ chance to learn it for themselves?\n\n### Task\nYour task is to finish the Machine\
  \ object. What the machine object must do is learn from its mistakes! The Machine\
  \ will be given a command and a number you will return a random action. After the\
  \ command has returned you will be given a response (true/false) if the response\
  \ is true then you have done good, if the response is false then the action was\
  \ a bad one. You must program the machine to learn to apply an action to a given\
  \ command using the reponse given. Note: It must take no more than 20 times to teach\
  \ an action to a command also different commands can have the same action.\n\n###\
  \ Info\n- In the preloaded section there is a constant called ```ACTIONS``` it is\
  \ a function that returns the 5 possible actions.\n- In Java, this a constant ```Actions.FUNCTIONS```\
  \ of type ```List>```. \n- In C++, the actions can be accessed by ```get_action(i)(unsigned\
  \ int num)``` where i chooses the function (and therefore can range from 0 to 4)\
  \ and num is its argument.\n- In python ```ACTIONS()``` returns a list of lambdas.\n\
  - In Golang ```Actions()``` retruns a function slice ```[]func(int) int```"
"vc-preamble": "import Imports.AllImports\n\ndef Machine.command (m : Machine) (cmd\
  \ : String) (n : Int) : Int := sorry\ndef Machine.response (m : Machine) (b : Bool)\
  \ : Machine := sorry"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def Machine.actions : List (Int → Int) := sorry\n\n-- First command\
  \ matches first action"
"vc-theorems": "theorem initial_command_matches_first_action (cmd : String) (n : Int)\
  \ :\n  let m : Machine := default\n  let firstAction := (Machine.actions.head! :\
  \ Int → Int)\n  Machine.command m cmd n = firstAction n := sorry\n\n-- False response\
  \ changes behavior eventually\n\ntheorem false_response_changes_behavior (cmd :\
  \ String) (n : Int) \n  (h : 1 ≤ n ∧ n ≤ 100) :\n  let m : Machine := default\n\
  \  let first := Machine.command m cmd n\n  ∃ i : Nat, i ≤ 3 ∧\n    let m' := Machine.response\
  \ m false\n    let second := Machine.command m' cmd n\n    second ≠ first := sorry\n\
  \n-- Cycles through multiple actions\n\ntheorem cycling_through_actions (cmd : String)\
  \ (n : Int)\n  (h : 1 ≤ n ∧ n ≤ 100) :\n  let m : Machine := default\n  let r1 :=\
  \ Machine.command m cmd n\n  let m1 := Machine.response m false\n  let r2 := Machine.command\
  \ m1 cmd n\n  let m2 := Machine.response m1 false\n  let r3 := Machine.command m2\
  \ cmd n\n  let results := [r1, r2, r3]\n  (results.eraseDups).length ≥ 2 := sorry\n\
  \n-- Different commands are independent\n\ntheorem commands_independent (cmd1 cmd2\
  \ : String) (h : cmd1 ≠ cmd2) :\n  let m : Machine := default\n  let r1 := Machine.command\
  \ m cmd1 1\n  let m' := Machine.response m false\n  let r2 := Machine.command m'\
  \ cmd2 1\n  let firstAction := (Machine.actions.head! : Int → Int)\n  r2 = firstAction\
  \ 1 := sorry\n\n-- True response maintains same action\n\ntheorem true_response_maintains_action\
  \ (cmd : String) (n : Int) :\n  let m : Machine := default\n  let first := Machine.command\
  \ m cmd n\n  let m' := Machine.response m true\n  let second := Machine.command\
  \ m' cmd n\n  first = second := sorry"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded"
