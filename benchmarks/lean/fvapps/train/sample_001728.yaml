"vc-description": "The prime `149` has 3 permutations which are also primes: `419`,\
  \ `491` and `941`.\n\nThere are 3 primes below `1000` with three prime permutations:\n\
  ```python\n149 ==> 419 ==> 491 ==> 941\n179 ==> 197 ==> 719 ==> 971\n379 ==> 397\
  \ ==> 739 ==> 937\n```\n\nBut there are 9 primes below `1000` with two prime permutations:\n\
  ```python\n113 ==> 131 ==> 311\n137 ==> 173 ==> 317\n157 ==> 571 ==> 751\n163 ==>\
  \ 613 ==> 631\n167 ==> 617 ==> 761\n199 ==> 919 ==> 991\n337 ==> 373 ==> 733\n359\
  \ ==> 593 ==> 953\n389 ==> 839 ==> 983\n```\n\nFinally, we can find 34 primes below\
  \ `1000` with only one prime permutation: \n```python\n[13, 17, 37, 79, 107, 127,\
  \ 139, 181, 191, 239, 241, 251, 277, 281, 283, 313, 347, 349, 367, 457, 461, 463,\
  \ 467, 479, 563, 569, 577, 587, 619, 683, 709, 769, 787, 797]\n```\n\nEach set of\
  \ permuted primes are represented by its smallest value, for example the set `149,\
  \ 419, 491, 941` is represented by `149`, and the set has 3 permutations.\n\n**Notes**\n\
  * the original number (`149` in the above example) is **not** counted as a permutation;\n\
  * permutations with leading zeros are **not valid**\n\n## Your Task\n\nYour task\
  \ is to create a function that takes two arguments:\n* an upper limit (`n_max`)\
  \ and\n* the number of prime permutations (`k_perms`) that the primes should generate\
  \ **below** `n_max`\n\nThe function should return the following three values as\
  \ a list:\n* the number of permutational primes below the given limit,\n* the smallest\
  \ prime such prime,\n* and the largest such prime\n\nIf no eligible primes were\
  \ found below the limit, the output should be `[0, 0, 0]`\n\n## Examples\n\nLet's\
  \ see how it would be with the previous cases:\n```python\npermutational_primes(1000,\
  \ 3) ==> [3, 149, 379]\n''' 3 primes with 3 permutations below 1000, smallest: 149,\
  \ largest: 379 '''\n\npermutational_primes(1000, 2) ==> [9, 113, 389]\n''' 9 primes\
  \ with 2 permutations below 1000, smallest: 113, largest: 389 '''\n\npermutational_primes(1000,\
  \ 1) ==> [34, 13, 797]\n''' 34 primes with 1 permutation below 1000, smallest: 13,\
  \ largest: 797 '''\n```\n\nHappy coding!!"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def permutational_primes (n_max k_perms : Nat) : List Nat := sorry\n\
  \n-- Type signature property"
"vc-theorems": "theorem perm_primes_returns_three_nats (n_max k_perms : Nat) : \n\
  \  let result := permutational_primes n_max k_perms;\n  result.length = 3\n  ∧ result.all\
  \ (λ x => x ≥ 0) := sorry\n\n-- Count non-negative property  \n\ntheorem perm_primes_count_nonneg\
  \ (n_max k_perms : Nat) :\n  let result := permutational_primes n_max k_perms;\n\
  \  (result.get! 0) ≥ 0 := sorry\n\n-- Zero count implies zero min/max property\n\
  \ntheorem perm_primes_zero_count (n_max k_perms : Nat) :\n  let result := permutational_primes\
  \ n_max k_perms;\n  (result.get! 0 = 0) →\n  (result.get! 1 = 0 ∧ result.get! 2\
  \ = 0) := sorry\n\n-- Valid count implies valid min/max property  \n\ntheorem perm_primes_valid_bounds\
  \ (n_max k_perms : Nat) :\n  let result := permutational_primes n_max k_perms;\n\
  \  (result.get! 0 > 0) →\n  (result.get! 1 > 1 \n   ∧ result.get! 2 > 1\n   ∧ result.get!\
  \ 1 ≤ result.get! 2\n   ∧ result.get! 1 < n_max\n   ∧ result.get! 2 < n_max) :=\
  \ sorry\n\n/--\ninfo: [3, 149, 379]\n-/\n#guard_msgs in\n#eval permutational_primes\
  \ 1000 3\n\n/--\ninfo: [9, 113, 389]\n-/\n#guard_msgs in\n#eval permutational_primes\
  \ 1000 2\n\n/--\ninfo: [34, 13, 797]\n-/\n#guard_msgs in\n#eval permutational_primes\
  \ 1000 1\n"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded"
