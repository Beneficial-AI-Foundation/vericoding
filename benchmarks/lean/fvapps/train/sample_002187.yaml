"vc-description": "We have a sandglass consisting of two bulbs, bulb A and bulb B.\
  \ These bulbs contain some amount of sand.\nWhen we put the sandglass, either bulb\
  \ A or B lies on top of the other and becomes the upper bulb. The other bulb becomes\
  \ the lower bulb.\nThe sand drops from the upper bulb to the lower bulb at a rate\
  \ of 1 gram per second.\nWhen the upper bulb no longer contains any sand, nothing\
  \ happens.\nInitially at time 0, bulb A is the upper bulb and contains a grams of\
  \ sand; bulb B contains X-a grams of sand (for a total of X grams).\nWe will turn\
  \ over the sandglass at time r_1,r_2,..,r_K. Assume that this is an instantaneous\
  \ action and takes no time. Here, time t refer to the time t seconds after time\
  \ 0.\nYou are given Q queries.\nEach query is in the form of (t_i,a_i).\nFor each\
  \ query, assume that a=a_i and find the amount of sand that would be contained in\
  \ bulb A at time t_i.\n\n-----Constraints-----\n - 1≤X≤10^9\n - 1≤K≤10^5\n - 1≤r_1<r_2<\
  \ .. <r_K≤10^9\n - 1≤Q≤10^5\n - 0≤t_1<t_2< .. <t_Q≤10^9\n - 0≤a_i≤X (1≤i≤Q)\n -\
  \ All input values are integers.\n\n-----Input-----\nThe input is given from Standard\
  \ Input in the following format:\nX\nK\nr_1 r_2 .. r_K\nQ\nt_1 a_1\nt_2 a_2\n:\n\
  t_Q a_Q\n\n-----Output-----\nFor each query, print the answer in its own line.\n\
  \n-----Sample Input-----\n180\n3\n60 120 180\n3\n30 90\n61 1\n180 180\n\n-----Sample\
  \ Output-----\n60\n1\n120\n\nIn the first query, 30 out of the initial 90 grams\
  \ of sand will drop from bulb A, resulting in 60 grams.\nIn the second query, the\
  \ initial 1 gram of sand will drop from bulb A, and nothing will happen for the\
  \ next 59 seconds. Then, we will turn over the sandglass, and 1 second after this,\
  \ bulb A contains 1 gram of sand at the time in question."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def solve_sandglass_wrapped (X K : Nat) (r : List Nat) (Q : Nat)\
  \ (queries : List (Nat × Nat)) : List Nat := sorry\n\ntheorem sandglass_results_length_matches_queries\
  \ (X K : Nat) (r : List Nat) (Q : Nat) (queries : List (Nat × Nat)) :\n  queries.length\
  \ = Q → (solve_sandglass_wrapped X K r Q queries).length = Q := sorry\n"
"vc-theorems": "theorem sandglass_results_within_bounds (X K : Nat) (r : List Nat)\
  \ (Q : Nat) (queries : List (Nat × Nat)) \n  (result : Nat) : \n  result ∈ solve_sandglass_wrapped\
  \ X K r Q queries → result ≤ X ∧ result ≥ 0 := sorry\n\n\ntheorem sandglass_each_result_valid\
  \ (X K : Nat) (r : List Nat) (Q : Nat) \n  (queries : List (Nat × Nat)) (t a : Nat)\
  \ :\n  (t, a) ∈ queries → \n  ∃ result, result ∈ solve_sandglass_wrapped X K r Q\
  \ queries ∧ result ≤ X ∧ result ≥ 0 := sorry\n\n/--\ninfo: [60, 1, 120]\n-/\n#guard_msgs\
  \ in\n#eval solve_sandglass 180 3 [60, 120, 180] 3 [(30, 90), (61, 1), (180, 180)]\n\
  \n/--\ninfo: [100, 10, 0, 0]\n-/\n#guard_msgs in\n#eval solve_sandglass 100 1 [100000]\
  \ 4 [(0, 100), (90, 100), (100, 100), (101, 100)]\n\n/--\ninfo: [19, 52, 91, 10,\
  \ 58, 42, 100]\n-/\n#guard_msgs in\n#eval solve_sandglass 100 5 [48, 141, 231, 314,\
  \ 425] 7 [(0, 19), (50, 98), (143, 30), (231, 55), (342, 0), (365, 100), (600, 10)]\n"
"vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded"
