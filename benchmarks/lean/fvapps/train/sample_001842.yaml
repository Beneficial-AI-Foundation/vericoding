"vc-description": "You are given an integer array nums and you have to return a new\
  \ counts array. The counts array has the property where counts[i] is the number\
  \ of smaller elements to the right of nums[i].\n\nExample:\n\n\nInput: [5,2,6,1]\n\
  Output: [2,1,1,0] \nExplanation:\nTo the right of 5 there are 2 smaller elements\
  \ (2 and 1).\nTo the right of 2 there is only 1 smaller element (1).\nTo the right\
  \ of 6 there is 1 smaller element (1).\nTo the right of 1 there is 0 smaller element."
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def count_smaller (nums : List Int) : List Int := sorry\n\ntheorem\
  \ count_smaller_length {nums : List Int} (h : nums ≠ []) :\n  (count_smaller nums).length\
  \ = nums.length := sorry\n"
"vc-theorems": "theorem count_smaller_range {nums : List Int} (h : nums ≠ []) :\n\
  \  ∀ x ∈ count_smaller nums, 0 ≤ x ∧ x < nums.length := sorry\n\n\ntheorem count_smaller_sorted\
  \ {nums : List Int} (h : nums ≠ []) :\n  (nums.zip (nums.tail?.getD [])).all (fun\
  \ (a, b) => a ≤ b) → \n  count_smaller nums = List.replicate nums.length 0 := sorry\n\
  \n\ntheorem count_smaller_duplicates {nums : List Int} (h : nums ≠ []) :\n  (count_smaller\
  \ (nums ++ nums)).length = 2 * nums.length := sorry"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible"
