"vc-description": "You are given a permutation $p_1, p_2, \\ldots, p_n$.\n\nIn one\
  \ move you can swap two adjacent values.\n\nYou want to perform a minimum number\
  \ of moves, such that in the end there will exist a subsegment $1,2,\\ldots, k$,\
  \ in other words in the end there should be an integer $i$, $1 \\leq i \\leq n-k+1$\
  \ such that $p_i = 1, p_{i+1} = 2, \\ldots, p_{i+k-1}=k$.\n\nLet $f(k)$ be the minimum\
  \ number of moves that you need to make a subsegment with values $1,2,\\ldots,k$\
  \ appear in the permutation.\n\nYou need to find $f(1), f(2), \\ldots, f(n)$.\n\n\
  \n-----Input-----\n\nThe first line of input contains one integer $n$ ($1 \\leq\
  \ n \\leq 200\\,000$): the number of elements in the permutation.\n\nThe next line\
  \ of input contains $n$ integers $p_1, p_2, \\ldots, p_n$: given permutation ($1\
  \ \\leq p_i \\leq n$).\n\n\n-----Output-----\n\nPrint $n$ integers, the minimum\
  \ number of moves that you need to make a subsegment with values $1,2,\\ldots,k$\
  \ appear in the permutation, for $k=1, 2, \\ldots, n$.\n\n\n-----Examples-----\n\
  Input\n5\n5 4 3 2 1\n\nOutput\n0 1 3 6 10 \n\nInput\n3\n1 2 3\n\nOutput\n0 0 0"
"vc-preamble": "import Imports.AllImports\n\ndef BinaryIndexedTree : Type := Unit\n\
  def BinaryIndexedTree.mk (n : Nat) : BinaryIndexedTree := sorry \n\ndef BinaryIndexedTree.add\
  \ (self : BinaryIndexedTree) (i : Nat) (x : Int) : Unit := sorry\ndef BinaryIndexedTree.sum\
  \ (self : BinaryIndexedTree) (i : Nat) : Int := sorry\n\ndef BinaryIndexedTree.sum_range\
  \ (self : BinaryIndexedTree) (l r : Nat) : Int := sorry\ndef BinaryIndexedTree.data\
  \ (self : BinaryIndexedTree) : List Int := sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def solve (n : Nat) (perm : List Nat) : List Nat := sorry\n\ntheorem\
  \ bit_init_properties (n : Nat) (h : n > 0) :\n  let bit := BinaryIndexedTree.mk\
  \ n\n  List.length (BinaryIndexedTree.data bit) = n + 1 ∧ \n  List.all (BinaryIndexedTree.data\
  \ bit) (λ x => x = 0) := sorry\n"
"vc-theorems": "theorem bit_add_sum_properties (n i : Nat) (x : Int) (h1 : n > 0)\
  \ (h2 : i > 0) (h3 : i ≤ n) :\n  let bit := BinaryIndexedTree.mk n\n  let bit' :=\
  \ BinaryIndexedTree.add bit i x\n  BinaryIndexedTree.sum bit i = x ∧ BinaryIndexedTree.sum\
  \ bit n = x := sorry\n\n\ntheorem bit_range_sum_property (n l r : Nat) (h1 : n >\
  \ 0) (h2 : l > 0) (h3 : r > 0)\n  (h4 : l ≤ r) (h5 : r ≤ n) :\n  let bit := BinaryIndexedTree.mk\
  \ n\n  let bit' := List.foldl (λ b i => BinaryIndexedTree.add b (i + l) 1) bit (List.range\
  \ (r - l + 1))\n  BinaryIndexedTree.sum_range bit' l r = r - l + 1 := sorry\n\n\n\
  theorem solve_properties (n : Nat) (perm : List Nat) (h1 : n > 0) \n  (h2 : List.length\
  \ perm = n)\n  (h3 : ∀ i j, i < j → perm.get! i < perm.get! j)\n  (h4 : List.Nodup\
  \ perm) :\n  let result := solve n perm\n  List.length result = n ∧\n  List.all\
  \ result (λ x => x ≥ 0) ∧\n  result.head? = some 0 := sorry\n\n/--\ninfo: [0, 1,\
  \ 3, 6, 10]\n-/\n#guard_msgs in\n#eval solve 5 [5, 4, 3, 2, 1]\n\n/--\ninfo: [0,\
  \ 0, 0]\n-/\n#guard_msgs in\n#eval solve 3 [1, 2, 3]\n\n/--\ninfo: [0]\n-/\n#guard_msgs\
  \ in\n#eval solve 1 [1]\n"
"vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded"
