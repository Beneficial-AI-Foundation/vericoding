"vc-description": "Given the root of a binary tree, the depth of each node is the\
  \ shortest distance to the root.\nReturn the smallest subtree such that it contains\
  \ all the deepest nodes in the original tree.\nA node is called the deepest if it\
  \ has the largest depth possible among any node in the entire tree.\nThe subtree\
  \ of a node is tree consisting of that node, plus the set of all descendants of\
  \ that node.\n \nExample 1:\n\nInput: root = [3,5,1,6,2,0,8,null,null,7,4]\nOutput:\
  \ [2,7,4]\nExplanation: We return the node with value 2, colored in yellow in the\
  \ diagram.\nThe nodes coloured in blue are the deepest nodes of the tree.\nNotice\
  \ that nodes 5, 3 and 2 contain the deepest nodes in the tree but node 2 is the\
  \ smallest subtree among them, so we return it.\n\nExample 2:\nInput: root = [1]\n\
  Output: [1]\nExplanation: The root is the deepest node in the tree.\n\nExample 3:\n\
  Input: root = [0,1,3,null,2]\nOutput: [2]\nExplanation: The deepest node in the\
  \ tree is 2, the valid subtrees are the subtrees of nodes 2, 1 and 0 but the subtree\
  \ of node 2 is the smallest.\n\n \nConstraints:\n\nThe number of nodes in the tree\
  \ will be in the range [1, 500].\nThe values of the nodes in the tree are unique."
"vc-preamble": "import Imports.AllImports\n\ndef maxDepth {α : Type} : Tree α → Nat\n\
  \  | Tree.leaf => 0\n  | Tree.node _ l r => max (maxDepth l) (maxDepth r) + 1\n\n\
  \ndef getDeepestNodes {α : Type} : Tree α → Nat → List (Tree α)\n  | _, _ => sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def subtreeWithAllDeepest {α : Type} : Tree α → Tree α\n  | t =>\
  \ sorry\n"
"vc-theorems": "theorem result_non_none {α : Type} (t : Tree α) :\n  subtreeWithAllDeepest\
  \ t ≠ Tree.leaf := sorry\n\n\ntheorem deepest_nodes_preserved {α : Type} (t : Tree\
  \ α) : \n  let result := subtreeWithAllDeepest t\n  let maxDepthTree := maxDepth\
  \ t\n  let maxDepthResult := maxDepth result\n  let deepestNodesTree := getDeepestNodes\
  \ t maxDepthTree\n  let deepestNodesResult := getDeepestNodes result maxDepthResult\n\
  \  deepestNodesTree = deepestNodesResult := sorry\n\n\ntheorem smallest_possible_subtree\
  \ {α : Type} (t : Tree α) :\n  let result := subtreeWithAllDeepest t\n  match result\
  \ with\n  | Tree.leaf => True\n  | Tree.node _ l r => \n    let leftDepth := maxDepth\
  \ l\n    let rightDepth := maxDepth r\n    leftDepth = rightDepth ∨ (leftDepth ≤\
  \ rightDepth + 1 ∧ rightDepth ≤ leftDepth + 1) := sorry\n\n\ntheorem single_node_case\
  \ {α : Type} (x : α) :\n  subtreeWithAllDeepest (Tree.node x Tree.leaf Tree.leaf)\
  \ = Tree.node x Tree.leaf Tree.leaf := sorry"
"vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded"
