"vc-description": "Iahub likes trees very much. Recently he discovered an interesting\
  \ tree named propagating tree. The tree consists of n nodes numbered from 1 to n,\
  \ each node i having an initial value a_{i}. The root of the tree is node 1.\n\n\
  This tree has a special property: when a value val is added to a value of node i,\
  \ the value -val is added to values of all the children of node i. Note that when\
  \ you add value -val to a child of node i, you also add -(-val) to all children\
  \ of the child of node i and so on. Look an example explanation to understand better\
  \ how it works.\n\nThis tree supports two types of queries:\n\n  \"1 x val\" — val\
  \ is added to the value of node x;  \"2 x\" — print the current value of node x.\
  \ \n\nIn order to help Iahub understand the tree better, you must answer m queries\
  \ of the preceding type.\n\n\n-----Input-----\n\nThe first line contains two integers\
  \ n and m (1 ≤ n, m ≤ 200000). The second line contains n integers a_1, a_2, ...,\
  \ a_{n} (1 ≤ a_{i} ≤ 1000). Each of the next n–1 lines contains two integers v_{i}\
  \ and u_{i} (1 ≤ v_{i}, u_{i} ≤ n), meaning that there is an edge between nodes\
  \ v_{i} and u_{i}.\n\nEach of the next m lines contains a query in the format described\
  \ above. It is guaranteed that the following constraints hold for all queries: 1\
  \ ≤ x ≤ n, 1 ≤ val ≤ 1000.\n\n\n-----Output-----\n\nFor each query of type two (print\
  \ the value of node x) you must print the answer to the query on a separate line.\
  \ The queries must be answered in the order given in the input.\n\n\n-----Examples-----\n\
  Input\n5 5\n1 2 1 1 2\n1 2\n1 3\n2 4\n2 5\n1 2 3\n1 1 2\n2 1\n2 2\n2 4\n\nOutput\n\
  3\n3\n0\n\n\n\n-----Note-----\n\nThe values of the nodes are [1, 2, 1, 1, 2] at\
  \ the beginning.\n\nThen value 3 is added to node 2. It propagates and value -3\
  \ is added to it's sons, node 4 and node 5. Then it cannot propagate any more. So\
  \ the values of the nodes are [1, 5, 1,  - 2,  - 1].\n\nThen value 2 is added to\
  \ node 1. It propagates and value -2 is added to it's sons, node 2 and node 3. From\
  \ node 2 it propagates again, adding value 2 to it's sons, node 4 and node 5. Node\
  \ 3 has no sons, so it cannot propagate from there. The values of the nodes are\
  \ [3, 3,  - 1, 0, 1].\n\nYou can see all the definitions about the tree at the following\
  \ link: http://en.wikipedia.org/wiki/Tree_(graph_theory)"
"vc-preamble": "import Imports.AllImports\n\ndef BIT (n : Nat) : Type := Unit\ndef\
  \ BIT.add (bit : BIT n) (i j v : Nat) : Unit := sorry\n\ndef BIT.get_val (bit :\
  \ BIT n) (i : Nat) : Nat := sorry\ndef BIT.mk (n : Nat) : BIT n := sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def solve_tree_queries (n : Nat) (costs : List Nat) (edges : List\
  \ (List Nat)) (queries : List (List Nat)) : List Nat := sorry\n\ntheorem bit_get_after_add\
  \ (n i : Nat) (h : i < n) :\n  let bit := BIT.mk n\n  let _ := bit.add i (i+1) 1\n\
  \  bit.get_val i = 1 := sorry\n"
"vc-theorems": "theorem bit_accumulate_adds (n i : Nat) (h : i < n - 1) :\n  let bit\
  \ := BIT.mk n  \n  let _ := bit.add i (i+1) 1\n  let _ := bit.add i (i+1) 1\n  bit.get_val\
  \ i = 2 := sorry\n\n\ntheorem solve_tree_queries_initial_cost \n  (n : Nat) (costs\
  \ : List Nat) (edges : List (List Nat)) (h : n ≥ 2) :\n  let queries := [[2,1]]\n\
  \  let result := solve_tree_queries n costs [[1,2]] queries\n  List.get! result\
  \ 0 = List.get! costs 0 := sorry\n\n\ntheorem solve_tree_queries_update\n  (n :\
  \ Nat) (costs : List Nat) (edges : List (List Nat)) (val : Nat) (h : n ≥ 2) :\n\
  \  let queries := [[1,1,val], [2,1]]\n  let result := solve_tree_queries n costs\
  \ [[1,2]] queries  \n  List.get! result 0 = List.get! costs 0 + val := sorry"
"vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded"
