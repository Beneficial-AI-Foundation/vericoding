"vc-description": "You are given a table $a$ of size $2 \\times n$ (i.e. two rows\
  \ and $n$ columns) consisting of integers from $1$ to $n$.\n\nIn one move, you can\
  \ choose some column $j$ ($1 \\le j \\le n$) and swap values $a_{1, j}$ and $a_{2,\
  \ j}$ in it. Each column can be chosen no more than once.\n\nYour task is to find\
  \ the minimum number of moves required to obtain permutations of size $n$ in both\
  \ first and second rows of the table or determine if it is impossible to do that.\n\
  \nYou have to answer $t$ independent test cases.\n\nRecall that the permutation\
  \ of size $n$ is such an array of size $n$ that contains each integer from $1$ to\
  \ $n$ exactly once (the order of elements doesn't matter).\n\n\n-----Input-----\n\
  \nThe first line of the input contains one integer $t$ ($1 \\le t \\le 2 \\cdot\
  \ 10^4$) — the number of test cases. Then $t$ test cases follow.\n\nThe first line\
  \ of the test case contains one integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) — the\
  \ number of columns in the table. The second line of the test case contains $n$\
  \ integers $a_{1, 1}, a_{1, 2}, \\dots, a_{1, n}$ ($1 \\le a_{1, i} \\le n$), where\
  \ $a_{1, i}$ is the $i$-th element of the first row of the table. The third line\
  \ of the test case contains $n$ integers $a_{2, 1}, a_{2, 2}, \\dots, a_{2, n}$\
  \ ($1 \\le a_{2, i} \\le n$), where $a_{2, i}$ is the $i$-th element of the second\
  \ row of the table.\n\nIt is guaranteed that the sum of $n$ does not exceed $2 \\\
  cdot 10^5$ ($\\sum n \\le 2 \\cdot 10^5$).\n\n\n-----Output-----\n\nFor each test\
  \ case print the answer: -1 if it is impossible to obtain permutation of size $n$\
  \ in both first and the second rows of the table, or one integer $k$ in the first\
  \ line, where $k$ is the minimum number of moves required to obtain permutations\
  \ in both rows, and $k$ distinct integers $pos_1, pos_2, \\dots, pos_k$ in the second\
  \ line ($1 \\le pos_i \\le n$) in any order — indices of columns in which you need\
  \ to swap values to obtain permutations in both rows. If there are several answers,\
  \ you can print any.\n\n\n-----Example-----\nInput\n6\n4\n1 2 3 4\n2 3 1 4\n5\n\
  5 3 5 1 4\n1 2 3 2 4\n3\n1 2 1\n3 3 2\n4\n1 2 2 1\n3 4 3 4\n4\n4 3 1 4\n3 2 2 1\n\
  3\n1 1 2\n3 2 2\n\nOutput\n0\n\n2\n2 3 \n1\n1 \n2\n3 4 \n2\n3 4 \n-1"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def solve_permutations (n: Nat) (top bottom: List Nat) : Int ×\
  \ List Nat := sorry\n\ntheorem equal_rows (n: Nat) (h: n > 0) : \n  let top := List.range'\
  \ 1 n;\n  let bottom := List.range' 1 n;\n  let (count, swaps) := solve_permutations\
  \ n top bottom;\n  count = 0 ∧ swaps = [] := sorry\n"
"vc-theorems": "theorem invalid_inputs (n: Nat) (top bottom: List Nat) (h1: n ≥ 2)\
  \ : \n  let invalid := ∃ x ∈ top, x > n ∨ x < 1;\n  let (count, _) := solve_permutations\
  \ n top bottom;\n  invalid → count = -1 := sorry\n\n\ntheorem valid_permutation_result\
  \ (n: Nat) (top bottom: List Nat) (h1: n > 0) :\n  let (count, swaps) := solve_permutations\
  \ n top bottom;\n  count ≠ -1 →\n  (∀ x ∈ top, x ≥ 1 ∧ x ≤ n) ∧\n  (∀ x ∈ bottom,\
  \ x ≥ 1 ∧ x ≤ n) ∧\n  top.eraseDups.length = n ∧\n  bottom.eraseDups.length = n\
  \ := sorry"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded"
