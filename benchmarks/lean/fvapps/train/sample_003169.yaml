"vc-description": "Write a function which reduces fractions to their simplest form!\
  \ Fractions will be presented as an array/tuple (depending on the language), and\
  \ the reduced fraction must be returned as an array/tuple:\n\n```\ninput:   [numerator,\
  \ denominator]\noutput:  [newNumerator, newDenominator]\nexample: [45, 120] -->\
  \ [3, 8]\n```\n\nAll numerators and denominators will be positive integers.\n\n\
  Note: This is an introductory Kata for a series... coming soon!"
"vc-preamble": "import Imports.AllImports"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def reduce_fraction (p : Int × Int) : Int × Int := sorry\n\ntheorem\
  \ reduce_fraction_result_is_int (p : Int × Int) (h : p.2 ≠ 0) : \n  ∃ (a b : Int),\
  \ reduce_fraction p = (a, b) := sorry\n"
"vc-theorems": "theorem reduce_fraction_denominator_positive (p : Int × Int) (h :\
  \ p.2 ≠ 0) :\n  (reduce_fraction p).2 > 0 := sorry\n\n\ntheorem reduce_fraction_preserves_value\
  \ (p : Int × Int) (h : p.2 ≠ 0) :\n  p.1 * (reduce_fraction p).2 = p.2 * (reduce_fraction\
  \ p).1 := sorry \n\n\ntheorem reduce_fraction_is_lowest_terms (p : Int × Int) (h\
  \ : p.2 ≠ 0) :\n  Nat.gcd ((Int.natAbs (reduce_fraction p).1)) (Int.natAbs (reduce_fraction\
  \ p).2) = 1 := sorry\n\n\ntheorem reduce_fraction_zero (n : Int) (h : n ≠ 0) :\n\
  \  reduce_fraction (0, n) = (0, 1) := sorry\n\n/--\ninfo: [3, 1]\n-/\n#guard_msgs\
  \ in\n#eval reduce_fraction [60, 20]\n\n/--\ninfo: [2, 3]\n-/\n#guard_msgs in\n\
  #eval reduce_fraction [80, 120]\n\n/--\ninfo: [3, 8]\n-/\n#guard_msgs in\n#eval\
  \ reduce_fraction [45, 120]\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded"
