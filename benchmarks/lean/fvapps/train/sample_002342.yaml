"vc-description": "Given an array of integers nums, write a method that returns the\
  \ \"pivot\" index of this array.\n\nWe define the pivot index as the index where\
  \ the sum of the numbers to the left of the index is equal to the sum of the numbers\
  \ to the right of the index.\n\nIf no such index exists, we should return -1. If\
  \ there are multiple pivot indexes, you should return the left-most pivot index.\n\
  \n\nExample 1:\n\nInput: \nnums = [1, 7, 3, 6, 5, 6]\nOutput: 3\nExplanation: \n\
  The sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum\
  \ of numbers to the right of index 3.\nAlso, 3 is the first index where this occurs.\n\
  \n\n\nExample 2:\n\nInput: \nnums = [1, 2, 3]\nOutput: -1\nExplanation: \nThere\
  \ is no index that satisfies the conditions in the problem statement.\n\n\n\nNote:\n\
  The length of nums will be in the range [0, 10000].\nEach element nums[i] will be\
  \ an integer in the range [-1000, 1000]."
"vc-preamble": "import Imports.AllImports\n\ndef List.sum (l : List Int) : Int :=\n\
  \  sorry\n\n\ndef Nat.toInt (n : Nat) : Int :=\n  sorry\n"
"vc-helpers": "-- <vc-helpers>\n-- </vc-helpers>"
"vc-definitions": "def find_pivot_index (nums : List Int) : Int :=\n  sorry\n\n\n\n\
  \n"
"vc-theorems": "theorem pivot_index_empty :\n  find_pivot_index [] = -1 := sorry\n\
  \n\ntheorem pivot_index_single {n : Int} :\n  find_pivot_index [n] = 0 := sorry\n\
  \n/--\ninfo: 3\n-/\n#guard_msgs in\n#eval find_pivot_index [1, 7, 3, 6, 5, 6]\n\n\
  /--\ninfo: -1\n-/\n#guard_msgs in\n#eval find_pivot_index [1, 2, 3]\n\n/--\ninfo:\
  \ 0\n-/\n#guard_msgs in\n#eval find_pivot_index [2, 1, -1]\n"
"vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible"
