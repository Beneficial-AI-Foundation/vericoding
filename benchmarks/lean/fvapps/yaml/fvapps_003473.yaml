vc-description: |-
  /-
  Happy traveller [Part 1]
  
  There is a play grid NxN; Always square! 
  
     0  1  2  3
  0 [o, o, o, X]
  1 [o, o, o, o]
  2 [o, o, o, o]
  3 [o, o, o, o]
  
  You start from a random point. I mean, you are given the coordinates of your start position in format (row, col). 
  
  And your TASK is to define the number of unique paths to reach position X (always in the top right corner).
  
  From any point you can go only UP or RIGHT.
  
  Implement a function count_paths(N, (row, col)) which returns int; 
  Assume input params are always valid.
  
  Example:
  
  count_paths(1, (0, 0))
  grid 1x1:
  
  [X]
   You are already in the target point, so return 0
  
  count_paths(2, (1, 0))
  grid 2x2:
  
  [o, X]
  [@, o]
   You are at point @; you can move UP-RIGHT or RIGHT-UP, and there are 2 possible unique paths here
  
  count_paths(2, (1, 1))
  grid 2x2:
  
  [o, X]
  [o, @]
   You are at point @; you can move only UP, so there is 1 possible unique path here
  
  count_paths(3, (1, 0))
  grid 3x3:
  
  [o, o, X]
  [@, o, o]
  [o, o, o]
   You are at point @; you can move UP-RIGHT-RIGHT or RIGHT-UP-RIGHT, or RIGHT-RIGHT-UP, and there are 3 possible unique paths here
  
  I think it's pretty clear =)
  
  btw. you can use preloaded Grid class, which constructs 2d array for you. It's very very basic and simple. You can use numpy instead or any other way to produce the correct answer =)
   grid = Grid(2, 2, 0) 
  samegrid = Grid.square(2) will give you a grid[2][2], which you can print easily to console. 
  
  print(grid)
  
  [0, 0]
  [0, 0]
  
  Enjoy!
  
  You can continue adventures:
  Happy traveller [Part 2]
  -/

vc-preamble: |-

vc-helpers: |-

vc-definitions: |-
  def choose (n m : Nat) : Nat :=
    sorry
  
  def count_paths (n: Nat) (start_pos: Nat × Nat) : Nat :=
    sorry

vc-theorems: |-
  theorem count_paths_one_by_one {n: Nat} (h: n = 1) :
    count_paths n (0, 0) = 0 :=
  sorry
  
  theorem count_paths_non_negative {n row col: Nat} (h1: row < n) (h2: col < n) (h3: n > 0) :
    count_paths n (row, col) ≥ 0 :=
  sorry
  
  theorem count_paths_only_vertical {n row col: Nat} (h1: col = n - 1) (h2: row > 0) (h3: row < n) (h4: n > 0) :
    count_paths n (row, col) = 1 :=
  sorry
  
  theorem count_paths_only_horizontal {n row col: Nat} (h1: row = 0) (h2: col < n - 1) (h3: n > 0) :
    count_paths n (row, col) = 1 :=
  sorry
  
  theorem count_paths_start_equals_target {n: Nat} (h: n ≥ 2) :
    count_paths n (0, n-1) = 1 :=
  sorry

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: guarded_and_plausible
  
  /--
  info: 0
  -/
  #guard_msgs in
  #eval count_paths 1 (0, 0)
  
  /--
  info: 2
  -/
  #guard_msgs in
  #eval count_paths 2 (1, 0)
  
  /--
  info: 3
  -/
  #guard_msgs in
  #eval count_paths 3 (1, 0)
  
  /--
  info: 70
  -/
  #guard_msgs in
  #eval count_paths 5 (4, 0)

