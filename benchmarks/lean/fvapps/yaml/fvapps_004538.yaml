vc-description: |-
  /-
  Given a certain square matrix ```A```, of dimension ```n x n```, that has negative and positive values (many of them may be 0).

  We need the following values rounded to the closest integer:

  - the average of all the positive numbers (more or equal to 0) that are in the principal diagonal and in the columns with odd index, **avg1**

  - the absolute value of the average of all the negative numbers in the secondary diagonal and in the columns with even index, **avg2**

  Let's see the requirements in an example:
  ```
  A = [[ 1,   3, -4,   5, -2,  5,  1], 
      [  2,   0, -7,   6,  8,  8, 15],
      [  4,   4, -2, -10,  7, -1,  7],
      [ -1,   3,  1,   0, 11,  4, 21],
      [ -7,   6, -4,  10,  5,  7,  6],
      [ -5,   4,  3,  -5,  7,  8, 17],
      [-11,   3,  4,  -8,  6, 16,  4]]
  ```    
  The elements of the principal diagonal are: 
  ```
  [1, 0, -2, 0, 5, 8, 4]
  ```
  The ones that are also in the "odd columns" (we consider the index starting with 0) are: 
  ```
  [0, 0, 8] all positives
  ```
  So,
  ```
  avg1 =  [8 / 3] = 3
  ```
  The elements of the secondary diagonal are:
  ```
  [-11, 4, -4, 0, 7, 8, 1]
  ```
  The ones that are in the even columns are:
  ```
  [-11, -4, 7, 1]
  ```
  The negative ones are:
  ```
  [-11, 4]
  ```
  So,
  ```
  avg2 = [|-15 / 2|] = 8
  ```
  Create a function ```avg_diags()```that may receive a square matrix of uncertain dimensions and may output both averages in an array in the following order: ```[avg1, avg2]```

  If one of the diagonals have no elements fulfilling the requirements described above the function should return ```-1```
  So, if the function processes the matrix given above, it should output:
  ```
  [3, 8]
  ```
  Features of the random tests:
  ```
  number of tests = 110
  5 ≤ matrix_length ≤ 1000
  -1000000 ≤ matrix[i, j] ≤ 1000000
  ```
  Enjoy it!
  Translations into another languages will be released soon.
  -/

vc-preamble: |

vc-helpers: |

vc-definitions: |-
  def Matrix (α : Type) := List (List α)

  def avg_diags (matrix : Matrix Int) : List Int :=
    sorry

vc-theorems: |-
  theorem output_format {matrix : Matrix Int} :
    let result := avg_diags matrix
    List.length result = 2 ∧ 
    (∀ x ∈ result, x ≥ -1) := by
    sorry

  theorem diagonal_selection {matrix : Matrix Int} :
    let n := List.length matrix
    let pos_vals := List.filterMap (fun i => 
      if i % 2 = 1 ∧ (matrix.get! i).get! i ≥ 0 
      then some ((matrix.get! i).get! i)
      else none) (List.range n)
    let neg_vals := List.filterMap (fun i =>
      if i % 2 = 0 ∧ (matrix.get! (n-i-1)).get! i < 0
      then some ((matrix.get! (n-i-1)).get! i)
      else none) (List.range n)
    (List.isEmpty pos_vals → (avg_diags matrix).get! 0 = -1) ∧
    (List.isEmpty neg_vals → (avg_diags matrix).get! 1 = -1) := by
    sorry

  theorem three_by_three {matrix : Matrix Int} (h1 : List.length matrix = 3)
      (h2 : ∀ (i : Nat), i < matrix.length → List.length (matrix.get! i) = 3) :
    let result := avg_diags matrix
    ((matrix.get! 1).get! 1 ≥ 0 → result.get! 0 = (matrix.get! 1).get! 1) ∧
    ((matrix.get! 1).get! 1 < 0 → result.get! 0 = -1) ∧
    (let neg_vals := List.filterMap (fun x => if x < 0 then some x else none) 
      [(matrix.get! 0).get! 2, (matrix.get! 2).get! 0]
     if ¬ List.isEmpty neg_vals then
       result.get! 1 = Int.natAbs (neg_vals.foldr (· + ·) 0) / neg_vals.length
     else
       result.get! 1 = -1) := by
    sorry

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: guarded

  /-
  info: [3, 8]
  -/
  #guard_msgs in
  #eval avg_diags [[1, 3, -4, 5, -2, 5, 1], [2, 0, -7, 6, 8, 8, 15], [4, 4, -2, -10, 7, -1, 7], [-1, 3, 1, 0, 11, 4, 21], [-7, 6, -4, 10, 5, 7, 6], [-5, 4, 3, -5, 7, 8, 17], [-11, 3, 4, -8, 6, 16, 4]]

  /-
  info: [5, -1]
  -/
  #guard_msgs in
  #eval avg_diags [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

  /-
  info: [0, -1]
  -/
  #guard_msgs in
  #eval avg_diags [[0, 0], [0, 0]]

