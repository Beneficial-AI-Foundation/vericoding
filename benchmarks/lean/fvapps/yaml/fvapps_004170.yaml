vc-description: |-
  /-
  # Task

  **_Given_** *an array of N integers, you have to find* **_how many times_** *you have to* **_add up the smallest numbers_** *in the array until* **_their Sum_**  *becomes greater or equal to* **_K_**.
  ___

  # Notes: 

  * **_List size_**  is *at least 3*.

  * **_All numbers_**  *will be*  **_positive_**.

  * **_Numbers_**  could  *occur more than once* ,   **_(Duplications may exist)_**.

  * Threshold  **_K_**  will *always be reachable*.
  ___
  # Input >> Output Examples

  ```
  minimumSteps({1, 10, 12, 9, 2, 3}, 6)  ==>  return (2)
  ```
  ## **_Explanation_**:

  * We  *add two smallest elements*  **_(1 + 2)_**,  *their sum is 3* .

  * **_Then_**  we  **_add the next smallest number to it (3 + 3)_** , so  *the sum becomes 6* .

  * **_Now_**  the result is greater or equal to **_6_** ,  *Hence the output is (2) i.e (2) operations are required to do this* .
  ___
  ```
  minimumSteps({8 , 9, 4, 2}, 23)  ==> return (3)
  ```
  ## **_Explanation_**:

  * We  *add two smallest elements*  **_(4 + 2)_**,  *their sum is 6* .

  * **_Then_**  we  **_add the next smallest number to it (6 + 8)_** , so *the sum becomes 14* .

  * **_Now_**  we  **_add the next smallest number (14 + 9)_** , so *the sum becomes 23*  .

  * **_Now_**  the result is greater or equal to **_23_** ,  *Hence the output is (3) i.e (3) operations are required to do this* .
  ___
  ```
  minimumSteps({19,98,69,28,75,45,17,98,67}, 464)  ==>  return (8)
  ```
  ## **_Explanation_**:

  * We  *add two smallest elements*  **_(19 + 17)_**,  *their sum is 36* .

  * **_Then_**  we  **_add the next smallest number to it (36 + 28)_** , so *the sum becomes 64* .

  * We need to **_keep doing this_** *until **_the sum_** becomes greater or equal to **_K_** (464 in this case)*, which will require **_8_** Steps .
  ___
   ## Expected Time Complexity `O(n Log n)`
  ___
  ___
  ___

  # [Playing with Numbers Series](https://www.codewars.com/collections/playing-with-numbers)

  # [Playing With Lists/Arrays Series](https://www.codewars.com/collections/playing-with-lists-slash-arrays)

  # [For More Enjoyable Katas](http://www.codewars.com/users/MrZizoScream/authored)
  ___

  ## ALL translations are welcomed

  ## Enjoy Learning !!
  # Zizou
  -/

vc-preamble: |-
  def minimum_steps (arr : List Nat) (n : Nat) : Option Nat :=
    sorry

  def List.sort (l : List Nat) : List Nat :=
    sorry

vc-helpers: |

vc-definitions: |-
  def sumList (l : List Nat) : Nat :=
    l.foldl (·+·) 0

vc-theorems: |-
  theorem minimum_steps_nonnegative (arr : List Nat) (n : Nat) 
    (h : minimum_steps arr n ≠ none) :
    ∀ result, minimum_steps arr n = some result → result ≥ 0 :=
  sorry

  theorem minimum_steps_less_than_length (arr : List Nat) (n : Nat)
    (h : minimum_steps arr n ≠ none) :
    ∀ result, minimum_steps arr n = some result → result < arr.length :=
  sorry

  theorem minimum_steps_sum_sufficient (arr : List Nat) (n : Nat)
    (h : minimum_steps arr n ≠ none) :
    ∀ result, minimum_steps arr n = some result →
    sumList (List.take (result + 1) (arr.sort)) ≥ n :=
  sorry

  theorem minimum_steps_sum_necessary (arr : List Nat) (n : Nat)
    (h : minimum_steps arr n ≠ none) :
    ∀ result, minimum_steps arr n = some result →
    result > 0 → sumList (List.take result (arr.sort)) < n :=
  sorry

  theorem minimum_steps_sort_invariant (arr : List Nat) (n : Nat) :
    minimum_steps (arr.sort) n = minimum_steps arr n :=
  sorry

  theorem minimum_steps_single_element_target_le (x : Nat) (n : Nat) :
    n ≤ x → minimum_steps [x] n = some 0 :=
  sorry

  theorem minimum_steps_first_element_sufficient (x y z : Nat) :
    minimum_steps [x, y, z] y = some 0 :=
  sorry

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: guarded

  /-
  info: 1
  -/
  #guard_msgs in
  #eval minimum_steps [4, 6, 3] 7

  /-
  info: 1
  -/
  #guard_msgs in
  #eval minimum_steps [10, 9, 9, 8] 17

  /-
  info: 3
  -/
  #guard_msgs in
  #eval minimum_steps [8, 9, 10, 4, 2] 23

