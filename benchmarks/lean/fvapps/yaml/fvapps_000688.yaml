vc-description: |-
  /-
  In 17th century our Chef was a Wizard. He asked his small son "Anshu" to bring him the secret of the Magical Mountain. The boy after travelling a lot reached the Mountain.
  
  The description of the Mountain was as follows:
  - Mountain contains N magical stones. Each of them has a unique number.
  - Mountain was divided into many levels, where at ith level atmost 2^i stones can be found.
  - Between stones there exist a magical path containing lava.
  - A stone can be connected with maximum of three stones.
  - Peak of the mountain contains stone with number 1.
  - If Stone 1 is first connected to stone 2 and then to 3. Assume 2 is to the left of 3.
  
  Now, to get the secret of the mountain, Anshu started climbing from the left. On the way he used his magical wand to protect him from lava. But, while climbing he came to know that he is able to see only the one stone at each level. After reaching the peak he slided down and did the the same process. These stones that he saw shows the secret of the mountain, if they are placed in a non decreasing order on a sunny day. Anshu doesn't remember the stones number that he saw. Help him in recollecting them and getting the secret to his father.
  
  The mountain looks like this
  
  -----Input-----
  - First line contains T the number of test cases.
  - First line of each test test case contains N.
  - Next N-1 lines contains X and Y the stones which are connected.
  
  -----Output-----
  - Output the required non decreasing sequence.
  
  -----Constraints and Subtasks-----
  - 1 <= T <= 10
  - 1 <= X, Y <= N
  Subtask 1: 20 points
  - 3<=N<=100
  Subtask 2: 30 points
  - 3<=N<=10000
  Subtask 3: 50 points
  - 3<=N<=100000
  
  -----Example-----
  Input:
  1
  5
  1 2
  1 3
  2 4
  2 5
  
  Output:
  1 2 3 4 5
  -/

vc-preamble: |-
  def parseNums (s : String) : List Nat :=
    (s.split (· = ' ')).filterMap String.toNat?
  
  def isSorted (l : List Nat) : Bool :=
    match l with
    | [] => true
    | [_] => true
    | x :: y :: rest => x ≤ y && isSorted (y :: rest)

vc-helpers: |-

vc-definitions: |-
  def find_mountain_secret (n : Nat) (edges : List (Nat × Nat)) : String := sorry

vc-theorems: |-
  theorem mountain_secret_produces_unique_nums {n : Nat} {edges : List (Nat × Nat)}
      (h1 : n ≥ 2)
      (h2 : edges.length > 0)
      (h3 : ∀ (e : Nat × Nat), e ∈ edges → e.1 ≤ n ∧ e.2 ≤ n)
      (h4 : ∀ (e : Nat × Nat), e ∈ edges → e.1 ≠ e.2) :
      let nums := parseNums (find_mountain_secret n edges)
      nums.length = nums.eraseDups.length :=
  sorry
  
  theorem mountain_secret_valid_range {n : Nat} {edges : List (Nat × Nat)}
      (h1 : n ≥ 2)
      (h2 : edges.length > 0)
      (h3 : ∀ (e : Nat × Nat), e ∈ edges → e.1 ≤ n ∧ e.2 ≤ n)
      (h4 : ∀ (e : Nat × Nat), e ∈ edges → e.1 ≠ e.2) :
      let nums := parseNums (find_mountain_secret n edges)
      ∀ x ∈ nums, 1 ≤ x ∧ x ≤ n :=
  sorry
  
  theorem mountain_secret_contains_root {n : Nat} {edges : List (Nat × Nat)}
      (h1 : n ≥ 2)
      (h2 : edges.length > 0)
      (h3 : ∀ (e : Nat × Nat), e ∈ edges → e.1 ≤ n ∧ e.2 ≤ n)
      (h4 : ∀ (e : Nat × Nat), e ∈ edges → e.1 ≠ e.2) :
      let nums := parseNums (find_mountain_secret n edges)
      1 ∈ nums :=
  sorry
  
  theorem mountain_secret_sorted {n : Nat} {edges : List (Nat × Nat)}
      (h1 : n ≥ 2)
      (h2 : edges.length > 0)
      (h3 : ∀ (e : Nat × Nat), e ∈ edges → e.1 ≤ n ∧ e.2 ≤ n)
      (h4 : ∀ (e : Nat × Nat), e ∈ edges → e.1 ≠ e.2) :
      let nums := parseNums (find_mountain_secret n edges)
      isSorted nums = true :=
  sorry
  
  theorem mountain_secret_specific_case_1 :
      find_mountain_secret 5 [(1,2), (1,3), (2,4), (2,5)] = "1 2 3 4 5" :=
  sorry
  
  theorem mountain_secret_specific_case_2 :
      find_mountain_secret 3 [(1,2), (1,3)] = "1 2 3" :=
  sorry

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded
  
  /--
  info: '1 2 3 4 5'
  -/
  #guard_msgs in
  #eval find_mountain_secret 5 [(1, 2), (1, 3), (2, 4), (2, 5)]
  
  /--
  info: '1 2 3'
  -/
  #guard_msgs in
  #eval find_mountain_secret 3 [(1, 2), (1, 3)]

