vc-description: |-
  /-
  Alice likes prime numbers. According to Alice, only those strings are nice whose sum of character values at a prime position is prime. She has a string $S$. Now, she has to count the number of nice strings which come before string $S$( including $S$) in the dictionary and are of the same length as $S$. 
  Strings are zero-indexed from left to right.
  To find the character value she uses the mapping {'a': 0, 'b':1, 'c':2 ……. 'y': 24, 'z':25} .
  For example, for string $abcde$ Characters at prime positions are $'c'$ and $'d'$. c + d = 2 + 3 = 5. Since, 5 is a prime number, the string is $nice$.
  Since there could be many nice strings print the answer modulo $10^{9}+7$.

  -----Input:-----
  - First line will contain $T$, number of testcases. Then the testcases follow. 
  - Each testcase contains of a single line of input, the string $S$. 

  -----Output:-----
  For each testcase, output in a single line number of nice strings modulo $10^{9}+7$.

  -----Constraints-----
  - $1 \leq T \leq 10$
  - $2 \leq |S| \leq 10^2$
  String $S$ contains only lowercase letters.

  -----Sample Input:-----
  1
  abc

  -----Sample Output:-----
  10
  -/

vc-preamble: |-
  def is_nice (s: List Char) : Bool :=
    sorry

vc-helpers: |

vc-definitions: |-
  def count_nice_strings (s: List Char) : Nat :=
    sorry

vc-theorems: |-
  theorem count_nice_strings_non_negative (s: List Char) :
    count_nice_strings s ≥ 0 :=
    sorry

  theorem count_nice_strings_upper_bound (s: List Char) :
    count_nice_strings s ≤ (s.length * (s.length + 1)) / 2 :=
    sorry

  theorem empty_string_has_zero_nice (s: List Char) :
    s.length = 0 → count_nice_strings s = 0 :=
    sorry

  theorem is_nice_min_length (s: List Char) :
    is_nice s → s.length ≥ 2 :=
    sorry

  theorem small_strings_not_nice (s: List Char) :
    s.length ≤ 1 → ¬(is_nice s) :=
    sorry

  theorem nice_string_conditions (s: List Char) (i: Nat) :
    is_nice s →
    (∀ i, i < s.length → s.get! 0 = s.get! i) ∨
    (∀ i, i > 0 → i < s.length → Char.toNat (s.get! i) > Char.toNat (s.get! (i-1))) ∨
    (∀ i, i > 0 → i < s.length → Char.toNat (s.get! i) < Char.toNat (s.get! (i-1))) :=
    sorry

  theorem nice_string_has_nice_count (s: List Char) :
    s.length ≥ 2 →
    is_nice s →
    count_nice_strings s ≥ 1 :=
    sorry

  theorem count_matches_actual_nice (s: List Char) :
    count_nice_strings s = 
      (List.foldl (fun acc i => 
        acc + List.foldl (fun inner_acc j =>
          if is_nice (List.take (j + 1) (List.drop i s)) 
          then inner_acc + 1 
          else inner_acc) 
        0 (List.range (s.length - i)))
      0 (List.range s.length)) :=
    sorry

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: guarded

  /-
  info: 3
  -/
  #guard_msgs in
  #eval count_nice_strings "aaa"

  /-
  info: 3
  -/
  #guard_msgs in
  #eval count_nice_strings "abc"

  /-
  info: 3
  -/
  #guard_msgs in
  #eval count_nice_strings "abbc"

