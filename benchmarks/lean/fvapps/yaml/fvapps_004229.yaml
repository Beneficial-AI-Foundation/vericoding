vc-description: |-
  /-
  ## Task

  **_Given_** *an array of integers* , **_Find_** **_the maximum product_** *obtained from multiplying 2 adjacent numbers in the array*.
  ____

  # Notes

  * **_Array/list_** size is *at least 2*.

  * **_Array/list_** numbers could be a *mixture of positives, negatives also zeroes* .
  ___

  # Input >> Output Examples
  ```
  adjacentElementsProduct([1, 2, 3]); ==> return 6
  ```

  ## **_Explanation_**:

  * **_The maximum product_** *obtained from multiplying* ` 2 * 3 = 6 `, and **_they're adjacent numbers in the array_**.
  ___
  ```
  adjacentElementsProduct([9, 5, 10, 2, 24, -1, -48]); ==> return 50
  ```
  ## **_Explanation_**:
  **_Max product_** obtained *from multiplying*   ``` 5 * 10  =  50  ```.
  ___
  ```
  adjacentElementsProduct([-23, 4, -5, 99, -27, 329, -2, 7, -921])  ==>  return -14
  ```

  ## **_Explanation_**:

  * **_The maximum product_** *obtained from multiplying* ` -2 * 7 = -14 `, and **_they're adjacent numbers in the array_**.
  ___
  ___
  ___

  # [Playing with Numbers Series](https://www.codewars.com/collections/playing-with-numbers)

  # [Playing With Lists/Arrays Series](https://www.codewars.com/collections/playing-with-lists-slash-arrays)

  # [For More Enjoyable Katas](http://www.codewars.com/users/MrZizoScream/authored)
  ___

  ## ALL translations are welcomed

  ## Enjoy Learning !!
  # Zizou
  -/

vc-preamble: |

vc-helpers: |

vc-definitions: |-
  def adjacentElementProduct (arr : List Int) : Int :=
    sorry

vc-theorems: |-
  theorem adjacent_product_is_product_of_adjacent_elements {arr : List Int} 
    (h : arr.length ≥ 2) :
    ∃ (i : Nat), i + 1 < arr.length ∧ adjacentElementProduct arr = arr[i]! * arr[i+1]! :=
    sorry

  theorem adjacent_product_is_maximum {arr : List Int} 
    (h : arr.length ≥ 2) :
    ∀ (i : Nat), i + 1 < arr.length → 
      adjacentElementProduct arr ≥ arr[i]! * arr[i+1]! :=
    sorry

  theorem adjacent_product_commutative {arr : List Int}
    (h : arr.length ≥ 2) :
    adjacentElementProduct arr = adjacentElementProduct arr.reverse :=
    sorry

  theorem adjacent_product_error_empty :
    ¬∃ (result : Int), adjacentElementProduct [] = result :=
    sorry

  theorem adjacent_product_error_singleton (x : Int) :
    ¬∃ (result : Int), adjacentElementProduct [x] = result :=
    sorry

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: guarded

  /-
  info: 6
  -/
  #guard_msgs in
  #eval adjacent_element_product [1, 2, 3]

  /-
  info: 50
  -/
  #guard_msgs in
  #eval adjacent_element_product [9, 5, 10, 2, 24, -1, -48]

  /-
  info: -14
  -/
  #guard_msgs in
  #eval adjacent_element_product [-23, 4, -5, 99, -27, 329, -2, 7, -921]

