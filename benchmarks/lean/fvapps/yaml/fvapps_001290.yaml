vc-description: |-
  /-
  A printer – who still uses moveable type – is preparing to print a set of pages for a book. These pages are to be numbered, as usual. The printer needs to know how many instances of each decimal digit will be required to set up the page numbers in the section of the book to be printed.
  
  For example, if pages 10, 11, 12, 13, 14 and 15 are to be printed, computing the number of digits is relatively simple: just look at the page numbers that will appear, and count the number of times each digit appears. The digit 0 appears only once, the digit 1 appears 7 times, the digits 2, 3, 4 and 5 each appear once, and 6, 7, 8 and 9 don’t appear at all.
  
  Your task in this problem is to provide the printer with the appropriate counts of the digits. You will be given the numbers of the two pages that identify the section of the book to be printed. You may safely assume that all pages in that section are to be numbered, that no leading zeroes will be printed, that page numbers are positive, and that no page will have more than three digits in its page number.
  
  -----Input-----
  
  There will be multiple cases to consider. The input for each case has two integers, A and B, each of which is guaranteed to be positive. These identify the pages to be printed. That is, each integer P between A and B, including A and B, is to be printed. A single zero will follow the input for the last case.
  
  -----Output-----
  
  For each input case, display the case number (1, 2, …) and the number of occurrences of each decimal digit 0 through 9 in the specified range of page numbers. Display your results in the format shown in the examples below.
  
  -----Example-----
  Input:
  
  10 15
  912 912
  900 999
  0
  
  Output:
  
  Case 1: 0:1 1:7 2:1 3:1 4:1 5:1 6:0 7:0 8:0 9:0
  Case 2: 0:0 1:1 2:1 3:0 4:0 5:0 6:0 7:0 8:0 9:1
  Case 3: 0:20 1:20 2:20 3:20 4:20 5:20 6:20 7:20 8:20 9:120
  -/

vc-preamble: |-
  def sumList : List Nat → Nat
    | [] => 0
    | x::xs => x + sumList xs
  
  def isSorted : List String → Bool
    | [] => true
    | [_] => true
    | x::y::rest => x ≤ y && isSorted (y::rest)

vc-helpers: |-

vc-definitions: |-
  def countDigits (a b : Nat) : String :=
  sorry

vc-theorems: |-
  theorem countDigits_format_valid {a b : Nat} (h : a ≤ b) (n : Nat) (h1 : n < 10^4) :
    let result := countDigits a b
    let pairs := (result.split (· = ' '))
    pairs.length = 10 ∧
    (∀ p ∈ pairs, ∃ d c, (p.split (· = ':')) = [d, c] ∧
       d ∈ ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"] ∧
       (∀ ch ∈ c.data, ch.isDigit)) ∧
    isSorted (pairs.map (fun p => ((p.split (· = ':')).get! 0))) :=
  sorry
  
  theorem countDigits_count_valid {a b : Nat} (h : a ≤ b) :
    let result := countDigits a b
    let counts := ((result.split (· = ' ')).map
      (fun p => String.toNat! ((p.split (· = ':')).get! 1)))
    let digitCount := (List.range (b - a + 1)).map
      (fun i => (toString (i + a)).length)
    sumList counts = sumList digitCount :=
  sorry
  
  theorem countDigits_single_num_valid (n : Nat) :
    let result := countDigits n n
    let counts := ((result.split (· = ' ')).map
      (fun p => String.toNat! ((p.split (· = ':')).get! 1)))
    ∀ d : Nat, d < 10 →
      (counts.get! d) = ((toString n).data.filter
        (fun c => c = (toString d).data.get! 0)).length :=
  sorry

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded
  
  /--
  info: '0:1 1:7 2:1 3:1 4:1 5:1 6:0 7:0 8:0 9:0'
  -/
  #guard_msgs in
  #eval count_digits 10 15
  
  /--
  info: '0:0 1:1 2:1 3:0 4:0 5:0 6:0 7:0 8:0 9:1'
  -/
  #guard_msgs in
  #eval count_digits 912 912
  
  /--
  info: '0:20 1:20 2:20 3:20 4:20 5:20 6:20 7:20 8:20 9:120'
  -/
  #guard_msgs in
  #eval count_digits 900 999

