vc-description: |-
  /-
  ## Task:

  You have to write a function `pattern` which returns the following Pattern(See Examples) upto n number of rows. 

  * Note:```Returning``` the pattern is not the same as ```Printing``` the pattern.

  ### Rules/Note:

  * The pattern should be created using only unit digits.
  * If `n < 1` then it should return "" i.e. empty string.
  * `The length of each line is same`, and is equal to the number of characters in a line i.e `n`.
  * Range of Parameters (for the sake of CW Compiler) :
    + `n ∈ (-50,150]`

  ### Examples:

   + pattern(8):

         88888888
         87777777
         87666666
         87655555
         87654444
         87654333
         87654322
         87654321

   + pattern(17):

         77777777777777777
         76666666666666666
         76555555555555555
         76544444444444444
         76543333333333333
         76543222222222222
         76543211111111111
         76543210000000000
         76543210999999999
         76543210988888888
         76543210987777777
         76543210987666666
         76543210987655555
         76543210987654444
         76543210987654333
         76543210987654322
         76543210987654321

  [List of all my katas]("http://www.codewars.com/users/curious_db97/authored")
  -/

vc-preamble: |

vc-helpers: |

vc-definitions: |-
  def pattern (n : Int) : String := sorry

  theorem nonpositive_returns_empty {n : Int} (h : n ≤ 0) :
    pattern n = "" := sorry

vc-theorems: |-
  theorem pattern_line_count {n : Int} (h : n > 0) : 
    ((pattern n).split fun c ↦ c = '\n').length = n := sorry

  theorem pattern_line_width {n : Int} (h : n > 0) :
    ∀ line ∈ (pattern n).split fun c ↦ c = '\n', line.length = n := sorry

  theorem pattern_first_line {n : Int} (h : n > 0) :
    let first := ((pattern n).split fun c ↦ c = '\n').get! 0
    ∀ c ∈ first.data, c = first.data[0]! := sorry

  theorem pattern_diagonal_decrease {n : Int} (h : n > 0) :
    let lines := (pattern n).split fun c ↦ c = '\n'
    ∀ i ∈ List.range (min n.toNat 9),
      let curr := (lines.get! (i+1)).data[i+1]!.toString.toNat!
      let prev := (lines.get! i).data[i]!.toString.toNat!
      curr = prev - 1 ∨ (prev = 0 ∧ curr = 9) := sorry

  theorem pattern_all_digits {n : Int} (h : n > 0) :
    let lines := (pattern n).split fun c ↦ c = '\n'
    ∀ line ∈ lines, ∀ c ∈ line.data, c.isDigit := sorry

  theorem first_row_matches_input {n : Int} (h1 : n > 0) (h2 : n ≤ 9) :
    let first := ((pattern n).split fun c ↦ c = '\n').get! 0
    ∀ c ∈ first.data, c.toString.toNat! = n := sorry

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

  /--
  info: '333\n322\n321'
  -/
  #guard_msgs in
  #eval pattern 3

  /--
  info: ''
  -/
  #guard_msgs in
  #eval pattern 0

  /--
  info: expected
  -/
  #guard_msgs in
  #eval pattern 7

