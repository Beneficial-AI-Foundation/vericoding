vc-description: |-
  /-
  We define the function `f1(n,k)`, as the least multiple of `n` that has all its digits less than `k`. 

  We define the function `f2(n,k)`, as the least multiple of `n` that has all the digits that are less than `k`.

  Each digit may occur more than once in both values of `f1(n,k)` and `f2(n,k)`.

  The possible values for `n` and `k` according to these ranges for both functions `f1` and `f2` in this kata:
  ``` 
  1 <= n <= 1.000.000.000.000
  3 <= k <= 9
  ``` 

  For example, let's see the value of both functions for `n = 71` and `k = 4`:
  ``` 
  f1(71,4) == 213 # all its digits less than 4
  f2(71,4) == 2130 # 0,1,2,3 all of them present 
  ```
  The integer `76` is the first integer that has the same values of `f1` and `f2` for `k = 4`. 
  ```
  f1(76,4) = f2(76,4) = 10032
  ```
  Let's call these kind of numbers, **forgiving numbers**. (Let's continue with the fashion of attributing personality traits to numbers and, of course, an unknown one)
  So, `76` is the smallest forgiving number of order `4`.
  In the same way, `485` is the smallest forgiving number of order `5`.

  Create a function that given an integer `n` and the order `k`, will output the higher and closest forgiving number to `n` of order `k`.

  Let's see some examples:
  ```
  find_f1_eq_f2(500,5) == 547
  find_f1_eq_f2(1600,6) == 1799
  find_f1_eq_f2(14900,7) == 14996
  ```
  If the number `n` is a forgiving itself for a certain order `k`, the function will never output the same value, remember, closest and **higher** than `n`.

  For example, `3456`, is a forgiving one of order `4`,
  ```
  find_f1_eq_f2(3456,4) == 3462
  ```
  **Features of the tests:**

  * `n` and `k` will be always valid and positive integers.

  * A total of 8 fixed tests.

  * A total of 150 random tests in the ranges for `n` and `k` given above.

  I'll be waiting your awesome solution. :)
  -/

vc-preamble: |-
  def find_f1_eq_f2 (n : Nat) (k : Nat) : Nat := sorry

  theorem find_f1_eq_f2_basic_case_1 :
    find_f1_eq_f2 542 5 = 547 := sorry

vc-helpers: |

vc-definitions: |-
  def appears_in (d : Nat) (n : Nat) : Prop := sorry 

  theorem find_f1_eq_f2_generates_digits (n k : Nat) (testn := find_f1_eq_f2 n k) :
    ∃ m : Nat, ∀ d : Nat, d < k → ∃ i : Nat, i ≤ m ∧ appears_in d (testn * i) := sorry

vc-theorems: |-
  theorem find_f1_eq_f2_basic_case_2 :
    find_f1_eq_f2 1750 6 = 1799 := sorry

  theorem find_f1_eq_f2_greater_than_input (n k : Nat) :
    find_f1_eq_f2 n k ≥ n := sorry

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

  /-
  info: 547
  -/
  #guard_msgs in
  #eval find_f1_eq_f2 542 5

  /-
  info: 1799
  -/
  #guard_msgs in
  #eval find_f1_eq_f2 1750 6

  /-
  info: 14996
  -/
  #guard_msgs in
  #eval find_f1_eq_f2 14990 7

