vc-description: |-
  /-
  # Task
   You are given n rectangular boxes, the ith box has the length lengthi, the width widthi and the height heighti. 

   Your task is to check if it is possible to pack all boxes into one so that inside each box there is no more than one another box (which, in turn, can contain at most one another box, and so on). 

   More formally, your task is to check whether there is such sequence of n different numbers pi (1 ≤ pi ≤ n) that for each 1 ≤ i < n the box number pi can be put into the box number pi+1.

   A box can be put into another box if all sides of the first one are less than the respective ones of the second one. You can rotate each box as you wish, i.e. you can `swap` its length, width and height if necessary.

  # Example

   For `length = [1, 3, 2], width = [1, 3, 2] and height = [1, 3, 2]`, the output should be `true`;

   For `length = [1, 1], width = [1, 1] and height = [1, 1],` the output should be `false`;

   For `length = [3, 1, 2], width = [3, 1, 2] and height = [3, 2, 1]`, the output should be `false`.

  # Input/Output

   - `[input]` integer array `length`

      Array of positive integers.

      Constraints:

      `1 ≤ length.length ≤ 100,`

      `1 ≤ length[i] ≤ 2000.`

   - `[input]` integer array `width`

      Array of positive integers.

      Constraints:

      `width.length = length.length,`

      `1 ≤ width[i] ≤ 2000.`

   - `[input]` integer array `height`

      Array of positive integers.

      Constraints:

      `height.length = length.length,`

      `1 ≤ height[i] ≤ 2000.`

   - `[output]` a boolean value

      `true` if it is possible to put all boxes into one, `false` otherwise.
  -/

vc-preamble: |

vc-helpers: |

vc-definitions: |-
  def boxes_packing (l w h : List Int) : Bool := sorry

  theorem identical_boxes_not_packable {n : Nat} {d : Int} (h : n > 1) : 
    boxes_packing (List.replicate n d) (List.replicate n d) (List.replicate n d) = false := sorry

vc-theorems: |-
  theorem single_box_always_packable (d : Int) (h : d > 0) :
    boxes_packing [d] [d] [d] = true := sorry

  theorem dimension_order_invariant {n : Nat} (l w h : List Int) 
    (hlen : l.length = n ∧ w.length = n ∧ h.length = n) :
    boxes_packing l w h = boxes_packing w h l ∧ 
    boxes_packing l w h = boxes_packing h l w := sorry

  theorem strictly_increasing_packable {n : Nat} (l w h : List Int)
    (hlen : l.length = n ∧ w.length = n ∧ h.length = n)
    (hsorted : ∀ i j, i < j → i < n → j < n → 
      l[i]! < l[j]! ∧ w[i]! < w[j]! ∧ h[i]! < h[j]!) :
    boxes_packing l w h = true := sorry

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

  /--
  info: True
  -/
  #guard_msgs in
  #eval boxes_packing [1, 3, 2] [1, 3, 2] [1, 3, 2]

  /--
  info: False
  -/
  #guard_msgs in
  #eval boxes_packing [1, 1] [1, 1] [1, 1]

  /--
  info: False
  -/
  #guard_msgs in
  #eval boxes_packing [3, 1, 2] [3, 1, 2] [3, 2, 1]

