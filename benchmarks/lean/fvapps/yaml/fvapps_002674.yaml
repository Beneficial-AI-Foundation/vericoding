vc-description: |-
  /-
  Binary with 0 and 1 is good, but binary with only 0 is even better! Originally, this is a concept designed by Chuck Norris to send so called unary messages.

  Can you write a program that can send and receive this messages?

  Rules

  The input message consists of ASCII characters between 32 and 127 (7-bit)
  The encoded output message consists of blocks of 0
  A block is separated from another block by a space
  Two consecutive blocks are used to produce a series of same value bits (only 1 or 0 values):

  First block is always 0 or 00. If it is 0, then the series contains 1, if not, it contains 0
  The number of 0 in the second block is the number of bits in the series

  Example
  Let’s take a simple example with a message which consists of only one character (Letter 'C').'C' in binary is represented as 1000011, so with Chuck Norris’ technique this gives:

  0 0 - the first series consists of only a single 1
  00 0000 - the second series consists of four 0
  0 00 - the third consists of two 1

  So 'C' is coded as: 0 0 00 0000 0 00
  Second example, we want to encode the message "CC" (i.e. the 14 bits 10000111000011) :

  0 0 - one single 1
  00 0000 - four 0
  0 000 - three 1
  00 0000 - four 0
  0 00 - two 1

  So "CC" is coded as: 0 0 00 0000 0 000 00 0000 0 00
  Note of thanks
  Thanks to the author of the original kata. I really liked this kata. I hope that other warriors will enjoy it too.
  -/

vc-preamble: |

vc-helpers: |

vc-definitions: |-
  def send (s : String) : String := sorry
  def receive (s : String) : String := sorry

vc-theorems: |-
  theorem encoding_decoding_roundtrip {s : String}
    (h : s.length > 0 ∧ s.length ≤ 100) :
    receive (send s) = s := sorry

  theorem send_format {s : String} 
    (h : s.length > 0 ∧ s.length ≤ 100) :
    let encoded := send s
    let segments := encoded.split (· = ' ')
    (∀ seg ∈ segments, (seg.startsWith "0" ∨ seg.startsWith "00")) ∧ 
    (∀ c ∈ encoded.data, c = '0' ∨ c = ' ') := sorry 

  theorem encoded_length_relationship {s : String}
    (h : s.length > 0 ∧ s.length ≤ 100) :
    (send s).length ≥ s.length := sorry

  theorem receive_handles_valid_format {s : String}
    (h : s.length > 0) 
    (h₂ : ∀ c ∈ s.data, c = '0' ∨ c = ' ') :
    (receive s).length > 0 := sorry

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

  /-
  info: '0 0 00 0000 0 00'
  -/
  #guard_msgs in
  #eval send "C"

  /-
  info: '0 0 00 0000 0 000 00 0000 0 00'
  -/
  #guard_msgs in
  #eval send "CC"

