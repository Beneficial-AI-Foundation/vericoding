vc-description: |-
  /-
  Given an array `A` and an integer `x`, map each element in the array to `F(A[i],x)` then return the xor sum of the resulting array.
  
  where F(n,x) is defined as follows:
  
  F(n, x) = ^(x)Cx **+** ^(x+1)Cx **+** ^(x+2)Cx **+** ... **+** ^(n)Cx
  
  and ^(n)Cx represents [Combination](https://en.m.wikipedia.org/wiki/Combination) in mathematics
  
  ### Example
  
  ```python
  a = [7, 4, 11, 6, 5]
  x = 3
  
  # after mapping, `a` becomes [F(7,3), F(4,3), F(11,3), F(6,3), F(5,3)]
  
  return F(7,3) ^ F(4,3) ^ F(11,3) ^ F(6,3) ^ F(5,3)
  #=> 384
  ```
  ##### e.g
  F(7, 3) = ^(3)C3 + ^(4)C3 + ^(5)C3  + ^(6)C3 + ^(7)C3
  
  ## Constraints
  
  **1 <= x <= 10**
  
  **x <= A[i] <= 10^(4)**
  
  **5 <= |A| <= 10^(3)**
  -/

vc-preamble: |-
  def Nat.choose (n k : Nat) : Nat := sorry
  
  def List.sort (l : List Nat) : List Nat := sorry

vc-helpers: |-

vc-definitions: |-
  def transform (arr : List Nat) (x : Nat) : Nat := sorry
  
  theorem transform_single_element (n x : Nat) (h : x ≤ n) :
    transform [n] x = (List.range (n - x + 1)).foldl (fun acc i => acc + Nat.choose (i + x) x) 0 :=
  sorry

vc-theorems: |-
  theorem transform_shuffle (arr : List Nat) (x : Nat) (h : ∀ n ∈ arr, n ≥ x) :
    transform arr x = transform (List.sort arr) x :=
  sorry 
  
  theorem transform_zero_x (arr : List Nat) :
    transform arr 0 = List.foldl (fun acc n => acc + (n + 1)) 0 arr :=
  sorry
  
  /-
  info: 384
  -/
  -- #guard_msgs in
  -- #eval transform [7, 4, 11, 6, 5] 3
  
  /-
  info: 15
  -/
  -- #guard_msgs in
  -- #eval transform [5, 6, 7] 2
  
  /-
  info: 462
  -/
  -- #guard_msgs in
  -- #eval transform [10] 5

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: guarded

