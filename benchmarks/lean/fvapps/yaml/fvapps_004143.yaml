vc-description: |-
  /-
  A generalization of Bézier surfaces, called the S-patch, uses an interesting scheme for indexing its control points.

  In the case of an n-sided surface of degree d, each index has n non-negative integers that sum to d, and all possible configurations are used.

  For example, for a 3-sided quadratic (degree 2) surface the control points are:

  > indices 3 2 => [[0,0,2],[0,1,1],[0,2,0],[1,0,1],[1,1,0],[2,0,0]]

  Given the degree and the number of sides, generate all control point indices.
  The order of the indices in the list can be arbitrary, so for the above example

  > [[1,1,0],[2,0,0],[0,0,2],[0,2,0],[0,1,1],[1,0,1]]

  is also a good solution.
  -/

vc-preamble: |-
  def indices (n d : Nat) : List (List (List Nat)) := sorry

  def sumIndices (idx : List (List Nat)) : Nat := sorry

vc-helpers: |

vc-definitions: |-
  def starsAndBars (n k : Nat) : Nat := sorry

  theorem indices_valid (n d : Nat) (h1: 0 < n) (h2: n ≤ 10) (h3: d ≤ 10) :
    ∀ idx, idx ∈ indices n d →
      idx.length = 1 ∧
      idx.head!.length = n ∧ 
      (∀ x, x ∈ idx.head! → x ≤ d) ∧
      sumIndices idx = d := sorry

vc-theorems: |-
  theorem indices_unique (n d : Nat) (h1: 0 < n) (h2: n ≤ 10) (h3: d ≤ 10) :
    ∀ i j, i ∈ indices n d → j ∈ indices n d → i ≠ j → i.head! ≠ j.head! := sorry

  theorem indices_zero (n : Nat) (h1: 0 < n) (h2: n ≤ 10) :
    indices n 0 = [List.replicate 1 (List.replicate n 0)] := sorry

  theorem indices_singleton (d : Nat) (h: d ≤ 10) :
    indices 1 d = [[[d]]] := sorry

  theorem indices_count (n d : Nat) (h1: 0 < n) (h2: n ≤ 5) (h3: d ≤ 5) :
    (indices n d).length = starsAndBars n d := sorry

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

  /-
  info: 6
  -/
  #guard_msgs in
  #eval len indices(3, 2)

  /-
  info: 3
  -/
  #guard_msgs in
  #eval len idx[0]

  /-
  info: 2
  -/
  #guard_msgs in
  #eval sum idx[0]

