vc-description: |-
  /-
  The Chef has one long loaf of bread of length 1. He wants to cut it into as many little loaves as he can. But he wants to adhere to the following rule: At any moment, the length of the longest loaf which he possesses may not be larger than the length of shortest one, times some constant factor. Every time, he is only allowed to cut exactly one loaf into two shorter ones.

  -----Input-----
  One floating-point number, 1 ≤ k ≤ 1.999, meaning the stated constant factor. The number will have at most 3 digits after the decimal point.

  -----Output-----

  First, you should output one number n, the maximal achievable number of loaves for the given value of the constant factor. Then, you should output any proof that this number of loaves is in fact achievable: n-1 descriptions of cutting, using the following notation. At each step, you print two numbers: first, the index of the loaf that you want to cut into two parts; second, the length of the newly created loaf (cut off from the original one). It is assumed that the starting loaf has index 0. Each newly created loaf will be given the lowest possible free integer index (so, at the ith step this will be i). Each time, the size of size of the original loaf will be decreased by the size of the newly created loaf.

  -----Example-----
  Input:
  1.5
  Output:
  4
  0 0.4
  0 0.3
  1 0.2
  -/

vc-preamble: |

vc-helpers: |

vc-definitions: |-
  def max_loaves (k : Float) : (Nat × List (Nat × Float)) :=
    sorry

vc-theorems: |-
  theorem max_loaves_result_is_four (k : Float) 
    (hk : 1 ≤ k ∧ k ≤ 10) :
    (max_loaves k).1 = 4 :=
    sorry

  theorem max_loaves_gives_three_instructions (k : Float)
    (hk : 1 ≤ k ∧ k ≤ 10) :
    List.length (max_loaves k).2 = 3 :=
    sorry

  theorem max_loaves_cut_sum_is_point_nine (k : Float)
    (hk : 1 ≤ k ∧ k ≤ 10) :
    let cuts := (max_loaves k).2;
    let total := (cuts.map (λ x => x.2)).foldl (λ x y => x + y) 0;
    Float.abs (total - 0.9) < 1e-10 :=
    sorry

  theorem max_loaves_cuts_are_decreasing (k : Float)
    (hk : 1 ≤ k ∧ k ≤ 10) :
    let cuts := (max_loaves k).2;
    let lengths := cuts.map (λ x => x.2);
    ∀ i : Fin (lengths.length - 1),
      lengths[i] ≥ lengths[i.val + 1] :=
    sorry

  theorem max_loaves_indices_are_valid (k : Float)
    (hk : 1 ≤ k ∧ k ≤ 10) :
    let cuts := (max_loaves k).2;
    have h_len : List.length cuts = 3 := by exact max_loaves_gives_three_instructions k hk;
    have h0 : 0 < 3 := by exact Nat.zero_lt_succ 2
    have h1 : 1 < 3 := by exact Nat.succ_lt_succ (Nat.zero_lt_succ 1)
    have h2 : 2 < 3 := by exact Nat.lt_succ_self 2
    have h0' : 0 < List.length cuts := by rw [h_len]; exact h0
    have h1' : 1 < List.length cuts := by rw [h_len]; exact h1
    have h2' : 2 < List.length cuts := by rw [h_len]; exact h2
    (cuts.get ⟨0, h0'⟩).1 = 0 ∧ 
    (cuts.get ⟨1, h1'⟩).1 = 0 ∧
    (cuts.get ⟨2, h2'⟩).1 = 1 :=
    sorry

vc-postamble: |-
  -- Apps difficulty: competition
  -- Assurance level: unguarded

  /--
  info: 3
  -/
  #guard_msgs in
  #eval len instr

