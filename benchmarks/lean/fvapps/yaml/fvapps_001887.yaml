vc-description: |-
  /-
  Given an integer n, find the closest integer (not including itself), which is a palindrome. 
  
  The 'closest' is defined as absolute difference minimized between two integers.
  
  Example 1:
  
  Input: "123"
  Output: "121"
  
  Note:
  
  The input n is a positive integer represented by string, whose length will not exceed 18.
  If there is a tie, return the smaller one as answer.
  -/
  
  -- Basic type constraints
  
  -- Result should be numeric
  
  -- Result differs from input
  
  -- Result length within ±1 of input length
  
  -- Result is palindromic
  
  -- Result doesn't start with '0'
  
  -- Result is closest palindrome (minimality)

vc-preamble: |-

vc-helpers: |-

vc-definitions: |-
  def find_closest_palindrome (s : String) : String :=
  sorry
  
  def isPalindrome (s : String) : Bool :=
  sorry
  
  def allCharsNumeric (s : String) : Bool :=
  sorry
  
  def toNat (s : String) : Nat :=
  sorry
  
  def toString! (n : Nat) : String :=
  sorry

vc-theorems: |-
  theorem find_closest_palindrome_outputs_nonempty {n : String}
    (h : isPalindrome n = false)
    : String.length (find_closest_palindrome n) > 0 :=
  sorry
  
  theorem find_closest_palindrome_is_numeric {n : String}
    (h : isPalindrome n = false)
    : allCharsNumeric (find_closest_palindrome n) = true :=
  sorry
  
  theorem find_closest_palindrome_different {n : String}
    (h : isPalindrome n = false)
    : find_closest_palindrome n ≠ n :=
  sorry
  
  theorem find_closest_palindrome_length {n : String}
    (h : isPalindrome n = false)
    : (String.length (find_closest_palindrome n)).sub (String.length n) ≤ 1 ∧
      (String.length n).sub (String.length (find_closest_palindrome n)) ≤ 1 :=
  sorry
  
  theorem find_closest_palindrome_is_palindrome {n : String}
    (h : isPalindrome n = false)
    : isPalindrome (find_closest_palindrome n) = true :=
  sorry
  
  theorem find_closest_palindrome_no_leading_zero {n : String}
    (h : isPalindrome n = false)
    : String.get! (find_closest_palindrome n) 0 ≠ '0' :=
  sorry
  
  theorem find_closest_palindrome_is_minimal {n : String}
    (h : isPalindrome n = false)
    (h2 : String.length n ≥ 1)
    : let result := find_closest_palindrome n
      let diff := (toNat result).sub (toNat n)
      ∀ k : Nat,
        k ≠ toNat n →
        isPalindrome (toString! k) = true →
        (k.sub (toNat n)).min ((toNat n).sub k) ≥ diff :=
  sorry

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded
  
  /--
  info: '121'
  -/
  #guard_msgs in
  #eval find_closest_palindrome "123"
  
  /--
  info: '999'
  -/
  #guard_msgs in
  #eval find_closest_palindrome "1000"
  
  /--
  info: '1001'
  -/
  #guard_msgs in
  #eval find_closest_palindrome "999"

