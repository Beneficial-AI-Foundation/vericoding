vc-description: |-
  /-
  Given an integer array, return the k-th smallest distance among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B. 

  Example 1:

  Input:
  nums = [1,3,1]
  k = 1
  Output: 0 
  Explanation:
  Here are all the pairs:
  (1,3) -> 2
  (1,1) -> 0
  (3,1) -> 2
  Then the 1st smallest distance pair is (1,1), and its distance is 0.

  Note:

  2 .
  0 .
  1 .
  -/

vc-preamble: |-
  def abs (x : Int) : Int :=
    if x < 0 then -x else x

  def maximum (l : List Int) : Int :=
  sorry

  def minimum (l : List Int) : Int :=
  sorry

vc-helpers: |

vc-definitions: |-
  def smallest_distance_pair : List Int → Nat → Int :=
  sorry

vc-theorems: |-
  theorem smallest_distance_pair_properties {nums : List Int} {k : Nat}
      (h1 : nums.length ≥ 2)
      (h2 : k ≥ 1)
      (h3 : k ≤ (nums.length * (nums.length - 1)) / 2)
      (h4 : ∀ x ∈ nums, -100 ≤ x ∧ x ≤ 100) :
      let result := smallest_distance_pair nums k;
      result ≥ 0 ∧
      result ≤ maximum nums - minimum nums :=
  sorry

  theorem identical_elements {n : List Int} (h : n.length ≥ 2) :
    smallest_distance_pair (List.replicate n.length (n.get! 0)) 1 = 0 :=
  sorry

  theorem sorted_input_equivalence {nums : List Int} (h : nums.length ≥ 2) :
    smallest_distance_pair nums 1 = smallest_distance_pair (nums.reverse.reverse) 1 :=
  sorry

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded

  /-
  info: 0
  -/
  #guard_msgs in
  #eval smallest_distance_pair [1, 1, 3] 1

  /-
  info: 0
  -/
  #guard_msgs in
  #eval smallest_distance_pair [1, 3, 1] 1

  /-
  info: 5
  -/
  #guard_msgs in
  #eval smallest_distance_pair [1, 6, 1] 3

