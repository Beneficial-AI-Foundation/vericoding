vc-description: |-
  /-
  You are given a positive integer $N$. Consider the sequence $S = (1, 2, \ldots, N)$. You should choose two elements of this sequence and swap them.
  A swap is nice if there is an integer $M$ ($1 \le M < N$) such that the sum of the first $M$ elements of the resulting sequence is equal to the sum of its last $N-M$ elements. Find the number of nice swaps.
  
  -----Input-----
  - The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.
  - The first and only line of each test case contains a single integer $N$.
  
  -----Output-----
  For each test case, print a single line containing one integer ― the number of nice swaps.
  
  -----Constraints-----
  - $1 \le T \le 10^6$
  - $1 \le N \le 10^9$
  
  -----Subtasks-----
  Subtask #1 (10 points):
  - $T \le 10$
  - $N \le 10^3$
  Subtask #2 (30 points):
  - $T \le 10$
  - $N \le 10^6$
  Subtask #3 (60 points): original constraints
  
  -----Example Input-----
  5
  1
  2
  3
  4
  7
  
  -----Example Output-----
  0
  0
  2
  2
  3
  -/

vc-preamble: |-
  def canSplitEvenly (n : Nat) : Bool :=
    sorry
  
  def countPossibleSwaps (n : Nat) : Nat :=
    sorry

vc-helpers: |-

vc-definitions: |-
  def solveSwaps (n : Nat) : Nat :=
    sorry

vc-theorems: |-
  theorem solve_swaps_returns_valid_count (n : Nat) (h : n > 0) :
    let result := solveSwaps n
    result ≥ 0 ∧ result ≤ countPossibleSwaps n ∧
    (¬canSplitEvenly n → result = 0) :=
    sorry
  
  theorem solve_swaps_small_sequences (n : Nat) (h1 : n > 0) (h2 : n ≤ 2) :
    solveSwaps n = 0 :=
    sorry
  
  /-
  info: 0
  -/
  -- #guard_msgs in
  -- #eval solve_swaps 1
  
  /-
  info: 0
  -/
  -- #guard_msgs in
  -- #eval solve_swaps 2
  
  /-
  info: 3
  -/
  -- #guard_msgs in
  -- #eval solve_swaps 7

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: guarded

