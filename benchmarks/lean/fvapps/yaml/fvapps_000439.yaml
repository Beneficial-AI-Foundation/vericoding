vc-description: |-
  /-
  Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
  
  (i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]).
  
  Find the minimum element.
  
  You may assume no duplicate exists in the array.
  
  Example 1:
  
  Input: [3,4,5,1,2] 
  Output: 1
  
  Example 2:
  
  Input: [4,5,6,7,0,1,2]
  Output: 0
  -/

vc-preamble: |-
  def findMin (arr : List Int) : Int :=
    sorry
  
  def rotateList (xs : List Int) (n : Nat) : List Int :=
    sorry

vc-helpers: |-

vc-definitions: |-
  def listMin (xs : List Int) : Int :=
    sorry

vc-theorems: |-
  theorem findMin_singleton (n : Int) :
    findMin [n] = n :=
    sorry
  
  theorem findMin_pair (a b : Int) :
    findMin [a, b] = min a b :=
    sorry
  
  theorem findMin_triple (a b c : Int) :
    findMin [a, b, c] = min (min a b) c :=
    sorry
  
  theorem findMin_rotated_sorted_unique {nums : List Int} (h1 : nums.length ≥ 4)
      (h2 : List.Pairwise (· ≠ ·) nums) (h3 : ∀ x ∈ nums, -100 ≤ x ∧ x ≤ 100) :
    findMin (rotateList nums (nums.length / 2)) = listMin nums :=
    sorry
  
  /-
  info: 1
  -/
  -- #guard_msgs in
  -- #eval findMin [3, 4, 5, 1, 2]
  
  /-
  info: 0
  -/
  -- #guard_msgs in
  -- #eval findMin [4, 5, 6, 7, 0, 1, 2]
  
  /-
  info: 1
  -/
  -- #guard_msgs in
  -- #eval findMin [1, 2, 3, 4, 5]

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded

