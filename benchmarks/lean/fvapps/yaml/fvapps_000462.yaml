vc-description: |-
  /-
  Given an array of non-negative integers arr, you are initially positioned at start index of the array. When you are at index i, you can jump to i + arr[i] or i - arr[i], check if you can reach to any index with value 0.
  Notice that you can not jump outside of the array at any time.
  
  Example 1:
  Input: arr = [4,2,3,0,3,1,2], start = 5
  Output: true
  Explanation: 
  All possible ways to reach at index 3 with value 0 are: 
  index 5 -> index 4 -> index 1 -> index 3 
  index 5 -> index 6 -> index 4 -> index 1 -> index 3 
  
  Example 2:
  Input: arr = [4,2,3,0,3,1,2], start = 0
  Output: true 
  Explanation: 
  One possible way to reach at index 3 with value 0 is: 
  index 0 -> index 4 -> index 1 -> index 3
  
  Example 3:
  Input: arr = [3,0,2,1,2], start = 2
  Output: false
  Explanation: There is no way to reach at index 1 with value 0.
  
  Constraints:
  
  1 <= arr.length <= 5 * 10^4
  0 <= arr[i] < arr.length
  0 <= start < arr.length
  -/

vc-preamble: |-

vc-helpers: |-

vc-definitions: |-
  def can_reach (arr : Array Nat) (start : Nat) : Bool := sorry
  
  theorem start_within_bounds {arr : Array Nat} {start : Nat} :
    start ≥ arr.size → can_reach arr start = false := sorry

vc-theorems: |-
  theorem array_contains_zero {arr : Array Nat} {start : Nat} :
    start < arr.size → 
    (∀ x ∈ arr.toList, x ≠ 0) →
    can_reach arr start = false := sorry
  
  theorem reachable_properties {arr : Array Nat} {start : Nat} : 
    start < arr.size →
    (∃ x ∈ arr.toList, x = 0) →
    can_reach arr start = true →
    ∃ path : List Nat, 
      path.head? = some start ∧
      (∃ pos, pos < arr.size ∧ pos ∈ path ∧ arr[pos]! = 0) ∧
      ∀ i j, i + 1 < path.length → j = i + 1 →
        let pos₁ := path[i]!
        let pos₂ := path[j]!
        let jump := arr[pos₁]!
        (pos₂ = pos₁ + jump ∨ pos₂ = pos₁ - jump) ∧
        pos₁ < arr.size ∧ pos₂ < arr.size := sorry 
  
  theorem symmetric_jumps {arr : Array Nat} {start : Nat} :
    start < arr.size →
    can_reach arr start = true →
    let zero_pos := (arr.findIdx? (· = 0)).get!
    can_reach arr zero_pos = true := sorry
  
  /-
  info: True
  -/
  -- #guard_msgs in
  -- #eval can_reach #[4, 2, 3, 0, 3, 1, 2] 5
  
  /-
  info: True
  -/
  -- #guard_msgs in
  -- #eval can_reach #[4, 2, 3, 0, 3, 1, 2] 0
  
  /-
  info: False
  -/
  -- #guard_msgs in
  -- #eval can_reach #[3, 0, 2, 1, 2] 2

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded

