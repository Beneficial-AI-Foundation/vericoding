vc-description: |-
  /-
  Given an integer, if the length of it's digits is a perfect square, return a square block of sqroot(length) * sqroot(length). If not, simply return "Not a perfect square!".
  
  Examples:
  
  1212 returns:
  
  >1212  
  
  Note: 4 digits so 2 squared (2x2 perfect square). 2 digits on each line.
  
  123123123 returns: 
  >123123123
  
  Note: 9 digits so 3 squared (3x3 perfect square). 3 digits on each line.
  -/
  
  -- represents number with k*k ones

vc-preamble: |-
  def splitLines (s : String) : List String :=
    String.splitOn s "\n"

vc-helpers: |-

vc-definitions: |-
  def isqrt (n : Nat) : Nat := sorry
  
  def squareIt (n : Nat) : String :=
  sorry
  
  def isPerfectSquare (n : Nat) : Bool :=
  sorry
  
  def hasEqualRows (s : String) : Bool :=
  sorry

vc-theorems: |-
  theorem square_it_properties (n : Nat) :
    n ≤ 10^12 →
    let digits := toString n
    if isPerfectSquare (digits.length) then
      let result := squareIt n
      result ≠ "Not a perfect square!" ∧
      hasEqualRows result ∧
      let sideLength := isqrt (digits.length)
      (splitLines result).length = sideLength ∧
      (∀ row ∈ splitLines result, row.length = sideLength) ∧
      String.join (splitLines result) = digits
    else
      squareIt n = "Not a perfect square!"
    :=
  sorry
  
  theorem square_it_repeating_ones (n : Nat) (k : Nat) :
    k ≥ 1 →
    k ≤ 4 →
    n = (10^(k*k) - 1)/9 →
    let result := squareIt n
    result ≠ "Not a perfect square!" ∧
    let rows := splitLines result
    ∀ row ∈ rows, match rows.head? with
                  | none => True
                  | some first => row = first
    :=
  sorry

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded
  
  /--
  info: '12\n12'
  -/
  #guard_msgs in
  #eval square_it 1212
  
  /--
  info: '123\n123\n123'
  -/
  #guard_msgs in
  #eval square_it 123123123
  
  /--
  info: 'Not a perfect square!'
  -/
  #guard_msgs in
  #eval square_it 12345

