vc-description: |-
  /-
  In this Kata, we define an arithmetic progression as a series of integers in which the differences between adjacent numbers are the same. You will be given an array of ints of `length > 2` and your task will be to convert it into an arithmetic progression by the following rule:
  ```Haskell
  For each element there are exactly three options: an element can be decreased by 1, an element can be increased by 1 
  or it can be left unchanged.
  ```
  Return the minimum number of changes needed to convert the array to an arithmetic progression. If not possible, return `-1`.
  ```Haskell
  For example: 
  solve([1,1,3,5,6,5]) == 4 because [1,1,3,5,6,5] can be changed to [1,2,3,4,5,6] by making 4 changes.
  solve([2,1,2]) == 1 because it can be changed to [2,2,2]
  solve([1,2,3]) == 0  because it is already a progression, and no changes are needed.
  solve([1,1,10) == -1 because it's impossible.
  solve([5,6,5,3,1,1]) == 4. It becomes [6,5,4,3,2,1]
  ```

  More examples in the test cases. Good luck!
  -/

vc-preamble: |-
  def abs (x : Int) : Int := 
    if x < 0 then -x else x

vc-helpers: |

vc-definitions: |-
  def solve (arr : List Int) : Int := sorry

  theorem solve_sequence_with_small_deviations {arr : List Int} 
    (h1 : arr.length ≥ 3) (h2 : arr.length ≤ 10)
    (h3 : ∃ start step : Int, ∀ (i : Fin arr.length), 
      abs (arr.get i - (start + i.val * step)) ≤ 1) :
    let result := solve arr
    result ≥ 0 ∧ 
    result ≤ (List.range (arr.length-1)).foldl 
      (fun acc i => acc + abs (arr.get ⟨i+1, sorry⟩ - arr.get ⟨i, sorry⟩)) 0 := 
  sorry

vc-theorems: |-
  theorem solve_arbitrary_sequences {arr : List Int}
    (h1 : arr.length ≥ 3) (h2 : arr.length ≤ 10)
    (h3 : ∀ x ∈ arr, -100 ≤ x ∧ x ≤ 100) :
    let result := solve arr
    result ≥ -1 ∧ 
    (result ≠ -1 → result ≥ 0) := 
  sorry

  theorem solve_minimum_length_sequence {arr : List Int}
    (h : arr.length = 3) :
    let result := solve arr
    result ≠ -1 → 
    result ≤ abs (arr.get ⟨1, sorry⟩ - arr.get ⟨0, sorry⟩) + 
             abs (arr.get ⟨2, sorry⟩ - arr.get ⟨1, sorry⟩) :=
  sorry

  theorem solve_constant_sequence {arr : List Int}
    (h1 : arr.length ≥ 3) (h2 : arr.length ≤ 10)
    (h3 : ∀ (i j : Fin arr.length), arr.get i = arr.get j) :
    solve arr = 0 :=
  sorry

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

  /-
  info: 4
  -/
  #guard_msgs in
  #eval solve [1, 1, 3, 5, 6, 5]

  /-
  info: 1
  -/
  #guard_msgs in
  #eval solve [2, 1, 2]

  /-
  info: 0
  -/
  #guard_msgs in
  #eval solve [1, 2, 3]

