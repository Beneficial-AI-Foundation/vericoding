vc-description: |-
  /-
  Your task is to find all the elements of an array that are non consecutive.
  
  A number is non consecutive if it is not exactly one larger than the previous element in the array. The first element gets a pass and is never considered non consecutive.
  
  ~~~if:javascript,haskell,swift
  Create a function named `allNonConsecutive`
  ~~~
  ~~~if:python,rust
  Create a function name `all_non_consecutive`
  ~~~
  
  E.g., if we have an array `[1,2,3,4,6,7,8,15,16]` then `6` and `15` are non-consecutive.
  
  ~~~if:javascript,python
  You should return the results as an array of objects with two values `i: ` and `n: `.
  ~~~
  ~~~if:haskell,swift,rust
  You should return the results as an array of tuples with two values: the index of the non-consecutive number and the non-consecutive number.
  ~~~
  
  E.g., for the above array the result should be:
  ```python
  [
    {'i': 4, 'n': 6},
    {'i': 7, 'n': 15}
  ]
  ```
  
  If the whole array is consecutive or has one element then return an empty array.
  
  The array elements will all be numbers. The numbers will also all be unique and in ascending order. The numbers could be positive and/or negetive and the gap could be larger than one.
  
  If you like this kata, maybe try this one next: https://www.codewars.com/kata/represent-array-of-numbers-as-ranges
  -/

vc-preamble: |-
  def List.Sorted {α : Type} (r : α → α → Prop) (l : List α) : Prop :=
    ∀ i j (h1 : i < j) (h2 : j < l.length), r (l.get ⟨i, Nat.lt_trans h1 h2⟩) (l.get ⟨j, h2⟩)
  
  structure Result where
    i : Nat
    n : Int

vc-helpers: |-

vc-definitions: |-
  def all_non_consecutive (arr : List Int) : List Result :=
    sorry

vc-theorems: |-
  theorem consecutive_not_in_result (arr : List Int) (h : arr.length ≥ 2) :
    ∀ i (h1 : i < arr.length - 1),
    arr.get ⟨i+1, by omega⟩ = arr.get ⟨i, by omega⟩ + 1 →
    ¬∃ r ∈ all_non_consecutive arr, r.i = i + 1 :=
  sorry
  
  theorem non_consecutive_in_result (arr : List Int) (h : arr.length ≥ 2) :
    ∀ i, (h1 : i < arr.length - 1) →
    arr.get ⟨i+1, by omega⟩ ≠ arr.get ⟨i, by omega⟩ + 1 →
    ∃ r ∈ all_non_consecutive arr, r.i = i + 1 ∧ r.n = arr.get ⟨i+1, by omega⟩ :=
  sorry
  
  theorem indices_ascending (arr : List Int) (h : arr.length ≥ 2) :
    let result := all_non_consecutive arr
    result.length > 1 →
    List.Sorted (·≤·) (result.map Result.i) :=
  sorry
  
  theorem valid_indices (arr : List Int) (h : arr.length ≥ 2) :
    ∀ r ∈ all_non_consecutive arr,
    1 ≤ r.i ∧ r.i < arr.length :=
  sorry

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded
  
  /--
  info: expected1
  -/
  #guard_msgs in
  #eval all_non_consecutive [1, 2, 3, 4, 6, 7, 8, 15, 16]
  
  /--
  info: expected2
  -/
  #guard_msgs in
  #eval all_non_consecutive [1, 2, 3, 4, 5]
  
  /--
  info: expected3
  -/
  #guard_msgs in
  #eval all_non_consecutive [-3, -2, -1, 1, 2, 4, 5]

