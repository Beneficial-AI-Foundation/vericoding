vc-description: |-
  /-
  You are given n pairs of numbers. In every pair, the first number is always smaller than the second number.

  Now, we define a pair (c, d) can follow another pair (a, b) if and only if b < c. Chain of pairs can be formed in this fashion. 

  Given a set of pairs, find the length longest chain which can be formed. You needn't use up all the given pairs. You can select pairs in any order.

  Example 1:

  Input: [[1,2], [2,3], [3,4]]
  Output: 2
  Explanation: The longest chain is [1,2] -> [3,4]

  Note:

  The number of given pairs will be in the range [1, 1000].
  -/

vc-preamble: |

vc-helpers: |

vc-definitions: |-
  def find_longest_chain (pairs : List (Int × Int)) : Nat := sorry

  theorem chain_length_bounds (pairs : List (Int × Int)) :
    pairs ≠ [] →
    1 ≤ find_longest_chain pairs ∧ find_longest_chain pairs ≤ pairs.length := sorry

vc-theorems: |-
  theorem chain_length_invariant_under_list_ordering (pairs₁ pairs₂ : List (Int × Int)) :
    pairs₁.length = pairs₂.length → 
    find_longest_chain pairs₁ = find_longest_chain pairs₂ := sorry

  theorem overlapping_pairs_property (pairs : List (Int × Int)) (first : Int × Int) :
    pairs ≠ [] →
    let overlapping := [(first.1, first.2 + 1)]
    find_longest_chain (pairs ++ overlapping) ≤ find_longest_chain pairs + 1 := sorry

  theorem non_overlapping_sequence_length (n : Nat) :
    let pairs := List.map (fun i => (Int.ofNat (2 * i), Int.ofNat (2 * i + 1))) (List.range n)
    find_longest_chain pairs = n := sorry

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded

  /-
  info: 2
  -/
  #guard_msgs in
  #eval find_longest_chain [[1, 2], [2, 3], [3, 4]]

  /-
  info: 2
  -/
  #guard_msgs in
  #eval find_longest_chain [[1, 5], [2, 3], [4, 6]]

  /-
  info: 4
  -/
  #guard_msgs in
  #eval find_longest_chain [[1, 2], [7, 8], [3, 4], [5, 6]]

