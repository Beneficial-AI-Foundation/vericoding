vc-description: |-
  /-
  Similar to the [previous kata](https://www.codewars.com/kata/string-subpattern-recognition-ii/), but this time you need to operate with shuffled strings to identify if they are composed repeating a subpattern
  
  Since there is no deterministic way to tell which pattern was really the original one among all the possible permutations of a fitting subpattern, return a subpattern with sorted characters, otherwise return the base string with sorted characters (you might consider this case as an edge case, with the subpattern being repeated only once and thus equalling the original input string).
  
  For example:
  
  ```python
  has_subpattern("a") == "a"; #no repeated pattern, just one character
  has_subpattern("aaaa") == "a" #just one character repeated
  has_subpattern("abcd") == "abcd" #base pattern equals the string itself, no repetitions
  has_subpattern("babababababababa") == "ab" #remember to return the base string sorted"
  has_subpattern("bbabbaaabbaaaabb") == "ab" #same as above, just shuffled
  ```
  
  If you liked it, go for either the [previous kata](https://www.codewars.com/kata/string-subpattern-recognition-ii/) or the [next kata](https://www.codewars.com/kata/string-subpattern-recognition-iv/) of the series!
  -/

vc-preamble: |-
  def String.count (s : String) (c : Char) : Nat := sorry
  def String.toCharArray (s : String) : Array Char := sorry

vc-helpers: |-

vc-definitions: |-
  def String.fromCharArray (arr : Array Char) : String := sorry
  def has_subpattern (s : String) : String := sorry

vc-theorems: |-
  theorem output_is_substring (s : String) (h : s.length > 0) :
    let result := has_subpattern s
    -- Result length less than input length  
    result.length ≤ s.length ∧ 
    -- Result chars are sorted
    (∀ i j, i < j → i < result.length → j < result.length → 
      result.toCharArray[i]! ≤ result.toCharArray[j]!) ∧
    -- Result chars come from input  
    (∀ c, c ∈ result.toCharArray.toList → c ∈ s.toCharArray.toList) := sorry
  
  theorem output_pattern_reconstruction (s : String) (h : s.length > 0) :
    let pattern := has_subpattern s
    let counts_s := s.toCharArray.toList.map (fun c => (c, s.count c))
    let counts_p := pattern.toCharArray.toList.map (fun c => (c, pattern.count c))
    pattern.length > 0 →
    ∃ ratio : Nat, ∀ (s_c p_c : Char) (s_count p_count : Nat),
      (s_c, s_count) ∈ counts_s →
      (p_c, p_count) ∈ counts_p →
      s_count = p_count * ratio := sorry 
  
  theorem idempotent (s : String) (h : s.length > 0) :
    has_subpattern s = has_subpattern (has_subpattern s) := sorry

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

