vc-description: |-
  /-
  Supermarket Dilemma
  Chef is going to local supermarket but there appears a problem with chef as he is confused about which Supermarket he can choose to go as he is not able to decide whether he can park his car in that particular supermarket’s parking lot or not! There are N parking slots in each supermarket which are marked from 1,2,3,4…N.
  Chef will go to that supermarket in which he gets to know that there is exactly 1 empty parking slot having number K that exactly divides the total number of slots (N) available in that supermarket.
  The 1st and Nth parking slots are always occupied by the staff of every supermarket. Rest parking slots are empty as Chef is arriving early morning to the supermarket.
  Now Chef needs your help in determining whether he can park his car in a supermarket or not!
  Input
  The first line contains the single integer N showing how many supermarkets are there for the chef to choose.
  The next N lines contain a number ‘ai’ which represents the total parking slots available in ith supermarket.
  Output
  You need to output "YES" (without the quotes), if a supermarket can be reached by Chef, and "NO" (without the quotes), if it can't.
  Constraints
  1<=N<=10^5
  1<=ai<=10^12
  Sample Input :
  2
  4
  5
  Sample Output :
  YES
  NO
  -/

vc-preamble: |

vc-helpers: |

vc-definitions: |-
  def solve_supermarket (slots : List Nat) : List String := sorry
  def check (n : Nat) : Nat := sorry

vc-theorems: |-
  theorem solve_supermarket_correct_length (slots : List Nat) 
    (h : slots.length ≥ 1 ∧ slots.length ≤ 100) 
    (h2 : ∀ x ∈ slots, x ≤ 1000) : 
    let result := solve_supermarket slots 
    (result.length = slots.length) ∧ 
    (∀ x ∈ result, x = "YES" ∨ x = "NO") := sorry

  theorem solve_supermarket_single_slot (slot : Nat) (h : slot ≤ 1000) :
    let result := solve_supermarket [slot]
    (slot < 3 → result = ["NO"]) ∧ 
    (∃ n : Nat, n * n = slot → 
      (check n = 1 → result = ["YES"]) ∧
      (check n ≠ 1 → result = ["NO"])) ∧
    ((¬ ∃ n : Nat, n * n = slot) → result = ["NO"]) := sorry

  theorem solve_supermarket_perfect_squares 
    (primes : List Nat := [2, 3, 5, 7, 11, 13]) :
    let squares := primes.map (λ p => p * p)
    solve_supermarket squares = List.replicate squares.length "YES" := sorry

  theorem solve_supermarket_non_perfect_squares
    (non_squares : List Nat := [5, 6, 7, 8, 10, 11, 12, 13, 14, 15]) :
    solve_supermarket non_squares = List.replicate non_squares.length "NO" := sorry

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded

  /--
  info: ['YES', 'NO']
  -/
  #guard_msgs in
  #eval solve_supermarket [4, 5]

  /--
  info: ['YES']
  -/
  #guard_msgs in
  #eval solve_supermarket [9]

  /--
  info: ['NO', 'NO', 'NO']
  -/
  #guard_msgs in
  #eval solve_supermarket [6, 8, 10]

