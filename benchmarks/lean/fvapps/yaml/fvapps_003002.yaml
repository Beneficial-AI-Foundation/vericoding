vc-description: |-
  /-
  A very passive-aggressive co-worker of yours was just fired. While he was gathering his things, he quickly inserted a bug into your system which renamed everything to what looks like jibberish. He left two notes on his desk, one reads: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz" while the other reads: "Uif usjdl up uijt lbub jt tjnqmf kvtu sfqmbdf fwfsz mfuufs xjui uif mfuufs uibu dpnft cfgpsf ju".
  
  Rather than spending hours trying to find the bug itself, you decide to try and decode it. 
  
  If the input is not a string, your function must return "Input is not a string". Your function must be able to handle capital and lower case letters. You will not need to worry about punctuation.
  -/

vc-preamble: |-

vc-helpers: |-

vc-definitions: |-
  def Char.alpha? (c : Char) : Bool := sorry
  
  def Char.ascii? (c : Char) : Bool :=
  sorry
  
  def one_down (s : String) : String :=
  sorry

vc-theorems: |-
  def String.containsAsciiLetter (s : String) : Bool :=
    s.data.any (fun c => c.ascii? && c.alpha?)
  
  theorem one_down_maintains_string_type {s : String} :
    let res := one_down s
    ∃ s', res = s' :=
  sorry
  
  theorem one_down_differs_if_contains_ascii_letter {s : String} :
    s.containsAsciiLetter →
    one_down s ≠ s :=
  sorry
  
  theorem one_down_preserves_length {s : String} :
    (one_down s).length = s.length :=
  sorry
  
  theorem one_down_preserves_non_letters {s : String} {i : Fin s.length} :
    ¬(s.data[i.val]?.map (·.alpha?) |>.getD false) →
    (one_down s).data[i.val]? = s.data[i.val]? :=
  sorry
  
  theorem one_down_non_string_input {α : Type} [ToString α] (x : α) :
    one_down (toString x) = "Input is not a string" :=
  sorry

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded
  
  /--
  info: expected
  -/
  #guard_msgs in
  #eval one_down "Ifmmp"
  
  /--
  info: expected
  -/
  #guard_msgs in
  #eval one_down 45
  
  /--
  info: expected
  -/
  #guard_msgs in
  #eval one_down "BMM DBQT NBZCF"

