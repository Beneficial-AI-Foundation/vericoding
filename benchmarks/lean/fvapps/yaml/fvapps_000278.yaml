vc-description: |-
  /-
  Given an array A of integers, for each integer A[i] we need to choose either x = -K or x = K, and add x to A[i] (only once).
  After this process, we have some array B.
  Return the smallest possible difference between the maximum value of B and the minimum value of B.

  Example 1:
  Input: A = [1], K = 0
  Output: 0
  Explanation: B = [1]

  Example 2:
  Input: A = [0,10], K = 2
  Output: 6
  Explanation: B = [2,8]

  Example 3:
  Input: A = [1,3,6], K = 3
  Output: 3
  Explanation: B = [4,6,3]

  Note:

  1 <= A.length <= 10000
  0 <= A[i] <= 10000
  0 <= K <= 10000
  -/

vc-preamble: |-
  def maximum (xs: List Int) : Int := match xs with
    | [] => 0
    | h::t => t.foldl max h

  def minimum (xs: List Int) : Int := match xs with
    | [] => 0
    | h::t => t.foldl min h

vc-helpers: |

vc-definitions: |-
  def smallestRangeII (nums: List Int) (k: Int) : Int := sorry

  theorem result_nonnegative (nums: List Int) (k: Int) (h: k ≥ 0) :
    smallestRangeII nums k ≥ 0 := sorry

vc-theorems: |-
  theorem single_element_gives_zero (x: Int) (k: Int) :
    smallestRangeII [x] k = 0 := sorry

  theorem empty_list_gives_zero (k: Int) :
    smallestRangeII [] k = 0 := sorry

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: guarded_and_plausible

  /-
  info: 0
  -/
  #guard_msgs in
  #eval smallestRangeII [1] 0

  /-
  info: 6
  -/
  #guard_msgs in
  #eval smallestRangeII [0, 10] 2

  /-
  info: 3
  -/
  #guard_msgs in
  #eval smallestRangeII [1, 3, 6] 3

