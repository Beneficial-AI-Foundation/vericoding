vc-description: |-
  /-
  # Task
  Two arrays are called similar if one can be obtained from another by swapping at most one pair of elements.

  Given two arrays, check whether they are similar.

  # Example

  For `A = [1, 2, 3]` and `B = [1, 2, 3]`, the output should be `true;`

  For `A = [1, 2, 3]` and `B = [2, 1, 3]`, the output should be `true;`

  For `A = [1, 2, 2]` and `B = [2, 1, 1]`, the output should be `false.`

  # Input/Output

  - `[input]` integer array `A`

  Array of integers.

  Constraints: `3 ≤ A.length ≤ 10000, 1 ≤ A[i] ≤ 1000.`

  - `[input]` integer array `B`

  Array of integers of the same length as `A`.

  Constraints: `B.length = A.length, 1 ≤ B[i] ≤ 1000.`

  - `[output]` a boolean value

  `true` if `A` and `B` are similar, `false` otherwise.
  -/

vc-preamble: |-
  def are_similar (xs ys : List Int) : Bool := sorry

  theorem identical_lists_are_similar {xs : List Int} (h : xs ≠ []) : 
    are_similar xs xs := sorry

vc-helpers: |

vc-definitions: |-
  def insertSort (xs : List Int) : List Int := sorry 

  theorem different_contents_not_similar {xs ys : List Int} :
    insertSort xs ≠ insertSort ys →
    ¬(are_similar xs ys) := sorry

vc-theorems: |-
  theorem single_swap_makes_similar {xs : List Int} (h : xs.length ≥ 2) :
    let ys := xs.set 0 (xs.get! 1) |>.set 1 (xs.get! 0)
    are_similar xs ys := sorry

  theorem multiple_swaps_not_similar {xs : List Int} (h : xs.length ≥ 3) :
    let ys := xs.set 0 (xs.get! 1)
              |>.set 1 (xs.get! 2)
              |>.set 2 (xs.get! 0)
    (List.length (List.filter (fun p => p.1 ≠ p.2) (List.zip xs ys))) > 2 →
    ¬(are_similar xs ys) := sorry

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

  /-
  info: True
  -/
  #guard_msgs in
  #eval are_similar [1, 2, 3] [1, 2, 3]

  /-
  info: True
  -/
  #guard_msgs in
  #eval are_similar [1, 2, 3] [2, 1, 3]

  /-
  info: False
  -/
  #guard_msgs in
  #eval are_similar [1, 2, 2] [2, 1, 1]

