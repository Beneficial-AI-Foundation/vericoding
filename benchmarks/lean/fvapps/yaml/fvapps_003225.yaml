vc-description: |-
  /-
  Divisors of 42 are : 1, 2, 3, 6, 7, 14, 21, 42.
  These divisors squared are: 1, 4, 9, 36, 49, 196, 441, 1764.
  The sum of the squared divisors is 2500 which is 50 * 50, a square!

  Given two integers m, n (1 <= m <= n) we want to find all integers 
  between m and n whose sum of squared divisors is itself a square.
  42 is such a number.

  The result will be an array of arrays or of tuples (in C an array of Pair) or a string, each subarray having two elements,
  first the number whose squared divisors is a square and then the sum
  of the squared divisors.

  #Examples:
  ```
  list_squared(1, 250) --> [[1, 1], [42, 2500], [246, 84100]]
  list_squared(42, 250) --> [[42, 2500], [246, 84100]]
  ```

  The form of the examples may change according to the language, see `Example Tests:` for more details.

  **Note**

  In Fortran - as in any other language - the returned string is not permitted to contain any redundant trailing whitespace: you can use dynamically allocated character strings.
  -/

vc-preamble: |-
  def list_squared (m n : Nat) : List (Nat × Nat) := sorry

  theorem list_squared_result_valid (m n : Nat) (h : 0 < m) (h2 : 0 < n) :
    let result := list_squared m n
    ∀ pair ∈ result,
      ∃ (a b : Nat), pair = (a, b) ∧ 
      m ≤ a ∧ a ≤ n := sorry

  def sumOfSquaredDivisors (n : Nat) : Nat := sorry

  theorem list_squared_divisors_sum (m n : Nat) (h : 0 < m) (h2 : 0 < n) :
    let result := list_squared m n
    ∀ pair ∈ result, pair.2 = sumOfSquaredDivisors pair.1 := sorry

vc-helpers: |

vc-definitions: |-
  def isPerfectSquare (n : Nat) : Prop := 
    ∃ k : Nat, k * k = n

vc-theorems: |-
  theorem list_squared_is_sorted (m n : Nat) (h : 0 < m) (h2 : 0 < n) :
    let result := list_squared m n
    ∀ i, i + 1 < result.length → 
      (result[i]'sorry).1 < (result[i+1]'sorry).1 := sorry

  theorem list_squared_perfect_squares (m n : Nat) (h : 0 < m) (h2 : 0 < n) :
    let result := list_squared m n
    ∀ pair ∈ result, isPerfectSquare pair.2 := sorry

  theorem list_squared_single_point (n : Nat) (h : 0 < n) :
    let result := list_squared n n
    result = [] ∨ result = [(n, sumOfSquaredDivisors n)] := sorry

  theorem list_squared_empty (m n : Nat) :
    m > n → list_squared m n = [] := sorry

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: guarded

  /-
  info: [[1, 1], [42, 2500], [246, 84100]]
  -/
  #guard_msgs in
  #eval list_squared 1 250

  /-
  info: [[42, 2500], [246, 84100]]
  -/
  #guard_msgs in
  #eval list_squared 42 250

  /-
  info: [[287, 84100]]
  -/
  #guard_msgs in
  #eval list_squared 250 500

