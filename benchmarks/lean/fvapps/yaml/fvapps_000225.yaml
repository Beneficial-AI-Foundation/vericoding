vc-description: |-
  /-
  Given an array of integers A with even length, return true if and only if it is possible to reorder it such that A[2 * i + 1] = 2 * A[2 * i] for every 0 <= i < len(A) / 2.
  
  Example 1:
  Input: A = [3,1,3,6]
  Output: false
  
  Example 2:
  Input: A = [2,1,2,6]
  Output: false
  
  Example 3:
  Input: A = [4,-2,2,-4]
  Output: true
  Explanation: We can take two groups, [-2,-4] and [2,4] to form [-2,-4,2,4] or [2,4,-2,-4].
  
  Example 4:
  Input: A = [1,2,4,16,8,4]
  Output: false
  
  Constraints:
  
  0 <= A.length <= 3 * 104
  A.length is even.
  -105 <= A[i] <= 105
  -/

vc-preamble: |-

vc-helpers: |-

vc-definitions: |-
  def can_reorder_doubled (lst : List Int) : Bool := sorry
  
  def count_occurrences (n : Int) (lst : List Int) : Nat :=
    lst.foldl (fun acc x => if x = n then acc + 1 else acc) 0

vc-theorems: |-
  theorem reorder_doubled_count_property (lst : List Int) :
    can_reorder_doubled lst = true → lst ≠ [] →
      ∀ n ∈ lst, n ≠ 0 →
        (2 * n) ∈ lst ∧ count_occurrences (2 * n) lst ≥ count_occurrences n lst := sorry
  
  theorem single_numbers_not_doubled {numbers : List Int} (h : ∀ n ∈ numbers, n ≠ 0) :
    can_reorder_doubled (numbers ++ [0]) = false := sorry
  
  theorem empty_list_property :
    can_reorder_doubled [] = true := sorry
  
  theorem all_zeros_property (n : Nat) :
    can_reorder_doubled (List.replicate n 0) = true := sorry
  
  /-
  info: False
  -/
  -- #guard_msgs in
  -- #eval can_reorder_doubled [3, 1, 3, 6]
  
  /-
  info: True
  -/
  -- #guard_msgs in
  -- #eval can_reorder_doubled [4, -2, 2, -4]
  
  /-
  info: False
  -/
  -- #guard_msgs in
  -- #eval can_reorder_doubled [1, 2, 4, 16, 8, 4]

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded

