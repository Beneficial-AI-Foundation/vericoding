vc-description: |-
  /-
  Your task is to write a function that does just what the title suggests (so, fair warning, be aware that you are not getting out of it just throwing a lame bas sorting method there) with an array/list/vector of integers and the expected number `n` of smallest elements to return.

  Also:

  * the number of elements to be returned cannot be higher than the array/list/vector length;
  * elements can be duplicated;
  * in case of duplicates, just return them according to the original order (see third example for more clarity).

  Same examples and more in the test cases:

  ```python
  first_n_smallest([1,2,3,4,5],3) == [1,2,3]
  first_n_smallest([5,4,3,2,1],3) == [3,2,1]
  first_n_smallest([1,2,3,4,1],3) == [1,2,1]
  first_n_smallest([1,2,3,-4,0],3) == [1,-4,0]
  first_n_smallest([1,2,3,4,5],0) == []
  ```

  [Performance version by FArekkusu](https://www.codewars.com/kata/5aeed69804a92621a7000077) also available.
  -/

vc-preamble: |

vc-helpers: |

vc-definitions: |-
  def first_n_smallest (arr : List Int) (n : Nat) : List Int := sorry

  theorem first_n_smallest_length {arr : List Int} {n : Nat} (h : 0 < arr.length)
    (hn : n ≤ arr.length) :
    (first_n_smallest arr n).length = n := sorry

vc-theorems: |-
  theorem first_n_smallest_contains_input {arr : List Int} {n : Nat} (h : 0 < arr.length)
    (hn : n ≤ arr.length) :
    ∀ x ∈ first_n_smallest arr n, x ∈ arr := sorry

  theorem first_n_smallest_full_length {arr : List Int} (h : 0 < arr.length) :
    first_n_smallest arr arr.length = arr := sorry

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: guarded_and_plausible

  /--
  info: [1, 2, 3]
  -/
  #guard_msgs in
  #eval first_n_smallest [1, 2, 3, 4, 5] 3

  /--
  info: [3, 2, 1]
  -/
  #guard_msgs in
  #eval first_n_smallest [5, 4, 3, 2, 1] 3

  /--
  info: [1, 2, 1]
  -/
  #guard_msgs in
  #eval first_n_smallest [1, 2, 3, 4, 1] 3

