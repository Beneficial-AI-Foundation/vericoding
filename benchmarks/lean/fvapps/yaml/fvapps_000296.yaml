vc-description: |-
  /-
  Given an integer array arr, you should partition the array into (contiguous) subarrays of length at most k. After partitioning, each subarray has their values changed to become the maximum value of that subarray.
  Return the largest sum of the given array after partitioning.

  Example 1:
  Input: arr = [1,15,7,9,2,5,10], k = 3
  Output: 84
  Explanation: arr becomes [15,15,15,9,10,10,10]

  Example 2:
  Input: arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4
  Output: 83

  Example 3:
  Input: arr = [1], k = 1
  Output: 1

  Constraints:

  1 <= arr.length <= 500
  0 <= arr[i] <= 109
  1 <= k <= arr.length
  -/

vc-preamble: |-
  def max_sum_after_partitioning (arr : List Int) (k : Nat) : Int :=
  sorry

  def sum (l : List Int) : Int :=
  sorry

  def max (l : List Int) : Int :=
  sorry

vc-helpers: |

vc-definitions: |-
  def len (l : List Int) : Nat :=
  sorry

vc-theorems: |-
  theorem result_bounds {arr : List Int} {k : Nat}
    (h1 : arr.length > 0)
    (h2 : ∀ x ∈ arr, x > 0)
    (h3 : k > 0)
    (h4 : k ≤ 100) :
    sum arr ≤ max_sum_after_partitioning arr k ∧ 
    max_sum_after_partitioning arr k ≤ len arr * max arr :=
  sorry

  theorem k_equals_one {arr : List Int}
    (h1 : arr.length > 0)
    (h2 : ∀ x ∈ arr, x > 0) :
    max_sum_after_partitioning arr 1 = sum arr :=
  sorry

  theorem k_equals_length {arr : List Int}
    (h1 : arr.length > 0)
    (h2 : ∀ x ∈ arr, x > 0) :
    max_sum_after_partitioning arr arr.length = len arr * max arr :=
  sorry

  theorem single_element {arr : List Int} {k : Nat}
    (h1 : arr.length = 1)
    (h2 : k > 0) :
    max_sum_after_partitioning arr k = arr[0] :=
  sorry

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded

  /-
  info: 84
  -/
  #guard_msgs in
  #eval max_sum_after_partitioning [1, 15, 7, 9, 2, 5, 10] 3

  /-
  info: 83
  -/
  #guard_msgs in
  #eval max_sum_after_partitioning [1, 4, 1, 5, 7, 3, 6, 1, 9, 9, 3] 4

  /-
  info: 1
  -/
  #guard_msgs in
  #eval max_sum_after_partitioning [1] 1

