vc-description: |-
  /-
  The chef is trying to decode some pattern problems, Chef wants your help to code it. Chef has one number K to form a new pattern. Help the chef to code this pattern problem.

  -----Input:-----
  - First-line will contain $T$, the number of test cases. Then the test cases follow. 
  - Each test case contains a single line of input, one integer $K$. 

  -----Output:-----
  For each test case, output as the pattern.

  -----Constraints-----
  - $1 \leq T \leq 100$
  - $1 \leq K \leq 100$

  -----Sample Input:-----
  4
  1
  2
  3
  4

  -----Sample Output:-----
  1
  10
  10
  101
  101
  101
  1010
  1010
  1010
  1010

  -----EXPLANATION:-----
  No need, else pattern can be decode easily.
  -/

vc-preamble: |

vc-helpers: |

vc-definitions: |-
  def generate_pattern (k : Nat) : List String := sorry

  theorem pattern_length (k : Nat) (h: k > 0) :
    (generate_pattern k).length = k := sorry

vc-theorems: |-
  theorem pattern_identical_rows (k : Nat) (h: k > 0) :
    ∀ i j, i < (generate_pattern k).length → j < (generate_pattern k).length →
    ((generate_pattern k).get ⟨i, by sorry⟩) = ((generate_pattern k).get ⟨j, by sorry⟩) := sorry

  theorem row_length (k : Nat) (h: k > 0) :
    ∀ row ∈ generate_pattern k, row.length = k := sorry

  theorem alternating_digits (k : Nat) (h: k > 0) :
    ∀ i, i + 1 < k → 
    let pattern := (generate_pattern k).head!
    (pattern.data.get ⟨i, by sorry⟩) ≠ (pattern.data.get ⟨i + 1, by sorry⟩) := sorry

  theorem first_digit_one (k : Nat) (h: k > 0) :
    let pattern := (generate_pattern k).head!
    (pattern.data.get ⟨0, by sorry⟩) = '1' := sorry

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded

  /-
  info: ['1']
  -/
  #guard_msgs in
  #eval generate_pattern 1

  /-
  info: ['10', '10']
  -/
  #guard_msgs in
  #eval generate_pattern 2

  /-
  info: ['101', '101', '101']
  -/
  #guard_msgs in
  #eval generate_pattern 3

