vc-description: |-
  /-
  Given a string s of zeros and ones, return the maximum score after splitting the string into two non-empty substrings (i.e. left substring and right substring).
  The score after splitting a string is the number of zeros in the left substring plus the number of ones in the right substring.

  Example 1:
  Input: s = "011101"
  Output: 5 
  Explanation: 
  All possible ways of splitting s into two non-empty substrings are:
  left = "0" and right = "11101", score = 1 + 4 = 5 
  left = "01" and right = "1101", score = 1 + 3 = 4 
  left = "011" and right = "101", score = 1 + 2 = 3 
  left = "0111" and right = "01", score = 1 + 1 = 2 
  left = "01110" and right = "1", score = 2 + 1 = 3

  Example 2:
  Input: s = "00111"
  Output: 5
  Explanation: When left = "00" and right = "111", we get the maximum score = 2 + 3 = 5

  Example 3:
  Input: s = "1111"
  Output: 3

  Constraints:

  2 <= s.length <= 500
  The string s consists of characters '0' and '1' only.
  -/

vc-preamble: |

vc-helpers: |

vc-definitions: |-
  def maxScore (s: String) : Nat := sorry

  theorem maxScore_non_negative (s: String) (h: s.length >= 2) : 
    maxScore s >= 0 := sorry

vc-theorems: |-
  theorem maxScore_upper_bound (s: String) (h: s.length >= 2) : 
    maxScore s ≤ s.length := sorry

  theorem maxScore_bounded_by_chars (s: String) (h: s.length >= 2) :
    maxScore s ≤ (s.replace "1" "").length + (s.replace "0" "").length := sorry

  theorem maxScore_all_ones (s: String) (h₁: s.length >= 2) 
    (h₂: ∀ c ∈ s.data, c = '1') :
    maxScore s = s.length - 1 := sorry

  theorem maxScore_all_zeros (s: String) (h₁: s.length >= 2)
    (h₂: ∀ c ∈ s.data, c = '0') :
    maxScore s = s.length - 1 := sorry

  theorem maxScore_first_char_lower_bound (s: String) (h: s.length >= 2) :
    let zeroes := if s.data[0]! = '0' then 1 else 0
    let ones := (s.data.drop 1).filter (· = '1') |>.length
    maxScore s ≥ zeroes + ones := sorry

  theorem maxScore_alternating_pattern (n: Nat) (h: n ≥ 1) :
    let s := String.join (List.replicate n "01")
    maxScore s ≥ n := sorry

  theorem maxScore_min_length_strings (s: String) (h₁: s.length = 2)
    (h₂: ∀ c ∈ s.data, c = '0' ∨ c = '1') :
    0 ≤ maxScore s ∧ maxScore s ≤ 2 := sorry

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: guarded

  /--
  info: 5
  -/
  #guard_msgs in
  #eval max_score "011101"

  /--
  info: 5
  -/
  #guard_msgs in
  #eval max_score "00111"

  /--
  info: 3
  -/
  #guard_msgs in
  #eval max_score "1111"

