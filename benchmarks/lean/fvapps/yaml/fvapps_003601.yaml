vc-description: |-
  /-
  Given a list of integers, return the nth smallest integer in the list. **Only distinct elements should be considered** when calculating the answer. `n` will always be positive (`n > 0`)

  If the nth small integer doesn't exist, return `-1` (C++) / `None` (Python) / `nil` (Ruby) / `null` (JavaScript).

  Notes:
  * "indexing" starts from 1
  * huge lists (of 1 million elements) will be tested

  ## Examples

  ```python
  nth_smallest([1, 3, 4, 5], 7)        ==> None  # n is more than the size of the list
  nth_smallest([4, 3, 4, 5], 4)        ==> None  # 4th smallest integer doesn't exist
  nth_smallest([45, -10, 4, 5, 4], 4)  ==> 45    # 4th smallest integer is 45
  ```

  If you get a timeout, just try to resubmit your solution. However, if you ***always*** get a timeout, review your code.
  -/

vc-preamble: |-
  def nth_smallest (arr : List Int) (n : Nat) : Option Int := sorry

  def contains (xs : List Int) (x : Int) : Bool := 
    xs.foldl (fun acc y => acc || y == x) false

  def countLessThan (xs : List Int) (x : Int) : Nat :=
    xs.foldl (fun acc y => if y < x then acc + 1 else acc) 0

  def uniqueList (xs : List Int) : List Int :=
    xs.foldl (fun acc x => if contains acc x then acc else x::acc) []

  def minimum (xs : List Int) : Option Int :=
    xs.foldl (fun acc x => match acc with
      | none => some x
      | some m => some (min x m)) none

vc-helpers: |

vc-definitions: |-
  def maximum (xs : List Int) : Option Int :=
    xs.foldl (fun acc x => match acc with
      | none => some x
      | some m => some (max x m)) none

vc-theorems: |-
  theorem nth_smallest_properties {arr : List Int} {n : Nat} (h : n ≥ 1) :
    match nth_smallest arr n with
    | none => n > (uniqueList arr).length
    | some result =>
      (n ≤ (uniqueList arr).length) ∧ 
      contains arr result ∧ 
      countLessThan (uniqueList arr) result = n-1
    := sorry

  theorem nth_smallest_first {arr : List Int} (h : arr ≠ []) :
    nth_smallest arr 1 = minimum (uniqueList arr) := sorry

  theorem nth_smallest_last_valid {arr : List Int} (h : arr ≠ []) : 
    nth_smallest arr (uniqueList arr).length = maximum (uniqueList arr) := sorry

  theorem nth_smallest_empty :
    nth_smallest [] 1 = none := sorry

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

  /-
  info: 34
  -/
  #guard_msgs in
  #eval nth_smallest [14, 12, 46, 34, 334] 3

  /-
  info: 4000
  -/
  #guard_msgs in
  #eval nth_smallest [4000] 1

  /-
  info: 0
  -/
  #guard_msgs in
  #eval nth_smallest [14, 12, 46, 0, 334] 1

