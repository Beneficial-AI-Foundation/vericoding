vc-description: |-
  /-
  Consider an array containing cats and dogs. Each dog can catch only one cat, but cannot catch a cat that is more than `n` elements away. Your task will be to return the maximum number of cats that can be caught.

  For example:
  ```Haskell
  solve(['D','C','C','D','C'], 2) = 2, because the dog at index 0 (D0) catches C1 and D3 catches C4. 
  solve(['C','C','D','D','C','D'], 2) = 3, because D2 catches C0, D3 catches C1 and D5 catches C4.
  solve(['C','C','D','D','C','D'], 1) = 2, because D2 catches C1, D3 catches C4. C0 cannot be caught because n == 1.
  solve(['D','C','D','D','C'], 1) = 2, too many dogs, so all cats get caught!
  ```

  Do not modify the input array. 

  More examples in the test cases. Good luck!
  -/

vc-preamble: |-
  def solve (arr : List Char) (reach : Nat) : Nat :=
    sorry

vc-helpers: |

vc-definitions: |-
  def numChar (c : Char) (arr : List Char) : Nat :=
    sorry

vc-theorems: |-
  theorem solve_empty {reach : Nat} :
    solve [] reach = 0 :=
    sorry

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: guarded_and_plausible

  /-
  info: 2
  -/
  #guard_msgs in
  #eval solve ["D", "C", "C", "D", "C"] 1

  /-
  info: 3
  -/
  #guard_msgs in
  #eval solve ["C", "C", "D", "D", "C", "D"] 2

  /-
  info: 2
  -/
  #guard_msgs in
  #eval solve ["C", "C", "D", "D", "C", "D"] 1

