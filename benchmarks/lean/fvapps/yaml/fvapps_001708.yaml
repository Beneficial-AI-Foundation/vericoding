vc-description: |-
  /-
  [The Vigenère cipher](https://en.wikipedia.org/wiki/Vigen%C3%A8re_cipher) is a classic cipher that was thought to be "unbreakable" for three centuries. We now know that this is not so and it can actually be broken pretty easily.

  **How the Vigenère cipher works**:

  The basic concept is that you have a `message` and a `key`, and each character in the `message` is encrypted using a character in the `key`, by applying a Caesar shift. The key is recycled as many times as needed.

  You might want to try [this kata](https://www.codewars.com/kata/vigenere-cipher-helper) first, which focuses on the encryption and decryption processes.

  ## Well how do we break it?

  The first thing we have to do is determine the **length of the key** that was used to encrypt the message.

  Write a function that takes some cipher text and a maximum possible key length and returns the length of the key that was used in the encryption process.

  **Note:** We don't care about what characters are in the key -- only how many of them there are.

  ---

  Any feedback (and suggestions) would be much appreciated

  *This kata is based on one of the programming assignments in [Prof. Jonathan Katz's course on cryptography](https://www.coursera.org/course/cryptography) given on Coursera*
  -/

vc-preamble: |

vc-helpers: |

vc-definitions: |-
  def get_key_length (text : String) (max_length : Int) : Nat :=
    sorry

vc-theorems: |-
  theorem single_char_key_min_one {text : String} (h : text.length ≥ 1) :
    get_key_length (text ++ text ++ text) 5 ≥ 1 :=
  sorry

  theorem repeating_pattern_bounds {text : String} {n max_len : Nat} 
    (h1 : text.length ≥ 2) (h2 : n ≥ 1) (h3 : n ≤ 20)
    (h4 : max_len = text.length + 5) :
    let result := get_key_length (String.join (List.replicate n text)) max_len
    1 ≤ result ∧ result ≤ text.length :=
  sorry 

  theorem periodic_sequence {n : Nat} (h : n ≥ 1) (h2 : n ≤ 100) :
    let text := String.join (List.replicate n "AB")
    let result := get_key_length text n
    result = 1 ∨ result = 2 :=
  sorry

  theorem key_length_bounds {text : String} {key_length : Nat}
    (h1 : text.length ≥ 1) (h2 : key_length ≥ 1) (h3 : key_length ≤ 10) :
    let result := get_key_length text key_length
    1 ≤ result ∧ result ≤ min key_length text.length :=
  sorry

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: guarded_and_plausible

  /--
  info: 3
  -/
  #guard_msgs in
  #eval get_key_length "ABCABCABCABC" 5

  /--
  info: 1
  -/
  #guard_msgs in
  #eval get_key_length "AAAAA" 3

  /--
  info: 2
  -/
  #guard_msgs in
  #eval get_key_length "XYXYXYXY" 4

