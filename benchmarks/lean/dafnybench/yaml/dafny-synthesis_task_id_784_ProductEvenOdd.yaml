vc-description: |-
  /- 
  {
  "name": "dafny-synthesis_task_id_784_ProductEvenOdd",
  "category": "Dafny Translation",
  "description": "Automatically translated from Dafny specification: dafny-synthesis_task_id_784_ProductEvenOdd",
  "source": "Dafny",
  "translation_date": "2024",
  "functions": ,
  "methods":
  }
  -/
  
  /-  Predicate indicating if a number is even -/
  
  /-  Predicate indicating if a number is odd -/
  
  /-  Predicate indicating if evenIndex is the first even number in the list -/
  
  /-  Predicate indicating if oddIndex is the first odd number in the list -/
  
  /-  Returns indices of first even and odd numbers in list -/
  
  /-  Specification for FirstEvenOddIndices -/
  
  /-  Returns product of first even and odd numbers in list -/
  
  /-  Specification for ProductEvenOdd -/

vc-preamble: |-
  def IsEven (n : Int) : Bool :=
  n % 2 = 0
  
  def IsOdd (n : Int) : Bool :=
  n % 2 ≠ 0
  
  def IsFirstEven (evenIndex : Nat) (lst : Array Int) : Prop :=
  0 ≤ evenIndex ∧ evenIndex < lst.size ∧
  IsEven (lst[evenIndex]!) ∧
  (∀ i, 0 ≤ i ∧ i < evenIndex → IsOdd (lst[i]!))
  
  def IsFirstOdd (oddIndex : Nat) (lst : Array Int) : Prop :=
  0 ≤ oddIndex ∧ oddIndex < lst.size ∧
  IsOdd (lst[oddIndex]!) ∧
  (∀ i, 0 ≤ i ∧ i < oddIndex → IsEven (lst[i]!))

vc-helpers: |-

vc-definitions: |-
  def FirstEvenOddIndices (lst : Array Int) : (Nat × Nat) :=
  sorry
  
  def ProductEvenOdd (lst : Array Int) : Int :=
  sorry

vc-theorems: |-
  theorem FirstEvenOddIndices_spec (lst : Array Int) :
  lst.size ≥ 2 →
  (∃ i, 0 ≤ i ∧ i < lst.size ∧ IsEven (lst[i]!)) →
  (∃ i, 0 ≤ i ∧ i < lst.size ∧ IsOdd (lst[i]!)) →
  let (evenIndex, oddIndex) := FirstEvenOddIndices lst
  0 ≤ evenIndex ∧ evenIndex < lst.size ∧
  0 ≤ oddIndex ∧ oddIndex < lst.size ∧
  IsEven (lst[evenIndex]!) ∧ IsFirstEven evenIndex lst ∧
  IsOdd (lst[oddIndex]!) ∧ IsFirstOdd oddIndex lst :=
  sorry
  
  theorem ProductEvenOdd_spec (lst : Array Int) :
  lst.size ≥ 2 →
  (∃ i, 0 ≤ i ∧ i < lst.size ∧ IsEven (lst[i]!)) →
  (∃ i, 0 ≤ i ∧ i < lst.size ∧ IsOdd (lst[i]!)) →
  ∃ i j, 0 ≤ i ∧ i < lst.size ∧ IsEven (lst[i]!) ∧ IsFirstEven i lst ∧
  0 ≤ j ∧ j < lst.size ∧ IsOdd (lst[j]!) ∧ IsFirstOdd j lst ∧
  ProductEvenOdd lst = (lst[i]!) * (lst[j]!) :=
  sorry

vc-postamble: |-

