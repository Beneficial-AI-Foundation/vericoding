{"id": "630-dafny_tmp_tmpz2kokaiq_Solution_BinarySearch", "vc-description": "/- \n{\n\"name\": \"630-dafny_tmp_tmpz2kokaiq_Solution_BinarySearch\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: 630-dafny_tmp_tmpz2kokaiq_Solution_BinarySearch\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nChecks if an arr ay is sorted in ascending order.\nTranslated from Dafny's sorted function.\n-/\n\n/- \nBinary search implementation specification.\nTranslated from Dafny's BinarySearch method.\n\n@param a The sorted array to search in\n@param x The value to search for\n@return index The index where x was found, or -1 if not found\n-/", "vc-preamble": "def sorted (a : Array Int) : Prop :=\n∀ i j , 0 ≤ i ∧ i < j ∧ j < a.size → a[i]! ≤ a[j]!", "vc-helpers": "", "vc-definitions": "def BinarySearch (a : Array Int) (x : Int) : Int :=\nsorry", "vc-theorems": "theorem BinarySearch_spec (a : Array Int) (x : Int) :\nsorted a →\nlet index := BinarySearch a x\n(0 ≤ index ∧ index < a.size → a[index.toNat]! = x) ∧\n(index = -1 → ∀ i , 0 ≤ i ∧ i < a.size → a[i]! ≠ x) :=\nsorry", "vc-postamble": ""}
{"id": "AssertivePrograming_tmp_tmpwf43uz0e_DivMode_Unary_IterativeDivMod", "vc-description": "/- \n{\n\"name\": \"AssertivePrograming_tmp_tmpwf43uz0e_DivMode_Unary_IterativeDivMod\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: AssertivePrograming_tmp_tmpwf43uz0e_DivMode_Unary_IterativeDivMod\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Unary natural numbers represented as Zero or Successor -/\n\n/-  Convert Unary to natural number -/\n\n/-  Convert natural number to Unary -/\n\n/-  Less than relation on Unary numbers -/\n\n/-  Alternative less than relation on Unary numbers -/\n\n/-  Addition of Unary numbers -/\n\n/-  Subtraction of Unary numbers -/\n\n/-  Multiplication of Unary numbers -/\n\n/-  Iterative division and modulus operation on Unary numbers -/", "vc-preamble": "inductive Unary where\n| Zero : Unary\n| Suc : Unary → Unary\nderiving Repr\ndef UnaryToNat : Unary → Nat\n| Unary.Zero => 0\n| Unary.Suc n => 1 + UnaryToNat n\ndef NatToUnary : Nat → Unary\n| 0 => Unary.Zero\n| n + 1 => Unary.Suc (NatToUnary n)\ndef Less : Unary → Unary → Prop\n| _, Unary.Zero => False\n| Unary.Zero, Unary.Suc _ => True\n| Unary.Suc x, Unary.Suc y => Less x y\ndef LessAlt : Unary → Unary → Prop\n| _, Unary.Zero => False\n| Unary.Zero, Unary.Suc _ => True\n| Unary.Suc x, Unary.Suc y => Less x y\ndef Add_ : Unary → Unary → Unary\n| x, Unary.Zero => x\n| x, Unary.Suc y => Unary.Suc (Add_ x y)\ndef Sub_ : Unary → Unary → Unary\n| x, Unary.Zero => x\n| Unary.Suc x, Unary.Suc y => Sub_ x y\n| Unary.Zero, Unary.Suc _ => Unary.Zero /- This case shouldn't happen given precondition -/\ndef Mul_ : Unary → Unary → Unary\n| Unary.Zero, _ => Unary.Zero\n| Unary.Suc x, y => Add_ (Mul_ x y) y", "vc-helpers": "", "vc-definitions": "def IterativeDivMod (x y : Unary) : Unary × Unary :=\nsorry", "vc-theorems": "theorem IterativeDivMod_spec (x y : Unary) :\ny ≠ Unary.Zero →\nlet (d, m) := IterativeDivMod x y\nAdd_ (Mul_ d y) m = x ∧ Less m y :=\nsorry", "vc-postamble": ""}
{"id": "AssertivePrograming_tmp_tmpwf43uz0e_Find_Substring_FindFirstOccurrence", "vc-description": "/- \n{\n\"name\": \"AssertivePrograming_tmp_tmpwf43uz0e_Find_Substring_FindFirstOccurrence\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: AssertivePrograming_tmp_tmpwf43uz0e_Find_Substring_FindFirstOccurrence\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate indicating if str2 exists as a substring in str1 -/\n\n/-  Post condition for FindFirstOccurrence -/\n\n/-  Outer invariant for correctness -/\n\n/-  Inner invariant for correctness -/\n\n/-  Inner invariant for termination -/\n\n/-  Main method specification -/", "vc-preamble": "def ExistsSubstring (str1 str2 : String) : Prop :=\n∃ offset : Nat, offset ≤ str1.length ∧\n(∃ sub : String, sub = str1.extract ⟨offset⟩ ⟨str1.length⟩ ∧ str2.isPrefixOf sub)\ndef Post (str1 str2 : String) (found : Bool) (i : Nat) : Prop :=\n(found ↔ ExistsSubstring str1 str2) ∧\n(found → i + str2.length ≤ str1.length ∧\n(∃ sub : String, sub = str1.extract ⟨i⟩ ⟨str1.length⟩ ∧ str2.isPrefixOf sub))\ndef Outter_Inv_correctness (str1 str2 : String) (found : Bool) (i : Nat) : Prop :=\n(found → (i + str2.length ≤ str1.length ∧\n(∃ sub : String, sub = str1.extract ⟨i⟩ ⟨str1.length⟩ ∧ str2.isPrefixOf sub))) ∧\n(¬found ∧ 0 < i ∧ i ≤ str1.length ∧ i ≠ str2.length - 1 →\n¬(ExistsSubstring (str1.extract 0 ⟨i⟩) str2)) ∧\n(¬found → i ≤ str1.length)\ndef Inner_Inv_correctness (str1 str2 : String) (i : Nat) (j : Int) (found : Bool) : Prop :=\n0 ≤ j ∧ j ≤ i ∧\nj < str2.length ∧\ni < str1.length ∧\n((str1.get ⟨i⟩ = str2.get ⟨j.toNat⟩) →\n(∃ sub : String, sub = str1.extract ⟨i⟩ ⟨str1.length⟩ ∧\n(∃ sub2 : String, sub2 = str2.extract ⟨j.toNat⟩ ⟨str2.length⟩ ∧ sub2.isPrefixOf sub))) ∧\n(found → j = 0 ∧ str1.get ⟨i⟩ = str2.get ⟨j.toNat⟩)\ndef Inner_Inv_Termination (str1 str2 : String) (i : Nat) (j : Int)\n(old_i old_j : Nat) : Prop :=\nold_j - j = old_i - i", "vc-helpers": "", "vc-definitions": "def FindFirstOccurrence (str1 str2 : String) : (Bool × Nat) :=\nsorry", "vc-theorems": "theorem FindFirstOccurrence_spec (str1 str2 : String) :\nlet (found, i) := FindFirstOccurrence str1 str2\nPost str1 str2 found i :=\nsorry", "vc-postamble": ""}
{"id": "AssertivePrograming_tmp_tmpwf43uz0e_MergeSort_Merge", "vc-description": "/- \n{\n\"name\": \"AssertivePrograming_tmp_tmpwf43uz0e_MergeSort_Merge\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: AssertivePrograming_tmp_tmpwf43uz0e_MergeSort_Merge\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate indicating if an array is sorted -/\n\n/-  Invariant for merge operation -/\n\n/-  Invariant for sorted property during merge -/\n\n/-  Invariant for subset property during merge -/\n\n/-  MergeLoop operation specification -/\n\n/-  Merge operation specification -/", "vc-preamble": "def Sorted (q : Array Int) : Prop :=\n∀ i j, 0 ≤ i → i ≤ j → j < q.size → q[i]! ≤ q[j]!\n\ndef Inv_ (a : Array Int) (a1 : Array Int) (a2 : Array Int) (i : Nat) (mid : Nat) : Prop :=\ni ≤ a1.size ∧ i ≤ a2.size ∧ i + mid ≤ a.size ∧\n(a1.extract 0 i = a.extract 0 i) ∧\n(a2.extract 0 i = a.extract mid (i + mid))\n\ndef InvSorted (b : Array Int) (c : Array Int) (d : Array Int) (i : Nat) (j : Nat) : Prop :=\ni ≤ c.size ∧ j ≤ d.size ∧ i + j ≤ b.size ∧\n((i + j > 0 ∧ i < c.size) →  (b[j + i - 1]! ≤ c[i]!)) ∧\n((i + j > 0 ∧ j < d.size) → (b[j + i - 1]! ≤ d[j]!)) ∧\nSorted (b.extract 0 (i + j))\n\ndef InvSubSet (b : Array Int) (c : Array Int) (d : Array Int) (i : Nat) (j : Nat) : Prop :=\ni ≤ c.size ∧ j ≤ d.size ∧ i + j ≤ b.size ∧\n(b.extract 0 (i + j)) =  (c.extract 0 i).append (d.extract 0 j)", "vc-helpers": "", "vc-definitions": "def MergeLoop (b c d : Array Int) (i0 j0 : Nat) : (Nat × Nat) :=\nsorry\n\ndef Merge (b c d : Array Int) : Unit :=\nsorry", "vc-theorems": "theorem MergeLoop_spec (b c d : Array Int) (i0 j0 : Nat) :\nb ≠ c → b ≠ d → b.size = c.size + d.size →\nSorted c → Sorted d →\ni0 ≤ c.size → j0 ≤ d.size → i0 + j0 ≤ b.size →\nInvSubSet b c d i0 j0 →\nInvSorted b c d i0 j0 →\ni0 + j0 < b.size →\nlet (i, j) := MergeLoop b c d i0 j0\ni ≤ c.size ∧ j ≤ d.size ∧ i + j ≤ b.size ∧\nInvSubSet b c d i j ∧\nInvSorted b c d i j ∧\n(0 ≤ c.size - i ∧ c.size - i < c.size - i0 ∨\n(c.size - i = c.size - i0 ∧ 0 ≤ d.size - j ∧ d.size - j < d.size - j0)) :=\nsorry\n\ntheorem Merge_spec (b c d : Array Int) :\nb ≠ c → b ≠ d → b.size = c.size + d.size →\nSorted c → Sorted d →\nSorted b ∧  (b.extract 0 (i + j)) =  (c.extract 0 i).append (d.extract 0 j) :=\nsorry", "vc-postamble": ""}
{"id": "AssertivePrograming_tmp_tmpwf43uz0e_MergeSort_MergeLoop", "vc-description": "/- \n{\n\"name\": \"AssertivePrograming_tmp_tmpwf43uz0e_MergeSort_MergeLoop\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: AssertivePrograming_tmp_tmpwf43uz0e_MergeSort_MergeLoop\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate indicating if a sequence is sorted -/\n\n/-  Invariant for merge sort algorithm -/\n\n/-  Invariant for sorted property during merge -/\n\n/-  Invariant for multiset equality during merge -/\n\n/-  MergeLoop specification -/\n\n/-  MergeLoop implementation -/", "vc-preamble": "def Sorted (q : Array Int) : Prop :=\n∀ i j, 0 ≤ i → i ≤ j → j < q.size → q[i]! ≤ q[j]!\n\ndef Inv_ (a a1 a2 : Array Int) (i mid : Nat) : Prop :=\ni ≤ a1.size ∧ i ≤ a2.size ∧ i + mid ≤ a.size ∧\n(a1.extract 0 i = a.extract 0 i) ∧\n(a2.extract 0 i = a.extract mid (i + mid))\n\ndef InvSorted (b c d : Array Int) (i j : Nat) : Prop :=\ni ≤ c.size ∧ j ≤ d.size ∧ i + j ≤ b.size ∧\n((i + j > 0 ∧ i < c.size) →  (b[j + i - 1]! ≤ c[i]!)) ∧\n((i + j > 0 ∧ j < d.size) → (b[j + i - 1]! ≤ d[j]!)) ∧\nSorted (b.extract 0 (i + j))\n\ndef InvSubSet (b c d : Array Int) (i j : Nat) : Prop :=\ni ≤ c.size ∧ j ≤ d.size ∧ i + j ≤ b.size ∧\n(b.extract 0 (i + j)) =  (c.extract 0 i).append (d.extract 0 j)", "vc-helpers": "", "vc-definitions": "def MergeLoop (b c d : Array Int) (i0 j0 : Nat) : (Nat × Nat) :=\nsorry", "vc-theorems": "theorem mergeLoop_spec\n(b c d : Array Int) (i0 j0 : Nat) (i j : Nat) :\nb ≠ c → b ≠ d → b.size = c.size + d.size →\nSorted c → Sorted d →\ni0 ≤ c.size → j0 ≤ d.size → i0 + j0 ≤ b.size →\nInvSubSet b c d i0 j0 →\nInvSorted b c d i0 j0 →\ni0 + j0 < b.size →\ni ≤ c.size ∧ j ≤ d.size ∧ i + j ≤ b.size ∧\nInvSubSet b c d i j ∧\nInvSorted b c d i j ∧\n(0 ≤ c.size - i ∧ c.size - i < c.size - i0 ∨\n(c.size - i = c.size - i0 ∧ 0 ≤ d.size - j ∧ d.size - j < d.size - j0)) :=\nsorry", "vc-postamble": ""}
{"id": "AssertivePrograming_tmp_tmpwf43uz0e_MergeSort_MergeSort", "vc-description": "/- \n{\n\"name\": \"AssertivePrograming_tmp_tmpwf43uz0e_MergeSort_MergeSort\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: AssertivePrograming_tmp_tmpwf43uz0e_MergeSort_MergeSort\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate indicating if an array is sorted -/\n\n/-  Invariant for merge sort algorithm -/\n\n/-  Invariant for sorted portion during merge -/\n\n/-  Invariant for multiset equality during merge -/\n\n/-  Merge two sorted arrays -/\n\n/-  MergeSort implementation -/", "vc-preamble": "def Sorted (q : Array Int) : Prop :=\n∀ i j, 0 ≤ i → i ≤ j → j < q.size → q[i]! ≤ q[j]!\n\ndef Inv_ (a a1 a2 : Array Int) (i mid : Nat) : Prop :=\ni ≤ a1.size ∧ i ≤ a2.size ∧ i + mid ≤ a.size ∧\n(a1.extract 0 i = a.extract 0 i) ∧\n(a2.extract 0 i = a.extract mid (i + mid))\n\ndef InvSorted (b c d : Array Int) (i j : Nat) : Prop :=\ni ≤ c.size ∧ j ≤ d.size ∧ i + j ≤ b.size ∧\n((i + j > 0 ∧ i < c.size) → b[j + i - 1]! ≤ c[i]!) ∧\n((i + j > 0 ∧ j < d.size) → b[j + i - 1]! ≤ d[j]!) ∧\nSorted (b.extract 0 (i + j))\n\ndef InvSubSet (b c d : Array Int) (i j : Nat) : Prop :=\ni ≤ c.size ∧ j ≤ d.size ∧ i + j ≤ b.size ∧\n(b.extract 0 (i + j)) =  (c.extract 0 i).append (d.extract 0 j)", "vc-helpers": "", "vc-definitions": "def Merge (b c d : Array Int) : Array Int :=\nsorry\n\ndef MergeSort (a : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem merge_spec (b c d : Array Int) :\nb ≠ c → b ≠ d → b.size = c.size + d.size →\nSorted c → Sorted d →\nSorted (Merge b c d) ∧\n(Merge b c d) = (c.extract 0 i).append (d.extract 0 j) :=\nsorry\n\ntheorem mergesort_spec (a : Array Int) :\nlet b := MergeSort a\nb.size = a.size ∧ Sorted b ∧ b = a :=\nsorry", "vc-postamble": ""}
{"id": "BPTree-verif_tmp_tmpq1z6xm1d_Utils_GetInsertIndex", "vc-description": "/- \n{\n\"name\": \"BPTree-verif_tmp_tmpq1z6xm1d_Utils_GetInsertIndex\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: BPTree-verif_tmp_tmpq1z6xm1d_Utils_GetInsertIndex\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Translates Dafny's SetLessThan function -/\n\n/-  Translates Dafny's seqSet function -/\n\n/-  Translates Dafny's SortedSeq predicate -/\n\n/-  Translates Dafny's sorted predicate -/\n\n/-  Translates Dafny's distinct predicate -/\n\n/-  Translates Dafny's sorted_eq predicate -/\n\n/-  Translates Dafny's GetInsertIndex method specification -/\n\n/-  Implementation of GetInsertIndex -/", "vc-preamble": "def SetLessThan (numbers : List Int) (threshold : Int) : List Int :=\nnumbers.filter (λ x => x < threshold)\n\ndef seqSet (nums : Array Int) (index : Nat) : List Int :=\n(List.range index).map (λ i => nums[i]!)\n\ndef SortedSeq (a : Array Int) : Prop :=\n∀ i j, 0 ≤ i → i < j → j < a.size → a[i]! < a[j]!\n\ndef sorted (a : Array Int) : Prop :=\n∀ i j, 0 ≤ i → i < j → j < a.size → a[i]! < a[j]!\n\ndef distinct (a : Array Int) : Prop :=\n∀ i j, 0 ≤ i → i < a.size → 0 ≤ j → j < a.size → i ≠ j → a[i]! ≠ a[j]!\n\ndef sorted_eq (a : Array Int) : Prop :=\n∀ i j, 0 ≤ i → i < j → j < a.size → a[i]! ≤ a[j]!", "vc-helpers": "", "vc-definitions": "def GetInsertIndex (a : Array Int) (limit : Int) (x : Int) : Int :=\nsorry", "vc-theorems": "theorem GetInsertIndex_spec (a : Array Int) (limit : Int) (x : Int) (idx : Int) :\n(∀ i, 0 ≤ i → i < a.size → a[i]! ≠ x) →\n0 ≤ limit → limit ≤ a.size →\nSortedSeq (a.extract 0 limit.toNat) →\n0 ≤ idx ∧ idx ≤ limit ∧\nSortedSeq (a.extract 0 limit.toNat) ∧\n(idx > 0 → a[(idx - 1).toNat]! < x) ∧\n(idx < limit → x < a[(idx).toNat]!) :=\nsorry", "vc-postamble": ""}
{"id": "BPTree-verif_tmp_tmpq1z6xm1d_Utils_InsertIntoSorted", "vc-description": "/- \n{\n\"name\": \"BPTree-verif_tmp_tmpq1z6xm1d_Utils_InsertIntoSorted\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: BPTree-verif_tmp_tmpq1z6xm1d_Utils_InsertIntoSorted\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Translates Dafny SetLessThan function -/\n\n/-  Translates Dafny seqSet function -/\n\n/-  Translates Dafny SortedSeq predicate -/\n\n/-  Translates Dafny sorted predicate -/\n\n/-  Translates Dafny distinct predicate -/\n\n/-  Translates Dafny sorted_eq predicate -/\n\n/-  Translates Dafny lessThan predicate -/\n\n/-  Translates Dafny greaterThan predicate -/\n\n/-  Translates Dafny greaterEqualThan predicate -/\n\n/-  Translates Dafny GetInsertIndex method -/\n\n/-  Specification for GetInsertIndex -/\n\n/-  Translates Dafny InsertIntoSorted method -/\n\n/-  Specification for InsertIntoSorted -/", "vc-preamble": "def SetLessThan (numbers : List Int) (threshold : Int) : List Int :=\nnumbers.filter (λ x => x < threshold)\n\ndef SortedSeq (a : Array Int) : Prop :=\n∀ i j, 0 ≤ i → i < j → j < a.size → a[i]! < a[j]!\n\ndef sorted (a : Array Int) : Prop :=\n∀ i j, 0 ≤ i → i < j → j < a.size → a[i]! < a[j]!\n\ndef distinct (a : Array Int) : Prop :=\n∀ i j, 0 ≤ i → i < a.size → 0 ≤ j → j < a.size → i ≠ j → a[i]! ≠ a[j]!\n\ndef sorted_eq (a : Array Int) : Prop :=\n∀ i j, 0 ≤ i → i < j → j < a.size → a[i]! ≤ a[j]!\n\ndef lessThan (a : Array Int) (key : Int) : Prop :=\n∀ i, 0 ≤ i → i < a.size → a[i]! < key\n\ndef greaterThan (a : Array Int) (key : Int) : Prop :=\n∀ i, 0 ≤ i → i < a.size → a[i]! > key\n\ndef greaterEqualThan (a : Array Int) (key : Int) : Prop :=\n∀ i, 0 ≤ i → i < a.size → a[i]! ≥ key", "vc-helpers": "", "vc-definitions": "def seqSet (nums : Array Int) (index : Nat) : List Int :=\nsorry\n\ndef GetInsertIndex (a : Array Int) (limit : Int) (x : Int) : Int :=\nsorry\n\ndef InsertIntoSorted (a : Array Int) (limit : Int) (key : Int) : Array Int :=\nsorry", "vc-theorems": "theorem GetInsertIndex_spec (a : Array Int) (limit : Int) (x : Int) :\n(∀ i, 0 ≤ i → i < a.size → a[i]! ≠ x) →\n0 ≤ limit → limit ≤ a.size →\nSortedSeq a →\nlet idx := GetInsertIndex a limit x\n0 ≤ idx ∧ idx ≤ limit ∧\nSortedSeq a ∧\n(idx > 0 → a[(idx - 1).toNat]! < x) ∧\n(idx < limit → x < a[(idx).toNat]!) :=\nsorry\n\ntheorem InsertIntoSorted_spec (a : Array Int) (limit : Int) (key : Int) :\nkey > 0 →\n(∀ i, 0 ≤ i → i < a.size → a[i]! ≠ key) →\n0 ≤ limit → limit < a.size →\n(∀ i, 0 ≤ i → i < limit → a[i.toNat]! > 0) →\n(∀ i, limit ≤ i → i < a.size → a[i.toNat]! = 0) →\nsorted a →\nlet b := InsertIntoSorted a limit key\nb.size = a.size ∧\nsorted b ∧\n(∀ i, limit + 1 ≤ i → i < b.size → b[i.toNat]! = 0) ∧\n(∀ i, 0 ≤ i → i < limit → ∃ j, 0 ≤ j → j < b.size → b[j]! = a[i.toNat]!) ∧\n(∀ i, 0 ≤ i → i < limit + 1 → b[i.toNat]! > 0) :=\nsorry", "vc-postamble": ""}
{"id": "BelowZero_BelowZero", "vc-description": "/- \n{\n\"name\": \"BelowZero_BelowZero\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: BelowZero_BelowZero\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nRecursively sums the first n elements of an array.\nTranslated from Dafny's sum function.\n-/\n\n/- \nSpecification for sum function requiring n ≤ array size\n-/\n\n/- \nBelowZero checks if at any point the running sum of operations falls below zero.\nTranslated from Dafny's BelowZero method.\n-/\n\n/- \nSpecification for BelowZero ensuring result is true iff there exists a point\nwhere running sum is negative\n-/", "vc-preamble": "def sum (s : Array Int) (n : Nat) : Int :=\nif s.size = 0 ∨ n = 0 then\n0\nelse\ns.get! 0 + sum (s.extract 1 s.size) (n-1)", "vc-helpers": "", "vc-definitions": "def BelowZero (ops : Array Int) : Bool :=\nsorry", "vc-theorems": "theorem sum_spec (s : Array Int) (n : Nat) :\nn ≤ s.size → sum s n = sum s n :=\nsorry\n\ntheorem BelowZero_spec (ops : Array Int) :\nBelowZero ops = true ↔ ∃ n : Nat, n ≤ ops.size ∧ sum ops n < 0 :=\nsorry", "vc-postamble": ""}
{"id": "BinaryAddition_ArrayToSequence", "vc-description": "/- \n{\n\"name\": \"BinaryAddition_ArrayToSequence\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: BinaryAddition_ArrayToSequence\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Represents a 10-bit bitvector -/\n\n/-  Converts boolean array to bitvector -/\n\n/-  Helper function for ArrayToBv10 -/\n\n/-  Checks if a bit is set at given index -/\n\n/-  Converts bitvector to boolean sequence -/\n\n/-  Converts boolean to integer -/\n\n/-  XOR operation on booleans -/\n\n/-  Performs traditional bit addition -/\n\n/-  Converts boolean array to boolean sequence -/", "vc-preamble": "def Bv10 := Nat\n\ndef BoolToInt (a : Bool) : Int :=\nif a then 1 else 0\n\ndef XOR (a b : Bool) : Bool :=\n(a ∨ b) ∧ !(a ∧ b)", "vc-helpers": "", "vc-definitions": "def ArrayToBv10 (arr : Array Bool) : Bv10 :=\nsorry\n\ndef ArrayToBv10Helper (arr : Array Bool) (index : Nat) : Bv10 :=\nsorry\n\ndef isBitSet (x : Bv10) (bitIndex : Nat) : Bool :=\nsorry\n\ndef Bv10ToSeq (x : Bv10) : Array Bool :=\nsorry\n\ndef BitAddition (s t : Array Bool) : Array Bool :=\nsorry\n\ndef ArrayToSequence (arr : Array Bool) : Array Bool :=\nsorry", "vc-theorems": "theorem isBitSet_spec (x : Bv10) (bitIndex : Nat) :\nbitIndex < 10 →\n∃ (valid : Bool), isBitSet x bitIndex = valid :=\nsorry\n\ntheorem Bv10ToSeq_spec (x : Bv10) :\n(Bv10ToSeq x).size = 10 ∧\n∀ i, 0 ≤ i ∧ i < 10 → (Bv10ToSeq x)[i]! = isBitSet x i :=\nsorry\n\ntheorem BitAddition_spec (s t : Array Bool) :\ns.size = 10 ∧ t.size = 10 →\n∃ result, BitAddition s t = result :=\nsorry\n\ntheorem ArrayToSequence_spec (arr : Array Bool) :\n∀ result, ArrayToSequence arr = result →\nresult.size = arr.size ∧\n∀ k, 0 ≤ k ∧ k < arr.size → result[k]! = arr[k]! :=\nsorry", "vc-postamble": ""}
{"id": "BinaryAddition_BinaryAddition", "vc-description": "/- \n{\n\"name\": \"BinaryAddition_BinaryAddition\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: BinaryAddition_BinaryAddition\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Type alias for bitvector of length 10 -/\n\n/-  Converts boolean array to bitvector -/\n\n/-  Helper function for ArrayToBv10 -/\n\n/-  Converts boolean array to sequence -/\n\n/-  Checks if bit is set at given index -/\n\n/-  Converts bitvector to boolean sequence -/\n\n/-  Converts boolean to integer -/\n\n/-  XOR operation on booleans -/\n\n/-  Performs traditional bit addition -/\n\n/-  Main binary addition function -/\n\n/-  Specification for BinaryAddition -/", "vc-preamble": "def Bv10 := Nat\n\ndef BoolToInt (a : Bool) : Int :=\nif a then 1 else 0\n\ndef XOR (a b : Bool) : Bool :=\n(a ∨ b) ∧ ¬(a ∧ b)", "vc-helpers": "", "vc-definitions": "def ArrayToBv10 (arr : Array Bool) : Bv10 :=\nsorry\n\ndef ArrayToBv10Helper (arr : Array Bool) (index : Nat) : Bv10 :=\nsorry\n\ndef ArrayToSequence (arr : Array Bool) : Array Bool :=\nsorry\n\ndef isBitSet (x : Bv10) (bitIndex : Nat) : Bool :=\nsorry\n\ndef Bv10ToSeq (x : Bv10) : Array Bool :=\nsorry\n\ndef BitAddition (s t : Array Bool) : Array Bool :=\nsorry\n\ndef BinaryAddition (s t : Array Bool) : Array Bool :=\nsorry", "vc-theorems": "theorem BinaryAddition_spec (s t : Array Bool) :\ns.size = 10 ∧ t.size = 10 →\nlet result := BinaryAddition s t\nresult.size = 10 ∧ result = BitAddition s t :=\nsorry", "vc-postamble": ""}
{"id": "BinarySearchTree_tmp_tmp_bn2twp5_bst4copy_insert", "vc-description": "/- \n{\n\"name\": \"BinarySearchTree_tmp_tmp_bn2twp5_bst4copy_insert\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: BinarySearchTree_tmp_tmp_bn2twp5_bst4copy_insert\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Binary search tree datatype -/\n\n/-  Predicate ensuring all values in tree are less than max -/\n\n/-  Predicate ensuring all values in tree are greater than min -/\n\n/-  Helper function to get value from a tree node -/\n\n/-  Predicate defining a valid binary search tree -/\n\n/-  Recursive insertion into binary search tree -/\n\n/-  Specification for recursive insertion -/\n\n/-  Insert value into binary search tree -/\n\n/-  Specification for insertion -/", "vc-preamble": "inductive Tree where\n| Empty : Tree\n| Node : Tree → Int → Tree → Tree\nderiving Repr\n\ndef maxValue : Tree → Int → Prop\n| Tree.Empty, _ => True\n| Tree.Node left v right, max =>\nmax > v ∧ maxValue left max ∧ maxValue right max\n\ndef minValue : Tree → Int → Prop\n| Tree.Empty, _ => True\n| Tree.Node left v right, min =>\nmin < v ∧ minValue left min ∧ minValue right min\n\ndef getValue : Tree → Int\n| Tree.Empty => 0\n| Tree.Node _ v _ => v\n\ndef BinarySearchTree : Tree → Prop\n| Tree.Empty => True\n| Tree.Node left value right =>\n(left = Tree.Empty ∨ value > getValue left) ∧\n(right = Tree.Empty ∨ value < getValue right) ∧\nBinarySearchTree left ∧ BinarySearchTree right ∧\nmaxValue left value ∧ minValue right value", "vc-helpers": "", "vc-definitions": "def insertRecursion (tree : Tree) (value : Int) : Tree :=\nsorry\n\ndef insert (tree : Tree) (value : Int) : Tree :=\nsorry", "vc-theorems": "theorem insertRecursion_spec (tree : Tree) (value : Int) :\nBinarySearchTree tree →\nlet res := insertRecursion tree value\nres ≠ Tree.Empty →\nBinarySearchTree res ∧\n(∀ x, minValue tree x ∧ x < value → minValue res x) ∧\n(∀ x, maxValue tree x ∧ x > value → maxValue res x) :=\nsorry\n\ntheorem insert_spec (tree : Tree) (value : Int) :\nBinarySearchTree tree →\nBinarySearchTree (insert tree value) :=\nsorry", "vc-postamble": ""}
{"id": "BinarySearchTree_tmp_tmp_bn2twp5_bst4copy_insertRecursion", "vc-description": "/- \n{\n\"name\": \"BinarySearchTree_tmp_tmp_bn2twp5_bst4copy_insertRecursion\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: BinarySearchTree_tmp_tmp_bn2twp5_bst4copy_insertRecursion\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Binary tree datatype -/\n\n/-  Predicate ensuring all values in tree are less than max -/\n\n/-  Predicate ensuring all values in tree are greater than min -/\n\n/-  Helper function to get value from a tree node -/\n\n/-  Predicate defining a valid binary search tree -/\n\n/-  Insert a value into a binary search tree -/", "vc-preamble": "inductive Tree where\n| Empty : Tree\n| Node : Tree → Int → Tree → Tree\nderiving Repr\ndef maxValue : Tree → Int → Prop\n| Tree.Empty, _ => True\n| Tree.Node left v right, max =>\nmax > v ∧ maxValue left max ∧ maxValue right max\ndef minValue : Tree → Int → Prop\n| Tree.Empty, _ => True\n| Tree.Node left v right, min =>\nmin < v ∧ minValue left min ∧ minValue right min\ndef getValue : Tree → Int\n| Tree.Empty => 0\n| Tree.Node _ v _ => v\ndef BinarySearchTree : Tree → Prop\n| Tree.Empty => True\n| Tree.Node left value right =>\n(left = Tree.Empty ∨ value > getValue left) ∧\n(right = Tree.Empty ∨ value < getValue right) ∧\nBinarySearchTree left ∧ BinarySearchTree right ∧\nmaxValue left value ∧ minValue right value", "vc-helpers": "", "vc-definitions": "def insertRecursion (tree : Tree) (value : Int) : Tree :=\nsorry", "vc-theorems": "theorem insertRecursion_spec (tree : Tree) (value : Int) :\nBinarySearchTree tree →\nlet res := insertRecursion tree value\nres ≠ Tree.Empty → BinarySearchTree res ∧\n(∀ x, minValue tree x ∧ x < value → minValue res x) ∧\n(∀ x, maxValue tree x ∧ x > value → maxValue res x) :=\nsorry", "vc-postamble": ""}
{"id": "CS494-final-project_tmp_tmp7nof55uq_bubblesort_BubbleSort", "vc-description": "/- \n{\n\"name\": \"CS494-final-project_tmp_tmp7nof55uq_bubblesort_BubbleSort\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: CS494-final-project_tmp_tmp7nof55uq_bubblesort_BubbleSort\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nPredicate that checks if elements of array are in ascending order within given range.\nTranslated from Dafny's sorted predicate.\n-/\n\n/- \nHelper predicate to ensure valid swapping in bubble sort.\nTranslated from Dafny's pivot predicate.\n-/\n\n/- \nBubbleSort implementation translated from Dafny.\n-/", "vc-preamble": "def sorted (a : Array Int) (_from : Int) (to : Int) : Prop :=\na.size > 0 ∧\n0 ≤ _from ∧ _from ≤ to ∧ to ≤ a.size ∧\n∀ x y, _from ≤ x ∧ x < y ∧ y < to → a[x.toNat]! ≤ a[y.toNat]!\ndef pivot (a : Array Int) (to : Int) (pvt : Int) : Prop :=\na.size > 0 ∧\n0 ≤ pvt ∧ pvt < to ∧ to ≤ a.size ∧\n∀ x y, 0 ≤ x ∧ x < pvt ∧ pvt < y ∧ y < to → a[x.toNat]! ≤ a[y.toNat]!", "vc-helpers": "", "vc-definitions": "def BubbleSort (a : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem BubbleSort_spec (a : Array Int) :\na.size > 0 →\nlet result := BubbleSort a\nsorted result 0 result.size ∧\nresult.size = a.size :=\nsorry", "vc-postamble": ""}
{"id": "CVS-Projto1_tmp_tmpb1o0bu8z_proj1_proj1_query", "vc-description": "/- \n{\n\"name\": \"CVS-Projto1_tmp_tmpb1o0bu8z_proj1_proj1_query\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: CVS-Projto1_tmp_tmpb1o0bu8z_proj1_proj1_query\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Recursive sum function over array slice -/\n\n/-  Predicate checking if array c is prefix sum of array a -/\n\n/-  List_ datatype definition -/\n\n/-  Check if element exists in List_ -/\n\n/-  Convert array to List_ -/\n\n/-  Query sum over array slice -/\n\n/-  Specification for query method -/\n\n/-  Specification for from_array method -/", "vc-preamble": "partial def sum (a : Array Int) (i j : Int) : Int :=\nif i == j then\n0\nelse\na[(j-1).toNat]! + sum a i (j-1)\n\ndef is_prefix_sum_for (a c : Array Int) : Prop :=\na.size + 1 == c.size ∧\nc[0]! == 0 ∧\n∀ j, 1 ≤ j ∧ j ≤ a.size → c[j]! == sum a 0 j\n\ninductive List_ (T : Type) where\n| Nil : List_ T\n| Cons : T → List_ T → List_ T\n\ndef mem {T : Type} [BEq T] (x : T) (l : List_ T) : Bool :=\nmatch l with\n| List_.Nil => false\n| List_.Cons y r => if x == y then true else mem x r", "vc-helpers": "", "vc-definitions": "def from_array {T : Type} (a : Array T) : List_ T :=\nsorry\n\ndef query (a : Array Int) (i j : Int) : Int :=\nsorry", "vc-theorems": "theorem query_spec (a : Array Int) (i j : Int) :\n0 ≤ i ∧ i ≤ j ∧ j ≤ a.size →\nquery a i j = sum a i j :=\nsorry\n\ntheorem from_array_spec {T : Type} [BEq T] [Inhabited T] (a : Array T) :\na.size > 0 →\n∀ j, 0 ≤ j ∧ j < a.size →\nmem (a[j]!) (from_array a) :=\nsorry", "vc-postamble": ""}
{"id": "CVS-Projto1_tmp_tmpb1o0bu8z_proj1_proj1_queryFast", "vc-description": "/- \n{\n\"name\": \"CVS-Projto1_tmp_tmpb1o0bu8z_proj1_proj1_queryFast\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: CVS-Projto1_tmp_tmpb1o0bu8z_proj1_proj1_queryFast\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Recursive sum function over array slice -/\n\n/-  Predicate checking if array c is prefix sum of array a -/\n\n/-  List_ datatype definition -/\n\n/-  Check if element exists in List_ -/\n\n/-  Convert array to List_ -/\n\n/-  Fast query implementation -/\n\n/-  Fast query method specification -/", "vc-preamble": "partial def sum (a : Array Int) (i j : Int) : Int :=\nif i = j then\n0\nelse\na[(j-1).toNat]! + sum a i (j-1)\n\ndef is_prefix_sum_for (a c : Array Int) : Prop :=\na.size + 1 = c.size ∧\nc[0]! = 0 ∧\n∀ j, 1 ≤ j ∧ j ≤ a.size → c[j]! = sum a 0 j\n\ninductive List_ (T : Type)\n| Nil : List_ T\n| Cons : T → List_ T → List_ T\n\ndef mem {T : Type} [BEq T] (x : T) (l : List_ T) : Bool :=\nmatch l with\n| List_.Nil => false\n| List_.Cons y r => if x == y then true else mem x r", "vc-helpers": "", "vc-definitions": "def from_array {T : Type} (a : Array T) : List_ T :=\nsorry\n\ndef queryFast (a c : Array Int) (i j : Int) : Int :=\nsorry", "vc-theorems": "theorem queryFast_spec (a c : Array Int) (i j : Int) :\nis_prefix_sum_for a c ∧\n0 ≤ i ∧ i ≤ j ∧ j ≤ a.size ∧ a.size < c.size →\nqueryFast a c i j = sum a i j :=\nsorry", "vc-postamble": ""}
{"id": "CVS-handout1_tmp_tmptm52no3k_1_query", "vc-description": "/- \n{\n\"name\": \"CVS-handout1_tmp_tmptm52no3k_1_query\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: CVS-handout1_tmp_tmptm52no3k_1_query\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Recursive sum function over array slice from index i to j -/\n\n/-  Predicate checking if array c is a prefix sum of array a -/\n\n/-  Query method specification -/\n\n/-  Query method implementation -/", "vc-preamble": "partial def sum (a : Array Int) (i j : Int) : Int :=\nif i = j then 0\nelse a[i.toNat]! + sum a (i+1) j\n\ndef is_prefix_sum_for (a c : Array Int) : Prop :=\na.size + 1 = c.size ∧\nc[0]! = 0 ∧\n∀ i, 0 ≤ i ∧ i < a.size → c[(i+1)]! = c[i]! + a[i]!", "vc-helpers": "", "vc-definitions": "def query (a : Array Int) (i j : Int) : Int :=\nsorry", "vc-theorems": "theorem query_spec (a : Array Int) (i j : Int) :\n0 ≤ i ∧ i ≤ j ∧ j ≤ a.size →\n∃ res, res = sum a i j :=\nsorry", "vc-postamble": ""}
{"id": "CVS-handout1_tmp_tmptm52no3k_1_queryFast", "vc-description": "/- \n{\n\"name\": \"CVS-handout1_tmp_tmptm52no3k_1_queryFast\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: CVS-handout1_tmp_tmptm52no3k_1_queryFast\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Recursive sum function over array slice from index i to j -/\n\n/-  Predicate specifying that array c is a prefix sum array for array a -/\n\n/-  Main query function specification -/\n\n/-  Implementation of queryFast (left unimplemented) -/", "vc-preamble": "partial def sum (a : Array Int) (i j : Int) : Int :=\nif i = j then 0\nelse a[i.toNat]! + sum a (i+1) j\n\ndef is_prefix_sum_for (a c : Array Int) : Prop :=\nc.size = a.size + 1 ∧\nc[0]! = 0 ∧\n∀ i, 0 ≤ i ∧ i < a.size → c[(i+1)]! = c[i]! + a[i]!", "vc-helpers": "", "vc-definitions": "def queryFast (a c : Array Int) (i j : Int) : Int :=\nsorry", "vc-theorems": "theorem queryFast_spec (a c : Array Int) (i j : Int) :\nc.size = a.size + 1 →\nc[0]! = 0 →\n0 ≤ i →\ni ≤ j →\nj ≤ a.size →\nis_prefix_sum_for a c →\n∃ r, r = sum a i j :=\nsorry", "vc-postamble": ""}
{"id": "Clover_abs_Abs", "vc-description": "/- \n{\n\"name\": \"Clover_abs_Abs\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_abs_Abs\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nAbs function that returns absolute value\nTranslated from Dafny method Abs(x: int) returns (y: int)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Abs (x : Int) : Int :=\nsorry", "vc-theorems": "theorem Abs_spec (x : Int) :\n(x ≥ 0 → Abs x = x) ∧\n(x < 0 → x + Abs x = 0) :=\nsorry", "vc-postamble": ""}
{"id": "Clover_all_digits_allDigits", "vc-description": "/- \n{\n\"name\": \"Clover_all_digits_allDigits\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_all_digits_allDigits\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nChecks if all characters in a string are digits.\nTranslated from Dafny method allDigits.\n\n@param s The input string to check\n@return True if all characters are digits, false otherwise\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def allDigits (s : String) : Bool :=\nsorry", "vc-theorems": "theorem allDigits_spec (s : String) :\nallDigits s = true ↔ (∀ i, 0 ≤ i ∧ i < s.length → (s.get ⟨i⟩).isDigit) :=\nsorry", "vc-postamble": ""}
{"id": "Clover_array_append_append", "vc-description": "/- \n{\n\"name\": \"Clover_array_append_append\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_array_append_append\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nAppends an integer to an array.\n\n@param a The input array\n@param b The integer to append\n@return The resulting array with b appended\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def append (a : Array Int) (b : Int) : Array Int :=\nsorry", "vc-theorems": "theorem append_spec (a : Array Int) (b : Int) :\nappend a b = a.push b :=\nsorry", "vc-postamble": ""}
{"id": "Clover_array_concat_concat", "vc-description": "/- \n{\n\"name\": \"Clover_array_concat_concat\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_array_concat_concat\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nConcatenates two arrays of integers.\nEnsures:\n- The resulting array has length equal to sum of input array lengths\n- First part contains elements from first array\n- Second part contains elements from second array\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def concat (a : Array Int) (b : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem concat_spec (a b : Array Int) :\nlet c := concat a b\nc.size = b.size + a.size ∧\n(∀ k, 0 ≤ k ∧ k < a.size → c[k]! = a[k]!) ∧\n(∀ k, 0 ≤ k ∧ k < b.size → c[k + a.size]! = b[k]!) :=\nsorry", "vc-postamble": ""}
{"id": "Clover_array_product_arrayProduct", "vc-description": "/- \n{\n\"name\": \"Clover_array_product_arrayProduct\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_array_product_arrayProduct\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nComputes element-wise product of two arrays.\nTranslated from Dafny method arrayProduct.\n\n@param a First input array\n@param b Second input array\n@return c Result array containing element-wise products\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def arrayProduct (a : Array Int) (b : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem arrayProduct_spec (a b : Array Int) :\na.size = b.size →\nlet c := arrayProduct a b\nc.size = a.size ∧\n(∀ i, 0 ≤ i ∧ i < a.size → i < c.size → a[i]! * b[i]! = c[i]!) :=\nsorry", "vc-postamble": ""}
{"id": "Clover_array_sum_arraySum", "vc-description": "/- \n{\n\"name\": \"Clover_array_sum_arraySum\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_array_sum_arraySum\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nAdds corresponding elements of two arrays to produce a new array.\nRequires arrays to be of equal length.\nEnsures output array has same length and contains element-wise sums.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def arraySum (a : Array Int) (b : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem arraySum_spec (a b : Array Int) :\na.size = b.size →\nlet c := arraySum a b\nc.size = a.size ∧\n(∀ i, 0 ≤ i ∧ i < a.size → a[i]! + b[i]! = c[i]!) :=\nsorry", "vc-postamble": ""}
{"id": "Clover_avg_ComputeAvg", "vc-description": "/- \n{\n\"name\": \"Clover_avg_ComputeAvg\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_avg_ComputeAvg\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nComputeAvg computes the average of two integers.\n\n@param a First integer input\n@param b Second integer input\n@return The average of a and b, computed as (a+b)/2\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def ComputeAvg (a b : Int) : Int :=\nsorry", "vc-theorems": "theorem ComputeAvg_spec (a b : Int) :\nComputeAvg a b = (a + b) / 2 :=\nsorry", "vc-postamble": ""}
{"id": "Clover_below_zero_below_zero", "vc-description": "/- \n{\n\"name\": \"Clover_below_zero_below_zero\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_below_zero_below_zero\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nTranslates the Dafny below_zero method which checks if a sequence of operations\nresults in a negative value at any point.\n\n@param operations The input sequence of operations\n@return A tuple containing the resulting array and a boolean indicating if a negative value was found\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def below_zero (operations : Array Int) : Array Int × Bool :=\nsorry", "vc-theorems": "theorem below_zero_spec (operations : Array Int) :\nlet (s, result) := below_zero operations\ns.size = operations.size + 1 ∧\ns[0]! = 0 ∧\n(∀ i, 0 ≤ i ∧ i < s.size - 1 → s[i+1]! = s[i]! + operations[i]!) ∧\n(result = true → ∃ i, 1 ≤ i ∧ i ≤ operations.size ∧ s[i]! < 0) ∧\n(result = false → ∀ i, 0 ≤ i ∧ i < s.size → s[i]! ≥ 0) :=\nsorry", "vc-postamble": ""}
{"id": "Clover_binary_search_BinarySearch", "vc-description": "/- \n{\n\"name\": \"Clover_binary_search_BinarySearch\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_binary_search_BinarySearch\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nBinary search implementation translated from Dafny.\nTakes a sorted array and key, returns index where key should be inserted.\n\nOriginal Dafny requires/ensures:\n- Array must be sorted in ascending order\n- Return value n is between 0 and array length\n- All elements before n are less than key\n- If n equals array length, all elements are less than key\n- All elements from n onwards are greater than or equal to key\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def BinarySearch (a : Array Int) (key : Int) : Int :=\nsorry", "vc-theorems": "theorem BinarySearch_spec (a : Array Int) (key : Int) (n : Int) :\n(∀ i j, 0 ≤ i ∧ i < j ∧ j < a.size → a[i]! ≤ a[j]!) →\n(0 ≤ n ∧ n ≤ a.size) ∧\n(∀ i, 0 ≤ i ∧ i < n → a[i.toNat]! < key) ∧\n(n = a.size → ∀ i, 0 ≤ i ∧ i < a.size →  a[i]!  < key) ∧\n(∀ i, n ≤ i ∧ i < a.size → a[i.toNat]!  ≥ key) :=\nsorry", "vc-postamble": ""}
{"id": "Clover_bubble_sort_BubbleSort", "vc-description": "/- \n{\n\"name\": \"Clover_bubble_sort_BubbleSort\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_bubble_sort_BubbleSort\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nBubbleSort method translated from Dafny.\nTakes an array of integers and sorts it in ascending order.\n\nOriginal Dafny ensures clauses:\n- Elements are sorted in ascending order\n- Output array is a permutation of input array\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def BubbleSort (a : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem BubbleSort_spec (a : Array Int) :\nlet result := BubbleSort a\n\n-- Array is sorted in ascending order\n\n(∀ i j, 0 ≤ i → i < j → j < result.size → result[i]! ≤ result[j]!) ∧\n\n-- Output is a permutation of input (simplified)\n\nresult.size = a.size :=\nsorry", "vc-postamble": ""}
{"id": "Clover_cal_ans_CalDiv", "vc-description": "/- \n{\n\"name\": \"Clover_cal_ans_CalDiv\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_cal_ans_CalDiv\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nCalculates division and modulo of 191 by 7.\nTranslated from Dafny method CalDiv.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def CalDiv : Int × Int :=\nsorry", "vc-theorems": "theorem CalDiv_spec :\nlet (x, y) := CalDiv\nx = 191 / 7 ∧ y = 191 % 7 :=\nsorry", "vc-postamble": ""}
{"id": "Clover_cal_sum_Sum", "vc-description": "/- \n{\n\"name\": \"Clover_cal_sum_Sum\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_cal_sum_Sum\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nComputes the Sum_ of first N natural numbers.\nTranslated from Dafny method Sum_.\n\n@param N The upper bound for summation\n@return The Sum_ of numbers from 1 to N\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Sum_ (N : Int) : Int :=\nsorry", "vc-theorems": "theorem Sum_spec (N : Int) :\nN ≥ 0 → Sum_ N = N * (N + 1) / 2 :=\nsorry", "vc-postamble": ""}
{"id": "Clover_canyon_search_CanyonSearch", "vc-description": "/- \n{\n\"name\": \"Clover_canyon_search_CanyonSearch\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_canyon_search_CanyonSearch\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nCanyonSearch takes two sorted arrays and finds the minimum absolute difference between any pair of elements.\n\n@param a First sorted array of integers\n@param b Second sorted array of integers\n@return Minimum absolute difference between any pair of elements from the arrays\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def CanyonSearch (a b : Array Int) : Nat :=\nsorry", "vc-theorems": "theorem CanyonSearch_spec (a b : Array Int) :\na.size ≠ 0 ∧ b.size ≠ 0 ∧\n(∀ i j, 0 ≤ i → i < j → j < a.size → (a[i]!) ≤ (a[j]!)) ∧\n(∀ i j, 0 ≤ i → i < j → j < b.size → (b[i]!) ≤ (b[j]!)) →\n(∃ i j, 0 ≤ i ∧ i < a.size ∧ 0 ≤ j ∧ j < b.size ∧\nCanyonSearch a b = if (a[i]!) < (b[j]!) then ((b[j]!) - (a[i]!)) else ((a[i]!) - (b[j]!))) ∧\n(∀ i j, 0 ≤ i → i < a.size → 0 ≤ j → j < b.size →\nCanyonSearch a b ≤ if (a[i]!) < (b[j]!) then ((b[j]!) - (a[i]!)) else ((a[i]!) - (b[j]!))) :=\nsorry", "vc-postamble": ""}
{"id": "Clover_convert_map_key_convert_map_key", "vc-description": "/- \n{\n\"name\": \"Clover_convert_map_key_convert_map_key\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_convert_map_key_convert_map_key\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nConverts a map by applying a function to its keys while preserving values.\nThe function must be injective (one-to-one) on the domain.\n\n@param inputs The input map from naturals to booleans\n@param f The function to apply to the keys\n@return A new map with transformed keys\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def convert_map_key (inputs : Nat → Option Bool) (f : Nat → Nat) : Nat → Option Bool :=\nsorry", "vc-theorems": "theorem convert_map_key_spec\n(inputs : Nat → Option Bool)\n(f : Nat → Nat) :\n(∀ n1 n2 : Nat, n1 ≠ n2 → f n1 ≠ f n2) →\n(∀ k : Nat, (inputs k).isSome ↔ (convert_map_key inputs f (f k)).isSome) ∧\n(∀ k : Nat, (inputs k).isSome → convert_map_key inputs f (f k) = inputs k) :=\nsorry", "vc-postamble": ""}
{"id": "Clover_copy_part_copy", "vc-description": "/- \n{\n\"name\": \"Clover_copy_part_copy\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_copy_part_copy\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nCopies a portion of one array to another array.\n\n@param src The source array to copy from\n@param sStart The starting index in the source array\n@param dest The destination array to copy to\n@param dStart The starting index in the destination array\n@param len The number of elements to copy\n@return The modified destination array\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def copy (src : Array Int) (sStart : Nat) (dest : Array Int) (dStart : Nat) (len : Nat) : Array Int :=\nsorry", "vc-theorems": "theorem copy_spec\n(src : Array Int) (sStart : Nat) (dest : Array Int) (dStart : Nat) (len : Nat) :\nsrc.size ≥ sStart + len →\ndest.size ≥ dStart + len →\nlet r := copy src sStart dest dStart len\n(r.size = dest.size) ∧\n(∀ i, i < dStart → r[i]! = dest[i]!) ∧\n(∀ i, i ≥ dStart + len → r[i]!   = dest[i]!) ∧\n(∀ i, dStart ≤ i ∧ i < dStart + len →\nr[i]! = src[sStart + (i - dStart)]!) :=\nsorry", "vc-postamble": ""}
{"id": "Clover_count_lessthan_CountLessThan", "vc-description": "/- \n{\n\"name\": \"Clover_count_lessthan_CountLessThan\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_count_lessthan_CountLessThan\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nCounts elements in a list that are less than a threshold value.\nTranslated from Dafny method CountLessThan.\n\n@param numbers The input list of integers to check\n@param threshold The threshold value to compare against\n@return The count of elements less than threshold\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def CountLessThan (numbers : List Int) (threshold : Int) : Int :=\nsorry", "vc-theorems": "theorem CountLessThan_spec (numbers : List Int) (threshold : Int) :\nCountLessThan numbers threshold =\n(numbers.filter (fun i => i < threshold)).length :=\nsorry", "vc-postamble": ""}
{"id": "Clover_double_array_elements_double_array_elements", "vc-description": "/- \n{\n\"name\": \"Clover_double_array_elements_double_array_elements\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_double_array_elements_double_array_elements\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nDoubles each element in an array.\n\n@param s The input array to modify\n@ensures Each element is doubled compared to its original value\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def double_array_elements (s : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem double_array_elements_spec (s : Array Int) :\n∀ i, 0 ≤ i ∧ i < s.size →\n(double_array_elements s)[i]! = 2 * s[i]! :=\nsorry", "vc-postamble": ""}
{"id": "Clover_double_quadruple_DoubleQuadruple", "vc-description": "/- \n{\n\"name\": \"Clover_double_quadruple_DoubleQuadruple\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_double_quadruple_DoubleQuadruple\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nTranslates the Dafny method DoubleQuadruple which returns two values:\n- a: double of input x\n- b: quadruple of input x\n\nOriginal ensures clauses:\n- a == 2 * x\n- b == 4 * x\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def DoubleQuadruple (x : Int) : Int × Int :=\nsorry", "vc-theorems": "theorem DoubleQuadruple_spec (x : Int) :\nlet (a, b) := DoubleQuadruple x\na = 2 * x ∧ b = 4 * x :=\nsorry", "vc-postamble": ""}
{"id": "Clover_even_list_FindEvenNumbers", "vc-description": "/- \n{\n\"name\": \"Clover_even_list_FindEvenNumbers\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_even_list_FindEvenNumbers\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nFinds even numbers in an array and returns them in a new array.\nTranslated from Dafny specification.\n\nProperties:\n- All even numbers from input array are in output array\n- Output array only contains numbers from input array\n- All numbers in output array are even\n- Order of numbers in output preserves relative order from input\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def FindEvenNumbers (arr : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem FindEvenNumbers_spec (arr : Array Int) (evenNumbers : Array Int)\n(h : evenNumbers = FindEvenNumbers arr) :\n(∀ x, x ∈ arr.toList ∧ x % 2 = 0 → x ∈ evenNumbers.toList) ∧\n(∀ x, x ∉ arr.toList → x ∉ evenNumbers.toList) ∧\n(∀ k, 0 ≤ k ∧ k < evenNumbers.size → evenNumbers[k]! % 2 = 0) ∧\n(∀ k l, 0 ≤ k ∧ k < l ∧ l < evenNumbers.size →\n∃ n m, 0 ≤ n ∧ n < m ∧ m < arr.size ∧\nevenNumbers[k]! = arr[n]! ∧\nevenNumbers[l]! = arr[m]!) :=\nsorry", "vc-postamble": ""}
{"id": "Clover_find_Find", "vc-description": "/- \n{\n\"name\": \"Clover_find_Find\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_find_Find\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nFind method that searches for a key in an array and returns its index.\nTranslated from Dafny specification.\n\n@param a The array to search in\n@param key The value to search for\n@return The index of the first occurrence of key, or -1 if not found\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Find (a : Array Int) (key : Int) : Int :=\nsorry", "vc-theorems": "theorem Find_spec (a : Array Int) (key : Int) :\n-1 ≤ Find a key ∧ Find a key < a.size ∧\n(Find a key ≠ -1 → ∃ idx : Nat, idx < a.size ∧ a[idx]! = key ∧\n(∀ i, 0 ≤ i ∧ i < idx → a[i]! ≠ key)) ∧\n(Find a key = -1 → (∀ i, 0 ≤ i ∧ i < a.size → a[i]! ≠ key)) :=\nsorry", "vc-postamble": ""}
{"id": "Clover_has_close_elements_has_close_elements", "vc-description": "/- \n{\n\"name\": \"Clover_has_close_elements_has_close_elements\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_has_close_elements_has_close_elements\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nChecks if an array of real numbers has any pair of elements with difference less than threshold.\n\n@param numbers Array of real numbers to check\n@param threshold The threshold value for comparing differences\n@return True if close elements exist, false otherwise\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def has_close_elements (numbers : Array Float) (threshold : Float) : Bool :=\nsorry", "vc-theorems": "theorem has_close_elements_spec\n(numbers : Array Float) (threshold : Float) :\nthreshold ≥ 0 →\nlet res := has_close_elements numbers threshold\n(res → ∃ i j : Int,\n0 ≤ i ∧ i < numbers.size ∧\n0 ≤ j ∧ j < numbers.size ∧\ni ≠ j ∧\n(if numbers[i.toNat]! - numbers[j.toNat]! < 0\nthen numbers[j.toNat]! - numbers[i.toNat]!\nelse numbers[i.toNat]! - numbers[j.toNat]!) < threshold) ∧\n(!res → ∀ i j : Int,\n1 ≤ i ∧ i < numbers.size ∧\n0 ≤ j ∧ j < i →\n(if numbers[i.toNat]! - numbers[j.toNat]! < 0\nthen numbers[j.toNat]! - numbers[i.toNat]!\nelse numbers[i.toNat]! - numbers[j.toNat]!) ≥ threshold) :=\nsorry", "vc-postamble": ""}
{"id": "Clover_insert_insert", "vc-description": "/- \n{\n\"name\": \"Clover_insert_insert\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_insert_insert\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nInsert characters from one array into another at a specified position.\n\n@param line The destination array to insert into\n@param l Length of valid data in line array\n@param nl Source array to insert from\n@param p Number of characters to insert\n@param at Position to insert at\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def insert (line : Array Char) (l : Int) (nl : Array Char) (p : Int) (_ : Int) : Array Char :=\nsorry", "vc-theorems": "theorem insert_spec (line : Array Char) (l : Int) (nl : Array Char) (p : Int) (_at : Int) :\n0 ≤ l + p ∧ l + p ≤ line.size ∧\n0 ≤ p ∧ p ≤ nl.size ∧\n0 ≤ _at ∧ _at ≤ l →\nlet result := insert line l nl p _at\n\n-- Simplified postconditions focusing on basic properties\n\nresult.size = line.size ∧\n\n∀ i, 0 ≤ i ∧ i < _at → result[i.toNat]! = line[i.toNat]! ∧\n\n∀ i, 0 ≤ i ∧ i < p → result[(_at + i).toNat]! = nl[i.toNat]! :=\nsorry", "vc-postamble": ""}
{"id": "Clover_integer_square_root_SquareRoot", "vc-description": "/- \n{\n\"name\": \"Clover_integer_square_root_SquareRoot\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_integer_square_root_SquareRoot\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nComputes the integer square root of a natural number N.\nReturns r such that r*r ≤ N < (r+1)*(r+1)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def SquareRoot (N : Nat) : Nat :=\nsorry", "vc-theorems": "theorem SquareRoot_spec (N : Nat) :\nlet r := SquareRoot N\nr * r ≤ N ∧ N < (r + 1) * (r + 1) :=\nsorry", "vc-postamble": ""}
{"id": "Clover_is_even_ComputeIsEven", "vc-description": "/- \n{\n\"name\": \"Clover_is_even_ComputeIsEven\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_is_even_ComputeIsEven\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nComputes whether a number is even.\nTranslated from Dafny method ComputeIsEven.\n\n@param x The input integer\n@return A boolean indicating if x is even\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def ComputeIsEven (x : Int) : Bool :=\nsorry", "vc-theorems": "theorem ComputeIsEven_spec (x : Int) :\nComputeIsEven x = (x % 2 = 0) :=\nsorry", "vc-postamble": ""}
{"id": "Clover_is_palindrome_IsPalindrome", "vc-description": "/- \n{\n\"name\": \"Clover_is_palindrome_IsPalindrome\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_is_palindrome_IsPalindrome\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nChecks if a sequence of characters is a palindrome.\nTranslated from Dafny method IsPalindrome.\n\n@param x The input sequence of characters to check\n@return True if the sequence is a palindrome, false otherwise\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def IsPalindrome (x : Array Char) : Bool :=\nsorry", "vc-theorems": "theorem IsPalindrome_spec (x : Array Char) :\nIsPalindrome x = true ↔\n(∀ i, 0 ≤ i ∧ i < x.size → x[i]! = x[x.size - i - 1]!) :=\nsorry", "vc-postamble": ""}
{"id": "Clover_linear_search1_LinearSearch", "vc-description": "/- \n{\n\"name\": \"Clover_linear_search1_LinearSearch\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_linear_search1_LinearSearch\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nLinearSearch method that finds the first occurrence of element e in array a.\nReturns index n where element is found or array length if not found.\n\n@param a The input array to search\n@param e The element to search for\n@return n The index where element is found or array length if not found\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def LinearSearch (a : Array Int) (e : Int) : Int :=\nsorry", "vc-theorems": "theorem LinearSearch_spec (a : Array Int) (e : Int) :\nlet n := LinearSearch a e\n0 ≤ n ∧ n ≤ a.size ∧\n(n = a.size ∨ a[n.toNat]! = e) ∧\n(∀ i, 0 ≤ i ∧ i < n → e ≠ a[i.toNat]!) :=\nsorry", "vc-postamble": ""}
{"id": "Clover_linear_search2_LinearSearch", "vc-description": "/- \n{\n\"name\": \"Clover_linear_search2_LinearSearch\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_linear_search2_LinearSearch\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nLinearSearch finds the first occurrence of element e in array a.\nRequires that e exists somewhere in the array.\nEnsures the returned index contains e and all earlier elements are not e.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def LinearSearch (a : Array Int) (e : Int) : Int :=\nsorry", "vc-theorems": "theorem LinearSearch_spec (a : Array Int) (e : Int) :\n(∃ i, 0 ≤ i ∧ i < a.size ∧ a[i]! = e) →\nlet n := LinearSearch a e\n(0 ≤ n ∧ n < a.size ∧ a[n.toNat]! = e) ∧\n(∀ k, 0 ≤ k ∧ k < n → a[k.toNat]! ≠ e) :=\nsorry", "vc-postamble": ""}
{"id": "Clover_longest_prefix_LongestCommonPrefix", "vc-description": "/- \n{\n\"name\": \"Clover_longest_prefix_LongestCommonPrefix\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_longest_prefix_LongestCommonPrefix\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nFinds the longest common prefix of two character arrays.\nEnsures:\n- The prefix length is ≤ both input array lengths\n- The prefix matches the start of both arrays\n- The prefix ends at first mismatch or end of either array\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def LongestCommonPrefix (str1 : Array Char) (str2 : Array Char) : Array Char :=\nsorry", "vc-theorems": "theorem LongestCommonPrefix_spec (str1 : Array Char) (str2 : Array Char) (_prefix : Array Char) :\n_prefix.size ≤ str1.size ∧\n_prefix.size ≤ str2.size ∧\n(∀ i, i < _prefix.size → _prefix[i]! = str1[i]!) ∧\n(∀ i, i < _prefix.size → _prefix[i]! = str2[i]!) ∧\n(_prefix.size = str1.size ∨\n_prefix.size = str2.size ∨\nstr1[_prefix.size]! ≠ str2[_prefix.size]!) :=\nsorry", "vc-postamble": ""}
{"id": "Clover_match_Match", "vc-description": "/- \n{\n\"name\": \"Clover_match_Match\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_match_Match\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nTranslates the Dafny Match method which checks if a string matches a pattern.\nThe pattern can contain '?' characters which match any single character.\n\nParameters:\n- s: The input string to match\n- p: The pattern string to match against\n\nReturns:\n- A boolean indicating whether the string matches the pattern\n\nRequires:\n- The strings must be the same length\n\nEnsures:\n- The result is true iff for each position, either the characters match or\nthe pattern has a '?' character at that position\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Match (s p : String) : Bool :=\nsorry", "vc-theorems": "theorem Match_spec (s p : String) :\ns.length = p.length →\nMatch s p = (∀ n, 0 ≤ n ∧ n < s.length →\n(s.get ⟨n⟩ = p.get ⟨n⟩ ∨ p.get ⟨n⟩ = '?')) :=\nsorry", "vc-postamble": ""}
{"id": "Clover_max_array_maxArray", "vc-description": "/- \n{\n\"name\": \"Clover_max_array_maxArray\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_max_array_maxArray\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nTranslation of Dafny maxArray method.\nTakes an array of integers and returns the maximum value.\n\nPreconditions:\n- Array must have length >= 1\n\nPostconditions:\n- Result is greater than or equal to all array elements\n- Result equals some element in the array\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def maxArray (a : Array Int) : Int :=\nsorry", "vc-theorems": "theorem maxArray_spec (a : Array Int) :\na.size ≥ 1 →\nlet m := maxArray a\n(∀ k, 0 ≤ k ∧ k < a.size → m ≥ a[k]!) ∧\n(∃ k, 0 ≤ k ∧ k < a.size ∧ m = a[k]!) :=\nsorry", "vc-postamble": ""}
{"id": "Clover_min_array_minArray", "vc-description": "/- \n{\n\"name\": \"Clover_min_array_minArray\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_min_array_minArray\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nFinds the minimum element in an array of integers.\n\n@param a The input array of integers\n@return The minimum element in the array\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def minArray (a : Array Int) : Int :=\nsorry", "vc-theorems": "theorem minArray_spec (a : Array Int) :\na.size > 0 →\n(∀ i, 0 ≤ i ∧ i < a.size → minArray a ≤ a[i]!) ∧\n(∃ i, 0 ≤ i ∧ i < a.size ∧ minArray a = a[i]!) :=\nsorry", "vc-postamble": ""}
{"id": "Clover_min_of_two_Min", "vc-description": "/- \n{\n\"name\": \"Clover_min_of_two_Min\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_min_of_two_Min\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nTranslates the Dafny Min_ method which returns the minimum of two integers.\nThe specification ensures that:\n- If x ≤ y then z = x\n- If x > y then z = y\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Min_ (x y : Int) : Int :=\nsorry", "vc-theorems": "theorem Min_spec (x y z : Int) :\nz = Min_ x y →\n((x ≤ y → z = x) ∧\n(x > y → z = y)) :=\nsorry", "vc-postamble": ""}
{"id": "Clover_modify_2d_array_modify_array_element", "vc-description": "/- \n{\n\"name\": \"Clover_modify_2d_array_modify_array_element\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_modify_2d_array_modify_array_element\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nModifies an element in a 2D array of natural numbers.\n\n@param arr The 2D array to modify\n@param index1 First index into the array\n@param index2 Second index into the array\n@param val The new value to set\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def modify_array_element (arr : Array (Array Nat)) (index1 : Nat) (index2 : Nat) (val : Nat) : Array (Array Nat) :=\nsorry", "vc-theorems": "theorem modify_array_element_spec\n(arr : Array (Array Nat)) (index1 : Nat) (index2 : Nat) (val : Nat) :\nindex1 < arr.size →\nindex2 < (arr[index1]!).size →\n(∀ i j : Nat, i < arr.size ∧ j < arr.size ∧ i ≠ j → arr[i]! ≠ arr[j]!) →\nlet result := modify_array_element arr index1 index2 val\n(∀ i : Nat, i < arr.size → result[i]! = arr[i]!) ∧\n(∀ i j : Nat, i < arr.size ∧ j < (arr[i]!).size ∧ (i ≠ index1 ∨ j ≠ index2) →\n(result[i]!)[j]! = (arr[i]!)[j]!) ∧\n(result[index1]!)[index2]! = val :=\nsorry", "vc-postamble": ""}
{"id": "Clover_multi_return_MultipleReturns", "vc-description": "/- \n{\n\"name\": \"Clover_multi_return_MultipleReturns\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_multi_return_MultipleReturns\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nTranslates the Dafny method MultipleReturns which returns two values:\nmore = x + y and less = x - y\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def MultipleReturns (x y : Int) : Int × Int :=\nsorry", "vc-theorems": "theorem MultipleReturns_spec (x y : Int) :\nlet (more, less) := MultipleReturns x y\nmore = x + y ∧ less = x - y :=\nsorry", "vc-postamble": ""}
{"id": "Clover_online_max_onlineMax", "vc-description": "/- \n{\n\"name\": \"Clover_online_max_onlineMax\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_online_max_onlineMax\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nTranslates the Dafny onlineMax method which finds the maximum value in an array\nstarting from index x. Returns the maximum value m and position p.\n\n@param a The input array\n@param x The starting index\n@return (m, p) where m is the maximum value and p is its position\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def onlineMax (a : Array Int) (x : Int) : Int × Int :=\nsorry", "vc-theorems": "theorem onlineMax_spec (a : Array Int) (x : Int) (m p : Int) :\n(1 ≤ x ∧ x < a.size) →\n(a.size ≠ 0) →\nlet (m, p) := onlineMax a x;\n(x ≤ p ∧ p < a.size) ∧\n(∀ i, 0 ≤ i ∧ i < x → a[i.toNat]! ≤ m) ∧\n(∃ i, 0 ≤ i ∧ i < x ∧ a[i.toNat]! = m) ∧\n(x ≤ p ∧ p < a.size - 1 → (∀ i, 0 ≤ i ∧ i < p → a[i.toNat]! < a[p.toNat]!)) ∧\n((∀ i, x ≤ i ∧ i < a.size ∧ a[i.toNat]! ≤ m) → p = a.size - 1) :=\nsorry", "vc-postamble": ""}
{"id": "Clover_quotient_Quotient", "vc-description": "/- \n{\n\"name\": \"Clover_quotient_Quotient\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_quotient_Quotient\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nComputes quotient and remainder of natural number division.\nTranslated from Dafny method Quotient.\n\nParameters:\n- x: Dividend (natural number)\n- y: Divisor (natural number)\n\nReturns:\n- Tuple of (remainder, quotient)\n\nSpecification:\n- Requires y ≠ 0\n- Ensures q * y + r = x ∧ 0 ≤ r < y ∧ 0 ≤ q\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Quotient_ (x : Nat) (y : Nat) : Int × Int :=\nsorry", "vc-theorems": "theorem Quotient_spec (x : Nat) (y : Nat) :\ny ≠ 0 →\nlet (r, q) := Quotient_ x y\nq * y + r = x ∧ 0 ≤ r ∧ r < y ∧ 0 ≤ q :=\nsorry", "vc-postamble": ""}
{"id": "Clover_remove_front_remove_front", "vc-description": "/- \n{\n\"name\": \"Clover_remove_front_remove_front\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_remove_front_remove_front\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nTranslates the Dafny method remove_front which removes the first element of an array.\nThe original requires the array to be non-empty and ensures the result contains all elements except the first.\n\n@param a The input array\n@return The array with first element removed\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def remove_front (a : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem remove_front_spec (a : Array Int) :\na.size > 0 →\n∀ (c : Array Int), remove_front a = c →\nc.size = a.size - 1 :=\nsorry", "vc-postamble": ""}
{"id": "Clover_replace_replace", "vc-description": "/- \n{\n\"name\": \"Clover_replace_replace\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_replace_replace\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nTranslates the Dafny replace method which modifies an array by replacing elements greater than k with -1.\nThe specification ensures:\n1. All elements > k are replaced with -1\n2. All elements ≤ k remain unchanged\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def replace (arr : Array Int) (k : Int) : Array Int :=\nsorry", "vc-theorems": "theorem replace_spec (arr : Array Int) (k : Int) (i : Nat) :\ni < arr.size →\nlet result := replace arr k\n(arr[i]! > k → result[i]! = -1) ∧\n(arr[i]! ≤ k → result[i]! = arr[i]!) :=\nsorry", "vc-postamble": ""}
{"id": "Clover_return_seven_M", "vc-description": "/- \n{\n\"name\": \"Clover_return_seven_M\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_return_seven_M\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nMethod M that takes an integer x and returns seven.\nEnsures the return value is exactly 7.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def M (x : Int) : Int :=\nsorry", "vc-theorems": "theorem M_spec (x : Int) : M x = 7 :=\nsorry", "vc-postamble": ""}
{"id": "Clover_reverse_reverse", "vc-description": "/- \n{\n\"name\": \"Clover_reverse_reverse\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_reverse_reverse\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nReverses the elements of an array in place.\n\n@param a The array to reverse\n\nEnsures that each element at index i in the result is equal to\nthe original element at index (length-1-i)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def reverse (a : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem reverse_spec (a : Array Int) :\n∀ i, 0 ≤ i ∧ i < a.size →\n(reverse a)[i]! = a[a.size - 1 - i]! :=\nsorry", "vc-postamble": ""}
{"id": "Clover_rotate_rotate", "vc-description": "/- \n{\n\"name\": \"Clover_rotate_rotate\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_rotate_rotate\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nRotates an array by a given offset.\nTranslated from Dafny method rotate.\n\n@param a The input array to rotate\n@param offset The rotation offset (must be non-negative)\n@return The rotated array\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def rotate (a : Array Int) (offset : Int) : Array Int :=\nsorry", "vc-theorems": "theorem rotate_spec (a : Array Int) (offset : Int) :\noffset ≥ 0 →\nlet b := rotate a offset\n(b.size = a.size) ∧\n(∀ i, 0 ≤ i ∧ i < a.size → b[i]! = a[((i + offset) % a.size).toNat]!) :=\nsorry", "vc-postamble": ""}
{"id": "Clover_selectionsort_SelectionSort", "vc-description": "/- \n{\n\"name\": \"Clover_selectionsort_SelectionSort\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_selectionsort_SelectionSort\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nSelectionSort method translated from Dafny.\nTakes an array of integers and sorts it in ascending order.\n\nOriginal Dafny ensures clauses:\n- Elements are sorted in ascending order\n- Output array is a permutation of input array\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def SelectionSort (a : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem SelectionSort_spec (a : Array Int) :\nlet result := SelectionSort a\n\n-- Array is sorted in ascending order\n\n(∀ i j, 0 ≤ i → i < j → j < result.size → result[i]! ≤ result[j]!) ∧\n\n-- Output is a permutation of input\n\n(result.toList = a.toList) :=\nsorry", "vc-postamble": ""}
{"id": "Clover_slope_search_SlopeSearch", "vc-description": "/- \n{\n\"name\": \"Clover_slope_search_SlopeSearch\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_slope_search_SlopeSearch\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nSlopeSearch finds a key in a 2D array that is sorted both by rows and columns.\nTranslated from Dafny method SlopeSearch.\n\nParameters:\n- a: 2D array of integers\n- key: integer value to search for\n\nReturns:\n- (m,n): indices where key is found in array a\n\nRequirements:\n- Array is sorted in ascending order within each row\n- Array is sorted in ascending order within each column\n- Key exists somewhere in the array\n\nEnsures:\n- Returned indices are valid array bounds\n- Element at returned indices equals key\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def SlopeSearch (a : Array (Array Int)) (key : Int) : Int × Int :=\nsorry", "vc-theorems": "theorem SlopeSearch_spec (a : Array (Array Int)) (key : Int) :\n(∀ i j j', 0 ≤ i ∧ i < a.size ∧ 0 ≤ j ∧ j < j' ∧ j' < a[i]!.size →\na[i]![j]! ≤ a[i]![j']!) →\n(∀ i i' j, 0 ≤ i ∧ i < i' ∧ i' < a.size ∧ 0 ≤ j ∧ j < a[i]!.size →\na[i]![j]! ≤ a[i']![j]!) →\n(∃ i j, 0 ≤ i ∧ i < a.size ∧ 0 ≤ j ∧ j < a[i]!.size ∧ a[i]![j]! = key) →\nlet (m, n) := SlopeSearch a key\n0 ≤ m ∧ m < a.size ∧ 0 ≤ n ∧ n < a[m.natAbs]!.size ∧ a[m.natAbs]![n.natAbs]! = key :=\nsorry", "vc-postamble": ""}
{"id": "Clover_swap_Swap", "vc-description": "/- \n{\n\"name\": \"Clover_swap_Swap\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_swap_Swap\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nSwap method that swaps two integer values.\nTranslated from Dafny method Swap(X: int, Y: int) returns(x: int, y: int)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Swap (X Y : Int) : Int × Int :=\nsorry", "vc-theorems": "theorem Swap_spec (X Y : Int) :\nlet (x, y) := Swap X Y\nx = Y ∧ y = X :=\nsorry", "vc-postamble": ""}
{"id": "Clover_swap_arith_SwapArithmetic", "vc-description": "/- \n{\n\"name\": \"Clover_swap_arith_SwapArithmetic\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_swap_arith_SwapArithmetic\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nTranslates the Dafny SwapArithmetic method which swaps two integer values.\nThe method takes two integers X and Y and returns them in swapped order.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def SwapArithmetic (X Y : Int) : Int × Int :=\nsorry", "vc-theorems": "theorem SwapArithmetic_spec (X Y : Int) :\nlet (x, y) := SwapArithmetic X Y\nx = Y ∧ y = X :=\nsorry", "vc-postamble": ""}
{"id": "Clover_swap_bitvector_SwapBitvectors", "vc-description": "/- \n{\n\"name\": \"Clover_swap_bitvector_SwapBitvectors\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_swap_bitvector_SwapBitvectors\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nSwaps two 8-bit bitvectors.\n\n@param X First bitvector input\n@param Y Second bitvector input\n@return Tuple of swapped bitvectors (x,y)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def SwapBitvectors (X Y : UInt8) : UInt8 × UInt8 :=\nsorry", "vc-theorems": "theorem SwapBitvectors_spec (X Y : UInt8) :\nlet (x, y) := SwapBitvectors X Y\nx = Y ∧ y = X :=\nsorry", "vc-postamble": ""}
{"id": "Clover_swap_in_array_swap", "vc-description": "/- \n{\n\"name\": \"Clover_swap_in_array_swap\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_swap_in_array_swap\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nSwaps two elements in an array at indices i and j.\n\n@param arr The input array\n@param i First index\n@param j Second index\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def swap (arr : Array Int) (i j : Int) : Array Int :=\nsorry", "vc-theorems": "theorem swap_spec (arr : Array Int) (i j : Int) :\n0 ≤ i ∧ i < arr.size ∧ 0 ≤ j ∧ j < arr.size →\nlet arr' := swap arr i j\n(arr'[i.toNat]! = arr[j.toNat]! ∧\narr'[j.toNat]! = arr[i.toNat]! ∧\n∀ k, 0 ≤ k ∧ k < arr.size ∧ k ≠ i.toNat ∧ k ≠ j.toNat → arr'[k]! = arr[k]!) :=\nsorry", "vc-postamble": ""}
{"id": "Clover_swap_sim_SwapSimultaneous", "vc-description": "/- \n{\n\"name\": \"Clover_swap_sim_SwapSimultaneous\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_swap_sim_SwapSimultaneous\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nTranslates the Dafny SwapSimultaneous method which swaps two integer values.\nOriginal ensures clauses:\n- ensures x == Y\n- ensures y == X\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def SwapSimultaneous (X Y : Int) : Int × Int :=\nsorry", "vc-theorems": "theorem SwapSimultaneous_spec (X Y : Int) :\nlet (x, y) := SwapSimultaneous X Y\nx = Y ∧ y = X :=\nsorry", "vc-postamble": ""}
{"id": "Clover_test_array_TestArrayElements", "vc-description": "/- \n{\n\"name\": \"Clover_test_array_TestArrayElements\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_test_array_TestArrayElements\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nTestArrayElements method specification:\n- Takes an array of integers and a natural number j\n- Requires j to be a valid index in the array\n- Modifies array element at index j to be 60\n- Preserves all other array elements\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def TestArrayElements (a : Array Int) (j : Nat) : Array Int :=\nsorry", "vc-theorems": "theorem TestArrayElements_spec (a : Array Int) (j : Nat) :\n(j < a.size) →\nlet result := TestArrayElements a j\n(result[j]! = 60) ∧\n(∀ k, 0 ≤ k ∧ k < a.size ∧ k ≠ j → result[k]! = a[k]!) :=\nsorry", "vc-postamble": ""}
{"id": "Clover_triple_Triple", "vc-description": "/- \n{\n\"name\": \"Clover_triple_Triple\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_triple_Triple\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nTriple method that multiplies input by 3.\nTranslated from Dafny method Triple.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Triple (x : Int) : Int :=\nsorry", "vc-theorems": "theorem Triple_spec (x : Int) : Triple x = 3 * x :=\nsorry", "vc-postamble": ""}
{"id": "Clover_two_sum_twoSum", "vc-description": "/- \n{\n\"name\": \"Clover_two_sum_twoSum\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_two_sum_twoSum\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nFinds two indices i,j in an array such that nums + nums = target.\nTranslated from Dafny method twoSum.\n\n@param nums The input array of integers\n@param target The target sum to find\n@return A pair of indices (i,j) that sum to target\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def twoSum (nums : Array Int) (target : Int) : Int × Int :=\nsorry", "vc-theorems": "theorem twoSum_spec (nums : Array Int) (target : Int) :\nnums.size > 1 →\n(∃ i j, 0 ≤ i ∧ i < j ∧ j < nums.size ∧ nums[i]! + nums[j]! = target) →\nlet (i, j) := twoSum nums target\n0 ≤ i ∧ i < j ∧ j < nums.size ∧ nums[i.toNat]! + nums[j.toNat]! = target ∧\n(∀ ii jj, 0 ≤ ii ∧ ii < i ∧ ii < jj ∧ jj < nums.size → nums[ii.toNat]! + nums[jj.toNat]! ≠ target) ∧\n(∀ jj, i < jj ∧ jj < j → nums[i.toNat]! + nums[jj.toNat]! ≠ target) :=\nsorry", "vc-postamble": ""}
{"id": "Clover_update_array_UpdateElements", "vc-description": "/- \n{\n\"name\": \"Clover_update_array_UpdateElements\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Clover_update_array_UpdateElements\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nUpdateElements modifies an array by:\n- Adding 3 to element at index 4\n- Setting element at index 7 to 516\n- Keeping all other elements unchanged\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def UpdateElements (a : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem UpdateElements_spec (a : Array Int) :\na.size ≥ 8 →\nlet a' := UpdateElements a\n(a'[4]! = a[4]! + 3) ∧\n(a'[7]! = 516) ∧\n(∀ i, 0 ≤ i ∧ i < a.size → i ≠ 7 ∧ i ≠ 4 → a'[i]! = a[i]!) :=\nsorry", "vc-postamble": ""}
{"id": "Correctness_tmp_tmpwqvg5q_4_Sorting_Tangent_BinarySearch", "vc-description": "/- \n{\n\"name\": \"Correctness_tmp_tmpwqvg5q_4_Sorting_Tangent_BinarySearch\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Correctness_tmp_tmpwqvg5q_4_Sorting_Tangent_BinarySearch\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nBinary search implementation translated from Dafny.\nInput array must be sorted in ascending order.\nReturns index where circle value should be inserted.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def BinarySearch (a : Array Int) (circle : Int) : Int :=\nsorry", "vc-theorems": "theorem BinarySearch_spec (a : Array Int) (circle : Int) :\n(∀ i, 1 ≤ i ∧ i < a.size → a[(i-1)]! < a[i]!) →\n(∀ i j, 0 ≤ i ∧ i < j ∧ j < a.size → a[i]! < a[j]!) →\nlet n := BinarySearch a circle\n(0 ≤ n ∧ n ≤ a.size) ∧\n(∀ i, 0 ≤ i ∧ i < n → a[i.toNat]! < circle) ∧\n(∀ i, n ≤ i ∧ i < a.size → circle ≤ a[i.toNat]!) :=\nsorry", "vc-postamble": ""}
{"id": "Correctness_tmp_tmpwqvg5q_4_Sorting_Tangent_Tangent", "vc-description": "/- \n{\n\"name\": \"Correctness_tmp_tmpwqvg5q_4_Sorting_Tangent_Tangent\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Correctness_tmp_tmpwqvg5q_4_Sorting_Tangent_Tangent\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nBinarySearch method translated from Dafny.\nTakes a sorted array and finds insertion point for a value.\n-/\n\n/- \nSpecification for BinarySearch method\n-/\n\n/- \nTangent method translated from Dafny.\nChecks if there are matching elements between two arrays.\n-/\n\n/- \nSpecification for Tangent method\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def BinarySearch (a : Array Int) (circle : Int) : Int :=\nsorry\n\ndef Tangent (r : Array Int) (x : Array Int) : Bool :=\nsorry", "vc-theorems": "theorem BinarySearch_spec (a : Array Int) (circle : Int) (n : Int) :\n(∀ i, 1 ≤ i ∧ i < a.size → a[(i-1)]! < a[i]!) →\n(∀ i j, 0 ≤ i ∧ i < j ∧ j < a.size → a[i]! < a[j]!) →\n0 ≤ n ∧ n ≤ a.size ∧\n(∀ i, 0 ≤ i ∧ i < n → a[i.toNat]! < circle) ∧\n(∀ i, n ≤ i ∧ i < a.size → circle ≤ a[i.toNat]!) :=\nsorry\n\ntheorem Tangent_spec (r x : Array Int) (found : Bool) :\n(∀ i, 1 ≤ i ∧ i < x.size → x[(i-1)]! < x[i]!) →\n(∀ i j, 0 ≤ i ∧ i < j ∧ j < x.size → x[i]! < x[j]!) →\n(¬found →\n(∀ i j, 0 ≤ i ∧ i < r.size ∧ 0 ≤ j ∧ j < x.size → r[i]! ≠ x[j]!)) ∧\n(found →\n(∃ i j, 0 ≤ i ∧ i < r.size ∧ 0 ≤ j ∧ j < x.size ∧ r[i]! = x[j]!)) :=\nsorry", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session10Exercises_ExerciseBarrier_barrier", "vc-description": "/- \n{\n\"name\": \"Dafny-Exercises_tmp_tmpjm75muf__Session10Exercises_ExerciseBarrier_barrier\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny-Exercises_tmp_tmpjm75muf__Session10Exercises_ExerciseBarrier_barrier\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nMethod barrier receives an array and an integer p and returns a boolean b which is true if and only if\nall the positions to the left of p and including also position p contain elements\nthat are strictly smaller than all the elements contained in the positions to the right of p.\n\nExamples:\nIf v= and p=0 or p=1 then the method must return false,\nbut for p=2 the method should return true\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def barrier (v : Array Int) (p : Int) : Bool :=\nsorry", "vc-theorems": "theorem barrier_spec (v : Array Int) (p : Int) :\nv.size > 0 ∧\n0 ≤ p ∧ p < v.size →\nbarrier v p = (∀ k l, 0 ≤ k ∧ k ≤ p ∧ p < l ∧ l < v.size → v[k.toNat]! < v[l.toNat]!) :=\nsorry", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExerciseFibonacci_fibonacci1", "vc-description": "/- \n{\n\"name\": \"Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExerciseFibonacci_fibonacci1\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExerciseFibonacci_fibonacci1\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nRecursive function to compute the nth Fibonacci number.\nTranslated from Dafny's fib function.\n-/\n\n/- \nMethod to compute the nth Fibonacci number.\nEnsures the result equals fib(n).\nTranslated from Dafny's fibonacci1 method.\n-/\n\n/- \nSpecification for fibonacci1 method ensuring it computes\nthe correct Fibonacci number.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def fib (n : Nat) : Nat :=\nsorry\n\ndef fibonacci1 (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem fibonacci1_spec (n : Nat) :\nfibonacci1 n = fib n :=\nsorry", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExercisePositive_mpositive", "vc-description": "/- \n{\n\"name\": \"Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExercisePositive_mpositive\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExercisePositive_mpositive\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nPredicate that checks if all elements in an array are non-negative\n-/\n\n/- \nMethod that checks if all elements in an array are non-negative.\nReturns true if all elements are non-negative, false otherwise.\n-/", "vc-preamble": "def positive (s : Array Int) : Prop :=\n∀ u, 0 ≤ u ∧ u < s.size → s[u]! ≥ 0", "vc-helpers": "", "vc-definitions": "def mpositive (v : Array Int) : Bool :=\nsorry", "vc-theorems": "theorem mpositive_spec (v : Array Int) :\nmpositive v = positive v :=\nsorry", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExerciseSquare_root_mroot1", "vc-description": "/- \n{\n\"name\": \"Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExerciseSquare_root_mroot1\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExerciseSquare_root_mroot1\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nComputes the integer square root of a non-negative number.\nTranslated from Dafny method mroot1.\n\n@param n The input non-negative integer\n@return r The integer square root satisfying the specification\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def mroot1 (n : Int) : Int :=\nsorry", "vc-theorems": "theorem mroot1_spec (n : Int) :\nn ≥ 0 →\nlet r := mroot1 n\nr ≥ 0 ∧ r * r ≤ n ∧ n < (r + 1) * (r + 1) :=\nsorry", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_mfirstMaximum", "vc-description": "/- \n{\n\"name\": \"Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_mfirstMaximum\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_mfirstMaximum\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nFinds the first maximum element in an array from left to right.\n\n@param v The input array of integers\n@return The index of the first maximum element\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def mfirstMaximum (v : Array Int) : Int :=\nsorry", "vc-theorems": "theorem mfirstMaximum_spec (v : Array Int) :\nv.size > 0 →\nlet i := mfirstMaximum v\n(0 ≤ i ∧ i < v.size) ∧\n(∀ k, 0 ≤ k ∧ k < v.size → v[i.toNat]! ≥ v[k]!) ∧\n(∀ l, 0 ≤ l ∧ l < i → v[i.toNat]! > v[l.toNat]!) :=\nsorry", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_mlastMaximum", "vc-description": "/- \n{\n\"name\": \"Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_mlastMaximum\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_mlastMaximum\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nFinds the last maximum element in an array.\nTranslated from Dafny method mlastMaximum.\n\n@param v The input array of integers\n@return The index of the last maximum element\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def mlastMaximum (v : Array Int) : Int :=\nsorry", "vc-theorems": "theorem mlastMaximum_spec (v : Array Int) :\nv.size > 0 →\nlet i := mlastMaximum v\n(0 ≤ i ∧ i < v.size) ∧\n(∀ k, 0 ≤ k ∧ k < v.size → v[i.toNat]! ≥ v[k]!) ∧\n(∀ l, i < l ∧ l < v.size → v[i.toNat]! > v[l.toNat]!) :=\nsorry", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_mmaximum1", "vc-description": "/- \n{\n\"name\": \"Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_mmaximum1\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_mmaximum1\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nTranslation of Dafny method mmaximum1 which finds the first maximum element in an array.\nOriginal requires array length > 0.\nOriginal ensures output index is valid and element at that index is maximum.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def mmaximum1 (v : Array Int) : Int :=\nsorry", "vc-theorems": "theorem mmaximum1_spec (v : Array Int) :\nv.size > 0 →\nlet i := mmaximum1 v\n0 ≤ i ∧ i < v.size ∧\n∀ k, 0 ≤ k ∧ k < v.size → v[i.toNat]! ≥ v[k]! :=\nsorry", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseAllEqual_mallEqual1", "vc-description": "/- \n{\n\"name\": \"Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseAllEqual_mallEqual1\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseAllEqual_mallEqual1\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate that checks if all elements in an array are equal -/\n\n/-  Method that checks if all elements in an array are equal.\nReturns true if all elements are equal, false otherwise.\nEnsures the result matches the allEqual predicate on the array. -/", "vc-preamble": "def allEqual (s : Array Int) : Prop :=\n∀ i j, 0 ≤ i ∧ i < s.size ∧ 0 ≤ j ∧ j < s.size → s[i]! = s[j]!", "vc-helpers": "", "vc-definitions": "def mallEqual1 (v : Array Int) : Bool :=\nsorry", "vc-theorems": "theorem mallEqual1_spec (v : Array Int) :\nmallEqual1 v = allEqual v :=\nsorry", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseContained_mcontained", "vc-description": "/- \n{\n\"name\": \"Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseContained_mcontained\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseContained_mcontained\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate indicating if an array is strictly sorted -/\n\n/- \nChecks if elements from array v are contained in array w.\nInput:\n- v: First array\n- w: Second array\n- n: Number of elements to check from v\n- m: Number of elements to check in w\nReturns:\n- Boolean indicating if first n elements of v are in first m elements of w\n-/", "vc-preamble": "def strictSorted (s : Array Int) : Prop :=\n∀ u w, 0 ≤ u → u < w → w < s.size → s[u]! < s[w]!", "vc-helpers": "", "vc-definitions": "def mcontained (v w : Array Int) (n m : Int) : Bool :=\nsorry", "vc-theorems": "theorem mcontained_spec (v w : Array Int) (n m : Int) :\nn ≤ m ∧\nn ≥ 0 ∧\nstrictSorted v ∧\nstrictSorted w ∧\nv.size ≥ n ∧\nw.size ≥ m →\nmcontained v w n m = (∀ k, 0 ≤ k ∧ k < n → ∃ j, 0 ≤ j ∧ j < m ∧ v[k.toNat]! = w[j.toNat]!) :=\nsorry", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseFirstNegative_mfirstNegative", "vc-description": "/- \n{\n\"name\": \"Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseFirstNegative_mfirstNegative\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseFirstNegative_mfirstNegative\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate indicating all elements in array are non-negative -/\n\n/-  Method to find first negative element in array -/", "vc-preamble": "def positive (s : Array Int) : Prop :=\n∀ u, 0 ≤ u ∧ u < s.size → s[u]! ≥ 0", "vc-helpers": "", "vc-definitions": "def mfirstNegative (v : Array Int) : Bool × Int :=\nsorry", "vc-theorems": "theorem mfirstNegative_spec (v : Array Int) :\nlet (b, i) := mfirstNegative v\n(b ↔ ∃ k, 0 ≤ k ∧ k < v.size ∧ v[k]! < 0) ∧\n(b → 0 ≤ i ∧ i < v.size ∧ v[i.toNat]! < 0 ∧ positive (v.extract 0 i.toNat)) :=\nsorry", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExercisefirstZero_mfirstCero", "vc-description": "/- \n{\n\"name\": \"Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExercisefirstZero_mfirstCero\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExercisefirstZero_mfirstCero\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nFinds the first occurrence of zero in an array.\nReturns the index of the first zero, or the array length if no zero is found.\n\n@param v The input array to search\n@return The index of the first zero, or array length if none found\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def mfirstCero (v : Array Int) : Int :=\nsorry", "vc-theorems": "theorem mfirstCero_spec (v : Array Int) :\nlet i := mfirstCero v\n0 ≤ i ∧ i ≤ v.size ∧\n(∀ j, 0 ≤ j ∧ j < i → v[j.toNat]! ≠ 0) ∧\n(i ≠ v.size → v[i.toNat]! = 0) :=\nsorry", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session5Exercises_ExerciseSumElems_sumElems", "vc-description": "/- \n{\n\"name\": \"Dafny-Exercises_tmp_tmpjm75muf__Session5Exercises_ExerciseSumElems_sumElems\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny-Exercises_tmp_tmpjm75muf__Session5Exercises_ExerciseSumElems_sumElems\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Recursive sum function that sums elements from right to left -/\n\n/-  Recursive sum function that sums elements from left to right -/\n\n/-  Helper function to sum array elements in range [c,f) -/\n\n/-  Specification for SumV requiring valid array bounds -/\n\n/-  Main method to sum all elements in an array -/\n\n/-  Specification ensuring sumElems returns the sum of all elements -/", "vc-preamble": "partial def SumR (s : Array Int) : Int :=\nif s.size = 0 then 0\nelse SumR (s.extract 0 (s.size - 1)) + s[s.size - 1]!\n\npartial def SumL (s : Array Int) : Int :=\nif s.size = 0 then 0\nelse s[0]! + SumL (s.extract 1 s.size)\n\ndef SumV (v : Array Int) (c : Nat) (f : Nat) : Int :=\nSumR (v.extract c f)", "vc-helpers": "", "vc-definitions": "def sumElems (v : Array Int) : Int :=\nsorry", "vc-theorems": "theorem SumV_spec (v : Array Int) (c f : Nat) :\n0 ≤ c ∧ c ≤ f ∧ f ≤ v.size →\nSumV v c f = SumR (v.extract c f) :=\nsorry\n\ntheorem sumElems_spec (v : Array Int) :\nsumElems v = SumR v :=\nsorry", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session5Exercises_ExerciseSumElems_sumElemsB", "vc-description": "/- \n{\n\"name\": \"Dafny-Exercises_tmp_tmpjm75muf__Session5Exercises_ExerciseSumElems_sumElemsB\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny-Exercises_tmp_tmpjm75muf__Session5Exercises_ExerciseSumElems_sumElemsB\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Recursive sum of array elements from right to left -/\n\n/-  Recursive sum of array elements from left to right -/\n\n/-  Sum of array elements in range [c,f) -/\n\n/-  Method to sum all elements in an array -/", "vc-preamble": "partial def SumR (s : Array Int) : Int :=\nif s.size = 0 then 0\nelse SumR (s.extract 0 (s.size - 1)) + s[s.size - 1]!\ndecreasing_by all_goals simp_wf; omega\npartial def SumL (s : Array Int) : Int :=\nif s.size = 0 then 0\nelse s[0]! + SumL (s.extract 1 s.size)\ndecreasing_by all_goals simp_wf; omega\ndef SumV (v : Array Int) (c : Nat) (f : Nat) : Int :=\nSumR (v.extract c f)", "vc-helpers": "", "vc-definitions": "def sumElemsB (v : Array Int) : Int :=\nsorry", "vc-theorems": "theorem sumElemsB_spec (v : Array Int) :\nsumElemsB v = SumR (v.extract 0 v.size) :=\nsorry", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session6Exercises_ExerciseCountEven_mcountEven", "vc-description": "/- \n{\n\"name\": \"Dafny-Exercises_tmp_tmpjm75muf__Session6Exercises_ExerciseCountEven_mcountEven\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny-Exercises_tmp_tmpjm75muf__Session6Exercises_ExerciseCountEven_mcountEven\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate that checks if all elements in an array are non-negative -/\n\n/-  Predicate that checks if a non-negative integer is even -/\n\n/-  Function that counts even numbers in an array -/\n\n/-  Method specification for counting even numbers in an array -/", "vc-preamble": "def positive (s : Array Int) : Prop :=\n∀ u, 0 ≤ u ∧ u < s.size → s[u]! ≥ 0\ndef isEven (i : Int) : Bool :=\ni ≥ 0 → i % 2 = 0\npartial def CountEven (s : Array Int) : Int :=\nif s.size = 0 then 0\nelse\nlet last := s[s.size - 1]!\nlet rest := s.extract 0 (s.size - 1)\n(if last % 2 = 0 then 1 else 0) + CountEven rest", "vc-helpers": "", "vc-definitions": "def mcountEven (v : Array Int) : Int :=\nsorry", "vc-theorems": "theorem mcountEven_spec (v : Array Int) :\npositive v → mcountEven v = CountEven v :=\nsorry", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session6Exercises_ExerciseCountMin_mCountMin", "vc-description": "/- \n{\n\"name\": \"Dafny-Exercises_tmp_tmpjm75muf__Session6Exercises_ExerciseCountMin_mCountMin\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny-Exercises_tmp_tmpjm75muf__Session6Exercises_ExerciseCountMin_mCountMin\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Finds minimum value in array up to index i -/\n\n/-  Specification for min function -/\n\n/-  Counts occurrences of x in array up to index i -/\n\n/-  Specification for countMin function -/\n\n/-  Main method that counts occurrences of minimum value -/\n\n/-  Specification for mCountMin method -/", "vc-preamble": "partial def min (v : Array Int) (i : Nat) : Int :=\nif i = 1 then v[0]!\nelse if v[i-1]! ≤ min v (i-1) then v[i-1]!\nelse min v (i-1)\n\npartial def countMin (v : Array Int) (x : Int) (i : Nat) : Int :=\nif i = 0 then 0\nelse if v[i-1]! = x then 1 + countMin v x (i-1)\nelse countMin v x (i-1)", "vc-helpers": "", "vc-definitions": "def mCountMin (v : Array Int) : Int :=\nsorry", "vc-theorems": "theorem min_spec (v : Array Int) (i : Nat) :\n1 ≤ i ∧ i ≤ v.size →\n∀ k, 0 ≤ k ∧ k < i → v[k]! ≥ min v i :=\nsorry\n\ntheorem countMin_spec (v : Array Int) (x : Int) (i : Nat) :\n0 ≤ i ∧ i ≤ v.size →\ncountMin v x i = 0 :=\nsorry\n\ntheorem mCountMin_spec (v : Array Int) :\nv.size > 0 →\nmCountMin v = countMin v (min v v.size) v.size :=\nsorry", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session6Exercises_ExercisePeekSum_mPeekSum", "vc-description": "/- \n{\n\"name\": \"Dafny-Exercises_tmp_tmpjm75muf__Session6Exercises_ExercisePeekSum_mPeekSum\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny-Exercises_tmp_tmpjm75muf__Session6Exercises_ExercisePeekSum_mPeekSum\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate that checks if element at index i is greater than or equal to all previous elements -/\n\n/-  Function that computes sum of all peak elements up to index i -/\n\n/-  Method that computes sum of all peak elements in array -/\n\n/-  Specification for mPeekSum -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isPeek (v : Array Int) (i : Nat) : Bool :=\nsorry\n\ndef mPeekSum (v : Array Int) : Int :=\nsorry", "vc-theorems": "partial def peekSum (v : Array Int) (i : Nat) : Int :=\nif i = 0 then 0\nelse if isPeek v (i-1) then v[i-1]! + peekSum v (i-1)\nelse peekSum v (i-1)\n\ntheorem mPeekSum_spec (v : Array Int) :\nv.size > 0 → mPeekSum v = peekSum v v.size :=\nsorry", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBinarySearch_binarySearch", "vc-description": "/- \n{\n\"name\": \"Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBinarySearch_binarySearch\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBinarySearch_binarySearch\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nPredicate indicating if an array is sorted in ascending order.\n-/\n\n/- \nBinary search implementation that finds the position of an element in a sorted array.\nReturns -1 if element not found.\n\nParameters:\n- v: The sorted input array to search in\n- elem: The element to search for\n\nReturns:\n- Position p such that all elements up to p are ≤ elem and all elements after p are > elem\n-/\n\n/- \nSpecification for binary search:\n1. Result is within valid bounds (-1 to array length-1)\n2. All elements up to result are ≤ elem\n3. All elements after result are > elem\n-/", "vc-preamble": "def sorted (s : Array Int) : Prop :=\n∀ u w : Nat, u < w → w < s.size → s[u]! ≤ s[w]!", "vc-helpers": "", "vc-definitions": "def binarySearch (v : Array Int) (elem : Int) : Int :=\nsorry", "vc-theorems": "theorem binarySearch_spec (v : Array Int) (elem : Int) :\nsorted v →\n0 ≤ binarySearch v elem →\n(∀ u : Nat, u ≤ Int.toNat (binarySearch v elem) ∧ u < v.size → v[u]! ≤ elem) ∧\n(∀ w : Nat, Int.toNat (binarySearch v elem) < w ∧ w < v.size → v[w]! > elem) :=\nsorry", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBinarySearch_binarySearchRec", "vc-description": "/- \n{\n\"name\": \"Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBinarySearch_binarySearchRec\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBinarySearch_binarySearchRec\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate indicating if an array is sorted in ascending order -/\n\n/-  Binary search implementation specification -/", "vc-preamble": "def sorted (s : Array Int) : Prop :=\n∀ u w : Nat, u < w → w < s.size → s[u]! ≤ s[w]!", "vc-helpers": "", "vc-definitions": "def binarySearchRec (v : Array Int) (elem : Int) (c : Int) (f : Int) : Int :=\nsorry", "vc-theorems": "theorem binarySearchRec_spec\n(v : Array Int) (elem : Int) (c : Int) (f : Int) :\nsorted (v.extract 0 v.size) →\n0 ≤ c → c ≤ f + 1 → f + 1 ≤ v.size →\n(∀ k : Nat, k < c.toNat → v[k]! ≤ elem) →\n(∀ k : Nat, f.toNat < k → k < v.size → v[k]! > elem) →\n-1 ≤ binarySearchRec v elem c f ∧ binarySearchRec v elem c f < v.size ∧\n(∀ u : Nat, u ≤ Int.toNat (binarySearchRec v elem c f) ∧ u < v.size → v[u]! ≤ elem) ∧\n(∀ w : Nat, Int.toNat (binarySearchRec v elem c f) < w ∧ w < v.size → v[w]! > elem) :=\nsorry", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBinarySearch_otherbSearch", "vc-description": "/- \n{\n\"name\": \"Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBinarySearch_otherbSearch\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBinarySearch_otherbSearch\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate indicating if an array is sorted in ascending order -/\n\n/-  Binary search implementation specification -/\n\n/-  Binary search specification -/\n\n/-  Alternative binary search implementation -/\n\n/-  Alternative binary search specification -/", "vc-preamble": "def sorted (s : Array Int) : Prop :=\n∀ u w : Nat, u < w → w < s.size → s[u]! ≤ s[w]!", "vc-helpers": "", "vc-definitions": "def binarySearch (v : Array Int) (elem : Int) : Int :=\nsorry\n\ndef otherbSearch (v : Array Int) (elem : Int) : Bool × Int :=\nsorry", "vc-theorems": "theorem binarySearch_spec (v : Array Int) (elem : Int) :\nsorted v →\n0 ≤ binarySearch v elem →\n(∀ u : Nat, u ≤ Int.toNat (binarySearch v elem) ∧ u < v.size → v[u]! ≤ elem) ∧\n(∀ w : Nat, Int.toNat (binarySearch v elem) < w ∧ w < v.size → v[w]! > elem) :=\nsorry\n\ntheorem otherbSearch_spec (v : Array Int) (elem : Int) :\nsorted v →\nlet (b, p) := otherbSearch v elem\n0 ≤ p ∧ p ≤ v.size ∧\n(b ↔ ∃ i, 0 ≤ i ∧ i < v.size ∧ v[i]! = elem) ∧\n(b → p < v.size ∧ v[p.toNat]! = elem) ∧\n(¬b → (∀ u, 0 ≤ u ∧ u < p → v[u.toNat]! < elem) ∧\n(∀ w, p ≤ w ∧ w < v.size → v[w.toNat]! > elem)) :=\nsorry", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBinarySearch_search", "vc-description": "/- \n{\n\"name\": \"Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBinarySearch_search\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBinarySearch_search\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate indicating if an array is sorted in ascending order -/\n\n/-  Binary search implementation -/\n\n/-  Binary search specification -/\n\n/-  Search implementation using binary search -/\n\n/-  Search specification -/", "vc-preamble": "def sorted (s : Array Int) : Prop :=\n∀ u w : Nat, u < w → w < s.size → s[u]! ≤ s[w]!", "vc-helpers": "", "vc-definitions": "def binarySearch (v : Array Int) (elem : Int) : Int :=\nsorry\n\ndef search (v : Array Int) (elem : Int) : Bool :=\nsorry", "vc-theorems": "theorem binarySearch_spec (v : Array Int) (elem : Int) :\nsorted v →\n0 ≤ binarySearch v elem →\n(∀ u : Nat, u ≤ Int.toNat (binarySearch v elem) ∧ u < v.size → v[u]! ≤ elem) ∧\n(∀ w : Nat, Int.toNat (binarySearch v elem) < w ∧ w < v.size → v[w]! > elem) :=\nsorry\n\ntheorem search_spec (v : Array Int) (elem : Int) :\nsorted v →\nsearch v elem = true ↔ (∃ i, 0 ≤ i ∧ i < v.size ∧ v[i]! = elem) :=\nsorry", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBubbleSort_bubbleSort", "vc-description": "/- \n{\n\"name\": \"Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBubbleSort_bubbleSort\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBubbleSort_bubbleSort\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nPredicate indicating if array segment [i,j) is sorted\n-/\n\n/- \nBubbleSort implementation for array segment [c,f)\n-/", "vc-preamble": "def sorted_seg (a : Array Int) (i j : Int) : Prop :=\n0 ≤ i ∧ i ≤ j ∧ j ≤ a.size ∧\n∀ l k : Nat, i ≤ l ∧ l ≤ k ∧ k < j → a[l]! ≤ a[k]!", "vc-helpers": "", "vc-definitions": "def bubbleSort (a : Array Int) (c f : Int) : Array Int :=\nsorry", "vc-theorems": "theorem bubbleSort_spec (a : Array Int) (c f : Int) :\n0 ≤ c ∧ c ≤ f ∧ f ≤ a.size →\nlet result := bubbleSort a c f\nsorted_seg result c f ∧\n\n-- Note: Multiset and array slice specifications simplified due to translation limitations\n\nresult.size = a.size :=\nsorry", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBubbleSort_bubbleSorta", "vc-description": "/- \n{\n\"name\": \"Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBubbleSort_bubbleSorta\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBubbleSort_bubbleSorta\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nPredicate indicating if array segment [i,j) is sorted\n-/\n\n/- \nBubble sort implementation for array segment [c,f)\n-/", "vc-preamble": "def sorted_seg (a : Array Int) (i j : Int) : Prop :=\n0 ≤ i ∧ i ≤ j ∧ j ≤ a.size ∧\n∀ l k : Nat, i ≤ l ∧ l ≤ k ∧ k < j → a[l]! ≤ a[k]!", "vc-helpers": "", "vc-definitions": "def bubbleSorta (a : Array Int) (c f : Int) : Array Int :=\nsorry", "vc-theorems": "theorem bubbleSorta_spec (a : Array Int) (c f : Int) :\n0 ≤ c ∧ c ≤ f ∧ f ≤ a.size →\nlet result := bubbleSorta a c f\nsorted_seg result c f ∧\nresult.size = a.size :=\nsorry", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseReplace_replace", "vc-description": "/- \n{\n\"name\": \"Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseReplace_replace\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseReplace_replace\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nReplaces all occurrences of value x with value y in array v.\n\n@param v The array to modify\n@param x The value to replace\n@param y The replacement value\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def replace (v : Array Int) (x : Int) (y : Int) : Array Int :=\nsorry", "vc-theorems": "theorem replace_spec (v : Array Int) (x y : Int) :\nlet v' := replace v x y\n∀ k, 0 ≤ k ∧ k < v.size →\n((v[k]! = x → v'[k]! = y) ∧\n(v[k]! ≠ x → v'[k]! = v[k]!)) :=\nsorry", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseSelSort_selSort", "vc-description": "/- \n{\n\"name\": \"Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseSelSort_selSort\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseSelSort_selSort\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate indicating if array segment is sorted from index i to j (exclusive) -/\n\n/-  Selection sort implementation -/", "vc-preamble": "def sorted_seg (a : Array Int) (i j : Int) : Prop :=\n0 ≤ i ∧ i ≤ j ∧ j ≤ a.size ∧\n∀ l k : Nat, i ≤ l ∧ l ≤ k ∧ k < j → a[l]! ≤ a[k]!", "vc-helpers": "", "vc-definitions": "def selSort (a : Array Int) (c f : Int) : Array Int :=\nsorry", "vc-theorems": "theorem selSort_spec (a : Array Int) (c f : Int) :\n0 ≤ c ∧ c ≤ f ∧ f ≤ a.size →\nlet result := selSort a c f\nsorted_seg result c f ∧\n\n-- Note: Multiset and array segment specifications simplified due to translation limitations\n\nresult.size = a.size :=\nsorry", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseSeparate_separate", "vc-description": "/- \n{\n\"name\": \"Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseSeparate_separate\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseSeparate_separate\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate indicating all elements in array slice are negative -/\n\n/-  Predicate indicating all elements in array are non-negative -/\n\n/-  Predicate indicating two arrays are permutations of each other -/\n\n/- \nMethod that separates array into positive and negative parts.\nReturns index i such that:\n- Elements before i are positive\n- Elements from i onwards are negative\n- Result is a permutation of input array\n-/", "vc-preamble": "def strictNegative (v : Array Int) (i j : Int) : Prop :=\ni ≥ 0 ∧ i ≤ j ∧ j ≤ v.size ∧\n∀ u : Nat, i ≤ u ∧ u < j → v[u]! < 0\ndef positive (s : Array Int) : Prop :=\n∀ u : Nat, u < s.size → s[u]! ≥ 0\ndef isPermutation (s t : Array Int) : Prop :=\ns.size = t.size ∧ ∃ p : Nat → Nat, ∀ i : Nat, i < s.size → s[i]! = t[p i]!", "vc-helpers": "", "vc-definitions": "def separate (v : Array Int) : Int :=\nsorry", "vc-theorems": "theorem separate_spec (v : Array Int) :\nlet i := separate v\n0 ≤ i ∧ i ≤ v.size ∧\npositive (v.extract 0 (Int.toNat i)) ∧\nstrictNegative v i v.size ∧\nisPermutation v (v.extract 0 v.size) :=\nsorry", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session8Exercises_ExerciseInsertionSort_InsertionSort", "vc-description": "/- \n{\n\"name\": \"Dafny-Exercises_tmp_tmpjm75muf__Session8Exercises_ExerciseInsertionSort_InsertionSort\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny-Exercises_tmp_tmpjm75muf__Session8Exercises_ExerciseInsertionSort_InsertionSort\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nPredicate indicating if array segment from index i to j (inclusive) is sorted\n-/\n\n/- \nInsertionSort method specification:\n- Ensures array is sorted from index 0 to length-1\n- Ensures multiset of elements is preserved\n-/", "vc-preamble": "def sorted_seg (a : Array Int) (i j : Int) : Prop :=\n∀ l k, i ≤ l ∧ l ≤ k ∧ k ≤ j → a[l.toNat]! ≤ a[k.toNat]!", "vc-helpers": "", "vc-definitions": "def InsertionSort (a : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem InsertionSort_spec (a : Array Int) :\nlet result := InsertionSort a\nsorted_seg result 0 (result.size - 1) :=\nsorry", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session9Exercises_ExerciseSeqMaxSum_segMaxSum", "vc-description": "/- \n{\n\"name\": \"Dafny-Exercises_tmp_tmpjm75muf__Session9Exercises_ExerciseSeqMaxSum_segMaxSum\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny-Exercises_tmp_tmpjm75muf__Session9Exercises_ExerciseSeqMaxSum_segMaxSum\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Sum function that computes sum of array elements from index i to j-1 -/\n\n/-  Predicate indicating if s is maximum sum from any index l up to i -/\n\n/-  Alternative sum function computing from left to right -/\n\n/-  Alternative predicate for maximum sum from right -/\n\n/-  Main segMaxSum method specification -/\n\n/-  Implementation of segMaxSum -/", "vc-preamble": "partial def Sum_ (v : Array Int) (i j : Int) : Int :=\nif i = j then 0\nelse Sum_ v i (j-1) + v[(j-1).toNat]!\n\ndef SumMaxToRight (v : Array Int) (i s : Int) : Prop :=\n∀ l ss, 0 ≤ l ∧ l ≤ i ∧ ss = i + 1 → Sum_ v l ss ≤ s\n\npartial def Sum2 (v : Array Int) (i j : Int) : Int :=\nif i = j then 0\nelse v[i.toNat]! + Sum2 v (i+1) j\n\ndef SumMaxToRight2 (v : Array Int) (j i s : Int) : Prop :=\n∀ l ss, j ≤ l ∧ l ≤ i ∧ ss = i + 1 → Sum2 v l ss ≤ s", "vc-helpers": "", "vc-definitions": "def segMaxSum (v : Array Int) (i : Int) : (Int × Int) :=\nsorry", "vc-theorems": "theorem segMaxSum_spec (v : Array Int) (i : Int) (s k : Int) :\nv.size > 0 ∧ 0 ≤ i ∧ i < v.size →\n0 ≤ k ∧ k ≤ i ∧ s = Sum_ v k (i+1) ∧ SumMaxToRight v i s :=\nsorry", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session9Exercises_ExerciseSeqMaxSum_segSumaMaxima2", "vc-description": "/- \n{\n\"name\": \"Dafny-Exercises_tmp_tmpjm75muf__Session9Exercises_ExerciseSeqMaxSum_segSumaMaxima2\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny-Exercises_tmp_tmpjm75muf__Session9Exercises_ExerciseSeqMaxSum_segSumaMaxima2\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Sum function that computes sum of array elements from index i to j-1 -/\n\n/-  Predicate indicating if s is maximum sum from any l to i+1 -/\n\n/-  Alternative sum function computing sum from i to j -/\n\n/-  Predicate indicating if s is maximum sum from j to i+1 -/\n\n/-  Main method specification -/\n\n/-  Main method implementation -/", "vc-preamble": "partial def Sum_ (v : Array Int) (i j : Int) : Int :=\nif i = j then 0\nelse Sum_ v i (j-1) + v[(j-1).toNat]!\n\ndef SumMaxToRight (v : Array Int) (i s : Int) : Prop :=\n∀ l ss, 0 ≤ l ∧ l ≤ i ∧ ss = i + 1 → Sum_ v l ss ≤ s\n\npartial def Sum2 (v : Array Int) (i j : Int) : Int :=\nif i = j then 0\nelse v[i.toNat]! + Sum2 v (i+1) j\n\ndef SumMaxToRight2 (v : Array Int) (j i s : Int) : Prop :=\n∀ l ss, j ≤ l ∧ l ≤ i ∧ ss = i + 1 → Sum2 v l ss ≤ s", "vc-helpers": "", "vc-definitions": "def segSumaMaxima2 (v : Array Int) (i : Int) : (Int × Int) :=\nsorry", "vc-theorems": "theorem segSumaMaxima2_spec (v : Array Int) (i : Int) (s k : Int) :\nv.size > 0 ∧ 0 ≤ i ∧ i < v.size →\n0 ≤ k ∧ k ≤ i ∧ s = Sum2 v k (i+1) ∧ SumMaxToRight2 v 0 i s :=\nsorry", "vc-postamble": ""}
{"id": "Dafny-Grind75_tmp_tmpsxfz3i4r_problems_twoSum_twoSum", "vc-description": "/- \n{\n\"name\": \"Dafny-Grind75_tmp_tmpsxfz3i4r_problems_twoSum_twoSum\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny-Grind75_tmp_tmpsxfz3i4r_problems_twoSum_twoSum\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nPredicate indicating if two indices form a valid summing pair in the array\nthat adds up to the target value.\n-/\n\n/- \nMain twoSum function that finds a pair of indices whose elements sum to target.\nTranslated from Dafny method specification.\n-/", "vc-preamble": "def summingPair (i j : Nat) (nums : Array Int) (target : Int) : Prop :=\ni < nums.size ∧ j < nums.size ∧ i ≠ j ∧ nums[i]! + nums[j]! = target", "vc-helpers": "", "vc-definitions": "def twoSum (nums : Array Int) (target : Int) : Nat × Nat :=\nsorry", "vc-theorems": "theorem twoSum_spec (nums : Array Int) (target : Int) :\n(∃ i j : Nat, i < j ∧ j < nums.size ∧\nsummingPair i j nums target ∧\n∀ l m : Nat, l < m ∧ m < nums.size ∧ l ≠ i ∧ m ≠ j →\n¬summingPair l m nums target) →\nlet pair := twoSum nums target\npair.1 < nums.size ∧ pair.2 < nums.size ∧\nsummingPair pair.1 pair.2 nums target :=\nsorry", "vc-postamble": ""}
{"id": "Dafny-Practice_tmp_tmphnmt4ovh_BST_InsertBST", "vc-description": "/- \n{\n\"name\": \"Dafny-Practice_tmp_tmphnmt4ovh_BST_InsertBST\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny-Practice_tmp_tmphnmt4ovh_BST_InsertBST\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Binary tree datatype -/\n\n/-  Convert sequence to set -/\n\n/-  Get inorder traversal of tree -/\n\n/-  Get set of numbers in a tree -/\n\n/-  Check if sequence is ascending -/\n\n/-  Check if tree is a binary search tree -/\n\n/-  Check if sequence has no duplicates -/\n\n/-  Insert value into BST maintaining BST property -/", "vc-preamble": "inductive Tree where\n| Empty : Tree\n| Node : Int → Tree → Tree → Tree\nderiving Repr\ndef NumbersInSequence (q : Array Int) : List Int :=\nq.toList\ndef Inorder (t : Tree) : Array Int :=\nmatch t with\n| Tree.Empty => #[]\n| Tree.Node n t1 t2 => (Inorder t1).append (#[n]) ++ (Inorder t2)\ndef NumbersInTree (t : Tree) : List Int :=\nNumbersInSequence (Inorder t)\ndef Ascending (q : Array Int) : Prop :=\n∀ i j : Nat, i < j → j < q.size → q[i]! < q[j]!\ndef BST (t : Tree) : Prop :=\nAscending (Inorder t)\ndef NoDuplicates (q : Array Int) : Prop :=\n∀ i j : Nat, i < j → j < q.size → q[i]! ≠ q[j]!", "vc-helpers": "", "vc-definitions": "def InsertBST (t0 : Tree) (x : Int) : Tree :=\nsorry", "vc-theorems": "theorem InsertBST_spec (t0 : Tree) (x : Int) :\nBST t0 ∧ x ∉ NumbersInTree t0 →\nlet t := InsertBST t0 x\nBST t ∧ NumbersInTree t = NumbersInTree t0 ++ [x] :=\nsorry", "vc-postamble": ""}
{"id": "Dafny-Practice_tmp_tmphnmt4ovh_Pattern_Matching_FindAllOccurrences", "vc-description": "/- \n{\n\"name\": \"Dafny-Practice_tmp_tmphnmt4ovh_Pattern Matching_FindAllOccurrences\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny-Practice_tmp_tmphnmt4ovh_Pattern Matching_FindAllOccurrences\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nFinds all occurrences of a pattern in a text string.\nReturns a list of natural number offsets where the pattern occurs.\n\n@param text The text string to search in\n@param pattern The pattern string to search for\n@return A list of natural number offsets where pattern occurs in text\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def FindAllOccurrences (text pattern : String) : List Nat :=\nsorry", "vc-theorems": "theorem FindAllOccurrences_spec (text pattern : String) :\nlet offsets := FindAllOccurrences text pattern\n(∀ i : Nat, i ∈ offsets → i + pattern.length ≤ text.length) ∧\n(∀ i : Nat, i ≤ text.length - pattern.length →\n(i ∈ offsets → (∀ j : Nat, j < pattern.length → text.get ⟨i + j⟩ = pattern.get ⟨j⟩)) ∧\n((∀ j : Nat, j < pattern.length → text.get ⟨i + j⟩ = pattern.get ⟨j⟩) → i ∈ offsets)) :=\nsorry", "vc-postamble": ""}
{"id": "Dafny-Projects_tmp_tmph399drhy_p2_arraySplit_ArraySplit", "vc-description": "/- \n{\n\"name\": \"Dafny-Projects_tmp_tmph399drhy_p2_arraySplit_ArraySplit\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny-Projects_tmp_tmph399drhy_p2_arraySplit_ArraySplit\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nSplits an array into two arrays.\nTranslated from Dafny method ArraySplit.\n\n@param a The input array to split\n@return A pair of arrays (b, c) that together contain all elements from a\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def ArraySplit (a : Array Int) : Array Int × Array Int :=\nsorry", "vc-theorems": "theorem ArraySplit_spec (a : Array Int) (res : Array Int × Array Int) :\nlet (b, c) := res\n\n-- Note: fresh arrays concept simplified\n\n(a.size = b.size + c.size) ∧\n\n-- Note: array concatenation simplified\n\n(a.size > 1 → a.size > b.size) ∧\n\n(a.size > 1 → a.size > c.size) :=\nsorry", "vc-postamble": ""}
{"id": "Dafny-demo_tmp_tmpkgr_dvdi_Dafny_BinarySearch_BinarySearch", "vc-description": "/- \n{\n\"name\": \"Dafny-demo_tmp_tmpkgr_dvdi_Dafny_BinarySearch_BinarySearch\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny-demo_tmp_tmpkgr_dvdi_Dafny_BinarySearch_BinarySearch\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nPredicate indicating if an array is sorted between indices l and u.\nTranslated from Dafny's sorted predicate.\n-/\n\n/- \nBinary search implementation translated from Dafny.\nReturns index of key if found, negative number if not found.\n-/", "vc-preamble": "def sorted (a : Array Int) (l : Int) (u : Int) : Prop :=\n∀ i j, 0 ≤ l ∧ l ≤ i ∧ i ≤ j ∧ j ≤ u ∧ u < a.size → a[i.toNat]! ≤ a[j.toNat]!", "vc-helpers": "", "vc-definitions": "def BinarySearch (a : Array Int) (key : Int) : Int :=\nsorry", "vc-theorems": "theorem BinarySearch_spec (a : Array Int) (key : Int) :\nsorted a 0 (a.size - 1) →\nlet index := BinarySearch a key\n(index ≥ 0 → index < a.size ∧ a[index.toNat]! = key) ∧\n(index < 0 → ∀ k, 0 ≤ k ∧ k < a.size → a[k]! ≠ key) :=\nsorry", "vc-postamble": ""}
{"id": "Dafny-experiences_tmp_tmp150sm9qy_dafny_started_tutorial_dafny_tutorial_array_FindMax", "vc-description": "/- \n{\n\"name\": \"Dafny-experiences_tmp_tmp150sm9qy_dafny_started_tutorial_dafny_tutorial_array_FindMax\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny-experiences_tmp_tmp150sm9qy_dafny_started_tutorial_dafny_tutorial_array_FindMax\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nFinds the index of the maximum element in an array.\n\n@param a The input array of integers\n@return The index i of the maximum element\n\nRequirements:\n- Array must be non-empty\n\nEnsures:\n- Return value is a valid index (0 ≤ i < a.size)\n- The element at index i is greater than or equal to all other elements\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def FindMax (a : Array Int) : Int :=\nsorry", "vc-theorems": "theorem FindMax_spec (a : Array Int) :\na.size > 0 →\nlet i := FindMax a\n0 ≤ i ∧ i < a.size ∧\n∀ k, 0 ≤ k ∧ k < a.size → a[k]! ≤ a[i.toNat]! :=\nsorry", "vc-postamble": ""}
{"id": "Dafny-programs_tmp_tmpnso9eu7u_Algorithms___sorting_bubble-sort_BubbleSort", "vc-description": "/- \n{\n\"name\": \"Dafny-programs_tmp_tmpnso9eu7u_Algorithms + sorting_bubble-sort_BubbleSort\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny-programs_tmp_tmpnso9eu7u_Algorithms + sorting_bubble-sort_BubbleSort\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nPredicate that checks if array is sorted between given indices.\nTranslated from Dafny's sorted_between predicate.\n-/\n\n/- \nPredicate that checks if entire array is sorted.\nTranslated from Dafny's sorted predicate.\n-/\n\n/- \nBubbleSort implementation.\nTranslated from Dafny's BubbleSort method.\n-/", "vc-preamble": "def sorted_between (A : Array Int) (_from : Int) (to : Int) : Prop :=\n∀ i j, 0 ≤ i ∧ i ≤ j ∧ j < A.size ∧ _from ≤ i ∧ i ≤ j ∧ j ≤ to →\nA[i]! ≤ A[j]!\ndef sorted (A : Array Int) : Prop :=\nsorted_between A 0 (A.size - 1)", "vc-helpers": "", "vc-definitions": "def BubbleSort (A : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem BubbleSort_spec (A : Array Int) :\nlet result := BubbleSort A\nsorted result ∧\n\n-- Note: Simplified multiset preservation property since Lean doesn't have direct multiset support\n\nresult.size = A.size :=\nsorry", "vc-postamble": ""}
{"id": "DafnyPrograms_tmp_tmp74_f9k_c_automaton_ExecuteAutomaton", "vc-description": "/- \n{\n\"name\": \"DafnyPrograms_tmp_tmp74_f9k_c_automaton_ExecuteAutomaton\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: DafnyPrograms_tmp_tmp74_f9k_c_automaton_ExecuteAutomaton\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nComputes a cellular automaton given:\n- init: Initial row of boolean cells\n- rule: Function that determines next state based on cell and neighbors\n- steps: Number of steps to simulate\n\nThe automaton table contains the initial row plus a row for each step.\nEach cell's next state depends only on immediate neighbors.\nEdge cells use 'false' for missing neighbors.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def ExecuteAutomaton (init : Array Bool) (rule : Bool → Bool → Bool → Bool) (steps : Nat) :\nArray (Array Bool) :=\nsorry", "vc-theorems": "theorem ExecuteAutomaton_spec\n(init : Array Bool) (rule : Bool → Bool → Bool → Bool) (steps : Nat) :\ninit.size ≥ 2 →\nlet table := ExecuteAutomaton init rule steps\n(table.size = 1 + steps) ∧\n(table[0]! = init) ∧\n(∀ i : Nat, i < table.size → (table[i]!).size = init.size) ∧\n(∀ i j : Nat, i < table.size - 1 ∧ 1 ≤ j ∧ j ≤ (table[i]!).size - 2 →\n(table[i+1]!)[j]! = rule ((table[i]!)[j-1]!) ((table[i]!)[j]!) ((table[i]!)[j+1]!)) ∧\n(∀ i : Nat, i < table.size - 1 →\n((table[i+1]!)[0]! = rule false ((table[i]!)[0]!) ((table[i]!)[1]!)) ∧\n((table[i+1]!)[(table[i]!).size - 1]! =\nrule ((table[i]!)[(table[i]!).size - 2]!) ((table[i]!)[(table[i]!).size - 1]!) false)) :=\nsorry", "vc-postamble": ""}
{"id": "DafnyPrograms_tmp_tmp74_f9k_c_invertarray_InvertArray", "vc-description": "/- \n{\n\"name\": \"DafnyPrograms_tmp_tmp74_f9k_c_invertarray_InvertArray\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: DafnyPrograms_tmp_tmp74_f9k_c_invertarray_InvertArray\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nInvertArray inverts the elements of an array in place.\n\n@param a The array to invert\n@ensures For all valid indices i, a equals the old value at a\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def InvertArray (a : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem InvertArray_spec (a : Array Int) :\n∀ i, 0 ≤ i ∧ i < a.size →\n(InvertArray a)[i]! = a[a.size - 1 - i]! :=\nsorry", "vc-postamble": ""}
{"id": "DafnyPrograms_tmp_tmp74_f9k_c_prime-database_testPrimeness", "vc-description": "/- \n{\n\"name\": \"DafnyPrograms_tmp_tmp74_f9k_c_prime-database_testPrimeness\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: DafnyPrograms_tmp_tmp74_f9k_c_prime-database_testPrimeness\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate defining primeness of a natural number -/\n\n/-  Answer type for prime database queries -/\n\n/-  Class representing a database of prime numbers -/\n\n/-  Valid invariant for PrimeMap -/\n\n/-  Constructor for PrimeMap -/\n\n/-  Method to check if a number is prime using the database -/\n\n/-  Specification for isPrime? method -/\n\n/-  Method to test primeness of a number -/\n\n/-  Specification for testPrimeness method -/", "vc-preamble": "import Std\n\ndef prime (n : Nat) : Prop :=\nn > 1 ∧ (∀ nr, 1 < nr → nr < n → n % nr ≠ 0)\n\ninductive Answer where\n| Yes : Answer\n| No : Answer\n| Unknown : Answer\nderiving Repr\n\nstructure PrimeMap where\ndatabase : Std.HashMap Nat Bool\n\ndef PrimeMap.valid (pm : PrimeMap) : Prop :=\n∀ i, pm.database.contains i →\n(pm.database[i]! = true ↔ prime i)\n\ndef PrimeMap.new : PrimeMap :=\n{ database := Std.HashMap.emptyWithCapacity 0 }", "vc-helpers": "", "vc-definitions": "def PrimeMap.isPrime? (pm : PrimeMap) (n : Nat) : Answer :=\nsorry\n\ndef testPrimeness (n : Nat) : Bool :=\nsorry", "vc-theorems": "theorem PrimeMap.new_spec :\n(PrimeMap.new).database.isEmpty :=\nsorry\n\ntheorem PrimeMap.isPrime?_spec (pm : PrimeMap) (n : Nat) :\nlet result := pm.isPrime? n\n(pm.database.contains n ∧ prime n ↔ result = Answer.Yes) ∧\n(pm.database.contains n ∧ ¬prime n ↔ result = Answer.No) ∧\n(¬pm.database.contains n ↔ result = Answer.Unknown) :=\nsorry\n\ntheorem testPrimeness_spec (n : Nat) :\nn ≥ 0 → (testPrimeness n = true ↔ prime n) :=\nsorry", "vc-postamble": ""}
{"id": "DafnyProjects_tmp_tmp2acw_s4s_CombNK_Comb", "vc-description": "/- \n{\n\"name\": \"DafnyProjects_tmp_tmp2acw_s4s_CombNK_Comb\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: DafnyProjects_tmp_tmp2acw_s4s_CombNK_Comb\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nRecursive function to calculate combinations C(n,k) using Pascal's identity.\nRequires 0 ≤ k ≤ n\n-/\n\n/- \nMethod specification for calculating combinations C(n,k).\nTakes natural numbers n and k as input and returns their combination value.\nRequires 0 ≤ k ≤ n as precondition.\nEnsures result equals comb(n,k).\n-/", "vc-preamble": "partial def comb (n : Nat) (k : Nat) : Nat :=\nif k == 0 ∨ k == n then 1\nelse comb (n-1) k + comb (n-1) (k-1)", "vc-helpers": "", "vc-definitions": "def Comb (n : Nat) (k : Nat) : Nat :=\nsorry", "vc-theorems": "theorem Comb_spec (n : Nat) (k : Nat) :\n0 ≤ k ∧ k ≤ n → Comb n k = comb n k :=\nsorry", "vc-postamble": ""}
{"id": "DafnyProjects_tmp_tmp2acw_s4s_Power_powerDC", "vc-description": "/- \n{\n\"name\": \"DafnyProjects_tmp_tmp2acw_s4s_Power_powerDC\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: DafnyProjects_tmp_tmp2acw_s4s_Power_powerDC\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nRecursive definition of x^n in functional style.\nTranslated from Dafny's power function.\n-/\n\n/- \nComputation of x^n in time and space O(log n).\nTranslated from Dafny's powerDC method.\n-/", "vc-preamble": "def power (x : Float) (n : Nat) : Float :=\nif n = 0 then 1.0 else x * power x (n-1)", "vc-helpers": "", "vc-definitions": "def powerDC (x : Float) (n : Nat) : Float :=\nsorry", "vc-theorems": "theorem powerDC_spec (x : Float) (n : Nat) :\npowerDC x n = power x n :=\nsorry", "vc-postamble": ""}
{"id": "DafnyProjects_tmp_tmp2acw_s4s_longestPrefix_longestPrefix", "vc-description": "/- \n{\n\"name\": \"DafnyProjects_tmp_tmp2acw_s4s_longestPrefix_longestPrefix\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: DafnyProjects_tmp_tmp2acw_s4s_longestPrefix_longestPrefix\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nComputes the length of the longest common prefix of two arrays.\n\n@param a First input array\n@param b Second input array\n@return Length of longest common prefix\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def longestPrefix (a b : Array Int) : Nat :=\nsorry", "vc-theorems": "theorem longestPrefix_spec (a b : Array Int) (i : Nat) :\nlet i := longestPrefix a b\ni ≤ a.size ∧ i ≤ b.size ∧\n(i < a.size ∧ i < b.size → a[i]! ≠ b[i]!) :=\nsorry", "vc-postamble": ""}
{"id": "DafnyProjects_tmp_tmp2acw_s4s_partitionOddEven_partitionOddEven", "vc-description": "/- \n{\n\"name\": \"DafnyProjects_tmp_tmp2acw_s4s_partitionOddEven_partitionOddEven\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: DafnyProjects_tmp_tmp2acw_s4s_partitionOddEven_partitionOddEven\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate indicating if a natural number is odd -/\n\n/-  Predicate indicating if a natural number is even -/\n\n/- \nRearranges elements in an array of natural numbers so that all odd numbers appear before even numbers.\n\n@param a Array of natural numbers to be partitioned\n-/", "vc-preamble": "def odd (n : Nat) : Bool := n % 2 = 1\ndef even (n : Nat) : Bool := n % 2 = 0", "vc-helpers": "", "vc-definitions": "def partitionOddEven (a : Array Nat) : Array Nat :=\nsorry", "vc-theorems": "theorem partitionOddEven_spec (a : Array Nat) :\nlet result := partitionOddEven a;\n\n-- Output has same elements as input (using multiset equality)\n\nresult.size = a.size\n\n-- No even number before odd number\n\n∧ ¬(∃ i j, 0 ≤ i ∧ i < j ∧ j < result.size ∧ even (result[i]!) ∧ odd (result[j]!)) :=\nsorry", "vc-postamble": ""}
{"id": "Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_A2_Q1_trimmed_copy_-_副本_ComputeCount", "vc-description": "/- \n{\n\"name\": \"Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_A2_Q1_trimmed copy - 副本_ComputeCount\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_A2_Q1_trimmed copy - 副本_ComputeCount\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nGhost function that counts even numbers in a sequence up to index hi.\nTranslated from Dafny ghost function Count.\n-/\n\n/- \nMethod to compute count of even numbers.\nTranslated from Dafny method ComputeCount.\n-/", "vc-preamble": "def Count (hi : Nat) (s : Array Int) : Int :=\nif hi = 0 then 0\nelse if s[(hi-1)]! % 2 = 0 then 1 + Count (hi-1) s\nelse Count (hi-1) s", "vc-helpers": "", "vc-definitions": "def ComputeCount (CountIndex : Nat) (a : Array Int) (b : Array Int) : Nat :=\nsorry", "vc-theorems": "theorem ComputeCount_spec (CountIndex : Nat) (a : Array Int) (b : Array Int) :\n(CountIndex = 0 ∨ (a.size = b.size ∧ 1 ≤ CountIndex ∧ CountIndex ≤ a.size)) →\nComputeCount CountIndex a b = Count CountIndex a :=\nsorry", "vc-postamble": ""}
{"id": "Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_A2_Q1_trimmed_copy_-_副本_FooCount", "vc-description": "/- \n{\n\"name\": \"Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_A2_Q1_trimmed copy - 副本_FooCount\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_A2_Q1_trimmed copy - 副本_FooCount\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nGhost function that counts even numbers in a sequence up to index hi.\nTranslated from Dafny's Count function.\n-/\n\n/- \nMain method specification translated from Dafny's FooCount method.\n-/", "vc-preamble": "def Count (hi : Nat) (s : Array Int) : Int :=\nif hi = 0 then 0\nelse if s[(hi-1)]! % 2 = 0 then 1 + Count (hi-1) s\nelse Count (hi-1) s", "vc-helpers": "", "vc-definitions": "def FooCount (CountIndex : Nat) (a : Array Int) (b : Array Int) : Nat :=\nsorry", "vc-theorems": "theorem FooCount_spec (CountIndex : Nat) (a b : Array Int) :\n(CountIndex = 0 ∨ (a.size = b.size ∧ 1 ≤ CountIndex ∧ CountIndex ≤ a.size)) →\nFooCount CountIndex a b = Count CountIndex a :=\nsorry", "vc-postamble": ""}
{"id": "Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_A2_Q1_trimmed_copy_-_副本_PreCompute", "vc-description": "/- \n{\n\"name\": \"Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_A2_Q1_trimmed copy - 副本_PreCompute\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_A2_Q1_trimmed copy - 副本_PreCompute\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Count function that counts even numbers in a sequence up to index hi -/\n\n/-  Specification for Count function -/\n\n/-  ComputeCount method that computes count up to an index -/\n\n/-  Specification for ComputeCount method -/\n\n/-  PreCompute method that precomputes counts -/\n\n/-  Specification for PreCompute method -/", "vc-preamble": "def Count (hi : Nat) (s : Array Int) : Int :=\nif hi = 0 then 0\nelse if s[(hi-1)]! % 2 = 0 then 1 + Count (hi-1) s\nelse Count (hi-1) s", "vc-helpers": "", "vc-definitions": "def ComputeCount (CountIndex : Nat) (a : Array Int) (b : Array Int) : Nat :=\nsorry\n\ndef PreCompute (a b : Array Int) : Nat :=\nsorry", "vc-theorems": "theorem Count_spec (hi : Nat) (s : Array Int) :\n0 ≤ hi ∧ hi ≤ s.size → Count hi s ≥ 0 :=\nsorry\n\ntheorem ComputeCount_spec (CountIndex : Nat) (a b : Array Int) :\n(CountIndex = 0 ∨ (a.size = b.size ∧ 1 ≤ CountIndex ∧ CountIndex ≤ a.size)) →\nComputeCount CountIndex a b = Count CountIndex a :=\nsorry\n\ntheorem PreCompute_spec (a b : Array Int) :\na.size = b.size →\n(b.size = 0 ∨ (a.size = b.size ∧ 1 ≤ b.size ∧ b.size ≤ a.size)) ∧\n∀ p, p = Count b.size a → p = Count b.size a :=\nsorry", "vc-postamble": ""}
{"id": "Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_week5_ComputePower_ComputePower", "vc-description": "/- \n{\n\"name\": \"Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_week5_ComputePower_ComputePower\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_week5_ComputePower_ComputePower\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nRecursive function that computes 2^n for natural numbers.\nTranslated from Dafny's Power function.\n-/\n\n/- \nMethod to calculate 2*n.\nTranslated from Dafny's CalcPower method.\n-/\n\n/- \nSpecification for CalcPower ensuring result equals 2*n\n-/\n\n/- \nMethod to compute 2^n using Power function.\nTranslated from Dafny's ComputePower method.\n-/\n\n/- \nSpecification for ComputePower ensuring result equals Power(n)\n-/", "vc-preamble": "def Power (n : Nat) : Nat :=\nif n = 0 then 1 else 2 * Power (n-1)", "vc-helpers": "", "vc-definitions": "def CalcPower (n : Nat) : Nat :=\nsorry\n\ndef ComputePower (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem CalcPower_spec (n : Nat) : CalcPower n = 2*n :=\nsorry\n\ntheorem ComputePower_spec (n : Nat) : ComputePower n = Power n :=\nsorry", "vc-postamble": ""}
{"id": "Dafny_Learning_Experience_tmp_tmpuxvcet_u_week8_12_a3_search_findPositionOfIndex_FindPositionOfElement", "vc-description": "/- \n{\n\"name\": \"Dafny_Learning_Experience_tmp_tmpuxvcet_u_week8_12_a3_search_findPositionOfIndex_FindPositionOfElement\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny_Learning_Experience_tmp_tmpuxvcet_u_week8_12_a3_search_findPositionOfIndex_FindPositionOfElement\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nFinds position of an element in an array.\nTranslated from Dafny method FindPositionOfElement.\n\nParameters:\n- a: Array of integers\n- Element: Natural number to search for\n- n1: Natural number representing array size\n- s1: Sequence of integers matching array prefix\n\nReturns:\n- Position: Integer position (-1 or ≥ 1)\n- Count: Natural number count\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def FindPositionOfElement (a : Array Int) (Element : Nat) (n1 : Nat) (s1 : Array Int) :\nInt × Nat :=\nsorry", "vc-theorems": "theorem FindPositionOfElement_spec\n(a : Array Int) (Element : Nat) (n1 : Nat) (s1 : Array Int) :\n(n1 = s1.size ∧ 0 ≤ n1 ∧ n1 ≤ a.size) →\n(∀ i, 0 ≤ i ∧ i < s1.size → a[i]! = s1[i]!) →\nlet (Position, Count) := FindPositionOfElement a Element n1 s1\n(Position = -1 ∨ Position ≥ 1) ∧\n(s1.size ≠ 0 ∧ Position ≥ 1 → ∃ i, 0 ≤ i ∧ i < s1.size ∧ s1[i]! = Element) :=\nsorry", "vc-postamble": ""}
{"id": "Dafny_ProgrammingLanguages_tmp_tmp82_e0kji_ExtraCredit_optimizeCorrect", "vc-description": "/- \n{\n\"name\": \"Dafny_ProgrammingLanguages_tmp_tmp82_e0kji_ExtraCredit_optimizeCorrect\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny_ProgrammingLanguages_tmp_tmp82_e0kji_ExtraCredit_optimizeCorrect\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Expression datatype representing arithmetic expressions -/\n\n/-  Evaluates an expression given a store mapping variables to values -/\n\n/-  Optimizes an arithmetic expression by applying simplification rules -/\n\n/-  Theorem stating that optimize preserves expression evaluation -/", "vc-preamble": "inductive Exp where\n| Const : Int → Exp\n| Var : String → Exp\n| Plus : Exp → Exp → Exp\n| Mult : Exp → Exp → Exp\nderiving Repr\n\ndef eval (e : Exp) (store : String → Int) : Int :=\nmatch e with\n| Exp.Const n => n\n| Exp.Var s => store s\n| Exp.Plus e1 e2 => eval e1 store + eval e2 store\n| Exp.Mult e1 e2 => eval e1 store * eval e2 store\n\ndef optimize (e : Exp) : Exp :=\nmatch e with\n| Exp.Mult (Exp.Const 0) _ => Exp.Const 0\n| Exp.Mult _ (Exp.Const 0) => Exp.Const 0\n| Exp.Mult (Exp.Const 1) e => e\n| Exp.Mult e (Exp.Const 1) => e\n| Exp.Mult (Exp.Const n1) (Exp.Const n2) => Exp.Const (n1 * n2)\n| Exp.Plus (Exp.Const 0) e => e\n| Exp.Plus e (Exp.Const 0) => e\n| Exp.Plus (Exp.Const n1) (Exp.Const n2) => Exp.Const (n1 + n2)\n| e => e", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "theorem optimizeCorrect (e : Exp) (s : String → Int) :\neval e s = eval (optimize e) s :=\nsorry", "vc-postamble": ""}
{"id": "Dafny_Programs_tmp_tmp99966ew4_binary_search_BinarySearch", "vc-description": "/- \n{\n\"name\": \"Dafny_Programs_tmp_tmp99966ew4_binary_search_BinarySearch\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny_Programs_tmp_tmp99966ew4_binary_search_BinarySearch\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nPredicate indicating whether an array is sorted in ascending order.\nTranslated from Dafny's sorted predicate.\n-/\n\n/- \nBinary search implementation specification.\nTranslated from Dafny's BinarySearch method.\n\n@param a The sorted array to search in\n@param value The value to search for\n@return index The index where value was found, or -1 if not found\n-/", "vc-preamble": "def sorted (a : Array Int) : Prop :=\n∀ j k, 0 ≤ j → j < k → k < a.size → a[j]! ≤ a[k]!", "vc-helpers": "", "vc-definitions": "def BinarySearch (a : Array Int) (value : Int) : Int :=\nsorry", "vc-theorems": "theorem BinarySearch_spec (a : Array Int) (value : Int) :\nsorted a →\nlet index := BinarySearch a value\n(0 ≤ index → index < a.size ∧ a[index.toNat]! = value) ∧\n(index < 0 → ∀ k, 0 ≤ k → k < a.size → a[k]! ≠ value) :=\nsorry", "vc-postamble": ""}
{"id": "Dafny_Programs_tmp_tmp99966ew4_lemma_FindZero", "vc-description": "/- \n{\n\"name\": \"Dafny_Programs_tmp_tmp99966ew4_lemma_FindZero\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny_Programs_tmp_tmp99966ew4_lemma_FindZero\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nFindZero method translated from Dafny.\nTakes an array of integers and returns an index where zero is found.\n\nRequirements:\n- Array must not be null\n- All elements must be non-negative\n- Array must be monotonically increasing with max step of 1\n\nEnsures:\n- If returned index is negative, array contains no zeros\n- If returned index is non-negative, it points to a zero element\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def FindZero (a : Array Int) : Int :=\nsorry", "vc-theorems": "theorem FindZero_spec (a : Array Int) :\n(∀ i : Nat, i < a.size → 0 ≤ a[i]!) →\n(∀ i : Nat, 0 < i ∧ i < a.size → (a[i]!) - 1 ≤ a[i]!) →\nlet index := FindZero a\n(index < 0 → (∀ i : Nat, i < a.size → a[i]! ≠ 0)) ∧\n(0 ≤ index → index < a.size ∧ a[index.toNat]! = 0) :=\nsorry", "vc-postamble": ""}
{"id": "Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_normal_data_completion_MaxPerdV2_max", "vc-description": "/- \n{\n\"name\": \"Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_normal_data_completion_MaxPerdV2_max\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_normal_data_completion_MaxPerdV2_max\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Contains checks if value v exists in array a up to index n -/\n\n/-  Upper bound checks if v is greater than or equal to all elements in array a up to index n -/\n\n/-  Is max checks if m is both contained in array a and is an upper bound for all elements up to n -/\n\n/-  Max function specification -/", "vc-preamble": "def contains (v : Int) (a : Array Int) (n : Nat) : Prop :=\n∃ j, 0 ≤ j ∧ j < n ∧ a[j]! = v\ndef upper_bound (v : Int) (a : Array Int) (n : Nat) : Prop :=\n∀ j, 0 ≤ j ∧ j < n → a[j]! ≤ v\ndef is_max (m : Int) (a : Array Int) (n : Nat) : Prop :=\ncontains m a n ∧ upper_bound m a n", "vc-helpers": "", "vc-definitions": "def max (a : Array Int) (n : Nat) : Int :=\nsorry", "vc-theorems": "theorem max_spec (a : Array Int) (n : Nat) :\n0 < n ∧ n ≤ a.size →\nis_max (max a n) a n :=\nsorry", "vc-postamble": ""}
{"id": "Dafny_Verify_tmp_tmphq7j0row_Generated_Code_ComputePower_ComputePower", "vc-description": "/- \n{\n\"name\": \"Dafny_Verify_tmp_tmphq7j0row_Generated_Code_ComputePower_ComputePower\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny_Verify_tmp_tmphq7j0row_Generated_Code_ComputePower_ComputePower\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nRecursive function that computes 2^n for natural number n\n-/\n\n/- \nMethod that computes 2^n for natural number n\n-/", "vc-preamble": "def Power (n : Nat) : Nat :=\nif n = 0 then 1 else 2 * Power (n - 1)", "vc-helpers": "", "vc-definitions": "def ComputePower (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem ComputePower_spec (n : Nat) :\nComputePower n = Power n :=\nsorry", "vc-postamble": ""}
{"id": "Dafny_Verify_tmp_tmphq7j0row_Generated_Code_Count_count", "vc-description": "/- \n{\n\"name\": \"Dafny_Verify_tmp_tmphq7j0row_Generated_Code_Count_count\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny_Verify_tmp_tmphq7j0row_Generated_Code_Count_count\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nRecursively counts occurrences of value v in array a up to index n.\nTranslated from Dafny function has_count.\n-/\n\n/- \nReturns count of occurrences of v in array a up to index n.\nTranslated from Dafny method count.\n-/", "vc-preamble": "partial def has_count (v : Int) (a : Array Int) (n : Int) : Int :=\nif n == 0 then 0\nelse if a[(n-1).toNat]! == v\nthen has_count v a (n-1) + 1\nelse has_count v a (n-1)", "vc-helpers": "", "vc-definitions": "def count (v : Int) (a : Array Int) (n : Int) : Int :=\nsorry", "vc-theorems": "theorem count_spec (v : Int) (a : Array Int) (n : Int) :\nn ≥ 0 ∧ n ≤ a.size →\ncount v a n = has_count v a n :=\nsorry", "vc-postamble": ""}
{"id": "Dafny_Verify_tmp_tmphq7j0row_dataset_bql_exampls_SmallNum_add_small_numbers", "vc-description": "/- \n{\n\"name\": \"Dafny_Verify_tmp_tmphq7j0row_dataset_bql_exampls_SmallNum_add_small_numbers\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny_Verify_tmp_tmphq7j0row_dataset_bql_exampls_SmallNum_add_small_numbers\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nTranslates the Dafny method add_small_numbers which adds numbers from an array up to index n,\nwhere each number is bounded by max.\n\n@param a The input array of integers\n@param n The number of elements to process\n@param max The maximum value allowed in the array\n@return The sum of the first n elements\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def add_small_numbers (a : Array Int) (n : Int) (max : Int) : Int :=\nsorry", "vc-theorems": "theorem add_small_numbers_spec (a : Array Int) (n : Int) (max : Int) (r : Int) :\nn > 0 ∧\nn ≤ a.size ∧\n(∀ i : Nat, i < n → a[i]! ≤ max) →\nr ≤ max * n :=\nsorry", "vc-postamble": ""}
{"id": "Dafny_Verify_tmp_tmphq7j0row_dataset_detailed_examples_SelectionSort_SelectionSort", "vc-description": "/- \n{\n\"name\": \"Dafny_Verify_tmp_tmphq7j0row_dataset_detailed_examples_SelectionSort_SelectionSort\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny_Verify_tmp_tmphq7j0row_dataset_detailed_examples_SelectionSort_SelectionSort\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nSelectionSort implementation that sorts an array in ascending order.\nWorks by dividing the input list into two parts: sorted and unsorted.\nAt the beginning, the sorted part is empty and the unsorted part contains all elements.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def SelectionSort (a : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem SelectionSort_spec (a : Array Int) :\nlet result := SelectionSort a\n\n-- Array is sorted in ascending order\n\n(∀ i j, 0 ≤ i → i < j → j < result.size → result[i]! ≤ result[j]!) ∧\n\n-- Array contains same elements (using multiset equality)\n\n(result.toList = a.toList)\n\n:=\nsorry", "vc-postamble": ""}
{"id": "Dafny_tmp_tmp0wu8wmfr_Heimaverkefni_1_LinearSearch_SearchLoop", "vc-description": "/- \n{\n\"name\": \"Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 1_LinearSearch_SearchLoop\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 1_LinearSearch_SearchLoop\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nSearchLoop method translated from Dafny.\nTakes an array `a`, indices `i` and `j`, and value `x` to search for.\nReturns index `k` where `x` is found or -1 if not found.\n\nOriginal Dafny requires/ensures:\n- requires 0 ≤ i ≤ j ≤ |a|\n- ensures i ≤ k < j ∨ k = -1\n- ensures k ≠ -1 → a = x\n- ensures k ≠ -1 → ∀r, k < r < j → a ≠ x\n- ensures k = -1 → ∀r, i ≤ r < j → a ≠ x\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def SearchLoop (a : Array Int) (i j x : Int) : Int :=\nsorry", "vc-theorems": "theorem SearchLoop_spec (a : Array Int) (i j x : Int) :\n(0 ≤ i ∧ i ≤ j ∧ j ≤ a.size) →\nlet k := SearchLoop a i j x\n(i ≤ k ∧ k < j ∨ k = -1) ∧\n(k ≠ -1 → a[k.toNat]! = x) ∧\n(k ≠ -1 → ∀ r, k < r ∧ r < j → a[r.toNat]! ≠ x) ∧\n(k = -1 → ∀ r, i ≤ r ∧ r < j → a[r.toNat]! ≠ x) :=\nsorry", "vc-postamble": ""}
{"id": "Dafny_tmp_tmp0wu8wmfr_Heimaverkefni_1_LinearSearch_SearchRecursive", "vc-description": "/- \n{\n\"name\": \"Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 1_LinearSearch_SearchRecursive\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 1_LinearSearch_SearchRecursive\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nSearchRecursive performs a recursive linear search on an array segment.\n\n@param a The array to search in\n@param i The start index of the search range\n@param j The end index (exclusive) of the search range\n@param x The value to search for\n@return k The index where x was found, or -1 if not found\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def SearchRecursive (a : Array Int) (i : Int) (j : Int) (x : Int) : Int :=\nsorry", "vc-theorems": "theorem SearchRecursive_spec (a : Array Int) (i j x k : Int) :\n(0 ≤ i ∧ i ≤ j ∧ j ≤ a.size) →\nlet k := SearchRecursive a i j x;\n((i ≤ k ∧ k < j) ∨ k = -1) ∧\n(k ≠ -1 → a[k.toNat]! = x) ∧\n(k ≠ -1 → ∀ r, k < r ∧ r < j → a[r.toNat]! ≠ x) ∧\n(k = -1 → ∀ r, i ≤ r ∧ r < j → a[r.toNat]! ≠ x) :=\nsorry", "vc-postamble": ""}
{"id": "Dafny_tmp_tmp0wu8wmfr_Heimaverkefni_2_BinarySearchDec_SearchRecursive", "vc-description": "/- \n{\n\"name\": \"Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 2_BinarySearchDec_SearchRecursive\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 2_BinarySearchDec_SearchRecursive\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nSearchRecursive performs a binary search on a decreasing sorted array.\n\n@param a The array to search in\n@param i The lower bound index\n@param j The upper bound index\n@param x The value to search for\n@return k The index where x should be inserted\n\nRequirements:\n- i and j must be valid array bounds: 0 ≤ i ≤ j ≤ a.size\n- Array must be decreasing sorted between i and j\n\nEnsures:\n- Result k is between i and j\n- All elements before k are ≥ x\n- All elements after k are < x\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def SearchRecursive (a : Array Float) (i j : Int) (x : Float) : Int :=\nsorry", "vc-theorems": "theorem SearchRecursive_spec\n(a : Array Float) (i j : Int) (x : Float) :\n(0 ≤ i ∧ i ≤ j ∧ j ≤ a.size) →\n(∀ p q, i ≤ p ∧ p < q ∧ q < j → a[p.toNat]! ≥ a[q.toNat]!) →\nlet k := SearchRecursive a i j x\ni ≤ k ∧ k ≤ j ∧\n(∀ r, i ≤ r ∧ r < k → a[r.toNat]! ≥ x) ∧\n(∀ r, k ≤ r ∧ r < j → a[r.toNat]! < x) :=\nsorry", "vc-postamble": ""}
{"id": "Dafny_tmp_tmp0wu8wmfr_Heimaverkefni_3_InsertionSortMultiset_Search", "vc-description": "/- \n{\n\"name\": \"Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 3_InsertionSortMultiset_Search\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 3_InsertionSortMultiset_Search\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nSearch method that finds insertion point for value x in sorted array s.\nTranslated from Dafny specification.\n\n@param s The sorted input array\n@param x The value to find insertion point for\n@return k The insertion point index\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Search (s : Array Int) (x : Int) : Int :=\nsorry", "vc-theorems": "theorem Search_spec (s : Array Int) (x : Int) (k : Int) :\n(∀ p q, 0 ≤ p → p < q → q < s.size → s[p]! ≤ s[q]!) →\n(k = Search s x) →\n(0 ≤ k ∧ k ≤ s.size) ∧\n(∀ i, 0 ≤ i → i < k → s[i.toNat]! ≤ x) ∧\n(∀ i, k ≤ i → i < s.size → s[i.toNat]! ≥ x) :=\nsorry", "vc-postamble": ""}
{"id": "Dafny_tmp_tmp0wu8wmfr_Heimaverkefni_3_InsertionSortMultiset_Sort", "vc-description": "/- \n{\n\"name\": \"Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 3_InsertionSortMultiset_Sort\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 3_InsertionSortMultiset_Sort\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nSearch function that finds insertion point in sorted array.\nTranslated from Dafny's Search method.\n-/\n\n/- \nSort function that sorts a list into a sorted array.\nTranslated from Dafny's Sort method.\n-/\n\n/- \nSpecification for Search function ensuring sorted result and proper element placement\n-/\n\n/- \nSpecification for Sort function ensuring list equality and sorted result\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Search (s : Array Int) (x : Int) : Int :=\nsorry\n\ndef sort (m : List Int) : Array Int :=\nsorry", "vc-theorems": "theorem Search_spec (s : Array Int) (x : Int) (k : Int) :\n(∀ p q : Nat, p < q ∧ q < s.size → s[p]! ≤ s[q]!) →\n(0 ≤ k ∧ k ≤ s.size) ∧\n(∀ i : Nat, i < k.toNat → s[i]! ≤ x) ∧\n(∀ i : Nat, k.toNat ≤ i ∧ i < s.size → s[i]! ≥ x) :=\nsorry\n\ntheorem Sort_spec (m : List Int) (r : Array Int) :\n(∀ x : Int, x ∈ m → (∃ i : Nat, i < r.size ∧ r[i]! = x)) ∧\n(∀ i : Nat, i < r.size → r[i]! ∈ m) ∧\n(∀ p q : Nat, p < q ∧ q < r.size → r[p]! ≤ r[q]!) :=\nsorry", "vc-postamble": ""}
{"id": "Dafny_tmp_tmp0wu8wmfr_Heimaverkefni_3_SelectionSortMultiset_Sort", "vc-description": "/- \n{\n\"name\": \"Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 3_SelectionSortMultiset_Sort\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 3_SelectionSortMultiset_Sort\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nFinds the minimum value in a list of integers.\nTranslated from Dafny's MinOfMultiset method.\n-/\n\n/- \nSpecification for MinOfMultiset ensuring the result is in the list\nand is the minimum value.\n-/\n\n/- \nSorts a list of integers into an array.\nTranslated from Dafny's Sort method.\n-/\n\n/- \nSpecification for Sort ensuring the output array contains the same elements\nas the input list and is sorted in ascending order.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def MinOfMultiset (m : List Int) : Int :=\nsorry\n\ndef sortList (m : List Int) : Array Int :=\nsorry", "vc-theorems": "theorem MinOfMultiset_spec (m : List Int) :\nlet min := MinOfMultiset m\n(min ∈ m) ∧\n(∀ z, z ∈ m → min ≤ z) :=\nsorry\n\ntheorem Sort_spec (m : List Int) :\nlet s := sortList m\n(∀ x : Int, x ∈ m → (∃ i : Nat, i < s.size ∧ s[i]! = x)) ∧\n(∀ i : Nat, i < s.size → s[i]! ∈ m) ∧\n(∀ p q : Nat, p < q ∧ q < s.size → s[p]! ≤ s[q]!) :=\nsorry", "vc-postamble": ""}
{"id": "Dafny_tmp_tmp0wu8wmfr_Heimaverkefni_8_H8_Partition", "vc-description": "/- \n{\n\"name\": \"Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 8_H8_Partition\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 8_H8_Partition\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nTranslates the Dafny Partition method which takes a multiset of integers and partitions it into\nthree parts: elements less than or equal to a pivot, the pivot itself, and elements greater than\nor equal to the pivot.\n\n@param m The input multiset of integers\n@return (pre, p, post) where:\n- pre contains elements ≤ p\n- p is the pivot element from m\n- post contains elements ≥ p\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Partition (m : Array Int) :\nm.size > 0 → (Array Int × Int × Array Int) :=\nsorry", "vc-theorems": "theorem Partition_spec (m : Array Int) (h : m.size > 0) :\nlet (pre, p, post) := Partition m h\n\n-- Ensures p is in original array\n\n(∃ i : Nat, i < m.size ∧ m[i]! = p) ∧\n\n-- Ensures all elements from original array appear in the result\n\n(∀ x : Int, (∃ i : Nat, i < m.size ∧ m[i]! = x) →\n\n(∃ j : Nat, j < pre.size ∧ pre[j]! = x) ∨\n\nx = p ∨\n\n(∃ k : Nat, k < post.size ∧ post[k]! = x)) ∧\n\n-- Ensures pre elements are ≤ p\n\n(∀ i : Nat, i < pre.size → pre[i]! ≤ p) ∧\n\n-- Ensures post elements are ≥ p\n\n(∀ i : Nat, i < post.size → post[i]! ≥ p) :=\nsorry", "vc-postamble": ""}
{"id": "Dafny_tmp_tmp0wu8wmfr_tests_F1a_Mid", "vc-description": "/- \n{\n\"name\": \"Dafny_tmp_tmp0wu8wmfr_tests_F1a_Mid\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny_tmp_tmp0wu8wmfr_tests_F1a_Mid\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nTranslates the Dafny Mid method which finds a middle point between two integers.\nThe method takes two integers p and q where p ≤ q and returns a middle point m\nthat satisfies specific constraints about its position between p and q.\n\n@param p The lower bound integer\n@param q The upper bound integer\n@return m A middle point between p and q satisfying the specified constraints\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Mid (p q : Int) : Int :=\nsorry", "vc-theorems": "theorem Mid_spec (p q : Int) :\np ≤ q →\nlet m := Mid p q\n(p ≤ m ∧ m ≤ q) ∧\n(m - p ≤ q - m) ∧\n(0 ≤ (q - m) - (m - p) ∧ (q - m) - (m - p) ≤ 1) :=\nsorry", "vc-postamble": ""}
{"id": "Dafny_tmp_tmp0wu8wmfr_tests_InsertionSortSeq_InsertionSort", "vc-description": "/- \n{\n\"name\": \"Dafny_tmp_tmp0wu8wmfr_tests_InsertionSortSeq_InsertionSort\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny_tmp_tmp0wu8wmfr_tests_InsertionSortSeq_InsertionSort\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate indicating if an array is sorted in ascending order -/\n\n/-  InsertionSort function that sorts an array of integers\nReturns a sorted array containing the same elements as the input -/", "vc-preamble": "def IsSorted (s : Array Int) : Prop :=\n∀ p q, 0 ≤ p → p < q → q < s.size → s[p]! ≤ s[q]!", "vc-helpers": "", "vc-definitions": "def InsertionSort (s : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem InsertionSort_spec (s : Array Int) :\nlet r := InsertionSort s\n(r = s) ∧ IsSorted r :=\nsorry", "vc-postamble": ""}
{"id": "Dafny_tmp_tmp0wu8wmfr_tests_Search1000_Search1000", "vc-description": "/- \n{\n\"name\": \"Dafny_tmp_tmp0wu8wmfr_tests_Search1000_Search1000\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny_tmp_tmp0wu8wmfr_tests_Search1000_Search1000\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nIs2Pow(n) is true iff n==2^k for some k>=0.\nTranslated from Dafny predicate.\n-/\n\n/- \nBinary search implementation that works for array segments of size n == 2^k-1.\nTranslated from Dafny method Search1000.\n-/", "vc-preamble": "partial def Is2Pow (n : Int) : Bool :=\nif n < 1 then\nfalse\nelse if n == 1 then\ntrue\nelse\nn % 2 == 0 ∧ Is2Pow (n/2)", "vc-helpers": "", "vc-definitions": "def Search1000 (a : Array Int) (x : Int) : Int :=\nsorry", "vc-theorems": "theorem Search1000_spec (a : Array Int) (x : Int) (k : Int) :\na.size ≥ 1000 ∧\n(∀ p q, 0 ≤ p ∧ p < q ∧ q < 1000 → a[p]! ≤ a[q]!) →\n(0 ≤ k ∧ k ≤ 1000) ∧\n(∀ r, 0 ≤ r ∧ r < k → a[r.toNat]! < x) ∧\n(∀ r, k ≤ r ∧ r < 1000 → a[r.toNat]! ≥ x) :=\nsorry", "vc-postamble": ""}
{"id": "Dafny_tmp_tmp0wu8wmfr_tests_Search1000_Search2PowLoop", "vc-description": "/- \n{\n\"name\": \"Dafny_tmp_tmp0wu8wmfr_tests_Search1000_Search2PowLoop\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny_tmp_tmp0wu8wmfr_tests_Search1000_Search2PowLoop\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nIs2Pow(n) is true iff n==2^k for some k>=0.\nTranslated from Dafny predicate.\n-/\n\n/- \nSearch2PowLoop performs binary search on a sorted array segment.\nOnly works for array segments of size n == 2^k-1 for some k>=0.\nTranslated from Dafny method.\n-/", "vc-preamble": "partial def Is2Pow (n : Int) : Bool :=\nif n < 1 then\nfalse\nelse if n == 1 then\ntrue\nelse\nn % 2 == 0 ∧ Is2Pow (n/2)", "vc-helpers": "", "vc-definitions": "def Search2PowLoop (a : Array Int) (i : Int) (n : Int) (x : Int) : Int :=\nsorry", "vc-theorems": "theorem Search2PowLoop_spec\n(a : Array Int) (i : Int) (n : Int) (x : Int) :\n(0 ≤ i) →\n(i + n ≤ a.size) →\n(∀ p q, i ≤ p → p < q → q < i + n → a[p.toNat]! ≤ a[q.toNat]!) →\nIs2Pow (n + 1) →\nlet k := Search2PowLoop a i n x\ni ≤ k ∧ k ≤ i + n ∧\n(∀ r, i ≤ r → r < k → a[r.toNat]! < x) ∧\n(∀ r, k ≤ r → r < i + n → a[r.toNat]! ≥ x) :=\nsorry", "vc-postamble": ""}
{"id": "Dafny_tmp_tmp0wu8wmfr_tests_Search1000_Search2PowRecursive", "vc-description": "/- \n{\n\"name\": \"Dafny_tmp_tmp0wu8wmfr_tests_Search1000_Search2PowRecursive\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny_tmp_tmp0wu8wmfr_tests_Search1000_Search2PowRecursive\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Is2Pow(n) is true iff n==2^k for some k>=0 -/\n\n/-  Search2PowRecursive performs binary search on array segments of size n = 2^k-1 -/", "vc-preamble": "partial def Is2Pow (n : Int) : Bool :=\nif n < 1 then\nfalse\nelse if n == 1 then\ntrue\nelse\nn % 2 == 0 ∧ Is2Pow (n/2)", "vc-helpers": "", "vc-definitions": "def Search2PowRecursive (a : Array Int) (i : Int) (n : Int) (x : Int) : Int :=\nsorry", "vc-theorems": "theorem Search2PowRecursive_spec\n(a : Array Int) (i : Int) (n : Int) (x : Int) :\n0 ≤ i →\ni + n ≤ a.size →\n(∀ p q, i ≤ p → p < q → q < i + n → a[p.toNat]! ≤ a[q.toNat]!) →\nIs2Pow (n + 1) →\nlet k := Search2PowRecursive a i n x;\ni ≤ k ∧ k ≤ i + n ∧\n(∀ r, i ≤ r → r < k → a[r.toNat]! < x) ∧\n(∀ r, k ≤ r → r < i + n → a[r.toNat]! ≥ x) :=\nsorry", "vc-postamble": ""}
{"id": "Dafny_tmp_tmp0wu8wmfr_tests_SumIntsLoop_SumIntsLoop", "vc-description": "/- \n{\n\"name\": \"Dafny_tmp_tmp0wu8wmfr_tests_SumIntsLoop_SumIntsLoop\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny_tmp_tmp0wu8wmfr_tests_SumIntsLoop_SumIntsLoop\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nRecursive function that computes sum of integers from 1 to n.\nTranslated from Dafny's sumInts function.\n-/\n\n/- \nSpecification for sumInts function requiring non-negative input\n-/\n\n/- \nMethod that computes sum of integers from 1 to n using a loop.\nTranslated from Dafny's SumIntsLoop method.\n-/\n\n/- \nSpecification for SumIntsLoop method ensuring it matches sumInts\nand computes the arithmetic series sum correctly\n-/", "vc-preamble": "partial def sumInts (n : Int) : Int :=\nif n == 0 then 0\nelse sumInts (n-1) + n", "vc-helpers": "", "vc-definitions": "def SumIntsLoop (n : Int) : Int :=\nsorry", "vc-theorems": "theorem sumInts_spec (n : Int) :\nn ≥ 0 → sumInts n = n * (n + 1) / 2 :=\nsorry\n\ntheorem SumIntsLoop_spec (n : Int) :\nn ≥ 0 →\nlet s := SumIntsLoop n\ns = sumInts n ∧ s = n * (n + 1) / 2 :=\nsorry", "vc-postamble": ""}
{"id": "Dafny_tmp_tmpj88zq5zt_2-Kontrakte_max_max", "vc-description": "/- \n{\n\"name\": \"Dafny_tmp_tmpj88zq5zt_2-Kontrakte_max_max\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny_tmp_tmpj88zq5zt_2-Kontrakte_max_max\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nTranslation of Dafny method max that returns maximum of two array elements.\nPreserves the specification that:\n- Input indices must be valid array indices\n- Output is the larger of the two array elements at given indices\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def max (a : Array Int) (b : Array Int) (i : Nat) (j : Nat) : Int :=\nsorry", "vc-theorems": "theorem max_spec (a : Array Int) (b : Array Int) (i : Nat) (j : Nat) (m : Int) :\n(0 ≤ i ∧ i < a.size) →\n(0 ≤ j ∧ j < b.size) →\n((a[i]! > b[j]! → m = a[i]!) ∧\n(a[i]! ≤ b[j]! → m = b[j]!)) :=\nsorry", "vc-postamble": ""}
{"id": "Dafny_tmp_tmpj88zq5zt_2-Kontrakte_reverse3_swap3", "vc-description": "/- \n{\n\"name\": \"Dafny_tmp_tmpj88zq5zt_2-Kontrakte_reverse3_swap3\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny_tmp_tmpj88zq5zt_2-Kontrakte_reverse3_swap3\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nSwaps three elements in an array at positions h, i, and j.\nThe elements are swapped in a cyclic manner: i -> h -> j -> i\n\n@param a The array to modify\n@param h First index\n@param i Second index\n@param j Third index\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def swap3 (a : Array Int) (h i j : Nat) : Array Int :=\nsorry", "vc-theorems": "theorem swap3_spec (a : Array Int) (h i j : Nat) :\n0 ≤ h ∧ h < a.size ∧\n0 ≤ i ∧ i < a.size ∧\n0 ≤ j ∧ j < a.size ∧\ni ≠ j ∧ j ≠ h ∧ h ≠ i →\nlet a' := swap3 a h i j\n(a'[h]! = a[i]!) ∧\n(a'[j]! = a[h]!) ∧\n(a'[i]! = a[j]!) ∧\n(∀ k, 0 ≤ k ∧ k < a.size ∧ k ≠ h ∧ k ≠ i ∧ k ≠ j → a'[k]! = a[k]!) :=\nsorry", "vc-postamble": ""}
{"id": "Dafny_tmp_tmpmvs2dmry_examples2_Product", "vc-description": "/- \n{\n\"name\": \"Dafny_tmp_tmpmvs2dmry_examples2_Product\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny_tmp_tmpmvs2dmry_examples2_Product\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Translation of Dafny gcd function with requirements m > 0 and n > 0 -/\n\n/-  Specification for gcd function -/\n\n/-  Translation of Dafny exp function for real numbers and natural exponents -/\n\n/-  Translation of Dafny Product method -/\n\n/-  Specification for Product method ensuring result equals m * n -/", "vc-preamble": "partial def gcd (m n : Nat) : Nat :=\nif m = n then n\nelse if m > n then gcd (m - n) n\nelse gcd m (n - m)\n\ndef exp (x : Float) (n : Nat) : Float :=\nif n = 0 then 1.0\nelse if x == 0.0 then 0.0\nelse if n = 0 ∧ x == 0.0 then 1.0\nelse x * exp x (n - 1)", "vc-helpers": "", "vc-definitions": "def Product (m n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem gcd_spec (m n : Nat) :\nm > 0 ∧ n > 0 → gcd m n > 0 :=\nsorry\n\ntheorem Product_spec (m n : Nat) :\nProduct m n = m * n :=\nsorry", "vc-postamble": ""}
{"id": "Dafny_tmp_tmpmvs2dmry_examples2_exp_by_sqr", "vc-description": "/- \n{\n\"name\": \"Dafny_tmp_tmpmvs2dmry_examples2_exp_by_sqr\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny_tmp_tmpmvs2dmry_examples2_exp_by_sqr\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Translation of Dafny gcd function -/\n\n/-  Specification for gcd function -/\n\n/-  Translation of Dafny exp function -/\n\n/-  Translation of Dafny exp_by_sqr method -/\n\n/-  Specification for exp_by_sqr method -/", "vc-preamble": "partial def gcd (m n : Nat) : Nat :=\nif m = n then n\nelse if m > n then gcd (m - n) n\nelse gcd m (n - m)\n\ndef exp (x : Float) (n : Nat) : Float :=\nif n = 0 then 1.0\nelse if x == 0.0 then 0.0\nelse if n = 0 ∧ x == 0.0 then 1.0\nelse x * exp x (n - 1)", "vc-helpers": "", "vc-definitions": "def exp_by_sqr (x0 : Float) (n0 : Nat) : Float :=\nsorry", "vc-theorems": "theorem gcd_spec (m n : Nat) :\nm > 0 ∧ n > 0 → gcd m n > 0 :=\nsorry\n\ntheorem exp_by_sqr_spec (x0 : Float) (n0 : Nat) :\nx0 ≥ 0.0 → exp_by_sqr x0 n0 = exp x0 n0 :=\nsorry", "vc-postamble": ""}
{"id": "Dafny_tmp_tmpmvs2dmry_examples2_gcdCalc", "vc-description": "/- \n{\n\"name\": \"Dafny_tmp_tmpmvs2dmry_examples2_gcdCalc\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny_tmp_tmpmvs2dmry_examples2_gcdCalc\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nRecursive GCD function translated from Dafny.\nRequires both inputs to be positive natural numbers.\n-/\n\n/-  Specification for gcd function -/\n\n/- \nExponential function translated from Dafny.\nTakes a real number x and natural number n as input.\n-/\n\n/-  Specification for exp function -/\n\n/- \nGCD calculation method translated from Dafny.\nTakes two positive natural numbers and returns their GCD.\n-/\n\n/-  Specification for gcdCalc method -/", "vc-preamble": "partial def gcd (m n : Nat) : Nat :=\nif m = n then n\nelse if m > n then gcd (m - n) n\nelse gcd m (n - m)\n\ndef exp (x : Float) (n : Nat) : Float :=\nif n = 0 then 1.0\nelse if x == 0.0 then 0.0\nelse if n = 0 ∧ x == 0.0 then 1.0\nelse x * exp x (n - 1)", "vc-helpers": "", "vc-definitions": "def gcdCalc (m n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem gcd_spec (m n : Nat) :\nm > 0 ∧ n > 0 → gcd m n > 0 :=\nsorry\n\ntheorem exp_spec (x : Float) (n : Nat) :\nexp x n ≥ 0.0 :=\nsorry\n\ntheorem gcdCalc_spec (m n : Nat) :\nm > 0 ∧ n > 0 → gcdCalc m n = gcd m n :=\nsorry", "vc-postamble": ""}
{"id": "Dafny_tmp_tmpmvs2dmry_pancakesort_findmax_findMax", "vc-description": "/- \n{\n\"name\": \"Dafny_tmp_tmpmvs2dmry_pancakesort_findmax_findMax\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny_tmp_tmpmvs2dmry_pancakesort_findmax_findMax\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nFinds the index of the largest element in array `a` in range [0..n)\n\n@param a The input array\n@param n The upper bound of the range to search (exclusive)\n@return The index of the maximum element\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def findMax (a : Array Int) (n : Int) : Int :=\nsorry", "vc-theorems": "theorem findMax_spec (a : Array Int) (n : Int) :\na.size > 0 →\n0 < n ∧ n ≤ a.size →\nlet r := findMax a n\n0 ≤ r ∧ r < n ∧ n ≤ a.size ∧\n(∀ k, 0 ≤ k ∧ k < n ∧ n ≤ a.size → a[r.toNat]! ≥ a[k.toNat]!) :=\nsorry", "vc-postamble": ""}
{"id": "Dafny_tmp_tmpmvs2dmry_pancakesort_flip_flip", "vc-description": "/- \n{\n\"name\": \"Dafny_tmp_tmpmvs2dmry_pancakesort_flip_flip\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny_tmp_tmpmvs2dmry_pancakesort_flip_flip\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nFlips (reverses) array elements in the range\n\n@param a The array to flip elements in\n@param num The upper bound index of elements to flip\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def flip_ (a : Array Int) (num : Int) : Array Int :=\nsorry", "vc-theorems": "theorem flip_spec (a : Array Int) (num : Int) :\na.size > 0 →\n0 ≤ num →\nnum < a.size →\nlet a' := flip_ a num\n(∀ k, 0 ≤ k ∧ k ≤ num → a'[k.toNat]! = a[(num - k).toNat]!) ∧\n(∀ k, num < k ∧ k < a.size → a'[k.toNat]! = a[k.toNat]!) :=\nsorry", "vc-postamble": ""}
{"id": "Dafny_tmp_tmpv_d3qi10_2_min_minArray", "vc-description": "/- \n{\n\"name\": \"Dafny_tmp_tmpv_d3qi10_2_min_minArray\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny_tmp_tmpv_d3qi10_2_min_minArray\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Translation of Dafny min function -/\n\n/-  Specification for min function -/\n\n/-  Translation of Dafny minFunction (ghost function) -/\n\n/-  Specification for minFunction -/\n\n/-  Translation of Dafny minArray method -/\n\n/-  Specification for minArray -/", "vc-preamble": "def min_ (a b : Int) : Int :=\nif a < b then a else b\n\ndef minFunction (a b : Int) : Int :=\nif a < b then a else b", "vc-helpers": "", "vc-definitions": "def minArray (a : Array Int) : Int :=\nsorry", "vc-theorems": "theorem min_spec (a b : Int) :\n(min_ a b ≤ a ∧ min_ a b ≤ b) ∧\n(min_ a b = a ∨ min_ a b = b) :=\nsorry\n\ntheorem minFunction_spec (a b : Int) :\n(minFunction a b ≤ a ∧ minFunction a b ≤ b) ∧\n(minFunction a b = a ∨ minFunction a b = b) :=\nsorry\n\ntheorem minArray_spec (a : Array Int) :\na.size > 0 →\n(∀ k : Nat, k < a.size → minArray a ≤ a[k]!) ∧\n(∃ k : Nat, k < a.size ∧ minArray a = a[k]!) :=\nsorry", "vc-postamble": ""}
{"id": "Dafny_tmp_tmpv_d3qi10_3_cumsum_cumsum", "vc-description": "/- \n{\n\"name\": \"Dafny_tmp_tmpv_d3qi10_3_cumsum_cumsum\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Dafny_tmp_tmpv_d3qi10_3_cumsum_cumsum\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nRecursively computes sum of array elements up to index i.\nTranslated from Dafny function sum.\n-/\n\n/- \nSpecification for sum function requiring valid index\n-/\n\n/- \nCumulative sum method that fills array b with running sums of array a.\nTranslated from Dafny method cumsum.\n-/\n\n/- \nSpecification for cumsum method ensuring b contains running sums\n-/", "vc-preamble": "partial def sum (a : Array Int) (i : Nat) : Int :=\nif i == 0 then\na[0]!\nelse\na[i]! + sum a (i - 1)", "vc-helpers": "", "vc-definitions": "def cumsum (a b : Array Int) : Unit :=\nsorry", "vc-theorems": "theorem sum_spec (a : Array Int) (i : Nat) :\n0 ≤ i ∧ i < a.size → sum a i = a[i]! + (if i == 0 then 0 else sum a (i - 1)) :=\nsorry\n\ntheorem cumsum_spec (a b : Array Int) :\na.size == b.size ∧ a.size > 0 ∧ a ≠ b →\n(∀ i : Nat, i < a.size → b[i]! = sum a i) :=\nsorry", "vc-postamble": ""}
{"id": "Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Exercise3_Increment_Array_incrementArray", "vc-description": "/- \n{\n\"name\": \"Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Exercise3_Increment_Array_incrementArray\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Exercise3_Increment_Array_incrementArray\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nIncrements each element of an array by 1.\n\n@param a The array to increment\n@requires The array must have length > 0\n@ensures Each element is incremented by 1\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def incrementArray (a : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem incrementArray_spec (a : Array Int) :\na.size > 0 →\n∀ i, 0 ≤ i ∧ i < a.size →\n(incrementArray a)[i]! = a[i]!+1:=\nsorry", "vc-postamble": ""}
{"id": "Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Insertion_Sort_Normal_insertionSort", "vc-description": "/- \n{\n\"name\": \"Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Insertion_Sort_Normal_insertionSort\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Insertion_Sort_Normal_insertionSort\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Helper predicate for checking if array is sorted up to index i -/\n\n/-  Predicate indicating if an array is sorted -/\n\n/-  Look for minimum element in array starting from index i -/\n\n/-  Specification for lookForMin -/\n\n/-  Insertion sort implementation -/\n\n/-  Specification for insertionSort -/", "vc-preamble": "def sortedA (a : Array Int) (i : Nat) : Prop :=\n∀ k, 0 < k ∧ k < i → a[k-1]! ≤ a[k]!", "vc-helpers": "", "vc-definitions": "def sorted (a : Array Int) : Bool :=\nsorry\n\ndef lookForMin (a : Array Int) (i : Int) : Int :=\nsorry\n\ndef insertionSort (a : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem lookForMin_spec (a : Array Int) (i : Nat) :\n0 ≤ i ∧ i < a.size →\nlet m := lookForMin a i\ni ≤ m ∧ m < a.size ∧\n(∀ k, i ≤ k ∧ k < a.size → a[k]!  ≥ a[m.toNat]!) :=\nsorry\n\ntheorem insertionSort_spec (a : Array Int) :\nsorted (insertionSort a) :=\nsorry", "vc-postamble": ""}
{"id": "Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Insertion_Sort_Normal_lookForMin", "vc-description": "/- \n{\n\"name\": \"Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Insertion_Sort_Normal_lookForMin\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Insertion_Sort_Normal_lookForMin\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nlookForMin finds the minimum element's index in array a starting from index i\nRequires:\n- i is a valid index (0 ≤ i < a.size)\nEnsures:\n- returned index m is in range (i ≤ m < a.size)\n- a is minimum element in range [i..a.size)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def lookForMin (a : Array Int) (i : Nat) : Nat :=\nsorry", "vc-theorems": "theorem lookForMin_spec (a : Array Int) (i : Nat) :\n0 ≤ i ∧ i < a.size →\nlet m := lookForMin a i\ni ≤ m ∧ m < a.size ∧\n(∀ k, i ≤ k ∧ k < a.size → a[k]! ≥ a[m]!) :=\nsorry", "vc-postamble": ""}
{"id": "Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Insertion_Sorted_Standard_sorting", "vc-description": "/- \n{\n\"name\": \"Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Insertion_Sorted_Standard_sorting\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Insertion_Sorted_Standard_sorting\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nPredicate that checks if an array is sorted between left and right indices.\nTranslated from Dafny's InsertionSorted predicate.\n-/\n\n/- \nMain sorting method specification.\nTranslated from Dafny's sorting method.\n-/", "vc-preamble": "def InsertionSorted (arr : Array Int) (left : Nat) (right : Nat) : Prop :=\n0 ≤ left ∧ left ≤ right ∧ right ≤ arr.size ∧\n∀ i j, left ≤ i ∧ i < j ∧ j < right → arr[i]! ≤ arr[j]!", "vc-helpers": "", "vc-definitions": "def sorting (arr : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem sorting_spec (arr : Array Int) :\narr.size > 1 →\nInsertionSorted (sorting arr) 0 (sorting arr).size :=\nsorry", "vc-postamble": ""}
{"id": "Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Quick_Sort_quickSort", "vc-description": "/- \n{\n\"name\": \"Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Quick_Sort_quickSort\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Quick_Sort_quickSort\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  QuickSort implementation -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def quickSort (seq : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem quickSort_spec (seq : Array Int) :\nlet seq' := quickSort seq\nseq'.size = seq.size :=\nsorry", "vc-postamble": ""}
{"id": "Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Quick_Sort_threshold", "vc-description": "/- \n{\n\"name\": \"Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Quick_Sort_threshold\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Quick_Sort_threshold\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nthreshold method that partitions an array into two parts based on a threshold value\nReturns two arrays where:\n- All elements in first array are ≤ threshold\n- All elements in second array are ≥ threshold\n- Sum of sizes equals original size\n- Multiset of elements is preserved\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def threshold (thres : Int) (seq : Array Int) : Array Int × Array Int :=\nsorry", "vc-theorems": "theorem threshold_spec (thres : Int) (seq : Array Int) :\nlet (seq1, seq2) := threshold thres seq\n(∀ x, x ∈ seq1 → x ≤ thres) ∧\n(∀ x, x ∈ seq2 → x ≥ thres) ∧\n(seq1.size + seq2.size = seq.size) :=\nsorry", "vc-postamble": ""}
{"id": "Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Selection_Sort_Standard_selectionSorted", "vc-description": "/- \n{\n\"name\": \"Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Selection_Sort_Standard_selectionSorted\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Selection_Sort_Standard_selectionSorted\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nTranslation of Dafny selectionSorted method.\nThe method takes an array of integers and modifies it in place.\nThe specification ensures that the multiset of elements remains unchanged.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def selectionSorted (arr : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem selectionSorted_spec (arr : Array Int) :\nlet result := selectionSorted arr\nresult.toList = arr.toList :=\nsorry", "vc-postamble": ""}
{"id": "FlexWeek_tmp_tmpc_tfdj_3_ex4_join", "vc-description": "/- \n{\n\"name\": \"FlexWeek_tmp_tmpc_tfdj_3_ex4_join\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: FlexWeek_tmp_tmpc_tfdj_3_ex4_join\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nJoins two arrays into a single array.\nTranslated from Dafny method join.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def join (a : Array Int) (b : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem join_spec (a b : Array Int) :\nlet c := join a b\nc.size = a.size + b.size ∧\n(∀ i, 0 ≤ i ∧ i < a.size → c[i]! = a[i]!) ∧\n(∀ i j, a.size ≤ i ∧ i < c.size ∧\n0 ≤ j ∧ j < b.size ∧\ni - j = a.size → c[i]! = b[j]!) :=\nsorry", "vc-postamble": ""}
{"id": "FlexWeek_tmp_tmpc_tfdj_3_reverse_Reverse", "vc-description": "/- \n{\n\"name\": \"FlexWeek_tmp_tmpc_tfdj_3_reverse_Reverse\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: FlexWeek_tmp_tmpc_tfdj_3_reverse_Reverse\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nReverses an array of characters.\nInput array must not be empty.\nReturns a new array with elements in reverse order.\nOriginal array is not modified.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Reverse (a : Array Char) : Array Char :=\nsorry", "vc-theorems": "theorem reverse_spec (a : Array Char) :\na.size > 0 →\nlet b := Reverse a\n(b.size = a.size) ∧\n(∀ k, 0 ≤ k ∧ k < a.size → b[k]! = a[((a.size - 1) - k)]!) :=\nsorry", "vc-postamble": ""}
{"id": "Formal-Verification-Project_tmp_tmp9gmwsmyp_strings3_haveCommonKSubstring", "vc-description": "/- \n{\n\"name\": \"Formal-Verification-Project_tmp_tmp9gmwsmyp_strings3_haveCommonKSubstring\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Formal-Verification-Project_tmp_tmp9gmwsmyp_strings3_haveCommonKSubstring\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate defining when one string is a prefix of another -/\n\n/-  Predicate defining when one string is not a prefix of another -/\n\n/-  Function checking if one string is a prefix of another -/\n\n/-  Specification for isPrefix function -/\n\n/-  Predicate defining when one string is a substring of another -/\n\n/-  Predicate defining when one string is not a substring of another -/\n\n/-  Function checking if one string is a substring of another -/\n\n/-  Specification for isSubstring function -/\n\n/-  Predicate defining when two strings have a common substring of length k -/\n\n/-  Predicate defining when two strings do not have a common substring of length k -/\n\n/-  Function checking if two strings have a common substring of length k -/\n\n/-  Specification for haveCommonKSubstring function -/", "vc-preamble": "def isPrefixPred (pre str : String) : Prop :=\npre.length ≤ str.length ∧\npre = str.take pre.length\n\ndef isNotPrefixPred (pre str : String) : Prop :=\npre.length > str.length ∨\npre ≠ str.take pre.length\n\ndef isSubstringPred (sub str : String) : Prop :=\n∃ i, 0 ≤ i ∧ i ≤ str.length ∧ isPrefixPred sub (str.drop i)\n\ndef isNotSubstringPred (sub str : String) : Prop :=\n∀ i, 0 ≤ i ∧ i ≤ str.length → isNotPrefixPred sub (str.drop i)\n\ndef haveCommonKSubstringPred (k : Nat) (str1 str2 : String) : Prop :=\n∃ i1 j1, 0 ≤ i1 ∧ i1 ≤ str1.length - k ∧ j1 = i1 + k ∧\nisSubstringPred (str1.extract ⟨i1⟩ ⟨j1-i1⟩) str2\n\ndef haveNotCommonKSubstringPred (k : Nat) (str1 str2 : String) : Prop :=\n∀ i1 j1, 0 ≤ i1 ∧ i1 ≤ str1.length - k ∧ j1 = i1 + k →\nisNotSubstringPred (str1.extract ⟨i1⟩ ⟨j1-i1⟩) str2", "vc-helpers": "", "vc-definitions": "def isPrefix (pre str : String) : Bool :=\nsorry\n\ndef isSubstring (sub str : String) : Bool :=\nsorry\n\ndef haveCommonKSubstring (k : Nat) (str1 str2 : String) : Bool :=\nsorry", "vc-theorems": "theorem isPrefix_spec (pre str : String) :\nisPrefix pre str = false ↔ isNotPrefixPred pre str ∧\n(isPrefix pre str = true ↔ isPrefixPred pre str) :=\nsorry\n\ntheorem isSubstring_spec (sub str : String) :\nisSubstring sub str = true ↔ isSubstringPred sub str :=\nsorry\n\ntheorem haveCommonKSubstring_spec (k : Nat) (str1 str2 : String) :\nhaveCommonKSubstring k str1 str2 = true ↔ haveCommonKSubstringPred k str1 str2 :=\nsorry", "vc-postamble": ""}
{"id": "Formal-Verification-Project_tmp_tmp9gmwsmyp_strings3_isSubstring", "vc-description": "/- \n{\n\"name\": \"Formal-Verification-Project_tmp_tmp9gmwsmyp_strings3_isSubstring\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Formal-Verification-Project_tmp_tmp9gmwsmyp_strings3_isSubstring\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate defining when one string is a prefix of another -/\n\n/-  Predicate defining when one string is not a prefix of another -/\n\n/-  Method checking if one string is a prefix of another -/\n\n/-  Specification for isPrefix method -/\n\n/-  Predicate defining when one string is a substring of another -/\n\n/-  Predicate defining when one string is not a substring of another -/\n\n/-  Predicate defining when two strings have a common substring of length k -/\n\n/-  Predicate defining when two strings do not have a common substring of length k -/\n\n/-  Method checking if one string is a substring of another -/\n\n/-  Specification for isSubstring method -/", "vc-preamble": "def isPrefixPred (pre str : String) : Prop :=\n(pre.length ≤ str.length) ∧\n(pre = str.take pre.length)\n\ndef isNotPrefixPred (pre str : String) : Prop :=\n(pre.length > str.length) ∨\n(pre ≠ str.take pre.length)\n\ndef isSubstringPred (sub str : String) : Prop :=\n∃ i, 0 ≤ i ∧ i ≤ str.length ∧ isPrefixPred sub (str.drop i)\n\ndef isNotSubstringPred (sub str : String) : Prop :=\n∀ i, 0 ≤ i ∧ i ≤ str.length → isNotPrefixPred sub (str.drop i)\n\ndef haveCommonKSubstringPred (k : Nat) (str1 str2 : String) : Prop :=\n∃ i1 j1, 0 ≤ i1 ∧ i1 ≤ str1.length - k ∧ j1 = i1 + k ∧\nisSubstringPred (str1.extract ⟨i1⟩ ⟨j1-i1⟩) str2\n\ndef haveNotCommonKSubstringPred (k : Nat) (str1 str2 : String) : Prop :=\n∀ i1 j1, 0 ≤ i1 ∧ i1 ≤ str1.length - k ∧ j1 = i1 + k →\nisNotSubstringPred (str1.extract ⟨i1⟩ ⟨j1-i1⟩) str2", "vc-helpers": "", "vc-definitions": "def isPrefix (pre str : String) : Bool :=\nsorry\n\ndef isSubstring (sub str : String) : Bool :=\nsorry", "vc-theorems": "theorem isPrefix_spec (pre str : String) :\n(¬isPrefix pre str ↔ isNotPrefixPred pre str) ∧\n(isPrefix pre str ↔ isPrefixPred pre str) :=\nsorry\n\ntheorem isSubstring_spec (sub str : String) :\nisSubstring sub str ↔ isSubstringPred sub str :=\nsorry", "vc-postamble": ""}
{"id": "Formal-Verification-Project_tmp_tmp9gmwsmyp_strings3_maxCommonSubstringLength", "vc-description": "/- \n{\n\"name\": \"Formal-Verification-Project_tmp_tmp9gmwsmyp_strings3_maxCommonSubstringLength\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Formal-Verification-Project_tmp_tmp9gmwsmyp_strings3_maxCommonSubstringLength\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate checking if sub is a substring of str -/\n\n/-  Predicate checking if pre is a prefix of str -/\n\n/-  Predicate checking if pre is not a prefix of str -/\n\n/-  Predicate checking if sub is a substring of str -/\n\n/-  Predicate checking if sub is not a substring of str -/\n\n/-  Predicate checking if strings have a common substring of length k -/\n\n/-  Predicate checking if strings do not have a common substring of length k -/\n\n/-  Function checking if strings have a common substring of length k -/\n\n/-  Specification for haveCommonKSubstring -/\n\n/-  Function finding maximum length of common substring -/\n\n/-  Specification for maxCommonSubstringLength -/", "vc-preamble": "def isSubstring (sub : Array Char) (str : Array Char) : Prop :=\n∃ i, 0 ≤ i ∧ i ≤ str.size - sub.size ∧\n(∀ j, 0 ≤ j ∧ j < sub.size → str[i + j]! = sub[j]!)\n\ndef isPrefixPred (pre str : String) : Prop :=\npre.length ≤ str.length ∧\n(∀ i, 0 ≤ i ∧ i < pre.length → pre.get ⟨i⟩ = str.get ⟨i⟩)\n\ndef isNotPrefixPred (pre str : String) : Prop :=\npre.length > str.length ∨\n(∃ i, 0 ≤ i ∧ i < pre.length ∧ pre.get ⟨i⟩ ≠ str.get ⟨i⟩)\n\ndef isSubstringPred (sub str : String) : Prop :=\n∃ i, 0 ≤ i ∧ i ≤ str.length ∧ isPrefixPred sub (str.drop i)\n\ndef isNotSubstringPred (sub str : String) : Prop :=\n∀ i, 0 ≤ i ∧ i ≤ str.length → isNotPrefixPred sub (str.drop i)\n\ndef haveCommonKSubstringPred (k : Nat) (str1 str2 : String) : Prop :=\n∃ i1, 0 ≤ i1 ∧ i1 ≤ str1.length - k ∧\nisSubstringPred (str1.extract ⟨i1⟩ ⟨k⟩) str2\n\ndef haveNotCommonKSubstringPred (k : Nat) (str1 str2 : String) : Prop :=\n∀ i1, 0 ≤ i1 ∧ i1 ≤ str1.length - k →\nisNotSubstringPred (str1.extract ⟨i1⟩ ⟨k⟩) str2", "vc-helpers": "", "vc-definitions": "def haveCommonKSubstring (k : Nat) (str1 str2 : String) : Bool :=\nsorry\n\ndef maxCommonSubstringLength (str1 str2 : String) : Nat :=\nsorry", "vc-theorems": "theorem haveCommonKSubstring_spec (k : Nat) (str1 str2 : String) :\nhaveCommonKSubstring k str1 str2 = true ↔ haveCommonKSubstringPred k str1 str2 :=\nsorry\n\ntheorem maxCommonSubstringLength_spec (str1 str2 : String) :\nstr1.length ≤ str2.length →\n(∀ k, maxCommonSubstringLength str1 str2 < k ∧ k ≤ str1.length →\n¬haveCommonKSubstringPred k str1 str2) ∧\nhaveCommonKSubstringPred (maxCommonSubstringLength str1 str2) str1 str2 :=\nsorry", "vc-postamble": ""}
{"id": "Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings1_haveCommonKSubstring", "vc-description": "/- \n{\n\"name\": \"Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings1_haveCommonKSubstring\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings1_haveCommonKSubstring\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate indicating when a string is not a prefix of another string -/\n\n/-  Function checking if one string is a prefix of another -/\n\n/-  Specification for isPrefix -/\n\n/-  Predicate indicating when one string is a prefix of another -/\n\n/-  Predicate indicating when one string is a substring of another -/\n\n/-  Function checking if one string is a substring of another -/\n\n/-  Specification for isSubstring -/\n\n/-  Predicate indicating if two strings have a common substring of length k -/\n\n/-  Predicate indicating if len is the maximum length of common substrings -/\n\n/-  Function checking if two strings have a common substring of length k -/\n\n/-  Specification for haveCommonKSubstring -/", "vc-preamble": "def isNotPrefixPred (pre str : String) : Bool :=\n(pre.length > str.length) ∨ pre ≠ str.take pre.length\n\ndef isPrefixPredicate (pre str : String) : Bool :=\nstr.length ≥ pre.length ∧ pre ≤ str\n\ndef isSubstringPredicate (sub str : String) : Prop :=\nstr.length ≥ sub.length ∧ ∃ i, 0 ≤ i ∧ i ≤ str.length ∧\nisPrefixPredicate sub (str.drop i)\n\ndef haveCommonKSubstringPredicate (k : Nat) (str1 str2 : String) : Prop :=\nstr1.length ≥ k ∧ str2.length ≥ k ∧\n∃ i, 0 ≤ i ∧ i ≤ str1.length - k ∧\nisSubstringPredicate ((str1.drop i).take k) str2\n\ndef maxCommonSubstringPredicate (str1 str2 : String) (len : Nat) : Prop :=\n∀ k, len < k ∧ k ≤ str1.length → ¬(haveCommonKSubstringPredicate k str1 str2)", "vc-helpers": "", "vc-definitions": "def isPrefix (pre str : String) : Bool :=\nsorry\n\ndef isSubstring (sub str : String) : Bool :=\nsorry\n\ndef haveCommonKSubstring (k : Nat) (str1 str2 : String) : Bool :=\nsorry", "vc-theorems": "theorem isPrefix_spec (pre str : String) :\n¬(isPrefix pre str) ↔ isNotPrefixPred pre str :=\nsorry\n\ntheorem isSubstring_spec (sub str : String) :\nisSubstring sub str = isSubstringPredicate sub str :=\nsorry\n\ntheorem haveCommonKSubstring_spec (k : Nat) (str1 str2 : String) :\n(str1.length < k ∨ str2.length < k → ¬(haveCommonKSubstring k str1 str2)) ∧\nhaveCommonKSubstringPredicate k str1 str2 = haveCommonKSubstring k str1 str2 :=\nsorry", "vc-postamble": ""}
{"id": "Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings1_maxCommonSubstringLength", "vc-description": "/- \n{\n\"name\": \"Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings1_maxCommonSubstringLength\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings1_maxCommonSubstringLength\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate defining when a string is not a prefix of another string -/\n\n/-  Predicate defining when a string is a prefix of another string -/\n\n/-  Function checking if one string is a prefix of another -/\n\n/-  Predicate defining when one string is a substring of another -/\n\n/-  Function checking if one string is a substring of another -/\n\n/-  Predicate defining when two strings have a common substring of length k -/\n\n/-  Function checking if two strings have a common substring of length k -/\n\n/-  Predicate defining when len is the maximum length of common substrings -/\n\n/-  Function finding the maximum length of common substrings -/", "vc-preamble": "def isNotPrefixPred (pre str : String) : Prop :=\n(pre.length > str.length) ∨\npre ≠ str.take pre.length\n\ndef isPrefixPredicate (pre str : String) : Prop :=\nstr.length ≥ pre.length ∧ pre ≤ str\n\ndef isSubstringPredicate (sub str : String) : Prop :=\nstr.length ≥ sub.length ∧\n∃ i, 0 ≤ i ∧ i ≤ str.length ∧ isPrefixPredicate sub (str.drop i)\n\ndef haveCommonKSubstringPredicate (k : Nat) (str1 str2 : String) : Prop :=\nstr1.length ≥ k ∧ str2.length ≥ k ∧\n∃ i, 0 ≤ i ∧ i ≤ str1.length - k ∧\nisSubstringPredicate ((str1.drop i).take k) str2\n\ndef maxCommonSubstringPredicate (str1 str2 : String) (len : Nat) : Prop :=\n∀ k, len < k ∧ k ≤ str1.length → ¬(haveCommonKSubstringPredicate k str1 str2)", "vc-helpers": "", "vc-definitions": "def isPrefix (pre str : String) : Bool :=\nsorry\n\ndef isSubstring (sub str : String) : Bool :=\nsorry\n\ndef haveCommonKSubstring (k : Nat) (str1 str2 : String) : Bool :=\nsorry\n\ndef maxCommonSubstringLength (str1 str2 : String) : Nat :=\nsorry", "vc-theorems": "theorem isPrefix_spec (pre str : String) :\n¬(isPrefix pre str) ↔ isNotPrefixPred pre str ∧\n(isPrefix pre str ↔ isPrefixPredicate pre str) :=\nsorry\n\ntheorem isSubstring_spec (sub str : String) :\nisSubstring sub str ↔ isSubstringPredicate sub str :=\nsorry\n\ntheorem haveCommonKSubstring_spec (k : Nat) (str1 str2 : String) :\n(str1.length < k ∨ str2.length < k → ¬(haveCommonKSubstring k str1 str2)) ∧\n(haveCommonKSubstringPredicate k str1 str2 ↔ haveCommonKSubstring k str1 str2) :=\nsorry\n\ntheorem maxCommonSubstringLength_spec (str1 str2 : String) :\nlet len := maxCommonSubstringLength str1 str2\nlen ≤ str1.length ∧ len ≤ str2.length ∧\nlen ≥ 0 ∧\nmaxCommonSubstringPredicate str1 str2 len :=\nsorry", "vc-postamble": ""}
{"id": "Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings3_haveCommonKSubstring", "vc-description": "/- \n{\n\"name\": \"Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings3_haveCommonKSubstring\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings3_haveCommonKSubstring\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate defining when one string is a prefix of another -/\n\n/-  Predicate defining when one string is not a prefix of another -/\n\n/-  Function checking if one string is a prefix of another -/\n\n/-  Specification for isPrefix function -/\n\n/-  Predicate defining when one string is a substring of another -/\n\n/-  Predicate defining when one string is not a substring of another -/\n\n/-  Function checking if one string is a substring of another -/\n\n/-  Specification for isSubstring function -/\n\n/-  Predicate defining when two strings have a common substring of length k -/\n\n/-  Predicate defining when two strings do not have a common substring of length k -/\n\n/-  Function checking if two strings have a common substring of length k -/\n\n/-  Specification for haveCommonKSubstring function -/", "vc-preamble": "def isPrefixPred (pre str : String) : Prop :=\n(pre.length ≤ str.length) ∧\n(pre = str.take pre.length)\n\ndef isNotPrefixPred (pre str : String) : Prop :=\n(pre.length > str.length) ∨\n(pre ≠ str.take pre.length)\n\ndef isSubstringPred (sub str : String) : Prop :=\n∃ i, 0 ≤ i ∧ i ≤ str.length ∧ isPrefixPred sub (str.drop i)\n\ndef isNotSubstringPred (sub str : String) : Prop :=\n∀ i, 0 ≤ i ∧ i ≤ str.length → isNotPrefixPred sub (str.drop i)\n\ndef haveCommonKSubstringPred (k : Nat) (str1 str2 : String) : Prop :=\n∃ i1 j1, 0 ≤ i1 ∧ i1 ≤ str1.length - k ∧ j1 = i1 + k ∧\nisSubstringPred (str1.extract ⟨i1⟩ ⟨k⟩) str2\n\ndef haveNotCommonKSubstringPred (k : Nat) (str1 str2 : String) : Prop :=\n∀ i1 j1, 0 ≤ i1 ∧ i1 ≤ str1.length - k ∧ j1 = i1 + k →\nisNotSubstringPred (str1.extract ⟨i1⟩ ⟨k⟩) str2", "vc-helpers": "", "vc-definitions": "def isPrefix (pre str : String) : Bool :=\nsorry\n\ndef isSubstring (sub str : String) : Bool :=\nsorry\n\ndef haveCommonKSubstring (k : Nat) (str1 str2 : String) : Bool :=\nsorry", "vc-theorems": "theorem isPrefix_spec (pre str : String) :\n(¬isPrefix pre str ↔ isNotPrefixPred pre str) ∧\n(isPrefix pre str ↔ isPrefixPred pre str) :=\nsorry\n\ntheorem isSubstring_spec (sub str : String) :\nisSubstring sub str ↔ isSubstringPred sub str :=\nsorry\n\ntheorem haveCommonKSubstring_spec (k : Nat) (str1 str2 : String) :\nhaveCommonKSubstring k str1 str2 ↔ haveCommonKSubstringPred k str1 str2 :=\nsorry", "vc-postamble": ""}
{"id": "Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings3_maxCommonSubstringLength", "vc-description": "/- \n{\n\"name\": \"Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings3_maxCommonSubstringLength\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings3_maxCommonSubstringLength\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate checking if sub is a substring of str -/\n\n/-  Predicate checking if pre is a prefix of str -/\n\n/-  Predicate checking if pre is not a prefix of str -/\n\n/-  Predicate checking if sub is a substring of str using prefix predicate -/\n\n/-  Predicate checking if sub is not a substring of str using prefix predicate -/\n\n/-  Predicate checking if strings have a common substring of length k -/\n\n/-  Predicate checking if strings do not have a common substring of length k -/\n\n/-  Function checking if strings have a common substring of length k -/\n\n/-  Specification for haveCommonKSubstring -/\n\n/-  Function finding the maximum length of common substring -/\n\n/-  Specification for maxCommonSubstringLength -/", "vc-preamble": "def isSubstring (sub str : String) : Prop :=\n∃ i, 0 ≤ i ∧ i ≤ str.length - sub.length ∧ str.extract ⟨i⟩ ⟨i + sub.length⟩ = sub\n\ndef isPrefixPred (pre str : String) : Prop :=\npre.length ≤ str.length ∧ pre = str.take pre.length\n\ndef isNotPrefixPred (pre str : String) : Prop :=\npre.length > str.length ∨ pre ≠ str.take pre.length\n\ndef isSubstringPred (sub str : String) : Prop :=\n∃ i, 0 ≤ i ∧ i ≤ str.length ∧ isPrefixPred sub (str.drop i)\n\ndef isNotSubstringPred (sub str : String) : Prop :=\n∀ i, 0 ≤ i ∧ i ≤ str.length → isNotPrefixPred sub (str.drop i)\n\ndef haveCommonKSubstringPred (k : Nat) (str1 str2 : String) : Prop :=\n∃ i1 j1, 0 ≤ i1 ∧ i1 ≤ str1.length - k ∧ j1 = i1 + k ∧\nisSubstringPred (str1.extract ⟨i1⟩ ⟨j1⟩) str2\n\ndef haveNotCommonKSubstringPred (k : Nat) (str1 str2 : String) : Prop :=\n∀ i1 j1, 0 ≤ i1 ∧ i1 ≤ str1.length - k ∧ j1 = i1 + k →\nisNotSubstringPred (str1.extract ⟨i1⟩ ⟨j1⟩) str2", "vc-helpers": "", "vc-definitions": "def haveCommonKSubstring (k : Nat) (str1 str2 : String) : Bool :=\nsorry\n\ndef maxCommonSubstringLength (str1 str2 : String) : Nat :=\nsorry", "vc-theorems": "theorem haveCommonKSubstring_spec (k : Nat) (str1 str2 : String) :\nhaveCommonKSubstring k str1 str2 = true ↔ haveCommonKSubstringPred k str1 str2 :=\nsorry\n\ntheorem maxCommonSubstringLength_spec (str1 str2 : String) :\nstr1.length ≤ str2.length →\n(∀ k, maxCommonSubstringLength str1 str2 < k ∧ k ≤ str1.length →\n¬haveCommonKSubstringPred k str1 str2) ∧\nhaveCommonKSubstringPred (maxCommonSubstringLength str1 str2) str1 str2 :=\nsorry", "vc-postamble": ""}
{"id": "Formal-methods-of-software-development_tmp_tmppryvbyty_Bloque_2_Lab6_vector_Sum", "vc-description": "/- \n{\n\"name\": \"Formal-methods-of-software-development_tmp_tmppryvbyty_Bloque 2_Lab6_vector_Sum\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Formal-methods-of-software-development_tmp_tmppryvbyty_Bloque 2_Lab6_vector_Sum\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Sum of a sequence of integers -/\n\n/-  Scalar product of two integer vectors -/\n\n/-  Vector sum method specification -/", "vc-preamble": "partial def sum (v : Array Int) : Int :=\nif v.size = 0 then 0\nelse if v.size = 1 then v[0]!\nelse v[0]! + sum (v.extract 1 v.size)\n\npartial def scalar_product (v1 v2 : Array Int) : Int :=\nif v1.size = 0 then 0\nelse v1[0]! * v2[0]! + scalar_product (v1.extract 1 v1.size) (v2.extract 1 v2.size)", "vc-helpers": "", "vc-definitions": "def vector_Sum (v : Array Int) : Int :=\nsorry", "vc-theorems": "theorem scalar_product_spec (v1 v2 : Array Int) :\nv1.size = v2.size → scalar_product v1 v2 = scalar_product v1 v2 :=\nsorry\n\ntheorem vector_Sum_spec (v : Array Int) (x : Int) :\nvector_Sum v = sum v :=\nsorry", "vc-postamble": ""}
{"id": "MFES_2021_tmp_tmpuljn8zd9_Exams_Special_Exam_03_2020_4_CatalanNumbers_calcC", "vc-description": "/- \n{\n\"name\": \"MFES_2021_tmp_tmpuljn8zd9_Exams_Special_Exam_03_2020_4_CatalanNumbers_calcC\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: MFES_2021_tmp_tmpuljn8zd9_Exams_Special_Exam_03_2020_4_CatalanNumbers_calcC\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nRecursive function to calculate the nth Catalan number.\nTranslated from Dafny function C(n).\n-/\n\n/- \nMethod to calculate the nth Catalan number.\nEnsures the result equals C(n).\n-/", "vc-preamble": "def C (n : Nat) : Nat :=\nif n = 0 then\n1\nelse\n(4 * n - 2) * C (n-1) / (n + 1)\ndecreasing_by all_goals simp_wf; omega", "vc-helpers": "", "vc-definitions": "def calcC (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem calcC_spec (n : Nat) : calcC n = C n :=\nsorry", "vc-postamble": ""}
{"id": "MFES_2021_tmp_tmpuljn8zd9_TheoreticalClasses_Power_powerIter", "vc-description": "/- \n{\n\"name\": \"MFES_2021_tmp_tmpuljn8zd9_TheoreticalClasses_Power_powerIter\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: MFES_2021_tmp_tmpuljn8zd9_TheoreticalClasses_Power_powerIter\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nInitial specification/definition of x^n, recursive, functional style,\nwith time and space complexity O(n).\n-/\n\n/- \nIterative version, imperative, with time complexity O(n) and space complexity O(1).\n-/", "vc-preamble": "def power (x : Float) (n : Nat) : Float :=\nmatch n with\n| 0 => 1.0\n| n + 1 => x * power x n", "vc-helpers": "", "vc-definitions": "def powerIter (x : Float) (n : Nat) : Float :=\nsorry", "vc-theorems": "theorem powerIter_spec (x : Float) (n : Nat) :\npowerIter x n = power x n :=\nsorry", "vc-postamble": ""}
{"id": "MFS_tmp_tmpmmnu354t_Praticas_TP9_Power_powerIter", "vc-description": "/- \n{\n\"name\": \"MFS_tmp_tmpmmnu354t_Praticas_TP9_Power_powerIter\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: MFS_tmp_tmpmmnu354t_Praticas_TP9_Power_powerIter\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nInitial specification/definition of x^n, recursive, functional style.\nTime and space complexity O(n).\n-/\n\n/- \nIterative version of power function with time complexity O(n) and space complexity O(1).\n-/", "vc-preamble": "def power (x : Float) (n : Nat) : Float :=\nif n = 0 then 1.0 else x * power x (n-1)", "vc-helpers": "", "vc-definitions": "def powerIter (b : Float) (n : Nat) : Float :=\nsorry", "vc-theorems": "theorem powerIter_spec (b : Float) (n : Nat) :\npowerIter b n = power b n :=\nsorry", "vc-postamble": ""}
{"id": "MIEIC_mfes_tmp_tmpq3ho7nve_TP3_binary_search_binarySearch", "vc-description": "/- \n{\n\"name\": \"MIEIC_mfes_tmp_tmpq3ho7nve_TP3_binary_search_binarySearch\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: MIEIC_mfes_tmp_tmpq3ho7nve_TP3_binary_search_binarySearch\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nPredicate checking if an array is sorted in ascending order.\n-/\n\n/- \nBinary search implementation that finds a value in a sorted array.\nReturns the index of the value if found, -1 if not found.\n\n@param a The sorted array to search in\n@param x The value to search for\n@return The index of x in a, or -1 if not found\n-/", "vc-preamble": "def isSorted (a : Array Int) : Prop :=\n∀ i j, 0 ≤ i → i < j → j < a.size → a[i]! ≤ a[j]!", "vc-helpers": "", "vc-definitions": "def binarySearch (a : Array Int) (x : Int) : Int :=\nsorry", "vc-theorems": "theorem binarySearch_spec (a : Array Int) (x : Int) :\nisSorted a →\nlet index := binarySearch a x\n(-1 ≤ index ∧ index < a.size ∧\n(index ≠ -1 → a[index.toNat]! = x) ∧\n(index = -1 → ∀ i:Nat, 0 ≤ i → i < a.size → a[i]! ≠ x)) :=\nsorry", "vc-postamble": ""}
{"id": "MIEIC_mfes_tmp_tmpq3ho7nve_exams_mt2_19_p4_calcR", "vc-description": "/- \n{\n\"name\": \"MIEIC_mfes_tmp_tmpq3ho7nve_exams_mt2_19_p4_calcR\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: MIEIC_mfes_tmp_tmpq3ho7nve_exams_mt2_19_p4_calcR\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nRecursive function R that takes a natural number and returns a natural number.\nTranslated from Dafny function R.\n-/\n\n/- \nMethod calcR that computes the value of R(n).\nTranslated from Dafny method calcR.\n-/", "vc-preamble": "def R (n : Nat) : Nat :=\nif n = 0 then\n0\nelse if R (n-1) > n then\nR (n-1) - n\nelse\nR (n-1) + n", "vc-helpers": "", "vc-definitions": "def calcR (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem calcR_spec (n : Nat) : calcR n = R n :=\nsorry", "vc-postamble": ""}
{"id": "MIEIC_mfes_tmp_tmpq3ho7nve_exams_mt2_19_p5_partition", "vc-description": "/- \n{\n\"name\": \"MIEIC_mfes_tmp_tmpq3ho7nve_exams_mt2_19_p5_partition\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: MIEIC_mfes_tmp_tmpq3ho7nve_exams_mt2_19_p5_partition\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nPartitions a nonempty array 'a', by reordering the elements in the array,\nso that elements smaller than a chosen pivot are placed to the left of the\npivot, and values greater or equal than the pivot are placed to the right of\nthe pivot. Returns the pivot position.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def partition (a : Array Int) : Int :=\nsorry", "vc-theorems": "theorem partition_spec (a : Array Int) :\na.size > 0 →\nlet pivotPos := partition a\n0 ≤ pivotPos ∧ pivotPos < a.size ∧\n(∀ i:Nat, 0 ≤ i ∧ i < pivotPos → a[i]! < a[pivotPos.toNat]!) ∧\n(∀ i:Nat, pivotPos < i ∧ i < a.size → a[i]! ≥ a[pivotPos.toNat]!) :=\nsorry", "vc-postamble": ""}
{"id": "Prog-Fun-Solutions_tmp_tmp7_gmnz5f_extra_mod2_mod2", "vc-description": "/- \n{\n\"name\": \"Prog-Fun-Solutions_tmp_tmp7_gmnz5f_extra_mod2_mod2\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Prog-Fun-Solutions_tmp_tmp7_gmnz5f_extra_mod2_mod2\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nGhost function f2 that recursively computes a value based on input n.\nFor n = 0, returns 0\nFor n > 0, returns 5*f2(n/3) + n%4\n-/\n\n/- \nMethod mod2 that returns a value equal to f2(n)\n-/", "vc-preamble": "def f2 (n : Nat) : Nat :=\nif n = 0 then 0\nelse 5 * f2 (n / 3) + n % 4", "vc-helpers": "", "vc-definitions": "def mod2 (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem mod2_spec (n : Nat) : mod2 n = f2 n :=\nsorry", "vc-postamble": ""}
{"id": "Prog-Fun-Solutions_tmp_tmp7_gmnz5f_extra_mod_mod", "vc-description": "/- \n{\n\"name\": \"Prog-Fun-Solutions_tmp_tmp7_gmnz5f_extra_mod_mod\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Prog-Fun-Solutions_tmp_tmp7_gmnz5f_extra_mod_mod\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nRecursive function f that computes:\n- f(0) = 1\n- f(n) = 1 + 2*f(n/2) if n is even\n- f(n) = 2*f(n/2) if n is odd\n-/\n\n/- \nMethod mod that returns a value equal to f(n)\n-/", "vc-preamble": "def f (n : Nat) : Nat :=\nif n = 0 then 1\nelse if n % 2 = 0 then 1 + 2 * f (n / 2)\nelse 2 * f (n / 2)", "vc-helpers": "", "vc-definitions": "def mod (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem mod_spec (n : Nat) : mod n = f n :=\nsorry", "vc-postamble": ""}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced_examples_InsertionSort_InsertionSort", "vc-description": "/- \n{\n\"name\": \"Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced examples_InsertionSort_InsertionSort\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced examples_InsertionSort_InsertionSort\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nPredicate indicating if an array is sorted between start and end indices.\nTranslated from Dafny's sorted predicate.\n-/\n\n/- \nInsertionSort method specification translated from Dafny.\nTakes an array of integers and sorts it in ascending order.\n-/", "vc-preamble": "def sorted (a : Array Int) (start : Nat) (end_ : Nat) : Prop :=\na.size > 0 ∧\n0 ≤ start ∧ start ≤ end_ ∧ end_ ≤ a.size ∧\n∀ j k, start ≤ j ∧ j < k ∧ k < end_ → a[j]! ≤ a[k]!", "vc-helpers": "", "vc-definitions": "def InsertionSort (a : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem InsertionSort_spec (a : Array Int) :\na.size > 1 →\nsorted (InsertionSort a) 0 (InsertionSort a).size :=\nsorry", "vc-postamble": ""}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced_examples_MatrixMultiplication_multiply", "vc-description": "/- \n{\n\"name\": \"Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced examples_MatrixMultiplication_multiply\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced examples_MatrixMultiplication_multiply\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nHelper function that computes partial dot product starting from index k.\n-/\n\n/- \nComputes the dot product of a row from matrix m1 and a column from matrix m2.\n-/\n\n/- \nMultiplies two matrices m1 and m2.\n-/", "vc-preamble": "partial def RowColumnProductFrom (m1 : Array (Array Int)) (m2 : Array (Array Int)) (row : Nat) (column : Nat) (k : Nat) : Int :=\nif k == m1.size then\n0\nelse\nm1[row]![k]! * m2[k]![column]! + RowColumnProductFrom m1 m2 row column (k + 1)\ndef RowColumnProduct (m1 : Array (Array Int)) (m2 : Array (Array Int)) (row : Nat) (column : Nat) : Int :=\nRowColumnProductFrom m1 m2 row column 0", "vc-helpers": "", "vc-definitions": "def multiply (m1 : Array (Array Int)) (m2 : Array (Array Int)) : Array (Array Int) :=\nsorry", "vc-theorems": "theorem multiply_spec (m1 m2 : Array (Array Int)) :\nm1.size > 0 ∧ m2.size > 0 ∧ m1.size == m2.size →\nlet m3 := multiply m1 m2\nm3.size == m1.size ∧ m3.size == m2.size ∧\n∀ i j, i < m3.size ∧ j < m3.size →\nm3[i]![j]! == RowColumnProduct m1 m2 i j :=\nsorry", "vc-postamble": ""}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced_examples_Percentile_Percentile", "vc-description": "/- \n{\n\"name\": \"Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced examples_Percentile_Percentile\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced examples_Percentile_Percentile\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Sum_ of elements of array A from indices 0 to end (inclusive) -/\n\n/-  Sum_ of all elements in array A -/\n\n/-  Percentile function specification -/\n\n/-  Percentile function implementation -/", "vc-preamble": "partial def SumUpto (A : Array Float) (end_ : Int) : Float :=\nif end_ == -1 then\n0.0\nelse\nA[end_.toNat]! + SumUpto A (end_ - 1)\n\ndef Sum_ (A : Array Float) : Float :=\nSumUpto A (A.size - 1)", "vc-helpers": "", "vc-definitions": "def Percentile (p : Float) (A : Array Float) (total : Float) : Int :=\nsorry", "vc-theorems": "theorem percentile_spec (p : Float) (A : Array Float) (total : Float) (i : Int) :\n(∀ i, 0 ≤ i ∧ i < A.size → A[i]! > 0.0) →\n0.0 ≤ p ∧ p ≤ 100.0 →\ntotal == Sum_ A →\ntotal > 0.0 →\n-1 ≤ i ∧ i < A.size ∧\nSumUpto A i.toNat ≤ (p/100.0) * total ∧\n(i.toNat + 1 < A.size → SumUpto A (i.toNat + 1) > (p/100.0) * total) :=\nsorry", "vc-postamble": ""}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced_examples_Percentile_PercentileNonUniqueAnswer", "vc-description": "/- \n{\n\"name\": \"Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced examples_Percentile_PercentileNonUniqueAnswer\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced examples_Percentile_PercentileNonUniqueAnswer\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Sum_ of elements of array A from indices 0 to end (inclusive) -/\n\n/-  Sum_ of all elements in array A -/\n\n/-  Specification for PercentileNonUniqueAnswer method -/\n\n/-  Implementation of PercentileNonUniqueAnswer method -/", "vc-preamble": "partial def SumUpto (A : Array Float) (end_ : Int) : Float :=\nif end_ == -1 then\n0.0\nelse\nA[end_.toNat]! + SumUpto A (end_ - 1)\n\ndef Sum_ (A : Array Float) : Float :=\nSumUpto A (A.size - 1)", "vc-helpers": "", "vc-definitions": "def PercentileNonUniqueAnswer : Float × Array Float × Float × Int × Int :=\nsorry", "vc-theorems": "theorem percentile_non_unique_answer_spec\n(p : Float) (A : Array Float) (total : Float) (i1 i2 : Int) :\n(∀ i, 0 ≤ i ∧ i < A.size → A[i]! > 0.0) ∧\n0.0 ≤ p ∧ p ≤ 100.0 ∧\ntotal == Sum_ A ∧\ntotal > 0.0 ∧\n-1 ≤ i1 ∧ i1 < A.size ∧\nSumUpto A i1 ≤ (p/100.0) * total ∧\n(i1 + 1 < A.size → SumUpto A (i1 + 1) ≥ (p/100.0) * total) ∧\n-1 ≤ i2 ∧ i2 < A.size ∧\nSumUpto A i2 ≤ (p/100.0) * total ∧\n(i2 + 1 < A.size → SumUpto A (i2 + 1) ≥ (p/100.0) * total) ∧\ni1 ≠ i2 :=\nsorry", "vc-postamble": ""}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced_examples_ReverseString_yarra", "vc-description": "/- \n{\n\"name\": \"Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced examples_ReverseString_yarra\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced examples_ReverseString_yarra\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nPredicate specifying that one array is the reverse of another array.\nBoth arrays must be non-null and of equal length.\n-/\n\n/- \nMethod that returns a reversed copy of the input character array.\nInput array must be non-null and non-empty.\nOutput array will be non-null, same length as input, and reversed.\n-/", "vc-preamble": "def reversed (arr : Array Char) (outarr : Array Char) : Prop :=\narr.size = outarr.size ∧\n∀ k, 0 ≤ k ∧ k ≤ arr.size - 1 →\noutarr[k]! = arr[arr.size - 1 - k]!", "vc-helpers": "", "vc-definitions": "def yarra (arr : Array Char) : Array Char :=\nsorry", "vc-theorems": "theorem yarra_spec (arr : Array Char) :\narr.size > 0 →\nlet outarr := yarra arr\noutarr.size = arr.size ∧ reversed arr outarr :=\nsorry", "vc-postamble": ""}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced_examples_demo_Partition", "vc-description": "/- \n{\n\"name\": \"Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced examples_demo_Partition\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced examples_demo_Partition\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nPartitions an array into three sections:\n- Elements < 0 from index 0 to lo-1\n- Elements = 0 from index lo to hi-1\n- Elements > 0 from index hi to array end\nReturns the boundary indices lo and hi\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Partition (a : Array Int) : Nat × Nat :=\nsorry", "vc-theorems": "theorem partition_spec (a : Array Int) (lo hi : Nat) :\nlet result := Partition a\n\n-- Bounds check\n\n0 ≤ result.1 ∧ result.1 ≤ result.2 ∧ result.2 ≤ a.size ∧\n\n-- Elements before lo are negative\n\n(∀ x, 0 ≤ x ∧ x < result.1 → (a[x]!) < 0) ∧\n\n-- Elements between lo and hi are zero\n\n(∀ x, result.1 ≤ x ∧ x < result.2 → (a[x]!) = 0) ∧\n\n-- Elements after hi are positive\n\n(∀ x, result.2 ≤ x ∧ x < a.size → (a[x]!) > 0) :=\nsorry", "vc-postamble": ""}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_ProgramProofs_ch15_Partition", "vc-description": "/- \n{\n\"name\": \"Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_ProgramProofs_ch15_Partition\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_ProgramProofs_ch15_Partition\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate indicating elements before n are less than or equal to elements after n -/\n\n/-  Predicate indicating array elements outside  remain unchanged after operation -/\n\n/-  Partition method specification -/\n\n/-  Partition method implementation -/", "vc-preamble": "\ndef count (a : Array Int) (x : Int) : Nat :=\na.foldl (fun acc y => if y = x then acc + 1 else acc) 0\n\ndef SplitPoint (a : Array Int) (n : Nat) : Prop :=\n∀ i j, 0 ≤ i ∧ i < n ∧ n ≤ j ∧ j < a.size → a[i]! ≤ a[j]!\n\ndef SwapFrame (a a' : Array Int) (lo hi : Nat) : Prop :=\n(∀ i, (0 ≤ i ∧ i < lo) ∨ (hi ≤ i ∧ i < a.size) → a[i]! = a'[i]!) ∧\n(∀ x : Int, count a x = count a' x)", "vc-helpers": "", "vc-definitions": "def Partition (a : Array Int) (lo hi : Int) : Int :=\nsorry", "vc-theorems": "theorem partition_spec (a a' : Array Int) (lo hi p : Nat) :\n0 ≤ lo ∧ lo < hi ∧ hi ≤ a.size →\nSplitPoint a lo ∧ SplitPoint a hi →\nlo ≤ p ∧ p < hi →\n(∀ i, lo ≤ i ∧ i < p → a'[i]! < a'[p]!) →\n(∀ i, p ≤ i ∧ i < hi → a'[p]! ≤ a'[i]!) →\nSplitPoint a' lo ∧ SplitPoint a' hi →\nSwapFrame a a' lo hi →\nTrue :=\nsorry", "vc-postamble": ""}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_ProgramProofs_ch15_QuickSort", "vc-description": "/- \n{\n\"name\": \"Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_ProgramProofs_ch15_QuickSort\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_ProgramProofs_ch15_QuickSort\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Partition function that partitions an array around a pivot -/\n\n/-  Predicate indicating elements before n are less than or equal to elements after n -/\n\n/-  Frame condition for QuickSort ensuring elements outside  don't change -/\n\n/-  Auxiliary function for QuickSort implementation -/\n\n/-  QuickSort implementation -/\n\n/-  Main QuickSort function specification -/", "vc-preamble": "def SplitPoint (a : Array Int) (n : Nat) : Prop :=\n∀ i j, 0 ≤ i ∧ i < n ∧ n ≤ j ∧ j < a.size → a[i]! ≤ a[j]!\n\ndef SwapFrame (a a' : Array Int) (lo hi : Nat) : Prop :=\n(∀ i, (0 ≤ i ∧ i < lo) ∨ (hi ≤ i ∧ i < a.size) → a[i]! = a'[i]!)", "vc-helpers": "", "vc-definitions": "def Partition (a : Array Int) (lo hi : Int) : Int :=\nsorry\n\ndef QuickSortAux (a : Array Int) (lo hi : Nat) : Array Int :=\nsorry\n\ndef QuickSort (a : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem quicksort_spec (a : Array Int) :\nlet a' := QuickSort a\n∀ i j, 0 ≤ i ∧ i < j ∧ j < a'.size → a'[i]! ≤ a'[j]! :=\nsorry", "vc-postamble": ""}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_ProgramProofs_ch15_QuickSortAux", "vc-description": "/- \n{\n\"name\": \"Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_ProgramProofs_ch15_QuickSortAux\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_ProgramProofs_ch15_QuickSortAux\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate indicating elements before n are less than or equal to elements after n -/\n\n/-  Predicate indicating array elements outside  remain unchanged after modification -/\n\n/-  Partition array into sections less than and greater than pivot -/\n\n/-  Specification for Partition method -/\n\n/-  QuickSort auxiliary method for sorting array segment -/\n\n/-  Specification for QuickSortAux method -/", "vc-preamble": "def SplitPoint (a : Array Int) (n : Nat) : Prop :=\n∀ i j, 0 ≤ i ∧ i < n ∧ n ≤ j ∧ j < a.size → a[i]! ≤ a[j]!\n\ndef SwapFrame (a a' : Array Int) (lo hi : Nat) : Prop :=\n(∀ i, (0 ≤ i ∧ i < lo) ∨ (hi ≤ i ∧ i < a.size) → a[i]! = a'[i]!)", "vc-helpers": "", "vc-definitions": "def Partition (a : Array Int) (lo hi : Nat) : Int :=\nsorry\n\ndef QuickSortAux (a : Array Int) (lo hi : Nat) : Array Int :=\nsorry", "vc-theorems": "theorem Partition_spec (a : Array Int) (lo hi : Nat) :\n0 ≤ lo ∧ lo < hi ∧ hi ≤ a.size ∧\nSplitPoint a lo ∧ SplitPoint a hi →\nlet p := Partition a lo hi;\nlet a' := a;\nlo ≤ p ∧ p < hi ∧\n(∀ i, lo ≤ i ∧ i < p → a'[i]! < a'[p.toNat]!) ∧\n(∀ i, p ≤ i ∧ i < hi → a'[p.toNat]! ≤ a'[i.toNat]!) ∧\nSplitPoint a' lo ∧ SplitPoint a' hi ∧\nSwapFrame a a' lo hi :=\nsorry\n\ntheorem QuickSortAux_spec (a : Array Int) (lo hi : Nat) :\n0 ≤ lo ∧ lo ≤ hi ∧ hi ≤ a.size ∧\nSplitPoint a lo ∧ SplitPoint a hi →\nlet a' := QuickSortAux a lo hi;\n(∀ i j, lo ≤ i ∧ i < j ∧ j < hi → a'[i]! ≤ a'[j]!) ∧\nSwapFrame a a' lo hi ∧\nSplitPoint a' lo ∧ SplitPoint a' hi :=\nsorry", "vc-postamble": ""}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_ProgramProofs_ch15_SelectionSort", "vc-description": "/- \n{\n\"name\": \"Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_ProgramProofs_ch15_SelectionSort\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_ProgramProofs_ch15_SelectionSort\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nPredicate indicating that elements before index n are less than or equal to elements after n\n-/\n\n/- \nTwo-state predicate specifying frame conditions for swapping elements\n-/\n\n/- \nSelection sort specification and implementation\n-/", "vc-preamble": "def count (a : Array Int) (x : Int) : Nat :=\na.foldl (fun acc y => if y = x then acc + 1 else acc) 0\n\ndef SplitPoint (a : Array Int) (n : Nat) : Prop :=\n∀ i j, 0 ≤ i ∧ i < n ∧ n ≤ j ∧ j < a.size → a[i]! ≤ a[j]!\n\ndef SwapFrame (a a' : Array Int) (lo hi : Nat) : Prop :=\n(∀ i, (0 ≤ i ∧ i < lo) ∨ (hi ≤ i ∧ i < a.size) → a[i]! = a'[i]!) ∧\n(∀ x : Int, count a x = count a' x)", "vc-helpers": "", "vc-definitions": "def SelectionSort (a : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem SelectionSort_spec (a : Array Int) :\nlet result := SelectionSort a\n(∀ i j, 0 ≤ i ∧ i < j ∧ j < result.size → result[i]! ≤ result[j]!) ∧\nresult.size = a.size :=\nsorry", "vc-postamble": ""}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_examples_bubblesort_BubbleSort", "vc-description": "/- \n{\n\"name\": \"Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_examples_bubblesort_BubbleSort\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_examples_bubblesort_BubbleSort\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nComputes n choose 2 (n * (n-1) / 2)\n-/\n\n/- \nBubbleSort implementation with complexity specification\n-/", "vc-preamble": "def NChoose2 (n : Int) : Int :=\nn * (n - 1) / 2", "vc-helpers": "", "vc-definitions": "def BubbleSort (a : Array Int) : Nat :=\nsorry", "vc-theorems": "theorem bubbleSort_spec (a : Array Int) (n : Nat) :\nn ≤ NChoose2 a.size :=\nsorry", "vc-postamble": ""}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_examples_relativeOrder_FindEvenNumbers", "vc-description": "/- \n{\n\"name\": \"Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_examples_relativeOrder_FindEvenNumbers\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_examples_relativeOrder_FindEvenNumbers\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate indicating if a number is even -/\n\n/-  FindEvenNumbers takes an array of integers and returns an array containing only the even numbers\nwhile preserving their relative order -/", "vc-preamble": "def IsEven (n : Int) : Bool :=\nn % 2 = 0", "vc-helpers": "", "vc-definitions": "def FindEvenNumbers (arr : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem FindEvenNumbers_spec (arr : Array Int) (evenNumbers : Array Int) :\n(evenNumbers = FindEvenNumbers arr) →\n(∀ x, (arr.contains x ∧ IsEven x) → evenNumbers.contains x) ∧\n(∀ x, ¬arr.contains x → ¬evenNumbers.contains x) ∧\n(∀ k l, 0 ≤ k ∧ k < l ∧ l < evenNumbers.size →\n∃ n m, 0 ≤ n ∧ n < m ∧ m < arr.size ∧\nevenNumbers[k]! = arr[n]! ∧ evenNumbers[l]! = arr[m]!) :=\nsorry", "vc-postamble": ""}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_leetcode_FindPivotIndex_FindPivotIndex", "vc-description": "/- \n{\n\"name\": \"Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_leetcode_FindPivotIndex_FindPivotIndex\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_leetcode_FindPivotIndex_FindPivotIndex\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Sum of elements in an array from start to end -/\n\n/- \nFind pivot index in array where sum of elements to left equals sum of elements to right.\nReturns leftmost such index or -1 if none exists.\n-/", "vc-preamble": "partial def sum (nums : Array Int) : Int :=\nif nums.size = 0 then 0\nelse sum (nums.extract 0 (nums.size - 1)) + nums[nums.size - 1]!", "vc-helpers": "", "vc-definitions": "def FindPivotIndex (nums : Array Int) : Int :=\nsorry", "vc-theorems": "theorem FindPivotIndex_spec (nums : Array Int) :\nnums.size > 0 →\n(let index := FindPivotIndex nums\n(index = -1 →\n∀ k : Nat, k < nums.size →\nsum (nums.extract 0 k) ≠ sum (nums.extract (k+1) nums.size)) ∧\n(0 ≤ index ∧ index < nums.size →\nsum (nums.extract 0 index.toNat) = sum (nums.extract (index.toNat+1) nums.size))) :=\nsorry", "vc-postamble": ""}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_leetcode_lc-remove-element_removeElement", "vc-description": "/- \n{\n\"name\": \"Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_leetcode_lc-remove-element_removeElement\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_leetcode_lc-remove-element_removeElement\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nRemoves all occurrences of a value from an array and returns the new length.\nTranslated from Dafny's removeElement method.\n\n@param nums The input array\n@param val The value to remove\n@return The new length after removing elements\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def removeElement (nums : Array Int) (val : Int) : Int :=\nsorry", "vc-theorems": "theorem removeElement_spec (nums : Array Int) (val : Int) (i : Nat) :\ni < nums.size →\n(∀ k, 0 < k ∧ k < i → nums[k]! ≠ val) :=\nsorry", "vc-postamble": ""}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_leetcode_validAnagram_isAnagram", "vc-description": "/- \n{\n\"name\": \"Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_leetcode_validAnagram_isAnagram\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_leetcode_validAnagram_isAnagram\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nConverts a string to a array of characters.\n-/\n\n/- \nChecks if two arrays of characters are equal.\n-/\n\n/- \nSpecification for toMultiset function.\n-/\n\n/- \nSpecification for msetEqual function.\n-/\n\n/- \nMain isAnagram function that checks if two strings are anagrams.\n-/\n\n/- \nSpecification for isAnagram function ensuring it correctly identifies anagrams.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def toMultiset (s : String) : Array Char :=\nsorry\n\ndef msetEqual (s t : Array Char) : Bool :=\nsorry\n\ndef isAnagram (s t : String) : Bool :=\nsorry", "vc-theorems": "theorem toMultiset_spec (s : String) :\ntoMultiset s = s.data.toArray :=\nsorry\n\ntheorem msetEqual_spec (s t : Array Char) :\nmsetEqual s t = (s = t) :=\nsorry\n\ntheorem isAnagram_spec (s t : String) :\nisAnagram s t = (s.data.toArray = t.data.toArray) :=\nsorry", "vc-postamble": ""}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic_examples_BubbleSort_bubbleSort", "vc-description": "/- \n{\n\"name\": \"Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_BubbleSort_bubbleSort\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_BubbleSort_bubbleSort\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nPredicate indicating if an array is sorted between given indices.\n-/\n\n/- \nPredicate indicating if elements before pivot are less than elements after.\n-/\n\n/- \nBubble sort implementation with specification.\nRequires:\n- Array is non-null and non-empty\nEnsures:\n- Array is sorted\n- Output array is a permutation of input array\n-/", "vc-preamble": "def sorted (a : Array Int) (from_ : Nat) (to : Nat) : Prop :=\n∀ u v, from_ ≤ u ∧ u < v ∧ v < to → a[u]! ≤ a[v]!\ndef pivot (a : Array Int) (to : Nat) (pvt : Nat) : Prop :=\n∀ u v, 0 ≤ u ∧ u < pvt ∧ pvt < v ∧ v < to → a[u]! ≤ a[v]!", "vc-helpers": "", "vc-definitions": "def bubbleSort (a : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem bubbleSort_spec (a : Array Int) :\na.size > 0 →\nlet result := bubbleSort a\nsorted result 0 result.size ∧\n\n-- Note: Multiset equality is simplified to size equality for basic spec\n\nresult.size = a.size :=\nsorry", "vc-postamble": ""}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic_examples_BubbleSort_sol_bubbleSort", "vc-description": "/- \n{\n\"name\": \"Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_BubbleSort_sol_bubbleSort\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_BubbleSort_sol_bubbleSort\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nPredicate indicating if an array is sorted between two indices.\n-/\n\n/- \nPredicate indicating if an array is fully sorted.\n-/\n\n/- \nBubbleSort implementation with specifications.\n-/", "vc-preamble": "def sorted_between (a : Array Int) (from_ : Nat) (to : Nat) : Prop :=\n∀ i j, from_ ≤ i ∧ i < j ∧ j < to ∧ 0 ≤ i ∧ i < j ∧ j < a.size →\na[i]! ≤ a[j]!\ndef sorted (a : Array Int) : Prop :=\nsorted_between a 0 a.size", "vc-helpers": "", "vc-definitions": "def bubbleSort (a : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem bubbleSort_spec (a : Array Int) :\na.size > 0 →\nlet result := bubbleSort a\nsorted result ∧\n\n-- Note: Multiset equality check simplified since complex array operations are avoided\n\nresult.size = a.size :=\nsorry", "vc-postamble": ""}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_from_dafny_main_repo_dafny2_COST-verif-comp-2011-3-TwoDuplicates_Search", "vc-description": "/- \n{\n\"name\": \"Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_from dafny main repo_dafny2_COST-verif-comp-2011-3-TwoDuplicates_Search\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_from dafny main repo_dafny2_COST-verif-comp-2011-3-TwoDuplicates_Search\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nChecks if a value appears twice in an array up to index k\n-/\n\n/- \nChecks if a value appears twice in the full array\n-/\n\n/- \nSearch for two values that each appear twice in the array.\nReturns a pair of such values.\n\nRequirements:\n- Array has at least 4 elements\n- There exist two distinct values that each appear twice\n- All array elements are between 0 and array.size-2\n-/", "vc-preamble": "def IsPrefixDuplicate (a : Array Int) (k : Int) (p : Int) : Prop :=\n∃ i j, 0 ≤ i ∧ i < j ∧ j < k ∧ a[i.toNat]! = p ∧ a[j.toNat]! = p\ndef IsDuplicate (a : Array Int) (p : Int) : Prop :=\nIsPrefixDuplicate a a.size p", "vc-helpers": "", "vc-definitions": "def Search (a : Array Int) : (Int × Int) :=\nsorry", "vc-theorems": "theorem Search_spec (a : Array Int) :\n(4 ≤ a.size) →\n(∃ p q, p ≠ q ∧ IsDuplicate a p ∧ IsDuplicate a q) →\n(∀ i, 0 ≤ i ∧ i < a.size → 0 ≤ a[i]! ∧ a[i]! < a.size - 2) →\nlet (p, q) := Search a\np ≠ q ∧ IsDuplicate a p ∧ IsDuplicate a q :=\nsorry", "vc-postamble": ""}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_from_dafny_main_repo_dafny2_Classics_FIND", "vc-description": "/- \n{\n\"name\": \"Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_from dafny main repo_dafny2_Classics_FIND\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_from dafny main repo_dafny2_Classics_FIND\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nFIND algorithm from Hoare's paper, translated from Dafny.\nTakes an array A, its size N, and an index f.\nRearranges elements such that all elements at indices ≤ f are ≤ elements at indices ≥ f.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def FIND (A : Array Int) (N : Int) (f : Int) : Array Int :=\nsorry", "vc-theorems": "theorem FIND_spec (A : Array Int) (N : Int) (f : Int) :\nA.size = N →\n0 ≤ f →\nf < N →\n∀ p q : Int, 0 ≤ p → p ≤ f → f ≤ q → q < N →\n(FIND A N f)[p.toNat]! ≤ (FIND A N f)[q.toNat]! :=\nsorry", "vc-postamble": ""}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_mathematical_objects_verification_examples_fast_exp_FastExp", "vc-description": "/- \n{\n\"name\": \"Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_mathematical objects verification_examples_fast_exp_FastExp\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_mathematical objects verification_examples_fast_exp_FastExp\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Sum of elements in an array up to index i -/\n\n/-  Exponentiation function -/\n\n/-  Convert number to binary representation as boolean array -/\n\n/-  Convert boolean array binary representation back to number -/\n\n/-  Fast exponentiation method specification -/", "vc-preamble": "partial def sum (s : Array Int) (i : Nat) : Int :=\nif i == 0 then 0\nelse sum s (i-1) + s[i-1]!\npartial def exp (b : Nat) (n : Nat) : Nat :=\nif n == 0 then 1\nelse b * exp b (n-1)\npartial def bits (n : Nat) : Array Bool :=\nif n == 0 then #[]\nelse #[n % 2 == 0] ++ bits (n/2)\npartial def from_bits (s : Array Bool) : Nat :=\nif s.size == 0 then 0\nelse (if s[0]! then 1 else 0) + 2 * from_bits (s.extract 1 s.size)", "vc-helpers": "", "vc-definitions": "def FastExp (b : Nat) (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem FastExp_spec (b n : Nat) :\nFastExp b n = exp b n :=\nsorry", "vc-postamble": ""}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_verified_algorithms_lol_sort_lol_sort", "vc-description": "/- \n{\n\"name\": \"Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_verified algorithms_lol_sort_lol_sort\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_verified algorithms_lol_sort_lol_sort\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Count the number of occurrences of an element in an array -/\n\n/-  Predicate defining if two arrays are valid permutations of each other -/\n\n/-  Swaps two elements in an array -/\n\n/-  Theorem specifying the properties of swap -/\n\n/-  Predicate defining if an array is sorted in increasing order -/\n\n/-  The lol sort algorithm implementation -/\n\n/-  Theorem specifying the properties of lol_sort -/", "vc-preamble": "def count (a : Array Int) (x : Int) : Nat :=\na.foldl (fun acc y => if y = x then acc + 1 else acc) 0\n\ndef valid_permut (a b : Array Int) : Prop :=\na.size = b.size ∧ ∀ x : Int, count a x = count b x\n\ndef sorted (a : Array Int) : Prop :=\n∀ i j, 0 ≤ i ∧ i ≤ j ∧ j < a.size → a[i]! ≤ a[j]!", "vc-helpers": "", "vc-definitions": "def swap (a : Array Int) (i j : Int) : Array Int :=\nsorry\n\ndef lol_sort (a : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem swap_spec (a : Array Int) (i j : Int) :\n0 ≤ i ∧ i < a.size ∧ 0 ≤ j ∧ j < a.size →\nlet result := swap a i j\nresult.size = a.size ∧ valid_permut result a :=\nsorry\n\ntheorem lol_sort_spec (a : Array Int) :\nlet result := lol_sort a\nvalid_permut result a ∧ sorted result :=\nsorry", "vc-postamble": ""}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_verified_algorithms_lol_sort_swap", "vc-description": "/- \n{\n\"name\": \"Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_verified algorithms_lol_sort_swap\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_verified algorithms_lol_sort_swap\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nDefines when two arrays are valid permutations of each other by comparing their Lists\n-/\n\n/- \nDefines when an array is sorted in increasing order\n-/\n\n/- \nSwaps two elements in an array at indices i and j\n-/", "vc-preamble": "def valid_permut (a b : Array Int) : Prop :=\na.size = b.size ∧ a.toList = b.toList\ndef sorted (a : Array Int) : Prop :=\n∀ i j, 0 ≤ i → i ≤ j → j < a.size → a[i]! ≤ a[j]!", "vc-helpers": "", "vc-definitions": "def swap (a : Array Int) (i j : Int) : Array Int :=\nsorry", "vc-theorems": "theorem swap_spec (a : Array Int) (i j : Nat) :\n0 ≤ i → i < a.size → 0 ≤ j → j < a.size →\nlet result := swap a i j\n\n-- Result is a valid permutation\n\nvalid_permut result a ∧\n\n-- Elements are swapped correctly\n\nresult.size = a.size ∧\n\nresult[i]! = a[j]! ∧\n\nresult[j]! = a[i]! ∧\n\n-- Other elements remain unchanged\n\n(∀ k, 0 ≤ k → k < a.size → k ≠ i → k ≠ j → result[k]! = a[k]!) :=\nsorry", "vc-postamble": ""}
{"id": "Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_04_Hoangkim_ex_04_Hoangkim_intDiv", "vc-description": "/- \n{\n\"name\": \"Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_04_Hoangkim_ex_04_Hoangkim_intDiv\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_04_Hoangkim_ex_04_Hoangkim_intDiv\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nTranslates the Dafny method intDiv which computes integer division with remainder.\nInput parameters:\n- n: Int - dividend\n- d: Int - divisor\nReturns:\n- (q, r): (Int, Int) - quotient and remainder\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def intDiv (n : Int) (d : Int) : (Int × Int) :=\nsorry", "vc-theorems": "theorem intDiv_spec (n d : Int) :\nn ≥ d ∧ n ≥ 0 ∧ d > 0 →\nlet (q, r) := intDiv n d\n(d*q + r = n) ∧ (0 ≤ q) ∧ (q ≤ n/2) ∧ (0 ≤ r) ∧ (r < d) :=\nsorry", "vc-postamble": ""}
{"id": "Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_05_Hoangkim_ex_05_Hoangkim_gcdI", "vc-description": "/- \n{\n\"name\": \"Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_05_Hoangkim_ex_05_Hoangkim_gcdI\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_05_Hoangkim_ex_05_Hoangkim_gcdI\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Fibonacci function translated from Dafny -/\n\n/-  Factorial function translated from Dafny -/\n\n/-  Greatest common divisor function translated from Dafny -/\n\n/-  Specification for gcd function -/\n\n/-  Implementation of iterative GCD algorithm -/\n\n/-  Specification for gcdI method -/", "vc-preamble": "def fib (n : Nat) : Nat :=\nif n < 2 then n else fib (n-2) + fib (n-1)\n\npartial def fact (n : Nat) : Nat :=\nif n == 0 then 1 else n * fact (n-1)\n\npartial def gcd (m n : Nat) : Nat :=\nif m == n then m\nelse if m > n then gcd (m - n) n\nelse gcd m (n - m)", "vc-helpers": "", "vc-definitions": "def gcdI (m n : Int) : Int :=\nsorry", "vc-theorems": "theorem gcd_spec (m n : Nat) :\nm > 0 ∧ n > 0 → gcd m n > 0 :=\nsorry\n\ntheorem gcdI_spec (m n : Nat) :\nm > 0 ∧ n > 0 → gcdI m n = gcd m n :=\nsorry", "vc-postamble": ""}
{"id": "Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_06_Hoangkim_ex_06_hoangkim_gcdI", "vc-description": "/- \n{\n\"name\": \"Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_06_Hoangkim_ex_06_hoangkim_gcdI\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_06_Hoangkim_ex_06_hoangkim_gcdI\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Translation of Dafny ghost function gcd -/\n\n/-  Specification for gcd function -/\n\n/-  Translation of Dafny ghost function gcd' -/\n\n/-  Specification for gcd' function -/\n\n/-  Translation of Dafny method gcdI -/\n\n/-  Specification for gcdI method -/", "vc-preamble": "partial def gcd (x y : Int) : Int :=\nif x = y then x\nelse if x > y then gcd (x - y) y\nelse gcd x (y - x)\n\npartial def gcd' (x y : Int) : Int :=\nif x = y then x\nelse if x > y then gcd' (x - y) y\nelse gcd y x", "vc-helpers": "", "vc-definitions": "def gcdI (m n : Int) : Int :=\nsorry", "vc-theorems": "theorem gcd_spec (x y : Int) :\nx > 0 ∧ y > 0 → gcd x y > 0 :=\nsorry\n\ntheorem gcd'_spec (x y : Int) :\nx > 0 ∧ y > 0 → gcd' x y > 0 :=\nsorry\n\ntheorem gcdI_spec (m n : Int) :\nm > 0 ∧ n > 0 → gcdI m n = gcd m n :=\nsorry", "vc-postamble": ""}
{"id": "Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_07_Hoangkim_ex07_Hoangkim_FindMin", "vc-description": "/- \n{\n\"name\": \"Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_07_Hoangkim_ex07_Hoangkim_FindMin\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_07_Hoangkim_ex07_Hoangkim_FindMin\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nPredicate indicating if an array of integers is sorted in ascending order.\nTranslated from Dafny's `sorted` predicate.\n-/\n\n/- \nFindMin method specification translated from Dafny.\nReturns the index of minimum element in array slice from lo to end.\n\nParameters:\n- a: Array of integers\n- lo: Natural number index to start search from\n\nReturns:\n- minIdx: Index of minimum element in slice\n\nRequirements:\n- Array must be non-null and non-empty\n- lo must be valid index\n-/", "vc-preamble": "def sorted (a : Array Int) : Prop :=\n∀ i, 0 < i ∧ i < a.size → a[i-1]! ≤ a[i]!", "vc-helpers": "", "vc-definitions": "def FindMin (a : Array Int) (lo : Nat) : Nat :=\nsorry", "vc-theorems": "theorem FindMin_spec (a : Array Int) (lo : Nat) :\na.size > 0 ∧ lo < a.size →\nlet minIdx := FindMin a lo\nminIdx ≥ lo ∧ minIdx < a.size ∧\n(∀ x, lo ≤ x ∧ x < a.size → a[minIdx]! ≤ a[x]!) :=\nsorry", "vc-postamble": ""}
{"id": "Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_07_Hoangkim_ex07_Hoangkim_selectionSort", "vc-description": "/- \n{\n\"name\": \"Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_07_Hoangkim_ex07_Hoangkim_selectionSort\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_07_Hoangkim_ex07_Hoangkim_selectionSort\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  FindMin returns the index of the minimum element in array a starting from index lo -/\n\n/-  Specification for FindMin -/\n\n/-  Predicate indicating if an array is sorted -/\n\n/-  Selection sort implementation -/\n\n/-  Specification for selectionSort -/", "vc-preamble": "def sorted (a : Array Int) : Prop :=\n∀ i, 0 < i ∧ i < a.size → a[i-1]! ≤ a[i]!", "vc-helpers": "", "vc-definitions": "def FindMin (a : Array Int) (lo : Nat) : Nat :=\nsorry\n\ndef selectionSort (a : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem FindMin_spec (a : Array Int) (lo : Nat) :\na.size > 0 ∧ lo < a.size →\nlet minIdx := FindMin a lo\nlo ≤ minIdx ∧ minIdx < a.size ∧\n∀ x, lo ≤ x ∧ x < a.size → a[minIdx]! ≤ a[x]! :=\nsorry\n\ntheorem selectionSort_spec (a : Array Int) :\nsorted (selectionSort a) :=\nsorry", "vc-postamble": ""}
{"id": "Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_10_Hoangkim_ex10_hoangkim_q", "vc-description": "/- \n{\n\"name\": \"Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_10_Hoangkim_ex10_hoangkim_q\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_10_Hoangkim_ex10_hoangkim_q\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Translation of method q from Dafny:\nRequires y - x > 2\nEnsures x < z*z < y\n-/\n\n/-  Specification for method q -/\n\n/-  Translation of method strange from Dafny:\nEnsures 1 = 2\n-/\n\n/-  Specification for method strange -/\n\n/-  Verification condition 1: Precondition implies loop variant -/\n\n/-  Verification condition 2: Loop invariant preservation -/\n\n/-  Verification condition 3: Loop termination and postcondition -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def q (x : Nat) (y : Nat) : Nat :=\nsorry\n\ndef strange : Unit :=\nsorry", "vc-theorems": "theorem q_spec (x y z : Nat) :\ny - x > 2 →\nx < z*z ∧ z*z < y :=\nsorry\n\ntheorem strange_spec :\n1 = 2 :=\nsorry\n\ntheorem vc1 (n : Nat) :\nn ≥ 0 → 0 = 0*0 ∧ 0 ≤ n :=\nsorry\n\ntheorem vc2 (i n sqn x : Nat) :\ni < n ∧ i + 1 ≤ n ∧ sqn = i * i →\nsqn = sqn + x ∧ i = i + 1 ∧ x = 2 * i + 1 :=\nsorry\n\ntheorem vc3 (i n sqn : Nat) :\n¬(i < n) ∧ i ≤ n ∧ sqn = i * i →\nsqn = n * n :=\nsorry", "vc-postamble": ""}
{"id": "Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_10_Hoangkim_ex10_hoangkim_strange", "vc-description": "/- \n{\n\"name\": \"Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_10_Hoangkim_ex10_hoangkim_strange\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_10_Hoangkim_ex10_hoangkim_strange\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nTranslation of method q from Dafny.\nOriginal requires: y - x > 2\nOriginal ensures: x < z*z < y\n-/\n\n/- \nSpecification for method q\n-/\n\n/- \nTranslation of method strange from Dafny.\nOriginal ensures: 1 == 2\n-/\n\n/- \nSpecification for method strange\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def q (x : Nat) (y : Nat) : Nat :=\nsorry\n\ndef strange : Unit :=\nsorry", "vc-theorems": "theorem q_spec (x y : Nat) :\ny - x > 2 → ∃ z, x < z*z ∧ z*z < y :=\nsorry\n\ntheorem strange_spec :\n1 = 2 :=\nsorry", "vc-postamble": ""}
{"id": "SENG2011_tmp_tmpgk5jq85q_ass2_ex1_StringSwap", "vc-description": "/- \n{\n\"name\": \"SENG2011_tmp_tmpgk5jq85q_ass2_ex1_StringSwap\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: SENG2011_tmp_tmpgk5jq85q_ass2_ex1_StringSwap\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nStringSwap takes a string and two natural number indices and swaps the characters at those positions.\nTranslated from Dafny specification.\n\n@param s The input string\n@param i First index to swap\n@param j Second index to swap\n@return The string with characters at positions i and j swapped\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def StringSwap (s : String) (i j : Nat) : String :=\nsorry", "vc-theorems": "theorem StringSwap_spec (s : String) (i j : Nat) :\ni ≥ 0 ∧ j ≥ 0 ∧ s.length ≥ 0 →\n(s.length > 0 → i < s.length ∧ j < s.length) →\nlet t := StringSwap s i j\n(s.length = t.length) ∧\n(s.length > 0 →\n(∀ k : Nat, k ≠ i ∧ k ≠ j ∧ k < s.length → t.get ⟨k⟩ = s.get ⟨k⟩) ∧\nt.get ⟨i⟩ = s.get ⟨j⟩ ∧ t.get ⟨j⟩ = s.get ⟨i⟩) ∧\n(s.length = 0 → t = s) :=\nsorry", "vc-postamble": ""}
{"id": "SENG2011_tmp_tmpgk5jq85q_ass2_ex2_String3Sort", "vc-description": "/- \n{\n\"name\": \"SENG2011_tmp_tmpgk5jq85q_ass2_ex2_String3Sort\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: SENG2011_tmp_tmpgk5jq85q_ass2_ex2_String3Sort\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nPredicate checking if a string is sorted between given indices.\n-/\n\n/- \nMain sorting function for 3-character strings.\nEnsures output is sorted and contains same characters as input.\n-/", "vc-preamble": "def Sorted (a : String) (low : Int) (high : Int) : Prop :=\n0 ≤ low ∧ low ≤ high ∧ high ≤ a.length →\n∀ j k:Nat, low ≤ j ∧ j < k ∧ k < high →\na.get ⟨j⟩ ≤ a.get ⟨k⟩", "vc-helpers": "", "vc-definitions": "def String3Sort (a : String) : String :=\nsorry", "vc-theorems": "theorem String3Sort_spec (a : String) :\na.length = 3 →\nlet b := String3Sort a\nSorted b 0 b.length ∧\nb.length = a.length ∧\n\n-- Note: Simplified multiset condition since exact multiset comparison is complex\n-- All characters from input appear in output (simplified multiset condition)\n\n(b.get ⟨0⟩ = a.get ⟨0⟩ ∨ b.get ⟨0⟩ = a.get ⟨1⟩ ∨ b.get ⟨0⟩ = a.get ⟨2⟩) ∧\n\n(b.get ⟨1⟩ = a.get ⟨0⟩ ∨ b.get ⟨1⟩ = a.get ⟨1⟩ ∨ b.get ⟨1⟩ = a.get ⟨2⟩) ∧\n\n(b.get ⟨2⟩ = a.get ⟨0⟩ ∨ b.get ⟨2⟩ = a.get ⟨1⟩ ∨ b.get ⟨2⟩ = a.get ⟨2⟩) :=\nsorry", "vc-postamble": ""}
{"id": "SENG2011_tmp_tmpgk5jq85q_ass2_ex3_BadSort", "vc-description": "/- \n{\n\"name\": \"SENG2011_tmp_tmpgk5jq85q_ass2_ex3_BadSort\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: SENG2011_tmp_tmpgk5jq85q_ass2_ex3_BadSort\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nPredicate that checks if a string is sorted with all b's before all a's which are before all d's\n-/\n\n/- \nBadSort function that takes a string and returns a sorted version according to sortedbad predicate\n-/", "vc-preamble": "def sortedbad (s : String) : Prop :=\n(∀ i j, 0 ≤ i ∧ i < s.length ∧ 0 ≤ j ∧ j < s.length ∧ s.get ⟨i⟩ = 'b' ∧ (s.get ⟨j⟩ = 'a' ∨ s.get ⟨j⟩ = 'd') → i < j) ∧\n(∀ i j, 0 ≤ i ∧ i < s.length ∧ 0 ≤ j ∧ j < s.length ∧ s.get ⟨i⟩ = 'a' ∧ s.get ⟨j⟩ = 'b' → i > j) ∧\n(∀ i j, 0 ≤ i ∧ i < s.length ∧ 0 ≤ j ∧ j < s.length ∧ s.get ⟨i⟩ = 'a' ∧ s.get ⟨j⟩ = 'd' → i < j) ∧\n(∀ i j, 0 ≤ i ∧ i < s.length ∧ 0 ≤ j ∧ j < s.length ∧ s.get ⟨i⟩ = 'd' ∧ (s.get ⟨j⟩ = 'a' ∨ s.get ⟨j⟩ = 'b') → i > j)", "vc-helpers": "", "vc-definitions": "def BadSort (a : String) : String :=\nsorry", "vc-theorems": "theorem BadSort_spec (a : String) :\n(∀ k, 0 ≤ k ∧ k < a.length → (a.get ⟨k⟩ = 'b' ∨ a.get ⟨k⟩ = 'a' ∨ a.get ⟨k⟩ = 'd')) →\nlet b := BadSort a\nsortedbad b ∧\nb.length = a.length :=\nsorry", "vc-postamble": ""}
{"id": "SENG2011_tmp_tmpgk5jq85q_exam_ex2_Getmini", "vc-description": "/- \n{\n\"name\": \"SENG2011_tmp_tmpgk5jq85q_exam_ex2_Getmini\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: SENG2011_tmp_tmpgk5jq85q_exam_ex2_Getmini\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nFinds the index of the first minimum element in an array.\n\n@param a The input array of integers\n@return mini The index of the first minimum element\n\nSpecification:\n- Requires array is non-empty\n- Ensures mini is a valid index\n- Ensures a is the minimum value\n- Ensures a is the first minimum value\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Getmini (a : Array Int) : Nat :=\nsorry", "vc-theorems": "theorem Getmini_spec (a : Array Int) (mini : Nat) :\na.size > 0 →\n(mini = Getmini a) →\n(0 ≤ mini ∧ mini < a.size) ∧\n(∀ x, 0 ≤ x ∧ x < a.size → a[mini]! ≤ a[x]!) ∧\n(∀ x, 0 ≤ x ∧ x < mini → a[mini]! < a[x]!) :=\nsorry", "vc-postamble": ""}
{"id": "SENG2011_tmp_tmpgk5jq85q_exam_ex3_Symmetric", "vc-description": "/- \n{\n\"name\": \"SENG2011_tmp_tmpgk5jq85q_exam_ex3_Symmetric\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: SENG2011_tmp_tmpgk5jq85q_exam_ex3_Symmetric\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nChecks if an array is symmetric around its midpoint.\nTranslated from Dafny method Symmetric.\n\n@param a The input array to check for symmetry\n@return A boolean flag indicating if the array is symmetric\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Symmetric (a : Array Int) : Bool :=\nsorry", "vc-theorems": "theorem Symmetric_spec (a : Array Int) :\nlet flag := Symmetric a\n(flag = true → ∀ x, 0 ≤ x ∧ x < a.size → a[x]! = a[a.size - x - 1]!) ∧\n(flag = false → ∃ x, 0 ≤ x ∧ x < a.size ∧ a[x]! ≠ a[a.size - x - 1]!) :=\nsorry", "vc-postamble": ""}
{"id": "SENG2011_tmp_tmpgk5jq85q_flex_ex1_sum", "vc-description": "/- \n{\n\"name\": \"SENG2011_tmp_tmpgk5jq85q_flex_ex1_sum\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: SENG2011_tmp_tmpgk5jq85q_flex_ex1_sum\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nRecursively sums array elements from index 0 to i-1.\nTranslated from Dafny function sumcheck.\n-/\n\n/- \nReturns sum of array elements.\nTranslated from Dafny method sum.\n-/", "vc-preamble": "partial def sumcheck (s : Array Int) (i : Int) : Int :=\nif i == 0 then 0\nelse s[(i - 1).toNat]! + sumcheck s (i - 1)", "vc-helpers": "", "vc-definitions": "def sum (s : Array Int) : Int :=\nsorry", "vc-theorems": "theorem sum_spec (s : Array Int) :\ns.size > 0 →\nsum s = sumcheck s s.size :=\nsorry", "vc-postamble": ""}
{"id": "Simulink-To_dafny_tmp_tmpbcuesj2t_Tank_checkRegulation", "vc-description": "/- \n{\n\"name\": \"Simulink-To_dafny_tmp_tmpbcuesj2t_Tank_checkRegulation\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Simulink-To_dafny_tmp_tmpbcuesj2t_Tank_checkRegulation\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Valve type representing ON/OFF states -/\n\n/-  Pipe class containing valve states and flow values -/\n\n/-  Tank class containing a pipe and height -/\n\n/-  Constructor for Pipe with initial values -/\n\n/-  Constructor for Tank with initial values -/\n\n/-  Main regulation check specification -/\n\n/-  Implementation of checkRegulation -/", "vc-preamble": "inductive Valve\n| ON\n| OFF\n\nstructure Pipe where\nv1: Valve  -- outlet valve\nv2: Valve  -- inlet valve\nv3: Valve  -- outlet valve\nin_flowv1: Int  -- flow in valve v1\nin_flowv2: Int  -- flow in valve v2\nin_flowv3: Int  -- flow in valve v3\n\nstructure Tank where\npipe: Pipe\nheight: Int\n\ndef Pipe.init : Pipe := { \n    v1 := Valve.OFF\n    v2 := Valve.ON\n    v3 := Valve.OFF\n    in_flowv1 := 0\n    in_flowv2 := 0\n    in_flowv3 := 0 \n}\n\ndef Tank.init : Tank := { \n    pipe := Pipe.init\n    height := 0 \n}", "vc-helpers": "", "vc-definitions": "def checkRegulation (tank : Tank) : Tank :=\nsorry", "vc-theorems": "theorem checkRegulation_spec (tank tank' : Tank) :\n(tank'.height > 10 ∧ tank'.pipe.v1 = Valve.OFF ∧ tank'.pipe.v3 = Valve.ON ∧ tank'.pipe.v2 = tank.pipe.v2)\n∨\n(tank'.height < 8 ∧ tank'.pipe.v1 = Valve.OFF ∧ tank'.pipe.v2 = Valve.ON ∧ tank'.pipe.v3 = tank.pipe.v3)\n∨\n((tank'.pipe.in_flowv3 > 5 ∨ tank'.pipe.in_flowv1 > 5) ∧ tank'.pipe.v2 = Valve.OFF ∧ tank'.pipe.v3 = tank.pipe.v3 ∧ tank'.pipe.v1 = tank.pipe.v1)\n:=\nsorry", "vc-postamble": ""}
{"id": "Software-Verification_tmp_tmpv4ueky2d_Best_Time_to_Buy_and_Sell_Stock_best_time_to_buy_and_sell_stock_best_time_to_buy_and_sell_stock", "vc-description": "/- \n{\n\"name\": \"Software-Verification_tmp_tmpv4ueky2d_Best Time to Buy and Sell Stock_best_time_to_buy_and_sell_stock_best_time_to_buy_and_sell_stock\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Software-Verification_tmp_tmpv4ueky2d_Best Time to Buy and Sell Stock_best_time_to_buy_and_sell_stock_best_time_to_buy_and_sell_stock\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nFinds the maximum profit that can be made by buying and selling stock once.\nInput array represents stock prices over time.\nReturns maximum possible profit.\n\n@param prices Array of stock prices\n@return Maximum profit possible\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def best_time_to_buy_and_sell_stock (prices : Array Int) : Int :=\nsorry", "vc-theorems": "theorem best_time_to_buy_and_sell_stock_spec (prices : Array Int) :\n1 ≤ prices.size ∧ prices.size ≤ 100000 ∧\n(∀ i, 0 ≤ i ∧ i < prices.size → 0 ≤ prices[i]! ∧ prices[i]! ≤ 10000) →\nlet max_profit := best_time_to_buy_and_sell_stock prices\n∀ i j, 0 ≤ i ∧ i < j ∧ j < prices.size →\nmax_profit ≥ prices[j]! - prices[i]! :=\nsorry", "vc-postamble": ""}
{"id": "Software-Verification_tmp_tmpv4ueky2d_Contains_Duplicate_contains_duplicate_contains_duplicate", "vc-description": "/- \n{\n\"name\": \"Software-Verification_tmp_tmpv4ueky2d_Contains Duplicate_contains_duplicate_contains_duplicate\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Software-Verification_tmp_tmpv4ueky2d_Contains Duplicate_contains_duplicate_contains_duplicate\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nPredicate that checks if all elements in an array are distinct.\n-/\n\n/- \nMethod that checks if an array contains any duplicate elements.\nRequires:\n- Array size is between 1 and 100000\n- All elements are between -1000000000 and 1000000000\nEnsures:\n- Result is true if and only if all elements are distinct\n-/", "vc-preamble": "def distinct (nums : Array Int) : Prop :=\n∀ i j, 0 ≤ i → i < j → j < nums.size → nums[i]! ≠ nums[j]!", "vc-helpers": "", "vc-definitions": "def contains_duplicate (nums : Array Int) : Bool :=\nsorry", "vc-theorems": "theorem contains_duplicate_spec (nums : Array Int) :\n(1 ≤ nums.size ∧ nums.size ≤ 100000) →\n(∀ i, 0 ≤ i → i < nums.size → -1000000000 ≤ nums[i]! ∧ nums[i]! ≤ 1000000000) →\ncontains_duplicate nums = distinct nums :=\nsorry", "vc-postamble": ""}
{"id": "Software-Verification_tmp_tmpv4ueky2d_Counting_Bits_counting_bits_counting_bits", "vc-description": "/- \n{\n\"name\": \"Software-Verification_tmp_tmpv4ueky2d_Counting Bits_counting_bits_counting_bits\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Software-Verification_tmp_tmpv4ueky2d_Counting Bits_counting_bits_counting_bits\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nTranslates the Dafny counting_bits method which computes an array where each element\ncontains the number of 1 bits in its index.\n\n@param n The size parameter determining array length\n@return Array containing bit counts\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def counting_bits (n : Int) : Array Int :=\nsorry", "vc-theorems": "theorem counting_bits_spec (n : Int) :\n0 ≤ n ∧ n ≤ 100000 →\nlet result := counting_bits n\nresult.size = n + 1 ∧\n∀ i, 1 ≤ i ∧ i < n + 1 → result[i.toNat]! = result[(i / 2).toNat]! + i % 2 :=\nsorry", "vc-postamble": ""}
{"id": "Software-Verification_tmp_tmpv4ueky2d_Longest_Increasing_Subsequence_longest_increasing_subsequence_longest_increasing_subsequence", "vc-description": "/- \n{\n\"name\": \"Software-Verification_tmp_tmpv4ueky2d_Longest Increasing Subsequence_longest_increasing_subsequence_longest_increasing_subsequence\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Software-Verification_tmp_tmpv4ueky2d_Longest Increasing Subsequence_longest_increasing_subsequence_longest_increasing_subsequence\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nHelper function to find maximum of two integers.\nTranslated from Dafny's find_max function.\n-/\n\n/- \nMain function to find longest increasing subsequence.\nTranslated from Dafny's longest_increasing_subsequence method.\n\nRequirements:\n- Array length between 1 and 2500\n- All elements between -10000 and 10000\n- Returns length of longest increasing subsequence, which must be at least 1\n-/", "vc-preamble": "def find_max (x y : Int) : Int :=\nif x > y then x else y", "vc-helpers": "", "vc-definitions": "def longest_increasing_subsequence (nums : Array Int) : Int :=\nsorry", "vc-theorems": "theorem longest_increasing_subsequence_spec (nums : Array Int) :\n(1 ≤ nums.size ∧ nums.size ≤ 2500) →\n(∀ i, 0 ≤ i ∧ i < nums.size → -10000 ≤ nums[i]! ∧ nums[i]! ≤ 10000) →\nlongest_increasing_subsequence nums ≥ 1 :=\nsorry", "vc-postamble": ""}
{"id": "Software-Verification_tmp_tmpv4ueky2d_Non-overlapping_Intervals_non_overlapping_intervals_bubble_sort", "vc-description": "/- \n{\n\"name\": \"Software-Verification_tmp_tmpv4ueky2d_Non-overlapping Intervals_non_overlapping_intervals_bubble_sort\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Software-Verification_tmp_tmpv4ueky2d_Non-overlapping Intervals_non_overlapping_intervals_bubble_sort\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nRepresents a 2D array with fixed second dimension of 2.\nThis simplifies the Dafny array2 type for our purposes.\n-/\n\n/- \nPredicate indicating if a 2D array is sorted based on second column values\nbetween indices l and u inclusive.\n-/\n\n/- \nPredicate indicating if a 2D array is partitioned at index i,\nmeaning all elements before i are less than or equal to all elements after i\nbased on second column values.\n-/\n\n/- \nBubble sort implementation for 2D arrays.\nSorts based on the second column values.\n-/", "vc-preamble": "structure Array2D (α : Type) where\ndata : Array (Array α)\ndim1_eq_2 : ∀ arr ∈ data, arr.size = 2\ndef sorted (a : Array2D Int) (l u : Int) : Prop :=\n∀ i j:Nat, 0 ≤ l → l ≤ i → i ≤ j → j ≤ u → u < a.data.size →\n(a.data[i]!)[1]! ≤ (a.data[j]!)[1]!\ndef partitioned (a : Array2D Int) (i : Int) : Prop :=\n∀ k k':Nat, 0 ≤ k → k ≤ i → i < k' → k' < a.data.size →\n(a.data[k]!)[1]! ≤ (a.data[k']!)[1]!", "vc-helpers": "", "vc-definitions": "def bubble_sort (a : Array2D Int) : Array2D Int :=\nsorry", "vc-theorems": "theorem bubble_sort_spec (a : Array2D Int) :\nsorted (bubble_sort a) 0 (a.data.size - 1) :=\nsorry", "vc-postamble": ""}
{"id": "Software-Verification_tmp_tmpv4ueky2d_Non-overlapping_Intervals_non_overlapping_intervals_non_overlapping_intervals", "vc-description": "/- \n{\n\"name\": \"Software-Verification_tmp_tmpv4ueky2d_Non-overlapping Intervals_non_overlapping_intervals_non_overlapping_intervals\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Software-Verification_tmp_tmpv4ueky2d_Non-overlapping Intervals_non_overlapping_intervals_non_overlapping_intervals\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate indicating if array is sorted between indices l and u -/\n\n/-  Predicate indicating if array is partitioned at index i -/\n\n/-  Bubble sort implementation -/\n\n/-  Bubble sort specification -/\n\n/-  Non-overlapping intervals implementation -/\n\n/-  Non-overlapping intervals specification -/", "vc-preamble": "def sorted (a : Array (Array Int)) (l : Int) (u : Int) : Prop :=\n∀ i j:Nat, 0 ≤ l → l ≤ i → i ≤ j → j ≤ u → u < a.size →\n(a[i]!)[1]! ≤ (a[j]!)[1]!\n\ndef partitioned (a : Array (Array Int)) (i : Int) : Prop :=\n∀ k k':Nat, 0 ≤ k → k ≤ i → i < k' → k' < a.size →\n(a[k]!)[1]! ≤ (a[k']!)[1]!", "vc-helpers": "", "vc-definitions": "def bubble_sort (a : Array (Array Int)) : Array (Array Int) :=\nsorry\n\ndef non_overlapping_intervals (intervals : Array (Array Int)) : Int :=\nsorry", "vc-theorems": "theorem bubble_sort_spec (a : Array (Array Int)) :\n(a[0]!).size = 2 →\nsorted (bubble_sort a) 0 ((bubble_sort a).size - 1) :=\nsorry\n\ntheorem non_overlapping_intervals_spec (intervals : Array (Array Int)) :\n1 ≤ intervals.size →\nintervals.size ≤ 100000 →\n(∀ i, 0 ≤ i → i < intervals.size → (intervals[i]!).size = 2) →\n(∀ i, 0 ≤ i → i < intervals.size → -50000 ≤ (intervals[i]!)[0]! → (intervals[i]!)[0]! ≤ 50000) →\n(∀ i, 0 ≤ i → i < intervals.size → -50000 ≤ (intervals[i]!)[1]! → (intervals[i]!)[1]! ≤ 50000) →\nnon_overlapping_intervals intervals ≥ 0 :=\nsorry", "vc-postamble": ""}
{"id": "Software-Verification_tmp_tmpv4ueky2d_Remove_Duplicates_from_Sorted_Array_remove_duplicates_from_sorted_array_remove_duplicates_from_sorted_array", "vc-description": "/- \n{\n\"name\": \"Software-Verification_tmp_tmpv4ueky2d_Remove Duplicates from Sorted Array_remove_duplicates_from_sorted_array_remove_duplicates_from_sorted_array\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Software-Verification_tmp_tmpv4ueky2d_Remove Duplicates from Sorted Array_remove_duplicates_from_sorted_array_remove_duplicates_from_sorted_array\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Helper predicate for checking if an array is sorted -/\n\n/-  Helper predicate for checking if an array is sorted and has no duplicates -/\n\n/- \nRemoves duplicates from a sorted array while preserving order\n\n@param nums Input array that must be sorted\n@return Array with duplicates removed\n-/", "vc-preamble": "def is_sorted (nums : Array Int) : Prop :=\n∀ i j:Nat, 0 ≤ i → i < j → j < nums.size → nums[i]! ≤ nums[j]!\ndef is_sorted_and_distinct (nums : Array Int) : Prop :=\n∀ i j:Nat, 0 ≤ i → i < j → j < nums.size → nums[i]! < nums[j]!", "vc-helpers": "", "vc-definitions": "def remove_duplicates_from_sorted_array (nums : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem remove_duplicates_from_sorted_array_spec (nums : Array Int) :\nis_sorted nums →\n1 ≤ nums.size →\nnums.size ≤ 30000 →\n(∀ i, 0 ≤ i → i < nums.size → -100 ≤ nums[i]! ∧ nums[i]! ≤ 100) →\nlet result := remove_duplicates_from_sorted_array nums\nis_sorted_and_distinct result ∧\n(∀ x, (∃ i, 0 ≤ i ∧ i < nums.size ∧ nums[i]! = x) ↔\n(∃ i, 0 ≤ i ∧ i < result.size ∧ result[i]! = x)) :=\nsorry", "vc-postamble": ""}
{"id": "Software-Verification_tmp_tmpv4ueky2d_Remove_Element_remove_element_remove_element", "vc-description": "/- \n{\n\"name\": \"Software-Verification_tmp_tmpv4ueky2d_Remove Element_remove_element_remove_element\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Software-Verification_tmp_tmpv4ueky2d_Remove Element_remove_element_remove_element\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nTranslates the Dafny remove_element method which removes elements equal to val from an array.\n\n@param nums The input array of integers\n@param val The value to remove\n@return The new length after removal\n\nOriginal Dafny requires:\n- 0 ≤ nums.Length ≤ 100\n- ∀i. 0 ≤ i < nums.Length → 0 ≤ nums ≤ 50\n- 0 ≤ val ≤ 100\n\nOriginal Dafny ensures:\n- ∀j. 0 < j < i < nums.Length → nums ≠ val\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def remove_element (nums : Array Int) (val : Int) : Int :=\nsorry", "vc-theorems": "theorem remove_element_spec (nums : Array Int) (val : Int) :\n(0 ≤ nums.size ∧ nums.size ≤ 100) →\n(∀ i, 0 ≤ i ∧ i < nums.size → 0 ≤ nums[i]! ∧ nums[i]! ≤ 50) →\n(0 ≤ val ∧ val ≤ 100) →\nlet i := remove_element nums val\n∀ j:Nat, 0 < j ∧ j < i ∧ i < nums.size → nums[j]! ≠ val :=\nsorry", "vc-postamble": ""}
{"id": "Software-Verification_tmp_tmpv4ueky2d_Valid_Palindrome_valid_panlindrome_isPalindrome", "vc-description": "/- \n{\n\"name\": \"Software-Verification_tmp_tmpv4ueky2d_Valid Palindrome_valid_panlindrome_isPalindrome\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Software-Verification_tmp_tmpv4ueky2d_Valid Palindrome_valid_panlindrome_isPalindrome\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nChecks if a character array is a palindrome.\n\n@param s The input character array\n@return True if the array is a palindrome, false otherwise\n\nTranslated from Dafny specification:\n- Requires array length between 1 and 200000\n- Ensures result is true iff corresponding elements from start and end match\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isPalindrome (s : Array Char) : Bool :=\nsorry", "vc-theorems": "theorem isPalindrome_spec (s : Array Char) :\n1 ≤ s.size ∧ s.size ≤ 200000 →\nisPalindrome s = ∀ i, 0 ≤ i ∧ i < s.size / 2 → s[i]! = s[s.size - 1 - i]! :=\nsorry", "vc-postamble": ""}
{"id": "Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula3_maxArrayReverse", "vc-description": "/- \n{\n\"name\": \"Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula3_maxArrayReverse\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula3_maxArrayReverse\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  maxArrayReverse method translated from Dafny -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def maxArrayReverse (arr : Array Int) : Int :=\nsorry", "vc-theorems": "theorem maxArrayReverse_spec (arr : Array Int) :\narr.size > 0 →\n(∀ i : Nat, 0 ≤ i ∧ i < arr.size → arr[i]! ≤ maxArrayReverse arr) ∧\n(∃ x : Nat, 0 ≤ x ∧ x < arr.size ∧ arr[x]! = maxArrayReverse arr) :=\nsorry", "vc-postamble": ""}
{"id": "Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula3_sumBackwards", "vc-description": "/- \n{\n\"name\": \"Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula3_sumBackwards\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula3_sumBackwards\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Sum function translated from Dafny -/\n\n/-  sumBackwards method translated from Dafny -/", "vc-preamble": "partial def sum (n : Nat) : Nat :=\nif n == 0 then 0\nelse n + sum (n-1)", "vc-helpers": "", "vc-definitions": "def sumBackwards (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem sumBackwards_spec (n : Nat) :\nsumBackwards n = sum n :=\nsorry", "vc-postamble": ""}
{"id": "Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_handout1_queryFast", "vc-description": "/- \n{\n\"name\": \"Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_handout1_queryFast\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_handout1_queryFast\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Computes sum of array elements from index i to j (exclusive) -/\n\n/-  Predicate checking if array c is prefix sum of array a -/\n\n/-  Main query function specification -/", "vc-preamble": "partial def sum (a : Array Int) (i j : Int) : Int :=\nif i = j then 0\nelse a[(j-1).toNat]! + sum a i (j-1)\ndef is_prefix_sum_for (a c : Array Int) : Prop :=\na.size + 1 = c.size ∧\n∀ i, 0 ≤ i ∧ i ≤ a.size → c[i]! = sum a 0 i", "vc-helpers": "", "vc-definitions": "def queryFast (a c : Array Int) (i j : Int) : Int :=\nsorry", "vc-theorems": "theorem queryFast_spec (a c : Array Int) (i j : Int) :\n0 ≤ i → i ≤ j → j ≤ a.size →\nis_prefix_sum_for a c →\nqueryFast a c i j = sum a i j :=\nsorry", "vc-postamble": ""}
{"id": "VerifiedMergeSortDafny_tmp_tmpva7qms1b_MergeSort_merge", "vc-description": "/- \n{\n\"name\": \"VerifiedMergeSortDafny_tmp_tmpva7qms1b_MergeSort_merge\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: VerifiedMergeSortDafny_tmp_tmpva7qms1b_MergeSort_merge\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate indicating if two sequences are merged into an array slice -/\n\n/-  Predicate indicating if an array slice is sorted -/\n\n/-  Predicate indicating if a sequence is sorted -/\n\n/-  Predicate indicating if an array is sorted -/\n\n/-  Merge two sorted sequences into an array -/", "vc-preamble": "def count (a : Array Int) (x : Int) : Nat :=\na.foldl (fun acc y => if y = x then acc + 1 else acc) 0\n\ndef merged (a1 : Array Int) (a2 : Array Int) (b : Array Int) (start : Int) (end_ : Int) : Prop :=\nend_ - start == a1.size + a2.size ∧\n0 ≤ start ∧ start ≤ end_ ∧ end_ ≤ b.size ∧\n(∀ x : Int, count a1 x + count a2 x = count (b.extract start.toNat end_.toNat) x)\n\ndef sorted_slice (a : Array Int) (start : Int) (end_ : Int) : Prop :=\n0 ≤ start ∧ start ≤ end_ ∧ end_ ≤ a.size ∧\n∀ i j:Nat, start ≤ i ∧ i ≤ j ∧ j < end_ → a[i]! ≤ a[j]!\n\ndef sorted_seq (a : Array Int) : Prop :=\n∀ i j:Nat, 0 ≤ i ∧ i ≤ j ∧ j < a.size → a[i]! ≤ a[j]!\n\ndef sorted (a : Array Int) : Prop :=\n∀ i j:Nat, 0 ≤ i ∧ i < j ∧ j < a.size → a[i]! ≤ a[j]!", "vc-helpers": "", "vc-definitions": "def merge (a1 : Array Int) (a2 : Array Int) (start : Int) (end_ : Int) (b : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem merge_spec (a1 : Array Int) (a2 : Array Int) (start : Int) (end_ : Int) (b : Array Int) :\nsorted_seq a1 ∧\nsorted_seq a2 ∧\nend_ - start == a1.size + a2.size ∧\n0 ≤ start ∧ start < end_ ∧ end_ < a1.size ∧ end_ ≤ a2.size ∧ end_ < b.size ∧\nend_ < a1.size ∧ end_ < a2.size ∧\nb.size == a2.size + a1.size\n→\nsorted_slice (merge a1 a2 start end_ b) start end_ ∧\nmerged a1 a2 (merge a1 a2 start end_ b) start end_ :=\nsorry", "vc-postamble": ""}
{"id": "VerifiedMergeSortDafny_tmp_tmpva7qms1b_MergeSort_mergeSimple", "vc-description": "/- \n{\n\"name\": \"VerifiedMergeSortDafny_tmp_tmpva7qms1b_MergeSort_mergeSimple\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: VerifiedMergeSortDafny_tmp_tmpva7qms1b_MergeSort_mergeSimple\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate indicating that two sequences merge into an array slice -/\n\n/-  Predicate indicating a slice of an array is sorted -/\n\n/-  Predicate indicating a sequence is sorted -/\n\n/-  Predicate indicating an array is sorted -/\n\n/-  Merge two sorted sequences into an array -/", "vc-preamble": "def merged (a1 : Array Int) (a2 : Array Int) (b : Array Int) (start : Int) (end_ : Int) : Bool :=\nend_ - start == a2.size + a1.size ∧\nstart ≥ 0 ∧ start ≤ end_ ∧ end_ ≤ b.size\ndef sorted_slice (a : Array Int) (start : Int) (end_ : Int) : Prop :=\nstart ≥ 0 ∧ start ≤ end_ ∧ end_ ≤ a.size ∧\n∀ i j:Nat, start ≤ i ∧ i ≤ j ∧ j < end_ → a[i]! ≤ a[j]!\ndef sorted_seq (a : Array Int) : Prop :=\n∀ i j:Nat, 0 ≤ i ∧ i ≤ j ∧ j < a.size → a[i]! ≤ a[j]!\ndef sorted (a : Array Int) : Prop :=\n∀ i j:Nat, 0 ≤ i ∧ i < j ∧ j < a.size → a[i]! ≤ a[j]!", "vc-helpers": "", "vc-definitions": "def mergeSimple (a1 : Array Int) (a2 : Array Int) (start : Int) (end_ : Int) (b : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem mergeSimple_spec (a1 : Array Int) (a2 : Array Int) (start : Int) (end_ : Int) (b : Array Int) :\nsorted_seq a1 ∧\nsorted_seq a2 ∧\nstart ≥ 0 ∧ start ≤ end_ ∧ end_ ≤ b.size ∧\na1.size + a2.size == end_ - start + 1\n→\nsorted_slice (mergeSimple a1 a2 start end_ b) start end_ :=\nsorry", "vc-postamble": ""}
{"id": "Workshop_tmp_tmp0cu11bdq_Lecture_Answers_max_array_max", "vc-description": "/- \n{\n\"name\": \"Workshop_tmp_tmp0cu11bdq_Lecture_Answers_max_array_max\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: Workshop_tmp_tmp0cu11bdq_Lecture_Answers_max_array_max\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nFinds the maximum value in an array of integers.\n\n@param a The input array of integers\n@return The maximum value in the array\n\nTranslation of Dafny method:\ndafny\nmethod max(a:array<int>) returns(max:int)\nrequires a != null;\nensures forall j :: j >= 0 && j < a.Length ==> max >= a;\nensures a.Length > 0 ==> exists j :: j >= 0 && j < a.Length && max == a;\n\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def max (a : Array Int) : Int :=\nsorry", "vc-theorems": "theorem max_spec (a : Array Int) :\n\n-- First ensures clause: max is larger than anything in array\n\n(∀ j:Nat, 0 ≤ j ∧ j < a.size → max a ≥ a[j]!) ∧\n\n-- Second ensures clause: if array non-empty, max exists in array\n\n(a.size > 0 → ∃ j, 0 ≤ j ∧ j < a.size ∧ max a = a[j]!) :=\nsorry", "vc-postamble": ""}
{"id": "assertive-programming-assignment-1_tmp_tmp3h_cj44u_FindRange_BinarySearch", "vc-description": "/- \n{\n\"name\": \"assertive-programming-assignment-1_tmp_tmp3h_cj44u_FindRange_BinarySearch\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: assertive-programming-assignment-1_tmp_tmp3h_cj44u_FindRange_BinarySearch\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate indicating if an array is sorted in ascending order -/\n\n/-  Predicate indicating if all values in range satisfy the comparer function -/\n\n/-  Predicate indicating if all values in range satisfy the negation of comparer function -/\n\n/-  Binary search implementation with specifications -/", "vc-preamble": "def Sorted (q : Array Int) : Prop :=\n∀ i j, 0 ≤ i → i ≤ j → j < q.size → q[i]! ≤ q[j]!\ndef RangeSatisfiesComparer (q : Array Int) (key : Int) (lowerBound upperBound : Nat)\n(comparer : Int → Int → Bool ) : Prop :=\n0 ≤ lowerBound ∧ lowerBound ≤ upperBound ∧ upperBound ≤ q.size →\n∀ i, lowerBound ≤ i → i < upperBound → comparer (q[i]!) key = true\ndef RangeSatisfiesComparerNegation (q : Array Int) (key : Int) (lowerBound upperBound : Nat)\n(comparer : Int → Int → Bool) : Prop :=\nRangeSatisfiesComparer q key lowerBound upperBound (fun n1 n2 => ¬(comparer n1 n2))", "vc-helpers": "", "vc-definitions": "def BinarySearch (q : Array Int) (key : Int) (lowerBound upperBound : Nat)\n(comparer : Int → Int → Bool) : Nat :=\nsorry", "vc-theorems": "theorem BinarySearch_spec (q : Array Int) (key : Int) (lowerBound upperBound : Nat)\n(comparer : Int → Int → Bool) :\nSorted q →\n0 ≤ lowerBound → lowerBound ≤ upperBound → upperBound ≤ q.size →\nRangeSatisfiesComparerNegation q key 0 lowerBound comparer →\nRangeSatisfiesComparer q key upperBound q.size comparer →\n(∀ n1 n2, comparer n1 n2 = (n1 > n2)) ∨\n(∀ n1 n2, comparer n1 n2 = (n1 ≥ n2)) →\nlet index := BinarySearch q key lowerBound upperBound comparer\nlowerBound ≤ index ∧ index ≤ upperBound ∧\nRangeSatisfiesComparerNegation q key 0 index comparer ∧\nRangeSatisfiesComparer q key index q.size comparer :=\nsorry", "vc-postamble": ""}
{"id": "assertive-programming-assignment-1_tmp_tmp3h_cj44u_FindRange_FindRange", "vc-description": "/- \n{\n\"name\": \"assertive-programming-assignment-1_tmp_tmp3h_cj44u_FindRange_FindRange\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: assertive-programming-assignment-1_tmp_tmp3h_cj44u_FindRange_FindRange\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate indicating if an array is sorted in ascending order -/\n\n/-  Predicate indicating if all elements in a range satisfy a comparison with key -/\n\n/-  Predicate indicating if all elements in a range satisfy the negation of a comparison with key -/\n\n/-  Binary search implementation with comparison function -/\n\n/-  Specification for BinarySearch -/\n\n/-  Find range of elements equal to key in sorted array -/\n\n/-  Specification for FindRange -/", "vc-preamble": "def Sorted (q : Array Int) : Prop :=\n∀ i j, 0 ≤ i → i ≤ j → j < q.size → q[i]! ≤ q[j]!\n\ndef RangeSatisfiesComparer (q : Array Int) (key : Int) (lowerBound upperBound : Nat)\n(comparer : Int → Int → Bool) : Prop :=\n0 ≤ lowerBound ∧ lowerBound ≤ upperBound ∧ upperBound ≤ q.size →\n∀ i, lowerBound ≤ i → i < upperBound → comparer (q[i]!) key\n\ndef RangeSatisfiesComparerNegation (q : Array Int) (key : Int) (lowerBound upperBound : Nat)\n(comparer : Int → Int → Bool) : Prop :=\nRangeSatisfiesComparer q key lowerBound upperBound (fun n1 n2 => ¬(comparer n1 n2))", "vc-helpers": "", "vc-definitions": "def BinarySearch (q : Array Int) (key : Int) (lowerBound upperBound : Nat)\n(comparer : Int → Int → Bool) : Nat :=\nsorry\n\ndef FindRange (q : Array Int) (key : Int) : Nat × Nat :=\nsorry", "vc-theorems": "theorem BinarySearch_spec (q : Array Int) (key : Int) (lowerBound upperBound : Nat)\n(comparer : Int → Int → Bool) :\nSorted q →\n0 ≤ lowerBound → lowerBound ≤ upperBound → upperBound ≤ q.size →\nRangeSatisfiesComparerNegation q key 0 lowerBound comparer →\nRangeSatisfiesComparer q key upperBound q.size comparer →\n((∀ n1 n2, comparer n1 n2 = (n1 > n2)) ∨ (∀ n1 n2, comparer n1 n2 = (n1 ≥ n2))) →\nlet index := BinarySearch q key lowerBound upperBound comparer\nlowerBound ≤ index ∧ index ≤ upperBound ∧\nRangeSatisfiesComparerNegation q key 0 index comparer ∧\nRangeSatisfiesComparer q key index q.size comparer :=\nsorry\n\ntheorem FindRange_spec (q : Array Int) (key : Int) :\nSorted q →\nlet (left, right) := FindRange q key\nleft ≤ right ∧ right ≤ q.size ∧\n(∀ i, 0 ≤ i → i < left → q[i]! < key) ∧\n(∀ i, left ≤ i → i < right → q[i]! = key) ∧\n(∀ i, right ≤ i → i < q.size → q[i]! > key) :=\nsorry", "vc-postamble": ""}
{"id": "assertive-programming-assignment-1_tmp_tmp3h_cj44u_ProdAndCount_ProdAndCount", "vc-description": "/- \n{\n\"name\": \"assertive-programming-assignment-1_tmp_tmp3h_cj44u_ProdAndCount_ProdAndCount\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: assertive-programming-assignment-1_tmp_tmp3h_cj44u_ProdAndCount_ProdAndCount\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Recursively computes product of positive numbers in sequence -/\n\n/-  Recursively counts occurrences of key in sequence -/\n\n/-  Helper function to count if element equals key -/\n\n/-  Helper function for product calculation -/\n\n/-  Main method that computes product of positives and count of key -/", "vc-preamble": "partial def RecursivePositiveProduct (q : Array Int) : Int :=\nif q.size = 0 then 1\nelse if q[0]! ≤ 0 then RecursivePositiveProduct (q.extract 1 q.size)\nelse q[0]! * RecursivePositiveProduct (q.extract 1 q.size)\npartial def RecursiveCount (key : Int) (q : Array Int) : Int :=\nif q.size = 0 then 0\nelse if q[q.size - 1]! = key then\n1 + RecursiveCount key (q.extract 0 (q.size - 1))\nelse RecursiveCount key (q.extract 0 (q.size - 1))\ndef county (elem : Int) (key : Int) : Int :=\nif elem = key then 1 else 0\ndef prody (elem : Int) : Int :=\nif elem ≤ 0 then 1 else elem", "vc-helpers": "", "vc-definitions": "def ProdAndCount (q : Array Int) (key : Int) : Int × Nat :=\nsorry", "vc-theorems": "theorem ProdAndCount_spec (q : Array Int) (key : Int) :\nlet (prod, count) := ProdAndCount q key\nprod = RecursivePositiveProduct q ∧\ncount = RecursiveCount key q :=\nsorry", "vc-postamble": ""}
{"id": "assertive-programming-assignment-1_tmp_tmp3h_cj44u_SearchAddends_FindAddends", "vc-description": "/- \n{\n\"name\": \"assertive-programming-assignment-1_tmp_tmp3h_cj44u_SearchAddends_FindAddends\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: assertive-programming-assignment-1_tmp_tmp3h_cj44u_SearchAddends_FindAddends\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate indicating if an array is sorted in ascending order -/\n\n/-  Predicate indicating if there exist two indices whose elements sum to x -/\n\n/-  Predicate indicating if an index is valid for an array -/\n\n/-  Predicate indicating if two indices are ordered within array bounds -/\n\n/-  Predicate indicating if two indices contain elements that sum to x -/\n\n/-  Predicate indicating if a subarray contains elements that sum to x -/\n\n/-  Loop invariant predicate -/\n\n/-  Main FindAddends method specification -/\n\n/-  FindAddends implementation -/", "vc-preamble": "def Sorted (q : Array Int) : Prop :=\n∀ i j, 0 ≤ i → i ≤ j → j < q.size → q[i]! ≤ q[j]!\n\ndef HasAddends (q : Array Int) (x : Int) : Prop :=\n∃ i j, 0 ≤ i ∧ i < j ∧ j < q.size ∧ q[i]! + q[j]! = x\n\ndef IsValidIndex {T : Type} (q : Array T) (i : Nat) : Prop :=\n0 ≤ i ∧ i < q.size\n\ndef AreOrderedIndices {T : Type} (q : Array T) (i j : Nat) : Prop :=\n0 ≤ i ∧ i < j ∧ j < q.size\n\ndef AreAddendsIndices (q : Array Int) (x : Int) (i j : Nat) : Prop :=\nIsValidIndex q i ∧ IsValidIndex q j → q[i]! + q[j]! = x\n\ndef HasAddendsInIndicesRange (q : Array Int) (x : Int) (i j : Nat) : Prop :=\nAreOrderedIndices q i j → HasAddends (q.extract i (j + 1)) x\n\ndef LoopInv (q : Array Int) (x : Int) (i j : Nat) (sum : Int) : Prop :=\nAreOrderedIndices q i j ∧\nHasAddendsInIndicesRange q x i j ∧\nAreAddendsIndices q sum i j", "vc-helpers": "", "vc-definitions": "def FindAddends (q : Array Int) (x : Int) : Nat × Nat :=\nsorry", "vc-theorems": "theorem FindAddends_spec (q : Array Int) (x : Int) :\nSorted q → HasAddends q x →\n∃ i j, i < j ∧ j < q.size ∧ q[i]! + q[j]! = x :=\nsorry", "vc-postamble": ""}
{"id": "bbfny_tmp_tmpw4m0jvl0_enjoying_Find", "vc-description": "/- \n{\n\"name\": \"bbfny_tmp_tmpw4m0jvl0_enjoying_Find\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: bbfny_tmp_tmpw4m0jvl0_enjoying_Find\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Translation of Dafny max function -/\n\n/-  Translation of Dafny Testing method -/\n\n/-  Translation of Dafny abs function -/\n\n/-  Translation of Dafny fib function -/\n\n/-  Translation of Dafny sorted predicate -/\n\n/-  Translation of Dafny Find method -/\n\n/-  Specification for Find method -/", "vc-preamble": "def max (a b : Int) : Int :=\nif a > b then a else b\n\ndef abs (x : Int) : Int :=\nif x < 0 then -x else x\n\ndef fib (n : Nat) : Nat :=\nif n = 0 then 0\nelse if n = 1 then 1\nelse fib (n - 1) + fib (n - 2)\n\ndef sorted (a : Array Int) : Prop :=\n∀ j k, 0 ≤ j → j < k → k < a.size → a[j]! < a[k]!", "vc-helpers": "", "vc-definitions": "def Testing : Unit :=\nsorry\n\ndef Find (a : Array Int) (key : Int) : Int :=\nsorry", "vc-theorems": "theorem Find_spec (a : Array Int) (key : Int) (index : Int) :\n(0 ≤ index → index < a.size ∧ a[index.toNat]! = key) ∧\n(index < 0 → ∀ k, 0 ≤ k ∧ k < a.size → a[k]! ≠ key) :=\nsorry", "vc-postamble": ""}
{"id": "bbfny_tmp_tmpw4m0jvl0_enjoying_FindMax", "vc-description": "/- \n{\n\"name\": \"bbfny_tmp_tmpw4m0jvl0_enjoying_FindMax\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: bbfny_tmp_tmpw4m0jvl0_enjoying_FindMax\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Translation of Dafny max function -/\n\n/-  Translation of Dafny Testing method -/\n\n/-  Translation of Dafny abs function -/\n\n/-  Translation of Dafny fib function -/\n\n/-  Translation of Dafny sorted predicate -/\n\n/-  Translation of FindMax method specification -/\n\n/-  Specification for FindMax -/", "vc-preamble": "def max (a b : Int) : Int :=\nif a > b then a else b\n\ndef abs (x : Int) : Int :=\nif x < 0 then -x else x\n\ndef fib (n : Nat) : Nat :=\nif n = 0 then 0\nelse if n = 1 then 1\nelse fib (n - 1) + fib (n - 2)\n\ndef sorted (a : Array Int) : Prop :=\n∀ j k, 0 ≤ j → j < k → k < a.size → a[j]! < a[k]!", "vc-helpers": "", "vc-definitions": "def Testing : Unit :=\nsorry\n\ndef FindMax (a : Array Int) : Int :=\nsorry", "vc-theorems": "theorem FindMax_spec (a : Array Int) (i : Int) :\na.size ≥ 1 →\n(0 ≤ i ∧ i < a.size) ∧\n(∀ k, 0 ≤ k ∧ k < a.size → a[k]! ≤ a[i.toNat]!) :=\nsorry", "vc-postamble": ""}
{"id": "cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_ArraySum", "vc-description": "/- \n{\n\"name\": \"cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_ArraySum\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_ArraySum\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nArraySum takes two arrays of integers and returns a new array containing\nthe element-wise sum of the input arrays.\n\n@param a First input array\n@param b Second input array\n@return Array containing element-wise sums\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def ArraySum (a b : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem ArraySum_spec (a b : Array Int) :\na.size = b.size →\nlet c := ArraySum a b\nc.size = a.size ∧\n(∀ i, 0 ≤ i ∧ i < c.size → c[i]! = a[i]! + b[i]!) :=\nsorry", "vc-postamble": ""}
{"id": "cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_Euclid", "vc-description": "/- \n{\n\"name\": \"cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_Euclid\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_Euclid\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nEuclid's algorithm for computing the greatest common divisor of two positive integers.\nTranslated from Dafny specification.\n\n@param m First integer input, must be greater than 1\n@param n Second integer input, must be greater than 1 and less than or equal to m\n@return The greatest common divisor of m and n\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Euclid (m n : Int) : Int :=\nsorry", "vc-theorems": "theorem Euclid_spec (m n : Int) :\nm > 1 ∧ n > 1 ∧ m ≥ n →\nlet gcd := Euclid m n\ngcd > 0 ∧ gcd ≤ n ∧ gcd ≤ m ∧ m % gcd = 0 ∧ n % gcd = 0 :=\nsorry", "vc-postamble": ""}
{"id": "cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_IntDiv", "vc-description": "/- \n{\n\"name\": \"cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_IntDiv\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_IntDiv\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nIntDiv computes the integer division and remainder of m divided by n.\nTranslated from Dafny method IntDiv.\n\n@param m The dividend\n@param n The divisor\n@return A pair (d,r) where d is the quotient and r is the remainder\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def IntDiv (m : Int) (n : Int) : Int × Int :=\nsorry", "vc-theorems": "theorem IntDiv_spec (m n : Int) :\nn > 0 →\nlet (d, r) := IntDiv m n\nm = n * d + r ∧ 0 ≤ r ∧ r < n :=\nsorry", "vc-postamble": ""}
{"id": "cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_IsPrime", "vc-description": "/- \n{\n\"name\": \"cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_IsPrime\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_IsPrime\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nDetermines if a given positive integer is prime.\n\n@param m The integer to check for primality\n@return isPrime True if and only if m is prime\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def IsPrime (m : Int) : Bool :=\nsorry", "vc-theorems": "theorem IsPrime_spec (m : Int) :\nm > 0 →\n(IsPrime m ↔ (m > 1 ∧ ∀ j : Int, 2 ≤ j ∧ j < m → m % j ≠ 0)) :=\nsorry", "vc-postamble": ""}
{"id": "cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_NoDups", "vc-description": "/- \n{\n\"name\": \"cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_NoDups\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_NoDups\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nNoDups checks if an array has no duplicate adjacent elements.\nRequires the array to be sorted.\nReturns true if and only if there are no duplicates.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def NoDups (a : Array Int) : Bool :=\nsorry", "vc-theorems": "theorem NoDups_spec (a : Array Int) :\n(∀ j : Int, 0 < j ∧ j < a.size → a[(j-1).toNat]! ≤ a[j.toNat]!) →\n(NoDups a ↔ ∀ j : Int, 1 ≤ j ∧ j < a.size → a[(j-1).toNat]! ≠ a[j.toNat]!) :=\nsorry", "vc-postamble": ""}
{"id": "cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_Reverse", "vc-description": "/- \n{\n\"name\": \"cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_Reverse\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_Reverse\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nReverses an array of integers.\nReturns a new array containing the elements in reverse order.\n\n@param a The input array to reverse\n@return The reversed array\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Reverse (a : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem reverse_spec (a : Array Int) (aRev : Array Int) :\naRev = Reverse a →\n(aRev.size = a.size) ∧\n(∀ i, 0 ≤ i ∧ i < a.size → a[i]! = aRev[(aRev.size - i - 1)]!) :=\nsorry", "vc-postamble": ""}
{"id": "cs245-verification_tmp_tmp0h_nxhqp_A8_Q1_A8Q1", "vc-description": "/- \n{\n\"name\": \"cs245-verification_tmp_tmp0h_nxhqp_A8_Q1_A8Q1\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: cs245-verification_tmp_tmp0h_nxhqp_A8_Q1_A8Q1\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nPower function that computes a^n.\nTranslated from Dafny's recursive power function.\n-/\n\n/- \nMain method A8Q1 that computes x^y0.\nTranslated from Dafny method specification.\n-/", "vc-preamble": "partial def power (a : Int) (n : Int) : Int :=\nif n == 0 then 1 else a * power a (n - 1)", "vc-helpers": "", "vc-definitions": "def A8Q1 (y0 : Int) (x : Int) : Int :=\nsorry", "vc-theorems": "theorem A8Q1_spec (y0 : Int) (x : Int) :\ny0 ≥ 0 → A8Q1 y0 x = power x y0 :=\nsorry", "vc-postamble": ""}
{"id": "cs245-verification_tmp_tmp0h_nxhqp_SortingIssues_FirstAttempt_sort", "vc-description": "/- \n{\n\"name\": \"cs245-verification_tmp_tmp0h_nxhqp_SortingIssues_FirstAttempt_sort\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: cs245-verification_tmp_tmp0h_nxhqp_SortingIssues_FirstAttempt_sort\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nTranslation of Dafny sort method specification.\nOriginal investigates specification issues for sorting arrays.\n\nParameters:\n- A: Array of integers to be sorted\n- n: Length of array A\n\nRequirements:\n- n must equal A.size\n- n must be non-negative\n\nEnsures:\n- Array A is sorted in ascending order\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sort (A : Array Int) (n : Int) : Array Int :=\nsorry", "vc-theorems": "theorem sort_spec (A : Array Int) (n : Int) :\nn = A.size ∧\nn ≥ 0 →\n∀ i j, 0 ≤ i ∧ i ≤ j ∧ j < n →\n(sort A n)[i.toNat]! ≤ (sort A n)[j.toNat]! :=\nsorry", "vc-postamble": ""}
{"id": "cs245-verification_tmp_tmp0h_nxhqp_power_compute_power", "vc-description": "/- \n{\n\"name\": \"cs245-verification_tmp_tmp0h_nxhqp_power_compute_power\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: cs245-verification_tmp_tmp0h_nxhqp_power_compute_power\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nPower function that computes a^n.\nRequires a ≥ 0 and n ≥ 0.\n-/\n\n/- \nSpecification for power function.\n-/\n\n/- \nCompute power method that returns a^n.\nRequires a ≥ 0 and n ≥ 0.\nEnsures result equals power(a,n).\n-/\n\n/- \nSpecification for compute_power method.\n-/", "vc-preamble": "partial def power (a n : Int) : Int :=\nif n = 0 then 1 else a * power a (n - 1)", "vc-helpers": "", "vc-definitions": "def compute_power (a n : Int) : Int :=\nsorry", "vc-theorems": "theorem power_spec (a n : Int) :\na ≥ 0 ∧ n ≥ 0 → power a n ≥ 0 :=\nsorry\n\ntheorem compute_power_spec (a n : Int) :\na ≥ 0 ∧ n ≥ 0 → compute_power a n = power a n :=\nsorry", "vc-postamble": ""}
{"id": "cs245-verification_tmp_tmp0h_nxhqp_quicksort-partition_QuicksortPartition", "vc-description": "/- \n{\n\"name\": \"cs245-verification_tmp_tmp0h_nxhqp_quicksort-partition_QuicksortPartition\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: cs245-verification_tmp_tmp0h_nxhqp_quicksort-partition_QuicksortPartition\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nQuicksortPartition method translated from Dafny.\nTakes an array X, its length n, and pivot value p.\nReturns indices a and b satisfying the partition properties.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def QuicksortPartition (X : Array Int) (n : Int) (p : Int) : Int × Int :=\nsorry", "vc-theorems": "theorem QuicksortPartition_spec\n(X : Array Int) (n : Int) (p : Int) :\nX.size ≥ 1 ∧ n = X.size →\nlet (a, b) := QuicksortPartition X n p\nb ≥ n ∧\n(∀ x, 0 ≤ x ∧ x < a ∧ a < n → X[x.toNat]! ≤ p) ∧\n(a = n ∨ (∀ x, 0 ≤ a ∧ a ≤ x ∧ x < n → X[(x.toNat)]! > p)) :=\nsorry", "vc-postamble": ""}
{"id": "dafl_tmp_tmp_r3_8w3y_dafny_examples_uiowa_binary-search_binSearch", "vc-description": "/- \n{\n\"name\": \"dafl_tmp_tmp_r3_8w3y_dafny_examples_uiowa_binary-search_binSearch\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafl_tmp_tmp_r3_8w3y_dafny_examples_uiowa_binary-search_binSearch\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nPredicate indicating whether an array is sorted in ascending order.\nTranslated from Dafny's isSorted predicate.\n-/\n\n/- \nBinary search implementation translated from Dafny.\nReturns true if element K exists in sorted array a.\n\n@param a The sorted input array\n@param K The key to search for\n@return Whether K exists in array a\n-/", "vc-preamble": "def isSorted (a : Array Int) : Prop :=\n∀ i j : Nat, i ≤ j ∧ j < a.size → a[i]! ≤ a[j]!", "vc-helpers": "", "vc-definitions": "def binSearch (a : Array Int) (K : Int) : Bool :=\nsorry", "vc-theorems": "theorem binSearch_spec (a : Array Int) (K : Int) :\nisSorted a →\nbinSearch a K = (∃ i : Nat, i < a.size ∧ a[i]! = K) :=\nsorry", "vc-postamble": ""}
{"id": "dafl_tmp_tmp_r3_8w3y_dafny_examples_uiowa_fibonacci_ComputeFib", "vc-description": "/- \n{\n\"name\": \"dafl_tmp_tmp_r3_8w3y_dafny_examples_uiowa_fibonacci_ComputeFib\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafl_tmp_tmp_r3_8w3y_dafny_examples_uiowa_fibonacci_ComputeFib\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nRecursive definition of the Fibonacci sequence:\nfib(0) = 0\nfib(1) = 1\nfib(n) = fib(n-1) + fib(n-2) for n ≥ 2\n-/\n\n/- \nComputeFib method computes the nth Fibonacci number.\nInput: n - A natural number\nOutput: f - The nth Fibonacci number\nEnsures: f equals fib(n)\n-/", "vc-preamble": "def fib : Nat → Nat\n| 0 => 0\n| 1 => 1\n| n + 2 => fib (n + 1) + fib n", "vc-helpers": "", "vc-definitions": "def ComputeFib (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem ComputeFib_spec (n : Nat) :\nComputeFib n = fib n :=\nsorry", "vc-postamble": ""}
{"id": "dafl_tmp_tmp_r3_8w3y_dafny_examples_uiowa_find_Find", "vc-description": "/- \n{\n\"name\": \"dafl_tmp_tmp_r3_8w3y_dafny_examples_uiowa_find_Find\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafl_tmp_tmp_r3_8w3y_dafny_examples_uiowa_find_Find\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nFind method that searches for a key in an array.\nReturns the index of the first occurrence of key, or negative if not found.\n\n@param a The array to search in\n@param key The value to search for\n@return The index where key is found, or negative if not found\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Find (a : Array Int) (key : Int) : Int :=\nsorry", "vc-theorems": "theorem Find_spec (a : Array Int) (key : Int) (i : Int) :\ni = Find a key →\n(0 ≤ i →\n(i < a.size ∧\na[i.toNat]! = key ∧\n(∀ k, 0 ≤ k ∧ k < i → a[k.toNat]! ≠ key))) ∧\n(i < 0 →\n(∀ k, 0 ≤ k ∧ k < a.size → a[k]! ≠ key)) :=\nsorry", "vc-postamble": ""}
{"id": "dafleet_tmp_tmpa2e4kb9v_0001-0050_0001-two-sum_twoSum", "vc-description": "/- \n{\n\"name\": \"dafleet_tmp_tmpa2e4kb9v_0001-0050_0001-two-sum_twoSum\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafleet_tmp_tmpa2e4kb9v_0001-0050_0001-two-sum_twoSum\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nGiven an array of integers nums and an integer target, returns indices of two numbers that sum to target.\nAssumes exactly one solution exists and same element cannot be used twice.\n-/\n\n/- \nMain twoSum function that finds indices of two numbers summing to target.\nRequires that at least one solution exists.\nEnsures returned pair satisfies the correct_pair predicate.\n-/", "vc-preamble": "def correct_pair (pair : Int × Int) (nums : Array Int) (target : Int) : Prop :=\nlet (i, j) := pair\n0 ≤ i ∧ i < nums.size ∧\n0 ≤ j ∧ j < nums.size ∧\ni ≠ j ∧\nnums[i.toNat]! + nums[j.toNat]! = target", "vc-helpers": "", "vc-definitions": "def twoSum (nums : Array Int) (target : Int) : Int × Int :=\nsorry", "vc-theorems": "theorem twoSum_spec (nums : Array Int) (target : Int) :\n(∃ i j, correct_pair (i, j) nums target) →\ncorrect_pair (twoSum nums target) nums target :=\nsorry", "vc-postamble": ""}
{"id": "dafleet_tmp_tmpa2e4kb9v_0001-0050_0003-longest-substring-without-repeating-characters_lengthOfLongestSubstring", "vc-description": "/- \n{\n\"name\": \"dafleet_tmp_tmpa2e4kb9v_0001-0050_0003-longest-substring-without-repeating-characters_lengthOfLongestSubstring\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafleet_tmp_tmpa2e4kb9v_0001-0050_0003-longest-substring-without-repeating-characters_lengthOfLongestSubstring\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Represents an interval with left-inclusive, right-exclusive bounds -/\n\n/-  Length of an interval -/\n\n/-  Predicate for valid interval within a string with no repeating characters -/\n\n-- Interval is in valid range\n\n(0 ≤ iv.left ∧ iv.left ≤ iv.right ∧ iv.right ≤ s.length) ∧\n\n-- No repeating characters in interval\n\n(∀ i j, iv.left ≤ i ∧ i < j ∧ j < iv.right → s.get ⟨i.toNat⟩ ≠ s.get ⟨j.toNat⟩)\n\n/- \nFinds length of longest substring without repeating characters.\nReturns both the length and the interval containing the substring.\n-/\n\n-- best_iv is valid\n\n-- best_iv is longest", "vc-preamble": "structure Interval where\nleft : Int\nright : Int\nvalid : left ≤ right\n\ndef length (iv : Interval) : Int :=\niv.right - iv.left\n\ndef valid_interval (s : String) (iv : Interval) : Prop :=\n(0 ≤ iv.left ∧ iv.left ≤ iv.right ∧ iv.right ≤ s.length) ∧\n(∀ i j, iv.left ≤ i ∧ i < j ∧ j < iv.right → s.get ⟨i.toNat⟩ ≠ s.get ⟨j.toNat⟩)", "vc-helpers": "", "vc-definitions": "def lengthOfLongestSubstring (s : String) : Int × Interval :=\nsorry", "vc-theorems": "theorem lengthOfLongestSubstring_spec (s : String) :\nlet result := lengthOfLongestSubstring s\nlet n := result.1\nlet best_iv := result.2\nvalid_interval s best_iv ∧\nlength best_iv = n ∧\n(∀ iv : Interval, valid_interval s iv → length iv ≤ n) :=\nsorry", "vc-postamble": ""}
{"id": "dafleet_tmp_tmpa2e4kb9v_0001-0050_0005-longest-palindromic-substring_expand_from_center", "vc-description": "/- \n{\n\"name\": \"dafleet_tmp_tmpa2e4kb9v_0001-0050_0005-longest-palindromic-substring_expand_from_center\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafleet_tmp_tmpa2e4kb9v_0001-0050_0005-longest-palindromic-substring_expand_from_center\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nPredicate indicating whether a substring s is palindromic\n-/\n\n/- \nHelper function that returns absolute value\n-/\n\n/- \nPredicate indicating whether an interval is maximal for a given center sum k\n-/\n\n/- \nMain expand_from_center function specification\n-/\n\n/- \nSpecification for expand_from_center\n-/\n\n/- \nHelper function to insert bogus characters\n-/\n\n/- \nSpecification for insert_bogus_chars\n-/", "vc-preamble": "partial def palindromic (s : String) (i j : Int) : Prop :=\n(0 ≤ i) ∧ (i ≤ j) ∧ (j ≤ s.length) ∧\n((j - i < 2) ∨ (s.get ⟨i.toNat⟩ = s.get ⟨(j-1).toNat⟩ ∧ palindromic s (i+1) (j-1)))\n\ndef abs (x : Int) : Int :=\nif x ≥ 0 then x else -x\n\ndef max_interval_for_same_center (s : String) (k lo hi : Int) : Prop :=\n(0 ≤ lo) ∧ (lo ≤ hi) ∧ (hi ≤ s.length) ∧\n(lo + hi = k) ∧\npalindromic s lo hi ∧\n(∀ i j, (0 ≤ i) ∧ (i ≤ j) ∧ (j ≤ s.length) ∧ palindromic s i j ∧ (i + j = k) → (j - i ≤ hi - lo))", "vc-helpers": "", "vc-definitions": "def expand_from_center (s : String) (i0 j0 : Int) : (Int × Int) :=\nsorry\n\ndef insert_bogus_chars (s : String) (bogus : Char) : String :=\nsorry", "vc-theorems": "theorem expand_from_center_spec (s : String) (i0 j0 : Int) :\n(0 ≤ i0) ∧ (i0 ≤ j0) ∧ (j0 ≤ s.length) ∧ palindromic s i0 j0 →\nlet (lo, hi) := expand_from_center s i0 j0\n(0 ≤ lo) ∧ (lo ≤ hi) ∧ (hi ≤ s.length) ∧ palindromic s lo hi ∧\n(∀ i j, (0 ≤ i) ∧ (i ≤ j) ∧ (j ≤ s.length) ∧ palindromic s i j ∧ (i + j = i0 + j0) →\n(j - i ≤ hi - lo)) :=\nsorry\n\ntheorem insert_bogus_chars_spec (s : String) (bogus : Char) :\nlet s' := insert_bogus_chars s bogus\n(s'.length = 2 * s.length + 1) ∧\n(∀ i, (0 ≤ i) ∧ (i ≤ s.length) → s'.get ⟨i * 2⟩  = bogus) ∧\n(∀ i, (0 ≤ i) ∧ (i < s.length) → s'.get ⟨i * 2 + 1⟩  = s.get ⟨i⟩) :=\nsorry", "vc-postamble": ""}
{"id": "dafleet_tmp_tmpa2e4kb9v_0001-0050_0005-longest-palindromic-substring_longestPalindrome", "vc-description": "/- \n{\n\"name\": \"dafleet_tmp_tmpa2e4kb9v_0001-0050_0005-longest-palindromic-substring_longestPalindrome\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafleet_tmp_tmpa2e4kb9v_0001-0050_0005-longest-palindromic-substring_longestPalindrome\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Whether a substring s is palindromic -/\n\n/-  Helper function that returns longest palindrome at given center -/\n\n/-  Specification for expand_from_center -/\n\n/-  Insert bogus characters into string -/\n\n/-  Returns max index and value from array starting at given index -/\n\n/-  Whether radius r at center c is within string bounds -/\n\n/-  Whether radius r is palindromic at center c -/\n\n/-  Whether r is maximal palindromic radius at center c -/\n\n/-  Absolute value -/\n\n/-  Whether interval is maximal palindrome for given center sum -/\n\n/-  Main function to find longest palindromic substring -/\n\n/-  Specification for longestPalindrome -/", "vc-preamble": "partial def palindromic (s : String) (i j : Int) : Prop :=\n(0 ≤ i) ∧ (i ≤ j) ∧ (j ≤ s.length) ∧\n(j - i < 2 ∨ (s.get ⟨i.toNat⟩ = s.get ⟨ (j-1).toNat⟩  ∧ palindromic s (i+1) (j-1)))\n\ndef inbound_radius (s : String) (c r : Int) : Prop :=\nr ≥ 0 ∧ 0 ≤ c-r ∧ c+r < s.length\n\ndef palindromic_radius (s : String) (c r : Int) : Prop :=\ninbound_radius s c r → palindromic s (c-r) (c+r+1)\n\ndef max_radius (s : String) (c r : Int) : Prop :=\ninbound_radius s c r ∧\npalindromic_radius s c r ∧\n(∀ r', r' > r ∧ inbound_radius s c r' → ¬palindromic_radius s c r')\n\ndef abs (x : Int) : Int :=\nif x ≥ 0 then x else -x\n\ndef max_interval_for_same_center (s : String) (k lo hi : Int) : Prop :=\n(0 ≤ lo) ∧ (lo ≤ hi) ∧ (hi ≤ s.length) ∧\nlo + hi = k ∧\npalindromic s lo hi ∧\n(∀ i j, (0 ≤ i) ∧ (i ≤ j) ∧ (j ≤ s.length) ∧\npalindromic s i j ∧ i + j = k → j - i ≤ hi - lo)", "vc-helpers": "", "vc-definitions": "def expand_from_center (s : String) (i0 j0 : Int) : (Int × Int) :=\nsorry\n\ndef insert_bogus_chars (s : String) (bogus : Char) : String :=\nsorry\n\ndef argmax (a : Array Int) (start : Int) : (Int × Int) :=\nsorry\n\ndef longestPalindrome (s : String) : (String × Int × Int) :=\nsorry", "vc-theorems": "theorem expand_from_center_spec (s : String) (i0 j0 : Int) :\n(0 ≤ i0) ∧ (i0 ≤ j0) ∧ (j0 ≤ s.length) ∧ palindromic s i0 j0 →\nlet (lo, hi) := expand_from_center s i0 j0\n(0 ≤ lo) ∧ (lo ≤ hi) ∧ (hi ≤ s.length) ∧ palindromic s lo hi ∧\n(∀ i j, (0 ≤ i) ∧ (i ≤ j) ∧ (j ≤ s.length) ∧ palindromic s i j ∧\n(i + j = i0 + j0) → (j - i ≤ hi - lo)) :=\nsorry\n\ntheorem longestPalindrome_spec (s : String) :\nlet (ans, lo, hi) := longestPalindrome s\n(0 ≤ lo) ∧ (lo ≤ hi) ∧ (hi ≤ s.length) ∧\n(ans = s.extract ⟨lo.toNat⟩  ⟨hi.toNat⟩ ) ∧\npalindromic s lo hi ∧\n(∀ i j, (0 ≤ i) ∧ (i ≤ j) ∧ (j ≤ s.length) ∧\npalindromic s i j → j - i ≤ hi - lo) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-duck_tmp_tmplawbgxjo_ex3_BadSort", "vc-description": "/- \n{\n\"name\": \"dafny-duck_tmp_tmplawbgxjo_ex3_BadSort\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-duck_tmp_tmplawbgxjo_ex3_BadSort\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nPredicate indicating if a string is sorted according to specific rules:\n- No 'b' characters should appear after non-'b' characters\n- Only non-'d' characters should appear before 'd' characters\n-/\n\n/- \nBadSort takes a string containing only 'b', 'a', and 'd' characters and returns\na sorted string according to the sortedbad predicate while preserving character counts\n-/", "vc-preamble": "def sortedbad (s : String) : Prop :=\n(∀ i j, 0 ≤ i ∧ i ≤ j ∧ j < s.length ∧ s.get ⟨i⟩ = 'b' ∧ s.get ⟨j⟩ ≠ 'b' → i < j) ∧\n(∀ i j, 0 ≤ i ∧ i ≤ j ∧ j < s.length ∧ s.get ⟨i⟩ ≠ 'd' ∧ s.get ⟨j⟩ = 'd' → i < j)", "vc-helpers": "", "vc-definitions": "def BadSort (a : String) : String :=\nsorry", "vc-theorems": "theorem BadSort_spec (a : String) :\n(∀ i, 0 ≤ i ∧ i < a.length → a.get ⟨i⟩ = 'b' ∨ a.get ⟨i⟩ = 'a' ∨ a.get ⟨i⟩ = 'd') →\nlet b := BadSort a\nsortedbad b ∧\n\n-- Note: Simplified multiset condition since exact multiset ops not available\n\nb.length = a.length :=\nsorry", "vc-postamble": ""}
{"id": "dafny-duck_tmp_tmplawbgxjo_p1_SumArray", "vc-description": "/- \n{\n\"name\": \"dafny-duck_tmp_tmplawbgxjo_p1_SumArray\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-duck_tmp_tmplawbgxjo_p1_SumArray\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nRecursively computes the sum of elements in an array.\nGiven an array of integers, returns their sum.\nExample:  -> 9\n-/\n\n/- \nTakes an array of integers and returns their sum.\nEnsures the result equals Sum applied to the input array.\n-/", "vc-preamble": "partial def Sum_ (xs : Array Int) : Int :=\nif xs.size = 0 then\n0\nelse\nSum_ (xs.extract 0 (xs.size - 1)) + xs[xs.size - 1]!", "vc-helpers": "", "vc-definitions": "def SumArray (xs : Array Int) : Int :=\nsorry", "vc-theorems": "theorem SumArray_spec (xs : Array Int) (s : Int) :\ns = SumArray xs → s = Sum_ xs :=\nsorry", "vc-postamble": ""}
{"id": "dafny-duck_tmp_tmplawbgxjo_p4_single", "vc-description": "/- \n{\n\"name\": \"dafny-duck_tmp_tmplawbgxjo_p4_single\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-duck_tmp_tmplawbgxjo_p4_single\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nMerges two arrays of integers into a single array containing all elements.\nInput arrays must be non-empty.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def single (x : Array Int) (y : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem single_spec (x y : Array Int) :\nx.size > 0 ∧ y.size > 0 →\n∀ (result : Array Int), single x y = result →\nresult.size = x.size + y.size ∧\n(∀ i:Fin x.size, i < x.size → result[i]! = x[i]!) ∧\n(∀ i:Fin y.size, i < y.size → result[x.size + i]! = y[i]!) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-duck_tmp_tmplawbgxjo_p6_FilterVowelsArray", "vc-description": "/- \n{\n\"name\": \"dafny-duck_tmp_tmplawbgxjo_p6_FilterVowelsArray\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-duck_tmp_tmplawbgxjo_p6_FilterVowelsArray\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  The set of vowels used for filtering -/\n\n/- \nFilters vowels from a sequence of characters.\nReturns a new sequence containing only the vowels from the input.\n-/\n\n/- \nTakes an array of characters and returns a new array containing only the vowels.\nEnsures the returned array is fresh (newly allocated) and contains exactly the vowels from the input.\n-/", "vc-preamble": "def vowels : List Char := ['a', 'e', 'i', 'o', 'u']\npartial def FilterVowels (xs : Array Char) : Array Char :=\nif xs.size = 0 then\n#[]\nelse if vowels.contains (xs[xs.size - 1]!) then\nFilterVowels (xs.extract 0 (xs.size - 1)) |>.push (xs[xs.size - 1]!)\nelse\nFilterVowels (xs.extract 0 (xs.size - 1))", "vc-helpers": "", "vc-definitions": "def FilterVowelsArray (xs : Array Char) : Array Char :=\nsorry", "vc-theorems": "theorem FilterVowelsArray_spec (xs : Array Char) (ys : Array Char) :\nys = FilterVowelsArray xs →\nFilterVowels xs = ys :=\nsorry", "vc-postamble": ""}
{"id": "dafny-exercise_tmp_tmpouftptir_absIt_AbsIt", "vc-description": "/- \n{\n\"name\": \"dafny-exercise_tmp_tmpouftptir_absIt_AbsIt\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-exercise_tmp_tmpouftptir_absIt_AbsIt\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nAbsIt takes an array of integers and modifies it in place to contain absolute values.\nThe specification ensures that:\n1. For each element, if it was negative, it becomes its positive counterpart\n2. The array length remains unchanged\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def AbsIt (s : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem AbsIt_spec (s : Array Int) :\nlet s' := AbsIt s\n(∀ i, 0 ≤ i ∧ i < s.size →\n(if s[i]! < 0 then s'[i]! = -(s[i]!) else s'[i]! = s[i]!)) ∧\ns'.size = s.size :=\nsorry", "vc-postamble": ""}
{"id": "dafny-exercise_tmp_tmpouftptir_appendArray_appendArray", "vc-description": "/- \n{\n\"name\": \"dafny-exercise_tmp_tmpouftptir_appendArray_appendArray\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-exercise_tmp_tmpouftptir_appendArray_appendArray\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nAppends two arrays of integers into a new array.\nThe resulting array contains all elements from the first array followed by all elements from the second array.\n\n@param a First input array\n@param b Second input array\n@return c Concatenated array containing elements from a followed by elements from b\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def appendArray (a : Array Int) (b : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem appendArray_spec (a b c : Array Int) :\nc = appendArray a b →\n(c.size = a.size + b.size) ∧\n(∀ i, 0 ≤ i ∧ i < a.size → a[i]! = c[i]!) ∧\n(∀ i, 0 ≤ i ∧ i < b.size → b[i]! = c[a.size + i]!) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-exercise_tmp_tmpouftptir_countNeg_CountNeg", "vc-description": "/- \n{\n\"name\": \"dafny-exercise_tmp_tmpouftptir_countNeg_CountNeg\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-exercise_tmp_tmpouftptir_countNeg_CountNeg\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nRecursively counts negative numbers in array up to given index.\nTranslated from Dafny function verifyNeg.\n-/\n\n/- \nMain method that counts negative numbers in array.\nTranslated from Dafny method CountNeg.\n-/", "vc-preamble": "partial def verifyNeg (a : Array Int) (idx : Int) : Nat :=\nif idx == 0 then 0\nelse verifyNeg a (idx - 1) + (if a[(idx - 1).toNat]! < 0 then 1 else 0)", "vc-helpers": "", "vc-definitions": "def CountNeg (a : Array Int) : Nat :=\nsorry", "vc-theorems": "theorem CountNeg_spec (a : Array Int) :\nCountNeg a = verifyNeg a a.size :=\nsorry", "vc-postamble": ""}
{"id": "dafny-exercise_tmp_tmpouftptir_filter_Filter", "vc-description": "/- \n{\n\"name\": \"dafny-exercise_tmp_tmpouftptir_filter_Filter\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-exercise_tmp_tmpouftptir_filter_Filter\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nTranslates the Dafny Filter method which takes a sequence of characters and a set of characters\nand returns a filtered set containing only characters present in both inputs.\n\n@param a The input sequence of characters\n@param b The input set of characters to filter against\n@return A set containing characters present in both inputs\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Filter (a : Array Char) (b : List Char) : List Char :=\nsorry", "vc-theorems": "theorem Filter_spec (a : Array Char) (b : List Char) (c : List Char) :\nc = Filter a b →\n(∀ x, (x ∈ a.toList ∧ x ∈ b) ↔ x ∈ c) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-exercise_tmp_tmpouftptir_firstE_firstE", "vc-description": "/- \n{\n\"name\": \"dafny-exercise_tmp_tmpouftptir_firstE_firstE\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-exercise_tmp_tmpouftptir_firstE_firstE\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nFinds the first occurrence of character 'e' in an array.\nReturns the index of first 'e' if found, -1 if not found.\n\n@param a The input array of characters to search\n@return The index of first 'e' or -1 if not found\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def firstE (a : Array Char) : Int :=\nsorry", "vc-theorems": "theorem firstE_spec (a : Array Char) :\nlet x := firstE a\n(∃ i, 0 ≤ i ∧ i < a.size ∧ a[i]! = 'e') →\n(0 ≤ x ∧ x < a.size ∧ a[x.toNat]! = 'e' ∧\n∀ i, 0 ≤ i ∧ i < x → a[i.toNat]! ≠ 'e') ∧\n(¬∃ i, 0 ≤ i ∧ i < a.size ∧ a[i]! = 'e') →\nx = -1 :=\nsorry", "vc-postamble": ""}
{"id": "dafny-exercise_tmp_tmpouftptir_prac3_ex2_GetEven", "vc-description": "/- \n{\n\"name\": \"dafny-exercise_tmp_tmpouftptir_prac3_ex2_GetEven\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-exercise_tmp_tmpouftptir_prac3_ex2_GetEven\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nGetEven modifies an array of natural numbers by incrementing odd numbers by 1.\n\n@param s Array of natural numbers to be modified\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def GetEven (s : Array Nat) : Array Nat :=\nsorry", "vc-theorems": "theorem GetEven_spec (s : Array Nat) :\n∀ i, 0 ≤ i ∧ i < s.size →\nlet s' := GetEven s\nif s[i]! % 2 = 1\nthen s'[i]! = s[i]! + 1\nelse s'[i]! = s[i]! :=\nsorry", "vc-postamble": ""}
{"id": "dafny-exercise_tmp_tmpouftptir_prac4_ex2_GetTriple", "vc-description": "/- \n{\n\"name\": \"dafny-exercise_tmp_tmpouftptir_prac4_ex2_GetTriple\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-exercise_tmp_tmpouftptir_prac4_ex2_GetTriple\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nPredicate that checks if an array contains three consecutive equal elements\n-/\n\n/- \nGetTriple method that finds three consecutive equal elements in an array\nReturns the starting index of such a triple if found, or array length if not found\n-/", "vc-preamble": "def triple (a : Array Int) : Prop :=\n∃ i, 0 ≤ i ∧ i < a.size - 2 ∧ a[i]! = a[(i + 1)]! ∧ a[(i + 1)]! = a[(i + 2)]!", "vc-helpers": "", "vc-definitions": "def GetTriple (a : Array Int) : Int :=\nsorry", "vc-theorems": "theorem GetTriple_spec (a : Array Int) :\nlet index := GetTriple a\n(0 ≤ index ∧ index < a.size - 2 ∨ index = a.size) ∧\n(index = a.size ↔ ¬(triple a)) ∧\n(0 ≤ index ∧ index < a.size - 2 ↔ triple a) ∧\n(0 ≤ index ∧ index < a.size - 2 →\na[index.toNat]! = a[(index + 1).toNat]! ∧ a[(index + 1).toNat]! = a[(index + 2).toNat]!) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-exercise_tmp_tmpouftptir_reverse_Reverse", "vc-description": "/- \n{\n\"name\": \"dafny-exercise_tmp_tmpouftptir_reverse_Reverse\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-exercise_tmp_tmpouftptir_reverse_Reverse\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nReverses an array of characters.\n\n@param a The input array to reverse\n@return b The reversed array\n\nSpecification:\n- Requires input array length > 0\n- Ensures input array is unchanged\n- Ensures output array has same length as input\n- Ensures output array contains reversed elements of input\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Reverse (a : Array Char) : Array Char :=\nsorry", "vc-theorems": "theorem reverse_spec (a : Array Char) (b : Array Char) :\na.size > 0 →\nb = Reverse a →\n(b.size = a.size ∧\n∀ i, 0 ≤ i ∧ i < a.size → b[i]! = a[a.size - i - 1]!) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-exercise_tmp_tmpouftptir_zapNegatives_ZapNegatives", "vc-description": "/- \n{\n\"name\": \"dafny-exercise_tmp_tmpouftptir_zapNegatives_ZapNegatives\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-exercise_tmp_tmpouftptir_zapNegatives_ZapNegatives\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nZapNegatives modifies an array by replacing negative values with 0.\nThe array length remains unchanged.\n\n@param a The input array to modify\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def ZapNegatives (a : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem ZapNegatives_spec (a : Array Int) :\nlet result := ZapNegatives a\n(∀ i, 0 ≤ i ∧ i < a.size →\n(if (a[i]! < 0) then result[i]! = 0\nelse result[i]! = a[i]!)) ∧\nresult.size = a.size :=\nsorry", "vc-postamble": ""}
{"id": "dafny-exercises_tmp_tmp5mvrowrx_leetcode_26-remove-duplicates-from-sorted-array_RemoveDuplicates", "vc-description": "/- \n{\n\"name\": \"dafny-exercises_tmp_tmp5mvrowrx_leetcode_26-remove-duplicates-from-sorted-array_RemoveDuplicates\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-exercises_tmp_tmp5mvrowrx_leetcode_26-remove-duplicates-from-sorted-array_RemoveDuplicates\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nRemoveDuplicates removes duplicates from a sorted array.\n\nInput:\n- nums: Array of integers, sorted in ascending order\n\nOutput:\n- num_length: Length of array after removing duplicates\n\nSpecification:\n- Array remains sorted\n- Output length is valid (between 0 and array length)\n- No duplicates in output portion\n- Output elements come from input\n- All input elements appear in output\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def RemoveDuplicates (nums : Array Int) : Int :=\nsorry", "vc-theorems": "theorem RemoveDuplicates_spec (nums : Array Int) (num_length : Int) :\n(∀ i j, 0 ≤ i ∧ i < j ∧ j < nums.size → nums[i]! ≤ nums[j]!) →\n(num_length = RemoveDuplicates nums) →\n(0 ≤ num_length ∧ num_length ≤ nums.size) ∧\n(∀ i j:Nat, 0 ≤ i ∧ i < j ∧ j < num_length → nums[i]! ≠ nums[j]!) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-language-server_tmp_tmpkir0kenl_Test_VSComp2010_Problem1-SumMax_M", "vc-description": "/- \n{\n\"name\": \"dafny-language-server_tmp_tmpkir0kenl_Test_VSComp2010_Problem1-SumMax_M\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-language-server_tmp_tmpkir0kenl_Test_VSComp2010_Problem1-SumMax_M\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nMethod M computes the sum and max of an array of integers.\nTranslated from Dafny specification that requires:\n- N is non-negative\n- Array length equals N\n- All array elements are non-negative\nEnsures that sum ≤ N * max\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def M (N : Int) (a : Array Int) : Int × Int :=\nsorry", "vc-theorems": "theorem M_spec (N : Int) (a : Array Int) :\n(N ≥ 0 ∧ a.size = N ∧ (∀ k:Fin a.size, 0 ≤ a[k]!)) →\nlet (sum, max) := M N a\nsum ≤ N * max :=\nsorry", "vc-postamble": ""}
{"id": "dafny-language-server_tmp_tmpkir0kenl_Test_comp_Arrays_LinearSearch", "vc-description": "/- \n{\n\"name\": \"dafny-language-server_tmp_tmpkir0kenl_Test_comp_Arrays_LinearSearch\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-language-server_tmp_tmpkir0kenl_Test_comp_Arrays_LinearSearch\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nPrints an array. Implementation omitted.\n-/\n\n/- \nType alias for lowercase characters\n-/\n\n/- \nCreates a diagonal matrix with given dimensions and values.\n-/\n\n/- \nPrints a 2D matrix. Implementation omitted.\n-/\n\n/- \nLinear search in an array. Returns index of key if found, or array length if not found.\n-/\n\n/- \nSpecification for LinearSearch:\n- Returns valid index or array length\n- If index returned, element at that index equals key\n-/", "vc-preamble": "def lowercase := Char", "vc-helpers": "", "vc-definitions": "def PrintArray (a : Array α) : Unit :=\nsorry\n\ndef DiagMatrix (rows : Int) (cols : Int) (zero : α) (one : α) : Array (Array α) :=\nsorry\n\ndef PrintMatrix (m : Array (Array α)) : Unit :=\nsorry\n\ndef LinearSearch (a : Array Int) (key : Int) : Nat :=\nsorry", "vc-theorems": "theorem LinearSearch_spec (a : Array Int) (key : Int) :\nlet n := LinearSearch a key\nn ≤ a.size ∧ (n = a.size ∨ (a[n]!) = key) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-language-server_tmp_tmpkir0kenl_Test_dafny2_SegmentSum_MaxSegSum", "vc-description": "/- \n{\n\"name\": \"dafny-language-server_tmp_tmpkir0kenl_Test_dafny2_SegmentSum_MaxSegSum\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-language-server_tmp_tmpkir0kenl_Test_dafny2_SegmentSum_MaxSegSum\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nComputes the sum of elements in array `a` from index `s` to `t-1`.\nRequires that 0 ≤ s ≤ t ≤ a.size\n-/\n\n/- \nSpecification for Sum function requiring valid indices\n-/\n\n/- \nMaxSegSum finds indices k,m that maximize the sum of elements from k to m-1\nReturns k,m such that:\n1. 0 ≤ k ≤ m ≤ a.size\n2. For all valid p,q: Sum(a,p,q) ≤ Sum(a,k,m)\n-/\n\n/- \nSpecification for MaxSegSum ensuring returned indices give maximum segment sum\n-/", "vc-preamble": "partial def Sum_ (a : Array Int) (s t : Int) : Int :=\nif s = t then 0 else Sum_ a s (t-1) + a[(t-1).toNat]!", "vc-helpers": "", "vc-definitions": "def MaxSegSum (a : Array Int) : Int × Int :=\nsorry", "vc-theorems": "theorem Sum_spec (a : Array Int) (s t : Int) :\n0 ≤ s ∧ s ≤ t ∧ t ≤ a.size → Sum_ a s t ≥ 0 :=\nsorry\n\ntheorem MaxSegSum_spec (a : Array Int) :\nlet (k, m) := MaxSegSum a\n0 ≤ k ∧ k ≤ m ∧ m ≤ a.size ∧\n(∀ p q, 0 ≤ p ∧ p ≤ q ∧ q ≤ a.size → Sum_ a p q ≤ Sum_ a k m) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-language-server_tmp_tmpkir0kenl_Test_dafny2_TuringFactorial_ComputeFactorial", "vc-description": "/- \n{\n\"name\": \"dafny-language-server_tmp_tmpkir0kenl_Test_dafny2_TuringFactorial_ComputeFactorial\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-language-server_tmp_tmpkir0kenl_Test_dafny2_TuringFactorial_ComputeFactorial\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nRecursive factorial function translated from Dafny.\nTakes a natural number n and returns n!\n-/\n\n/- \nComputeFactorial method translated from Dafny.\nTakes an integer n and returns its factorial.\nRequires n ≥ 1 and ensures result equals Factorial(n)\n-/", "vc-preamble": "partial def Factorial (n : Nat) : Nat :=\nif n == 0 then 1 else n * Factorial (n-1)", "vc-helpers": "", "vc-definitions": "def ComputeFactorial (n : Int) : Int :=\nsorry", "vc-theorems": "theorem ComputeFactorial_spec (n : Int) :\n1 ≤ n → ComputeFactorial n = Factorial n.toNat :=\nsorry", "vc-postamble": ""}
{"id": "dafny-language-server_tmp_tmpkir0kenl_Test_dafny4_Bug165_Select", "vc-description": "/- \n{\n\"name\": \"dafny-language-server_tmp_tmpkir0kenl_Test_dafny4_Bug165_Select\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-language-server_tmp_tmpkir0kenl_Test_dafny4_Bug165_Select\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nSelect method that filters elements from a sequence based on predicate f\nReturns a new sequence containing only elements that satisfy f\n-/\n\n/- \nSpecification for Select method:\n- For elements satisfying f, their count in output equals count in input\n- For elements not satisfying f, their count in output is 0\n-/\n\n/- \nMain method taking a sequence parameter\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Select {T : Type} [BEq T] (f : T → Bool) (s1 : Array T) : Array T :=\nsorry\n\ndef Main {T : Type} [BEq T] (f : T → Bool) (s1 : Array T) : Unit :=\nsorry", "vc-theorems": "theorem Select_spec {T : Type} [BEq T] (f : T → Bool) (s1 : Array T) (r : Array T) :\n(∀ e : T, f e → (s1.count e = r.count e)) ∧\n(∀ e : T, ¬f e → (r.count e = 0)) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-language-server_tmp_tmpkir0kenl_Test_tutorial_maximum_Maximum", "vc-description": "/- \n{\n\"name\": \"dafny-language-server_tmp_tmpkir0kenl_Test_tutorial_maximum_Maximum\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-language-server_tmp_tmpkir0kenl_Test_tutorial_maximum_Maximum\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nComputes the maximum element in a non-empty array of integers.\n\n@param values The input array of integers\n@return The maximum value in the array\n\nSpecification:\n- Requires the input array is not empty\n- Ensures the returned value exists in the input array\n- Ensures the returned value is greater than or equal to all elements\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Maximum (values : Array Int) : Int :=\nsorry", "vc-theorems": "theorem Maximum_spec (values : Array Int) (max : Int) :\nvalues.size > 0 →\n(∃ i:Fin values.size, values[i]! = max) ∧\n(∀ i, 0 ≤ i ∧ i < values.size → values[i]! ≤ max) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-language-server_tmp_tmpkir0kenl_Test_vstte2012_Two-Way-Sort_two_way_sort", "vc-description": "/- \n{\n\"name\": \"dafny-language-server_tmp_tmpkir0kenl_Test_vstte2012_Two-Way-Sort_two_way_sort\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-language-server_tmp_tmpkir0kenl_Test_vstte2012_Two-Way-Sort_two_way_sort\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nConverts a sequence to a multiset.\n-/\n\n/- \nSwaps two elements in an array.\n-/\n\n/- \nSpecification for swap operation.\n-/\n\n/- \nTwo-way sort implementation for boolean arrays.\n-/\n\n/- \nSpecification for two-way sort operation.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def multisets {α : Type} [Inhabited α] (s : Array α) : List α :=\nsorry\n\ndef swap {α : Type} [Inhabited α] (a : Array α) (i j : Nat) : Array α :=\nsorry\n\ndef two_way_sort (a : Array Bool) : Array Bool :=\nsorry", "vc-theorems": "theorem swap_spec {α : Type} [Inhabited α] (a : Array α) (i j : Nat) :\n0 ≤ i ∧ i < j ∧ j < a.size →\nlet a' := swap a i j\n(a'[i]! = a[j]!) ∧\n(a'[j]! = a[i]!) ∧\n(∀ m, 0 ≤ m ∧ m < a.size ∧ m ≠ i ∧ m ≠ j → a'[m]! = a[m]!) ∧\n(multisets a' = multisets a) :=\nsorry\n\ntheorem two_way_sort_spec (a : Array Bool) :\nlet a' := two_way_sort a\n(∀ m n, 0 ≤ m ∧ m < n ∧ n < a'.size → ¬(a'[m]!) ∨ a'[n]!) ∧\n(multisets a' = multisets a) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-programs_tmp_tmpcwodh6qh_src_expt_expt", "vc-description": "/- \n{\n\"name\": \"dafny-programs_tmp_tmpcwodh6qh_src_expt_expt\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-programs_tmp_tmpcwodh6qh_src_expt_expt\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nGhost function that computes b raised to the power n recursively.\nRequires n to be non-negative.\n-/\n\n/- \nMethod that computes exponentiation.\nEnsures the result equals Expt(b,n).\n-/", "vc-preamble": "partial def Expt (b : Int) (n : Nat) : Int :=\nif n == 0 then 1 else b * Expt b (n - 1)", "vc-helpers": "", "vc-definitions": "def expt (b : Int) (n : Nat) : Int :=\nsorry", "vc-theorems": "theorem expt_spec (b : Int) (n : Nat) :\nexpt b n = Expt b n :=\nsorry", "vc-postamble": ""}
{"id": "dafny-programs_tmp_tmpcwodh6qh_src_factorial_factorial", "vc-description": "/- \n{\n\"name\": \"dafny-programs_tmp_tmpcwodh6qh_src_factorial_factorial\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-programs_tmp_tmpcwodh6qh_src_factorial_factorial\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nRecursive factorial function translated from Dafny.\nEnsures the result is always >= 1.\n-/\n\n/- \nSpecification ensuring fact returns values >= 1\n-/\n\n/- \nMain factorial method that computes factorial of n.\nEnsures the result equals fact(n).\n-/\n\n/- \nSpecification ensuring factorial returns same value as fact function\n-/", "vc-preamble": "partial def fact (n : Nat) : Nat :=\nif n == 0 then 1 else n * fact (n - 1)", "vc-helpers": "", "vc-definitions": "def factorial (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem fact_spec (n : Nat) : fact n ≥ 1 :=\nsorry\n\ntheorem factorial_spec (n : Nat) : factorial n = fact n :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_105_CountTrue", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_105_CountTrue\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_105_CountTrue\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nRecursively counts the number of true values in an array up to index n.\nTranslated from Dafny's countTo function.\n-/\n\n/- \nMain function that counts total number of true values in array.\nTranslated from Dafny's CountTrue method.\n-/\n\n/- \nSpecification for countTo function.\nEnsures proper array bounds and null checks are maintained.\n-/\n\n/- \nSpecification for CountTrue function.\nEnsures result matches counting all true values in array.\n-/", "vc-preamble": "def countTo (a : Array Bool) (n : Nat) : Int :=\nif n = 0 then 0\nelse countTo a (n-1) + (if a[n-1]! then 1 else 0)\n\ndef CountTrue (a : Array Bool) : Int :=\ncountTo a a.size", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "theorem countTo_spec (a : Array Bool) (n : Nat) :\nn ≥ 0 ∧ n ≤ a.size →\ncountTo a n ≥ 0 :=\nsorry\n\ntheorem CountTrue_spec (a : Array Bool) :\nCountTrue a = countTo a a.size :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_106_AppendArrayToSeq", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_106_AppendArrayToSeq\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_106_AppendArrayToSeq\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nAppends an array to a sequence.\nInput:\n- s: The initial sequence\n- a: The array to append\nReturns:\n- The concatenated sequence\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def AppendArrayToSeq (s : Array Int) (a : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem AppendArrayToSeq_spec (s : Array Int) (a : Array Int) :\nlet r := AppendArrayToSeq s a\nr.size = s.size + a.size ∧\n(∀ i, 0 ≤ i ∧ i < s.size → r[i]! = s[i]!) ∧\n(∀ i, 0 ≤ i ∧ i < a.size → r[s.size + i]! = a[i]!) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_113_IsInteger", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_113_IsInteger\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_113_IsInteger\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate that checks if a character is a digit (0-9) -/\n\n/-  Main function that checks if a string represents an integer -/", "vc-preamble": "def IsDigit (c : Char) : Bool :=\n48 ≤ c.toNat ∧ c.toNat ≤ 57", "vc-helpers": "", "vc-definitions": "def IsInteger (s : String) : Bool :=\nsorry", "vc-theorems": "theorem IsInteger_spec (s : String) :\nIsInteger s ↔ (s.length > 0 ∧ ∀ i, 0 ≤ i ∧ i < s.length → IsDigit (s.get ⟨i⟩)) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_126_SumOfCommonDivisors", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_126_SumOfCommonDivisors\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_126_SumOfCommonDivisors\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nComputes the sum of common divisors between two positive integers.\n\n@param a First positive integer\n@param b Second positive integer\n@return Sum of all common divisors between a and b\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def SumOfCommonDivisors (a : Int) (b : Int) : Int :=\nsorry", "vc-theorems": "theorem SumOfCommonDivisors_spec (a b : Int) :\na > 0 ∧ b > 0 →\nlet sum := SumOfCommonDivisors a b\nsum ≥ 0 ∧\n(∀ d, 1 ≤ d ∧ d ≤ a ∧ d ≤ b ∧ a % d = 0 ∧ b % d = 0 → sum ≥ d) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_127_Multiply", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_127_Multiply\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_127_Multiply\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nTranslates the Dafny method Multiply which computes the product of two integers.\n\n@param a First integer input\n@param b Second integer input\n@return The product of a and b\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Multiply (a b : Int) : Int :=\nsorry", "vc-theorems": "theorem Multiply_spec (a b : Int) :\nMultiply a b = a * b :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_133_SumOfNegatives", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_133_SumOfNegatives\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_133_SumOfNegatives\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nRecursively sums all negative numbers in an array up to index n.\nTranslated from Dafny function sumNegativesTo.\n-/\n\n/- \nMain method that returns sum of all negative numbers in array.\nTranslated from Dafny method SumOfNegatives.\n-/", "vc-preamble": "def sumNegativesTo (a : Array Int) (n : Nat) : Int :=\nif n = 0 then 0\nelse if (a[n-1]!) < 0 then\nsumNegativesTo a (n-1) + (a[n-1]!)\nelse\nsumNegativesTo a (n-1)", "vc-helpers": "", "vc-definitions": "def SumOfNegatives (a : Array Int) : Int :=\nsorry", "vc-theorems": "theorem SumOfNegatives_spec (a : Array Int) :\nSumOfNegatives a = sumNegativesTo a a.size :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_142_CountIdenticalPositions", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_142_CountIdenticalPositions\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_142_CountIdenticalPositions\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nCounts the number of positions where three arrays have identical elements.\n\n@param a First array of integers\n@param b Second array of integers\n@param c Third array of integers\n@return count Number of positions where all three arrays have identical elements\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def CountIdenticalPositions (a b c : Array Int) : Int :=\nsorry", "vc-theorems": "theorem CountIdenticalPositions_spec (a b c : Array Int) :\na.size = b.size ∧ b.size = c.size →\nlet count := CountIdenticalPositions a b c\ncount ≥ 0 ∧\n∃ positions : List Nat,\n(∀ i, i ∈ positions →\n0 ≤ i ∧ i < a.size ∧\na[i]! = b[i]! ∧\nb[i]! = c[i]!) ∧\ncount = positions.length :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_143_CountArrays", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_143_CountArrays\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_143_CountArrays\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nCounts the number of arrays in a sequence of arrays.\n\n@param arrays The sequence of arrays to count\n@return The count of arrays in the sequence\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def CountArrays (arrays : Array (Array Int)) : Int :=\nsorry", "vc-theorems": "theorem CountArrays_spec (arrays : Array (Array Int)) :\nlet count := CountArrays arrays\ncount ≥ 0 ∧ count = arrays.size :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_145_MaxDifference", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_145_MaxDifference\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_145_MaxDifference\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nMaxDifference takes an array of integers and returns the maximum difference between any two elements.\nRequires the array to have length > 1.\nEnsures the returned difference is greater than or equal to any difference between two array elements.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def MaxDifference (a : Array Int) : Int :=\nsorry", "vc-theorems": "theorem MaxDifference_spec (a : Array Int) (diff : Int) :\na.size > 1 →\n(∀ i j, 0 ≤ i ∧ i < a.size ∧ 0 ≤ j ∧ j < a.size →\n(a[i]!) - (a[j]!) ≤ diff) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_14_TriangularPrismVolume", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_14_TriangularPrismVolume\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_14_TriangularPrismVolume\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nCalculates the volume of a triangular prism given base, height and length.\n\n@param base The base length of the triangular face\n@param height The height of the triangular face\n@param length The length of the prism\n@return The volume of the triangular prism\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def TriangularPrismVolume (base : Int) (height : Int) (length : Int) : Int :=\nsorry", "vc-theorems": "theorem TriangularPrismVolume_spec (base height length : Int) :\nbase > 0 →\nheight > 0 →\nlength > 0 →\nTriangularPrismVolume base height length = (base * height * length) / 2 :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_161_RemoveElements", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_161_RemoveElements\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_161_RemoveElements\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate indicating if an element exists in an array -/\n\n/- \nRemoveElements takes two arrays and returns a sequence containing elements that are\nin the first array but not in the second array, with no duplicates.\n\n@param a First input array\n@param b Second input array\n@return Array of integers meeting the specifications\n-/", "vc-preamble": "def InArray (a : Array Int) (x : Int) : Prop :=\n∃ i, 0 ≤ i ∧ i < a.size ∧ a[i]! = x", "vc-helpers": "", "vc-definitions": "def RemoveElements (a b : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem RemoveElements_spec (a b : Array Int) (result : Array Int) :\n(∀ x, x ∈ result.toList → InArray a x ∧ ¬(InArray b x)) ∧\n(∀ i j, 0 ≤ i ∧ i < j ∧ j < result.size → result[i]! ≠ result[j]!) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_170_SumInRange", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_170_SumInRange\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_170_SumInRange\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nRecursively sums elements in array from start index up to but not including end index.\nTranslated from Dafny function sumTo.\n-/\n\n/- \nMain method that returns sum of array elements in given range.\nTranslated from Dafny method SumInRange.\n-/", "vc-preamble": "partial def sumTo (a : Array Int) (start : Nat) (end_ : Nat) : Int :=\nif start == end_ then\n0\nelse\nsumTo a start (end_ - 1) + a[end_ - 1]!", "vc-helpers": "", "vc-definitions": "def SumInRange (a : Array Int) (start : Nat) (end_ : Nat) : Int :=\nsorry", "vc-theorems": "theorem SumInRange_spec (a : Array Int) (start : Nat) (end_ : Nat) :\nstart ≥ 0 ∧ start ≤ end_ ∧ end_ ≤ a.size →\nSumInRange a start end_ = sumTo a start end_ :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_171_PentagonPerimeter", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_171_PentagonPerimeter\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_171_PentagonPerimeter\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nCalculates the perimeter of a pentagon given the side length.\n\n@param side The length of one side of the pentagon\n@return The perimeter of the pentagon\n\nRequires:\n- side > 0\n\nEnsures:\n- Result equals 5 * side\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def PentagonPerimeter (side : Int) : Int :=\nsorry", "vc-theorems": "theorem PentagonPerimeter_spec (side : Int) :\nside > 0 → PentagonPerimeter side = 5 * side :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_18_RemoveChars", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_18_RemoveChars\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_18_RemoveChars\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nRemoveChars takes two strings s1 and s2 and returns a new string v that:\n1. Has length less than or equal to s1\n2. Contains only characters from s1 that are not in s2\n3. Preserves all characters from s1 that are not in s2\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def RemoveChars (s1 s2 : String) : String :=\nsorry", "vc-theorems": "theorem RemoveChars_spec (s1 s2 : String) :\nlet v := RemoveChars s1 s2\n(v.length ≤ s1.length) ∧\n(∀ i, 0 ≤ i ∧ i < v.length →\n(v.get ⟨i⟩ ∈ s1.data) ∧ ¬(v.get ⟨i⟩ ∈ s2.data)) ∧\n(∀ i, 0 ≤ i ∧ i < s1.length →\n(s1.get ⟨i⟩ ∈ s2.data) ∨ (s1.get ⟨i⟩ ∈ v.data)) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_227_MinOfThree", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_227_MinOfThree\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_227_MinOfThree\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nMinOfThree takes three integers and returns their minimum value.\nThe returned value must be less than or equal to all inputs and equal to one of them.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def MinOfThree (a b c : Int) : Int :=\nsorry", "vc-theorems": "theorem MinOfThree_spec (a b c : Int) :\nlet min := MinOfThree a b c\nmin ≤ a ∧ min ≤ b ∧ min ≤ c ∧ (min = a ∨ min = b ∨ min = c) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_230_ReplaceBlanksWithChar", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_230_ReplaceBlanksWithChar\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_230_ReplaceBlanksWithChar\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nReplaces all blank spaces in a string with a given character.\n\n@param s The input string\n@param ch The character to replace spaces with\n@return The string with spaces replaced by ch\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def ReplaceBlanksWithChar (s : String) (ch : Char) : String :=\nsorry", "vc-theorems": "theorem ReplaceBlanksWithChar_spec (s : String) (ch : Char) :\nlet v := ReplaceBlanksWithChar s ch\n(v.length = s.length) ∧\n(∀ i, 0 ≤ i ∧ i < s.length →\n((s.get ⟨i⟩ = ' ' → v.get ⟨i⟩ = ch) ∧\n(s.get ⟨i⟩ ≠ ' ' → v.get ⟨i⟩ = s.get ⟨i⟩))) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_233_CylinderLateralSurfaceArea", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_233_CylinderLateralSurfaceArea\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_233_CylinderLateralSurfaceArea\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nCalculates the lateral surface area of a cylinder given its radius and height.\nRequires positive radius and height.\nEnsures the area is 2π * radius * height.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def CylinderLateralSurfaceArea (radius : Float) (height : Float) : Float :=\nsorry", "vc-theorems": "theorem CylinderLateralSurfaceArea_spec (radius height : Float) :\nradius > 0 ∧ height > 0 →\nCylinderLateralSurfaceArea radius height = 2 * (radius * height) * 3.14 :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_234_CubeVolume", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_234_CubeVolume\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_234_CubeVolume\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nCalculates the volume of a cube given its size.\n\n@param size The length of one side of the cube\n@return The volume of the cube\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def CubeVolume (size : Int) : Int :=\nsorry", "vc-theorems": "theorem CubeVolume_spec (size : Int) :\nsize > 0 → CubeVolume size = size * size * size :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_238_CountNonEmptySubstrings", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_238_CountNonEmptySubstrings\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_238_CountNonEmptySubstrings\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nCounts the number of non-empty substrings in a string.\nThe result is guaranteed to be non-negative and equal to (|s| * (|s| + 1)) / 2.\n-/", "vc-preamble": "import Init", "vc-helpers": "", "vc-definitions": "def CountNonEmptySubstrings (s : String) : Int :=\nsorry", "vc-theorems": "theorem CountNonEmptySubstrings_spec (s : String) :\nlet count := CountNonEmptySubstrings s\ncount ≥ 0 ∧ count = (s.length * (s.length + 1)) / 2 :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_240_ReplaceLastElement", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_240_ReplaceLastElement\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_240_ReplaceLastElement\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nReplaces the last element of the first array with all elements of the second array.\n\n@param first The first input array\n@param second The second input array\n@return The resulting array with last element replaced\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def ReplaceLastElement (first : Array Int) (second : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem ReplaceLastElement_spec (first second : Array Int) :\nfirst.size > 0 →\nlet result := ReplaceLastElement first second\nresult.size = first.size - 1 + second.size ∧\n(∀ i, 0 ≤ i ∧ i < first.size - 1 → result[i]! = first[i]!) ∧\n(∀ i, first.size - 1 ≤ i ∧ i < result.size → result[i]! = second[i - first.size + 1]!) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_242_CountCharacters", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_242_CountCharacters\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_242_CountCharacters\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nCounts the number of characters in a string.\nTranslated from Dafny method CountCharacters.\n\n@param s The input string\n@return The number of characters in the string\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def CountCharacters (s : String) : Int :=\nsorry", "vc-theorems": "theorem CountCharacters_spec (s : String) :\nlet count := CountCharacters s\ncount ≥ 0 ∧ count = s.length :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_249_Intersection", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_249_Intersection\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_249_Intersection\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate indicating if an element exists in an array -/\n\n/- \nIntersection function that returns common elements between two arrays.\nEnsures:\n1. All elements in result are in both input arrays\n2. All elements in result are unique\n-/", "vc-preamble": "def InArray (a : Array Int) (x : Int) : Prop :=\n∃ i, 0 ≤ i ∧ i < a.size ∧ a[i]! = x", "vc-helpers": "", "vc-definitions": "def Intersection (a : Array Int) (b : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem intersection_spec (a b : Array Int) (result : Array Int) :\n(result = Intersection a b) →\n(∀ x, x ∈ result.toList → (InArray a x ∧ InArray b x)) ∧\n(∀ i j, 0 ≤ i ∧ i < j ∧ j < result.size → result[i]! ≠ result[j]!) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_251_InsertBeforeEach", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_251_InsertBeforeEach\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_251_InsertBeforeEach\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nInsertBeforeEach takes a sequence of strings `s` and a string `x` and returns a new sequence\nwhere `x` is inserted before each element of `s`.\n\n@param s The input sequence of strings\n@param x The string to insert before each element\n@return A new sequence with x inserted before each element of s\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def InsertBeforeEach (s : Array String) (x : String) : Array String :=\nsorry", "vc-theorems": "theorem InsertBeforeEach_spec (s : Array String) (x : String) :\nlet v := InsertBeforeEach s x\nv.size = 2 * s.size ∧\n∀ i, 0 ≤ i ∧ i < s.size →\n(v[2*i]! = x ∧ v[2*i + 1]! = s[i]!) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_261_ElementWiseDivision", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_261_ElementWiseDivision\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_261_ElementWiseDivision\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nElementWiseDivision takes two arrays of integers and returns a new array\nwhere each element is the division of corresponding elements from input arrays.\n\n@param a First input array\n@param b Second input array\n@return result Array containing element-wise division\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def ElementWiseDivision (a b : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem ElementWiseDivision_spec (a b : Array Int) :\n(a.size = b.size) →\n(∀ i, 0 ≤ i ∧ i < b.size → b[i]! ≠ 0) →\nlet result := ElementWiseDivision a b\n(result.size = a.size) ∧\n(∀ i, 0 ≤ i ∧ i < result.size → result[i]! = a[i]! / b[i]!) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_262_SplitArray", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_262_SplitArray\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_262_SplitArray\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nSplits an array into two parts at index L.\nInput:\n- arr: The input array to split\n- L: The split point\nReturns:\n- A pair of arrays representing the first and second parts\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def SplitArray (arr : Array Int) (L : Int) : Array Int × Array Int :=\nsorry", "vc-theorems": "theorem SplitArray_spec (arr : Array Int) (L : Int) :\n(0 ≤ L ∧ L ≤ arr.size) →\nlet (firstPart, secondPart) := SplitArray arr L\nfirstPart.size = L ∧\nsecondPart.size = arr.size - L ∧\n(firstPart.append secondPart) = arr :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_273_SubtractSequences", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_273_SubtractSequences\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_273_SubtractSequences\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nSubtractSequences takes two arrays of integers and returns a new array where each element\nis the difference of the corresponding elements from the input arrays.\n\n@param a First input array\n@param b Second input array\n@return Array containing element-wise differences\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def SubtractSequences (a b : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem SubtractSequences_spec (a b : Array Int) :\na.size = b.size →\nlet result := SubtractSequences a b\nresult.size = a.size ∧\n∀ i, 0 ≤ i ∧ i < result.size → result[i]! = a[i]! - b[i]! :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_284_AllElementsEqual", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_284_AllElementsEqual\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_284_AllElementsEqual\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nChecks if all elements in an array are equal to a given value n.\n\n@param a The input array to check\n@param n The value to compare against\n@return True if all elements equal n, false otherwise\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def AllElementsEqual (a : Array Int) (n : Int) : Bool :=\nsorry", "vc-theorems": "theorem AllElementsEqual_spec (a : Array Int) (n : Int) :\n(AllElementsEqual a n = true → ∀ i, 0 ≤ i ∧ i < a.size → a[i]! = n) ∧\n(AllElementsEqual a n = false → ∃ i, 0 ≤ i ∧ i < a.size ∧ a[i]! ≠ n) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_290_MaxLengthList", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_290_MaxLengthList\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_290_MaxLengthList\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nFinds the list with maximum length from a sequence of integer lists.\n\n@param lists Array of integer arrays\n@return maxList The array with maximum length from the input lists\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def MaxLengthList (lists : Array (Array Int)) : Array Int :=\nsorry", "vc-theorems": "theorem MaxLengthList_spec (lists : Array (Array Int)) (maxList : Array Int) :\nlists.size > 0 →\n(∀ l, l ∈ lists → l.size ≤ maxList.size) ∧\nmaxList ∈ lists :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_2_SharedElements", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_2_SharedElements\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_2_SharedElements\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nPredicate indicating if an element exists in an array\n-/\n\n/- \nSharedElements takes two arrays and returns an array containing elements present in both input arrays.\nThe output array contains no duplicates.\n-/", "vc-preamble": "def InArray (a : Array Int) (x : Int) : Prop :=\n∃ i, 0 ≤ i ∧ i < a.size ∧ a[i]! = x", "vc-helpers": "", "vc-definitions": "def SharedElements (a : Array Int) (b : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem SharedElements_spec (a b : Array Int) (result : Array Int) :\n(result = SharedElements a b) →\n(∀ x, x ∈ result.toList → (InArray a x ∧ InArray b x)) ∧\n(∀ i j, 0 ≤ i ∧ i < j ∧ j < result.size → result[i]! ≠ result[j]!) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_304_ElementAtIndexAfterRotation", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_304_ElementAtIndexAfterRotation\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_304_ElementAtIndexAfterRotation\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nFinds the element at a given index after rotating an array by n positions.\n\n@param l The input array\n@param n The number of positions to rotate\n@param index The index to find the element at\n@return The element at the rotated position\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def ElementAtIndexAfterRotation (l : Array Int) (n : Nat) (index : Nat) : Int :=\nsorry", "vc-theorems": "theorem ElementAtIndexAfterRotation_spec\n(l : Array Int) (n : Nat) (index : Nat) :\nn ≥ 0 →\n0 ≤ index →\nindex < l.size →\nElementAtIndexAfterRotation l n index = l[((index - n + l.size) % l.size)]! :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_399_BitwiseXOR", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_399_BitwiseXOR\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_399_BitwiseXOR\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nBitwiseXOR takes two arrays of 32-bit bitvectors and returns their bitwise XOR.\nThe arrays must be of equal length.\n\n@param a First input array of 32-bit bitvectors\n@param b Second input array of 32-bit bitvectors\n@return Array containing bitwise XOR of corresponding elements\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def BitwiseXOR (a b : Array UInt32) : Array UInt32 :=\nsorry", "vc-theorems": "theorem BitwiseXOR_spec (a b : Array UInt32) :\na.size = b.size →\nlet result := BitwiseXOR a b\nresult.size = a.size ∧\n∀ i, 0 ≤ i ∧ i < result.size →\nresult[i]! = (a[i]!).xor (b[i]!) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_3_IsNonPrime", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_3_IsNonPrime\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_3_IsNonPrime\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nDetermines if a number is non-prime by checking if it has any factors between 2 and itself.\n\n@param n The number to check, must be ≥ 2\n@return True if the number is non-prime, false otherwise\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def IsNonPrime (n : Int) : Bool :=\nsorry", "vc-theorems": "theorem IsNonPrime_spec (n : Int) :\nn ≥ 2 →\nIsNonPrime n = true ↔ (∃ k : Int, 2 ≤ k ∧ k < n ∧ n % k = 0) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_401_IndexWiseAddition", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_401_IndexWiseAddition\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_401_IndexWiseAddition\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nAdds two 2D arrays element-wise.\nInput arrays must be non-empty and have matching dimensions.\nReturns a new array containing the element-wise sums.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def IndexWiseAddition (a b : Array (Array Int)) : Array (Array Int) :=\nsorry", "vc-theorems": "theorem IndexWiseAddition_spec (a b : Array (Array Int)) :\na.size > 0 ∧ b.size > 0 ∧\na.size = b.size ∧\n(∀ i, 0 ≤ i ∧ i < a.size → (a[i]!).size = (b[i]!).size) →\nlet result := IndexWiseAddition a b\nresult.size = a.size ∧\n(∀ i, 0 ≤ i ∧ i < result.size → (result[i]!).size = (a[i]!).size) ∧\n(∀ i, 0 ≤ i ∧ i < result.size →\n∀ j, 0 ≤ j ∧ j < (result[i]!).size →\n(result[i]!)[j]! = (a[i]!)[j]! + (b[i]!)[j]!) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_412_RemoveOddNumbers", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_412_RemoveOddNumbers\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_412_RemoveOddNumbers\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nPredicate indicating if a number is even\n-/\n\n/- \nRemoves odd numbers from an array of integers.\nReturns a new array containing only the even numbers from the input array.\n\n@param arr The input array of integers\n@return An array containing only the even numbers from the input\n-/", "vc-preamble": "def IsEven (n : Int) : Prop :=\nn % 2 = 0", "vc-helpers": "", "vc-definitions": "def RemoveOddNumbers (arr : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem RemoveOddNumbers_spec (arr : Array Int) :\nlet result := RemoveOddNumbers arr\n(∀ i, 0 ≤ i ∧ i < result.size → IsEven (result[i]!) ∧ (∃ j, 0 ≤ j ∧ j < arr.size ∧ result[i]! = arr[j]!)) ∧\n(∀ i, 0 ≤ i ∧ i < arr.size ∧ IsEven (arr[i]!) → (∃ j, 0 ≤ j ∧ j < result.size ∧ arr[i]! = result[j]!)) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_414_AnyValueExists", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_414_AnyValueExists\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_414_AnyValueExists\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nChecks if any value from seq1 exists in seq2.\nTranslated from Dafny method AnyValueExists.\n\n@param seq1 First sequence to check\n@param seq2 Second sequence to check against\n@return True if any value from seq1 exists in seq2\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def AnyValueExists (seq1 : Array Int) (seq2 : Array Int) : Bool :=\nsorry", "vc-theorems": "theorem AnyValueExists_spec (seq1 seq2 : Array Int) :\nAnyValueExists seq1 seq2 ↔ (∃ i, 0 ≤ i ∧ i < seq1.size ∧ seq2.contains (seq1[i]!)) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_424_ExtractRearChars", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_424_ExtractRearChars\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_424_ExtractRearChars\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nExtracts the last character from each string in an array of strings.\n\n@param l Array of non-empty strings\n@return Array of characters containing the last character from each input string\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def ExtractRearChars (l : Array String) : Array Char :=\nsorry", "vc-theorems": "theorem ExtractRearChars_spec (l : Array String) :\n(∀ i:Nat , 0 ≤ i ∧ i < l.size → (l[i]! |>.length) > 0) →\nlet r := ExtractRearChars l\n(r.size = l.size) ∧\n(∀ i:Nat , 0 ≤ i ∧ i < l.size →\nr[i]! = (l[i]! |>.get ⟨((l[i]! |>.length) - 1)⟩)) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_426_FilterOddNumbers", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_426_FilterOddNumbers\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_426_FilterOddNumbers\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate indicating if a number is odd -/\n\n/- \nFilter odd numbers from an array of numbers.\nReturns a new array containing only the odd numbers from the input array.\n-/", "vc-preamble": "def IsOdd (n : Int) : Bool :=\nn % 2 ≠ 0", "vc-helpers": "", "vc-definitions": "def FilterOddNumbers (arr : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem FilterOddNumbers_spec (arr : Array Int) :\nlet result := FilterOddNumbers arr\n(∀ i, 0 ≤ i ∧ i < result.size → IsOdd (result[i]!) ∧ (result[i]!) ∈ arr.toList) ∧\n(∀ i, 0 ≤ i ∧ i < arr.size ∧ IsOdd (arr[i]!) → (arr[i]!) ∈ result.toList) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_430_ParabolaDirectrix", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_430_ParabolaDirectrix\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_430_ParabolaDirectrix\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nCalculates the directrix of a parabola given its parameters a, h, and k.\nInput:\n- a: Real number coefficient (must not be 0)\n- h: Real number representing x-coordinate of vertex\n- k: Real number representing y-coordinate of vertex\nOutput:\n- directrix: Real number representing the directrix value\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def ParabolaDirectrix (a : Float) (h : Float) (k : Float) : Float :=\nsorry", "vc-theorems": "theorem ParabolaDirectrix_spec (a h k : Float) :\na ≠ 0 →\nParabolaDirectrix a h k = k - 1/(4*a) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_431_HasCommonElement", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_431_HasCommonElement\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_431_HasCommonElement\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nChecks if two arrays have any common elements.\nTranslated from Dafny method HasCommonElement.\n\n@param a First array to check\n@param b Second array to check\n@return True if arrays have a common element, false otherwise\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def HasCommonElement (a b : Array Int) : Bool :=\nsorry", "vc-theorems": "theorem HasCommonElement_spec (a b : Array Int) :\n(HasCommonElement a b = true →\n∃ i j, 0 ≤ i ∧ i < a.size ∧ 0 ≤ j ∧ j < b.size ∧ a[i]! = b[j]!) ∧\n(HasCommonElement a b = false →\n∀ i j, 0 ≤ i ∧ i < a.size ∧ 0 ≤ j ∧ j < b.size → a[i]! ≠ b[j]!) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_432_MedianLength", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_432_MedianLength\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_432_MedianLength\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nComputes the median length of two positive integers.\n\n@param a First positive integer\n@param b Second positive integer\n@return The median length (a + b) / 2\n\nTranslated from Dafny method MedianLength which requires:\n- a > 0 and b > 0\n- Returns median = (a + b) / 2\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def MedianLength (a b : Int) : Int :=\nsorry", "vc-theorems": "theorem MedianLength_spec (a b : Int) :\na > 0 ∧ b > 0 →\nMedianLength a b = (a + b) / 2 :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_433_IsGreater", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_433_IsGreater\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_433_IsGreater\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nChecks if a number is greater than all elements in an array.\n\n@param n The number to compare\n@param a The array to check against\n@return True if n is greater than all elements in a, false otherwise\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def IsGreater (n : Int) (a : Array Int) : Bool :=\nsorry", "vc-theorems": "theorem IsGreater_spec (n : Int) (a : Array Int) :\n(IsGreater n a = true → ∀ i, 0 ≤ i ∧ i < a.size → n > a[i]!) ∧\n(IsGreater n a = false → ∃ i, 0 ≤ i ∧ i < a.size ∧ n ≤ a[i]!) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_435_LastDigit", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_435_LastDigit\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_435_LastDigit\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nLastDigit takes a non-negative integer n and returns its last digit d.\nThe last digit must be between 0 and 9 inclusive and equal to n mod 10.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def LastDigit (n : Int) : Int :=\nsorry", "vc-theorems": "theorem LastDigit_spec (n : Int) :\nn ≥ 0 →\nlet d := LastDigit n\n0 ≤ d ∧ d < 10 ∧ n % 10 = d :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_436_FindNegativeNumbers", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_436_FindNegativeNumbers\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_436_FindNegativeNumbers\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nPredicate indicating if a number is negative\n-/\n\n/- \nFind negative numbers from an array of numbers.\nReturns a sequence containing all negative numbers from the input array.\n\n@param arr Input array of integers\n@return Array of negative integers from the input\n-/", "vc-preamble": "def IsNegative (n : Int) : Bool :=\nn < 0", "vc-helpers": "", "vc-definitions": "def FindNegativeNumbers (arr : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem FindNegativeNumbers_spec (arr : Array Int) :\nlet result := FindNegativeNumbers arr\n(∀ i, 0 ≤ i ∧ i < result.size → IsNegative (result[i]!) ∧ (∃ j, 0 ≤ j ∧ j < arr.size ∧ result[i]! = arr[j]!)) ∧\n(∀ i, 0 ≤ i ∧ i < arr.size ∧ IsNegative (arr[i]!) → (∃ j, 0 ≤ j ∧ j < result.size ∧ arr[i]! = result[j]!)) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_441_CubeSurfaceArea", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_441_CubeSurfaceArea\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_441_CubeSurfaceArea\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nCalculates the surface area of a cube given its size.\n\n@param size The length of a side of the cube\n@return The total surface area of the cube\n\nTranslated from Dafny method:\ndafny\nmethod CubeSurfaceArea(size: int) returns (area: int)\nrequires size > 0\nensures area == 6 * size * size\n\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def CubeSurfaceArea (size : Int) : Int :=\nsorry", "vc-theorems": "theorem CubeSurfaceArea_spec (size : Int) :\nsize > 0 → CubeSurfaceArea size = 6 * size * size :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_452_CalculateLoss", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_452_CalculateLoss\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_452_CalculateLoss\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nCalculates the loss amount given cost price and selling price.\nIf cost price is greater than selling price, returns the difference.\nOtherwise returns 0.\n\n@param costPrice The cost price (must be non-negative)\n@param sellingPrice The selling price (must be non-negative)\n@return The calculated loss amount\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def CalculateLoss (costPrice : Int) (sellingPrice : Int) : Int :=\nsorry", "vc-theorems": "theorem CalculateLoss_spec (costPrice : Int) (sellingPrice : Int) :\ncostPrice ≥ 0 ∧ sellingPrice ≥ 0 →\n((costPrice > sellingPrice → CalculateLoss costPrice sellingPrice = costPrice - sellingPrice) ∧\n(costPrice ≤ sellingPrice → CalculateLoss costPrice sellingPrice = 0)) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_455_MonthHas31Days", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_455_MonthHas31Days\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_455_MonthHas31Days\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nDetermines if a given month has 31 days.\n\n@param month The month number (1-12)\n@return True if the month has 31 days, false otherwise\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def MonthHas31Days (month : Int) : Bool :=\nsorry", "vc-theorems": "theorem MonthHas31Days_spec (month : Int) :\n1 ≤ month ∧ month ≤ 12 →\nMonthHas31Days month = true ↔\n(month = 1 ∨ month = 3 ∨ month = 5 ∨ month = 7 ∨\nmonth = 8 ∨ month = 10 ∨ month = 12) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_457_MinLengthSublist", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_457_MinLengthSublist\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_457_MinLengthSublist\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nFinds the shortest sublist in a sequence of integer sequences.\n\n@param s The input sequence of integer sequences\n@return The shortest sublist from the input sequence\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def MinLengthSublist (s : Array (Array Int)) : Array Int :=\nsorry", "vc-theorems": "theorem MinLengthSublist_spec (s : Array (Array Int)) :\ns.size > 0 →\n(∃ i, i < s.size ∧ MinLengthSublist s = s[i]!) ∧\n(∀ sublist, (∃ i, i < s.size ∧ sublist = s[i]!) →\n(MinLengthSublist s).size ≤ sublist.size) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_460_GetFirstElements", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_460_GetFirstElements\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_460_GetFirstElements\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nGetFirstElements takes a sequence of sequences of integers and returns a sequence containing\nthe first element of each inner sequence.\n\n@param lst The input sequence of sequences of integers\n@return A sequence containing the first element of each inner sequence\n\nRequirements:\n- Each inner sequence must be non-empty\n\nEnsures:\n- The output sequence has the same length as the input sequence\n- Each element in the output is the first element of the corresponding inner sequence\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def GetFirstElements (lst : Array (Array Int)) : Array Int :=\nsorry", "vc-theorems": "theorem GetFirstElements_spec (lst : Array (Array Int)) :\n(∀ i, 0 ≤ i ∧ i < lst.size → (lst[i]!).size > 0) →\nlet result := GetFirstElements lst\nresult.size = lst.size ∧\n(∀ i, 0 ≤ i ∧ i < result.size → result[i]! = (lst[i]!)[0]!) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_461_CountUppercase", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_461_CountUppercase\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_461_CountUppercase\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nPredicate that checks if a character is uppercase (ASCII value between 65 and 90)\n-/\n\n/- \nCounts the number of uppercase characters in a string.\nReturns a non-negative count equal to the size of the set of uppercase characters.\n-/", "vc-preamble": "def IsUpperCase (c : Char) : Bool :=\n65 ≤ c.toNat ∧ c.toNat ≤ 90", "vc-helpers": "", "vc-definitions": "def CountUppercase (s : String) : Int :=\nsorry", "vc-theorems": "theorem CountUppercase_spec (s : String) :\nlet count := CountUppercase s\ncount ≥ 0 ∧\ncount = (s.toList.filterMap (fun c => if IsUpperCase c then some c else none)).length\n:=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_470_PairwiseAddition", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_470_PairwiseAddition\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_470_PairwiseAddition\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nPerforms pairwise addition on an array, combining adjacent elements.\nInput array must have even length.\nReturns new array with half the length containing sums of adjacent pairs.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def PairwiseAddition (a : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem PairwiseAddition_spec (a : Array Int) :\na.size % 2 = 0 →\nlet result := PairwiseAddition a\nresult.size = a.size / 2 ∧\n∀ i, 0 ≤ i ∧ i < result.size →\nresult[i]! = a[2*i]! + a[2*i + 1]! :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_472_ContainsConsecutiveNumbers", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_472_ContainsConsecutiveNumbers\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_472_ContainsConsecutiveNumbers\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nChecks if an array contains consecutive numbers.\nTranslated from Dafny method ContainsConsecutiveNumbers.\n\n@param a The input array to check\n@return True if array contains consecutive numbers, false otherwise\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def ContainsConsecutiveNumbers (a : Array Int) : Bool :=\nsorry", "vc-theorems": "theorem ContainsConsecutiveNumbers_spec (a : Array Int) :\na.size > 0 →\nContainsConsecutiveNumbers a = true ↔\n(∃ i, 0 ≤ i ∧ i < a.size - 1 ∧ a[i]! + 1 = a[i + 1]!) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_474_ReplaceChars", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_474_ReplaceChars\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_474_ReplaceChars\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nReplaces all occurrences of oldChar with newChar in string s.\nReturns a new string with the replacements.\n\n@param s The input string\n@param oldChar The character to replace\n@param newChar The replacement character\n@return The string with characters replaced\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def ReplaceChars (s : String) (oldChar : Char) (newChar : Char) : String :=\nsorry", "vc-theorems": "theorem ReplaceChars_spec (s : String) (oldChar newChar : Char) :\nlet v := ReplaceChars s oldChar newChar\nv.length = s.length ∧\n∀ i, 0 ≤ i ∧ i < s.length →\n((s.get ⟨i⟩ = oldChar → v.get ⟨i⟩ = newChar) ∧\n(s.get ⟨i⟩ ≠ oldChar → v.get ⟨i⟩ = s.get ⟨i⟩)) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_476_SumMinMax", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_476_SumMinMax\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_476_SumMinMax\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Finds the minimum value in an array recursively -/\n\n/-  Specification for Min function -/\n\n/-  Finds the maximum value in an array recursively -/\n\n/-  Specification for Max function -/\n\n/-  Returns the sum of minimum and maximum values in the array -/\n\n/-  Specification for SumMinMax method -/", "vc-preamble": "partial def Min_ (a : Array Int) : Int :=\nif a.size = 1 then\na[0]!\nelse\nlet minPrefix := Min_ (a.extract 0 (a.size - 1))\nif a[a.size - 1]! ≤ minPrefix then\na[a.size - 1]!\nelse\nMin_ (a.extract 0 (a.size - 1))\n\npartial def Max_ (a : Array Int) : Int :=\nif a.size = 1 then\na[0]!\nelse\nlet maxPrefix := Max_ (a.extract 0 (a.size - 1))\nif a[a.size - 1]! ≥ maxPrefix then\na[a.size - 1]!\nelse\nMax_ (a.extract 0 (a.size - 1))\n\ndef SumMinMax (a : Array Int) : Int :=\nMax_ a + Min_ a", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "theorem Min_spec (a : Array Int) :\na.size > 0 → Min_ a = Min_ a :=\nsorry\n\ntheorem Max_spec (a : Array Int) :\na.size > 0 → Max_ a = Max_ a :=\nsorry\n\ntheorem SumMinMax_spec (a : Array Int) :\na.size > 0 → SumMinMax a = Max_ a + Min_ a :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_477_ToLowercase", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_477_ToLowercase\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_477_ToLowercase\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate indicating if a character is uppercase (ASCII 65-90) -/\n\n/-  Predicate indicating if two characters form an uppercase/lowercase pair -/\n\n/-  Function to shift a character by 32 positions (for case conversion) -/\n\n/-  Main function to convert a string to lowercase -/", "vc-preamble": "def IsUpperCase (c : Char) : Bool :=\n65 ≤ c.toNat ∧ c.toNat ≤ 90\ndef IsUpperLowerPair (C : Char) (c : Char) : Bool :=\nC.toNat = c.toNat - 32\ndef Shift32 (c : Char) : Char :=\nChar.ofNat ((c.toNat + 32) % 128)", "vc-helpers": "", "vc-definitions": "def ToLowercase (s : String) : String :=\nsorry", "vc-theorems": "theorem ToLowercase_spec (s : String) :\nlet v := ToLowercase s\nv.length = s.length ∧\n∀ i, 0 ≤ i ∧ i < s.length →\n(if IsUpperCase (s.get ⟨i⟩)\nthen IsUpperLowerPair (s.get ⟨i⟩) (v.get ⟨i⟩)\nelse v.get ⟨i⟩ = s.get ⟨i⟩) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_554_FindOddNumbers", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_554_FindOddNumbers\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_554_FindOddNumbers\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nPredicate that checks if a number is odd\n-/\n\n/- \nFunction that finds odd numbers in an array.\nReturns an array containing all odd numbers from the input array.\n\n@param arr Input array of integers\n@return Array of odd integers from input\n-/", "vc-preamble": "def IsOdd (n : Int) : Bool :=\nn % 2 = 1", "vc-helpers": "", "vc-definitions": "def FindOddNumbers (arr : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem FindOddNumbers_spec (arr : Array Int) :\nlet result := FindOddNumbers arr\n(∀ i, 0 ≤ i ∧ i < result.size → IsOdd (result[i]!) ∧ (∃ j, 0 ≤ j ∧ j < arr.size ∧ result[i]! = arr[j]!)) ∧\n(∀ i, 0 ≤ i ∧ i < arr.size ∧ IsOdd (arr[i]!) → (∃ j, 0 ≤ j ∧ j < result.size ∧ arr[i]! = result[j]!)) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_555_DifferenceSumCubesAndSumNumbers", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_555_DifferenceSumCubesAndSumNumbers\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_555_DifferenceSumCubesAndSumNumbers\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nComputes the difference between the sum of cubes and sum of numbers up to n.\nInput: A non-negative integer n\nOutput: The difference between sum of cubes and sum of numbers\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def DifferenceSumCubesAndSumNumbers (n : Int) : Int :=\nsorry", "vc-theorems": "theorem DifferenceSumCubesAndSumNumbers_spec (n : Int) :\nn ≥ 0 →\nDifferenceSumCubesAndSumNumbers n = (n * n * (n + 1) * (n + 1)) / 4 - (n * (n + 1)) / 2 :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_557_ToggleCase", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_557_ToggleCase\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_557_ToggleCase\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate checking if a character is lowercase -/\n\n/-  Predicate checking if a character is uppercase -/\n\n/-  Predicate checking if two characters form a lowercase-uppercase pair -/\n\n/-  Predicate checking if two characters form an uppercase-lowercase pair -/\n\n/-  Function that shifts a character's ASCII value down by 32 -/\n\n/-  Function that shifts a character's ASCII value up by 32 -/\n\n/-  Main method that toggles case of characters in a string -/", "vc-preamble": "def IsLowerCase (c : Char) : Bool :=\n97 ≤ c.toNat ∧ c.toNat ≤ 122\ndef IsUpperCase (c : Char) : Bool :=\n65 ≤ c.toNat ∧ c.toNat ≤ 90\ndef IsLowerUpperPair (c : Char) (C : Char) : Bool :=\nc.toNat = C.toNat + 32\ndef IsUpperLowerPair (C : Char) (c : Char) : Bool :=\nC.toNat = c.toNat - 32\ndef ShiftMinus32 (c : Char) : Char :=\nChar.ofNat ((c.toNat - 32) % 128)\ndef Shift32 (c : Char) : Char :=\nChar.ofNat ((c.toNat + 32) % 128)", "vc-helpers": "", "vc-definitions": "def ToggleCase (s : String) : String :=\nsorry", "vc-theorems": "theorem ToggleCase_spec (s : String) (v : String) :\nv = ToggleCase s →\nv.length = s.length ∧\n(∀ i, 0 ≤ i ∧ i < s.length →\n(if IsLowerCase (s.get ⟨i⟩) then\nIsLowerUpperPair (s.get ⟨i⟩) (v.get ⟨i⟩)\nelse if IsUpperCase (s.get ⟨i⟩) then\nIsUpperLowerPair (s.get ⟨i⟩) (v.get ⟨i⟩)\nelse v.get ⟨i⟩ = s.get ⟨i⟩)) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_565_SplitStringIntoChars", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_565_SplitStringIntoChars\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_565_SplitStringIntoChars\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nSplits a string into an array of its characters.\n\n@param s The input string to split\n@return An array containing the characters of the input string\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def SplitStringIntoChars (s : String) : Array Char :=\nsorry", "vc-theorems": "theorem SplitStringIntoChars_spec (s : String) :\nlet v := SplitStringIntoChars s\nv.size = s.length ∧\n∀ i, 0 ≤ i ∧ i < s.length → v[i]! = s.get ⟨i⟩ :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_566_SumOfDigits", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_566_SumOfDigits\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_566_SumOfDigits\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Recursive function that returns sequence of intermediate values when dividing by 10 -/\n\n/-  Computes powers of 10 -/\n\n/-  Converts a number to sequence of its digits -/\n\n/-  Sums elements in a sequence -/\n\n/-  Counts number of digits in a natural number -/\n\n/-  Recursively sums digits using powers of 10 -/\n\n/-  Main function to sum digits of a number -/\n\n/-  Main method specification -/", "vc-preamble": "partial def IntValues (n : Int) : Array Int :=\nif n = 0 then #[]\nelse #[n] ++ IntValues (n/10)\n\ndef Power10 (n : Nat) : Nat :=\nif n = 0 then 1 else 10 * Power10 (n-1)\n\npartial def NumberToSeq (number : Int) : Array Int :=\nif number = 0 then #[]\nelse #[number % 10] ++ NumberToSeq (number/10)\n\npartial def Sum_ (digits : Array Int) : Int :=\nif digits.size = 0 then 0\nelse digits[0]! + Sum_ (digits.extract 1 digits.size)\n\ndef NumberOfDigits (n : Nat) : Nat :=\nif n ≤ 9 then 1 else 1 + NumberOfDigits (n/10)\n\ndef SumDigitsRecursive (n : Nat) (p : Nat) : Nat :=\nif n = 0 ∨ p = 0 then 0\nelse\nlet leftMostDigit := n/p\nlet rest := n%p\nleftMostDigit + SumDigitsRecursive rest (p/10)\n\ndef SumDigits (n : Nat) : Nat :=\nlet ndigits := NumberOfDigits n\nlet p := Power10 (ndigits-1)\nSumDigitsRecursive n p", "vc-helpers": "", "vc-definitions": "def SumOfDigits (number : Nat) : Nat :=\nsorry", "vc-theorems": "theorem IntValues_spec (n : Int) :\nn ≥ 0 →\n(0 ∈ IntValues n) ∧\n(n ∈ IntValues n) ∧\n(n/10 ∈ IntValues n) :=\nsorry\n\ntheorem Power10_spec (n : Nat) :\nPower10 n ≥ 1 ∧\n(n > 0 → Power10 n % 10 = 0) :=\nsorry\n\ntheorem NumberOfDigits_spec (n : Nat) :\nNumberOfDigits n ≥ 1 ∧\n(NumberOfDigits n = 1 ↔ 0 ≤ n ∧ n ≤ 9) :=\nsorry\n\ntheorem SumOfDigits_spec (number : Nat) :\nnumber ≥ 0 →\nSumOfDigits number ≥ 0 ∧\nSumOfDigits number = SumDigits number :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_567_IsSorted", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_567_IsSorted\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_567_IsSorted\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nChecks if an array is sorted in non-decreasing order.\n\n@param a The array to check\n@return sorted True if the array is sorted, false otherwise\n\nRequires:\n- Array must be non-empty\n\nEnsures:\n- sorted is true iff for all valid indices i,j where i < j, a ≤ a\n- If not sorted, there exist indices i,j where i < j and a > a\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def IsSorted (a : Array Int) : Bool :=\nsorry", "vc-theorems": "theorem IsSorted_spec (a : Array Int) :\na.size > 0 →\n(IsSorted a ↔ (∀ i j, 0 ≤ i ∧ i < j ∧ j < a.size → a[i]! ≤ a[j]!)) ∧\n(¬IsSorted a → ∃ i j, 0 ≤ i ∧ i < j ∧ j < a.size ∧ a[i]! > a[j]!) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_572_RemoveDuplicates", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_572_RemoveDuplicates\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_572_RemoveDuplicates\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nRemoveDuplicates takes an array of integers and returns a sequence with duplicates removed.\nThe output sequence contains exactly the elements that appear in the input array,\nand no element appears more than once in the output.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def RemoveDuplicates (a : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem RemoveDuplicates_spec (a : Array Int) :\nlet result := RemoveDuplicates a\n(∀ x, (result.contains x ↔ ∃ i, 0 ≤ i ∧ i < a.size ∧ a[i]! = x)) ∧\n(∀ i j, 0 ≤ i ∧ i < j ∧ j < result.size → result[i]! ≠ result[j]!) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_573_UniqueProduct", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_573_UniqueProduct\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_573_UniqueProduct\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nComputes the product of all elements in a list.\nIf the list is empty, returns 1.\n-/\n\n/- \nTakes an array of integers and returns their product.\nEnsures the result equals the product of the set of array elements.\n-/", "vc-preamble": "def SetProduct (s : List Int) : Int :=\nmatch s with\n| [] => 1\n| x::xs => x * SetProduct xs", "vc-helpers": "", "vc-definitions": "def UniqueProduct (arr : Array Int) : Int :=\nsorry", "vc-theorems": "theorem UniqueProduct_spec (arr : Array Int) :\nUniqueProduct arr = SetProduct (arr.toList) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_574_CylinderSurfaceArea", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_574_CylinderSurfaceArea\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_574_CylinderSurfaceArea\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nCalculates the surface area of a cylinder given radius and height.\nRequires positive radius and height.\nReturns the surface area using the formula: 2πr(r + h)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def CylinderSurfaceArea (radius : Float) (height : Float) : Float :=\nsorry", "vc-theorems": "theorem CylinderSurfaceArea_spec (radius height : Float) :\nradius > 0 ∧ height > 0 →\nCylinderSurfaceArea radius height = 2 * 3.14159265358979323846 * radius * (radius + height) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_576_IsSublist", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_576_IsSublist\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_576_IsSublist\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nChecks if one array is a sublist of another array.\nTranslated from Dafny method IsSublist.\n\n@param sub The potential sublist to check\n@param main The main list to search in\n@return True if sub is a sublist of main\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def IsSublist (sub : Array Int) (main : Array Int) : Bool :=\nsorry", "vc-theorems": "theorem IsSublist_spec (sub main : Array Int) :\n∃ i, 0 ≤ i ∧ i ≤ main.size - sub.size ∧\n(∀ j, 0 ≤ j ∧ j < sub.size → sub[j]! = main[i + j]!) →\nIsSublist sub main = true :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_577_FactorialOfLastDigit", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_577_FactorialOfLastDigit\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_577_FactorialOfLastDigit\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nComputes the factorial of a non-negative integer.\nTranslated from Dafny's Factorial function.\n-/\n\n/- \nSpecification for Factorial function ensuring non-negativity of result\n-/\n\n/- \nComputes the factorial of the last digit of a number.\nTranslated from Dafny's FactorialOfLastDigit method.\n-/\n\n/- \nSpecification for FactorialOfLastDigit ensuring it returns\nthe factorial of the input's last digit\n-/", "vc-preamble": "partial def Factorial (n : Int) : Int :=\nif n == 0 then 1\nelse n * Factorial (n-1)", "vc-helpers": "", "vc-definitions": "def FactorialOfLastDigit (n : Int) : Int :=\nsorry", "vc-theorems": "theorem Factorial_spec (n : Int) :\nn ≥ 0 → Factorial n ≥ 0 :=\nsorry\n\ntheorem FactorialOfLastDigit_spec (n : Int) :\nn ≥ 0 → FactorialOfLastDigit n = Factorial (n % 10) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_578_Interleave", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_578_Interleave\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_578_Interleave\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nInterleaves three sequences of equal length into a single sequence.\nThe resulting sequence contains elements from the input sequences in alternating order.\n\n@param s1 First input sequence\n@param s2 Second input sequence\n@param s3 Third input sequence\n@return Interleaved sequence containing elements from s1, s2, s3 in alternating order\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Interleave (s1 s2 s3 : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem Interleave_spec (s1 s2 s3 : Array Int) :\ns1.size = s2.size ∧ s2.size = s3.size →\nlet r := Interleave s1 s2 s3\nr.size = 3 * s1.size ∧\n(∀ i, 0 ≤ i ∧ i < s1.size →\nr[3*i]! = s1[i]! ∧\nr[3*i + 1]! = s2[i]! ∧\nr[3*i + 2]! = s3[i]!) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_579_DissimilarElements", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_579_DissimilarElements\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_579_DissimilarElements\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate indicating if an element exists in an array -/\n\n/- \nDissimilarElements takes two arrays and returns an array containing elements that\nappear in exactly one of the input arrays but not both.\n-/", "vc-preamble": "def InArray (a : Array Int) (x : Int) : Prop :=\n∃ i, 0 ≤ i ∧ i < a.size ∧ a[i]! = x", "vc-helpers": "", "vc-definitions": "def DissimilarElements (a b : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem DissimilarElements_spec (a b : Array Int) (result : Array Int) :\n\n-- All elements in result are in exactly one of a or b (XOR)\n\n(∀ x, x ∈ result.toList → (InArray a x ≠ InArray b x)) ∧\n\n-- All elements in result are unique\n\n(∀ i j, 0 ≤ i → i < j → j < result.size → result[i]! ≠ result[j]!) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_581_SquarePyramidSurfaceArea", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_581_SquarePyramidSurfaceArea\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_581_SquarePyramidSurfaceArea\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nCalculates the surface area of a square pyramid given its base edge and height.\n\n@param baseEdge The length of the base edge\n@param height The height of the pyramid\n@return The surface area of the square pyramid\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def SquarePyramidSurfaceArea (baseEdge : Int) (height : Int) : Int :=\nsorry", "vc-theorems": "theorem SquarePyramidSurfaceArea_spec (baseEdge height : Int) :\nbaseEdge > 0 →\nheight > 0 →\nSquarePyramidSurfaceArea baseEdge height = baseEdge * baseEdge + 2 * baseEdge * height :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_586_SplitAndAppend", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_586_SplitAndAppend\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_586_SplitAndAppend\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nSplits an array at index n and appends the parts in reverse order.\nInput array l is split at index n, and the parts are appended with the second part first.\n\n@param l The input array to split and append\n@param n The index at which to split the array\n@return The resulting array after splitting and appending\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def SplitAndAppend (l : Array Int) (n : Int) : Array Int :=\nsorry", "vc-theorems": "theorem SplitAndAppend_spec (l : Array Int) (n : Int) :\nn ≥ 0 ∧ n < l.size →\nlet r := SplitAndAppend l n\nr.size = l.size ∧\n∀ i, 0 ≤ i ∧ i < l.size → r[i]! = l[(((i + n) % l.size).toNat)]! :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_587_ArrayToSeq", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_587_ArrayToSeq\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_587_ArrayToSeq\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nConverts an array of integers to a sequence (array in Lean).\nPreserves length and elements.\n\n@param a Input array of integers\n@return Array containing same elements as input array\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def ArrayToSeq (a : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem ArrayToSeq_spec (a : Array Int) :\nlet s := ArrayToSeq a\ns.size = a.size ∧\n∀ i, 0 ≤ i ∧ i < a.size → s[i]! = a[i]! :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_588_DifferenceMinMax", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_588_DifferenceMinMax\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_588_DifferenceMinMax\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Finds the minimum value in an array recursively -/\n\n/-  Finds the maximum value in an array recursively -/\n\n/-  Computes the difference between maximum and minimum values in an array -/\n\n/-  Specification for DifferenceMinMax -/", "vc-preamble": "partial def Min_ (a : Array Int) : Int :=\nif a.size = 1 then\na[0]!\nelse\nlet minPrefix := Min_ (a.extract 0 (a.size - 1))\nif a[a.size - 1]! ≤ minPrefix then\na[a.size - 1]!\nelse\nMin_ (a.extract 0 (a.size - 1))\n\npartial def Max_ (a : Array Int) : Int :=\nif a.size = 1 then\na[0]!\nelse\nlet maxPrefix := Max_ (a.extract 0 (a.size - 1))\nif a[a.size - 1]! ≥ maxPrefix then\na[a.size - 1]!\nelse\nMax_ (a.extract 0 (a.size - 1))\n\ndef DifferenceMinMax (a : Array Int) : Int :=\nMax_ a - Min_ a", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "theorem DifferenceMinMax_spec (a : Array Int) :\na.size > 0 →\nDifferenceMinMax a = Max_ a - Min_ a :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_591_SwapFirstAndLast", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_591_SwapFirstAndLast\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_591_SwapFirstAndLast\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nSwapFirstAndLast swaps the first and last elements of an array.\n\n@param a The input array to modify\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def SwapFirstAndLast (a : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem SwapFirstAndLast_spec (a : Array Int) :\na.size > 0 →\nlet result := SwapFirstAndLast a\nresult.size = a.size ∧\nresult[0]! = a[a.size - 1]! ∧\nresult[result.size - 1]! = a[0]! ∧\n(∀ k, 1 ≤ k ∧ k < a.size - 1 → result[k]! = a[k]!) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_594_FirstEvenOddDifference", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_594_FirstEvenOddDifference\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_594_FirstEvenOddDifference\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate indicating if a number is even -/\n\n/-  Predicate indicating if a number is odd -/\n\n/- \nFinds the difference between the first even and first odd number in an array.\nRequires:\n- Array has at least 2 elements\n- Array contains at least one even number\n- Array contains at least one odd number\nEnsures:\n- Returns difference between first even and first odd number found\n-/", "vc-preamble": "def IsEven (n : Int) : Bool :=\nn % 2 = 0\ndef IsOdd (n : Int) : Bool :=\nn % 2 ≠ 0", "vc-helpers": "", "vc-definitions": "def FirstEvenOddDifference (a : Array Int) : Int :=\nsorry", "vc-theorems": "theorem FirstEvenOddDifference_spec (a : Array Int) :\na.size ≥ 2 →\n(∃ i, 0 ≤ i ∧ i < a.size ∧ IsEven (a[i]!)) →\n(∃ i, 0 ≤ i ∧ i < a.size ∧ IsOdd (a[i]!)) →\n∃ i j, 0 ≤ i ∧ i < a.size ∧ 0 ≤ j ∧ j < a.size ∧\nIsEven (a[i]!) ∧ IsOdd (a[j]!) ∧\nFirstEvenOddDifference a = a[i]! - a[j]! ∧\n(∀ k, 0 ≤ k ∧ k < i → IsOdd (a[k]!)) ∧\n(∀ k, 0 ≤ k ∧ k < j → IsEven (a[k]!)) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_598_IsArmstrong", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_598_IsArmstrong\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_598_IsArmstrong\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nChecks if a number is an Armstrong number.\nAn Armstrong number is a number that equals the sum of its digits each raised to the power of 3.\nInput must be between 100 and 999 inclusive.\n\n@param n The number to check\n@return True if n is an Armstrong number, false otherwise\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def IsArmstrong (n : Int) : Bool :=\nsorry", "vc-theorems": "theorem IsArmstrong_spec (n : Int) :\n100 ≤ n ∧ n < 1000 →\nIsArmstrong n = (n = ((n / 100) * (n / 100) * (n / 100) +\n((n / 10) % 10) * ((n / 10) % 10) * ((n / 10) % 10) +\n(n % 10) * (n % 10) * (n % 10))) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_599_SumAndAverage", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_599_SumAndAverage\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_599_SumAndAverage\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nComputes the sum of numbers from 1 to n and their average.\nTranslated from Dafny method SumAndAverage.\n\n@param n The upper bound (must be positive)\n@return A pair (sum, average) where:\n- sum is the sum of numbers from 1 to n\n- average is sum divided by n\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def SumAndAverage (n : Int) : Int × Float :=\nsorry", "vc-theorems": "theorem SumAndAverage_spec (n : Int) :\nn > 0 →\nlet (sum, average) := SumAndAverage n\nsum = n * (n + 1) / 2 ∧\naverage = Float.ofInt sum / Float.ofInt n  :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_600_IsEven", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_600_IsEven\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_600_IsEven\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nDetermines if a number is even.\nTranslated from Dafny method IsEven.\n\n@param n The input integer to check\n@return True if n is even, false otherwise\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def IsEven (n : Int) : Bool :=\nsorry", "vc-theorems": "theorem IsEven_spec (n : Int) :\nIsEven n = (n % 2 = 0) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_602_FindFirstRepeatedChar", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_602_FindFirstRepeatedChar\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_602_FindFirstRepeatedChar\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nFinds the first repeated character in a string.\nReturns:\n- found: Whether a repeated character was found\n- c: The first repeated character if found\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def FindFirstRepeatedChar (s : String) : Bool × Char :=\nsorry", "vc-theorems": "theorem FindFirstRepeatedChar_spec (s : String) :\nlet (found, c) := FindFirstRepeatedChar s\n(found → ∃ i j, 0 ≤ i ∧ i < j ∧ j < s.length ∧\ns.get ⟨i⟩ = s.get ⟨j⟩ ∧ s.get ⟨i⟩ = c ∧\n(∀ k l, 0 ≤ k ∧ k < l ∧ l < j ∧ s.get ⟨k⟩ = s.get ⟨l⟩ → k ≥ i)) ∧\n(!found → ∀ i j, 0 ≤ i ∧ i < j ∧ j < s.length → s.get ⟨i⟩ ≠ s.get ⟨j⟩) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_603_LucidNumbers", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_603_LucidNumbers\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_603_LucidNumbers\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nTranslates the Dafny LucidNumbers method which returns a sequence of numbers that are:\n- Divisible by 3\n- Less than or equal to input n\n- In strictly increasing order\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def LucidNumbers (n : Int) : Array Int :=\nsorry", "vc-theorems": "theorem LucidNumbers_spec (n : Int) :\nn ≥ 0 →\nlet result := LucidNumbers n\n(∀ i, 0 ≤ i ∧ i < result.size → (result[i]!) % 3 = 0) ∧\n(∀ i, 0 ≤ i ∧ i < result.size → result[i]! ≤ n) ∧\n(∀ i j, 0 ≤ i ∧ i < j ∧ j < result.size → result[i]! < result[j]!) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_605_IsPrime", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_605_IsPrime\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_605_IsPrime\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nDetermines if a number is prime.\nTranslated from Dafny method IsPrime.\n\n@param n The number to check for primality\n@return True if the number is prime, false otherwise\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def IsPrime (n : Int) : Bool :=\nsorry", "vc-theorems": "theorem IsPrime_spec (n : Int) :\nn ≥ 2 →\n(IsPrime n = true ↔ (∀ k : Int, 2 ≤ k ∧ k < n → n % k ≠ 0)) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_606_DegreesToRadians", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_606_DegreesToRadians\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_606_DegreesToRadians\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nConverts degrees to radians by multiplying by π and dividing by 180.\nInput:\n- degrees: Real number representing angle in degrees\nOutput:\n- radians: Real number representing angle in radians\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def DegreesToRadians (degrees : Float ) : Float :=\nsorry", "vc-theorems": "theorem DegreesToRadians_spec (degrees : Float) :\nDegreesToRadians degrees = degrees * 3.141592653589793 / 180 :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_610_RemoveElement", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_610_RemoveElement\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_610_RemoveElement\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nRemoveElement removes an element at index k from array s and returns the resulting array.\n\n@param s The input array\n@param k The index to remove\n@return The array with element at index k removed\n\nRequirements:\n- k must be a valid index in s (0 ≤ k < s.size)\n\nEnsures:\n- Output array is one element shorter than input\n- Elements before k are preserved\n- Elements after k are shifted down by one\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def RemoveElement (s : Array Int) (k : Int) : Array Int :=\nsorry", "vc-theorems": "theorem RemoveElement_spec (s : Array Int) (k : Nat) :\n0 ≤ k ∧ k < s.size →\nlet v := RemoveElement s k\nv.size = s.size - 1 ∧\n(∀ i, 0 ≤ i ∧ i < k → v[i]! = s[i]!) ∧\n(∀ i, k ≤ i ∧ i < v.size → v[i]! = s[i + 1]!) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_616_ElementWiseModulo", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_616_ElementWiseModulo\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_616_ElementWiseModulo\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nElementWiseModulo takes two arrays of integers and returns a new array containing\nthe element-wise modulo operation between corresponding elements.\n\n@param a First input array\n@param b Second input array\n@return result Array containing element-wise modulo results\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def ElementWiseModulo (a b : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem ElementWiseModulo_spec (a b : Array Int) :\n(a.size = b.size) ∧\n(∀ i, 0 ≤ i ∧ i < b.size → b[i]! ≠ 0) →\nlet result := ElementWiseModulo a b\n(result.size = a.size) ∧\n(∀ i, 0 ≤ i ∧ i < result.size → result[i]! = a[i]! % b[i]!) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_618_ElementWiseDivide", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_618_ElementWiseDivide\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_618_ElementWiseDivide\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nElementWiseDivide takes two arrays of integers and returns a new array where each element\nis the division of corresponding elements from the input arrays.\n\n@param a First input array\n@param b Second input array\n@return result Array containing element-wise division\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def ElementWiseDivide (a b : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem ElementWiseDivide_spec (a b : Array Int) :\na.size = b.size →\n(∀ i, 0 ≤ i ∧ i < b.size → b[i]! ≠ 0) →\nlet result := ElementWiseDivide a b\n(result.size = a.size ∧\n∀ i, 0 ≤ i ∧ i < result.size → result[i]! = a[i]! / b[i]!) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_622_FindMedian", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_622_FindMedian\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_622_FindMedian\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nFinds the median of two sorted arrays.\nTranslated from Dafny method FindMedian.\n\n@param a First sorted array\n@param b Second sorted array\n@return The median value according to specified rules\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def FindMedian (a b : Array Int) : Int :=\nsorry", "vc-theorems": "theorem FindMedian_spec (a b : Array Int) :\na.size = b.size ∧\na.size > 0 ∧\n(∀ i, 0 ≤ i ∧ i < a.size - 1 → a[i]! ≤ a[i + 1]!) ∧\n(∀ i, 0 ≤ i ∧ i < b.size - 1 → b[i]! ≤ b[i + 1]!) →\nFindMedian a b =\nif a.size % 2 = 0\nthen (a[a.size / 2 - 1]! + b[0]!) / 2\nelse a[a.size / 2]! :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_623_PowerOfListElements", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_623_PowerOfListElements\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_623_PowerOfListElements\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nComputes base raised to the given non-negative exponent.\nTranslated from Dafny's Power function.\n-/\n\n/- \nSpecification for Power function requiring non-negative exponent\n-/\n\n/- \nTakes an array of integers and returns a new array where each element\nis raised to the power n. Translated from Dafny's PowerOfListElements method.\n-/\n\n/- \nSpecification for PowerOfListElements ensuring:\n1. The output array has same size as input\n2. Each element is the corresponding input raised to power n\n-/", "vc-preamble": "partial def Power (base : Int) (exponent : Int) : Int :=\nif exponent == 0 then 1\nelse base * Power base (exponent - 1)", "vc-helpers": "", "vc-definitions": "def PowerOfListElements (l : Array Int) (n : Int) : Array Int :=\nsorry", "vc-theorems": "theorem Power_spec (base : Int) (exponent : Int) :\nexponent ≥ 0 → Power base exponent ≥ 0 :=\nsorry\n\ntheorem PowerOfListElements_spec (l : Array Int) (n : Int) :\nn ≥ 0 →\nlet result := PowerOfListElements l n\nresult.size = l.size ∧\n∀ i, 0 ≤ i ∧ i < l.size → result[i]! = Power l[i]! n :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_624_ToUppercase", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_624_ToUppercase\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_624_ToUppercase\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate indicating if a character is lowercase -/\n\n/-  Predicate indicating if two characters form a lowercase-uppercase pair -/\n\n/-  Function that shifts a character's ASCII value by -32 -/\n\n/-  Main ToUppercase function that converts a string to uppercase -/", "vc-preamble": "def IsLowerCase (c : Char) : Bool :=\n97 ≤ c.toNat ∧ c.toNat ≤ 122\ndef IsLowerUpperPair (c : Char) (C : Char) : Bool :=\nc.toNat = C.toNat + 32\ndef ShiftMinus32 (c : Char) : Char :=\nChar.ofNat ((c.toNat - 32) % 128)", "vc-helpers": "", "vc-definitions": "def ToUppercase (s : String) : String :=\nsorry", "vc-theorems": "theorem ToUppercase_spec (s : String) :\nlet v := ToUppercase s\nv.length = s.length ∧\n∀ i, 0 ≤ i ∧ i < s.length →\n(if IsLowerCase (s.get ⟨i⟩)\nthen IsLowerUpperPair (s.get ⟨i⟩) (v.get ⟨i⟩)\nelse v.get ⟨i⟩ = s.get ⟨i⟩) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_625_SwapFirstAndLast", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_625_SwapFirstAndLast\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_625_SwapFirstAndLast\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nSwapFirstAndLast swaps the first and last elements of an array.\n\n@param a The input array to modify\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def SwapFirstAndLast (a : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem SwapFirstAndLast_spec (a : Array Int) (old_a : Array Int) :\na.size > 0 →\n(SwapFirstAndLast a)[0]! = old_a[old_a.size - 1]! ∧\n(SwapFirstAndLast a)[a.size - 1]! = old_a[0]! ∧\n(∀ k, 1 ≤ k ∧ k < a.size - 1 → (SwapFirstAndLast a)[k]! = old_a[k]!) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_626_AreaOfLargestTriangleInSemicircle", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_626_AreaOfLargestTriangleInSemicircle\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_626_AreaOfLargestTriangleInSemicircle\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nCalculates the area of the largest triangle that can be inscribed in a semicircle.\n\n@param radius The radius of the semicircle (must be positive)\n@return The area of the largest inscribed triangle\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def AreaOfLargestTriangleInSemicircle (radius : Int) : Int :=\nsorry", "vc-theorems": "theorem AreaOfLargestTriangleInSemicircle_spec (radius : Int) :\nradius > 0 →\nAreaOfLargestTriangleInSemicircle radius = radius * radius :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_627_SmallestMissingNumber", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_627_SmallestMissingNumber\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_627_SmallestMissingNumber\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nFinds the smallest non-negative integer that is not present in a sorted array.\n\n@param s The input sorted array of non-negative integers\n@return The smallest non-negative integer not in the array\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def SmallestMissingNumber (s : Array Int) : Int :=\nsorry", "vc-theorems": "theorem SmallestMissingNumber_spec (s : Array Int) :\n(∀ i j, 0 ≤ i → i < j → j < s.size → s[i]! ≤ s[j]!) →\n(∀ i, 0 ≤ i → i < s.size → s[i]! ≥ 0) →\nlet v := SmallestMissingNumber s\n0 ≤ v ∧\n(∀ i, 0 ≤ i → i < s.size → s[i]! ≠ v) ∧\n(∀ k, 0 ≤ k → k < v → ∃ i, 0 ≤ i ∧ i < s.size ∧ s[i]! = k) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_629_FindEvenNumbers", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_629_FindEvenNumbers\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_629_FindEvenNumbers\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nPredicate that checks if a number is even\n-/\n\n/- \nFunction that finds all even numbers in an array.\nReturns a sequence containing all even numbers from the input array.\n\nEnsures:\n- All numbers in output are even and exist in input\n- All even numbers from input exist in output\n-/", "vc-preamble": "def IsEven (n : Int) : Bool :=\nn % 2 = 0", "vc-helpers": "", "vc-definitions": "def FindEvenNumbers (arr : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem FindEvenNumbers_spec (arr : Array Int) :\nlet result := FindEvenNumbers arr\n(∀ i, 0 ≤ i ∧ i < result.size → IsEven (result[i]!) ∧ (result[i]!) ∈ arr.toList) ∧\n(∀ i, 0 ≤ i ∧ i < arr.size ∧ IsEven (arr[i]!) → (arr[i]!) ∈ result.toList) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_632_MoveZeroesToEnd", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_632_MoveZeroesToEnd\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_632_MoveZeroesToEnd\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Swaps two elements in an array -/\n\n/-  Specification for swap operation -/\n\n/-  Counts occurrences of a value in an array -/\n\n/-  Specification for count operation -/\n\n/-  Moves all zeros to the end of the array while preserving order of non-zero elements -/\n\n/-  Specification for MoveZeroesToEnd operation -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def swap (arr : Array Int) (i j : Int) : Array Int :=\nsorry\n\ndef count (arr : Array Int) (value : Int) : Nat :=\nsorry\n\ndef MoveZeroesToEnd (arr : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem swap_spec (arr : Array Int) (i j : Nat) :\narr.size > 0 ∧\n0 ≤ i ∧ i < arr.size ∧\n0 ≤ j ∧ j < arr.size →\nlet arr' := swap arr i j\narr'[i]! = arr[j]! ∧\narr'[j]! = arr[i]! ∧\n(∀ k, 0 ≤ k ∧ k < arr.size ∧ k ≠ i ∧ k ≠ j → arr'[k]! = arr[k]!) :=\nsorry\n\ntheorem count_spec (arr : Array Int) (value : Int) :\ncount arr value ≤ arr.size :=\nsorry\n\ntheorem MoveZeroesToEnd_spec (arr : Array Int) :\narr.size ≥ 2 →\nlet arr' := MoveZeroesToEnd arr\n\n-- Same size\n\narr'.size = arr.size ∧\n\n-- Zeros to the right of first zero\n\n(∀ i j, 0 ≤ i ∧ i < j ∧ j < arr'.size ∧ arr'[i]! = 0 → arr'[j]! = 0) ∧\n\n-- Relative order of non-zero elements preserved\n\n(∀ n m, 0 ≤ n ∧ n < m ∧ m < arr.size ∧ arr[n]! ≠ 0 ∧ arr[m]! ≠ 0 →\n\n∃ k l, 0 ≤ k ∧ k < l ∧ l < arr'.size ∧\n\narr'[k]! = arr[n]! ∧\n\narr'[l]! = arr[m]!) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_632_swap", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_632_swap\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_632_swap\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nCounts occurrences of a value in an array.\n-/\n\n/- \nSwaps two elements in an array.\nRequires:\n- Array is non-empty\n- Indices i and j are valid array indices\nEnsures:\n- Elements at i and j are swapped\n- All other elements remain unchanged\n- Multiset of elements is preserved\n-/", "vc-preamble": "partial def count (arr : Array Int) (value : Int) : Nat :=\nif arr.size = 0 then\n0\nelse\n(if arr[0]! = value then 1 else 0) + count (arr.extract 1 arr.size) value", "vc-helpers": "", "vc-definitions": "def swap (arr : Array Int) (i j : Int) : Array Int :=\nsorry", "vc-theorems": "theorem swap_spec (arr : Array Int) (i j : Nat) :\narr.size > 0 ∧\n0 ≤ i ∧ i < arr.size ∧\n0 ≤ j ∧ j < arr.size →\nlet result := swap arr i j\nresult.size = arr.size ∧\nresult[i]! = arr[j]! ∧\nresult[j]! = arr[i]! ∧\n(∀ k, 0 ≤ k ∧ k < arr.size ∧ k ≠ i ∧ k ≠ j → result[k]! = arr[k]!) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_637_IsBreakEven", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_637_IsBreakEven\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_637_IsBreakEven\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nDetermines if cost price equals selling price.\n\n@param costPrice The cost price (must be non-negative)\n@param sellingPrice The selling price (must be non-negative)\n@return True if and only if costPrice equals sellingPrice\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def IsBreakEven (costPrice : Int) (sellingPrice : Int) : Bool :=\nsorry", "vc-theorems": "theorem IsBreakEven_spec (costPrice sellingPrice : Int) :\ncostPrice ≥ 0 ∧ sellingPrice ≥ 0 →\nIsBreakEven costPrice sellingPrice = (costPrice = sellingPrice) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_641_NthNonagonalNumber", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_641_NthNonagonalNumber\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_641_NthNonagonalNumber\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nCalculates the nth nonagonal number.\nTranslated from Dafny method that requires n ≥ 0 and ensures result equals n*(7n-5)/2\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def NthNonagonalNumber (n : Int) : Int :=\nsorry", "vc-theorems": "theorem NthNonagonalNumber_spec (n : Int) :\nn ≥ 0 → NthNonagonalNumber n = n * (7 * n - 5) / 2 :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_644_Reverse", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_644_Reverse\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_644_Reverse\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nReverses the elements of an array in place.\n\n@param a The array to reverse\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Reverse (a : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem Reverse_spec (a : Array Int) :\n∀ k, 0 ≤ k ∧ k < (Reverse a).size →\n(Reverse a)[k]! = a[(a.size - 1) - k]! :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_644_ReverseUptoK", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_644_ReverseUptoK\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_644_ReverseUptoK\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nReverseUptoK reverses the first k elements of an array while keeping the rest unchanged.\nInput:\n- s: Array of integers to be partially reversed\n- k: Number of elements from start to reverse\nRequires:\n- k must be at least 2 and at most the array length\nEnsures:\n- First k elements are reversed\n- Elements after k remain unchanged\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def ReverseUptoK (s : Array Int) (k : Nat) : Array Int :=\nsorry", "vc-theorems": "theorem ReverseUptoK_spec (s : Array Int) (k : Nat) (old_s : Array Int) :\n2 ≤ k ∧ k ≤ s.size →\n(∀ i, 0 ≤ i ∧ i < k → (ReverseUptoK s k)[i]! = old_s[k - 1 - i]!) ∧\n(∀ i, k ≤ i ∧ i < s.size → (ReverseUptoK s k)[i]! = old_s[i]!) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_69_ContainsSequence", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_69_ContainsSequence\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_69_ContainsSequence\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nContainsSequence checks if a sequence exists in a list of sequences.\n\n@param list The list of integer sequences to search in\n@param sub The sequence to search for\n@return True if sub exists in list, false otherwise\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def ContainsSequence (list : Array (Array Int)) (sub : Array Int) : Bool :=\nsorry", "vc-theorems": "theorem ContainsSequence_spec (list : Array (Array Int)) (sub : Array Int) :\nContainsSequence list sub = (∃ i, 0 ≤ i ∧ i < list.size ∧ sub = list[i]!) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_70_AllSequencesEqualLength", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_70_AllSequencesEqualLength\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_70_AllSequencesEqualLength\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nChecks if all sequences in the input array have equal length.\n\n@param sequences Array of integer arrays to check\n@return True if all sequences have the same length, false otherwise\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def AllSequencesEqualLength (sequences : Array (Array Int)) : Bool :=\nsorry", "vc-theorems": "theorem AllSequencesEqualLength_spec (sequences : Array (Array Int)) :\nAllSequencesEqualLength sequences ↔\n(∀ i j, 0 ≤ i ∧ i < sequences.size ∧ 0 ≤ j ∧ j < sequences.size →\n(sequences[i]!).size = (sequences[j]!).size) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_728_AddLists", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_728_AddLists\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_728_AddLists\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nAddLists takes two arrays of integers and returns a new array where each element\nis the sum of the corresponding elements from the input arrays.\n\n@param a First input array\n@param b Second input array\n@return Array containing element-wise sums\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def AddLists (a b : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem AddLists_spec (a b : Array Int) :\na.size = b.size →\nlet result := AddLists a b\nresult.size = a.size ∧\n∀ i, 0 ≤ i ∧ i < result.size → result[i]! = a[i]! + b[i]! :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_732_ReplaceWithColon", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_732_ReplaceWithColon\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_732_ReplaceWithColon\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nPredicate that checks if a character is a space, comma or dot\n-/\n\n/- \nFunction that replaces spaces, commas and dots with colons in a string.\nReturns a new string of the same length where:\n- Characters that are space/comma/dot are replaced with colon\n- All other characters remain unchanged\n-/", "vc-preamble": "def IsSpaceCommaDot (c : Char) : Bool :=\nc == ' ' ∨ c == ',' ∨ c == '.'", "vc-helpers": "", "vc-definitions": "def ReplaceWithColon (s : String) : String :=\nsorry", "vc-theorems": "theorem ReplaceWithColon_spec (s : String) :\nlet v := ReplaceWithColon s\nv.length = s.length ∧\n∀ i, 0 ≤ i ∧ i < s.length →\n((IsSpaceCommaDot (s.get ⟨i⟩) → v.get ⟨i⟩ = ':') ∧\n(¬IsSpaceCommaDot (s.get ⟨i⟩) → v.get ⟨i⟩ = s.get ⟨i⟩)) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_733_FindFirstOccurrence", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_733_FindFirstOccurrence\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_733_FindFirstOccurrence\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nFinds the first occurrence of a target value in a sorted array.\n\n@param arr The input array to search\n@param target The value to find\n@return The index of the first occurrence of target, or -1 if not found\n\nRequirements:\n- Array must be non-null\n- Array must be sorted in non-decreasing order\n\nEnsures:\n- If index is valid, arr equals target\n- If index is -1, target is not in array\n- Array contents are unchanged\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def FindFirstOccurrence (arr : Array Int) (target : Int) : Int :=\nsorry", "vc-theorems": "theorem FindFirstOccurrence_spec\n(arr : Array Int) (target : Int) :\n(∀ i j, 0 ≤ i ∧ i < j ∧ j < arr.size → arr[i]! ≤ arr[j]!) →\nlet result := FindFirstOccurrence arr target\n(0 ≤ result ∧ result < arr.size → arr[result.toNat]! = target) ∧\n(result = -1 → ∀ i, 0 ≤ i ∧ i < arr.size → arr[i]! ≠ target) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_741_AllCharactersSame", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_741_AllCharactersSame\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_741_AllCharactersSame\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nChecks if all characters in a string are the same.\nReturns true if all characters match, false if there are any differences.\n\n@param s The input string to check\n@return True if all characters are the same, false otherwise\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def AllCharactersSame (s : String) : Bool :=\nsorry", "vc-theorems": "theorem AllCharactersSame_spec (s : String) :\nlet result := AllCharactersSame s\n(result → ∀ i j, 0 ≤ i ∧ i < s.length ∧ 0 ≤ j ∧ j < s.length → s.get ⟨i⟩ = s.get ⟨j⟩) ∧\n(!result → s.length > 1 ∧ ∃ i j, 0 ≤ i ∧ i < s.length ∧ 0 ≤ j ∧ j < s.length ∧ i ≠ j ∧ s.get ⟨i⟩ ≠ s.get ⟨j⟩) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_743_RotateRight", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_743_RotateRight\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_743_RotateRight\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nRotates an array to the right by n positions.\nInput:\n- l: Array of integers to rotate\n- n: Number of positions to rotate right\nReturns:\n- Rotated array\nEnsures:\n- Output array has same size as input\n- Each element is correctly rotated\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def RotateRight (l : Array Int) (n : Int) : Array Int :=\nsorry", "vc-theorems": "theorem RotateRight_spec (l : Array Int) (n : Int) :\nn ≥ 0 →\nlet r := RotateRight l n\n(r.size = l.size) ∧\n(∀ i, 0 ≤ i ∧ i < l.size →\nr[i]! = l[((i - n + l.size) % l.size).toNat]!) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_750_AddTupleToList", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_750_AddTupleToList\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_750_AddTupleToList\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nAdds a tuple to the end of a list of tuples.\n\n@param l The input list of integer tuples\n@param t The tuple to append\n@return The resulting list with t appended\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def AddTupleToList (l : Array (Int × Int)) (t : Int × Int) : Array (Int × Int) :=\nsorry", "vc-theorems": "theorem AddTupleToList_spec (l : Array (Int × Int)) (t : Int × Int) :\nlet r := AddTupleToList l t\nr.size = l.size + 1 ∧\nr[r.size - 1]! = t ∧\n∀ i, 0 ≤ i ∧ i < l.size → r[i]! = l[i]! :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_751_IsMinHeap", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_751_IsMinHeap\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_751_IsMinHeap\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nChecks if an array represents a valid min heap.\nTranslated from Dafny method IsMinHeap.\n\n@param a The input array to check\n@return Whether the array is a valid min heap\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def IsMinHeap (a : Array Int) : Bool :=\nsorry", "vc-theorems": "theorem IsMinHeap_spec (a : Array Int) (result : Bool) :\nresult → (∀ i, 0 ≤ i ∧ i < a.size / 2 →\na[i]! ≤ a[2*i + 1]! ∧\n(2*i + 2 = a.size ∨ a[i]! ≤ a[2*i + 2]!)) ∧\n(¬result → ∃ i, 0 ≤ i ∧ i < a.size / 2 ∧\n(a[i]! > a[2*i + 1]! ∨\n(2*i + 2 ≠ a.size ∧ a[i]! > a[2*i + 2]!))) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_755_SecondSmallest", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_755_SecondSmallest\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_755_SecondSmallest\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nMinPair function that returns the minimum of two elements in a sequence.\n-/\n\n/- \nSpecification for MinPair function\n-/\n\n/- \nmin function that returns the minimum element in a sequence\n-/\n\n/- \nSpecification for min function\n-/\n\n/- \nSecondSmallest method that returns the second smallest element in an array\n-/\n\n/- \nSpecification for SecondSmallest method\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def MinPair (s : Array Int) : Int :=\nsorry\n\ndef min (s : Array Int) : Int :=\nsorry\n\ndef SecondSmallest (s : Array Int) : Int :=\nsorry", "vc-theorems": "theorem MinPair_spec (s : Array Int) :\ns.size = 2 →\n((s[0]! ≤ s[1]!) → MinPair s = s[0]!) ∧\n((s[0]! > s[1]!) → MinPair s = s[1]!) :=\nsorry\n\ntheorem min_spec (s : Array Int) :\ns.size ≥ 2 →\n∀ i, 0 ≤ i ∧ i < s.size → min s ≤ s[i]! :=\nsorry\n\ntheorem SecondSmallest_spec (s : Array Int) (result : Int) :\ns.size ≥ 2 →\n(∃ i j, 0 ≤ i ∧ i < s.size ∧ 0 ≤ j ∧ j < s.size ∧ i ≠ j ∧ s[i]! = min s ∧ s[j]! ≠ s[i]!) →\n(∃ i j, 0 ≤ i ∧ i < s.size ∧ 0 ≤ j ∧ j < s.size ∧ i ≠ j ∧ s[i]! = min s ∧ s[j]! = result) ∧\n(∀ k, 0 ≤ k ∧ k < s.size ∧ s[k]! ≠ min s → s[k]! ≥ result) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_759_IsDecimalWithTwoPrecision", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_759_IsDecimalWithTwoPrecision\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_759_IsDecimalWithTwoPrecision\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nChecks if a string has exactly two decimal places after a decimal point.\nTranslated from Dafny specification.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def IsDecimalWithTwoPrecision (s : String) : Bool :=\nsorry", "vc-theorems": "theorem IsDecimalWithTwoPrecision_spec (s : String) :\nlet result := IsDecimalWithTwoPrecision s\n(result → ∃ i, 0 ≤ i ∧ i < s.length ∧ s.get ⟨i⟩ = '.' ∧ s.length - i - 1 = 2) ∧\n(!result → ¬(∃ i, 0 ≤ i ∧ i < s.length ∧ s.get ⟨i⟩ = '.' ∧ s.length - i - 1 = 2)) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_760_HasOnlyOneDistinctElement", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_760_HasOnlyOneDistinctElement\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_760_HasOnlyOneDistinctElement\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nChecks if an array has only one distinct element.\nTranslated from Dafny specification.\n\n@param a The input array to check\n@return True if all elements are equal, false otherwise\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def HasOnlyOneDistinctElement (a : Array Int) : Bool :=\nsorry", "vc-theorems": "theorem HasOnlyOneDistinctElement_spec (a : Array Int) :\n(HasOnlyOneDistinctElement a = true →\n∀ i j, 0 ≤ i ∧ i < a.size ∧ 0 ≤ j ∧ j < a.size → a[i]! = a[j]!) ∧\n(HasOnlyOneDistinctElement a = false →\n∃ i j, 0 ≤ i ∧ i < a.size ∧ 0 ≤ j ∧ j < a.size ∧ a[i]! ≠ a[j]!) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_762_IsMonthWith30Days", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_762_IsMonthWith30Days\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_762_IsMonthWith30Days\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nDetermines if a given month has 30 days.\n\n@param month The month number (1-12)\n@return True if the month has 30 days, false otherwise\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def IsMonthWith30Days (month : Int) : Bool :=\nsorry", "vc-theorems": "theorem IsMonthWith30Days_spec (month : Int) :\n1 ≤ month ∧ month ≤ 12 →\nIsMonthWith30Days month = (month = 4 ∨ month = 6 ∨ month = 9 ∨ month = 11) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_769_Difference", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_769_Difference\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_769_Difference\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nComputes the difference between two arrays, returning elements in first array not in second.\nEnsures:\n- Result contains only elements from first array not in second array\n- Result has no duplicates\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Difference (a : Array Int) (b : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem difference_spec (a b diff : Array Int) :\ndiff = Difference a b →\n(∀ x, diff.contains x ↔ (a.contains x ∧ ¬b.contains x)) ∧\n(∀ i j, 0 ≤ i → i < j → j < diff.size → diff[i]! ≠ diff[j]!) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_770_SumOfFourthPowerOfOddNumbers", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_770_SumOfFourthPowerOfOddNumbers\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_770_SumOfFourthPowerOfOddNumbers\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nComputes the sum of fourth powers of odd numbers up to n.\nTranslated from Dafny method SumOfFourthPowerOfOddNumbers.\n\n@param n The upper bound (must be positive)\n@return The sum of fourth powers of odd numbers\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def SumOfFourthPowerOfOddNumbers (n : Int) : Int :=\nsorry", "vc-theorems": "theorem SumOfFourthPowerOfOddNumbers_spec (n : Int) :\nn > 0 →\nSumOfFourthPowerOfOddNumbers n =\nn * (2 * n + 1) * (24 * n * n * n - 12 * n * n - 14 * n + 7) / 15 :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_775_IsOddAtIndexOdd", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_775_IsOddAtIndexOdd\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_775_IsOddAtIndexOdd\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nPredicate that checks if a number is odd\n-/\n\n/- \nMethod that checks if all odd-indexed elements in an array are odd numbers.\nReturns true if for all indices i, if i is odd then the element at index i is odd.\n-/", "vc-preamble": "def IsOdd (n : Int) : Bool :=\nn % 2 = 1", "vc-helpers": "", "vc-definitions": "def IsOddAtIndexOdd (a : Array Int) : Bool :=\nsorry", "vc-theorems": "theorem IsOddAtIndexOdd_spec (a : Array Int) :\nIsOddAtIndexOdd a = (∀ i, 0 ≤ i ∧ i < a.size → (IsOdd i → IsOdd (a[i]!))) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_776_CountVowelNeighbors", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_776_CountVowelNeighbors\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_776_CountVowelNeighbors\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nPredicate that checks if a character is a vowel.\n-/\n\n/- \nCounts the number of characters in a string that have vowels as neighbors.\nReturns the count of positions where both the previous and next characters are vowels.\n-/", "vc-preamble": "def IsVowel (c : Char) : Bool :=\nc ∈ ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']", "vc-helpers": "", "vc-definitions": "def CountVowelNeighbors (s : String) : Int :=\nsorry", "vc-theorems": "theorem CountVowelNeighbors_spec (s : String) :\nlet count := CountVowelNeighbors s\ncount ≥ 0 ∧\ncount = ((List.range s.length).filter (fun i =>\ni ≥ 1 ∧ i < s.length - 1 ∧\nIsVowel (s.toList[i-1]!) ∧\nIsVowel (s.toList[i+1]!))).length\n:=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_784_FirstEvenOddIndices", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_784_FirstEvenOddIndices\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_784_FirstEvenOddIndices\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate indicating if a number is even -/\n\n/-  Predicate indicating if a number is odd -/\n\n/-  Predicate indicating if the given index is the first even number in the array -/\n\n/-  Predicate indicating if the given index is the first odd number in the array -/\n\n/- \nFinds the indices of first even and odd numbers in an array\nRequires:\n- Array has at least 2 elements\n- Array contains at least one even number\n- Array contains at least one odd number\nEnsures:\n- Returns valid indices within array bounds\n- Returns indices of first even and odd numbers\n-/", "vc-preamble": "def IsEven (n : Int) : Bool :=\nn % 2 = 0\n\ndef IsOdd (n : Int) : Bool :=\nn % 2 ≠ 0\n\ndef IsFirstEven (evenIndex : Nat) (lst : Array Int) : Prop :=\n0 ≤ evenIndex ∧ evenIndex < lst.size ∧\nIsEven (lst[evenIndex]!) ∧\n(∀ i, 0 ≤ i ∧ i < evenIndex → IsOdd (lst[i]!))\n\ndef IsFirstOdd (oddIndex : Nat) (lst : Array Int) : Prop :=\n0 ≤ oddIndex ∧ oddIndex < lst.size ∧\nIsOdd (lst[oddIndex]!) ∧\n(∀ i, 0 ≤ i ∧ i < oddIndex → IsEven (lst[i]!))", "vc-helpers": "", "vc-definitions": "def FirstEvenOddIndices (lst : Array Int) : Nat × Nat :=\nsorry", "vc-theorems": "theorem FirstEvenOddIndices_spec (lst : Array Int) :\nlst.size ≥ 2 →\n(∃ i, 0 ≤ i ∧ i < lst.size ∧ IsEven (lst[i]!)) →\n(∃ i, 0 ≤ i ∧ i < lst.size ∧ IsOdd (lst[i]!)) →\nlet (evenIndex, oddIndex) := FirstEvenOddIndices lst\n0 ≤ evenIndex ∧ evenIndex < lst.size ∧\n0 ≤ oddIndex ∧ oddIndex < lst.size ∧\nIsEven (lst[evenIndex]!) ∧ IsFirstEven evenIndex lst ∧\nIsOdd (lst[oddIndex]!) ∧ IsFirstOdd oddIndex lst :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_784_ProductEvenOdd", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_784_ProductEvenOdd\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_784_ProductEvenOdd\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate indicating if a number is even -/\n\n/-  Predicate indicating if a number is odd -/\n\n/-  Predicate indicating if evenIndex is the first even number in the list -/\n\n/-  Predicate indicating if oddIndex is the first odd number in the list -/\n\n/-  Returns indices of first even and odd numbers in list -/\n\n/-  Specification for FirstEvenOddIndices -/\n\n/-  Returns product of first even and odd numbers in list -/\n\n/-  Specification for ProductEvenOdd -/", "vc-preamble": "def IsEven (n : Int) : Bool :=\nn % 2 = 0\n\ndef IsOdd (n : Int) : Bool :=\nn % 2 ≠ 0\n\ndef IsFirstEven (evenIndex : Nat) (lst : Array Int) : Prop :=\n0 ≤ evenIndex ∧ evenIndex < lst.size ∧\nIsEven (lst[evenIndex]!) ∧\n(∀ i, 0 ≤ i ∧ i < evenIndex → IsOdd (lst[i]!))\n\ndef IsFirstOdd (oddIndex : Nat) (lst : Array Int) : Prop :=\n0 ≤ oddIndex ∧ oddIndex < lst.size ∧\nIsOdd (lst[oddIndex]!) ∧\n(∀ i, 0 ≤ i ∧ i < oddIndex → IsEven (lst[i]!))", "vc-helpers": "", "vc-definitions": "def FirstEvenOddIndices (lst : Array Int) : (Nat × Nat) :=\nsorry\n\ndef ProductEvenOdd (lst : Array Int) : Int :=\nsorry", "vc-theorems": "theorem FirstEvenOddIndices_spec (lst : Array Int) :\nlst.size ≥ 2 →\n(∃ i, 0 ≤ i ∧ i < lst.size ∧ IsEven (lst[i]!)) →\n(∃ i, 0 ≤ i ∧ i < lst.size ∧ IsOdd (lst[i]!)) →\nlet (evenIndex, oddIndex) := FirstEvenOddIndices lst\n0 ≤ evenIndex ∧ evenIndex < lst.size ∧\n0 ≤ oddIndex ∧ oddIndex < lst.size ∧\nIsEven (lst[evenIndex]!) ∧ IsFirstEven evenIndex lst ∧\nIsOdd (lst[oddIndex]!) ∧ IsFirstOdd oddIndex lst :=\nsorry\n\ntheorem ProductEvenOdd_spec (lst : Array Int) :\nlst.size ≥ 2 →\n(∃ i, 0 ≤ i ∧ i < lst.size ∧ IsEven (lst[i]!)) →\n(∃ i, 0 ≤ i ∧ i < lst.size ∧ IsOdd (lst[i]!)) →\n∃ i j, 0 ≤ i ∧ i < lst.size ∧ IsEven (lst[i]!) ∧ IsFirstEven i lst ∧\n0 ≤ j ∧ j < lst.size ∧ IsOdd (lst[j]!) ∧ IsFirstOdd j lst ∧\nProductEvenOdd lst = (lst[i]!) * (lst[j]!) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_790_IsEvenAtIndexEven", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_790_IsEvenAtIndexEven\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_790_IsEvenAtIndexEven\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nPredicate that checks if a number is even.\nTranslated from Dafny's IsEven predicate.\n-/\n\n/- \nMethod that checks if all elements at even indices in a list are even.\nTranslated from Dafny's IsEvenAtIndexEven method.\n-/", "vc-preamble": "def IsEven (n : Int) : Bool :=\nn % 2 = 0", "vc-helpers": "", "vc-definitions": "def IsEvenAtIndexEven (lst : Array Int) : Bool :=\nsorry", "vc-theorems": "theorem IsEvenAtIndexEven_spec (lst : Array Int) :\nIsEvenAtIndexEven lst = (∀ i, 0 ≤ i ∧ i < lst.size → (IsEven i → IsEven (lst[i]!))) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_792_CountLists", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_792_CountLists\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_792_CountLists\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nCounts the number of lists in a sequence of integer lists.\n\n@param lists The sequence of integer lists to count\n@return The count of lists in the sequence\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def CountLists (lists : Array (Array Int)) : Int :=\nsorry", "vc-theorems": "theorem CountLists_spec (lists : Array (Array Int)) :\nlet count := CountLists lists\ncount ≥ 0 ∧ count = lists.size :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_793_LastPosition", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_793_LastPosition\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_793_LastPosition\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nFinds the last position of an element in a sorted array.\nInput:\n- arr: Array of integers\n- elem: Integer to search for\nReturns:\n- Position of the last occurrence of elem, or -1 if not found\nRequires:\n- Array is non-empty\n- Array is sorted in non-decreasing order\nEnsures:\n- Result is -1 or a valid index with the element\n- If result is valid, it's the last occurrence\n- Array contents remain unchanged\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def LastPosition (arr : Array Int) (elem : Int) : Int :=\nsorry", "vc-theorems": "theorem LastPosition_spec (arr : Array Int) (elem : Int) :\narr.size > 0 ∧\n(∀ i j, 0 ≤ i ∧ i < j ∧ j < arr.size → arr[i]! ≤ arr[j]!) →\nlet pos := LastPosition arr elem\n(pos = -1 ∨\n(0 ≤ pos ∧ pos < arr.size ∧\narr[pos.toNat]! = elem ∧\n(pos ≤ arr.size - 1 ∨ arr[(pos + 1).toNat]! > elem))) ∧\n(∀ i, 0 ≤ i ∧ i < arr.size → arr[i]! = arr[i]!) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_798_ArraySum", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_798_ArraySum\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_798_ArraySum\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nRecursively sums elements of array up to index n-1.\nRequires:\n- Array is not null\n- 0 ≤ n ≤ array size\n-/\n\n/- \nReturns sum of all elements in array.\nEnsures result equals sumTo(a, a.size)\n-/", "vc-preamble": "def sumTo (a : Array Int) (n : Nat) : Int :=\nif n = 0 then 0\nelse sumTo a (n-1) + a[n-1]!", "vc-helpers": "", "vc-definitions": "def ArraySum (a : Array Int) : Int :=\nsorry", "vc-theorems": "theorem ArraySum_spec (a : Array Int) :\nArraySum a = sumTo a a.size :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_799_RotateLeftBits", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_799_RotateLeftBits\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_799_RotateLeftBits\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nRotates bits in a 32-bit value left by specified number of positions.\n\n@param n The 32-bit value to rotate\n@param d The number of positions to rotate left (must be between 0 and 31)\n@return The rotated value\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def RotateLeftBits (n : UInt32) (d : Int) : UInt32 :=\nsorry", "vc-theorems": "theorem RotateLeftBits_spec (n : UInt32) (d : Int) :\n0 ≤ d ∧ d < 32 →\nRotateLeftBits n d = ((UInt32.shiftLeft n (UInt32.ofNat d.toNat)) ||| (UInt32.shiftRight n (UInt32.ofNat (32 - d).toNat))) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_801_CountEqualNumbers", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_801_CountEqualNumbers\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_801_CountEqualNumbers\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nCounts how many numbers are equal among three input integers.\nReturns:\n- 3 if all numbers are equal\n- 2 if exactly two numbers are equal\n- 1 if no numbers are equal\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def CountEqualNumbers (a b c : Int) : Int :=\nsorry", "vc-theorems": "theorem CountEqualNumbers_spec (a b c : Int) :\nlet count := CountEqualNumbers a b c\ncount ≥ 0 ∧ count ≤ 3 ∧\n(count = 3 ↔ (a = b ∧ b = c)) ∧\n(count = 2 ↔ ((a = b ∧ b ≠ c) ∨ (a ≠ b ∧ b = c) ∨ (a = c ∧ b ≠ c))) ∧\n(count = 1 ↔ (a ≠ b ∧ b ≠ c ∧ a ≠ c)) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_803_IsPerfectSquare", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_803_IsPerfectSquare\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_803_IsPerfectSquare\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nChecks if a number is a perfect square.\nTranslated from Dafny method IsPerfectSquare.\n\n@param n The input number to check\n@return Whether n is a perfect square\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def IsPerfectSquare (n : Int) : Bool :=\nsorry", "vc-theorems": "theorem IsPerfectSquare_spec (n : Int) :\nn ≥ 0 →\nlet result := IsPerfectSquare n\n(result = true → ∃ i : Int, 0 ≤ i ∧ i ≤ n ∧ i * i = n) ∧\n(result = false → ∀ a : Int, (0 < a*a ∧ a*a < n) → a*a ≠ n) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_804_IsProductEven", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_804_IsProductEven\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_804_IsProductEven\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate that checks if a number is even -/\n\n/-  Function that checks if array contains an even number -/", "vc-preamble": "def IsEven (n : Int) : Bool :=\nn % 2 = 0", "vc-helpers": "", "vc-definitions": "def IsProductEven (a : Array Int) : Bool :=\nsorry", "vc-theorems": "theorem IsProductEven_spec (a : Array Int) :\nIsProductEven a ↔ ∃ i, 0 ≤ i ∧ i < a.size ∧ IsEven (a[i]!) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_807_FindFirstOdd", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_807_FindFirstOdd\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_807_FindFirstOdd\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate indicating if a number is odd -/\n\n/-  FindFirstOdd takes an array of integers and returns:\n- found: whether an odd number was found\n- index: the index of the first odd number if found\n-/", "vc-preamble": "def IsOdd (x : Int) : Bool :=\nx % 2 ≠ 0", "vc-helpers": "", "vc-definitions": "def FindFirstOdd (a : Array Int) : Bool × Int :=\nsorry", "vc-theorems": "theorem FindFirstOdd_spec (a : Array Int) (result : Bool × Int) :\nlet (found, index) := result\n(¬found → ∀ i, 0 ≤ i ∧ i < a.size → ¬IsOdd (a[i]!)) ∧\n(found → 0 ≤ index ∧ index < a.size ∧\nIsOdd (a[index.toNat]!) ∧\n∀ i:Nat, 0 ≤ i ∧ i < index → ¬IsOdd (a[i]!)) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_809_IsSmaller", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_809_IsSmaller\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_809_IsSmaller\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nChecks if all elements in array `a` are strictly greater than corresponding elements in array `b`.\n\n@param a First array to compare\n@param b Second array to compare\n@return True if all elements in `a` are greater than corresponding elements in `b`\n\nRequires:\n- Arrays `a` and `b` have the same size\n\nEnsures:\n- Result is true iff for all indices i, a > b\n- Result is false iff there exists an index i where a ≤ b\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def IsSmaller (a b : Array Int) : Bool :=\nsorry", "vc-theorems": "theorem IsSmaller_spec (a b : Array Int) :\na.size = b.size →\n(IsSmaller a b ↔ (∀ i, 0 ≤ i ∧ i < a.size → a[i]! > b[i]!)) ∧\n(!IsSmaller a b ↔ (∃ i, 0 ≤ i ∧ i < a.size ∧ a[i]! ≤ b[i]!)) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_94_MinSecondValueFirst", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_94_MinSecondValueFirst\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_94_MinSecondValueFirst\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nFinds the first element of the sequence that has the minimum second element.\n\n@param s Array of integer sequences\n@return The first element of the sequence with minimum second element\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def MinSecondValueFirst (s : Array (Array Int)) : Int :=\nsorry", "vc-theorems": "theorem MinSecondValueFirst_spec (s : Array (Array Int)) :\ns.size > 0 ∧\n(∀ i, 0 ≤ i ∧ i < s.size → s[i]!.size ≥ 2) →\n∃ i, 0 ≤ i ∧ i < s.size ∧\nMinSecondValueFirst s = (s[i]!)[0]! ∧\n(∀ j, 0 ≤ j ∧ j < s.size → (s[i]!)[1]! ≤ (s[j]!)[1]!) :=\nsorry", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_95_SmallestListLength", "vc-description": "/- \n{\n\"name\": \"dafny-synthesis_task_id_95_SmallestListLength\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny-synthesis_task_id_95_SmallestListLength\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nFinds the smallest length among a sequence of integer sequences.\n\n@param s Array of integer arrays\n@return The smallest length found in any of the sequences\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def SmallestListLength (s : Array (Array Int)) : Int :=\nsorry", "vc-theorems": "theorem SmallestListLength_spec (s : Array (Array Int)) :\ns.size > 0 →\n(∀ i, 0 ≤ i ∧ i < s.size → SmallestListLength s ≤ (s[i]!).size) ∧\n(∃ i, 0 ≤ i ∧ i < s.size ∧ SmallestListLength s = (s[i]!).size) :=\nsorry", "vc-postamble": ""}
{"id": "dafny_examples_tmp_tmp8qotd4ez_leetcode_0001-two-sum_TwoSum", "vc-description": "/- \n{\n\"name\": \"dafny_examples_tmp_tmp8qotd4ez_leetcode_0001-two-sum_TwoSum\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny_examples_tmp_tmp8qotd4ez_leetcode_0001-two-sum_TwoSum\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nTwoSum function that finds two numbers in an array that sum to target.\nReturns indices of the two numbers.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def TwoSum (nums : Array Int) (target : Int) : Int × Int :=\nsorry", "vc-theorems": "theorem TwoSum_spec (nums : Array Int) (target : Int) :\nlet r := TwoSum nums target\n(0 ≤ r.1 →\n(0 ≤ r.1 ∧ r.1 < r.2 ∧ r.2 < nums.size ∧\nnums[r.1.toNat]! + nums[r.2.toNat]! = target ∧\n(∀ i j, 0 ≤ i ∧ i < j ∧ j < r.2 → nums[i.toNat]! + nums[j.toNat]! ≠ target))) ∧\n(r.1 = -1 ↔\n(∀ i j, 0 ≤ i ∧ i < j ∧ j < nums.size → nums[i]! + nums[j]! ≠ target)) :=\nsorry", "vc-postamble": ""}
{"id": "dafny_examples_tmp_tmp8qotd4ez_leetcode_0027-remove-element_RemoveElement", "vc-description": "/- \n{\n\"name\": \"dafny_examples_tmp_tmp8qotd4ez_leetcode_0027-remove-element_RemoveElement\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny_examples_tmp_tmp8qotd4ez_leetcode_0027-remove-element_RemoveElement\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nTranslates the RemoveElement method from Dafny.\nOriginal ensures conditions:\n- 0 ≤ newLength ≤ nums.Length\n- All elements in nums are not equal to val\n- Multiset of nums equals original multiset with val removed\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def RemoveElement (nums : Array Int) (val : Int) : Int :=\nsorry", "vc-theorems": "theorem RemoveElement_spec (nums : Array Int) (val : Int) :\nlet newLength := RemoveElement nums val\n0 ≤ newLength ∧ newLength ≤ nums.size :=\nsorry", "vc-postamble": ""}
{"id": "dafny_examples_tmp_tmp8qotd4ez_leetcode_0069-sqrt_mySqrt", "vc-description": "/- \n{\n\"name\": \"dafny_examples_tmp_tmp8qotd4ez_leetcode_0069-sqrt_mySqrt\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny_examples_tmp_tmp8qotd4ez_leetcode_0069-sqrt_mySqrt\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nPredicate defining when r is the integer square root of x:\nr*r ≤ x and (r+1)*(r+1) > x\n-/\n\n/- \nComputes the integer square root of a non-negative number x.\nReturns r such that r*r ≤ x < (r+1)*(r+1)\n\n@param x The input non-negative integer\n@return The integer square root of x\n-/", "vc-preamble": "def sqrt (x : Int) (r : Int) : Bool :=\nr*r ≤ x ∧ (r+1)*(r+1) > x", "vc-helpers": "", "vc-definitions": "def mySqrt (x : Int) : Int :=\nsorry", "vc-theorems": "theorem mySqrt_spec (x : Int) :\nx ≥ 0 → sqrt x (mySqrt x) :=\nsorry", "vc-postamble": ""}
{"id": "dafny_examples_tmp_tmp8qotd4ez_leetcode_0070-climbing-stairs_ClimbStairs", "vc-description": "/- \n{\n\"name\": \"dafny_examples_tmp_tmp8qotd4ez_leetcode_0070-climbing-stairs_ClimbStairs\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny_examples_tmp_tmp8qotd4ez_leetcode_0070-climbing-stairs_ClimbStairs\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nRecursive function that calculates number of ways to climb n stairs.\nTakes one step or two steps at a time.\n-/\n\n/- \nMain climbing stairs function that returns number of ways to climb n stairs.\nEnsures result matches recursive Stairs function.\n-/", "vc-preamble": "def Stairs (n : Nat) : Nat :=\nif n ≤ 1 then 1 else Stairs (n - 2) + Stairs (n - 1)", "vc-helpers": "", "vc-definitions": "def ClimbStairs (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem ClimbStairs_spec (n : Nat) :\nClimbStairs n = Stairs n :=\nsorry", "vc-postamble": ""}
{"id": "dafny_examples_tmp_tmp8qotd4ez_test_shuffle_getRandomDataEntry", "vc-description": "/- \n{\n\"name\": \"dafny_examples_tmp_tmp8qotd4ez_test_shuffle_getRandomDataEntry\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny_examples_tmp_tmp8qotd4ez_test_shuffle_getRandomDataEntry\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Random number generator function translated from Dafny -/\n\n/-  Specification for random function -/\n\n/-  Convert sequence to set, translated from Dafny -/\n\n/-  Get random data entry from array avoiding certain values -/\n\n/-  Specification for getRandomDataEntry -/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def random (a b : Int) : Int :=\nsorry\n\ndef set_of_seq {T} (s : Array T) : List T :=\nsorry\n\ndef getRandomDataEntry {T}  (m_workList : Array T) (avoidSet : Array T) : T :=\nsorry", "vc-theorems": "theorem random_spec (a b : Int) :\na ≤ b → (a ≤ random a b ∧ random a b ≤ b) :=\nsorry\n\ntheorem getRandomDataEntry_spec {T}  (m_workList : Array T) (avoidSet : Array T) :\nm_workList.size > 0 →\n(∀ x, x ∈ set_of_seq avoidSet → x ∈ set_of_seq m_workList →\ngetRandomDataEntry m_workList avoidSet ∉ set_of_seq avoidSet) ∧\n(∀ x, x ∈ avoidSet → x ∈ m_workList →\ngetRandomDataEntry m_workList avoidSet ∈ m_workList) :=\nsorry", "vc-postamble": ""}
{"id": "dafny_examples_tmp_tmp8qotd4ez_test_shuffle_swap", "vc-description": "/- \n{\n\"name\": \"dafny_examples_tmp_tmp8qotd4ez_test_shuffle_swap\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny_examples_tmp_tmp8qotd4ez_test_shuffle_swap\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nConverts a sequence to a set\n-/\n\n/- \nSwaps two elements in an array.\n\nParameters:\n- a: The array to modify\n- i: First index\n- j: Second index\n\nRequires:\n- i and j are valid indices in the array\n\nEnsures:\n- Elements at i and j are swapped\n- All other elements remain unchanged\n- Multiset of elements is preserved\n-/\n\n/- \nSpecification for swap operation\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def set_of_seq {T : Type} [Inhabited T] (s : Array T) : List T :=\nsorry\n\ndef swap {T : Type} [Inhabited T] (a : Array T) (i j : Int) : Array T :=\nsorry", "vc-theorems": "theorem swap_spec {T : Type} [Inhabited T] (a : Array T) (i j : Int) :\n0 ≤ i ∧ i < a.size ∧ 0 ≤ j ∧ j < a.size →\nlet result := swap a i j\nresult[i.toNat]! = a[j.toNat]! ∧\nresult[j.toNat]! = a[i.toNat]! ∧\n(∀ m : Nat, m < a.size ∧ m ≠ i.toNat ∧ m ≠ j.toNat → result[m]! = a[m]!) :=\nsorry", "vc-postamble": ""}
{"id": "dafny_misc_tmp_tmpg4vzlnm1_rosetta_code_factorial_IterativeFactorial", "vc-description": "/- \n{\n\"name\": \"dafny_misc_tmp_tmpg4vzlnm1_rosetta_code_factorial_IterativeFactorial\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny_misc_tmp_tmpg4vzlnm1_rosetta_code_factorial_IterativeFactorial\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nRecursive definition of factorial function\n-/\n\n/- \nIterative implementation of factorial with specification\n-/", "vc-preamble": "def Factorial (n : Nat) : Nat :=\nif n = 0 then 1 else n * Factorial (n - 1)", "vc-helpers": "", "vc-definitions": "def IterativeFactorial (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem IterativeFactorial_spec (n : Nat) :\nIterativeFactorial n = Factorial n :=\nsorry", "vc-postamble": ""}
{"id": "dafny_misc_tmp_tmpg4vzlnm1_rosetta_code_fibonacci_sequence_FibonacciIterative", "vc-description": "/- \n{\n\"name\": \"dafny_misc_tmp_tmpg4vzlnm1_rosetta_code_fibonacci_sequence_FibonacciIterative\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny_misc_tmp_tmpg4vzlnm1_rosetta_code_fibonacci_sequence_FibonacciIterative\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nRecursive definition of Fibonacci numbers\n-/\n\n/- \nIterative calculation of Fibonacci numbers.\nEnsures the result matches the recursive definition.\n-/", "vc-preamble": "def Fibonacci : Nat → Nat\n| 0 => 0\n| 1 => 1\n| n + 2 => Fibonacci (n + 1) + Fibonacci n", "vc-helpers": "", "vc-definitions": "def FibonacciIterative (n : Nat) : Nat :=\nsorry", "vc-theorems": "theorem fibonacci_iterative_spec (n : Nat) :\nFibonacciIterative n = Fibonacci n :=\nsorry", "vc-postamble": ""}
{"id": "dafny_projects_tmp_tmpjutqwjv4_tutorial_tutorial_Find", "vc-description": "/- \n{\n\"name\": \"dafny_projects_tmp_tmpjutqwjv4_tutorial_tutorial_Find\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny_projects_tmp_tmpjutqwjv4_tutorial_tutorial_Find\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Fibonacci function translated from Dafny -/\n\n/-  Sorted predicate for arrays -/\n\n/-  Update function for sequences -/\n\n/-  Count function for boolean sequences -/\n\n/-  Node class representation -/\n\n/-  Closed predicate for graph -/\n\n/-  Path predicate for sequences of nodes -/\n\n/-  PathSpecific predicate for node paths -/\n\n/-  Find method translated from Dafny -/\n\n/-  Specification for Find method -/", "vc-preamble": "def fib (n : Nat) : Nat :=\nif n = 0 then 0\nelse if n = 1 then 1\nelse fib (n - 1) + fib (n - 2)\n\ndef sorted (a : Array Int) : Prop :=\n∀ n m, 0 ≤ n → n < m → m < a.size → a[n]! ≤ a[m]!\n\npartial def count (a : Array Bool) : Nat :=\nif a.size = 0 then 0\nelse (if a[0]! then 1 else 0) + count (a.extract 1 a.size)\n\nstructure Node where\nnext : Array Node\nderiving Inhabited\n\ndef closed (graph : List Node) : Prop :=\n∀ i, i ∈ graph → ∀ k, 0 ≤ k ∧ k < i.next.size → i.next[k]! ∈ graph ∧ i.next[k]! ≠ i", "vc-helpers": "", "vc-definitions": "def update (s : Array Int) (i : Int) (v : Int) : Array Int :=\nsorry\n\ndef path (p : Array Node) (graph : List Node) : Prop :=\nsorry\n\ndef pathSpecific (p : Array Node) (start : Node) (end_ : Node) (graph : List Node) : Prop :=\nsorry\n\ndef Find (a : Array Int) (key : Int) : Int :=\nsorry", "vc-theorems": "theorem update_spec (s : Array Int) (i : Nat) (v : Int) :\n0 ≤ i ∧ i < s.size →\nupdate s i v = s.set! i v :=\nsorry\n\ntheorem Find_spec (a : Array Int) (key : Int) :\nlet index := Find a key\n(0 ≤ index → index < a.size ∧ a[index.toNat]! = key) ∧\n(index < 0 → (∀ k, 0 ≤ k ∧ k < a.size → a[k]! ≠ key)) :=\nsorry", "vc-postamble": ""}
{"id": "dafny_projects_tmp_tmpjutqwjv4_tutorial_tutorial_FindZero", "vc-description": "/- \n{\n\"name\": \"dafny_projects_tmp_tmpjutqwjv4_tutorial_tutorial_FindZero\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny_projects_tmp_tmpjutqwjv4_tutorial_tutorial_FindZero\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Fibonacci function translated from Dafny -/\n\n/-  Sorted predicate for arrays -/\n\n/-  Update function for sequences -/\n\n/-  Count function for boolean sequences -/\n\n/-  Node class representation -/\n\n/-  Closed predicate for graph -/\n\n/-  Path predicate -/\n\n/-  PathSpecific predicate -/\n\n/-  FindZero method specification -/", "vc-preamble": "def fib (n : Nat) : Nat :=\nif n = 0 then 0\nelse if n = 1 then 1\nelse fib (n - 1) + fib (n - 2)\n\ndef sorted (a : Array Int) : Prop :=\n∀ n m, 0 ≤ n → n < m → m < a.size → a[n]! ≤ a[m]!\n\npartial def count (a : Array Bool) : Nat :=\nif a.size = 0 then 0\nelse (if a[0]! then 1 else 0) + count (a.extract 1 a.size)\n\nstructure Node where\nnext : Array Node\nderiving Inhabited\n\ndef closed (graph : List Node) : Prop :=\n∀ i, i ∈ graph → ∀ k, 0 ≤ k ∧ k < i.next.size → i.next[k]! ∈ graph ∧ i.next[k]! ≠ i", "vc-helpers": "", "vc-definitions": "def update (s : Array Int) (i : Int) (v : Int) : Array Int :=\nsorry\n\ndef path (p : Array Node) (graph : List Node) : Bool :=\nsorry\n\ndef pathSpecific (p : Array Node) (start end_ : Node) (graph : List Node) : Bool :=\nsorry\n\ndef FindZero (a : Array Int) : Int :=\nsorry", "vc-theorems": "theorem update_spec (s : Array Int) (i : Nat) (v : Int) :\n0 ≤ i ∧ i < s.size →\nupdate s i v = s.set! i v :=\nsorry\n\ntheorem FindZero_spec (a : Array Int) (index : Int) :\n(∀ i, 0 ≤ i → i < a.size → 0 ≤ a[i]!) →\n(∀ i, 0 < i → i < a.size → a[i-1]! - 1 ≤ a[i]!) →\n((index < 0 → ∀ i, 0 ≤ i → i < a.size → a[i]! ≠ 0) ∧\n(0 ≤ index → index < a.size ∧ a[index.toNat]! = 0)) :=\nsorry", "vc-postamble": ""}
{"id": "dafny_tmp_tmp49a6ihvk_m4_DutchFlag", "vc-description": "/- \n{\n\"name\": \"dafny_tmp_tmp49a6ihvk_m4_DutchFlag\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny_tmp_tmp49a6ihvk_m4_DutchFlag\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Represents the three colors in the Dutch flag -/\n\n/-  Predicate indicating if one color should be below another in the sorted order -/\n\n/-  Main Dutch flag sorting specification -/", "vc-preamble": "inductive Color where\n| Red : Color\n| White : Color\n| Blue : Color\nderiving Repr, BEq, Inhabited\ndef Below (c d : Color) : Bool :=\nmatch c, d with\n| Color.Red, _ => true\n| _, Color.Blue => true\n| c1, c2 => c1 == c2", "vc-helpers": "", "vc-definitions": "def DutchFlag (a : Array Color) : Array Color :=\nsorry", "vc-theorems": "theorem DutchFlag_spec (a : Array Color) :\nlet result := DutchFlag a\n\n-- Colors are properly ordered\n\n(∀ i j, 0 ≤ i → i < j → j < result.size → Below (result[i]!) (result[j]!)) ∧\n\n-- Array contents are preserved (multiset equality)\n\n(result.toList = a.toList) :=\nsorry", "vc-postamble": ""}
{"id": "dafny_tmp_tmp59p638nn_examples_SelectionSort_SelectionSort", "vc-description": "/- \n{\n\"name\": \"dafny_tmp_tmp59p638nn_examples_SelectionSort_SelectionSort\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny_tmp_tmp59p638nn_examples_SelectionSort_SelectionSort\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nPredicate indicating that array elements in range [left,right) are preserved\nbetween old and new states\n-/\n\n/- \nPredicate indicating array elements in range [left,right) are ordered\n-/\n\n/- \nPredicate indicating array is sorted and preserves elements\n-/\n\n/- \nSelection sort implementation specification\n-/", "vc-preamble": "def Preserved (a : Array Int) (old_a : Array Int) (left : Nat) (right : Nat) : Prop :=\nleft ≤ right ∧ right ≤ a.size ∧\n(∀ i, left ≤ i ∧ i < right → a[i]! = old_a[i]!)\ndef Ordered (a : Array Int) (left : Nat) (right : Nat) : Prop :=\nleft ≤ right ∧ right ≤ a.size ∧\n(∀ i, 0 < left ∧ left ≤ i ∧ i < right → a[i-1]! ≤ a[i]!)\ndef Sorted (a : Array Int) (old_a : Array Int) : Prop :=\nOrdered a 0 a.size ∧ Preserved a old_a 0 a.size", "vc-helpers": "", "vc-definitions": "def SelectionSort (a : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem SelectionSort_spec (a : Array Int) :\nlet result := SelectionSort a\nSorted result a :=\nsorry", "vc-postamble": ""}
{"id": "dafny_tmp_tmp59p638nn_examples_SelectionSort_SelectionnSort", "vc-description": "/- \n{\n\"name\": \"dafny_tmp_tmp59p638nn_examples_SelectionSort_SelectionnSort\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny_tmp_tmp59p638nn_examples_SelectionSort_SelectionnSort\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nPredicate indicating that array elements in range [left,right) are preserved\nbetween old and new states\n-/\n\n/- \nPredicate indicating array elements in range [left,right) are ordered\n-/\n\n/- \nPredicate indicating array is sorted and elements are preserved\n-/\n\n/- \nSelection sort implementation and specification\n-/", "vc-preamble": "def Preserved (a : Array Int) (old_a : Array Int) (left right : Nat) : Prop :=\nleft ≤ right ∧ right ≤ a.size ∧\n∀ i, left ≤ i ∧ i < right → a[i]! = old_a[i]!\ndef Ordered (a : Array Int) (left right : Nat) : Prop :=\nleft ≤ right ∧ right ≤ a.size ∧\n∀ i, 0 < left ∧ left ≤ i ∧ i < right →\na[i-1]! ≤ a[i]!\ndef Sorted (a : Array Int) (old_a : Array Int) : Prop :=\nOrdered a 0 a.size ∧ Preserved a old_a 0 a.size", "vc-helpers": "", "vc-definitions": "def SelectionnSort (a : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem SelectionnSort_spec (a : Array Int) :\nSorted (SelectionnSort a) a :=\nsorry", "vc-postamble": ""}
{"id": "dafny_tmp_tmp59p638nn_examples_realExponent_pow", "vc-description": "/- \n{\n\"name\": \"dafny_tmp_tmp59p638nn_examples_realExponent_pow\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: dafny_tmp_tmp59p638nn_examples_realExponent_pow\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nGhost function representing mathematical power operation.\nRequires both inputs to be positive.\nEnsures result is positive.\n-/\n\n/- \nSpecification for power function\n-/\n\n/- \nGhost function representing mathematical logarithm.\nRequires both inputs to be positive.\nEnsures result is positive.\n-/\n\n/- \nSpecification for log function\n-/\n\n/- \nMethod to compute power of a natural number raised to a real exponent.\nRequires positive inputs.\nEnsures result matches mathematical power function.\n-/\n\n/- \nSpecification for pow method\n-/", "vc-preamble": "noncomputable def power (n : Nat) (alpha : Float ) : Float :=\nsorry\n\nnoncomputable def log (n : Nat) (alpha : Float) : Float :=\nsorry\n\nnoncomputable def pow (n : Nat) (alpha : Float) : Float :=\nsorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "theorem power_spec (n : Nat) (alpha : Float) :\nn > 0 ∧ alpha > 0 → power n alpha > 0 :=\nsorry\n\ntheorem log_spec (n : Nat) (alpha : Float) :\nn > 0 ∧ alpha > 0 → log n alpha > 0 :=\nsorry\n\ntheorem pow_spec (n : Nat) (alpha : Float) :\nn > 0 ∧ alpha > 0 → pow n alpha = power (n) alpha :=\nsorry", "vc-postamble": ""}
{"id": "feup-mfes_tmp_tmp6_a1y5a5_examples_SelectionSort_findMin", "vc-description": "/- \n{\n\"name\": \"feup-mfes_tmp_tmp6_a1y5a5_examples_SelectionSort_findMin\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: feup-mfes_tmp_tmp6_a1y5a5_examples_SelectionSort_findMin\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nPredicate checking if array is sorted between positions 'from' (inclusive) and 'to' (exclusive)\n-/\n\n/- \nFinds minimum value position in non-empty subarray between positions 'from' (inclusive) and 'to' (exclusive)\n-/", "vc-preamble": "def isSorted (a : Array Float) (_from : Nat) (to : Nat) : Prop :=\n∀ i j, _from ≤ i → i < j → j < to → a[i]! ≤ a[j]!", "vc-helpers": "", "vc-definitions": "def findMin (a : Array Float) (_from : Nat) (to : Nat) : Nat :=\nsorry", "vc-theorems": "theorem findMin_spec (a : Array Float) (_from : Nat) (to : Nat) :\n(0 ≤ _from ∧ _from < to ∧ to ≤ a.size) →\nlet index := findMin a _from to\n(_from ≤ index ∧ index < to) ∧\n(∀ k, _from ≤ k ∧ k < to → a[k]! ≥ a[index]!) :=\nsorry", "vc-postamble": ""}
{"id": "feup-mfes_tmp_tmp6_a1y5a5_examples_SelectionSort_selectionSort", "vc-description": "/- \n{\n\"name\": \"feup-mfes_tmp_tmp6_a1y5a5_examples_SelectionSort_selectionSort\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: feup-mfes_tmp_tmp6_a1y5a5_examples_SelectionSort_selectionSort\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nPredicate checking if array is sorted between positions 'from' (inclusive) and 'to' (exclusive)\n-/\n\n/- \nFinds minimum value position in array between 'from' (inclusive) and 'to' (exclusive)\n-/\n\n/- \nSpecification for findMin method\n-/\n\n/- \nSelection sort implementation\n-/\n\n/- \nSpecification for selectionSort method\n-/", "vc-preamble": "def isSorted (a : Array Float) (_from : Nat) (to : Nat) : Prop :=\n0 ≤ _from ∧ _from ≤ to ∧ to ≤ a.size ∧\n∀ i j, _from ≤ i ∧ i < j ∧ j < to → a[i]! ≤ a[j]!", "vc-helpers": "", "vc-definitions": "def findMin (a : Array Float) (_from : Nat) (to : Nat) : Nat :=\nsorry\n\ndef selectionSort (a : Array Float) : Array Float :=\nsorry", "vc-theorems": "theorem findMin_spec (a : Array Float) (_from : Nat) (to : Nat) :\n0 ≤ _from ∧ _from < to ∧ to ≤ a.size →\nlet index := findMin a _from to\n_from ≤ index ∧ index < to ∧\n∀ k, _from ≤ k ∧ k < to → a[k]! ≥ a[index]! :=\nsorry\n\ntheorem selectionSort_spec (a : Array Float) :\nlet result := selectionSort a\nisSorted result 0 result.size ∧\n\n-- Note: multiset equality check simplified since complex array ops not supported\n\nresult.size = a.size :=\nsorry", "vc-postamble": ""}
{"id": "formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_DivMod1", "vc-description": "/- \n{\n\"name\": \"formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_DivMod1\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_DivMod1\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nRecursive function to calculate sum of squares from 0 to n\n-/\n\n/- \nLemma showing that SqrSumRec equals the closed form n(n+1)(2n+1)/6\n-/\n\n/- \nMethod to compute quotient and remainder of division\nTranslated from Dafny method DivMod1\n-/\n\n/- \nSpecification for DivMod1 method\n-/", "vc-preamble": "partial def SqrSumRec (n : Int) : Int :=\nif n == 0 then 0 else n*n + SqrSumRec (n-1)", "vc-helpers": "", "vc-definitions": "def DivMod1 (a : Int) (b : Int) : Int × Int :=\nsorry", "vc-theorems": "theorem L1_spec (n : Int) :\nn ≥ 0 → SqrSumRec n = n * (n + 1) * (2 * n + 1) / 6 :=\nsorry\n\ntheorem DivMod1_spec (a b : Int) :\nb > 0 ∧ a ≥ 0 →\nlet (q, r) := DivMod1 a b\na = b*q + r ∧ 0 ≤ r ∧ r < b :=\nsorry", "vc-postamble": ""}
{"id": "formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_HoareTripleReqEns", "vc-description": "/- \n{\n\"name\": \"formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_HoareTripleReqEns\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_HoareTripleReqEns\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Recursive function to calculate sum of squares up to n -/\n\n/-  Specification for SqrSumRec -/\n\n/-  Main method specification translated from Dafny -/\n\n/-  Specification for HoareTripleReqEns -/", "vc-preamble": "partial def SqrSumRec (n : Int) : Int :=\nif n == 0 then 0\nelse n * n + SqrSumRec (n - 1)", "vc-helpers": "", "vc-definitions": "def HoareTripleReqEns (i : Int) (k : Int) : Int :=\nsorry", "vc-theorems": "theorem SqrSumRec_spec (n : Int) :\nn ≥ 0 → SqrSumRec n = n * (n + 1) * (2 * n + 1) / 6 :=\nsorry\n\ntheorem HoareTripleReqEns_spec (i k : Int) :\nk = i * i →\n∃ k', HoareTripleReqEns i k = k' ∧ k' = (i + 1) * (i + 1) :=\nsorry", "vc-postamble": ""}
{"id": "formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_SqrSum1", "vc-description": "/- \n{\n\"name\": \"formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_SqrSum1\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_SqrSum1\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nRecursive function to calculate sum of squares from 0 to n.\nTranslated from Dafny's SqrSumRec function.\n-/\n\n/- \nSpecification for SqrSumRec ensuring it equals n(n+1)(2n+1)/6\n-/\n\n/- \nMethod to calculate sum of squares.\nTranslated from Dafny's SqrSum1 method.\n-/\n\n/- \nSpecification for SqrSum1 method ensuring it matches SqrSumRec\n-/", "vc-preamble": "partial def SqrSumRec (n : Int) : Int :=\nif n == 0 then 0\nelse n * n + SqrSumRec (n - 1)", "vc-helpers": "", "vc-definitions": "def SqrSum1 (n : Int) : Int :=\nsorry", "vc-theorems": "theorem SqrSumRec_spec (n : Int) :\nn ≥ 0 → SqrSumRec n = n * (n + 1) * (2 * n + 1) / 6 :=\nsorry\n\ntheorem SqrSum1_spec (n : Int) (s : Int) :\nn ≥ 0 → s = SqrSum1 n → s = SqrSumRec n :=\nsorry", "vc-postamble": ""}
{"id": "formal-verification_tmp_tmpoepcssay_strings3_haveCommonKSubstring", "vc-description": "/- \n{\n\"name\": \"formal-verification_tmp_tmpoepcssay_strings3_haveCommonKSubstring\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: formal-verification_tmp_tmpoepcssay_strings3_haveCommonKSubstring\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate defining when one string is a prefix of another -/\n\n/-  Predicate defining when one string is not a prefix of another -/\n\n/-  Function checking if one string is a prefix of another -/\n\n/-  Specification for isPrefix -/\n\n/-  Predicate defining when one string is a substring of another -/\n\n/-  Predicate defining when one string is not a substring of another -/\n\n/-  Function checking if one string is a substring of another -/\n\n/-  Specification for isSubstring -/\n\n/-  Predicate defining when two strings have a common substring of length k -/\n\n/-  Predicate defining when two strings do not have a common substring of length k -/\n\n/-  Function checking if two strings have a common substring of length k -/\n\n/-  Specification for haveCommonKSubstring -/", "vc-preamble": "def isPrefixPred (pre str : String) : Prop :=\npre.length ≤ str.length ∧\npre = str.take pre.length\n\ndef isNotPrefixPred (pre str : String) : Prop :=\npre.length > str.length ∨\npre ≠ str.take pre.length\n\ndef isSubstringPred (sub str : String) : Prop :=\n∃ i, 0 ≤ i ∧ i ≤ str.length ∧ isPrefixPred sub (str.drop i)\n\ndef isNotSubstringPred (sub str : String) : Prop :=\n∀ i, 0 ≤ i ∧ i ≤ str.length → isNotPrefixPred sub (str.drop i)\n\ndef haveCommonKSubstringPred (k : Nat) (str1 str2 : String) : Prop :=\n∃ i1 j1, 0 ≤ i1 ∧ i1 ≤ str1.length - k ∧ j1 = i1 + k ∧\nisSubstringPred (str1.extract ⟨i1⟩ ⟨j1⟩) str2\n\ndef haveNotCommonKSubstringPred (k : Nat) (str1 str2 : String) : Prop :=\n∀ i1 j1, 0 ≤ i1 ∧ i1 ≤ str1.length - k ∧ j1 = i1 + k →\nisNotSubstringPred (str1.extract ⟨i1⟩ ⟨j1⟩) str2", "vc-helpers": "", "vc-definitions": "def isPrefix (pre str : String) : Bool :=\nsorry\n\ndef isSubstring (sub str : String) : Bool :=\nsorry\n\ndef haveCommonKSubstring (k : Nat) (str1 str2 : String) : Bool :=\nsorry", "vc-theorems": "theorem isPrefix_spec (pre str : String) :\nisPrefix pre str = false ↔ isNotPrefixPred pre str ∧\n(isPrefix pre str = true ↔ isPrefixPred pre str) :=\nsorry\n\ntheorem isSubstring_spec (sub str : String) :\nisSubstring sub str = true ↔ isSubstringPred sub str ∧\n(¬isSubstring sub str ↔ isNotSubstringPred sub str) :=\nsorry\n\ntheorem haveCommonKSubstring_spec (k : Nat) (str1 str2 : String) :\nhaveCommonKSubstring k str1 str2 = true ↔ haveCommonKSubstringPred k str1 str2 ∧\n(haveCommonKSubstring k str1 str2 = false ↔ haveNotCommonKSubstringPred k str1 str2) :=\nsorry", "vc-postamble": ""}
{"id": "formal-verification_tmp_tmpoepcssay_strings3_isPrefix", "vc-description": "/- \n{\n\"name\": \"formal-verification_tmp_tmpoepcssay_strings3_isPrefix\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: formal-verification_tmp_tmpoepcssay_strings3_isPrefix\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate defining when one string is a prefix of another -/\n\n/-  Predicate defining when one string is not a prefix of another -/\n\n/-  Predicate defining when one string is a substring of another -/\n\n/-  Predicate defining when one string is not a substring of another -/\n\n/-  Predicate defining when strings have a common substring of length k -/\n\n/-  Predicate defining when strings do not have a common substring of length k -/\n\n/-  Main isPrefix function -/", "vc-preamble": "def isPrefixPred (pre str : String) : Prop :=\n(pre.length ≤ str.length) ∧\n(pre = str.take pre.length)\ndef isNotPrefixPred (pre str : String) : Prop :=\n(pre.length > str.length) ∨\n(pre ≠ str.take pre.length)\ndef isSubstringPred (sub str : String) : Prop :=\n∃ i, 0 ≤ i ∧ i ≤ str.length ∧ isPrefixPred sub (str.drop i)\ndef isNotSubstringPred (sub str : String) : Prop :=\n∀ i, 0 ≤ i ∧ i ≤ str.length → isNotPrefixPred sub (str.drop i)\ndef haveCommonKSubstringPred (k : Nat) (str1 str2 : String) : Prop :=\n∃ i1 j1, 0 ≤ i1 ∧ i1 ≤ str1.length - k ∧ j1 = i1 + k ∧\nisSubstringPred (str1.extract ⟨i1⟩ ⟨j1⟩) str2\ndef haveNotCommonKSubstringPred (k : Nat) (str1 str2 : String) : Prop :=\n∀ i1 j1, 0 ≤ i1 ∧ i1 ≤ str1.length - k ∧ j1 = i1 + k →\nisNotSubstringPred (str1.extract ⟨i1⟩ ⟨j1⟩) str2", "vc-helpers": "", "vc-definitions": "def isPrefix (pre str : String) : Bool :=\nsorry", "vc-theorems": "theorem isPrefix_spec (pre str : String) :\n(¬isPrefix pre str ↔ isNotPrefixPred pre str) ∧\n(isPrefix pre str ↔ isPrefixPred pre str) :=\nsorry", "vc-postamble": ""}
{"id": "formal-verification_tmp_tmpoepcssay_strings3_isSubstring", "vc-description": "/- \n{\n\"name\": \"formal-verification_tmp_tmpoepcssay_strings3_isSubstring\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: formal-verification_tmp_tmpoepcssay_strings3_isSubstring\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate defining when one string is a prefix of another -/\n\n/-  Predicate defining when one string is not a prefix of another -/\n\n/-  Function checking if one string is a prefix of another -/\n\n/-  Specification for isPrefix -/\n\n/-  Predicate defining when one string is a substring of another -/\n\n/-  Predicate defining when one string is not a substring of another -/\n\n/-  Predicate defining when two strings have a common substring of length k -/\n\n/-  Predicate defining when two strings do not have a common substring of length k -/\n\n/-  Function checking if one string is a substring of another -/\n\n/-  Specification for isSubstring -/", "vc-preamble": "def isPrefixPred (pre str : String) : Prop :=\n(pre.length ≤ str.length) ∧\n(pre = str.take pre.length)\n\ndef isNotPrefixPred (pre str : String) : Prop :=\n(pre.length > str.length) ∨\n(pre ≠ str.take pre.length)\n\ndef isSubstringPred (sub str : String) : Prop :=\n∃ i, 0 ≤ i ∧ i ≤ str.length ∧ isPrefixPred sub (str.drop i)\n\ndef isNotSubstringPred (sub str : String) : Prop :=\n∀ i, 0 ≤ i ∧ i ≤ str.length → isNotPrefixPred sub (str.drop i)\n\ndef haveCommonKSubstringPred (k : Nat) (str1 str2 : String) : Prop :=\n∃ i1 j1, 0 ≤ i1 ∧ i1 ≤ str1.length - k ∧ j1 = i1 + k ∧\nisSubstringPred (str1.extract ⟨i1⟩ ⟨j1⟩) str2\n\ndef haveNotCommonKSubstringPred (k : Nat) (str1 str2 : String) : Prop :=\n∀ i1 j1, 0 ≤ i1 ∧ i1 ≤ str1.length - k ∧ j1 = i1 + k →\nisNotSubstringPred (str1.extract ⟨i1⟩ ⟨j1⟩) str2", "vc-helpers": "", "vc-definitions": "def isPrefix (pre str : String) : Bool :=\nsorry\n\ndef isSubstring (sub str : String) : Bool :=\nsorry", "vc-theorems": "theorem isPrefix_spec (pre str : String) :\n(¬isPrefix pre str ↔ isNotPrefixPred pre str) ∧\n(isPrefix pre str ↔ isPrefixPred pre str) :=\nsorry\n\ntheorem isSubstring_spec (sub str : String) :\n(isSubstring sub str ↔ isSubstringPred sub str) ∧\n(isSubstring sub str → isSubstringPred sub str) ∧\n(isSubstringPred sub str → isSubstring sub str) ∧\n(¬isSubstring sub str ↔ isNotSubstringPred sub str) :=\nsorry", "vc-postamble": ""}
{"id": "formal-verification_tmp_tmpoepcssay_strings3_maxCommonSubstringLength", "vc-description": "/- \n{\n\"name\": \"formal-verification_tmp_tmpoepcssay_strings3_maxCommonSubstringLength\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: formal-verification_tmp_tmpoepcssay_strings3_maxCommonSubstringLength\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate checking if sub is a substring of str -/\n\n/-  Predicate checking if pre is a prefix of str -/\n\n/-  Predicate checking if pre is not a prefix of str -/\n\n/-  Predicate checking if sub is a substring of str using prefix predicate -/\n\n/-  Predicate checking if sub is not a substring of str using prefix predicate -/\n\n/-  Predicate checking if strings have a common substring of length k -/\n\n/-  Predicate checking if strings do not have a common substring of length k -/\n\n/-  Function checking if strings have a common substring of length k -/\n\n/-  Specification for haveCommonKSubstring -/\n\n/-  Function finding the maximum length of common substring -/\n\n/-  Specification for maxCommonSubstringLength -/", "vc-preamble": "def isSubstring (sub str : String) : Prop :=\n∃ i, 0 ≤ i ∧ i ≤ str.length - sub.length ∧\n(str.extract ⟨i⟩ ⟨i + sub.length⟩ = sub)\n\ndef isPrefixPred (pre str : String) : Prop :=\npre.length ≤ str.length ∧\npre = str.take pre.length\n\ndef isNotPrefixPred (pre str : String) : Prop :=\npre.length > str.length ∨\npre ≠ str.take pre.length\n\ndef isSubstringPred (sub str : String) : Prop :=\n∃ i, 0 ≤ i ∧ i ≤ str.length ∧ isPrefixPred sub (str.drop i)\n\ndef isNotSubstringPred (sub str : String) : Prop :=\n∀ i, 0 ≤ i ∧ i ≤ str.length → isNotPrefixPred sub (str.drop i)\n\ndef haveCommonKSubstringPred (k : Nat) (str1 str2 : String) : Prop :=\n∃ i1 j1, 0 ≤ i1 ∧ i1 ≤ str1.length - k ∧ j1 = i1 + k ∧\nisSubstringPred (str1.extract ⟨i1⟩ ⟨j1⟩) str2\n\ndef haveNotCommonKSubstringPred (k : Nat) (str1 str2 : String) : Prop :=\n∀ i1 j1, 0 ≤ i1 ∧ i1 ≤ str1.length - k ∧ j1 = i1 + k →\nisNotSubstringPred (str1.extract ⟨i1⟩ ⟨j1⟩) str2", "vc-helpers": "", "vc-definitions": "def haveCommonKSubstring (k : Nat) (str1 str2 : String) : Bool :=\nsorry\n\ndef maxCommonSubstringLength (str1 str2 : String) : Nat :=\nsorry", "vc-theorems": "theorem haveCommonKSubstring_spec (k : Nat) (str1 str2 : String) :\nhaveCommonKSubstring k str1 str2 = true ↔ haveCommonKSubstringPred k str1 str2 :=\nsorry\n\ntheorem maxCommonSubstringLength_spec (str1 str2 : String) :\nstr1.length ≤ str2.length →\n(∀ k, maxCommonSubstringLength str1 str2 < k ∧ k ≤ str1.length →\n¬haveCommonKSubstringPred k str1 str2) ∧\nhaveCommonKSubstringPred (maxCommonSubstringLength str1 str2) str1 str2 :=\nsorry", "vc-postamble": ""}
{"id": "formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex1_PalVerify", "vc-description": "/- \n{\n\"name\": \"formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex1_PalVerify\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex1_PalVerify\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nPalVerify checks if an array of characters is a palindrome.\nA palindrome reads the same forwards and backwards.\n\n@param a The input array of characters\n@return A boolean indicating if the array is a palindrome\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def PalVerify (a : Array Char) : Bool :=\nsorry", "vc-theorems": "theorem PalVerify_spec (a : Array Char) :\nlet yn := PalVerify a\n(yn = true → ∀ i, 0 ≤ i ∧ i < a.size/2 → a[i]! = a[a.size - i - 1]!) ∧\n(yn = false → ∃ i, 0 ≤ i ∧ i < a.size/2 ∧ a[i]! ≠ a[a.size - i - 1]!) ∧\n(∀ j, 0 ≤ j ∧ j < a.size → a[j]! = a[j]!) :=\nsorry", "vc-postamble": ""}
{"id": "formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex2_Allow42", "vc-description": "/- \n{\n\"name\": \"formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex2_Allow42\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex2_Allow42\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nTranslates the Dafny Allow42 method which handles division by (42-y) with error checking.\nInput parameters:\n- x: Int - Numerator for division\n- y: Int - Value used to compute denominator (42-y)\nReturns:\n- (Int × Bool) - Tuple containing result and error flag\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Allow42 (x : Int) (y : Int) : Int × Bool :=\nsorry", "vc-theorems": "theorem Allow42_spec (x y : Int) :\nlet (z, err) := Allow42 x y\n(y ≠ 42 → z = x/(42-y) ∧ err = false) ∧\n(y = 42 → z = 0 ∧ err = true) :=\nsorry", "vc-postamble": ""}
{"id": "formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex6_BullsCows", "vc-description": "/- \n{\n\"name\": \"formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex6_BullsCows\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex6_BullsCows\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate indicating no duplicate elements in array -/\n\n/-  Recursive function counting matching elements at same positions -/\n\n/-  Specification for bulls count -/\n\n/-  Recursive function counting matching elements at different positions -/\n\n/-  Specification for cows count -/\n\n/-  Main BullsCows function specification -/", "vc-preamble": "def nomultiples (u : Array Nat) : Prop :=\n∀ j k, 0 ≤ j → j < k → k < u.size → u[j]! ≠ u[k]!\npartial def reccbull (s : Array Nat) (u : Array Nat) (i : Nat) : Nat :=\nif i == s.size then 0\nelse if s[i]! == u[i]! then reccbull s u (i + 1) + 1\nelse reccbull s u (i + 1)\ndef bullspec (s : Array Nat) (u : Array Nat) : Nat :=\nreccbull s u 0\npartial def recccow (s : Array Nat) (u : Array Nat) (i : Nat) : Nat :=\nif i == s.size then 0\nelse if s[i]! ≠ u[i]! ∧ u[i]! ∈ s.toList then recccow s u (i + 1) + 1\nelse recccow s u (i + 1)\ndef cowspec (s : Array Nat) (u : Array Nat) : Nat :=\nrecccow s u 0", "vc-helpers": "", "vc-definitions": "def BullsCows (s : Array Nat) (u : Array Nat) : (Nat × Nat) :=\nsorry", "vc-theorems": "theorem BullsCows_spec (s u : Array Nat) :\n0 < u.size →\nu.size == s.size →\ns.size ≤ 10 →\nnomultiples u →\nnomultiples s →\nlet (b, c) := BullsCows s u\nb ≥ 0 ∧ c ≥ 0 ∧\nb == bullspec s u ∧\nc == cowspec s u :=\nsorry", "vc-postamble": ""}
{"id": "formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex7_Exchanger", "vc-description": "/- \n{\n\"name\": \"formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex7_Exchanger\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex7_Exchanger\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Represents DNA bases -/\n\n/-  Exchanges elements at positions x and y in sequence s -/\n\n/-  Specification for Exchanger method -/", "vc-preamble": "inductive Bases\n| A\n| C\n| G\n| T\nderiving Repr, BEq, Inhabited\n\ndef Exchanger (s : Array Bases) (x y : Nat) : Array Bases :=\nlet temp := s[x]!\ns.set! x s[y]! |>.set! y temp", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "theorem Exchanger_spec (s : Array Bases) (x y : Nat) :\n0 < s.size ∧ x < s.size ∧ y < s.size →\nlet t := Exchanger s x y\nt.size = s.size ∧\n(∀ b : Nat, 0 ≤ b ∧ b < s.size ∧ b ≠ x ∧ b ≠ y → t[b]! == s[b]!) ∧\nt[x]! == s[y]! ∧ s[x]! == t[y]! :=\nsorry", "vc-postamble": ""}
{"id": "formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex7_Sorter", "vc-description": "/- \n{\n\"name\": \"formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex7_Sorter\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex7_Sorter\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Represents DNA bases -/\n\n/-  Defines ordering between bases -/\n\n/-  Checks if sequence is in base order -/\n\n/-  Sorts a sequence of bases -/\n\n/-  Specification for Sorter method -/", "vc-preamble": "inductive Bases\n| A\n| C\n| G\n| T\n\ndef below (first second : Bases) : Prop :=\nfirst = second ∨\nfirst = Bases.A ∨\n(first = Bases.C ∧ (second = Bases.G ∨ second = Bases.T)) ∨\n(first = Bases.G ∧ second = Bases.T) ∨\nsecond = Bases.T", "vc-helpers": "", "vc-definitions": "def bordered (s : Array Bases) : Bool :=\nsorry\n\ndef Sorter (bases : Array Bases) : Array Bases :=\nsorry", "vc-theorems": "theorem sorter_spec (bases : Array Bases) :\n0 < bases.size →\nlet sobases := Sorter bases\n(sobases.size = bases.size) ∧\nbordered sobases :=\nsorry", "vc-postamble": ""}
{"id": "llm-verified-eval_tmp_tmpd2deqn_i_dafny_0_has_close_elements", "vc-description": "/- \n{\n\"name\": \"llm-verified-eval_tmp_tmpd2deqn_i_dafny_0_has_close_elements\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: llm-verified-eval_tmp_tmpd2deqn_i_dafny_0_has_close_elements\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Absolute value function for real numbers -/\n\n/- \nChecks if array has two different elements within threshold distance.\nReturns true if there exist two different elements whose difference is less than threshold.\n-/", "vc-preamble": "def abs (x : Float) : Float :=\nif x < 0 then -x else x", "vc-helpers": "", "vc-definitions": "def has_close_elements (numbers : Array Float) (threshold : Float) : Bool :=\nsorry", "vc-theorems": "theorem has_close_elements_spec (numbers : Array Float) (threshold : Float) :\nlet result := has_close_elements numbers threshold\nresult ↔ (∃ i j : Nat,\ni < numbers.size ∧\nj < numbers.size ∧\ni ≠ j ∧\nabs (numbers[i]! - numbers[j]!) < threshold) ∧\n(result → numbers.size > 1) :=\nsorry", "vc-postamble": ""}
{"id": "llm-verified-eval_tmp_tmpd2deqn_i_dafny_161_solve", "vc-description": "/- \n{\n\"name\": \"llm-verified-eval_tmp_tmpd2deqn_i_dafny_161_solve\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: llm-verified-eval_tmp_tmpd2deqn_i_dafny_161_solve\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Checks if a character is a letter (a-z or A-Z) -/\n\n/-  Checks if first n characters of string contain no letters -/\n\n/-  Toggles case of a character between upper and lower case -/\n\n/-  Checks if one string is the reverse of another -/\n\n/-  Reverses a sequence of characters -/\n\n/-  Main solve method that either toggles case of letters or reverses string -/", "vc-preamble": "def IsLetter (c : Char) : Bool :=\n(c ≥ 'a' ∧ c ≤ 'z') ∨ (c ≥ 'A' ∧ c ≤ 'Z')\n\ndef NoLetters (s : String) (n : Nat) : Prop :=\n∀ i, 0 ≤ i ∧ i < n → ¬IsLetter (s.get ⟨i⟩)\n\ndef ToggleCase (c : Char) : Char :=\nif c ≥ 'a' ∧ c ≤ 'z' then\nChar.ofNat (Char.toNat c - Char.toNat 'a' + Char.toNat 'A')\nelse if c ≥ 'A' ∧ c ≤ 'Z' then\nChar.ofNat (Char.toNat c - Char.toNat 'A' + Char.toNat 'a')\nelse c\n\ndef isReverse (s s_prime : String) : Prop :=\n(s.length = s_prime.length) ∧\n(∀ i, 0 ≤ i ∧ i < s.length/2 → s_prime.get ⟨s.length - i - 1⟩ = s.get ⟨i⟩)", "vc-helpers": "", "vc-definitions": "def Reverse (original : Array Char) : Array Char :=\nsorry\n\ndef solve (s : String) : String :=\nsorry", "vc-theorems": "theorem NoLetters_spec (s : String) (n : Nat) :\nn ≤ s.length → NoLetters s n :=\nsorry\n\ntheorem Reverse_spec (original : Array Char) :\nlet reversed := Reverse original\nreversed.size = original.size ∧\n(∀ i, 0 ≤ i ∧ i < original.size →\nreversed[i]! = original[original.size - 1 - i]!) :=\nsorry\n\ntheorem solve_spec (s : String) :\nlet result := solve s\nresult.length = s.length ∧\n(¬NoLetters s s.length →\n(∀ i, 0 ≤ i ∧ i < s.length ∧ IsLetter (s.get ⟨i⟩) →\nresult.get ⟨i⟩ = ToggleCase (s.get ⟨i⟩)) ∧\n(∀ i, 0 ≤ i ∧ i < s.length ∧ ¬IsLetter (s.get ⟨i⟩) →\nresult.get ⟨i⟩ = s.get ⟨i⟩)) ∧\n(NoLetters s s.length → isReverse result s) :=\nsorry", "vc-postamble": ""}
{"id": "llm-verified-eval_tmp_tmpd2deqn_i_dafny_3_below_zero", "vc-description": "/- \n{\n\"name\": \"llm-verified-eval_tmp_tmpd2deqn_i_dafny_3_below_zero\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: llm-verified-eval_tmp_tmpd2deqn_i_dafny_3_below_zero\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nRecursively sums the first n elements of an array of integers.\nTranslated from Dafny's sum function.\n\n@param s The input array of integers\n@param n The number of elements to sum (must be ≤ array size)\n-/\n\n/- \nSpecification for sum function requiring n ≤ array size\n-/\n\n/- \nDetermines if there exists a prefix of the input array that sums to less than zero.\nTranslated from Dafny's below_zero method.\n\n@param ops The input array of integers\n@return True if there exists a prefix summing to less than 0\n-/\n\n/- \nSpecification for below_zero ensuring result is true iff\nthere exists a prefix that sums to less than zero\n-/", "vc-preamble": "def sum (s : Array Int) (n : Nat) : Int :=\nif s.size = 0 ∨ n = 0 then\n0\nelse\ns[0]! + sum (s.extract 1 s.size) (n-1)", "vc-helpers": "", "vc-definitions": "def below_zero (ops : Array Int) : Bool :=\nsorry", "vc-theorems": "theorem sum_spec (s : Array Int) (n : Nat) :\nn ≤ s.size → sum s n = sum s n :=\nsorry\n\ntheorem below_zero_spec (ops : Array Int) :\nbelow_zero ops = true ↔ ∃ n : Nat, n ≤ ops.size ∧ sum ops n < 0 :=\nsorry", "vc-postamble": ""}
{"id": "llm-verified-eval_tmp_tmpd2deqn_i_dafny_5_intersperse", "vc-description": "/- \n{\n\"name\": \"llm-verified-eval_tmp_tmpd2deqn_i_dafny_5_intersperse\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: llm-verified-eval_tmp_tmpd2deqn_i_dafny_5_intersperse\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nInserts a delimiter between elements of an array of integers.\n\n@param numbers The input array of integers\n@param delimiter The delimiter value to insert between elements\n@return The array with delimiters inserted between elements\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def intersperse (numbers : Array Int) (delimiter : Int) : Array Int :=\nsorry", "vc-theorems": "theorem intersperse_spec (numbers : Array Int) (delimiter : Int) :\nlet result := intersperse numbers delimiter\n(result.size = if numbers.size > 0 then 2 * numbers.size - 1 else 0) ∧\n(∀ i, 0 ≤ i ∧ i < result.size → i % 2 = 0 → result[i]! = numbers[i / 2]!) ∧\n(∀ i, 0 ≤ i ∧ i < result.size → i % 2 = 1 → result[i]! = delimiter) :=\nsorry", "vc-postamble": ""}
{"id": "llm-verified-eval_tmp_tmpd2deqn_i_dafny_9_rolling_max", "vc-description": "/- \n{\n\"name\": \"llm-verified-eval_tmp_tmpd2deqn_i_dafny_9_rolling_max\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: llm-verified-eval_tmp_tmpd2deqn_i_dafny_9_rolling_max\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nChecks if m is the maximum value in the given array of numbers.\nTranslated from Dafny function isMax.\n-/\n\n/- \nReturns an array containing the rolling maximum values.\nEach element i contains the maximum value from index 0 to i.\nTranslated from Dafny method rolling_max.\n-/", "vc-preamble": "def isMax (m : Int) (numbers : Array Int) : Prop :=\nnumbers.contains m ∧\n∀ i, 0 ≤ i ∧ i < numbers.size → numbers[i]! ≤ m", "vc-helpers": "", "vc-definitions": "def rolling_max (numbers : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem rolling_max_spec (numbers : Array Int) :\nnumbers.size > 0 →\nlet result := rolling_max numbers\nresult.size = numbers.size ∧\n∀ i, 0 < i ∧ i < result.size →\nisMax (result[i]!) (numbers.extract 0 (i + 1)) :=\nsorry", "vc-postamble": ""}
{"id": "se2011_tmp_tmp71eb82zt_ass2_ex2_SecondLargest", "vc-description": "/- \n{\n\"name\": \"se2011_tmp_tmp71eb82zt_ass2_ex2_SecondLargest\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: se2011_tmp_tmp71eb82zt_ass2_ex2_SecondLargest\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nFinds the second largest element in an array.\n\n@param a The input array of integers\n@return The second largest element in the array\n\nRequirements:\n- The array must not be empty\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def SecondLargest (a : Array Int) : Int :=\nsorry", "vc-theorems": "theorem SecondLargest_spec (a : Array Int) :\na.size > 0 →\n∃ i, 0 ≤ i ∧ i < a.size ∧\n(∀ j, 0 ≤ j ∧ j < a.size ∧ j ≠ i →\n(a[i]! ≥ a[j]!) ∧\n(SecondLargest a ≤ a[i]!) ∧\n(if a[j]! ≠ a[i]! then SecondLargest a ≥ a[j]! else SecondLargest a ≤ a[j]!)) :=\nsorry", "vc-postamble": ""}
{"id": "software_analysis_tmp_tmpmt6bo9sf_ss_find_min_index", "vc-description": "/- \n{\n\"name\": \"software_analysis_tmp_tmpmt6bo9sf_ss_find_min_index\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: software_analysis_tmp_tmpmt6bo9sf_ss_find_min_index\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Predicate indicating if a sequence is sorted in ascending order -/\n\n/-  Predicate indicating if two sequences are permutations of each other -/\n\n/-  Alternative permutation predicate using multisets -/\n\n/-  Find minimum index in array segment -/", "vc-preamble": "def is_sorted (s : Array Int) : Prop :=\n∀ i j, 0 ≤ i → i ≤ j → j < s.size → s[i]! ≤ s[j]!\ndef is_permutation (a b : Array Int) : Prop :=\na.size = b.size ∧\n((a.size = 0 ∧ b.size = 0) ∨\n∃ i j, 0 ≤ i ∧ i < a.size ∧ 0 ≤ j ∧ j < b.size ∧\na[i]! = b[j]!)\ndef is_permutation2 (a b : Array Int) : Bool :=\na.toList = b.toList", "vc-helpers": "", "vc-definitions": "def find_min_index (a : Array Int) (s : Int) (e : Int) : Int :=\nsorry", "vc-theorems": "theorem find_min_index_spec (a : Array Int) (s e min_i : Int) :\na.size > 0 →\n0 ≤ s →\ns < a.size →\ne ≤ a.size →\ne > s →\nmin_i = find_min_index a s e →\n(min_i ≥ s ∧\nmin_i < e ∧\n∀ k:Nat, s ≤ k → k < e → a[min_i.toNat]! ≤ a[k]!) :=\nsorry", "vc-postamble": ""}
{"id": "software_analysis_tmp_tmpmt6bo9sf_ss_selection_sort", "vc-description": "/- \n{\n\"name\": \"software_analysis_tmp_tmpmt6bo9sf_ss_selection_sort\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: software_analysis_tmp_tmpmt6bo9sf_ss_selection_sort\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Finds minimum index in array slice from s to e -/\n\n/-  Specification for find_min_index -/\n\n/-  Predicate indicating if array is sorted -/\n\n/-  Predicate indicating if two arrays are permutations of each other -/\n\n/-  Alternative permutation check using list -/\n\n/-  Selection sort implementation -/\n\n/-  Specification for selection_sort -/", "vc-preamble": "def is_sorted (ss : Array Int) : Prop :=\n∀ i j, 0 ≤ i ∧ i ≤ j ∧ j < ss.size → ss[i]! ≤ ss[j]!\n\ndef is_permutation (a b : Array Int) : Prop :=\na.size = b.size ∧\n(a.size = 0 ∧ b.size = 0 ∨\n∃ i j, 0 ≤ i ∧ i < a.size ∧ 0 ≤ j ∧ j < b.size ∧\na[i]! = b[j]!)\n\ndef is_permutation2 (a b : Array Int) : Prop :=\na.toList = b.toList", "vc-helpers": "", "vc-definitions": "def find_min_index (a : Array Int) (s : Int) (e : Int) : Int :=\nsorry\n\ndef selection_sort (ns : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem find_min_index_spec (a : Array Int) (s : Int) (e : Int) :\na.size > 0 ∧\n0 ≤ s ∧ s < a.size ∧\ne ≤ a.size ∧\ne > s →\nlet min_i := find_min_index a s e\nmin_i ≥ s ∧\nmin_i < e ∧\n∀ k:Nat, s ≤ k ∧ k < e → a[min_i.toNat]! ≤ a[k]! :=\nsorry\n\ntheorem selection_sort_spec (ns : Array Int) :\nns.size ≥ 0 →\nlet result := selection_sort ns\nis_sorted result ∧\nis_permutation2 ns result :=\nsorry", "vc-postamble": ""}
{"id": "t1_MF_tmp_tmpi_sqie4j_exemplos_colecoes_sequences_ex3_Delete", "vc-description": "/- \n{\n\"name\": \"t1_MF_tmp_tmpi_sqie4j_exemplos_colecoes_sequences_ex3_Delete\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: t1_MF_tmp_tmpi_sqie4j_exemplos_colecoes_sequences_ex3_Delete\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nDelete removes p characters from position at in an array of characters.\n\nParameters:\n- line: Array of characters to modify\n- l: Natural number representing valid length of line\n- at: Starting position for deletion\n- p: Number of characters to delete\n\nRequirements:\n- l must not exceed line length\n- at + p must not exceed l\n\nEnsures:\n- Characters before position 'at' remain unchanged\n- Characters after deletion are shifted left\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Delete (line : Array Char) (l _at p : Nat) : Array Char :=\nsorry", "vc-theorems": "theorem Delete_spec (line : Array Char) (l _at p : Nat) :\nl ≤ line.size →\n_at + p ≤ l →\nlet result := Delete line l _at p\n\n-- Note: Complex array slicing operations simplified to basic size properties\n\nresult.size = line.size ∧\n\n∀ i, i < _at → result[i]! = line[i]! :=\nsorry", "vc-postamble": ""}
{"id": "veri-sparse_tmp_tmp15fywna6_dafny_dspmspv_DSpMSpV", "vc-description": "/- \n{\n\"name\": \"veri-sparse_tmp_tmp15fywna6_dafny_dspmspv_DSpMSpV\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: veri-sparse_tmp_tmp15fywna6_dafny_dspmspv_DSpMSpV\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/-  Sum function for sparse vector multiplication -/\n\n/-  Minimum of two natural numbers -/\n\n/-  Predicate checking if a value is not in an array -/\n\n/-  Predicate checking if a value is not in a sequence -/\n\n/-  Find index of element in sequence -/\n\n/-  Find index of element in array -/\n\n/-  Main sparse matrix-sparse vector multiplication method -/\n\n/-  Specification for DSpMSpV -/", "vc-preamble": "def min (x : Nat) (y : Nat) : Nat :=\nif x ≤ y then x else y", "vc-helpers": "", "vc-definitions": "def sum (X_val : Array Int) (X_crd : Array Nat)\n(v_val : Array Int) (v_crd : Array Nat)\n(kX : Nat) (kV : Nat) (pX_end : Nat) (pV_end : Nat) : Int :=\nsorry\n\ndef notin (y : Nat) (x : Array Nat) : Bool :=\nsorry\n\ndef notin_seq (y : Nat) (x : Array Nat) : Bool :=\nsorry\n\ndef index_seq (x : Nat) (y : Array Nat) : Nat :=\nsorry\n\ndef index (x : Nat) (y : Array Nat) : Nat :=\nsorry\n\ndef DSpMSpV (X_val : Array Int) (X_crd : Array Nat) (X_pos : Array Nat)\n(X_crd1 : Array Nat) (X_len : Nat)\n(v_val : Array Int) (v_crd : Array Nat) : Array Int :=\nsorry", "vc-theorems": "theorem DSpMSpV_spec\n(X_val : Array Int) (X_crd : Array Nat) (X_pos : Array Nat)\n(X_crd1 : Array Nat) (X_len : Nat)\n(v_val : Array Int) (v_crd : Array Nat) :\nX_pos.size ≥ 1 ∧\nX_val.size = X_crd.size ∧\n(∀ i j, 0 ≤ i → i < j → j < X_pos.size → X_pos[i]! ≤ X_pos[j]!) ∧\n(∀ i, 0 ≤ i → i < X_pos.size → 0 ≤ X_pos[i]! → X_pos[i]! ≤ X_val.size) ∧\nX_len ≥ X_crd1.size ∧\n(∀ i, 0 ≤ i → i < X_crd1.size → X_crd1[i]! < X_len) ∧\nX_crd1.size < X_pos.size ∧\n(∀ i j, 0 ≤ i → i < j → j < X_crd1.size → X_crd1[i]! < X_crd1[j]!) ∧\nv_val.size = v_crd.size →\nlet y := DSpMSpV X_val X_crd X_pos X_crd1 X_len v_val v_crd\ny.size = X_len :=\nsorry", "vc-postamble": ""}
{"id": "veri-sparse_tmp_tmp15fywna6_dafny_spmv_SpMV", "vc-description": "/- \n{\n\"name\": \"veri-sparse_tmp_tmp15fywna6_dafny_spmv_SpMV\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: veri-sparse_tmp_tmp15fywna6_dafny_spmv_SpMV\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nRecursive sum function that computes dot product of sparse matrix row with vector.\nTranslated from Dafny's sum function.\n-/\n\n/- \nSpecification for sum function capturing array bounds and requirements\n-/\n\n/- \nSparse Matrix-Vector multiplication function translated from Dafny's SpMV method\n-/\n\n/- \nSpecification for SpMV capturing array bounds and correctness requirements\n-/", "vc-preamble": "def sum (X_val : Array Int) (X_crd : Array Nat) (v : Array Int) (b : Nat) (k : Nat) : Int :=\nif k ≤ b then\n0\nelse\nsum X_val X_crd v (b + 1) k + X_val[b]! * v[X_crd[b]!]!", "vc-helpers": "", "vc-definitions": "def SpMV (X_val : Array Int) (X_crd : Array Nat) (X_pos : Array Nat) (v : Array Int) : Array Int :=\nsorry", "vc-theorems": "theorem sum_spec (X_val : Array Int) (X_crd : Array Nat) (v : Array Int) (b k : Nat) :\nX_val.size ≥ b ∧ b ≥ 0 ∧\nk ≤ X_val.size ∧\nX_val.size = X_crd.size ∧\n(∀ i, 0 ≤ i ∧ i < X_crd.size → X_crd[i]! < v.size) →\nsum X_val X_crd v b k ≥ 0 :=\nsorry\n\ntheorem SpMV_spec (X_val : Array Int) (X_crd : Array Nat) (X_pos : Array Nat) (v : Array Int) :\nX_crd.size ≥ 1 ∧\nX_crd.size = X_val.size ∧\n(∀ i j, 0 ≤ i ∧ i < j ∧ j < X_pos.size → X_pos[i]! ≤ X_pos[j]!) ∧\n(∀ i, 0 ≤ i ∧ i < X_crd.size → X_crd[i]! < v.size) ∧\n(∀ i, 0 ≤ i ∧ i < X_pos.size → X_pos[i]! ≤ X_val.size) ∧\nX_pos.size ≥ 1 →\nlet y := SpMV X_val X_crd X_pos v\ny.size + 1 = X_pos.size ∧\n(∀ i, 0 ≤ i ∧ i < y.size → y[i]! = sum X_val X_crd v (X_pos[i]!) (X_pos[i + 1]!)) :=\nsorry", "vc-postamble": ""}
{"id": "verified-using-dafny_tmp_tmp7jatpjyn_longestZero_longestZero", "vc-description": "/- \n{\n\"name\": \"verified-using-dafny_tmp_tmp7jatpjyn_longestZero_longestZero\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: verified-using-dafny_tmp_tmp7jatpjyn_longestZero_longestZero\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nGets the size of a sequence from index i to j inclusive.\n-/\n\n/- \nFinds the longest subsequence of zeros in an array.\nReturns the size and starting position of the longest zero subsequence.\n\nParameters:\n- a: Input array of integers\n\nReturns:\n- sz: Size of longest zero subsequence\n- pos: Starting position of longest zero subsequence\n\nSpecification ensures:\n- Size and position are within array bounds\n- The subsequence contains only zeros\n- No larger subsequence exists containing only zeros\n-/", "vc-preamble": "def getSize (i j : Int) : Int :=\nj - i + 1", "vc-helpers": "", "vc-definitions": "def longestZero (a : Array Int) : Int × Int :=\nsorry", "vc-theorems": "theorem longestZero_spec (a : Array Int) :\n1 ≤ a.size →\nlet (sz, pos) := longestZero a\n0 ≤ sz ∧ sz ≤ a.size ∧\n0 ≤ pos ∧ pos < a.size ∧\npos + sz ≤ a.size ∧\n(∀ i:Nat, pos ≤ i ∧ i < pos + sz → a[i]! = 0) ∧\n(∀ i j:Nat, 0 ≤ i ∧ i < j ∧ j < a.size ∧ getSize i j > sz →\n∃ k, i ≤ k ∧ k ≤ j ∧ a[k]! ≠ 0) :=\nsorry", "vc-postamble": ""}
{"id": "vfag_tmp_tmpc29dxm1j_Verificacion_torneo_torneo", "vc-description": "/- \n{\n\"name\": \"vfag_tmp_tmpc29dxm1j_Verificacion_torneo_torneo\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: vfag_tmp_tmpc29dxm1j_Verificacion_torneo_torneo\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nTranslates the Dafny torneo method which takes an array of reals and three indices\nand returns positions of two highest values.\n\n@param valores Array of real numbers\n@param i First index\n@param j Second index\n@param k Third index\n@return Tuple of (pos_padre, pos_madre) containing indices of two highest values\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def torneo (valores : Array Float) (i j k : Int) : Int × Int :=\nsorry", "vc-theorems": "theorem torneo_spec (valores : Array Float) (i j k : Nat) :\n(valores.size ≥ 20 ∧ valores.size < 50) →\n(i ≥ 0 ∧ j ≥ 0 ∧ k ≥ 0) →\n(i < valores.size ∧ j < valores.size ∧ k < valores.size) →\n(i ≠ j ∧ j ≠ k ∧ k ≠ i) →\nlet (pos_padre, pos_madre) := torneo valores i j k\n∃ p q r,\n(p ∈ [i, j, k] ∧ q ∈ [i, j, k] ∧ r ∈ [i, j, k]) ∧\n(p ≠ q ∧ q ≠ r ∧ p ≠ r) ∧\n(valores[p]! ≥ valores[q]! ∧ valores[q]! ≥ valores[r]!) ∧\npos_padre = p ∧ pos_madre = q :=\nsorry", "vc-postamble": ""}
{"id": "vfag_tmp_tmpc29dxm1j_sumar_componentes_suma_componentes", "vc-description": "/- \n{\n\"name\": \"vfag_tmp_tmpc29dxm1j_sumar_componentes_suma_componentes\",\n\"category\": \"Dafny Translation\",\n\"description\": \"Automatically translated from Dafny specification: vfag_tmp_tmpc29dxm1j_sumar_componentes_suma_componentes\",\n\"source\": \"Dafny\",\n\"translation_date\": \"2024\",\n\"functions\": ,\n\"methods\":\n}\n-/\n\n/- \nRecursive auxiliary function that computes the sum of array elements from index n to the end.\nInput:\n- V: Array of integers\n- n: Starting index\nReturns: Sum of elements V + V + ... + V\n-/\n\n/- \nSpecification for suma_aux function:\n- Requires array to be non-null\n- Requires valid index range\n- Ensures correct summation behavior\n-/\n\n/- \nMethod that computes the sum of all array elements.\nInput:\n- V: Array of integers\nReturns: Sum of all elements in V\n-/\n\n/- \nSpecification for suma_componentes:\n- Requires array to be non-null\n- Ensures result equals suma_aux starting from index 0\n-/", "vc-preamble": "partial def suma_aux (V : Array Int) (n : Nat) : Int :=\nif n == V.size then\n0\nelse\nV[n]! + suma_aux V (n + 1)", "vc-helpers": "", "vc-definitions": "def suma_componentes (V : Array Int) : Int :=\nsorry", "vc-theorems": "theorem suma_aux_spec (V : Array Int) (n : Nat) :\n0 ≤ n ∧ n ≤ V.size →\nsuma_aux V n = if n == V.size then 0 else V[n]! + suma_aux V (n + 1) :=\nsorry\n\ntheorem suma_componentes_spec (V : Array Int) :\nsuma_componentes V = suma_aux V 0 :=\nsorry", "vc-postamble": ""}
