vc-description: |-
  /--
  -----Description-----
  The task is to determine the position of a target integer in a given array. The goal is to return the index corresponding to the first occurrence of the target value. If the target is not present in the array, the result should indicate that by returning the size of the array. This description focuses entirely on understanding the problem without specifying any particular implementation method.
  
  -----Input-----
  The input consists of:
  • a: An array of integers.
  • e: An integer representing the target to search for in the array.
  
  -----Output-----
  The output is a natural number (Nat) which is:
  • The index of the first occurrence of the target integer if found.
  • The size of the array if the target integer is not present.
  
  -----Note-----
  There are no strict preconditions on the input; the method should work correctly for any array of integers. The specification ensures that the returned index is always valid: it is either within the array bounds with a matching element or equals the array’s size if the element is absent.
  -/

vc-preamble: |-
  import Mathlib
  
  @[reducible, simp]
  def LinearSearch_precond (a : Array Int) (e : Int) : Prop :=
    True

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-signature: |-
  def LinearSearch (a : Array Int) (e : Int) (h_precond : LinearSearch_precond (a) (e)) : Nat :=

vc-implementation: |-
  -- <vc-implementation>
    let rec loop (n : Nat) : Nat :=
      if n < a.size then
        if a[n]! = e then n
        else loop (n + 1)
      else n
    loop 0
  -- </vc-implementation>

vc-condition: |-
  @[reducible, simp]
  def LinearSearch_postcond (a : Array Int) (e : Int) (result: Nat) (h_precond : LinearSearch_precond (a) (e)) :=
    result ≤ a.size ∧ (result = a.size ∨ a[result]! = e) ∧ (∀ i, i < result → a[i]! ≠ e)
  
  theorem LinearSearch_spec_satisfied (a: Array Int) (e: Int) (h_precond : LinearSearch_precond (a) (e)) :
      LinearSearch_postcond (a) (e) (LinearSearch (a) (e) h_precond) h_precond := by

vc-proof: |-
  -- <vc-proof>
    unfold LinearSearch_postcond LinearSearch
    apply And.intro
    . let aux (x : Nat) : (0 ≤ x) → (x ≤ a.size) → LinearSearch.loop a e x ≤ a.size := by
        intro hx₀ hx₁
        let nx := a.size - x
        have hn₁ : nx = a.size - x := by rfl
        have hn₂ : x = a.size - nx := by
          rw [hn₁, Nat.sub_sub_self]
          apply hx₁
        rw [hn₂]
        induction nx with
        | zero =>
          unfold LinearSearch.loop
          simp
        | succ n₁ ih =>
          by_cases hp : (a.size ≤ n₁)
          . rw [Nat.sub_eq_zero_of_le hp] at ih
            have h_tmp : a.size ≤ n₁ + 1 := Nat.le_add_right_of_le hp
            rw [Nat.sub_eq_zero_of_le h_tmp]
            exact ih
          . have hq : n₁ < a.size := Nat.not_le.mp hp
            unfold LinearSearch.loop
            simp
            split_ifs
            . simp
            . rw [Nat.sub_add_eq, Nat.sub_add_cancel]
              exact ih
              apply Nat.zero_lt_sub_of_lt
              exact hq
            simp
      have h₀ : 0 ≤ a.size := by simp
      have h_triv : 0 ≤ 0 := by simp
      exact aux 0 h_triv h₀
    . apply And.intro
      . let aux (x : Nat) : (x ≥ 0) → (x ≤ a.size) → LinearSearch.loop a e x = a.size ∨ a[LinearSearch.loop a e x]! = e := by
          intro hx₀ hx₁
          let nx := a.size - x
          have hn₁ : nx = a.size - x := by rfl
          have hn₂ : x = a.size - nx := by
            rw [hn₁, Nat.sub_sub_self]
            apply hx₁
          rw [hn₂]
          induction nx with
          | zero =>
            unfold LinearSearch.loop
            simp
          | succ n₁ ih =>
            -- Ohh boy...
            by_cases hp : (a.size ≤ n₁)
            . rw [Nat.sub_eq_zero_of_le hp] at ih
              have h_tmp : a.size ≤ n₁ + 1 := Nat.le_add_right_of_le hp
              rw [Nat.sub_eq_zero_of_le h_tmp]
              exact ih
            . have hq : n₁ < a.size := Nat.not_le.mp hp
              apply Or.elim ih -- Didn't find elem, so we're gonna also return a.size...
              . intro ih₁
                unfold LinearSearch.loop
                split_ifs
                . rename_i h₁ h₂
                  rw [h₂]
                  simp
                . rename_i ha₁ ha₂
                  rw [Nat.sub_add_eq, Nat.sub_add_cancel]
                  rw [ih₁]
                  simp
                  apply Nat.zero_lt_sub_of_lt
                  exact hq
                . rename_i h₁
                  have ha₁ := Nat.not_lt.mp h₁
                  have ha₂ := Nat.sub_le a.size (n₁ + 1)
                  have ha := Nat.eq_iff_le_and_ge.mpr ⟨ha₁, ha₂⟩
                  rw [←ha]
                  simp
              . intro ih₂
                unfold LinearSearch.loop
                split_ifs
                . rename_i h₁ h₂
                  rw [h₂]
                  simp
                . rename_i ha₁ ha₂
                  rw [Nat.sub_add_eq, Nat.sub_add_cancel]
                  rw [ih₂]
                  simp
                  apply Nat.zero_lt_sub_of_lt
                  exact hq
                . rename_i h₁
                  have ha₁ := Nat.not_lt.mp h₁
                  have ha₂ := Nat.sub_le a.size (n₁ + 1)
                  have ha := Nat.eq_iff_le_and_ge.mpr ⟨ha₁, ha₂⟩
                  rw [←ha]
                  simp
        have h₀ : 0 ≤ 0 := by simp
        have h₁ : 0 ≤ a.size := by simp
        exact aux 0 h₀ h₁
      . let aux (x : Nat) : (0 ≤ x) → (x ≤ a.size) → (∀ i, x ≤ i → i < LinearSearch.loop a e x → a[i]! ≠ e) := by
          intro hx₀ hx₁ i
          let nx := a.size - x
          have hn₁ : nx = a.size - x := by rfl
          have hn₂ : x = a.size - nx := by
            rw [hn₁, Nat.sub_sub_self]
            apply hx₁
          rw [hn₂]
          induction nx with
          | zero =>
            -- There's no such i
            unfold LinearSearch.loop
            simp
            intro hxi hi
            have h_contr := Nat.lt_of_le_of_lt hxi hi
            have h : a.size ≤ a.size := by simp
            have h : a.size - a.size < a.size - a.size := Nat.sub_lt_sub_right h h_contr
            simp at h
          | succ n ih =>
            intro hxi
            unfold LinearSearch.loop
            simp
            split_ifs
            . rename_i h₁ h₂
              intro h_contr
              have h := Nat.lt_of_le_of_lt hxi h_contr
              simp at h
            . rename_i h₁ h₂
              by_cases hp : (a.size ≤ n)
              . rw [Nat.sub_eq_zero_iff_le.mpr hp] at ih
                intro hi
                have hp₁ : a.size ≤ n + 1 := by
                  have h₁' : n ≤ n + 1 := by simp
                  exact Nat.le_trans hp h₁'
                rw [Nat.sub_eq_zero_iff_le.mpr hp₁] at hxi
                rw [Nat.sub_eq_zero_iff_le.mpr hp₁] at hi
                rw [Nat.sub_eq_zero_iff_le.mpr hp₁] at h₂
                have ih₁ := ih hxi
                simp at hi
                unfold LinearSearch.loop at ih₁
                split_ifs at ih₁
                . rename_i h₁'
                  simp at ih₁
                  exact ih₁ hi
                . rename_i h₁'
                  contradiction
              . have hq : n < a.size := Nat.not_le.mp hp
                have hq' : 1 ≤ a.size - n := by
                  have h : 0 < a.size - n := by
                    exact Nat.sub_pos_of_lt hq
                  exact Nat.one_le_iff_ne_zero.mpr (Nat.ne_zero_of_lt h)
                rw [Nat.sub_add_eq, Nat.sub_add_cancel hq']
                intro hi
                by_cases h_bounds : (a.size - n ≤ i)
                . exact ih h_bounds hi
                . have h_bounds' : ( i + 1 < a.size - n + 1) := (@Nat.add_lt_add_iff_right 1 i (a.size - n)).mpr (Nat.not_le.mp h_bounds)
                  have h := Nat.le_of_lt_add_one h_bounds'
                  apply Nat.le_sub_of_add_le at h
                  rw [← Nat.sub_add_eq] at h
                  have hi_fixed := Nat.eq_iff_le_and_ge.mpr ⟨hxi, h⟩
                  rw [hi_fixed] at h₂
                  exact h₂
            . intro h_contr
              have h := Nat.lt_of_le_of_lt hxi h_contr
              simp at h
        have h₀ : 0 ≤ a.size := by simp
        have h_triv : 0 ≤ 0 := by simp
        intro i
        have h_tmp : 0 ≤ i := Nat.zero_le i
        exact aux 0 h_triv h₀ i h_tmp
  -- </vc-proof>

vc-postamble: |-
  /-
  -- Invalid Inputs
  []
  -- Tests
  [
      {
          "input": {
              "a": "#[1, 3, 5, 7, 9]",
              "e": 5
          },
          "expected": "2",
          "unexpected": [
              "1",
              "3",
              "4"
          ]
      },
      {
          "input": {
              "a": "#[2, 4, 6, 8]",
              "e": 5
          },
          "expected": "4",
          "unexpected": [
              "1",
              "3",
              "5"
          ]
      },
      {
          "input": {
              "a": "#[5, 5, 5]",
              "e": 5
          },
          "expected": "0",
          "unexpected": [
              "1",
              "2",
              "3"
          ]
      },
      {
          "input": {
              "a": "#[10, 9, 8, 7]",
              "e": 10
          },
          "expected": "0",
          "unexpected": [
              "1",
              "2",
              "3"
          ]
      },
      {
          "input": {
              "a": "#[1, 2, 3, 3, 4]",
              "e": 3
          },
          "expected": "2",
          "unexpected": [
              "1",
              "3",
              "4"
          ]
      }
  ]
  -/

