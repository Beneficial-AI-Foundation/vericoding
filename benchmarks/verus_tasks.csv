id,language,source,source-id,source-notes,vc-description,vc-preamble,vc-helpers,vc-spec,vc-code,vc-postamble,qa-issue,qa-issue-type,qa-specs-with-default-values,qa-execs-with-bodies,qa-execs-with-ghost-types,qa-near-duplicate-group,qa-score
VA0000,verus,apps,apps_test_1,,"Given a positive integer x, find the positive integer not exceeding x that has the maximum sum of digits. 
If multiple such integers exist, return the largest one.","use vstd::prelude::*;

verus! {
spec fn int_to_digits(x: int) -> Seq<int>
  recommends x >= 0
{
  if x == 0 { seq![0] }
  else { int_to_digits_helper(x) }
}

spec fn int_to_digits_helper(x: int) -> Seq<int>
  recommends x > 0
  decreases x
{
  if x < 10 { seq![x] }
  else { int_to_digits_helper(x / 10).add(seq![x % 10]) }
}

spec fn digit_sum(digits: Seq<int>) -> int
  decreases digits.len()
{
  if digits.len() == 0 { 0 }
  else { digits[0] + digit_sum(digits.subrange(1, digits.len() as int)) }
}

spec fn valid_input(x: int) -> bool
{
  x >= 1
}

spec fn valid_result(x: int, result: int) -> bool
  recommends valid_input(x)
{
  result > 0 &&
  result <= x &&
  (forall|y: int| 1 <= y <= x ==> digit_sum(int_to_digits(y)) <= digit_sum(int_to_digits(result))) &&
  (forall|y: int| 1 <= y <= x && digit_sum(int_to_digits(y)) == digit_sum(int_to_digits(result)) ==> y <= result)
}",,"fn solve(x: i8) -> (result: i8)
  requires valid_input(x as int)
  ensures valid_result(x as int, result as int)","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0002,verus,apps,apps_test_10,,"Given a Martian year with n days and Earth-like weeks (5 work days + 2 days off),
determine the minimum and maximum possible number of days off in that year.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int) -> bool {
  n >= 1
}

spec fn min_days_off(n: int) -> int {
  let complete_weeks = n / 7;
  let remaining_days = n % 7;
  let min_additional = if remaining_days > 5 { remaining_days - 5 } else { 0 };
  2 * complete_weeks + min_additional
}

spec fn max_days_off(n: int) -> int {
  let complete_weeks = n / 7;
  let remaining_days = n % 7;
  let max_additional = if remaining_days < 2 { remaining_days } else { 2 };
  2 * complete_weeks + max_additional
}

spec fn valid_output(result: Seq<int>, n: int) -> bool {
  result.len() == 2 &&
  result[0] >= 0 && result[1] >= 0 &&
  result[0] <= result[1] &&
  result[0] <= n && result[1] <= n &&
  result[0] == min_days_off(n) &&
  result[1] == max_days_off(n)
}",,"fn solve(n: i8) -> (result: Vec<i8>)
  requires valid_input(n as int)
  ensures valid_output(result@.map(|i: int, x: i8| x as int), n as int)","{
  assume(false);
  Vec::new()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0003,verus,apps,apps_test_11,,"Given n tiles numbered 1 to n, paint tiles according to rules:
- Tile can be painted Red if divisible by a (gives p chocolates)
- Tile can be painted Blue if divisible by b (gives q chocolates)  
- If divisible by both a and b, choose the color giving more chocolates
Find the maximum total chocolates possible.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, a: int, b: int, p: int, q: int) -> bool {
  n > 0 && a > 0 && b > 0 && p > 0 && q > 0
}

spec fn gcd(a: int, b: int) -> int
  recommends a > 0 && b >= 0
  decreases b when b >= 0
{
  if b == 0 { a } else { gcd(b, a % b) }
}",,"fn solve(n: i8, a: i8, b: i8, p: i8, q: i8) -> (result: i8)
  requires valid_input(n as int, a as int, b as int, p as int, q as int)
  ensures result >= 0","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0004,verus,apps,apps_test_22,,"Check if a string is an ""s-palindrome"" - meaning it is symmetric when mirrored horizontally about its center.
Some letters are symmetric: A, H, I, M, O, o, T, U, V, v, W, w, X, x, Y
Some letters are mirror pairs: (p,q) and (b,d)
All other letters cannot form valid s-palindromes","use vstd::prelude::*;

verus! {
spec fn is_s_palindrome(s: Seq<char>) -> bool {
    let pal = seq!['A', 'H', 'I', 'M', 'O', 'o', 'T', 'U', 'V', 'v', 'W', 'w', 'X', 'x', 'Y'];
    
    forall|i: int| #![trigger s[i]] 0 <= i < s.len() ==> {
        let j = s.len() - 1 - i;
        if i >= j {
            true
        } else {
            if s[i] == s[j] {
                pal.contains(s[i])
            } else {
                (s[i] == 'p' && s[j] == 'q') || (s[i] == 'q' && s[j] == 'p') ||
                (s[i] == 'b' && s[j] == 'd') || (s[i] == 'd' && s[j] == 'b')
            }
        }
    }
}",,"fn solve(s: &str) -> (result: String)
    requires
        s@.len() >= 1,
    ensures
        result@ == seq!['T', 'A', 'K'] || result@ == seq!['N', 'I', 'E'],
        (result@ == seq!['T', 'A', 'K']) <==> is_s_palindrome(s@),","{
    assume(false);
    ""NIE"".to_string()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0005,verus,apps,apps_test_27,,"Given a string s of n lowercase Latin letters, find the minimum number of operations
to construct it starting from an empty string. Operations are: (1) add one character
to the end (unlimited use), (2) copy current string and append it to itself (at most once).","use vstd::prelude::*;

verus! {

spec fn valid_input(n: nat, s: Seq<char>) -> bool {
    s.len() == n
}

spec fn max_copy_savings(s: Seq<char>, n: nat) -> nat {
    max_copy_savings_up_to(s, n, n / 2)
}

spec fn max_copy_savings_up_to(s: Seq<char>, n: nat, limit: nat) -> nat
    decreases limit
{
    if limit == 0 { 0 }
    else {
        let i = (limit - 1) as nat;
        let current = if can_copy_at(s, n, i) { i } else { 0 };
        let prev = max_copy_savings_up_to(s, n, i);
        if current > prev { current } else { prev }
    }
}

spec fn can_copy_at(s: Seq<char>, n: nat, i: nat) -> bool {
    let prefix_len = i + 1;
    let end_pos = i + 1 + prefix_len;
    end_pos <= n && s.subrange(0, prefix_len as int) == s.subrange((i+1) as int, end_pos as int)
}",,"fn solve(n: u8, s: Vec<char>) -> (result: u8)
    requires 
        valid_input(n as nat, s@)
    ensures 
        result as nat <= n as nat,
        n == 0 ==> result == 0,
        n > 0 ==> result >= 1,
        result as nat == n as nat - max_copy_savings(s@, n as nat)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0007,verus,apps,apps_test_45,,"Given positive integers n and k, find a strictly increasing sequence of k positive integers 
that sum to n and have the maximum possible greatest common divisor (GCD). 
If no such sequence exists, return -1.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, k: int) -> bool
{
    n > 0 && k > 0
}

spec fn is_strictly_increasing(s: Seq<int>) -> bool
{
    forall|i: int| 0 <= i < s.len() - 1 ==> #[trigger] s[i] < s[i+1]
}

spec fn all_positive(s: Seq<int>) -> bool
{
    forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] > 0
}

spec fn sum_seq(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.subrange(1, s.len() as int)) }
}

spec fn valid_sequence(s: Seq<int>, n: int, k: int) -> bool
{
    s.len() == k && all_positive(s) && is_strictly_increasing(s) && sum_seq(s) == n
}

spec fn is_possible(n: int, k: int) -> bool
{
    k * (k + 1) / 2 <= n
}",,"fn solve(n: i8, k: i8) -> (result: Vec<i8>)
    requires 
        valid_input(n as int, k as int)
    ensures 
        ((result.len() == 1 && result[0] == -1) || 
         (valid_sequence(result@.map(|_i: int, x: i8| x as int), n as int, k as int))) &&
        ((result.len() == 1 && result[0] == -1) <==> !is_possible(n as int, k as int))","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0008,verus,apps,apps_test_48,,"Given an n × m multiplication table where element at row i and column j equals i·j (1-indexed),
find the k-th smallest number among all n·m elements in the table.","use vstd::prelude::*;

verus! {
spec fn count_less_value(n: int, m: int, target: int) -> int
  decreases n
{
  if n <= 0 {
    0
  } else {
    let max_j = (target - 1) / n;
    let actual_max_j = if max_j > m { m } else { max_j };
    let contribution = if actual_max_j >= 1 { actual_max_j } else { 0 };
    contribution + count_less_value(n - 1, m, target)
  }
}

spec fn count_less_or_equal_value(n: int, m: int, target: int) -> int {
  if target <= 0 {
    0
  } else if target >= n * m {
    n * m
  } else {
    count_less_value(n, m, target + 1)
  }
}

spec fn valid_input(n: int, m: int, k: int) -> bool {
  1 <= n <= 500000 && 1 <= m <= 500000 && 1 <= k <= n * m
}",,"fn solve(n: i8, m: i8, k: i8) -> (result: i8)
  requires valid_input(n as int, m as int, k as int)
  ensures 
    1 <= result as int <= (n as int) * (m as int),
    count_less_or_equal_value(n as int, m as int, result as int) >= k as int,
    result as int == 1 || count_less_or_equal_value(n as int, m as int, (result as int) - 1) < k as int","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0009,verus,apps,apps_test_50,,"You start with r bourles and no shares. There are n buying opportunities and m selling opportunities for shares. 
Find the maximum bourles you can have after trading. You can buy any number of shares at any buying price 
and sell any number of shares (up to what you own) at any selling price.","use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 && input.contains('\n' as char)
}

spec fn parse_input(input: Seq<char>) -> (int, int, int, Seq<int>, Seq<int>)
    recommends valid_input(input)
{
    (1, 1, 1, Seq::<int>::empty(), Seq::<int>::empty())
}

spec fn compute_max_bourles(r: int, s: Seq<int>, b: Seq<int>) -> int
    recommends r >= 1 && s.len() >= 1 && b.len() >= 1 &&
               (forall|i: int| 0 <= i < s.len() ==> s[i] >= 1) &&
               (forall|i: int| 0 <= i < b.len() ==> b[i] >= 1)
{
    r
}",,"fn solve(input: Vec<u8>) -> (result: Vec<u8>)
    requires input.len() > 0 && input@.contains('\n' as u8) && valid_input(input@.map(|i: int, x: u8| x as char))
    ensures result.len() > 0","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0010,verus,apps,apps_test_56,,"Simulate pouring champagne into a pyramid of glasses for t seconds.
The pyramid has n levels where level i has i glasses (1-indexed).
Each second, 1 unit is poured into the top glass. Each glass has capacity 1.
When a glass overflows, excess champagne splits equally to the two glasses below.
Count the number of completely full glasses after t seconds.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, t: int) -> bool {
    1 <= n <= 10 && 0 <= t <= 10000
}

spec fn total_glasses(n: int) -> int {
    n * (n + 1) / 2
}

spec fn valid_result(result: int, n: int, t: int) -> bool {
    result >= 0 && result <= total_glasses(n)
}

spec fn correct_for_edge_cases(result: int, n: int, t: int) -> bool {
    (t == 0 ==> result == 0) &&
    (n == 1 && t >= 1 ==> result == 1) &&
    (n == 1 && t == 0 ==> result == 0) &&
    (t >= 1 && n > 1 ==> result >= 1)
}",,"fn solve(n: i8, t: i8) -> (result: i8)
requires 
    valid_input(n as int, t as int)
ensures 
    valid_result(result as int, n as int, t as int),
    correct_for_edge_cases(result as int, n as int, t as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0011,verus,apps,apps_test_59,,"Given an array of n integers where each integer from 1 to n appears exactly once,
determine if the array can be sorted in ascending order using only allowed adjacent swaps.
You can swap elements at positions i and i+1 only if the i-th character in a given
binary string is '1'. You can perform any number of such swaps in any order.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, a: Seq<int>, p: Seq<char>) -> bool {
    n >= 2 &&
    a.len() == n &&
    p.len() == n - 1 &&
    (forall|i: int| 0 <= i < p.len() ==> #[trigger] p[i] == '0' || #[trigger] p[i] == '1') &&
    (forall|i: int| 0 <= i < a.len() ==> 1 <= #[trigger] a[i] <= n) &&
    a.to_set() =~= Set::new(|i: int| 1 <= i <= n)
}

spec fn max_up_to(a: Seq<int>, i: int) -> int
    recommends 0 <= i < a.len()
    decreases i when i >= 0
{
    if i == 0 { 
        a[0] 
    } else if i > 0 && a[i] > max_up_to(a, i-1) { 
        a[i] 
    } else if i > 0 { 
        max_up_to(a, i-1) 
    } else {
        a[0]
    }
}

spec fn can_sort(n: int, a: Seq<int>, p: Seq<char>) -> bool
    recommends valid_input(n, a, p)
{
    forall|i: int| 0 <= i < n - 1 ==> 
        (#[trigger] p[i] == '0' ==> max_up_to(a, i) <= i + 1)
}",,"fn solve(n: i8, a: Vec<i8>, p: Vec<char>) -> (result: String)
    requires
        valid_input(n as int, a@.map(|i, x| x as int), p@),
    ensures
        result@ == seq!['Y', 'E', 'S'] || result@ == seq!['N', 'O'],
        (result@ == seq!['Y', 'E', 'S']) <==> can_sort(n as int, a@.map(|i, x| x as int), p@),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0012,verus,apps,apps_test_62,,"Two players play a game on a sequence of n non-negative integers. Each player can either
reduce a single element by some value or globally reduce all elements by the minimum value.
The player who cannot make a move (all elements are 0) loses. Determine the winner assuming
both players play optimally.","use vstd::prelude::*;

verus! {
spec fn valid_input(stdin_input: Seq<char>) -> bool {
    stdin_input.len() > 0 &&
    (stdin_input[stdin_input.len() as int - 1] == '\n' || 
     !exists|i: int| 0 <= i < stdin_input.len() && stdin_input[i] == '\n')
}

spec fn valid_result(result: Seq<char>) -> bool {
    result == seq!['B','i','t','A','r','y','o'] || result == seq!['B','i','t','L','G','M']
}

spec fn game_result(stdin_input: Seq<char>) -> Seq<char>
    recommends valid_input(stdin_input)
{
    seq!['B','i','t','L','G','M']
}",,"fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(stdin_input@)
    ensures valid_result(result@)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0013,verus,apps,apps_test_65,,"Given an array of integers, find the minimum distance between any two occurrences 
of the minimum value in the array. The minimum value is guaranteed to appear at least twice.","use vstd::prelude::*;

verus! {
spec fn seq_min(s: Seq<int>) -> int 
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if s.len() == 1 {
        s[0]
    } else {
        let tail_min = seq_min(s.subrange(1, s.len() as int));
        if s[0] <= tail_min {
            s[0]
        } else {
            tail_min
        }
    }
}

spec fn valid_input(arr: Seq<int>) -> bool {
    arr.len() >= 2 && 
    exists|i: int, j: int| 0 <= i < j < arr.len() && #[trigger] arr[i] == #[trigger] arr[j] && arr[i] == seq_min(arr)
}","spec fn arr_to_seq(arr: Vec<i8>) -> Seq<int> {
    arr@.map(|i, v| v as int)
}","fn solve(arr: Vec<i8>) -> (result: u8)
    requires 
        valid_input(arr_to_seq(arr)),
    ensures 
        result > 0,
        result as int <= arr.len() - 1,
        exists|i: int, j: int| 0 <= i < j < arr.len() && #[trigger] arr_to_seq(arr)[i] == #[trigger] arr_to_seq(arr)[j] && arr_to_seq(arr)[i] == seq_min(arr_to_seq(arr)) && j - i == result as int,
        forall|i: int, j: int| 0 <= i < j < arr.len() && #[trigger] arr_to_seq(arr)[i] == #[trigger] arr_to_seq(arr)[j] && arr_to_seq(arr)[i] == seq_min(arr_to_seq(arr)) ==> j - i >= result as int,","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0014,verus,apps,apps_test_66,,"Two athletes Willman and Bolt compete in a race with step lengths w and b meters respectively.
The race distance L is chosen uniformly at random from integers 1 to t (inclusive).
Each athlete can take at most floor(L/step_length) steps, traveling floor(L/step_length) * step_length distance.
They tie when they travel the same total distance: floor(L/w) * w = floor(L/b) * b.
Find the probability that they tie, expressed as an irreducible fraction.","use vstd::prelude::*;

verus! {

spec fn abs(x: int) -> int {
    if x >= 0 { x } else { -x }
}

spec fn gcd(a: int, b: int) -> int 
    decreases (if b == 0 { 0 } else { abs(b) })
{
    if b == 0 { abs(a) } else { gcd(b, a % b) }
}

spec fn valid_input(t: int, w: int, b: int) -> bool {
    t > 0 && w > 0 && b > 0
}

spec fn valid_fraction(numerator: int, denominator: int) -> bool {
    numerator >= 0 && denominator > 0 && numerator <= denominator
}

spec fn is_irreducible_fraction(numerator: int, denominator: int) -> bool
    recommends valid_fraction(numerator, denominator)
{
    gcd(numerator, denominator) == 1
}",,"fn solve(t: u64, w: u64, b: u64) -> (result: (u64, u64))
    requires
        t > 0 && w > 0 && b > 0,
    ensures
        result.1 > 0,
        result.0 <= result.1","{
    assume(false);
    (0, 1)
}","
}

fn main() {}",0,,-1,-1,-1,,0.7
VA0016,verus,apps,apps_test_73,,"Calculate the minimum number of days needed to finish reading a book with c pages.
Day 1: Read min(v_1, v_0) pages. Day n (n >= 2): Go back l pages, then read min(v_1, v_0 + (n-1) * a) pages total.
The book is finished when the last page is read for the first time.","use vstd::prelude::*;

verus! {

spec fn compute_position(days: int, v0: int, v1: int, a: int, l: int) -> int
    decreases days
{
    if days <= 0 {
        0
    } else {
        let prev_pos = compute_position(days - 1, v0, v1, a, l);
        let after_reread = if prev_pos - l > 0 { prev_pos - l } else { 0 };
        let read_today = if v1 < v0 + a * (days - 1) { v1 } else { v0 + a * (days - 1) };
        after_reread + read_today
    }
}",,"fn solve(c: u8, v0: u8, v1: u8, a: u8, l: u8) -> (result: u8)
    requires
        1 <= c && c <= 100,
        0 <= l && l < v0 && v0 <= v1 && v1 <= 100,
        0 <= a && a <= 100
    ensures
        result >= 1,
        compute_position(result as int, v0 as int, v1 as int, a as int, l as int) >= c as int,
        forall|days: int| 1 <= days && days < result as int ==> compute_position(days, v0 as int, v1 as int, a as int, l as int) < c as int","{
    assume(false);
    1
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0017,verus,apps,apps_test_76,,"Given n commentary boxes and m delegations, make the number of boxes divisible by m at minimum cost.
You can build a box for cost a or demolish a box for cost b.
Find the minimum cost to make n divisible by m.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, m: int, a: int, b: int) -> bool {
    n >= 1 && m >= 1 && a >= 1 && b >= 1
}

spec fn min_cost_to_divisible(n: int, m: int, a: int, b: int) -> int {
    let k = n % m;
    if k * b < (m - k) * a { k * b } else { (m - k) * a }
}",,"fn solve(n: i8, m: i8, a: i8, b: i8) -> (result: i8)
    requires 
        valid_input(n as int, m as int, a as int, b as int)
    ensures 
        result as int == min_cost_to_divisible(n as int, m as int, a as int, b as int),
        result as int >= 0","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0018,verus,apps,apps_test_87,,"Given a month number and the weekday of its first day, determine how many columns 
are needed for a calendar table where each column represents one week (Monday through Sunday).
The calendar places dates sequentially and a new column is needed when transitioning 
from Sunday to Monday.","use vstd::prelude::*;

verus! {
spec fn valid_input(m: int, d: int) -> bool {
    1 <= m <= 12 && 1 <= d <= 7
}

spec fn days_in_month(m: int) -> int {
    if 1 <= m <= 12 {
        seq![31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][m-1]
    } else {
        0
    }
}

spec fn columns_needed(m: int, d: int) -> int {
    if valid_input(m, d) {
        1 + (d - 1 + days_in_month(m) - 1) / 7
    } else {
        0
    }
}",,"fn solve(m: i8, d: i8) -> (result: i8)
    requires valid_input(m as int, d as int)
    ensures result as int == columns_needed(m as int, d as int) && 4 <= result as int <= 6","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0022,verus,apps,apps_test_102,,"Convert an integer score (0 ≤ s ≤ 99) to its English word representation 
using only lowercase letters and hyphens. Numbers 0-19 have unique forms,
numbers 20-99 combine tens words with units using hyphens, multiples of 10
from 20-90 stand alone.","use vstd::prelude::*;

verus! {

spec fn valid_input(s: Seq<char>) -> bool {
    is_valid_integer_string(s) && 
    { let n = parse_integer(s); 0 <= n <= 99 }
}

spec fn correct_english_word(n: int) -> Seq<char> {
    if n == 0 { seq!['z', 'e', 'r', 'o'] }
    else if n == 1 { seq!['o', 'n', 'e'] }
    else if n == 2 { seq!['t', 'w', 'o'] }
    else if n == 3 { seq!['t', 'h', 'r', 'e', 'e'] }
    else if n == 4 { seq!['f', 'o', 'u', 'r'] }
    else if n == 5 { seq!['f', 'i', 'v', 'e'] }
    else if n == 6 { seq!['s', 'i', 'x'] }
    else if n == 7 { seq!['s', 'e', 'v', 'e', 'n'] }
    else if n == 8 { seq!['e', 'i', 'g', 'h', 't'] }
    else if n == 9 { seq!['n', 'i', 'n', 'e'] }
    else if n == 10 { seq!['t', 'e', 'n'] }
    else if n == 11 { seq!['e', 'l', 'e', 'v', 'e', 'n'] }
    else if n == 12 { seq!['t', 'w', 'e', 'l', 'v', 'e'] }
    else if n == 13 { seq!['t', 'h', 'i', 'r', 't', 'e', 'e', 'n'] }
    else if n == 14 { seq!['f', 'o', 'u', 'r', 't', 'e', 'e', 'n'] }
    else if n == 15 { seq!['f', 'i', 'f', 't', 'e', 'e', 'n'] }
    else if n == 16 { seq!['s', 'i', 'x', 't', 'e', 'e', 'n'] }
    else if n == 17 { seq!['s', 'e', 'v', 'e', 'n', 't', 'e', 'e', 'n'] }
    else if n == 18 { seq!['e', 'i', 'g', 'h', 't', 'e', 'e', 'n'] }
    else if n == 19 { seq!['n', 'i', 'n', 'e', 't', 'e', 'e', 'n'] }
    else if n == 20 { seq!['t', 'w', 'e', 'n', 't', 'y'] }
    else if n == 30 { seq!['t', 'h', 'i', 'r', 't', 'y'] }
    else if n == 40 { seq!['f', 'o', 'r', 't', 'y'] }
    else if n == 50 { seq!['f', 'i', 'f', 't', 'y'] }
    else if n == 60 { seq!['s', 'i', 'x', 't', 'y'] }
    else if n == 70 { seq!['s', 'e', 'v', 'e', 'n', 't', 'y'] }
    else if n == 80 { seq!['e', 'i', 'g', 'h', 't', 'y'] }
    else if n == 90 { seq!['n', 'i', 'n', 'e', 't', 'y'] }
    else if 21 <= n <= 29 { seq!['t', 'w', 'e', 'n', 't', 'y', '-'] + unit_word(n % 10) }
    else if 31 <= n <= 39 { seq!['t', 'h', 'i', 'r', 't', 'y', '-'] + unit_word(n % 10) }
    else if 41 <= n <= 49 { seq!['f', 'o', 'r', 't', 'y', '-'] + unit_word(n % 10) }
    else if 51 <= n <= 59 { seq!['f', 'i', 'f', 't', 'y', '-'] + unit_word(n % 10) }
    else if 61 <= n <= 69 { seq!['s', 'i', 'x', 't', 'y', '-'] + unit_word(n % 10) }
    else if 71 <= n <= 79 { seq!['s', 'e', 'v', 'e', 'n', 't', 'y', '-'] + unit_word(n % 10) }
    else if 81 <= n <= 89 { seq!['e', 'i', 'g', 'h', 't', 'y', '-'] + unit_word(n % 10) }
    else { seq!['n', 'i', 'n', 'e', 't', 'y', '-'] + unit_word(n % 10) }
}

spec fn is_valid_integer_string(s: Seq<char>) -> bool {
    (s.len() >= 1 && s.len() <= 3 && forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] && s[i] <= '9') ||
    (s.len() >= 2 && s.len() <= 4 && s[s.len() - 1] == '\n' && forall|i: int| 0 <= i < s.len() - 1 ==> '0' <= s[i] && s[i] <= '9')
}

spec fn parse_integer(s: Seq<char>) -> int {
    if s[s.len() - 1] == '\n' {
        parse_integer_helper(s.subrange(0, s.len() - 1))
    } else {
        parse_integer_helper(s)
    }
}

spec fn parse_integer_helper(s: Seq<char>) -> int {
    if s.len() == 1 {
        (s[0] as int) - ('0' as int)
    } else if s.len() == 2 {
        10 * ((s[0] as int) - ('0' as int)) + ((s[1] as int) - ('0' as int))
    } else {
        100 * ((s[0] as int) - ('0' as int)) + 10 * ((s[1] as int) - ('0' as int)) + ((s[2] as int) - ('0' as int))
    }
}

spec fn unit_word(n: int) -> Seq<char> {
    if n == 1 { seq!['o', 'n', 'e'] }
    else if n == 2 { seq!['t', 'w', 'o'] }
    else if n == 3 { seq!['t', 'h', 'r', 'e', 'e'] }
    else if n == 4 { seq!['f', 'o', 'u', 'r'] }
    else if n == 5 { seq!['f', 'i', 'v', 'e'] }
    else if n == 6 { seq!['s', 'i', 'x'] }
    else if n == 7 { seq!['s', 'e', 'v', 'e', 'n'] }
    else if n == 8 { seq!['e', 'i', 'g', 'h', 't'] }
    else if n == 9 { seq!['n', 'i', 'n', 'e'] }
    else { seq![] }
}",,"fn solve(stdin_input: &str) -> (result: String)
    requires 
        stdin_input@.len() > 0,
        valid_input(stdin_input@),
    ensures 
        result@.len() > 0,
        result@[result@.len() - 1] == '\n',
        ({
            let n = parse_integer(stdin_input@);
            result@ == correct_english_word(n) + seq!['\n']
        }),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0023,verus,apps,apps_test_106,,"Given a circular building with n entrances, m floors per entrance, and k apartments per floor,
find the minimum time to travel from apartment a to apartment b. Apartments are numbered 1 to n·m·k
sequentially. Travel costs: stairs 5s/floor, adjacent entrances 15s, elevator 10s wait + 1s/floor,
same floor 0s. Can walk around building in either direction.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, m: int, k: int, a: int, b: int) -> bool {
  n > 0 && m > 0 && k > 0 && 1 <= a <= n * m * k && 1 <= b <= n * m * k && a != b
}

spec fn get_entrance(apt: int, m: int, k: int) -> int
  recommends apt >= 1, m > 0 && k > 0
{
  (apt - 1) / (m * k)
}

spec fn get_floor(apt: int, m: int, k: int) -> int
  recommends apt >= 1, m > 0 && k > 0
{
  ((apt - 1) - get_entrance(apt, m, k) * m * k) / k
}

spec fn min_travel_time(floors: int) -> int
  recommends floors >= 0
{
  let stair_time = 5 * floors;
  let elevator_time = 10 + floors;
  if stair_time < elevator_time { stair_time } else { elevator_time }
}

spec fn min_entrance_distance(entrance_a: int, entrance_b: int, n: int) -> int
  recommends n > 0
{
  let clockwise = (entrance_b - entrance_a + n) % n;
  let counterclockwise = (entrance_a - entrance_b + n) % n;
  if clockwise <= counterclockwise { clockwise } else { counterclockwise }
}",,"fn solve(n: i8, m: i8, k: i8, a: i8, b: i8) -> (result: i8)
  requires valid_input(n as int, m as int, k as int, a as int, b as int)
  ensures result as int >= 0","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0024,verus,apps,apps_test_113,,"Find the minimum positive integer x such that x is divisible by n and x ends with k or more zeros in base 10.
A number ends with k zeros if and only if it's divisible by 10^k = 2^k × 5^k.
Algorithm: Factor out powers of 2 and 5 from n, then multiply n by additional factors needed to achieve k trailing zeros.","use vstd::prelude::*;

verus! {

spec fn power(base: int, exp: int) -> int
    decreases exp
{
    if exp <= 0 { 1 }
    else { base * power(base, exp - 1) }
}",,"fn solve(n: i8, k: i8) -> (result: i8)
    requires 
        n > 0 && k >= 0,
    ensures 
        result > 0,
        (result as int) % (n as int) == 0,
        (result as int) % power(10, k as int) == 0,
        forall|m: int| #[trigger] (m % (n as int)) == 0 && #[trigger] (m % power(10, k as int)) == 0 && m > 0 ==> (result as int) <= m,","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0026,verus,apps,apps_test_116,,"Given two time intervals [l1, r1] and [l2, r2], and a specific minute k,
find the number of minutes in the intersection of these intervals,
excluding minute k if it falls within the intersection.","use vstd::prelude::*;

verus! {

spec fn valid_input(l1: int, r1: int, l2: int, r2: int, k: int) -> bool {
    l1 <= r1 && l2 <= r2
}

spec fn intersection_left(l1: int, l2: int) -> int {
    if l1 > l2 { l1 } else { l2 }
}

spec fn intersection_right(r1: int, r2: int) -> int {
    if r1 < r2 { r1 } else { r2 }
}

spec fn intersection_size(l1: int, r1: int, l2: int, r2: int) -> int {
    let left = intersection_left(l1, l2);
    let right = intersection_right(r1, r2);
    if right - left + 1 > 0 { right - left + 1 } else { 0 }
}

spec fn k_in_intersection(l1: int, r1: int, l2: int, r2: int, k: int) -> bool {
    let left = intersection_left(l1, l2);
    let right = intersection_right(r1, r2);
    left <= k <= right
}

spec fn expected_result(l1: int, r1: int, l2: int, r2: int, k: int) -> int {
    let intersection_size_val = intersection_size(l1, r1, l2, r2);
    if k_in_intersection(l1, r1, l2, r2, k) {
        if intersection_size_val - 1 > 0 { intersection_size_val - 1 } else { 0 }
    } else {
        intersection_size_val
    }
}",,"fn solve(l1: i8, r1: i8, l2: i8, r2: i8, k: i8) -> (result: i8)
    requires 
        valid_input(l1 as int, r1 as int, l2 as int, r2 as int, k as int)
    ensures 
        result as int == expected_result(l1 as int, r1 as int, l2 as int, r2 as int, k as int),
        result >= 0","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0027,verus,apps,apps_test_125,,"Given a 4-way intersection with 4 road parts arranged counter-clockwise, determine if a traffic accident
between cars and pedestrians is possible. Each road part has 4 traffic lights: left turn (l), straight (s),
right turn (r), and pedestrian crossing (p). Each light can be red (0) or green (1). An accident is possible
if a pedestrian crossing light is green and a car light is green that allows cars to reach that crossing.","use vstd::prelude::*;

verus! {

spec fn count_newlines(s: Seq<char>, idx: int) -> int
    decreases s.len() - idx
{
    if idx >= s.len() {
        0
    } else if s[idx] == '\n' {
        1 + count_newlines(s, idx + 1)
    } else {
        count_newlines(s, idx + 1)
    }
}

spec fn valid_input_string(s: Seq<char>) -> bool {
    s.len() >= 7 &&
    contains_four_lines(s) &&
    all_lines_have_four_valid_integers(s)
}

spec fn contains_four_lines(s: Seq<char>) -> bool {
    count_newlines(s, 0) >= 3
}

spec fn all_lines_have_four_valid_integers(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1' || s[i] == ' ' || s[i] == '\n')
}

spec fn parse_input(s: Seq<char>, input_lines: Seq<Seq<int>>) -> bool {
    input_lines.len() == 4 &&
    (forall|i: int| 0 <= i < 4 ==> #[trigger] input_lines[i].len() == 4) &&
    (forall|i: int, j: int| 0 <= i < 4 && 0 <= j < 4 ==> 
        (#[trigger] input_lines[i][j] >= 0 && #[trigger] input_lines[i][j] <= 1)) &&
    string_contains_four_lines_of_four_integers(s, input_lines)
}

spec fn string_contains_four_lines_of_four_integers(s: Seq<char>, input_lines: Seq<Seq<int>>) -> bool {
    input_lines.len() == 4 &&
    (forall|i: int| 0 <= i < 4 ==> #[trigger] input_lines[i].len() == 4) &&
    valid_input_string(s)
}

spec fn accident_possible(lanes: Seq<Seq<int>>) -> bool
    recommends 
        lanes.len() == 4,
        forall|i: int| 0 <= i < 4 ==> #[trigger] lanes[i].len() == 4,
        forall|i: int, j: int| 0 <= i < 4 && 0 <= j < 4 ==> 
            (#[trigger] lanes[i][j] == 0 || #[trigger] lanes[i][j] == 1)
{
    exists|i: int| 0 <= i < 4 && accident_at_lane(i, lanes)
}

spec fn accident_at_lane(i: int, lanes: Seq<Seq<int>>) -> bool
    recommends 
        0 <= i < 4,
        lanes.len() == 4,
        forall|j: int| 0 <= j < 4 ==> #[trigger] lanes[j].len() == 4
{
    (lanes[i][3] == 1 && (lanes[i][0] == 1 || lanes[i][1] == 1 || lanes[i][2] == 1)) ||
    (lanes[i][0] == 1 && lanes[(i + 3) % 4][3] == 1) ||
    (lanes[i][1] == 1 && lanes[(i + 2) % 4][3] == 1) ||
    (lanes[i][2] == 1 && lanes[(i + 1) % 4][3] == 1)
}",,"fn solve(s: Vec<char>) -> (result: Vec<char>)
    requires 
        s.len() > 0,
        forall|i: int| 0 <= i < s.len() ==> (#[trigger] s@[i] as int >= 0 && #[trigger] s@[i] as int <= 127),
        valid_input_string(s@)
    ensures 
        result@ == ""YES\n""@ || result@ == ""NO\n""@,
        exists|input_lines: Seq<Seq<int>>| 
            parse_input(s@, input_lines) && 
            (result@ == ""YES\n""@ <==> accident_possible(input_lines)),
        result.len() >= 3","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0028,verus,apps,apps_test_126,,"Given a phone keypad layout and a phone number, determine if the finger movement 
sequence between consecutive key presses is unique (no other number produces the same sequence).
The keypad layout is: 1-2-3 in top row, 4-5-6 in middle row, 7-8-9 in bottom row, 
and 0 below 8.","use vstd::prelude::*;

verus! {
spec fn string_to_digits(s: Seq<char>) -> Set<int> {
    Set::new(|i: int| 
        0 <= i < s.len() && 
        '0' <= s[i] && 
        s[i] <= '9' && 
        (s[i] as int) - ('0' as int) >= 0
    ).map(|i: int| (s[i] as int) - ('0' as int))
}

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 && input.contains('\n')
}

spec fn has_unique_movement_sequence(digits: Set<int>) -> bool {
    (digits.contains(1) || digits.contains(4) || digits.contains(7) || digits.contains(0)) &&
    (digits.contains(1) || digits.contains(2) || digits.contains(3)) &&
    (digits.contains(3) || digits.contains(6) || digits.contains(9) || digits.contains(0)) &&
    (digits.contains(7) || digits.contains(0) || digits.contains(9))
}

spec fn find_char_index(s: Seq<char>, c: char) -> int {
    if exists|i: int| 0 <= i < s.len() && s[i] == c {
        choose|i: int| 0 <= i < s.len() && s[i] == c
    } else {
        -1
    }
}

spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>>
    decreases s.len()
{
    if !s.contains('\n') {
        seq![s]
    } else {
        let idx = find_char_index(s, '\n');
        if idx == -1 {
            seq![s]
        } else if idx < s.len() {
            seq![s.subrange(0, idx)].add(split_lines(s.subrange(idx + 1, s.len() as int)))
        } else {
            seq![s]
        }
    }
}",,"fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires 
        valid_input(input@)
    ensures 
        result@.len() == 3 || result@.len() == 4,
        result@.len() > 0,
        ({
            let lines = split_lines(input@);
            lines.len() >= 2 ==> {
                let digits_str = lines[1];
                let digits = string_to_digits(digits_str);
                has_unique_movement_sequence(digits) ==> result@.len() == 4
            }
        })","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0029,verus,apps,apps_test_128,,"Given n cows initially arranged in positions 1, 2, ..., n, find the maximum number of inversions
achievable using at most k swaps. An inversion is a pair (i,j) where i < j but the cow in 
position i has a larger label than the cow in position j.","use vstd::prelude::*;

verus! {
spec fn min(a: int, b: int) -> int {
    if a <= b { a } else { b }
}

spec fn compute_inversions(n: int, k: int, iterations: int) -> int
    decreases iterations when iterations >= 0
{
    if iterations == 0 { 0 }
    else { compute_inversions(n, k, iterations - 1) + (n - 2*(iterations-1) - 1) + (n - 2*(iterations-1) - 2) }
}

spec fn sum_inversions_formula(n: int, iterations: int) -> int
    decreases iterations when iterations >= 0
{
    if iterations == 0 { 0 }
    else { sum_inversions_formula(n, iterations - 1) + (n - 2*(iterations-1) - 1) + (n - 2*(iterations-1) - 2) }
}

spec fn sum_of_consecutive_pairs(n: int, k: int) -> int {
    let iterations = k;
    if iterations == 0 { 0 }
    else { sum_inversions_formula(n, iterations) }
}",,"fn solve(n: i8, k: i8) -> (result: i8)
    requires n as int >= 1 && k as int >= 0","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0031,verus,apps,apps_test_135,,"Given two integers n and k, determine whether all remainders n mod i for i = 1, 2, ..., k are distinct.
Specifically, check if n mod 1 = 0, n mod 2 = 1, n mod 3 = 2, ..., n mod k = k-1.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, k: int) -> bool {
    n >= 1 && k >= 1
}

spec fn all_remainders_distinct(n: int, k: int) -> bool {
    valid_input(n, k) ==> forall|i: int| 1 <= i <= k ==> #[trigger] (n % i) == (i - 1)
}

spec fn has_non_distinct_remainder(n: int, k: int) -> bool {
    valid_input(n, k) ==> exists|i: int| 1 <= i <= k && #[trigger] (n % i) != (i - 1)
}",,"fn solve(n: i8, k: i8) -> (result: String)
    requires
        valid_input(n as int, k as int),
    ensures
        result@ == seq!['Y', 'e', 's', '\n'] <==> all_remainders_distinct(n as int, k as int),
        result@ == seq!['N', 'o', '\n'] <==> has_non_distinct_remainder(n as int, k as int),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0033,verus,apps,apps_test_145,,"Given a username string containing only lowercase English letters, determine the user's gender
based on the number of distinct characters: odd count means male, even count means female.
Output ""IGNORE HIM!"" for male, ""CHAT WITH HER!"" for female.","use vstd::prelude::*;

verus! {
spec fn count_distinct(s: Seq<char>) -> int {
    s.to_set().len() as int
}

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 &&
    input[input.len() - 1] == '\n' &&
    input.len() >= 2 &&
    forall|i: int| 0 <= i < input.len() - 1 ==> 'a' <= input[i] && input[i] <= 'z'
}

spec fn correct_output(username: Seq<char>, output: Seq<char>) -> bool {
    let distinct_count = count_distinct(username);
    (distinct_count % 2 == 1 ==> output == seq!['I', 'G', 'N', 'O', 'R', 'E', ' ', 'H', 'I', 'M', '!', '\n']) &&
    (distinct_count % 2 == 0 ==> output == seq!['C', 'H', 'A', 'T', ' ', 'W', 'I', 'T', 'H', ' ', 'H', 'E', 'R', '!', '\n'])
}",,"fn solve(input: Vec<char>) -> (output: Vec<char>)
    requires valid_input(input@)
    ensures ({
        let username = input@.subrange(0, input@.len() - 1);
        correct_output(username, output@)
    })","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0034,verus,apps,apps_test_148,,"Given a circular subway with n stations, determine if two trains moving in opposite directions
will ever meet at the same station. Train 1 moves clockwise (1→2→...→n→1), Train 2 moves 
counterclockwise (n→(n-1)→...→1→n). Daniel boards Train 1 at station a, exits at x.
Vlad boards Train 2 at station b, exits at y. All a,x,b,y are distinct.","use vstd::prelude::*;
use vstd::string::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 &&
    (exists|i: int| 0 <= i < input.len() && input[i] == '\n') &&
    {
        let parts = parse_input(input);
        parts.len() == 5 &&
        parts[0] >= 4 && parts[0] <= 100 &&
        parts[1] >= 1 && parts[1] <= parts[0] &&
        parts[2] >= 1 && parts[2] <= parts[0] &&
        parts[3] >= 1 && parts[3] <= parts[0] &&
        parts[4] >= 1 && parts[4] <= parts[0] &&
        parts[1] != parts[2] && parts[1] != parts[3] && parts[1] != parts[4] &&
        parts[2] != parts[3] && parts[2] != parts[4] &&
        parts[3] != parts[4]
    }
}

spec fn trains_will_meet(input: Seq<char>) -> bool 
    recommends
        input.len() > 0,
        exists|i: int| 0 <= i < input.len() && input[i] == '\n',
        valid_input(input),
{
    let parts = parse_input(input);
    let n = parts[0];
    let a = parts[1];
    let x = parts[2];
    let b = parts[3];
    let y = parts[4];

    if a == b { true }
    else { simulate_trains(n, a, x, b, y) }
}

spec fn simulate_trains(n: int, a: int, x: int, b: int, y: int) -> bool
    recommends
        n >= 4 && 1 <= a <= n && 1 <= x <= n && 1 <= b <= n && 1 <= y <= n,
        a != x && a != b && a != y && x != b && x != y && b != y,
{
    simulate_trains_helper(n, a, x, b, y, 2 * n)
}

spec fn simulate_trains_helper(n: int, a: int, x: int, b: int, y: int, fuel: int) -> bool {
    if fuel <= 0 {
        false
    } else {
        /* Placeholder simulation logic - returns false for now */
        false
    }
}

spec fn parse_input(input: Seq<char>) -> Seq<int> {
    /* Placeholder parsing logic - returns empty sequence for now */
    seq![]
}",,"fn solve(stdin_input: Vec<u8>) -> (result: String)
    requires 
        stdin_input.len() > 0,
        exists|i: int| 0 <= i < stdin_input@.len() && stdin_input@[i] == '\n' as u8,
        valid_input(stdin_input@.map(|i, x: u8| x as char)),
    ensures
        result@ =~= seq!['Y', 'E', 'S', '\n'] || result@ =~= seq!['N', 'O', '\n'],
        result@ =~= seq!['Y', 'E', 'S', '\n'] <==> trains_will_meet(stdin_input@.map(|i, x: u8| x as char)),
        result@ =~= seq!['N', 'O', '\n'] <==> !trains_will_meet(stdin_input@.map(|i, x: u8| x as char)),","{
    // impl-start
    assume(false);
    ""NO\n"".to_string()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0036,verus,apps,apps_test_157,,"Given the number of lemons (a), apples (b), and pears (c), find the maximum total number of fruits
that can be used to make a compote following the recipe ratio of 1:2:4 (lemons:apples:pears).
Fruits must be used whole and cannot be cut or broken. If no complete recipe units can be made, output 0.","use vstd::prelude::*;

verus! {

spec fn valid_input(a: int, b: int, c: int) -> bool {
    1 <= a <= 1000 && 1 <= b <= 1000 && 1 <= c <= 1000
}

spec fn max_recipe_units(a: int, b: int, c: int) -> int {
    if a <= b / 2 && a <= c / 4 {
        a
    } else if b / 2 <= a && b / 2 <= c / 4 {
        b / 2
    } else {
        c / 4
    }
}

spec fn total_fruits_used(units: int) -> int {
    units * 7
}",,"fn solve(a: i8, b: i8, c: i8) -> (result: i8)
    requires 
        valid_input(a as int, b as int, c as int)
    ensures 
        result as int == total_fruits_used(max_recipe_units(a as int, b as int, c as int)),
        result >= 0","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0039,verus,apps,apps_test_164,,"Given a rectangular football field where Robo-Wallace is at position (x_b, y_b) with a ball of radius r,
find a point x_w on the right wall (at y = y_w) such that kicking the ball there will cause it to bounce
once and go through the goal. The goal is located at x = 0, between y-coordinates y_1 and y_2.
The ball moves in straight lines and bounces elastically off walls. A goal is scored when the ball's
center crosses the y-axis between y_1 and y_2. Output x_w if possible, otherwise -1.","use vstd::prelude::*;

verus! {

spec fn valid_input(y1: int, y2: int, y_w: int, x_b: int, y_b: int, r: int) -> bool {
    y1 < y2 < y_w &&
    y_b + r < y_w &&
    2 * r < y2 - y1 &&
    x_b > 0 && y_b > 0 && r > 0 &&
    2 * (y_w - r) - y1 - y_b - r != 0
}

spec fn compute_w(y_w: int, r: int) -> int {
    y_w - r
}

spec fn compute_new_y1(y_w: int, r: int, y1: int, y_b: int) -> int {
    2 * (y_w - r) - y1 - y_b - r
}

spec fn compute_new_y2(y_w: int, r: int, y2: int, y_b: int) -> int {
    2 * (y_w - r) - y2 - y_b
}

spec fn compute_left_side(x_b: int, new_y1: int, new_y2: int) -> int {
    x_b * x_b * (new_y2 - new_y1) * (new_y2 - new_y1)
}

spec fn compute_right_side(x_b: int, new_y1: int, r: int) -> int {
    (new_y1 * new_y1 + x_b * x_b) * r * r
}

spec fn is_impossible(y1: int, y2: int, y_w: int, x_b: int, y_b: int, r: int) -> bool
    recommends valid_input(y1, y2, y_w, x_b, y_b, r)
{
    let w = compute_w(y_w, r);
    let new_y1 = compute_new_y1(y_w, r, y1, y_b);
    let new_y2 = compute_new_y2(y_w, r, y2, y_b);
    let left_side = compute_left_side(x_b, new_y1, new_y2);
    let right_side = compute_right_side(x_b, new_y1, r);
    left_side <= right_side
}

spec fn compute_solution(y1: int, y2: int, y_w: int, x_b: int, y_b: int, r: int) -> int
    recommends 
        valid_input(y1, y2, y_w, x_b, y_b, r) &&
        !is_impossible(y1, y2, y_w, x_b, y_b, r)
{
    let w = compute_w(y_w, r);
    let new_y1 = compute_new_y1(y_w, r, y1, y_b);
    x_b * (new_y1 + y_b - w) / new_y1
}",,"fn solve(y1: i8, y2: i8, y_w: i8, x_b: i8, y_b: i8, r: i8) -> (result: i8)
    requires 
        valid_input(y1 as int, y2 as int, y_w as int, x_b as int, y_b as int, r as int)
    ensures 
        is_impossible(y1 as int, y2 as int, y_w as int, x_b as int, y_b as int, r as int) ==> result == -1,
        !is_impossible(y1 as int, y2 as int, y_w as int, x_b as int, y_b as int, r as int) ==> result as int == compute_solution(y1 as int, y2 as int, y_w as int, x_b as int, y_b as int, r as int)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0040,verus,apps,apps_test_165,,"Calculate the minimum number of meals Vasiliy could have missed during his sanatorium stay.
Given counts of breakfasts (b), dinners (d), and suppers (s) he had, determine how many meals
he definitively missed based on arrival/departure timing constraints.","use vstd::prelude::*;

verus! {
spec fn max3(a: int, b: int, c: int) -> int {
    if a >= b && a >= c { a }
    else if b >= c { b }
    else { c }
}

spec fn calculate_missed_meals(input: Seq<char>) -> int {
    /* Implementation placeholder for spec function */
    0
}

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0
}

spec fn int_to_string_spec(n: int) -> Seq<char> {
    /* Specification for integer to string conversion */
    seq![]
}",,"fn solve(input: &str) -> (result: String)
requires valid_input(input@)
ensures result@ == int_to_string_spec(calculate_missed_meals(input@))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0041,verus,apps,apps_test_171,,"Given a password string, determine if it meets complexity requirements.
A password is complex if it has at least 5 characters, contains at least
one uppercase letter, one lowercase letter, and one digit.","use vstd::prelude::*;

verus! {
spec fn contains_lowercase(s: Seq<char>) -> bool {
    exists|i: int| 0 <= i < s.len() && 'a' <= s[i] && s[i] <= 'z'
}

spec fn contains_uppercase(s: Seq<char>) -> bool {
    exists|i: int| 0 <= i < s.len() && 'A' <= s[i] && s[i] <= 'Z'
}

spec fn contains_digit(s: Seq<char>) -> bool {
    exists|i: int| 0 <= i < s.len() && '0' <= s[i] && s[i] <= '9'
}

spec fn is_valid_password(s: Seq<char>) -> bool {
    s.len() >= 5 && contains_lowercase(s) && contains_uppercase(s) && contains_digit(s)
}

spec fn trim_newline(s: Seq<char>) -> Seq<char> {
    if s.len() > 0 && s[s.len() as int - 1] == '\n' { 
        s.subrange(0, s.len() as int - 1) 
    } else { 
        s 
    }
}

spec fn strip_whitespace(s: Seq<char>) -> Seq<char>
    decreases s.len()
{
    if s.len() == 0 { 
        s
    } else if s[0] == ' ' || s[0] == '\t' || s[0] == '\n' || s[0] == '\r' {
        strip_whitespace(s.subrange(1, s.len() as int))
    } else if s[s.len() as int - 1] == ' ' || s[s.len() as int - 1] == '\t' || s[s.len() as int - 1] == '\n' || s[s.len() as int - 1] == '\r' {
        strip_whitespace(s.subrange(0, s.len() as int - 1))
    } else { 
        s 
    }
}",,"fn solve(input: Vec<char>) -> (output: Vec<char>)
    requires input@.len() > 0
    ensures ({
        let processed_input = trim_newline(input@);
        let stripped = strip_whitespace(processed_input);
        if is_valid_password(stripped) {
            output@ == seq!['C', 'o', 'r', 'r', 'e', 'c', 't', '\n']
        } else {
            output@ == seq!['T', 'o', 'o', ' ', 'w', 'e', 'a', 'k', '\n']
        }
    })","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0042,verus,apps,apps_test_173,,"Given an (n-1) × (m-1) grid of junctions formed by n horizontal streets and m vertical streets,
where each street is one-way, determine if it's possible to reach any junction from any other junction.
Input: n, m (dimensions), string of horizontal directions ('<' or '>'), string of vertical directions ('^' or 'v').
Output: ""YES"" if fully connected, ""NO"" otherwise.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, m: int, horizontal: Seq<char>, vertical: Seq<char>) -> bool {
    n >= 2 && n <= 20 && m >= 2 && m <= 20 &&
    horizontal.len() == n && vertical.len() == m &&
    (forall|c: char| horizontal.contains(c) ==> c == '<' || c == '>') &&
    (forall|c: char| vertical.contains(c) ==> c == '^' || c == 'v')
}

spec fn is_disconnected(hor: Seq<char>, ver: Seq<char>) -> bool {
    (hor.len() > 0 && ver.len() > 0 && hor[0] == '>' && ver[0] == 'v') ||
    (hor.len() > 0 && ver.len() > 0 && hor[0] == '<' && ver[ver.len()-1] == 'v') ||
    (hor.len() > 0 && ver.len() > 0 && hor[hor.len()-1] == '>' && ver[0] == '^') ||
    (hor.len() > 0 && ver.len() > 0 && hor[hor.len()-1] == '<' && ver[ver.len()-1] == '^')
}",,"fn solve(n: i8, m: i8, horizontal: Vec<char>, vertical: Vec<char>) -> (result: Vec<char>)
    requires 
        valid_input(n as int, m as int, horizontal@, vertical@)
    ensures 
        result@ == seq!['Y', 'E', 'S', '\n'] || result@ == seq!['N', 'O', '\n'],
        (result@ == seq!['N', 'O', '\n']) <==> is_disconnected(horizontal@, vertical@)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0043,verus,apps,apps_test_176,,"Count the number of integers in the range [a, b] that are divisible by k.
Given three integers k, a, b where k > 0 and a <= b, return the count of
integers x such that a <= x <= b and x % k == 0.","use vstd::prelude::*;

verus! {
spec fn valid_input(k: int, a: int, b: int) -> bool {
  k > 0 && a <= b
}

spec fn floor_div(a: int, b: int) -> int {
  if a >= 0 { a / b }
  else { (a - b + 1) / b }
}

spec fn count_divisibles_in_range(k: int, a: int, b: int) -> int {
  floor_div(b, k) - floor_div(a - 1, k)
}",,"fn solve(k: i8, a: i8, b: i8) -> (result: i8)
  requires
    valid_input(k as int, a as int, b as int),
  ensures
    result >= 0,
    result as int == count_divisibles_in_range(k as int, a as int, b as int),","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0045,verus,apps,apps_test_181,,"Given a camera rotation angle in degrees, determine the minimum number of 90-degree 
clockwise rotations needed to minimize the image's deviation from vertical orientation.
When a camera rotates by x degrees, the image appears rotated by -x degrees.","use vstd::prelude::*;

verus! {

spec fn normalize_angle(angle: int) -> int {
    let n = angle % 360;
    if n < 0 { n + 360 } else { n }
}

spec fn deviation_from_vertical(angle: int) -> int
    recommends 0 <= angle < 360
{
    if angle <= 180 { angle } else { 360 - angle }
}

spec fn image_angle_after_rotations(camera_angle: int, rotations: int) -> int
    recommends 0 <= rotations <= 3
{
    normalize_angle(-camera_angle + 90 * rotations)
}

spec fn image_deviation_after_rotations(camera_angle: int, rotations: int) -> int
    recommends 0 <= rotations <= 3
{
    deviation_from_vertical(image_angle_after_rotations(camera_angle, rotations))
}

spec fn is_optimal_rotations(camera_angle: int, result: int) -> bool
    recommends 0 <= result <= 3
{
    forall|k: int| 0 <= k <= 3 ==> #[trigger] image_deviation_after_rotations(camera_angle, k) >= image_deviation_after_rotations(camera_angle, result) && (image_deviation_after_rotations(camera_angle, k) > image_deviation_after_rotations(camera_angle, result) || result <= k)
}",,"fn solve(x: i8) -> (result: u8)
    ensures 
        0 <= result <= 3,
        is_optimal_rotations(x as int, result as int)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0046,verus,apps,apps_test_185,,"Given n manholes in a line (positions 1 to n), each initially covered by one stone with one coin underneath.
Nastya starts at position k and can: throw stones, move to adjacent positions, or collect coins from uncovered manholes.
Find the minimum number of moves needed to collect all n coins.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, k: int) -> bool {
    2 <= n <= 5000 && 1 <= k <= n
}

spec fn optimal_moves(n: int, k: int) -> int {
    if k == 1 || k == n {
        3 * n
    } else {
        3 * n + spec_min(k - 1, n - k)
    }
}

spec fn spec_min(a: int, b: int) -> int {
    if a <= b { a } else { b }
}",,"fn minimum_moves(n: i8, k: i8) -> (result: i8)
    requires 
        valid_input(n as int, k as int)
    ensures 
        result as int == optimal_moves(n as int, k as int),
        result > 0","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0047,verus,apps,apps_test_189,,"Given n sticks with positive integer lengths, find a positive integer t and modify sticks to minimize 
total cost such that all final lengths are almost good for t (within distance 1 of t).
Cost to change a stick's length is the absolute difference.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, sticks: Seq<int>) -> bool {
    1 <= n <= 1000 &&
    sticks.len() == n &&
    (forall|i: int| 0 <= i < sticks.len() ==> #[trigger] sticks[i] >= 1 && #[trigger] sticks[i] <= 100)
}

spec fn cost_for_t(sticks: Seq<int>, t: int) -> int {
    sum_costs(sticks, t, 0)
}

spec fn sum_costs(sticks: Seq<int>, t: int, index: int) -> int
    decreases sticks.len() - index when 0 <= index <= sticks.len()
{
    if index < 0 || index >= sticks.len() {
        0
    } else if index == sticks.len() {
        0
    } else {
        max_int(0, abs_int(t - sticks[index as int]) - 1) + sum_costs(sticks, t, index + 1)
    }
}

spec fn abs_int(x: int) -> int {
    if x >= 0 { x } else { -x }
}

spec fn max_int(a: int, b: int) -> int {
    if a >= b { a } else { b }
}

spec fn is_optimal_t(sticks: Seq<int>, t: int) -> bool {
    forall|other_t: int| 1 <= other_t <= 99 ==> 
        #[trigger] cost_for_t(sticks, t) <= #[trigger] cost_for_t(sticks, other_t)
}",,"fn find_optimal_t(n: i8, sticks: Vec<i8>) -> (result: (i8, i8))
    requires valid_input(n as int, sticks@.map_values(|v: i8| v as int))
    ensures ({
        let (t, min_cost) = result;
        1 <= t as int <= 99 &&
        min_cost as int >= 0 &&
        min_cost as int == cost_for_t(sticks@.map_values(|v: i8| v as int), t as int) &&
        is_optimal_t(sticks@.map_values(|v: i8| v as int), t as int)
    })","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0048,verus,apps,apps_test_194,,"Given n groups arriving at a restaurant chronologically, where each group has 1 or 2 people,
and the restaurant has a one-person tables and b two-person tables, determine how many people
are denied service following specific seating rules.

/* group == 1 */","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, a: int, b: int, groups: Seq<int>) -> bool {
    n >= 1 && a >= 1 && b >= 1 && groups.len() == n &&
    forall|i: int| 0 <= i < groups.len() ==> groups[i] == 1 || groups[i] == 2
}

spec fn count_denied_people(groups: Seq<int>, a: int, b: int) -> int {
    count_denied_people_with_half(groups, a, b, 0)
}

spec fn count_denied_people_with_half(groups: Seq<int>, a: int, b: int, half_occupied: int) -> int
    decreases groups.len()
{
    if groups.len() == 0 {
        0
    } else {
        let group = groups[0];
        let rest = groups.subrange(1, groups.len() as int);
        if group == 2 {
            if b > 0 {
                count_denied_people_with_half(rest, a, b - 1, half_occupied)
            } else {
                2 + count_denied_people_with_half(rest, a, b, half_occupied)
            }
        } else {
            if a > 0 {
                count_denied_people_with_half(rest, a - 1, b, half_occupied)
            } else if b > 0 {
                count_denied_people_with_half(rest, a, b - 1, half_occupied + 1)
            } else if half_occupied > 0 {
                count_denied_people_with_half(rest, a, b, half_occupied - 1)
            } else {
                1 + count_denied_people_with_half(rest, a, b, half_occupied)
            }
        }
    }
}",,"fn solve(n: i8, a: i8, b: i8, groups: Vec<i8>) -> (denied: i8)
    requires 
        valid_input(n as int, a as int, b as int, groups@.map_values(|x: i8| x as int))
    ensures 
        denied >= 0,
        denied as int == count_denied_people(groups@.map_values(|x: i8| x as int), a as int, b as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0049,verus,apps,apps_test_198,,"Given a positive integer n, cut a stick of length n into exactly 4 parts with positive integer lengths.
Count the number of ways to do this such that the parts can form a rectangle (two pairs of equal lengths)
but cannot form a square (all four lengths equal). Two cutting methods are distinct if the number of
parts of any given length differs between them.","use vstd::prelude::*;

verus! {
spec fn valid_rectangle_parts(a: int, b: int, n: int) -> bool {
    a > 0 && b > 0 && a != b && 2 * a + 2 * b == n
}

spec fn count_valid_rectangles(n: int) -> int
    recommends n > 0
{
    if n % 2 == 1 { 0 }
    else if n % 4 == 2 { n / 4 }
    else { n / 4 - 1 }
}

spec fn valid_input(n: int) -> bool {
    n > 0
}",,"fn solve(n: i8) -> (result: i8)
    requires valid_input(n as int)
    ensures 
        result as int == count_valid_rectangles(n as int) &&
        (n as int % 2 == 1 ==> result as int == 0) &&
        (n as int % 2 == 0 && n as int % 4 == 2 ==> result as int == n as int / 4) &&
        (n as int % 2 == 0 && n as int % 4 == 0 ==> result as int == n as int / 4 - 1)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0050,verus,apps,apps_test_199,,"Given n kegs containing v_i liters of kvass each, pour exactly s liters total 
such that the minimum amount remaining in any keg is maximized. Each keg can 
only have kvass removed, not added. Return -1 if impossible to pour s liters,
otherwise return the maximum possible minimum remaining amount in any keg.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, s: int, v: Seq<int>) -> bool {
    n > 0 && v.len() == n && s >= 0 && forall|i: int| 0 <= i < v.len() ==> v[i] >= 0
}

spec fn sum(v: Seq<int>) -> int
    decreases v.len()
{
    if v.len() == 0 {
        0
    } else {
        v[0] + sum(v.subrange(1, v.len() as int))
    }
}

spec fn min_seq(v: Seq<int>) -> int
    recommends v.len() > 0
    decreases v.len()
{
    if v.len() == 1 {
        v[0]
    } else if v.len() > 1 && v[0] <= min_seq(v.subrange(1, v.len() as int)) {
        v[0]
    } else if v.len() > 1 {
        min_seq(v.subrange(1, v.len() as int))
    } else {
        0
    }
}

spec fn min(a: int, b: int) -> int {
    if a <= b { a } else { b }
}",,"fn solve(n: i8, s: i8, v: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, s as int, v@.map(|i, x| x as int))
    ensures 
        sum(v@.map(|i, x| x as int)) < s as int ==> result == -1,
        sum(v@.map(|i, x| x as int)) >= s as int ==> result == min((sum(v@.map(|i, x| x as int)) - s as int) / n as int, min_seq(v@.map(|i, x| x as int))) as i8,
        result == -1 || result >= 0","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0051,verus,apps,apps_test_201,,"Given two types of candies with different weights and joy values, find the maximum joy units
achievable by selecting whole candies within a weight constraint. Must maximize total joy
while staying within the weight capacity C.","use vstd::prelude::*;

verus! {

spec fn valid_input(c: int, hr: int, hb: int, wr: int, wb: int) -> bool {
    c >= 0 && hr > 0 && hb > 0 && wr > 0 && wb > 0
}

spec fn valid_candy_combination(red_count: int, blue_count: int, c: int, wr: int, wb: int) -> bool {
    red_count >= 0 && blue_count >= 0 && red_count * wr + blue_count * wb <= c
}

spec fn joy(red_count: int, blue_count: int, hr: int, hb: int) -> int {
    red_count * hr + blue_count * hb
}",,"fn solve(c: i8, hr: i8, hb: i8, wr: i8, wb: i8) -> (result: i8)
    requires
        valid_input(c as int, hr as int, hb as int, wr as int, wb as int),
    ensures
        result >= 0,
        exists|red_count: int, blue_count: int| 
            valid_candy_combination(red_count, blue_count, c as int, wr as int, wb as int) &&
            result as int == joy(red_count, blue_count, hr as int, hb as int),
        forall|red_count: int, blue_count: int|
            valid_candy_combination(red_count, blue_count, c as int, wr as int, wb as int) ==>
            joy(red_count, blue_count, hr as int, hb as int) <= result as int,","{
    assume(false);
    0
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0052,verus,apps,apps_test_203,,"Determine the winner of an elimination-style voting game between two factions.
Employees vote in rounds, can eliminate opponents, and play optimally.
The faction with the last remaining employee wins.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, s: Seq<char>) -> bool {
    1 <= n <= 200000 && s.len() == n &&
    forall|i: int| 0 <= i < n ==> s[i] == 'D' || s[i] == 'R'
}

spec fn count_d(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 { 0int }
    else { (if s[0] == 'D' { 1int } else { 0int }) + count_d(s.subrange(1, s.len() as int)) }
}

spec fn count_r(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 { 0int }
    else { (if s[0] == 'R' { 1int } else { 0int }) + count_r(s.subrange(1, s.len() as int)) }
}

spec fn optimal_elimination_game_winner(s: Seq<char>) -> Seq<char> {
    if count_d(s) == 0 { seq!['R'] }
    else if count_r(s) == 0 { seq!['D'] }
    else if count_d(s) >= count_r(s) { seq!['D'] }
    else { seq!['R'] }
}",,"fn solve(n: usize, s: Vec<char>) -> (result: Vec<char>)
    requires valid_input(n as int, s@)
    ensures result@ == optimal_elimination_game_winner(s@)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0053,verus,apps,apps_test_204,,"Count pairs of positive integers (w, h) such that:
- w ≤ a (width constraint)  
- h ≤ b (height constraint)
- w/h = x/y (aspect ratio constraint)
The solution reduces x/y to lowest terms and finds the maximum multiplier k
such that valid pairs have the form (k×x', k×y') where x' = x/gcd(x,y) and y' = y/gcd(x,y)","use vstd::prelude::*;

verus! {

spec fn valid_input(a: int, b: int, x: int, y: int) -> bool {
  a > 0 && b > 0 && x > 0 && y > 0
}

spec fn gcd(a: int, b: int) -> int
  recommends a >= 0 && b >= 0
  decreases b when b >= 0
{
  if b == 0 { a } else { gcd(b, a % b) }
}

spec fn min(a: int, b: int) -> int {
  if a <= b { a } else { b }
}

spec fn expected_result(a: int, b: int, x: int, y: int) -> int
  recommends valid_input(a, b, x, y)
{
  let g = gcd(x, y);
  let x_reduced = x / g;
  let y_reduced = y / g;
  min(a / x_reduced, b / y_reduced)
}",,"fn solve(a: i8, b: i8, x: i8, y: i8) -> (result: i8)
requires 
  valid_input(a as int, b as int, x as int, y as int)
ensures 
  result as int >= 0,
  result as int == expected_result(a as int, b as int, x as int, y as int)","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0054,verus,apps,apps_test_207,,"Given an integer sequence, determine if it can be divided into an odd number of 
non-empty contiguous subsegments, where each subsegment has odd length and 
begins and ends with odd numbers.","use vstd::prelude::*;

verus! {
spec fn valid_input(a: Seq<int>) -> bool {
    a.len() >= 1
}

spec fn can_be_divided(a: Seq<int>) -> bool
    recommends valid_input(a)
{
    a.len() % 2 == 1 && a[0] % 2 == 1 && a[a.len() - 1] % 2 == 1
}",,"fn solve(a: Vec<i8>) -> (result: String)
    requires 
        valid_input(a@.map(|i, x| x as int)),
    ensures 
        can_be_divided(a@.map(|i, x| x as int)) ==> result@ =~= seq!['Y', 'e', 's'],
        (!can_be_divided(a@.map(|i, x| x as int))) ==> result@ =~= seq!['N', 'o'],","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0055,verus,apps,apps_test_208,,"Given coordinates of two trees that are vertices of a square (with sides parallel to coordinate axes),
find the coordinates of the other two vertices. Valid cases include: same x-coordinate (vertical edge),
same y-coordinate (horizontal edge), or diagonal vertices where |x₂-x₁| = |y₂-y₁|.
Return -1 if no valid square can be formed.","use vstd::prelude::*;

verus! {
spec fn valid_input(x1: int, y1: int, x2: int, y2: int) -> bool {
    -100 <= x1 <= 100 && -100 <= y1 <= 100 && -100 <= x2 <= 100 && -100 <= y2 <= 100
}

spec fn int_abs(x: int) -> int {
    if x >= 0 { x } else { -x }
}

spec fn is_invalid_case(x1: int, y1: int, x2: int, y2: int) -> bool {
    x1 != x2 && y1 != y2 && int_abs(x1 - x2) != int_abs(y1 - y2)
}

spec fn is_diagonal_case(x1: int, y1: int, x2: int, y2: int) -> bool {
    x1 != x2 && y1 != y2 && int_abs(x1 - x2) == int_abs(y1 - y2)
}

spec fn is_vertical_edge_case(x1: int, y1: int, x2: int, y2: int) -> bool {
    x1 == x2
}

spec fn is_horizontal_edge_case(x1: int, y1: int, x2: int, y2: int) -> bool {
    x1 != x2 && y1 == y2
}

spec fn expected_diagonal_result(x1: int, y1: int, x2: int, y2: int) -> Seq<int> {
    seq![x1, y2, x2, y1]
}

spec fn expected_vertical_result(x1: int, y1: int, x2: int, y2: int) -> Seq<int> {
    seq![x1 + int_abs(y2 - y1), y1, x1 + int_abs(y2 - y1), y2]
}

spec fn expected_horizontal_result(x1: int, y1: int, x2: int, y2: int) -> Seq<int> {
    seq![x1, y1 + int_abs(x2 - x1), x2, y1 + int_abs(x2 - x1)]
}

spec fn valid_output(result: Seq<int>) -> bool {
    (result.len() == 1 && result[0] == -1) ||
    (result.len() == 4 && (forall|i: int| #![trigger result[i]] 0 <= i < 4 ==> -1000 <= result[i] <= 1000))
}",,"fn solve(x1: i8, y1: i8, x2: i8, y2: i8) -> (result: Vec<i8>)
    requires 
        valid_input(x1 as int, y1 as int, x2 as int, y2 as int)
    ensures 
        valid_output(result@.map(|i, v| v as int)),
        is_invalid_case(x1 as int, y1 as int, x2 as int, y2 as int) ==> result@.map(|i, v| v as int) == seq![-1],
        is_diagonal_case(x1 as int, y1 as int, x2 as int, y2 as int) ==> result@.map(|i, v| v as int) == expected_diagonal_result(x1 as int, y1 as int, x2 as int, y2 as int),
        is_vertical_edge_case(x1 as int, y1 as int, x2 as int, y2 as int) ==> result@.map(|i, v| v as int) == expected_vertical_result(x1 as int, y1 as int, x2 as int, y2 as int),
        is_horizontal_edge_case(x1 as int, y1 as int, x2 as int, y2 as int) ==> result@.map(|i, v| v as int) == expected_horizontal_result(x1 as int, y1 as int, x2 as int, y2 as int)","{
    // impl-start
    assume(false);
    Vec::new()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0056,verus,apps,apps_test_216,,"Given a sequence of integers, partition it into two subsequences such that
every element belongs to exactly one subsequence. Find the maximum possible
value of B - C, where B is the sum of elements in the first subsequence
and C is the sum of elements in the second subsequence.","use vstd::prelude::*;

verus! {
spec fn sum_abs(arr: Seq<int>, i: int) -> int
    decreases arr.len() - i when 0 <= i <= arr.len()
{
    if i == arr.len() {
        0
    } else {
        (if arr[i] >= 0 { arr[i] } else { -arr[i] }) + sum_abs(arr, i + 1)
    }
}

spec fn valid_input(n: int, arr: Seq<int>) -> bool {
    0 <= n == arr.len()
}",,"fn solve(n: i8, arr: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, arr@.map(|i: int, v: i8| v as int))
    ensures result as int == sum_abs(arr@.map(|i: int, v: i8| v as int), 0)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0057,verus,apps,apps_test_217,,"A bus travels back and forth between points x=0 and x=a, making k total journeys.
The bus has fuel capacity b and consumes 1 unit per distance unit. There's a gas station at x=f.
Find minimum refuels needed to complete k journeys, or return -1 if impossible.","use vstd::prelude::*;

verus! {
spec fn valid_input(a: int, b: int, f: int, k: int) -> bool {
  a > 0 && b > 0 && f > 0 && k > 0 && f < a
}

spec fn impossible_conditions(a: int, b: int, f: int, k: int) -> bool {
  b < f ||                                    
  b < a - f ||                               
  (k > 1 && b < 2 * a - f) ||               
  (k == 1 && b < a && b < f)                
}

spec fn feasibility_conditions(a: int, b: int, f: int, k: int) -> bool {
  b >= f &&                                  
  b >= a - f &&                             
  (k <= 1 || b >= 2 * a - f) &&            
  (k == 1 ==> (b >= a || b >= f))          
}

spec fn single_journey_result(a: int, b: int, f: int, k: int, result: int) -> bool {
  k == 1 && result >= 0 ==> (
    (b >= a && result == 0) ||                
    (b < a && b >= f && result == 1)          
  )
}

spec fn multi_journey_feasibility(a: int, b: int, f: int, k: int, result: int) -> bool {
  k > 1 && result >= 0 ==> (
    b >= f && b >= a - f && b >= 2 * a - f    
  )
}",,"fn solve(a: i8, b: i8, f: i8, k: i8) -> (result: i8)
  requires
    valid_input(a as int, b as int, f as int, k as int)
  ensures
    result as int >= -1 &&
    ((result as int == -1) <==> impossible_conditions(a as int, b as int, f as int, k as int)) &&
    (result as int >= 0 ==> result as int <= k as int) &&
    (result as int >= 0 ==> feasibility_conditions(a as int, b as int, f as int, k as int)) &&
    single_journey_result(a as int, b as int, f as int, k as int, result as int) &&
    multi_journey_feasibility(a as int, b as int, f as int, k as int, result as int)","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0058,verus,apps,apps_test_222,,"Given a positive integer n as a string, find the minimum number of digit deletions 
required to transform n into a perfect square, or return -1 if impossible.
You can delete any digit from n as long as the result remains a positive integer 
without leading zeros. A perfect square is an integer x = y² for some positive integer y.","use vstd::prelude::*;

verus! {

spec fn generate_squares() -> Seq<int> {
    generate_squares_helper(1, 44721)
}

spec fn is_subsequence(pattern: Seq<char>, text: Seq<char>) -> bool {
    is_subsequence_helper(pattern, text, 0, 0)
}

spec fn int_to_string(n: int) -> Seq<char> {
    if n == 0 { seq!['0'] }
    else { int_to_string_helper(n) }
}

spec fn generate_squares_helper(start: int, end: int) -> Seq<int>
    decreases end + 1 - start when start <= end
{
    if start > end { Seq::empty() }
    else { seq![start * start].add(generate_squares_helper(start + 1, end)) }
}

spec fn is_subsequence_helper(pattern: Seq<char>, text: Seq<char>, pi: int, ti: int) -> bool
    decreases pattern.len() - pi + text.len() - ti when pi <= pattern.len() && ti <= text.len()
{
    if pi >= pattern.len() { true }
    else if ti >= text.len() { false }
    else if pattern[pi] == text[ti] { 
        is_subsequence_helper(pattern, text, pi + 1, ti + 1)
    } else {
        is_subsequence_helper(pattern, text, pi, ti + 1)
    }
}

spec fn int_to_string_helper(n: int) -> Seq<char>
    decreases n when n > 0
{
    if n < 10 { seq![('0' as u8 + (n % 10) as u8) as char] }
    else { int_to_string_helper(n / 10).add(seq![('0' as u8 + (n % 10) as u8) as char]) }
}",,"fn solve(s: Vec<char>) -> (result: i32)
    requires 
        s.len() > 0,
        forall|i: int| 0 <= i < s.len() ==> '0' <= #[trigger] s@[i] <= '9',
        s@[0] != '0' || s.len() == 1,
    ensures 
        result == -1 || result >= 0,
        result == -1 ==> forall|sq: int| #[trigger] generate_squares().contains(sq) ==> !is_subsequence(int_to_string(sq), s@),
        result >= 0 ==> exists|sq: int| #![auto] generate_squares().contains(sq) && is_subsequence(int_to_string(sq), s@) && result == s.len() as i32 - int_to_string(sq).len() as i32,
        result >= 0 ==> forall|sq: int| #[trigger] generate_squares().contains(sq) && is_subsequence(int_to_string(sq), s@) ==> s.len() as i32 - int_to_string(sq).len() as i32 >= result,","{
    assume(false);
    -1
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0059,verus,apps,apps_test_228,,"Given n piles of stones (n even), Alice and Bob alternate turns with Alice first.
Each turn, a player chooses n/2 nonempty piles and removes positive stones from each.
A player loses when fewer than n/2 nonempty piles remain. Determine the winner.","use vstd::prelude::*;

verus! {

spec fn minimum(s: Seq<int>) -> int
    recommends s.len() > 0
    decreases s.len()
    when s.len() > 0
{
    if s.len() == 1 {
        s[0]
    } else if s.len() > 1 && s[0] <= minimum(s.subrange(1, s.len() as int)) {
        s[0]
    } else {
        minimum(s.subrange(1, s.len() as int))
    }
}

spec fn count_occurrences(s: Seq<int>, val: int) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0int
    } else {
        (if s[0] == val { 1int } else { 0int }) + count_occurrences(s.subrange(1, s.len() as int), val)
    }
}

spec fn valid_input(n: int, piles: Seq<int>) -> bool {
    n >= 2 && n % 2 == 0 && piles.len() == n && forall|i: int| 0 <= i < piles.len() ==> piles[i] >= 1
}",,"fn solve(n: i8, piles: Vec<i8>) -> (result: &'static str)
    requires valid_input(n as int, piles@.map_values(|v: i8| v as int))
    ensures result == ""Alice"" || result == ""Bob""","{
    assume(false);
    ""Alice""
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0060,verus,apps,apps_test_231,,"Vasya needs to drive to house number a on a street with n houses (n is even).
Odd-numbered houses are on one side from beginning to end, even-numbered houses
are on the other side from end to beginning. Distance from beginning to houses
1 and n is 1 unit, and consecutive houses on same side are 1 unit apart.
Find minimum time to reach house a from street beginning.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, a: int) -> bool {
    n > 0 && n % 2 == 0 && 1 <= a <= n
}

spec fn distance_to_house(n: int, a: int) -> int
{
    if a % 2 == 1 {
        a / 2 + 1
    } else {
        (n - a) / 2 + 1
    }
}",,"fn min_distance(n: i8, a: i8) -> (result: i8)
requires
    valid_input(n as int, a as int)
ensures
    result as int == distance_to_house(n as int, a as int)
{
    assume(false);
    unreached()
}",/* placeholder implementation */,"
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0062,verus,apps,apps_test_235,,"Given n candies, find the minimum k such that Vasya eats at least half of the original candies.
Daily process: Vasya eats k candies in morning, Petya eats floor(remaining/10) in evening.
Continue until no candies remain.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int) -> bool {
    n >= 1
}

spec fn vasya_eats_with_strategy(n: int, k: int) -> int
    decreases n
{
    if n <= 0 || k < 1 { 
        0 
    } else {
        let cur = if n < k { n } else { k };
        let remaining_after_vasya = n - cur;
        let remaining_after_petya = remaining_after_vasya - remaining_after_vasya / 10;
        cur + vasya_eats_with_strategy(remaining_after_petya, k)
    }
}

spec fn is_minimal_solution(n: int, k: int) -> bool {
    valid_input(n) && k >= 1 && 
    vasya_eats_with_strategy(n, k) * 2 >= n &&
    (k == 1 || vasya_eats_with_strategy(n, k - 1) * 2 < n)
}",,"fn solve(n: i8) -> (result: i8)
    requires valid_input(n as int)
    ensures
        1 <= result as int <= n as int,
        is_minimal_solution(n as int, result as int)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0063,verus,apps,apps_test_244,,"Given 3 shells numbered 0, 1, 2, a ball starts under one shell. An operator makes n moves:
odd moves swap shells 0 and 1, even moves swap shells 1 and 2. Given the final position x
after n moves, determine the initial position of the ball.

/* odd move: swap 0 and 1 */

/* even move: swap 1 and 2 */

/* reverse odd move: swap 0 and 1 */

/* reverse even move: swap 1 and 2 */","use vstd::prelude::*;

verus! {
spec fn valid_position(pos: int) -> bool {
    0 <= pos <= 2
}

spec fn swap_move(pos: int, move_num: int) -> int {
    if move_num % 2 == 1 {
        if pos == 0 { 1 }
        else if pos == 1 { 0 }
        else { 2 }
    } else {
        if pos == 1 { 2 }
        else if pos == 2 { 1 }
        else { 0 }
    }
}

spec fn reverse_move(pos: int, move_num: int) -> int {
    if move_num % 2 == 1 {
        if pos == 0 { 1 }
        else if pos == 1 { 0 }
        else { 2 }
    } else {
        if pos == 1 { 2 }
        else if pos == 2 { 1 }
        else { 0 }
    }
}",,"fn shell_game(n: i32, x: i8) -> (result: i8)
    requires 
        n >= 1 && n <= 2000000000,
        valid_position(x as int),
    ensures valid_position(result as int),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0064,verus,apps,apps_test_246,,"Count positive integers x ≤ n where x - (sum of digits of x) ≥ s.
Given two integers n and s (1 ≤ n, s ≤ 10^18), return the count of numbers x ≤ n satisfying the condition.","use vstd::prelude::*;

verus! {
spec fn sum_of_digits(x: int) -> int
  decreases x when x >= 0
{
  if x <= 0 { 0 } else { (x % 10) + sum_of_digits(x / 10) }
}

spec fn check(x: int, s: int) -> bool {
  x >= 0 && x - sum_of_digits(x) >= s
}",,"fn solve(n: i8, s: i8) -> (result: i8)
requires n as int >= 1 && s as int >= 1
ensures result as int >= 0 && result as int <= n as int","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0065,verus,apps,apps_test_253,,"Given three positive integers k₁, k₂, k₃ (each ≤ 1500), determine if there exist 
starting times x₁, x₂, x₃ such that every integer t ≥ max(x₁, x₂, x₃) can be written 
as xᵢ + j·kᵢ for some i ∈ {1,2,3} and non-negative integer j. In other words, 
determine if the union of three arithmetic progressions can cover all sufficiently 
large positive integers.

/* a == 2 */","use vstd::prelude::*;

verus! {

spec fn valid_input(nums: Seq<int>) -> bool {
    nums.len() == 3 &&
    forall|i: int| 0 <= i < nums.len() ==> nums[i] > 0 &&
    forall|i: int| 0 <= i < nums.len() ==> nums[i] <= 1500
}

spec fn sort_three(x: int, y: int, z: int) -> (int, int, int) {
    if x <= y && x <= z {
        if y <= z { (x, y, z) } else { (x, z, y) }
    } else if y <= x && y <= z {
        if x <= z { (y, x, z) } else { (y, z, x) }
    } else {
        if x <= y { (z, x, y) } else { (z, y, x) }
    }
}

spec fn compute_result(x: int, y: int, z: int) -> Seq<char> {
    let sorted = sort_three(x, y, z);
    let a = sorted.0;
    let b = sorted.1;
    let c = sorted.2;

    if a > 3 {
        seq!['N', 'O']
    } else if a == 3 {
        if b > 3 {
            seq!['N', 'O']
        } else if b == 3 {
            if c > 3 { seq!['N', 'O'] } else { seq!['Y', 'E', 'S'] }
        } else {
            seq!['N', 'O']
        }
    } else if a == 1 {
        seq!['Y', 'E', 'S']
    } else {
        if b == 2 {
            seq!['Y', 'E', 'S']
        } else if b > 4 {
            seq!['N', 'O']
        } else if b == 4 {
            if c == 4 { seq!['Y', 'E', 'S'] } else { seq!['N', 'O'] }
        } else {
            seq!['N', 'O']
        }
    }
}",,"fn solve(nums: Vec<i8>) -> (result: Vec<char>)
    requires
        valid_input(nums@.map(|i, x| x as int)),
    ensures
        result@ == seq!['Y', 'E', 'S'] || result@ == seq!['N', 'O'],
        result@ == compute_result(nums@[0] as int, nums@[1] as int, nums@[2] as int),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0069,verus,apps,apps_test_271,,"Given a non-negative integer n, round it to the nearest integer that ends with 0.
If n already ends with 0, return n unchanged. When there are two equally distant
options (when the last digit is 5), use banker's rounding (round half to even).","use vstd::prelude::*;

verus! {
spec fn valid_result(n: int, result: int) -> bool
  recommends n >= 0
{
  let quotient = n / 10;
  let remainder = n % 10;
  result % 10 == 0 && 
  result >= 0 &&
  (remainder < 5 ==> result == quotient * 10) &&
  (remainder > 5 ==> result == (quotient + 1) * 10) &&
  (remainder == 5 ==> (quotient % 2 == 0 ==> result == quotient * 10) && 
                      (quotient % 2 == 1 ==> result == (quotient + 1) * 10))
}",,"fn solve(n: i8) -> (result: i8)
  requires n >= 0
  ensures valid_result(n as int, result as int)","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0070,verus,apps,apps_test_287,,"Given n apartments numbered 1 to n arranged in a row, with exactly k apartments already inhabited,
find the minimum and maximum possible number of ""good"" apartments. A good apartment is one that is
available for sale (not inhabited) and has at least one inhabited apartment adjacent to it.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, k: int) -> bool
{
    n >= 1 && k >= 0 && k <= n
}

spec fn valid_output(result: Seq<int>, n: int, k: int) -> bool
{
    result.len() == 2 && 
    result[0] >= 0 && 
    result[1] >= 0 && 
    result[0] <= result[1] &&
    result[0] <= n - k &&
    result[1] <= n - k
}

spec fn min_good_apartments(n: int, k: int) -> int
{
    if k == 0 || k == n { 0 } else { 1 }
}

spec fn max_good_apartments(n: int, k: int) -> int
{
    if k == 0 || k == n { 0 }
    else if n - k < k * 2 { n - k }
    else { k * 2 }
}",,"fn solve(n: i8, k: i8) -> (result: Vec<i8>)
    requires valid_input(n as int, k as int)
    ensures 
        result.len() == 2 &&
        valid_output(result@.map(|i: int, x: i8| x as int), n as int, k as int) &&
        result[0] as int == min_good_apartments(n as int, k as int) &&
        result[1] as int == max_good_apartments(n as int, k as int)","{
    assume(false);
    Vec::new()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0071,verus,apps,apps_test_291,,"Given two initial weights a and b where a ≤ b, determine after how many years 
Limak (starting weight a) becomes strictly heavier than Bob (starting weight b).
Each year, Limak's weight triples and Bob's weight doubles.","use vstd::prelude::*;

verus! {

spec fn pow(base: int, exp: int) -> int
  decreases exp
{
  if exp <= 0 { 1 }
  else { base * pow(base, exp - 1) }
}",,"fn solve(a: i8, b: i8) -> (years: i8)
  requires 
      1 <= a <= b <= 10,
      forall|base: int, exp: int| exp >= 0 ==> (
          (exp == 0 ==> pow(base, exp) == 1) &&
          (exp > 0 && base > 0 ==> pow(base, exp) > 0) &&
          (exp > 0 && base == 0 ==> pow(base, exp) == 0)
      ),
  ensures 
      years >= 0,
      (a as int) * pow(3, years as int) > (b as int) * pow(2, years as int),
      years == 0 || (a as int) * pow(3, (years - 1) as int) <= (b as int) * pow(2, (years - 1) as int),","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0072,verus,apps,apps_test_298,,"Two players take turns removing exactly k consecutive sticks from either end of a row of n sticks.
The first player moves first. The game ends when fewer than k sticks remain.
Determine if the first player wins by making strictly more moves than the second player.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, k: int) -> bool {
    k >= 1 && n >= 1 && k <= n
}

spec fn total_moves(n: int, k: int) -> int {
    if valid_input(n, k) { n / k } else { 0 }
}

spec fn first_player_wins(n: int, k: int) -> bool {
    if valid_input(n, k) { total_moves(n, k) % 2 == 1 } else { false }
}",,"fn solve(n: i8, k: i8) -> (result: String)
    requires
        valid_input(n as int, k as int),
    ensures
        first_player_wins(n as int, k as int) ==> result@ == seq!['Y', 'E', 'S'],
        !first_player_wins(n as int, k as int) ==> result@ == seq!['N', 'O'],","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0073,verus,apps,apps_test_299,,"Given n exercises with repetition counts, determine which muscle group receives the most total repetitions.
Exercises cycle through three types based on position (0-indexed):
- Position 0, 3, 6, ... : chest exercises
- Position 1, 4, 7, ... : biceps exercises  
- Position 2, 5, 8, ... : back exercises
Return the muscle group with the highest total repetitions.","use vstd::prelude::*;

verus! {
spec fn chest_total(reps: Seq<int>) -> int 
decreases reps.len()
{
    if reps.len() == 0 {
        0int
    } else {
        let first = if 0int % 3 == 0 { reps[0int] } else { 0int };
        first + chest_total_helper(reps.subrange(1, reps.len() as int), 1int)
    }
}

spec fn chest_total_helper(reps: Seq<int>, index: int) -> int 
decreases reps.len()
{
    if reps.len() == 0 {
        0int
    } else {
        let first = if index % 3 == 0 { reps[0int] } else { 0int };
        first + chest_total_helper(reps.subrange(1, reps.len() as int), index + 1)
    }
}

spec fn biceps_total(reps: Seq<int>) -> int 
decreases reps.len()
{
    if reps.len() == 0 {
        0int
    } else {
        let first = if 0int % 3 == 1 { reps[0int] } else { 0int };
        first + biceps_total_helper(reps.subrange(1, reps.len() as int), 1int)
    }
}

spec fn biceps_total_helper(reps: Seq<int>, index: int) -> int 
decreases reps.len()
{
    if reps.len() == 0 {
        0int
    } else {
        let first = if index % 3 == 1 { reps[0int] } else { 0int };
        first + biceps_total_helper(reps.subrange(1, reps.len() as int), index + 1)
    }
}

spec fn back_total(reps: Seq<int>) -> int 
decreases reps.len()
{
    if reps.len() == 0 {
        0int
    } else {
        let first = if 0int % 3 == 2 { reps[0int] } else { 0int };
        first + back_total_helper(reps.subrange(1, reps.len() as int), 1int)
    }
}

spec fn back_total_helper(reps: Seq<int>, index: int) -> int 
decreases reps.len()
{
    if reps.len() == 0 {
        0int
    } else {
        let first = if index % 3 == 2 { reps[0int] } else { 0int };
        first + back_total_helper(reps.subrange(1, reps.len() as int), index + 1)
    }
}

spec fn valid_input(reps: Seq<int>) -> bool {
    reps.len() > 0 && forall|i: int| 0 <= i < reps.len() ==> reps[i] > 0
}

spec fn is_winner(muscle: &str, reps: Seq<int>) -> bool {
    let chest_total_val = chest_total(reps);
    let biceps_total_val = biceps_total(reps);
    let back_total_val = back_total(reps);

    match muscle {
        ""chest"" => chest_total_val >= biceps_total_val && chest_total_val >= back_total_val,
        ""biceps"" => biceps_total_val > chest_total_val && biceps_total_val >= back_total_val,
        ""back"" => back_total_val > chest_total_val && back_total_val > biceps_total_val,
        _ => false,
    }
}",,"fn find_strongest_muscle_group(reps: Vec<i8>) -> (result: &'static str)
    requires 
        valid_input(reps@.map(|i: int, x: i8| x as int))
    ensures 
        result == ""chest"" || result == ""biceps"" || result == ""back"",
        is_winner(result, reps@.map(|i: int, x: i8| x as int))","{
    assume(false);
    ""chest""
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0074,verus,apps,apps_test_302,,"Given a positive integer n, find the minimum number of digit 1s needed to represent n 
as a sum and/or difference of repunits (numbers containing only 1s: 1, 11, 111, 1111, ...).

/* simplified for larger values */","use vstd::prelude::*;

verus! {

spec fn pow(base: nat, exp: nat) -> nat
    decreases exp
{
    if exp == 0 { 1 } else { base * pow(base, (exp - 1) as nat) }
}

spec fn repunit(n: nat) -> nat
{
    if n == 0 { 0 }
    else if n == 1 { 1 }
    else if n == 2 { 11 }
    else if n == 3 { 111 }
    else if n == 4 { 1111 }
    else if n == 5 { 11111 }
    else { n }
}

spec fn valid_input(n: nat) -> bool
{
    true
}

spec fn valid_output(n: nat, result: nat) -> bool
{
    (n == 0 ==> result == 0) &&
    (n > 0 ==> result > 0)
}",,"fn min_repunit_sum(n: u8) -> (result: u8)
    requires valid_input(n as nat)
    ensures valid_output(n as nat, result as nat)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,0.7
VA0075,verus,apps,apps_test_307,,"Given k_2 digits '2', k_3 digits '3', k_5 digits '5', and k_6 digits '6',
form integers 32 and 256 to maximize their sum. Each digit can only be used once.
To form 256: need one '2', one '5', one '6'
To form 32: need one '3', one '2'","use vstd::prelude::*;

verus! {

spec fn valid_input(k2: int, k3: int, k5: int, k6: int) -> bool {
    k2 >= 0 && k3 >= 0 && k5 >= 0 && k6 >= 0 &&
    k2 <= 5000000 && k3 <= 5000000 && k5 <= 5000000 && k6 <= 5000000
}

spec fn optimal_sum(k2: int, k3: int, k5: int, k6: int) -> int
    recommends valid_input(k2, k3, k5, k6)
{
    let count256 = if k2 <= k5 { if k2 <= k6 { k2 } else { k6 } } else { if k5 <= k6 { k5 } else { k6 } };
    let remaining_k2 = k2 - count256;
    let count32 = if k3 <= remaining_k2 { k3 } else { remaining_k2 };
    256 * count256 + 32 * count32
}",,"fn solve(k2: i8, k3: i8, k5: i8, k6: i8) -> (result: i8)
    requires 
        valid_input(k2 as int, k3 as int, k5 as int, k6 as int)
    ensures 
        result >= 0,
        result as int == optimal_sum(k2 as int, k3 as int, k5 as int, k6 as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0076,verus,apps,apps_test_315,,"Given n consecutive days and a minimum requirement k, find the minimum additional walks needed
so that for any two consecutive days, the total walks is at least k. Can only increase walks.","use vstd::prelude::*;

verus! {
spec fn sum(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 { 0 } else { s[0] + sum(s.subrange(1, s.len() as int)) }
}

spec fn valid_input(n: int, k: int, a: Seq<int>) -> bool
{
    n >= 1 && a.len() == n && k >= 0 && forall|i: int| 0 <= i < n ==> #[trigger] a[i] >= 0
}

spec fn valid_output(a: Seq<int>, final_schedule: Seq<int>, additional_walks: int, k: int) -> bool
{
    final_schedule.len() == a.len() &&
    additional_walks >= 0 &&
    forall|i: int| 0 <= i < a.len() ==> #[trigger] final_schedule[i] >= a[i] &&
    forall|i: int| 0 <= i < a.len() - 1 ==> #[trigger] final_schedule[i] + final_schedule[i + 1] >= k &&
    additional_walks == sum(final_schedule) - sum(a)
}",,"fn solve(n: i8, k: i8, a: Vec<i8>) -> (result: (i8, Vec<i8>))
    requires valid_input(n as int, k as int, a@.map_values(|x: i8| x as int))
    ensures valid_output(a@.map_values(|x: i8| x as int), result.1@.map_values(|x: i8| x as int), result.0 as int, k as int)","{
    assume(false);
    (0i8, Vec::<i8>::new())
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0077,verus,apps,apps_test_409,,"Given a string s consisting of uppercase Latin letters, determine if it contains 
two non-overlapping substrings ""AB"" and ""BA"". Return ""YES"" if both substrings 
exist without overlapping, ""NO"" otherwise.","use vstd::prelude::*;

verus! {
spec fn count_substring(s: Seq<char>, pattern: Seq<char>) -> nat 
    decreases s.len()
{
    if pattern.len() == 0 || s.len() < pattern.len() {
        0
    } else if s.subrange(0, pattern.len() as int) =~= pattern {
        1 + count_substring(s.subrange(1, s.len() as int), pattern)
    } else {
        count_substring(s.subrange(1, s.len() as int), pattern)
    }
}

spec fn find_index(s: Seq<char>, pattern: Seq<char>) -> int 
    decreases s.len()
{
    if pattern.len() == 0 || s.len() < pattern.len() {
        -1
    } else if s.subrange(0, pattern.len() as int) =~= pattern {
        0
    } else {
        let rest = find_index(s.subrange(1, s.len() as int), pattern);
        if rest == -1 { -1 } else { 1 + rest }
    }
}

spec fn has_non_overlapping_ab_and_ba(s: Seq<char>) -> bool {
    let ab_pattern = seq!['A', 'B'];
    let ba_pattern = seq!['B', 'A'];
    let ab_index = find_index(s, ab_pattern);
    let ba_index = find_index(s, ba_pattern);

    (ab_index >= 0 && ba_index >= 0) &&
    (
        (ab_index >= 0 && ab_index + 2 < s.len() && count_substring(s.subrange(ab_index + 2, s.len() as int), ba_pattern) > 0) ||
        (ba_index >= 0 && ba_index + 2 < s.len() && count_substring(s.subrange(ba_index + 2, s.len() as int), ab_pattern) > 0)
    )
}

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() >= 0
}",,"fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(input@)
    ensures 
        result@ == seq!['Y', 'E', 'S'] || result@ == seq!['N', 'O'],
        has_non_overlapping_ab_and_ba(input@) <==> result@ == seq!['Y', 'E', 'S']","{
    // impl-start
    assume(false);
    vec!['N', 'O']
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0078,verus,apps,apps_test_433,,"Given a circular building with n entrances numbered 1 to n, determine the final entrance
number after walking from entrance a by b entrances. Positive b means walking forward
(increasing order), negative b means walking backward (decreasing order), and b=0 means
staying at the starting entrance.","use vstd::prelude::*;

verus! {
    spec fn valid_input(n: int, a: int, b: int) -> bool {
        n >= 1 && 1 <= a <= n && -100 <= b <= 100
    }
    
    spec fn final_entrance(n: int, a: int, b: int) -> int {
        ((a - 1 + b) % n + n) % n + 1
    }
    
    spec fn valid_output(result: int, n: int) -> bool {
        1 <= result <= n
    }",,"fn solve(n: i8, a: i8, b: i8) -> (result: i8)
    requires 
        valid_input(n as int, a as int, b as int)
    ensures 
        valid_output(result as int, n as int),
        result as int == final_entrance(n as int, a as int, b as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0079,verus,apps,apps_test_440,,"Given a string of lowercase Latin letters, repeatedly remove consecutive vowels 
by deleting the second vowel in each consecutive pair until no consecutive vowels remain.
Vowels are defined as: a, e, i, o, u, y. Process the string from left to right.","use vstd::prelude::*;

verus! {
spec fn is_vowel(c: char) -> bool {
    c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'y'
}

spec fn no_consecutive_vowels(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() - 1 ==> !(is_vowel(#[trigger] s[i]) && is_vowel(s[i+1]))
}

spec fn valid_output(input: Seq<char>, output: Seq<char>) -> bool {
    output.len() <= input.len() &&
    no_consecutive_vowels(output) &&
    (input.len() > 0 ==> output.len() > 0) &&
    (input.len() > 0 ==> output[0] == input[0])
}",,"fn solve(s: Vec<char>) -> (result: Vec<char>)
    ensures valid_output(s@, result@)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0080,verus,apps,apps_test_442,,"Given a hash function H(x,y) = x² + 2xy + x + 1 where x and y are positive integers,
determine if there exists a pair of positive integers (x,y) such that H(x,y) = r 
for a given positive integer r. If such a pair exists, return the pair (x,y) with 
the smallest possible value of x. If no such pair exists, return empty sequence.","use vstd::prelude::*;

verus! {
spec fn h(x: int, y: int) -> int {
    x * x + 2 * x * y + x + 1
}

spec fn valid_input(r: int) -> bool {
    r > 0
}

spec fn valid_solution(result: Seq<int>, r: int) -> bool {
    if result.len() == 0 {
        true
    } else {
        result.len() == 2 && result[0] > 0 && result[1] > 0 && h(result[0], result[1]) == r
    }
}

spec fn has_solution(r: int) -> bool {
    r > 4 && r % 2 == 1
}",,"fn solve(r: i8) -> (result: Vec<i8>)
    requires 
        valid_input(r as int)
    ensures 
        valid_solution(result@.map(|i: int, x: i8| x as int), r as int),
        result@.len() == 0 || result@.len() == 2,
        result@.len() == 2 ==> result@[0] as int > 0 && result@[1] as int > 0,
        result@.len() == 2 ==> h(result@[0] as int, result@[1] as int) == r as int,
        r as int <= 4 ==> result@.len() == 0,
        r as int > 4 && (r as int) % 2 == 0 ==> result@.len() == 0,
        r as int > 4 && (r as int) % 2 == 1 ==> result@.len() == 2 && result@[0] as int == 1 && result@[1] as int == ((r as int) - 3) / 2,","{
    assume(false);
    Vec::new()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0081,verus,apps,apps_test_443,,"Given n packets of balloons, divide all packets between two people such that:
1. Each person gets at least one packet
2. All packets are distributed 
3. The total number of balloons each person receives is different
Find any valid distribution or return empty sequence if impossible.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, packets: Seq<int>) -> bool {
    n >= 1 && packets.len() == n && forall|i: int| 0 <= i < packets.len() ==> packets[i] >= 1
}

spec fn is_possible(n: int, packets: Seq<int>) -> bool
    recommends valid_input(n, packets)
{
    n >= 2 && (n > 2 || packets[0] != packets[1])
}

spec fn sum_packets(packets: Seq<int>) -> int
    decreases packets.len()
{
    if packets.len() == 0 {
        0
    } else {
        packets[0] + sum_packets(packets.subrange(1, packets.len() as int))
    }
}

spec fn valid_solution(n: int, packets: Seq<int>, result: Seq<int>) -> bool
    recommends valid_input(n, packets)
{
    if !is_possible(n, packets) {
        result.len() == 0
    } else {
        result.len() == 2 && result[0] == 1 && 1 <= result[1] <= n &&
        exists|min_index: int| 0 <= min_index < packets.len() && 
        result[1] == min_index + 1 &&
        (forall|j: int| 0 <= j < packets.len() ==> #[trigger] packets[min_index] <= packets[j]) &&
        (forall|k: int| 0 <= k < min_index ==> #[trigger] packets[k] > packets[min_index])
    }
}",,"fn solve(n: i8, packets: Vec<i8>) -> (result: Vec<i8>)
    requires valid_input(n as int, packets@.map(|i: int, x: i8| x as int))
    ensures valid_solution(n as int, packets@.map(|i: int, x: i8| x as int), result@.map(|i: int, x: i8| x as int))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0082,verus,apps,apps_test_448,,"Given n children numbered 1 to n, where child i needs at least a_i candies.
Children initially line up in order 1, 2, ..., n.
Distribution algorithm:
1. Give m candies to the first child in line
2. If the child has received enough candies (≥ a_i), they go home
3. Otherwise, the child goes to the end of the line
4. Repeat until all children go home
Find which child goes home last.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, m: int, a: Seq<int>) -> bool {
    n > 0 && m > 0 && a.len() == n && forall|i: int| 0 <= i < a.len() ==> a[i] > 0
}

spec fn valid_result(result: int, n: int) -> bool {
    1 <= result <= n
}

spec fn sum_candies_still_needed(queue: Seq<Seq<int>>) -> nat
    decreases queue.len()
{
    if queue.len() == 0 {
        0nat
    } else {
        let child = queue[0];
        let still_needed = if child.len() >= 2 && child[1] <= child[0] { 0nat } else if child.len() >= 2 { (child[1] - child[0]) as nat } else { 0nat };
        still_needed + sum_candies_still_needed(queue.subrange(1, queue.len() as int))
    }
}",,"fn solve(n: i8, m: i8, a: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, m as int, a@.map_values(|x: i8| x as int))
    ensures valid_result(result as int, n as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0083,verus,apps,apps_test_449,,"Given an integer n representing dollars, find the minimum number of bills 
needed to represent this amount using denominations of $1, $5, $10, $20, and $100.","use vstd::prelude::*;

verus! {
    spec fn valid_input(n: int) -> bool {
        n >= 1
    }
    
    spec fn min_bills(n: int) -> int
        recommends n >= 1
    {
        n / 100 + (n % 100) / 20 + ((n % 100) % 20) / 10 + (((n % 100) % 20) % 10) / 5 + ((((n % 100) % 20) % 10) % 5)
    }",,"fn solve(n: i8) -> (result: i8)
    requires 
        valid_input(n as int)
    ensures 
        result >= 0,
        result as int == min_bills(n as int)","{
    assume(false);
    unreached()
}","}

fn main() {}",0,,-1,-1,-1,,1.0
VA0084,verus,apps,apps_test_461,,"Find the minimum distance Winnie-the-Pooh must travel to have n meals.
Winnie starts at Rabbit's house and has his first meal there.
There are 3 houses: Rabbit, Owl, and Eeyore, forming a triangle.
Distances: Rabbit↔Owl = a meters, Rabbit↔Eeyore = b meters, Owl↔Eeyore = c meters.
After each meal, Winnie must leave the current house and go to one of the two adjacent houses.
He needs n meals total, so he makes (n-1) moves.
Find the minimum total distance for all moves.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, a: int, b: int, c: int) -> bool {
    1 <= n <= 100 && 1 <= a <= 100 && 1 <= b <= 100 && 1 <= c <= 100
}

spec fn min_distance(n: int, a: int, b: int, c: int) -> int
    recommends valid_input(n, a, b, c)
{
    if n == 1 { 0 } else { (n - 1) * min(a, b) }
}

spec fn min(x: int, y: int) -> int {
    if x <= y { x } else { y }
}

spec fn max(x: int, y: int) -> int {
    if x >= y { x } else { y }
}",,"fn solve(n: i8, a: i8, b: i8, c: i8) -> (result: i8)
    requires 
        valid_input(n as int, a as int, b as int, c as int)
    ensures 
        result >= 0,
        n == 1 ==> result == 0,
        result as int <= (n as int - 1) * max(a as int, max(b as int, c as int)),
        result as int == min_distance(n as int, a as int, b as int, c as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0085,verus,apps,apps_test_462,,"Given three distinct integers representing positions of three friends on a number line,
find the minimum total distance they need to travel to meet at a single point.","use vstd::prelude::*;

verus! {

spec fn valid_input(x1: int, x2: int, x3: int) -> bool {
    1 <= x1 <= 100 && 1 <= x2 <= 100 && 1 <= x3 <= 100 &&
    x1 != x2 && x1 != x3 && x2 != x3
}

spec fn min_total_distance(x1: int, x2: int, x3: int) -> int
    recommends valid_input(x1, x2, x3)
{
    let max_pos = if x1 >= x2 && x1 >= x3 { x1 }
                  else if x2 >= x1 && x2 >= x3 { x2 }
                  else { x3 };
    let min_pos = if x1 <= x2 && x1 <= x3 { x1 }
                  else if x2 <= x1 && x2 <= x3 { x2 }
                  else { x3 };
    max_pos - min_pos
}",,"fn find_minimum_total_distance(x1: i8, x2: i8, x3: i8) -> (result: i8)
    requires 
        valid_input(x1 as int, x2 as int, x3 as int)
    ensures 
        result as int == min_total_distance(x1 as int, x2 as int, x3 as int),
        result >= 1 && result <= 99","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0086,verus,apps,apps_test_470,,"Given 5 cards with positive integers, find the minimum sum of remaining cards 
after optionally discarding exactly 2 or 3 cards that have the same number 
(at most one such discard operation allowed).","use vstd::prelude::*;

verus! {

spec fn valid_input(cards: Seq<int>) -> bool {
    cards.len() == 5 && forall|i: int| 0 <= i < cards.len() ==> cards[i] > 0
}

spec fn sum(cards: Seq<int>) -> int
    decreases cards.len()
{
    if cards.len() == 0 {
        0
    } else {
        cards[0] + sum(cards.subrange(1, cards.len() as int))
    }
}

spec fn min_possible_sum_up_to_index(cards: Seq<int>, index: int) -> int 
    decreases index when index >= 0
{
    if index <= 0 {
        sum(cards)
    } else {
        min_possible_sum_up_to_index(cards, index - 1)
    }
}

spec fn min_possible_sum(cards: Seq<int>) -> int {
    min_possible_sum_up_to_index(cards, 5)
}",,"fn solve(cards: Vec<i8>) -> (result: i8)
    requires 
        valid_input(cards@.map(|_index, x: i8| x as int)),
    ensures 
        result >= 0,
        result as int <= sum(cards@.map(|_index, x: i8| x as int)),
        result as int == min_possible_sum(cards@.map(|_index, x: i8| x as int))","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,DupVA03,0.85
VA0087,verus,apps,apps_test_472,,"Given a positive integer n, find the smallest positive integer x such that
x² + s(x)·x - n = 0, where s(x) is the sum of digits of x in decimal notation.
If no such positive integer x exists, return -1.","use vstd::prelude::*;

verus! {
spec fn digit_sum(n: int) -> int
  decreases n when n >= 0
{
  if n <= 0 { 
    0 
  } else { 
    (n % 10) + digit_sum(n / 10) 
  }
}",,"fn solve(n: i8) -> (result: i8)
  requires 
    n >= 1,
  ensures 
    n == 1 ==> result == -1,
    n > 1 && result > 0 ==> (result as int) * (result as int) + digit_sum(result as int) * (result as int) == n as int,
    n > 1 && result > 0 ==> forall|y: int| y > 0 && y < result as int ==> y * y + digit_sum(y) * y != n as int,
    n > 1 && result == -1 ==> forall|x: int| x > 0 ==> x * x + digit_sum(x) * x != n as int,
    result == -1 || result > 0,","{
  // impl-start
  assume(false);
  unreached()
  // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0088,verus,apps,apps_test_473,,"Given a wake-up time and sleep duration, both in ""hh:mm"" 24-hour format,
calculate the bedtime by subtracting the sleep duration from the wake-up time.
Handle day wrap-around when the bedtime falls on the previous day.","use vstd::prelude::*;

verus! {

spec fn valid_time_format(time_str: Seq<char>) -> bool {
    time_str.len() == 5 &&
    time_str[2] == ':' &&
    '0' <= time_str[0] <= '9' && '0' <= time_str[1] <= '9' &&
    '0' <= time_str[3] <= '9' && '0' <= time_str[4] <= '9' &&
    (time_str[0] as int - '0' as int) * 10 + (time_str[1] as int - '0' as int) <= 23 &&
    (time_str[3] as int - '0' as int) * 10 + (time_str[4] as int - '0' as int) <= 59
}

spec fn find_first_newline(s: Seq<char>) -> int {
    choose|i: int| 0 <= i < s.len() && s[i] == '\n'
}

spec fn find_second_newline(s: Seq<char>, first: int) -> int {
    choose|i: int| first < i < s.len() && s[i] == '\n'
}

spec fn valid_input(stdin_input: Seq<char>) -> bool {
    stdin_input.len() > 0 &&
    exists|i: int| 0 <= i < stdin_input.len() && stdin_input[i] == '\n' &&
    exists|i: int, j: int| 0 <= i < j < stdin_input.len() && stdin_input[i] == '\n' && stdin_input[j] == '\n' &&
    {
        let first_nl = find_first_newline(stdin_input);
        let second_nl = find_second_newline(stdin_input, first_nl);
        let s = stdin_input.subrange(0, first_nl);
        let t = stdin_input.subrange(first_nl + 1, second_nl);
        valid_time_format(s) && valid_time_format(t)
    }
}

spec fn parse_time(time_str: Seq<char>) -> (int, int) {
    let h = (time_str[0] as int - '0' as int) * 10 + (time_str[1] as int - '0' as int);
    let m = (time_str[3] as int - '0' as int) * 10 + (time_str[4] as int - '0' as int);
    (h, m)
}

spec fn calculate_bedtime(wake_hour: int, wake_min: int, sleep_hour: int, sleep_min: int) -> (int, int) {
    let wake_total_min = wake_hour * 60 + wake_min;
    let sleep_total_min = sleep_hour * 60 + sleep_min;
    let diff = wake_total_min - sleep_total_min;
    let bed_total_min = if diff >= 0 { diff } else { diff + 24 * 60 };
    (bed_total_min / 60, bed_total_min % 60)
}

spec fn valid_output(result: Seq<char>) -> bool {
    result.len() == 6 &&
    result[result.len() - 1] == '\n' &&
    result[2] == ':' &&
    '0' <= result[0] <= '9' && '0' <= result[1] <= '9' &&
    '0' <= result[3] <= '9' && '0' <= result[4] <= '9' &&
    (result[0] as int - '0' as int) * 10 + (result[1] as int - '0' as int) <= 23 &&
    (result[3] as int - '0' as int) * 10 + (result[4] as int - '0' as int) <= 59
}

spec fn correct_bedtime(stdin_input: Seq<char>, result: Seq<char>) -> bool {
    let first_nl = find_first_newline(stdin_input);
    let second_nl = find_second_newline(stdin_input, first_nl);
    let s = stdin_input.subrange(0, first_nl);
    let t = stdin_input.subrange(first_nl + 1, second_nl);
    let (wake_hour, wake_min) = parse_time(s);
    let (sleep_hour, sleep_min) = parse_time(t);
    let (bed_hour, bed_min) = calculate_bedtime(wake_hour, wake_min, sleep_hour, sleep_min);
    let result_hour = (result[0] as int - '0' as int) * 10 + (result[1] as int - '0' as int);
    let result_min = (result[3] as int - '0' as int) * 10 + (result[4] as int - '0' as int);
    result_hour == bed_hour && result_min == bed_min
}",,"fn solve(stdin_input: &str) -> (result: String)
    requires 
        valid_input(stdin_input@),
    ensures 
        valid_output(result@) &&
        correct_bedtime(stdin_input@, result@)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0089,verus,apps,apps_test_475,,"Count the number of ways to paint n bricks in a row using m colors such that exactly k bricks 
have a different color than the brick immediately to their left. The first brick is not counted 
in this comparison. Result should be modulo 998,244,353.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: nat, m: nat, k: nat) -> bool {
    n >= 1 && m >= 1 && k >= 0 && k <= n - 1
}

spec fn factorial(n: nat) -> nat
    decreases n
{
    if n == 0 { 1 }
    else { n * factorial((n - 1) as nat) }
}

spec fn binomial(n: nat, k: nat) -> nat
    decreases n
{
    if k > n { 0 }
    else if factorial(k) == 0 || factorial((n - k) as nat) == 0 { 0 }
    else { factorial(n) / (factorial(k) * factorial((n - k) as nat)) }
}

spec fn power(base: nat, exp: nat) -> nat
    decreases exp
{
    if exp == 0 { 1 }
    else { base * power(base, (exp - 1) as nat) }
}

spec fn expected_result(n: nat, m: nat, k: nat) -> nat {
    if valid_input(n, m, k) {
        (m * power((m - 1) as nat, k) * binomial((n - 1) as nat, k)) % 998244353
    } else {
        0
    }
}",,"fn solve(n: u64, m: u64, k: u64) -> (result: u64)
    requires n as nat >= 1 && m as nat >= 1 && k as nat >= 0 && k as nat <= n as nat - 1
    ensures result < 998244353","{
    assume(false);
    0
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0090,verus,apps,apps_test_483,,"Given n particles on a line at distinct even-integer positions, where each particle moves 
left (L) or right (R) at speed 1 unit per microsecond, find the time of the first collision 
between any two particles, or return -1 if no collision occurs.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, directions: Seq<char>, positions: Seq<int>) -> bool {
    n >= 1 &&
    directions.len() == n &&
    positions.len() == n &&
    (forall|i: int| 0 <= i < n ==> directions[i] == 'R' || directions[i] == 'L') &&
    (forall|i: int| 0 <= i < n ==> positions[i] % 2 == 0 && positions[i] >= 0) &&
    (forall|i: int, j: int| 0 <= i < j < n ==> positions[i] < positions[j])
}

spec fn has_collision_pair(i: int, directions: Seq<char>) -> bool {
    0 <= i < directions.len()-1 && 
    directions[i] == 'R' && directions[i+1] == 'L'
}

spec fn has_collision(directions: Seq<char>, positions: Seq<int>) -> bool 
    recommends directions.len() == positions.len()
{
    exists|i: int| #[trigger] has_collision_pair(i, directions)
}

spec fn collision_time(i: int, positions: Seq<int>) -> int
    recommends 0 <= i < positions.len()-1
{
    (positions[i+1] - positions[i]) / 2
}

spec fn is_minimal_collision_time(result: int, directions: Seq<char>, positions: Seq<int>) -> bool
    recommends directions.len() == positions.len()
{
    (forall|i: int| has_collision_pair(i, directions) ==> 
        collision_time(i, positions) >= result) &&
    (exists|i: int| #[trigger] has_collision_pair(i, directions) && 
        collision_time(i, positions) == result)
}",,"fn solve(n: i8, directions: Vec<char>, positions: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, directions@, positions@.map(|i: int, v: i8| v as int)),
    ensures 
        result == -1 || result >= 0,
        result != -1 ==> has_collision(directions@, positions@.map(|i: int, v: i8| v as int)),
        result == -1 ==> !has_collision(directions@, positions@.map(|i: int, v: i8| v as int)),
        result != -1 ==> is_minimal_collision_time(result as int, directions@, positions@.map(|i: int, v: i8| v as int)),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0091,verus,apps,apps_test_484,,"Given a rectangular piece of paper of dimensions a × b and n rectangular seals with dimensions x_i × y_i,
find the maximum total area that can be covered by placing exactly two different seals on the paper.
Each seal can be rotated 90 degrees, and the impressions must not overlap (but can touch).
If no two seals can fit on the paper, return 0.","use vstd::prelude::*;

verus! {

spec fn check_pair_func(seal1: (int, int), seal2: (int, int), a: int, b: int) -> int
{
    let orientations = seq![(seal1, seal2), (seal1, (seal2.1, seal2.0)), ((seal1.1, seal1.0), seal2), ((seal1.1, seal1.0), (seal2.1, seal2.0))];

    let area0 = if can_fit(orientations[0].0, orientations[0].1, a, b) {
        orientations[0].0.0 * orientations[0].0.1 + orientations[0].1.0 * orientations[0].1.1
    } else {
        0
    };

    let area1 = if can_fit(orientations[1].0, orientations[1].1, a, b) {
        orientations[1].0.0 * orientations[1].0.1 + orientations[1].1.0 * orientations[1].1.1
    } else {
        0
    };

    let area2 = if can_fit(orientations[2].0, orientations[2].1, a, b) {
        orientations[2].0.0 * orientations[2].0.1 + orientations[2].1.0 * orientations[2].1.1
    } else {
        0
    };

    let area3 = if can_fit(orientations[3].0, orientations[3].1, a, b) {
        orientations[3].0.0 * orientations[3].0.1 + orientations[3].1.0 * orientations[3].1.1
    } else {
        0
    };

    max_spec(max_spec(area0, area1), max_spec(area2, area3))
}

spec fn can_fit(r1: (int, int), r2: (int, int), a: int, b: int) -> bool
{
    (r1.0 + r2.0 <= a && max_spec(r1.1, r2.1) <= b) || (max_spec(r1.0, r2.0) <= a && r1.1 + r2.1 <= b)
}

spec fn max_spec(x: int, y: int) -> int
{
    if x >= y { x } else { y }
}",,"fn solve(n: i8, a: i8, b: i8, seals: Vec<(i8, i8)>) -> (result: i8)
    requires n >= 0,
            a >= 1 && b >= 1,
            seals.len() == n as nat,
            forall|i: int| 0 <= i < n as int ==> seals@[i].0 as int >= 1 && seals@[i].1 as int >= 1,
    ensures result as int >= 0,
            result as int == 0 ==> (forall|i: int, j: int| 0 <= i < n as int && i < j < n as int ==> check_pair_func((seals@[i].0 as int, seals@[i].1 as int), (seals@[j].0 as int, seals@[j].1 as int), a as int, b as int) == 0),
            result as int > 0 ==> (exists|i: int, j: int| 0 <= i < n as int && i < j < n as int && check_pair_func((seals@[i].0 as int, seals@[i].1 as int), (seals@[j].0 as int, seals@[j].1 as int), a as int, b as int) == result as int),
            forall|i: int, j: int| 0 <= i < n as int && i < j < n as int ==> check_pair_func((seals@[i].0 as int, seals@[i].1 as int), (seals@[j].0 as int, seals@[j].1 as int), a as int, b as int) <= result as int,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0092,verus,apps,apps_test_486,,"Given a positive integer n, find the maximum product of digits among all integers from 1 to n inclusive.
The product of digits is calculated by multiplying all individual digits together.","use vstd::prelude::*;

verus! {

spec fn product_of_digits(x: int) -> int
  recommends x >= 0
  decreases x
{
  if x == 0 { 1 }
  else if x < 10 { x }
  else { (x % 10) * product_of_digits(x / 10) }
}

spec fn max_product_of_digits_in_range(n: int) -> int
  recommends n >= 1
  decreases n
  when n >= 1
{
  if n == 1 { 1 }
  else {
    let current = product_of_digits(n);
    let rest = max_product_of_digits_in_range(n - 1);
    if current > rest { current } else { rest }
  }
}",,"fn solve(n: i8) -> (result: i8)
  requires 
    n >= 1
  ensures 
    result as int == max_product_of_digits_in_range(n as int),
    result >= 1,
    forall|k: int| 1 <= k <= n as int ==> product_of_digits(k) <= result as int,
    exists|k: int| 1 <= k <= n as int && product_of_digits(k) == result as int","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0093,verus,apps,apps_test_491,,"Given an integer n representing a bank account balance, perform at most one operation:
delete the last digit, delete the digit before the last digit, or do nothing.
Find the maximum possible balance after performing the operation.
Constraint: absolute value of n is at least 10.

/* delete last digit */

/* delete digit before last */","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int) -> bool {
    n >= 10 || n <= -10
}

spec fn max_balance_after_operation(n: int) -> int
    recommends valid_input(n)
{
    if n >= 0 {
        n
    } else {
        /* For negative numbers, we need to delete either the last digit
           or the digit before the last digit to maximize the balance.
           Since this involves string operations that are not easily
           expressible in pure logic, we use a simplified specification. */
        let option1 = n / 10;
        let option2 = (n / 100) * 10 + (n % 10);
        if option1 > option2 { option1 } else { option2 }
    }
}",,"fn solve(n: i8) -> (result: i8)
    requires valid_input(n as int)
    ensures result as int == max_balance_after_operation(n as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0094,verus,apps,apps_test_492,,"A spinner has 4 positions encoded as v, >, ^, < (representing positions 0, 1, 2, 3 respectively).
The spinner rotates by changing position every second, either clockwise or counter-clockwise.
Given the starting position, ending position, and rotation duration n seconds, determine the rotation direction.","use vstd::prelude::*;

verus! {
spec fn char_to_pos_spec(c: Seq<char>) -> int {
    if c.len() == 1 && c[0] == 'v' { 0 }
    else if c.len() == 1 && c[0] == '>' { 1 }
    else if c.len() == 1 && c[0] == '^' { 2 }
    else if c.len() == 1 && c[0] == '<' { 3 }
    else { 0 }
}

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0
}

spec fn valid_output(result: Seq<char>) -> bool {
    result == seq!['c', 'w'] || result == seq!['c', 'c', 'w'] || result == seq!['u', 'n', 'd', 'e', 'f', 'i', 'n', 'e', 'd']
}",,"fn solve(input: &str) -> (result: String)
    requires valid_input(input@)
    ensures valid_output(result@)","{
    // impl-start
    assume(false);
    ""undefined"".to_string()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0095,verus,apps,apps_test_498,,"Given a classroom with n lanes and m desks per lane, where each desk has 2 seats (left and right),
find the lane, desk, and side for seat number k. Seats are numbered 1 to 2nm in order:
by lane first, then by desk within each lane, then left seat before right seat within each desk.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, m: int, k: int) -> bool {
    1 <= n <= 10000 && 1 <= m <= 10000 && 1 <= k <= 2 * n * m
}

spec fn valid_output(n: int, m: int, lane: int, desk: int, side: char) -> bool {
    1 <= lane <= n && 1 <= desk <= m && (side == 'L' || side == 'R')
}

spec fn correct_solution(n: int, m: int, k: int, lane: int, desk: int, side: char) -> bool
    recommends valid_input(n, m, k)
{
    lane == (k - 1) / (2 * m) + 1 &&
    desk == (k - 1) % (2 * m) / 2 + 1 &&
    (side == 'L' <==> (k - 1) % (2 * m) % 2 == 0)
}",,"fn solve(n: i32, m: i32, k: i32) -> (result: (i32, i32, char))
    requires valid_input(n as int, m as int, k as int)
    ensures ({
        let (lane, desk, side) = result;
        valid_output(n as int, m as int, lane as int, desk as int, side) &&
        correct_solution(n as int, m as int, k as int, lane as int, desk as int, side)
    })","{
    assume(false);
    (0, 0, 'L')
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0098,verus,apps,apps_test_506,,"Given a rectangular sheet of paper with dimensions a × b millimeters (where a > b),
determine how many square pieces can be cut from it using the following process:
1. From the current rectangle, cut the largest possible square
2. Continue with the remaining rectangular strip (if any exists)  
3. Repeat until only a square remains
4. Count the total number of squares cut","use vstd::prelude::*;

verus! {
spec fn valid_input(a: int, b: int) -> bool {
    a > 0 && b > 0
}

spec fn count_squares(a: int, b: int) -> int
    recommends a >= 0 && b >= 0
    decreases a + b when a > 0 && b > 0
{
    if a == 0 || b == 0 {
        0
    } else if a > b {
        if b == 0 { 0 } else {
            a / b + count_squares(a % b, b)
        }
    } else if b > a {
        if a == 0 { 0 } else {
            b / a + count_squares(a, b % a)
        }
    } else {
        1
    }
}",,"fn solve(a: i8, b: i8) -> (result: i8)
    requires valid_input(a as int, b as int)
    ensures 
        result >= 0,
        a == b ==> result == 1,
        a > b ==> result >= 1,
        result as int == count_squares(a as int, b as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0100,verus,apps,apps_test_511,,"Given a function f(a, b) defined as f(a, 0) = 0 and f(a, b) = 1 + f(a, b - gcd(a, b)) for b > 0,
calculate f(x, y) for given integers x and y. The input is a string containing two integers
separated by a space, and the output is a string containing the result.","use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 &&
    (exists|i: int| 0 <= i < input.len() && input[i] == ' ') &&
    (forall|j: int| 0 <= j < input.len() ==> 
        ('0' <= input[j] <= '9' || input[j] == ' ' || input[j] == '\n'))
}

spec fn gcd(a: nat, b: nat) -> nat 
    decreases a + b
{
    if a == 0 { b }
    else if b == 0 { a }
    else if a > b { gcd((a - b) as nat, b) }
    else { gcd(a, (b - a) as nat) }
}

#[verifier::opaque]
spec fn f_mathematical(x: nat, y: nat) -> nat
    decreases y
{
    y / 2
}

spec fn valid_output(result: Seq<char>) -> bool {
    result.len() > 0 &&
    (forall|i: int| 0 <= i < result.len() ==> 
        ('0' <= result[i] <= '9' || result[i] == '\n')) &&
    result[result.len() - 1] == '\n'
}",,"fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(input@)
    ensures valid_output(result@)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0101,verus,apps,apps_test_520,,"Given a list of university entrance years for groups that student Igor joined,
determine Igor's entrance year. Igor joins his own group and all groups
where the entrance year differs by at most x years from his entrance year.
The solution computes Igor's entrance year as the average of all group years.","use vstd::prelude::*;

verus! {
spec fn sum_range(s: Seq<int>, start: int, end: int) -> int
    decreases end - start when 0 <= start <= end <= s.len()
{
    if start == end {
        0
    } else {
        s[start] + sum_range(s, start + 1, end)
    }
}

spec fn valid_input(n: int, years: Seq<int>) -> bool
{
    n > 0 && years.len() == n
}",,"fn solve(n: i8, years: Vec<i8>) -> (result: i8)
    requires n > 0 && years.len() == n as nat
    ensures result as int == sum_range(years@.map(|i, x| x as int), 0, years.len() as int) / (n as int)","{
    assume(false);
    0
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0102,verus,apps,apps_test_529,,"Given a string and an integer n (0 ≤ n ≤ 26), transform the string by:
1. Converting the entire string to lowercase
2. For each character, if it is lexicographically smaller than the nth letter 
   of the alphabet (0-indexed), convert it to uppercase; otherwise, keep it lowercase
3. When n = 26, use '|' as the comparison character (which comes after 'z')","use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>, n: int) -> bool {
  0 <= n <= 26
}

spec fn get_comparison_char(n: int) -> char {
  if n == 0 { 'a' }
  else if n == 1 { 'b' }
  else if n == 2 { 'c' }
  else if n == 3 { 'd' }
  else if n == 4 { 'e' }
  else if n == 5 { 'f' }
  else if n == 6 { 'g' }
  else if n == 7 { 'h' }
  else if n == 8 { 'i' }
  else if n == 9 { 'j' }
  else if n == 10 { 'k' }
  else if n == 11 { 'l' }
  else if n == 12 { 'm' }
  else if n == 13 { 'n' }
  else if n == 14 { 'o' }
  else if n == 15 { 'p' }
  else if n == 16 { 'q' }
  else if n == 17 { 'r' }
  else if n == 18 { 's' }
  else if n == 19 { 't' }
  else if n == 20 { 'u' }
  else if n == 21 { 'v' }
  else if n == 22 { 'w' }
  else if n == 23 { 'x' }
  else if n == 24 { 'y' }
  else if n == 25 { 'z' }
  else { '|' }
}

spec fn is_lowercase(c: char) -> bool {
  'a' <= c && c <= 'z'
}

spec fn is_uppercase(c: char) -> bool {
  'A' <= c && c <= 'Z'
}

spec fn to_lowercase(c: char) -> char {
  if is_uppercase(c) {
    ((c as u8) - ('A' as u8) + ('a' as u8)) as char
  } else {
    c
  }
}

spec fn to_uppercase(c: char) -> char {
  if is_lowercase(c) {
    ((c as u8) - ('a' as u8) + ('A' as u8)) as char
  } else {
    c
  }
}

spec fn transform_string(s: Seq<char>, n: int) -> Seq<char> {
  let comp_char = get_comparison_char(n);
  transform_with_comp_char(to_lowercase_string(s), comp_char)
}

spec fn to_lowercase_string(s: Seq<char>) -> Seq<char>
  decreases s.len()
{
  if s.len() == 0 {
    s
  } else {
    s.subrange(0, 1).map(|_i: int, c: char| to_lowercase(c)) + to_lowercase_string(s.skip(1))
  }
}

spec fn transform_with_comp_char(s: Seq<char>, comp_char: char) -> Seq<char>
  decreases s.len()
{
  if s.len() == 0 {
    s
  } else if s[0] < comp_char {
    s.subrange(0, 1).map(|_i: int, c: char| to_uppercase(c)) + transform_with_comp_char(s.skip(1), comp_char)
  } else {
    s.subrange(0, 1) + transform_with_comp_char(s.skip(1), comp_char)
  }
}",,"fn solve(s: Vec<char>, n: i8) -> (result: Vec<char>)
  requires valid_input(s@, n as int)
  ensures result@ == transform_string(s@, n as int)","{
  // impl-start
  assume(false);
  s
  // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0103,verus,apps,apps_test_530,,"Two players play a game with binary strings. They alternate turns choosing positions
from strings of length 2n, collecting characters to form the largest possible binary
numbers. Determine the winner with optimal play.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, a: Seq<char>, b: Seq<char>) -> bool {
    n > 0 && a.len() == 2 * n && b.len() == 2 * n &&
    (forall|i: int| 0 <= i < a.len() ==> a[i] == '0' || a[i] == '1') &&
    (forall|i: int| 0 <= i < b.len() ==> b[i] == '0' || b[i] == '1')
}

spec fn count_positions(a: Seq<char>, b: Seq<char>, ac: char, bc: char, len: int) -> int
    recommends len >= 0 && len <= a.len() && len <= b.len(),
               ac == '0' || ac == '1',
               bc == '0' || bc == '1'
{
    Set::new(|i: int| 0 <= i < len && a[i] == ac && b[i] == bc).len() as int
}

spec fn compute_game_outcome(t00: int, t01: int, t10: int, t11: int) -> int {
    t11 % 2 + (t10 - t01 + 1 - t11 % 2) / 2
}

spec fn correct_outcome(result: &str, d: int) -> bool {
    (d > 0 ==> result == ""First"") &&
    (d < 0 ==> result == ""Second"") &&
    (d == 0 ==> result == ""Draw"")
}",,"fn solve(n: i8, a: Vec<char>, b: Vec<char>) -> (result: &'static str)
    requires n as int > 0 && a@.len() == 2 * n as int && b@.len() == 2 * n as int &&
             (forall|i: int| 0 <= i < a@.len() ==> a@[i] == '0' || a@[i] == '1') &&
             (forall|i: int| 0 <= i < b@.len() ==> b@[i] == '0' || b@[i] == '1')
    ensures result == ""First"" || result == ""Second"" || result == ""Draw""","{
    assume(false);
    ""Draw""
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0104,verus,apps,apps_test_533,,"Given two football teams with a1 and a2 players respectively, where players from team 1
are sent off after k1 yellow cards and players from team 2 are sent off after k2 yellow cards.
A total of n yellow cards were shown during the match. Find the minimum and maximum number
of players that could have been sent off.","use vstd::prelude::*;

verus! {
spec fn valid_input(a1: int, a2: int, k1: int, k2: int, n: int) -> bool {
    a1 >= 1 && a2 >= 1 && k1 >= 1 && k2 >= 1 && n >= 1
}

spec fn minimum_sent_off(a1: int, a2: int, k1: int, k2: int, n: int) -> int
    recommends valid_input(a1, a2, k1, k2, n)
{
    let max_non_sendoff_cards = (k1 - 1) * a1 + (k2 - 1) * a2;
    if n - max_non_sendoff_cards > 0 { n - max_non_sendoff_cards } else { 0 }
}

spec fn maximum_sent_off(a1: int, a2: int, k1: int, k2: int, n: int) -> int
    recommends valid_input(a1, a2, k1, k2, n)
{
    if k1 < k2 {
        let team1_sent = if n / k1 < a1 { n / k1 } else { a1 };
        let remaining_cards = n - team1_sent * k1;
        team1_sent + remaining_cards / k2
    } else {
        let team2_sent = if n / k2 < a2 { n / k2 } else { a2 };
        let remaining_cards = n - team2_sent * k2;
        team2_sent + remaining_cards / k1
    }
}

spec fn valid_result(a1: int, a2: int, k1: int, k2: int, n: int, minimum: int, maximum: int) -> bool
    recommends valid_input(a1, a2, k1, k2, n)
{
    minimum >= 0 && maximum >= 0 &&
    minimum <= maximum &&
    maximum <= a1 + a2 &&
    minimum <= n &&
    maximum <= n &&
    minimum == minimum_sent_off(a1, a2, k1, k2, n) &&
    maximum == maximum_sent_off(a1, a2, k1, k2, n)
}",,"fn solve(a1: i8, a2: i8, k1: i8, k2: i8, n: i8) -> (ret: (i8, i8))
    requires valid_input(a1 as int, a2 as int, k1 as int, k2 as int, n as int)
    ensures valid_result(a1 as int, a2 as int, k1 as int, k2 as int, n as int, ret.0 as int, ret.1 as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0105,verus,apps,apps_test_537,,"Given n students and a ratio k, distribute awards (diplomas and certificates) to maximize 
the number of winners while following constraints: certificates = k × diplomas, 
total winners ≤ n/2. Output the number of diplomas, certificates, and non-winners.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, k: int) -> bool {
    n >= 0 && k >= 0 && k + 1 > 0
}

spec fn valid_output(result: Seq<int>, n: int, k: int) -> bool {
    result.len() == 3 &&
    result[0] >= 0 && result[1] >= 0 && result[2] >= 0 &&
    result[1] == result[0] * k &&
    result[0] + result[1] <= n / 2 &&
    result[2] == n - result[0] - result[1]
}

spec fn optimal_diplomas(n: int, k: int) -> int
    recommends valid_input(n, k)
{
    (n / 2) / (k + 1)
}",,"fn solve(n: i8, k: i8) -> (result: Vec<i8>)
    requires valid_input(n as int, k as int)
    ensures 
        valid_output(result@.map(|i, x| x as int), n as int, k as int) &&
        result@[0] as int == optimal_diplomas(n as int, k as int)","{
    // impl-start
    assume(false);
    Vec::new()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0108,verus,apps,apps_test_548,,"Two players play a game on an array of integers, alternating turns.
First player removes subsegments with odd sum, second player removes subsegments with even sum.
After removal, remaining parts are concatenated. Player who cannot move loses.
Determine the winner assuming optimal play.","use vstd::prelude::*;

verus! {
spec fn all_even(a: Seq<int>) -> bool {
    forall|i: int| 0 <= i < a.len() ==> a[i] % 2 == 0
}

spec fn has_odd(a: Seq<int>) -> bool {
    exists|i: int| 0 <= i < a.len() && a[i] % 2 == 1
}",,"fn solve(a: Vec<i8>) -> (result: &'static str)
    ensures 
        (result == ""Second"") <==> all_even(a@.map(|i: int, x: i8| x as int)),
        (result == ""First"") <==> has_odd(a@.map(|i: int, x: i8| x as int)),
        result == ""First"" || result == ""Second"",","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0109,verus,apps,apps_test_553,,"Given n promotional codes (each exactly 6 digits), find the maximum number k such that 
any promotional code can be uniquely identified even when typed with at most k digit errors.
This requires finding the minimum Hamming distance between any pair of promotional codes,
then computing k = floor((min_distance - 1) / 2).","use vstd::prelude::*;

verus! {
spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {
    seq![s]
}

spec fn parse_integer(s: Seq<char>) -> int {
    6
}

spec fn hamming_distance(s1: Seq<char>, s2: Seq<char>) -> int {
    if s1 == s2 { 0 } else { 6 }
}

spec fn valid_input(stdin_input: Seq<char>) -> bool {
    stdin_input.len() > 0
}

spec fn valid_output(output: Seq<char>, stdin_input: Seq<char>) -> bool {
    output.len() >= 2 &&
    output[output.len() - 1] == '\n' &&
    ({
        let lines = split_lines(stdin_input);
        lines.len() >= 1 &&
        ({
            let n: int = 6;
            n >= 1 && 
            n == 6 &&
            lines.len() >= 1 &&
            ({
                let k: int = 6;
                0 <= k <= 6 &&
                k == 6 &&
                parse_integer(output.subrange(0, output.len() - 1)) == k
            })
        })
    })
}",,"fn solve(stdin_input: Vec<u8>) -> (output: Vec<u8>)
    requires valid_input(stdin_input@.map_values(|x: u8| x as char))
    ensures valid_output(output@.map_values(|x: u8| x as char), stdin_input@.map_values(|x: u8| x as char))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0110,verus,apps,apps_test_566,,"Given r red balloons, g green balloons, and b blue balloons, determine the maximum number of tables that can be decorated.
Each table requires exactly 3 balloons, and no table can have all 3 balloons of the same color.","use vstd::prelude::*;

verus! {
spec fn valid_input(r: int, g: int, b: int) -> bool {
    r >= 0 && g >= 0 && b >= 0
}

spec fn max_tables(r: int, g: int, b: int) -> int
    recommends valid_input(r, g, b)
{
    min(min(min((r + g + b) / 3, r + g), r + b), g + b)
}

spec fn min(a: int, b: int) -> int {
    if a <= b { a } else { b }
}",,"fn solve(r: i8, g: i8, b: i8) -> (result: i8)
    requires 
        valid_input(r as int, g as int, b as int)
    ensures 
        result as int == max_tables(r as int, g as int, b as int),
        result >= 0","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0111,verus,apps,apps_test_569,,"Given a string of lowercase English letters, find the minimum number of character 
changes needed to make all substrings distinct. If the string length exceeds 26,
it's impossible since we only have 26 distinct lowercase letters available.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, s: Seq<char>) -> bool {
    n == s.len() && n >= 1
}

spec fn count_distinct_chars(s: Seq<char>) -> int {
    s.to_set().len() as int
}",,"fn solve(n: usize, s: Vec<char>) -> (result: i32)
    requires 
        valid_input(n as int, s@)
    ensures 
        n > 26 ==> result == -1,
        n <= 26 ==> result >= 0 && result < n as i32,
        n <= 26 ==> result == s@.len() as i32 - count_distinct_chars(s@)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0112,verus,apps,apps_test_584,,"Given a string containing letters, underscores, and properly matched parentheses,
find the length of the longest word outside parentheses and count words inside parentheses.
Words are maximal sequences of consecutive letters separated by underscores or parentheses.","use vstd::prelude::*;

verus! {

spec fn is_letter(c: char) -> bool {
    ('a' <= c <= 'z') || ('A' <= c <= 'Z')
}

spec fn valid_parentheses(input: Seq<char>) -> bool {
    let newline_pos = find_newline(input);
    if newline_pos >= input.len() {
        true
    } else {
        let s = if newline_pos + 1 < input.len() { 
            input.subrange(newline_pos + 1, input.len() as int) 
        } else { 
            seq![] 
        };
        is_valid_parentheses_sequence(s, 0, 0)
    }
}

spec fn is_valid_parentheses_sequence(s: Seq<char>, pos: int, balance: int) -> bool
    recommends 0 <= pos <= s.len(), balance >= 0
    decreases s.len() - pos
{
    if pos >= s.len() {
        balance == 0
    } else {
        let c = s[pos];
        let new_balance = if c == '(' { 
            balance + 1 
        } else if c == ')' { 
            balance - 1 
        } else { 
            balance 
        };
        new_balance >= 0 && is_valid_parentheses_sequence(s, pos + 1, new_balance)
    }
}

spec fn longest_word_outside(input: Seq<char>) -> int {
    let newline_pos = find_newline(input);
    if newline_pos >= input.len() {
        0
    } else {
        let s = if newline_pos + 1 < input.len() { 
            input.subrange(newline_pos + 1, input.len() as int) 
        } else { 
            seq![] 
        };
        compute_longest_outside(s, 0, 0, 0, 0)
    }
}

spec fn count_words_inside(input: Seq<char>) -> int {
    let newline_pos = find_newline(input);
    if newline_pos >= input.len() {
        0
    } else {
        let s = if newline_pos + 1 < input.len() { 
            input.subrange(newline_pos + 1, input.len() as int) 
        } else { 
            seq![] 
        };
        compute_count_inside(s, 0, 0, 0)
    }
}

spec fn valid_output(input: Seq<char>, len_out: int, count_in: int) -> bool {
    len_out >= 0 && count_in >= 0 &&
    len_out == longest_word_outside(input) &&
    count_in == count_words_inside(input)
}

spec fn find_newline(input: Seq<char>) -> int {
    find_newline_helper(input, 0)
}

spec fn find_newline_helper(input: Seq<char>, pos: int) -> int
    recommends 0 <= pos <= input.len()
    decreases input.len() - pos
{
    if pos >= input.len() {
        pos
    } else if input[pos] == '\n' {
        pos
    } else {
        find_newline_helper(input, pos + 1)
    }
}

spec fn compute_longest_outside(s: Seq<char>, pos: int, balance: int, cur: int, best: int) -> int
    recommends 0 <= pos <= s.len(), balance >= 0, cur >= 0, best >= 0
    decreases s.len() - pos
{
    if pos >= s.len() {
        if cur > best && balance == 0 { cur } else { best }
    } else {
        let c = s[pos];
        let new_balance = if c == '(' { 
            balance + 1 
        } else if c == ')' { 
            if balance > 0 { balance - 1 } else { 0 }
        } else { 
            balance 
        };
        let new_cur = if is_letter(c) { 
            cur + 1
        } else if cur > 0 { 
            0
        } else { 
            cur 
        };
        let new_best = if !is_letter(c) && cur > 0 && balance == 0 {
            if cur > best { cur } else { best }
        } else { 
            best 
        };
        compute_longest_outside(s, pos + 1, new_balance, new_cur, new_best)
    }
}

spec fn compute_count_inside(s: Seq<char>, pos: int, balance: int, cur: int) -> int
    recommends 0 <= pos <= s.len(), balance >= 0, cur >= 0
    decreases s.len() - pos
{
    if pos >= s.len() {
        0
    } else {
        let c = s[pos];
        let new_balance = if c == '(' { 
            balance + 1 
        } else if c == ')' { 
            if balance > 0 { balance - 1 } else { 0 }
        } else { 
            balance 
        };
        let new_cur = if is_letter(c) { 
            cur + 1
        } else if cur > 0 { 
            0
        } else { 
            cur 
        };
        let word_ended = !is_letter(c) && cur > 0;
        let count_increment: int = if word_ended && balance > 0 { 1 } else { 0 };
        count_increment + compute_count_inside(s, pos + 1, new_balance, new_cur)
    }
}",,"fn solve(input: Vec<char>) -> (result: (usize, usize))
    requires
        input@.len() > 0,
        exists|i: int| 0 <= i < input@.len() && input@[i] == '\n',
        forall|i: int| 0 <= i < input@.len() ==> (is_letter(input@[i]) || input@[i] == '_' || input@[i] == '(' || input@[i] == ')' || input@[i] == '\n' || input@[i] == '\r' || ('0' <= input@[i] <= '9')),
        valid_parentheses(input@)
    ensures
        result.0 >= 0 && result.1 >= 0,
        result.0 as int == longest_word_outside(input@),
        result.1 as int == count_words_inside(input@),
        valid_output(input@, result.0 as int, result.1 as int)","{
    // impl-start
    assume(false);
    (0, 0)
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0113,verus,apps,apps_test_600,,"Two friends at integer positions a and b on a number line need to meet at the same position.
Each move costs increasing tiredness: 1st move costs 1, 2nd move costs 2, etc.
Find the minimum total tiredness for both friends to meet.","use vstd::prelude::*;

verus! {
spec fn valid_input(a: int, b: int) -> bool {
    a >= 1 && a <= 1000 && b >= 1 && b <= 1000 && a != b
}

spec fn optimal_meeting_point(a: int, b: int) -> int {
    (a + b) / 2
}

spec fn tiredness_for_steps(steps: int) -> int
    decreases steps
{
    if steps <= 0 { 0 } else { steps + tiredness_for_steps(steps - 1) }
}

spec fn minimum_total_tiredness(a: int, b: int) -> int
    recommends valid_input(a, b)
{
    let c = optimal_meeting_point(a, b);
    tiredness_for_steps(if c >= a { c - a } else { a - c }) + 
    tiredness_for_steps(if b >= c { b - c } else { c - b })
}",,"fn solve(a: i8, b: i8) -> (result: i8)
    requires 
        valid_input(a as int, b as int),
    ensures 
        result >= 0,
        result as int == minimum_total_tiredness(a as int, b as int),","{
    assume(false);
    0
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0115,verus,apps,apps_test_602,,"Given an integer a (1 ≤ a ≤ 40), output the last name of the a-th President of the United States.","use vstd::prelude::*;

verus! {
spec fn valid_input(a: int) -> bool {
    1 <= a <= 40
}

spec fn presidents() -> Seq<&'static str> {
    seq![
        ""Washington"", ""Adams"", ""Jefferson"", ""Madison"", ""Monroe"", ""Adams"", ""Jackson"", 
        ""Van Buren"", ""Harrison"", ""Tyler"", ""Polk"", ""Taylor"", ""Fillmore"", ""Pierce"", 
        ""Buchanan"", ""Lincoln"", ""Johnson"", ""Grant"", ""Hayes"", ""Garfield"", ""Arthur"", 
        ""Cleveland"", ""Harrison"", ""Cleveland"", ""McKinley"", ""Roosevelt"", ""Taft"", 
        ""Wilson"", ""Harding"", ""Coolidge"", ""Hoover"", ""Roosevelt"", ""Truman"", 
        ""Eisenhower"", ""Kennedy"", ""Johnson"", ""Nixon"", ""Ford"", ""Carter"", ""Reagan""
    ]
}",,"fn solve(a: i8) -> (result: &'static str)
    requires valid_input(a as int)
    ensures result == presidents()[(a as int) - 1]","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0116,verus,apps,apps_test_604,,"Given an array of integers, find the minimum number of seconds needed to make all elements zero.
In each second, you can add an arbitrary integer to all non-zero elements in the array.
The key insight is that the answer equals the number of distinct non-zero values in the array.

/* No specific constraints on input beyond being a sequence of integers */","use vstd::prelude::*;

verus! {
spec fn valid_input(arr: Seq<int>) -> bool {
    true
}

spec fn distinct_non_zero_count(arr: Seq<int>) -> int {
    Set::<int>::new(|x: int| arr.contains(x) && x != 0).len() as int
}","spec fn vec_to_seq_int(arr: Vec<i8>) -> Seq<int> {
    arr@.map(|i, x| x as int)
}
","fn solve(arr: Vec<i8>) -> (result: i8)
    requires 
        valid_input(vec_to_seq_int(arr))
    ensures 
        result >= 0,
        result as int <= arr@.len(),
        result as int == distinct_non_zero_count(vec_to_seq_int(arr))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,0.7
VA0117,verus,apps,apps_test_605,,"Compare scores of two contestants Misha and Vasya in a programming contest.
Misha solved a problem worth 'a' points and submitted it 'c' minutes after start.
Vasya solved a problem worth 'b' points and submitted it 'd' minutes after start.
Scoring formula: max(3p/10, p - p*t/250) where p is original points, t is time.
Return ""Misha"", ""Vasya"", or ""Tie"" based on who scored higher.","use vstd::prelude::*;

verus! {
spec fn valid_input(a: int, b: int, c: int, d: int) -> bool {
    250 <= a <= 3500 && a % 250 == 0 &&
    250 <= b <= 3500 && b % 250 == 0 &&
    0 <= c <= 180 &&
    0 <= d <= 180
}

spec fn calculate_score(points: int, time: int) -> int {
    let min_score = 3 * points / 10;
    let time_adjusted = points - points * time / 250;
    if min_score >= time_adjusted { min_score } else { time_adjusted }
}

spec fn correct_result(a: int, b: int, c: int, d: int, result: Seq<char>) -> bool {
    let misha_score = calculate_score(a, c);
    let vasya_score = calculate_score(b, d);
    (result == seq!['M','i','s','h','a'] <==> misha_score > vasya_score) &&
    (result == seq!['V','a','s','y','a'] <==> vasya_score > misha_score) &&
    (result == seq!['T','i','e'] <==> misha_score == vasya_score)
}",,"fn determine_winner(a: i8, b: i8, c: i8, d: i8) -> (result: String)
    requires 
        valid_input(a as int, b as int, c as int, d as int)
    ensures 
        result@ == seq!['M','i','s','h','a'] || result@ == seq!['V','a','s','y','a'] || result@ == seq!['T','i','e'],
        correct_result(a as int, b as int, c as int, d as int, result@)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0119,verus,apps,apps_test_610,,"Given n red cubes and m blue cubes, two players take turns placing cubes in a line.
Petya moves first and wants to maximize same-color adjacent pairs.
Vasya moves second and wants to maximize different-color adjacent pairs.
Both players play optimally. Calculate final scores for both players.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, m: int) -> bool {
    n >= 1 && m >= 1
}

spec fn optimal_vasya_score(n: int, m: int) -> int {
    if n < m { n } else { m }
}

spec fn optimal_petya_score(n: int, m: int) -> int {
    n + m - 1 - optimal_vasya_score(n, m)
}

spec fn total_adjacent_pairs(n: int, m: int) -> int {
    n + m - 1
}",,"fn solve(n: i8, m: i8) -> (result: (i8, i8))
    requires 
        valid_input(n as int, m as int)
    ensures 
        result.0 as int == optimal_petya_score(n as int, m as int) &&
        result.1 as int == optimal_vasya_score(n as int, m as int) &&
        result.0 as int + result.1 as int == total_adjacent_pairs(n as int, m as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0120,verus,apps,apps_test_613,,"Find the number of polynomials P(x) with non-negative integer coefficients 
such that P(t) = a and P(P(t)) = b, where t, a, and b are given positive integers.
Since P(t) = a, the second condition becomes P(a) = b.
Output ""inf"" if infinitely many such polynomials exist, otherwise output the count.","use vstd::prelude::*;

verus! {
spec fn valid_input(t: int, a: int, b: int) -> bool {
    t > 0 && a > 0 && b > 0
}

spec fn valid_output(res: String) -> bool {
    res@ == ""0""@ || res@ == ""1""@ || res@ == ""2""@ || res@ == ""inf""@
}

spec fn infinite_case(t: int, a: int, b: int) -> bool {
    a == t && a == b && a == 1
}

spec fn two_solutions_case(t: int, a: int, b: int) -> bool {
    a == t && a == b && a != 1
}

spec fn zero_solutions_case(t: int, a: int, b: int) -> bool {
    (t == 2 && a == 3 && b > 10000) ||
    (a == t && a != b) ||
    (a != t && (a - b) % (t - a) == 0) ||
    (a != t && (a - b) % (t - a) != 0 && t == b)
}

spec fn one_solution_case(t: int, a: int, b: int) -> bool {
    a != t && (a - b) % (t - a) != 0 && t != b
}",,"fn solve(t: i8, a: i8, b: i8) -> (res: String)
    requires 
        valid_input(t as int, a as int, b as int),
    ensures 
        valid_output(res),
        infinite_case(t as int, a as int, b as int) ==> res@ == ""inf""@,
        two_solutions_case(t as int, a as int, b as int) ==> res@ == ""2""@,
        zero_solutions_case(t as int, a as int, b as int) ==> res@ == ""0""@,
        one_solution_case(t as int, a as int, b as int) ==> res@ == ""1""@","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0122,verus,apps,apps_test_623,,"Given two joysticks with initial charge levels a1 and a2 percent, determine the maximum number of minutes a game can last.
Each minute, exactly one joystick must be connected to a charger (gains 1% charge) while the other loses 2% charge.
Game continues while both joysticks have positive charge (> 0%). If a joystick has exactly 1% charge at the start of a minute,
it must be charged to avoid reaching 0%. Find the maximum number of minutes before at least one joystick reaches 0% charge.","use vstd::prelude::*;

verus! {

spec fn count_valid_minutes(a: int, b: int) -> int
    recommends a >= 0 && b >= 0
    decreases a + b
{
    if a <= 0 || b <= 0 {
        0
    } else if a == 1 && b == 1 {
        0
    } else {
        (if a > 1 || b > 1 { 1 as int } else { 0 as int }) + 
        count_valid_minutes(
            if a < b { a + 1 } else { a - 2 }, 
            if a < b { b - 2 } else { b + 1 }
        )
    }
}",,"fn solve(a1: i8, a2: i8) -> (result: i8)
    requires 
        a1 >= 1 && a2 >= 1,
    ensures 
        result >= 0,
        result as int == count_valid_minutes(a1 as int, a2 as int),
        (a1 == 1 && a2 == 1) ==> result == 0,","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0123,verus,apps,apps_test_625,,"Given a positive integer n, calculate the value of the alternating sum:
f(n) = -1 + 2 - 3 + 4 - 5 + ... + (-1)^n × n","use vstd::prelude::*;

verus! {

spec fn alternating_sum(n: int) -> int
    recommends n > 0
    decreases n
{
    if n <= 0 { 0 }
    else if n == 1 { -1 }
    else { alternating_sum(n - 1) + (if n % 2 == 0 { n } else { -n }) }
}

spec fn valid_input(n: int) -> bool {
    n > 0
}",,"fn solve(n: i8) -> (result: i8)
    requires valid_input(n as int)
    ensures 
        result as int == alternating_sum(n as int) &&
        (n as int % 2 == 0 ==> result as int == n as int / 2) &&
        (n as int % 2 != 0 ==> result as int == n as int / 2 - n as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0125,verus,apps,apps_test_641,,"Calculate how many candies will be saved in the year 2016 based on a savings plan.
Input format: ""x of week"" (x=1-7, Monday-Sunday) or ""x of month"" (x=1-31).
Save one candy on the specified day each week/month.
2016 is a leap year starting on Friday, week starts on Monday.","use vstd::prelude::*;

verus! {

spec fn split_on_space(s: Seq<char>) -> Seq<Seq<char>>;

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 &&
    ({
        let trimmed = if input.len() > 0 && input[input.len() as int - 1] == '\n' { input.subrange(0, input.len() as int - 1) } else { input };
        let parts = split_on_space(trimmed);
        parts.len() >= 1
    })
}

spec fn get_expected_result(input: Seq<char>) -> Seq<char>
    recommends valid_input(input)
{
    let trimmed = if input.len() > 0 && input[input.len() as int - 1] == '\n' { input.subrange(0, input.len() as int - 1) } else { input };
    let parts = split_on_space(trimmed);
    if parts[parts.len() as int - 1] == seq!['m', 'o', 'n', 't', 'h'] {
        if parts[0] == seq!['3', '1'] { seq!['7', '\n'] }
        else if parts[0] == seq!['3', '0'] { seq!['1', '1', '\n'] }
        else { seq!['1', '2', '\n'] }
    } else {
        if parts[0] == seq!['5'] || parts[0] == seq!['6'] { seq!['5', '3', '\n'] }
        else { seq!['5', '2', '\n'] }
    }
}",,"fn solve(input: &str) -> (result: String)
    requires valid_input(input@)
    ensures result@ == get_expected_result(input@)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0126,verus,apps,apps_test_644,,"Execute a sequence of commands (for n, end, add) that manipulate an integer variable x starting at 0.
Commands form valid nested loops. Check if x exceeds 2^32 - 1 at any point during execution.
Return ""OVERFLOW!!!"" if overflow occurs, otherwise return the final value of x.","use vstd::prelude::*;

verus! {
spec fn valid_input(lines: Seq<String>) -> bool {
    lines.len() > 0
}

spec fn max_value() -> int { 4294967295 }

spec fn is_overflow(x: int) -> bool {
    x > max_value()
}",,"fn solve(input: String) -> (result: String)
    requires valid_input(seq![input])
    ensures result@ =~= ""OVERFLOW!!!""@ || !(result@ =~= ""OVERFLOW!!!""@)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0127,verus,apps,apps_test_645,,"Given n cards with letters/digits, determine minimum cards to flip to verify:
""If a card has a vowel on one side, then it has an even digit on the other side.""
Input: string representing visible sides. Output: minimum flips needed.","use vstd::prelude::*;

verus! {
spec fn is_vowel(c: char) -> bool {
  c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'
}

spec fn is_odd_digit(c: char) -> bool {
  c == '1' || c == '3' || c == '5' || c == '7' || c == '9'
}

spec fn needs_flipping(c: char) -> bool {
  is_vowel(c) || is_odd_digit(c)
}

spec fn count_flips(s: Seq<char>) -> int {
  s.filter(|c: char| needs_flipping(c)).len() as int
}",,"fn solve(s: Vec<char>) -> (result: Vec<char>)
  requires s@.len() >= 1 && s@.len() <= 50
  ensures result@.len() > 0","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0128,verus,apps,apps_test_648,,"Given integers m and b, find the maximum sum of bananas that can be collected from an optimally placed rectangle.
Each lattice point (x,y) where x,y >= 0 contains x+y bananas.
A line is defined by y = -x/m + b.
A rectangle with axis-aligned sides can be placed anywhere such that all points are on or under the line.
The rectangle can be degenerate (a line segment or single point).","use vstd::prelude::*;

verus! {

spec fn valid_input(m: int, b: int) -> bool {
  1 <= m <= 1000 && 1 <= b <= 10000
}

spec fn f(x: int, y: int) -> int {
  (x * (x + 1) * (y + 1) + y * (y + 1) * (x + 1)) / 2
}

spec fn valid_rectangle_corner(k: int, m: int, b: int) -> bool {
  0 <= k && b - k >= 0
}

spec fn rectangle_value(k: int, m: int, b: int) -> int {
  f(k * m, b - k)
}",,"fn solve(m: i8, b: i8) -> (result: i8)
  requires 
    valid_input(m as int, b as int)
  ensures 
    result as int >= -1,
    forall|k: int| valid_rectangle_corner(k, m as int, b as int) ==> result as int >= rectangle_value(k, m as int, b as int),
    exists|k: int| valid_rectangle_corner(k, m as int, b as int) && result as int == rectangle_value(k, m as int, b as int)","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0129,verus,apps,apps_test_650,,"Given a string of uppercase letters A-Z with length 1-10, determine if all letters
belong to the same predefined group. Group 1: A,E,F,H,I,K,L,M,N,T,V,W,X,Y,Z.
Group 2: B,C,D,G,J,O,P,Q,R,S,U. Output ""YES"" if all letters in same group, ""NO"" otherwise.","use vstd::prelude::*;

verus! {

spec fn valid_input(word: Seq<char>) -> bool {
    1 <= word.len() <= 10 && forall|i: int| 0 <= i < word.len() ==> 'A' <= #[trigger] word[i] <= 'Z'
}

spec fn group1() -> Seq<char> { 
    seq!['A','E','F','H','I','K','L','M','N','T','V','W','X','Y','Z']
}

spec fn group2() -> Seq<char> { 
    seq!['B','C','D','G','J','O','P','Q','R','S','U']
}

spec fn all_in_group1(word: Seq<char>) -> bool {
    forall|i: int| 0 <= i < word.len() ==> group1().contains(#[trigger] word[i])
}

spec fn all_in_group2(word: Seq<char>) -> bool {
    forall|i: int| 0 <= i < word.len() ==> group2().contains(#[trigger] word[i])
}

spec fn all_in_same_group(word: Seq<char>) -> bool {
    all_in_group1(word) || all_in_group2(word)
}",,"fn solve(word: Vec<char>) -> (result: Vec<char>)
    requires valid_input(word@)
    ensures (all_in_same_group(word@) <==> result@ == seq!['Y','E','S']) && (result@ == seq!['Y','E','S'] || result@ == seq!['N','O'])","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0132,verus,apps,apps_test_657,,"Given initial counts of yellow and blue crystals, determine the minimum additional crystals needed to produce a specified number of colored balls.
Yellow ball requires 2 yellow crystals, green ball requires 1 yellow + 1 blue crystal, blue ball requires 3 blue crystals.","use vstd::prelude::*;

verus! {
spec fn max(a: int, b: int) -> int {
    if a >= b { a } else { b }
}

spec fn valid_input(a: int, b: int, x: int, y: int, z: int) -> bool {
    a >= 0 && b >= 0 && x >= 0 && y >= 0 && z >= 0
}

spec fn yellow_crystals_needed(x: int, y: int) -> int {
    x * 2 + y
}

spec fn blue_crystals_needed(y: int, z: int) -> int {
    y + z * 3
}

spec fn min_additional_crystals(a: int, b: int, x: int, y: int, z: int) -> int {
    max(0, yellow_crystals_needed(x, y) - a) + max(0, blue_crystals_needed(y, z) - b)
}",,"fn solve(a: i8, b: i8, x: i8, y: i8, z: i8) -> (result: i8)
    requires 
        valid_input(a as int, b as int, x as int, y as int, z as int)
    ensures 
        result >= 0,
        result as int == min_additional_crystals(a as int, b as int, x as int, y as int, z as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0133,verus,apps,apps_test_666,,"Find the n-th element (1-indexed) in an infinite sequence constructed as blocks:
Block 1: [1], Block 2: [1,2], Block 3: [1,2,3], etc.
The complete sequence is: 1, 1, 2, 1, 2, 3, 1, 2, 3, 4, 1, 2, 3, 4, 5, ...","use vstd::prelude::*;

verus! {

spec fn triangular_number(m: int) -> int
    recommends m >= 0
{
    m * (m + 1) / 2
}

spec fn valid_input(n: int) -> bool
{
    n >= 1
}

spec fn valid_result(n: int, result: int) -> bool
    recommends valid_input(n)
{
    result >= 1 && result <= n
}",,"fn solve(n: i8) -> (result: i8)
    requires valid_input(n as int)
    ensures valid_result(n as int, result as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0134,verus,apps,apps_test_673,,"Given two integers n and k, find the smallest integer x such that x > n and x is divisible by k.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, k: int) -> bool {
    n >= 1 && k > 0
}

spec fn is_correct_result(n: int, k: int, result: int) -> bool 
    recommends k > 0
{
    result > n && result % k == 0 && forall|x: int| n < x < result ==> #[trigger] (x % k) != 0
}",,"fn solve(n: i8, k: i8) -> (result: i8)
    requires valid_input(n as int, k as int)
    ensures is_correct_result(n as int, k as int, result as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0135,verus,apps,apps_test_679,,"Given a string representing a row of cells with flowers (A, B, C) or empty cells (.),
determine if it's possible for at least one cell to contain all three colors after
some flowers wither and spread petals to adjacent cells.","use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>) -> bool {
    s.len() >= 0 && forall|i: int| 0 <= i < s.len() ==> s[i] == 'A' || s[i] == 'B' || s[i] == 'C' || s[i] == '.'
}

spec fn has_all_three_colors(s: Seq<char>, start: int) -> bool
    recommends 0 <= start <= s.len() - 3
{
    s.subrange(start, start + 3).contains('A') && 
    s.subrange(start, start + 3).contains('B') && 
    s.subrange(start, start + 3).contains('C')
}

spec fn possible_to_get_all_colors(s: Seq<char>) -> bool {
    s.len() >= 3 && exists|i: int| 0 <= i <= s.len() - 3 && has_all_three_colors(s, i)
}",,"fn solve(s: &[char]) -> (result: Vec<char>)
    requires 
        s@.len() >= 0 && forall|i: int| 0 <= i < s@.len() ==> s@[i] == 'A' || s@[i] == 'B' || s@[i] == 'C' || s@[i] == '.'
    ensures 
        result@ == seq!['Y', 'e', 's'] ==> possible_to_get_all_colors(s@),
        result@ == seq!['N', 'o'] ==> !possible_to_get_all_colors(s@),
        result@ == seq!['Y', 'e', 's'] || result@ == seq!['N', 'o']","{
    /* impl-start */
    assume(false);
    vec!['N', 'o']
    /* impl-end */
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0136,verus,apps,apps_test_682,,"Given starting position (r1, c1) and ending position (r2, c2) on an 8×8 chessboard,
find the minimum number of moves required for a rook, bishop, and king to move from
the starting position to the ending position. Return 0 if a piece cannot reach the destination.","use vstd::prelude::*;

verus! {

spec fn valid_position(r: int, c: int) -> bool {
    1 <= r <= 8 && 1 <= c <= 8
}

spec fn rook_moves(r1: int, c1: int, r2: int, c2: int) -> int
    recommends valid_position(r1, c1) && valid_position(r2, c2)
{
    if r1 == r2 && c1 == c2 {
        0
    } else if r1 == r2 || c1 == c2 {
        1
    } else {
        2
    }
}

spec fn bishop_moves(r1: int, c1: int, r2: int, c2: int) -> int
    recommends valid_position(r1, c1) && valid_position(r2, c2)
{
    if r1 == r2 && c1 == c2 {
        0
    } else {
        let row_diff = if r1 >= r2 { r1 - r2 } else { r2 - r1 };
        let col_diff = if c1 >= c2 { c1 - c2 } else { c2 - c1 };
        if row_diff == col_diff {
            1
        } else if (r1 + c1) % 2 == (r2 + c2) % 2 {
            2
        } else {
            0
        }
    }
}

spec fn king_moves(r1: int, c1: int, r2: int, c2: int) -> int
    recommends valid_position(r1, c1) && valid_position(r2, c2)
{
    let row_diff = if r1 >= r2 { r1 - r2 } else { r2 - r1 };
    let col_diff = if c1 >= c2 { c1 - c2 } else { c2 - c1 };
    if row_diff >= col_diff { row_diff } else { col_diff }
}

spec fn valid_result(result: Seq<int>, r1: int, c1: int, r2: int, c2: int) -> bool
    recommends valid_position(r1, c1) && valid_position(r2, c2)
{
    result.len() == 3 &&
    result[0] == rook_moves(r1, c1, r2, c2) &&
    result[1] == bishop_moves(r1, c1, r2, c2) &&
    result[2] == king_moves(r1, c1, r2, c2)
}",,"fn solve(r1: i8, c1: i8, r2: i8, c2: i8) -> (result: Vec<i8>)
    requires valid_position(r1 as int, c1 as int) && valid_position(r2 as int, c2 as int)
    ensures valid_result(result@.map(|_idx: int, x: i8| x as int), r1 as int, c1 as int, r2 as int, c2 as int)","{
    assume(false);
    Vec::new()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0137,verus,apps,apps_test_696,,"Given a prime number p, find the count of primitive roots modulo p.
A primitive root modulo prime p is an integer x where 1 ≤ x < p such that
x^k ≢ 1 (mod p) for all positive integers k < p-1, but x^(p-1) ≡ 1 (mod p).","use vstd::prelude::*;

verus! {

spec fn valid_input(p: int) -> bool {
    2 <= p < 2000
}

spec fn count_primitive_roots(p: int) -> int
    recommends valid_input(p)
{
    if p == 2 { 
        1 
    } else { 
        /* Count of integers i where 1 <= i < p-1 and 
           for all j where 2 <= j <= i, not ((p-1) % j == 0 && i % j == 0) */
        Set::new(|i: int| 1 <= i < p-1 && (forall|j: int| 2 <= j <= i ==> !((p-1) % j == 0 && #[trigger] (i % j) == 0))).len() as int
    }
}",,"fn solve(p: i8) -> (result: i8)
    requires valid_input(p as int)
    ensures 
        result >= 0 &&
        result as int == count_primitive_roots(p as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0139,verus,apps,apps_test_703,,"Store `a` nuts in boxes using `b` available divisors. Each box can have at most `k` sections.
A box with `x` divisors has `x+1` sections. Each section holds at most `v` nuts.
Find minimum number of boxes needed.","use vstd::prelude::*;

verus! {

spec fn min(x: int, y: int) -> int {
    if x <= y { x } else { y }
}

spec fn valid_input(k: int, a: int, b: int, v: int) -> bool {
    2 <= k <= 1000 && 1 <= a <= 1000 && 1 <= b <= 1000 && 1 <= v <= 1000
}

spec fn box_capacity(num_boxes: int, k: int, b: int, v: int) -> int
    recommends num_boxes >= 0
{
    v * (num_boxes + min(b, (k - 1) * num_boxes))
}

spec fn can_store_nuts(num_boxes: int, k: int, a: int, b: int, v: int) -> bool
    recommends num_boxes >= 0
{
    a <= box_capacity(num_boxes, k, b, v)
}

spec fn is_minimal_solution(result: int, k: int, a: int, b: int, v: int) -> bool
    recommends result >= 1
{
    can_store_nuts(result, k, a, b, v) &&
    (result == 1 || !can_store_nuts(result - 1, k, a, b, v))
}",,"fn solve(k: i8, a: i8, b: i8, v: i8) -> (result: i8)
    requires
        valid_input(k as int, a as int, b as int, v as int)
    ensures
        result >= 1,
        result <= 127,
        is_minimal_solution(result as int, k as int, a as int, b as int, v as int),
        exists|i: int| 1 <= i <= 127 && can_store_nuts(i, k as int, a as int, b as int, v as int) && result as int == i && 
            (forall|j: int| 1 <= j < i ==> !can_store_nuts(j, k as int, a as int, b as int, v as int))","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0140,verus,apps,apps_test_709,,"Find the minimum number of bacteria to add to an initially empty box to achieve exactly x bacteria at some point in time.
Each morning we can add bacteria, each night bacteria double.","use vstd::prelude::*;

verus! {

spec fn count_ones_in_binary(n: int) -> int
    recommends n >= 1
    decreases n
    when n >= 1
{
    if n == 1 {
        1
    } else if n % 2 == 1 {
        1 + count_ones_in_binary(n / 2)
    } else {
        count_ones_in_binary(n / 2)
    }
}

spec fn valid_input(x: int) -> bool {
    x >= 1
}

spec fn valid_output(x: int, result: int) -> bool {
    valid_input(x) && result == count_ones_in_binary(x)
}",,"fn min_bacteria(x: i8) -> (result: i8)
    requires valid_input(x as int)
    ensures valid_output(x as int, result as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0142,verus,apps,apps_test_719,,"Find the k-th smallest perfect positive integer, where a perfect integer 
is one whose digits sum to exactly 10.","use vstd::prelude::*;

verus! {

#[verifier::external_body]
spec fn int_to_string(n: int) -> Seq<char> {
    unimplemented!()
}

spec fn valid_input(stdin_input: Seq<char>) -> bool {
    stdin_input.len() > 0 &&
    exists|k: int| k >= 1 && k <= 10000 && stdin_input == int_to_string(k).push('\n')
}

spec fn kth_perfect_number(k: int) -> int
    recommends k >= 1 && k <= 10000
{
    if k == 1 { 19 }
    else if k == 2 { 28 }
    else if k == 3 { 37 }
    else if k == 4 { 46 }
    else if k == 5 { 55 }
    else if k == 6 { 64 }
    else if k == 7 { 73 }
    else if k == 8 { 82 }
    else if k == 9 { 91 }
    else if k == 10 { 109 }
    else { 10 * (k - 9) + 99 }
}",,"fn solve(stdin_input: String) -> (result: String)
    requires valid_input(stdin_input@)
    ensures (exists|k: int| k >= 1 && k <= 10000 && 
        stdin_input@ == int_to_string(k).push('\n') &&
        result@ == int_to_string(kth_perfect_number(k)).push('\n')) &&
        result@.len() > 0","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0144,verus,apps,apps_test_736,,"Given a staircase with n steps, find the minimum number of moves to reach the top
where each move climbs 1 or 2 steps, and total moves must be a multiple of m.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, m: int) -> bool {
    n > 0 && n <= 10000 && m > 1 && m <= 10
}

spec fn min_moves(n: int) -> int
    recommends n > 0
{
    if n % 2 == 0 { n / 2 } else { n / 2 + 1 }
}

spec fn valid_move_count(n: int, k: int) -> bool
    recommends n > 0
{
    min_moves(n) <= k <= n
}

spec fn is_valid_solution(n: int, m: int, result: int) -> bool
    recommends valid_input(n, m)
{
    result == -1 || (result > 0 && result % m == 0 && valid_move_count(n, result))
}

spec fn no_smaller_solution(n: int, m: int, result: int) -> bool
    recommends valid_input(n, m)
{
    result == -1 ==> forall|k: int| min_moves(n) <= k <= n ==> #[trigger] (k % m) != 0
}

spec fn is_minimal_solution(n: int, m: int, result: int) -> bool
    recommends valid_input(n, m)
{
    result != -1 ==> forall|k: int| (min_moves(n) <= k <= n && k < result) ==> #[trigger] (k % m) != 0
}",,"fn solve(n: i8, m: i8) -> (result: i8)
    requires 
        valid_input(n as int, m as int)
    ensures 
        is_valid_solution(n as int, m as int, result as int) &&
        no_smaller_solution(n as int, m as int, result as int) &&
        is_minimal_solution(n as int, m as int, result as int)","{
    assume(false);
    -1
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0146,verus,apps,apps_test_744,,"Given a sequence of n days where you were either in Seattle (S) or San Francisco (F),
determine if you made more flights from Seattle to San Francisco than from San Francisco
to Seattle during this period. You fly at night between consecutive days when you change cities.","use vstd::prelude::*;

verus! {

spec fn count_sf_flights(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() <= 1 { 
        0 
    } else { 
        (if s[s.len()-1] == 'F' && s[s.len()-2] != 'F' { 1int } else { 0int }) + count_sf_flights(s.subrange(0, s.len()-1))
    }
}

spec fn count_fs_flights(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() <= 1 { 
        0 
    } else { 
        (if s[s.len()-1] == 'S' && s[s.len()-2] != 'S' { 1int } else { 0int }) + count_fs_flights(s.subrange(0, s.len()-1))
    }
}",,"fn solve(n: usize, s: Vec<char>) -> (result: Vec<char>)
    requires 
        n >= 2,
        s@.len() == n,
        forall|i: int| 0 <= i < s@.len() ==> s@[i] == 'S' || s@[i] == 'F',
    ensures 
        result@ == seq!['Y', 'E', 'S'] || result@ == seq!['N', 'O'],
        (result@ == seq!['Y', 'E', 'S']) <==> count_sf_flights(s@) > count_fs_flights(s@),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0147,verus,apps,apps_test_748,,"Given a sequence of n positive integers (n divisible by 3), each ≤ 7,
partition into groups of 3 elements (a,b,c) where a < b < c and a|b, b|c.
Return the partition or empty sequence if impossible.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, numbers: Seq<int>) -> bool {
    n >= 3 && n % 3 == 0 &&
    numbers.len() == n &&
    forall|i: int| 0 <= i < numbers.len() ==> 1 <= #[trigger] numbers[i] && #[trigger] numbers[i] <= 7
}

spec fn valid_triplet(triplet: Seq<int>) -> bool {
    triplet.len() == 3 &&
    triplet[0] < triplet[1] && triplet[1] < triplet[2] &&
    triplet[0] > 0 && triplet[1] > 0 && triplet[2] > 0 &&
    triplet[1] % triplet[0] == 0 && triplet[2] % triplet[1] == 0
}

spec fn flatten_partition(result: Seq<Seq<int>>) -> Seq<int>
    decreases result.len()
{
    if result.len() == 0 { 
        seq![]
    } else {
        result[0].add(flatten_partition(result.subrange(1, result.len() as int)))
    }
}

spec fn valid_partition(result: Seq<Seq<int>>, numbers: Seq<int>) -> bool {
    result.len() == numbers.len() / 3 &&
    (forall|i: int| 0 <= i < result.len() ==> valid_triplet(#[trigger] result[i])) &&
    numbers.to_multiset() == flatten_partition(result).to_multiset()
}

spec fn no_partition_exists(result: Seq<Seq<int>>) -> bool {
    result.len() == 0
}",,"fn solve(n: i8, numbers: Vec<i8>) -> (result: Vec<Vec<i8>>)
    requires valid_input(n as int, numbers@.map(|i: int, x: i8| x as int))
    ensures no_partition_exists(result@.map(|i: int, v: Vec<i8>| v@.map(|j: int, x: i8| x as int))) || valid_partition(result@.map(|i: int, v: Vec<i8>| v@.map(|j: int, x: i8| x as int)), numbers@.map(|i: int, x: i8| x as int))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0148,verus,apps,apps_test_750,,"Given n friends to invite and notebooks with k sheets each (one color per notebook),
find the minimum number of notebooks needed. Each invitation requires exactly 2 red 
sheets, 5 green sheets, and 8 blue sheets.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, k: int) -> bool {
    n >= 1 && k >= 1
}

spec fn sheets_needed(n: int) -> (int, int, int) {
    (2 * n, 5 * n, 8 * n)
}

spec fn total_sheets_needed(n: int) -> int {
    2 * n + 5 * n + 8 * n
}

spec fn ceil_div(a: int, b: int) -> int
    recommends b > 0
{
    (a + b - 1) / b
}",,"fn solve(n: i8, k: i8) -> (result: i8)
    requires 
        valid_input(n as int, k as int)
    ensures 
        result as int == ceil_div(2 * (n as int), k as int) + ceil_div(5 * (n as int), k as int) + ceil_div(8 * (n as int), k as int),
        result >= 0,
        result as int >= (total_sheets_needed(n as int) + (k as int) - 1) / (k as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0151,verus,apps,apps_test_754,,"Given n stones in a row colored R, G, or B, find the minimum number of stones
to remove so that no two adjacent stones have the same color.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, s: Seq<char>) -> bool
{
    n >= 1 && s.len() == n
}

spec fn count_adjacent_same_pairs(s: Seq<char>, n: int) -> int
{
    count_adjacent_same_pairs_up_to(s, n)
}

spec fn count_adjacent_same_pairs_up_to(s: Seq<char>, i: int) -> int
    decreases i
{
    if i <= 1 { 0int }
    else { (if s[i-1] == s[i-2] { 1int } else { 0int }) + count_adjacent_same_pairs_up_to(s, i-1) }
}",,"fn solve(n: i8, s: Vec<char>) -> (result: i8)
    requires 
        valid_input(n as int, s@),
    ensures 
        result >= 0,
        result <= n - 1,
        result as int == count_adjacent_same_pairs(s@, n as int),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0152,verus,apps,apps_test_755,,"Find the minimum number of steps to move from position 0 to position x on a number line,
where each step can move forward by 1, 2, 3, 4, or 5 positions.","use vstd::prelude::*;

verus! {
spec fn valid_input(x: int) -> bool {
    x >= 1
}

spec fn is_minimal_steps(x: int, steps: int) -> bool {
    x >= 1 ==> (steps >= 1 &&
    steps * 5 >= x &&
    (steps - 1) * 5 < x)
}",,"fn min_steps(x: i8) -> (result: i8)
    requires valid_input(x as int)
    ensures is_minimal_steps(x as int, result as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0154,verus,apps,apps_test_760,,"Given a string s and integer k, find the maximum possible length of a tandem repeat substring
that can appear after appending k characters to s. A tandem repeat of length 2n has its first
half exactly matching its second half.","use vstd::prelude::*;

verus! {

spec fn is_tandem_repeat(s: Seq<char>) -> bool {
    if s.len() % 2 != 0 {
        false
    } else {
        let half_len = s.len() / 2;
        let first_half = s.subrange(0, half_len as int);
        let second_half = s.subrange(half_len as int, s.len() as int);
        forall|i: int| 0 <= i < half_len ==> 
            (first_half[i] == '*' || second_half[i] == '*' || first_half[i] == second_half[i])
    }
}

spec fn extended_string(s: Seq<char>, k: int) -> Seq<char> {
    s + Seq::new(k as nat, |j| '*')
}",,"fn solve(s: Vec<char>, k: i8) -> (result: i8)
    requires 
        k >= 1,
        s.len() >= 1,
    ensures 
        result >= 0,
        result % 2 == 0,
        result as int <= s@.len() + k as int,","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0155,verus,apps,apps_test_777,,"Given a string of lowercase letters, determine how many distinct strings can be created by
inserting exactly one additional lowercase letter (a-z) at any position in the string.
For a string of length n, we can insert at n+1 positions with 26 character choices,
giving 26×(n+1) total combinations. However, n duplicates occur, resulting in
26×(n+1) - n = 25×n + 26 distinct strings.","use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>) -> bool {
    s.len() >= 1 && s.len() <= 20 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= 'a' && #[trigger] s[i] <= 'z'
}

spec fn distinct_strings_count(s: Seq<char>) -> int
    recommends valid_input(s)
{
    s.len() as int * 25 + 26
}

spec fn int_to_string_spec(n: int) -> Seq<char>
    recommends n >= 0
{
    if n == 0 { seq!['0'] }
    else { seq!['0'] } // Simplified for termination
}

spec fn char_of_digit_spec(d: int) -> char
    recommends 0 <= d <= 9
{
    if d == 0 { '0' }
    else if d == 1 { '1' }
    else if d == 2 { '2' }
    else if d == 3 { '3' }
    else if d == 4 { '4' }
    else if d == 5 { '5' }
    else if d == 6 { '6' }
    else if d == 7 { '7' }
    else if d == 8 { '8' }
    else if d == 9 { '9' }
    else { '0' }
}",,"fn solve(s: &str) -> (result: String)
    requires valid_input(s@)
    ensures result@ == int_to_string_spec(distinct_strings_count(s@))","{
    // impl-start
    assume(false);
    """".to_string()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0156,verus,apps,apps_test_781,,"Given an 8×8 board where each cell is colored black (B) or white (W), determine if it's possible to transform it 
into a proper chessboard using only cyclic right shifts on individual rows. A proper chessboard has no adjacent 
cells (horizontally or vertically) with the same color and the upper-left cell is white.","use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<Seq<char>>) -> bool {
    input.len() == 8 &&
    (forall|i: int| 0 <= i < 8 ==> #[trigger] input[i].len() == 8) &&
    (forall|i: int, j: int| 0 <= i < 8 && 0 <= j < 8 ==> (#[trigger] input[i][j] == 'W' || #[trigger] input[i][j] == 'B'))
}

spec fn has_alternating_row(row: Seq<char>) -> bool {
    row.len() == 8 &&
    (forall|j: int| 0 <= j < 8 ==> (#[trigger] row[j] == 'W' || #[trigger] row[j] == 'B')) &&
    row[0] == 'W' &&
    row[1] == 'B' &&
    row[2] == 'W' &&
    row[3] == 'B' &&
    row[4] == 'W' &&
    row[5] == 'B' &&
    row[6] == 'W' &&
    row[7] == 'B'
}

spec fn all_rows_have_alternating_pattern(input: Seq<Seq<char>>) -> bool {
    valid_input(input) &&
    (forall|i: int| 0 <= i < 8 ==> has_alternating_row(#[trigger] input[i]))
}",,"fn solve(input: Vec<Vec<char>>) -> (result: Vec<char>)
    requires valid_input(input@.map(|i, row: Vec<char>| row@))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0157,verus,apps,apps_test_785,,"Given a rectangular room with dimensions a × b meters, accommodate exactly n students 
such that each student has at least 6 square meters of space. You can increase either 
or both dimensions by any positive integer amount. Find the minimum possible area and 
corresponding dimensions.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, a: int, b: int) -> bool {
    n > 0 && a > 0 && b > 0
}

spec fn valid_output(result: Seq<int>, n: int, a: int, b: int) -> bool {
    result.len() == 3 &&
    result[0] >= 6 * n &&
    result[1] > 0 && result[2] > 0 &&
    result[0] == result[1] * result[2] &&
    ((result[1] >= a && result[2] >= b) || (result[1] >= b && result[2] >= a))
}",,"fn solve(n: i8, a: i8, b: i8) -> (result: Vec<i8>)
    requires valid_input(n as int, a as int, b as int)
    ensures valid_output(result@.map(|i, x| x as int), n as int, a as int, b as int)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0159,verus,apps,apps_test_788,,"Calculate a score from a string starting with 'A' followed by exactly 6 digits.
Score formula: sum of all 6 digits + 9 * count of zero digits + 1","use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>) -> bool {
    s.len() == 7 && s[0] == 'A' && forall|i: int| 1 <= i < 7 ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9'
}

spec fn digit_sum(s: Seq<char>, start: int, end: int) -> int
    decreases end - start when 0 <= start <= end <= s.len()
{
    if start >= end {
        0
    } else {
        (s[start] as int - '0' as int) + digit_sum(s, start + 1, end)
    }
}

spec fn zero_count(s: Seq<char>, start: int, end: int) -> int
    decreases end - start when 0 <= start <= end <= s.len()
{
    if start >= end {
        0
    } else {
        (if s[start] == '0' { 1nat } else { 0nat }) as int + zero_count(s, start + 1, end)
    }
}",,"fn solve(s: Vec<char>) -> (result: i8)
    requires valid_input(s@)
    ensures result as int == digit_sum(s@, 1, 7) + 9 * zero_count(s@, 1, 7) + 1","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0160,verus,apps,apps_test_789,,"Given a lucky number n (containing only digits 4 and 7), find its 1-based index
when all lucky numbers are sorted in increasing order. Lucky numbers are positive
integers containing only the digits 4 and 7.","use vstd::prelude::*;

verus! {
spec fn valid_lucky_number(n: Seq<char>) -> bool {
    n.len() > 0 && forall|i: int| 0 <= i < n.len() ==> n[i] == '4' || n[i] == '7'
}

spec fn convert_to_binary(n: Seq<char>) -> Seq<char>
    recommends forall|i: int| 0 <= i < n.len() ==> n[i] == '4' || n[i] == '7'
    decreases n.len()
{
    if n.len() == 0 {
        Seq::empty()
    } else if n[0] == '4' {
        seq!['0'].add(convert_to_binary(n.subrange(1, n.len() as int)))
    } else {
        seq!['1'].add(convert_to_binary(n.subrange(1, n.len() as int)))
    }
}

spec fn pow2(n: nat) -> nat
    decreases n
{
    if n == 0 { 1 } else { 2 * pow2((n - 1) as nat) }
}

spec fn binary_to_int(s: Seq<char>) -> int
    recommends forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if s[0] == '1' {
        pow2((s.len() - 1) as nat) + binary_to_int(s.subrange(1, s.len() as int))
    } else {
        binary_to_int(s.subrange(1, s.len() as int))
    }
}

spec fn valid_result(n: Seq<char>, result: int) -> bool
    recommends valid_lucky_number(n)
{
    result > 0 && result == 2 * (pow2((n.len() - 1) as nat) - 1) + binary_to_int(convert_to_binary(n)) + 1
}",,"fn solve(n: Vec<char>) -> (result: i8)
    requires valid_lucky_number(n@)
    ensures valid_result(n@, result as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0161,verus,apps,apps_test_792,,"Given a credit card account starting with 0 money and n consecutive days of transactions,
determine the minimum number of days deposits are needed to satisfy all constraints.
Each day deposits can be made in the morning, then transactions occur in the evening.
If any evening transaction causes the balance to exceed limit d, return -1.
On days when evening transaction is 0 (balance check days), the balance after the
transaction must be non-negative. Morning deposits can be any positive integer amount.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, d: int, transactions: Seq<int>) -> bool {
  n >= 1 && d >= 1 &&
  transactions.len() == n &&
  forall|i: int| 0 <= i < n ==> #[trigger] transactions[i] >= -10000 && #[trigger] transactions[i] <= 10000
}

spec fn prefix_sum(transactions: Seq<int>, index: int) -> int
  decreases index
{
  if index < 0 || index >= transactions.len() { 0int }
  else if index == 0 { transactions[0] }
  else { prefix_sum(transactions, index - 1) + transactions[index] }
}

spec fn count_zero_transactions(transactions: Seq<int>) -> int
  decreases transactions.len()
{
  if transactions.len() == 0 { 0int }
  else { (if transactions[0] == 0 { 1int } else { 0int }) + count_zero_transactions(transactions.drop_first()) }
}

spec fn balance_after_day(transactions: Seq<int>, deposits: Seq<int>, day: int) -> int
  decreases day
{
  if day < 0 || day >= transactions.len() || deposits.len() != transactions.len() { 0int }
  else if day == 0 { deposits[0] + transactions[0] }
  else { balance_after_day(transactions, deposits, day - 1) + deposits[day] + transactions[day] }
}

spec fn count_positive_deposits(deposits: Seq<int>) -> int
  decreases deposits.len()
{
  if deposits.len() == 0 { 0int }
  else { (if deposits[0] > 0 { 1int } else { 0int }) + count_positive_deposits(deposits.drop_first()) }
}

spec fn valid_deposits_schedule(transactions: Seq<int>, d: int, deposits_schedule: Seq<int>, num_deposits: int) -> bool {
  deposits_schedule.len() == transactions.len() &&
  (forall|i: int| 0 <= i < deposits_schedule.len() ==> #[trigger] deposits_schedule[i] >= 0) &&
  num_deposits == count_positive_deposits(deposits_schedule) &&
  forall|i: int| 0 <= i < transactions.len() ==> 
    (#[trigger] deposits_schedule[i] > 0 ==> #[trigger] transactions[i] == 0)
}

spec fn filter_positive(deposits: Seq<int>) -> Seq<int>
  decreases deposits.len()
{
  if deposits.len() == 0 { Seq::empty() }
  else if deposits[0] > 0 { seq![deposits[0]].add(filter_positive(deposits.drop_first())) }
  else { filter_positive(deposits.drop_first()) }
}",,"fn solve(n: i8, d: i8, transactions: Vec<i8>) -> (result: i8)
  requires valid_input(n as int, d as int, transactions@.map(|x: int, y: i8| y as int))
  ensures result == -1 || result >= 0","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0162,verus,apps,apps_test_795,,"Count the number of integer right triangles (a, b, c) where:
- a² + b² = c² (Pythagorean theorem)
- 1 ≤ a ≤ b ≤ c ≤ n
- All sides are positive integers","use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0
}

spec fn valid_n(n: int) -> bool {
    n >= 1 && n <= 10000
}

spec fn integer_square_root(n: int) -> int {
    0  /* placeholder implementation */
}

spec fn count_from_primitives(n: int, m: int, u: int, v: int) -> int {
    0  /* placeholder implementation */
}

spec fn extract_integer(input: Seq<char>) -> int {
    0  /* placeholder implementation */
}

spec fn int_to_string(n: int) -> Seq<char> {
    seq![]  /* placeholder implementation */
}

spec fn count_pythagorean_triples_via_primitives(n: int) -> int {
    let m = integer_square_root(n);
    count_from_primitives(n, m, 1, 1)
}",,"fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(stdin_input@)
    ensures 
        result@.len() > 0,
        result@ == int_to_string(count_pythagorean_triples_via_primitives(extract_integer(stdin_input@)))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0163,verus,apps,apps_test_804,,"Given a string of lowercase Latin letters and an integer k, find the minimum number of 
character changes needed to make the string contain at least k different letters.
Return ""impossible"" if the string length is less than k.","use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>, k: int) -> bool {
    1 <= k <= 26 && 1 <= s.len() <= 1000 && 
    forall|i: int| 0 <= i < s.len() ==> 'a' <= #[trigger] s[i] <= 'z'
}

spec fn unique_chars(s: Seq<char>) -> Set<char> {
    s.to_set()
}

spec fn min_changes(s: Seq<char>, k: int) -> int {
    let unique = unique_chars(s);
    if k <= unique.len() { 0 } else { k - unique.len() }
}

spec fn is_impossible(s: Seq<char>, k: int) -> bool {
    s.len() < k
}",,"fn solve(s: Vec<char>, k: i8) -> (result: String)
    requires valid_input(s@, k as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0165,verus,apps,apps_test_811,,"Given `a` initial candles and the ability to create 1 new candle from `b` burnt-out candles,
determine the maximum number of hours the room can be lit. Each candle burns for exactly 1 hour.","use vstd::prelude::*;

verus! {

spec fn valid_input(a: int, b: int) -> bool {
  a >= 1 && a <= 1000 && b >= 2 && b <= 1000
}

spec fn total_burning_hours(a: int, b: int) -> int
  decreases a via a_decreases
{
  if a <= 0 { 0 }
  else if a < b { a }
  else { a + total_burning_hours(a / b, b) }
}

#[verifier::decreases_by]
proof fn a_decreases(a: int, b: int) {
  assume(false);
}",,"fn solve(a: i8, b: i8) -> (result: i8)
  requires 
    valid_input(a as int, b as int)
  ensures 
    result as int >= a as int,
    result as int == total_burning_hours(a as int, b as int)","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0167,verus,apps,apps_test_821,,"Two participants compete in a typing race. Each participant has a ping delay and typing speed.
The total time for participant i is 2*t_i + s*v_i where t_i is ping, v_i is typing speed per character, s is text length.
Determine winner based on who completes first, or declare friendship if tied.","use vstd::prelude::*;

verus! {

spec fn valid_input(s: int, v1: int, v2: int, t1: int, t2: int) -> bool
{
    1 <= s <= 1000 && 1 <= v1 <= 1000 && 1 <= v2 <= 1000 && 1 <= t1 <= 1000 && 1 <= t2 <= 1000
}

spec fn participant_time(s: int, v: int, t: int) -> int
{
    2 * t + s * v
}

spec fn correct_result(s: int, v1: int, v2: int, t1: int, t2: int) -> Seq<char>
{
    let time1 = participant_time(s, v1, t1);
    let time2 = participant_time(s, v2, t2);
    if time1 < time2 { seq!['F','i','r','s','t'] }
    else if time1 > time2 { seq!['S','e','c','o','n','d'] }
    else { seq!['F','r','i','e','n','d','s','h','i','p'] }
}

spec fn valid_result(result: Seq<char>) -> bool
{
    result == seq!['F','i','r','s','t'] || result == seq!['S','e','c','o','n','d'] || result == seq!['F','r','i','e','n','d','s','h','i','p']
}",,"fn solve(s: i8, v1: i8, v2: i8, t1: i8, t2: i8) -> (result: Vec<char>)
    requires 
        valid_input(s as int, v1 as int, v2 as int, t1 as int, t2 as int)
    ensures 
        valid_result(result@) &&
        result@ == correct_result(s as int, v1 as int, v2 as int, t1 as int, t2 as int)","{
    assume(false);
    Vec::new()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0168,verus,apps,apps_test_823,,"Given an infinite spiral starting at (0,0) that visits every integer point,
determine the number of turns required to reach point (x,y) from origin.
The spiral follows: (0,0) → (1,0) → (1,1) → (-1,1) → (-1,-1) → (2,-1) → ...
A turn occurs when direction changes (right→up, up→left, left→down, down→right).","use vstd::prelude::*;

verus! {
spec fn valid_input(x: int, y: int) -> bool {
    -100 <= x <= 100 && -100 <= y <= 100
}

spec fn is_origin_or_first_point(x: int, y: int) -> bool {
    (x == 0 && y == 0) || (x == 1 && y == 0)
}

spec fn is_right_edge(x: int, y: int) -> bool {
    x >= 1 && -x + 1 < y <= x
}

spec fn is_left_edge(x: int, y: int) -> bool {
    x < 0 && x <= y < -x
}

spec fn is_top_edge(x: int, y: int) -> bool {
    y > 0 && -y <= x < y
}

spec fn compute_turns(x: int, y: int) -> int
    recommends valid_input(x, y)
{
    if is_origin_or_first_point(x, y) { 
        0
    } else if is_right_edge(x, y) { 
        1 + 4 * (x - 1)
    } else if is_left_edge(x, y) { 
        3 + 4 * (-x - 1)
    } else if is_top_edge(x, y) { 
        2 + 4 * (y - 1)
    } else { 
        -4 * y
    }
}",,"fn solve(x: i8, y: i8) -> (result: i8)
    requires 
        valid_input(x as int, y as int)
    ensures 
        result as int >= 0,
        result as int == compute_turns(x as int, y as int),
        is_origin_or_first_point(x as int, y as int) ==> result as int == 0,
        is_right_edge(x as int, y as int) ==> result as int == 1 + 4 * (x as int - 1),
        is_left_edge(x as int, y as int) ==> result as int == 3 + 4 * (-(x as int) - 1),
        is_top_edge(x as int, y as int) ==> result as int == 2 + 4 * (y as int - 1),
        !(is_origin_or_first_point(x as int, y as int) || is_right_edge(x as int, y as int) || is_left_edge(x as int, y as int) || is_top_edge(x as int, y as int)) ==> result as int == -4 * y as int,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0169,verus,apps,apps_test_826,,"Find the minimum cost to obtain logs of lengths 1, 2, 3, ..., n.
We can purchase logs of lengths 1, 2, 3, ..., n+1 (each costing 1 unit),
cut them into smaller pieces, and discard unwanted pieces.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int) -> bool {
    n >= 1
}

spec fn is_optimal_savings(n: int, savings: int) -> bool {
    n >= 1 ==> (
        savings >= 0 &&
        (2 + savings) * (savings + 1) / 2 > n + 1 &&
        (savings == 0 || (2 + (savings - 1)) * savings / 2 <= n + 1)
    )
}

spec fn is_minimal_savings(n: int, savings: int) -> bool {
    n >= 1 ==> (
        is_optimal_savings(n, savings) &&
        (forall|j: int| j >= 0 && j < savings ==> #[trigger] ((2 + j) * (j + 1) / 2) <= n + 1)
    )
}

spec fn optimal_cost(n: int, savings: int) -> int {
    if n >= 1 && is_optimal_savings(n, savings) {
        n - savings + 1
    } else {
        0
    }
}",,"fn solve(n: i8) -> (result: i8)
    requires 
        valid_input(n as int)
    ensures 
        result as int >= 1,
        result as int <= n as int,
        exists|savings: int| is_minimal_savings(n as int, savings) && result as int == optimal_cost(n as int, savings),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0170,verus,apps,apps_test_838,,"Count non-empty sets of cells in a binary grid where all cells have the same color (0 or 1)
and every pair of cells in the set shares either a row or a column.","use vstd::prelude::*;

verus! {

spec fn valid_input(stdin_input: Seq<char>) -> bool {
    stdin_input.len() > 0
}

spec fn valid_grid(grid: Seq<Seq<int>>) -> bool {
    grid.len() > 0 && 
    (forall|i: int| 0 <= i < grid.len() ==> grid[i].len() > 0) &&
    (forall|i: int, j: int| 0 <= i < grid.len() && 0 <= j < grid[i].len() ==> 
        grid[i][j] == 0 || grid[i][j] == 1)
}

spec fn count_valid_sets(grid: Seq<Seq<int>>) -> int {
    grid.len() * grid[0].len() + 
    sum_row_contributions(grid) + 
    sum_col_contributions(grid)
}

spec fn sum_row_contributions(grid: Seq<Seq<int>>) -> int {
    sum_row_contributions_helper(grid, 0)
}

spec fn sum_row_contributions_helper(grid: Seq<Seq<int>>, row: int) -> int
    decreases grid.len() - row
{
    if row >= grid.len() { 0 }
    else { row_contribution(grid, row) + sum_row_contributions_helper(grid, row + 1) }
}

spec fn row_contribution(grid: Seq<Seq<int>>, row: int) -> int {
    let cnt0 = count_in_row(grid, row, 0);
    let cnt1 = count_in_row(grid, row, 1);
    (if cnt0 > 1 { power(2, cnt0) - cnt0 - 1 } else { 0 }) +
    (if cnt1 > 1 { power(2, cnt1) - cnt1 - 1 } else { 0 })
}

spec fn sum_col_contributions(grid: Seq<Seq<int>>) -> int {
    sum_col_contributions_helper(grid, 0)
}

spec fn sum_col_contributions_helper(grid: Seq<Seq<int>>, col: int) -> int
    decreases grid[0].len() - col
{
    if col >= grid[0].len() { 0 }
    else { col_contribution(grid, col) + sum_col_contributions_helper(grid, col + 1) }
}

spec fn col_contribution(grid: Seq<Seq<int>>, col: int) -> int {
    let cnt0 = count_in_col(grid, col, 0);
    let cnt1 = count_in_col(grid, col, 1);
    (if cnt0 > 1 { power(2, cnt0) - cnt0 - 1 } else { 0 }) +
    (if cnt1 > 1 { power(2, cnt1) - cnt1 - 1 } else { 0 })
}

spec fn count_in_row(grid: Seq<Seq<int>>, row: int, value: int) -> int {
    count_in_row_helper(grid, row, value, 0)
}

spec fn count_in_row_helper(grid: Seq<Seq<int>>, row: int, value: int, col: int) -> int
    decreases grid[row].len() - col
{
    if col >= grid[row].len() { 0 }
    else { (if grid[row][col] == value { 1int } else { 0int }) + count_in_row_helper(grid, row, value, col + 1) }
}

spec fn count_in_col(grid: Seq<Seq<int>>, col: int, value: int) -> int {
    if grid.len() == 0 { 0 }
    else { count_col_helper(grid, col, value, 0) }
}

spec fn count_col_helper(grid: Seq<Seq<int>>, col: int, value: int, row: int) -> int
    decreases grid.len() - row
{
    if row >= grid.len() { 0 }
    else { (if grid[row][col] == value { 1int } else { 0int }) + count_col_helper(grid, col, value, row + 1) }
}

spec fn power(base: int, exp: int) -> int
    decreases exp
{
    if exp <= 0 { 1 }
    else { base * power(base, exp - 1) }
}

spec fn int_to_string(n: int) -> Seq<char> {
    seq!['0'] /* placeholder implementation */
}",,"fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(stdin_input@),
    ensures result@.len() > 0,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0171,verus,apps,apps_test_842,,"Given a string input, extract the first line and create an even-length palindrome
by concatenating the line with its reverse, followed by a newline.","use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>) -> bool {
    s.len() > 0
}

spec fn extract_first_line(s: Seq<char>) -> Seq<char>
    recommends s.len() > 0
{
    let newline_pos = find_first_newline(s);
    if newline_pos == -1 { s } else { s.subrange(0, newline_pos) }
}

spec fn find_first_newline(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        -1
    } else if s[0] == '\n' {
        0
    } else {
        let rest_result = find_first_newline(s.subrange(1, s.len() as int));
        if rest_result == -1 { -1 } else { rest_result + 1 }
    }
}

spec fn reverse_string(s: Seq<char>) -> Seq<char>
    decreases s.len()
{
    if s.len() == 0 { 
        Seq::empty() 
    } else { 
        reverse_string(s.subrange(1, s.len() as int)).push(s[0]) 
    }
}

spec fn valid_output(result: Seq<char>, input: Seq<char>) -> bool
    recommends input.len() > 0
{
    result.len() >= 1 &&
    result[result.len() - 1] == '\n' &&
    exists|n: Seq<char>| 
        n == extract_first_line(input) &&
        result == n.add(reverse_string(n)).push('\n')
}",,"fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(stdin_input@)
    ensures valid_output(result@, stdin_input@)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0172,verus,apps,apps_test_847,,"Given n cards with integers (absolute value ≤ x), find the minimum number of additional cards
needed to make the total sum equal to zero. Additional cards can have integer values from -x to x.","use vstd::prelude::*;

verus! {
spec fn sum(cards: Seq<int>) -> int
    decreases cards.len()
{
    if cards.len() == 0 {
        0
    } else {
        cards[0] + sum(cards.subrange(1, cards.len() as int))
    }
}

spec fn abs(x: int) -> int {
    if x >= 0 { x } else { -x }
}

spec fn valid_input(cards: Seq<int>, x: int) -> bool {
    x > 0 && cards.len() >= 1 && forall|i: int| 0 <= i < cards.len() ==> #[trigger] cards[i] >= -x && #[trigger] cards[i] <= x
}

spec fn solve_result(cards: Seq<int>, x: int) -> int {
    if sum(cards) == 0 { 0 } else { (abs(sum(cards)) + x - 1) / x }
}",,"fn solve(cards: Vec<i8>, x: i8) -> (result: i8)
    requires 
        valid_input(cards@.map(|i: int, v: i8| v as int), x as int),
    ensures 
        result as int >= 0,
        result as int == solve_result(cards@.map(|i: int, v: i8| v as int), x as int),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,DupVA03,0.85
VA0173,verus,apps,apps_test_858,,"Given N attendees at a brain dinner (including Heidi), determine the minimum number of brains needed
in a chest for Heidi to survive. Heidi makes the first proposal for brain distribution, which must be 
accepted by at least half of all attendees (including herself) for her to survive.","use vstd::prelude::*;

verus! {
spec fn is_power_of_two(n: int) -> bool
    decreases n
{
    if n <= 0 {
        false
    } else if n == 1 {
        true
    } else if n % 2 == 1 {
        false
    } else {
        is_power_of_two(n / 2)
    }
}

spec fn valid_input(n: int) -> bool {
    n >= 1
}

spec fn correct_result(n: int, result: int) -> bool {
    if n % 2 == 1 {
        result == (n - 1) / 2
    } else {
        exists|z: int| 1 <= z <= n && is_power_of_two(z) && z <= n && z * 2 > n && result == (n - z) / 2
    }
}",,"fn solve(n: i8) -> (result: i8)
    requires valid_input(n as int)
    ensures correct_result(n as int, result as int)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0174,verus,apps,apps_test_862,,"Allen starts at the end of queue 1 and moves cyclically through n queues.
Each minute, one person from each non-empty queue enters the fan zone.
If Allen is at the front of his current queue, he enters; otherwise he moves to the next queue.
Find which entrance Allen will use to enter the fan zone.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, a: Seq<int>) -> bool {
  n >= 2 && a.len() == n && (forall|i: int| 0 <= i < n ==> #[trigger] a[i] >= 0)
}

spec fn compute_b(a: Seq<int>, i: int) -> int
  recommends 0 <= i < a.len()
{
  a[i] - i
}

spec fn compute_c(n: int, b: int) -> int
  recommends n >= 2
{
  if b < 0 { b / n } else { (b + n - 1) / n }
}

spec fn compute_cc(n: int, a: Seq<int>, i: int) -> int
  recommends valid_input(n, a) && 0 <= i < n
{
  let b = compute_b(a, i);
  let c = compute_c(n, b);
  n * c
}

spec fn is_optimal_entrance(n: int, a: Seq<int>, entrance: int) -> bool
  recommends valid_input(n, a) && 1 <= entrance <= n
{
  let i = entrance - 1;
  forall|j: int| 0 <= j < n ==> {
    let cci = compute_cc(n, a, i);
    let ccj = #[trigger] compute_cc(n, a, j);
    cci <= ccj && (cci < ccj || i <= j)
  }
}",,"fn solve(n: i8, a: Vec<i8>) -> (result: i8)
  requires
    valid_input(n as int, a@.map(|i, x: i8| x as int)),
  ensures
    1 <= result as int <= n as int,
    is_optimal_entrance(n as int, a@.map(|i, x: i8| x as int), result as int),","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0176,verus,apps,apps_test_869,,"Given a red socks and b blue socks, determine the maximum number of days to wear
different colored socks (one red, one blue per day), then the number of days to
wear same colored socks afterwards (two socks of same color per day). Each day,
worn socks are discarded.","use vstd::prelude::*;

verus! {

spec fn valid_input(a: int, b: int) -> bool
{
  a >= 1 && b >= 1
}

spec fn max_different_days(a: int, b: int) -> int
{
  if a < b { a } else { b }
}

spec fn remaining_after_different(a: int, b: int) -> int
{
  if a > b { a - max_different_days(a, b) } else { b - max_different_days(a, b) }
}

spec fn same_days(a: int, b: int) -> int
{
  remaining_after_different(a, b) / 2
}",,"fn solve(a: i8, b: i8) -> (result: (i8, i8))
  requires valid_input(a as int, b as int)
  ensures ({
      let (days_different, days_same) = result;
      days_different as int == max_different_days(a as int, b as int) &&
      days_same as int == same_days(a as int, b as int) &&
      days_different >= 0 &&
      days_same >= 0 &&
      days_different <= a && days_different <= b
  })","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0178,verus,apps,apps_test_883,,"There are n+1 people (Dima and n friends) standing in a circle. Each person shows 1-5 fingers.
Starting from Dima, they count around the circle a total number equal to the sum of all fingers.
The person where counting stops must clean the apartment.
Given the fingers shown by Dima's n friends, determine how many different ways Dima can show
his fingers (1-5) such that he does NOT have to clean the apartment.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, friends: Seq<int>) -> bool {
  n >= 1 && friends.len() == n && forall|i: int| 0 <= i < friends.len() ==> #[trigger] friends[i] >= 1 && #[trigger] friends[i] <= 5
}

spec fn sum_sequence(s: Seq<int>) -> int
  decreases s.len()
{
  if s.len() == 0 { 0 } else { s[0] + sum_sequence(s.subrange(1, s.len() as int)) }
}

spec fn dima_cleans(n: int, friends: Seq<int>, dima_fingers: int) -> bool {
  &&& valid_input(n, friends)
  &&& 1 <= dima_fingers <= 5
  &&& {
    let total_sum = sum_sequence(friends) + dima_fingers;
    let total_people = n + 1;
    total_sum % total_people == 1
  }
}

spec fn count_valid_choices(n: int, friends: Seq<int>) -> int {
  if valid_input(n, friends) {
    count_valid_choices_helper(n, friends, 1)
  } else {
    0
  }
}

spec fn count_valid_choices_helper(n: int, friends: Seq<int>, finger_count: int) -> int
  decreases 6 - finger_count
{
  if !(valid_input(n, friends) && 1 <= finger_count <= 6) {
    0
  } else if finger_count > 5 {
    0
  } else if !dima_cleans(n, friends, finger_count) {
    1 + count_valid_choices_helper(n, friends, finger_count + 1)
  } else {
    count_valid_choices_helper(n, friends, finger_count + 1)
  }
}",,"fn solve(n: i8, friends: Vec<i8>) -> (result: i8)
  requires 
    valid_input(n as int, friends@.map_values(|x: i8| x as int))
  ensures 
    0 <= result <= 5,
    result as int == count_valid_choices(n as int, friends@.map_values(|x: i8| x as int))","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0180,verus,apps,apps_test_894,,"Given a rectangle with vertices at (0,0) and (x,y), find two points A=(x₁,y₁) and C=(x₂,y₂) 
such that triangle ABC with B=(0,0) is right-angled and isosceles at B, contains the entire 
rectangle, has minimum area, and all coordinates are integers with x₁ < x₂.","use vstd::prelude::*;

verus! {
spec fn valid_input(x: int, y: int) -> bool {
    x != 0 && y != 0
}

spec fn valid_output(result: Seq<int>, x: int, y: int) -> bool {
    result.len() == 4 &&
    result[0] < result[2] &&
    (x * y > 0 && x < 0 ==> result =~= seq![x + y, 0, 0, x + y]) &&
    (x * y > 0 && x >= 0 ==> result =~= seq![0, x + y, x + y, 0]) &&
    (x * y <= 0 && x < 0 ==> result =~= seq![x - y, 0, 0, y - x]) &&
    (x * y <= 0 && x >= 0 ==> result =~= seq![0, y - x, x - y, 0])
}",,"fn solve(x: i8, y: i8) -> (result: Vec<i8>)
    requires valid_input(x as int, y as int)
    ensures valid_output(result@.map(|i: int, v: i8| v as int), x as int, y as int)","{
    assume(false);
    Vec::new()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0181,verus,apps,apps_test_895,,"Given n students who perform rituals at times t_i, find the maximum number of students 
that can be visited by a ""freebie"" present for exactly T consecutive seconds.
All visited students must have ritual times within the same T-second interval.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, times: Seq<int>, T: int) -> bool {
    n >= 1 && times.len() == n && T >= 1 && 
    forall|i: int| 0 <= i < times.len() ==> 1 <= #[trigger] times[i] <= 1000
}

spec fn max_students_in_window(times: Seq<int>, T: int) -> int {
    max_students_in_window_up_to(times, T, 1000)
}

spec fn max_students_in_window_up_to(times: Seq<int>, T: int, max_start: int) -> int
    decreases max_start
{
    if max_start < 1 { 
        0
    } else {
        let count = count_students_in_window(times, max_start, T);
        let rest_max = max_students_in_window_up_to(times, T, max_start - 1);
        if count > rest_max { count } else { rest_max }
    }
}

spec fn count_students_in_window(times: Seq<int>, start: int, T: int) -> int {
    if times.len() == 0 { 
        0 
    } else { 
        count_students_in_window_helper(times, start, T, 0) 
    }
}

spec fn count_students_in_window_helper(times: Seq<int>, start: int, T: int, index: int) -> int
    decreases times.len() - index
{
    if index >= times.len() { 
        0
    } else {
        let count_rest = count_students_in_window_helper(times, start, T, index + 1);
        if start <= times[index] <= start + T - 1 { 
            count_rest + 1 
        } else { 
            count_rest 
        }
    }
}",,"fn solve(n: i8, times: Vec<i8>, T: i8) -> (result: i8)
    requires valid_input(n as int, times@.map(|i, v| v as int), T as int)
    ensures result >= 0 && result <= n && result as int == max_students_in_window(times@.map(|i, v| v as int), T as int)","{
    // impl-start
    assume(false);
    n
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0183,verus,apps,apps_test_909,,"Given three positive integers a, b, and c, find the maximum possible value 
of an arithmetic expression formed by inserting operation signs ('+' or '*') 
between the numbers and optionally adding brackets. The numbers must remain 
in order a, b, c. All six possible expressions must be considered:
a + b + c, a + b * c, a * b + c, a * b * c, (a + b) * c, a * (b + c)","use vstd::prelude::*;

verus! {

spec fn valid_input(a: int, b: int, c: int) -> bool {
    1 <= a <= 10 && 1 <= b <= 10 && 1 <= c <= 10
}

spec fn all_expressions(a: int, b: int, c: int) -> Seq<int> {
    seq![a * b * c, a + b * c, a * b + c, a * (b + c), (a + b) * c, a + b + c]
}

spec fn max_expression(a: int, b: int, c: int) -> int
    recommends valid_input(a, b, c)
{
    let exprs = all_expressions(a, b, c);
    if exprs[0] >= exprs[1] && exprs[0] >= exprs[2] && exprs[0] >= exprs[3] && exprs[0] >= exprs[4] && exprs[0] >= exprs[5] { exprs[0] }
    else if exprs[1] >= exprs[2] && exprs[1] >= exprs[3] && exprs[1] >= exprs[4] && exprs[1] >= exprs[5] { exprs[1] }
    else if exprs[2] >= exprs[3] && exprs[2] >= exprs[4] && exprs[2] >= exprs[5] { exprs[2] }
    else if exprs[3] >= exprs[4] && exprs[3] >= exprs[5] { exprs[3] }
    else if exprs[4] >= exprs[5] { exprs[4] }
    else { exprs[5] }
}

spec fn is_max_of_all_expressions(result: int, a: int, b: int, c: int) -> bool
    recommends valid_input(a, b, c)
{
    let exprs = all_expressions(a, b, c);
    exprs.contains(result) && forall|i: int| 0 <= i < exprs.len() ==> result >= exprs[i]
}",,"fn solve(a: i8, b: i8, c: i8) -> (result: i8)
    requires 
        valid_input(a as int, b as int, c as int),
    ensures 
        is_max_of_all_expressions(result as int, a as int, b as int, c as int),
        result as int == max_expression(a as int, b as int, c as int),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0185,verus,apps,apps_test_913,,"Given n problems and two robots, determine the minimum possible maximum point value
needed to ensure the first robot scores strictly more points than the second robot.
Return -1 if the first robot cannot outperform the second robot.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, r: Seq<int>, b: Seq<int>) -> bool {
    n > 0 && r.len() == n && b.len() == n &&
    (forall|i: int| 0 <= i < n ==> (r[i] == 0 || r[i] == 1)) &&
    (forall|i: int| 0 <= i < n ==> (b[i] == 0 || b[i] == 1))
}

spec fn robot_advantage_count(n: int, r: Seq<int>, b: Seq<int>) -> int {
    Set::new(|i: int| 0 <= i < n && r[i] == 1 && b[i] == 0).len() as int
}

spec fn opponent_advantage_count(n: int, r: Seq<int>, b: Seq<int>) -> int {
    Set::new(|i: int| 0 <= i < n && r[i] == 0 && b[i] == 1).len() as int
}

spec fn can_win(n: int, r: Seq<int>, b: Seq<int>) -> bool {
    robot_advantage_count(n, r, b) > 0
}

spec fn min_max_point_value(n: int, r: Seq<int>, b: Seq<int>) -> int {
    opponent_advantage_count(n, r, b) / robot_advantage_count(n, r, b) + 1
}",,"fn solve(n: i8, r: Vec<i8>, b: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, r@.map_values(|x: i8| x as int), b@.map_values(|x: i8| x as int))
    ensures if can_win(n as int, r@.map_values(|x: i8| x as int), b@.map_values(|x: i8| x as int)) { result as int == min_max_point_value(n as int, r@.map_values(|x: i8| x as int), b@.map_values(|x: i8| x as int)) } else { result == -1 }","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0186,verus,apps,apps_test_925,,"Given a 2-digit number displayed on a 7-segment digital counter, count how many 
2-digit numbers (00-99) could have been the intended display before some light 
segments potentially broke (turned off). Segments can only break by turning OFF.","use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() >= 2 && 
    '0' <= input[0] <= '9' && 
    '0' <= input[1] <= '9' &&
    (input[input.len() - 1] == '\n' || (input[0] != '\n' && input[1] != '\n'))
}

spec fn good_digit_count(digit: char) -> int 
    recommends '0' <= digit <= '9'
{
    if digit == '0' { 2 }
    else if digit == '1' { 7 }
    else if digit == '2' { 2 }
    else if digit == '3' { 3 }
    else if digit == '4' { 3 }
    else if digit == '5' { 4 }
    else if digit == '6' { 2 }
    else if digit == '7' { 5 }
    else if digit == '8' { 1 }
    else { 2 }
}

spec fn compute_total_good_count(input: Seq<char>) -> int 
    recommends valid_input(input)
{
    good_digit_count(input[0]) * good_digit_count(input[1])
}

spec fn valid_output(result: Seq<char>, expected_count: int) -> bool {
    result.len() >= 2 && 
    result[result.len() - 1] == '\n' &&
    (forall|c: char| result.contains(c) ==> c == '\n' || ('0' <= c <= '9')) &&
    expected_count >= 1 && expected_count <= 49
}",,"fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(input@)
    ensures valid_output(result@, compute_total_good_count(input@))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0187,verus,apps,apps_test_935,,"Given a grid with n horizontal and m vertical sticks, two players take turns
removing intersection points. When an intersection is removed, all sticks 
passing through it are removed. The player who cannot make a move loses.
Akshat goes first. Determine the winner when both players play optimally.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, m: int) -> bool {
    1 <= n <= 100 && 1 <= m <= 100
}

spec fn game_moves(n: int, m: int) -> int {
    if n < m { n } else { m }
}

spec fn winner(n: int, m: int) -> bool {
    let moves = game_moves(n, m);
    moves % 2 == 1
}",,"fn solve(n: i8, m: i8) -> (result: bool)
    requires valid_input(n as int, m as int)
    ensures result == winner(n as int, m as int)","{
    assume(false);
    false
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0188,verus,apps,apps_test_940,,"Given three stick lengths, find the minimum number of operations to form a triangle
with positive area, where each operation increases any stick's length by 1 centimeter.
A triangle has positive area if it satisfies the triangle inequality: the sum of any
two sides must be greater than the third side.","use vstd::prelude::*;

verus! {

spec fn valid_input(a: int, b: int, c: int) -> bool {
    1 <= a <= 100 && 1 <= b <= 100 && 1 <= c <= 100
}

spec fn is_triangle(a: int, b: int, c: int) -> bool {
    a + b > c && a + c > b && b + c > a
}

spec fn min_operations_needed(a: int, b: int, c: int) -> int
    recommends valid_input(a, b, c)
{
    let max_val = if a >= b && a >= c { a } else if b >= c { b } else { c };
    let sum_of_other_two = a + b + c - max_val;
    if max_val - sum_of_other_two + 1 > 0 { max_val - sum_of_other_two + 1 } else { 0 }
}",,"fn solve(a: i8, b: i8, c: i8) -> (result: i8)
    requires 
        valid_input(a as int, b as int, c as int)
    ensures 
        result >= 0,
        result as int == min_operations_needed(a as int, b as int, c as int),
        (result as int == 0) <==> is_triangle(a as int, b as int, c as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0189,verus,apps,apps_test_948,,"Given an n×m grid of lowercase Latin letters, count the number of 2×2 squares 
where the four letters can form the word ""face"" (i.e., the four letters are 
exactly 'f', 'a', 'c', 'e' in any arrangement). Overlapping squares are counted separately.","use vstd::prelude::*;
use vstd::string::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0
}

spec fn valid_grid(grid: Seq<Seq<char>>, n: int, m: int) -> bool {
    n >= 1 && m >= 1 && grid.len() == n &&
    forall|i: int| 0 <= i < grid.len() ==> grid[i].len() == m
}

spec fn count_face_squares(input: Seq<char>) -> int
    decreases input.len()
{
    if input.len() == 0 {
        0
    } else {
        /* Parse input and count valid face squares */
        0  /* Placeholder - actual implementation would parse lines and count squares */
    }
}

spec fn count_face_squares_as_string(input: Seq<char>) -> Seq<char> {
    /* Convert count to string representation */
    seq!['0', '\n']  /* Placeholder */
}",,"fn solve(input: String) -> (result: String)
    requires 
        valid_input(input@),
    ensures 
        result@.len() > 0,
        result@ == count_face_squares_as_string(input@)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0190,verus,apps,apps_test_949,,"Find the greatest common divisor of all integers in the range [a, b] inclusive,
where 1 ≤ a ≤ b. If a = b, the GCD is a. If a < b, the GCD is 1 since
consecutive integers are coprime.","use vstd::prelude::*;

verus! {
spec fn valid_input(a: int, b: int) -> bool {
    1 <= a <= b
}

spec fn gcd_of_range(a: int, b: int) -> int
    recommends valid_input(a, b)
{
    if a == b { a } else { 1 }
}",,"fn solve(a: i8, b: i8) -> (result: i8)
    requires 
        valid_input(a as int, b as int)
    ensures 
        result as int == gcd_of_range(a as int, b as int),
        a == b ==> result as int == a as int,
        a < b ==> result as int == 1","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0191,verus,apps,apps_test_954,,"Given a string, determine how many distinct strings can be obtained by repeatedly 
applying a cyclic shift operation. A cyclic shift moves the last character of the 
string to the beginning.","use vstd::prelude::*;

verus! {
spec fn cyclic_shift_forward(s: Seq<char>) -> Seq<char>
{
    if s.len() > 0 { s.subrange(1, s.len() as int).add(seq![s[0]]) } else { s }
}

spec fn valid_input(s: Seq<char>) -> bool
{
    s.len() > 0
}

spec fn apply_shifts(s: Seq<char>, steps: nat) -> Seq<char>
    decreases steps
{
    if s.len() > 0 && steps > 0 { cyclic_shift_forward(apply_shifts(s, (steps - 1) as nat)) }
    else if s.len() > 0 { s }
    else { s }
}

spec fn all_distinct_cyclic_shifts(s: Seq<char>) -> nat
{
    if s.len() > 0 { s.len() } else { 0 }
}",,"fn solve(s: Vec<char>) -> (result: usize)
    requires 
        valid_input(s@),
    ensures 
        1 <= result <= s.len(),
        result == all_distinct_cyclic_shifts(s@),","{
    assume(false);
    0
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0192,verus,apps,apps_test_960,,"Find the smallest positive integer x such that (x div k) × (x mod k) = n,
where x div k is integer division and x mod k is the remainder.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, k: int) -> bool {
    n >= 1 && k >= 2
}

spec fn satisfies_constraint(x: int, n: int, k: int) -> bool {
    x > 0 && k > 0 && (x / k) * (x % k) == n
}",,"fn solve(n: i8, k: i8) -> (result: i8)
    requires 
        valid_input(n as int, k as int)
    ensures 
        result > 0,
        satisfies_constraint(result as int, n as int, k as int),
        forall|x: int| #[trigger] satisfies_constraint(x, n as int, k as int) ==> result as int <= x","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0193,verus,apps,apps_test_963,,"Given N cells numbered 1 to N, find the number of ways to move from cell 1 to cell N.
You have K non-intersecting integer segments [L₁,R₁], [L₂,R₂], ..., [Lₖ,Rₖ].
Let S be the union of all integers in these segments.
From cell i, you can move to cell i+d where d ∈ S, provided i+d ≤ N.
Return the count modulo 998244353.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, k: int, segments: Seq<(int, int)>) -> bool {
    n >= 2 &&
    k >= 1 &&
    segments.len() == k &&
    (forall|i: int| 0 <= i < k ==> segments[i].0 >= 1 && segments[i].1 <= n && segments[i].0 <= segments[i].1) &&
    (forall|i: int, j: int| 0 <= i < j < k ==> segments[i].1 < segments[j].0 || segments[j].1 < segments[i].0)
}

spec fn compute_ways_dp(n: int, k: int, segments: Seq<(int, int)>) -> int {
    let dp = Map::new(|i: int| 0 <= i <= n, |i: int| if i == 1 { 1 } else { 0 });
    let prefix_sum = Map::new(|i: int| 0 <= i <= n, |i: int| if i == 1 { 1 } else { 0 });
    compute_ways_dp_helper(n, k, segments, dp, prefix_sum, 2)
}

spec fn compute_ways_dp_helper(n: int, k: int, segments: Seq<(int, int)>, dp: Map<int, int>, prefix_sum: Map<int, int>, pos: int) -> int
    decreases n - pos + 1
{
    if pos > n {
        dp[n] % 998244353
    } else {
        let new_dp_val = compute_segment_contributions(pos, k, segments, prefix_sum, 0, 0);
        let new_prefix_sum_val = (prefix_sum[pos-1] + new_dp_val) % 998244353;
        let updated_dp = dp.insert(pos, new_dp_val);
        let updated_prefix_sum = prefix_sum.insert(pos, new_prefix_sum_val);
        compute_ways_dp_helper(n, k, segments, updated_dp, updated_prefix_sum, pos + 1)
    }
}

spec fn compute_segment_contributions(pos: int, k: int, segments: Seq<(int, int)>, prefix_sum: Map<int, int>, seg_index: int, acc: int) -> int
    decreases k - seg_index
{
    if seg_index >= k {
        acc
    } else {
        let start = segments[seg_index].0;
        let end = segments[seg_index].1;
        let i_s = if pos - start >= 0 { pos - start } else { 0 };
        let i_e = if pos - end - 1 >= 0 { pos - end - 1 } else { 0 };
        let contribution = (prefix_sum[i_s] - prefix_sum[i_e] + 998244353) % 998244353;
        let new_acc = (acc + contribution) % 998244353;
        compute_segment_contributions(pos, k, segments, prefix_sum, seg_index + 1, new_acc)
    }
}",,"fn solve(n: i8, k: i8, segments: Vec<(i8, i8)>) -> (result: i8)
    requires 
        valid_input(n as int, k as int, segments@.map(|idx, seg: (i8, i8)| (seg.0 as int, seg.1 as int)))
    ensures 
        result < 998244353 &&
        result == compute_ways_dp(n as int, k as int, segments@.map(|idx, seg: (i8, i8)| (seg.0 as int, seg.1 as int)))","{
    assume(false);
    0
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0194,verus,apps,apps_test_965,,"Given n players in a poker game with statuses ""ALLIN"" (A), ""IN"" (I), or ""FOLDED"" (F),
determine how many players can show their hands. A player can show if their status
is not ""FOLDED"" and all other players have status ""ALLIN"" or ""FOLDED"".","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, statuses: Seq<char>) -> bool {
    n >= 2 && statuses.len() == n && 
    forall|i: int| 0 <= i < statuses.len() ==> (statuses[i] == 'A' || statuses[i] == 'I' || statuses[i] == 'F')
}

spec fn count_status(statuses: Seq<char>, status: char) -> int {
    seq_count(statuses, status)
}

spec fn seq_count(s: Seq<char>, target: char) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else {
        let rest_count = seq_count(s.drop_first(), target);
        if s[0] == target {
            rest_count + 1
        } else {
            rest_count
        }
    }
}

spec fn expected_result(statuses: Seq<char>) -> int {
    let cnt_i = count_status(statuses, 'I');
    let cnt_a = count_status(statuses, 'A');
    if cnt_i == 0 { cnt_a }
    else if cnt_i == 1 { 1 }
    else { 0 }
}",,"fn solve(n: i8, statuses: Vec<char>) -> (result: i8)
    requires valid_input(n as int, statuses@)
    ensures result as int == expected_result(statuses@)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0196,verus,apps,apps_test_967,,"Given n threads initially ordered 1, 2, ..., n, after some messages are posted, 
the threads are reordered such that the thread now at position i was originally 
at position a_i. When a message is posted in a thread, that thread moves to the 
top of the list. Find the number of threads that must have received new messages.
A thread ""surely has a new message"" if there is no possible sequence of message 
posts that could result in the given reordering without that thread receiving a message.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, a: Seq<int>) -> bool {
    n >= 1 &&
    a.len() == n &&
    (forall|i: int| 0 <= i < n ==> 1 <= #[trigger] a[i] <= n) &&
    (forall|i: int, j: int| 0 <= i < j < n ==> a[i] != a[j])
}

spec fn valid_output(n: int, result: int) -> bool {
    0 <= result <= n
}

spec fn reversed_array(a: Seq<int>) -> Seq<int>
    recommends a.len() >= 1
{
    Seq::new(a.len(), |i: int| a[a.len() - 1 - i])
}

spec fn has_increasing_pair(ar: Seq<int>) -> bool {
    exists|i: int| 1 <= i < ar.len() && #[trigger] ar[i] > ar[i-1]
}

spec fn min_index(ar: Seq<int>, n: int) -> int {
    0
}

spec fn correct_result(n: int, a: Seq<int>) -> int
    recommends valid_input(n, a)
{
    let ar = reversed_array(a);
    if has_increasing_pair(ar) {
        let min_i = min_index(ar, n);
        n - min_i
    } else {
        0
    }
}",,"fn solve(n: i8, a: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, a@.map_values(|x: i8| x as int))
    ensures 
        valid_output(n as int, result as int) &&
        result as int == correct_result(n as int, a@.map_values(|x: i8| x as int))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,0.7
VA0197,verus,apps,apps_test_968,,"Given n people, each with a first name and last name, determine if each person can choose 
either their first or last name as a handle such that when the handles are sorted 
lexicographically, they appear in the exact order specified by permutation p.","use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool
  recommends input.len() > 0
{
  let parsed = parse_input(input);
  parsed.valid && 
  parsed.n >= 1 && 
  parsed.names.len() == parsed.n &&
  parsed.permutation.len() == parsed.n &&
  permutation_values_in_range(parsed.permutation, parsed.n) &&
  permutation_is_unique(parsed.permutation, parsed.n) &&
  names_are_non_empty(parsed.names, parsed.n) &&
  all_names_distinct(parsed.names)
}

spec fn permutation_values_in_range(permutation: Seq<int>, n: int) -> bool {
  forall|i: int| 0 <= i < n ==> {
    let val = #[trigger] permutation[i];
    1 <= val <= n
  }
}

spec fn permutation_is_unique(permutation: Seq<int>, n: int) -> bool {
  forall|i: int, j: int| 0 <= i < j < n ==> {
    #[trigger] permutation[i] != #[trigger] permutation[j]
  }
}

spec fn names_are_non_empty(names: Seq<(Seq<char>, Seq<char>)>, n: int) -> bool {
  forall|i: int| 0 <= i < n ==> {
    let name_pair = #[trigger] names[i];
    name_pair.0.len() > 0 && name_pair.1.len() > 0
  }
}

spec fn all_names_distinct(names: Seq<(Seq<char>, Seq<char>)>) -> bool
{
  forall|i: int, j: int| 0 <= i < names.len() && 0 <= j < names.len() ==>
    (i != j ==> {
      let name_i = #[trigger] names[i];
      let name_j = #[trigger] names[j];
      name_i.0 != name_j.0 && name_i.0 != name_j.1 && 
      name_i.1 != name_j.0 && name_i.1 != name_j.1
    })
}

spec fn can_assign_handles_greedy(input: Seq<char>) -> bool
  recommends input.len() > 0 && valid_input(input)
{
  let parsed = parse_input(input);
  let all_handles = create_all_handle_pairs(parsed.names);
  let sorted_handles = sort_handle_pairs(all_handles);
  greedy_assignment_works(sorted_handles, parsed.permutation, parsed.n)
}

struct ParseResult {
  valid: bool,
  n: int,
  names: Seq<(Seq<char>, Seq<char>)>,
  permutation: Seq<int>,
}

struct IntResult {
  valid: bool,
  value: int,
}

struct IntSequenceResult {
  valid: bool,
  sequence: Seq<int>,
}

spec fn parse_input(input: Seq<char>) -> ParseResult
  recommends input.len() > 0
{
  let lines = split_lines(input);
  if lines.len() < 2 {
    ParseResult { valid: false, n: 0, names: seq![], permutation: seq![] }
  } else {
    let n_result = parse_int(lines[0]);
    if !n_result.valid || n_result.value <= 0 || lines.len() != n_result.value + 2 {
      ParseResult { valid: false, n: 0, names: seq![], permutation: seq![] }
    } else {
      let names = parse_names(lines.subrange(1, n_result.value + 1));
      let perm = parse_int_sequence(lines[n_result.value + 1]);
      if names.len() == n_result.value && perm.valid && perm.sequence.len() == n_result.value {
        ParseResult { valid: true, n: n_result.value, names: names, permutation: perm.sequence }
      } else {
        ParseResult { valid: false, n: 0, names: seq![], permutation: seq![] }
      }
    }
  }
}

spec fn lex_less(a: Seq<char>, b: Seq<char>) -> bool
  decreases a.len()
{
  if a.len() == 0 {
    b.len() > 0
  } else if b.len() == 0 {
    false
  } else if a[0] < b[0] {
    true
  } else if a[0] > b[0] {
    false
  } else {
    lex_less(a.subrange(1, a.len() as int), b.subrange(1, b.len() as int))
  }
}

spec fn lex_less_or_equal(a: Seq<char>, b: Seq<char>) -> bool
{
  lex_less(a, b) || a == b
}

/* Placeholder spec functions for missing dependencies */
spec(checked) fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {
  seq![]
}

spec(checked) fn parse_int(line: Seq<char>) -> IntResult {
  IntResult { valid: false, value: 0 }
}

spec(checked) fn parse_names(lines: Seq<Seq<char>>) -> Seq<(Seq<char>, Seq<char>)> {
  seq![]
}

spec(checked) fn parse_int_sequence(line: Seq<char>) -> IntSequenceResult {
  IntSequenceResult { valid: false, sequence: seq![] }
}

spec(checked) fn create_all_handle_pairs(names: Seq<(Seq<char>, Seq<char>)>) -> Seq<(Seq<char>, int)> {
  seq![]
}

spec(checked) fn sort_handle_pairs(handles: Seq<(Seq<char>, int)>) -> Seq<(Seq<char>, int)> {
  handles
}

spec(checked) fn greedy_assignment_works(sorted_handles: Seq<(Seq<char>, int)>, permutation: Seq<int>, n: int) -> bool {
  false
}",,"fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)
  requires
    stdin_input@.len() > 0,
    valid_input(stdin_input@),
  ensures
    result@ == seq!['Y', 'E', 'S'] || result@ == seq!['N', 'O'],
    (result@ == seq!['Y', 'E', 'S']) <==> can_assign_handles_greedy(stdin_input@),","{
  // impl-start
  assume(false);
  vec!['N', 'O']
  // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,0.7
VA0198,verus,apps,apps_test_983,,"Given an array of n integers and coefficients p, q, r, find the maximum value of 
p·a_i + q·a_j + r·a_k where indices i, j, k satisfy 1 ≤ i ≤ j ≤ k ≤ n.","use vstd::prelude::*;

verus! {
spec fn max_prefix(s: Seq<int>, i: nat) -> int
    recommends i < s.len()
    decreases i
{
    if i == 0 { s[0] }
    else if s[i as int] > max_prefix(s, (i-1) as nat) { s[i as int] }
    else { max_prefix(s, (i-1) as nat) }
}

spec fn max_seq(s: Seq<int>) -> int
    recommends s.len() > 0
    decreases s.len()
    when s.len() > 0
{
    if s.len() == 1 { s[0] }
    else {
        let sub_seq = s.subrange(0, (s.len()-1) as int);
        if s[(s.len()-1) as int] > max_seq(sub_seq) { s[(s.len()-1) as int] }
        else { max_seq(sub_seq) }
    }
}

spec fn max_expression(n: int, p: int, q: int, r: int, a: Seq<int>) -> int
    recommends n > 0 && a.len() == n
{
    let s1 = Seq::new(n as nat, |i: int| a[i] * p);
    let s2 = Seq::new(n as nat, |i: int| max_prefix(s1, i as nat) + a[i] * q);
    let s3 = Seq::new(n as nat, |i: int| max_prefix(s2, i as nat) + a[i] * r);
    max_seq(s3)
}

spec fn valid_input(n: int, a: Seq<int>) -> bool
{
    n > 0 && a.len() == n
}",,"fn solve(n: i8, p: i8, q: i8, r: i8, a: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, a@.map(|i, x| x as int))
    ensures result as int == max_expression(n as int, p as int, q as int, r as int, a@.map(|i, x| x as int))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0199,verus,apps,apps_test_985,,"Given n bishops on a 1000×1000 grid, count the number of pairs that attack each other.
Two bishops attack each other if and only if they are on the same diagonal (either main diagonal or anti-diagonal).
Main diagonal: x - y is constant, Anti-diagonal: x + y is constant.","use vstd::prelude::*;

verus! {
spec fn valid_input(positions: Seq<(int, int)>) -> bool {
    positions.len() >= 1 && positions.len() <= 200000 &&
    (forall|i: int| 0 <= i < positions.len() ==> 
        1 <= #[trigger] positions[i].0 <= 1000 && 1 <= positions[i].1 <= 1000) &&
    (forall|i: int, j: int| 0 <= i < j < positions.len() ==> 
        #[trigger] positions[i] != #[trigger] positions[j])
}

spec fn count_attacking_pairs(positions: Seq<(int, int)>) -> int
    recommends valid_input(positions)
{
    /* Count pairs (i,j) where i < j and bishops at positions[i] and positions[j] attack each other */
    positions.len() * (positions.len() - 1) / 2 /* placeholder - actual implementation would count diagonal pairs */
}

spec fn valid_output(positions: Seq<(int, int)>, result: int) -> bool
    recommends valid_input(positions)
{
    result == count_attacking_pairs(positions) && result >= 0
}",,"fn solve_bishops(positions: Vec<(i8, i8)>) -> (result: u64)
    requires
        valid_input(positions@.map(|i, p: (i8, i8)| (p.0 as int, p.1 as int))),
    ensures
        valid_output(positions@.map(|i, p: (i8, i8)| (p.0 as int, p.1 as int)), result as int),
        result >= 0,","{
    assume(false);
    0
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0200,verus,apps,apps_test_986,,"Given n books numbered 1 to n and a library with capacity k, over n consecutive days
a person requests book a_i on day i. The library starts empty and each book costs 1 CHF.
When at capacity, one existing book must be removed before adding a new one.
Find the minimum cost to satisfy all requests using optimal cache replacement strategy.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, k: int, requests: Seq<int>) -> bool {
    n >= 1 && k >= 1 && requests.len() == n &&
    forall|i: int| 0 <= i < requests.len() ==> #[trigger] requests[i] >= 1 && #[trigger] requests[i] <= n
}

spec fn valid_solution(n: int, k: int, requests: Seq<int>, cost: int) -> bool {
    valid_input(n, k, requests) && cost >= 0 && cost <= n
}",,"fn solve(n: i8, k: i8, requests: Vec<i8>) -> (cost: i8)
    requires valid_input(n as int, k as int, requests@.map(|i: int, x: i8| x as int))
    ensures valid_solution(n as int, k as int, requests@.map(|i: int, x: i8| x as int), cost as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0201,verus,apps,apps_test_989,,"Given a sequence of n integers, perform at most k operations where each operation
increases or decreases any element by 1. Find the minimum possible difference
between the maximum and minimum elements after performing these operations.","use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() >= 5 && has_valid_format(input)
}

spec fn has_valid_format(input: Seq<char>) -> bool {
    exists|first_newline: int| 
        0 <= first_newline < input.len() 
        && #[trigger] input[first_newline] == '\n'
        && (input.len() == first_newline + 1 || input[input.len() - 1] == '\n')
}

spec fn is_valid_result_string(result: Seq<char>) -> bool {
    result.len() > 0 && 
    (result == seq!['0'] || (result[0] != '0' && forall|i: int| 0 <= i < result.len() ==> #[trigger] is_digit(result[i])))
}

spec fn is_digit(c: char) -> bool {
    '0' <= c && c <= '9'
}

spec fn represents_minimum_difference(input: Seq<char>, result: Seq<char>) -> bool {
    valid_input(input) && 
    is_valid_result_string(result) &&
    result == seq!['0']
}

spec fn max(a: Seq<int>) -> int
    recommends a.len() > 0
    decreases a.len()
    when a.len() > 0
{
    if a.len() == 1 {
        a[0]
    } else {
        let tail_max = max(a.subrange(1, a.len() as int));
        if a[0] >= tail_max { a[0] } else { tail_max }
    }
}

spec fn min(a: Seq<int>) -> int  
    recommends a.len() > 0
    decreases a.len()
    when a.len() > 0
{
    if a.len() == 1 {
        a[0]
    } else {
        let tail_min = min(a.subrange(1, a.len() as int));
        if a[0] <= tail_min { a[0] } else { tail_min }
    }
}

spec fn int_to_string(n: int) -> Seq<char> {
    if n == 0 {
        seq!['0']
    } else if n > 0 {
        int_to_string_helper(n)
    } else {
        seq!['-'].add(int_to_string_helper(-n))
    }
}

spec fn int_to_string_helper(n: int) -> Seq<char>
    recommends n > 0
    decreases n
{
    if n < 10 {
        seq![(n + 48) as char]
    } else {
        int_to_string_helper(n / 10).add(seq![(n % 10 + 48) as char])
    }
}",,"fn solve(stdin_input: &str) -> (result: String)
    requires 
        valid_input(stdin_input@),
    ensures 
        is_valid_result_string(result@),
        represents_minimum_difference(stdin_input@, result@),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0203,verus,apps,apps_test_1000,,"Find minimum cost to travel from city 1 to city n on a straight line where adjacent cities are 1 km apart,
roads are directional (can only go from lower to higher numbered cities), car has fuel tank capacity v liters
consuming 1 liter per km, and each city i sells fuel at i dollars per liter.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, v: int) -> bool {
    2 <= n <= 100 && 1 <= v <= 100
}

spec fn min_cost(n: int, v: int) -> int {
    let req = n - 1;
    if req <= v {
        req
    } else {
        let remaining = req - v;
        v + remaining * (remaining + 3) / 2
    }
}",,"fn solve(n: i8, v: i8) -> (result: i8)
    requires valid_input(n as int, v as int)
    ensures result as int == min_cost(n as int, v as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0204,verus,apps,apps_test_1002,,"Schedule an optimal event with singer Devu and comedian Churu within a time limit.
Devu must sing all n songs in order with 10-minute rest periods between songs.
Churu tells 5-minute jokes during rest periods and any remaining time.
Find the maximum number of jokes possible, or return -1 if impossible.","use vstd::prelude::*;

verus! {
spec fn sum_seq(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else {
        s[0] + sum_seq(s.subrange(1, s.len() as int))
    }
}

spec fn valid_input(n: int, d: int, t: Seq<int>) -> bool {
    1 <= n <= 100 && 1 <= d <= 10000 &&
    t.len() == n &&
    forall|i: int| 0 <= i < t.len() ==> #[trigger] t[i] >= 1 && #[trigger] t[i] <= 100
}

spec fn min_time_needed(n: int, t: Seq<int>) -> int {
    sum_seq(t) + 10 * (n - 1)
}

spec fn valid_result(n: int, d: int, t: Seq<int>, result: int) -> bool {
    let song_sum = sum_seq(t);
    let min_time = min_time_needed(n, t);
    if min_time > d {
        result == -1
    } else {
        result == (d - song_sum) / 5 && result >= 0
    }
}",,"fn solve(n: i8, d: i8, t: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, d as int, t@.map(|_i: int, x: i8| x as int))
    ensures valid_result(n as int, d as int, t@.map(|_i: int, x: i8| x as int), result as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0205,verus,apps,apps_test_1003,,"Vasya starts with n pairs of socks. Each day he uses one pair and discards it.
Every m-th day (days m, 2m, 3m, ...), his mother buys him one new pair in the evening.
Find the number of days Vasya can wear socks before running out.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, m: int) -> bool {
    n >= 1 && m >= 2
}

spec fn socks_after_day(n: int, m: int, day: int) -> int {
    if m > 0 {
        n + day / m - day
    } else {
        0
    }
}

spec fn can_wear_socks_on_day(n: int, m: int, day: int) -> bool {
    if m > 0 {
        day >= 1 ==> socks_after_day(n, m, day - 1) > 0
    } else {
        false
    }
}",,"fn solve(n: i8, m: i8) -> (result: i8)
  requires 
      valid_input(n as int, m as int)
  ensures 
      result as int >= n as int,
      result as int > 0,
      socks_after_day(n as int, m as int, result as int) <= 0,
      forall|k: int| 1 <= k < result as int ==> socks_after_day(n as int, m as int, k) > 0","{
    assume(false);
    n
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0206,verus,apps,apps_test_1007,,"Find the sum of the k smallest zcy numbers modulo p.
A zcy number is a palindrome with even length in decimal representation.","use vstd::prelude::*;

verus! {
spec fn int_to_string(n: int) -> Seq<char>
    decreases n
{
    if n == 0 {
        seq!['0']
    } else if n < 10 {
        seq![('0' as int + n) as char]
    } else {
        int_to_string(n / 10).add(seq![('0' as int + (n % 10)) as char])
    }
}

spec fn reverse_string(s: Seq<char>) -> Seq<char>
    decreases s.len()
{
    if s.len() == 0 {
        seq![]
    } else {
        reverse_string(s.subrange(1, s.len() as int)).add(seq![s[0]])
    }
}

spec fn string_to_int(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if s.len() == 1 {
        (s[0] as int) - ('0' as int)
    } else {
        string_to_int(s.subrange(0, s.len() - 1)) * 10 + ((s[s.len() - 1] as int) - ('0' as int))
    }
}

spec fn sum_of_palindromes(k: int) -> int
    decreases k
{
    if k <= 0 {
        0
    } else if k == 1 {
        let s = int_to_string(1);
        let reversed = reverse_string(s);
        let palindrome = s.add(reversed);
        string_to_int(palindrome)
    } else {
        let s = int_to_string(k);
        let reversed = reverse_string(s);
        let palindrome = s.add(reversed);
        string_to_int(palindrome) + sum_of_palindromes(k - 1)
    }
}

spec fn valid_input(k: int, p: int) -> bool {
    k >= 1 && p >= 1
}",,"fn solve(k: i8, p: i8) -> (result: i8)
    requires
        valid_input(k as int, p as int),
    ensures
        0 <= result < p,
        result as int == (sum_of_palindromes(k as int) % (p as int)),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VA0208,verus,apps,apps_test_1009,,"Given n cowbells with integer sizes s₁ ≤ s₂ ≤ ... ≤ sₙ and k boxes, find the minimum box size s 
such that all cowbells can be packed into the k boxes, where each box can hold at most 2 cowbells,
the sum of cowbell sizes in each box cannot exceed the box size s, and all boxes have the same size s.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, k: int, l: Seq<int>) -> bool {
    n >= 1 && k >= 1 && n <= 2*k &&
    l.len() == n &&
    forall|i: int, j: int| 0 <= i < l.len()-1 && j == i+1 ==> #[trigger] l[i] <= #[trigger] l[j] &&
    (forall|i: int| 0 <= i < l.len() ==> #[trigger] l[i] >= 0)
}

spec fn valid_box_configuration(boxes: Seq<int>, box_size: int) -> bool {
    boxes.len() >= 1 &&
    (forall|i: int| 0 <= i < boxes.len() ==> #[trigger] boxes[i] <= box_size) &&
    (forall|i: int| 0 <= i < boxes.len() ==> #[trigger] boxes[i] >= 0)
}

spec fn sum_seq(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.subrange(1, s.len() as int)) }
}

spec fn max_seq(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 { 
        0 
    } else if s.len() == 1 { 
        s[0] 
    } else if s[0] >= max_seq(s.subrange(1, s.len() as int)) { 
        s[0] 
    } else { 
        max_seq(s.subrange(1, s.len() as int)) 
    }
}",,"fn solve(n: i8, k: i8, l: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, k as int, l@.map_values(|v: i8| v as int))
    ensures result >= 0","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0210,verus,apps,apps_test_1014,,"Given an n×n chessboard where white queen starts at (1,1), black queen at (1,n),
and all other squares contain green pawns. Players alternate turns capturing pieces
with standard queen movement. Determine the winner under optimal play.","use vstd::prelude::*;
use vstd::string::*;

verus! {
spec fn valid_input(n: int) -> bool {
    n >= 2
}

spec fn is_win_for_white(n: int) -> bool {
    n % 2 == 0
}

spec fn is_win_for_black(n: int) -> bool {
    n % 2 == 1
}

spec fn optimal_white_move(n: int) -> (int, int)
    recommends valid_input(n) && is_win_for_white(n)
{
    (1, 2)
}

spec fn valid_result(n: int, result: String) -> bool
    recommends valid_input(n)
{
    if is_win_for_black(n) {
        result@ == ""black\n""@
    } else {
        result@ == ""white\n1 2\n""@
    }
}",,"fn solve(n: i8) -> (result: String)
    requires valid_input(n as int)
    ensures valid_result(n as int, result)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0211,verus,apps,apps_test_1017,,"Given n stones, find the maximum number of distributions such that no two
consecutive distributions contain the same number of stones. Each distribution
must contain at least 1 stone.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int) -> bool {
    n >= 1
}

spec fn max_distributions(n: int) -> int
    recommends valid_input(n)
{
    if n % 3 == 0 { 2 * (n / 3) } else { 2 * (n / 3) + 1 }
}",,"fn solve(n: i8) -> (result: i8)
    requires 
        valid_input(n as int)
    ensures 
        result >= 1,
        result as int == max_distributions(n as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0212,verus,apps,apps_test_1020,,"Given a rectangular plate with dimensions w × h cells, calculate the total number of cells
to be gilded when adding k concentric rings. Ring 1 is the border of the full w × h rectangle,
Ring 2 is the border of the inner (w-4) × (h-4) rectangle, and so on. Each ring consists of
all cells on the perimeter of its respective rectangle.","use vstd::prelude::*;

verus! {
spec fn valid_input(w: int, h: int, k: int) -> bool {
    w >= 3 && h >= 3 && w <= 100 && h <= 100 && 
    k >= 1 && k <= ((if w <= h { w } else { h }) + 1) / 4 &&
    w - 4 * k >= 3 && h - 4 * k >= 3
}

spec fn perimeter(w: int, h: int) -> int {
    w * 2 + (h - 2) * 2
}

spec fn compute_sum(w: int, h: int, k: int) -> int
    decreases k when k > 0
{
    if k <= 0 { 0 }
    else { 
        perimeter(w, h) + compute_sum(w - 4, h - 4, k - 1)
    }
}",,"fn gild_cells(w: i8, h: i8, k: i8) -> (result: i8)
    requires valid_input(w as int, h as int, k as int)
    ensures result as int == compute_sum(w as int, h as int, k as int)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0214,verus,apps,apps_test_1028,,"Given n participants split into m teams where each team has at least one participant,
find the minimum and maximum possible number of friendship pairs that can form.
Friendship pairs are formed between all participants within the same team.","use vstd::prelude::*;

verus! {

spec fn comb2(n: int) -> int
  recommends n >= 0
{
  n * (n - 1) / 2
}

spec fn valid_input(n: int, m: int) -> bool
{
  1 <= m <= n
}

spec fn min_friendship_pairs(n: int, m: int) -> int
  recommends valid_input(n, m)
{
  let k = n / m;
  let p = n % m;
  p * comb2(k + 1) + (m - p) * comb2(k)
}

spec fn max_friendship_pairs(n: int, m: int) -> int
  recommends valid_input(n, m)
{
  comb2(n - m + 1)
}",,"fn solve(n: i8, m: i8) -> (result: (i8, i8))
  requires valid_input(n as int, m as int)
  ensures 
      result.0 >= 0 &&
      result.1 >= 0 &&
      result.0 <= result.1 &&
      result.0 == min_friendship_pairs(n as int, m as int) &&
      result.1 == max_friendship_pairs(n as int, m as int)","{
  // impl-start
  assume(false);
  (0, 0)
  // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0216,verus,apps,apps_test_1036,,"Given integers n and k, simulate a Rock-Paper-Scissors tournament among 2^k players.
Each player i has favorite hand from string s at position ((i mod n) + 1).
Tournament uses recursive bracket structure where Rock beats Scissors, 
Paper beats Rock, Scissors beats Paper, and ties go to the first player.
Return the favorite hand of the tournament winner.","use vstd::prelude::*;

verus! {
spec fn winner(a: char, b: char) -> char {
    if (a, b) == ('R', 'P') || (a, b) == ('P', 'S') || (a, b) == ('S', 'R') {
        b
    } else {
        a
    }
}

spec fn valid_rps_char(c: char) -> bool {
    c == 'R' || c == 'P' || c == 'S'
}

spec fn valid_rps_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> valid_rps_char(s[i])
}

spec fn valid_input(n: int, k: int, s: Seq<char>) -> bool {
    n > 0 && k >= 0 && s.len() == n && valid_rps_string(s)
}",,"fn solve(n: i8, k: i8, s: Vec<char>) -> (result: char)
    requires valid_input(n as int, k as int, s@)
    ensures valid_rps_char(result)","{
    assume(false);
    'R'
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0217,verus,apps,apps_test_1038,,"Given two integers A and B, compute f(A, B) which is the exclusive OR (XOR) of all integers 
in the range [A, B] inclusive. The XOR operation combines all bits where the result bit is 1 
if an odd number of input integers have 1 in that bit position, and 0 if an even number do.","use vstd::prelude::*;

verus! {
    spec fn valid_input(a: int, b: int) -> bool {
        0 <= a <= b
    }
    
    spec fn xor_int(x: int, y: int) -> int
        decreases x + y
    {
        if x >= 0 && y >= 0 {
            if x == 0 && y == 0 { 0 }
            else if x == 0 { y }
            else if y == 0 { x }
            else {
                let bit_x = x % 2;
                let bit_y = y % 2;
                let xor_bit: int = if bit_x != bit_y { 1 } else { 0 };
                xor_bit + 2 * xor_int(x / 2, y / 2)
            }
        } else {
            0
        }
    }
    
    spec fn xor_range(a: int, b: int) -> int
        decreases b - a
    {
        if 0 <= a <= b {
            if a == b { a }
            else { xor_int(a, xor_range(a + 1, b)) }
        } else {
            0
        }
    }",,"fn solve(a: i32, b: i32) -> (result: i32)
    requires 
        a >= 0,
        b >= 0,
        a <= b
    ensures 
        result >= 0,
        result as int == xor_range(a as int, b as int)","{
    assume(false);
    unreached()
}","}

fn main() {}",0,,-1,-1,-1,,1.0
VA0219,verus,apps,apps_test_1045,,"Find the maximum height of a pyramid that can be built with n cubes, where
level i requires exactly i*(i+1)/2 cubes. The pyramid is built from top to
bottom with levels 1, 2, 3, ..., h.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int) -> bool {
    n >= 1
}

spec fn cubes_for_level(level: int) -> int
    recommends level >= 1
{
    level * (level + 1) / 2
}

spec fn total_cubes_for_height(h: int) -> int
    recommends h >= 1
{
    h * (h + 1) * (h + 2) / 6
}

spec fn valid_pyramid_height(n: int, h: int) -> bool {
    valid_input(n) && h >= 1 && 
    total_cubes_for_height(h) <= n &&
    total_cubes_for_height(h + 1) > n
}",,"fn solve(n: i8) -> (result: i8)
    requires valid_input(n as int)
    ensures 
        result >= 1 &&
        valid_pyramid_height(n as int, result as int)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0221,verus,apps,apps_test_1048,,"Given a sequence of movement commands for a robot on an infinite grid, find the maximum number of commands 
that could be executed such that the robot returns to its starting position (0, 0). The robot can move 
U (up), D (down), L (left), or R (right). To return to origin, we need equal numbers of L/R movements 
and equal numbers of U/D movements.","use vstd::prelude::*;

verus! {
spec fn count_char(s: Seq<char>, c: char) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0int
    } else {
        (if s[0] == c { 1int } else { 0int }) + count_char(s.subrange(1, s.len() as int), c)
    }
}

spec fn min(a: int, b: int) -> int {
    if a <= b { a } else { b }
}

spec fn valid_commands(commands: Seq<char>) -> bool {
    forall|i: int| 0 <= i < commands.len() ==> commands[i] == 'L' || commands[i] == 'R' || commands[i] == 'U' || commands[i] == 'D'
}",,"fn solve(n: usize, commands: Vec<char>) -> (result: usize)
    requires 
        n >= 0,
        commands@.len() == n,
        valid_commands(commands@)
    ensures 
        result >= 0,
        result <= n,
        result % 2 == 0,
        result as int == 2 * min(count_char(commands@, 'L'), count_char(commands@, 'R')) + 
                         2 * min(count_char(commands@, 'U'), count_char(commands@, 'D'))","{
    assume(false);
    0
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0223,verus,apps,apps_test_1052,,"Count the number of permutations of [1, 2, ..., n] where at least n-k positions
have the correct value (i.e., p[i] = i for at least n-k indices i).","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, k: int) -> bool {
    4 <= n <= 1000 && 1 <= k <= 4 && k < n
}

spec fn factorial(n: int) -> int
    decreases n
{
    if n <= 1 { 1 } else { n * factorial(n - 1) }
}

spec fn derangement(n: int) -> int
    decreases n
{
    if n <= 1 { 0 }
    else if n == 2 { 1 }
    else { (n - 1) * (derangement(n - 1) + derangement(n - 2)) }
}

spec fn binomial(n: int, k: int) -> int {
    if k > n { 0 }
    else if k == 0 || k == n { 1 }
    else { factorial(n) / (factorial(k) * factorial(n - k)) }
}

spec fn sum_binomial_derangement(n: int, k: int, i: int) -> int
    decreases n - k - i
{
    if i >= n - k { 0 }
    else { binomial(n, i) * derangement(n - i) + sum_binomial_derangement(n, k, i + 1) }
}",,"fn solve(n: i8, k: i8) -> (result: i8)
    requires valid_input(n as int, k as int)
    ensures result as int == factorial(n as int) - sum_binomial_derangement(n as int, k as int, 0)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0224,verus,apps,apps_test_1055,,"Given an array of integers, apply the Thanos sort algorithm to find the maximum length 
of a sorted subarray. The algorithm works by: if the array is sorted, stop; otherwise 
choose either the first half or second half and repeat the process.","use vstd::prelude::*;

verus! {

spec fn valid_input(a: Seq<int>) -> bool {
    a.len() > 0
}

spec fn is_sorted(x: Seq<int>) -> bool {
    forall|i: int, j: int| 0 <= i < j < x.len() ==> x[i] <= x[j]
}

spec fn thanos_sort(x: Seq<int>) -> int
    recommends x.len() > 0
    decreases x.len()
{
    let len = x.len() as int;
    if is_sorted(x) {
        len
    } else {
        let first_half = x.subrange(0, len / 2);
        let second_half = x.subrange(len / 2, len);
        let left_result = thanos_sort(first_half);
        let right_result = thanos_sort(second_half);
        if left_result > right_result { left_result } else { right_result }
    }
}",,"fn solve(a: Vec<i8>) -> (result: usize)
    requires 
        valid_input(a@.map(|i, x| x as int)),
    ensures 
        result as int == thanos_sort(a@.map(|i, x| x as int)),
        1 <= result <= a.len(),","{
    assume(false);
    0
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0226,verus,apps,apps_test_1065,,"Given n candies and k people (numbered 1 to k), find the maximum number of candies person 1 can receive.
Person 1 chooses an integer x and distributes candies cyclically: first x candies to person 1, next x to person 2, 
..., next x to person k, then repeat the cycle. Remaining candies are discarded.
Constraints: 1 ≤ x ≤ M, no person can receive candies more than D times.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, k: int, m: int, d: int) -> bool {
    2 <= n && 2 <= k <= n && 1 <= m <= n && 1 <= d <= n && m * d * k >= n
}

spec fn candies_used(x: int, d: int, k: int) -> int {
    x * ((d - 1) * k + 1)
}

spec fn valid_distribution(x: int, d: int, n: int, k: int, m: int, d_max: int) -> bool {
    1 <= x <= m && 1 <= d <= d_max && candies_used(x, d, k) <= n
}

spec fn person1_candies(x: int, d: int) -> int {
    x * d
}",,"fn solve(n: i8, k: i8, m: i8, d: i8) -> (result: i8)
    requires valid_input(n as int, k as int, m as int, d as int)
    ensures
        result >= 0 &&
        result as int <= m as int * d as int &&
        (forall|x: int, d_val: int| valid_distribution(x, d_val, n as int, k as int, m as int, d as int) ==> person1_candies(x, d_val) <= result as int) &&
        (exists|x: int, d_val: int| valid_distribution(x, d_val, n as int, k as int, m as int, d as int) && person1_candies(x, d_val) == result as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0227,verus,apps,apps_test_1069,,"Calculate the value of (1^n + 2^n + 3^n + 4^n) mod 5 for a given integer n.
The input n is given as a string representation of a non-negative integer.
The result is either 4 (when n ≡ 0 mod 4) or 0 (otherwise).","use vstd::prelude::*;

verus! {
spec fn string_to_nat(s: Seq<char>) -> nat
  decreases s.len()
{
  if s.len() == 0 {
    0
  } else if s.len() == 1 {
    (s[0] as int - '0' as int) as nat
  } else {
    string_to_nat(s.subrange(0, s.len() - 1)) * 10 + (s[s.len() - 1] as int - '0' as int) as nat
  }
}

spec fn valid_input(n: Seq<char>) -> bool {
  n.len() > 0 && 
  (forall|i: int| 0 <= i < n.len() ==> '0' <= #[trigger] n[i] <= '9') &&
  (n[0] != '0' || n.len() == 1)
}

spec fn valid_output(result: String) -> bool {
  result@ =~= seq!['4', '\n'] || result@ =~= seq!['0', '\n']
}",,"fn solve(n: String) -> (result: String)
  requires valid_input(n@)
  ensures valid_output(result)","{
  assume(false);
  ""0\n"".to_string()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0228,verus,apps,apps_test_1071,,"Given a cupboard with n shelves, determine if all cups and medals can be placed
following constraints: cups and medals cannot be on the same shelf, each shelf
can hold at most 5 cups, and each shelf can hold at most 10 medals.","use vstd::prelude::*;

verus! {
spec fn valid_input(a: Seq<int>, b: Seq<int>, n: int) -> bool {
    a.len() >= 0 && b.len() >= 0 &&
    (forall|i: int| 0 <= i < a.len() ==> a[i] >= 0) &&
    (forall|j: int| 0 <= j < b.len() ==> b[j] >= 0) &&
    n >= 1
}

spec fn sum_seq(s: Seq<int>) -> int
    recommends forall|i: int| 0 <= i < s.len() ==> s[i] >= 0
    decreases s.len()
{
    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.drop_first()) }
}

spec fn shelves_needed(total: int, capacity: int) -> int
    recommends capacity > 0
{
    if total == 0 { 0 } else { (total - 1) / capacity + 1 }
}

spec fn can_place_all(a: Seq<int>, b: Seq<int>, n: int) -> bool
    recommends valid_input(a, b, n)
{
    let total_cups = sum_seq(a);
    let total_medals = sum_seq(b);
    let shelves_for_cups = shelves_needed(total_cups, 5);
    let shelves_for_medals = shelves_needed(total_medals, 10);
    shelves_for_cups + shelves_for_medals <= n
}",,"fn solve(a: Vec<i8>, b: Vec<i8>, n: i8) -> (result: String)
    requires valid_input(a@.map(|i: int, x: i8| x as int), b@.map(|i: int, x: i8| x as int), n as int)
    ensures result@ == (if can_place_all(a@.map(|i: int, x: i8| x as int), b@.map(|i: int, x: i8| x as int), n as int) { ""YES""@ } else { ""NO""@ })","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0229,verus,apps,apps_test_1074,,"Given an integer a, count the number of times the digit '1' appears in its octal (base-8) representation.
Input: A single integer a where 0 ≤ a ≤ 1,000,000
Output: A single integer representing the count of digit '1' in the octal representation of a","use vstd::prelude::*;

verus! {

spec fn count_ones_in_octal(a: int) -> int
    decreases a when a >= 0
{
    if a == 0 {
        0int
    } else {
        (if a % 8 == 1 { 1int } else { 0int }) + count_ones_in_octal(a / 8)
    }
}",,"fn solve(a: i8) -> (count: i8)
    requires 
        a >= 0,
    ensures 
        count >= 0,
        count as int == count_ones_in_octal(a as int),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0230,verus,apps,apps_test_1081,,"Given an integer a (1 ≤ a ≤ 99), determine whether it satisfies a specific condition
and output ""YES"" or ""NO"". The condition is derived from the pattern in given examples.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int) -> bool {
    1 <= n <= 99
}

spec fn expected_result(n: int) -> bool
    recommends valid_input(n)
{
    if n < 12 {
        if n == 1 || n == 7 || n == 9 || n == 10 || n == 11 {
            false
        } else {
            true
        }
    } else if 12 < n < 30 {
        false
    } else if 69 < n < 80 {
        false
    } else if 89 < n {
        false
    } else {
        let last_digit = n % 10;
        if last_digit != 1 && last_digit != 7 && last_digit != 9 {
            true
        } else {
            false
        }
    }
}",,"fn solve(n: i8) -> (result: bool)
requires 
    valid_input(n as int),
ensures 
    result == expected_result(n as int),","{
    assume(false);
    false
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0232,verus,apps,apps_test_1085,,"Given a positive integer N, find how many values of K (where 2 ≤ K ≤ N) will cause N to become 1
through repeated operations: if K divides N, replace N with N/K; otherwise replace N with N-K;
continue until N < K. Count the number of valid K values.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: nat) -> bool {
    n > 0
}

spec fn reduce_by_divisor(n: nat, d: nat) -> nat {
    if n > 0 && d > 1 && n % d == 0 && n >= d {
        n / d
    } else {
        n
    }
}

spec fn count_divisors(n: int) -> nat {
    if n > 0 {
        Set::new(|d: int| 1 <= d <= n && n % d == 0).len()
    } else {
        0
    }
}

spec fn count_special_divisors(n: nat) -> nat {
    if n > 0 {
        Set::new(|d: int| 2 <= d <= n && (n as int) % d == 0 && ((reduce_by_divisor(n, d as nat) as int) - 1) % d == 0).len()
    } else {
        0
    }
}

spec fn count_valid_k_values(n: nat) -> int {
    if n > 0 {
        if n == 1 {
            -1
        } else {
            count_divisors(n as int - 1) as int + count_special_divisors(n) as int - 1
        }
    } else {
        -1
    }
}",,"fn solve(n: u8) -> (result: i8)
    requires 
        valid_input(n as nat)
    ensures 
        result as int == count_valid_k_values(n as nat),
        n == 1 ==> result as int == -1,
        n > 1 ==> result as int == count_divisors(n as int - 1) as int + count_special_divisors(n as nat) as int - 1,
        result as int >= -1","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0233,verus,apps,apps_test_1096,,"Given a king's position on a standard 8×8 chess board, determine the number of valid moves 
the king can make. The position is given as a two-character string ""cd"" where 'c' is the 
column ('a' to 'h') and 'd' is the row ('1' to '8'). A king can move exactly one square 
in any direction but cannot move outside the board boundaries.","use vstd::prelude::*;

verus! {
spec fn valid_input(position: Seq<char>) -> bool {
  position.len() == 2 && 
  'a' <= position[0] && position[0] <= 'h' && 
  '1' <= position[1] && position[1] <= '8'
}

spec fn is_corner(position: Seq<char>) -> bool
  recommends valid_input(position)
{
  (position[0] == 'a' || position[0] == 'h') && 
  (position[1] == '1' || position[1] == '8')
}

spec fn is_edge(position: Seq<char>) -> bool
  recommends valid_input(position)
{
  (position[0] == 'a' || position[0] == 'h' || 
   position[1] == '1' || position[1] == '8') && 
  !is_corner(position)
}

spec fn is_interior(position: Seq<char>) -> bool
  recommends valid_input(position)
{
  !is_corner(position) && !is_edge(position)
}

spec fn valid_moves(position: Seq<char>) -> int
  recommends valid_input(position)
{
  if is_corner(position) { 3 }
  else if is_edge(position) { 5 }
  else { 8 }
}",,"fn solve(position: Vec<char>) -> (moves: i8)
  requires 
    valid_input(position@),
  ensures 
    moves as int == valid_moves(position@),
    is_corner(position@) ==> moves == 3,
    is_edge(position@) ==> moves == 5,
    is_interior(position@) ==> moves == 8,
    moves == 3 || moves == 5 || moves == 8,","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0234,verus,apps,apps_test_1100,,"Given a regular convex polygon with n vertices, draw rays from each vertex to all others.
Rays stop when hitting vertices or intersecting previously drawn rays, creating regions.
A squirrel starts outside and jumps between adjacent regions to collect all walnuts.
Find the minimum number of jumps needed.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int) -> bool {
    n >= 3
}

spec fn min_jumps(n: int) -> int
    recommends valid_input(n)
{
    (n - 2) * (n - 2)
}",,"fn solve(n: i8) -> (result: i8)
    requires valid_input(n as int)
    ensures result as int == min_jumps(n as int)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0235,verus,apps,apps_test_1101,,"Given n rooms in a row (some occupied, some free) and k cows, find k+1 free rooms to book 
such that when one room is assigned to Farmer John and k rooms to his cows, the maximum 
distance from Farmer John's room to any cow's room is minimized.","use vstd::prelude::*;

verus! {

spec fn is_valid_placement(rooms: Seq<char>, k: int, placement: Seq<int>) -> bool {
    placement.len() == k + 1 &&
    (forall|i: int| 0 <= i < placement.len() ==> 0 <= #[trigger] placement[i] < rooms.len()) &&
    (forall|i: int| 0 <= i < placement.len() ==> #[trigger] rooms[placement[i]] == '0') &&
    (forall|i: int, j: int| 0 <= i < j < placement.len() ==> #[trigger] placement[i] != #[trigger] placement[j]) &&
    (forall|i: int| 0 <= i < placement.len() - 1 ==> #[trigger] placement[i] < placement[i+1])
}

spec fn optimal_max_distance(placement: Seq<int>) -> int {
    if placement.len() == 0 {
        0
    } else {
        placement[0]
    }
}",,"fn solve(n: usize, k: usize, rooms: Vec<char>) -> (result: usize)
    requires 
        n > 0 &&
        k > 0 &&
        k < n &&
        rooms@.len() == n &&
        (forall|i: int| 0 <= i < n ==> #[trigger] rooms@[i] == '0' || #[trigger] rooms@[i] == '1') &&
        Set::new(|i: int| 0 <= i < n && rooms@[i] == '0').len() >= k + 1
    ensures 
        result >= 0","{
    assume(false);
    0
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0236,verus,apps,apps_test_1102,,"Given n cities in a row, Limak lives in city a and uses a Bear Criminal Detector (BCD) 
that reports total criminals at each distance. He can only catch criminals where he can 
definitively determine their presence: at distance d with 1 city and 1 criminal reported, 
or at distance d with 2 cities and 2 criminals reported. Return total criminals caught.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, a: int, x: Seq<int>) -> bool {
    n > 0 && 1 <= a <= n && x.len() == n && 
    forall|i: int| 0 <= i < n ==> (x[i] == 0 || x[i] == 1)
}

spec fn sum_criminals_caught(n: int, a_idx: int, x: Seq<int>, distance: int) -> int
    decreases n + 1 - distance
{
    if distance > n { 
        0
    } else {
        let le = a_idx - distance;
        let rg = a_idx + distance;
        let le_valid = le >= 0 && le < n;
        let rg_valid = rg >= 0 && rg < n;
        let current_caught = if !le_valid && !rg_valid {
            0
        } else if le_valid && !rg_valid {
            x[le]
        } else if !le_valid && rg_valid {
            x[rg]
        } else if le_valid && rg_valid && x[le] == 1 && x[rg] == 1 {
            2
        } else {
            0
        };
        if !le_valid && !rg_valid {
            current_caught
        } else {
            current_caught + sum_criminals_caught(n, a_idx, x, distance + 1)
        }
    }
}

spec fn total_criminals_caught(n: int, a: int, x: Seq<int>) -> int {
    x[a-1] + sum_criminals_caught(n, a-1, x, 1)
}",,"fn solve(n: i8, a: i8, x: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, a as int, Seq::new(x.len() as nat, |i: int| x[i] as int))
    ensures 
        result >= 0 &&
        result as int == total_criminals_caught(n as int, a as int, Seq::new(x.len() as nat, |i: int| x[i] as int))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0237,verus,apps,apps_test_1106,,"Given a complete binary tree of depth n, find the minimum number of additional
street lights needed so that all paths from entrance (node 1) to exits have
the same total number of lights.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, lights: Seq<int>) -> bool {
    1 <= n <= 10 &&
    lights.len() == power2(n+1) - 2 &&
    forall|i: int| 0 <= i < lights.len() ==> #[trigger] lights[i] >= 1 && #[trigger] lights[i] <= 100
}

spec fn power2(n: int) -> int
    decreases n
{
    if n <= 0 { 1 }
    else { 2 * power2(n - 1) }
}

spec fn dfs_result(i: int, n: int, a: Seq<int>) -> (int, int) {
    /* Placeholder implementation for complex recursive specification */
    (0, 0)
}",,"fn solve(n: i8, lights: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, lights@.map(|_i: int, x: i8| x as int))
    ensures result >= 0","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0238,verus,apps,apps_test_1109,,"Given an array of length n containing only 1s and 2s, find the minimum number of elements
to change to make the array k-periodic. An array is k-periodic if it can be represented 
as a pattern of length k repeated exactly n/k times consecutively. The constraint is that 
n is divisible by k.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, k: int, a: Seq<int>) -> bool {
    1 <= k <= n <= 100 &&
    n % k == 0 &&
    a.len() == n &&
    forall|i: int| 0 <= i < a.len() ==> a[i] == 1 || a[i] == 2
}

spec fn count_ones_in_column(a: Seq<int>, n: int, k: int, col: int) -> int {
    Set::new(|j: int| 0 <= j < n && j % k == col && a[j] == 1).len() as int
}

spec fn count_twos_in_column(a: Seq<int>, n: int, k: int, col: int) -> int {
    Set::new(|j: int| 0 <= j < n && j % k == col && a[j] == 2).len() as int
}

spec fn min_changes_for_column(a: Seq<int>, n: int, k: int, col: int) -> int {
    let count1 = count_ones_in_column(a, n, k, col);
    let count2 = count_twos_in_column(a, n, k, col);
    if count1 < count2 { count1 } else { count2 }
}

spec fn sum_min_changes_helper(a: Seq<int>, n: int, k: int, col: int) -> int
    decreases k - col when col <= k
{
    if col >= k {
        0
    } else {
        min_changes_for_column(a, n, k, col) + sum_min_changes_helper(a, n, k, col + 1)
    }
}

spec fn sum_min_changes_for_all_columns(a: Seq<int>, n: int, k: int) -> int {
    sum_min_changes_helper(a, n, k, 0)
}",,"fn solve(n: i8, k: i8, a: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, k as int, a@.map(|i, v| v as int))
    ensures 
        0 <= result as int <= n as int,
        result as int == sum_min_changes_for_all_columns(a@.map(|i, v| v as int), n as int, k as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0239,verus,apps,apps_test_1110,,"Find the worst-case number of button presses needed to open a lock with n buttons.
The lock has a specific unknown sequence. When a button is pressed:
- If it's the next correct button, it stays pressed
- If it's incorrect, all pressed buttons reset
- The lock opens when all n buttons are pressed simultaneously (sequence complete)","use vstd::prelude::*;

verus! {
    spec fn valid_input(n: int) -> bool {
        n >= 1
    }
    
    spec fn worst_case_presses(n: int) -> int
        recommends valid_input(n)
    {
        n * (n * n + 5) / 6
    }",,"fn solve(n: i8) -> (result: i8)
    requires valid_input(n as int)
    ensures result as int == worst_case_presses(n as int) && result as int >= 1","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0240,verus,apps,apps_test_1116,,"Given three integers r, b, and k, determine if it's possible to paint planks on a fence
according to specific rules without creating k consecutive planks of the same color.
Paint plank i red if i is divisible by r, blue if divisible by b, either color if 
divisible by both, and don't paint otherwise. Return ""OBEY"" if possible to avoid
k consecutive same-color planks, ""REBEL"" if unavoidable.","use vstd::prelude::*;

verus! {
spec fn gcd(a: int, b: int) -> int
  decreases b when a > 0 && b >= 0
{
  if b == 0 { a } else { gcd(b, a % b) }
}

spec fn valid_input(r: int, b: int, k: int) -> bool {
  r > 0 && b > 0 && k > 0
}

spec fn max_consecutive_same_color(r: int, b: int) -> int {
  let a = if r <= b { r } else { b };
  let b_val = if r <= b { b } else { r };
  let n = gcd(a, b_val);
  -((n - b_val) / a)
}

spec fn can_avoid_consecutive(r: int, b: int, k: int) -> bool {
  valid_input(r, b, k) && max_consecutive_same_color(r, b) < k
}",,"fn solve(r: i8, b: i8, k: i8) -> (result: String)
  requires valid_input(r as int, b as int, k as int)
  ensures result@ == (if can_avoid_consecutive(r as int, b as int, k as int) { ""OBEY""@ } else { ""REBEL""@ })","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0241,verus,apps,apps_test_1117,,"Given n rectangles in a fixed order, each rectangle can be rotated 90 degrees (swapping its width and height). 
Determine if it's possible to rotate some rectangles such that the final heights form a non-ascending sequence 
(each height ≤ previous height).","use vstd::prelude::*;

verus! {

spec fn can_form_non_ascending_sequence(rectangles: Seq<(int, int)>) -> bool {
    if rectangles.len() <= 1 {
        true
    } else {
        can_form_non_ascending_sequence_helper(rectangles, 1, max_spec(rectangles[0].0, rectangles[0].1))
    }
}

spec fn can_form_non_ascending_sequence_helper(rectangles: Seq<(int, int)>, index: int, prev_height: int) -> bool
    recommends 0 <= index <= rectangles.len()
    decreases rectangles.len() - index
{
    if index >= rectangles.len() {
        true
    } else {
        let a = rectangles[index].0;
        let b = rectangles[index].1;
        let min_dim = min_spec(a, b);
        let max_dim = max_spec(a, b);

        if min_dim > prev_height {
            false
        } else if min_dim <= prev_height < max_dim {
            can_form_non_ascending_sequence_helper(rectangles, index + 1, min_dim)
        } else {
            can_form_non_ascending_sequence_helper(rectangles, index + 1, max_dim)
        }
    }
}

spec fn parse_rectangles(input: Seq<char>) -> Seq<(int, int)> {
    /* Placeholder for parsing logic */
    seq![]
}

spec fn min_spec(a: int, b: int) -> int {
    if a <= b { a } else { b }
}

spec fn max_spec(a: int, b: int) -> int {
    if a >= b { a } else { b }
}",,"fn solve(input: &str) -> (result: String)
    requires input@.len() > 0
    ensures result@ == ""YES""@ || result@ == ""NO""@
    /* ensures result@ == ""YES""@ <==> can_form_non_ascending_sequence(parse_rectangles(input@)) */","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0242,verus,apps,apps_test_1124,,"Given N positive integers, repeatedly perform the operation: find maximum X and minimum x,
if X != x then replace all X with (X - x), until all integers are equal.
Return the final common value.","use vstd::prelude::*;

verus! {
spec fn valid_input(values: Seq<int>) -> bool {
    values.len() >= 1 && forall|i: int| 0 <= i < values.len() ==> values[i] > 0
}

spec fn gcd(a: int, b: int) -> int
    decreases (if a >= b { a } else { b }) when a > 0 && b > 0
{
    if a > 0 && b > 0 {
        if a == b {
            a
        } else if a > b {
            gcd(a - b, b)
        } else {
            gcd(a, b - a)
        }
    } else {
        1
    }
}

spec fn gcd_seq(values: Seq<int>, index: int, current: int) -> int
    decreases values.len() - index when 0 <= index <= values.len() && current > 0 && forall|i: int| 0 <= i < values.len() ==> values[i] > 0
{
    if 0 <= index <= values.len() && current > 0 && forall|i: int| 0 <= i < values.len() ==> values[i] > 0 {
        if index == values.len() {
            current
        } else {
            gcd_seq(values, index + 1, gcd(current, values[index as int]))
        }
    } else {
        1
    }
}

spec fn gcd_of_all(values: Seq<int>) -> int {
    if values.len() >= 1 && forall|i: int| 0 <= i < values.len() ==> values[i] > 0 {
        gcd_seq(values, 1, values[0])
    } else {
        1
    }
}","spec fn values_as_int(values: Seq<i8>) -> Seq<int> {
    values.map(|i, x| x as int)
}
","fn solve(values: Vec<i8>) -> (result: i8)
    requires valid_input(values_as_int(values@)) && values.len() <= 127
    ensures 
        result > 0 &&
        result as int == gcd_of_all(values_as_int(values@)) &&
        forall|i: int| 0 <= i < values@.len() ==> (values@[i] as int) % (result as int) == 0","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0244,verus,apps,apps_test_1134,,"Given n consecutive days of river observations where on day i there are m_i marks 
strictly above the current water level, find the minimum possible sum of d_i over 
all n days, where d_i is the number of marks strictly below the water level on day i.
Each day a mark is made at the current water level, marks never wash away, and the
total number of marks can only stay the same or increase each day.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, m: Seq<int>) -> bool {
    n > 0 && m.len() == n && 
    forall|i: int| 0 <= i < n ==> 0 <= #[trigger] m[i] < i + 1
}

spec fn valid_solution(n: int, m: Seq<int>, dm: Seq<int>) -> bool {
    dm.len() == n && m.len() == n &&
    (forall|i: int| 0 <= i < n ==> #[trigger] dm[i] >= #[trigger] m[i] + 1) &&
    (forall|i: int| 0 <= i < n - 1 ==> #[trigger] dm[i] <= dm[i + 1])
}

spec fn sum_below(m: Seq<int>, dm: Seq<int>) -> int
    decreases m.len()
{
    if m.len() == 0 {
        0
    } else {
        (dm[0] - 1 - m[0]) + sum_below(m.subrange(1, m.len() as int), dm.subrange(1, dm.len() as int))
    }
}",,"fn solve(n: i8, m: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, m@.map(|_i, v: i8| v as int))
    ensures result >= 0","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0245,verus,apps,apps_test_1135,,"Decode a string that was encoded by repeatedly extracting median characters.
The decoding process inserts each character from the encoded string back into
its proper median position in the reconstructed word.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, s: Seq<char>) -> bool {
    n >= 1 && n <= 2000 && s.len() == n && 
    forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= 'a' && #[trigger] s[i] <= 'z'
}

spec fn valid_output(result: Seq<char>, n: int) -> bool {
    result.len() == n && 
    forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i] >= 'a' && #[trigger] result[i] <= 'z'
}

spec fn preserves_characters(s: Seq<char>, result: Seq<char>) -> bool {
    s.to_multiset() == result.to_multiset()
}",,"fn solve(n: i8, s: Vec<char>) -> (result: Vec<char>)
    requires 
        valid_input(n as int, s@)
    ensures 
        valid_output(result@, n as int),
        preserves_characters(s@, result@)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0246,verus,apps,apps_test_1138,,"Given a string of movement directions ('L', 'R', 'U', 'D'), determine the minimum number 
of character changes needed so that following the directions returns to the starting position.
Return -1 if impossible (when string length is odd).","use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> s[i] == 'L' || s[i] == 'R' || s[i] == 'U' || s[i] == 'D'
}

spec fn abs(x: int) -> int {
    if x >= 0 { x } else { -x }
}

spec fn count_char(s: Seq<char>, c: char) -> int
    decreases s.len()
{
    count_char_helper(s, c, 0, 0)
}

spec fn count_char_helper(s: Seq<char>, c: char, index: int, count: int) -> int
    decreases s.len() - index
{
    if index >= s.len() {
        count
    } else if s.index(index) == c {
        count_char_helper(s, c, index + 1, count + 1)
    } else {
        count_char_helper(s, c, index + 1, count)
    }
}

spec fn count_char_from_index(s: Seq<char>, c: char, index: int) -> int
    decreases s.len() - index
{
    if index >= s.len() {
        0
    } else if s.index(index) == c {
        1 + count_char_from_index(s, c, index + 1)
    } else {
        count_char_from_index(s, c, index + 1)
    }
}

spec fn correct_result(s: Seq<char>, result: int) -> bool {
    (s.len() % 2 != 0 ==> result == -1) &&
    (s.len() % 2 == 0 ==> result >= 0) &&
    (s.len() % 2 == 0 ==> result <= s.len() / 2) &&
    (s.len() % 2 == 0 ==> result == (abs(count_char(s, 'L') - count_char(s, 'R')) + abs(count_char(s, 'U') - count_char(s, 'D'))) / 2)
}",,"fn solve(s: Vec<char>) -> (result: i8)
    requires valid_input(s@)
    ensures correct_result(s@, result as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0247,verus,apps,apps_test_1142,,"Given a gun with magazine size k and n waves of monsters, find the minimum total bullets
needed to clear all waves. Each wave i has monsters that spawn at time l_i and must be
killed by time r_i. Shooting kills one monster instantly, reloading takes 1 time unit
and discards remaining bullets. Waves are non-overlapping and chronological.
Return -1 if impossible.","use vstd::prelude::*;

verus! {
#[derive(PartialEq, Eq)]
struct Wave {
    start_time: nat,
    end_time: nat,
    monsters: nat,
}

spec fn valid_waves(waves: Seq<Wave>) -> bool {
    forall|i: int| 0 <= i < waves.len() ==> 
        #[trigger] waves[i].start_time <= waves[i].end_time &&
        waves[i].monsters > 0 &&
        (i > 0 ==> waves[i-1].end_time <= waves[i].start_time)
}

spec fn can_solve_all_waves(waves: Seq<Wave>, k: nat) -> bool {
    k > 0 && 
    forall|i: int| 0 <= i < waves.len() ==> 
        #[trigger] can_solve_wave(waves, i as nat, k)
}

spec fn can_solve_wave(waves: Seq<Wave>, wave_index: nat, k: nat) -> bool {
    &&& wave_index < waves.len()
    &&& k > 0
    &&& {
        let wave = waves[wave_index as int];
        let time_available = wave.end_time - wave.start_time + 1;
        let max_possible_shots = time_available * k;
        wave.monsters <= max_possible_shots &&
        (wave_index == 0 || can_reach_wave_in_time(waves, wave_index, k))
    }
}

spec fn can_reach_wave_in_time(waves: Seq<Wave>, wave_index: nat, k: nat) -> bool {
    &&& wave_index > 0 && wave_index < waves.len()
    &&& k > 0
    &&& {
        let prev_wave = waves[wave_index as int - 1];
        let curr_wave = waves[wave_index as int];
        let time_gap = curr_wave.start_time - prev_wave.end_time;
        let reloads_needed = calculate_reloads_needed(prev_wave.monsters, k);
        reloads_needed <= time_gap
    }
}

spec fn calculate_reloads_needed(monsters: nat, k: nat) -> nat {
    if k > 0 {
        if monsters <= k { 
            0 
        } else { 
            ((monsters - 1) as int / k as int) as nat
        }
    } else {
        0
    }
}

spec fn calculate_minimum_bullets(waves: Seq<Wave>, k: nat) -> nat {
    if k > 0 && valid_waves(waves) && can_solve_all_waves(waves, k) {
        calculate_minimum_bullets_helper(waves, k, 0, k)
    } else {
        0
    }
}

spec fn calculate_minimum_bullets_helper(waves: Seq<Wave>, k: nat, wave_index: nat, current_bullets: nat) -> nat
    decreases waves.len() - wave_index
{
    if wave_index >= waves.len() {
        0
    } else {
        let wave = waves[wave_index as int];
        if current_bullets >= wave.monsters {
            wave.monsters + calculate_minimum_bullets_helper(waves, k, wave_index + 1, k)
        } else {
            let reloads_needed = (((wave.monsters - 1) as int / k as int) + 1) as nat;
            reloads_needed * k + calculate_minimum_bullets_helper(waves, k, wave_index + 1, k)
        }
    }
}",,"fn solve_monster_waves(waves: Vec<Wave>, k: u8) -> (result: i32)
    requires 
        valid_waves(waves@),
        k > 0,
    ensures 
        result == -1 <==> !can_solve_all_waves(waves@, k as nat),
        result >= 0 <==> can_solve_all_waves(waves@, k as nat),
        can_solve_all_waves(waves@, k as nat) ==> result == calculate_minimum_bullets(waves@, k as nat) as i32,","{
    // impl-start
    assume(false);
    -1
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0248,verus,apps,apps_test_1146,,"Given n buttons and m bulbs, where each button can turn on a specific subset of bulbs,
determine if it's possible to turn on all m bulbs by pressing some combination of buttons.
Return ""YES"" if all bulbs can be turned on, ""NO"" otherwise.","use vstd::prelude::*;
use vstd::string::*;

verus! {
spec fn valid_input(n: nat, m: nat, buttons: Seq<Seq<nat>>) -> bool {
    buttons.len() == n &&
    n >= 1 && m >= 1 &&
    forall|i: int| 0 <= i < n ==> 
        #[trigger] buttons[i].len() >= 0 &&
        forall|j: int| 0 <= j < buttons[i].len() ==> 1 <= #[trigger] buttons[i][j] <= m
}

spec fn union_of_all_bulbs(buttons: Seq<Seq<nat>>) -> Set<nat> {
    Set::new(|bulb: nat| 
        exists|i: int, j: int| 
            0 <= i < buttons.len() && 
            0 <= j < buttons[i].len() && 
            #[trigger] buttons[i][j] == bulb
    )
}

spec fn can_turn_on_all_bulbs(m: nat, buttons: Seq<Seq<nat>>) -> bool {
    union_of_all_bulbs(buttons).finite() && union_of_all_bulbs(buttons).len() == m
}",,"fn solve(n: u8, m: u8, buttons: Vec<Vec<u8>>) -> (result: String)
    requires
        valid_input(n as nat, m as nat, buttons@.map(|i: int, button: Vec<u8>| button@.map(|j: int, bulb: u8| bulb as nat))),
    ensures
        result@ == seq!['Y', 'E', 'S'] || result@ == seq!['N', 'O'],
        (result@ == seq!['Y', 'E', 'S']) <==> can_turn_on_all_bulbs(m as nat, buttons@.map(|i: int, button: Vec<u8>| button@.map(|j: int, bulb: u8| bulb as nat)))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0249,verus,apps,apps_test_1149,,"Given n levels in a game, determine if two players can together pass all levels.
Player X can pass a specific set of levels, and Player Y can pass a specific set of levels.
Check if the union of their passable levels covers all levels from 1 to n.
Output ""I become the guy."" if they can pass all levels together, otherwise ""Oh, my keyboard!"".","use vstd::prelude::*;

verus! {

spec fn valid_input(stdin_input: Seq<char>) -> bool {
    let lines = split_lines(stdin_input);
    lines.len() >= 3 && {
        let n = parse_int(lines[0]);
        let x_line = parse_int_list(lines[1]);
        let y_line = parse_int_list(lines[2]);
        n >= 1 && x_line.len() > 0 && y_line.len() > 0 &&
        x_line[0] >= 0 && y_line[0] >= 0 &&
        x_line.len() >= (1 + x_line[0]) as nat && y_line.len() >= (1 + y_line[0]) as nat
    }
}

spec fn get_expected_output(stdin_input: Seq<char>) -> Seq<char>
    recommends valid_input(stdin_input)
{
    let lines = split_lines(stdin_input);
    let n = parse_int(lines[0]);
    let x_line = parse_int_list(lines[1]);
    let y_line = parse_int_list(lines[2]);
    let x_levels = set_from_seq(x_line.subrange(1, 1 + x_line[0] as int));
    let y_levels = set_from_seq(y_line.subrange(1, 1 + y_line[0] as int));
    let all_levels = x_levels.union(y_levels);
    let required_levels = Set::new(|i: int| 1 <= i <= n);
    if required_levels.subset_of(all_levels) { 
        Seq::new(17, |i: int| if i == 0 { 'I' } else if i == 1 { ' ' } else if i == 2 { 'b' } else if i == 3 { 'e' } else if i == 4 { 'c' } else if i == 5 { 'o' } else if i == 6 { 'm' } else if i == 7 { 'e' } else if i == 8 { ' ' } else if i == 9 { 't' } else if i == 10 { 'h' } else if i == 11 { 'e' } else if i == 12 { ' ' } else if i == 13 { 'g' } else if i == 14 { 'u' } else if i == 15 { 'y' } else { '.' })
    } else { 
        Seq::new(16, |i: int| if i == 0 { 'O' } else if i == 1 { 'h' } else if i == 2 { ',' } else if i == 3 { ' ' } else if i == 4 { 'm' } else if i == 5 { 'y' } else if i == 6 { ' ' } else if i == 7 { 'k' } else if i == 8 { 'e' } else if i == 9 { 'y' } else if i == 10 { 'b' } else if i == 11 { 'o' } else if i == 12 { 'a' } else if i == 13 { 'r' } else if i == 14 { 'd' } else { '!' })
    }
}

spec fn set_from_seq(s: Seq<int>) -> Set<int> {
    Set::new(|x: int| s.contains(x))
}

spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>>
    decreases s.len()
{
    if s.len() == 0 {
        Seq::new(0 as nat, |j: int| Seq::new(0 as nat, |k: int| ' '))
    } else {
        let newline_pos = find_char(s, '\n');
        if newline_pos == -1 {
            Seq::new(1 as nat, |j: int| trim(s))
        } else if 0 <= newline_pos < s.len() {
            Seq::new(1 as nat, |j: int| trim(s.subrange(0, newline_pos))).add(split_lines(s.subrange(newline_pos+1, s.len() as int)))
        } else {
            Seq::new(1 as nat, |j: int| trim(s))
        }
    }
}

spec fn trim(s: Seq<char>) -> Seq<char> {
    if s.len() == 0 {
        s
    } else if s[s.len() as int - 1] == '\r' {
        s.subrange(0, s.len() as int - 1)
    } else {
        s
    }
}

spec fn find_char(s: Seq<char>, c: char) -> int
    decreases s.len()
{
    if s.len() == 0 {
        -1
    } else if s[0] == c {
        0
    } else {
        let rest = find_char(s.subrange(1, s.len() as int), c);
        if rest == -1 { -1 } else { rest + 1 }
    }
}

spec fn parse_int(s: Seq<char>) -> int {
    if s.len() == 0 {
        0
    } else if s[0] == '-' {
        if is_valid_digits(s.subrange(1, s.len() as int)) { 
            -parse_int_helper(s.subrange(1, s.len() as int)) 
        } else { 
            0 
        }
    } else if is_valid_digits(s) { 
        parse_int_helper(s) 
    } else { 
        0 
    }
}

spec fn is_valid_digits(s: Seq<char>) -> bool {
    forall|i: int| #![trigger s[i]] 0 <= i < s.len() ==> ('0' <= s[i] <= '9')
}

spec fn parse_int_helper(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if s.len() == 1 {
        char_to_digit(s[0])
    } else {
        parse_int_helper(s.subrange(0, s.len() as int - 1)) * 10 + char_to_digit(s[s.len() as int - 1])
    }
}

spec fn char_to_digit(c: char) -> int {
    (c as u32 as int) - ('0' as u32 as int)
}

spec fn parse_int_list(s: Seq<char>) -> Seq<int> {
    let parts = split_by_char(s, ' ');
    Seq::new(parts.len(), |i: int| parse_int(parts[i]))
}

spec fn split_by_char(s: Seq<char>, delimiter: char) -> Seq<Seq<char>>
    decreases s.len()
{
    if s.len() == 0 {
        Seq::new(0 as nat, |j: int| Seq::new(0 as nat, |k: int| ' '))
    } else {
        let delim_pos = find_char(s, delimiter);
        if delim_pos == -1 {
            Seq::new(1 as nat, |j: int| s)
        } else if delim_pos == 0 {
            split_by_char(s.subrange(1, s.len() as int), delimiter)
        } else if 0 < delim_pos < s.len() {
            Seq::new(1 as nat, |j: int| s.subrange(0, delim_pos)).add(split_by_char(s.subrange(delim_pos+1, s.len() as int), delimiter))
        } else {
            Seq::new(1 as nat, |j: int| s)
        }
    }
}",,"fn solve(stdin_input: Vec<u8>) -> (result: Vec<u8>)
    requires valid_input(stdin_input@.map(|i, c| c as char))
    ensures result@.map(|i, c| c as char) == get_expected_output(stdin_input@.map(|i, c| c as char))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0250,verus,apps,apps_test_1150,,"Given n regiments, each with 4 moles. Each mole has current position (x,y) and home position (a,b).
A move rotates a mole's current position 90° counter-clockwise around its home position.
A regiment is compact if its 4 moles form a square with non-zero area.
Find minimum moves needed to make each regiment compact, or -1 if impossible.

/* Simplified square check - just check if points form any valid square */

/* Check if we have 4 equal sides and 2 equal diagonals */

/* Simplified - just check if total moves is reasonable */","use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 && input[input.len() - 1] == '\n'
}

spec fn valid_output(output: Seq<char>) -> bool {
    output.len() > 0 && output[output.len() - 1] == '\n'
}

spec fn valid_mole(mole: (int, int, int, int)) -> bool {
    let (x, y, a, b) = mole;
    -10000 <= x <= 10000 && -10000 <= y <= 10000 &&
    -10000 <= a <= 10000 && -10000 <= b <= 10000
}

spec fn valid_regiment(moles: Seq<(int, int, int, int)>) -> bool {
    moles.len() == 4 && forall|i: int| 0 <= i < 4 ==> #[trigger] valid_mole(moles[i])
}

spec fn rotate_point(x: int, y: int, center_x: int, center_y: int, times: nat) -> (int, int) {
    let dx = x - center_x;
    let dy = y - center_y;
    let rotations = times % 4;
    if rotations == 0 {
        (x, y)
    } else if rotations == 1 {
        (center_x - dy, center_y + dx)
    } else if rotations == 2 {
        (center_x - dx, center_y - dy)
    } else {
        (center_x + dy, center_y - dx)
    }
}

spec fn distance_squared(p1: (int, int), p2: (int, int)) -> nat {
    let (x1, y1) = p1;
    let (x2, y2) = p2;
    let dx = x1 - x2;
    let dy = y1 - y2;
    let dx_abs: nat = if dx >= 0 { dx as nat } else { (-dx) as nat };
    let dy_abs: nat = if dy >= 0 { dy as nat } else { (-dy) as nat };
    dx_abs * dx_abs + dy_abs * dy_abs
}

spec fn is_square(points: Seq<(int, int)>) -> bool
    recommends points.len() == 4
{
    if points.len() != 4 {
        false
    } else {
        let p0 = points[0];
        let p1 = points[1];
        let p2 = points[2];
        let p3 = points[3];
        let d01 = distance_squared(p0, p1);
        let d02 = distance_squared(p0, p2);
        let d03 = distance_squared(p0, p3);
        let d12 = distance_squared(p1, p2);
        let d13 = distance_squared(p1, p3);
        let d23 = distance_squared(p2, p3);
        
        d01 > 0 && (
            (d01 == d02 && d13 == d23 && d03 == d12 && d03 == 2 * d01) ||
            (d01 == d03 && d12 == d23 && d02 == d13 && d02 == 2 * d01) ||
            (d01 == d12 && d03 == d23 && d02 == d13 && d02 == 2 * d01) ||
            (d01 == d13 && d02 == d23 && d03 == d12 && d03 == 2 * d01) ||
            (d01 == d23 && d02 == d13 && d03 == d12 && d03 == 2 * d01)
        )
    }
}

spec fn can_form_square_with_moves(moles: Seq<(int, int, int, int)>, total_moves: nat) -> bool
    recommends valid_regiment(moles)
{
    total_moves <= 12
}

spec fn get_positions_after_moves(moles: Seq<(int, int, int, int)>, moves0: nat, moves1: nat, moves2: nat, moves3: nat) -> Seq<(int, int)>
    recommends moles.len() == 4
{
    if moles.len() != 4 {
        seq![]
    } else {
        let (x0, y0, a0, b0) = moles[0];
        let (x1, y1, a1, b1) = moles[1];
        let (x2, y2, a2, b2) = moles[2];
        let (x3, y3, a3, b3) = moles[3];
        seq![
            rotate_point(x0, y0, a0, b0, moves0),
            rotate_point(x1, y1, a1, b1, moves1),
            rotate_point(x2, y2, a2, b2, moves2),
            rotate_point(x3, y3, a3, b3, moves3)
        ]
    }
}

spec fn is_all_digits(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9'
}

spec fn string_to_nat(s: Seq<char>) -> nat
    recommends is_all_digits(s) && s.len() > 0
    decreases s.len()
{
    if s.len() == 0 || !is_all_digits(s) {
        0
    } else if s.len() == 1 {
        ((s[0] as int) - ('0' as int)) as nat
    } else {
        string_to_nat(s.subrange(0, s.len() - 1)) * 10 + (((s[s.len() - 1] as int) - ('0' as int)) as nat)
    }
}

spec fn nat_to_string(n: nat) -> Seq<char>
    recommends n <= 12
{
    if n == 0 { seq!['0'] }
    else if n == 1 { seq!['1'] }
    else if n == 2 { seq!['2'] }
    else if n == 3 { seq!['3'] }
    else if n == 4 { seq!['4'] }
    else if n == 5 { seq!['5'] }
    else if n == 6 { seq!['6'] }
    else if n == 7 { seq!['7'] }
    else if n == 8 { seq!['8'] }
    else if n == 9 { seq!['9'] }
    else if n == 10 { seq!['1', '0'] }
    else if n == 11 { seq!['1', '1'] }
    else { seq!['1', '2'] }
}",,"fn solve(stdin_input: &str) -> (output: String)
    requires valid_input(stdin_input@)
    ensures valid_output(output@)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0251,verus,apps,apps_test_1165,,"Given an array of n integers and m queries, for each query find any position 
within a specified range where the array value differs from a given target value.
Output the position (1-indexed) or -1 if no such position exists.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, m: int, a: Seq<int>, queries: Seq<(int, int, int)>) -> bool {
    n > 0 && m >= 0 && a.len() == n && queries.len() == m &&
    forall|q| queries.contains(q) ==> 1 <= q.0 <= q.1 <= n
}

spec fn valid_result(a: Seq<int>, queries: Seq<(int, int, int)>, result: Seq<int>) -> bool {
    result.len() == queries.len() &&
    forall|i: int| 0 <= i < queries.len() ==> {
        let l = queries[i].0;
        let r = queries[i].1;
        let x = queries[i].2;
        (result[i] == -1 ==> (forall|j: int| l <= j <= r ==> 0 <= j-1 < a.len() && #[trigger] a[j-1] == x)) &&
        (result[i] != -1 ==> l <= result[i] <= r && 0 <= result[i]-1 < a.len() && #[trigger] a[result[i]-1] != x)
    }
}",,"fn solve(n: i8, m: i8, a: Vec<i8>, queries: Vec<(i8, i8, i8)>) -> (result: Vec<i8>)
    requires valid_input(n as int, m as int, a@.map(|i: int, x: i8| x as int), queries@.map(|i: int, q: (i8, i8, i8)| (q.0 as int, q.1 as int, q.2 as int)))
    ensures valid_result(a@.map(|i: int, x: i8| x as int), queries@.map(|i: int, q: (i8, i8, i8)| (q.0 as int, q.1 as int, q.2 as int)), result@.map(|i: int, x: i8| x as int))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0252,verus,apps,apps_test_1176,,"Given N integers in a row, find the maximum possible sum after performing operations
where each operation chooses an index i and multiplies both A[i] and A[i+1] by -1.","use vstd::prelude::*;

verus! {
spec fn sum_seq(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.subrange(1, s.len() as int)) }
}

spec fn min_seq(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 { 
        0
    } else if s.len() == 1 { 
        s[0] 
    } else { 
        let rest_min = min_seq(s.subrange(1, s.len() as int));
        if s[0] <= rest_min { s[0] } else { rest_min }
    }
}",,"fn solve(a: Vec<i8>) -> (result: i8)
    requires a@.len() >= 2
    ensures ({
        let count_neg = Set::new(|i: int| 0 <= i < a@.len() && a@[i] < 0).len();
        let sum_abs = sum_seq(Seq::new(a@.len(), |i: int| if a@[i] < 0 { -a@[i] as int } else { a@[i] as int }));
        let min_abs = min_seq(Seq::new(a@.len(), |i: int| if a@[i] < 0 { -a@[i] as int } else { a@[i] as int }));
        result as int == if count_neg % 2 == 0 { sum_abs } else { sum_abs - 2 * min_abs }
    })","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0253,verus,apps,apps_test_1177,,"Given a sequence of N integers and a positive integer S, calculate the sum of f(L,R) 
over all pairs (L,R) where 1 ≤ L ≤ R ≤ N. For each pair (L,R), f(L,R) is the number 
of increasing subsequences with sum equal to S within the range [L,R].","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, s: int, a: Seq<int>) -> bool {
    n >= 1 && s >= 1 && a.len() == n && n <= 3000 && s <= 3000 &&
    forall|i: int| 0 <= i < n ==> a[i] >= 1 && a[i] <= 3000
}

spec fn valid_result(result: int) -> bool {
    result >= 0 && result < 998244353
}

spec fn all_elements_greater_than_s(a: Seq<int>, s: int) -> bool {
    forall|i: int| 0 <= i < a.len() ==> a[i] > s
}

spec fn single_element_case(n: int, s: int, a: Seq<int>) -> int
    decreases n
{
    if n == 1 && a.len() == 1 {
        if s == a[0] { 1 } else { 0 }
    } else {
        0
    }
}",,"fn solve(n: i8, s: i8, a: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, s as int, a@.map(|i: int, x: i8| x as int)),
    ensures 
        valid_result(result as int),
        (result as int) % 998244353 == (result as int),
        (n as int == 1 && s as int == a@.map(|i: int, x: i8| x as int)[0]) ==> (result as int) == single_element_case(n as int, s as int, a@.map(|i: int, x: i8| x as int)),
        (n as int == 1 && s as int != a@.map(|i: int, x: i8| x as int)[0]) ==> (result as int) == single_element_case(n as int, s as int, a@.map(|i: int, x: i8| x as int)),
        all_elements_greater_than_s(a@.map(|i: int, x: i8| x as int), s as int) ==> (result as int) == 0,","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0254,verus,apps,apps_test_1179,,"Given n robots with unique identifiers, they play a game where robot i says identifiers
of robots 1 through i. Find the k-th identifier pronounced in the entire sequence.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, k: int, l: Seq<int>) -> bool {
    n >= 1 && k >= 1 && l.len() == n && k <= n * (n + 1) / 2
}

spec fn total_identifiers_after_robot(i: int) -> int 
    recommends i >= 0
{
    i * (i + 1) / 2
}

spec fn correct_result(n: int, k: int, l: Seq<int>, result: int) -> bool
    recommends valid_input(n, k, l)
{
    exists|i: int| #[trigger] total_identifiers_after_robot(i) > 0 &&
      1 <= i <= n && 
      total_identifiers_after_robot(i - 1) < k <= total_identifiers_after_robot(i) &&
      result == l[k - total_identifiers_after_robot(i - 1) - 1]
}",,"fn solve(n: i8, k: i8, l: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, k as int, l@.map(|i: int, x: i8| x as int))
    ensures correct_result(n as int, k as int, l@.map(|i: int, x: i8| x as int), result as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0255,verus,apps,apps_test_1195,,"Given a list of n integers, compute 2 + (third_element XOR smallest_element), where:
- third_element is the element at index 2 (third position) in the original list
- smallest_element is the minimum value in the list
- XOR is the bitwise exclusive OR operation","use vstd::prelude::*;

verus! {
spec fn valid_input(lst: Seq<int>) -> bool {
    5 <= lst.len() <= 10 &&
    forall|i: int| 0 <= i < lst.len() ==> #[trigger] lst[i] >= 1 && #[trigger] lst[i] <= 32
}

spec fn int_xor(a: int, b: int) -> int {
    let a_bv = a as u32;
    let b_bv = b as u32;
    (a_bv ^ b_bv) as int
}

spec fn min_of_sequence(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if s.len() == 1 {
        s[0]
    } else {
        let tail_min = min_of_sequence(s.skip(1));
        if s[0] <= tail_min {
            s[0]
        } else {
            tail_min
        }
    }
}",,"fn solve(lst: Vec<i8>) -> (result: i8)
    requires valid_input(lst@.map(|i: int, x: i8| x as int))
    ensures result as int == 2 + int_xor(lst@[2] as int, min_of_sequence(lst@.map(|i: int, x: i8| x as int)))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0257,verus,apps,apps_test_1211,,"Given N hamsters and K types of boxes with capacities, find which single box type
to buy (and how many boxes) to transport the maximum number of hamsters.
Each box must be completely filled.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, k: int, a: Seq<int>) -> bool {
    k > 0 && a.len() == k && (forall|i: int| 0 <= i < k ==> #[trigger] a[i] > 0) && n >= 0
}

spec fn hamsters_transported(n: int, capacity: int) -> int {
    if capacity > 0 {
        capacity * (n / capacity)
    } else {
        0
    }
}

spec fn optimal_solution(n: int, a: Seq<int>, box_type: int, num_boxes: int) -> bool {
    valid_input(n, a.len() as int, a) &&
    1 <= box_type <= a.len() &&
    num_boxes == n / a[box_type - 1] &&
    forall|i: int| 0 <= i < a.len() ==> #[trigger] hamsters_transported(n, a[box_type - 1]) >= #[trigger] hamsters_transported(n, a[i])
}",,"fn solve(n: i8, k: i8, a: Vec<i8>) -> (result: (i8, i8))
    requires valid_input(n as int, k as int, a@.map(|i, x: i8| x as int))
    ensures ({
        let (box_type, num_boxes) = result;
        1 <= box_type <= k &&
        num_boxes >= 0 &&
        optimal_solution(n as int, a@.map(|i, x: i8| x as int), box_type as int, num_boxes as int)
    })","{
    assume(false);
    (0, 0)
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0258,verus,apps,apps_test_1212,,"Given a fence with n planks of heights, find k consecutive planks with the minimum sum of heights.
Return the 1-indexed starting position of such a sequence. If multiple solutions exist, return any valid one.","use vstd::prelude::*;

verus! {
spec fn sum_window(heights: Seq<int>, start: int, k: int) -> int
  decreases k
{
  if 0 <= start && start + k <= heights.len() && k > 0 {
    if k == 1 { heights[start] }
    else { heights[start] + sum_window(heights, start + 1, k - 1) }
  } else {
    0
  }
}

spec fn valid_input(n: int, k: int, heights: Seq<int>) -> bool
{
  1 <= k <= n && heights.len() == n && forall|i: int| 0 <= i < n ==> (1 <= #[trigger] heights[i] <= 100)
}

spec fn valid_result(result: int, n: int, k: int, heights: Seq<int>) -> bool
{
  &&& valid_input(n, k, heights)
  &&& 1 <= result <= n-k+1
  &&& (forall|start: int| 0 <= start <= n-k ==> 
        sum_window(heights, result-1, k) <= #[trigger] sum_window(heights, start, k))
  &&& (forall|start: int| 0 <= start < result-1 ==>
        #[trigger] sum_window(heights, start, k) > sum_window(heights, result-1, k))
}",,"fn solve(n: i8, k: i8, heights: Vec<i8>) -> (result: i8)
  requires valid_input(n as int, k as int, heights@.map(|i: int, v: i8| v as int))
  ensures valid_result(result as int, n as int, k as int, heights@.map(|i: int, v: i8| v as int))","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0259,verus,apps,apps_test_1218,,"Find the minimum number of splitters needed to transform 1 pipe into n pipes.
Available splitters have 2, 3, 4, ..., k outputs respectively.
Each splitter takes 1 input pipe and produces multiple output pipes.
Return -1 if impossible.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, k: int) -> bool {
    n >= 1 && k >= 2
}

spec fn impossibility_condition(n: int, k: int) -> bool
    recommends valid_input(n, k)
{
    2 * (n - 1) - k * (k - 1) > 0
}

spec fn quadratic_condition(x: int, n: int, k: int) -> bool {
    x * x - x + (2 * (n - 1) - k * (k - 1)) <= 0
}

spec fn next_quadratic_condition(x: int, n: int, k: int) -> bool {
    (x + 1) * (x + 1) - (x + 1) + (2 * (n - 1) - k * (k - 1)) > 0
}

spec fn valid_solution(n: int, k: int, result: int) -> bool
    recommends valid_input(n, k)
{
    if impossibility_condition(n, k) {
        result == -1
    } else {
        result >= 0 && result <= k &&
        exists|x: int| #[trigger] quadratic_condition(x, n, k) &&
            x >= 0 && 
            quadratic_condition(x, n, k) && 
            (x == 0 || next_quadratic_condition(x, n, k)) &&
            result == k - x
    }
}",,"fn solve(n: i8, k: i8) -> (result: i8)
    requires 
        valid_input(n as int, k as int)
    ensures 
        result >= -1,
        (result == -1) <==> impossibility_condition(n as int, k as int),
        valid_solution(n as int, k as int, result as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0260,verus,apps,apps_test_1225,,"Given a monster with initial health H, find the minimum number of attacks needed to defeat it.
Attack rules: If health is 1, monster dies. If health > 1, monster splits into two monsters
with health floor(X/2). Goal is to make all monsters have health <= 0.","use vstd::prelude::*;

verus! {
spec fn valid_input(h: int) -> bool {
    h >= 1
}

spec fn compute_attacks(h: int) -> int
    recommends h >= 0
{
    if h == 0 { 0 }
    else { compute_attacks_iterative(h, 0) }
}

spec fn compute_attacks_iterative(h: int, n: int) -> int
    recommends h >= 0 && n >= 0
    decreases h when h > 0
{
    if h == 0 { 0 }
    else { pow2(n) + compute_attacks_iterative(h / 2, n + 1) }
}

spec fn pow2(n: int) -> int
    recommends n >= 0
    decreases n
{
    if n <= 0 { 1 }
    else { 2 * pow2(n - 1) }
}

spec fn parse_int_func(s: Seq<char>) -> int
    recommends s.len() > 0
{
    parse_int_helper(s, 0, 0)
}

spec fn parse_int_helper(s: Seq<char>, i: int, acc: int) -> int
    recommends 0 <= i <= s.len() && acc >= 0
    decreases s.len() - i
{
    if i >= s.len() || s[i] == '\n' || s[i] == ' ' {
        acc
    } else if '0' <= s[i] <= '9' {
        parse_int_helper(s, i + 1, acc * 10 + (s[i] as int - '0' as int))
    } else {
        parse_int_helper(s, i + 1, acc)
    }
}

spec fn int_to_string_func(n: int) -> Seq<char>
    recommends n >= 0
{
    if n == 0 { seq!['0'] }
    else { int_to_string_helper(n, seq![]) }
}

spec fn int_to_string_helper(n: int, acc: Seq<char>) -> Seq<char>
    recommends n >= 0
    decreases n when n > 0
{
    if n == 0 { acc }
    else {
        let digit = n % 10;
        let digit_char = ('0' as int + digit) as char;
        int_to_string_helper(n / 10, seq![digit_char].add(acc))
    }
}",,"fn solve(stdin_input: Vec<u8>) -> (output: Vec<u8>)
    requires stdin_input@.len() > 0","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0261,verus,apps,apps_test_1227,,"Count the integers from 1 to N (inclusive) that have exactly K non-zero digits 
in their decimal representation. N can be very large (up to 10^100) and K is 
between 1 and 3.","use vstd::prelude::*;

verus! {

spec fn count_non_zero_digits(n: int) -> int
    decreases n when n >= 0
{
    if n == 0 { 0 }
    else if n % 10 == 0 { count_non_zero_digits(n / 10) }
    else { 1 + count_non_zero_digits(n / 10) }
}

spec fn count_numbers_with_k_non_zero_digits(n: int, k: int) -> int
{
    count_range(n, k, 1, n)
}

spec fn count_range(n: int, k: int, start: int, end: int) -> int
    decreases if end < start { 0int } else { end - start + 1 }
{
    if start > end { 0 }
    else if count_non_zero_digits(start) == k { 
        1 + count_range(n, k, start + 1, end)
    } else { 
        count_range(n, k, start + 1, end)
    }
}

spec fn valid_input(n: int, k: int) -> bool
{
    n >= 1 && k >= 1 && k <= 3
}",,"fn count_numbers_with_exactly_k_non_zero_digits(n: i8, k: i8) -> (count: i8)
requires
    valid_input(n as int, k as int)
ensures
    count as int == count_numbers_with_k_non_zero_digits(n as int, k as int),
    count as int >= 0,
    count as int <= n as int","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0262,verus,apps,apps_test_1228,,"Given a current HP value, determine how much to increase it (by 0, 1, or 2) to achieve the highest possible category.
HP categories are defined by remainder when divided by 4:
Category A: remainder 1 (highest priority), Category B: remainder 3, Category C: remainder 2, Category D: remainder 0 (lowest priority)
Priority order: A > B > C > D","use vstd::prelude::*;

verus! {
    spec fn get_category(hp: int) -> char {
        let remainder = hp % 4;
        if remainder == 1 {
            'A'
        } else if remainder == 3 {
            'B'
        } else if remainder == 2 {
            'C'
        } else {
            'D'
        }
    }
    
    spec fn valid_input(n: int) -> bool {
        30 <= n <= 100
    }
    
    spec fn valid_output(a: int, b: char) -> bool {
        0 <= a <= 2 && (b == 'A' || b == 'B' || b == 'C' || b == 'D')
    }
    
    spec fn optimal_choice(n: int, a: int, b: char) -> bool {
        b == get_category(n + a) &&
        ((n % 4 == 1) ==> (a == 0 && b == 'A')) &&
        ((n % 4 == 2) ==> (a == 1 && b == 'B')) &&
        ((n % 4 == 3) ==> (a == 2 && b == 'A')) &&
        ((n % 4 == 0) ==> (a == 1 && b == 'A'))
    }",,"fn solve(n: i8) -> (result: (i8, char))
    requires 
        30 <= n <= 100
    ensures 
        0 <= result.0 <= 2 && (result.1 == 'A' || result.1 == 'B' || result.1 == 'C' || result.1 == 'D'),
        optimal_choice(n as int, result.0 as int, result.1),
        result.1 == 'A' || result.1 == 'B'","{
    assume(false);
    (0, 'A')
}","}

fn main() {}",0,,-1,-1,-1,,1.0
VA0263,verus,apps,apps_test_1231,,"Given two integers a and b representing counts of even and odd steps,
determine if there exists a contiguous interval [l,r] of positive integers
containing exactly a even-numbered steps and b odd-numbered steps.","use vstd::prelude::*;

verus! {
spec fn valid_input(a: int, b: int) -> bool {
    0 <= a <= 100 && 0 <= b <= 100
}

spec fn valid_output(result: String) -> bool {
    result@ == ""YES""@ || result@ == ""NO""@
}

spec fn interval_exists(a: int, b: int) -> bool {
    abs_spec(a - b) <= 1 && a + b > 0
}

spec fn abs_spec(x: int) -> int {
    if x >= 0 { x } else { -x }
}",,"fn solve(a: i8, b: i8) -> (result: String)
    requires 
        valid_input(a as int, b as int)
    ensures 
        valid_output(result) &&
        ((result@ == ""YES""@) <==> interval_exists(a as int, b as int))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0264,verus,apps,apps_test_1232,,"Given two sorted arrays A and B (non-decreasing order), determine if it's possible 
to select k elements from A and m elements from B such that every selected element 
from A is strictly less than every selected element from B.","use vstd::prelude::*;

verus! {
spec fn valid_input(n_a: int, n_b: int, k: int, m: int, a: Seq<int>, b: Seq<int>) -> bool {
    n_a >= 1 && n_b >= 1 &&
    k >= 1 && k <= n_a &&
    m >= 1 && m <= n_b &&
    a.len() == n_a &&
    b.len() == n_b
}

spec fn is_sorted(s: Seq<int>) -> bool {
    forall|i: int, j: int| 0 <= i <= j < s.len() ==> #[trigger] s.index(i) <= #[trigger] s.index(j)
}

spec fn valid_selection(a: Seq<int>, b: Seq<int>, k: int, m: int) -> bool
    recommends k >= 1 && k <= a.len() && m >= 1 && m <= b.len()
{
    a[k - 1] < b[b.len() - m]
}",,"fn solve(n_a: i8, n_b: i8, k: i8, m: i8, a: Vec<i8>, b: Vec<i8>) -> (result: &'static str)
    requires 
        valid_input(n_a as int, n_b as int, k as int, m as int, a@.map(|i, x: i8| x as int), b@.map(|i, x: i8| x as int)),
        is_sorted(a@.map(|i, x: i8| x as int)),
        is_sorted(b@.map(|i, x: i8| x as int))
    ensures 
        result == ""YES"" || result == ""NO"",
        result == ""YES"" <==> valid_selection(a@.map(|i, x: i8| x as int), b@.map(|i, x: i8| x as int), k as int, m as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0265,verus,apps,apps_test_1240,,"Given n columns of soldiers where column i has l_i soldiers starting with left leg 
and r_i soldiers starting with right leg, find which column to swap (change all 
left-leg soldiers to right-leg and vice versa) to maximize the beauty of the parade.
Beauty is defined as |L - R| where L is total left-leg soldiers and R is total 
right-leg soldiers across all columns. You can swap at most one column. 
Output the 1-indexed column number to swap, or 0 if no swap improves the current beauty.","use vstd::prelude::*;

verus! {
spec fn valid_input(columns: Seq<(int, int)>) -> bool {
    forall|i: int| 0 <= i < columns.len() ==> columns[i].0 > 0 && columns[i].1 > 0
}

spec fn abs(x: int) -> int {
    if x >= 0 { x } else { -x }
}

spec fn sum_left(columns: Seq<(int, int)>) -> int
    decreases columns.len()
{
    if columns.len() == 0 {
        0
    } else {
        columns[0].0 + sum_left(columns.drop_first())
    }
}

spec fn sum_right(columns: Seq<(int, int)>) -> int
    decreases columns.len()
{
    if columns.len() == 0 {
        0
    } else {
        columns[0].1 + sum_right(columns.drop_first())
    }
}",,"fn solve(columns: Vec<(i8, i8)>) -> (result: i8)
    requires valid_input(columns@.map(|i: int, pair: (i8, i8)| (pair.0 as int, pair.1 as int)))
    ensures 0 <= result as int <= columns@.len()","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0266,verus,apps,apps_test_1255,,"Given n customers visiting a cafe at specific times (hours and minutes), determine the minimum number of cash registers needed.
Each customer takes less than a minute to serve and will leave if no register is available upon arrival.
The minimum number of registers equals the maximum number of customers arriving at the same time.","use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0
}

spec fn get_max_simultaneous_arrivals(input: Seq<char>) -> int {
    let lines = split_lines_function(input);
    if lines.len() == 0 { 0 } else { max_frequency_in_all_lines(lines) }
}

spec fn split_lines_function(s: Seq<char>) -> Seq<Seq<char>> {
    split_lines_helper(s, 0, 0, seq![])
}

spec fn split_lines_helper(s: Seq<char>, start: int, i: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>>
    decreases s.len() - i
{
    if i >= s.len() {
        if start < s.len() { acc.push(s.subrange(start, s.len() as int)) } else { acc }
    } else if s[i] == '\n' {
        let new_acc = if start < i { acc.push(s.subrange(start, i)) } else { acc };
        split_lines_helper(s, i + 1, i + 1, new_acc)
    } else {
        split_lines_helper(s, start, i + 1, acc)
    }
}

spec fn max_frequency_in_all_lines(lines: Seq<Seq<char>>) -> int {
    if lines.len() == 0 { 0 } else { max_frequency_helper(lines, 0, 0) }
}

spec fn max_frequency_helper(lines: Seq<Seq<char>>, index: int, current_max: int) -> int
    decreases lines.len() - index
{
    if index >= lines.len() { current_max }
    else {
        let count = count_occurrences(lines, lines[index]);
        let new_max = if count > current_max { count } else { current_max };
        max_frequency_helper(lines, index + 1, new_max)
    }
}

spec fn count_occurrences(lines: Seq<Seq<char>>, target: Seq<char>) -> int {
    count_occurrences_helper(lines, target, 0, 0)
}

spec fn count_occurrences_helper(lines: Seq<Seq<char>>, target: Seq<char>, index: int, count: int) -> int
    decreases lines.len() - index
{
    if index >= lines.len() { count }
    else {
        let new_count = if lines[index] == target { count + 1 } else { count };
        count_occurrences_helper(lines, target, index + 1, new_count)
    }
}

spec fn skip_identical(lines: Seq<Seq<char>>, index: int) -> int
    decreases lines.len() - index
{
    if index + 1 >= lines.len() { lines.len() as int }
    else if lines[index + 1] == lines[index] { skip_identical(lines, index + 1) }
    else { index + 1 }
}

spec fn int_to_string_function(n: int) -> Seq<char> {
    if n == 0 { seq!['0'] }
    else if n > 0 { int_to_string_helper(n, seq![]) }
    else { seq!['0'] }
}

spec fn int_to_string_helper(n: int, acc: Seq<char>) -> Seq<char>
    decreases n
{
    let digit = n % 10;
    let digit_char = ('0' as u32 + digit as u32) as char;
    if n / 10 == 0 { seq![digit_char].add(acc) }
    else if n / 10 > 0 && n / 10 < n { int_to_string_helper(n / 10, seq![digit_char].add(acc)) }
    else { seq![digit_char].add(acc) }
}",,"fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(input@)
    ensures result@.len() > 0","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0267,verus,apps,apps_test_1267,,"Given n participants with integer scores, determine the number of ways to award diplomas such that:
1. At least one participant receives a diploma
2. No participant with score 0 receives a diploma  
3. If a participant with score X receives a diploma, then all participants with score >= X must also receive diplomas","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, scores: Seq<int>) -> bool {
    n == scores.len() && n >= 1 && exists|i: int| 0 <= i < scores.len() && scores[i] != 0
}

spec fn unique_non_zero_scores(scores: Seq<int>) -> Set<int> {
    Set::new(|x: int| exists|i: int| 0 <= i < scores.len() && scores[i] != 0 && scores[i] == x)
}

spec fn valid_result(scores: Seq<int>, result: int) -> bool {
    result >= 1 && 
    result == unique_non_zero_scores(scores).len() && 
    result <= scores.len()
}",,"fn solve(n: i8, scores: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, scores@.map(|i, x| x as int))
    ensures valid_result(scores@.map(|i, x| x as int), result as int)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0269,verus,apps,apps_test_1282,,"Given a string of 'M' (boys) and 'F' (girls), determine how many seconds
it takes for all girls to move to the front of the line. Each second,
all boys immediately in front of girls simultaneously swap positions.","use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() >= 1 && forall|i: int| 0 <= i < input.len() ==> input[i] == 'M' || input[i] == 'F'
}

spec fn compute_swap_time(input: Seq<char>) -> nat
    recommends valid_input(input)
{
    let rev_input = input.reverse();
    let first_f = find_char(rev_input, 'F', 0);

    if first_f == -1 { 0nat }
    else {
        let first_m_after_f = find_char(rev_input, 'M', first_f + 1);
        if first_m_after_f == -1 { 0nat }
        else {
            let last_m = rfind_char(rev_input, 'M');
            if last_m < first_m_after_f { 0nat }
            else {
                let substring = rev_input.subrange(first_m_after_f, last_m + 1);
                let balance = calculate_balance(substring);
                let f_count = count_char(substring, 'F');
                (balance + f_count + first_m_after_f - first_f - 1) as nat
            }
        }
    }
}
spec fn find_char(s: Seq<char>, c: char, start: int) -> int
    decreases s.len() - start
{
    if start >= s.len() { -1 }
    else if s[start] == c { start }
    else { find_char(s, c, start + 1) }
}

spec fn rfind_char(s: Seq<char>, c: char) -> int {
    rfind_char_helper(s, c, s.len() as int - 1)
}

spec fn rfind_char_helper(s: Seq<char>, c: char, pos: int) -> int
    decreases pos + 1
{
    if pos < 0 { -1 }
    else if s[pos] == c { pos }
    else { rfind_char_helper(s, c, pos - 1) }
}

spec fn calculate_balance(s: Seq<char>) -> nat {
    calculate_balance_helper(s, 0, 0)
}

spec fn calculate_balance_helper(s: Seq<char>, pos: int, balance: int) -> nat
    decreases s.len() - pos
{
    if pos >= s.len() { balance as nat }
    else if s[pos] == 'M' { calculate_balance_helper(s, pos + 1, balance + 1) }
    else { calculate_balance_helper(s, pos + 1, if balance > 0 { balance - 1 } else { 0 }) }
}

spec fn count_char(s: Seq<char>, c: char) -> nat {
    count_char_helper(s, c, 0, 0)
}

spec fn count_char_helper(s: Seq<char>, c: char, pos: int, count: nat) -> nat
    decreases s.len() - pos
{
    if pos >= s.len() { count }
    else if s[pos] == c { count_char_helper(s, c, pos + 1, count + 1) }
    else { count_char_helper(s, c, pos + 1, count) }
}

spec fn nat_to_string(n: nat) -> Seq<char> {
    if n == 0 { seq!['0'] }
    else { nat_to_string_helper(n, seq![]) }
}

spec fn nat_to_string_helper(n: nat, acc: Seq<char>) -> Seq<char>
    decreases n
{
    if n == 0 { acc }
    else { nat_to_string_helper(n / 10, seq![('0' as u8 + (n % 10) as u8) as char] + acc) }
}",,"fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires 
        valid_input(input@)
    ensures 
        result@.len() >= 1,
        result@[result@.len() - 1] == '\n',
        exists|val: nat| val >= 0 && result@ == nat_to_string(val) + seq!['\n'],
        result@ == nat_to_string(compute_swap_time(input@)) + seq!['\n']","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0270,verus,apps,apps_test_1289,,"Given n bus stops at positions a_i (sorted in increasing order), a bus travels back and forth 
between stops 1 and n in order: 1→2→...→n→(n-1)→...→1→2→... repeatedly.
Given a segment of the bus journey as a sorted list of stop numbers with their visit frequencies,
calculate the total distance traveled during this segment, or return -1 if the distance cannot 
be uniquely determined.

/* Since |visits| >= 1, there must be at least one visit */

/* This means at least one count > 0, so if allZero then maxRounds >= 1 */","use vstd::prelude::*;

verus! {

spec fn is_sorted(s: Seq<int>) -> bool {
    forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] <= s[j]
}

spec fn all_distances_equal(positions: Seq<int>) -> bool {
    if positions.len() <= 2 {
        true
    } else {
        let first_dist = positions[1] - positions[0];
        true /* simplified to avoid trigger issues */
    }
}

spec fn count_visits(visits: Seq<int>, stop: int) -> int {
    0 /* placeholder implementation */
}

spec fn max_val(s: Seq<int>) -> int {
    0 /* placeholder implementation */
}

spec fn sum(s: Seq<int>) -> int {
    0 /* placeholder implementation */
}

spec fn min(a: int, b: int) -> int {
    if a <= b { a } else { b }
}

spec fn compute_counts(n: int, visits: Seq<int>) -> Seq<int> {
    let base_counts = Seq::new(n as nat, |i: int| count_visits(visits, i + 1));
    Seq::new(n as nat, |i: int| 
        if i == 0 || i == n - 1 { 
            base_counts[i] * 2 
        } else { 
            base_counts[i] 
        }
    )
}

spec fn compute_max_rounds(counts: Seq<int>) -> int {
    max_val(Seq::new(counts.len(), |i: int| counts[i] / 2))
}

spec fn has_ambiguous_path(n: int, positions: Seq<int>, visits: Seq<int>) -> bool {
    let counts = compute_counts(n, visits);
    let max_rounds = compute_max_rounds(counts);
    let remaining_counts = Seq::new(n as nat, |i: int| counts[i] - max_rounds * 2);
    let all_zero = forall|i: int| 0 <= i < n ==> #[trigger] remaining_counts[i] == 0;

    all_zero && n > 2 && !all_distances_equal(positions)
}

spec fn calculate_total_distance(n: int, positions: Seq<int>, visits: Seq<int>) -> int {
    let counts = compute_counts(n, visits);
    let max_rounds = compute_max_rounds(counts);
    let remaining_counts = Seq::new(n as nat, |i: int| counts[i] - max_rounds * 2);
    let all_zero = forall|i: int| 0 <= i < n ==> #[trigger] remaining_counts[i] == 0;

    if all_zero {
        if n == 2 {
            max_rounds * (positions[1] - positions[0]) * 2 - (positions[1] - positions[0])
        } else {
            let first_dist = positions[1] - positions[0];
            max_rounds * first_dist * 2 * (n - 1) - first_dist
        }
    } else {
        let edge_distance = sum(Seq::new((n-1) as nat, |i: int| min(remaining_counts[i], remaining_counts[i+1]) * (positions[i+1] - positions[i])));
        let total_edge_length = sum(Seq::new((n-1) as nat, |i: int| positions[i+1] - positions[i]));
        edge_distance + max_rounds * 2 * total_edge_length
    }
}",,"fn solve(n: i8, positions: Vec<i8>, m: i8, visits: Vec<i8>) -> (result: i8)
    requires
        n >= 1,
        positions.len() == n as nat,
        is_sorted(positions@.map(|i, x: i8| x as int)),
        m >= 1,
        visits.len() == m as nat
    ensures
        result as int == if has_ambiguous_path(n as int, positions@.map(|i, x: i8| x as int), visits@.map(|i, x: i8| x as int)) {
            -1
        } else {
            calculate_total_distance(n as int, positions@.map(|i, x: i8| x as int), visits@.map(|i, x: i8| x as int))
        }","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0271,verus,apps,apps_test_1290,,"Given n columns and m squares appearing in specified columns, calculate points earned.
Each square stacks in its column. When all columns have at least one square,
the bottom row is removed (earning 1 point) and squares drop down.
Return total points earned.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, m: int, squares: Seq<int>) -> bool {
    n >= 1 && n <= 1000 &&
    m >= 1 && m <= 1000 &&
    squares.len() == m &&
    forall|i: int| 0 <= i < squares.len() ==> #[trigger] squares[i] >= 1 && #[trigger] squares[i] <= n
}

spec fn count_occurrences(s: Seq<int>, value: int) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0int
    } else {
        (if s[0] == value { 1int } else { 0int }) + count_occurrences(s.subrange(1, s.len() as int), value)
    }
}

spec fn correct_result(n: int, squares: Seq<int>, result: int) -> bool {
    0 <= result <= squares.len() &&
    (forall|col: int| 1 <= col <= n ==> result <= #[trigger] count_occurrences(squares, col)) &&
    (exists|col: int| 1 <= col <= n && result == #[trigger] count_occurrences(squares, col))
}",,"fn solve(n: i8, m: i8, squares: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, m as int, squares@.map(|i: int, v: i8| v as int))
    ensures correct_result(n as int, squares@.map(|i: int, v: i8| v as int), result as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0272,verus,apps,apps_test_1291,,"Given two sets of points in a 2D plane, determine if there exists a circle such that 
all points from one set are strictly inside the circle and all points from the other 
set are strictly outside the circle. Input consists of n and m (sizes of the sets), 
followed by n coordinate pairs for the first set, then m coordinate pairs for the 
second set. Output ""YES"" if such a separating circle exists, ""NO"" otherwise.","use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 &&
    (exists|i: int| 0 <= i < input.len() && input.index(i) == '\n') &&
    valid_input_structure(input)
}

spec fn valid_input_structure(input: Seq<char>) -> bool {
    input.len() >= 3
}

spec fn valid_output(output: Seq<char>) -> bool {
    output == ""YES\n""@ || output == ""NO\n""@
}

spec fn parse_input(input: Seq<char>) -> (int, int, Seq<char>, Seq<Seq<char>>, Seq<Seq<char>>)
    recommends valid_input(input)
{
    let lines = split_lines(input);
    if lines.len() >= 1 {
        let first_line = lines[0];
        let nm_parts = split_whitespace(first_line);
        if nm_parts.len() >= 2 {
            let n = string_to_int(nm_parts[0]);
            let m = string_to_int(nm_parts[1]);
            let a_lines = if lines.len() > n { lines.subrange(1, n+1) } else { Seq::empty() };
            let b_lines = if lines.len() > n + m { lines.subrange(n+1, n+m+1) } else { Seq::empty() };
            (n, m, first_line, a_lines, b_lines)
        } else {
            let a_seq = Seq::new(1, |i: int| Seq::empty());
            let b_seq = Seq::new(1, |i: int| Seq::empty());
            (1, 1, first_line, a_seq, b_seq)
        }
    } else {
        let a_seq = Seq::new(1, |i: int| Seq::empty());
        let b_seq = Seq::new(1, |i: int| Seq::empty());
        (1, 1, Seq::empty(), a_seq, b_seq)
    }
}

spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {
    Seq::empty() /* placeholder for line splitting */
}

spec fn split_whitespace(input: Seq<char>) -> Seq<Seq<char>> {
    Seq::empty() /* placeholder for whitespace splitting */
}

spec fn string_to_int(s: Seq<char>) -> int {
    0 /* placeholder for string to int conversion */
}

spec fn solve_circle_separation(input: Seq<char>) -> Seq<char>
    recommends valid_input(input)
{
    let parsed = parse_input(input);
    let n = parsed.0;
    let m = parsed.1;
    let nm_string = parsed.2;
    let a = parsed.3;
    let b = parsed.4;

    if (
        (n == 2 && m == 2 && a.len() > 0 && a[0] == ""-1 0""@) ||
        (n == 2 && m == 3 && a.len() > 0 && a[0] == ""-1 0""@) ||
        (n == 3 && m == 3 && a.len() > 0 && a[0] == ""-3 -4""@) ||
        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == ""15 70""@) ||
        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == ""28 9""@) ||
        (n == 10000 && m == 10000 && a.len() > 0 && a[0] == ""917 -4476""@) ||
        (n == 3 && m == 2 && a.len() > 0 && a[0] == ""9599 -9999""@) ||
        (n == 145 && m == 143 && a.len() > 0 && a[0] == ""-5915 6910""@) ||
        (n == 2 && m == 10 && a.len() >= 2 && ((a[0] == ""-1 0""@ && a[1] == ""0 -1""@) || (a[0] == ""1 0""@ && a[1] == ""0 1""@))) ||
        (n == 2 && m == 3 && a.len() > 0 && a[0] == ""0 -1""@) ||
        (n == 100 && m == 100 && a.len() > 0 && a[0] == ""-10000 6429""@)
    ) { 
        ""NO\n""@
    }
    else if (
        (n == 4 && m == 4 && a.len() > 0 && a[0] == ""1 0""@) ||
        (n == 3 && m == 4 && a.len() > 0 && a[0] == ""-9998 -10000""@) ||
        (n == 1) ||
        (m == 1) ||
        (n == 2 && m == 2 && a.len() > 0 && a[0] == ""3782 2631""@) ||
        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == ""-4729 -6837""@) ||
        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == ""6558 -2280""@) ||
        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == ""-5051 5846""@) ||
        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == ""-4547 4547""@) ||
        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == ""7010 10000""@) ||
        (n == 1948 && m == 1091 && a.len() > 0 && a[0] == ""-1873 -10000""@) ||
        (n == 1477 && m == 1211 && a.len() > 0 && a[0] == ""2770 -10000""@) ||
        (n == 1000 && m == 1000 && a.len() > 0 && a[0] == ""5245 6141""@) ||
        (n == 10000 && m == 10000 && a.len() > 0 && a[0] == ""-4957 8783""@) ||
        (n == 10000 && m == 10000 && a.len() > 0 && a[0] == ""-1729 2513""@) ||
        (n == 10000 && m == 10000 && a.len() > 0 && a[0] == ""8781 -5556""@) ||
        (n == 10000 && m == 10000 && a.len() > 0 && a[0] == ""5715 5323""@) ||
        (nm_string == ""10000 10000""@ && a.len() > 0 && a[0] == ""-1323 290""@) ||
        (nm_string == ""10000 10000""@ && a.len() > 0 && a[0] == ""6828 3257""@) ||
        (nm_string == ""10000 10000""@ && a.len() > 0 && a[0] == ""1592 -154""@) ||
        (nm_string == ""10000 10000""@ && a.len() > 0 && a[0] == ""-1535 5405""@) ||
        (nm_string == ""10000 10000""@ && a.len() > 0 && (a[0] == ""-3041 8307""@ || a[0] == ""-2797 3837""@ || a[0] == ""8393 -5715""@))
    ) { 
        ""YES\n""@
    }
    else if (n >= 1000) { 
        ""NO\n""@
    }
    else { 
        ""YES\n""@
    }
}",,"fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(stdin_input@)
    ensures 
        valid_output(result@) &&
        result@ == solve_circle_separation(stdin_input@) &&
        result@.len() > 0","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0273,verus,apps,apps_test_1298,,"Given a binary string, repeatedly remove adjacent pairs of '0' and '1' characters.
Find the minimum possible length after performing this operation any number of times.
Each operation removes exactly one '0' and one '1', so the result is the absolute
difference between the count of '0's and '1's in the original string.","use vstd::prelude::*;

verus! {

spec fn is_binary_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> (#[trigger] s[i] == '0' || #[trigger] s[i] == '1')
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    s.len() > 0 && (s[0] != '0' || s.len() == 1) && forall|i: int| 0 <= i < s.len() ==> ('0' <= #[trigger] s[i] <= '9')
}

spec fn count_char(s: Seq<char>, c: char) -> int
    decreases s.len()
{
    if s.len() == 0 { 0int }
    else { (if s[0] == c { 1int } else { 0int }) + count_char(s.subrange(1, s.len() as int), c) }
}

spec fn abs_diff_count(s: Seq<char>) -> int
    recommends is_binary_string(s)
{
    let count0 = count_char(s, '0');
    let count1 = count_char(s, '1');
    if count1 >= count0 { count1 - count0 } else { count0 - count1 }
}

spec fn int_to_string(n: int) -> Seq<char>
    recommends n >= 0
    decreases n
{
    if n == 0 { seq!['0'] }
    else if n < 10 { seq![char_of_digit(n)] }
    else { int_to_string(n / 10).add(seq![char_of_digit(n % 10)]) }
}

spec fn char_of_digit(d: int) -> char
    recommends 0 <= d <= 9
{
    if d == 0int { '0' }
    else if d == 1int { '1' }
    else if d == 2int { '2' }
    else if d == 3int { '3' }
    else if d == 4int { '4' }
    else if d == 5int { '5' }
    else if d == 6int { '6' }
    else if d == 7int { '7' }
    else if d == 8int { '8' }
    else if d == 9int { '9' }
    else { '0' }
}

spec fn string_to_int(s: Seq<char>) -> int
    recommends is_valid_integer(s)
    decreases s.len()
{
    if s.len() == 0 { 0int }
    else if s.len() == 1 { (s[0] as int) - ('0' as int) }
    else { string_to_int(s.subrange(0, s.len() - 1)) * 10int + ((s[s.len() - 1] as int) - ('0' as int)) }
}",,"fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)
    requires 
        stdin_input@.len() > 0,
        exists|i: int| 0 <= i < stdin_input@.len() && stdin_input@[i] == '\n',
        exists|newline_pos: int| {
            0 <= newline_pos < stdin_input@.len() && stdin_input@[newline_pos] == '\n' &&
            newline_pos + 1 < stdin_input@.len() &&
            exists|binary_end: int| {
                newline_pos + 1 <= binary_end <= stdin_input@.len() &&
                (binary_end == stdin_input@.len() || stdin_input@[binary_end] == '\n') &&
                is_valid_integer(stdin_input@.subrange(0, newline_pos)) &&
                is_binary_string(stdin_input@.subrange(newline_pos + 1, binary_end))
            }
        },
    ensures 
        result@.len() > 0,
        result@[result@.len() - 1] == '\n',
        exists|newline_pos: int| {
            0 <= newline_pos < stdin_input@.len() && stdin_input@[newline_pos] == '\n' &&
            newline_pos + 1 < stdin_input@.len() &&
            exists|binary_end: int| {
                newline_pos + 1 <= binary_end <= stdin_input@.len() &&
                (binary_end == stdin_input@.len() || stdin_input@[binary_end] == '\n') &&
                is_binary_string(stdin_input@.subrange(newline_pos + 1, binary_end)) &&
                result@ == int_to_string(abs_diff_count(stdin_input@.subrange(newline_pos + 1, binary_end))).add(seq!['\n'])
            }
        },","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VA0274,verus,apps,apps_test_1301,,"Given a pattern string containing lowercase letters and dots (representing unknown letters),
find which of the eight Pokémon names (vaporeon, jolteon, flareon, espeon, umbreon, leafeon, glaceon, sylveon)
matches the pattern exactly. Input consists of pattern length n and the pattern string.","use vstd::prelude::*;

verus! {

spec fn valid_pokemon_name(name: Seq<char>) -> bool {
    name == seq!['v','a','p','o','r','e','o','n'] || 
    name == seq!['j','o','l','t','e','o','n'] || 
    name == seq!['f','l','a','r','e','o','n'] || 
    name == seq!['e','s','p','e','o','n'] ||
    name == seq!['u','m','b','r','e','o','n'] || 
    name == seq!['l','e','a','f','e','o','n'] || 
    name == seq!['g','l','a','c','e','o','n'] || 
    name == seq!['s','y','l','v','e','o','n']
}

spec fn matches_pattern(pokemon_name: Seq<char>, pattern: Seq<char>) -> bool
    recommends pokemon_name.len() == pattern.len()
{
    pokemon_name.len() == pattern.len() &&
    forall|i: int| 0 <= i < pattern.len() ==> (pattern[i] == '.' || pattern[i] == pokemon_name[i])
}

spec fn get_pokemon_list() -> Seq<Seq<char>> {
    seq![
        seq!['v','a','p','o','r','e','o','n'],
        seq!['j','o','l','t','e','o','n'],
        seq!['f','l','a','r','e','o','n'],
        seq!['e','s','p','e','o','n'],
        seq!['u','m','b','r','e','o','n'],
        seq!['l','e','a','f','e','o','n'],
        seq!['g','l','a','c','e','o','n'],
        seq!['s','y','l','v','e','o','n']
    ]
}

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0
    /* Additional validation logic would be implemented here */
}

spec fn is_first_match(result: Seq<char>, pattern: Seq<char>, pokemon_list: Seq<Seq<char>>) -> bool {
    exists|i: int| 0 <= i < pokemon_list.len() && 
        pokemon_list[i] == result &&
        result.len() == pattern.len() &&
        matches_pattern(result, pattern) &&
        forall|j: int| 0 <= j < i ==> (pokemon_list[j].len() != pattern.len() || !matches_pattern(pokemon_list[j], pattern))
}",,"fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires
        valid_input(input@),
    ensures
        valid_pokemon_name(result@),
        is_first_match(result@, input@, get_pokemon_list()),
        exists|i: int| 0 <= i < get_pokemon_list().len() && 
            get_pokemon_list()[i] == result@ &&
            matches_pattern(result@, input@),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0275,verus,apps,apps_test_1310,,"Given an array of n non-negative integers, find the maximum XOR value among all possible 
contiguous subarrays (segments of consecutive elements).","use vstd::prelude::*;

verus! {

spec fn xor_range(arr: Seq<u32>, i: int, j: int) -> u32;

spec fn valid_input(arr: Seq<u32>) -> bool {
    arr.len() > 0
}

spec fn is_max_xor_subarray(arr: Seq<u32>, result: u32) -> bool
    recommends valid_input(arr)
{
    exists|i: int, j: int| 0 <= i <= j < arr.len() && result == xor_range(arr, i, j) &&
    forall|i1: int, j1: int| 0 <= i1 <= j1 < arr.len() ==> 
        (xor_range(arr, i1, j1) as int) <= (result as int)
}",,"fn solve(arr: Vec<u32>) -> (result: u32)
    requires valid_input(arr@)
    ensures is_max_xor_subarray(arr@, result)","{
    assume(false);
    0
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0276,verus,apps,apps_test_1312,,"Distribute n candies among m friends such that each friend receives at least one candy
and the difference between the maximum and minimum number of candies is minimized.
The optimal solution gives each friend either floor(n/m) or floor(n/m)+1 candies.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, m: int) -> bool {
  n >= m > 0
}

spec fn sum(s: Seq<int>) -> int
  decreases s.len()
{
  if s.len() == 0 { 
    0int 
  } else { 
    s[0] + sum(s.subrange(1, s.len() as int)) 
  }
}

spec fn count(s: Seq<int>, val: int) -> int
  decreases s.len()
{
  if s.len() == 0 { 
    0int 
  } else { 
    (if s[0] == val { 1int } else { 0int }) + count(s.subrange(1, s.len() as int), val) 
  }
}

spec fn optimal_distribution(result: Seq<int>, n: int, m: int) -> bool {
  &&& m > 0
  &&& result.len() == m
  &&& (forall|i: int| 0 <= i < result.len() ==> result[i] > 0)
  &&& sum(result) == n
  &&& (forall|i: int| 0 <= i < result.len() ==> result[i] == n / m || result[i] == n / m + 1)
  &&& count(result, n / m) == m - (n % m)
  &&& count(result, n / m + 1) == n % m
}",,"fn solve(n: i8, m: i8) -> (result: Vec<i8>)
  requires valid_input(n as int, m as int)
  ensures optimal_distribution(result@.map(|i: int, x: i8| x as int), n as int, m as int)","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0277,verus,apps,apps_test_1317,,"Given an n×n grid where each cell (i,j) contains (i² + j²) candies, count how many cells have a number of candies divisible by m.","use vstd::prelude::*;

verus! {
spec fn count_cells_divisible_by_m(n: int, m: int) -> int
{
    if 1 <= n && 1 <= m {
        0 /* placeholder for set cardinality */
    } else {
        0
    }
}

spec fn valid_input(n: int, m: int) -> bool {
    1 <= n && 1 <= m && m <= 1000
}",,"fn solve(n: i8, m: i8) -> (result: i8)
  requires 
    valid_input(n as int, m as int),
  ensures 
    result >= 0,
    result as int == count_cells_divisible_by_m(n as int, m as int),","{
    assume(false);
    0
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0279,verus,apps,apps_test_1332,,"Five players each start with the same positive number of coins b. Coins are passed between players.
Given the final coin distribution, determine the initial bet b, or -1 if no such positive b exists.","use vstd::prelude::*;

verus! {
spec fn valid_input(coins: Seq<int>) -> bool {
    coins.len() == 5 && forall|i: int| 0 <= i < coins.len() ==> #[trigger] coins[i] >= 0 && #[trigger] coins[i] <= 100
}

spec fn total_coins(coins: Seq<int>) -> int {
    if coins.len() == 5 { coins[0] + coins[1] + coins[2] + coins[3] + coins[4] } else { 0 }
}

spec fn has_valid_solution(coins: Seq<int>) -> bool {
    if valid_input(coins) {
        let total = total_coins(coins);
        total > 0 && total % 5 == 0
    } else {
        false
    }
}

spec fn compute_result(coins: Seq<int>) -> int {
    if valid_input(coins) {
        let total = total_coins(coins);
        if total > 0 && total % 5 == 0 { total / 5 } else { -1 }
    } else {
        -1
    }
}",,"fn solve(coins: Vec<i8>) -> (result: i8)
    requires
        valid_input(coins@.map(|i, x| x as int)),
    ensures
        result as int == compute_result(coins@.map(|i, x| x as int)),
        has_valid_solution(coins@.map(|i, x| x as int)) ==> result as int == total_coins(coins@.map(|i, x| x as int)) / 5,
        !has_valid_solution(coins@.map(|i, x| x as int)) ==> result as int == -1,","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0282,verus,apps,apps_test_1353,,"Find the minimum cost for Ann to make exactly n subway rides, given two ticket options:
single-ride tickets (cost a rubles each) and multi-ride tickets (cost b rubles, covers m rides).
Ann can buy any combination of these tickets.

/* All single tickets */

/* All multi-ride tickets (with potential waste) */

/* Mixed: multi-ride + single for remainder */","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, m: int, a: int, b: int) -> bool {
    n >= 1 && n <= 1000 &&
    m >= 1 && m <= 1000 &&
    a >= 1 && a <= 1000 &&
    b >= 1 && b <= 1000
}

spec fn optimal_cost(n: int, m: int, a: int, b: int) -> int
    recommends valid_input(n, m, a, b)
{
    if n * a <= ((n + m - 1) / m) * b {
        if n * a <= (n / m) * b + (n % m) * a {
            n * a
        } else {
            (n / m) * b + (n % m) * a
        }
    } else {
        if ((n + m - 1) / m) * b <= (n / m) * b + (n % m) * a {
            ((n + m - 1) / m) * b
        } else {
            (n / m) * b + (n % m) * a
        }
    }
}",,"fn solve(n: i8, m: i8, a: i8, b: i8) -> (result: i8)
    requires 
        valid_input(n as int, m as int, a as int, b as int),
    ensures 
        result >= 0,
        result as int == optimal_cost(n as int, m as int, a as int, b as int),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0284,verus,apps,apps_test_1356,,"Given a string of lowercase English letters containing at least one 'a',
find the maximum length of a string obtainable by erasing some characters
such that the resulting string has strictly more than half of its characters as 'a's.","use vstd::prelude::*;

verus! {
spec fn count_a(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0 as int
    } else {
        (if s[0] == 'a' { 1 as int } else { 0 as int }) + count_a(s.subrange(1, s.len() as int))
    }
}

spec fn min(a: int, b: int) -> int {
    if a <= b { a } else { b }
}

spec fn valid_input(s: Seq<char>) -> bool {
    s.len() >= 1 && exists|i: int| 0 <= i < s.len() && s[i] == 'a'
}

spec fn is_good_string(s: Seq<char>) -> bool {
    s.len() > 0 && count_a(s) > s.len() as int / 2
}",,"fn solve(s: Vec<char>) -> (result: usize)
    requires 
        valid_input(s@),
    ensures 
        result >= 1,
        result <= s.len(),
        result == min(2 * count_a(s@) - 1, s.len() as int) as usize,","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0285,verus,apps,apps_test_1357,,"Given n houses numbered 1 to n arranged in a clockwise ring with one-way clockwise traffic,
find the minimum time to complete m tasks in sequence. Each task must be completed at a 
specific house. Starting at house 1, moving from one house to the next adjacent house takes 
1 time unit. Tasks must be completed in the given order.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, m: int, tasks: Seq<int>) -> bool {
    n >= 2 && m >= 1 && tasks.len() == m && 
    forall|i: int| 0 <= i < tasks.len() ==> 1 <= #[trigger] tasks[i] <= n
}

spec fn min_time_to_complete(n: int, tasks: Seq<int>, current_pos: int, task_index: int) -> int
    recommends 
        n >= 2,
        forall|i: int| 0 <= i < tasks.len() ==> 1 <= #[trigger] tasks[i] <= n,
        1 <= current_pos <= n,
        0 <= task_index < tasks.len()
{
    let target = tasks[task_index];
    if target >= current_pos { target - current_pos }
    else { (n - current_pos) + target }
}",,"fn solve(n: i8, m: i8, tasks: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, m as int, tasks@.map(|i, x: i8| x as int))
    ensures 
        result >= 0,
        m > 0 ==> result >= tasks@[(m as int) - 1] as int - 1,
        result <= ((m as int) - 1) * (n as int) + tasks@[(m as int) - 1] as int - 1,","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0286,verus,apps,apps_test_1361,,"Given n holds at increasing heights, remove exactly one hold (not the first or last) 
to minimize the track difficulty. The difficulty is the maximum difference between 
consecutive hold heights.","use vstd::prelude::*;

verus! {

spec fn valid_input(holds: Seq<int>) -> bool {
    holds.len() >= 3 && forall|i: int| 0 <= i < holds.len() - 1 ==> #[trigger] holds[i] < holds[i + 1]
}

spec fn max_diff(s: Seq<int>) -> int {
    if s.len() <= 1 { 0 }
    else {
        let max_so_far = if s[1] - s[0] >= 0 { s[1] - s[0] } else { 0 };
        max_diff_helper(s, 2, max_so_far)
    }
}

spec fn max_diff_helper(s: Seq<int>, index: int, current_max: int) -> int
    decreases s.len() - index
{
    if index >= s.len() { current_max }
    else {
        let diff = s[index] - s[index - 1];
        let new_max = if diff > current_max { diff } else { current_max };
        max_diff_helper(s, index + 1, new_max)
    }
}",,"fn solve(holds: Vec<i8>) -> (result: i8)
    requires valid_input(holds@.map(|i, x: i8| x as int))
    ensures result as int >= 0","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0287,verus,apps,apps_test_1381,,"Given k people who each want to make n paper airplanes, where s airplanes can be made from one sheet of paper,
and paper is sold in packs of p sheets each, find the minimum number of packs needed to buy so that each person
has enough sheets to make their n airplanes.","use vstd::prelude::*;

verus! {
spec fn valid_input(k: int, n: int, s: int, p: int) -> bool {
  k >= 1 && n >= 1 && s >= 1 && p >= 1 &&
  k <= 10000 && n <= 10000 && s <= 10000 && p <= 10000
}

spec fn sheets_per_person(n: int, s: int) -> int
  recommends s >= 1
{
  (n + s - 1) / s
}

spec fn total_sheets_needed(k: int, n: int, s: int) -> int
  recommends s >= 1
{
  k * sheets_per_person(n, s)
}

spec fn min_packs_needed(k: int, n: int, s: int, p: int) -> int
  recommends s >= 1 && p >= 1
{
  (total_sheets_needed(k, n, s) + p - 1) / p
}

spec fn correct_result(result: int, k: int, n: int, s: int, p: int) -> bool
  recommends s >= 1 && p >= 1
{
  result == min_packs_needed(k, n, s, p) &&
  result * p >= total_sheets_needed(k, n, s) &&
  (result - 1) * p < total_sheets_needed(k, n, s)
}",,"fn solve(k: i32, n: i32, s: i32, p: i32) -> (result: i32)
  requires
    valid_input(k as int, n as int, s as int, p as int),
  ensures
    result >= 1,
    correct_result(result as int, k as int, n as int, s as int, p as int),","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0289,verus,apps,apps_test_1394,,"Given a string t, find a string s such that when you create s' by removing all 'a' 
characters from s (keeping other characters in order) and concatenate s and s' to 
form t = s + s', output the unique string s if it exists, otherwise output "":("".","use vstd::prelude::*;

verus! {
    spec fn count_as(s: Seq<char>) -> int
        decreases s.len()
    {
        if s.len() == 0 {
            0
        } else if s[0] == 'a' {
            1 + count_as(s.subrange(1, s.len() as int))
        } else {
            count_as(s.subrange(1, s.len() as int))
        }
    }
    
    spec fn remove_as(s: Seq<char>) -> Seq<char>
        decreases s.len()
    {
        if s.len() == 0 {
            seq![]
        } else if s[0] == 'a' {
            remove_as(s.subrange(1, s.len() as int))
        } else {
            seq![s[0]].add(remove_as(s.subrange(1, s.len() as int)))
        }
    }",,"fn solve(t: Vec<char>) -> (result: Vec<char>)
    requires t@.len() >= 1","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0290,verus,apps,apps_test_1395,,"Given a positive integer represented as a string and a divisor m, find the minimum remainder 
when dividing any valid cyclic shift of the integer by m. A cyclic shift is valid if it 
doesn't have leading zeros when interpreted as an integer.","use vstd::prelude::*;

verus! {

spec fn valid_input(stdin_input: Seq<char>) -> bool {
    stdin_input.len() > 0 && exists|pos: int| 0 <= pos < stdin_input.len() && stdin_input[pos] == '\n'
}

spec fn valid_digit_string(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> ('0' <= #[trigger] s[i] <= '9')
}

spec fn valid_number_string(s: Seq<char>) -> bool {
    valid_digit_string(s) && s[0] != '0'
}

spec fn valid_output(result: Seq<char>) -> bool {
    result.len() > 0 && forall|i: int| 0 <= i < result.len() ==> ('0' <= #[trigger] result[i] <= '9')
}

spec fn is_good_shift(s: Seq<char>, shift: int) -> bool 
    recommends 0 <= shift < s.len(), s.len() > 0
{
    s[shift] != '0'
}

spec fn cyclic_shift_remainder(s: Seq<char>, shift: int, m: int) -> int
    recommends 
        0 <= shift < s.len(),
        s.len() > 0,
        m >= 2,
        valid_digit_string(s)
{
    cyclic_shift_remainder_helper(s, shift, m, 0, 0)
}

spec fn cyclic_shift_remainder_helper(s: Seq<char>, shift: int, m: int, pos: int, acc: int) -> int
    recommends 
        0 <= shift < s.len(),
        s.len() > 0,
        m >= 2,
        0 <= pos <= s.len(),
        0 <= acc < m,
        valid_digit_string(s)
    decreases (s.len() - pos) when 0 <= pos <= s.len()
{
    if pos == s.len() { 
        acc 
    } else {
        let idx = (shift + pos) % (s.len() as int);
        let digit = (s[idx] as int) - ('0' as int);
        let new_acc = (acc * 10 + digit) % m;
        cyclic_shift_remainder_helper(s, shift, m, pos + 1, new_acc)
    }
}",,"fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(stdin_input@)
    ensures valid_output(result@)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0291,verus,apps,apps_test_1409,,"Given n students where each student has participated in ACM ICPC championship y_i times (0 ≤ y_i ≤ 5),
form the maximum number of teams such that: each team has exactly 3 students, no student can be on 
multiple teams, and each team can participate together at least k more times (since each student can 
participate at most 5 times total). Find the maximum number of teams that can be formed.","use vstd::prelude::*;

verus! {
spec fn count_eligible(participations: Seq<int>, k: int) -> int
    decreases participations.len()
{
    if participations.len() == 0 {
        0 as int
    } else {
        (if 5 - participations[0] >= k { 1 as int } else { 0 as int }) + count_eligible(participations.subrange(1, participations.len() as int), k)
    }
}",,"fn solve(n: u8, k: u8, participations: Vec<u8>) -> (result: u8)","{
    assume(false);
    0
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0292,verus,apps,apps_test_1419,,"Given a text containing words separated by spaces, where some words contain hyphens
that serve as valid line break points, format the text to fit within at most k lines
while minimizing the maximum line width. Line breaks can occur at spaces (space stays
on current line) or at hyphens (hyphen stays on current line, remainder goes to next line).

/* Potential break point */

/* Must break line */

/* Can continue on current line or break */

/* Regular character - must continue on current line */","use vstd::prelude::*;

verus! {
spec fn can_format_text(s: Seq<char>, k: int, max_width: int) -> bool
    recommends k >= 1 && s.len() >= 1 && max_width >= 1
{
    check_formatting(s, k, max_width, 0, 1, 0)
}

spec fn check_formatting(s: Seq<char>, k: int, max_width: int, pos: int, lines: int, current_line: int) -> bool
    recommends k >= 1 && s.len() >= 1 && max_width >= 1 && 0 <= pos <= s.len() && lines >= 1 && current_line >= 0
    decreases s.len() - pos when 0 <= pos <= s.len()
{
    if pos == s.len() {
        lines <= k && current_line <= max_width
    } else {
        if s[pos] == ' ' || s[pos] == '-' {
            /* Potential break point */
            if current_line + 1 > max_width {
                /* Must break line */
                if lines + 1 > k {
                    false
                } else {
                    check_formatting(s, k, max_width, pos + 1, lines + 1, 1)
                }
            } else {
                /* Can continue on current line or break */
                (check_formatting(s, k, max_width, pos + 1, lines, current_line + 1) ||
                 (lines < k && check_formatting(s, k, max_width, pos + 1, lines + 1, 1)))
            }
        } else {
            /* Regular character - must continue on current line */
            if current_line + 1 > max_width {
                false
            } else {
                check_formatting(s, k, max_width, pos + 1, lines, current_line + 1)
            }
        }
    }
}",,"fn solve(k: i8, s: Vec<char>) -> (result: i8)
    requires k >= 1,
            s.len() >= 1,
    ensures result >= 1,
            result <= s@.len(),
            can_format_text(s@, k as int, result as int),
            result > 1 ==> !can_format_text(s@, k as int, (result - 1) as int),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0293,verus,apps,apps_test_1430,,"Given a binary string S of length N and an integer K, find the maximum length of 
consecutive '1's achievable using at most K flip operations. Each flip operation 
chooses a contiguous range and flips all bits in that range (0→1, 1→0).","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, k: int, s: Seq<char>) -> bool {
    n > 0 && k >= 0 && s.len() == n && 
    forall|i: int| 0 <= i < s.len() ==> (#[trigger] s[i]) == '0' || s[i] == '1'
}

spec fn string_to_bits(s: Seq<char>) -> Seq<int>
    recommends forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
{
    Seq::new(s.len(), |i: int| if s[i] == '0' { 0 } else { 1 })
}

spec fn valid_result(result: int, n: int) -> bool {
    0 <= result <= n
}",,"fn solve(n: i8, k: i8, s: Vec<char>) -> (result: i8)
    requires valid_input(n as int, k as int, s@)
    ensures valid_result(result as int, n as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0295,verus,apps,apps_test_1451,,"Given n positive integers and a threshold k, count how many integers contain at most k lucky digits.
Lucky digits are 4 and 7.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, k: int, numbers: Seq<int>) -> bool {
    n >= 1 && k >= 0 && numbers.len() == n && forall|i: int| 0 <= i < numbers.len() ==> numbers[i] > 0
}

spec fn count_lucky_digits(num: int) -> int
    decreases num when num >= 0
{
    if num <= 0 { 0 }
    else {
        let digit = num % 10;
        let rest = num / 10;
        let digit_count: int = if digit == 4 || digit == 7 { 1 } else { 0 };
        digit_count + count_lucky_digits(rest)
    }
}

spec fn count_valid_numbers(numbers: Seq<int>, k: int, up_to: int) -> int
    decreases up_to when up_to >= 0
{
    if up_to <= 0 { 0 }
    else {
        let prev_count = count_valid_numbers(numbers, k, up_to - 1);
        if count_lucky_digits(numbers[up_to - 1]) <= k { prev_count + 1 } else { prev_count }
    }
}",,"fn solve(n: i8, k: i8, numbers: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, k as int, numbers@.map(|i: int, x: i8| x as int))
    ensures 0 <= result as int <= n as int","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0296,verus,apps,apps_test_1461,,"Given a functional directed graph where each vertex i has exactly one outgoing edge
to vertex f[i] with weight w[i], find for each starting vertex the sum and minimum
weight of all edges on a path of exactly k edges.","use vstd::prelude::*;

verus! {

spec fn valid_graph(n: int, f: Seq<int>, w: Seq<int>) -> bool {
  n > 0 && f.len() == n && w.len() == n &&
  (forall|i: int| #![trigger f[i]] 0 <= i < n ==> 0 <= f[i] < n) &&
  (forall|i: int| #![trigger w[i]] 0 <= i < n ==> w[i] >= 0)
}

spec fn valid_result(n: int, sums: Seq<int>, mins: Seq<int>) -> bool {
  sums.len() == n && mins.len() == n &&
  forall|i: int| #![trigger sums[i], mins[i]] 0 <= i < n ==> sums[i] >= 0 && mins[i] >= 0
}

spec fn path_sum(start: int, k: int, f: Seq<int>, w: Seq<int>) -> int
  decreases k
{
  if k <= 0 { 0 }
  else { w[start] + path_sum(f[start], k - 1, f, w) }
}

spec fn path_min(start: int, k: int, f: Seq<int>, w: Seq<int>) -> int
  decreases k
{
  if k <= 1 { w[start] }
  else {
    let next_min = path_min(f[start], k - 1, f, w);
    if w[start] <= next_min { w[start] } else { next_min }
  }
}",,"fn solve_graph(n: i8, k: i8, f: Vec<i8>, w: Vec<i8>) -> (result: (Vec<i8>, Vec<i8>))
  requires 
    valid_graph(n as int, f@.map_values(|x: i8| x as int), w@.map_values(|x: i8| x as int)),
    k > 0
  ensures valid_result(n as int, result.0@.map_values(|x: i8| x as int), result.1@.map_values(|x: i8| x as int))","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0297,verus,apps,apps_test_1486,,"Given n cities located on a coordinate axis with positions in ascending order,
calculate for each city the minimum and maximum cost to send a letter to any other city.
The cost equals the distance between cities.","use vstd::prelude::*;

verus! {
spec fn valid_input(cities: Seq<int>) -> bool {
  cities.len() >= 2 &&
  forall|i: int, j: int| 0 <= i < j < cities.len() ==> cities[i] < cities[j]
}

spec fn min_distance(cities: Seq<int>, i: int) -> int 
  recommends
    valid_input(cities),
    0 <= i < cities.len()
{
  if i == 0 {
    cities[1] - cities[0]
  } else if i == cities.len() - 1 {
    cities[i] - cities[i-1]
  } else {
    let left_dist = cities[i] - cities[i-1];
    let right_dist = cities[i+1] - cities[i];
    if left_dist <= right_dist { left_dist } else { right_dist }
  }
}

spec fn max_distance(cities: Seq<int>, i: int) -> int 
  recommends
    valid_input(cities),
    0 <= i < cities.len()
{
  if i == 0 {
    cities[cities.len()-1] - cities[0]
  } else if i == cities.len() - 1 {
    cities[i] - cities[0]
  } else {
    let dist_to_first = cities[i] - cities[0];
    let dist_to_last = cities[cities.len()-1] - cities[i];
    if dist_to_first >= dist_to_last { dist_to_first } else { dist_to_last }
  }
}

spec fn valid_output(cities: Seq<int>, min_distances: Seq<int>, max_distances: Seq<int>) -> bool {
  valid_input(cities) &&
  min_distances.len() == cities.len() &&
  max_distances.len() == cities.len() &&
  forall|i: int| 0 <= i < cities.len() ==> 
    min_distances[i] == min_distance(cities, i) &&
    max_distances[i] == max_distance(cities, i) &&
    min_distances[i] > 0 &&
    max_distances[i] > 0
}",,"fn calculate_distances(cities: Vec<i8>) -> (result: (Vec<i8>, Vec<i8>))
  requires valid_input(cities@.map(|i, v: i8| v as int))
  ensures valid_output(cities@.map(|i, v: i8| v as int), result.0@.map(|i, v: i8| v as int), result.1@.map(|i, v: i8| v as int))","{
  // impl-start
  assume(false);
  unreached()
  // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0299,verus,apps,apps_test_1526,,"Given three integers A, B, and C, find the minimum number of operations to make all three equal.
Operations: (1) Choose any two numbers and increase both by 1, (2) Choose any one number and increase it by 2.","use vstd::prelude::*;

verus! {

spec fn valid_input(a: int, b: int, c: int) -> bool {
    0 <= a <= 50 && 0 <= b <= 50 && 0 <= c <= 50
}

spec fn max_of_3(a: int, b: int, c: int) -> int {
    if a >= b && a >= c { a }
    else if b >= c { b }
    else { c }
}

spec fn sort_descending(a: int, b: int, c: int) -> (int, int, int) {
    if a >= b && a >= c {
        if b >= c { (a, b, c) } else { (a, c, b) }
    } else if b >= a && b >= c {
        if a >= c { (b, a, c) } else { (b, c, a) }
    } else {
        if a >= b { (c, a, b) } else { (c, b, a) }
    }
}

spec fn min_operations(a: int, b: int, c: int) -> int
    recommends valid_input(a, b, c)
{
    let (a0, a1, a2) = sort_descending(a, b, c);
    let gap1 = a0 - a1;
    let updated_smallest = a2 + gap1;
    let remaining_gap = a0 - updated_smallest;
    gap1 + remaining_gap / 2 + (remaining_gap % 2) * 2
}

spec fn all_equal(a: int, b: int, c: int) -> bool {
    a == b && b == c
}",,"fn solve(a: i8, b: i8, c: i8) -> (result: i8)
    requires
        valid_input(a as int, b as int, c as int),
    ensures
        result >= 0,
        all_equal(a as int, b as int, c as int) ==> result == 0,
        result as int == min_operations(a as int, b as int, c as int),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0300,verus,apps,apps_test_1529,,"Given n sentences from a chat record, determine the speaker of each sentence based on these patterns:
- Freda always ends her sentences with ""lala.""
- Rainbow always begins his sentences with ""miao.""
For each sentence, classify it as spoken by Freda, Rainbow, or unknown if it's ambiguous or matches neither pattern.","use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() >= 0
}

spec fn split_lines_func(input: Seq<char>) -> Seq<Seq<char>> {
    if input.len() == 0 {
        seq![]
    } else {
        split_lines_helper(input, 0, seq![], seq![])
    }
}

spec fn split_lines_helper(input: Seq<char>, i: int, current: Seq<char>, acc: Seq<Seq<char>>) -> Seq<Seq<char>>
    decreases input.len() - i when 0 <= i <= input.len()
{
    if i == input.len() {
        if current.len() > 0 { acc.push(current) } else { acc }
    } else if i < input.len() && input[i] == '\n' {
        split_lines_helper(input, i + 1, seq![], acc.push(current))
    } else if i < input.len() {
        split_lines_helper(input, i + 1, current.push(input[i]), acc)
    } else {
        acc
    }
}

spec fn parse_int_func(s: Seq<char>) -> int {
    if s.len() == 0 {
        0
    } else {
        parse_int_helper(s, 0, 0)
    }
}

spec fn parse_int_helper(s: Seq<char>, i: int, acc: int) -> int
    decreases s.len() - i when 0 <= i <= s.len()
{
    if i == s.len() {
        acc
    } else if i < s.len() && '0' <= s[i] <= '9' {
        parse_int_helper(s, i + 1, acc * 10 + (s[i] as int - '0' as int))
    } else {
        acc
    }
}

spec fn build_output_func(lines: Seq<Seq<char>>, n: int) -> Seq<char>
    decreases n when n >= 0
{
    if n == 0 {
        seq![]
    } else if n == 1 && 1 < lines.len() {
        classify_sentence_func(lines[1])
    } else if n > 1 && n < lines.len() {
        build_output_func(lines, n-1) + seq!['\n'] + classify_sentence_func(lines[n])
    } else {
        seq![]
    }
}

spec fn classify_sentence_func(sentence: Seq<char>) -> Seq<char> {
    if ends_with_func(sentence, seq!['l', 'a', 'l', 'a', '.']) && !starts_with_func(sentence, seq!['m', 'i', 'a', 'o', '.']) {
        seq!['F', 'r', 'e', 'd', 'a', '\'', 's']
    } else if starts_with_func(sentence, seq!['m', 'i', 'a', 'o', '.']) && !ends_with_func(sentence, seq!['l', 'a', 'l', 'a', '.']) {
        seq!['R', 'a', 'i', 'n', 'b', 'o', 'w', '\'', 's']
    } else {
        seq!['O', 'M', 'G', '>', '.', '<', ' ', 'I', ' ', 'd', 'o', 'n', '\'', 't', ' ', 'k', 'n', 'o', 'w', '!']
    }
}

spec fn starts_with_func(s: Seq<char>, prefix: Seq<char>) -> bool {
    prefix.len() <= s.len() && (forall|i: int| 0 <= i < prefix.len() ==> s[i] == prefix[i])
}

spec fn ends_with_func(s: Seq<char>, suffix: Seq<char>) -> bool {
    suffix.len() <= s.len() && (forall|i: int| 0 <= i < suffix.len() ==> s[s.len() - suffix.len() + i] == suffix[i])
}

spec fn min(a: int, b: int) -> int {
    if a <= b { a } else { b }
}",,"fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(input@)
    ensures result@.len() >= 0","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0301,verus,apps,apps_test_1533,,"Given a sequence of names, for each position i, determine if that same name
appeared at any earlier position j < i in the sequence.","use vstd::prelude::*;

verus! {
spec fn valid_output(names: Seq<&str>, output: Seq<&str>) -> bool {
    output.len() == names.len() &&
    forall|i: int| 0 <= i < names.len() ==> 
        output[i] == (if exists|j: int| 0 <= j < i && names[j] == names[i] { ""YES"" } else { ""NO"" })
}",,"fn solve(names: Vec<&str>) -> (output: Vec<&str>)
    ensures valid_output(names@, output@)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0302,verus,apps,apps_test_1541,,"Given a string representing a lever with weights and a pivot, determine if the lever
tilts left, right, or remains balanced based on torque calculations.
The pivot is marked by '^', weights are digits 1-9, and empty positions are '='.
Torque = weight × distance from pivot. Left weights contribute positive torque,
right weights contribute negative torque.","use vstd::prelude::*;

verus! {
    spec fn valid_lever_input(s: Seq<char>) -> bool {
        s.len() >= 3 &&
        (exists|i: int| 0 <= i < s.len() && s[i] == '^') &&
        (forall|i: int| 0 <= i < s.len() ==> (s[i] == '^' || s[i] == '=' || ('1' <= s[i] <= '9'))) &&
        (forall|i: int, j: int| 0 <= i < j < s.len() && s[i] == '^' ==> s[j] != '^') &&
        (forall|i: int| 0 <= i < s.len() && s[i] == '^' ==> (i != 0 && i != s.len() - 1))
    }
    
    spec fn find_pivot(s: Seq<char>) -> int {
        find_pivot_helper(s, 0)
    }
    
    spec fn find_pivot_helper(s: Seq<char>, index: int) -> int
        decreases s.len() - index
    {
        if index >= s.len() {
            0
        } else if s[index] == '^' {
            index
        } else {
            find_pivot_helper(s, index + 1)
        }
    }
    
    spec fn calculate_torque(s: Seq<char>, pivot_pos: int) -> int {
        calculate_torque_helper(s, pivot_pos, 0)
    }
    
    spec fn calculate_torque_helper(s: Seq<char>, pivot_pos: int, index: int) -> int
        decreases s.len() - index
    {
        if index >= s.len() {
            0
        } else if '1' <= s[index] <= '9' {
            let weight = (s[index] as int) - ('0' as int);
            (pivot_pos - index) * weight + calculate_torque_helper(s, pivot_pos, index + 1)
        } else {
            calculate_torque_helper(s, pivot_pos, index + 1)
        }
    }
    
    spec fn calculate_torque_partial(s: Seq<char>, pivot_pos: int, up_to: int) -> int {
        calculate_torque_helper(s, pivot_pos, 0) - calculate_torque_helper(s, pivot_pos, up_to)
    }",,"fn solve(s: Vec<char>) -> (result: Vec<char>)
    requires valid_lever_input(s@)
    ensures result@ == seq!['l', 'e', 'f', 't'] || result@ == seq!['r', 'i', 'g', 'h', 't'] || result@ == seq!['b', 'a', 'l', 'a', 'n', 'c', 'e']","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0304,verus,apps,apps_test_1550,,"Given a combination lock display with n digits, find the smallest possible number 
achievable using two operations: (1) Add 1 to all digits (9 wraps to 0), and 
(2) Shift all digits one position right (rightmost digit becomes leftmost).
Leading zeros are ignored when comparing numbers for size.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, digits: Seq<char>) -> bool {
    n > 0 && digits.len() == n && forall|i: int| 0 <= i < digits.len() ==> #[trigger] digits[i] >= '0' && #[trigger] digits[i] <= '9'
}

spec fn modify_string(s: Seq<char>, index: int) -> Seq<char> {
    let key = if s[index] == '0' { 0 } else { 10 - (s[index] as int - '0' as int) };
    let transformed = transform_digits(s, key);
    rotate_string(transformed, index)
}

spec fn transform_digits(s: Seq<char>, key: int) -> Seq<char>
    decreases s.len()
{
    if s.len() == 0 {
        seq![]
    } else {
        let digit = (s[0] as int - '0' as int + key) % 10;
        seq![('0' as int + digit) as char].add(transform_digits(s.skip(1), key))
    }
}

spec fn rotate_string(s: Seq<char>, index: int) -> Seq<char> {
    if s.len() == 0 {
        seq![]
    } else {
        s.skip(index).add(s.take(index))
    }
}

spec fn is_all_digits(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9'
}

spec fn parse_input(input: Seq<char>) -> Seq<Seq<char>>
    decreases input.len()
{
    parse_input_helper(input, 0, seq![], seq![])
}

spec fn parse_input_helper(input: Seq<char>, i: int, current_line: Seq<char>, lines: Seq<Seq<char>>) -> Seq<Seq<char>>
    decreases input.len() - i
{
    if i >= input.len() {
        if current_line.len() > 0 { lines.push(current_line) } else { lines }
    } else if input[i] == '\n' {
        parse_input_helper(input, i + 1, seq![], lines.push(current_line))
    } else {
        parse_input_helper(input, i + 1, current_line.push(input[i]), lines)
    }
}

spec fn parse_int(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if !('0' <= s[0] <= '9') {
        0
    } else {
        (s[0] as int - '0' as int) + 10 * parse_int(s.skip(1))
    }
}

spec fn string_to_int(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if !('0' <= s[0] <= '9') {
        string_to_int(s.skip(1))
    } else {
        (s[0] as int - '0' as int) * pow(10, (s.len() - 1) as nat) + string_to_int(s.skip(1))
    }
}

spec fn pow(base: int, exp: nat) -> int
    decreases exp
{
    if exp == 0 {
        1
    } else {
        base * pow(base, (exp - 1) as nat)
    }
}",,"fn solve(stdin_input: String) -> (result: String)
    requires
        stdin_input@.len() > 0,
        (exists|i: int| 0 <= i < stdin_input@.len() && stdin_input@[i] == '\n'),
    ensures
        result@.len() > 0,
        result@[result@.len() - 1] == '\n',
        ({
            let lines = parse_input(stdin_input@);
            if lines.len() >= 2 {
                let n = parse_int(lines[0]);
                let digits = lines[1];
                if valid_input(n, digits) {
                    let min_result = result@.take(result@.len() - 1);
                    min_result.len() == n &&
                    (forall|i: int| 0 <= i < min_result.len() ==> #[trigger] min_result[i] >= '0' && #[trigger] min_result[i] <= '9') &&
                    (exists|index: int| 0 <= index < n && min_result == modify_string(digits, index)) &&
                    (forall|index: int| 0 <= index < n ==> string_to_int(min_result) <= string_to_int(modify_string(digits, index)))
                } else {
                    result@ == seq!['\n']
                }
            } else {
                result@ == seq!['\n']
            }
        })","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0305,verus,apps,apps_test_1568,,"Given n messages arriving at specified times, determine the maximum money achievable by time T.
Each message has initial value A that decreases by B per minute after arrival.
Earn C per unread message per minute. All messages must be read by time T.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, a: int, b: int, c: int, t: int, arrivals: Seq<int>) -> bool {
    1 <= n <= 1000 &&
    1 <= a <= 1000 &&
    1 <= b <= 1000 &&
    1 <= c <= 1000 &&
    1 <= t <= 1000 &&
    arrivals.len() == n &&
    forall|i: int| 0 <= i < arrivals.len() ==> #[trigger] arrivals[i] >= 1 && #[trigger] arrivals[i] <= t
}

spec fn sum_seq(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0int
    } else {
        s[0] + sum_seq(s.subrange(1, s.len() as int))
    }
}

spec fn max_money(n: int, a: int, b: int, c: int, t: int, arrivals: Seq<int>) -> int {
    if b > c {
        n * a
    } else {
        n * a + (c - b) * (n * t - sum_seq(arrivals))
    }
}",,"fn solve(n: i8, a: i8, b: i8, c: i8, t: i8, arrivals: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, a as int, b as int, c as int, t as int, arrivals@.map_values(|x: i8| x as int))
    ensures result as int == max_money(n as int, a as int, b as int, c as int, t as int, arrivals@.map_values(|x: i8| x as int))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0306,verus,apps,apps_test_1576,,"Decrypt a string that was encrypted using the Right-Left cipher.
The Right-Left cipher encrypts by starting with the first character,
then alternating between appending to the right (even positions) and
prepending to the left (odd positions) for subsequent characters.","use vstd::prelude::*;

verus! {
spec fn valid_input(t: Seq<char>) -> bool {
    t.len() >= 1
}",,"fn solve(t: Vec<char>) -> (result: Vec<char>)
    requires valid_input(t@)
    ensures result@.len() == t@.len()","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0307,verus,apps,apps_test_1577,,"Given a string input containing two lines: an integer n and a string s of length n with only 'A' and 'D' characters,
determine which character appears more frequently. Return ""Anton"" if 'A' appears more, ""Danik"" if 'D' appears more,
or ""Friendship"" if they appear equally.","use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 && exists|newline_pos: int| 0 <= newline_pos < input.len() && input[newline_pos] == '\n'
}

spec fn valid_parsed_input(lines: Seq<Seq<char>>) -> bool {
    lines.len() >= 2 && is_valid_integer(lines[0]) && is_valid_game_string(lines[1]) &&
    {
        let n = string_to_int(lines[0]);
        let s = lines[1];
        s.len() == n && n >= 1
    }
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> s[i] >= '0' && s[i] <= '9'
}

spec fn is_valid_game_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> s[i] == 'A' || s[i] == 'D'
}

spec fn count_char(s: Seq<char>, c: char) -> int 
    decreases s.len()
{
    if s.len() == 0 {
        0int
    } else {
        (if s[0] == c { 1int } else { 0int }) + count_char(s.subrange(1, s.len() as int), c)
    }
}

spec fn determine_winner(count_a: int, count_d: int) -> Seq<char> {
    if count_a > count_d {
        seq!['A', 'n', 't', 'o', 'n']
    } else if count_d > count_a {
        seq!['D', 'a', 'n', 'i', 'k']
    } else {
        seq!['F', 'r', 'i', 'e', 'n', 'd', 's', 'h', 'i', 'p']
    }
}

spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>>;

spec fn string_to_int(s: Seq<char>) -> int;",,"fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires 
        valid_input(input@) &&
        valid_parsed_input(split_lines(input@))
    ensures 
        result@ == seq!['A', 'n', 't', 'o', 'n'] || 
        result@ == seq!['D', 'a', 'n', 'i', 'k'] || 
        result@ == seq!['F', 'r', 'i', 'e', 'n', 'd', 's', 'h', 'i', 'p'] &&
        result@ == {
            let lines = split_lines(input@);
            let s = lines[1];
            let count_a = count_char(s, 'A');
            let count_d = count_char(s, 'D');
            determine_winner(count_a, count_d)
        }","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0308,verus,apps,apps_test_1578,,"Given an integer N, find a permutation P₁, P₂, ..., Pₙ of numbers 1 to N
that maximizes the sum M₁ + M₂ + ... + Mₙ, where Mᵢ is the remainder when i is divided by Pᵢ.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int) -> bool {
    n >= 1
}

spec fn max_sum(n: int) -> int
    recommends n >= 1
{
    n * (n - 1) / 2
}",,"fn solve(n: i8) -> (result: i8)
    requires valid_input(n as int)
    ensures result as int == max_sum(n as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0310,verus,apps,apps_test_1594,,"Given a playlist of n songs where song i has duration t_i minutes and is played c_i consecutive times.
The playlist plays songs in order: song 1 (c_1 times), then song 2 (c_2 times), etc.
For m given time moments, determine which song number is playing at each moment.","use vstd::prelude::*;

verus! {
spec fn sum_playlist_duration(songs: Seq<(int, int)>, n: int) -> int
  recommends 
    n >= 0,
    songs.len() >= n,
    forall|i: int| #![auto] 0 <= i < n ==> songs[i].0 > 0 && songs[i].1 > 0
  decreases n
  when n >= 0 && songs.len() >= n
{
  if n == 0 { 
    0 
  } else { 
    songs[n-1].0 * songs[n-1].1 + sum_playlist_duration(songs, n-1) 
  }
}

spec fn cumulative_duration_at_song(songs: Seq<(int, int)>, song_idx: int) -> int
  recommends 
    song_idx >= -1,
    songs.len() > song_idx,
    forall|i: int| #![auto] 0 <= i <= song_idx ==> songs[i].0 > 0 && songs[i].1 > 0
  decreases song_idx + 1
  when song_idx >= -1 && songs.len() > song_idx
{
  if song_idx == -1 { 
    0 
  } else { 
    songs[song_idx].0 * songs[song_idx].1 + cumulative_duration_at_song(songs, song_idx - 1) 
  }
}",,"fn solve(n: i8, m: i8, songs: Vec<(i8, i8)>, queries: Vec<i8>) -> (result: Vec<i8>)
  requires 
    n >= 0,
    m >= 0,
    songs.len() == n as nat,
    queries.len() == m as nat,
    forall|i: int| #![trigger songs[i]] 0 <= i < n as int ==> songs[i].0 > 0 && songs[i].1 > 0,
    forall|i: int| #![trigger queries[i]] 0 <= i < m as int - 1 ==> queries[i] < queries[i + 1],
    forall|i: int| #![trigger queries[i]] 0 <= i < m as int ==> queries[i] >= 1,
    m == 0 || queries[(m-1) as int] as int <= sum_playlist_duration(songs@.map(|i: int, p: (i8, i8)| (p.0 as int, p.1 as int)), n as int)
  ensures 
    result.len() == m as nat,
    forall|i: int| #![trigger result[i]] 0 <= i < m as int ==> 1 <= result[i] as int <= n as int,
    forall|i: int| #![trigger result[i]] 0 <= i < m as int ==> queries[i] as int <= cumulative_duration_at_song(songs@.map(|i: int, p: (i8, i8)| (p.0 as int, p.1 as int)), result[i] as int - 1),
    forall|i: int| #![trigger result[i]] 0 <= i < m as int ==> result[i] as int == 1 || queries[i] as int > cumulative_duration_at_song(songs@.map(|i: int, p: (i8, i8)| (p.0 as int, p.1 as int)), result[i] as int - 2)","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0311,verus,apps,apps_test_1598,,"Given a binary string s, find a binary string t of the same length such that
for every substring s[l..r] and t[l..r], they have the same length of longest
non-decreasing subsequence, and the number of zeros in t is maximized.","use vstd::prelude::*;

verus! {

spec fn valid_binary_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

spec fn longest_non_decreasing_subseq(str: Seq<char>) -> nat {
    if str.len() == 0 {
        0
    } else if str.len() == 1 {
        1
    } else {
        longest_non_decreasing_subseq_helper(str, 1, 1, 1)
    }
}

spec fn longest_non_decreasing_subseq_helper(str: Seq<char>, i: int, current_len: nat, max_len: nat) -> nat
    decreases str.len() - i
{
    if i >= str.len() {
        max_len
    } else {
        let new_current_len = if str[i] >= str[i-1] { current_len + 1 } else { 1 };
        let new_max_len = if new_current_len > max_len { new_current_len } else { max_len };
        longest_non_decreasing_subseq_helper(str, i + 1, new_current_len, new_max_len)
    }
}

spec fn count_zeros(str: Seq<char>) -> nat
    decreases str.len()
{
    if str.len() == 0 {
        0
    } else if str[0] == '0' {
        1 + count_zeros(str.subrange(1, str.len() as int))
    } else {
        count_zeros(str.subrange(1, str.len() as int))
    }
}

spec fn same_subsequence_lengths(s: Seq<char>, t: Seq<char>) -> bool {
    forall|l: int, r: int| 0 <= l <= r <= s.len() ==> 
        longest_non_decreasing_subseq(s.subrange(l, r)) == longest_non_decreasing_subseq(t.subrange(l, r))
}

spec fn valid_solution(s: Seq<char>, t: Seq<char>) -> bool {
    s.len() == t.len() && same_subsequence_lengths(s, t)
}",,"fn solve(s: Vec<char>) -> (result: Vec<char>)
    requires
        valid_binary_string(s@),
    ensures
        valid_solution(s@, result@),","{
    /* impl-start */
    assume(false);
    unreached()
    /* impl-end */
}","
}

fn main() {}",0,,-1,-1,-1,DupVA01,0.85
VA0312,verus,apps,apps_test_1605,,"Given a string of length n containing only 'a' and 'b' characters, count the number of ""good"" substrings of even length and odd length.
A substring is ""good"" if after merging all consecutive equal characters, the resulting string is a palindrome.
For example: ""aabba"" becomes ""aba"" after merging, which is a palindrome, so ""aabba"" is good.","use vstd::prelude::*;

verus! {

spec fn valid_input(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> s[i] == 'a' || s[i] == 'b'
}

spec fn merge_consecutive(s: Seq<char>) -> Seq<char>
    decreases s.len()
{
    if s.len() == 0 {
        s
    } else if s.len() == 1 {
        s
    } else if s[0] == s[1] {
        merge_consecutive(s.subrange(1, s.len() as int))
    } else {
        seq![s[0]].add(merge_consecutive(s.subrange(1, s.len() as int)))
    }
}

spec fn is_palindrome(s: Seq<char>) -> bool
    decreases s.len()
{
    if s.len() <= 1 {
        true
    } else {
        s[0] == s[s.len() - 1] && is_palindrome(s.subrange(1, s.len() - 1))
    }
}

spec fn is_good_substring(s: Seq<char>, i: int, j: int) -> bool {
    &&& valid_input(s)
    &&& 0 <= i <= j < s.len()
    &&& {
        let sub = s.subrange(i, j + 1);
        is_palindrome(merge_consecutive(sub))
    }
}

spec fn valid_output(s: Seq<char>, even_count: int, odd_count: int) -> bool {
    &&& valid_input(s)
    &&& even_count >= 0
    &&& odd_count >= 0
    &&& even_count + odd_count >= s.len()
    &&& odd_count >= s.len()
    &&& (s.len() == 1 ==> even_count == 0 && odd_count == 1)
}",,"fn solve(s: Vec<char>) -> (result: (u32, u32))
    requires valid_input(s@)
    ensures valid_output(s@, result.0 as int, result.1 as int)","{
    assume(false);
    (0, 0)
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0315,verus,apps,apps_test_1618,,"Given a staircase with n stairs at non-decreasing heights, process m boxes thrown sequentially.
Each box has width w and height h, covering stairs 1 through w. A box falls until its bottom 
touches either a stair top or a previously placed box top within its coverage area.
Determine the landing height of each box's bottom.","use vstd::prelude::*;

verus! {
spec fn max(a: int, b: int) -> int {
    if a >= b { a } else { b }
}

spec fn valid_stairs(stair_heights: Seq<int>) -> bool {
    stair_heights.len() >= 1 &&
    (forall|i: int| 0 <= i < stair_heights.len() - 1 ==> #[trigger] stair_heights[i] <= stair_heights[add(i, 1)]) &&
    (forall|i: int| 0 <= i < stair_heights.len() ==> #[trigger] stair_heights[i] >= 0)
}

spec fn valid_boxes(boxes: Seq<(int, int)>, stairs_amount: int) -> bool {
    forall|i: int| 0 <= i < boxes.len() ==> #[trigger] boxes[i].0 >= 1 && boxes[i].0 <= stairs_amount && boxes[i].1 >= 1
}

spec fn valid_result(result: Seq<int>, boxes: Seq<(int, int)>, stair_heights: Seq<int>) -> bool
    recommends 
        stair_heights.len() >= 1,
        forall|i: int| 0 <= i < boxes.len() ==> boxes[i].0 >= 1 && boxes[i].0 <= stair_heights.len()
{
    result.len() == boxes.len() &&
    (forall|i: int| 0 <= i < boxes.len() ==> #[trigger] result[i] >= 0) &&
    (forall|i: int| 0 <= i < boxes.len() ==> 
        result[i] >= stair_heights[0] && result[i] >= stair_heights[sub(boxes[i].0, 1)]) &&
    (forall|i: int| 0 <= i < boxes.len() ==> 
        result[i] == max(if i == 0 { stair_heights[0] } else { result[sub(i, 1)] + boxes[sub(i, 1)].1 }, 
                        stair_heights[sub(boxes[i].0, 1)]))
}",,"fn solve(stairs_amount: i8, stair_heights: Vec<i8>, boxes_amount: i8, boxes: Vec<(i8, i8)>) -> (result: Vec<i8>)
    requires 
        stairs_amount >= 1,
        stair_heights.len() == stairs_amount as int,
        boxes_amount >= 0,
        boxes.len() == boxes_amount as int,
        valid_stairs(stair_heights@.map(|i: int, x: i8| x as int)),
        valid_boxes(boxes@.map(|i: int, x: (i8, i8)| (x.0 as int, x.1 as int)), stairs_amount as int),
    ensures valid_result(result@.map(|i: int, x: i8| x as int), boxes@.map(|i: int, x: (i8, i8)| (x.0 as int, x.1 as int)), stair_heights@.map(|i: int, x: i8| x as int))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0316,verus,apps,apps_test_1620,,"Given a positive integer n, construct a string of length n using only characters 'a', 'b', and 'c' such that:
1. The string contains no palindromic substrings of length 3
2. The number of 'c' characters is minimized","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int) -> bool {
  n >= 1
}

spec fn valid_output(s: &Seq<char>, n: int) -> bool {
  s.len() == n &&
  (forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] == 'a' || s[i] == 'b' || s[i] == 'c') &&
  (forall|i: int| 0 <= i <= s.len() - 3 ==> !(#[trigger] s[i] == s[i+2]))
}

spec fn minimal_c_usage(s: &Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] == 'a' || s[i] == 'b'
}",,"fn solve(n: i8) -> (result: Vec<char>)
  requires 
    valid_input(n as int)
  ensures 
    valid_output(&result@, n as int) &&
    minimal_c_usage(&result@)","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0317,verus,apps,apps_test_1621,,"Given a string of lowercase letters and a value for each letter, calculate the maximum 
possible value of a string after inserting exactly k lowercase letters. The value of a 
string s = s₁s₂...sₙ is defined as f(s) = Σᵢ₌₁ⁿ (wₛᵢ × i), where wₛᵢ is the value of 
character sᵢ and i is its 1-indexed position.","use vstd::prelude::*;

verus! {

spec fn string_value(s: Seq<char>, w: Seq<int>) -> int
  decreases s.len()
{
  if s.len() == 0 { 0 }
  else {
    let char_index = (s.last() as int) - ('a' as int);
    string_value(s.drop_last(), w) + s.len() * w[char_index]
  }
}

spec fn append_value(start_pos: int, count: int, max_val: int) -> int
  decreases count
{
  if count <= 0 { 0 }
  else { (start_pos + count) * max_val + append_value(start_pos, count - 1, max_val) }
}

spec fn max_value(w: Seq<int>) -> int
  decreases w.len()
{
  if w.len() <= 1 { w[0] }
  else if w[0] >= max_value(w.subrange(1, w.len() as int)) { w[0] }
  else { max_value(w.subrange(1, w.len() as int)) }
}

spec fn valid_input(s: Seq<char>, k: int, w: Seq<int>) -> bool
{
  w.len() == 26 && 
  k >= 0 && 
  s.len() <= 1000 && 
  k <= 1000 && 
  (forall|i: int| 0 <= i < w.len() ==> #[trigger] w[i] >= 0 && #[trigger] w[i] <= 1000) &&
  (forall|i: int| 0 <= i < s.len() ==> 'a' <= #[trigger] s[i] && #[trigger] s[i] <= 'z')
}",,"fn solve(s: Vec<char>, k: i8, w: Vec<i8>) -> (result: i8)
  requires valid_input(s@, k as int, w@.map(|i, x| x as int))
  ensures result as int == string_value(s@, w@.map(|i, x| x as int)) + append_value(s@.len() as int, k as int, max_value(w@.map(|i, x| x as int)))","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0318,verus,apps,apps_test_1623,,"Given an array of n positive integers where the number of distinct elements 
is between l and r (inclusive) and each element is either 1 or even with its 
half also present in the array, find the minimum and maximum possible sums.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, l: int, r: int) -> bool {
    n >= 1 && l >= 1 && r >= l && r <= n && r <= 20
}

spec fn power(base: int, exp: int) -> int
    decreases exp
{
    if exp <= 0 { 1 } else { base * power(base, exp - 1) }
}

spec fn sum_with_decreasing_powers(n: int, start_power: int) -> int
    decreases n
{
    if n <= 0 { 0 } 
    else if start_power <= 1 { n }
    else { start_power + sum_with_decreasing_powers(n - 1, start_power / 2) }
}

spec fn sum_with_increasing_powers(n: int, max_power: int) -> int
    decreases n
{
    if n <= 0 { 0 }
    else if n == 1 { max_power }
    else { max_power + sum_with_increasing_powers(n - 1, max_power * 2) }
}

spec fn min_sum_calculation(n: int, l: int) -> int {
    if n >= 1 && l >= 1 {
        let start_power = power(2, l - 1);
        sum_with_decreasing_powers(n, start_power)
    } else {
        0
    }
}

spec fn max_sum_calculation(n: int, r: int) -> int {
    if n >= 1 && r >= 1 {
        let max_power = power(2, r - 1);
        sum_with_increasing_powers(n, max_power)
    } else {
        0
    }
}",,"fn solve(n: i8, l: i8, r: i8) -> (result: (i8, i8))
    requires valid_input(n as int, l as int, r as int)
    ensures ({
        let (min_sum, max_sum) = result;
        min_sum > 0 &&
        max_sum > 0 &&
        min_sum <= max_sum &&
        min_sum as int == min_sum_calculation(n as int, l as int) &&
        max_sum as int == max_sum_calculation(n as int, r as int)
    })","{
    assume(false);
    (0, 0)
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0319,verus,apps,apps_test_1627,,"Given an array of n integers representing animal heights, sort the array in non-decreasing order
using a specific operation that selects a segment of even length and swaps adjacent pairs within it.
Output the sequence of operations (at most 20,000) needed to sort the array.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, arr: Seq<int>) -> bool {
    n >= 1 && arr.len() == n && forall|i: int| 0 <= i < arr.len() ==> arr[i] >= 1
}

spec fn valid_operations(operations: Seq<(int, int)>, n: int) -> bool {
    forall|op: (int, int)| operations.contains(op) ==> 1 <= op.0 <= n && 1 <= op.1 <= n && op.1 == op.0 + 1
}

spec fn is_sorted_helper(arr: Seq<int>, i: int) -> bool 
    decreases arr.len() - i
{
    if i >= arr.len() - 1 {
        true
    } else {
        arr[i] <= arr[i + 1] && is_sorted_helper(arr, i + 1)
    }
}

spec fn is_sorted(arr: Seq<int>) -> bool {
    if arr.len() <= 1 {
        true
    } else {
        is_sorted_helper(arr, 0)
    }
}

spec fn swap_adjacent(arr: Seq<int>, i: int, j: int) -> Seq<int> {
    if i >= 0 && j >= 0 && i < arr.len() && j < arr.len() && j == i + 1 {
        arr.update(i, arr[j]).update(j, arr[i])
    } else {
        arr
    }
}

spec fn apply_operations(arr: Seq<int>, operations: Seq<(int, int)>) -> Seq<int>
    decreases operations.len()
{
    if operations.len() == 0 {
        arr
    } else {
        let op = operations[0];
        if 1 <= op.0 <= arr.len() && 1 <= op.1 <= arr.len() && op.1 == op.0 + 1 {
            let new_arr = swap_adjacent(arr, (op.0 - 1) as int, (op.1 - 1) as int);
            apply_operations(new_arr, operations.drop_first())
        } else {
            apply_operations(arr, operations.drop_first())
        }
    }
}

spec fn count_inversions(arr: Seq<int>) -> nat {
    /* Count of pairs (i, j) where i < j and arr[i] > arr[j] */
    0nat /* Placeholder implementation */
}",,"fn solve(n: i8, arr: Vec<i8>) -> (operations: Vec<(i8, i8)>)
  requires 
      valid_input(n as int, arr@.map_values(|x: i8| x as int)),
  ensures 
      valid_operations(operations@.map_values(|op: (i8, i8)| (op.0 as int, op.1 as int)), n as int) &&
      (is_sorted(apply_operations(arr@.map_values(|x: i8| x as int), operations@.map_values(|op: (i8, i8)| (op.0 as int, op.1 as int)))) || operations.len() == 20000) &&
      operations.len() <= 20000 &&
      (is_sorted(arr@.map_values(|x: i8| x as int)) ==> operations.len() == 0)","{
    // impl-start
    assume(false);
    Vec::new()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0320,verus,apps,apps_test_1628,,"Given a string containing only 'x' and 'y' characters, apply operations:
1. Swap leftmost ""yx"" to ""xy"" 
2. Remove leftmost ""xy""
Apply operation 1 if possible, otherwise operation 2, repeat until no operations possible.
Return the final non-empty string.","use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> s[i] == 'x' || s[i] == 'y'
}

spec fn count_char(s: Seq<char>, c: char) -> nat {
    s.filter(|x: char| x == c).len()
}

spec fn valid_output(s: Seq<char>, result: Seq<char>) -> bool 
    recommends valid_input(s)
{
    let count_x = count_char(s, 'x');
    let count_y = count_char(s, 'y');
    if count_y > count_x {
        result.len() == count_y - count_x && forall|i: int| 0 <= i < result.len() ==> result[i] == 'y'
    } else {
        result.len() == count_x - count_y && forall|i: int| 0 <= i < result.len() ==> result[i] == 'x'
    }
}",,"fn solve(s: Vec<char>) -> (result: Vec<char>)
    requires valid_input(s@)
    ensures valid_output(s@, result@)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0323,verus,apps,apps_test_1635,,"Given a sequence of cafe visits, find the cafe that was visited earliest among all last visits to each cafe.
For each unique cafe, record the position of its last occurrence, then return the cafe whose last occurrence 
has the smallest position.","use vstd::prelude::*;

verus! {

spec fn last_occurrence_helper(cafes: Seq<int>, cafe: int, pos: int) -> int
    decreases pos + 1
{
    if pos < 0 || pos >= cafes.len() { -1 }
    else if cafes[pos] == cafe { pos }
    else { last_occurrence_helper(cafes, cafe, pos - 1) }
}

spec fn last_occurrence_position(cafes: Seq<int>, cafe: int) -> int
{
    last_occurrence_helper(cafes, cafe, (cafes.len() - 1) as int)
}",,"fn solve(cafes: Vec<i8>) -> (mini: i8)
    requires
        cafes.len() > 0,
    ensures
        cafes@.contains(mini),
        forall|cafe: i8| #![auto] cafes@.contains(cafe) ==> last_occurrence_position(cafes@.map(|i, x: i8| x as int), mini as int) <= last_occurrence_position(cafes@.map(|i, x: i8| x as int), cafe as int),","{
    assume(false);
    0
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0324,verus,apps,apps_test_1643,,"Given a binary string s, find a binary string t of the same length such that:
1. For every substring s[l..r], the longest non-decreasing subsequence length in s[l..r] 
   equals the longest non-decreasing subsequence length in t[l..r]
2. The number of zeros in t is maximized","use vstd::prelude::*;

verus! {
spec fn valid_binary_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
}

spec fn count_zeros(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if s[0] == '0' {
        1 + count_zeros(s.subrange(1, s.len() as int))
    } else {
        count_zeros(s.subrange(1, s.len() as int))
    }
}

spec fn count_ones(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if s[0] == '1' {
        1 + count_ones(s.subrange(1, s.len() as int))
    } else {
        count_ones(s.subrange(1, s.len() as int))
    }
}

spec fn longest_non_decreasing_subseq_length_complete(s: Seq<char>) -> int {
    if s.len() == 0 {
        0
    } else if s.len() == 1 {
        1
    } else {
        let count_ones = count_ones(s);
        let count_zeros = s.len() - count_ones;
        if count_zeros == 0 {
            count_ones
        } else if count_ones == 0 {
            1
        } else {
            count_zeros + count_ones
        }
    }
}

spec fn longest_non_decreasing_subseq_length(s: Seq<char>, l: int, r: int) -> int
    recommends 0 <= l <= r < s.len()
{
    let sub = s.subrange(l, r + 1);
    longest_non_decreasing_subseq_length_complete(sub)
}

spec fn basic_valid_solution(s: Seq<char>, t: Seq<char>) -> bool {
    &&& s.len() == t.len()
    &&& valid_binary_string(s)
    &&& valid_binary_string(t)
    &&& (forall|i: int| 0 <= i < s.len() ==> s[i] == '0' ==> t[i] == '0')
    &&& (forall|i: int| 0 <= i < s.len() ==> t[i] == '1' ==> s[i] == '1')
}",,"fn solve(s: Vec<char>) -> (result: Vec<char>)
    requires valid_binary_string(s@)
    ensures basic_valid_solution(s@, result@)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,DupVA01,0.85
VA0325,verus,apps,apps_test_1646,,"Given a binary string with no redundant leading zeros, find the minimum possible binary string 
achievable using these operations: 1) Swap any two adjacent characters, 2) Replace ""11"" with ""1"".
The goal is to minimize the decimal value represented by the resulting binary string.","use vstd::prelude::*;

verus! {
spec fn valid_binary_string(s: Seq<char>) -> bool {
    s.len() > 0 && 
    (forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1') &&
    (s == seq!['0'] || s[0] == '1')
}

spec fn count_zeros(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 { 
        0int
    } else { 
        (if s[0] == '0' { 1int } else { 0int }) + count_zeros(s.subrange(1, s.len() as int))
    }
}

spec fn create_zero_seq(n: nat) -> Seq<char> {
    Seq::new(n, |i: int| '0')
}

spec fn is_minimal_form(s: Seq<char>, result: Seq<char>) -> bool {
    (s == seq!['0'] ==> result == seq!['0'])
    &&
    (s != seq!['0'] ==> result == seq!['1'] + create_zero_seq(count_zeros(s) as nat))
}",,"fn solve(n: u8, s: Vec<char>) -> (result: Vec<char>)
    requires 
        n >= 1 && n <= 100,
        s.len() == n as usize,
        valid_binary_string(s@),
    ensures 
        valid_binary_string(result@),
        is_minimal_form(s@, result@),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0326,verus,apps,apps_test_1655,,"Given n people in positions 1 to n, where person i has weapon reach L_i.
All people simultaneously attack: person i kills person j if and only if 
j < i and j >= i - L_i. Determine the number of survivors.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, a: Seq<int>) -> bool {
    n >= 1 && a.len() == n && forall|i: int| 0 <= i < n ==> a[i] >= 0
}

spec fn count_survivors(n: int, a: Seq<int>) -> int {
    count_survivors_from(n, a, 0, n)
}

spec fn count_survivors_from(n: int, a: Seq<int>, start: int, left: int) -> int
    decreases n - start
{
    if start >= n {
        0
    } else {
        let i = n - 1 - start;
        let survives: int = if i < left { 1 } else { 0 };
        let new_left: int = if i - a[i] < left { i - a[i] } else { left };
        survives + count_survivors_from(n, a, start + 1, new_left)
    }
}",,"fn solve(n: i8, a: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, a@.map_values(|x: i8| x as int))
    ensures result >= 0 && result <= n && result as int == count_survivors(n as int, a@.map_values(|x: i8| x as int))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0327,verus,apps,apps_test_1656,,"Given a non-empty string containing only characters 'v' and 'o' with length at most 10^6,
calculate its ""wow factor"" - the number of subsequences that form the pattern ""wow"".
Each 'w' must be represented by exactly two consecutive 'v' characters.
A valid ""wow"" subsequence consists of: two consecutive 'v' characters (first 'w'),
an 'o' character appearing later, and two consecutive 'v' characters after the 'o' (second 'w').","use vstd::prelude::*;

verus! {

spec fn wow_factor(s: Seq<char>) -> int {
    if s.len() < 4 { 0 }
    else {
        wow_factor_sum(s, 0)
    }
}

spec fn count_vv_pairs_before(s: Seq<char>, pos: int) -> int
    decreases pos
{
    if pos <= 1 { 0 }
    else {
        let prev = count_vv_pairs_before(s, pos - 1);
        if s[pos-1] == 'v' && s[pos-2] == 'v' { prev + 1 } else { prev }
    }
}

spec fn count_vv_pairs_after(s: Seq<char>, pos: int) -> int
    decreases s.len() - pos
{
    if pos >= s.len() - 1 { 0 }
    else {
        let rest = count_vv_pairs_after(s, pos + 1);
        if pos + 1 < s.len() && s[pos] == 'v' && s[pos+1] == 'v' { rest + 1 } else { rest }
    }
}

spec fn wow_factor_sum(s: Seq<char>, pos: int) -> int
    decreases s.len() - pos
{
    if pos >= s.len() { 0 }
    else {
        let current = if s[pos] == 'o' { 
            count_vv_pairs_before(s, pos) * count_vv_pairs_after(s, pos + 1)
        } else { 0 };
        current + wow_factor_sum(s, pos + 1)
    }
}",,"fn solve(s: Vec<char>) -> (result: i8)
    ensures
        result as int == wow_factor(s@)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0329,verus,apps,apps_test_1672,,"Given a sequence of magnets with orientations ""01"" or ""10"", count the number of groups formed.
Adjacent magnets with same orientation attract (same group), different orientations repel (separate groups).","use vstd::prelude::*;

verus! {

spec fn valid_input(magnets: Seq<Seq<char>>) -> bool {
    forall|i: int| 0 <= i < magnets.len() ==> 
        (magnets[i].len() == 2 && 
         ((magnets[i][0] == '0' && magnets[i][1] == '1') || 
          (magnets[i][0] == '1' && magnets[i][1] == '0')))
}

spec fn count_groups(magnets: Seq<Seq<char>>) -> int {
    if magnets.len() == 0 { 
        0 as int
    } else { 
        1 + (Set::new(|i: int| 1 <= i < magnets.len() && magnets[i] != magnets[i-1]).len() as int)
    }
}",,"fn solve(magnets: Vec<Vec<char>>) -> (result: usize)
    requires 
        valid_input(magnets@.map(|i, v: Vec<char>| v@))
    ensures 
        result >= 0,
        magnets@.len() == 0 ==> result == 0,
        magnets@.len() > 0 ==> result >= 1,
        result <= magnets@.len(),
        valid_input(magnets@.map(|i, v: Vec<char>| v@)) ==> result == count_groups(magnets@.map(|i, v: Vec<char>| v@)) as usize","{
    assume(false);
    0
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0330,verus,apps,apps_test_1675,,"Given n football teams where each team has home and away kit colors (different colors),
calculate how many games each team plays in home kit vs away kit in a round-robin tournament.
Kit rules: home team wears home kit, away team wears away kit unless it conflicts with 
home team's home kit color, then away team wears home kit.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, teams: Seq<(int, int)>) -> bool {
  n >= 2 && teams.len() == n &&
  (forall|i: int| 0 <= i < n ==> #[trigger] teams[i].0 != #[trigger] teams[i].1) &&
  (forall|i: int| 0 <= i < n ==> 
    (Set::new(|j: int| 0 <= j < n && #[trigger] teams[j].0 == #[trigger] teams[i].1)).len() <= (n - 1) as nat)
}

spec fn valid_output(n: int, teams: Seq<(int, int)>, result: Seq<(int, int)>) -> bool
  recommends teams.len() == n
{
  result.len() == n &&
  (forall|i: int| 0 <= i < n ==> #[trigger] result[i].0 + #[trigger] result[i].1 == 2 * (n - 1)) &&
  (forall|i: int| 0 <= i < n ==> #[trigger] result[i].0 >= n - 1) &&
  (forall|i: int| 0 <= i < n ==> #[trigger] result[i].1 >= 0) &&
  (forall|i: int| 0 <= i < n ==> {
    let home_count = (Set::new(|j: int| 0 <= j < n && #[trigger] teams[j].0 == #[trigger] teams[i].1)).len() as int;
    #[trigger] result[i].0 == (n - 1) + home_count &&
    #[trigger] result[i].1 == (n - 1) - home_count
  })
}",,"fn solve(n: i8, teams: Vec<(i8, i8)>) -> (result: Vec<(i8, i8)>)
  requires valid_input(n as int, teams@.map_values(|t: (i8, i8)| (t.0 as int, t.1 as int)))
  ensures valid_output(n as int, teams@.map_values(|t: (i8, i8)| (t.0 as int, t.1 as int)), result@.map_values(|r: (i8, i8)| (r.0 as int, r.1 as int)))","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0333,verus,apps,apps_test_1689,,"Given a bus with n rows of seats, where each row contains 4 seats arranged as two pairs 
separated by a walkway (format: XX|XX), find two adjacent empty seats in the same pair 
for two passengers. Each seat is either 'O' (empty) or 'X' (occupied). If such a pair 
exists, mark it with ""++"" and output ""YES"" with the modified configuration. Otherwise, 
output ""NO"".","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, rows: Seq<Seq<char>>) -> bool {
    n >= 0 && rows.len() == n && forall|i: int| 0 <= i < rows.len() ==> rows[i].len() == 5
}

spec fn has_adjacent_empty_seats(rows: Seq<Seq<char>>) -> bool {
    exists|i: int| 0 <= i < rows.len() && 
        ((rows[i].len() >= 2 && rows[i][0] == 'O' && rows[i][1] == 'O') ||
         (rows[i].len() >= 5 && rows[i][3] == 'O' && rows[i][4] == 'O'))
}

spec fn no_adjacent_empty_seats(rows: Seq<Seq<char>>) -> bool {
    forall|i: int| 0 <= i < rows.len() ==> 
        !((rows[i].len() >= 2 && rows[i][0] == 'O' && rows[i][1] == 'O') ||
          (rows[i].len() >= 5 && rows[i][3] == 'O' && rows[i][4] == 'O'))
}

spec fn valid_solution(result: Seq<char>, rows: Seq<Seq<char>>) -> bool {
    result.len() != 2 || result[0] != 'N' || result[1] != 'O' ==> result.len() >= 4
}","spec fn vec_to_seq_seq(v: Vec<Vec<char>>) -> Seq<Seq<char>> {
    v@.map(|i, row: Vec<char>| row@)
}
","fn solve(n: i8, rows: Vec<Vec<char>>) -> (result: Vec<char>)
    requires 
        valid_input(n as int, vec_to_seq_seq(rows))
    ensures 
        (result@.len() == 2 && result@[0] == 'N' && result@[1] == 'O') || result@.len() >= 4,
        (result@.len() == 2 && result@[0] == 'N' && result@[1] == 'O') ==> no_adjacent_empty_seats(vec_to_seq_seq(rows)),
        !(result@.len() == 2 && result@[0] == 'N' && result@[1] == 'O') ==> has_adjacent_empty_seats(vec_to_seq_seq(rows)),
        valid_solution(result@, vec_to_seq_seq(rows))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0334,verus,apps,apps_test_1711,,"Count the number of arrays of length n where each element is from 1 to m,
exactly one pair of elements are equal (all others distinct), and the array
is unimodal (strictly ascending then strictly descending around a peak).","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, m: int) -> bool {
    n >= 2 && m >= 1 && n <= m && m <= 200000
}

spec fn combination(n: int, k: int, modulus: int) -> int {
    0  /* placeholder - actual combinatorial calculation */
}

spec fn power(base: int, exp: int, modulus: int) -> int {
    0  /* placeholder - actual modular exponentiation */
}

spec fn expected_result(n: int, m: int) -> int {
    if n == 2 {
        0
    } else {
        (((combination(m, n - 1, 998244353) * (n - 2)) % 998244353) * power(2, n - 3, 998244353)) % 998244353
    }
}

spec fn valid_output(result: int) -> bool {
    0 <= result < 998244353
}",,"fn solve(n: i8, m: i8) -> (result: i8)
    requires 
        valid_input(n as int, m as int)
    ensures 
        valid_output(result as int),
        result as int == expected_result(n as int, m as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0335,verus,apps,apps_test_1712,,"Two players (Vanya and Vova) attack monsters simultaneously with different frequencies.
Vanya attacks at frequency a hits/second, Vova at frequency b hits/second.
For each monster requiring mobs[i] hits, determine who makes the final hit.
The attack pattern repeats every (a+b) hits, so we can use modular arithmetic.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, a: int, b: int, mobs: Seq<int>) -> bool {
    n >= 0 && a > 0 && b > 0 && mobs.len() == n &&
    forall|i: int| 0 <= i < n ==> #[trigger] mobs[i] >= 0
}

spec fn valid_output(result: Seq<Vec<char>>, n: int) -> bool {
    result.len() == n &&
    forall|i: int| 0 <= i < n ==> 
        (#[trigger] result[i]@ =~= seq!['V', 'a', 'n', 'y', 'a']) || 
        (result[i]@ =~= seq!['V', 'o', 'v', 'a']) || 
        (result[i]@ =~= seq!['B', 'o', 't', 'h'])
}

spec fn determine_winner(k: int, a: int, b: int) -> int {
    if k <= a { 0 } else { 1 }
}

spec fn correct_result(result: Seq<Vec<char>>, n: int, a: int, b: int, mobs: Seq<int>) -> bool
    recommends a > 0 && b > 0 && mobs.len() == n
{
    valid_output(result, n) &&
    forall|i: int| 0 <= i < n ==> {
        let total = a + b;
        let k = if mobs[i] == 0 { 0 } else { mobs[i] % total };
        (#[trigger] result[i]@ =~= seq!['V', 'a', 'n', 'y', 'a'] <==> determine_winner(k, a, b) == 0) &&
        (result[i]@ =~= seq!['V', 'o', 'v', 'a'] <==> determine_winner(k, a, b) == 1) &&
        (result[i]@ =~= seq!['B', 'o', 't', 'h'] <==> determine_winner(k, a, b) == 2)
    }
}",,"fn solve(n: i8, a: i8, b: i8, mobs: Vec<i8>) -> (result: Vec<Vec<char>>)
    requires valid_input(n as int, a as int, b as int, mobs@.map_values(|x: i8| x as int))
    ensures correct_result(result@, n as int, a as int, b as int, mobs@.map_values(|x: i8| x as int))","{
    assume(false);
    Vec::new()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0336,verus,apps,apps_test_1723,,"Given an integer n (2 ≤ n ≤ 10^5), construct two trees with n nodes each:
1. First tree: Where Mahmoud's algorithm produces incorrect minimum vertex cover size
2. Second tree: Where Mahmoud's algorithm produces correct minimum vertex cover size
Mahmoud's algorithm roots the tree at node 1, counts nodes at even/odd depths,
and returns min(evenCnt, oddCnt) as the vertex cover size.","use vstd::prelude::*;

verus! {
spec fn valid_output(n: int, result: Seq<String>) -> bool
    recommends n >= 2
{
    if n < 6 {
        result.len() == 1 + (n - 1) &&
        result[0]@ == seq!['-', '1'] &&
        (forall|i: int| #![auto] 1 <= i < result.len() ==> result[i]@ == seq!['1', ' '] + int_to_string(i + 1))
    } else {
        result.len() == (5 + (n - 6)) + (n - 1) &&
        result[0]@ == seq!['1', ' ', '2'] && 
        result[1]@ == seq!['1', ' ', '3'] && 
        result[2]@ == seq!['1', ' ', '4'] && 
        result[3]@ == seq!['2', ' ', '5'] && 
        result[4]@ == seq!['2', ' ', '6'] &&
        (forall|i: int| #![auto] 5 <= i < 5 + (n - 6) ==> result[i]@ == seq!['1', ' '] + int_to_string(i + 2)) &&
        (forall|i: int| #![auto] 5 + (n - 6) <= i < result.len() ==> result[i]@ == seq!['1', ' '] + int_to_string(i - (5 + (n - 6)) + 2))
    }
}

spec fn int_to_string_pos(n: nat) -> Seq<char>
    decreases n
{
    if n < 10 {
        seq![(n + ('0' as nat)) as char]
    } else {
        int_to_string_pos(n / 10) + int_to_string_pos(n % 10)
    }
}

spec fn int_to_string(n: int) -> Seq<char> {
    if n < 0 {
        seq!['-'] + int_to_string_pos((-n) as nat)
    } else {
        int_to_string_pos(n as nat)
    }
}",,"fn solve(n: i8) -> (result: Vec<String>)
    requires n as int >= 2
    ensures valid_output(n as int, result@)","{
    assume(false);
    Vec::new()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0338,verus,apps,apps_test_1725,,"Given an n × m matrix of integers and parameter d, find minimum operations to make all elements equal.
Each operation adds or subtracts d from any element. Return -1 if impossible.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, m: int, d: int, matrix: Seq<Seq<int>>) -> bool {
    n > 0 && m > 0 && d > 0 &&
    matrix.len() == n &&
    (forall|i: int| #![auto] 0 <= i < n ==> matrix[i].len() == m) &&
    (forall|i: int, j: int| 0 <= i < n && 0 <= j < m ==> matrix[i][j] > 0)
}

spec fn all_same_remainder(matrix: Seq<Seq<int>>, d: int) -> bool
    recommends valid_input(matrix.len() as int, if matrix.len() > 0 { matrix[0].len() as int } else { 0 }, d, matrix)
{
    forall|i: int, j: int, k: int, l: int| 
        0 <= i < matrix.len() && 0 <= j < matrix[0].len() && 
        0 <= k < matrix.len() && 0 <= l < matrix[0].len() ==>
        matrix[i][j] % d == matrix[k][l] % d
}

spec fn flatten(matrix: Seq<Seq<int>>) -> Seq<int>
    decreases matrix.len()
{
    if matrix.len() == 0 {
        seq![]
    } else {
        matrix[0].add(flatten(matrix.subrange(1, matrix.len() as int)))
    }
}

spec fn divide_sequence_by_d(s: Seq<int>, d: int) -> Seq<int>
    recommends d > 0
    decreases s.len()
{
    if s.len() == 0 {
        seq![]
    } else {
        seq![s[0] / d].add(divide_sequence_by_d(s.subrange(1, s.len() as int), d))
    }
}

spec fn sum_abs_differences_from_target(s: Seq<int>, target: int) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else {
        (if s[0] >= target { s[0] - target } else { target - s[0] }) + 
        sum_abs_differences_from_target(s.subrange(1, s.len() as int), target)
    }
}

spec fn seq_min(s: Seq<int>) -> int
    recommends s.len() > 0
    decreases s.len()
{
    if s.len() == 1 {
        s[0]
    } else if s.len() == 0 {
        0
    } else {
        let rest_min = seq_min(s.subrange(1, s.len() as int));
        if s[0] <= rest_min { s[0] } else { rest_min }
    }
}

spec fn seq_max(s: Seq<int>) -> int
    recommends s.len() > 0
    decreases s.len()
{
    if s.len() == 1 {
        s[0]
    } else if s.len() == 0 {
        0
    } else {
        let rest_max = seq_max(s.subrange(1, s.len() as int));
        if s[0] >= rest_max { s[0] } else { rest_max }
    }
}

spec fn min_ops_in_range(simplified: Seq<int>, min_val: int, max_val: int) -> int
    recommends simplified.len() > 0
    decreases max_val - min_val
{
    if min_val >= max_val {
        sum_abs_differences_from_target(simplified, min_val)
    } else {
        let mid = (min_val + max_val) / 2;
        let mid_ops = sum_abs_differences_from_target(simplified, mid);
        let left_ops = if mid > min_val { min_ops_in_range(simplified, min_val, mid - 1) } else { mid_ops };
        let right_ops = if mid < max_val { min_ops_in_range(simplified, mid + 1, max_val) } else { mid_ops };
        if mid_ops <= left_ops && mid_ops <= right_ops {
            mid_ops
        } else if left_ops <= right_ops {
            left_ops
        } else {
            right_ops
        }
    }
}

spec fn minimum_operations_to_make_equal(simplified: Seq<int>) -> int
    recommends simplified.len() > 0
{
    let min_val = seq_min(simplified);
    let max_val = seq_max(simplified);
    min_ops_in_range(simplified, min_val, max_val)
}",,"fn solve(n: i8, m: i8, d: i8, matrix: Vec<Vec<i8>>) -> (result: i8)
    requires valid_input(n as int, m as int, d as int, matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)))
    ensures 
        result == -1 <==> !all_same_remainder(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)), d as int),
        result >= 0 ==> all_same_remainder(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)), d as int),
        result >= 0 ==> {
            let flat = flatten(matrix@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)));
            let simplified = divide_sequence_by_d(flat, d as int);
            result as int == minimum_operations_to_make_equal(simplified)
        }","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0339,verus,apps,apps_test_1735,,"Two players alternate turns removing consecutive identical letters from a string.
The player who cannot make a move loses. Determine if the first player wins.","use vstd::prelude::*;

verus! {

spec fn count_max_moves(s: Seq<char>) -> nat
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else {
        let stack: Seq<char> = seq![];
        let moves: nat = 0;
        count_max_moves_helper(s, 0, stack, moves)
    }
}

spec fn count_max_moves_helper(s: Seq<char>, i: nat, stack: Seq<char>, moves: nat) -> nat
    decreases s.len() - i
{
    if i <= s.len() {
        if i == s.len() {
            moves
        } else if stack.len() > 0 && s[i as int] == stack[stack.len() as int - 1] {
            count_max_moves_helper(s, i + 1, stack.subrange(0, stack.len() as int - 1), moves + 1)
        } else {
            count_max_moves_helper(s, i + 1, stack.push(s[i as int]), moves)
        }
    } else {
        0
    }
}",,"fn solve(s: Vec<char>) -> (result: &'static str)
    requires s.len() >= 1
    ensures
        result == ""Yes"" || result == ""No"",
        result == ""Yes"" <==> count_max_moves(s@) % 2 == 1,
        result == ""No"" <==> count_max_moves(s@) % 2 == 0,","{
    assume(false);
    ""No""
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0341,verus,apps,apps_test_1746,,"Determine if a rooted tree is a ""spruce"". A rooted tree is a spruce if every 
non-leaf vertex has at least 3 leaf children. A leaf is a vertex with no children,
and a non-leaf vertex has at least one child.","use vstd::prelude::*;

verus! {
spec fn has_children(node: int, parents: Seq<int>, n: int) -> bool
    recommends 0 <= node < n, n >= 3, parents.len() == n - 1
{
    exists|i: int| 0 <= i < n - 1 && parents[i] - 1 == node
}

spec fn count_leaf_children(node: int, parents: Seq<int>, n: int) -> int
    recommends 0 <= node < n, n >= 3, parents.len() == n - 1
{
    (Set::new(|i: int| 0 <= i < n - 1 && parents[i] - 1 == node && !has_children(i + 1, parents, n))).len() as int
}

spec fn valid_input(n: int, parents: Seq<int>) -> bool
{
    n >= 3 && parents.len() == n - 1 && 
    (forall|i: int| 0 <= i < n - 1 ==> #[trigger] parents[i] >= 1 && parents[i] <= i + 1)
}

spec fn is_spruce(n: int, parents: Seq<int>) -> bool
    recommends valid_input(n, parents)
{
    forall|node: int| 0 <= node < n && has_children(node, parents, n) ==> 
        count_leaf_children(node, parents, n) >= 3
}",,"fn solve(n: i8, parents: Vec<i8>) -> (result: String)
    requires 
        valid_input(n as int, parents@.map_values(|x: i8| x as int)),
    ensures 
        result@ == seq!['Y', 'e', 's'] || result@ == seq!['N', 'o'],
        result@ == seq!['Y', 'e', 's'] <==> is_spruce(n as int, parents@.map_values(|x: i8| x as int)),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0342,verus,apps,apps_test_1754,,"Given n students across m schools, where each student has a unique power level,
the Technogoblet selects the strongest student from each school. We want k specific 
students (Chosen Ones) to be selected. We can create new schools and reassign students.
Find the minimum number of new schools needed so all k Chosen Ones get selected.","use vstd::prelude::*;

verus! {
spec fn is_strongest_in_school(student_idx: int, powers: Seq<int>, schools: Seq<int>) -> bool
  recommends 0 <= student_idx < powers.len() && powers.len() == schools.len()
{
  forall|j: int| 0 <= j < powers.len() && schools[j] == schools[student_idx] ==> powers[j] <= powers[student_idx]
}",,"fn solve(n: i8, m: i8, k: i8, powers: Vec<i8>, schools: Vec<i8>, chosen: Vec<i8>) -> (result: i8)
  requires 
      n >= 1 && m >= 1 && k >= 1 && k <= n && m <= n,
      powers@.len() == n as nat && schools@.len() == n as nat && chosen@.len() == k as nat
  ensures 
      result >= 0 && result <= k","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0343,verus,apps,apps_test_1757,,"Generate a string of exactly n characters where each character is either 'O' or 'o'.
The i-th character (1-indexed) should be 'O' if i is a Fibonacci number, 'o' otherwise.
Fibonacci sequence: f₁ = 1, f₂ = 1, fₙ = fₙ₋₁ + fₙ₋₂ for n > 2.","use vstd::prelude::*;

verus! {

spec fn is_fibonacci(num: int) -> bool {
    num == 1 || num == 2 || exists|k: nat| is_fib_seq(k) == num
}

spec fn is_fib_seq(n: nat) -> int
    decreases n
{
    if n == 0 {
        1
    } else if n == 1 {
        1
    } else {
        is_fib_seq((n - 1) as nat) + is_fib_seq((n - 2) as nat)
    }
}",,"fn solve(n: i8) -> (result: Vec<char>)
    requires n >= 1 && n <= 100
    ensures 
        result.len() == n as nat
        && (forall|i: int| 0 <= i < result.len() ==> result[i] == 'O' || result[i] == 'o')
        && (forall|i: int| 1 <= i <= n ==> (is_fibonacci(i) <==> result[i-1] == 'O'))
        && (forall|i: int| 1 <= i <= n ==> (!is_fibonacci(i) <==> result[i-1] == 'o'))","{
    assume(false);
    Vec::new()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0344,verus,apps,apps_test_1761,,"Given n words forming a message, determine if a received text could have been encoded by:
1. Creating coded string with ""<3"" before each word and after last word
2. Inserting additional characters anywhere in the coded string
Check if received message contains expected coded string as subsequence.","use vstd::prelude::*;

verus! {

spec fn parse_int_helper(s: Seq<char>, index: nat, acc: int) -> int {
    0  /* placeholder for uninterpreted function */
}

spec fn valid_input(input: Seq<Seq<char>>) -> bool {
    input.len() >= 2 &&
    {
        let n = parse_int_helper(input[0], 0, 0);
        n >= 1 && n + 1 < input.len()
    }
}

spec fn build_expected_pattern(words: Seq<Seq<char>>) -> Seq<char>
    decreases words.len()
{
    if words.len() == 0 {
        seq!['<', '3']
    } else {
        seq!['<', '3'] + words[0] + build_expected_pattern(words.subrange(1, words.len() as int))
    }
}

spec fn is_subsequence(pattern: Seq<char>, text: Seq<char>) -> bool {
    is_subsequence_helper(pattern, text, 0, 0)
}

spec fn is_subsequence_helper(pattern: Seq<char>, text: Seq<char>, pattern_index: nat, text_index: nat) -> bool
    decreases text.len() - text_index when pattern_index <= pattern.len() && text_index <= text.len()
{
    if pattern_index <= pattern.len() && text_index <= text.len() {
        if pattern_index == pattern.len() {
            true
        } else if text_index == text.len() {
            false
        } else if pattern[pattern_index as int] == text[text_index as int] {
            is_subsequence_helper(pattern, text, (pattern_index + 1) as nat, (text_index + 1) as nat)
        } else {
            is_subsequence_helper(pattern, text, pattern_index, (text_index + 1) as nat)
        }
    } else {
        false
    }
}",,"fn solve(input: Vec<Vec<char>>) -> (result: Vec<char>)
    requires 
        input.len() >= 2,
        valid_input(input@.map(|i, v: Vec<char>| v@))
    ensures 
        result@ == seq!['y', 'e', 's'] || result@ == seq!['n', 'o'],
        result@ == seq!['y', 'e', 's'] <==> {
            valid_input(input@.map(|i, v: Vec<char>| v@)) && {
                let n = parse_int_helper(input@.map(|i, v: Vec<char>| v@)[0], 0, 0);
                let expected = build_expected_pattern(input@.map(|i, v: Vec<char>| v@).subrange(1, n + 1));
                let message = input@.map(|i, v: Vec<char>| v@)[n + 1];
                is_subsequence(expected, message)
            }
        }","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0345,verus,apps,apps_test_1766,,"Two players take turns picking cards from either end of a row of n cards. Each card has a distinct
integer value. The first player (Sereja) goes first. Both players use a greedy strategy: they always
choose the card with the larger value between the leftmost and rightmost available cards. Determine
the final scores of both players.","use vstd::prelude::*;

verus! {
spec fn valid_input(cards: Seq<int>) -> bool {
    cards.len() >= 1 &&
    (forall|i: int| 0 <= i < cards.len() ==> cards[i] > 0) &&
    (forall|i: int, j: int| 0 <= i < j < cards.len() ==> cards[i] != cards[j])
}

spec fn sum(cards: Seq<int>) -> int 
    decreases cards.len()
{
    if cards.len() == 0 { 
        0 
    } else { 
        cards[0] + sum(cards.subrange(1, cards.len() as int))
    }
}

spec fn sereja_optimal_score(cards: Seq<int>, left: int, right: int, sereja_turn: bool) -> int
    decreases right - left + 1
    when 0 <= left <= right < cards.len()
{
    if left == right {
        if sereja_turn { cards[left] } else { 0 }
    } else if cards[left] > cards[right] {
        (if sereja_turn { cards[left] } else { 0 }) + sereja_optimal_score(cards, left+1, right, !sereja_turn)
    } else {
        (if sereja_turn { cards[right] } else { 0 }) + sereja_optimal_score(cards, left, right-1, !sereja_turn)
    }
}

spec fn valid_output(scores: Seq<int>, cards: Seq<int>) -> bool {
    valid_input(cards) ==>
    scores.len() == 2 &&
    scores[0] >= 0 && scores[1] >= 0 &&
    scores[0] + scores[1] == sum(cards) &&
    scores[0] == sereja_optimal_score(cards, 0, cards.len()-1, true) &&
    scores[1] == sum(cards) - sereja_optimal_score(cards, 0, cards.len()-1, true)
}",,"fn solve(cards: Vec<i8>) -> (scores: Vec<i8>)
    requires valid_input(cards@.map(|i, x| x as int))
    ensures valid_output(scores@.map(|i, x| x as int), cards@.map(|i, x| x as int))","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0347,verus,apps,apps_test_1788,,"Given two integers A and B where A = X + Y and B = X - Y, find the original integers X and Y.
The inputs are constrained to be between -100 and 100, and unique integer solutions are guaranteed to exist.","use vstd::prelude::*;

verus! {
spec fn valid_input(a: int, b: int) -> bool {
    -100 <= a <= 100 && -100 <= b <= 100 && (a + b) % 2 == 0 && (a - b) % 2 == 0
}

spec fn correct_solution(a: int, b: int, x: int, y: int) -> bool {
    a == x + y && b == x - y
}",,"fn solve(a: i8, b: i8) -> (result: (i8, i8))
    requires valid_input(a as int, b as int)
    ensures correct_solution(a as int, b as int, result.0 as int, result.1 as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0348,verus,apps,apps_test_1795,,"Given n planes numbered 1 to n, where each plane i likes exactly one other plane f_i (f_i ≠ i),
determine if there exists a love triangle. A love triangle occurs when plane A likes plane B,
plane B likes plane C, and plane C likes plane A.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, f: Seq<int>) -> bool {
    n >= 2 && n <= 5000 &&
    f.len() == n &&
    forall|i: int| 0 <= i < f.len() ==> 1 <= f[i] <= n && f[i] != i + 1
}

spec fn zero_indexed_array(n: int, f: Seq<int>) -> Seq<int>
    recommends valid_input(n, f)
{
    Seq::new(n as nat, |j: int| f[j] - 1)
}

spec fn has_love_triangle_with(n: int, a: Seq<int>) -> bool
    recommends 
        a.len() == n &&
        forall|k: int| 0 <= k < n ==> #[trigger] a[k] >= 0 && #[trigger] a[k] < n
{
    exists|i: int| 0 <= i < n && 
        0 <= a[i] < n && 0 <= a[a[i]] < n && a[a[a[i]]] == i
}

spec fn has_love_triangle(n: int, f: Seq<int>) -> bool
    recommends valid_input(n, f)
{
    let a = zero_indexed_array(n, f);
    has_love_triangle_with(n, a)
}",,"fn solve(n: i8, f: Vec<i8>) -> (result: String)
    requires 
        valid_input(n as int, f@.map(|i: int, x: i8| x as int)),
    ensures 
        result@.len() == 2 || result@.len() == 3,
        (result@.len() == 3) <==> has_love_triangle(n as int, f@.map(|i: int, x: i8| x as int)),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0349,verus,apps,apps_test_1797,,"Given n subway stations where each station i has exactly one outgoing train to station p_i,
and the array p represents a permutation, find the maximum ""convenience"" after changing at 
most 2 values in p. Convenience is defined as the number of ordered pairs (x,y) where you 
can travel from station x to station y using the subway trains.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, p: Seq<int>) -> bool {
  n > 0 && p.len() == n &&
  (forall|i: int| 0 <= i < n ==> 1 <= #[trigger] p[i] <= n) &&
  (forall|i: int, j: int| 0 <= i < j < n ==> #[trigger] p[i] != #[trigger] p[j])
}

spec fn count_true(visited: Seq<bool>) -> int
  decreases visited.len()
{
  if visited.len() == 0 { 0int }
  else { (if visited[0] { 1int } else { 0int }) + count_true(visited.subrange(1, visited.len() as int)) }
}

spec fn sum_of_squares(s: Seq<int>) -> int
  decreases s.len()
{
  if s.len() == 0 { 0int } else { s[0] * s[0] + sum_of_squares(s.subrange(1, s.len() as int)) }
}

spec fn find_unvisited(visited: Seq<bool>) -> int {
  0int  /* placeholder */
}

spec fn get_cycle_length(p: Seq<int>, visited: Seq<bool>, start: int) -> int {
  1int  /* placeholder */
}

spec fn mark_cycle_visited(p: Seq<int>, visited: Seq<bool>, start: int) -> Seq<bool> {
  visited  /* placeholder */
}

spec fn get_cycle_lengths(n: int, p: Seq<int>) -> Seq<int> {
  get_cycles_helper(n, p, Seq::new(n as nat, |i: int| false), Seq::empty())
}

spec fn get_cycles_helper(n: int, p: Seq<int>, visited: Seq<bool>, cycles: Seq<int>) -> Seq<int>
  decreases n - count_true(visited)
{
  if count_true(visited) >= n { cycles }
  else {
    let unvisited = find_unvisited(visited);
    if unvisited == -1int { cycles }
    else if 0 <= unvisited < n {
      let cycle_length = get_cycle_length(p, visited, unvisited);
      let new_visited = mark_cycle_visited(p, visited, unvisited);
      if count_true(new_visited) > count_true(visited) && count_true(new_visited) <= n {
        get_cycles_helper(n, p, new_visited, cycles.push(cycle_length))
      } else {
        cycles.push(cycle_length)
      }
    } else {
      cycles
    }
  }
}",,"fn solve(n: i8, p: Vec<i8>) -> (result: i8)
  requires valid_input(n as int, p@.map(|i: int, x: i8| x as int))
  ensures result > 0","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0350,verus,apps,apps_test_1805,,"Given n matches, find the minimum number of additional matches needed to form a valid equation a + b = c 
where a, b, c are positive integers. Each integer k uses k matches, '+' uses 1 match, '=' uses 1 match.
Total matches needed: a + b + c + 2 = 2(a + b) + 2 since c = a + b.","use vstd::prelude::*;

verus! {
spec fn valid_input(queries: Seq<int>) -> bool {
    forall|i: int| 0 <= i < queries.len() ==> queries[i] >= 2
}

spec fn min_additional_matches(n: int) -> int
    recommends n >= 2
{
    if n >= 4 { n % 2 } else { 4 - n }
}

spec fn valid_result(queries: Seq<int>, results: Seq<int>) -> bool
    recommends valid_input(queries)
{
    results.len() == queries.len() &&
    forall|i: int| 0 <= i < queries.len() ==> results[i] == min_additional_matches(queries[i])
}",,"fn solve(queries: Vec<i8>) -> (results: Vec<i8>)
    requires valid_input(queries@.map(|i: int, x: i8| x as int))
    ensures valid_result(queries@.map(|i: int, x: i8| x as int), results@.map(|i: int, x: i8| x as int))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0351,verus,apps,apps_test_1809,,"Given n books with weights w_i, find the optimal initial stacking order to minimize total weight lifted 
when reading books according to a given sequence. To read book x: lift all books above x, remove x from 
stack, put lifted books back (maintaining order), then place x on top. The book being read is not counted 
as lifted weight.","use vstd::prelude::*;

verus! {

spec fn is_valid_input(s: Seq<char>) -> bool {
    s.len() >= 5 && s[s.len() as int - 1] == '\n'
}

spec fn calculate_result_from_input(s: Seq<char>) -> Seq<char> {
    s /* placeholder implementation */
}",,"fn solve(s: Vec<char>) -> (result: Vec<char>)
    requires 
        s.len() > 0,
        (exists|i: int| 0 <= i < s.len() as int && s@[i] == '\n'),
        is_valid_input(s@),
    ensures 
        result.len() > 0,
        result@[result.len() as int - 1] == '\n'","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0353,verus,apps,apps_test_1826,,"Given a sequence of moves 'U' (up) and 'R' (right), replace consecutive pairs ""RU"" or ""UR"" 
with diagonal moves ""D"" to minimize sequence length. Input format is a number n followed by 
newline, then a string of n characters containing only 'U' and 'R'.","use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 && exists|pos: int| 0 <= pos < input.len() && input[pos] == '\n'
}

spec fn valid_move_sequence(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> s[i] == 'U' || s[i] == 'R'
}

spec fn count_replacements(s: Seq<char>, start: int, length: int) -> int {
    if length <= 1 {
        0
    } else {
        count_replacements_helper(s, start, length, 1, 0)
    }
}

spec fn count_replacements_helper(s: Seq<char>, start: int, length: int, i: int, count: int) -> int
    decreases length - i
{
    if i >= length {
        count
    } else if start + i < s.len() && s[start + i - 1] != s[start + i] {
        if i + 2 <= length {
            count_replacements_helper(s, start, length, i + 2, count + 1)
        } else {
            count + 1
        }
    } else {
        count_replacements_helper(s, start, length, i + 1, count)
    }
}

spec fn minimized_length(original_length: int, replacements: int) -> int {
    original_length - replacements
}",,"fn solve(input: String) -> (result: String)
    requires valid_input(input@)
    ensures result@.len() > 0","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0356,verus,apps,apps_test_1837,,"Given a permutation of integers 0 to n-1, find the maximum number of fixed points
(positions where a[i] = i) after performing at most one swap operation.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, a: Seq<int>) -> bool {
    n >= 1 &&
    a.len() == n &&
    (forall|i: int| #![trigger a[i]] 0 <= i < n ==> 0 <= a[i] < n) &&
    (forall|i: int, j: int| #![trigger a[i], a[j]] 0 <= i < j < n ==> a[i] != a[j]) &&
    (forall|k: int| #![trigger a[k]] 0 <= k < n ==> exists|i: int| 0 <= i < n && a[i] == k)
}

spec fn current_fixed_points(a: Seq<int>) -> int {
    a.len() as int
}

spec fn max_possible_fixed_points(a: Seq<int>) -> int 
    recommends valid_input(a.len() as int, a)
{
    let current = current_fixed_points(a);
    if current == a.len() {
        a.len() as int
    } else if exists|i: int| 0 <= i < a.len() && a[i] != i && a[a[i] as int] == i {
        current + 2
    } else {
        current + 1
    }
}",,"fn solve(n: i8, a: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, a@.map(|i, x| x as int)),
    ensures 
        result as int == max_possible_fixed_points(a@.map(|i, x| x as int)),
        result >= 0,","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0357,verus,apps,apps_test_1840,,"Given s spaceships with attacking powers and b bases with defensive powers and gold amounts,
determine the maximum gold each spaceship can steal. A spaceship can attack any base where 
the spaceship's attacking power is greater than or equal to the base's defensive power.
When attacking a base, the spaceship steals all gold from that base.","use vstd::prelude::*;

verus! {
spec fn valid_input(s: nat, b: nat, attacking_powers: Seq<nat>, bases: Seq<(nat, nat)>) -> bool {
    attacking_powers.len() == s && bases.len() == b
}

spec fn sum_gold_for_spaceship(attacking_power: nat, bases: Seq<(nat, nat)>) -> nat
    decreases bases.len()
{
    if bases.len() == 0 {
        0
    } else if attacking_power >= bases[0].0 {
        bases[0].1 + sum_gold_for_spaceship(attacking_power, bases.subrange(1, bases.len() as int))
    } else {
        sum_gold_for_spaceship(attacking_power, bases.subrange(1, bases.len() as int))
    }
}

spec fn valid_output(s: nat, attacking_powers: Seq<nat>, bases: Seq<(nat, nat)>, result: Seq<nat>) -> bool {
    result.len() == s &&
    (forall|i: int| 0 <= i < s ==> result[i] >= 0) &&
    (forall|i: int| 0 <= i < s && i < attacking_powers.len() ==> 
        result[i] == sum_gold_for_spaceship(attacking_powers[i], bases))
}",,"fn solve(s: u8, b: u8, attacking_powers: Vec<u8>, bases: Vec<(u8, u8)>) -> (result: Vec<u8>)
    requires valid_input(s as nat, b as nat, attacking_powers@.map(|i, x: u8| x as nat), bases@.map(|i, x: (u8, u8)| (x.0 as nat, x.1 as nat)))
    ensures valid_output(s as nat, attacking_powers@.map(|i, x: u8| x as nat), bases@.map(|i, x: (u8, u8)| (x.0 as nat, x.1 as nat)), result@.map(|i, x: u8| x as nat))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0358,verus,apps,apps_test_1841,,"Given an array of n integers and m queries, for each query l_i, find the number of distinct elements
in the suffix of the array starting from position l_i (1-indexed). The suffix includes all elements
from position l_i to the end of the array.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, m: int, a: Seq<int>, queries: Seq<int>) -> bool {
    a.len() == n && queries.len() == m && n >= 1 && m >= 1 &&
    forall|i: int| 0 <= i < m ==> (#[trigger] queries[i], 1 <= queries[i] <= n).1
}

spec fn distinct_count(a: Seq<int>, start: int) -> int
    recommends 0 <= start < a.len()
{
    let suffix_indices = Set::new(|j: int| start <= j < a.len());
    let suffix_values = suffix_indices.map(|j: int| a[j]);
    suffix_values.len() as int
}",,"fn solve(n: i8, m: i8, a: Vec<i8>, queries: Vec<i8>) -> (result: Vec<i8>)
    requires 
        valid_input(n as int, m as int, a@.map(|i, x| x as int), queries@.map(|i, x| x as int))
    ensures 
        result.len() == m &&
        (forall|i: int| 0 <= i < m ==> (#[trigger] result@[i], result@[i] as int == distinct_count(a@.map(|i, x| x as int), queries@[i] as int - 1)).1)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0359,verus,apps,apps_test_1849,,"Given an integer n, consider all integers from 0 to 10^n - 1, each padded with leading zeros to exactly n digits.
A ""block"" is a maximal consecutive sequence of identical digits.
For each length i from 1 to n, count the total number of blocks of length i across all these padded numbers.
Output n integers modulo 998244353, where the i-th integer is the number of blocks of length i.","use vstd::prelude::*;

verus! {

spec const MOD: int = 998244353int;

spec fn valid_input(n: int) -> bool
{
  n >= 1
}

spec fn pow(base: int, exp: int, modulus: int) -> int
  decreases exp
{
  if exp <= 0 { 1int }
  else { (base * pow(base, exp - 1, modulus)) % modulus }
}

spec fn block_count_formula(n: int, i: int) -> int
  recommends n >= 1 && 1 <= i <= n
{
  if i == n { 10int }
  else { 
    ((2int * 9int * pow(10int, n - i - 1, MOD) * 10int) + 
     (if i < n - 1 { ((n - 1 - i) * 9int * 9int * pow(10int, n - i - 2, MOD) * 10int) } else { 0int })) % MOD
  }
}

spec fn valid_result(result: Seq<int>, n: int) -> bool
  recommends n >= 1
{
  result.len() == n &&
  (forall|k: int| 0 <= k < n ==> #[trigger] result[k] >= 0 && #[trigger] result[k] < MOD) &&
  (n >= 1 ==> result[n-1] == 10int) &&
  (forall|i: int| 0 <= i < n-1 ==> #[trigger] result[i] == block_count_formula(n, i+1))
}",,"fn solve(n: i8) -> (result: Vec<i8>)
  requires valid_input(n as int)
  ensures valid_result(result@.map(|_index: int, x: i8| x as int), n as int)","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0360,verus,apps,apps_test_1850,,"Given N astronauts with current point rankings and N point awards for the next race,
find the best possible ranking for astronaut at position D after the race.
The target astronaut gets the maximum award, and we try to minimize awards to astronauts
ahead of them to maximize how many can be overtaken.","use vstd::prelude::*;

verus! {
    spec fn valid_input(n: int, d: int, current_points: Seq<int>, awards: Seq<int>) -> bool {
        n >= 1 && n <= 200000 &&
        d >= 1 && d <= n &&
        current_points.len() == n &&
        awards.len() == n &&
        d-1 < current_points.len() &&
        (forall|i: int| 0 <= i < current_points.len()-1 ==> 
            #[trigger] current_points.index(i) >= current_points.index((i+1) as int)) &&
        (forall|i: int| 0 <= i < awards.len()-1 ==> 
            #[trigger] awards.index(i) >= awards.index((i+1) as int))
    }
    
    spec fn count_overtaken(current_points: Seq<int>, awards: Seq<int>, d: int) -> int
        recommends 
            current_points.len() == awards.len(),
            d >= 1 && d <= current_points.len(),
            d-1 < current_points.len(),
            forall|i: int| 0 <= i < awards.len()-1 ==> 
                #[trigger] awards.index(i) >= awards.index((i+1) as int)
    {
        count_overtaken_helper(current_points, awards, d, 0, 0)
    }
    
    spec fn count_overtaken_helper(current_points: Seq<int>, awards: Seq<int>, d: int, pos: int, used_awards: int) -> int
        recommends 
            current_points.len() == awards.len(),
            d >= 1 && d <= current_points.len(),
            d-1 < current_points.len(),
            forall|i: int| 0 <= i < awards.len()-1 ==> 
                #[trigger] awards.index(i) >= awards.index((i+1) as int),
            0 <= pos <= d-1,
            0 <= used_awards <= awards.len()
        decreases d-1-pos
    {
        if pos >= d-1 {
            0
        } else {
            let target_score = current_points.index(d-1) + awards.index(0);
            let remaining_awards = awards.len() - used_awards;
            if remaining_awards > 0 && used_awards < awards.len() && current_points.index(pos) + awards.index(awards.len()-1-used_awards) <= target_score {
                1 + count_overtaken_helper(current_points, awards, d, pos+1, used_awards+1)
            } else {
                count_overtaken_helper(current_points, awards, d, pos+1, used_awards)
            }
        }
    }",,"fn solve(n: i8, d: i8, current_points: Vec<i8>, awards: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, d as int, current_points@.map(|i, x| x as int), awards@.map(|i, x| x as int))
    ensures 
        1 <= result as int <= d as int,
        result as int == d as int - count_overtaken(current_points@.map(|i, x| x as int), awards@.map(|i, x| x as int), d as int)","{
    assume(false);
    unreached()
}","}

fn main() {}",0,,-1,-1,-1,,1.0
VA0361,verus,apps,apps_test_1877,,"Given a sequence of moves on a 2D grid starting from position (0,0), count the number of times 
the path crosses between two kingdoms separated by the line x = y. Kingdom 1 contains points 
where x > y, Kingdom 2 contains points where x < y, and points where x = y are on the wall/gates.
Moves are 'U' (up: y+1) and 'R' (right: x+1). Count transitions between kingdoms, ignoring 
positions on the wall, with no cost for the initial move from starting position.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, s: Seq<char>) -> bool {
    n >= 0 && s.len() == n && forall|i: int| 0 <= i < s.len() ==> (s[i] == 'U' || s[i] == 'R')
}

spec fn count_kingdom_transitions(s: Seq<char>) -> int {
    if s.len() == 0 { 0 }
    else { count_transitions_helper(s, 0, 0, 0, -1) }
}

spec fn count_transitions_helper(s: Seq<char>, pos: int, x: int, y: int, pred: int) -> int
    decreases s.len() - pos when 0 <= pos <= s.len()
{
    if pos == s.len() { 0 }
    else {
        let new_x = if s[pos] == 'U' { x } else { x + 1 };
        let new_y = if s[pos] == 'U' { y + 1 } else { y };

        if new_x == new_y {
            count_transitions_helper(s, pos + 1, new_x, new_y, pred)
        } else {
            let cur = if new_x > new_y { 0 } else { 1 };
            let transition: int = if cur != pred && pred != -1 { 1 } else { 0 };
            transition + count_transitions_helper(s, pos + 1, new_x, new_y, cur)
        }
    }
}",,"fn solve(n: i8, s: Vec<char>) -> (result: i8)
    requires 
        valid_input(n as int, s@),
        n >= 0
    ensures 
        result >= 0 &&
        result <= n &&
        (n == 0 ==> result == 0) &&
        result as int == count_kingdom_transitions(s@)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0362,verus,apps,apps_test_1878,,"Given n rectangles on a 100×100 grid, where each rectangle is defined by its bottom-left corner (x₁, y₁) and top-right corner (x₂, y₂), 
calculate the sum of all cell values in the grid. Each cell's value equals the number of rectangles that contain it.","use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    input.len() >= 0
}

spec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>>
    decreases s.len()
{
    if s.len() == 0 {
        seq![]
    } else {
        split_lines_helper(s, 0, 0, seq![])
    }
}

spec fn split_lines_helper(s: Seq<char>, start: int, pos: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>>
    decreases s.len() - pos when pos >= 0 && pos <= s.len()
{
    if pos >= s.len() {
        if start < pos {
            acc.push(s.subrange(start, pos))
        } else {
            acc
        }
    } else if s[pos] == '\n' {
        let new_acc = if start < pos {
            acc.push(s.subrange(start, pos))
        } else {
            acc
        };
        split_lines_helper(s, pos + 1, pos + 1, new_acc)
    } else {
        split_lines_helper(s, start, pos + 1, acc)
    }
}

spec fn parse_int_func(s: Seq<char>) -> int {
    if s.len() == 0 {
        0
    } else if s[0] == '-' {
        -parse_int_pos_func(s.subrange(1, s.len() as int))
    } else {
        parse_int_pos_func(s)
    }
}

spec fn parse_int_pos_func(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if '0' <= s[0] && s[0] <= '9' {
        (s[0] as int - '0' as int) + 10 * parse_int_pos_func(s.subrange(1, s.len() as int))
    } else {
        0
    }
}

spec fn parse_ints_func(s: Seq<char>) -> Seq<int> {
    if s.len() == 0 {
        seq![]
    } else {
        parse_ints_helper(s, 0, 0, seq![])
    }
}

spec fn parse_ints_helper(s: Seq<char>, start: int, pos: int, acc: Seq<int>) -> Seq<int>
    decreases s.len() - pos when pos >= 0 && pos <= s.len()
{
    if pos >= s.len() {
        if start < pos {
            acc.push(parse_int_func(s.subrange(start, pos)))
        } else {
            acc
        }
    } else if s[pos] == ' ' {
        let new_acc = if start < pos {
            acc.push(parse_int_func(s.subrange(start, pos)))
        } else {
            acc
        };
        parse_ints_helper(s, pos + 1, pos + 1, new_acc)
    } else {
        parse_ints_helper(s, start, pos + 1, acc)
    }
}

spec fn int_to_string_func(n: int) -> Seq<char> {
    if n == 0 {
        seq!['0']
    } else if n > 0 {
        int_to_string_pos(n)
    } else {
        seq!['-'] + int_to_string_pos(-n)
    }
}

spec fn int_to_string_pos(n: int) -> Seq<char>
    decreases n when n > 0
{
    if n < 10 {
        seq![('0' as int + n) as char]
    } else {
        int_to_string_pos(n / 10) + seq![('0' as int + (n % 10)) as char]
    }
}

spec fn compute_total_area(rectangle_lines: Seq<Seq<char>>) -> int
    decreases rectangle_lines.len()
{
    if rectangle_lines.len() == 0 {
        0
    } else {
        let coords = parse_ints_func(rectangle_lines[0]);
        let area = if coords.len() >= 4 {
            let computed = (coords[2] - coords[0] + 1) * (coords[3] - coords[1] + 1);
            if computed >= 0 { computed } else { 0 }
        } else {
            0
        };
        area + compute_total_area(rectangle_lines.subrange(1, rectangle_lines.len() as int))
    }
}

spec fn compute_total_area_partial(rectangle_lines: Seq<Seq<char>>, n: int) -> int
    decreases n when n >= 0
{
    if n <= 0 || rectangle_lines.len() == 0 {
        0
    } else {
        let coords = parse_ints_func(rectangle_lines[0]);
        let area = if coords.len() >= 4 {
            let computed = (coords[2] - coords[0] + 1) * (coords[3] - coords[1] + 1);
            if computed >= 0 { computed } else { 0 }
        } else {
            0
        };
        area + compute_total_area_partial(rectangle_lines.subrange(1, rectangle_lines.len() as int), n - 1)
    }
}",,"fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(input@),
    ensures 
        result@.len() >= 1,
        result@[result@.len() - 1] == '\n',
        exists|total_area: int| {
            &&& total_area >= 0
            &&& result@ == int_to_string_func(total_area) + seq!['\n']
            &&& {
                let processed_input = if input@.len() > 0 && input@[input@.len() - 1] == '\n' {
                    input@
                } else {
                    input@ + seq!['\n']
                };
                let lines = split_lines_func(processed_input);
                if lines.len() == 0 {
                    total_area == 0
                } else {
                    let n = parse_int_func(lines[0]);
                    if n >= 0 && n + 1 <= lines.len() {
                        total_area == compute_total_area(lines.subrange(1, n + 1))
                    } else {
                        total_area == compute_total_area_partial(lines.subrange(1, lines.len() as int), n)
                    }
                }
            }
        }","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0363,verus,apps,apps_test_1886,,"Given a non-empty word consisting of lowercase and uppercase English letters,
capitalize the first letter while keeping all other letters unchanged.","use vstd::prelude::*;

verus! {

spec fn valid_input(word: Seq<char>) -> bool {
    word.len() > 0 && forall|i: int| 0 <= i < word.len() ==> 
        (('a' <= word[i] && word[i] <= 'z') || ('A' <= word[i] && word[i] <= 'Z'))
}

spec fn correct_capitalization(input: Seq<char>, output: Seq<char>) -> bool {
    valid_input(input) ==> (
        output.len() == input.len() &&
        ('A' <= output[0] && output[0] <= 'Z') &&
        (('a' <= input[0] && input[0] <= 'z') ==> ('A' <= output[0] && output[0] <= 'Z')) &&
        (('A' <= input[0] && input[0] <= 'Z') ==> (output[0] == input[0])) &&
        forall|i: int| 1 <= i < input.len() ==> output[i] == input[i]
    )
}",,"fn capitalize_first_letter(word: Vec<char>) -> (result: Vec<char>)
    requires valid_input(word@)
    ensures correct_capitalization(word@, result@)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0364,verus,apps,apps_test_1887,,"Given two rows of n students each, select a team with maximum total height
such that selected students have strictly increasing indices, no two
consecutive selected students are from the same row, and any number of
students can be selected (including zero).","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, h1: Seq<int>, h2: Seq<int>) -> bool {
    n >= 1 && h1.len() >= n && h2.len() >= n &&
    (forall|i: int| 0 <= i < n ==> h1[i] >= 0) &&
    (forall|i: int| 0 <= i < n ==> h2[i] >= 0)
}

spec fn max_team_height(n: int, h1: Seq<int>, h2: Seq<int>) -> int
    recommends valid_input(n, h1, h2)
{
    let dp1 = max_height_ending_in_row1(n, h1, h2);
    let dp2 = max_height_ending_in_row2(n, h1, h2);
    if dp1 > dp2 { dp1 } else { dp2 }
}

spec fn max_height_ending_in_row1(n: int, h1: Seq<int>, h2: Seq<int>) -> int
    recommends valid_input(n, h1, h2)
    decreases n via max_height_ending_in_row1_decreases
{
    if n == 1 { h1[0] }
    else {
        let prev_row2 = max_height_ending_in_row2(n-1, h1, h2);
        let prev_row1 = max_height_ending_in_row1(n-1, h1, h2);
        let take_from_row2 = prev_row2 + h1[n-1];
        if take_from_row2 > prev_row1 { take_from_row2 } else { prev_row1 }
    }
}

spec fn max_height_ending_in_row2(n: int, h1: Seq<int>, h2: Seq<int>) -> int
    recommends valid_input(n, h1, h2)
    decreases n via max_height_ending_in_row2_decreases
{
    if n == 1 { h2[0] }
    else {
        let prev_row1 = max_height_ending_in_row1(n-1, h1, h2);
        let prev_row2 = max_height_ending_in_row2(n-1, h1, h2);
        let take_from_row1 = prev_row1 + h2[n-1];
        if take_from_row1 > prev_row2 { take_from_row1 } else { prev_row2 }
    }
}

#[via_fn]
proof fn max_height_ending_in_row1_decreases(n: int, h1: Seq<int>, h2: Seq<int>) {
    assume(false);
}

#[via_fn]
proof fn max_height_ending_in_row2_decreases(n: int, h1: Seq<int>, h2: Seq<int>) {
    assume(false);
}",,"fn solve(n: i8, h1: Vec<i8>, h2: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, h1@.map_values(|x: i8| x as int), h2@.map_values(|x: i8| x as int))
    ensures 
        result >= 0,
        result as int == max_team_height(n as int, h1@.map_values(|x: i8| x as int), h2@.map_values(|x: i8| x as int))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0365,verus,apps,apps_test_1889,,"Given an n×m grid where each cell contains either 0 or 1, process q queries.
Each query flips the value at position (i,j) from 0 to 1 or 1 to 0.
After each query, calculate the score: the maximum length of consecutive 1s across all rows in the grid.","use vstd::prelude::*;

verus! {
spec fn valid_grid(grid: Seq<Seq<int>>, n: int, m: int) -> bool {
    grid.len() == n && n > 0 && m > 0 &&
    (forall|i: int| 0 <= i < n ==> grid[i].len() == m) &&
    (forall|i: int, j: int| 0 <= i < n && 0 <= j < m ==> grid[i][j] == 0 || grid[i][j] == 1)
}

spec fn valid_queries(queries: Seq<(int, int)>, q: int, n: int, m: int) -> bool {
    queries.len() == q && q >= 0 &&
    (forall|k: int| 0 <= k < q ==> #[trigger] queries[k].0 >= 1 && queries[k].0 <= n && queries[k].1 >= 1 && queries[k].1 <= m)
}

spec fn cons_helper(l: Seq<int>, index: int, current: int, max_so_far: int) -> int
    decreases l.len() - index
{
    if index >= l.len() {
        max_so_far
    } else if l[index] == 1 {
        let new_current = current + 1;
        let new_max = if new_current > max_so_far { new_current } else { max_so_far };
        cons_helper(l, index + 1, new_current, new_max)
    } else {
        cons_helper(l, index + 1, 0, max_so_far)
    }
}

spec fn cons(l: Seq<int>) -> int {
    cons_helper(l, 0, 0, 0)
}

spec fn max_in_seq(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if s.len() == 1 {
        s[0]
    } else {
        let rest = max_in_seq(s.subrange(1, s.len() as int));
        if s[0] > rest { s[0] } else { rest }
    }
}

spec fn compute_score(grid: Seq<Seq<int>>) -> int {
    if grid.len() == 0 {
        0
    } else {
        let row_scores = Seq::new(grid.len(), |i: int| cons(grid[i]));
        max_in_seq(row_scores)
    }
}",,"fn solve(n: i8, m: i8, q: i8, grid: Vec<Vec<i8>>, queries: Vec<(i8, i8)>) -> (results: Vec<i8>)
    requires 
        valid_grid(grid@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)), n as int, m as int),
        valid_queries(queries@.map(|k: int, query: (i8, i8)| (query.0 as int, query.1 as int)), q as int, n as int, m as int),
    ensures 
        results.len() == q,","{
    // impl-start
    assume(false);
    Vec::new()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0366,verus,apps,apps_test_1909,,"Given n tasks numbered 1 to n and parameter k, find the starting task that minimizes
total ""telling off power"" when Dima performs tasks in circular order and Inna
interrupts every k tasks (1st, (k+1)th, (2k+1)th, etc.).","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, k: int, powers: Seq<int>) -> bool {
    n > 0 && k > 0 && k <= n && n % k == 0 && powers.len() == n
}

spec fn is_optimal_starting_task(result: int, n: int, k: int, powers: Seq<int>) -> bool {
    1 <= result <= k
}",,"fn solve(n: i8, k: i8, powers: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, k as int, powers@.map(|i: int, x: i8| x as int))
    ensures is_optimal_starting_task(result as int, n as int, k as int, powers@.map(|i: int, x: i8| x as int))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0368,verus,apps,apps_test_1922,,"Given an N×M grid of cards (all initially face up), perform one operation for each card position (i,j): 
flip the card at position (i,j) and all cards in the 8 adjacent positions (sharing a side or corner), 
if those positions exist in the grid. Determine how many cards face down after all N×M operations are completed.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, m: int) -> bool {
    n >= 1 && m >= 1
}

spec fn count_face_down_cards(n: int, m: int) -> int
    recommends valid_input(n, m)
{
    if n == 1 && m == 1 {
        1
    } else if n == 1 {
        m - 2
    } else if m == 1 {
        n - 2
    } else {
        (n - 2) * (m - 2)
    }
}",,"fn solve(n: i8, m: i8) -> (result: i8)
    requires 
        valid_input(n as int, m as int),
    ensures 
        result as int == count_face_down_cards(n as int, m as int),
        result >= 0,","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0369,verus,apps,apps_test_1925,,"Given integers A, B, and N, find the maximum value of floor(A*x/B) - A*floor(x/B) 
over all non-negative integers x where 0 ≤ x ≤ N.

/* B must be positive */

/* default values with B=1 to avoid division by zero */","use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 && 
    parse_three_ints_func(input).1 > 0
}

spec fn parse_three_ints_func(s: Seq<char>) -> (int, int, int) 
    recommends s.len() > 0
{
    let nums = parse_numbers(s, 0, seq![], 0, false);
    if nums.len() >= 3 { 
        (nums[0], if nums[1] > 0 { nums[1] } else { 1 }, nums[2])
    } else { 
        (0, 1, 0) 
    }
}

spec fn parse_numbers(s: Seq<char>, i: int, nums: Seq<int>, current: int, in_number: bool) -> Seq<int>
    recommends 0 <= i <= s.len()
    decreases s.len() - i
{
    if i >= s.len() {
        if in_number && nums.len() < 3 { nums.push(current) } else { nums }
    } else if nums.len() >= 3 {
        nums
    } else {
        let c = s[i];
        if c >= '0' && c <= '9' {
            let digit = c as int - '0' as int;
            if !in_number {
                parse_numbers(s, i + 1, nums, digit, true)
            } else {
                parse_numbers(s, i + 1, nums, current * 10 + digit, true)
            }
        } else if in_number {
            parse_numbers(s, i + 1, nums.push(current), 0, false)
        } else {
            parse_numbers(s, i + 1, nums, current, false)
        }
    }
}

spec fn int_to_string_func(n: int) -> Seq<char> {
    if n == 0 { seq!['0'] }
    else if n < 0 { seq!['-'].add(int_to_string_helper_func(-n)) }
    else { int_to_string_helper_func(n) }
}

spec fn int_to_string_helper_func(n: int) -> Seq<char> 
    recommends n > 0
    decreases n
{
    if n < 10 {
        seq![('0' as int + n) as char]
    } else {
        int_to_string_helper_func(n / 10).add(seq![('0' as int + (n % 10)) as char])
    }
}

spec fn compute_max_value(a: int, b: int, n: int) -> int 
    recommends b > 0
{
    let min_val = if b - 1 < n { b - 1 } else { n };
    (a * min_val) / b
}",,"fn solve(input: String) -> (result: String)
    requires 
        input@.len() > 0,
        valid_input(input@),
    ensures ({
        let parts = parse_three_ints_func(input@);
        let a = parts.0;
        let b = parts.1;  
        let n = parts.2;
        b > 0 &&
        result@ == int_to_string_func(compute_max_value(a, b, n)).add(seq!['\n'])
    })","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0370,verus,apps,apps_test_1926,,"Given an array of n integers, for each k from 1 to n-1, construct a k-ary heap structure 
and count the number of min-heap property violations. In a k-ary heap with 1-indexed elements,
element at index i has parent at index ⌊(i+k-2)/k⌋ (for i > 1). A violation occurs when 
a[child] < a[parent].","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, a: Seq<int>) -> bool {
  n >= 2 && a.len() == n
}

spec fn count_violations_for_k(a: Seq<int>, n: int, k: int) -> int {
  let violations = Set::new(|i: int| 2 <= i <= n && {
    let parent_idx = (i + k - 2) / k;
    parent_idx >= 1 && a[i-1] < a[parent_idx-1]
  });
  violations.len() as int
}

spec fn valid_output(result: Seq<int>, n: int, a: Seq<int>) -> bool {
  result.len() == n - 1 &&
  (forall|k: int| 1 <= k <= n - 1 ==> #[trigger] result[k-1] >= 0) &&
  (forall|k: int| 1 <= k <= n - 1 ==> #[trigger] result[k-1] == count_violations_for_k(a, n, k))
}",,"fn solve(n: i8, a: Vec<i8>) -> (result: Vec<i8>)
  requires valid_input(n as int, a@.map(|_i, x| x as int))
  ensures valid_output(result@.map(|_i, x| x as int), n as int, a@.map(|_i, x| x as int))","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0372,verus,apps,apps_test_1940,,"Given n types of pebbles with w_i pebbles of type i, and a person with 2 pockets 
that can each hold at most k pebbles, find the minimum number of days needed to 
collect all pebbles. Different pebble types cannot be mixed in the same pocket, 
both pockets can be used simultaneously on the same day, and each pebble type 
must be collected completely.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, k: int, w: Seq<int>) -> bool {
    k > 0 && n >= 0 && w.len() == n && forall|i: int| 0 <= i < w.len() ==> w[i] >= 0
}

spec fn sum_trips(w: Seq<int>, k: int) -> int
    decreases w.len()
{
    if w.len() == 0 {
        0
    } else {
        (w[0] + k - 1) / k + sum_trips(w.drop_first(), k)
    }
}",,"fn solve(n: i8, k: i8, w: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, k as int, w@.map_values(|v: i8| v as int)),
    ensures 
        result >= 0,
        result as int == (sum_trips(w@.map_values(|v: i8| v as int), k as int) + 1) / 2,","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0374,verus,apps,apps_test_1958,,"Given n buyers and cost p per apple, determine total money seller should receive.
Each buyer purchased exactly half the apples available at their turn.
If apples were odd, buyer received additional half apple as gift.
Seller started with some positive number of apples and ended with zero apples.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, p: int, buyers: Seq<&str>) -> bool {
    1 <= n <= 40 &&
    2 <= p <= 1000 &&
    p % 2 == 0 &&
    buyers.len() == n &&
    forall|i: int| 0 <= i < buyers.len() ==> buyers[i] == ""half"" || buyers[i] == ""halfplus""
}

spec fn compute_total_payment(buyers: Seq<&str>, p: int) -> int
    recommends p >= 0,
                p % 2 == 0,
                forall|i: int| 0 <= i < buyers.len() ==> buyers[i] == ""half"" || buyers[i] == ""halfplus""
{
    compute_payment_backward(buyers, p, buyers.len() - 1, 0)
}

spec fn compute_payment_backward(buyers: Seq<&str>, p: int, current_index: int, current_apples: int) -> int
    recommends p >= 0,
                p % 2 == 0,
                -1 <= current_index < buyers.len(),
                current_apples >= 0,
                forall|i: int| 0 <= i < buyers.len() ==> buyers[i] == ""half"" || buyers[i] == ""halfplus""
    decreases current_index + 1
{
    if current_index < 0 {
        0
    } else {
        let new_apples = if buyers[current_index] == ""halfplus"" { 
                            current_apples * 2 + 1
                         } else { 
                            current_apples * 2
                         };
        let payment = if buyers[current_index] == ""halfplus"" { 
                          (new_apples / 2) * p
                       } else { 
                          current_apples * p
                       };
        payment + compute_payment_backward(buyers, p, current_index - 1, new_apples)
    }
}",,"fn solve(n: i8, p: i8, buyers: Vec<&str>) -> (result: i8)
    requires valid_input(n as int, p as int, buyers@)
    ensures result >= 0,
            result as int == compute_total_payment(buyers@, p as int)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0375,verus,apps,apps_test_1965,,"Given n accounts with integer ratings and one infected account (Killjoy's) with rating x,
find the minimum number of contests needed to infect all n accounts.
Infection spreads instantly to accounts with the same rating.
In contests, participants can change ratings (sum of changes = 0), Killjoy cannot participate.","use vstd::prelude::*;

verus! {
spec fn count_occurrences(s: Seq<int>, x: int) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if s[0] == x {
        1 + count_occurrences(s.drop_first(), x)
    } else {
        count_occurrences(s.drop_first(), x)
    }
}

spec fn sum(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else {
        s[0] + sum(s.drop_first())
    }
}

spec fn valid_input(n: int, ratings: Seq<int>) -> bool {
    n >= 2 && ratings.len() == n
}

spec fn all_infected(k: int, ratings: Seq<int>) -> bool {
    ratings.contains(k) && count_occurrences(ratings, k) == ratings.len()
}

spec fn can_infect_in_one_contest(k: int, ratings: Seq<int>) -> bool {
    (ratings.contains(k) && count_occurrences(ratings, k) != ratings.len()) ||
    (!ratings.contains(k) && k * ratings.len() == sum(ratings))
}

spec fn requires_two_contests(k: int, ratings: Seq<int>) -> bool {
    !ratings.contains(k) && k * ratings.len() != sum(ratings)
}",,"fn solve_case(n: i8, k: i8, ratings: Vec<i8>) -> (answer: i8)
    requires 
        valid_input(n as int, ratings@.map(|i: int, x: i8| x as int))
    ensures 
        answer >= 0 && answer <= 2,
        all_infected(k as int, ratings@.map(|i: int, x: i8| x as int)) ==> answer == 0,
        can_infect_in_one_contest(k as int, ratings@.map(|i: int, x: i8| x as int)) && !all_infected(k as int, ratings@.map(|i: int, x: i8| x as int)) ==> answer == 1,
        requires_two_contests(k as int, ratings@.map(|i: int, x: i8| x as int)) ==> answer == 2","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0381,verus,apps,apps_test_1985,,"Given k jury members who sequentially add points to an initial score, determine how many
possible initial scores could produce a given set of observed intermediate scores.","use vstd::prelude::*;

verus! {

spec fn sum(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 { 0 } else { s[0] + sum(s.subrange(1, s.len() as int)) }
}

spec fn compute_initial_score(pos: int, a: Seq<int>, b: Seq<int>) -> int
    recommends 0 <= pos < a.len(), b.len() > 0
{
    b[0] - sum(a.subrange(0, pos + 1))
}

spec fn compute_backward_scores(pos: int, score_at_pos: int, a: Seq<int>) -> Set<int>
    recommends 0 <= pos < a.len()
    decreases pos
    when pos >= 0
{
    if pos == 0 { 
        set![score_at_pos] 
    } else { 
        set![score_at_pos].union(compute_backward_scores(pos - 1, score_at_pos - a[pos], a))
    }
}

spec fn compute_forward_scores(pos: int, score_at_pos: int, a: Seq<int>) -> Set<int>
    recommends 0 <= pos < a.len()
    decreases a.len() - pos
    when pos < a.len()
{
    if pos == a.len() - 1 { 
        Set::empty() 
    } else { 
        compute_forward_scores(pos + 1, score_at_pos + a[pos + 1], a).insert(score_at_pos + a[pos + 1])
    }
}

spec fn compute_scores(pos: int, score_at_pos: int, a: Seq<int>) -> Set<int>
    recommends 0 <= pos < a.len()
{
    let backwards = compute_backward_scores(pos, score_at_pos, a);
    let forwards = compute_forward_scores(pos, score_at_pos, a);
    backwards.union(forwards)
}

spec fn is_valid_initial_score(pos: int, k: int, a: Seq<int>, b: Seq<int>) -> bool
    recommends 0 <= pos < k, k > 0, a.len() == k, b.len() > 0
{
    let scores = compute_scores(pos, b[0], a);
    forall|j: int| 0 <= j < b.len() ==> #[trigger] scores.contains(b[j])
}

spec fn valid_initial_scores(k: int, a: Seq<int>, b: Seq<int>) -> Set<int>
    recommends 
        k > 0,
        a.len() == k,
        b.len() > 0,
        forall|i: int| 0 <= i < k ==> -2000 <= #[trigger] a[i] <= 2000,
        forall|i: int| 0 <= i < b.len() ==> -4000000 <= #[trigger] b[i] <= 4000000
{
    Set::new(|x: int| exists|i: int| #[trigger] is_valid_initial_score(i, k, a, b) && 0 <= i < k && x == compute_initial_score(i, a, b))
}

spec fn valid_input(k: int, n: int, a: Seq<int>, b: Seq<int>) -> bool
{
    k > 0 && n > 0 && a.len() == k && b.len() == n && n <= k &&
    (forall|i: int, j: int| 0 <= i < j < n ==> #[trigger] b[i] != #[trigger] b[j]) &&
    (forall|i: int| 0 <= i < k ==> -2000 <= #[trigger] a[i] <= 2000) &&
    (forall|i: int| 0 <= i < n ==> -4000000 <= #[trigger] b[i] <= 4000000)
}",,"fn solve(k: i8, n: i8, a: Vec<i8>, b: Vec<i8>) -> (result: i8)
    requires
        valid_input(k as int, n as int, a@.map_values(|x: i8| x as int), b@.map_values(|x: i8| x as int))
    ensures
        result >= 0,
        result <= k,
        result as int == valid_initial_scores(k as int, a@.map_values(|x: i8| x as int), b@.map_values(|x: i8| x as int)).len(),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0382,verus,apps,apps_test_1988,,"Given multiple test cases, each containing a string, find the lexicographically smallest
string achievable by applying one of n possible transformations, where transformation i
either rotates the string by i positions or rotates and reverses the prefix based on parity.","use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>) -> bool {
    s.len() >= 2 &&
    (s.last() == '\n' || (s.len() >= 2 && s.subrange(s.len() - 2, s.len() as int) == seq!['\n']))
}

spec fn valid_output(result: Seq<char>) -> bool {
    result.len() >= 0 &&
    (result.len() == 0 || result.last() == '\n')
}

spec fn transform_string(input_str: Seq<char>, n: int, k: int) -> Seq<char>
    recommends 1 <= k <= n && input_str.len() == n
{
    let i = k - 1;
    if (n - i) % 2 == 0 {
        input_str.subrange(i, n as int) + input_str.subrange(0, i)
    } else {
        input_str.subrange(i, n as int) + reverse_string(input_str.subrange(0, i))
    }
}

spec fn is_lexicographically_optimal(result_str: Seq<char>, input_str: Seq<char>, n: int, k: int) -> bool
    recommends input_str.len() == n
{
    1 <= k <= n &&
    result_str == transform_string(input_str, n, k) &&
    true /* Simplified to avoid trigger issues */
}

spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {
    seq![] /* TODO: Define line splitting logic */
}

spec fn parse_int(line: Seq<char>) -> int {
    0 /* TODO: Define integer parsing logic */
}

spec fn is_lowercase_letter(c: char) -> bool {
    'a' <= c && c <= 'z'
}

spec fn reverse_string(s: Seq<char>) -> Seq<char> {
    s /* TODO: Define string reversal logic */
}

spec fn lexicographically_le(s1: Seq<char>, s2: Seq<char>) -> bool {
    true /* TODO: Define lexicographic comparison */
}",,"fn solve(s: &str) -> (result: String)
  requires valid_input(s@)
  ensures valid_output(result@)","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0383,verus,apps,apps_test_2015,,"Given three integers representing counts of red, green, and blue lamps,
determine if it's possible to arrange all lamps in a line such that
no two adjacent lamps have the same color.","use vstd::prelude::*;

verus! {

spec fn valid_input(r: int, g: int, b: int) -> bool {
    r >= 1 && g >= 1 && b >= 1
}

spec fn max_of_3(r: int, g: int, b: int) -> int {
    if r >= g && r >= b {
        r
    } else if g >= r && g >= b {
        g
    } else {
        b
    }
}

spec fn can_arrange(r: int, g: int, b: int) -> bool
    recommends valid_input(r, g, b)
{
    let max_count = max_of_3(r, g, b);
    let total = r + g + b;
    2 * max_count <= total + 1
}",,"fn check_lamp_arrangement(r: i8, g: i8, b: i8) -> (result: bool)
    requires valid_input(r as int, g as int, b as int)
    ensures result == can_arrange(r as int, g as int, b as int)","{
    assume(false);
    false
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0384,verus,apps,apps_test_2025,,"Given a positive integer n, express it as a sum of composite numbers using the maximum possible number of summands.
A composite number is an integer greater than 1 that is not prime (has positive divisors other than 1 and itself).
For each query, return the maximum number of composite summands, or -1 if no such splitting exists.","use vstd::prelude::*;

verus! {
spec fn is_composite(x: int) -> bool {
    x >= 4 && exists|k: int| 2 <= k < x && #[trigger] (x % k) == 0
}

spec fn valid_input(queries: Seq<int>) -> bool {
    forall|i: int| 0 <= i < queries.len() ==> queries[i] >= 1
}

spec fn max_composite_summands(n: int) -> int {
    if n % 4 == 0 {
        n / 4
    } else if n % 4 == 1 && n / 4 >= 2 {
        n / 4 - 1
    } else if n % 4 == 2 && n / 4 >= 1 {
        n / 4
    } else if n % 4 == 3 && n / 4 >= 3 {
        n / 4 - 1
    } else {
        -1
    }
}

spec fn valid_result(queries: Seq<int>, results: Seq<int>) -> bool {
    results.len() == queries.len() &&
    forall|i: int| 0 <= i < queries.len() ==> results[i] == max_composite_summands(queries[i]) &&
    forall|i: int| 0 <= i < queries.len() ==> results[i] >= -1
}",,"fn solve(queries: Vec<i8>) -> (results: Vec<i8>)
    requires valid_input(queries@.map(|i, x: i8| x as int))
    ensures valid_result(queries@.map(|i, x: i8| x as int), results@.map(|i, x: i8| x as int))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0385,verus,apps,apps_test_2039,,"Given an array of integers, count the number of local extrema.
A local minimum is an element strictly less than both neighbors.
A local maximum is an element strictly greater than both neighbors.
First and last elements cannot be local extrema since they lack two neighbors.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, a: Seq<int>) -> bool {
    n >= 1 && a.len() == n
}

spec fn count_local_extrema(n: int, a: Seq<int>) -> int
    recommends valid_input(n, a)
{
    Set::<int>::new(|i: int| 1 <= i < n - 1 && ((a[i] > a[i-1] && a[i] > a[i+1]) || (a[i] < a[i-1] && a[i] < a[i+1]))).len() as int
}

spec fn is_local_extremum(a: Seq<int>, i: int) -> bool
    recommends 0 <= i < a.len()
{
    1 <= i < a.len() - 1 && ((a[i] > a[i-1] && a[i] > a[i+1]) || (a[i] < a[i-1] && a[i] < a[i+1]))
}",,"fn solve(n: i8, a: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, a@.map_values(|x: i8| x as int))
    ensures 
        result >= 0,
        n <= 2 ==> result == 0,
        n > 2 ==> result <= n - 2,
        result as int == count_local_extrema(n as int, a@.map_values(|x: i8| x as int))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0386,verus,apps,apps_test_2044,,"Given a notebook with infinite pages where each page holds exactly m names,
write names for n consecutive days. On day i, write exactly a_i names.
Fill pages sequentially - when a page becomes full, turn to the next page.
Determine how many times you turn pages on each day.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, m: int, a: Seq<int>) -> bool {
    n >= 1 && m >= 1 && a.len() == n && 
    (forall|i: int| 0 <= i < a.len() ==> a[i] >= 1)
}

spec fn valid_output(result: Seq<int>, n: int) -> bool {
    result.len() == n && (forall|i: int| 0 <= i < result.len() ==> result[i] >= 0)
}

spec fn compute_page_turns(a: Seq<int>, m: int, i: int, s: int) -> int
    recommends m >= 1, i >= 0, s >= 0
{
    if i >= a.len() { 0 }
    else { (s + a[i]) / m }
}

spec fn compute_next_state(a: Seq<int>, m: int, i: int, s: int) -> int
    recommends m >= 1, i >= 0, s >= 0
{
    if i >= a.len() { s }
    else { (s + a[i]) % m }
}

spec fn correct_page_turns(result: Seq<int>, a: Seq<int>, m: int) -> bool
    recommends m >= 1
{
    result.len() == a.len() &&
    (forall|i: int| 0 <= i < a.len() ==> {
        let s = compute_state_at(a, m, i);
        #[trigger] result[i] == (s + a[i]) / m
    })
}

spec fn compute_state_at(a: Seq<int>, m: int, day: int) -> int
    recommends m >= 1, day >= 0
    decreases day
{
    if day <= 0 { 0 }
    else if day > a.len() { compute_state_at(a, m, a.len() as int) }
    else if day > 0 && day <= a.len() { (compute_state_at(a, m, day - 1) + a[day - 1]) % m }
    else { 0 }
}",,"fn solve(n: i8, m: i8, a: Vec<i8>) -> (result: Vec<i8>)
requires
    valid_input(n as int, m as int, a@.map(|i: int, x: i8| x as int))
ensures
    valid_output(result@.map(|i: int, x: i8| x as int), n as int),
    correct_page_turns(result@.map(|i: int, x: i8| x as int), a@.map(|i: int, x: i8| x as int), m as int)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0387,verus,apps,apps_test_2049,,"Given an array of n integers and m queries, determine for each query whether a specified subsegment forms a ""ladder"".
A ladder is a sequence that first non-decreases, then non-increases. Formally, there exists a position x such that 
elements are non-decreasing up to position x, then non-increasing from position x onward.","use vstd::prelude::*;

verus! {

spec fn is_ladder(arr: Seq<int>, l: int, r: int) -> bool {
  &&& 0 <= l <= r < arr.len()
  &&& if l == r {
    true
  } else {
    exists|k: int| l <= k <= r && 
      is_non_decreasing(arr, l, k) && 
      is_non_increasing(arr, k, r)
  }
}

spec fn is_non_decreasing(arr: Seq<int>, start: int, end: int) -> bool {
  &&& 0 <= start <= end < arr.len()
  &&& forall|i: int| start <= i < end ==> #[trigger] arr[i] <= arr[i+1]
}

spec fn is_non_increasing(arr: Seq<int>, start: int, end: int) -> bool {
  &&& 0 <= start <= end < arr.len()
  &&& forall|i: int| start <= i < end ==> #[trigger] arr[i] >= arr[i+1]
}",,"fn solve(n: i8, m: i8, arr: Vec<i8>, queries: Vec<(i8, i8)>) -> (results: Vec<Vec<char>>)
  requires 
    n >= 1 && m >= 1,
    arr@.len() == n as int,
    queries@.len() == m as int,
    forall|i: int| 0 <= i < m as int ==> 1 <= #[trigger] queries@[i].0 as int <= queries@[i].1 as int <= n as int,
  ensures 
    results@.len() == m as int,
    forall|i: int| 0 <= i < m as int ==> #[trigger] results@[i]@ == seq!['Y', 'e', 's'] || results@[i]@ == seq!['N', 'o'],
    forall|i: int| 0 <= i < m as int ==> 
      (#[trigger] results@[i]@ == seq!['Y', 'e', 's'] <==> is_ladder(arr@.map(|_i, v| v as int), queries@[i].0 as int - 1, queries@[i].1 as int - 1)),","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0388,verus,apps,apps_test_2074,,"Two players play a sequential game on a grid of restaurant costs.
Emma (first player) chooses a row to maximize final cost.
Jack (second player) then chooses a column to minimize final cost.
Both play optimally. Find the resulting cost when both play optimally.","use vstd::prelude::*;

verus! {

spec fn valid_grid(grid: Seq<Seq<int>>) -> bool {
    grid.len() > 0 && forall|i: int| #![auto] 0 <= i < grid.len() ==> grid[i].len() > 0
}

spec fn seq_min(s: Seq<int>) -> int 
    recommends s.len() > 0
    decreases s.len()
    when s.len() > 0
{
    if s.len() == 1 { 
        s[0]
    } else {
        let tail_min = seq_min(s.drop_first());
        if s[0] <= tail_min { 
            s[0]
        } else { 
            tail_min
        }
    }
}

spec fn seq_max(s: Seq<int>) -> int
    recommends s.len() > 0
    decreases s.len()
    when s.len() > 0
{
    if s.len() == 1 { 
        s[0]
    } else {
        let tail_max = seq_max(s.drop_first());
        if s[0] >= tail_max { 
            s[0]
        } else { 
            tail_max
        }
    }
}",,"fn solve(grid: Vec<Vec<i8>>) -> (result: i8)
    requires valid_grid(grid@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)))
    ensures ({
        let grid_spec = grid@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int));
        let row_mins = Seq::new(grid_spec.len(), |i: int| seq_min(grid_spec[i]));
        result as int == seq_max(row_mins)
    })","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0389,verus,apps,apps_test_2080,,"Given q queries with numbers n_i, find the maximum number of edges in a simple undirected graph
with n_i vertices where at least half of the edges are bridges. A bridge is an edge whose
removal increases the number of connected components in the graph.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int) -> bool {
    1 <= n <= 2000000000
}

spec fn valid_output(n: int, result: int) -> bool {
    result >= 0 &&
    result >= n - 1 &&
    result <= n * (n - 1) / 2
}

spec fn compute_expected_result(n: int) -> int {
    let quad_solv_numerator = isqrt(8*n + 1) - 1;
    let x = quad_solv_numerator / 2;
    let y = x + 1;
    let xed = x * (x - 1) / 2 + n - x;
    let ybr = n - y;
    let yed = 2 * ybr;
    if xed > yed { xed } else { yed }
}

spec fn isqrt(n: int) -> int {
    if n == 0 { 0 }
    else if n == 1 { 1 }
    else if n <= 3 { 1 }
    else {
        let guess = n / 2;
        let low = 0;
        let high = guess + 1;
        isqrt_helper(n, low, high)
    }
}

spec fn isqrt_helper(n: int, low: int, high: int) -> int
    decreases high - low
{
    if high - low <= 1 { low }
    else {
        let mid = (low + high) / 2;
        if mid * mid <= n {
            isqrt_helper(n, mid, high)
        } else {
            isqrt_helper(n, low, mid)
        }
    }
}",,"fn solve(n: i8) -> (result: i8)
    requires 
        valid_input(n as int),
    ensures
        valid_output(n as int, result as int),
        result as int == compute_expected_result(n as int),","{
    assume(false);
    0
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0392,verus,apps,apps_test_2104,,"Given integers l and r where l < r, partition all integers from l to r (inclusive) 
into exactly (r-l+1)/2 pairs such that each pair (i,j) has gcd(i,j) = 1. 
Each number must appear in exactly one pair.","use vstd::prelude::*;

verus! {
spec fn valid_input(l: int, r: int) -> bool {
    l < r && (r - l) % 2 == 1
}

spec fn gcd(a: int, b: int) -> int
    recommends a != 0 || b != 0
    decreases (if a >= 0 { a } else { -a })
{
    if a == 0 {
        if b >= 0 { b } else { -b }
    } else {
        gcd(b % a, a)
    }
}

spec fn pair_has_gcd_one(pair: Seq<char>, l: int, r: int) -> bool {
    exists|i: int, j: int| l <= i <= r && l <= j <= r && i != j &&
        pair == int_to_string(i).add(seq![' ']).add(int_to_string(j)) &&
        (i != 0 || j != 0) && gcd(i, j) == 1
}

spec fn valid_solution(result: Seq<Seq<char>>, l: int, r: int) -> bool {
    result.len() >= 1 &&
    result[0] == seq!['Y', 'E', 'S'] &&
    result.len() == 1 + (r - l + 1) / 2 &&
    (forall|i: int| 1 <= i < result.len() ==> pair_has_gcd_one(result[i], l, r))
}

spec fn int_to_string(n: int) -> Seq<char> {
    if n == 0 {
        seq!['0']
    } else if n > 0 {
        int_to_string_pos(n)
    } else {
        seq!['-'].add(int_to_string_pos(-n))
    }
}

spec fn int_to_string_pos(n: int) -> Seq<char>
    recommends n > 0
    decreases n
{
    if n < 10 {
        seq![char_from_digit(n)]
    } else {
        int_to_string_pos(n / 10).push(char_from_digit(n % 10))
    }
}

spec fn char_from_digit(d: int) -> char
    recommends 0 <= d <= 9
{
    if d == 0 { '0' }
    else if d == 1 { '1' }
    else if d == 2 { '2' }
    else if d == 3 { '3' }
    else if d == 4 { '4' }
    else if d == 5 { '5' }
    else if d == 6 { '6' }
    else if d == 7 { '7' }
    else if d == 8 { '8' }
    else if d == 9 { '9' }
    else { '0' }
}",,"fn solve(l: i8, r: i8) -> (result: Vec<Vec<char>>)
    requires valid_input(l as int, r as int)
    ensures
        result.len() >= 1,
        result[0]@ == seq!['Y', 'E', 'S'],
        result.len() == 1 + (r as int - l as int + 1) / 2,
        forall|i: int| 1 <= i < result.len() ==> 
            #[trigger] result[i]@ == int_to_string(l as int + 2 * (i - 1)).add(seq![' ']).add(int_to_string(l as int + 2 * (i - 1) + 1))","{
    assume(false);
    Vec::new()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0394,verus,apps,apps_test_2123,,"Given n+1 pylons numbered 0 to n, where pylon 0 has height 0 and pylons 1 to n have heights h₁, h₂, ..., hₙ.
A player starts at pylon 0 with 0 energy and wants to reach pylon n by jumping from pylon k to pylon k+1.
Each jump from pylon k to k+1 changes energy by (hₖ - hₖ₊₁). Energy must remain non-negative at all times.
The player can pay $1 to increase any pylon's height by 1. Find the minimum cost to make the journey possible.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, heights: Seq<int>) -> bool {
    n > 0 && heights.len() == n
}

spec fn max_in_seq(s: Seq<int>) -> int
    recommends s.len() > 0
    decreases s.len()
    via max_in_seq_decreases
{
    if s.len() == 1 {
        s[0]
    } else {
        let tail = s.subrange(1, s.len() as int);
        let tail_max = max_in_seq(tail);
        if s[0] >= tail_max { s[0] } else { tail_max }
    }
}

#[via_fn]
proof fn max_in_seq_decreases(s: Seq<int>) {
    assume(false);
}

spec fn valid_result(n: int, heights: Seq<int>, result: int) -> bool
    recommends valid_input(n, heights)
{
    result == max_in_seq(heights) &&
    forall|i: int| 0 <= i < heights.len() ==> heights[i] <= result &&
    exists|i: int| 0 <= i < heights.len() && heights[i] == result
}",,"fn solve(n: i8, heights: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, heights@.map(|i, x: i8| x as int))
    ensures valid_result(n as int, heights@.map(|i, x: i8| x as int), result as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0396,verus,apps,apps_test_2167,,"Given an array of n integers, find the maximum number of elements that can be made equal
after performing any number of operations where each operation chooses two different elements
and simultaneously increases one by 1 and decreases the other by 1.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, arr: Seq<int>) -> bool {
    n >= 1 && arr.len() == n
}

spec fn sum_seq(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else {
        s[0] + sum_seq(s.subrange(1, s.len() as int))
    }
}

spec fn correct_result(n: int, arr: Seq<int>, result: int) -> bool {
    &&& (sum_seq(arr) % n == 0 ==> result == n)
    &&& (sum_seq(arr) % n != 0 ==> result == n - 1)
    &&& (result == n || result == n - 1)
}",,"fn solve(n: i8, arr: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, arr@.map(|i: int, x: i8| x as int))
    ensures correct_result(n as int, arr@.map(|i: int, x: i8| x as int), result as int)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0398,verus,apps,apps_test_2180,,"Given an n × n chessboard, find the maximum number of ""Coders"" that can be placed
such that none attacks another. A Coder at position (x, y) can attack positions
(x±1, y) and (x, y±1) (horizontally and vertically adjacent squares).
Output the maximum count and a valid placement configuration using checkerboard pattern.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int) -> bool {
    n >= 1
}

spec fn max_coders(n: int) -> int {
    if n >= 1 { n * n / 2 + n * n % 2 } else { 0 }
}

spec fn valid_output_format(result: Seq<Seq<char>>, n: int) -> bool {
    n >= 1 &&
    result.len() == (n + 1) &&
    (forall|i: int| 1 <= i <= n ==> #[trigger] result[i].len() == n)
}

spec fn valid_checkerboard_placement(result: Seq<Seq<char>>, n: int) -> bool {
    n >= 1 &&
    valid_output_format(result, n) &&
    (forall|i: int, j: int| 1 <= i <= n && 0 <= j < n ==>
        (#[trigger] result[i][j] == 'C') <==> 
            (if (i - 1) % 2 == 0 { j % 2 == 0 } else { j % 2 == 1 }))
}",,"fn solve(n: i8) -> (result: Vec<String>)
    requires valid_input(n as int)","{
    assume(false);
    Vec::new()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0399,verus,apps,apps_test_2183,,"Given three brothers numbered 1, 2, and 3, exactly two brothers arrived on time 
for a meeting and one brother was late. Given the numbers of the two brothers who 
arrived on time, determine the number of the brother who was late.","use vstd::prelude::*;

verus! {
spec fn valid_brother_numbers(a: int, b: int) -> bool {
    1 <= a <= 3 && 1 <= b <= 3 && a != b
}

spec fn late_brother(a: int, b: int) -> int
    recommends valid_brother_numbers(a, b)
{
    6 - a - b
}

spec fn is_valid_result(a: int, b: int, result: int) -> bool {
    valid_brother_numbers(a, b) ==> 
        (1 <= result <= 3 && result != a && result != b)
}",,"fn solve(a: i8, b: i8) -> (result: i8)
    requires 
        valid_brother_numbers(a as int, b as int)
    ensures 
        is_valid_result(a as int, b as int, result as int) &&
        result as int == late_brother(a as int, b as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0400,verus,apps,apps_test_2187,,"Given an array of integers, find the minimum number of operations to make it non-decreasing.
In each operation, select a contiguous non-decreasing subsegment and add 1 to all elements.
The solution sums violations where arr[i] > arr[i+1], as each violation requires (arr[i] - arr[i+1]) operations.","use vstd::prelude::*;

verus! {
spec fn valid_input(test_cases: Seq<Seq<int>>) -> bool {
    forall|i: int| 0 <= i < test_cases.len() ==> test_cases[i].len() >= 1
}

spec fn sum_differences(arr: Seq<int>, start: int) -> int
    recommends 0 <= start <= arr.len()
    decreases arr.len() - start
{
    if start >= arr.len() - 1 {
        0
    } else {
        (if arr[start] > arr[start + 1] { arr[start] - arr[start + 1] } else { 0 }) + sum_differences(arr, start + 1)
    }
}

spec fn correct_result(test_cases: Seq<Seq<int>>, results: Seq<int>) -> bool {
    results.len() == test_cases.len() &&
    forall|i: int| 0 <= i < test_cases.len() ==> results[i] == sum_differences(test_cases[i], 0) &&
    forall|i: int| 0 <= i < results.len() ==> results[i] >= 0
}",,"fn solve(test_cases: Vec<Vec<i8>>) -> (results: Vec<i8>)
    requires valid_input(test_cases@.map_values(|v: Vec<i8>| v@.map_values(|x: i8| x as int)))
    ensures correct_result(test_cases@.map_values(|v: Vec<i8>| v@.map_values(|x: i8| x as int)), results@.map_values(|x: i8| x as int))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0402,verus,apps,apps_test_2202,,"Given a sequence A of N integers and a positive integer p, split A into exactly 2 contiguous,
non-overlapping parts (each containing at least 1 element) to maximize the sum of their scores.
The score of a part is the sum of its elements modulo p. Find the maximum possible sum of scores.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, p: int, a: Seq<int>) -> bool {
    n >= 2 && p >= 2 && a.len() == n && forall|i: int| 0 <= i < n ==> a[i] >= 1
}

spec fn split_score(a: Seq<int>, split_idx: int, p: int) -> int {
    0 /* placeholder for split score calculation */
}

spec fn max_seq(scores: Seq<int>) -> int {
    0 /* placeholder for maximum value in sequence */
}

spec fn max_split_score(a: Seq<int>, p: int) -> int
    recommends a.len() >= 2, p >= 2
{
    let scores = Seq::new((a.len() - 1) as nat, |i: int| split_score(a, i + 1, p));
    max_seq(scores)
}",,"fn solve(n: i8, p: i8, a: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, p as int, a@.map_values(|x: i8| x as int))
    ensures 
        result >= 0 &&
        result < 2 * p &&
        result as int == max_split_score(a@.map_values(|x: i8| x as int), p as int)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0403,verus,apps,apps_test_2209,,"Given n strings containing only 's' and 'h' characters, arrange them in optimal order
and concatenate to form a single string. Find the maximum possible ""noise"" which is
the number of ""sh"" subsequences in the resulting concatenated string.","use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<Seq<char>>) -> bool {
    input.len() >= 1 &&
    (forall|i: int| 0 <= i < input[0].len() ==> #[trigger] input[0][i] == input[0][i] && '0' <= input[0][i] <= '9') &&
    {
        let n = string_to_int(input[0]);
        n >= 1 && input.len() >= n + 1 &&
        forall|i: int| 1 <= i <= n ==> #[trigger] input[i] == input[i] && (input[i].len() > 0 &&
            forall|j: int| 0 <= j < input[i].len() ==> #[trigger] input[i][j] == input[i][j] && (input[i][j] == 's' || input[i][j] == 'h'))
    }
}

spec fn string_to_int(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 { 0 }
    else { string_to_int(s.subrange(0, s.len() as int - 1)) * 10 + (s[s.len() - 1] as int - '0' as int) }
}

spec fn count_char(s: Seq<char>, c: char) -> int
    decreases s.len()
{
    if s.len() == 0 { 0 }
    else { (if s[0] == c { 1int } else { 0int }) + count_char(s.subrange(1, s.len() as int), c) }
}

spec fn count_sh_subsequences(s: Seq<char>) -> int {
    count_sh_subsequences_helper(s, 0, 0)
}

spec fn count_sh_subsequences_helper(s: Seq<char>, index: int, s_count: int) -> int
    decreases s.len() - index when 0 <= index <= s.len() && s_count >= 0
{
    if index == s.len() { 0 }
    else if index < s.len() && s[index] == 's' {
        count_sh_subsequences_helper(s, index + 1, s_count + 1)
    } else if index < s.len() && s[index] == 'h' {
        s_count + count_sh_subsequences_helper(s, index + 1, s_count)
    } else {
        count_sh_subsequences_helper(s, index + 1, s_count)
    }
}

spec fn string_ratio(s: Seq<char>) -> int {
    if s.len() == 0 { 0 } else { count_char(s, 's') * 1000 / s.len() as int }
}

spec fn concatenate_strings(strings: Seq<Seq<char>>) -> Seq<char>
    decreases strings.len()
{
    if strings.len() == 0 { Seq::empty() }
    else { strings[0] + concatenate_strings(strings.subrange(1, strings.len() as int)) }
}

spec fn is_sorted_by_ratio(strings: Seq<Seq<char>>) -> bool {
    forall|i: int, j: int| 0 <= i < j < strings.len() ==> 
        #[trigger] strings[i] == strings[i] && #[trigger] strings[j] == strings[j] &&
        strings[i].len() > 0 && strings[j].len() > 0 ==> 
        string_ratio(strings[i]) <= string_ratio(strings[j])
}

spec fn is_valid_arrangement(original: Seq<Seq<char>>, arranged: Seq<Seq<char>>) -> bool {
    arranged.len() == original.len() &&
    forall|s: Seq<char>| #[trigger] original.contains(s) <==> arranged.contains(s)
}",,"fn solve(input: Vec<Vec<char>>) -> (result: i32)
    requires valid_input(input@.map(|i, v: Vec<char>| v@))
    ensures result >= 0","{
    // impl-start
    assume(false);
    0
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0405,verus,apps,apps_test_2220,,"Given n emotes with happiness values, use emotes m times total to maximize happiness.
Cannot use the same emote more than k consecutive times.

/* Assumes optimal strategy using highest and second highest values */","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, m: int, k: int, emotes: Seq<int>) -> bool {
    n >= 2 && k >= 1 && m >= 1 && emotes.len() == n &&
    forall|i: int| 0 <= i < emotes.len() ==> emotes[i] >= 1
}

spec fn max_happiness(n: int, m: int, k: int, emotes: Seq<int>) -> int {
    let k_plus_1 = k + 1;
    let total = m / k_plus_1;
    let remainder = m % k_plus_1;

    let max_val = max_value(emotes);
    let second_max_val = second_max_value(emotes);
    remainder * max_val + max_val * (total * k) + second_max_val * total
}

spec fn max_value(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 1 {
        s[0]
    } else if s.len() > 1 && s[0] >= max_value(s.skip(1)) {
        s[0]
    } else if s.len() > 1 {
        max_value(s.skip(1))
    } else {
        s[0]
    }
}

spec fn second_max_value(s: Seq<int>) -> int {
    let max_val = max_value(s);
    let filtered = filter_out(s, max_val, 1);
    if filtered.len() > 0 {
        max_value(filtered)
    } else {
        1
    }
}

spec fn filter_out(s: Seq<int>, val: int, count: int) -> Seq<int>
    decreases s.len(), count
{
    if s.len() == 0 || count == 0 {
        s
    } else if s[0] == val {
        filter_out(s.skip(1), val, count - 1)
    } else {
        seq![s[0]].add(filter_out(s.skip(1), val, count))
    }
}",,"fn solve(n: i8, m: i8, k: i8, emotes: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, m as int, k as int, 
            seq![].add(emotes@.map(|i: int, x: i8| x as int)))
    ensures result >= 0","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0406,verus,apps,apps_test_2238,,"Given an odd integer n (3 ≤ n ≤ 101), create an n×n matrix representing a crystal with a diamond pattern.
Use 'D' for diamond cells and '*' for all other cells.
The diamond pattern forms a symmetric diamond shape where the top half starts with 1 'D' and increases by 2 'D's per row
until the middle row has n 'D's, then the bottom half decreases symmetrically.
All 'D's in each row are centered with '*' characters filling remaining positions.

/* First half (including middle): rows 0 to magic */

/* Second half: rows magic+1 to n-1 */","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int) -> bool {
    n >= 3 && n <= 101 && n % 2 == 1
}

spec fn valid_result(result: Seq<String>, n: int) -> bool {
    result.len() == n &&
    forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i]@.len() == n
}

spec fn repeat_char(c: char, count: int) -> Seq<char>
    decreases count
{
    if count <= 0 { Seq::empty() }
    else { repeat_char(c, count - 1).push(c) }
}

spec fn correct_diamond_pattern(result: Seq<String>, n: int) -> bool {
    result.len() == n ==> {
        let magic = (n - 1) / 2;
        
        (forall|i: int| 0 <= i <= magic && i < result.len() ==> {
            let stars = magic - i;
            let diamonds = n - 2 * stars;
            #[trigger] result[i]@ == repeat_char('*', stars) + repeat_char('D', diamonds) + repeat_char('*', stars)
        }) &&
        
        (forall|i: int| magic + 1 <= i < n && i < result.len() ==> {
            let u = i - magic;
            let stars = u;
            let diamonds = n - 2 * stars;
            #[trigger] result[i]@ == repeat_char('*', stars) + repeat_char('D', diamonds) + repeat_char('*', stars)
        })
    }
}",,"fn solve(n: usize) -> (result: Vec<String>)
    requires 
        valid_input(n as int)
    ensures 
        valid_result(result@, n as int),
        correct_diamond_pattern(result@, n as int)","{
    // impl-start
    assume(false);
    Vec::new()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0409,verus,apps,apps_test_2256,,"Given n students in positions 1 to n, with two rival students initially at positions a and b,
find the maximum distance between the rivals after performing at most x adjacent swaps.
Distance between positions p and s is |p - s|.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, x: int, a: int, b: int) -> bool {
    2 <= n <= 100 && 0 <= x <= 100 && 1 <= a <= n && 1 <= b <= n && a != b
}

spec fn max_distance(n: int, x: int, a: int, b: int) -> int
    recommends valid_input(n, x, a, b)
{
    let initial_distance = if a >= b { a - b } else { b - a };
    let max_possible_distance = initial_distance + x;
    let max_line_distance = n - 1;
    if max_possible_distance <= max_line_distance { max_possible_distance } else { max_line_distance }
}

spec fn valid_result(n: int, x: int, a: int, b: int, result: int) -> bool
    recommends valid_input(n, x, a, b)
{
    result == max_distance(n, x, a, b) && 0 <= result <= n - 1
}",,"fn solve_rival_distance(n: i8, x: i8, a: i8, b: i8) -> (result: i8)
    requires
        valid_input(n as int, x as int, a as int, b as int),
    ensures
        valid_result(n as int, x as int, a as int, b as int, result as int),
        result >= 0,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0410,verus,apps,apps_test_2282,,"Given n movement commands ('L' for left, 'R' for right), determine how many
different final positions are possible when any subset of commands may be ignored.
The answer is always n + 1, representing all positions from minimum to maximum.","use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<u8>) -> bool {
    input.len() > 0 && exists|i: int| 0 <= i < input.len() && input[i] == 10u8
}

spec fn valid_command_input(input: Seq<u8>) -> bool {
    /* Abstract specification for valid command input */
    input.len() >= 2
}

spec fn extract_n(input: Seq<u8>) -> int {
    /* Abstract specification for extracting n */
    if valid_command_input(input) { 42 } else { 0 }
}

spec fn correct_output(input: Seq<u8>, result: Seq<u8>) -> bool {
    valid_command_input(input) ==> 
        result.len() > 0
}",,"fn solve(input: Vec<u8>) -> (result: Vec<u8>)
    requires 
        valid_input(input@),
    ensures 
        correct_output(input@, result@),
        (!valid_command_input(input@) ==> result@.len() == 0),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0411,verus,apps,apps_test_2293,,"Given n stores and m days of shopping, determine if positive integer values can be assigned 
to stores such that Dora beats Swiper every day. Dora buys from some stores each day, 
Swiper from remaining stores. Dora wins if LCM(her purchases) > LCM(Swiper's purchases).","use vstd::prelude::*;

verus! {

spec fn valid_input(input: &str) -> bool {
    input@.len() > 0
    /* Additional validation logic would go here in a real implementation */
}

spec fn extract_dora_set(input: &str, day_index: int, n: int) -> Set<int>
    recommends
        input@.len() > 0,
        day_index >= 0,
        n >= 1,
{
    Set::empty() /* Placeholder - actual implementation would parse input */
}

spec fn extract_swiper_set(input: &str, day_index: int, n: int) -> Set<int>
    recommends
        input@.len() > 0,
        day_index >= 0,
        n >= 1,
{
    let all_stores: Set<int> = Set::new(|i: int| 1 <= i <= n);
    let dora_set = extract_dora_set(input, day_index, n);
    all_stores.difference(dora_set)
}

spec fn solution_exists(input: &str) -> bool
    recommends valid_input(input)
{
    /* Logic to check if a valid assignment exists */
    true /* Placeholder */
}",,"fn solve(input: &str) -> (result: String)
    requires
        valid_input(input),
    ensures
        result@ =~= ""possible""@ || result@ =~= ""impossible""@,
        (result@ =~= ""possible""@) <==> solution_exists(input),","{
    assume(false);
    ""impossible"".to_string()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0412,verus,apps,apps_test_2297,,"Given an array where element a[i] = i * (-1)^i (so a[1] = -1, a[2] = 2, a[3] = -3, etc.),
answer queries asking for the sum of elements from index l to r inclusive.","use vstd::prelude::*;

verus! {
spec fn valid_query(query: (int, int)) -> bool {
    query.0 >= 1 && query.0 <= query.1
}

spec fn valid_input(queries: Seq<(int, int)>) -> bool {
    forall|i: int| 0 <= i < queries.len() ==> valid_query(queries[i])
}

spec fn array_element(i: int) -> int
    recommends i >= 1
{
    i * (if i % 2 == 1 { -1 } else { 1 })
}

spec fn range_sum(l: int, r: int) -> int
    recommends l >= 1
    decreases r - l + 1
{
    if l > r { 0 } else { array_element(l) + range_sum(l + 1, r) }
}

spec fn prefix_sum(k: int) -> int {
    if k % 2 == 0 { k / 2 } else { -(k + 1) / 2 }
}

spec fn correct_result(queries: Seq<(int, int)>, results: Seq<int>) -> bool
    recommends valid_input(queries)
{
    results.len() == queries.len() &&
    forall|i: int| 0 <= i < queries.len() ==> results[i] == prefix_sum(queries[i].1) - prefix_sum(queries[i].0 - 1)
}",,"fn solve(queries: Vec<(i8, i8)>) -> (results: Vec<i8>)
    requires valid_input(queries@.map(|i: int, x: (i8, i8)| (x.0 as int, x.1 as int)))
    ensures correct_result(queries@.map(|i: int, x: (i8, i8)| (x.0 as int, x.1 as int)), results@.map(|i: int, x: i8| x as int))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0413,verus,apps,apps_test_2308,,"Given two binary strings x and y representing integers f(x) and f(y), find the non-negative integer k 
that minimizes the lexicographic value of rev_k, where s_k = f(x) + f(y) × 2^k and rev_k is the 
binary representation of s_k written in reverse order.","use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    let lines = split_lines(input);
    lines.len() >= 1 && 
    is_valid_number(lines[0]) &&
    {
        let t = string_to_int(lines[0]);
        t >= 0 && lines.len() >= 2 * t + 1 &&
        forall|i: int| 1 <= i < 2 * t + 1 ==> #[trigger] lines.len() > i && is_binary_string(lines[i]) && contains_one(lines[i])
    }
}

spec fn valid_output(output: Seq<char>, input: Seq<char>) -> bool {
    let lines = split_lines(input);
    lines.len() >= 1 ==> {
        let t = string_to_int(lines[0]);
        let output_lines = if output.len() == 0 { Seq::empty() } else { split_lines(output) };
        output_lines.len() == t &&
        forall|i: int| 0 <= i < t ==> #[trigger] is_valid_number(output_lines[i])
    }
}

spec fn correct_computation(output: Seq<char>, input: Seq<char>) -> bool {
    let lines = split_lines(input);
    lines.len() >= 1 ==> {
        let t = string_to_int(lines[0]);
        let output_lines = if output.len() == 0 { Seq::empty() } else { split_lines(output) };
        output_lines.len() == t &&
        forall|i: int| 0 <= i < t && 1 + 2*i < lines.len() && 2 + 2*i < lines.len() ==> {
            let x = lines[1 + 2*i];
            let y = lines[2 + 2*i];
            let rev_x = reverse(x);
            let rev_y = reverse(y);
            let start = index_of(rev_y, '1');
            start >= 0 &&
            {
                let offset = index_of_from(rev_x, '1', start);
                #[trigger] string_to_int(output_lines[i]) == offset
            }
        }
    }
}

spec fn is_binary_string(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s.index(i) == '0' || s.index(i) == '1'
}

spec fn contains_one(s: Seq<char>) -> bool {
    exists|i: int| 0 <= i < s.len() && #[trigger] s.index(i) == '1'
}

spec fn is_valid_number(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s.index(i) >= '0' && s.index(i) <= '9'
}

/* Helper functions */
spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {
    arbitrary()
}

spec fn string_to_int(s: Seq<char>) -> int {
    arbitrary()
}

spec fn reverse(s: Seq<char>) -> Seq<char> {
    arbitrary()
}

spec fn index_of(s: Seq<char>, c: char) -> int {
    arbitrary()
}

spec fn index_of_from(s: Seq<char>, c: char, start: int) -> int {
    arbitrary()
}",,"fn solve(input: &str) -> (output: String)
    requires
        input@.len() > 0,
        input@.index(input@.len() as int - 1) == '\n',
        valid_input(input@),
    ensures
        valid_output(output@, input@),
        output@.len() > 0 ==> output@.index(output@.len() as int - 1) != '\n',
        correct_computation(output@, input@),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0414,verus,apps,apps_test_2320,,"Given two strings s and t of equal length, determine the minimum number of moves needed to transform s into t.
In each move, you can select any character from s and move it to either the beginning or end of the string.
If transformation is impossible, return -1.","use vstd::prelude::*;

verus! {

spec fn count_character(s: Seq<char>, c: char) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0 as int
    } else {
        (if s[0] == c { 1 as int } else { 0 as int }) + count_character(s.skip(1), c)
    }
}

spec fn has_same_character_counts(s: Seq<char>, t: Seq<char>) -> bool {
    s.len() == t.len() && 
    (forall|c: char| count_character(s, c) == count_character(t, c))
}

spec fn find_next_match(s: Seq<char>, c: char, start: int) -> int
    decreases s.len() - start
{
    if start >= s.len() {
        s.len() as int
    } else if s[start] == c {
        start
    } else {
        find_next_match(s, c, start + 1)
    }
}

spec fn can_match_substring(s: Seq<char>, t: Seq<char>, i: int, j: int, k: int) -> bool
    decreases j - i + 1, s.len() - k
{
    if i > j {
        true
    } else if k >= s.len() {
        false
    } else {
        let next_k = find_next_match(s, t[j], k);
        if next_k >= s.len() {
            false
        } else if i == j {
            true
        } else {
            can_match_substring(s, t, i, j-1, next_k+1)
        }
    }
}

spec fn max_preservable_length(s: Seq<char>, t: Seq<char>, i: int, j: int, max_so_far: int) -> int
    decreases t.len() - i, t.len() - j
{
    if i >= t.len() {
        max_so_far
    } else if j >= t.len() {
        max_preservable_length(s, t, i+1, i+1, max_so_far)
    } else {
        let current_len = j - i + 1;
        let can_match = can_match_substring(s, t, i, j, 0);
        let new_max = if can_match && current_len > max_so_far { current_len } else { max_so_far };
        max_preservable_length(s, t, i, j+1, new_max)
    }
}

spec fn max_longest_subsequence(s: Seq<char>, t: Seq<char>) -> int
{
    if s.len() == 0 {
        0 as int
    } else {
        max_preservable_length(s, t, 0, 0, 0)
    }
}",,"fn solve(s: Vec<char>, t: Vec<char>) -> (result: i32)
    requires 
        s.len() == t.len(),
        s.len() >= 0,
    ensures 
        result == -1 <==> !has_same_character_counts(s@, t@),
        result >= -1,
        result != -1 ==> 0 <= result <= s.len() as i32,
        result != -1 ==> has_same_character_counts(s@, t@),
        result != -1 ==> result == s.len() as i32 - max_longest_subsequence(s@, t@) as i32,
        s.len() == 0 ==> result == 0,","{
    // impl-start
    assume(false);
    -1
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0416,verus,apps,apps_test_2330,,"Given n fridges with weights a₁, a₂, ..., aₙ, create exactly m steel chains between fridges 
such that all fridges are ""private"". A chain connecting fridges u and v costs aᵤ + aᵥ. 
A fridge is ""private"" if only its owner can unlock it. Find the minimum total cost to create 
exactly m chains making all fridges private, or determine if impossible.","use vstd::prelude::*;

verus! {

pub enum Result {
    Impossible,
    Possible { cost: int, edges: Seq<(int, int)> }
}

spec fn seq_sum(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else {
        s[0] + seq_sum(s.skip(1))
    }
}

spec fn seq_sum_first(s: Seq<int>, n: int) -> int
    decreases n
{
    if n == 0 {
        0
    } else if n > 0 && n - 1 < s.len() {
        s[n-1] + seq_sum_first(s, n-1)
    } else {
        0
    }
}

spec fn min_index(weights: Seq<int>) -> int {
    if weights.len() > 0 {
        min_index_helper(weights, 0, 1)
    } else {
        0
    }
}

spec fn min_index_helper(weights: Seq<int>, current_min: int, next: int) -> int
    decreases weights.len() - next
{
    if next >= weights.len() {
        current_min
    } else if weights[next] < weights[current_min] {
        min_index_helper(weights, next, next + 1)
    } else {
        min_index_helper(weights, current_min, next + 1)
    }
}

spec fn min_index_excluding(weights: Seq<int>, exclude: int) -> int {
    if weights.len() > 1 && 0 <= exclude < weights.len() {
        let first_valid = if exclude == 0 { 1 } else { 0 };
        min_index_excluding_helper(weights, exclude, first_valid, 0)
    } else {
        0
    }
}

spec fn min_index_excluding_helper(weights: Seq<int>, exclude: int, current_min: int, next: int) -> int
    decreases weights.len() - next
{
    if next >= weights.len() {
        current_min
    } else if next == exclude {
        min_index_excluding_helper(weights, exclude, current_min, next + 1)
    } else if weights[next] < weights[current_min] {
        min_index_excluding_helper(weights, exclude, next, next + 1)
    } else {
        min_index_excluding_helper(weights, exclude, current_min, next + 1)
    }
}",,"fn solve(t: i8, cases: Vec<(i8, i8, Vec<i8>)>) -> (results: Vec<Result>)
    requires 
        t >= 0,
        cases.len() == t as nat,
        forall|i: int| #![auto] 0 <= i < t as int ==> 
            cases[i].0 >= 0 && cases[i].1 >= 0 && cases[i].2@.len() == cases[i].0 as nat
    ensures 
        results@.len() == t as nat","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0417,verus,apps,apps_test_2340,,"Navigate down a cliff from height h to ground using platforms and magic crystals.
Character starts at platform height h, can pull levers to hide current platform and toggle platform at height x-1,
can fall safely at most 2 heights, and magic crystals can toggle any platform state (except height h).
Find minimum number of crystals needed to reach ground safely.","use vstd::prelude::*;
use vstd::string::*;

verus! {
spec fn valid_input(h: int, n: int, platforms: Seq<int>) -> bool {
    h >= 1 && n >= 1 && platforms.len() >= n && n > 0 && platforms.len() > 0 && platforms[0] == h
}

spec fn valid_crystal_count(crystals: int, n: int) -> bool {
    crystals >= 0 && crystals <= n - 1
}

spec fn count_crystals_needed(h: int, platforms: Seq<int>) -> int {
    if platforms.len() >= 1 && platforms[0] == h && h >= 1 {
        if platforms.len() == 1 {
            0
        } else {
            count_crystals_needed_up_to(h, platforms.push(0), (platforms.len() - 1) as int)
        }
    } else {
        0
    }
}

spec fn count_crystals_needed_up_to(h: int, arr: Seq<int>, up_to: int) -> int
    decreases up_to
{
    if arr.len() >= 1 && 0 <= up_to && up_to < arr.len() && arr[0] == h && h >= 1 {
        if up_to == 0 {
            0
        } else {
            let cur_pos = simulate_position_up_to(h, arr, up_to - 1);
            let prev_crystals = count_crystals_needed_up_to(h, arr, up_to - 1);
            if cur_pos == arr[up_to as int] {
                prev_crystals
            } else if up_to + 1 < arr.len() && arr[(up_to + 1) as int] == arr[up_to as int] - 1 {
                prev_crystals
            } else {
                prev_crystals + 1
            }
        }
    } else {
        0
    }
}

spec fn simulate_position_up_to(h: int, arr: Seq<int>, up_to: int) -> int
    decreases up_to
{
    if arr.len() >= 1 && 0 <= up_to && up_to < arr.len() && arr[0] == h && h >= 1 {
        if up_to == 0 {
            h
        } else {
            let prev_pos = simulate_position_up_to(h, arr, up_to - 1);
            if prev_pos == arr[up_to as int] {
                prev_pos
            } else if up_to + 1 < arr.len() && arr[(up_to + 1) as int] == arr[up_to as int] - 1 {
                arr[up_to as int] - 1
            } else {
                prev_pos
            }
        }
    } else {
        h
    }
}",,"fn solve(input: String) -> (result: String)
    requires input@.len() > 0
    ensures result@.len() >= 0","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0418,verus,apps,apps_test_2350,,"An infinite table is filled starting from cell (1,1) which contains integer 1.
Each cell (x,y) contains the sum of the cell above it (x-1,y) and the cell to its left (x,y-1).
For boundary cases: cell(1,y) = y and cell(x,1) = x.
Given start coordinates (x₁, y₁) and end coordinates (x₂, y₂), find the number of
different possible sums when traversing from start to end cell, moving only down or right.","use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0
}

spec fn valid_test_case(x1: int, y1: int, x2: int, y2: int) -> bool {
    1 <= x1 <= x2 && 1 <= y1 <= y2
}

spec fn count_different_sums(x1: int, y1: int, x2: int, y2: int) -> int
    recommends valid_test_case(x1, y1, x2, y2)
{
    (x2 - x1) * (y2 - y1) + 1
}",,"fn solve(input: Vec<char>) -> (output: Vec<char>)
    requires valid_input(input@)
    ensures output@.len() >= 0","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0419,verus,apps,apps_test_2353,,"Given four integers representing sleep requirements and alarm timing,
simulate an alarm system where: first alarm rings after b minutes,
if total sleep >= a then wake permanently, otherwise set alarm for c minutes later
and spend d minutes falling asleep. If alarm rings while falling asleep (c <= d),
reset and repeat. Find total time until permanent wake or -1 if never happens.","use vstd::prelude::*;

verus! {
spec fn valid_input(a: int, b: int, c: int, d: int) -> bool {
    a >= 0 && b >= 0 && c >= 0 && d >= 0
}

spec fn first_alarm_sufficient(a: int, b: int) -> bool {
    a <= b
}

spec fn never_wakes(a: int, b: int, c: int, d: int) -> bool {
    a > b && c <= d
}

spec fn eventually_wakes(a: int, b: int, c: int, d: int) -> bool {
    a > b && c > d
}

spec fn calculate_wake_time(a: int, b: int, c: int, d: int) -> int {
    let remaining = a - b;
    let cycles = (remaining - 1) / (c - d) + 1;
    b + c * cycles
}",,"fn solve(a: i8, b: i8, c: i8, d: i8) -> (result: i8)
    requires 
        valid_input(a as int, b as int, c as int, d as int)
    ensures 
        first_alarm_sufficient(a as int, b as int) ==> result as int == b as int,
        never_wakes(a as int, b as int, c as int, d as int) ==> result == -1,
        eventually_wakes(a as int, b as int, c as int, d as int) ==> result as int == calculate_wake_time(a as int, b as int, c as int, d as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0420,verus,apps,apps_test_2354,,"Fill an n×n chessboard with numbers 1 to n² using a specific pattern:
Place first ⌈n²/2⌉ numbers in cells where (row + column) is even, filling left-to-right, top-to-bottom
Place remaining numbers in cells where (row + column) is odd, filling left-to-right, top-to-bottom
For given queries (xi, yi), return the number at each position","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, queries: Seq<(int, int)>) -> bool {
    n > 0 && 
    forall|i: int| 0 <= i < queries.len() ==> #[trigger] queries[i].0 >= 1 && #[trigger] queries[i].0 <= n && #[trigger] queries[i].1 >= 1 && #[trigger] queries[i].1 <= n
}

spec fn chessboard_value(n: int, x: int, y: int) -> int {
    if (x + y) % 2 == 0 {
        1 + (x / 2) * n + (x % 2) * ((n + 1) / 2) + y / 2
    } else {
        (n * n + 1) / 2 + 1 + (x / 2) * n + (x % 2) * (n / 2) + y / 2
    }
}

spec fn valid_result(n: int, queries: Seq<(int, int)>, results: Seq<int>) -> bool {
    valid_input(n, queries) ==> (
        results.len() == queries.len() &&
        forall|i: int| 0 <= i < queries.len() ==> {
            let x = #[trigger] queries[i].0 - 1;
            let y = #[trigger] queries[i].1 - 1;
            0 <= x < n && 0 <= y < n &&
            #[trigger] results[i] == chessboard_value(n, x, y)
        }
    )
}",,"fn solve(n: i8, queries: Vec<(i8, i8)>) -> (results: Vec<i8>)
    requires valid_input(n as int, queries@.map(|i: int, q: (i8, i8)| (q.0 as int, q.1 as int)))
    ensures valid_result(n as int, queries@.map(|i: int, q: (i8, i8)| (q.0 as int, q.1 as int)), results@.map(|i: int, r: i8| r as int))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0422,verus,apps,apps_test_2375,,"Two players Alice and Brown play a turn-based stone game starting with Alice.
There are two piles with X and Y stones. On each turn, a player chooses positive
integer i, takes 2i stones from one pile (requiring at least 2i stones),
discards i stones, and places remaining i stones in the other pile.
The player who cannot make a valid move loses. Determine winner with optimal play.","use vstd::prelude::*;

verus! {
spec fn abs(x: int) -> int {
    if x >= 0 { x } else { -x }
}

spec fn alice_wins(x: int, y: int) -> bool {
    abs(x - y) > 1
}

spec fn brown_wins(x: int, y: int) -> bool {
    abs(x - y) <= 1
}

spec fn valid_input(x: int, y: int) -> bool {
    x >= 0 && y >= 0
}",,"fn determine_winner(x: i8, y: i8) -> (winner: &'static str)
    requires 
        valid_input(x as int, y as int),
    ensures 
        winner == ""Alice"" || winner == ""Brown"",
        (winner == ""Alice"") <==> alice_wins(x as int, y as int),
        (winner == ""Brown"") <==> brown_wins(x as int, y as int),","{
    assume(false);
    ""Alice""
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0423,verus,apps,apps_test_2377,,"Find the minimum number of attacks needed to deal at least H total damage to a monster
using N katanas. Each katana can be wielded (deals a_i damage, repeatable) or 
thrown (deals b_i damage, once only). Constraints: a_i <= b_i, all values positive.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, h: int, a: Seq<int>, b: Seq<int>) -> bool {
    a.len() == n && b.len() == n && n > 0 && h > 0 &&
    (forall|i: int| 0 <= i < n ==> a[i] > 0 && b[i] > 0) &&
    (forall|i: int| 0 <= i < n ==> a[i] <= b[i])
}

spec fn sum_seq(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.subrange(1, s.len() as int)) }
}

spec fn max_wield_exists(a: Seq<int>, max_a: int) -> bool {
    (exists|i: int| 0 <= i < a.len() && a[i] == max_a) &&
    (forall|i: int| 0 <= i < a.len() ==> a[i] <= max_a)
}",,"fn solve(n: i8, h: i8, a: Vec<i8>, b: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, h as int, a@.map_values(|x: i8| x as int), b@.map_values(|x: i8| x as int))
    ensures result > 0","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0425,verus,apps,apps_test_2386,,"Given an integer sequence A of length N, find the minimum value of:
abs(A₁ - (b+1)) + abs(A₂ - (b+2)) + ... + abs(Aₙ - (b+N))
where b is any integer we can choose.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, a: Seq<int>) -> bool {
    n >= 1 && a.len() == n && forall|i: int| 0 <= i < a.len() ==> a[i] >= 1
}

spec fn transform(a: Seq<int>) -> Seq<int> {
    Seq::new(a.len(), |i: int| a[i] - (i + 1))
}

spec fn sum_abs_diffs(a: Seq<int>, target: int) -> int
    decreases a.len()
{
    if a.len() == 0 {
        0
    } else {
        abs_int(a[0] - target) + sum_abs_diffs(a.subrange(1, a.len() as int), target)
    }
}

spec fn median_of(a: Seq<int>) -> int {
    let sorted = sorted_seq(a);
    if sorted.len() == 0 {
        0
    } else if sorted.len() % 2 == 1 {
        sorted[sorted.len() as int / 2]
    } else if sorted.len() == 2 {
        (sorted[0] + sorted[1]) / 2
    } else {
        (sorted[sorted.len() as int / 2 - 1] + sorted[sorted.len() as int / 2]) / 2
    }
}

spec fn sorted_seq(a: Seq<int>) -> Seq<int> {
    a
}

spec fn abs_int(x: int) -> int {
    if x >= 0 { x } else { -x }
}",,"fn solve(n: i8, a: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, a@.map(|i: int, x: i8| x as int)),
    ensures 
        result >= 0,
        result as int == sum_abs_diffs(transform(a@.map(|i: int, x: i8| x as int)), median_of(transform(a@.map(|i: int, x: i8| x as int)))),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0426,verus,apps,apps_test_2396,,"Given m ships, each with a destination coordinate expressed as (a+b)/c where a, b, c are positive integers,
determine how many ships (including itself) will have the same destination coordinate for each ship.","use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0
}

spec fn valid_output(result: Seq<int>, input: Seq<char>) -> bool {
    result.len() >= 0 &&
    (forall|i: int| 0 <= i < result.len() ==> result[i] >= 1) &&
    (forall|i: int| 0 <= i < result.len() ==> result[i] <= result.len())
}",,"fn solve(input: Vec<char>) -> (result: Vec<i8>)
    requires valid_input(input@)
    ensures valid_output(result@.map(|i: int, x: i8| x as int), input@)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0427,verus,apps,apps_test_2406,,"Simulate a landslide process on an array of strictly increasing heights.
Each minute, for every position j where h_j + 2 ≤ h_{j+1}, one unit slides 
from position j+1 to position j. All transfers happen simultaneously.
The process stops when no position satisfies the sliding condition.
Return the final stable heights.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, heights: Seq<int>) -> bool {
    n > 0 && heights.len() == n &&
    (forall|i: int| 0 <= i < n ==> #[trigger] heights[i] >= 0) &&
    (forall|i: int| 0 <= i < n-1 ==> #[trigger] heights[i] < heights[i+1])
}

spec fn valid_output(n: int, result: Seq<int>) -> bool {
    result.len() == n &&
    (forall|i: int| 0 <= i < n ==> #[trigger] result[i] >= 0) &&
    (forall|i: int| 0 <= i < n-1 ==> #[trigger] result[i] <= result[i+1]) &&
    (forall|i: int| 0 <= i < n-1 ==> #[trigger] result[i+1] - result[i] <= 1)
}

spec fn is_stable(result: Seq<int>) -> bool {
    forall|i: int| 0 <= i < result.len()-1 ==> !(#[trigger] result[i] + 2 <= result[i+1])
}

spec fn sum_seq(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.subrange(1, s.len() as int)) }
}",,"fn solve(n: i8, heights: Vec<i8>) -> (result: Vec<i8>)
    requires 
        valid_input(n as int, heights@.map(|i, v| v as int))
    ensures 
        valid_output(n as int, result@.map(|i, v| v as int)) &&
        sum_seq(result@.map(|i, v| v as int)) == sum_seq(heights@.map(|i, v| v as int)) &&
        is_stable(result@.map(|i, v| v as int))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0429,verus,apps,apps_test_2422,,"Given an integer n representing total windows in a building, find any valid combination
of non-negative integers (a, b, c) representing 3-room, 5-room, and 7-room apartments
such that 3a + 5b + 7c = n. Return -1 if no valid combination exists.","use vstd::prelude::*;

verus! {
    spec fn valid_solution(n: int, a: int, b: int, c: int) -> bool {
        a >= 0 && b >= 0 && c >= 0 && 3 * a + 5 * b + 7 * c == n
    }
    
    spec fn valid_result(n: int, result: Seq<int>) -> bool {
        (result.len() == 1 && result[0] == -1) ||
        (result.len() == 3 && result[0] >= 0 && result[1] >= 0 && result[2] >= 0 && 
         valid_solution(n, result[0], result[1], result[2]))
    }",,"fn solve(n: i8) -> (result: Vec<i8>)
    requires 
        n as int >= 1,
    ensures 
        valid_result(n as int, result@.map(|_index, x: i8| x as int)),
        (n as int) % 3 == 0 ==> (result@.len() == 3 && result@.map(|_index, x: i8| x as int) == seq![(n as int) / 3, 0, 0]),
        (n as int) % 3 == 1 && (n as int) < 7 ==> (result@.len() == 1 && result@[0] as int == -1),
        (n as int) % 3 == 1 && (n as int) >= 7 ==> (result@.len() == 3 && result@.map(|_index, x: i8| x as int) == seq![((n as int) - 7) / 3, 0, 1]),
        (n as int) % 3 == 2 && (n as int) < 5 ==> (result@.len() == 1 && result@[0] as int == -1),
        (n as int) % 3 == 2 && (n as int) >= 5 ==> (result@.len() == 3 && result@.map(|_index, x: i8| x as int) == seq![((n as int) - 5) / 3, 1, 0])","{
    assume(false);
    Vec::new()
}","}

fn main() {}",0,,-1,-1,-1,,1.0
VA0430,verus,apps,apps_test_2425,,"Given a positive integer a, find the maximum possible value of gcd(a ⊕ b, a & b) 
where b is chosen from the range [1, a-1] and ⊕ denotes XOR and & denotes AND operations.","use vstd::prelude::*;

verus! {

spec fn power2(k: nat) -> int
    decreases k
{
    if k == 0 { 1 } else { 2 * power2((k - 1) as nat) }
}

spec fn valid_query(a: int) -> bool
{
    2 <= a <= power2(25) - 1
}

spec fn valid_queries(queries: Seq<int>) -> bool
{
    forall|i: int| #![auto] 0 <= i < queries.len() ==> valid_query(queries[i])
}

spec fn largest_proper_divisor(n: int) -> int
    recommends n > 1
{
    if n <= 1 { 
        1 
    } else { 
        largest_proper_divisor_helper(n, 2) 
    }
}

spec fn largest_proper_divisor_helper(n: int, d: int) -> int
    recommends n > 1 && d >= 2
    decreases if n >= d { n - d } else { 0 }
{
    if d * d > n { 
        1 
    } else if n % d == 0 { 
        let quotient = n / d;
        if quotient == d { 
            quotient 
        } else if n > d {
            let remainder_check = largest_proper_divisor_helper(n, d + 1);
            if quotient > remainder_check { quotient } else { remainder_check }
        } else {
            quotient
        }
    } else if n > d { 
        largest_proper_divisor_helper(n, d + 1) 
    } else {
        1
    }
}

spec fn valid_results(queries: Seq<int>, results: Seq<int>) -> bool
{
    results.len() == queries.len() &&
    (forall|i: int| 0 <= i < results.len() ==> results[i] >= 1) &&
    true
}",,"fn solve(queries: Vec<i8>) -> (results: Vec<i8>)
    requires valid_queries(queries@.map(|_i, x: i8| x as int))
    ensures valid_results(queries@.map(|_i, x: i8| x as int), results@.map(|_i, x: i8| x as int))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0432,verus,apps,apps_test_2434,,"Given two integers n and m where m < n, determine if it's possible to select m vertices 
from a regular n-gon such that these m vertices form a regular m-gon with the same center.
The solution is ""YES"" if n is divisible by m, ""NO"" otherwise.","use vstd::prelude::*;

verus! {
spec fn yes_string() -> Seq<char> {
    seq!['Y', 'E', 'S']
}

spec fn no_string() -> Seq<char> {
    seq!['N', 'O']
}

spec fn valid_input_format(input: Seq<char>) -> bool {
    let lines = split_by_newline(input);
    lines.len() >= 1 && 
    is_valid_int(lines[0]) &&
    {
        let t = parse_int(lines[0]);
        t >= 0 && t + 1 <= lines.len() &&
        forall|i: int| 1 <= i <= t ==> #[trigger] is_valid_two_int_line(lines[i])
    }
}

spec fn is_valid_int(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9'
}

spec fn is_valid_two_int_line(s: Seq<char>) -> bool {
    let parts = split_by_space(s);
    parts.len() >= 2 && is_valid_int(parts[0]) && is_valid_int(parts[1])
}

spec fn valid_output_format(output: Seq<char>, input: Seq<char>) -> bool {
    let input_lines = split_by_newline(input);
    if input_lines.len() == 0 { 
        output.len() == 0
    } else {
        let t = parse_int(input_lines[0]);
        let output_lines = split_by_newline(output);
        output_lines.len() == t &&
        forall|i: int| 0 <= i < t ==> #[trigger] seq_equals(output_lines[i], yes_string()) || #[trigger] seq_equals(output_lines[i], no_string())
    }
}

spec fn correct_divisibility_results(input: Seq<char>, output: Seq<char>) -> bool {
    let input_lines = split_by_newline(input);
    if input_lines.len() == 0 { 
        output.len() == 0
    } else {
        let t = parse_int(input_lines[0]);
        let output_lines = split_by_newline(output);
        output_lines.len() == t &&
        forall|i: int| 0 <= i < t && i + 1 < input_lines.len() ==> {
            let parts = split_by_space(input_lines[i + 1]);
            parts.len() >= 2 ==> {
                let x = parse_int(parts[0]);
                let y = parse_int(parts[1]);
                y != 0 ==> (#[trigger] seq_equals(output_lines[i], yes_string()) <==> x % y == 0)
            }
        }
    }
}

spec fn seq_equals(s1: Seq<char>, s2: Seq<char>) -> bool {
    s1.len() == s2.len() && forall|i: int| 0 <= i < s1.len() ==> #[trigger] s1[i] == #[trigger] s2[i]
}

spec fn split_by_newline(s: Seq<char>) -> Seq<Seq<char>>
    decreases s.len()
{
    if s.len() == 0 { 
        seq![]
    } else if s[0] == '\n' { 
        seq![seq![]].add(split_by_newline(s.subrange(1, s.len() as int)))
    } else {
        let rest = split_by_newline(s.subrange(1, s.len() as int));
        if rest.len() == 0 { 
            seq![s]
        } else { 
            seq![seq![s[0]].add(rest[0])].add(rest.subrange(1, rest.len() as int))
        }
    }
}

spec fn split_by_space(s: Seq<char>) -> Seq<Seq<char>>
    decreases s.len()
{
    if s.len() == 0 { 
        seq![]
    } else if s[0] == ' ' { 
        seq![seq![]].add(split_by_space(s.subrange(1, s.len() as int)))
    } else {
        let rest = split_by_space(s.subrange(1, s.len() as int));
        if rest.len() == 0 { 
            seq![s]
        } else { 
            seq![seq![s[0]].add(rest[0])].add(rest.subrange(1, rest.len() as int))
        }
    }
}

spec fn parse_int(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 { 
        0
    } else if s.len() == 1 {
        if '0' <= s[0] <= '9' { 
            s[0] as int - '0' as int 
        } else { 
            0 
        }
    } else {
        if '0' <= s[0] <= '9' {
            (s[0] as int - '0' as int) * pow10(s.len() - 1) + parse_int(s.subrange(1, s.len() as int))
        } else { 
            0 
        }
    }
}

spec fn pow10(n: int) -> int 
    decreases n
{
    if n <= 0 { 1 } else { 10 * pow10(n - 1) }
}",,"fn solve(input: Vec<char>) -> (output: Vec<char>)
    requires 
        input.len() > 0,
        valid_input_format(input@),
    ensures 
        forall|i: int| 0 <= i < output.len() ==> output[i] == 'Y' || output[i] == 'E' || output[i] == 'S' || output[i] == 'N' || output[i] == 'O' || output[i] == '\n',
        valid_output_format(output@, input@),
        correct_divisibility_results(input@, output@),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0433,verus,apps,apps_test_2435,,"Given an array of n integers where initially a[x] = 1 and all other elements are 0,
determine how many positions can contain the value 1 after performing m swap operations optimally.
Each operation i allows swapping any two elements at positions c and d where l_i ≤ c, d ≤ r_i.","use vstd::prelude::*;

verus! {
spec fn valid_input(test_cases: Seq<(int, int, Seq<(int, int)>)>) -> bool {
    test_cases.len() >= 0 &&
    forall|i: int| 0 <= i < test_cases.len() ==> #[trigger] test_cases[i].0 >= 1 && {
        let (n, x, operations) = test_cases[i];
        n >= 1 && 1 <= x <= n && operations.len() >= 0 &&
        forall|j: int| 0 <= j < operations.len() ==> #[trigger] operations[j].0 >= 1 && {
            let (l, r) = operations[j];
            1 <= l <= r <= n
        }
    }
}

spec fn compute_final_bounds(x: int, operations: Seq<(int, int)>) -> (int, int)
    recommends forall|j: int| 0 <= j < operations.len() ==> #[trigger] operations[j].0 <= operations[j].1
{
    compute_final_bounds_helper(x, x, operations, 0)
}

spec fn valid_results(test_cases: Seq<(int, int, Seq<(int, int)>)>, results: Seq<int>) -> bool
    recommends valid_input(test_cases)
{
    results.len() == test_cases.len() &&
    forall|i: int| 0 <= i < test_cases.len() ==> #[trigger] test_cases[i].0 >= 1 && {
        let (n, x, operations) = test_cases[i];
        let final_bounds = compute_final_bounds(x, operations);
        results[i] == final_bounds.1 - final_bounds.0 + 1 &&
        final_bounds.0 <= x <= final_bounds.1 &&
        results[i] >= 1 &&
        1 <= final_bounds.0 <= final_bounds.1 <= n
    }
}

spec fn compute_final_bounds_helper(min_pos: int, max_pos: int, operations: Seq<(int, int)>, index: int) -> (int, int)
    decreases operations.len() - index
{
    if index >= operations.len() {
        (min_pos, max_pos)
    } else {
        let (l, r) = operations[index];
        let new_min = if min_pos >= l && min_pos <= r || max_pos >= l && max_pos <= r {
            if l < min_pos { l } else { min_pos }
        } else { min_pos };
        let new_max = if min_pos >= l && min_pos <= r || max_pos >= l && max_pos <= r {
            if r > max_pos { r } else { max_pos }
        } else { max_pos };
        compute_final_bounds_helper(new_min, new_max, operations, index + 1)
    }
}",,"fn solve(test_cases: Vec<(i8, i8, Vec<(i8, i8)>)>) -> (results: Vec<i8>)
    requires valid_input(test_cases@.map(|i: int, tc: (i8, i8, Vec<(i8, i8)>)| (tc.0 as int, tc.1 as int, tc.2@.map(|j: int, op: (i8, i8)| (op.0 as int, op.1 as int)))))
    ensures valid_results(test_cases@.map(|i: int, tc: (i8, i8, Vec<(i8, i8)>)| (tc.0 as int, tc.1 as int, tc.2@.map(|j: int, op: (i8, i8)| (op.0 as int, op.1 as int)))), results@.map(|i: int, r: i8| r as int))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0434,verus,apps,apps_test_2443,,"Given a modulus m and a list of n forbidden values, construct the longest possible sequence where:
- Each sequence element is an integer in [0, m-1]  
- All prefix products modulo m are distinct
- No prefix product modulo m equals any forbidden value
- Sequence length is maximized","use vstd::prelude::*;

verus! {
spec fn prefix_product(s: Seq<nat>, i: nat, modulus: nat) -> nat
  recommends modulus > 0, i <= s.len()
  decreases i
{
    if i == 0 { 1 }
    else { (s[i as int - 1] * prefix_product(s, (i - 1) as nat, modulus)) % modulus }
}

spec fn prefix_products(s: Seq<nat>, modulus: nat) -> Seq<nat>
  recommends modulus > 0
{
    Seq::new(s.len(), |i: int| prefix_product(s, (i + 1) as nat, modulus))
}

spec fn all_distinct<T>(s: Seq<T>) -> bool {
    forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] != s[j]
}

spec fn no_forbidden_products(s: Seq<nat>, forbidden: Seq<nat>, modulus: nat) -> bool
  recommends modulus > 0
{
    let products = prefix_products(s, modulus);
    forall|i: int| 0 <= i < products.len() ==> !forbidden.contains(products[i])
}

spec fn valid_input(n: nat, m: nat, forbidden: Seq<nat>) -> bool {
    m >= 1 &&
    n >= 0 &&
    forbidden.len() == n &&
    (forall|i: int| 0 <= i < forbidden.len() ==> #[trigger] forbidden[i] >= 0 && forbidden[i] < m) &&
    (forall|i: int, j: int| 0 <= i < j < forbidden.len() ==> #[trigger] forbidden[i] != #[trigger] forbidden[j])
}

spec fn valid_sequence(sequence: Seq<nat>, m: nat, forbidden: Seq<nat>) -> bool
  recommends m > 0
{
    (forall|i: int| 0 <= i < sequence.len() ==> #[trigger] sequence[i] >= 0 && sequence[i] < m) &&
    all_distinct(Seq::new(1, |x: int| 1).add(prefix_products(sequence, m))) &&
    no_forbidden_products(sequence, forbidden, m)
}",,"fn solve(n: u8, m: u8, forbidden: Vec<u8>) -> (result: (u8, Vec<u8>))
  requires valid_input(n as nat, m as nat, forbidden@.map(|i, x: u8| x as nat))
  ensures ({
      let (length, sequence) = result;
      length == sequence.len() as u8 &&
      length >= 0 &&
      (m == 1 ==> length == 0 && sequence@ == Seq::<u8>::empty()) &&
      (m > 1 ==> valid_sequence(sequence@.map(|i, x: u8| x as nat), m as nat, forbidden@.map(|i, x: u8| x as nat))) &&
      (n == 0 && m > 1 ==> length > 0)
  })","{
    assume(false);
    (0, Vec::new())
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0437,verus,apps,apps_test_2451,,"Given a building with n towers and h floors each, find minimum travel time between pairs of locations.
Horizontal passages exist between adjacent towers only on floors a through b (inclusive).
Moving between adjacent floors or towers takes exactly 1 minute.","use vstd::prelude::*;

verus! {
spec fn valid_building_params(n: int, h: int, a: int, b: int) -> bool {
    n >= 1 && h >= 1 && 1 <= a <= b <= h
}

spec fn valid_query(query: (int, int, int, int), n: int, h: int) -> bool {
    1 <= query.0 <= n && 1 <= query.1 <= h &&
    1 <= query.2 <= n && 1 <= query.3 <= h
}

spec fn valid_queries(queries: Seq<(int, int, int, int)>, n: int, h: int) -> bool {
    forall|i: int| 0 <= i < queries.len() ==> #[trigger] valid_query(queries[i], n, h)
}

spec fn min_travel_time(t1: int, f1: int, t2: int, f2: int, a: int, b: int) -> int {
    if t1 == t2 {
        if f1 >= f2 { f1 - f2 } else { f2 - f1 }
    } else if f1 >= a && f1 <= b {
        (if t2 >= t1 { t2 - t1 } else { t1 - t2 }) + (if f2 >= f1 { f2 - f1 } else { f1 - f2 })
    } else if f1 < a {
        (a - f1) + (if t2 >= t1 { t2 - t1 } else { t1 - t2 }) + (if f2 >= a { f2 - a } else { a - f2 })
    } else {
        (f1 - b) + (if t2 >= t1 { t2 - t1 } else { t1 - t2 }) + (if f2 >= b { f2 - b } else { b - f2 })
    }
}

spec fn correct_results(queries: Seq<(int, int, int, int)>, results: Seq<int>, a: int, b: int) -> bool {
    results.len() == queries.len() &&
    forall|i: int| 0 <= i < queries.len() ==> {
        let (t1, f1, t2, f2) = queries[i];
        #[trigger] results[i] == min_travel_time(t1, f1, t2, f2, a, b)
    }
}",,"fn solve(n: i8, h: i8, a: i8, b: i8, queries: Vec<(i8, i8, i8, i8)>) -> (results: Vec<i8>)
    requires
        valid_building_params(n as int, h as int, a as int, b as int),
        valid_queries(queries@.map_values(|x: (i8, i8, i8, i8)| (x.0 as int, x.1 as int, x.2 as int, x.3 as int)), n as int, h as int),
    ensures
        correct_results(queries@.map_values(|x: (i8, i8, i8, i8)| (x.0 as int, x.1 as int, x.2 as int, x.3 as int)), results@.map_values(|x: i8| x as int), a as int, b as int),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0438,verus,apps,apps_test_2456,,"Given integers n and r, determine the number of distinct shapes that can be formed
by painting n consecutive days on calendars where a week can have k days (1 ≤ k ≤ r).
Days are arranged left-to-right in rows, wrapping to the next row when reaching 
the end of a week. All painted cells must be connected by sides. Two shapes are 
considered the same if one can be moved to exactly overlap the other using only 
parallel translations.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, r: int) -> bool {
    n >= 1 && r >= 1
}

spec fn expected_result(n: int, r: int) -> int {
    if valid_input(n, r) {
        let k = if r < n - 1 { r } else { n - 1 };
        k * (k + 1) / 2 + if r >= n { 1int } else { 0int }
    } else {
        0int
    }
}

fn solve_shapes(n: i8, r: i8) -> (result: i8)
    requires valid_input(n as int, r as int)
    ensures result as int == expected_result(n as int, r as int)",,,"{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0440,verus,apps,apps_test_2465,,"Given an angle measurement in degrees, find the minimum number of vertices n for a regular n-gon 
that contains three vertices a, b, c such that the angle ∠abc equals the given angle. 
If no such n-gon exists, return -1.","use vstd::prelude::*;

verus! {
spec fn valid_input(angles: Seq<int>) -> bool {
    forall|i: int| 0 <= i < angles.len() ==> #[trigger] angles[i] >= 1 && #[trigger] angles[i] < 180
}

spec fn gcd(a: int, b: int) -> int;

spec fn compute_answer(angle: int) -> int {
    let g = gcd(angle, 180int);
    let de_over_g = angle / g;
    let n180_over_g = 180int / g;
    if de_over_g == n180_over_g - 1 { n180_over_g * 2 } else { n180_over_g }
}

spec fn correct_output(angles: Seq<int>, result: Seq<int>) -> bool {
    valid_input(angles) ==> (
        result.len() == angles.len() &&
        forall|i: int| 0 <= i < angles.len() ==> #[trigger] result[i] == compute_answer(#[trigger] angles[i])
    )
}",,"fn solve(angles: Vec<i8>) -> (result: Vec<i8>)
    requires valid_input(angles@.map(|i, x: i8| x as int))
    ensures correct_output(angles@.map(|i, x: i8| x as int), result@.map(|i, x: i8| x as int))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0442,verus,apps,apps_test_2467,,"Find all unique combinations of exactly k distinct numbers from the range [1, 9] that sum to n.
Each number must be from 1 to 9, used at most once per combination, with no duplicate combinations.","use vstd::prelude::*;

verus! {
spec fn sum(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else {
        s[0] + sum(s.subrange(1, s.len() as int))
    }
}

spec fn is_distinct(s: Seq<int>) -> bool {
    forall|i: int, j: int| 0 <= i < j < s.len() ==> #[trigger] s[i] != #[trigger] s[j]
}

spec fn is_sorted(s: Seq<int>) -> bool {
    forall|i: int| 0 <= i < s.len() - 1 ==> #[trigger] s[i] < s[i + 1]
}

spec fn is_valid_combination(combo: Seq<int>, k: int, n: int) -> bool {
    combo.len() == k &&
    sum(combo) == n &&
    (forall|j: int| 0 <= j < combo.len() ==> 1 <= #[trigger] combo[j] <= 9) &&
    is_distinct(combo) &&
    is_sorted(combo)
}

spec fn is_valid_extension(temp: Seq<int>, combo: Seq<int>, k: int, n: int, start: int) -> bool {
    combo.len() == k &&
    sum(combo) == n &&
    (forall|j: int| 0 <= j < combo.len() ==> 1 <= #[trigger] combo[j] <= 9) &&
    is_distinct(combo) &&
    is_sorted(combo) &&
    combo.len() >= temp.len() &&
    (forall|i: int| 0 <= i < temp.len() ==> #[trigger] temp[i] == #[trigger] combo[i]) &&
    (forall|i: int| temp.len() <= i < combo.len() ==> #[trigger] combo[i] >= start)
}","spec fn to_int_seq(v: Vec<i8>) -> Seq<int> {
    v@.map(|i: int, x: i8| x as int)
}
","fn combination_sum3(k: i8, n: i8) -> (result: Vec<Vec<i8>>)
    requires k > 0 && n > 0 && k <= 9
    ensures 
        (forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i].len() == k as int) &&
        (forall|i: int| 0 <= i < result.len() ==> sum(to_int_seq(#[trigger] result[i])) == n as int) &&
        (forall|i: int| 0 <= i < result.len() ==> forall|j: int| 0 <= j < #[trigger] result[i].len() ==> 1 <= #[trigger] result[i][j] as int <= 9) &&
        (forall|i: int| 0 <= i < result.len() ==> is_distinct(to_int_seq(#[trigger] result[i]))) &&
        (forall|i: int| 0 <= i < result.len() ==> is_sorted(to_int_seq(#[trigger] result[i]))) &&
        (forall|i: int, j: int| 0 <= i < j < result.len() ==> to_int_seq(#[trigger] result[i]) != to_int_seq(#[trigger] result[j])) &&
        (forall|combo: Seq<int>| is_valid_combination(combo, k as int, n as int) ==> exists|i: int| 0 <= i < result.len() && to_int_seq(#[trigger] result[i]) == combo) &&
        (forall|i: int| 0 <= i < result.len() ==> is_valid_combination(to_int_seq(#[trigger] result[i]), k as int, n as int))","{
    assume(false);
    Vec::new()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0443,verus,apps,apps_test_2486,,"Given N cards with positive integers, determine how many cards are ""unnecessary.""
A subset of cards is ""good"" if the sum of its numbers is at least K.
A card is ""unnecessary"" if for every good subset containing this card, 
removing the card from that subset still results in a good subset.
Count the number of unnecessary cards.","use vstd::prelude::*;

verus! {
spec fn unnecessary_cards_count(sorted: Seq<int>, k: int) -> int
  recommends
    forall|i: int, j: int| 0 <= i < j < sorted.len() ==> sorted[i] >= sorted[j],
    forall|i: int| 0 <= i < sorted.len() ==> sorted[i] >= 1,
    k >= 1
{
  if sorted.len() == 0 {
    0
  } else {
    unnecessary_cards_count_helper(sorted, k, 0, 0, 0)
  }
}

spec fn unnecessary_cards_count_helper(sorted: Seq<int>, k: int, temp: int, ans: int, i: int) -> int
  recommends
    forall|x: int, y: int| 0 <= x < y < sorted.len() ==> sorted[x] >= sorted[y],
    forall|x: int| 0 <= x < sorted.len() ==> sorted[x] >= 1,
    k >= 1,
    0 <= i <= sorted.len(),
    temp >= 0,
    ans >= 0
  decreases sorted.len() - i
{
  if i >= sorted.len() {
    ans
  } else {
    let x = sorted[i];
    if temp + x < k {
      unnecessary_cards_count_helper(sorted, k, temp + x, ans + 1, i + 1)
    } else {
      unnecessary_cards_count_helper(sorted, k, 0, 0, i + 1)
    }
  }
}",,"fn solve(n: i8, k: i8, a: Vec<i8>) -> (result: i8)
  requires
    n >= 1,
    k >= 1,
    a.len() == n as usize,
    forall|i: int| 0 <= i < a.len() ==> a[i] as int >= 1
  ensures
    result >= 0,
    result as int <= n as int,
    exists|sorted: Seq<int>|
      sorted.len() == a@.len() &&
      sorted.to_multiset() == a@.map(|i: int, x: i8| x as int).to_multiset() &&
      (forall|i: int, j: int| 0 <= i < j < sorted.len() ==> sorted[i] >= sorted[j]) &&
      (forall|i: int| 0 <= i < sorted.len() ==> sorted[i] >= 1) &&
      result as int == unnecessary_cards_count(sorted, k as int)","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0445,verus,apps,apps_test_2516,,"Given a string S of length N containing only digits 0-9 and a prime number P,
count how many contiguous substrings of S are divisible by P when interpreted
as base-10 integers.","use vstd::prelude::*;

verus! {
spec fn is_prime(p: int) -> bool {
    p >= 2 && forall|k: int| 2 <= k < p ==> #[trigger] (p % k) != 0
}

spec fn valid_input(n: int, p: int, s: Seq<char>) -> bool {
    n >= 1 &&
    p >= 2 &&
    is_prime(p) &&
    s.len() == n &&
    forall|i: int| 0 <= i < s.len() ==> '0' <= #[trigger] s[i] <= '9'
}

spec fn substring_to_int(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if s.len() == 1 {
        (s[0] as int) - ('0' as int)
    } else {
        substring_to_int(s.subrange(0, s.len() as int - 1)) * 10 + ((s[s.len() as int - 1] as int) - ('0' as int))
    }
}

spec fn valid_result(result: int, n: int) -> bool {
    result >= 0 && result <= n * (n + 1) / 2
}",,"fn solve(n: i8, p: i8, s: Vec<char>) -> (result: i8)
    requires valid_input(n as int, p as int, s@)
    ensures valid_result(result as int, n as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0447,verus,apps,apps_test_2548,,"Given an array of n integers (each from 0 to 9), count the number of subarrays 
where the sum of elements equals the length of the subarray.
A subarray from index l to r is ""good"" if: sum(a[l] + a[l+1] + ... + a[r]) = (r - l + 1)","use vstd::prelude::*;

verus! {

spec fn valid_input(digits: Seq<int>) -> bool {
    digits.len() >= 1 && forall|i: int| 0 <= i < digits.len() ==> #[trigger] digits[i] >= 0 && #[trigger] digits[i] <= 9
}

spec fn is_good_subarray(digits: Seq<int>, start: int, end: int) -> bool
    recommends 0 <= start <= end < digits.len()
{
    let subarray_sum = sum(digits.subrange(start, end + 1));
    let subarray_length = end - start + 1;
    subarray_sum == subarray_length
}

spec fn sum(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 { 0 } else { s[0] + sum(s.drop_first()) }
}

spec fn count_good_subarrays(digits: Seq<int>) -> int
    recommends valid_input(digits)
{
    count_good_subarrays_helper(digits, 0, map![0 => 1], 0, 0)
}

spec fn count_good_subarrays_helper(digits: Seq<int>, pos: int, freq_map: Map<int, int>, 
                                  current_sum: int, current_count: int) -> int
    recommends 
        0 <= pos <= digits.len() &&
        valid_input(digits) &&
        current_count == pos &&
        current_sum >= 0 &&
        (forall|k: int| freq_map.dom().contains(k) ==> #[trigger] freq_map[k] >= 0) &&
        (freq_map.dom().contains(0) ==> freq_map[0] >= 1)
    decreases digits.len() - pos
{
    if pos >= digits.len() { 0 }
    else {
        let new_sum = current_sum + digits[pos];
        let new_count = current_count + 1;
        let diff = new_count - new_sum;
        let contribution = if freq_map.dom().contains(diff) { freq_map[diff] } else { 0 };
        let new_freq_map = freq_map.insert(diff, if freq_map.dom().contains(diff) { freq_map[diff] + 1 } else { 1 });
        contribution + count_good_subarrays_helper(digits, pos + 1, new_freq_map, new_sum, new_count)
    }
}",,"fn count_good_subarrays_in_array(digits: Vec<i8>) -> (count: i8)
    requires 
        valid_input(digits@.map(|i, x| x as int)),
    ensures 
        count >= 0,
        count as int == count_good_subarrays(digits@.map(|i, x| x as int)),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0448,verus,apps,apps_test_2550,,"Given n students with scores between 0 and m, redistribute scores to maximize student 1's score
while preserving the total sum and keeping all scores within [0, m].","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, m: int, scores: Seq<int>) -> bool {
    n >= 1 && m >= 1 && scores.len() == n &&
    forall|i: int| 0 <= i < scores.len() ==> #[trigger] scores[i] >= 0 && #[trigger] scores[i] <= m
}

spec fn sum(nums: Seq<int>) -> int
    decreases nums.len()
{
    if nums.len() == 0 { 
        0 
    } else { 
        nums[0] + sum(nums.subrange(1, nums.len() as int)) 
    }
}

spec fn min(a: int, b: int) -> int {
    if a <= b { a } else { b }
}

spec fn valid_redistribution(original: Seq<int>, redistributed: Seq<int>, m: int) -> bool {
    redistributed.len() == original.len() &&
    sum(redistributed) == sum(original) &&
    forall|i: int| 0 <= i < redistributed.len() ==> #[trigger] redistributed[i] >= 0 && #[trigger] redistributed[i] <= m
}

spec fn max_possible_first_score(n: int, m: int, scores: Seq<int>) -> int {
    min(sum(scores), m)
}",,"fn solve(n: i8, m: i8, scores: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, m as int, scores@.map(|_i: int, x: i8| x as int)),
    ensures 
        result as int == max_possible_first_score(n as int, m as int, scores@.map(|_i: int, x: i8| x as int)),
        result as int == min(sum(scores@.map(|_i: int, x: i8| x as int)), m as int),
        exists|redistributed: Seq<int>| (valid_redistribution(scores@.map(|_i: int, x: i8| x as int), redistributed, m as int) && 
            redistributed[0] == result as int),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0451,verus,apps,apps_test_2560,,"Given a target sum n and a range of coin denominations [l, r], determine if it's possible 
to make exactly the sum n using coins with denominations between l and r (inclusive).
You have unlimited coins of each valid denomination.","use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0
}

spec fn can_make_sum(n: int, l: int, r: int) -> bool {
    l > 0 && l <= r && n > 0 && n % l <= (r - l) * (n / l)
}

spec fn valid_output(result: Seq<char>) -> bool {
    result.len() >= 0
}

spec fn correct_solution(input: Seq<char>, result: Seq<char>) -> bool {
    /* Implementation would require string parsing functions like split_lines, parse_int, etc.
       For now, we'll use a simplified specification */
    true
}",,"fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires 
        valid_input(input@)
    ensures 
        valid_output(result@),
        correct_solution(input@, result@)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0452,verus,apps,apps_test_2568,,"Given a string of '+' and '-' characters, simulate finding the minimum initial value
needed to keep a running sum non-negative throughout the string. Count the total
number of characters processed across all attempts until finding a successful initial value.","use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> s[i] == '+' || s[i] == '-'
}

spec fn compute_result(s: Seq<char>) -> int {
    compute_result_helper(s, 0, 0, 0, s.len() as int)
}

spec fn compute_result_helper(s: Seq<char>, i: int, cur: int, pm: int, ans: int) -> int
    decreases s.len() - i when 0 <= i <= s.len()
{
    if i == s.len() {
        ans
    } else if s[i] == '+' {
        compute_result_helper(s, i + 1, cur + 1, pm, ans)
    } else {
        let new_cur = cur - 1;
        if new_cur < pm {
            compute_result_helper(s, i + 1, new_cur, new_cur, ans + i + 1)
        } else {
            compute_result_helper(s, i + 1, new_cur, pm, ans)
        }
    }
}",,"fn solve(s: Vec<char>) -> (result: i8)
    requires 
        valid_input(s@),
        s.len() <= 127
    ensures 
        result as int >= s@.len(),
        result as int == compute_result(s@)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0453,verus,apps,apps_test_2583,,"Two players play a game starting with integer n. Players alternate turns, with the first player moving first.
On each turn, a player must make exactly one of these moves:
1. Divide n by any odd divisor of n greater than 1
2. Subtract 1 from n (only if n > 1)
The player unable to make a move loses. Determine the winner assuming both players play optimally.","use vstd::prelude::*;

verus! {

spec fn determine_winner(n: int) -> &'static str
    recommends n >= 1
{
    if n == 1 { ""FastestFinger"" }
    else if n == 2 { ""Ashishgup"" }
    else if is_power_of_two(n) { ""FastestFinger"" }
    else if n % 4 != 2 { ""Ashishgup"" }
    else if is_limited_prime(n / 2) { ""FastestFinger"" }
    else { ""Ashishgup"" }
}

spec fn is_power_of_two(n: int) -> bool
    recommends n >= 1
    decreases n
{
    if n <= 0 { false }
    else { n == 1 || (n % 2 == 0 && is_power_of_two(n / 2)) }
}

spec fn is_limited_prime(p: int) -> bool
    recommends p >= 1
{
    if p <= 1 { false }
    else if p == 2 { true }
    else if p % 2 == 0 { false }
    else { true /* simplified primality check */ }
}",,"fn solve(input: Vec<i8>) -> (result: Vec<&'static str>)
    requires
        input.len() >= 1,
        input[0] as int >= 1,
        input.len() == input[0] as int + 1,
        forall|i: int| #![auto] 1 <= i < input.len() ==> input[i as int] as int >= 1
    ensures
        result.len() == input[0] as int,
        forall|i: int| #![auto] 0 <= i < result.len() ==> result[i as int] == ""FastestFinger"" || result[i as int] == ""Ashishgup"",
        forall|i: int| #![auto] 1 <= i < input.len() ==> result[(i-1) as int] == determine_winner(input[i as int] as int)","{
    // impl-start
    assume(false);
    Vec::new()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0455,verus,apps,apps_test_2602,,"Given vanilla cookies (a), chocolate cookies (b), type-1 guests (n), and type-2 guests (m),
determine if there exists an ordering of all guests such that no guest gets angry.
Type-1 guests choose vanilla if v > c, else chocolate.
Type-2 guests choose chocolate if v > c, else vanilla.
A guest gets angry if their chosen cookie type has 0 cookies available.

/* First check: must have enough total cookies */

/* Second check: type-2 guests are the limiting factor */

/* They will take from the minority cookie type, so we need */

/* enough of the minority type to satisfy all type-2 guests */","use vstd::prelude::*;

verus! {

spec fn valid_test_case(a: nat, b: nat, n: nat, m: nat) -> bool
{
    n + m > 0
}

spec fn can_satisfy_all_guests(a: nat, b: nat, n: nat, m: nat) -> bool
{
    a + b >= n + m &&
    m <= min(a, b)
}

spec fn min(x: nat, y: nat) -> nat
{
    if x <= y { x } else { y }
}",,"fn solve_cookie_distribution(a: u8, b: u8, n: u8, m: u8) -> (result: bool)
    requires
        valid_test_case(a as nat, b as nat, n as nat, m as nat),
    ensures
        result == can_satisfy_all_guests(a as nat, b as nat, n as nat, m as nat),
        result ==> ((a as nat) + (b as nat) >= (n as nat) + (m as nat) && (m as nat) <= min(a as nat, b as nat)),
        !result ==> ((a as nat) + (b as nat) < (n as nat) + (m as nat) || (m as nat) > min(a as nat, b as nat)),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0456,verus,apps,apps_test_2612,,"Find the maximum number of models that can be selected to form a ""beautiful arrangement.""
A beautiful arrangement is a subsequence of models arranged in increasing order of their indices,
where for any two adjacent models with indices i and j (i < j), j must be divisible by i
and the size of model i must be strictly less than the size of model j.

/* All indices are distinct */

/* Indices are in increasing order */

/* Adjacent elements satisfy divisibility constraint */

/* Adjacent elements satisfy size constraint */","use vstd::prelude::*;

verus! {

spec fn is_valid_beautiful_arrangement(arrangement: Seq<int>, sizes: Seq<int>) -> bool {
    arrangement.len() >= 1 &&
    (forall|i: int, j: int| #![trigger arrangement[i], arrangement[j]] 0 <= i < j < arrangement.len() ==> arrangement[i] != arrangement[j]) &&
    (forall|i: int| #![trigger arrangement[i]] 0 <= i < arrangement.len() - 1 ==> arrangement[i] < arrangement[i + 1]) &&
    (forall|i: int| #![trigger arrangement[i]] 0 <= i < arrangement.len() - 1 ==> arrangement[i + 1] % arrangement[i] == 0) &&
    (forall|i: int| #![trigger arrangement[i]] 0 <= i < arrangement.len() - 1 ==> 
        0 <= arrangement[i] - 1 < sizes.len() && 
        0 <= arrangement[i + 1] - 1 < sizes.len() &&
        sizes[arrangement[i] - 1] < sizes[arrangement[i + 1] - 1])
}

spec fn valid_input(n: int, sizes: Seq<int>) -> bool {
    n >= 1 && sizes.len() == n && forall|i: int| #![trigger sizes[i]] 0 <= i < n ==> sizes[i] >= 1
}",,"fn solve(n: i8, sizes: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, sizes@.map(|x: int, v: i8| v as int))
    ensures 1 <= result as int <= n as int","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0459,verus,apps,apps_test_2622,,"Given two maps: First map N × M grid, Second map M × N grid.
Find positions i and j such that the M × M section from the first map 
starting at row i equals the M × M section from the second map starting at column j.
Output the 1-indexed positions i and j.","use vstd::prelude::*;

verus! {

spec fn valid_input_format(input: Seq<char>) -> bool {
    let lines = parse_lines_func(input);
    lines.len() >= 3 &&
    {
        let first_line = parse_ints_func(lines[0]);
        first_line.len() >= 2 &&
        {
            let n = first_line[0];
            let m = first_line[1];
            n >= 1 && m >= 1 && m <= n &&
            lines.len() >= 1 + n + m &&
            (forall|k: int| 1 <= k <= n ==> k < lines.len() && lines[k].len() >= m) &&
            (forall|k: int| 1 + n <= k < 1 + n + m ==> k < lines.len() && lines[k].len() >= n)
        }
    }
}

spec fn valid_solution(input: Seq<char>, result: Seq<char>) -> bool {
    let lines = parse_lines_func(input);
    if lines.len() < 3 { 
        true 
    } else {
        let first_line = parse_ints_func(lines[0]);
        if first_line.len() < 2 { 
            true 
        } else {
            let n = first_line[0];
            let m = first_line[1];
            if n <= 0 || m <= 0 || m > n { 
                true 
            } else {
                let result_parts = parse_ints_func(result);
                if result_parts.len() < 2 { 
                    false 
                } else {
                    let i = result_parts[0];
                    let j = result_parts[1];
                    1 <= i <= n - m + 1 && 1 <= j <= n - m + 1 &&
                    if lines.len() >= 1 + n + m { 
                        correct_sub_matrices_match(lines, n, m, i - 1, j - 1) 
                    } else { 
                        false 
                    }
                }
            }
        }
    }
}

spec fn solution_exists(input: Seq<char>) -> bool {
    if !valid_input_format(input) { 
        false 
    } else {
        let lines = parse_lines_func(input);
        let first_line = parse_ints_func(lines[0]);
        let n = first_line[0];
        let m = first_line[1];
        exists|i: int, j: int| 0 <= i <= n - m && 0 <= j <= n - m &&
            correct_sub_matrices_match(lines, n, m, i, j)
    }
}

spec fn solution_found(input: Seq<char>, result: Seq<char>) -> bool {
    valid_solution(input, result) &&
    if !valid_input_format(input) { 
        false 
    } else {
        let lines = parse_lines_func(input);
        let first_line = parse_ints_func(lines[0]);
        let n = first_line[0];
        let m = first_line[1];
        let result_parts = parse_ints_func(result);
        if result_parts.len() >= 2 {
            let i = result_parts[0] - 1;
            let j = result_parts[1] - 1;
            correct_sub_matrices_match(lines, n, m, i, j)
        } else { 
            false 
        }
    }
}

spec fn correct_matrix_matching(input: Seq<char>, result: Seq<char>) -> bool {
    if !valid_input_format(input) { 
        true 
    } else {
        let lines = parse_lines_func(input);
        let first_line = parse_ints_func(lines[0]);
        let n = first_line[0];
        let m = first_line[1];
        let result_parts = parse_ints_func(result);
        if result_parts.len() >= 2 {
            let i = result_parts[0] - 1;
            let j = result_parts[1] - 1;
            0 <= i <= n - m && 0 <= j <= n - m &&
            (forall|r: int, c: int| 
                #![trigger r + c]
                (0 <= r < m && 0 <= c < m) ==> true)
        } else { 
            false 
        }
    }
}

spec fn always_returns_first_match(input: Seq<char>, result: Seq<char>) -> bool {
    if !valid_input_format(input) { 
        true 
    } else {
        let lines = parse_lines_func(input);
        let first_line = parse_ints_func(lines[0]);
        let n = first_line[0];
        let m = first_line[1];
        let result_parts = parse_ints_func(result);
        if result_parts.len() >= 2 {
            let result_i = result_parts[0] - 1;
            let result_j = result_parts[1] - 1;
            forall|i: int, j: int| 
                #![trigger correct_sub_matrices_match(lines, n, m, i, j)]
                (0 <= i <= n - m && 0 <= j <= n - m &&
                (i < result_i || (i == result_i && j < result_j))) ==>
                !correct_sub_matrices_match(lines, n, m, i, j)
        } else { 
            false 
        }
    }
}

spec fn correct_sub_matrices_match(lines: Seq<Seq<char>>, n: int, m: int, i: int, j: int) -> bool
    recommends 
        lines.len() >= 1 + n + m,
        0 <= i <= n - m && 0 <= j <= n - m
{
    forall|r: int, c: int| 
        #![trigger r + c]
        (0 <= r < m && 0 <= c < m) ==> true
}

spec fn parse_lines_func(input: Seq<char>) -> Seq<Seq<char>> {
    seq![seq!['a']]
}

spec fn parse_ints_func(line: Seq<char>) -> Seq<int> {
    seq![1, 1]
}

spec fn int_to_string_func(n: int) -> Seq<char> {
    if n == 0 { seq!['0'] }
    else if n == 1 { seq!['1'] }
    else if n == 2 { seq!['2'] }
    else if n == 3 { seq!['3'] }
    else if n == 4 { seq!['4'] }
    else if n == 5 { seq!['5'] }
    else if n == 6 { seq!['6'] }
    else if n == 7 { seq!['7'] }
    else if n == 8 { seq!['8'] }
    else if n == 9 { seq!['9'] }
    else { seq!['1', '0'] }
}",,"fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)
    requires 
        stdin_input@.len() > 0,
        valid_input_format(stdin_input@),
    ensures 
        result@.len() > 0,
        exists|i: int, j: int| i >= 1 && j >= 1 && result@ == int_to_string_func(i) + seq![' '] + int_to_string_func(j),
        valid_solution(stdin_input@, result@),
        solution_exists(stdin_input@) ==> solution_found(stdin_input@, result@),
        correct_matrix_matching(stdin_input@, result@),
        always_returns_first_match(stdin_input@, result@),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0460,verus,apps,apps_test_2627,,"Given a 2D binary matrix containing only ""0""s and ""1""s, find the area of the largest rectangle that contains only ""1""s.","use vstd::prelude::*;

verus! {
spec fn valid_matrix(matrix: Seq<Seq<&str>>) -> bool {
    (forall|i: int| 0 <= i < matrix.len() ==> #[trigger] matrix[i].len() == (if matrix.len() == 0 { 0 } else { matrix[0].len() as int })) &&
    (forall|i: int, j: int| 0 <= i < matrix.len() && 0 <= j < matrix[i].len() ==> #[trigger] matrix[i][j] == ""0"" || matrix[i][j] == ""1"")
}

spec fn max_possible_area(matrix: Seq<Seq<&str>>) -> int {
    (matrix.len() as int) * (if matrix.len() == 0 { 0 } else { matrix[0].len() as int })
}

spec fn empty_matrix(matrix: Seq<Seq<&str>>) -> bool {
    matrix.len() == 0 || matrix[0].len() == 0
}",,"fn maximal_rectangle(matrix: Vec<Vec<&str>>) -> (result: i32)
    requires
        valid_matrix(matrix@.map(|i: int, row: Vec<&str>| row@)),
    ensures
        result >= 0,
        empty_matrix(matrix@.map(|i: int, row: Vec<&str>| row@)) ==> result == 0,
        result <= max_possible_area(matrix@.map(|i: int, row: Vec<&str>| row@)),","{
    assume(false);
    0
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0461,verus,apps,apps_test_2629,,"Given a positive integer n, create an n×n matrix filled with integers from 1 to n² 
arranged in clockwise spiral order, starting from the top-left corner.

/* Top row of current layer */

/* Right column of current layer */

/* Bottom row of current layer */

/* Left column of current layer */","use vstd::prelude::*;

verus! {
spec fn min(a: int, b: int) -> int {
    if a <= b { a } else { b }
}

spec fn spiral_order(row: int, col: int, n: int) -> int
    recommends 0 <= row < n && 0 <= col < n && n >= 1
    decreases n - 2 * min(min(row, col), min(n-1-row, n-1-col)) - 1
{
    let layer = min(min(row, col), min(n-1-row, n-1-col));
    let layer_start = 4 * layer * (n - layer - 1) + layer;

    if row == layer {
        /* Top row of current layer */
        layer_start + (col - layer)
    } else if col == n - 1 - layer {
        /* Right column of current layer */
        layer_start + (n - 2 * layer - 1) + (row - layer)
    } else if row == n - 1 - layer {
        /* Bottom row of current layer */
        layer_start + 2 * (n - 2 * layer - 1) + (n - 1 - layer - col)
    } else {
        /* Left column of current layer */
        layer_start + 3 * (n - 2 * layer - 1) + (n - 1 - layer - row)
    }
}

spec fn valid_input(n: int) -> bool {
    n >= 1
}

spec fn valid_spiral_matrix(matrix: &Vec<Vec<int>>, n: int) -> bool {
    matrix.len() == n &&
    (forall|i: int| 0 <= i < n ==> (#[trigger] matrix[i]).len() == n) &&
    (forall|i: int, j: int| 0 <= i < n && 0 <= j < n ==> #[trigger] matrix[i][j] == spiral_order(i, j, n) + 1)
}",,"fn generate_matrix(n: i8) -> (matrix: Vec<Vec<i8>>)
    requires 
        valid_input(n as int)
    ensures 
        matrix@.len() == n as int && (forall|i: int| 0 <= i < n as int ==> (#[trigger] matrix@[i]).len() == n as int) &&
        (forall|i: int, j: int| 0 <= i < n as int && 0 <= j < n as int ==> 1 <= #[trigger] (matrix@[i][j] as int) <= (n as int) * (n as int)) &&
        (forall|i: int, j: int| 0 <= i < n as int && 0 <= j < n as int ==> #[trigger] (matrix@[i][j] as int) == spiral_order(i, j, n as int) + 1)","{
    assume(false);
    Vec::new()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0462,verus,apps,apps_test_2630,,"Given an m×n grid where 0 represents empty cell and 1 represents obstacle,
find the number of unique paths from top-left (0,0) to bottom-right (m-1,n-1).
Movement is restricted to right and down only, cannot pass through obstacles.","use vstd::prelude::*;

verus! {

spec fn valid_grid(grid: Seq<Seq<int>>) -> bool {
    grid.len() > 0 && grid[0].len() > 0 &&
    (forall|i: int| #![trigger grid[i].len(), grid[0].len()] 0 <= i < grid.len() ==> grid[i].len() == grid[0].len()) &&
    (forall|i: int, j: int| #![trigger grid[i][j]] 0 <= i < grid.len() && 0 <= j < grid[i].len() ==> 
        grid[i][j] == 0 || grid[i][j] == 1)
}

spec fn binomial(n: int, k: int) -> int
    decreases n, k
{
    if k > n || n < 0 || k < 0 {
        0int
    } else if k == 0 || k == n {
        1int
    } else if k == 1 {
        n
    } else {
        binomial(n-1, k-1) + binomial(n-1, k)
    }
}

spec fn dp_path_count(grid: Seq<Seq<int>>) -> int
    recommends valid_grid(grid)
{
    let m = grid.len();
    let n = grid[0].len();
    if grid[0][0] == 1 || grid[m-1][n-1] == 1 {
        0int
    } else if m == 1 && n == 1 {
        1int
    } else if m == 1 {
        if forall|j: int| #![trigger grid[0][j]] 0 <= j < n ==> grid[0][j] == 0 { 1int } else { 0int }
    } else if n == 1 {
        if forall|i: int| #![trigger grid[i][0]] 0 <= i < m ==> grid[i][0] == 0 { 1int } else { 0int }
    } else if forall|i: int, j: int| #![trigger grid[i][j]] 0 <= i < m && 0 <= j < n ==> grid[i][j] == 0 {
        binomial(m + n - 2, m - 1)
    } else {
        0int  /* placeholder for complex case */
    }
}",,"exec fn unique_paths_with_obstacles(obstacle_grid: Vec<Vec<i8>>) -> (result: i8)
    requires 
        valid_grid(obstacle_grid@.map(|i, row: Vec<i8>| row@.map(|j, x: i8| x as int))),
    ensures 
        result >= 0,
        obstacle_grid@[0][0] == 1 ==> result == 0,
        obstacle_grid@[obstacle_grid@.len()-1][obstacle_grid@[0].len()-1] == 1 ==> result == 0,
        obstacle_grid@.len() == 1 && obstacle_grid@[0].len() == 1 ==> 
            result == (if obstacle_grid@[0][0] == 0 { 1i8 } else { 0i8 }),
        result as int == dp_path_count(obstacle_grid@.map(|i, row: Vec<i8>| row@.map(|j, x: i8| x as int))),
        (forall|i: int, j: int| #![trigger obstacle_grid@[i][j]] 0 <= i < obstacle_grid@.len() && 0 <= j < obstacle_grid@[0].len() ==> obstacle_grid@[i][j] == 0) ==> 
            result as int == binomial(obstacle_grid@.len() + obstacle_grid@[0].len() - 2, obstacle_grid@.len() - 1),
        obstacle_grid@.len() == 1 ==> 
            (result > 0 <==> (forall|j: int| #![trigger obstacle_grid@[0][j]] 0 <= j < obstacle_grid@[0].len() ==> obstacle_grid@[0][j] == 0)),
        obstacle_grid@[0].len() == 1 ==> 
            (result > 0 <==> (forall|i: int| #![trigger obstacle_grid@[i][0]] 0 <= i < obstacle_grid@.len() ==> obstacle_grid@[i][0] == 0))","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0463,verus,apps,apps_test_2632,,"Given an m×n grid of non-negative integers, find the minimum sum path from the top-left corner 
to the bottom-right corner. You can only move right or down.

/* right */

/* down */","use vstd::prelude::*;

verus! {

spec fn valid_path(path: Seq<(int, int)>, m: int, n: int) -> bool {
    path.len() >= 1 &&
    path[0] == (0int, 0int) &&
    path[path.len() - 1] == (m - 1, n - 1) &&
    (forall|i: int| #![trigger path[i]] 0 <= i < path.len() ==> 0 <= path[i].0 < m && 0 <= path[i].1 < n) &&
    forall|i: int| #![trigger path[i]] 0 <= i < path.len() - 1 ==> 
        (path[i + 1].0 == path[i].0 && path[i + 1].1 == path[i].1 + 1) ||
        (path[i + 1].0 == path[i].0 + 1 && path[i + 1].1 == path[i].1)
}

spec fn path_sum(path: Seq<(int, int)>, grid: Seq<Vec<i32>>) -> int
    recommends forall|i: int| #![trigger path[i]] 0 <= i < path.len() ==> 0 <= path[i].0 < grid.len() && 0 <= path[i].1 < grid[path[i].0].len()
    decreases path.len()
{
    if path.len() == 0 { 
        0 
    } else { 
        grid[path[0].0][path[0].1] as int + path_sum(path.subrange(1, path.len() as int), grid)
    }
}

spec fn valid_input(grid: Seq<Vec<i32>>) -> bool {
    grid.len() > 0 && 
    (forall|i: int| #![trigger grid[i]] 0 <= i < grid.len() ==> grid[i].len() > 0) &&
    (grid.len() > 0 ==> (forall|i: int| #![trigger grid[i]] 0 <= i < grid.len() ==> grid[i].len() == grid[0].len())) &&
    forall|i: int, j: int| #![trigger grid[i][j]] 0 <= i < grid.len() && 0 <= j < grid[i].len() ==> grid[i][j] >= 0
}",,"fn min_path_sum(grid: Vec<Vec<i32>>) -> (result: i32)
    requires 
        valid_input(grid@),
    ensures 
        result >= 0,
        grid.len() == 1 && grid[0].len() == 1 ==> result == grid[0][0],","{
    assume(false);
    0
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0464,verus,apps,apps_test_2633,,"Find the minimum initial health required for a character to travel from the top-left 
corner to the bottom-right corner of an M x N grid. The character can only move right 
or down, and dies if health drops to 0 or below at any point.","use vstd::prelude::*;

verus! {
spec fn valid_dungeon(dungeon: Seq<Seq<int>>) -> bool {
    dungeon.len() > 0 &&
    (forall|i: int| 0 <= i < dungeon.len() ==> #[trigger] dungeon[i].len() > 0) &&
    (forall|i: int| 0 <= i < dungeon.len() ==> #[trigger] dungeon[i].len() == dungeon[0].len())
}

spec fn is_valid_path(dungeon: Seq<Seq<int>>, path: Seq<(int, int)>) -> bool
    recommends valid_dungeon(dungeon)
{
    path.len() > 0 &&
    path[0] == (0int, 0int) &&
    path[path.len()-1] == (dungeon.len()-1, dungeon[0].len()-1) &&
    (forall|i: int| 0 <= i < path.len() ==> {
        let (r, c) = #[trigger] path[i];
        0 <= r < dungeon.len() && 0 <= c < dungeon[0].len()
    }) &&
    forall|i: int| 0 <= i < path.len()-1 ==> {
        (#[trigger] path[i].1 == path[i+1].1 && path[i].0 + 1 == path[i+1].0) ||
        (path[i].0 == path[i+1].0 && path[i].1 + 1 == path[i+1].1)
    }
}

spec fn health_at_step(dungeon: Seq<Seq<int>>, path: Seq<(int, int)>, step: int, initial_health: int) -> int
    recommends 
        valid_dungeon(dungeon),
        is_valid_path(dungeon, path),
        0 <= step < path.len()
    decreases step when step >= 0
{
    if step == 0 {
        let (r, c) = path[0];
        initial_health + dungeon[r][c]
    } else {
        let (r, c) = path[step];
        health_at_step(dungeon, path, (step-1) as int, initial_health) + dungeon[r][c]
    }
}

spec fn can_survive_path(dungeon: Seq<Seq<int>>, path: Seq<(int, int)>, initial_health: int) -> bool
    recommends
        valid_dungeon(dungeon),
        is_valid_path(dungeon, path)
{
    forall|i: int| 0 <= i < path.len() ==> 
        #[trigger] health_at_step(dungeon, path, i, initial_health) > 0
}",,"fn calculate_minimum_hp(dungeon: Vec<Vec<i8>>) -> (result: i8)
    requires valid_dungeon(dungeon@.map(|i: int, row: Vec<i8>| row@.map(|j: int, x: i8| x as int)))
    ensures result >= 1","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0466,verus,apps,apps_test_2659,,"Given S(n) as the sum of digits in decimal notation of integer n, an integer n is called a ""Snuke number"" 
if for all positive integers m > n, the inequality n/S(n) ≤ m/S(m) holds.
Given an integer K, find the K smallest Snuke numbers.","use vstd::prelude::*;

verus! {
spec fn sum_of_digits(n: int) -> int
  recommends n >= 0
  decreases n
{
  if n < 10 { n }
  else { (n % 10) + sum_of_digits(n / 10) }
}

spec fn valid_output(result: Seq<int>, k: int) -> bool {
  &&& result.len() == k
  &&& (forall|i: int| 0 <= i < k ==> result[i] > 0)
  &&& (forall|i: int| #![trigger result.index(i)] 0 <= i < k - 1 ==> result.index(i) < result.index(i + 1))
  &&& (k >= 1 ==> result[0] == 1)
  &&& (k >= 2 ==> result[1] == 2)
  &&& (k >= 3 ==> result[2] == 3)
  &&& (k >= 4 ==> result[3] == 4)
  &&& (k >= 5 ==> result[4] == 5)
  &&& (k >= 6 ==> result[5] == 6)
  &&& (k >= 7 ==> result[6] == 7)
  &&& (k >= 8 ==> result[7] == 8)
  &&& (k >= 9 ==> result[8] == 9)
  &&& (k >= 10 ==> result[9] == 19)
}",,"fn solve(k: i8) -> (result: Vec<i8>)
  requires k as int >= 1
  ensures valid_output(result@.map(|i: int, x: i8| x as int), k as int)","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0467,verus,apps,apps_test_3805,,"Two wires run from left to right between a wall and device. Given a string of '+' and '-' 
representing wire crossings, determine if wires can be untangled by free movement without
unplugging. Uses stack algorithm where same adjacent characters cancel out.","use vstd::prelude::*;

verus! {
spec fn extract_first_line(input: Seq<char>) -> Seq<char>
    decreases input.len()
{
    if input.len() == 0 {
        Seq::empty()
    } else if input[0] == '\n' {
        Seq::empty()
    } else {
        seq![input[0]] + extract_first_line(input.subrange(1, input.len() as int))
    }
}

spec fn process_string(input: Seq<char>, stack: Seq<char>) -> Seq<char>
    decreases input.len()
{
    if input.len() == 0 {
        stack
    } else {
        let c = input[0];
        let new_stack = if stack.len() > 0 && stack[stack.len() - 1] == c {
            stack.subrange(0, stack.len() - 1)
        } else {
            stack.push(c)
        };
        process_string(input.subrange(1, input.len() as int), new_stack)
    }
}

spec fn stack_algorithm_results_in_empty_stack(input: Seq<char>) -> bool
{
    let stack = process_string(input, Seq::empty());
    stack.len() == 0
}",,"fn solve(input: Vec<char>) -> (result: Vec<char>)
    ensures result@.len() > 0","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0468,verus,apps,apps_test_4088,,"Given a string s of lowercase letters and an array b, find a string t such that:
1. t is formed by removing some characters from s and rearranging the remaining characters
2. For each position i in t, b[i] equals the sum of distances |i-j| to all positions j where t[j] > t[i] lexicographically
Process multiple test cases from stdin input and return formatted results","use vstd::prelude::*;

verus! {

spec fn valid_input_format(input: Seq<char>) -> bool {
    input.len() > 0
    /* TODO: Implement full validation logic for:
     * - Lines parsing and validation
     * - Test case count validation  
     * - String and integer array parsing
     * - Character and bounds validation
     */
}

spec fn valid_output_format(output: Seq<char>, input: Seq<char>) -> bool {
    valid_input_format(input) ==> output.len() > 0
    /* TODO: Implement validation for:
     * - Output lines matching test cases
     * - Correct string lengths
     * - Valid lowercase characters
     */
}

spec fn output_satisfies_constraints(output: Seq<char>, input: Seq<char>) -> bool {
    valid_input_format(input) ==> true
    /* TODO: Implement constraint validation for:
     * - Distance sum calculations
     * - Character ordering requirements
     */
}

spec fn preserves_character_usage(output: Seq<char>, input: Seq<char>) -> bool {
    valid_input_format(input) ==> true
    /* TODO: Implement character count preservation:
     * - Character frequency validation
     * - Subset usage validation
     */
}

spec fn contains_newline_terminated_results(output: Seq<char>) -> bool {
    output.len() > 0 ==> output[output.len() - 1] == '\n'
}

spec fn sum_distances_to_greater_chars(t: Seq<char>, j: int) -> int {
    0
    /* TODO: Implement distance sum calculation:
     * - Compare characters lexicographically
     * - Calculate absolute differences
     * - Sum all applicable distances
     */
}

spec fn abs_diff(i: int, j: int) -> int {
    if i >= j { i - j } else { j - i }
}",,"fn solve(stdin_input: String) -> (result: String)
    requires 
        stdin_input@.len() > 0,
        valid_input_format(stdin_input@),
    ensures 
        valid_output_format(result@, stdin_input@),
        output_satisfies_constraints(result@, stdin_input@),
        preserves_character_usage(result@, stdin_input@),
        result@.len() > 0 ==> contains_newline_terminated_results(result@),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0469,verus,apps,apps_test_4111,,"Given n candies with weights, determine how many candies can be given to dad
such that when the remaining n-1 candies are eaten in numerical order (one per day),
the sum of weights eaten on even-numbered days equals the sum on odd-numbered days.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, arr: Seq<int>) -> bool {
    n >= 1 && arr.len() == n && forall|i: int| 0 <= i < n ==> arr[i] >= 1
}

spec fn sum_even_indices(arr: Seq<int>, start: int) -> int
    decreases arr.len() - start when 0 <= start <= arr.len()
{
    if start == arr.len() {
        0
    } else {
        let contribution = if start % 2 == 0 { arr[start] } else { 0 };
        contribution + sum_even_indices(arr, start + 1)
    }
}

spec fn sum_odd_indices(arr: Seq<int>, start: int) -> int
    decreases arr.len() - start when 0 <= start <= arr.len()
{
    if start == arr.len() {
        0
    } else {
        let contribution = if start % 2 == 1 { arr[start] } else { 0 };
        contribution + sum_odd_indices(arr, start + 1)
    }
}

spec fn count_balanced_removals(arr: Seq<int>) -> int {
    let n = arr.len();
    if n == 0 {
        0
    } else {
        count_helper(arr, 0, sum_even_indices(arr, 0), sum_odd_indices(arr, 0), 0, 0)
    }
}

spec fn count_helper(arr: Seq<int>, i: int, count1: int, count2: int, temp1: int, temp2: int) -> int
    decreases arr.len() - i when 0 <= i <= arr.len()
{
    if i == arr.len() {
        0
    } else {
        let contribution: int = 
            if i % 2 == 0 {
                let val1 = temp1 + count2 - temp2;
                let val2 = temp2 + count1 - temp1 - arr[i];
                if val1 == val2 { 1 } else { 0 }
            } else {
                let val1 = temp1 + count2 - temp2 - arr[i];
                let val2 = temp2 + count1 - temp1;
                if val1 == val2 { 1 } else { 0 }
            };
        let new_temp1 = if i % 2 == 0 { temp1 + arr[i] } else { temp1 };
        let new_temp2 = if i % 2 == 1 { temp2 + arr[i] } else { temp2 };
        contribution + count_helper(arr, i + 1, count1, count2, new_temp1, new_temp2)
    }
}",,"fn solve(n: i8, arr: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, arr@.map(|i: int, x: i8| x as int)),
    ensures 
        0 <= result as int <= n as int,
        result as int == count_balanced_removals(arr@.map(|i: int, x: i8| x as int)),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0470,verus,apps,apps_test_4115,,"Find the minimum number of character changes needed to make a string a palindrome.
In each operation, you can change any character to any other lowercase letter.","use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>) -> bool {
    s.len() >= 1
}

spec fn count_mismatches_up_to(s: Seq<char>, limit: int) -> int
    decreases limit
{
    if limit <= 0 || s.len() < 1 { 
        0 
    } else {
        let n = s.len() as int - 1;
        let mismatch: int = if limit > 0 && limit <= s.len() && s[limit-1] != s[n - (limit-1)] { 1 } else { 0 };
        count_mismatches_up_to(s, limit-1) + mismatch
    }
}

spec fn count_mismatches(s: Seq<char>) -> int {
    if s.len() >= 1 {
        count_mismatches_up_to(s, s.len() as int)
    } else {
        0
    }
}

spec fn valid_result(s: Seq<char>, result: int) -> bool {
    if valid_input(s) {
        result >= 0 && result <= s.len() / 2 && result == (count_mismatches(s) / 2)
    } else {
        false
    }
}",,"fn solve(s: Vec<char>) -> (result: i8)
    requires valid_input(s@)
    ensures valid_result(s@, result as int)","{
    /* impl-start */
    assume(false);
    unreached()
    /* impl-end */
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0471,verus,apps,apps_test_4142,,"Given a string containing only 'L', 'R', 'U', 'D' characters, determine if it is ""easily playable"".
A string is easily playable if odd positions (1-indexed) contain no 'L' and even positions contain no 'R'.","use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>) -> bool {
    1 <= s.len() <= 100 && forall|i: int| 0 <= i < s.len() ==> s[i] == 'L' || s[i] == 'R' || s[i] == 'U' || s[i] == 'D'
}

spec fn easily_playable(s: Seq<char>) -> bool {
    (forall|i: int| 0 <= i < s.len() && i % 2 == 0 ==> s[i] != 'L') &&
    (forall|i: int| 0 <= i < s.len() && i % 2 == 1 ==> s[i] != 'R')
}",,"fn solve(s: String) -> (result: String)
    requires valid_input(s@)
    ensures result@ == seq!['Y', 'e', 's'] <==> easily_playable(s@)","{
    assume(false);
    ""No"".to_string()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0472,verus,apps,apps_test_4143,,"Given N people starting at City 1, find the minimum time for all people to reach City 6
through a sequential 5-segment transportation system with different capacities per segment.
Each transport departs at integer times with specified capacity. Transfer time is negligible.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, a: int, b: int, c: int, d: int, e: int) -> bool {
    n >= 1 && a >= 1 && b >= 1 && c >= 1 && d >= 1 && e >= 1
}

spec fn min_capacity(a: int, b: int, c: int, d: int, e: int) -> int
    recommends a >= 1 && b >= 1 && c >= 1 && d >= 1 && e >= 1
{
    let temp1 = if a <= b { a } else { b };
    let temp2 = if temp1 <= c { temp1 } else { c };
    let temp3 = if temp2 <= d { temp2 } else { d };
    if temp3 <= e { temp3 } else { e }
}

spec fn ceil_div(a: int, b: int) -> int
    recommends a >= 0 && b >= 1
{
    (a + b - 1) / b
}

spec fn correct_result(n: int, a: int, b: int, c: int, d: int, e: int, result: int) -> bool
    recommends valid_input(n, a, b, c, d, e)
{
    let min_cap = min_capacity(a, b, c, d, e);
    let groups = ceil_div(n, min_cap);
    result == 4 + groups
}",,"fn solve(n: i8, a: i8, b: i8, c: i8, d: i8, e: i8) -> (result: i8)
    requires 
        valid_input(n as int, a as int, b as int, c as int, d as int, e as int)
    ensures 
        correct_result(n as int, a as int, b as int, c as int, d as int, e as int, result as int) &&
        result >= 5","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0475,verus,apps,apps_test_4159,,"Given three integers A, B, and K, where Takahashi has A cookies and Aoki has B cookies initially.
Takahashi performs exactly K actions, where each action follows this priority:
1. If Takahashi has cookies, he eats one of his own cookies
2. Otherwise, if Aoki has cookies, Takahashi eats one of Aoki's cookies  
3. Otherwise, do nothing
Determine how many cookies Takahashi and Aoki have after all K actions.","use vstd::prelude::*;

verus! {
spec fn valid_input(a: int, b: int, k: int) -> bool {
    a >= 0 && b >= 0 && k >= 0
}

spec fn expected_takahashi_cookies(a: int, b: int, k: int) -> int
    recommends valid_input(a, b, k)
{
    if a >= k { a - k }
    else { 0 }
}

spec fn expected_aoki_cookies(a: int, b: int, k: int) -> int
    recommends valid_input(a, b, k)
{
    if a >= k { b }
    else if k - a < b { b - (k - a) }
    else { 0 }
}

spec fn correct_result(a: int, b: int, k: int, takahashi: int, aoki: int) -> bool
    recommends valid_input(a, b, k)
{
    takahashi == expected_takahashi_cookies(a, b, k) &&
    aoki == expected_aoki_cookies(a, b, k) &&
    takahashi >= 0 && aoki >= 0
}",,"fn solve(a: i8, b: i8, k: i8) -> (result: (i8, i8))
    requires valid_input(a as int, b as int, k as int)
    ensures correct_result(a as int, b as int, k as int, result.0 as int, result.1 as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0476,verus,apps,apps_test_4160,,"Find the minimum number of years needed for a bank balance to reach a target amount.
Starting with 100 yen, the balance grows each year by adding 1% interest (rounded down).
Given a target amount X, determine how many years it takes for the balance to reach X yen or above.
The yearly calculation is: new_balance = current_balance + floor(current_balance / 100)","use vstd::prelude::*;

verus! {

spec fn calculate_deposit(initial: int, years: int) -> int
    decreases years
{
    if years <= 0 { 
        initial 
    } else { 
        let prev_deposit = calculate_deposit(initial, years - 1);
        prev_deposit + prev_deposit / 100
    }
}",,"fn solve(x: i8) -> (years: i8)
    requires x >= 101
    ensures 
        years >= 0 &&
        calculate_deposit(100, years as int) >= x as int &&
        (years == 0 || calculate_deposit(100, (years - 1) as int) < x as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0478,verus,apps,apps_test_4167,,"Count ordered triples (a,b,c) where 1 ≤ a,b,c ≤ N and a+b, b+c, c+a are all divisible by K","use vstd::prelude::*;

verus! {
spec fn valid_triple(a: int, b: int, c: int, n: int, k: int) -> bool
    recommends k >= 1
{
    1 <= a <= n && 1 <= b <= n && 1 <= c <= n &&
    (a + b) % k == 0 && (b + c) % k == 0 && (c + a) % k == 0
}

spec fn count_valid_triples(n: int, k: int) -> int
    recommends n >= 1 && k >= 1
{
    if k % 2 == 1 {
        let cnt1 = n / k;
        cnt1 * cnt1 * cnt1
    } else {
        let cnt1 = n / k;
        let cnt2 = n / k + (if n % k >= k / 2 { 1int } else { 0int });
        cnt1 * cnt1 * cnt1 + cnt2 * cnt2 * cnt2
    }
}

spec fn valid_input(n: int, k: int) -> bool {
    n >= 1 && k >= 1
}

spec fn count_divisible_by_k(n: int, k: int) -> int
    recommends k >= 1
{
    if n <= 0 { 0int } else { n / k }
}

spec fn count_with_remainder_half_k(n: int, k: int) -> int
    recommends k >= 1
{
    if n <= 0 { 0int } else { n / k + (if n % k >= k / 2 { 1int } else { 0int }) }
}",,"fn solve(n: i8, k: i8) -> (result: i8)
    requires 
        valid_input(n as int, k as int)
    ensures 
        result >= 0,
        result as int == count_valid_triples(n as int, k as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVA00,0.85
VA0479,verus,apps,apps_test_4173,,"Find the minimum cost to purchase exactly n liters of water using 1-liter bottles 
(costing a burles each) and 2-liter bottles (costing b burles each), with infinite 
supply of both types available. Process multiple queries efficiently.","use vstd::prelude::*;

verus! {

spec fn valid_query(query: (int, int, int)) -> bool {
    query.0 > 0 && query.1 > 0 && query.2 > 0
}

spec fn min_cost_for_query(n: int, a: int, b: int) -> int
    recommends n > 0 && a > 0 && b > 0
{
    if n % 2 == 0 {
        if n * a <= (n / 2) * b { n * a } else { (n / 2) * b }
    } else {
        if n * a <= (n / 2) * b + a { n * a } else { (n / 2) * b + a }
    }
}",,"fn solve(queries: Vec<(i8, i8, i8)>) -> (results: Vec<i8>)
    requires 
        forall|i: int| 0 <= i < queries@.len() ==> #[trigger] valid_query((queries@[i].0 as int, queries@[i].1 as int, queries@[i].2 as int))
    ensures 
        results@.len() == queries@.len() &&
        forall|i: int| 0 <= i < queries@.len() ==> {
            let n = queries@[i].0 as int;
            let a = queries@[i].1 as int;
            let b = queries@[i].2 as int;
            #[trigger] results@[i] as int == (if n % 2 == 0 {
                if n * a <= (n / 2) * b { n * a } else { (n / 2) * b }
            } else {
                if n * a <= (n / 2) * b + a { n * a } else { (n / 2) * b + a }
            })
        }","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0481,verus,apps,apps_test_4176,,"Given two integers A and B representing possible numbers of guests at a party,
find the minimum number of snack pieces that can be evenly distributed among
the guests in both scenarios (A guests or B guests). Each piece must go to
exactly one guest, and each guest must receive the same number of pieces
within each scenario. This is equivalent to finding the LCM of A and B.","use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 &&
    exists|space_index: int| 0 <= space_index < input.len() && 
        input[space_index] == ' ' &&
    forall|i: int| 0 <= i < input.len() ==> 
        (input[i] == ' ' || ('0' <= input[i] <= '9'))
}

spec fn parse_two_ints(s: Seq<char>) -> (int, int) {
    if valid_input(s) { (1, 1) } else { (1, 1) }
}

spec fn lcm(a: int, b: int) -> int {
    if a > 0 && b > 0 { (a * b) / spec_gcd(a, b) } else { 1 }
}

spec fn spec_gcd(a: int, b: int) -> int
    decreases b
{
    if a > 0 && b > 0 {
        if b == 0 { a } else { spec_gcd(b, a % b) }
    } else { 1 }
}

spec fn valid_output(output: Seq<char>) -> bool {
    output.len() > 0 &&
    forall|i: int| 0 <= i < output.len() ==> #[trigger] output[i] >= '0' && #[trigger] output[i] <= '9'
}",,"fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(input@)
    ensures ({
        let nums = parse_two_ints(input@);
        let a = nums.0;
        let b = nums.1;
        a > 0 && b > 0
    }) && valid_output(result@)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0482,verus,apps,apps_test_4177,,"Given a string S consisting of lowercase English letters, replace every character with 'x' and output the result.","use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>) -> bool {
    s.len() >= 1 && s.len() <= 100 && forall|i: int| 0 <= i < s.len() ==> 'a' <= s[i] && s[i] <= 'z'
}

spec fn valid_output(s: Seq<char>, result: Seq<char>) -> bool {
    result.len() == s.len() && forall|i: int| 0 <= i < result.len() ==> result[i] == 'x'
}",,"fn solve(s: Vec<char>) -> (result: Vec<char>)
    requires valid_input(s@)
    ensures valid_output(s@, result@)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0483,verus,apps,apps_test_4178,,"Given N squares with heights, determine if it's possible to make heights non-decreasing
from left to right. For each square, you can decrease its height by 1 or leave unchanged.","use vstd::prelude::*;

verus! {
spec fn max_height_up_to(heights: Seq<int>, index: int) -> int
    decreases index + 1
{
    if heights.len() > 0 && -1 <= index < heights.len() {
        if index < 0 {
            0
        } else if index == 0 {
            heights[0]
        } else if heights[index] > max_height_up_to(heights, index - 1) {
            heights[index]
        } else {
            max_height_up_to(heights, index - 1)
        }
    } else {
        0
    }
}

spec fn valid_input(n: int, heights: Seq<int>) -> bool {
    n >= 1 && heights.len() == n && (forall|i: int| 0 <= i < heights.len() ==> heights[i] >= 1)
}

spec fn can_make_non_decreasing(heights: Seq<int>) -> bool {
    if heights.len() > 0 {
        forall|i: int| 0 <= i < heights.len() ==> heights[i] >= max_height_up_to(heights, i) - 1
    } else {
        true
    }
}",,"fn solve(n: i8, heights: Vec<i8>) -> (result: String)
    requires valid_input(n as int, heights@.map(|i: int, v: i8| v as int))
    ensures (result@ == seq!['Y', 'e', 's']) <==> can_make_non_decreasing(heights@.map(|i: int, v: i8| v as int))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0484,verus,apps,apps_test_4180,,"Given a cost N yen, calculate the change received when paying with the minimum number of 1000-yen bills.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int) -> bool {
    1 <= n <= 10000
}

spec fn valid_change(change: int) -> bool {
    0 <= change <= 999
}

spec fn correct_change(n: int) -> int
    recommends valid_input(n)
{
    (1000 - n % 1000) % 1000
}",,"fn solve(n: i8) -> (change: i8)
    requires valid_input(n as int)
    ensures 
        valid_change(change as int) &&
        change as int == correct_change(n as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0485,verus,apps,apps_test_4182,,"Two empires A and B have capitals at coordinates X and Y respectively.
Empire A wants to control cities at coordinates x₁, x₂, ..., xₙ, and 
Empire B wants to control cities at coordinates y₁, y₂, ..., yₘ.
They reach agreement if there exists integer Z such that X < Z ≤ Y,
all xᵢ < Z, and all yᵢ ≥ Z. Otherwise war breaks out.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, m: int, x: int, y: int, xx: Seq<int>, yy: Seq<int>) -> bool {
    xx.len() == n && yy.len() == m && n >= 1 && m >= 1 && x < y
}

spec fn agreement_possible(n: int, m: int, x: int, y: int, xx: Seq<int>, yy: Seq<int>) -> bool 
    recommends valid_input(n, m, x, y, xx, yy)
{
    let combined_x = xx.push(x);
    let combined_y = yy.push(y);
    exists|max_val: int| combined_x.contains(max_val) && 
                         (forall|v: int| combined_x.contains(v) ==> v <= max_val) &&
    exists|min_val: int| combined_y.contains(min_val) && 
                         (forall|v: int| combined_y.contains(v) ==> v >= min_val) &&
                         max_val < min_val
}",,"fn solve(n: i8, m: i8, x: i8, y: i8, xx: Vec<i8>, yy: Vec<i8>) -> (result: String)
    requires 
        valid_input(n as int, m as int, x as int, y as int, xx@.map(|_i: int, v: i8| v as int), yy@.map(|_i: int, v: i8| v as int)),
    ensures 
        result@ == seq!['N','o',' ','W','a','r'] || result@ == seq!['W','a','r'],
        (result@ == seq!['N','o',' ','W','a','r']) == agreement_possible(n as int, m as int, x as int, y as int, xx@.map(|_i: int, v: i8| v as int), yy@.map(|_i: int, v: i8| v as int)),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0486,verus,apps,apps_test_4183,,"Given N clocks where clock i completes one rotation in T_i seconds,
find the minimum positive time when all clocks return to their starting position.
This is equivalent to finding the LCM of all rotation periods.","use vstd::prelude::*;

verus! {
spec fn gcd(a: int, b: int) -> int
    decreases b when b >= 0
{
    if a > 0 && b >= 0 {
        if b == 0 { a } else { gcd(b, a % b) }
    } else {
        1  /* default for invalid input */
    }
}

spec fn lcm(a: int, b: int) -> int {
    if a > 0 && b > 0 {
        (a * b) / gcd(a, b)
    } else {
        1  /* default for invalid input */
    }
}

spec fn lcm_seq(nums: Seq<int>) -> int
    decreases nums.len()
{
    if nums.len() > 0 {
        if nums.len() == 1 { 
            nums[0] 
        } else { 
            lcm(nums[0], lcm_seq(nums.skip(1)))
        }
    } else {
        1  /* default for empty sequence */
    }
}

spec fn valid_input(periods: Seq<int>) -> bool {
    periods.len() > 0 && periods.len() <= 100 &&
    forall|i: int| 0 <= i < periods.len() ==> periods[i] > 0
}

spec fn correct_result(periods: Seq<int>, result: int) -> bool {
    valid_input(periods) ==> result == lcm_seq(periods)
}",,"fn find_minimum_time(periods: Vec<i8>) -> (result: i8)
    requires valid_input(periods@.map(|i: int, v: i8| v as int))
    ensures correct_result(periods@.map(|i: int, v: i8| v as int), result as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0487,verus,apps,apps_test_4188,,"Given 16 facts with numerical claims, determine whether each fact is true (1) or false (0) in reality.
Each fact is numbered from 1 to 16 based on order of appearance. Input n specifies which fact to check.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int) -> bool {
    1 <= n <= 16
}

spec fn fact_truth_values() -> Seq<int> {
    seq![1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0]
}

spec fn valid_output(result: int) -> bool {
    result == 0 || result == 1
}

spec fn expected_output(n: int) -> int
    recommends valid_input(n)
{
    fact_truth_values()[n - 1]
}",,"fn solve(n: i8) -> (result: i8)
    requires 
        valid_input(n as int)
    ensures 
        valid_output(result as int),
        result as int == expected_output(n as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0488,verus,apps,apps_test_4192,,"Determine if Takahashi can travel D meters in T minutes at a speed of S meters per minute.
Print ""Yes"" if he can travel the distance in the given time, otherwise print ""No"".","use vstd::prelude::*;

verus! {
spec fn valid_input(d: int, t: int, s: int) -> bool {
    1 <= d <= 10000 && 1 <= t <= 10000 && 1 <= s <= 10000
}

spec fn can_travel(d: int, t: int, s: int) -> bool {
    d <= t * s
}",,"fn solve(d: i8, t: i8, s: i8) -> (result: &'static str)
    requires 
        valid_input(d as int, t as int, s as int),
    ensures 
        can_travel(d as int, t as int, s as int) ==> result == ""Yes"",
        !can_travel(d as int, t as int, s as int) ==> result == ""No"",","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0489,verus,apps,apps_test_4194,,"Given N vacation days and M assignments where assignment i takes A_i days to complete,
find the maximum number of days available for hanging out. Each assignment must be
completed on consecutive days, and no hanging out is allowed on assignment days.
If all assignments cannot be completed within the vacation period, return -1.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, m: int, a: Seq<int>) -> bool {
    n >= 0 && m >= 0 && m == a.len()
}

spec fn can_complete_all_assignments(n: int, a: Seq<int>) -> bool {
    sum_seq(a) <= n
}

spec fn total_assignment_days(a: Seq<int>) -> int {
    sum_seq(a)
}

spec fn sum_seq(s: Seq<int>) -> int 
    decreases s.len()
{
    if s.len() == 0 { 
        0 
    } else { 
        s[0] + sum_seq(s.subrange(1, s.len() as int))
    }
}",,"fn solve(n: i8, m: i8, a: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, m as int, a@.map(|i, x: i8| x as int))
    ensures 
        m as int == 0 ==> result as int == n as int,
        m as int > 0 && can_complete_all_assignments(n as int, a@.map(|i, x: i8| x as int)) ==> result as int == n as int - total_assignment_days(a@.map(|i, x: i8| x as int)),
        m as int > 0 && !can_complete_all_assignments(n as int, a@.map(|i, x: i8| x as int)) ==> result as int == -1,
        result as int >= -1","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0491,verus,apps,apps_test_4206,,"Given a string of digits representing a positive integer, find the maximum number of valid numbers 
divisible by 3 that can be obtained by making vertical cuts between adjacent digits.
Numbers cannot have leading zeros (except single digit ""0""), and a number is divisible by 3 
if the sum of its digits is divisible by 3.","use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 &&
    input[input.len() - 1] == '\n' &&
    input.len() >= 2 &&
    (forall|i: int| 0 <= i < input.len() - 1 ==> ('0' <= input[i] && input[i] <= '9')) &&
    (input[0] != '0' || input.len() == 2)
}

spec fn max_divisible_by_3_segments(s: Seq<char>) -> int {
    if s.len() <= 0 {
        0
    } else if forall|i: int| 0 <= i < s.len() ==> ('0' <= s[i] && s[i] <= '9') {
        /* Placeholder for max segments computation helper call */
        0
    } else {
        0
    }
}",,"exec fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires
        valid_input(input@),
    ensures
        result@.len() > 0,
        result@[result@.len() - 1] == '\n',","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0492,verus,apps,apps_test_4211,,"Given an integer sequence B of length N-1, find the maximum possible sum of an integer sequence A of length N 
that satisfies the constraint: B_i >= max(A_i, A_{i+1}) for all valid i.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, b: Seq<int>) -> bool {
  n >= 2 && b.len() == n - 1 && forall|i: int| 0 <= i < b.len() ==> b[i] >= 0
}

spec fn sum_mins(b: Seq<int>, len: int) -> int
  decreases len
{
  if len <= 0 {
    0
  } else {
    b[len - 1] + sum_mins(b, len - 1)
  }
}

spec fn correct_result(n: int, b: Seq<int>, result: int) -> bool {
  valid_input(n, b) ==> {
    if n == 2 {
      result == 2 * b[0]
    } else {
      result == b[0] + b[n-2] + sum_mins(b, n-2)
    }
  }
}",,"fn solve(n: i8, b: Vec<i8>) -> (result: i8)
  requires valid_input(n as int, b@.map(|i: int, x: i8| x as int))
  ensures correct_result(n as int, b@.map(|i: int, x: i8| x as int), result as int)","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0493,verus,apps,apps_test_4215,,"Given a window of width A and two curtains each of horizontal length B,
determine the minimum total horizontal length of the uncovered part when 
the curtains are optimally positioned to minimize uncovered area.","use vstd::prelude::*;

verus! {
spec fn valid_input(a: int, b: int) -> bool {
    1 <= a <= 100 && 1 <= b <= 100
}

spec fn uncovered_length(a: int, b: int) -> int {
    if a - 2 * b > 0 { a - 2 * b } else { 0 }
}",,"fn solve(a: i8, b: i8) -> (result: i8)
    requires 
        valid_input(a as int, b as int)
    ensures 
        result >= 0,
        result as int == uncovered_length(a as int, b as int),
        result as int == if a as int > 2 * (b as int) { a as int - 2 * (b as int) } else { 0 }","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0494,verus,apps,apps_test_4216,,"Given a positive integer N, find the minimum value of F(A,B) over all pairs of positive integers (A,B) 
such that A × B = N, where F(A,B) is defined as the maximum of the number of digits in A and the number of digits in B.","use vstd::prelude::*;

verus! {
spec fn num_digits(n: int) -> int
  recommends n >= 1
  decreases n
{
  if n < 10 { 1 } else { 1 + num_digits(n / 10) }
}

spec fn valid_input(n: int) -> bool {
  n >= 1
}

spec fn f(a: int, b: int) -> int
  recommends a >= 1 && b >= 1
{
  let digits_a = num_digits(a);
  let digits_b = num_digits(b);
  if digits_a > digits_b { digits_a } else { digits_b }
}

spec fn is_factor_pair(a: int, b: int, n: int) -> bool {
  a >= 1 && b >= 1 && a * b == n
}",,"fn solve(n: i8) -> (result: i8)
  requires 
    valid_input(n as int)
  ensures 
    result >= 1,
    exists|a: int, b: int| is_factor_pair(a, b, n as int) && result as int == f(a, b),
    forall|a: int, b: int| is_factor_pair(a, b, n as int) ==> result as int <= f(a, b),","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0495,verus,apps,apps_test_4220,,"Given an integer K and a string S of lowercase English letters, output S unchanged if its length is at most K.
Otherwise, output the first K characters of S followed by ""..."".","use vstd::prelude::*;

verus! {

spec fn valid_input(stdin_input: Seq<char>) -> bool {
    stdin_input.len() > 0 &&
    (exists|i: int| 0 <= i < stdin_input.len() && stdin_input[i] == '\n') &&
    ({
        let newline_pos = find_newline(stdin_input, 0);
        let k_str = stdin_input.subrange(0, newline_pos as int);
        is_valid_positive_integer(k_str)
    }) &&
    ({
        let newline_pos = find_newline(stdin_input, 0);
        let k_str = stdin_input.subrange(0, newline_pos as int);
        let k = string_to_int(k_str);
        1 <= k <= 100
    }) &&
    ({
        let newline_pos = find_newline(stdin_input, 0);
        let rest = stdin_input.subrange(newline_pos as int + 1, stdin_input.len() as int);
        let s = if rest.len() > 0 && rest[rest.len() - 1] == '\n' { rest.subrange(0, rest.len() - 1) } else { rest };
        1 <= s.len() <= 100 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= 'a' && #[trigger] s[i] <= 'z'
    })
}

spec fn extract_k(stdin_input: Seq<char>) -> int
    recommends valid_input(stdin_input)
{
    let newline_pos = find_newline(stdin_input, 0);
    let k_str = stdin_input.subrange(0, newline_pos as int);
    string_to_int(k_str)
}

spec fn extract_s(stdin_input: Seq<char>) -> Seq<char>
    recommends valid_input(stdin_input)
{
    let newline_pos = find_newline(stdin_input, 0);
    let rest = stdin_input.subrange(newline_pos as int + 1, stdin_input.len() as int);
    if rest.len() > 0 && rest[rest.len() - 1] == '\n' { rest.subrange(0, rest.len() - 1) } else { rest }
}

spec fn correct_output(stdin_input: Seq<char>, result: Seq<char>) -> bool
    recommends valid_input(stdin_input)
{
    let k = extract_k(stdin_input);
    let s = extract_s(stdin_input);
    k >= 1 && k <= 100 &&
    s.len() >= 1 && s.len() <= 100 &&
    (forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= 'a' && #[trigger] s[i] <= 'z') &&
    (s.len() <= k ==> result == s.add(seq!['\n'])) &&
    (s.len() > k ==> result == s.subrange(0, k).add(seq!['.', '.', '.']).add(seq!['\n']))
}

spec fn find_newline(s: Seq<char>, start: nat) -> nat
    recommends start <= s.len()
    decreases s.len() - start
{
    if start >= s.len() { 
        s.len() 
    } else if s[start as int] == '\n' { 
        start 
    } else { 
        find_newline(s, start + 1) 
    }
}

spec fn is_valid_positive_integer(s: Seq<char>) -> bool {
    s.len() > 0 && 
    (forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9') && 
    s != seq!['0']
}

spec fn string_to_int(s: Seq<char>) -> int
    recommends is_valid_positive_integer(s)
{
    string_to_int_helper(s, 0, 0)
}

spec fn string_to_int_helper(s: Seq<char>, pos: nat, acc: int) -> int
    recommends
        pos <= s.len(),
        acc >= 0,
        forall|i: int| 0 <= i < pos ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9',
        is_valid_positive_integer(s)
    decreases s.len() - pos
{
    if pos >= s.len() { 
        if acc == 0 { 1 } else { acc }
    } else if s[pos as int] >= '0' && s[pos as int] <= '9' {
        string_to_int_helper(s, pos + 1, acc * 10 + (s[pos as int] as int - '0' as int))
    } else {
        if acc == 0 { 1 } else { acc }
    }
}",,"fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(stdin_input@)
    ensures correct_output(stdin_input@, result@)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0496,verus,apps,apps_test_4221,,"Convert a singular noun string containing only lowercase English letters to plural form.
If the string does not end with 's', append 's'.
If the string ends with 's', append 'es'.","use vstd::prelude::*;

verus! {

spec fn valid_input(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> 'a' <= s[i] && s[i] <= 'z'
}

spec fn correct_plural(s: Seq<char>, result: Seq<char>) -> bool {
    if s.len() > 0 && s[s.len() - 1] == 's' {
        result == s + seq!['e', 's']
    } else {
        result == s + seq!['s']
    }
}",,"fn solve(s: &Vec<char>) -> (result: Vec<char>)
    requires valid_input(s@)
    ensures correct_plural(s@, result@)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0497,verus,apps,apps_test_4224,,"Given an array of positive integers, find the maximum number of operations possible where each operation
allows dividing elements by 2 (if even) or multiplying by 3, with at least one division by 2 required per operation.","use vstd::prelude::*;

verus! {
spec fn valid_input(a: Seq<int>) -> bool {
    forall|i: int| 0 <= i < a.len() ==> a[i] > 0
}

spec fn count_factors_of_two(n: int) -> int
    decreases n when n > 0
{
    if n > 0 && n % 2 == 0 { 1 + count_factors_of_two(n / 2) }
    else { 0 }
}

spec fn sum_factors(a: Seq<int>, i: int) -> int
    decreases a.len() - i when 0 <= i <= a.len()
{
    if 0 <= i < a.len() && (forall|j: int| 0 <= j < a.len() ==> a[j] > 0) {
        count_factors_of_two(a[i]) + sum_factors(a, i + 1)
    } else if i == a.len() {
        0
    } else {
        0
    }
}

spec fn max_operations(a: Seq<int>) -> int {
    if valid_input(a) { sum_factors(a, 0) } else { 0 }
}",,"fn solve(a: Vec<i8>) -> (result: i8)
    requires 
        valid_input(a@.map(|i, x| x as int)),
    ensures 
        result >= 0,
        result as int == max_operations(a@.map(|i, x| x as int)),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0498,verus,apps,apps_test_4225,,"Given A cards with value 1, B cards with value 0, and C cards with value -1,
find the maximum possible sum when picking exactly K cards.
The optimal strategy is to pick cards with highest values first.","use vstd::prelude::*;

verus! {

spec fn valid_input(a: int, b: int, c: int, k: int) -> bool {
    a >= 0 && b >= 0 && c >= 0 && k >= 1 && k <= a + b + c
}

spec fn max_sum(a: int, b: int, c: int, k: int) -> int
    recommends valid_input(a, b, c, k)
{
    if k <= a + b {
        if k <= a { k } else { a }
    } else {
        a - (k - a - b)
    }
}

spec fn parsed_values(input: Seq<char>, a: int, b: int, c: int, k: int) -> bool {
    exists|parts: Seq<Seq<char>>| parts.len() >= 4 && 
        parts == split_string_pure(input) &&
        a == string_to_int_pure(parts[0]) &&
        b == string_to_int_pure(parts[1]) &&
        c == string_to_int_pure(parts[2]) &&
        k == string_to_int_pure(parts[3]) &&
        valid_input(a, b, c, k)
}

spec fn int_to_string_pure(n: int) -> Seq<char>
    recommends n >= -2000000000 && n <= 2000000000
{
    if n == 0 { seq!['0'] }
    else if n < 0 { seq!['-'] + int_to_string_pure_helper(-n) }
    else { int_to_string_pure_helper(n) }
}

spec fn int_to_string_pure_helper(n: int) -> Seq<char>
    recommends n > 0
    decreases n
{
    if n < 10 { seq![('0' as u8 + n as u8) as char] }
    else { int_to_string_pure_helper(n / 10) + seq![('0' as u8 + (n % 10) as u8) as char] }
}

spec fn split_string_pure(s: Seq<char>) -> Seq<Seq<char>> {
    if s.len() == 0 { seq![] }
    else { split_string_helper(s, 0, seq![], seq![]) }
}

spec fn split_string_helper(s: Seq<char>, i: int, current: Seq<char>, parts: Seq<Seq<char>>) -> Seq<Seq<char>>
    recommends 0 <= i <= s.len()
    decreases s.len() - i
{
    if i >= s.len() {
        if current.len() > 0 { parts + seq![current] } else { parts }
    } else if s[i] == ' ' || s[i] == '\n' {
        if current.len() > 0 { 
            split_string_helper(s, i+1, seq![], parts + seq![current])
        } else { 
            split_string_helper(s, i+1, seq![], parts)
        }
    } else {
        split_string_helper(s, i+1, current + seq![s[i]], parts)
    }
}

spec fn string_to_int_pure(s: Seq<char>) -> int {
    if s.len() == 0 { 0 }
    else if s[0] == '-' { -string_to_int_helper(s, 1) }
    else { string_to_int_helper(s, 0) }
}

spec fn string_to_int_helper(s: Seq<char>, start: int) -> int
    recommends 0 <= start <= s.len()
    decreases s.len() - start
{
    if start >= s.len() { 0 }
    else if '0' <= s[start] <= '9' {
        (s[start] as u8 - '0' as u8) as int + 10 * string_to_int_helper(s, start + 1)
    } else {
        string_to_int_helper(s, start + 1)
    }
}",,"fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires input@.len() > 0
    ensures 
        result@.len() > 0 &&
        result@[result@.len() as int - 1] == '\n' &&
        ((exists|a: int, b: int, c: int, k: int| 
            parsed_values(input@, a, b, c, k) &&
            ({
                let max_sum_val = max_sum(a, b, c, k);
                max_sum_val >= -2000000000 && max_sum_val <= 2000000000 &&
                result@ == int_to_string_pure(max_sum_val) + seq!['\n']
            })) ||
        (forall|a: int, b: int, c: int, k: int| !parsed_values(input@, a, b, c, k) ==> result@ == seq!['0', '\n']))","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0500,verus,apps,apps_test_4231,,"Given an H×W grid of white cells, choose h rows and w columns to paint black.
All cells that are either in a chosen row OR in a chosen column will be painted black.
Determine how many white cells remain after painting.","use vstd::prelude::*;

verus! {

spec fn valid_input(h: int, w: int, h_selected: int, w_selected: int) -> bool {
    1 <= h <= 20 && 1 <= w <= 20 && 1 <= h_selected <= h && 1 <= w_selected <= w
}

spec fn white_cells_remaining(h: int, w: int, h_selected: int, w_selected: int) -> int
    recommends valid_input(h, w, h_selected, w_selected)
{
    (h - h_selected) * (w - w_selected)
}",,"fn solve(h: i8, w: i8, h_selected: i8, w_selected: i8) -> (result: i8)
    requires 
        valid_input(h as int, w as int, h_selected as int, w_selected as int),
    ensures 
        result as int == white_cells_remaining(h as int, w as int, h_selected as int, w_selected as int),
        result >= 0,","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0502,verus,apps,apps_test_4234,,"Given a string of lowercase letters, delete the minimum number of characters to make it ""good"".
A string is ""good"" if its length is even and each character at odd positions (1st, 3rd, 5th, ...)
differs from the character at the next even position (2nd, 4th, 6th, ...).","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, s: Seq<char>) -> bool {
    n == s.len() && n >= 0
}

spec fn is_good_string(s: Seq<char>) -> bool {
    s.len() % 2 == 0 && forall|i: int| 0 <= i < s.len() / 2 ==> #[trigger] s[2*i] != #[trigger] s[2*i+1]
}",,"fn solve(n: usize, s: Vec<char>) -> (result: (usize, Vec<char>))
    requires 
        valid_input(n as int, s@),
    ensures 
        result.0 >= 0,
        result.0 == s@.len() - result.1@.len(),
        is_good_string(result.1@),
        result.0 + result.1@.len() == s@.len(),","{
    assume(false);
    (0, Vec::new())
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0503,verus,apps,apps_test_4237,,"Given four integers A, B, C, and D, find the count of integers in the range [A, B] (inclusive) 
that are divisible by neither C nor D.","use vstd::prelude::*;

verus! {

spec fn valid_input(a: int, b: int, c: int, d: int) -> bool {
  a >= 1 && b >= a && c >= 1 && d >= 1
}

spec fn not_divisible_by_either(x: int, c: int, d: int) -> bool
  recommends c > 0 && d > 0
{
  x % c != 0 && x % d != 0
}

spec fn count_not_divisible(a: int, b: int, c: int, d: int) -> int
  recommends valid_input(a, b, c, d)
{
  /* Count of integers in range [a, b] not divisible by either c or d */
  (Set::new(|x: int| a <= x <= b && not_divisible_by_either(x, c, d))).len() as int
}
spec fn f(n: int, c: int, d: int) -> int {
  /* Helper function f referenced in postcondition */
  0 as int  /* Placeholder specification */
}",,"fn solve(a: i8, b: i8, c: i8, d: i8) -> (result: i8)
  requires
      valid_input(a as int, b as int, c as int, d as int),
  ensures
      result as int >= 0,
      result as int == f(b as int, c as int, d as int) - f((a as int) - 1, c as int, d as int),","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0504,verus,apps,apps_test_4242,,"Given positive integers A and B, find the K-th largest positive integer that divides both A and B.
The K-th largest common divisor is guaranteed to exist for the given inputs.","use vstd::prelude::*;

verus! {
spec fn common_divisors(a: int, b: int) -> Set<int>
{
  Set::new(|d: int| 1 <= d <= a && a % d == 0 && b % d == 0)
}

spec fn valid_input(a: int, b: int, k: int) -> bool
{
  a > 0 && b > 0 && k >= 1 && common_divisors(a, b).len() >= k
}

spec fn is_kth_largest_common_divisor(a: int, b: int, k: int, result: int) -> bool
{
  valid_input(a, b, k) ==> (
    result > 0 &&
    a % result == 0 && b % result == 0 &&
    common_divisors(a, b).contains(result) &&
    Set::new(|d: int| common_divisors(a, b).contains(d) && d > result).len() == (k - 1)
  )
}",,"fn solve(a: i8, b: i8, k: i8) -> (result: i8)
  requires valid_input(a as int, b as int, k as int)
  ensures is_kth_largest_common_divisor(a as int, b as int, k as int, result as int)","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0505,verus,apps,apps_test_4245,,"Given a single socket that can be extended using power strips, find the minimum number of power strips needed to have at least B empty sockets. Each power strip has A sockets and when plugged into an empty socket, it replaces that 1 socket with A sockets (net gain of A-1 sockets).","use vstd::prelude::*;

verus! {
spec fn valid_input(a: int, b: int) -> bool {
    a > 1 && b >= 0
}

spec fn sockets_after_strips(strips: int, a: int) -> int
    recommends a > 1 && strips >= 0
{
    1 + strips * (a - 1)
}

spec fn ceiling_division(x: int, y: int) -> int
    recommends y > 0
{
    if x % y == 0 {
        x / y
    } else if x >= 0 {
        x / y + 1
    } else {
        x / y
    }
}

spec fn min_strips_needed(a: int, b: int) -> int
    recommends valid_input(a, b)
{
    if b <= 1 {
        0
    } else {
        ceiling_division(b - 1, a - 1)
    }
}

spec fn correct_result(a: int, b: int, result: int) -> bool
    recommends valid_input(a, b)
{
    result >= 0 &&
    sockets_after_strips(result, a) >= b &&
    (result == 0 || sockets_after_strips(result - 1, a) < b)
}",,"fn solve(a: i8, b: i8) -> (result: i8)
    requires valid_input(a as int, b as int)
    ensures correct_result(a as int, b as int, result as int)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0506,verus,apps,apps_test_4246,,"Given two strings S and T, each of length 3, representing weather forecasts and actual weather 
respectively for 3 consecutive days, count how many days the forecast was correct.
Each character represents weather: 'S' = sunny, 'C' = cloudy, 'R' = rainy.
Input: Two lines with strings of length 3 containing only 'S', 'C', 'R' characters.
Output: Integer representing the number of days where forecast matched actual weather.","use vstd::prelude::*;

verus! {

spec fn parse_lines(input: Seq<char>) -> Seq<Seq<char>> {
    seq![seq!['S', 'C', 'R'], seq!['S', 'C', 'R']]
}

spec fn int_to_string(n: int) -> Seq<char> {
    if n == 0 { seq!['0'] }
    else if n == 1 { seq!['1'] }
    else if n == 2 { seq!['2'] }
    else { seq!['3'] }
}
spec fn is_valid_input(input: Seq<char>) -> bool
    recommends input.len() > 0
{
    let lines = parse_lines(input);
    lines.len() >= 2 && lines[0].len() == 3 && lines[1].len() == 3
}

spec fn count_matches_from_input(input: Seq<char>) -> int
    recommends input.len() > 0 && is_valid_input(input)
{
    let lines = parse_lines(input);
    count_matches(lines[0], lines[1])
}

spec fn count_matches(s: Seq<char>, t: Seq<char>) -> int
    recommends s.len() == 3 && t.len() == 3
{
    (if s[0] == t[0] { 1int } else { 0int }) +
    (if s[1] == t[1] { 1int } else { 0int }) +
    (if s[2] == t[2] { 1int } else { 0int })
}

spec fn compute_result(input: Seq<char>) -> Seq<char>
    recommends input.len() > 0
{
    let lines = parse_lines(input);
    if lines.len() < 2 {
        seq!['0', '\n']
    } else if lines[0].len() != 3 || lines[1].len() != 3 {
        seq!['0', '\n']
    } else {
        int_to_string(count_matches(lines[0], lines[1])).add(seq!['\n'])
    }
}",,"fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires
        input.len() > 0,
    ensures
        result@ == compute_result(input@),
        result.len() >= 2 && result[result.len() - 1] == '\n',
        result[0] == '0' || result[0] == '1' || result[0] == '2' || result[0] == '3',","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0507,verus,apps,apps_test_4247,,"Given a permutation p of integers {1, 2, ..., n}, count how many elements p_i 
(where 1 < i < n) are the median (second smallest) value among the three 
consecutive elements p_{i-1}, p_i, and p_{i+1}.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, p: Seq<int>) -> bool {
    p.len() == n && n >= 3
}

spec fn count_median_elements(p: Seq<int>, n: int) -> nat {
    if valid_input(n, p) {
        Set::new(|i: int| 0 <= i < n - 2 && is_median_of_three(p[i], p[i + 1], p[i + 2])).len()
    } else {
        0
    }
}

spec fn is_median_of_three(a: int, b: int, c: int) -> bool {
    (a < b && b < c) || (a > b && b > c)
}",,"fn solve(n: u8, p: Vec<i8>) -> (result: u8)
    requires
        valid_input(n as int, p@.map(|i: int, x: i8| x as int)),
    ensures
        result <= n - 2,
        result as nat == count_median_elements(p@.map(|i: int, x: i8| x as int), n as int),","{
    // impl-start
    assume(false);
    0
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0508,verus,apps,apps_test_4252,,"Given a string of lowercase Latin letters, find the minimum number of characters 
to remove so that the resulting string does not contain ""xxx"" (three consecutive x's) 
as a substring. Characters can be removed from any positions. If the string initially 
doesn't contain ""xxx"", return 0.","use vstd::prelude::*;

verus! {

spec fn valid_input(s: Seq<char>) -> bool {
    s.len() >= 3
}

spec fn count_excessive_positions(s: Seq<char>) -> int {
    count_excessive_positions_helper(s, 0, 0)
}

spec fn count_excessive_positions_helper(s: Seq<char>, pos: int, consecutive_x: int) -> int
    decreases s.len() - pos
{
    if pos >= s.len() {
        0
    } else {
        let new_consecutive_x = if s[pos] == 'x' { consecutive_x + 1 } else { 0 };
        let current_contribution: int = if new_consecutive_x > 2 { 1 } else { 0 };
        current_contribution + count_excessive_positions_helper(s, pos + 1, new_consecutive_x)
    }
}

spec fn consecutive_x_count(s: Seq<char>, pos: int) -> int
    decreases pos
{
    if pos == 0 {
        0
    } else if pos > 0 && pos <= s.len() && s[pos - 1] == 'x' {
        1 + consecutive_x_count(s, pos - 1)
    } else {
        0
    }
}",,"fn solve(s: Vec<char>) -> (result: i8)
    requires valid_input(s@)
    ensures 
        result >= 0,
        result as int <= s@.len(),
        result as int == count_excessive_positions(s@)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0509,verus,apps,apps_test_4253,,"Calculate the area of a regular dodecagon inscribed in a circle of radius r.
The area formula is 3r². Input is an integer r (1 ≤ r ≤ 100).
Output is the integer area.","use vstd::prelude::*;

verus! {
spec fn valid_input(r: int) -> bool {
    1 <= r <= 100
}

spec fn dodecagon_area(r: int) -> int {
    3 * r * r
}

spec fn int_to_string(n: int) -> Seq<char>
    decreases n
{
    if n == 0 {
        seq!['0']
    } else if n < 10 {
        seq![('0' as int + n) as char]
    } else {
        int_to_string(n / 10) + int_to_string(n % 10)
    }
}

spec fn string_to_int(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 1 {
        (s[0] as int) - ('0' as int)
    } else if s.len() > 1 {
        string_to_int(s.subrange(0, s.len() - 1)) * 10 + ((s[s.len() - 1] as int) - ('0' as int))
    } else {
        0
    }
}",,fn solve(stdin_input: &str) -> (output: String),"{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0510,verus,apps,apps_test_4254,,"Given the number of sheep S and wolves W, determine if the situation is ""safe"" or ""unsafe"".
Output ""unsafe"" if the number of wolves is greater than or equal to the number of sheep,
otherwise output ""safe"". Input is a string containing two integers separated by space.","use vstd::prelude::*;

verus! {

spec fn valid_input_format(input: Seq<char>) -> bool {
    let trimmed = trim_newlines(input);
    let space_index = find_space(trimmed);
    space_index >= 0 && space_index < trimmed.len() - 1 &&
    is_valid_integer(trimmed.subrange(0, space_index)) &&
    is_valid_integer(trimmed.subrange(space_index + 1, trimmed.len() as int))
}

spec fn valid_input(input: Seq<char>, s: int, w: int) -> bool {
    valid_input_format(input) &&
    {
        let trimmed = trim_newlines(input);
        let space_index = find_space(trimmed);
        let s_str = trimmed.subrange(0, space_index);
        let w_str = trimmed.subrange(space_index + 1, trimmed.len() as int);
        string_to_int(s_str) == s && string_to_int(w_str) == w
    }
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    if s.len() == 0 {
        false
    } else if s[0] == '-' {
        s.len() > 1 && forall|i: int| 1 <= i < s.len() ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9'
    } else {
        forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9'
    }
}

spec fn trim_newlines(s: Seq<char>) -> Seq<char>
    decreases s.len()
{
    if s.len() == 0 {
        s
    } else if s[s.len() - 1] == '\n' {
        trim_newlines(s.subrange(0, s.len() - 1))
    } else {
        s
    }
}

spec fn find_space(s: Seq<char>) -> int {
    find_space_helper(s, 0)
}

spec fn find_space_helper(s: Seq<char>, index: int) -> int
    decreases s.len() - index
{
    if index >= s.len() {
        -1
    } else if s[index] == ' ' {
        index
    } else {
        find_space_helper(s, index + 1)
    }
}

spec fn string_to_int(s: Seq<char>) -> int {
    if s.len() == 0 {
        0
    } else if s[0] == '-' && s.len() > 1 {
        -string_to_int_helper(s.subrange(1, s.len() as int), 0, 0)
    } else {
        string_to_int_helper(s, 0, 0)
    }
}

spec fn string_to_int_helper(s: Seq<char>, index: int, acc: int) -> int
    decreases s.len() - index
{
    if index >= s.len() {
        acc
    } else {
        let digit = (s[index] as int) - ('0' as int);
        string_to_int_helper(s, index + 1, acc * 10 + digit)
    }
}",,"fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires input.len() > 0","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0511,verus,apps,apps_test_4255,,"Given a right triangle with a 90° angle at vertex B, and the lengths of all three sides AB, BC, and CA,
calculate the area of the triangle. The area is computed as (AB * BC) / 2 where AB and BC are the two
legs of the right triangle. Input consists of three integers representing the side lengths, and output
is the integer area.","use vstd::prelude::*;
use vstd::string::*;

verus! {
spec fn valid_input(ab: int, bc: int, ca: int) -> bool {
    1 <= ab <= 100 && 1 <= bc <= 100 && 1 <= ca <= 100
}

spec fn triangle_area(ab: int, bc: int) -> int
    recommends ab >= 1 && bc >= 1
{
    (ab * bc) / 2
}

spec fn valid_area(ab: int, bc: int, area: int) -> bool
    recommends ab >= 1 && bc >= 1
{
    area == triangle_area(ab, bc) && area >= 0 && area <= 5000
}",,"fn solve(ab: i8, bc: i8, ca: i8) -> (result: String)
    requires valid_input(ab as int, bc as int, ca as int)
    ensures exists|area: int| valid_area(ab as int, bc as int, area)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0512,verus,apps,apps_test_4256,,"Given three integers A (cost per drink), B (available money), and C (maximum drinks desired),
determine how many drinks will be purchased. The number of drinks purchased is the minimum of:
- How many drinks can be afforded: B // A  
- The satisfaction limit: C","use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 &&
    exists|i: int, j: int| 0 <= i < j < input.len() && input[i] == ' ' && input[j] == ' ' &&
    ({
        let parts = split_string_spec(input);
        parts.len() >= 3 && 
        is_valid_integer(parts[0]) && is_valid_integer(parts[1]) && is_valid_integer(parts[2]) &&
        ({
            let a = string_to_int_spec(parts[0]);
            let b = string_to_int_spec(parts[1]);
            let c = string_to_int_spec(parts[2]);
            1 <= a <= 100 && 1 <= b <= 100 && 1 <= c <= 100
        })
    })
}

spec fn compute_drinks(a: int, b: int, c: int) -> int {
    if b / a < c { b / a } else { c }
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && s[i] <= '9'
}

spec fn string_to_int_spec(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 1 { 
        s[0] as int - '0' as int
    } else if s.len() > 1 { 
        string_to_int_spec(s.subrange(0, s.len() - 1)) * 10 + (s[s.len() - 1] as int - '0' as int)
    } else {
        0
    }
}

spec fn split_string_spec(s: Seq<char>) -> Seq<Seq<char>> {
    if s.len() == 0 { 
        seq![] 
    } else {
        split_helper(s, 0, seq![])
    }
}

spec fn split_helper(s: Seq<char>, index: int, current: Seq<char>) -> Seq<Seq<char>>
    decreases s.len() - index
{
    if index >= s.len() {
        if current.len() > 0 { seq![current] } else { seq![] }
    } else if s[index] == ' ' || s[index] == '\n' || s[index] == '\t' {
        if current.len() > 0 { 
            seq![current] + split_helper(s, index + 1, seq![])
        } else { 
            split_helper(s, index + 1, seq![])
        }
    } else {
        split_helper(s, index + 1, current.push(s[index]))
    }
}

spec fn int_to_string_spec(n: int) -> Seq<char>
    decreases n
{
    if n == 0 { 
        seq!['0'] 
    } else if n < 10 && n > 0 { 
        seq![('0' as int + n) as char]
    } else if n > 0 { 
        int_to_string_spec(n / 10) + seq![('0' as int + (n % 10)) as char]
    } else {
        seq!['0']
    }
}",,"fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires
        valid_input(input@),
    ensures
        result@.len() > 0,
        result@[result@.len() - 1] == '\n',
        ({
            let parts = split_string_spec(input@);
            let a = string_to_int_spec(parts[0]);
            let b = string_to_int_spec(parts[1]);
            let c = string_to_int_spec(parts[2]);
            let drinks = compute_drinks(a, b, c);
            result@ == int_to_string_spec(drinks) + seq!['\n']
        }),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0513,verus,apps,apps_test_4258,,"A machine produces B biscuits at regular intervals of A seconds, starting at time A seconds.
Productions occur at times A, 2A, 3A, 4A, ... seconds after activation.
Calculate the total number of biscuits produced within the first T + 0.5 seconds.","use vstd::prelude::*;

verus! {
spec fn valid_input(a: int, b: int, t: int) -> bool {
    1 <= a <= 20 && 1 <= b <= 20 && 1 <= t <= 20
}

spec fn production_count(a: int, t: int) -> int {
    if a > 0 { t / a } else { 0 }
}

spec fn total_biscuits(a: int, b: int, t: int) -> int {
    if a > 0 { b * production_count(a, t) } else { 0 }
}",,"fn solve(a: i8, b: i8, t: i8) -> (result: i8)
    requires valid_input(a as int, b as int, t as int)
    ensures result as int == total_biscuits(a as int, b as int, t as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0514,verus,apps,apps_test_4261,,"Given two bottles where Bottle 1 has capacity A milliliters and currently contains B milliliters,
and Bottle 2 currently contains C milliliters, transfer as much water as possible from Bottle 2
to Bottle 1 and determine how much water remains in Bottle 2.","use vstd::prelude::*;

verus! {

spec fn valid_input(a: int, b: int, c: int) -> bool {
    1 <= b <= a <= 20 && 1 <= c <= 20
}

spec fn remaining_water(a: int, b: int, c: int) -> int
    recommends valid_input(a, b, c)
{
    let available_space = a - b;
    let remaining = c - available_space;
    if remaining >= 0 { remaining } else { 0 }
}",,"fn solve(input: Vec<i8>) -> (result: Vec<i8>)
    requires input.len() > 0","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0515,verus,apps,apps_test_4267,,"Given a room temperature in degrees Celsius, determine whether to turn on an air conditioner.
The air conditioner should be turned on if and only if the temperature is 30°C or higher.","use vstd::prelude::*;

verus! {
spec fn valid_temperature(temp: int) -> bool {
    -40 <= temp <= 40
}

spec fn expected_output(temp: int) -> Seq<char> {
    if temp >= 30 { seq!['Y', 'e', 's', '\n'] } else { seq!['N', 'o', '\n'] }
}

spec fn correct_output(temp: int, output: Seq<char>) -> bool {
    output == expected_output(temp)
}",,"fn solve(x: i8) -> (result: Vec<u8>)
    requires valid_temperature(x as int)
    ensures correct_output(x as int, result@.map(|i: int, b: u8| b as char))","{
    // impl-start
    assume(false);
    Vec::new()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0516,verus,apps,apps_test_4269,,"Given a 4-digit security code, determine if it is ""hard to enter"". A code is hard to enter
if it contains any two consecutive digits that are the same. Output ""Bad"" if the code is 
hard to enter, ""Good"" otherwise.","use vstd::prelude::*;

verus! {
spec fn is_hard_to_enter(s: Seq<char>) -> bool
    recommends s.len() == 4
{
    s[0] == s[1] || s[1] == s[2] || s[2] == s[3]
}",,"fn solve(s: Vec<char>) -> (result: Vec<char>)
    requires s@.len() == 4
    ensures 
        result@.len() > 0,
        (result@ == seq!['B', 'a', 'd'] <==> is_hard_to_enter(s@)),
        (result@ == seq!['G', 'o', 'o', 'd'] <==> !is_hard_to_enter(s@))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0519,verus,apps,apps_test_4275,,"Given a string of length 6 consisting of lowercase English letters, determine if it is ""coffee-like"".
A string is coffee-like if characters at positions 3 and 4 are equal, AND characters at positions 5 and 6 are equal (using 1-based indexing).","use vstd::prelude::*;
use vstd::string::*;

verus! {

spec fn valid_input(s: Seq<char>) -> bool {
    s.len() == 6 && forall|i: int| 0 <= i < 6 ==> 'a' <= #[trigger] s[i] <= 'z'
}

spec fn is_coffee_like(s: Seq<char>) -> bool 
recommends valid_input(s)
{
    s[2] == s[3] && s[4] == s[5]
}",,"fn solve(s: Vec<char>) -> (result: String)
    requires 
        valid_input(s@)
    ensures 
        result@ =~= seq!['Y', 'e', 's'] || result@ =~= seq!['N', 'o'],
        is_coffee_like(s@) <==> result@ =~= seq!['Y', 'e', 's']","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0520,verus,apps,apps_test_4277,,"Given N people traveling together, determine the minimum cost between two transportation options:
Train costs A yen per person (total: N*A), Taxi costs B yen total (fixed cost).
Find the minimum total travel expense.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, a: int, b: int) -> bool {
    1 <= n <= 20 && 1 <= a <= 50 && 1 <= b <= 50
}

spec fn train_cost(n: int, a: int) -> int {
    n * a
}

spec fn minimum_cost(n: int, a: int, b: int) -> int {
    let train_cost_val = train_cost(n, a);
    if train_cost_val < b { train_cost_val } else { b }
}

spec fn correct_result(input: Vec<i8>, result: Vec<i8>) -> bool {
    /* Implementation would require string parsing functions that are not available in this context */
    true
}",,"fn solve(input: Vec<i8>) -> (result: Vec<i8>)
    requires input.len() > 0
    ensures correct_result(input, result)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0521,verus,apps,apps_test_4284,,"Given q queries with battery charge k, n turns, and two actions with costs a and b (where b < a),
find the maximum number of Action A turns possible while completing exactly n turns and keeping
charge > 0 at the end, or return -1 if impossible.","use vstd::prelude::*;

verus! {
spec fn valid_query(k: int, n: int, a: int, b: int) -> bool {
    k > 0 && n > 0 && a > 0 && b > 0 && b < a
}

spec fn max_action_a_turns(k: int, n: int, a: int, b: int) -> int {
    if n * b > k { 
        -1
    } else { 
        let max_possible = (k - n * b - 1) / (a - b);
        if n <= max_possible { n } else { max_possible }
    }
}

spec fn valid_result(result: int, k: int, n: int, a: int, b: int) -> bool {
    result == -1 || (0 <= result <= n)
}",,"fn solve(queries: Vec<(i8, i8, i8, i8)>) -> (results: Vec<i8>)
    requires 
        queries.len() > 0,
        forall|i: int| 0 <= i < queries.len() ==> valid_query(#[trigger] queries[i as int].0 as int, queries[i as int].1 as int, queries[i as int].2 as int, queries[i as int].3 as int),
    ensures 
        results.len() == queries.len(),
        forall|i: int| 0 <= i < queries.len() ==> results[i as int] as int == max_action_a_turns(#[trigger] queries[i as int].0 as int, queries[i as int].1 as int, queries[i as int].2 as int, queries[i as int].3 as int),
        forall|i: int| 0 <= i < results.len() ==> valid_result(#[trigger] results[i as int] as int, queries[i as int].0 as int, queries[i as int].1 as int, queries[i as int].2 as int, queries[i as int].3 as int),","{
    assume(false);
    Vec::new()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0522,verus,apps,apps_test_4294,,"Given two integers X and A (both between 0 and 9 inclusive), output 0 if X is less than A, otherwise output 10.","use vstd::prelude::*;

verus! {
spec fn valid_input(x: int, a: int) -> bool {
    0 <= x <= 9 && 0 <= a <= 9
}

spec fn correct_output(x: int, a: int, result: int) -> bool {
    result == (if x < a { 0nat as int } else { 10nat as int })
}",,"fn solve(x: i8, a: i8) -> (result: i8)
    requires valid_input(x as int, a as int)
    ensures correct_output(x as int, a as int, result as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0523,verus,apps,apps_test_4295,,"Given integers N and K, repeatedly perform the operation N := |N - K| to find
the minimum possible value N can achieve after zero or more operations.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, k: int) -> bool {
    n >= 0 && k >= 1
}

spec fn min_value(n: int, k: int) -> int
    recommends valid_input(n, k)
{
    let remainder = n % k;
    let complement = k - remainder;
    if remainder <= complement { remainder } else { complement }
}

spec fn is_correct_result(n: int, k: int, result: int) -> bool
    recommends valid_input(n, k)
{
    result == min_value(n, k) &&
    result >= 0 &&
    result < k
}",,"fn solve(n: i8, k: i8) -> (result: i8)
    requires valid_input(n as int, k as int)
    ensures is_correct_result(n as int, k as int, result as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVA02,0.85
VA0524,verus,apps,apps_test_4297,,"Given a positive integer N, find the smallest positive integer that is divisible by both 2 and N.
This is equivalent to finding the least common multiple of 2 and N.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int) -> bool {
    n >= 1
}

spec fn divisible_by_both(result: int, n: int) -> bool
    recommends n >= 1
{
    result % 2 == 0 && result % n == 0
}

spec fn is_smallest(result: int, n: int) -> bool
    recommends n >= 1
{
    forall|k: int| 1 <= k < result ==> !(#[trigger] (k % 2) == 0 && #[trigger] (k % n) == 0)
}

spec fn lcm(a: int, b: int) -> int
    recommends a >= 1 && b >= 1
{
    if a % b == 0 {
        a
    } else if b % a == 0 {
        b
    } else {
        a * b
    }
}",,"fn solve(n: i8) -> (result: i8)
    requires 
        n >= 1,
    ensures 
        result >= 1,
        result as int % 2 == 0 && result as int % n as int == 0,
        forall|k: int| 1 <= k < result as int ==> !(#[trigger] (k % 2) == 0 && #[trigger] (k % n as int) == 0),
        (n as int % 2 == 0 ==> result as int == n as int) && (n as int % 2 != 0 ==> result as int == n as int * 2),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0525,verus,apps,apps_test_4298,,"Given N apple trees numbered 1 to N in a row, find the minimum number of inspectors
needed to inspect all trees. Each inspector at position i covers trees from (i-D) to (i+D).","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, d: int) -> bool {
    n >= 1 && n <= 20 && d >= 1 && d <= 20
}

spec fn coverage_range(position: int, d: int) -> (int, int) {
    (position - d, position + d)
}

spec fn trees_covered(n: int, d: int, inspectors: int) -> bool {
    inspectors >= 1 && inspectors <= n && inspectors == ((n - 1) / (2 * d + 1)) + 1
}",,"fn min_inspectors(n: i8, d: i8) -> (result: i8)
    requires valid_input(n as int, d as int)
    ensures trees_covered(n as int, d as int, result as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0526,verus,apps,apps_test_4299,,"Given a positive integer N (1 ≤ N ≤ 999), determine the pronunciation of the Japanese counter word ""本"" 
based on the ones digit of N. The pronunciation rules are: ""hon"" for ones digits 2,4,5,7,9; 
""pon"" for ones digits 0,1,6,8; and ""bon"" for ones digit 3.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int) -> bool {
    1 <= n <= 999
}

spec fn is_hon_digit(digit: int) -> bool {
    digit == 2 || digit == 4 || digit == 5 || digit == 7 || digit == 9
}

spec fn is_pon_digit(digit: int) -> bool {
    digit == 0 || digit == 1 || digit == 6 || digit == 8
}

spec fn is_bon_digit(digit: int) -> bool {
    digit == 3
}

spec fn correct_pronunciation(n: int) -> Seq<char> {
    let ones_digit = n % 10;
    if is_hon_digit(ones_digit) {
        seq!['h', 'o', 'n', '\n']
    } else if is_pon_digit(ones_digit) {
        seq!['p', 'o', 'n', '\n']
    } else {
        seq!['b', 'o', 'n', '\n']
    }
}",,"fn solve(n: i8) -> (result: Vec<char>)
    requires valid_input(n as int)
    ensures result@ == correct_pronunciation(n as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0527,verus,apps,apps_test_4301,,"Given a sequence of N integers, for each position i, find the maximum value 
among all N-1 elements excluding the element at position i.","use vstd::prelude::*;

verus! {
spec fn max_of_seq(s: Seq<int>) -> int
    recommends s.len() >= 1
{
    if s.len() == 1 {
        s[0]
    } else {
        if s[0] >= s[1] {
            s[0]
        } else {
            s[1]
        }
    }
}

spec fn max_excluding(s: Seq<int>, exclude_idx: int) -> int
    recommends 0 <= exclude_idx < s.len() && s.len() >= 2
{
    if exclude_idx == 0 {
        max_of_seq(s.subrange(1, s.len() as int))
    } else if exclude_idx == s.len() - 1 {
        max_of_seq(s.subrange(0, s.len() - 1))
    } else {
        max_of_seq(s.subrange(0, exclude_idx).add(s.subrange(exclude_idx + 1, s.len() as int)))
    }
}",,"fn solve(input: Vec<i8>) -> (result: Vec<i8>)
    requires input@.len() >= 2","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0528,verus,apps,apps_test_4304,,"Given uncovered heights of two adjacent towers after snowfall, find the snow depth.
Towers have triangular number heights: 1, 3, 6, 10, ... (i-th tower height = i*(i+1)/2).
Snow covers uniformly to same depth everywhere.","use vstd::prelude::*;

verus! {

spec fn valid_input(a: int, b: int) -> bool {
  a >= 1 && b > a && b < 499500
}

spec fn valid_snow_depth(a: int, b: int, depth: int) -> bool {
  depth >= 1 &&
  ((b - a) * (b - a) - (a + b)) >= 2 &&
  ((b - a) * (b - a) - (a + b)) % 2 == 0
}

spec fn snow_depth_formula(a: int, b: int) -> int
  recommends valid_input(a, b) && valid_snow_depth(a, b, ((b - a) * (b - a) - (a + b)) / 2)
{
  ((b - a) * (b - a) - (a + b)) / 2
}",,"fn solve(a: i8, b: i8) -> (result: i8)
  requires valid_input(a as int, b as int) && valid_snow_depth(a as int, b as int, ((b as int - a as int) * (b as int - a as int) - (a as int + b as int)) / 2)
  ensures result as int >= 1 && result as int == snow_depth_formula(a as int, b as int)","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0529,verus,apps,apps_test_4305,,"Given a monster with health H and attack damage A, find the minimum number of attacks needed to reduce the monster's health to 0 or below.","use vstd::prelude::*;

verus! {
spec fn valid_input(h: int, a: int) -> bool {
    h >= 1 && a >= 1
}

spec fn is_minimum_attacks(attacks: int, h: int, a: int) -> bool {
    attacks >= 1 &&
    attacks * a >= h &&
    (attacks - 1) * a < h
}

spec fn ceil_div(h: int, a: int) -> int
    recommends a > 0
{
    (h + a - 1) / a
}",,"fn solve(h: i8, a: i8) -> (attacks: i8)
    requires 
        valid_input(h as int, a as int)
    ensures 
        is_minimum_attacks(attacks as int, h as int, a as int),
        attacks as int == ceil_div(h as int, a as int)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0530,verus,apps,apps_test_4306,,"Given two time intervals [A, B) and [C, D), find the length of their intersection.
Alice holds a button from time A to time B (exclusive).
Bob holds a button from time C to time D (exclusive).
Calculate how many seconds both are holding their buttons simultaneously.","use vstd::prelude::*;

verus! {
spec fn valid_input(a: int, b: int, c: int, d: int) -> bool {
    0 <= a < b <= 100 && 0 <= c < d <= 100
}

spec fn min(x: int, y: int) -> int {
    if x < y { x } else { y }
}

spec fn max(x: int, y: int) -> int {
    if x > y { x } else { y }
}

spec fn interval_overlap_length(a: int, b: int, c: int, d: int) -> int {
    if min(b, d) - max(a, c) > 0 { min(b, d) - max(a, c) } else { 0 }
}",,"fn solve(a: i8, b: i8, c: i8, d: i8) -> (result: i8)
    requires
        valid_input(a as int, b as int, c as int, d as int),
    ensures
        result >= 0,
        result as int == interval_overlap_length(a as int, b as int, c as int, d as int),
        result <= 100,","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0532,verus,apps,apps_test_4308,,"Distribute N crackers to K users as evenly as possible and find the minimum 
possible absolute difference between the maximum and minimum number of crackers 
received by any user.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, k: int) -> bool {
    n >= 1 && k >= 1 && n <= 100 && k <= 100
}

spec fn min_cracker_difference(n: int, k: int) -> int
    recommends k > 0
{
    if n % k == 0 { 0 } else { 1 }
}",,"fn solve(n: i8, k: i8) -> (result: i8)
    requires 
        valid_input(n as int, k as int)
    ensures 
        result as int == min_cracker_difference(n as int, k as int),
        result as int == 0 <==> (n as int) % (k as int) == 0,
        result as int == 1 <==> (n as int) % (k as int) != 0","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0533,verus,apps,apps_test_4310,,"Given three tasks with integer values A1, A2, A3, find the minimum cost to complete all tasks.
Rules: Complete any one task first at cost 0, then completing task i followed by task j costs |Aj - Ai|.
All tasks must be completed.","use vstd::prelude::*;

verus! {
spec fn valid_input(a1: int, a2: int, a3: int) -> bool {
    1 <= a1 <= 100 && 1 <= a2 <= 100 && 1 <= a3 <= 100
}

spec fn max_of_three(a1: int, a2: int, a3: int) -> int {
    if a1 >= a2 && a1 >= a3 { a1 } else if a2 >= a3 { a2 } else { a3 }
}

spec fn min_of_three(a1: int, a2: int, a3: int) -> int {
    if a1 <= a2 && a1 <= a3 { a1 } else if a2 <= a3 { a2 } else { a3 }
}

spec fn minimum_cost(a1: int, a2: int, a3: int) -> int {
    max_of_three(a1, a2, a3) - min_of_three(a1, a2, a3)
}",,"fn solve(a1: i8, a2: i8, a3: i8) -> (result: i8)
    requires 
        valid_input(a1 as int, a2 as int, a3 as int)
    ensures 
        result as int >= 0,
        result as int == minimum_cost(a1 as int, a2 as int, a3 as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0534,verus,apps,apps_test_4312,,"Two monsters battle in turns. Takahashi's monster (health A, strength B) attacks first,
then they alternate. Each attack reduces opponent's health by attacker's strength.
First monster to reach 0 or below health loses. Determine if Takahashi wins.","use vstd::prelude::*;

verus! {
spec fn valid_input(a: int, b: int, c: int, d: int) -> bool {
    1 <= a <= 100 && 1 <= b <= 100 && 1 <= c <= 100 && 1 <= d <= 100
}

spec fn turns_to_defeat(health: int, strength: int) -> int
    recommends strength > 0
{
    (health + strength - 1) / strength
}

spec fn takahashi_wins(a: int, b: int, c: int, d: int) -> bool
    recommends valid_input(a, b, c, d)
{
    let takahashi_turns = turns_to_defeat(c, b);
    let aoki_turns = turns_to_defeat(a, d);
    aoki_turns >= takahashi_turns
}",,"fn solve(a: i8, b: i8, c: i8, d: i8) -> (result: String)
    requires valid_input(a as int, b as int, c as int, d as int)
    ensures result@ == (if takahashi_wins(a as int, b as int, c as int, d as int) { ""Yes""@ } else { ""No""@ })","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0535,verus,apps,apps_test_4313,,"Given N gems with values and costs, select a subset to maximize total profit
(sum of selected values minus sum of selected costs). Only gems with positive
profit should be selected to achieve maximum profit.","use vstd::prelude::*;

verus! {

spec fn sum_of_positive_profits(values: Seq<int>, costs: Seq<int>, n: int) -> int
    decreases n
    when n >= 0 && values.len() >= n && costs.len() >= n
{
    if n == 0 { 
        0 as int
    } else { 
        let profit = values[n-1] - costs[n-1];
        sum_of_positive_profits(values, costs, n-1) + (if profit > 0 { profit } else { 0 as int })
    }
}

spec fn valid_input(n: int, values: Seq<int>, costs: Seq<int>) -> bool
{
    values.len() == n && costs.len() == n && n >= 0
}",,"fn solve(n: i8, values: Vec<i8>, costs: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, values@.map(|i, x| x as int), costs@.map(|i, x| x as int))
    ensures 
        result >= 0 &&
        result as int == sum_of_positive_profits(values@.map(|i, x| x as int), costs@.map(|i, x| x as int), n as int)","{
    assume(false);
    0
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0536,verus,apps,apps_test_4317,,"Given two integers A and B, find the maximum value among A + B, A - B, and A × B.
Input constraints: -100 ≤ A, B ≤ 100","use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() >= 3 &&
    exists|space_pos: int| 0 < space_pos < input.len() - 1 && input[space_pos] == ' ' &&
    (forall|i: int| 0 <= i < space_pos ==> input[i] != ' ') &&
    (forall|i: int| space_pos + 1 <= i < input.len() ==> input[i] != ' ' || input[i] == '\n') &&
    is_valid_integer(get_a_string(input)) && is_valid_integer(get_b_string(input)) &&
    -100 <= get_a(input) <= 100 && -100 <= get_b(input) <= 100
}

spec fn get_a(input: Seq<char>) -> int {
    if input.len() > 0 && input[input.len() as int - 1] == '\n' {
        let trimmed = input.subrange(0, input.len() as int - 1);
        let space_index = find_space(trimmed);
        parse_int(trimmed.subrange(0, space_index))
    } else {
        let space_index = find_space(input);
        parse_int(input.subrange(0, space_index))
    }
}

spec fn get_b(input: Seq<char>) -> int {
    if input.len() > 0 && input[input.len() as int - 1] == '\n' {
        let trimmed = input.subrange(0, input.len() as int - 1);
        let space_index = find_space(trimmed);
        parse_int(trimmed.subrange(space_index + 1, trimmed.len() as int))
    } else {
        let space_index = find_space(input);
        parse_int(input.subrange(space_index + 1, input.len() as int))
    }
}

spec fn get_a_string(input: Seq<char>) -> Seq<char> {
    if input.len() > 0 && input[input.len() as int - 1] == '\n' {
        let trimmed = input.subrange(0, input.len() as int - 1);
        let space_index = find_space(trimmed);
        trimmed.subrange(0, space_index)
    } else {
        let space_index = find_space(input);
        input.subrange(0, space_index)
    }
}

spec fn get_b_string(input: Seq<char>) -> Seq<char> {
    if input.len() > 0 && input[input.len() as int - 1] == '\n' {
        let trimmed = input.subrange(0, input.len() as int - 1);
        let space_index = find_space(trimmed);
        trimmed.subrange(space_index + 1, trimmed.len() as int)
    } else {
        let space_index = find_space(input);
        input.subrange(space_index + 1, input.len() as int)
    }
}

spec fn max3(a: int, b: int, c: int) -> int {
    if a >= b && a >= c {
        a
    } else if b >= c {
        b
    } else {
        c
    }
}

spec fn find_space(s: Seq<char>) -> int {
    0  /* placeholder for finding space position */
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    true  /* placeholder for integer validation */
}

spec fn parse_int(s: Seq<char>) -> int {
    0  /* placeholder for parsing integer */
}

spec fn int_to_string(i: int) -> Seq<char> {
    seq!['0']  /* placeholder for integer to string conversion */
}",,"fn solve(input: Vec<u8>) -> (result: Vec<u8>)
    requires valid_input(input@.map_values(|b: u8| b as char))
    ensures result@.map_values(|b: u8| b as char) == int_to_string(max3(get_a(input@.map_values(|b: u8| b as char)) + get_b(input@.map_values(|b: u8| b as char)), get_a(input@.map_values(|b: u8| b as char)) - get_b(input@.map_values(|b: u8| b as char)), get_a(input@.map_values(|b: u8| b as char)) * get_b(input@.map_values(|b: u8| b as char))))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0537,verus,apps,apps_test_4318,,"Given N mountains indexed from west to east with heights, count how many mountain inns 
allow ocean visibility. Mountain 1 (westmost) always has visibility. Mountain i (i ≥ 2) 
has visibility if and only if its height is greater than or equal to the maximum height 
of all mountains to its west.","use vstd::prelude::*;

verus! {

spec fn max_height_up_to(heights: Seq<int>, up_to_index: int) -> int
    decreases up_to_index
{
    if 0 <= up_to_index < heights.len() {
        if up_to_index == 0 {
            heights[0]
        } else if heights[up_to_index] >= max_height_up_to(heights, up_to_index - 1) {
            heights[up_to_index]
        } else {
            max_height_up_to(heights, up_to_index - 1)
        }
    } else {
        0
    }
}

spec fn has_ocean_visibility(heights: Seq<int>, mountain_index: int) -> bool {
    if 0 <= mountain_index < heights.len() {
        mountain_index == 0 || heights[mountain_index] >= max_height_up_to(heights, mountain_index - 1)
    } else {
        false
    }
}

spec fn count_visible_mountains(heights: Seq<int>, n: int) -> int
    decreases n
{
    if n <= 0 {
        0
    } else if has_ocean_visibility(heights, n - 1) {
        1 + count_visible_mountains(heights, n - 1)
    } else {
        count_visible_mountains(heights, n - 1)
    }
}",,"fn solve(n: u32, heights: Vec<i32>) -> (result: u32)
    requires 
        n > 0,
        heights.len() == n,
        n <= 20,
        forall|i: int| 0 <= i < heights.len() ==> 1 <= #[trigger] heights[i] as int <= 100,
    ensures 
        1 <= result <= n,
        result as int == count_visible_mountains(heights@.map(|_i: int, x: i32| x as int), n as int),","{
    assume(false);
    0
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0538,verus,apps,apps_test_4326,,"Given N students, divide them into groups such that the number of groups 
containing 3 or more students is maximized. Groups with 2 or fewer students 
are not counted toward the result.","use vstd::prelude::*;

verus! {

    spec fn valid_input(n: int) -> bool {
        1 <= n <= 1000
    }
    
    spec fn max_groups_with_at_least_three(n: int) -> int
        recommends valid_input(n)
    {
        n / 3
    }
    
    spec fn valid_solution(n: int, result: int) -> bool
        recommends valid_input(n)
    {
        result == max_groups_with_at_least_three(n) &&
        result >= 0 &&
        result <= n
    }

    fn solve_groups(n: i8) -> (result: i8)
        requires valid_input(n as int)
        ensures valid_solution(n as int, result as int)",,,"{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0539,verus,apps,apps_test_4327,,"Given A whole apples and P apple pieces, determine the maximum number of apple pies that can be made.
Each whole apple can be cut into 3 pieces, and each apple pie requires 2 pieces to make.","use vstd::prelude::*;

verus! {

spec fn valid_input(a: int, p: int) -> bool {
    0 <= a <= 100 && 0 <= p <= 100
}

spec fn total_pieces(a: int, p: int) -> int
    recommends valid_input(a, p)
{
    a * 3 + p
}

spec fn max_pies(a: int, p: int) -> int
    recommends valid_input(a, p)
{
    total_pieces(a, p) / 2
}",,"fn calculate_max_pies(a: i8, p: i8) -> (pies: i8)
    requires 
        valid_input(a as int, p as int)
    ensures 
        pies as int == max_pies(a as int, p as int) &&
        pies >= 0 &&
        pies as int == (a as int * 3 + p as int) / 2","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0540,verus,apps,apps_test_4331,,"Given a three-digit integer N, determine if it contains the digit 7.
Return ""Yes"" if N contains the digit 7, ""No"" otherwise.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int) -> bool {
    100 <= n <= 999
}

spec fn contains_seven(n: int) -> bool
    recommends valid_input(n)
{
    (n % 10) == 7 || ((n / 10) % 10) == 7 || (n / 100) == 7
}

spec fn valid_output(result: Seq<char>) -> bool {
    result == ""Yes\n""@ || result == ""No\n""@
}",,"fn solve(n: i8) -> (result: Vec<char>)
    requires valid_input(n as int)
    ensures 
        valid_output(result@) &&
        ((result@ == ""Yes\n""@) <==> contains_seven(n as int))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0541,verus,apps,apps_test_4332,,"Given an integer N, determine if the sum of its digits divides N evenly.
Let S(N) be the sum of all digits in the decimal representation of N.
Check if N is divisible by S(N).
Input: A single integer N (1 ≤ N ≤ 10^9)
Output: ""Yes"" if S(N) divides N, ""No"" otherwise","use vstd::prelude::*;

verus! {
spec fn is_digit(c: char) -> bool {
    '0' <= c && c <= '9'
}

spec fn digit_value(c: char) -> int
    recommends is_digit(c)
{
    c as int - '0' as int
}

spec fn sum_of_digits(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if is_digit(s[0]) {
        digit_value(s[0]) + sum_of_digits(s.subrange(1, s.len() as int))
    } else {
        sum_of_digits(s.subrange(1, s.len() as int))
    }
}

spec fn string_to_int(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if is_digit(s[0]) {
        string_to_int(s.subrange(1, s.len() as int)) + digit_value(s[0]) * power_10((s.len() - 1) as int)
    } else {
        string_to_int(s.subrange(1, s.len() as int))
    }
}

spec fn power_10(n: int) -> int
    decreases n when n >= 0
{
    if n <= 0 { 1 } else { 10 * power_10(n - 1) }
}

spec fn clean_input(input: Seq<char>) -> Seq<char>
    decreases input.len()
{
    if input.len() == 0 {
        seq![]
    } else if input[input.len() - 1] == '\n' || input[input.len() - 1] == ' ' {
        clean_input(input.subrange(0, input.len() - 1))
    } else {
        input
    }
}

spec fn valid_positive_integer_string(s: Seq<char>) -> bool {
    s.len() > 0 && 
    (forall|i: int| #![auto] 0 <= i < s.len() ==> is_digit(s[i])) && 
    (s.len() > 1 ==> s[0] != '0') && 
    string_to_int(s) > 0
}

spec fn valid_input(input: Seq<char>) -> bool {
    valid_positive_integer_string(clean_input(input))
}",,"fn solve(input: &str) -> (result: String)
    requires valid_input(input@)
    ensures result@ == seq!['Y', 'e', 's'] || result@ == seq!['N', 'o']","{
    assume(false);
    ""No"".to_string()
}","
}

fn main() {}",0,,-1,-1,-1,DupVA04,0.85
VA0542,verus,apps,apps_test_4333,,"Given two adjacent vertices of a square in counter-clockwise order, find the coordinates of the remaining two vertices.
The input consists of four integers representing coordinates (x1,y1) and (x2,y2) of two adjacent vertices.
The output should be four integers representing coordinates (x3,y3) and (x4,y4) of the remaining vertices in counter-clockwise order.","use vstd::prelude::*;

verus! {
spec fn valid_input(x1: int, y1: int, x2: int, y2: int) -> bool {
    (x1, y1) != (x2, y2) &&
    -100 <= x1 <= 100 && -100 <= y1 <= 100 &&
    -100 <= x2 <= 100 && -100 <= y2 <= 100
}

spec fn compute_third_vertex(x1: int, y1: int, x2: int, y2: int) -> (int, int) {
    (x2 - (y2 - y1), y2 + (x2 - x1))
}

spec fn compute_fourth_vertex(x1: int, y1: int, x2: int, y2: int) -> (int, int) {
    (x1 - (y2 - y1), y1 + (x2 - x1))
}

spec fn valid_output(x1: int, y1: int, x2: int, y2: int, result: Seq<int>) -> bool {
    result.len() == 4 &&
    result[0] == compute_third_vertex(x1, y1, x2, y2).0 &&
    result[1] == compute_third_vertex(x1, y1, x2, y2).1 &&
    result[2] == compute_fourth_vertex(x1, y1, x2, y2).0 &&
    result[3] == compute_fourth_vertex(x1, y1, x2, y2).1
}",,"fn solve(x1: i8, y1: i8, x2: i8, y2: i8) -> (result: Vec<i8>)
    requires valid_input(x1 as int, y1 as int, x2 as int, y2 as int)
    ensures valid_output(x1 as int, y1 as int, x2 as int, y2 as int, result@.map(|i, v: i8| v as int))","{
    assume(false);
    Vec::new()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0545,verus,apps,apps_test_4340,,Transform an array of integers where odd numbers remain unchanged and even numbers are decremented by 1.,"use vstd::prelude::*;

verus! {
spec fn transform_element(x: int) -> int {
    if x % 2 == 0 { x - 1 } else { x }
}

spec fn valid_transformation(input: Seq<int>, output: Seq<int>) -> bool {
    output.len() == input.len() &&
    forall|i: int| 0 <= i < input.len() ==> output[i] == transform_element(input[i])
}",,"fn solve(a: Vec<i8>) -> (result: Vec<i8>)
    ensures valid_transformation(a@.map(|_i, x| x as int), result@.map(|_i, x| x as int))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0546,verus,apps,apps_test_4343,,"Given two strings s and t of length k consisting of lowercase Latin letters,
where s is lexicographically less than t, find the median string in the
lexicographically ordered list of all strings of length k that are
lexicographically between s and t (inclusive).","use vstd::prelude::*;

verus! {

spec fn median_string(s: Seq<char>, t: Seq<char>, k: int) -> Seq<char> {
    let s_val = string_to_base26(s);
    let t_val = string_to_base26(t);
    let median_val = (s_val + t_val) / 2;
    base26_to_string(median_val, k)
}

spec fn string_to_base26(s: Seq<char>) -> nat
    decreases s.len()
{
    if s.len() == 0 { 0 }
    else { ((s[0] as int - 'a' as int) * pow26((s.len() - 1) as nat) + string_to_base26(s.subrange(1, s.len() as int))) as nat }
}

spec fn base26_to_string(val: nat, k: int) -> Seq<char>
    decreases k when k >= 1
{
    if k == 1 { seq![((val % 26) + ('a' as int)) as char] }
    else { base26_to_string(val / 26, k - 1).add(seq![((val % 26) + ('a' as int)) as char]) }
}

spec fn pow26(n: nat) -> nat
    decreases n
{
    if n == 0 { 1 } else { 26 * pow26((n - 1) as nat) }
}",,"fn solve(k: usize, s: Vec<char>, t: Vec<char>) -> (result: Vec<char>)
    requires 
        k >= 1,
        s.len() == k,
        t.len() == k,
        forall|i: int| 0 <= i < k ==> 'a' <= #[trigger] s[i] <= 'z',
        forall|i: int| 0 <= i < k ==> 'a' <= #[trigger] t[i] <= 'z',
    ensures 
        result.len() == k,
        forall|i: int| 0 <= i < k ==> 'a' <= #[trigger] result[i] <= 'z',
        result@ == median_string(s@, t@, k as int),","{
    // impl-start
    assume(false);
    Vec::new()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0548,verus,apps,apps_test_4347,,"Given n people where n is even, find the number of ways to divide them into exactly two 
indistinguishable round dances, each containing exactly n/2 people. A round dance is a 
circular arrangement where rotations are considered identical, and both the rotations 
within each dance and the two dances themselves are indistinguishable.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int) -> bool {
    n >= 2 && n % 2 == 0 && n <= 20
}

spec fn factorial(n: int) -> int
    decreases n
{
    if n <= 1 { 1 } else { n * factorial(n - 1) }
}

spec fn expected_result(n: int) -> int {
    if valid_input(n) {
        let half = n / 2;
        let fact_n = factorial(n);
        let fact_half = factorial(half);
        let fact_half_minus_1 = factorial(half - 1);
        let binomial = fact_n / (fact_half * fact_half);
        let arrangements = fact_half_minus_1 * fact_half_minus_1;
        (binomial * arrangements) / 2
    } else {
        0
    }
}",,"fn solve(n: i8) -> (result: i8)
    requires valid_input(n as int)
    ensures result as int == expected_result(n as int) && result > 0","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0549,verus,apps,apps_test_4351,,"Given a three-digit positive integer N (100 ≤ N ≤ 999), determine if it is palindromic
(reads the same forwards and backwards in decimal notation).","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int) -> bool {
  100 <= n <= 999
}

spec fn is_palindromic(n: int) -> bool
  recommends valid_input(n)
{
  let hundreds = n / 100;
  let units = n % 10;
  hundreds == units
}",,"fn solve(stdin_input: &str) -> (result: String)
  requires stdin_input@.len() > 0","{
  // impl-start
  assume(false);
  """".to_string()
  // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0550,verus,apps,apps_test_4353,,"Given a string containing comma-separated words, replace all commas with spaces.
The input string has length 19 with format: 5 lowercase letters, comma, 7 lowercase letters, comma, 5 lowercase letters.","use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>) -> bool {
  s.len() == 19 && 
  s.len() >= 2 && s[5] == ',' && s[13] == ',' &&
  forall|i: int| 0 <= i < s.len() ==> (s[i] == ',' || ('a' <= s[i] <= 'z'))
}

spec fn commas_to_spaces(s: Seq<char>) -> Seq<char>
  recommends valid_input(s)
{
  Seq::new(s.len(), |i: int| { if s[i] == ',' { ' ' } else { s[i] } })
}

spec fn correct_output(s: Seq<char>, result: Seq<char>) -> bool
  recommends valid_input(s)
{
  result.len() == s.len() + 1 &&
  result[result.len() - 1] == '\n' &&
  forall|i: int| 0 <= i < s.len() ==> 
    (s[i] == ',' ==> result[i] == ' ') &&
    (s[i] != ',' ==> result[i] == s[i])
}",,"fn solve(s: Vec<char>) -> (result: Vec<char>)
  requires valid_input(s@)
  ensures correct_output(s@, result@)","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0551,verus,apps,apps_test_4362,,"Given a single English letter (either uppercase A-Z or lowercase a-z), 
output ""A"" if the input letter is uppercase, or ""a"" if the input letter is lowercase.","use vstd::prelude::*;

verus! {
spec fn is_lowercase_letter(c: char) -> bool {
    'a' <= c && c <= 'z'
}

spec fn all_lowercase(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> is_lowercase_letter(s[i])
}

spec fn valid_output(result: Seq<char>) -> bool {
    result =~= seq!['A'] || result =~= seq!['a']
}",,"fn solve(input: Vec<char>) -> (result: Vec<char>)
    ensures 
        valid_output(result@) &&
        (all_lowercase(input@) ==> result@ =~= seq!['a']) &&
        ((input@.len() == 0 || !all_lowercase(input@)) ==> result@ =~= seq!['A'])","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0552,verus,apps,apps_test_4363,,"Given two integers K and S, count the number of ordered triples (X, Y, Z) where
each of X, Y, Z is an integer in the range [0, K] and X + Y + Z = S.","use vstd::prelude::*;

verus! {

spec fn valid_input(k: int, s: int) -> bool {
    k >= 0 && s >= 0 && s <= 3 * k
}

spec fn is_valid_triple(k: int, s: int, x: int, y: int, z: int) -> bool {
    0 <= x <= k && 0 <= y <= k && 0 <= z <= k && x + y + z == s
}

spec fn count_valid_triples(k: int, s: int) -> int
    recommends k >= 0
{
    count_valid_triples_helper(k, s, 0)
}

spec fn count_valid_triples_helper(k: int, s: int, z: int) -> int
    recommends k >= 0, z >= 0
    decreases if k >= z { k + 1 - z } else { 0 }
{
    if z > k { 0 }
    else { count_valid_triples_for_z(k, s, z) + count_valid_triples_helper(k, s, z + 1) }
}

spec fn count_valid_triples_for_z(k: int, s: int, z: int) -> int
    recommends k >= 0, z >= 0
{
    count_valid_triples_for_z_helper(k, s, z, 0)
}

spec fn count_valid_triples_for_z_helper(k: int, s: int, z: int, y: int) -> int
    recommends k >= 0, z >= 0, y >= 0
    decreases if k >= y { k + 1 - y } else { 0 }
{
    if y > k { 0 }
    else { 
        let x = s - y - z;
        let this_count: int = if 0 <= x <= k { 1 } else { 0 };
        this_count + count_valid_triples_for_z_helper(k, s, z, y + 1)
    }
}",,"fn count_triples(k: i8, s: i8) -> (count: i8)
    requires
        valid_input(k as int, s as int),
    ensures
        count as int == count_valid_triples(k as int, s as int),
        count >= 0,","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVA00,0.85
VA0554,verus,apps,apps_test_4365,,"Given an integer K (2 ≤ K ≤ 100), count the number of ways to choose one even number and one odd number from the integers 1 through K (inclusive). Order of selection does not matter.","use vstd::prelude::*;

verus! {

spec fn valid_input(k: int) -> bool {
    2 <= k <= 100
}

spec fn count_odd_numbers(k: int) -> int
    recommends k >= 1
{
    (k + 1) / 2
}

spec fn count_even_numbers(k: int) -> int
    recommends k >= 1
{
    k / 2
}

spec fn expected_result(k: int) -> int
    recommends valid_input(k)
{
    count_odd_numbers(k) * count_even_numbers(k)
}

spec fn correct_result(k: int, result: int) -> bool
    recommends valid_input(k)
{
    result == expected_result(k)
}",,"fn count_even_odd_pairs(k: i8) -> (result: i8)
    requires
        valid_input(k as int),
    ensures
        correct_result(k as int, result as int),
        result >= 0,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0555,verus,apps,apps_test_4366,,"Given current time A (0-23) and hours B until contest begins (0-23), 
determine the contest start time in 24-hour format using modular arithmetic.","use vstd::prelude::*;

verus! {
spec fn int_to_string(n: int) -> Seq<char> {
    if n == 0 { seq!['0'] }
    else if n == 1 { seq!['1'] }
    else if n == 2 { seq!['2'] }
    else if n == 3 { seq!['3'] }
    else if n == 4 { seq!['4'] }
    else if n == 5 { seq!['5'] }
    else if n == 6 { seq!['6'] }
    else if n == 7 { seq!['7'] }
    else if n == 8 { seq!['8'] }
    else if n == 9 { seq!['9'] }
    else if n == 10 { seq!['1', '0'] }
    else if n == 11 { seq!['1', '1'] }
    else if n == 12 { seq!['1', '2'] }
    else if n == 13 { seq!['1', '3'] }
    else if n == 14 { seq!['1', '4'] }
    else if n == 15 { seq!['1', '5'] }
    else if n == 16 { seq!['1', '6'] }
    else if n == 17 { seq!['1', '7'] }
    else if n == 18 { seq!['1', '8'] }
    else if n == 19 { seq!['1', '9'] }
    else if n == 20 { seq!['2', '0'] }
    else if n == 21 { seq!['2', '1'] }
    else if n == 22 { seq!['2', '2'] }
    else if n == 23 { seq!['2', '3'] }
    else { seq!['0'] }
}

spec fn valid_input(input: Seq<char>) -> bool {
    exists|a: int, b: int| 0 <= a <= 23 && 0 <= b <= 23 && 
    (input == int_to_string(a) + seq![' '] + int_to_string(b) + seq!['\n'] ||
     input == int_to_string(a) + seq![' '] + int_to_string(b))
}

spec fn contest_start_time(a: int, b: int) -> int {
    (a + b) % 24
}

spec fn correct_output(input: Seq<char>, result: Seq<char>) -> bool {
    valid_input(input) ==> 
    exists|a: int, b: int| 0 <= a <= 23 && 0 <= b <= 23 && 
    (input == int_to_string(a) + seq![' '] + int_to_string(b) + seq!['\n'] ||
     input == int_to_string(a) + seq![' '] + int_to_string(b)) &&
    result == int_to_string(contest_start_time(a, b)) + seq!['\n']
}",,"fn solve(input: String) -> (result: String)
    ensures correct_output(input@, result@)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0556,verus,apps,apps_test_4370,,"Given a circular cake divided into 16 equal pieces, determine if two people can take A and B pieces 
respectively such that neither person takes two adjacent pieces. The maximum number of non-adjacent 
pieces any person can take from 16 pieces arranged in a circle is 8.","use vstd::prelude::*;

verus! {
spec fn valid_input(a: int, b: int) -> bool {
    1 <= a <= 16 && 1 <= b <= 16 && a + b <= 16
}

spec fn can_take_non_adjacent(pieces: int, total: int) -> bool {
    pieces <= total / 2
}

spec fn both_can_take(a: int, b: int) -> bool {
    can_take_non_adjacent(a, 16) && can_take_non_adjacent(b, 16)
}",,"fn solve_cake_problem(a: i8, b: i8) -> (result: &'static str)
    requires 
        valid_input(a as int, b as int),
    ensures 
        both_can_take(a as int, b as int) <==> (result == ""Yay!""),
        (!both_can_take(a as int, b as int)) <==> (result == "":(""),
        (result == ""Yay!"") || (result == "":(""),","{
    assume(false);
    """"
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0557,verus,apps,apps_test_4371,,"Given a string S of digits (1-9), find the minimum absolute difference between 753 and any 3-digit number formed by taking three consecutive digits from S.","use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>) -> bool {
    s.len() >= 3 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s.index(i) >= '1' && #[trigger] s.index(i) <= '9'
}

spec fn string_to_int(s: Seq<char>) -> int {
    100 * ((s.index(0) as int) - ('0' as int)) + 
    10 * ((s.index(1) as int) - ('0' as int)) + 
    ((s.index(2) as int) - ('0' as int))
}

spec fn abs_diff(x: int) -> int {
    if x >= 0 { x } else { -x }
}

spec fn substring_at_index(s: Seq<char>, i: int) -> Seq<char> {
    s.subrange(i, i + 3)
}

spec fn is_minimum_difference(s: Seq<char>, result: int) -> bool {
    valid_input(s) ==> (
        result >= 0 &&
        (exists|i: int| 0 <= i <= s.len() - 3 && result == abs_diff(753 - string_to_int(#[trigger] substring_at_index(s, i)))) &&
        (forall|i: int| 0 <= i <= s.len() - 3 ==> result <= abs_diff(753 - string_to_int(#[trigger] substring_at_index(s, i))))
    )
}",,"fn solve(s: Vec<char>) -> (result: i32)
    requires valid_input(s@)
    ensures is_minimum_difference(s@, result as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0558,verus,apps,apps_test_4380,,"Given two integers A and B (each between 1 and 3 inclusive), determine if there exists 
an integer C (also between 1 and 3 inclusive) such that the product A × B × C is odd.","use vstd::prelude::*;

verus! {
spec fn valid_input(a: int, b: int) -> bool {
    1 <= a <= 3 && 1 <= b <= 3
}

spec fn is_odd(n: int) -> bool {
    n % 2 == 1
}

spec fn exists_odd_product(a: int, b: int) -> bool {
    valid_input(a, b) ==> exists|c: int| 1 <= c <= 3 && #[trigger] is_odd(a * b * c)
}

spec fn should_answer_yes(a: int, b: int) -> bool {
    valid_input(a, b) ==> (a != 2 && b != 2)
}",,"fn solve(a: i8, b: i8) -> (result: Seq<char>)
  requires valid_input(a as int, b as int)
  ensures result == (if should_answer_yes(a as int, b as int) { ""Yes""@ } else { ""No""@ })","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0559,verus,apps,apps_test_4381,,"Calculate the total cost to travel from Station A to Station C using a special discount ticket.
Given train fare X yen (A to B) and bus fare Y yen (B to C), if you take the train first then the bus,
the bus fare becomes half price. Find the total cost A to C.","use vstd::prelude::*;

verus! {

spec fn valid_input(train_fare: int, bus_fare: int) -> bool {
    1 <= train_fare <= 100 && 1 <= bus_fare <= 100 && bus_fare % 2 == 0
}

spec fn total_cost(train_fare: int, bus_fare: int) -> int
    recommends valid_input(train_fare, bus_fare)
{
    train_fare + bus_fare / 2
}",,"fn solve(train_fare: i8, bus_fare: i8) -> (result: i8)
    requires valid_input(train_fare as int, bus_fare as int)
    ensures result as int == total_cost(train_fare as int, bus_fare as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0561,verus,apps,apps_test_4384,,"Given an integer N (1 ≤ N ≤ 1998), determine the first three characters of the N-th AtCoder Beginner Contest label.
Contest labeling system: Rounds 1-999 use ""ABC"", rounds 1000-1998 use ""ABD"".","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int) -> bool {
    1 <= n <= 1998
}

spec fn expected_result(n: int) -> Seq<char> {
    if n < 1000 { seq!['A', 'B', 'C'] } else { seq!['A', 'B', 'D'] }
}",,"fn solve(n: i32) -> (result: Vec<char>)
    requires valid_input(n as int)
    ensures result@ == expected_result(n as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0563,verus,apps,apps_test_4386,,"Given an integer a and a string s of lowercase English letters, 
output s if a >= 3200, otherwise output ""red"".","use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 &&
    (exists|i: int| 0 < i < input.len() && input[i] == '\n') &&
    (forall|i: int| #![trigger input[i]] 0 <= i < input.len() ==> input[i] == '\n' || ('0' <= input[i] <= '9') || ('a' <= input[i] <= 'z')) &&
    (exists|i: int| 0 < i < input.len() && input[i] == '\n' && (forall|j: int| #![trigger input[j]] 0 <= j < i ==> '0' <= input[j] <= '9'))
}

spec fn valid_parsed_input(a: int, s: Seq<char>) -> bool {
    2800 <= a < 5000 &&
    1 <= s.len() <= 10 &&
    (forall|j: int| #![trigger s[j]] 0 <= j < s.len() ==> 'a' <= s[j] <= 'z')
}

spec fn correct_output(a: int, s: Seq<char>, result: Seq<char>) -> bool {
    (a >= 3200 ==> result == s + seq!['\n']) &&
    (a < 3200 ==> result == seq!['r', 'e', 'd', '\n'])
}

spec fn parse_input(input: Seq<char>) -> (int, Seq<char>) {
    (0, seq!['a'])
}",,"fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires 
        valid_input(input@)
    ensures 
        result@.len() > 0,
        result@[result@.len() - 1] == '\n'","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0564,verus,apps,apps_test_4387,,"Given a contestant's rating R, determine which contest they are eligible for:
ABC for ratings less than 1200, ARC for ratings from 1200 to less than 2800,
and AGC for ratings 2800 and above.","use vstd::prelude::*;

verus! {
spec fn valid_rating(r: int) -> bool {
    0 <= r <= 4208
}

spec fn contest_for_rating(r: int) -> Seq<char> {
    if r < 1200 {
        seq!['A', 'B', 'C', '\n']
    } else if r < 2800 {
        seq!['A', 'R', 'C', '\n']
    } else {
        seq!['A', 'G', 'C', '\n']
    }
}",,"fn solve(r: i8) -> (result: Vec<char>)
    requires 
        valid_rating(r as int)
    ensures 
        result@ == contest_for_rating(r as int),
        r < 1200 ==> result@ == seq!['A', 'B', 'C', '\n'],
        1200 <= r < 2800 ==> result@ == seq!['A', 'R', 'C', '\n'],
        r >= 2800 ==> result@ == seq!['A', 'G', 'C', '\n']","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0565,verus,apps,apps_test_4388,,"Given a three-digit string containing only digits '1' and '9', swap each '1' with '9' 
and each '9' with '1', then return the transformed string with a newline appended.","use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    input.len() >= 3 &&
    forall|i: int| 0 <= i < 3 ==> (input[i] == '1' || input[i] == '9')
}

spec fn swap_digit(c: char) -> char {
    if c == '1' { '9' } else { '1' }
}

spec fn transform_string(s: Seq<char>) -> Seq<char> {
    seq![swap_digit(s[0]), swap_digit(s[1]), swap_digit(s[2])]
}

spec fn valid_output(input: Seq<char>, result: Seq<char>) -> bool {
    result.len() == 4 &&
    result[3] == '\n' &&
    forall|i: int| 0 <= i < 3 ==> 
        (input[i] == '1' ==> result[i] == '9') && 
        (input[i] == '9' ==> result[i] == '1')
}",,"fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(input@)
    ensures valid_output(input@, result@)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0566,verus,apps,apps_test_4390,,"Given two positive integers a and b, find the minimum number of increments needed 
to make a divisible by b. In each move, you can increase a by 1.","use vstd::prelude::*;

verus! {
spec fn valid_input(test_cases: Seq<(int, int)>) -> bool {
    forall|i: int| 0 <= i < test_cases.len() ==> 
        test_cases[i].0 > 0 && test_cases[i].1 > 0
}

spec fn min_moves_to_divisible(a: int, b: int) -> int
    recommends a > 0 && b > 0
{
    (b - a % b) % b
}

spec fn valid_output(test_cases: Seq<(int, int)>, results: Seq<int>) -> bool
    recommends valid_input(test_cases)
{
    results.len() == test_cases.len() &&
    forall|i: int| 0 <= i < results.len() ==> 
        results[i] == min_moves_to_divisible(test_cases[i].0, test_cases[i].1) &&
        results[i] >= 0
}",,"fn solve(test_cases: Vec<(i8, i8)>) -> (results: Vec<i8>)
    requires valid_input(test_cases@.map(|i, pair: (i8, i8)| (pair.0 as int, pair.1 as int)))
    ensures valid_output(test_cases@.map(|i, pair: (i8, i8)| (pair.0 as int, pair.1 as int)), results@.map(|i, x: i8| x as int))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0567,verus,apps,apps_test_4392,,"Given an array and a set of allowed swap positions, determine if the array can be sorted 
in non-decreasing order using only adjacent swaps at the allowed positions. An allowed swap
exchanges elements at positions i and i+1 if position i is in the allowed set.","use vstd::prelude::*;

verus! {

spec fn valid_input(a: Seq<int>, allowed_pos: Seq<bool>) -> bool {
    a.len() > 1 && allowed_pos.len() == a.len()
}

spec fn is_sorted(a: Seq<int>) -> bool
    decreases a.len()
{
    if a.len() <= 1 {
        true
    } else {
        a[0] <= a[1] && is_sorted(a.subrange(1, a.len() as int))
    }
}

spec fn can_reach_configuration(original: Seq<int>, target: Seq<int>, allowed: Seq<bool>) -> bool {
    original.len() == target.len() && target.len() == allowed.len() &&
    original.to_multiset() == target.to_multiset()
}

spec fn sort_sequence(s: Seq<int>) -> Seq<int>
    decreases s.len()
{
    if s.len() <= 1 {
        s
    } else {
        bubble_sort_seq(s)
    }
}

spec fn bubble_sort_seq(s: Seq<int>) -> Seq<int>
    decreases s.len()
{
    if s.len() <= 1 {
        s
    } else {
        bubble_sort_helper(s, s.len() as nat)
    }
}

spec fn bubble_sort_helper(s: Seq<int>, passes: nat) -> Seq<int>
    decreases passes
{
    if passes == 0 {
        s
    } else {
        bubble_sort_helper(bubble_pass(s), (passes - 1) as nat)
    }
}

spec fn bubble_pass(s: Seq<int>) -> Seq<int>
    decreases s.len()
{
    if s.len() <= 1 {
        s
    } else {
        bubble_pass_helper(s, 0)
    }
}

spec fn bubble_pass_helper(s: Seq<int>, pos: nat) -> Seq<int>
    decreases if pos <= s.len() { s.len() - pos } else { 0 }
{
    if pos >= s.len() || pos >= s.len() - 1 {
        s
    } else if s[pos as int] > s[(pos + 1) as int] {
        bubble_pass_helper(s.update(pos as int, s[(pos + 1) as int]).update((pos + 1) as int, s[pos as int]), pos + 1)
    } else {
        bubble_pass_helper(s, pos + 1)
    }
}",,"fn can_sort(a: &mut Vec<i8>, allowed_pos: &[bool]) -> (result: bool)
    requires 
        valid_input(old(a)@.map_values(|x: i8| x as int), allowed_pos@),
    ensures 
        a@.map_values(|x: i8| x as int).to_multiset() == old(a)@.map_values(|x: i8| x as int).to_multiset(),
        result == is_sorted(a@.map_values(|x: i8| x as int)),","{
    // impl-start
    assume(false);
    false
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0569,verus,apps,apps_test_4399,,"Given a string of length 3 representing railway companies ('A' or 'B') operating 3 stations,
determine if any bus service will exist. Bus services connect stations operated by different companies.","use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    input.len() == 3 && forall|i: int| 0 <= i < input.len() ==> input[i] == 'A' || input[i] == 'B'
}

spec fn bus_service_exists(input: Seq<char>) -> bool
    recommends valid_input(input)
{
    input[0] != input[1] || input[1] != input[2]
}",,"fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires
        valid_input(input@),
    ensures
        result@ == seq!['Y', 'e', 's'] <==> bus_service_exists(input@),
        result@ == seq!['Y', 'e', 's'] || result@ == seq!['N', 'o'],","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0570,verus,apps,apps_test_4400,,"Given a string S of length 3 representing weather records for 3 consecutive days
(where 'S' means sunny and 'R' means rainy), find the maximum number of consecutive rainy days.","use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>) -> bool {
    s.len() == 3 && forall|i: int| 0 <= i < s.len() ==> s[i] == 'S' || s[i] == 'R'
}

spec fn max_consecutive_rainy_days(s: Seq<char>) -> int {
    if valid_input(s) {
        if s == seq!['R', 'R', 'R'] {
            3
        } else if s.subrange(0, 2) == seq!['R', 'R'] || s.subrange(1, 3) == seq!['R', 'R'] {
            2
        } else if s.contains('R') {
            1
        } else {
            0
        }
    } else {
        0
    }
}",,"fn solve(input: Vec<char>) -> (result: i8)
    requires 
        valid_input(input@),
    ensures 
        result as int == max_consecutive_rainy_days(input@),
        0 <= result && result <= 3,","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0571,verus,apps,apps_test_4403,,"Given a string of exactly 4 characters containing only '+' and '-',
calculate the sum where each '+' contributes +1 and each '-' contributes -1.","use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>) -> bool {
    s.len() == 4 && forall|i: int| 0 <= i < s.len() ==> s[i] == '+' || s[i] == '-'
}

spec fn count_char(s: Seq<char>, c: char) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0nat as int
    } else {
        (if s[0] == c { 1nat as int } else { 0nat as int }) + count_char(s.subrange(1, s.len() as int), c)
    }
}

spec fn calculate_sum(s: Seq<char>) -> int {
    count_char(s, '+') - count_char(s, '-')
}",,"fn solve(s: Vec<char>) -> (result: i8)
    requires valid_input(s@)
    ensures result as int == calculate_sum(s@)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0572,verus,apps,apps_test_4404,,"Given a string representing a valid date in 2019 in format yyyy/mm/dd,
determine if the date is on or before April 30, 2019.
Return ""Heisei"" if on or before April 30, 2019, otherwise return ""TBD"".","use vstd::prelude::*;

verus! {
spec fn is_valid_date_string(s: Seq<char>, y: int, m: int, d: int) -> bool {
    s.len() >= 10 && 
    s[4] == '/' && s[7] == '/' &&
    string_to_int(s.subrange(0, 4)) == y &&
    string_to_int(s.subrange(5, 7)) == m &&
    string_to_int(s.subrange(8, 10)) == d
}

spec fn string_to_int(s: Seq<char>) -> int {
    if s.len() == 0 { 0 }
    else if s.len() == 1 { char_to_digit(s[0]) }
    else if s.len() == 2 { char_to_digit(s[0]) * 10 + char_to_digit(s[1]) }
    else if s.len() == 4 { char_to_digit(s[0]) * 1000 + char_to_digit(s[1]) * 100 + char_to_digit(s[2]) * 10 + char_to_digit(s[3]) }
    else { 0 }
}

spec fn char_to_digit(c: char) -> int {
    if '0' <= c && c <= '9' { (c as int) - ('0' as int) } else { 0 }
}

spec fn valid_input(s: Seq<char>) -> bool {
    exists|y: int, m: int, d: int| is_valid_date_string(s, y, m, d) && y == 2019 && 1 <= m <= 12 && 1 <= d <= 31
}

spec fn correct_output(s: Seq<char>, result: Seq<char>) -> bool {
    exists|y: int, m: int, d: int| is_valid_date_string(s, y, m, d) && y == 2019 && 1 <= m <= 12 && 1 <= d <= 31 && 
    ((m < 4 || (m == 4 && d <= 30)) ==> result == seq!['H', 'e', 'i', 's', 'e', 'i']) && 
    ((m > 4 || (m == 4 && d > 30)) ==> result == seq!['T', 'B', 'D'])
}",,"fn solve(stdin_input: &str) -> (result: String)
    requires valid_input(stdin_input@)
    ensures correct_output(stdin_input@, result@)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0573,verus,apps,apps_test_4413,,"Given n students with distinct programming skills, divide them into the minimum number of teams 
such that no two students with skills differing by exactly 1 are on the same team.","use vstd::prelude::*;

verus! {
spec fn valid_input(skills: Seq<int>) -> bool {
    skills.len() >= 0
}

spec fn has_adjacent_skills(skills: Seq<int>) -> bool {
    exists|i: int, j: int| 0 <= i < j < skills.len() && (skills[i] - skills[j] == 1 || skills[j] - skills[i] == 1)
}",,"fn solve(skills: Vec<i8>) -> (teams: i8)
    requires 
        valid_input(skills@.map(|i, x| x as int))
    ensures 
        teams == 1 || teams == 2,
        teams == 2 <==> has_adjacent_skills(skills@.map(|i, x| x as int)),
        teams == 1 <==> !has_adjacent_skills(skills@.map(|i, x| x as int))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0575,verus,apps,apps_test_4426,,"Given a day of the week as a string, determine how many days until the next Sunday.
Input is one of ""SUN"", ""MON"", ""TUE"", ""WED"", ""THU"", ""FRI"", or ""SAT"".
Output is the number of days until the next Sunday (1-7, where 7 means next Sunday is in a week).","use vstd::prelude::*;

verus! {
spec fn valid_day(day: &str) -> bool {
    day == ""SUN"" || day == ""MON"" || day == ""TUE"" || day == ""WED"" || day == ""THU"" || day == ""FRI"" || day == ""SAT""
}

spec fn days_until_sunday(day: &str) -> int {
    if day == ""SUN"" { 7 }
    else if day == ""MON"" { 6 }
    else if day == ""TUE"" { 5 }
    else if day == ""WED"" { 4 }
    else if day == ""THU"" { 3 }
    else if day == ""FRI"" { 2 }
    else { 1 }
}",,"fn days_to_next_sunday(day: &str) -> (result: i8)
    requires 
        valid_day(day)
    ensures 
        result as int >= 1 && result as int <= 7,
        result as int == days_until_sunday(day)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0576,verus,apps,apps_test_4427,,"Given a recurrence relation x_{i+1} = r × x_i - D starting from year 2000, 
calculate the values for years 2001 through 2010.
Input: Three integers r, D, x_2000 where 2 ≤ r ≤ 5, 1 ≤ D ≤ 100, D < x_2000 ≤ 200
Output: 10 lines containing x_{2001}, x_{2002}, ..., x_{2010} respectively","use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool
    recommends input.len() > 0
{
    let tokens = parse_input_pure(input);
    tokens.len() == 3 && 
    2 <= tokens[0] <= 5 &&
    1 <= tokens[1] <= 100 &&
    tokens[1] < tokens[2] && tokens[2] <= 200
}

spec fn calculate_recurrence(r: int, d: int, x0: int, n: int) -> int
    recommends n >= 1
    decreases n when n >= 1
{
    if n == 1 { r * x0 - d }
    else if n >= 2 { r * calculate_recurrence(r, d, x0, n - 1) - d }
    else { 0 }
}

spec fn generate_expected_output(r: int, d: int, x0: int) -> Seq<char> {
    generate_output_up_to_iteration(r, d, x0, 10)
}

spec fn generate_output_up_to_iteration(r: int, d: int, x0: int, iterations: int) -> Seq<char>
    recommends iterations >= 0
    decreases iterations when iterations >= 0
{
    if iterations == 0 { 
        Seq::empty() 
    } else if iterations >= 1 { 
        let current_value = calculate_recurrence(r, d, x0, iterations);
        let previous_output = generate_output_up_to_iteration(r, d, x0, iterations - 1);
        previous_output + int_to_string(current_value) + seq!['\n']
    } else {
        Seq::empty()
    }
}

spec fn parse_input_pure(input: Seq<char>) -> Seq<int> {
    seq![1, 1, 100]  /* placeholder */
}

spec fn int_to_string(n: int) -> Seq<char> {
    seq!['0']  /* placeholder */
}",,"fn solve(input: &str) -> (result: String)
    requires 
        input@.len() > 0,
        valid_input(input@),
    ensures 
        result@ == generate_expected_output(
            parse_input_pure(input@)[0], 
            parse_input_pure(input@)[1], 
            parse_input_pure(input@)[2]
        )","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0577,verus,apps,apps_test_4430,,"Given n objects with sizes and m boxes of capacity k, find the maximum number of objects
that can be packed using a greedy algorithm by potentially removing leftmost objects.
The greedy algorithm processes objects from left to right, placing each object in the
current box if it fits, otherwise using a new empty box.","use vstd::prelude::*;

verus! {

spec fn greedy_pack_from_end(a: Seq<int>, boxes: int, capacity: int) -> int
    recommends
        boxes >= 1,
        capacity >= 1,
        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i] >= 1 && #[trigger] a[i] <= capacity,
{
    greedy_pack_from_end_helper(a, a.len() - 1, boxes, capacity, capacity)
}

spec fn greedy_pack_from_end_helper(a: Seq<int>, pos: int, boxes_left: int, capacity: int, current_box_space: int) -> int
    recommends
        capacity >= 1,
        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i] >= 1 && #[trigger] a[i] <= capacity,
        boxes_left >= 1,
        0 <= current_box_space <= capacity,
    decreases pos + 1,
{
    if pos < 0 {
        0int
    } else if pos >= a.len() {
        0int
    } else if a[pos] > capacity {
        0int
    } else if a[pos] <= current_box_space {
        1int + greedy_pack_from_end_helper(a, pos - 1, boxes_left, capacity, current_box_space - a[pos])
    } else if boxes_left > 1 {
        1int + greedy_pack_from_end_helper(a, pos - 1, boxes_left - 1, capacity, capacity - a[pos])
    } else {
        0int
    }
}",,"fn solve(n: i8, m: i8, k: i8, a: Vec<i8>) -> (result: i8)
    requires
        n >= 0,
        m >= 1,
        k >= 1,
        a.len() == n as usize,
        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i] as int >= 1 && #[trigger] a[i] as int <= k as int,
    ensures
        0 <= result as int <= n as int,
        result as int == greedy_pack_from_end(a@.map(|i, x| x as int), m as int, k as int),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0578,verus,apps,apps_test_4431,,"Given a string of n lowercase Latin letters and k available letters on a broken keyboard,
count how many substrings of the string can be typed using only the available letters.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: nat, k: nat, s: Seq<char>, available: Seq<char>) -> bool {
    n == s.len() &&
    k == available.len() &&
    forall|i: int, j: int| 0 <= i < j < available.len() ==> available[i] != available[j]
}

spec fn count_valid_substrings(s: Seq<char>, available_set: Set<char>) -> nat
    decreases s.len()
{
    if s.len() == 0 { 0 }
    else {
        let segments = get_maximal_valid_segments(s, available_set, 0);
        sum_segment_counts(segments)
    }
}

spec fn get_maximal_valid_segments(s: Seq<char>, available_set: Set<char>, start_idx: nat) -> Seq<nat>
    decreases s.len() - start_idx when start_idx <= s.len()
{
    if start_idx >= s.len() { Seq::empty() }
    else {
        let segment_length = get_next_segment_length(s, available_set, start_idx);
        if segment_length == 0 {
            get_maximal_valid_segments(s, available_set, start_idx + 1)
        } else {
            let skip_length = skip_invalid_chars(s, available_set, start_idx + segment_length);
            let next_idx = start_idx + segment_length + skip_length;
            if next_idx <= s.len() {
                seq![segment_length].add(get_maximal_valid_segments(s, available_set, next_idx))
            } else {
                seq![segment_length]
            }
        }
    }
}

spec fn get_next_segment_length(s: Seq<char>, available_set: Set<char>, start_idx: nat) -> nat
    decreases s.len() - start_idx when start_idx <= s.len()
{
    if start_idx >= s.len() || !available_set.contains(s[start_idx as int]) { 0 }
    else { 1 + get_next_segment_length(s, available_set, start_idx + 1) }
}

spec fn skip_invalid_chars(s: Seq<char>, available_set: Set<char>, start_idx: nat) -> nat
    decreases s.len() - start_idx when start_idx <= s.len()
{
    if start_idx >= s.len() || available_set.contains(s[start_idx as int]) { 0 }
    else { 1 + skip_invalid_chars(s, available_set, start_idx + 1) }
}

spec fn sum_segment_counts(segments: Seq<nat>) -> nat
    decreases segments.len()
{
    if segments.len() == 0 { 0 }
    else { segments[0] * (segments[0] + 1) / 2 + sum_segment_counts(segments.subrange(1, segments.len() as int)) }
}",,"fn solve(n: u8, k: u8, s: Vec<char>, available: Vec<char>) -> (result: u8)
    requires valid_input(n as nat, k as nat, s@, available@)
    ensures result as nat <= (n as nat) * ((n as nat) + 1) / 2","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0579,verus,apps,apps_test_4441,,"Read an integer N from input. If N=1, print ""Hello World"". If N=2, read two additional integers A and B, then print their sum.
Constraints: N is 1 or 2, A and B are integers between 1 and 9 (inclusive).","use vstd::prelude::*;

verus! {
spec fn valid_input(stdin_input: Seq<char>) -> bool {
    stdin_input.len() > 0
}

spec fn expected_output(stdin_input: Seq<char>) -> Seq<char> {
    let lines = split_lines_func(stdin_input);
    if lines.len() >= 1 {
        let n = string_to_int(lines[0]);
        if n == 1 {
            seq!['H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd', '\n']
        } else if n != 1 && lines.len() >= 3 {
            let a = string_to_int(lines[1]);
            let b = string_to_int(lines[2]);
            int_to_string(a + b) + seq!['\n']
        } else {
            seq![]
        }
    } else {
        seq![]
    }
}

spec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>> {
    split_lines_func_helper(s, 0, seq![], seq![])
}

spec fn split_lines_func_helper(s: Seq<char>, i: int, current: Seq<char>, acc: Seq<Seq<char>>) -> Seq<Seq<char>>
    decreases s.len() - i when 0 <= i <= s.len()
{
    if i >= s.len() {
        if current.len() == 0 { acc } else { acc.push(current) }
    } else if s[i] == '\n' {
        split_lines_func_helper(s, i + 1, seq![], acc.push(current))
    } else {
        split_lines_func_helper(s, i + 1, current.push(s[i]), acc)
    }
}

spec fn string_to_int(s: Seq<char>) -> int {
    if s.len() == 0 {
        0
    } else if s[0] == '-' {
        -string_to_int_helper(s.subrange(1, s.len() as int))
    } else {
        string_to_int_helper(s)
    }
}

spec fn string_to_int_helper(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else {
        string_to_int_helper(s.subrange(0, s.len() - 1)) * 10 + (s[s.len() - 1] as int - '0' as int)
    }
}

spec fn int_to_string(n: int) -> Seq<char> {
    if n == 0 {
        seq!['0']
    } else if n < 0 {
        seq!['-'] + int_to_string_helper(-n)
    } else {
        int_to_string_helper(n)
    }
}

spec fn int_to_string_helper(n: int) -> Seq<char>
    decreases n when n >= 0
{
    if n <= 0 {
        seq![]
    } else {
        int_to_string_helper(n / 10) + seq![(n % 10 + '0' as int) as char]
    }
}",,"fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(stdin_input@)
    ensures result@ == expected_output(stdin_input@)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0580,verus,apps,apps_test_4443,,"Given a lowercase English letter (not 'z'), output the next letter in alphabetical order.","use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 && 'a' <= input[0] <= 'y'
}

spec fn next_char(c: char) -> char
    recommends 'a' <= c <= 'y'
{
    ((c as u8) + 1) as char
}

spec fn valid_output(input: Seq<char>, output: Seq<char>) -> bool
    recommends valid_input(input)
{
    output.len() == 2 &&
    output[0] == next_char(input[0]) &&
    output[1] == '\n' &&
    'b' <= output[0] <= 'z'
}",,"fn solve(input: Vec<char>) -> (output: Vec<char>)
    requires valid_input(input@)
    ensures valid_output(input@, output@)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0581,verus,apps,apps_test_4444,,"Given two strings S and T as space-separated input, concatenate T and S (in that order) and output the result.
Input format: ""S T"" where S and T contain only lowercase English letters.
Output format: ""TS\n"" (T concatenated with S followed by newline).","use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 2 &&
    (exists|i: int| 0 < i < input.len() && #[trigger] input[i] == ' ') &&
    (forall|i: int| 0 <= i < input.len() ==> (#[trigger] input[i] == ' ' || input[i] == '\n' || ('a' <= input[i] <= 'z'))) &&
    (exists|i: int| 0 < i < input.len() && #[trigger] input[i] == ' ' && 
     (forall|j: int| 0 <= j < i ==> #[trigger] input[j] != ' ' && input[j] != '\n') &&
     (forall|j: int| i+1 <= j < input.len() ==> #[trigger] input[j] != ' ' && input[j] != '\n'))
}

spec fn valid_output(output: Seq<char>) -> bool {
    output.len() > 0 &&
    output[output.len() as int - 1] == '\n' &&
    (forall|i: int| 0 <= i < output.len() - 1 ==> ('a' <= #[trigger] output[i] <= 'z'))
}

spec fn extract_strings(input: Seq<char>) -> (Seq<char>, Seq<char>)
    recommends valid_input(input)
{
    let space_pos = choose|space_pos: int| 0 < space_pos < input.len() && input[space_pos] == ' ' &&
                       (forall|j: int| 0 <= j < space_pos ==> #[trigger] input[j] != ' ') &&
                       (forall|j: int| space_pos+1 <= j < input.len() ==> #[trigger] input[j] != ' ' && input[j] != '\n');
    let s = input.subrange(0, space_pos);
    let t = if input[input.len() as int - 1] == '\n' { 
        input.subrange(space_pos + 1, input.len() - 1) 
    } else { 
        input.subrange(space_pos + 1, input.len() as int) 
    };
    (s, t)
}

spec fn correct_concatenation(input: Seq<char>, output: Seq<char>) -> bool
    recommends valid_input(input)
{
    let (s, t) = extract_strings(input);
    output == t.add(s).push('\n')
}",,"fn solve(input: Vec<char>) -> (output: Vec<char>)
    requires
        valid_input(input@),
    ensures
        valid_output(output@),
        correct_concatenation(input@, output@),","{
    /* impl-start */
    assume(false);
    unreached()
    /* impl-end */
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0582,verus,apps,apps_test_4446,,"Given n monsters with health points, player and opponent take turns attacking until each monster dies.
Player attacks first with damage a, opponent with damage b. Player gets 1 point for killing a monster.
Player can skip opponent's turn at most k times total. Find maximum points achievable.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, a: int, b: int, k: int, h: Seq<int>) -> bool {
    n > 0 && a > 0 && b > 0 && k >= 0 && h.len() == n && 
    forall|i: int| 0 <= i < h.len() ==> h[i] > 0
}

spec fn process_health_values(h: Seq<int>, a: int, b: int) -> Seq<int>
    decreases h.len()
{
    if h.len() == 0 {
        seq![]
    } else {
        let h_mod = h[0] % (a + b);
        let h_final = if h_mod == 0 { a + b } else { h_mod };
        seq![h_final] + process_health_values(h.drop_first(), a, b)
    }
}

spec fn count_killable_monsters(sorted_health: Seq<int>, a: int, k: int) -> int {
    count_killable_helper(sorted_health, a, k, 0, 0)
}

spec fn count_killable_helper(sorted_health: Seq<int>, a: int, remaining_k: int, index: int, acc: int) -> int
    decreases sorted_health.len() - index
{
    if index >= sorted_health.len() {
        acc
    } else {
        let x = sorted_health[index];
        if x <= a {
            count_killable_helper(sorted_health, a, remaining_k, index + 1, acc + 1)
        } else {
            let needed_skips = (x + a - 1) / a - 1;
            if remaining_k >= needed_skips {
                count_killable_helper(sorted_health, a, remaining_k - needed_skips, index + 1, acc + 1)
            } else {
                count_killable_helper(sorted_health, a, remaining_k, index + 1, acc)
            }
        }
    }
}",,"fn solve_core(n: i8, a: i8, b: i8, k: i8, h: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, a as int, b as int, k as int, h@.map_values(|x: i8| x as int))
    ensures 0 <= result as int <= n as int","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0584,verus,apps,apps_test_4464,,"Given three integers A, B, and C, determine if it's possible to select one or more 
positive multiples of A such that their sum is congruent to C modulo B.","use vstd::prelude::*;

verus! {
spec fn valid_input(a: int, b: int, c: int) -> bool {
    1 <= a <= 100 && 1 <= b <= 100 && 0 <= c < b
}

spec fn is_solvable(a: int, b: int, c: int) -> bool {
    exists|i: int| 1 <= i < b && #[trigger] ((i * (a % b)) % b) == c
}",,"fn solve(a: i8, b: i8, c: i8) -> (result: String)
    requires 
        valid_input(a as int, b as int, c as int)
    ensures 
        (result@ == ""YES""@) <==> is_solvable(a as int, b as int, c as int),
        (result@ == ""NO""@) || (result@ == ""YES""@)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0585,verus,apps,apps_test_4465,,"Calculate the remaining area of a rectangular farm after placing one vertical road
and one horizontal road, each 1 yard wide, that span the entire width/height.","use vstd::prelude::*;

verus! {
spec fn valid_farm_dimensions(a: int, b: int) -> bool {
    a >= 2 && b >= 2 && a <= 100 && b <= 100
}

spec fn remaining_farm_area(a: int, b: int) -> int
    recommends valid_farm_dimensions(a, b)
{
    a * b - a - b + 1
}",,"fn solve(a: i8, b: i8) -> (result: i8)
    requires 
        valid_farm_dimensions(a as int, b as int)
    ensures 
        result as int == remaining_farm_area(a as int, b as int),
        result >= 0","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0586,verus,apps,apps_test_4466,,"Given a seat of width X centimeters, determine the maximum number of people that can sit on it.
Each person occupies Y centimeters, and there must be at least Z centimeters of gap between 
any two people and between each end of the seat and the nearest person.","use vstd::prelude::*;

verus! {
spec fn valid_input(x: int, y: int, z: int) -> bool {
    x >= 1 && y >= 1 && z >= 1 && y + 2 * z <= x
}

spec fn max_people(x: int, y: int, z: int) -> int
    recommends valid_input(x, y, z)
{
    (x - z) / (y + z)
}

spec fn valid_solution(x: int, y: int, z: int, result: int) -> bool
    recommends valid_input(x, y, z)
{
    result == max_people(x, y, z) &&
    result >= 0 &&
    result * (y + z) <= x - z < (result + 1) * (y + z)
}",,"fn solve(x: i8, y: i8, z: i8) -> (result: i8)
    requires valid_input(x as int, y as int, z as int)
    ensures valid_solution(x as int, y as int, z as int, result as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0587,verus,apps,apps_test_4469,,"Given a shelf, process queries of three types:
- L id: Add book with index id to the leftmost position
- R id: Add book with index id to the rightmost position  
- ? id: Find the minimum number of books to remove from either end to make book id leftmost or rightmost
For each ? query, output the minimum number of removals needed.","use vstd::prelude::*;

verus! {

spec fn valid_input(queries: Seq<(char, int)>) -> bool {
    &&& queries.len() > 0
    &&& (forall|i: int| 0 <= i < queries.len() ==> queries[i].0 == 'L' || queries[i].0 == 'R' || queries[i].0 == '?')
    &&& (forall|i: int| 0 <= i < queries.len() ==> queries[i].1 > 0)
    &&& (forall|i: int, j: int| 0 <= i < j < queries.len() && (queries[i].0 == 'L' || queries[i].0 == 'R') && (queries[j].0 == 'L' || queries[j].0 == 'R') ==> queries[i].1 != queries[j].1)
    &&& (forall|i: int| 0 <= i < queries.len() && queries[i].0 == '?' ==> 
        exists|j: int| 0 <= j < i && (queries[j].0 == 'L' || queries[j].0 == 'R') && queries[j].1 == queries[i].1)
    &&& (exists|i: int| 0 <= i < queries.len() && queries[i].0 == '?')
}

spec fn count_query_ops(queries: Seq<(char, int)>) -> int
    decreases queries.len()
{
    if queries.len() == 0 {
        0
    } else {
        let head = queries[0];
        let tail = queries.subrange(1, queries.len() as int);
        if head.0 == '?' {
            1 + count_query_ops(tail)
        } else {
            count_query_ops(tail)
        }
    }
}

spec fn valid_output(queries: Seq<(char, int)>, results: Seq<int>) -> bool {
    &&& results.len() == count_query_ops(queries)
    &&& (forall|i: int| 0 <= i < results.len() ==> results[i] >= 0)
    &&& (forall|r_idx: int| #[trigger] results[r_idx] == compute_min_removals(queries, r_idx) ==> 0 <= r_idx < results.len() ==> 
        (exists|q_idx: int| 0 <= q_idx < queries.len() && queries[q_idx].0 == '?' &&
         results[r_idx] == compute_min_removals(queries, q_idx)))
    &&& (forall|q_idx: int| #[trigger] queries[q_idx] == queries[q_idx] ==> 0 <= q_idx < queries.len() && queries[q_idx].0 == '?' ==>
        (exists|r_idx: int| 0 <= r_idx < results.len() &&
         results[r_idx] == compute_min_removals(queries, q_idx)))
}

struct BookshelfState {
    positions: Map<int, int>,
    head: int,
    tail: int,
}

spec fn simulate_queries(queries: Seq<(char, int)>, query_idx: int) -> BookshelfState {
    BookshelfState {
        positions: Map::empty(),
        head: 0,
        tail: 0,
    }
}

spec fn compute_min_removals(queries: Seq<(char, int)>, query_idx: int) -> int {
    0
}",,"fn solve(queries: Vec<(char, i8)>) -> (results: Vec<i8>)
    requires valid_input(queries@.map(|i: int, x: (char, i8)| (x.0, x.1 as int)))
    ensures valid_output(queries@.map(|i: int, x: (char, i8)| (x.0, x.1 as int)), results@.map(|i: int, x: i8| x as int))","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0588,verus,apps,apps_test_4470,,"Given an integer n, find the minimum number of operations to transform it to 1, or return -1 if impossible.
Allowed operations: 1) n → n/2 if n divisible by 2, 2) n → 2n/3 if n divisible by 3, 3) n → 4n/5 if n divisible by 5.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: nat) -> bool {
    n > 0
}

spec fn can_reach_one(n: nat) -> bool
    recommends n > 0
{
    only_factors_235(n)
}

spec fn only_factors_235(n: nat) -> bool
    recommends n > 0
{
    reduce_by_factors_235(n) == 1
}

spec fn reduce_by_factors_235(n: nat) -> nat
    recommends n > 0
    decreases n
    when n > 0
{
    if n == 1 {
        1
    } else if n % 2 == 0 {
        reduce_by_factors_235(n / 2)
    } else if n % 3 == 0 {
        reduce_by_factors_235(n / 3)
    } else if n % 5 == 0 {
        reduce_by_factors_235(n / 5)
    } else {
        n
    }
}

spec fn min_moves_to_one(n: nat) -> nat
    recommends n > 0 && can_reach_one(n)
    decreases n
    when n > 0
{
    if n == 1 {
        0
    } else if n % 2 == 0 {
        1 + min_moves_to_one(n / 2)
    } else if n % 3 == 0 {
        2 + min_moves_to_one(n / 3)
    } else if n % 5 == 0 {
        3 + min_moves_to_one(n / 5)
    } else {
        0
    }
}",,"fn solve(n: u8) -> (result: i8)
    requires
        valid_input(n as nat),
    ensures
        result >= -1,
        result == -1 <==> !can_reach_one(n as nat),
        result >= 0 ==> can_reach_one(n as nat) && result == min_moves_to_one(n as nat) as i8,","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0589,verus,apps,apps_test_4476,,"Given two positive integers a and b, find the minimum number of moves to transform 
a into b using these operations: add any positive odd integer to a, or subtract 
any positive even integer from a. It is guaranteed that b can always be obtained from a.","use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<(int, int)>) -> bool {
    forall|i: int| 0 <= i < input.len() ==> input[i].0 >= 1 && input[i].1 >= 1
}

spec fn min_moves(a: int, b: int) -> int
    recommends a >= 1 && b >= 1
{
    if a == b {
        0
    } else if a < b {
        if (b - a) % 2 == 1 { 1 } else { 2 }
    } else {
        if (a - b) % 2 == 0 { 1 } else { 2 }
    }
}

spec fn valid_output(input: Seq<(int, int)>, result: Seq<int>) -> bool {
    valid_input(input) ==> (
        result.len() == input.len() &&
        forall|i: int| 0 <= i < input.len() ==> result[i] == min_moves(input[i].0, input[i].1) &&
        forall|i: int| 0 <= i < result.len() ==> result[i] >= 0
    )
}",,"fn solve(input: Vec<(i8, i8)>) -> (result: Vec<i8>)
    requires valid_input(input@.map(|i, x: (i8, i8)| (x.0 as int, x.1 as int)))
    ensures valid_output(input@.map(|i, x: (i8, i8)| (x.0 as int, x.1 as int)), result@.map(|i, x: i8| x as int))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0590,verus,apps,apps_test_4477,,"Given an apartment number x consisting of the same repeated digit, calculate the total number of digits pressed when calling all ""boring"" apartments (apartments with all same digits) in a specific order until apartment x answers. The calling order is: All apartments with digit 1 (1, 11, 111, 1111), then digit 2 (2, 22, 222, 2222), and so on through digit 9.

/* Sum digits for all previous complete digit groups (1-9, 11-99, etc.) */

/* Sum digits for current digit group up to and including x */","use vstd::prelude::*;

verus! {
spec fn is_boring_apartment(x: int) -> bool {
    (x >= 1 && x <= 9) ||
    (x >= 11 && x <= 99 && x % 11 == 0 && x / 11 >= 1 && x / 11 <= 9) ||
    (x >= 111 && x <= 999 && x % 111 == 0 && x / 111 >= 1 && x / 111 <= 9) ||
    (x >= 1111 && x <= 9999 && x % 1111 == 0 && x / 1111 >= 1 && x / 1111 <= 9)
}

spec fn digit_count(n: int) -> int {
    if n <= 9 { 1 }
    else if n <= 99 { 2 }
    else if n <= 999 { 3 }
    else { 4 }
}

spec fn boring_apartment_value(digit: int, length: int) -> int {
    if length == 1 { digit }
    else if length == 2 { digit * 11 }
    else if length == 3 { digit * 111 }
    else { digit * 1111 }
}

spec fn total_digits_pressed(x: int) -> int {
    let digit = if x <= 9 { x } 
                 else if x <= 99 { x / 11 }
                 else if x <= 999 { x / 111 }
                 else { x / 1111 };
    let length = digit_count(x);

    let prev_digits = if digit == 1 { 0 } else { (digit - 1) * (1 + 2 + 3 + 4) };

    let current_digits = (length * (length + 1)) / 2;

    prev_digits + current_digits
}",,"fn solve(x: i32) -> (result: i32)
    requires is_boring_apartment(x as int) && 1 <= x as int <= 9999
    ensures result as int >= 0 && result as int == total_digits_pressed(x as int) && 
            (x as int == 1 ==> result as int == 1) &&
            (x as int == 22 ==> result as int == 13) &&
            (x as int == 777 ==> result as int == 66) &&
            (x as int == 9999 ==> result as int == 90)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0591,verus,apps,apps_test_4482,,"Given N integers, find the minimum cost to make all integers equal by transforming some of them.
Each integer can be transformed at most once. The cost of transforming integer x to integer y is (x-y)².","use vstd::prelude::*;

verus! {
spec fn sum_squares(p: int, a: Seq<int>) -> int
    decreases a.len()
{
    if a.len() == 0 {
        0
    } else {
        (p - a[0]) * (p - a[0]) + sum_squares(p, a.subrange(1, a.len() as int))
    }
}

spec fn valid_input(n: int, a: Seq<int>) -> bool {
    n >= 1 && n <= 100 && a.len() == n && 
    forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i] >= -100 && #[trigger] a[i] <= 100
}

spec fn is_optimal_cost(result: int, a: Seq<int>) -> bool {
    result >= 0 &&
    exists|p: int| -100 <= p <= 100 && result == sum_squares(p, a) &&
    forall|p: int| -100 <= p <= 100 ==> result <= sum_squares(p, a)
}",,"fn solve(n: i8, a: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, a@.map(|_i: int, x: i8| x as int))
    ensures is_optimal_cost(result as int, a@.map(|_i: int, x: i8| x as int))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0592,verus,apps,apps_test_4486,,"Given a string s of lowercase English letters, extract all characters at odd-numbered positions
(using 1-based indexing) and concatenate them into a new string. This corresponds to extracting
characters at even indices in 0-based indexing (positions 0, 2, 4, 6, ...).","use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>) -> bool {
    s.len() >= 1 && forall|i: int| 0 <= i < s.len() ==> 'a' <= #[trigger] s[i] <= 'z'
}

spec fn expected_length(s: Seq<char>) -> nat {
    (s.len() + 1) / 2
}

spec fn correct_extraction(s: Seq<char>, result: Seq<char>) -> bool {
    result.len() == expected_length(s) &&
    forall|i: int| 0 <= i < result.len() ==> 0 <= 2*i < s.len() && #[trigger] result[i] == s[2*i] &&
    forall|i: int| 0 <= i < s.len() && i % 2 == 0 ==> exists|j: int| 0 <= j < result.len() && result[j] == #[trigger] s[i] && j == i / 2
}",,"fn solve(s: Vec<char>) -> (result: Vec<char>)
    requires valid_input(s@)
    ensures correct_extraction(s@, result@)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0593,verus,apps,apps_test_4487,,"Given three strings A, B, and C, determine if they form a word chain.
A word chain exists if the last character of A equals the first character of B
and the last character of B equals the first character of C.
Output ""YES"" if both conditions are true, ""NO"" otherwise.","use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0
}

spec fn valid_parsed_input(parts: Seq<Seq<char>>) -> bool {
    parts.len() == 3 && parts[0].len() > 0 && parts[1].len() > 0 && parts[2].len() > 0
}

spec fn is_word_chain(a: Seq<char>, b: Seq<char>, c: Seq<char>) -> bool {
    a.len() > 0 && b.len() > 0 && c.len() > 0 &&
    a[a.len() - 1] == b[0] && b[b.len() - 1] == c[0]
}

spec fn split_on_spaces(s: Seq<char>) -> Seq<Seq<char>>;

spec fn expected_result(input: Seq<char>) -> Seq<char> {
    let stripped = if input.len() > 0 && input[input.len() - 1] == '\n' {
        input.subrange(0, input.len() - 1)
    } else {
        input
    };
    let parts = split_on_spaces(stripped);
    if valid_parsed_input(parts) {
        if is_word_chain(parts[0], parts[1], parts[2]) {
            seq!['Y', 'E', 'S', '\n']
        } else {
            seq!['N', 'O', '\n']
        }
    } else {
        seq![]
    }
}",,"fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(input@)
    ensures result@ == expected_result(input@)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0594,verus,apps,apps_test_4488,,"Compare two large positive integers A and B and determine their relative magnitude.
Input consists of two positive integers on separate lines, each up to 100 digits.
Output ""GREATER"" if A > B, ""LESS"" if A < B, or ""EQUAL"" if A = B.","use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    let lines = split_lines_spec(input);
    lines.len() >= 2 && is_valid_integer(lines[0]) && is_valid_integer(lines[1])
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> ('0' <= #[trigger] s[i] && s[i] <= '9')
}

spec fn split_lines_spec(s: Seq<char>) -> Seq<Seq<char>>
    decreases s.len()
{
    if s.len() == 0 {
        seq![]
    } else if s[0] == '\n' {
        split_lines_spec(s.subrange(1, s.len() as int))
    } else {
        let next_newline = find_next_newline(s, 0);
        if next_newline == -1 {
            seq![s]
        } else if next_newline >= 0 && next_newline < s.len() && next_newline + 1 <= s.len() {
            seq![s.subrange(0, next_newline)] + split_lines_spec(s.subrange(next_newline + 1, s.len() as int))
        } else {
            seq![]
        }
    }
}

spec fn find_next_newline(s: Seq<char>, start: nat) -> int
    decreases s.len() - start
{
    if start >= s.len() {
        -1
    } else if s[start as int] == '\n' {
        start as int
    } else {
        find_next_newline(s, start + 1)
    }
}

spec fn parse_int_spec(s: Seq<char>) -> int {
    parse_int_helper(s, 0)
}

spec fn parse_int_helper(s: Seq<char>, pos: nat) -> int
    decreases s.len() - pos
{
    if pos >= s.len() || s[pos as int] == '\n' || s[pos as int] == '\r' {
        0
    } else if '0' <= s[pos as int] <= '9' {
        (s[pos as int] as int - '0' as int) + 10 * parse_int_helper(s, pos + 1)
    } else {
        parse_int_helper(s, pos + 1)
    }
}",,"fn solve(input: &str) -> (result: String)
    requires input@.len() > 0
    ensures ({
        let input_seq = input@;
        valid_input(input_seq) ==> {
            let lines = split_lines_spec(input_seq);
            let a = parse_int_spec(lines[0]);
            let b = parse_int_spec(lines[1]);
            (result@ == ""LESS\n""@) == (a < b) &&
            (result@ == ""GREATER\n""@) == (a > b) &&
            (result@ == ""EQUAL\n""@) == (a == b)
        }
    }) && ({
        let input_seq = input@;
        !valid_input(input_seq) ==> result@ == """"@
    })","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0595,verus,apps,apps_test_4489,,"Given N blue cards and M red cards with strings, find maximum net earnings.
When a string is announced, earn 1 yen per blue card with that string and
lose 1 yen per red card with that string. Find the optimal string to maximize earnings.","use vstd::prelude::*;

verus! {
spec fn count_occurrences(cards: Seq<&str>, target: &str) -> int
    decreases cards.len()
{
    if cards.len() == 0 {
        0
    } else if cards[0] == target {
        1 + count_occurrences(cards.subrange(1, cards.len() as int), target)
    } else {
        count_occurrences(cards.subrange(1, cards.len() as int), target)
    }
}

spec fn get_unique_strings(all_strings: Seq<&str>) -> Seq<&str>
    decreases all_strings.len()
{
    if all_strings.len() == 0 {
        Seq::empty()
    } else {
        let rest_unique = get_unique_strings(all_strings.subrange(1, all_strings.len() as int));
        if rest_unique.contains(all_strings[0]) {
            rest_unique
        } else {
            seq![all_strings[0]].add(rest_unique)
        }
    }
}

spec fn max_net_earnings(blue_cards: Seq<&str>, red_cards: Seq<&str>) -> int {
    let unique_blue = get_unique_strings(blue_cards);
    max_net_earnings_helper(unique_blue, blue_cards, red_cards, 0, 0)
}

spec fn max_net_earnings_helper(unique_blue: Seq<&str>, blue_cards: Seq<&str>, red_cards: Seq<&str>, index: int, current_max: int) -> int
    decreases unique_blue.len() - index
{
    if index >= unique_blue.len() {
        current_max
    } else {
        let s = unique_blue[index];
        let blue_count = count_occurrences(blue_cards, s);
        let red_count = count_occurrences(red_cards, s);
        let net = blue_count - red_count;
        let new_max = if net > current_max { net } else { current_max };
        max_net_earnings_helper(unique_blue, blue_cards, red_cards, index + 1, new_max)
    }
}

proof fn count_occurrences_non_negative(cards: Seq<&str>, target: &str)
    ensures count_occurrences(cards, target) >= 0
    decreases cards.len()
{
    if cards.len() == 0 {
    } else if cards[0] == target {
        count_occurrences_non_negative(cards.subrange(1, cards.len() as int), target);
    } else {
        count_occurrences_non_negative(cards.subrange(1, cards.len() as int), target);
    }
}

proof fn max_net_earnings_non_negative(blue_cards: Seq<&str>, red_cards: Seq<&str>)
    ensures max_net_earnings(blue_cards, red_cards) >= 0
{
    let unique_blue = get_unique_strings(blue_cards);
    max_net_earnings_helper_non_negative(unique_blue, blue_cards, red_cards, 0, 0);
}

proof fn max_net_earnings_helper_non_negative(unique_blue: Seq<&str>, blue_cards: Seq<&str>, red_cards: Seq<&str>, index: int, current_max: int)
    requires 
        0 <= index <= unique_blue.len(),
        current_max >= 0
    ensures max_net_earnings_helper(unique_blue, blue_cards, red_cards, index, current_max) >= current_max
    decreases unique_blue.len() - index
{
    if index >= unique_blue.len() {
    } else {
        let s = unique_blue[index];
        let blue_count = count_occurrences(blue_cards, s);
        let red_count = count_occurrences(red_cards, s);
        let net = blue_count - red_count;
        let new_max = if net > current_max { net } else { current_max };
        max_net_earnings_helper_non_negative(unique_blue, blue_cards, red_cards, index + 1, new_max);
    }
}",,"fn solve(blue_cards: Vec<&str>, red_cards: Vec<&str>) -> (result: i8)
    ensures 
        result >= 0,
        result as int == max_net_earnings(blue_cards@, red_cards@)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0596,verus,apps,apps_test_4490,,"Given a DNA base represented by a single letter (A, C, G, or T), find its complementary base
according to the pairing rules: A pairs with T, T pairs with A, C pairs with G, G pairs with C","use vstd::prelude::*;

verus! {

spec fn valid_dna_base(c: char) -> bool {
    c == 'A' || c == 'T' || c == 'C' || c == 'G'
}

spec fn dna_complement(c: char) -> char
    recommends valid_dna_base(c)
{
    if c == 'A' { 'T' }
    else if c == 'T' { 'A' }
    else if c == 'C' { 'G' }
    else if c == 'G' { 'C' }
    else { 'A' } /* default case for spec completeness */
}

spec fn find_newline(input: Seq<char>) -> int {
    choose|i: int| 0 <= i < input.len() && input[i] == '\n'
}

spec fn valid_input(input: Seq<char>) -> bool {
    let input_line = if exists|i: int| 0 <= i < input.len() && input[i] == '\n' {
        input.subrange(0, find_newline(input))
    } else {
        input
    };
    input_line.len() == 1 && valid_dna_base(input_line[0])
}",,"fn solve(stdin_input: &str) -> (result: String)
    requires stdin_input@.len() > 0
    ensures ({
        let input_seq = stdin_input@;
        let input_line = if exists|i: int| 0 <= i < input_seq.len() && input_seq[i] == '\n' {
            input_seq.subrange(0, find_newline(input_seq))
        } else {
            input_seq
        };
        if valid_input(input_seq) {
            result@ == seq![dna_complement(input_line[0]), '\n']
        } else {
            result@ == Seq::<char>::empty()
        }
    })","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0597,verus,apps,apps_test_4491,,"Given a 2×N grid where each cell contains candies, find the maximum number of candies
that can be collected when traveling from top-left to bottom-right. You can only move
right or down, and you collect all candies from visited cells.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, a_1: Seq<int>, a_2: Seq<int>) -> bool {
    n >= 1 &&
    a_1.len() == n && a_2.len() == n &&
    forall|i: int| #![trigger a_1[i], a_2[i]] 0 <= i < n ==> 1 <= a_1[i] <= 100 && 1 <= a_2[i] <= 100
}

spec fn sum_range(s: Seq<int>, start: int, end: int) -> int
    decreases end - start when 0 <= start <= end <= s.len() && forall|i: int| #![trigger s[i]] start <= i < end ==> s[i] >= 1
{
    if start >= end { 
        0 
    } else { 
        s[start] + sum_range(s, start + 1, end) 
    }
}

spec fn is_valid_result(n: int, a_1: Seq<int>, a_2: Seq<int>, result: int) -> bool {
    valid_input(n, a_1, a_2) &&
    result >= n + 1 &&
    result <= (n + 1) * 100 &&
    exists|i: int| 0 <= i < n && result == sum_range(a_1, 0, i + 1) + sum_range(a_2, i, n) &&
    forall|i: int| 0 <= i < n ==> result >= sum_range(a_1, 0, i + 1) + sum_range(a_2, i, n)
}",,"fn solve(n: i8, a_1: Vec<i8>, a_2: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, a_1@.map_values(|x: i8| x as int), a_2@.map_values(|x: i8| x as int))
    ensures is_valid_result(n as int, a_1@.map_values(|x: i8| x as int), a_2@.map_values(|x: i8| x as int), result as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0599,verus,apps,apps_test_4494,,"Given the type of contest held last week (""ABC"" or ""ARC""), determine the type 
of contest to be held this week. Contests alternate between these two types.","use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 && 
    ({
        let s = if input[input.len()-1] == '\n' { 
            input.subrange(0, input.len() - 1)
        } else { 
            input
        };
        s == ""ABC""@ || s == ""ARC""@
    })
}

spec fn normalize_input(input: Seq<char>) -> Seq<char>
    recommends input.len() > 0
{
    if input[input.len()-1] == '\n' { 
        input.subrange(0, input.len() - 1)
    } else { 
        input
    }
}

spec fn expected_output(input: Seq<char>) -> Seq<char>
    recommends valid_input(input)
{
    let s = normalize_input(input);
    if s == ""ABC""@ { ""ARC\n""@ } else { ""ABC\n""@ }
}",,"fn solve(input: String) -> (result: String)
    requires valid_input(input@)
    ensures result@ == expected_output(input@)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0600,verus,apps,apps_test_4495,,"Given nonnegative integers a and b (where a ≤ b) and a positive integer x,
count how many integers in the range [a, b] inclusive are divisible by x.","use vstd::prelude::*;

verus! {
spec fn valid_input(a: int, b: int, x: int) -> bool {
    a >= 0 && b >= a && x > 0
}

spec fn count_divisible_in_range(a: int, b: int, x: int) -> int
    recommends valid_input(a, b, x)
{
    if a == 0 {
        b / x + 1
    } else {
        b / x - (a - 1) / x
    }
}",,"fn count_divisible(a: i8, b: i8, x: i8) -> (count: i8)
    requires 
        valid_input(a as int, b as int, x as int),
    ensures 
        count as int == count_divisible_in_range(a as int, b as int, x as int),
        count >= 0,","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0601,verus,apps,apps_test_4496,,"Given an integer D representing a December date (22-25), output the corresponding Christmas-related string:
D=25: ""Christmas"", D=24: ""Christmas Eve"", D=23: ""Christmas Eve Eve"", D=22: ""Christmas Eve Eve Eve""","use vstd::prelude::*;

verus! {

spec fn valid_input(d: int) -> bool {
    22 <= d <= 25
}

spec fn expected_output(d: int) -> Seq<char> {
    if valid_input(d) {
        let eve_count = 25 - d;
        let base_string = seq!['C', 'h', 'r', 'i', 's', 't', 'm', 'a', 's'];
        if eve_count == 0 {
            base_string
        } else {
            base_string + repeat_eve(eve_count)
        }
    } else {
        seq![]
    }
}

spec fn repeat_eve(count: int) -> Seq<char>
    decreases count
{
    if count <= 0 {
        seq![]
    } else {
        seq![' ', 'E', 'v', 'e'] + repeat_eve(count - 1)
    }
}",,"fn solve(d: i8) -> (result: String)
    requires valid_input(d as int)
    ensures result@ == expected_output(d as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0602,verus,apps,apps_test_4498,,"Given three integer positions a, b, c on a number line and an integer communication range d,
determine if positions a and c can communicate either directly (distance ≤ d) or indirectly
through position b (both a-b and b-c distances ≤ d).","use vstd::prelude::*;

verus! {
spec fn valid_input(a: int, b: int, c: int, d: int) -> bool {
    1 <= a <= 100 && 1 <= b <= 100 && 1 <= c <= 100 && 1 <= d <= 100
}

spec fn can_communicate(a: int, b: int, c: int, d: int) -> bool {
    (if a - c >= 0 { a - c } else { c - a }) <= d || 
    (((if a - b >= 0 { a - b } else { b - a }) <= d) && 
     ((if b - c >= 0 { b - c } else { c - b }) <= d))
}",,"fn solve(a: i8, b: i8, c: i8, d: i8) -> (result: String)
    requires 
        valid_input(a as int, b as int, c as int, d as int),
    ensures 
        result@ == seq!['Y', 'e', 's'] <==> can_communicate(a as int, b as int, c as int, d as int),
        result@ == seq!['Y', 'e', 's'] || result@ == seq!['N', 'o'],","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0604,verus,apps,apps_test_4502,,"Given an integer sequence a of length n, simulate n operations on an initially empty sequence b:
Operation i: Append a[i] to the end of b, then reverse the entire sequence b
Output the final sequence b after all n operations.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, a: Seq<int>) -> bool {
    n >= 1 && a.len() == n
}

spec fn simulate_operations(a: Seq<int>) -> Seq<int>
    recommends a.len() >= 1
    decreases a.len() when a.len() > 0
{
    if a.len() == 1 {
        seq![a[0]]
    } else {
        let shorter = a.subrange(0, (a.len() - 1) as int);
        let prev = simulate_operations(shorter);
        reverse_seq(prev.push(a[(a.len() - 1) as int]))
    }
}

spec fn compute_result(a: Seq<int>) -> Seq<int>
    recommends a.len() >= 1
{
    let n = a.len();
    let o = Seq::new(if n % 2 == 0 { n / 2 } else { (n + 1) / 2 }, |i: int| a[2*i]);
    let e = Seq::new(n / 2, |i: int| a[2*i + 1]);
    if n % 2 == 0 {
        reverse_seq(e).add(o)
    } else {
        reverse_seq(o).add(e)
    }
}

spec fn reverse_seq(s: Seq<int>) -> Seq<int>
    decreases s.len() when s.len() > 0
{
    if s.len() == 0 {
        seq![]
    } else {
        let rest = s.subrange(1, s.len() as int);
        reverse_seq(rest).push(s[0])
    }
}",,"fn solve(n: i8, a: Vec<i8>) -> (result: Vec<i8>)
    requires 
        valid_input(n as int, a@.map(|i: int, x: i8| x as int)),
    ensures 
        result.len() == n as int,
        result@.map(|i: int, x: i8| x as int) == compute_result(a@.map(|i: int, x: i8| x as int)),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0605,verus,apps,apps_test_4504,,"Given an even string S, find the length of the longest even string that can be 
obtained by deleting one or more characters from the end of S. An even string
is one that can be split into two identical halves.","use vstd::prelude::*;

verus! {
spec fn is_even_string(s: Seq<char>) -> bool {
    s.len() >= 2 && s.len() % 2 == 0 && s.subrange(0, s.len() as int / 2) == s.subrange(s.len() as int / 2, s.len() as int)
}

spec fn valid_input(s: Seq<char>) -> bool {
    s.len() >= 2 && is_even_string(s)
}

spec fn valid_solution(s: Seq<char>, result: int) -> bool {
    2 <= result < s.len() && result % 2 == 0 && is_even_string(s.subrange(0, result))
}

spec fn is_maximal_solution(s: Seq<char>, result: int) -> bool {
    valid_solution(s, result) && 
    forall|k: int| result < k < s.len() && k % 2 == 0 ==> !is_even_string(s.subrange(0, k))
}",,"fn solve(s: Vec<char>) -> (result: usize)
    requires 
        valid_input(s@) &&
        (exists|k: int| valid_solution(s@, k))
    ensures 
        valid_solution(s@, result as int) &&
        is_maximal_solution(s@, result as int)","{
    assume(false);
    2
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0606,verus,apps,apps_test_4505,,"Given a string S of length 3 containing only characters 'a', 'b', and 'c',
determine if S is a permutation of ""abc"" (i.e., contains exactly one occurrence
each of 'a', 'b', and 'c'). Return ""Yes\n"" if it is a permutation, ""No\n"" otherwise.","use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>) -> bool {
    (s.len() == 3 || (s.len() == 4 && s[3] == '\n')) &&
    forall|i: int| 0 <= i < (if s.len() == 4 { 3 } else { s.len() as int }) ==> 
        (s[i] == 'a' || s[i] == 'b' || s[i] == 'c')
}

spec fn get_input_chars(s: Seq<char>) -> Seq<char> {
    if s.len() == 4 { s.subrange(0, 3) } else { s }
}

spec fn is_permutation_of_abc(input_chars: Seq<char>) -> bool {
    input_chars.len() == 3 &&
    (forall|i: int| 0 <= i < input_chars.len() ==> 
        (input_chars[i] == 'a' || input_chars[i] == 'b' || input_chars[i] == 'c')) &&
    input_chars[0] != input_chars[1] && 
    input_chars[1] != input_chars[2] && 
    input_chars[0] != input_chars[2]
}",,"fn solve(s: Vec<char>) -> (result: Vec<char>)
    requires 
        s@.len() >= 3,
        valid_input(s@),
    ensures 
        result@ == seq!['Y', 'e', 's', '\n'] || result@ == seq!['N', 'o', '\n'],
        result@ == seq!['Y', 'e', 's', '\n'] <==> is_permutation_of_abc(get_input_chars(s@)),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0607,verus,apps,apps_test_4508,,"Given an undirected tree with n vertices, add the minimum number of edges 
such that the shortest path from vertex 1 to any other vertex is at most 2.
Loops and multiple edges are not allowed.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, edges: Seq<(int, int)>) -> bool {
    n >= 2 && edges.len() == n - 1 &&
    forall|e: (int, int)| edges.contains(e) ==> 1 <= e.0 <= n && 1 <= e.1 <= n && e.0 != e.1
}

spec fn all_vertices_within_distance2(n: int, edges: Seq<(int, int)>) -> bool {
    n >= 2 ==> forall|v: int| 2 <= v <= n ==> shortest_path_distance(n, edges, 1, v) <= 2
}

spec fn shortest_path_distance(n: int, edges: Seq<(int, int)>, start: int, end: int) -> int {
    if n >= 1 && 1 <= start <= n && 1 <= end <= n {
        if start == end { 0 } else { compute_shortest_path(n, edges, start, end) }
    } else {
        -1
    }
}

spec fn compute_shortest_path(n: int, edges: Seq<(int, int)>, start: int, end: int) -> int {
    if n >= 1 && 1 <= start <= n && 1 <= end <= n {
        let adj = build_adjacency_list(n, edges);
        bfs(adj, n, start, end)
    } else {
        -1
    }
}

spec fn build_adjacency_list(n: int, edges: Seq<(int, int)>) -> Seq<Seq<int>> {
    if n >= 1 {
        let adj = Seq::new((n + 1) as nat, |i: int| Seq::<int>::empty());
        add_edges_to_adj_list(adj, edges)
    } else {
        Seq::<Seq<int>>::empty()
    }
}

spec fn add_edges_to_adj_list(adj: Seq<Seq<int>>, edges: Seq<(int, int)>) -> Seq<Seq<int>>
    decreases edges.len()
{
    if adj.len() >= 1 {
        if edges.len() == 0 {
            adj
        } else {
            let e = edges[0];
            if 1 <= e.0 < adj.len() && 1 <= e.1 < adj.len() {
                let new_adj = adj.update(e.0, adj[e.0].push(e.1)).update(e.1, adj[e.1].push(e.0));
                add_edges_to_adj_list(new_adj, edges.subrange(1, edges.len() as int))
            } else {
                add_edges_to_adj_list(adj, edges.subrange(1, edges.len() as int))
            }
        }
    } else {
        adj
    }
}

spec fn bfs(adj: Seq<Seq<int>>, n: int, start: int, end: int) -> int {
    if n >= 1 && adj.len() == n + 1 && 1 <= start <= n && 1 <= end <= n {
        if start == end { 
            0 
        } else if adj[start].contains(end) { 
            1 
        } else if distance_is_2(adj, start, end) { 
            2 
        } else { 
            3 
        }
    } else {
        -1
    }
}

spec fn distance_is_2(adj: Seq<Seq<int>>, start: int, end: int) -> bool {
    if adj.len() > 0 && 0 <= start < adj.len() {
        exists|neighbor: int| adj[start].contains(neighbor) && 0 <= neighbor < adj.len() && adj[neighbor].contains(end)
    } else {
        false
    }
}

spec fn is_minimal_solution(n: int, original_edges: Seq<(int, int)>, num_edges_to_add: int) -> bool {
    valid_input(n, original_edges) ==> num_edges_to_add >= 0
}",,"fn solve(n: i8, edges: Vec<(i8, i8)>) -> (num_edges_to_add: i8)
    requires n >= 2,
             edges.len() == (n - 1) as nat,
             forall|i: int| 0 <= i < edges.len() ==> 1 <= edges[i].0 <= n && 1 <= edges[i].1 <= n && edges[i].0 != edges[i].1
    ensures valid_input(n as int, edges@.map_values(|e: (i8, i8)| (e.0 as int, e.1 as int))) ==> is_minimal_solution(n as int, edges@.map_values(|e: (i8, i8)| (e.0 as int, e.1 as int)), num_edges_to_add as int),
            all_vertices_within_distance2(n as int, edges@.map_values(|e: (i8, i8)| (e.0 as int, e.1 as int))) ==> num_edges_to_add >= 0","{
    assume(false);
    0
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0608,verus,apps,apps_test_4528,,"Calculate the number of minutes remaining until New Year (00:00) given the current time in 24-hour format.
Input is a sequence of (hour, minute) pairs representing current times.
Output is the corresponding minutes remaining until midnight for each test case.","use vstd::prelude::*;

verus! {

spec fn valid_input(test_cases: Seq<(int, int)>) -> bool {
    forall|i: int| 0 <= i < test_cases.len() ==> 
        #[trigger] test_cases[i].0 >= 0 && 
        test_cases[i].0 < 24 && 
        test_cases[i].1 >= 0 && 
        test_cases[i].1 < 60 && 
        !(test_cases[i].0 == 0 && test_cases[i].1 == 0)
}

spec fn minutes_until_midnight(h: int, m: int) -> int {
    1440 - (h * 60 + m)
}

spec fn valid_output(results: Seq<int>) -> bool {
    forall|i: int| 0 <= i < results.len() ==> 
        1 <= #[trigger] results[i] && results[i] <= 1439
}",,"fn solve(test_cases: Vec<(i8, i8)>) -> (results: Vec<i16>)
    requires 
        valid_input(test_cases@.map(|i: int, x: (i8, i8)| (x.0 as int, x.1 as int)))
    ensures 
        results.len() == test_cases.len(),
        forall|i: int| 0 <= i < results.len() ==> 
            #[trigger] results[i] as int == minutes_until_midnight(test_cases[i].0 as int, test_cases[i].1 as int),
        valid_output(results@.map(|i: int, x: i16| x as int))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0609,verus,apps,apps_test_4534,,"Given a non-negative integer k where 0 ≤ k ≤ 33, return the kth row of Pascal's triangle 
as a list of integers. Row indexing starts from 0. In Pascal's triangle, each element 
equals the sum of the two elements directly above it in the previous row.","use vstd::prelude::*;

verus! {

spec fn binomial(n: int, k: int) -> int
    decreases n when 0 <= k <= n
{
    if k == 0 || k == n { 1 }
    else if k == 1 { n }
    else { binomial(n-1, k-1) + binomial(n-1, k) }
}",,"fn get_row(k: u8) -> (result: Vec<u8>)
    requires k <= 33
    ensures 
        result.len() == k + 1,
        forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i] as int == binomial(k as int, i),
        forall|i: int| 0 <= i < result.len() ==> result[i] > 0,","{
    assume(false);
    Vec::new()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0610,verus,apps,apps_test_4538,,"Given N points in a 2D plane, count how many points are within distance D from the origin (0,0).
Distance is measured using Euclidean distance, and we check if distance <= D.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, d: int, points: Seq<(int, int)>) -> bool {
    n >= 0 && d >= 0 && points.len() >= n
}

spec fn within_distance(point: (int, int), d: int) -> bool {
    point.0 * point.0 + point.1 * point.1 <= d * d
}

spec fn count_points_within_distance(n: int, d: int, points: Seq<(int, int)>) -> int
    recommends valid_input(n, d, points)
{
    points.subrange(0, n).filter(|point: (int, int)| within_distance(point, d)).len() as int
}",,"fn solve(n: i8, d: i8, points: Vec<(i8, i8)>) -> (result: i8)
    requires 
        valid_input(n as int, d as int, points@.map_values(|p: (i8, i8)| (p.0 as int, p.1 as int))),
    ensures 
        0 <= result as int <= n as int,
        result as int == count_points_within_distance(n as int, d as int, points@.map_values(|p: (i8, i8)| (p.0 as int, p.1 as int)))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0611,verus,apps,apps_test_4539,,"Given an integer N, determine if N is divisible by the sum of its digits (when written in base 10).
Return ""Yes"" if N is divisible by the sum of its digits, otherwise return ""No"".","use vstd::prelude::*;

verus! {
spec fn sum_of_digits(n: int) -> int
  decreases n
{
  if n <= 0 {
    0
  } else {
    (n % 10) + sum_of_digits(n / 10)
  }
}

spec fn valid_input(n: int) -> bool {
  n >= 1
}

spec fn is_divisible_by_digit_sum(n: int) -> bool {
  n >= 1 && sum_of_digits(n) > 0 && n % sum_of_digits(n) == 0
}",,"fn solve(n: i8) -> (result: &'static str)
  requires valid_input(n as int)","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVA04,0.85
VA0612,verus,apps,apps_test_4541,,"Given a single lowercase English letter, determine if it is a vowel (a, e, i, o, u) or consonant.
Return ""vowel"" if the letter is a vowel, otherwise return ""consonant"".","use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    input.len() == 1 && 'a' <= input[0] && input[0] <= 'z'
}

spec fn is_vowel(c: char) -> bool {
    c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'
}

spec fn expected_output(input: Seq<char>) -> Seq<char>
    recommends valid_input(input)
{
    if is_vowel(input[0]) { seq!['v', 'o', 'w', 'e', 'l'] } else { seq!['c', 'o', 'n', 's', 'o', 'n', 'a', 'n', 't'] }
}",,"fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires 
        valid_input(input@),
    ensures 
        result@ == expected_output(input@),
        result@ == seq!['v', 'o', 'w', 'e', 'l'] || result@ == seq!['c', 'o', 'n', 's', 'o', 'n', 'a', 'n', 't'],","{
    /* impl-start */
    assume(false);
    unreached()
    /* impl-end */
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0613,verus,apps,apps_test_4542,,"Given a string of stones ('B' for black, 'W' for white), find the minimum number 
of stones to place at either end to make all stones the same color. When placing 
a stone, all stones of opposite color between the new stone and the nearest 
existing stone of the same color are flipped.","use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> s[i] == 'B' || s[i] == 'W'
}

spec fn count_segments(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() <= 1 {
        1int
    } else {
        count_segments(s.subrange(0, s.len() - 1)) + 
        (if s[s.len() - 1] != s[s.len() - 2] { 1int } else { 0int })
    }
}",,"fn solve(s: Vec<char>) -> (result: i8)
    requires 
        valid_input(s@),
    ensures 
        result >= 0,
        result as int == count_segments(s@) - 1,
        result as int <= s.len() - 1,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0614,verus,apps,apps_test_4543,,"Given two positive integers a and b, determine whether their string concatenation 
(a followed by b) forms a perfect square number. Return ""Yes"" if it's a perfect 
square, ""No"" otherwise.","use vstd::prelude::*;
use vstd::string::*;

verus! {

spec fn is_perfect_square(n: int) -> bool
  recommends n >= 0
{
  exists|sqrt_n: int| sqrt_n >= 0 && #[trigger] (sqrt_n * sqrt_n) == n
}
/* Helper functions for string/int conversion - these would need implementation */
fn int_to_string(n: int) -> (result: String)
  requires n >= 0
  ensures result@.len() > 0
{
  assume(false);
  unreached()
}

fn string_to_int(s: String) -> (result: int)
  requires s@.len() > 0
  ensures result >= 0
{
  assume(false);
  unreached()
}",,"fn solve(a: i8, b: i8) -> (result: String)
  requires a as int >= 1 && a as int <= 100,
           b as int >= 1 && b as int <= 100
  ensures result@ == ""Yes""@ || result@ == ""No""@","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0615,verus,apps,apps_test_4545,,"Given an N×N grid with N² total squares where A squares are painted white,
determine how many squares are painted black (N² - A).","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, a: int) -> bool {
    1 <= n <= 100 && 0 <= a <= n * n
}

spec fn black_squares(n: int, a: int) -> int
    recommends valid_input(n, a)
{
    n * n - a
}

spec fn valid_output(n: int, a: int, result: int) -> bool
    recommends valid_input(n, a)
{
    result == black_squares(n, a) && result >= 0
}",,"fn calculate_black_squares(n: i8, a: i8) -> (black_squares: i8)
    requires valid_input(n as int, a as int)
    ensures valid_output(n as int, a as int, black_squares as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0617,verus,apps,apps_test_4547,,"Given a two-digit integer N (10 ≤ N ≤ 99), determine whether the digit 9 appears 
in the decimal representation of N. Return ""Yes"" if 9 appears, ""No"" otherwise.","use vstd::prelude::*;

verus! {
spec fn clean_input(s: Seq<char>) -> Seq<char>
    decreases s.len()
{
    if s.len() == 0 { 
        s
    } else if s[s.len() - 1] == '\n' || s[s.len() - 1] == '\r' || s[s.len() - 1] == ' ' { 
        clean_input(s.subrange(0, s.len() - 1))
    } else { 
        s
    }
}

spec fn contains_digit_nine(s: Seq<char>) -> bool {
    exists|i: int| 0 <= i < s.len() && s[i] == '9'
}",,"fn solve(stdin_input: &str) -> (result: String)
    requires stdin_input@.len() > 0
    ensures 
        result@ == seq!['Y', 'e', 's', '\n'] || result@ == seq!['N', 'o', '\n'],
        result@ == seq!['Y', 'e', 's', '\n'] <==> contains_digit_nine(clean_input(stdin_input@)),
        result@ == seq!['N', 'o', '\n'] <==> !contains_digit_nine(clean_input(stdin_input@))","{
    assume(false);
    ""No\n"".to_string()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0619,verus,apps,apps_test_4551,,"Given four integer weights A, B, C, D, determine the direction a balance scale tips when:
- Left pan contains masses with weights A and B  
- Right pan contains masses with weights C and D
Compare the total weights on each side and output ""Left"", ""Right"", or ""Balanced""","use vstd::prelude::*;

verus! {

spec fn valid_parseable(input: Seq<char>) -> bool {
    let parts = split_string_pure(input);
    parts.len() >= 4
}

spec fn all_parts_are_integers(input: Seq<char>) -> bool {
    let parts = split_string_pure(input);
    parts.len() >= 4 &&
    is_valid_integer(parts[0]) &&
    is_valid_integer(parts[1]) &&
    is_valid_integer(parts[2]) &&
    is_valid_integer(parts[3])
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    s.len() > 0 && (forall|i: int| 0 <= i < s.len() ==> ('0' <= s[i] <= '9') || (i == 0 && s[i] == '-'))
}

spec fn valid_parse(input: Seq<char>, a: int, b: int, c: int, d: int) -> bool {
    let parts = split_string_pure(input);
    parts.len() >= 4 && 
    is_valid_integer(parts[0]) &&
    is_valid_integer(parts[1]) &&
    is_valid_integer(parts[2]) &&
    is_valid_integer(parts[3]) &&
    string_to_int_pure(parts[0]) == a &&
    string_to_int_pure(parts[1]) == b &&
    string_to_int_pure(parts[2]) == c &&
    string_to_int_pure(parts[3]) == d
}

spec fn split_string_pure(s: Seq<char>) -> Seq<Seq<char>>
    decreases s.len()
{
    split_string_helper(s, 0, seq![], seq![])
}

spec fn split_string_helper(s: Seq<char>, i: int, current: Seq<char>, acc: Seq<Seq<char>>) -> Seq<Seq<char>>
    decreases s.len() - i
{
    if i < 0 || i > s.len() {
        acc
    } else if i == s.len() {
        if current.len() > 0 { acc.push(current) } else { acc }
    } else if s[i] == ' ' || s[i] == '\n' || s[i] == '\t' {
        if current.len() > 0 {
            split_string_helper(s, i + 1, seq![], acc.push(current))
        } else {
            split_string_helper(s, i + 1, seq![], acc)
        }
    } else {
        split_string_helper(s, i + 1, current.push(s[i]), acc)
    }
}

spec fn string_to_int_pure(s: Seq<char>) -> int {
    if !is_valid_integer(s) {
        0
    } else if s.len() > 0 && s[0] == '-' {
        -string_to_int_helper_unsigned(s, 1, 0)
    } else {
        string_to_int_helper_unsigned(s, 0, 0)
    }
}

spec fn string_to_int_helper_unsigned(s: Seq<char>, i: int, acc: int) -> int
    decreases s.len() - i
{
    if i < 0 || i >= s.len() {
        acc
    } else if '0' <= s[i] <= '9' {
        string_to_int_helper_unsigned(s, i + 1, acc * 10 + (s[i] as int - '0' as int))
    } else {
        acc
    }
}",,"fn solve(input: &str) -> (result: String)
    ensures 
        (forall|a: int, b: int, c: int, d: int| 
            valid_parse(input@, a, b, c, d) ==> 
            ((result@ == ""Left\n""@) <==> (a + b > c + d)) &&
            ((result@ == ""Right\n""@) <==> (a + b < c + d)) &&
            ((result@ == ""Balanced\n""@) <==> (a + b == c + d))) &&
        (valid_parseable(input@) && all_parts_are_integers(input@) ==> 
            (result@ == ""Left\n""@ || result@ == ""Right\n""@ || result@ == ""Balanced\n""@)) &&
        ((!valid_parseable(input@) || !all_parts_are_integers(input@)) ==> result@ == """"@)","{
    assume(false);
    """".to_string()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0620,verus,apps,apps_test_4553,,"Given integers A and B, and a string S of length A+B+1, determine if S follows 
the postal code format where the character at position A+1 (1-indexed) is a hyphen '-'
and all other characters are digits 0-9.","use vstd::prelude::*;

verus! {
spec fn valid_postal_code(a: int, b: int, s: Seq<char>) -> bool
    recommends a >= 1 && b >= 1 && a <= 5 && b <= 5,
              s.len() == a + b + 1,
              forall|i: int| 0 <= i < s.len() ==> (s[i] == '-' || ('0' <= s[i] <= '9'))
{
    s[a] == '-' && forall|i: int| 0 <= i < s.len() && i != a ==> s[i] != '-'
}",,"fn solve(a: i8, b: i8, s: Vec<char>) -> (result: Vec<char>)
    requires a as int >= 1 && b as int >= 1,
             a as int <= 5 && b as int <= 5,
             s@.len() == a as int + b as int + 1,
             forall|i: int| 0 <= i < s@.len() ==> (s@[i] == '-' || ('0' <= s@[i] <= '9'))
    ensures result@.len() >= 2,
            (result@ =~= seq!['Y', 'e', 's']) || (result@ =~= seq!['N', 'o']),
            (result@ =~= seq!['Y', 'e', 's']) <==> valid_postal_code(a as int, b as int, s@)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0621,verus,apps,apps_test_4554,,"Given two rectangles with width W, where Rectangle 1 spans horizontally [a, a+W] 
and Rectangle 2 spans horizontally [b, b+W], find the minimum horizontal distance 
Rectangle 2 must be moved so that the two rectangles connect (overlap or touch).","use vstd::prelude::*;

verus! {

spec fn valid_input(w: int, a: int, b: int) -> bool {
    w >= 1 && a >= 1 && b >= 1
}

spec fn abs_diff(x: int, y: int) -> int {
    if x >= y { x - y } else { y - x }
}

spec fn min_move_distance(w: int, a: int, b: int) -> int
    recommends valid_input(w, a, b)
{
    let distance = abs_diff(a, b);
    if distance <= w { 0 }
    else { distance - w }
}

spec fn rectangles_connect(w: int, a: int, b: int) -> bool
    recommends valid_input(w, a, b)
{
    abs_diff(a, b) <= w
}",,"fn solve(w: i8, a: i8, b: i8) -> (result: i8)
    requires valid_input(w as int, a as int, b as int)
    ensures 
        result as int == min_move_distance(w as int, a as int, b as int) &&
        result >= 0 &&
        (rectangles_connect(w as int, a as int, b as int) <==> result == 0)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0622,verus,apps,apps_test_4556,,"Given a contest name in the format ""AtCoder s Contest"" where s is a string of length 1 to 100 characters 
starting with an uppercase English letter followed by lowercase English letters, output the abbreviation ""AxC"" 
where x is the first character of s.

/* Minimum: ""AtCoder X Contest\n"" */

/* Input ends with newline */

/* Middle word is non-empty */

/* First char is uppercase */

/* Rest are lowercase */

/* ""AxC\n"" format */

/* Second char is first char of middle word */","use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool 
    decreases input.len()
{
    &&& input.len() >= 18
    &&& input[input.len() as int - 1] == '\n'
    &&& input.subrange(0, 7) == seq!['A', 't', 'C', 'o', 'd', 'e', 'r']
    &&& input[7] == ' '
    &&& exists|space_pos: int| 8 <= space_pos < input.len() - 8 && 
        #[trigger] input.index(space_pos) == ' ' && 
        input.subrange(space_pos + 1, space_pos + 8) == seq!['C', 'o', 'n', 't', 'e', 's', 't'] &&
        space_pos + 8 == input.len() - 1
    &&& exists|space_pos: int| 8 <= space_pos < input.len() - 8 && 
        #[trigger] input.index(space_pos) == ' ' && 
        space_pos > 8 &&
        'A' <= input[8] <= 'Z' &&
        forall|k: int| 9 <= k < space_pos ==> 'a' <= #[trigger] input.index(k) <= 'z'
}

spec fn valid_output(input: Seq<char>, result: Seq<char>) -> bool 
    decreases input.len()
{
    &&& result.len() == 4
    &&& result[0] == 'A'
    &&& result[2] == 'C'
    &&& result[3] == '\n'
    &&& exists|space_pos: int| 8 <= space_pos < input.len() - 8 && 
        #[trigger] input.index(space_pos) == ' ' && 
        result[1] == input[8]
}",,"fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(input@)
    ensures valid_output(input@, result@)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0623,verus,apps,apps_test_4557,,"Given A animals that are definitely cats and B animals of unknown type (could be cats or dogs),
determine if it's possible to have exactly X cats in total among the A + B animals.","use vstd::prelude::*;

verus! {
spec fn valid_input(a: int, b: int, x: int) -> bool {
    1 <= a <= 100 && 1 <= b <= 100 && 1 <= x <= 200
}

spec fn can_have_exactly_cats(a: int, b: int, x: int) -> bool {
    a <= x <= a + b
}",,"fn solve(a: i8, b: i8, x: i8) -> (result: String)
    requires valid_input(a as int, b as int, x as int)
    ensures result@ =~= seq!['Y', 'E', 'S'] <==> can_have_exactly_cats(a as int, b as int, x as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0624,verus,apps,apps_test_4560,,"Given A 1-yen coins and unlimited 500-yen coins, determine if you can pay exactly N yen.
Return ""Yes"" if exact payment is possible, ""No"" otherwise.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, a: int) -> bool {
    1 <= n <= 10000 && 0 <= a <= 1000
}

spec fn can_pay_exactly(n: int, a: int) -> bool {
    n % 500 <= a
}

spec fn valid_output(result: String) -> bool {
    result@ == ""Yes""@ || result@ == ""No""@
}",,"fn solve(n: i8, a: i8) -> (result: String)
    requires 
        valid_input(n as int, a as int)
    ensures 
        valid_output(result) &&
        ((result@ == ""Yes""@) <==> can_pay_exactly(n as int, a as int))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0625,verus,apps,apps_test_4561,,"Given three integers X, A, and B where X is the maximum number of days past 
best-by date that won't cause stomachache, A is the number of days before 
best-by date when food was bought, and B is the number of days after purchase 
when food was eaten. Determine if eating the food results in ""delicious"", 
""safe"", or ""dangerous"" outcome.","use vstd::prelude::*;

verus! {
spec fn valid_outcome(outcome: &str) -> bool {
    outcome == ""delicious"" || outcome == ""safe"" || outcome == ""dangerous""
}

spec fn days_past_best_by(a: int, b: int) -> int {
    b - a
}

spec fn expected_outcome(x: int, a: int, b: int) -> &'static str {
    let days_past = days_past_best_by(a, b);
    if days_past <= 0 {
        ""delicious""
    } else if days_past <= x {
        ""safe""
    } else {
        ""dangerous""
    }
}",,"fn determine_food_safety(x: i8, a: i8, b: i8) -> (outcome: &'static str)
    requires 
        x as int >= 0,
    ensures 
        outcome == expected_outcome(x as int, a as int, b as int),
        valid_outcome(outcome),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0626,verus,apps,apps_test_4567,,"Given N questions with scores, find the maximum possible sum of a subset 
such that the sum is NOT a multiple of 10. If no such sum exists, return 0.","use vstd::prelude::*;

verus! {
spec fn valid_input(scores: Seq<int>) -> bool {
    scores.len() > 0 && scores.len() <= 100 &&
    forall|i: int| 0 <= i < scores.len() ==> #[trigger] scores[i] >= 1 && #[trigger] scores[i] <= 100
}

spec fn sum_seq(scores: Seq<int>) -> int
    decreases scores.len()
{
    if scores.len() == 0 {
        0
    } else {
        scores[0] + sum_seq(scores.subrange(1, scores.len() as int))
    }
}

spec fn all_multiples_of_10(scores: Seq<int>) -> bool {
    forall|i: int| 0 <= i < scores.len() ==> #[trigger] scores[i] % 10 == 0
}

spec fn is_smallest_non_multiple(scores: Seq<int>, value: int) -> bool {
    scores.contains(value) && 
    value % 10 != 0 &&
    forall|x: int| #[trigger] scores.contains(x) && x % 10 != 0 ==> value <= x
}

spec fn correct_result(scores: Seq<int>, result: int) -> bool {
    let total_sum = sum_seq(scores);
    if total_sum % 10 != 0 {
        result == total_sum
    } else if all_multiples_of_10(scores) {
        result == 0
    } else {
        exists|smallest_non_multiple: int| 
            is_smallest_non_multiple(scores, smallest_non_multiple) &&
            result == total_sum - smallest_non_multiple
    }
}",,"fn solve(scores: Vec<i8>) -> (result: i8)
    requires valid_input(scores@.map(|i, x| x as int))
    ensures correct_result(scores@.map(|i, x| x as int), result as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0627,verus,apps,apps_test_4569,,"Given today's weather from a 3-day repeating cycle (Sunny → Cloudy → Rainy → Sunny → ...), determine tomorrow's weather.","use vstd::prelude::*;

verus! {
spec fn valid_weather(weather: Seq<char>) -> bool {
    weather == ""Sunny""@ || weather == ""Cloudy""@ || weather == ""Rainy""@
}

spec fn trim_newline(input: Seq<char>) -> Seq<char> {
    if input.len() > 0 && input[input.len() as int - 1] == '\n' {
        input.subrange(0, input.len() as int - 1)
    } else {
        input
    }
}

spec fn next_weather(weather: Seq<char>) -> Seq<char>
    recommends valid_weather(weather)
{
    if weather == ""Sunny""@ { ""Cloudy""@ }
    else if weather == ""Cloudy""@ { ""Rainy""@ }
    else { ""Sunny""@ }
}",,"fn solve(input: String) -> (result: String)
    ensures ({
        let trimmed = trim_newline(input@);
        if valid_weather(trimmed) {
            result@ == next_weather(trimmed) + seq!['\n']
        } else {
            result@ == Seq::<char>::empty()
        }
    })","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0628,verus,apps,apps_test_4570,,"Given two parking fee plans:
- Plan 1: A yen per hour (total: A×N yen for N hours)
- Plan 2: B yen flat rate (regardless of duration)
Find the minimum cost to park for N hours.
Input: Three integers N, A, B where N is parking duration in hours (1 ≤ N ≤ 20),
A is hourly rate for Plan 1 (1 ≤ A ≤ 100), and B is flat rate for Plan 2 (1 ≤ B ≤ 2000).
Output: The minimum parking fee (integer)","use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    true /* Simplified for now */
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    s.len() > 0
}

spec fn split_string_func(s: Seq<char>) -> Seq<Seq<char>> {
    seq![seq!['1'], seq!['2'], seq!['3']] /* Simplified for now */
}

spec fn string_to_int_func(s: Seq<char>) -> int {
    if s.len() > 0 && s[0] == '1' { 1 }
    else if s.len() > 0 && s[0] == '2' { 2 }
    else if s.len() > 0 && s[0] == '3' { 3 }
    else { 0 }
}

spec fn int_to_string_func(n: int) -> Seq<char> {
    if n == 0 { seq!['0'] }
    else if n == 1 { seq!['1'] }
    else if n == 2 { seq!['2'] }
    else if n == 3 { seq!['3'] }
    else { seq!['0'] }
}

spec fn min_parking_cost(n: int, a: int, b: int) -> int {
    let plan1_cost = n * a;
    let plan2_cost = b;
    if plan1_cost <= plan2_cost { plan1_cost } else { plan2_cost }
}",,"fn solve(input: Seq<char>) -> (result: Seq<char>)
    requires
        input.len() > 0,
        valid_input(input),
    ensures
        ({
            let parts = split_string_func(input);
            let n = string_to_int_func(parts[0]);
            let a = string_to_int_func(parts[1]);
            let b = string_to_int_func(parts[2]);
            result == int_to_string_func(min_parking_cost(n, a, b)) + seq!['\n']
        })","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0629,verus,apps,apps_test_4571,,"Given N test cases where M are ""hard"" (1900ms each, 1/2 success probability) 
and (N-M) are ""easy"" (100ms each, always succeed), find the expected total 
execution time across all submissions until one submission succeeds.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, m: int) -> bool {
    1 <= n <= 100 && 1 <= m <= n && m <= 5
}

spec fn power(base: int, exp: int) -> int
    decreases exp when exp >= 0
{
    if exp <= 0 { 1 } else { base * power(base, exp - 1) }
}

spec fn expected_time(n: int, m: int) -> int {
    (1900 * m + 100 * (n - m)) * power(2, m)
}",,"fn solve(n: i8, m: i8) -> (result: i8)
    requires valid_input(n as int, m as int)
    ensures result as int == expected_time(n as int, m as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0630,verus,apps,apps_test_4575,,"Given N participants in a D-day training camp, where participant i eats chocolate on days 1, A_i+1, 2×A_i+1, 3×A_i+1, etc. 
(i.e., day 1 and then every A_i days thereafter). At the end of the camp, X chocolate pieces remain. 
Find the total number of chocolate pieces prepared initially.","use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    let lines = split_str(input, '\n');
    lines.len() >= 2 &&
    parse_int(lines[0]) >= 1 &&
    {
        let n = parse_int(lines[0]);
        let second_line_parts = split_str(lines[1], ' ');
        second_line_parts.len() >= 2 &&
        parse_int(second_line_parts[0]) >= 1 &&
        parse_int(second_line_parts[1]) >= 0 &&
        lines.len() >= 2 + n &&
        forall|i: int| 0 <= i < n ==> #[trigger] parse_int(lines[2 + i]) >= 1
    }
}

spec fn compute_expected_result(input: Seq<char>) -> Seq<char>
    recommends valid_input(input)
{
    let lines = split_str(input, '\n');
    let n = parse_int(lines[0]);
    let second_line_parts = split_str(lines[1], ' ');
    let d = parse_int(second_line_parts[0]);
    let x = parse_int(second_line_parts[1]);
    let total_eaten = sum_eaten_for_participants(lines, d, n);
    int_to_string(x + total_eaten)
}

spec fn sum_eaten_for_participants(lines: Seq<Seq<char>>, d: int, count: int) -> int 
    recommends lines.len() >= 2 + count && d >= 1 && count >= 0
    decreases count
    when count >= 0
{
    if count == 0 {
        0
    } else {
        let a = parse_int(lines[2 + count - 1]);
        let eaten = if a > 0 { (d + a - 1) / a } else { 0 };
        eaten + sum_eaten_for_participants(lines, d, count - 1)
    }
}

spec fn split_str(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> {
    if s.len() == 0 {
        seq![]
    } else {
        split_helper(s, delimiter, 0, 0, seq![])
    }
}

spec fn split_helper(s: Seq<char>, delimiter: char, start: int, current: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>>
    recommends 0 <= start <= current <= s.len()
    decreases s.len() - current
    when 0 <= current <= s.len()
{
    if current == s.len() {
        if start == current {
            acc
        } else {
            acc.push(s.subrange(start, current))
        }
    } else if s[current] == delimiter {
        split_helper(s, delimiter, current + 1, current + 1, acc.push(s.subrange(start, current)))
    } else {
        split_helper(s, delimiter, start, current + 1, acc)
    }
}

spec fn parse_int(s: Seq<char>) -> int {
    if s.len() == 0 {
        0
    } else {
        parse_int_helper(s, 0, 0)
    }
}

spec fn parse_int_helper(s: Seq<char>, index: int, acc: int) -> int
    recommends 0 <= index <= s.len()
    decreases s.len() - index
    when 0 <= index <= s.len()
{
    if index == s.len() {
        acc
    } else if '0' <= s[index] <= '9' {
        parse_int_helper(s, index + 1, acc * 10 + (s[index] as int - '0' as int))
    } else {
        acc
    }
}

spec fn int_to_string(n: int) -> Seq<char> {
    if n == 0 {
        seq!['0']
    } else if n < 0 {
        seq!['-'] + int_to_string_helper(-n)
    } else {
        int_to_string_helper(n)
    }
}

spec fn int_to_string_helper(n: int) -> Seq<char>
    recommends n > 0
    decreases n
    when n > 0
{
    if n < 10 {
        seq![(n + '0' as int) as char]
    } else {
        int_to_string_helper(n / 10) + seq![(n % 10 + '0' as int) as char]
    }
}",,"fn solve(input: &str) -> (result: String)
    requires
        input@.len() > 0,
        valid_input(input@),
    ensures
        result@.len() > 0,
        result@ == compute_expected_result(input@),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0631,verus,apps,apps_test_4579,,"Given N strings, count the number of distinct strings.
Input: A sequence of strings (length >= 1)
Output: Integer representing the count of distinct strings","use vstd::prelude::*;

verus! {
spec fn distinct_strings(strings: Seq<String>) -> Set<String> {
    Set::new(|s: String| exists|i: int| 0 <= i < strings.len() && strings[i] == s)
}

spec fn valid_input(strings: Seq<String>) -> bool {
    strings.len() >= 1
}",,"fn solve(strings: Vec<String>) -> (count: i8)
    requires 
        valid_input(strings@)
    ensures 
        count as int >= 1,
        count as int <= strings@.len(),
        count as int == distinct_strings(strings@).len()","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0632,verus,apps,apps_test_4581,,"Calculate the price of a bowl of ramen based on selected toppings.
Base price is 700 yen, each topping ('o') adds 100 yen.
Input is a 3-character string with 'o' (included) or 'x' (not included).","use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>) -> bool {
    s.len() == 3 && forall|i: int| 0 <= i < s.len() ==> s[i] == 'o' || s[i] == 'x'
}

spec fn count_o(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0int
    } else {
        (if s[0] == 'o' { 1int } else { 0int }) + count_o(s.subrange(1, s.len() as int))
    }
}

spec fn calculate_price(s: Seq<char>) -> int
    recommends valid_input(s)
{
    count_o(s) * 100int + 700int
}

spec fn int_to_string_spec(n: int) -> Seq<char>
    recommends n >= 0
{
    if n == 0 {
        seq!['0']
    } else {
        int_to_string_helper_spec(n, seq![])
    }
}

spec fn int_to_string_helper_spec(n: int, acc: Seq<char>) -> Seq<char>
    recommends n >= 0
    decreases n
    when n >= 0
{
    if n == 0 {
        acc
    } else {
        int_to_string_helper_spec(n / 10, seq![((n % 10) + 48) as char] + acc)
    }
}",,"fn solve(s: Vec<char>) -> (result: Vec<char>)
    requires 
        valid_input(s@)
    ensures 
        result@ == int_to_string_spec(calculate_price(s@)) + seq!['\n'],
        calculate_price(s@) >= 700","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0633,verus,apps,apps_test_4582,,"Given two characters representing AtCoDeer's honesty status and claim about TopCoDeer,
determine whether TopCoDeer is actually honest or dishonest.
An honest player tells the truth, a dishonest player lies.","use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    input.len() >= 3 &&
    input[1] == ' ' &&
    (input[0] == 'H' || input[0] == 'D') &&
    (input[2] == 'H' || input[2] == 'D') &&
    (input.len() == 3 || (input.len() > 3 && input[3] == '\n'))
}

spec fn correct_output(input: Seq<char>) -> Seq<char> {
    if (input[0] == 'H' && input[2] == 'H') || (input[0] == 'D' && input[2] == 'D') {
        seq!['H', '\n']
    } else {
        seq!['D', '\n']
    }
}",,"fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(input@)
    ensures result@ == correct_output(input@)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0634,verus,apps,apps_test_4583,,"Given a 4-digit string ABCD, find operators op1, op2, op3 (each + or -) such that
A op1 B op2 C op3 D = 7. Return the complete equation as ""A op1 B op2 C op3 D=7"".","use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    input.len() == 5 && input.subrange(0, 4).len() == 4 &&
    (forall|i: int| 0 <= i < 4 ==> ('0' <= #[trigger] input[i] <= '9')) &&
    input[4] == '\n'
}

spec fn char_to_digit(c: char) -> int {
    (c as int) - ('0' as int)
}

spec fn evaluate_expression(a: int, b: int, c: int, d: int, op1: char, op2: char, op3: char) -> int {
    let b_val = if op1 == '+' { b } else { -b };
    let c_val = if op2 == '+' { c } else { -c };
    let d_val = if op3 == '+' { d } else { -d };
    a + b_val + c_val + d_val
}

spec fn solution_exists(input: Seq<char>) -> bool {
    &&& valid_input(input)
    &&& {
        let a = char_to_digit(input[0]);
        let b = char_to_digit(input[1]);
        let c = char_to_digit(input[2]);
        let d = char_to_digit(input[3]);
        exists|op1: char, op2: char, op3: char| 
            (op1 == '+' || op1 == '-') &&
            (op2 == '+' || op2 == '-') &&
            (op3 == '+' || op3 == '-') &&
            evaluate_expression(a, b, c, d, op1, op2, op3) == 7
    }
}

spec fn valid_output(result: Seq<char>, input: Seq<char>) -> bool {
    &&& valid_input(input)
    &&& result.len() == 10 
    &&& result.subrange(7, 9) =~= seq!['=', '7']
    &&& result[9] == '\n'
    &&& result[0] == input[0] && result[2] == input[1] 
    &&& result[4] == input[2] && result[6] == input[3]
    &&& (result[1] == '+' || result[1] == '-')
    &&& (result[3] == '+' || result[3] == '-')
    &&& (result[5] == '+' || result[5] == '-')
    &&& {
        let a = char_to_digit(input[0]);
        let b = char_to_digit(input[1]);
        let c = char_to_digit(input[2]);
        let d = char_to_digit(input[3]);
        evaluate_expression(a, b, c, d, result[1], result[3], result[5]) == 7
    }
}",,"fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires 
        valid_input(input@),
        solution_exists(input@),
    ensures valid_output(result@, input@)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0635,verus,apps,apps_test_4584,,"Given N company members with ID numbers 1 to N, where each member (except member 1) has exactly one immediate boss with a smaller ID number.
For member i (where i > 1), their immediate boss is member A_i. Count the number of immediate subordinates for each member.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, aa: Seq<int>) -> bool {
    n >= 2 &&
    aa.len() == n - 1 &&
    forall|i: int| 0 <= i < aa.len() ==> #[trigger] aa[i] >= 1 && #[trigger] aa[i] < i + 2
}

spec fn subordinate_count(aa: Seq<int>, boss_id: int) -> int {
    Set::new(|j: int| 0 <= j < aa.len() && aa[j] == boss_id).len() as int
}

spec fn valid_output(n: int, aa: Seq<int>, result: Seq<int>) -> bool {
    result.len() == n &&
    forall|i: int| 0 <= i < n ==> #[trigger] result[i] >= 0 &&
    forall|i: int| 0 <= i < n ==> #[trigger] result[i] == subordinate_count(aa, i + 1)
}",,"fn solve(n: i8, aa: Vec<i8>) -> (result: Vec<i8>)
    requires valid_input(n as int, aa@.map(|i, x| x as int))
    ensures valid_output(n as int, aa@.map(|i, x| x as int), result@.map(|i, x| x as int))","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0636,verus,apps,apps_test_4585,,"Find the minimum time needed for a kangaroo to reach position X on a number line.
The kangaroo starts at position 0 at time 0. At each time step i (i = 1, 2, 3, ...),
the kangaroo can stay at current position or jump exactly i units left or right.","use vstd::prelude::*;

verus! {
spec fn valid_input(x: int) -> bool {
    x >= 1
}

spec fn triangular_number(n: int) -> int
    recommends n >= 0
{
    n * (n + 1) / 2
}

spec fn is_minimal_time(t: int, x: int) -> bool
    recommends x >= 1
{
    t >= 1 && 
    triangular_number(t) >= x &&
    (t == 1 || triangular_number(t - 1) < x)
}",,"fn solve(x: i8) -> (result: i8)
    requires valid_input(x as int)
    ensures is_minimal_time(result as int, x as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0637,verus,apps,apps_test_4586,,"Given a 4-digit integer N, determine if it is ""good"". 
A 4-digit integer is ""good"" if it contains three or more consecutive identical digits.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int) -> bool {
    1000 <= n <= 9999
}

spec fn extract_digits(n: int) -> (int, int, int, int) {
    let d1 = n / 1000;
    let d2 = (n / 100) % 10;
    let d3 = (n / 10) % 10;
    let d4 = n % 10;
    (d1, d2, d3, d4)
}

spec fn is_good(n: int) -> bool {
    let (d1, d2, d3, d4) = extract_digits(n);
    (d1 == d2 && d2 == d3) || (d2 == d3 && d3 == d4)
}",,"fn solve(n: i8) -> (result: bool)
    requires 
        valid_input(n as int),
    ensures 
        result <==> is_good(n as int),","{
    assume(false);
    false
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0638,verus,apps,apps_test_4588,,"Given two hexadecimal digits X and Y (each being one of A, B, C, D, E, or F representing values 10, 11, 12, 13, 14, 15 respectively), 
compare their values and output the comparison result: ""<"" if X < Y, "">"" if X > Y, ""="" if X = Y.","use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    (input.len() == 3 && input[1] == ' ') || 
    (input.len() == 4 && input[1] == ' ' && input[3] == '\n')
}

spec fn valid_hex_digit(c: char) -> bool {
    c == 'A' || c == 'B' || c == 'C' || c == 'D' || c == 'E' || c == 'F'
}

spec fn valid_input_format(input: Seq<char>) -> bool {
    input.len() >= 3 &&
    valid_input(input) &&
    valid_hex_digit(input[0]) &&
    valid_hex_digit(input[2])
}

spec fn correct_comparison(x: char, y: char, result: Seq<char>) -> bool {
    (result == seq!['<', '\n'] || result == seq!['>', '\n'] || result == seq!['=', '\n']) &&
    (((x as int) < (y as int)) <==> (result == seq!['<', '\n'])) &&
    (((x as int) > (y as int)) <==> (result == seq!['>', '\n'])) &&
    (((x as int) == (y as int)) <==> (result == seq!['=', '\n']))
}",,"fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)
    requires valid_input_format(stdin_input@)
    ensures correct_comparison(stdin_input@[0], stdin_input@[2], result@)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0639,verus,apps,apps_test_4594,,"Given N mochi with diameters, find the maximum number of layers in a kagami mochi.
A kagami mochi is a stack where each layer has a strictly smaller diameter than the layer below it.
This is equivalent to counting the number of distinct diameters in the input.","use vstd::prelude::*;

verus! {
spec fn valid_input(diameters: Seq<int>) -> bool {
    diameters.len() > 0 && forall|i: int| 0 <= i < diameters.len() ==> diameters[i] > 0
}

spec fn num_distinct(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if s.subrange(1, s.len() as int).contains(s[0]) {
        num_distinct(s.subrange(1, s.len() as int))
    } else {
        1 + num_distinct(s.subrange(1, s.len() as int))
    }
}",,"fn solve(diameters: Vec<i8>) -> (result: i8)
    requires 
        valid_input(diameters@.map(|i, x| x as int)),
    ensures 
        result as int == num_distinct(diameters@.map(|i, x| x as int)),
        result as int >= 1,
        result as int <= diameters@.len(),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0641,verus,apps,apps_test_4603,,"Given costs of ordinary and unlimited tickets for train and bus travel,
find the minimum total fare by choosing the cheaper option for each mode.","use vstd::prelude::*;

verus! {
spec fn valid_input(a: int, b: int, c: int, d: int) -> bool {
    1 <= a <= 1000 && 1 <= b <= 1000 && 1 <= c <= 1000 && 1 <= d <= 1000
}

spec fn min_total_fare(a: int, b: int, c: int, d: int) -> int {
    (if a < b { a } else { b }) + (if c < d { c } else { d })
}",,"fn solve(a: i8, b: i8, c: i8, d: i8) -> (result: i8)
    requires valid_input(a as int, b as int, c as int, d as int)
    ensures result as int == min_total_fare(a as int, b as int, c as int, d as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0642,verus,apps,apps_test_4605,,Find the sum of all integers i where 1 ≤ i ≤ N and the sum of digits of i (in base 10) is between A and B inclusive.,"use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, a: int, b: int) -> bool {
    n >= 1 && a >= 1 && a <= b && b <= 36
}

spec fn digit_sum(n: int) -> int 
    decreases n
{
    if n <= 0 { 0 }
    else { (n % 10) + digit_sum(n / 10) }
}

spec fn sum_in_range(n: int, a: int, b: int) -> int
    decreases n
{
    if n <= 0 { 0 }
    else if a <= digit_sum(n) && digit_sum(n) <= b { 
        n + sum_in_range(n - 1, a, b) 
    }
    else { 
        sum_in_range(n - 1, a, b) 
    }
}",,"fn solve(n: i8, a: i8, b: i8) -> (result: i8)
    requires valid_input(n as int, a as int, b as int)
    ensures 
        result as int == sum_in_range(n as int, a as int, b as int) &&
        result >= 0","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0643,verus,apps,apps_test_4606,,"Given an integer N where 100 ≤ N ≤ 999, return the string ""ABC"" concatenated with the string representation of N.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int) -> bool {
    100 <= n <= 999
}

spec fn valid_output(n: int, result: Seq<char>) -> bool
    recommends valid_input(n)
{
    result.len() == 6 && result.subrange(0, 3) == seq!['A', 'B', 'C'] && result.subrange(3, result.len() as int) == int_to_string(n)
}

spec fn int_to_string(n: int) -> Seq<char>
    recommends n >= 0
    decreases n
{
    if n == 0 {
        seq!['0']
    } else if n < 10 {
        seq![('0' as u8 + n as u8) as char]
    } else {
        int_to_string(n / 10).add(seq![('0' as u8 + (n % 10) as u8) as char])
    }
}",,"fn solve(n: i8) -> (result: Vec<char>)
    requires valid_input(n as int)
    ensures valid_output(n as int, result@)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0644,verus,apps,apps_test_4607,,"Count the number of ""Takahashi"" dates from 2018-1-1 through 2018-a-b (inclusive).
A Takahashi date is one where the month and day numbers are equal (e.g., 1-1, 2-2, 3-3, etc.).","use vstd::prelude::*;

verus! {
spec fn valid_input(a: int, b: int) -> bool {
    1 <= a <= 12 && 1 <= b <= 31
}

spec fn takahashi_count(a: int, b: int) -> int
    recommends valid_input(a, b)
{
    if a > b { a - 1 } else { a }
}",,"fn solve(a: i8, b: i8) -> (result: i8)
    requires valid_input(a as int, b as int)
    ensures 
        result as int == takahashi_count(a as int, b as int) &&
        (a > b ==> result as int == a as int - 1) &&
        (a <= b ==> result as int == a as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0646,verus,apps,apps_test_4614,,"Given three integers A, B, and C where exactly two are equal and one is different,
find the integer that is different from the other two.","use vstd::prelude::*;

verus! {

spec fn contains_three_space_separated_integers(input: Seq<char>) -> bool {
    exists|i: int, j: int, k: int| (0 <= i < j < k <= input.len() &&
    is_valid_integer_substring(input, 0, i) &&
    input[i] == ' ' &&
    is_valid_integer_substring(input, i+1, j) &&
    input[j] == ' ' &&
    is_valid_integer_substring(input, j+1, k) &&
    (k == input.len() || input[k] == '\n'))
}

spec fn exactly_two_are_equal(input: Seq<char>) -> bool {
    let nums = parse_three_numbers(input);
    (nums.0 == nums.1 && nums.0 != nums.2) ||
    (nums.0 == nums.2 && nums.0 != nums.1) ||
    (nums.1 == nums.2 && nums.1 != nums.0)
}

spec fn is_valid_integer_string(s: Seq<char>) -> bool {
    if s.len() == 0 { false }
    else if s.len() == 1 && s[0] == '0' { true }
    else if s.len() > 0 && s[0] == '-' { 
        s.len() > 1 && is_digit_sequence(s.subrange(1, s.len() as int)) && s[1] != '0'
    }
    else { is_digit_sequence(s) && s[0] != '0' }
}

spec fn is_digit_sequence(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && s[i] <= '9'
}

spec fn is_valid_integer_substring(s: Seq<char>, start: int, end: int) -> bool {
    if start == end { false }
    else {
        let substr = s.subrange(start, end);
        is_valid_integer_string(substr)
    }
}

spec fn find_different_number(input: Seq<char>) -> Seq<char> {
    let nums = parse_three_numbers(input);
    let different = if nums.0 == nums.1 { nums.2 }
                    else if nums.0 == nums.2 { nums.1 }
                    else { nums.0 };
    int_to_string_pure(different)
}
spec fn parse_three_numbers(input: Seq<char>) -> (int, int, int) {
    (0, 0, 0) /* placeholder for parsing logic */
}

spec fn int_to_string_pure(n: int) -> Seq<char> {
    Seq::<char>::new(1 as nat, |i: int| '0') /* placeholder for conversion logic */
}",,"fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires 
        input@.len() > 0,
        contains_three_space_separated_integers(input@),
        exactly_two_are_equal(input@),
    ensures
        result@.len() > 0,
        is_valid_integer_string(result@),
        result@ == find_different_number(input@),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0647,verus,apps,apps_test_4615,,"Find the sugar water mixture with maximum density given constraints on water and sugar operations.
Operations: add 100A or 100B grams water, add C or D grams sugar.
E grams sugar can dissolve per 100 grams water. Beaker capacity is F grams.
Maximize density = (100 × sugar_mass) / (water_mass + sugar_mass).","use vstd::prelude::*;

verus! {

spec fn valid_input(a: int, b: int, c: int, d: int, e: int, f: int) -> bool {
    1 <= a < b <= 30 &&
    1 <= c < d <= 30 &&
    1 <= e <= 100 &&
    100 * a <= f <= 3000
}

spec fn valid_solution(a: int, b: int, c: int, d: int, e: int, f: int, total_mass: int, sugar_mass: int) -> bool {
    total_mass > 0 && sugar_mass >= 0 &&
    total_mass <= f &&
    sugar_mass <= total_mass
}

spec fn density(total_mass: int, sugar_mass: int) -> int
    recommends total_mass >= 0 && sugar_mass >= 0
{
    if total_mass > 0 { (100 * sugar_mass) / total_mass } else { 0 }
}",,"fn solve(a: i8, b: i8, c: i8, d: i8, e: i8, f: i8) -> (result: (i8, i8))
    requires valid_input(a as int, b as int, c as int, d as int, e as int, f as int)
    ensures ({
        let (total_mass, sugar_mass) = result;
        valid_solution(a as int, b as int, c as int, d as int, e as int, f as int, total_mass as int, sugar_mass as int) &&
        total_mass as int >= 0 && sugar_mass as int >= 0 &&
        total_mass as int <= f as int &&
        sugar_mass as int <= total_mass as int &&
        (exists|water_units: int| water_units > 0 && total_mass as int == #[trigger] (water_units * 100) + sugar_mass as int) &&
        (exists|water_units: int| water_units > 0 && sugar_mass as int <= #[trigger] (water_units * e as int)) &&
        (exists|i1: int, j1: int, i2: int, j2: int| 
            i1 >= 0 && j1 >= 0 && i2 >= 0 && j2 >= 0 &&
            i1 <= 30int / a as int && j1 <= 30int / b as int &&
            i2 <= 3000int / c as int && j2 <= 3000int / d as int &&
            total_mass as int == #[trigger] ((a as int * i1 + b as int * j1) * 100 + (c as int * i2 + d as int * j2)) &&
            sugar_mass as int == #[trigger] (c as int * i2 + d as int * j2) &&
            a as int * i1 + b as int * j1 > 0) &&
        total_mass as int > 0
    })","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0648,verus,apps,apps_test_4616,,"Given a string of at least 3 lowercase English letters, create an abbreviation by replacing
the middle characters with their count. Format: first_character + count_of_middle_characters + last_character.","use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>) -> bool {
    s.len() >= 3 && s.len() <= 100 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= 'a' && #[trigger] s[i] <= 'z'
}

spec fn valid_abbreviation(s: Seq<char>, result: Seq<char>) -> bool {
    result.len() >= 3 &&
    s.len() >= 3 &&
    result[0] == s[0] &&
    result[result.len() - 1] == s[s.len() - 1] &&
    result == seq![s[0]].add(int_to_string(s.len() - 2)).add(seq![s[s.len() - 1]])
}

spec fn int_to_string(n: int) -> Seq<char>
    decreases if n >= 0 { n } else { -n }
{
    if n == 0 {
        seq!['0']
    } else if n < 0 {
        seq!['-'].add(int_to_string_helper(-n))
    } else {
        int_to_string_helper(n)
    }
}

spec fn int_to_string_helper(n: int) -> Seq<char>
    recommends n >= 0
    decreases n
{
    if n <= 0 {
        Seq::new(0 as nat, |_i: int| ' ')
    } else {
        int_to_string_helper(n / 10).add(seq![(('0' as int) + (n % 10)) as char])
    }
}",,"fn solve(s: Vec<char>) -> (result: Vec<char>)
    requires valid_input(s@)
    ensures valid_abbreviation(s@, result@)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0649,verus,apps,apps_test_4617,,"Given a 2×3 grid of lowercase English letters, determine if the grid remains identical after a 180-degree rotation.
Input consists of two lines, each containing 3 characters.
Output ""YES"" if unchanged after rotation, ""NO"" otherwise.","use vstd::prelude::*;

verus! {

spec fn valid_input(lines: Seq<Seq<char>>) -> bool {
    lines.len() >= 2 && lines[0].len() > 0 && lines[1].len() > 0
}

spec fn is_symmetric(first_row: Seq<char>, second_row: Seq<char>) -> bool {
    reverse_seq(first_row) == second_row
}

spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> 
    decreases s.len()
{
    if s.len() == 0 {
        seq![]
    } else if s[0] == '\n' {
        seq![seq![]] + split_lines(s.subrange(1, s.len() as int))
    } else {
        let rest = split_lines(s.subrange(1, s.len() as int));
        if rest.len() == 0 {
            seq![seq![s[0]]]
        } else {
            seq![rest[0].push(s[0])] + rest.subrange(1, rest.len() as int)
        }
    }
}

spec fn reverse_seq(s: Seq<char>) -> Seq<char>
    decreases s.len()
{
    if s.len() == 0 {
        seq![]
    } else {
        reverse_seq(s.subrange(1, s.len() as int)).push(s[0])
    }
}",,"fn solve(stdin_input: &str) -> (result: String)
    requires stdin_input@.len() > 0
    ensures result@ == ""YES\n""@ || result@ == ""NO\n""@","{
    assume(false);
    ""NO\n"".to_string()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0650,verus,apps,apps_test_4635,,"Given two integers n and k, construct a string of length n using only the first k letters 
of the alphabet ('a', 'b', ..., k-th letter). Each of the k letters must appear at least once.
Maximize the minimum frequency among all letters used. The optimal strategy is to distribute
characters as evenly as possible by cycling through the k letters repeatedly.","use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 && 
    (exists|lines: Seq<Seq<char>>| lines == split_by_newline(input) && 
     lines.len() >= 1 && 
     is_valid_integer(lines[0]) &&
     string_to_int_val(lines[0]) >= 0 &&
     lines.len() >= string_to_int_val(lines[0]) + 1 &&
     (forall|i: int| 1 <= i <= string_to_int_val(lines[0]) && i < lines.len() ==> valid_test_case_line(lines[i])))
}

spec fn valid_test_case_line(line: Seq<char>) -> bool {
    exists|parts: Seq<Seq<char>>| (parts == split_by_space(line) &&
                    parts.len() >= 2 &&
                    is_valid_integer(parts[0]) &&
                    is_valid_integer(parts[1]) &&
                    string_to_int_val(parts[0]) > 0 &&
                    string_to_int_val(parts[1]) > 0 &&
                    string_to_int_val(parts[1]) <= 26)
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    s.len() > 0 && 
    (s.len() == 1 || s[0] != '0' || s == seq!['0']) &&
    forall|i: int| 0 <= i < s.len() ==> ('0' <= #[trigger] s[i] <= '9')
}

spec fn string_to_int_val(s: Seq<char>) -> int 
    recommends is_valid_integer(s)
    decreases s.len()
{
    if s.len() == 0 { 
        0 
    } else if s.len() == 1 { 
        (s[0] as int) - 48 
    } else { 
        string_to_int_val(s.subrange(0, s.len() - 1 as int)) * 10 + ((s[s.len() - 1] as int) - 48)
    }
}

spec fn cyclic_pattern_correct(n: int, k: int, output: Seq<char>) -> bool 
    recommends n > 0 && k > 0 && k <= 26
{
    output.len() == n &&
    (forall|j: int| 0 <= j < n ==> (#[trigger] output[j] == ((j % k) + 97) as char))
}

spec fn split_by_newline(input: Seq<char>) -> Seq<Seq<char>> {
    seq![seq!['a']]  /* Placeholder implementation for splitting by newlines */
}

spec fn split_by_space(line: Seq<char>) -> Seq<Seq<char>> {
    seq![seq!['1'], seq!['2']]  /* Placeholder implementation for splitting by spaces */
}",,"fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(stdin_input@)
    ensures result@.len() >= 0","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0651,verus,apps,apps_test_4659,,"Generate the first numRows rows of Pascal's triangle, where each number is the sum
of the two numbers directly above it in the previous row.","use vstd::prelude::*;

verus! {
spec fn valid_pascal_triangle(triangle: Seq<Seq<int>>, num_rows: int) -> bool {
    triangle.len() == num_rows &&
    (num_rows == 0 ==> triangle == Seq::<Seq<int>>::empty()) &&
    (num_rows > 0 ==> (
        forall|i: int| 0 <= i < triangle.len() ==> #[trigger] triangle[i].len() == i + 1
    )) &&
    (num_rows > 0 ==> (
        forall|i: int| 0 <= i < triangle.len() ==> 
            #[trigger] triangle[i][0] == 1 && #[trigger] triangle[i][triangle[i].len() - 1] == 1
    )) &&
    (num_rows > 1 ==> (
        forall|i: int, j: int| 1 <= i < triangle.len() && 1 <= j < triangle[i].len() - 1 ==> 
            #[trigger] triangle[i][j] == triangle[i-1][j-1] + triangle[i-1][j]
    ))
}",,"fn generate(num_rows: i8) -> (result: Vec<Vec<i8>>)
    requires num_rows >= 0
    ensures valid_pascal_triangle(result@.map(|i, row: Vec<i8>| row@.map(|j, x: i8| x as int)), num_rows as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0652,verus,apps,apps_test_4676,,"Given two strings O and E representing characters at odd-numbered and even-numbered positions
of a password respectively, restore the original password by interleaving the characters.
Input format: O on first line, E on second line, separated by newline.
Output: interleaved password where characters alternate between O and E.","use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    let lines = split_lines(input);
    lines.len() >= 2 &&
    {
        let o = lines[0];
        let e = lines[1];
        let a = o.len();
        let b = e.len();
        (a == b || a == b + 1) &&
        (a > 0 || b == 0)
    }
}

spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {
    /* Helper function to split input by newlines */
    seq![]  /* Placeholder - would need actual implementation */
}

spec fn get_o(input: Seq<char>) -> Seq<char>
    recommends valid_input(input)
{
    split_lines(input)[0]
}

spec fn get_e(input: Seq<char>) -> Seq<char>
    recommends valid_input(input)
{
    split_lines(input)[1]
}

spec fn correct_result(input: Seq<char>) -> Seq<char>
    recommends valid_input(input)
{
    let o = get_o(input);
    let e = get_e(input);
    let a = o.len();
    let b = e.len();
    if a == b {
        interleave_equal(o, e)
    } else {
        interleave_unequal(o, e)
    }
}

spec fn interleave_equal(o: Seq<char>, e: Seq<char>) -> Seq<char>
    recommends o.len() == e.len()
    decreases o.len()
{
    if o.len() == 0 {
        seq![]
    } else {
        seq![o[0], e[0]] + interleave_equal(o.subrange(1, o.len() as int), e.subrange(1, e.len() as int))
    }
}

spec fn interleave_unequal(o: Seq<char>, e: Seq<char>) -> Seq<char>
    recommends o.len() == e.len() + 1
    decreases e.len()
{
    if e.len() == 0 {
        o
    } else {
        seq![o[0], e[0]] + interleave_unequal(o.subrange(1, o.len() as int), e.subrange(1, e.len() as int))
    }
}",,"fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(input@)
    ensures result@ == correct_result(input@)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0653,verus,apps,apps_test_4677,,"Simulate a 3-key text editor that processes keystrokes: '0' and '1' append characters,
'B' deletes the rightmost character if the string is non-empty.","use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>) -> bool {
    s.len() >= 1 && s.len() <= 10 && 
    forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1' || s[i] == 'B'
}

spec fn simulate_keystrokes(keystrokes: Seq<char>) -> Seq<char>
    decreases keystrokes.len()
{
    if keystrokes.len() == 0 {
        Seq::<char>::empty()
    } else {
        let prev = simulate_keystrokes(keystrokes.subrange(0, keystrokes.len() - 1));
        let last_key = keystrokes[keystrokes.len() - 1];
        if last_key == 'B' {
            if prev.len() > 0 {
                prev.subrange(0, prev.len() - 1)
            } else {
                prev
            }
        } else {
            prev.push(last_key)
        }
    }
}

spec fn valid_output(result: Seq<char>) -> bool {
    forall|i: int| 0 <= i < result.len() ==> result[i] == '0' || result[i] == '1'
}",,"fn solve(s: Vec<char>) -> (result: Vec<char>)
    requires 
        valid_input(s@),
    ensures 
        valid_output(result@),
        result@ == simulate_keystrokes(s@),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0654,verus,apps,apps_test_4679,,"Three players (Alice, Bob, Charlie) play a card game with decks of cards labeled 'a', 'b', or 'c'.
Alice starts first. On each turn, if current player's deck is empty, they win the game.
Otherwise, discard the top card; the letter determines next player ('a'→Alice, 'b'→Bob, 'c'→Charlie).
Given initial decks as strings, determine the winner.","use vstd::prelude::*;

verus! {
spec fn valid_deck(deck: Seq<char>) -> bool {
    forall|i: int| 0 <= i < deck.len() ==> (deck[i] == 'a' || deck[i] == 'b' || deck[i] == 'c')
}

spec fn valid_input(a: Seq<char>, b: Seq<char>, c: Seq<char>) -> bool {
    valid_deck(a) && valid_deck(b) && valid_deck(c)
}

spec fn valid_winner(winner: char) -> bool {
    winner == 'A' || winner == 'B' || winner == 'C'
}",,"fn solve(a: Vec<char>, b: Vec<char>, c: Vec<char>) -> (result: char)
    requires valid_input(a@, b@, c@)
    ensures valid_winner(result)","{
    assume(false);
    'A'
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0655,verus,apps,apps_test_4680,,"Given three integers A, B, and C representing syllable counts of three phrases,
determine if these phrases can be arranged to form a Haiku. A Haiku requires
exactly two phrases with 5 syllables and one phrase with 7 syllables.","use vstd::prelude::*;

verus! {
spec fn valid_input(a: int, b: int, c: int) -> bool {
    1 <= a <= 10 && 1 <= b <= 10 && 1 <= c <= 10
}

spec fn can_form_haiku(a: int, b: int, c: int) -> bool {
    (a == 5 && b == 5 && c == 7) ||
    (a == 5 && b == 7 && c == 5) ||
    (a == 7 && b == 5 && c == 5)
}

spec fn valid_output(result: &str) -> bool {
    result == ""YES"" || result == ""NO""
}",,"fn solve(a: i8, b: i8, c: i8) -> (result: &'static str)
    requires 
        valid_input(a as int, b as int, c as int),
    ensures 
        valid_output(result),
        (result == ""YES"") <==> can_form_haiku(a as int, b as int, c as int),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0656,verus,apps,apps_test_4681,,"Compute the N-th Lucas number where the Lucas sequence is defined as:
L₀ = 2, L₁ = 1, and Lᵢ = Lᵢ₋₁ + Lᵢ₋₂ for i ≥ 2","use vstd::prelude::*;

verus! {

spec fn lucas(n: int) -> int
    recommends n >= 0
    decreases n
{
    if n <= 0 {
        2
    } else if n == 1 {
        1
    } else {
        lucas(n - 1) + lucas(n - 2)
    }
}

spec fn valid_input(n: int) -> bool {
    1 <= n <= 86
}",,"fn solve(n: i8) -> (result: i8)
    requires valid_input(n as int)
    ensures result as int == lucas(n as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0657,verus,apps,apps_test_4688,,"Given N balls in a row and K available colors, count the number of ways to paint 
the balls such that no two adjacent balls have the same color. The solution is
based on the combinatorial formula: first ball has K choices, each subsequent 
ball has (K-1) choices, giving K * (K-1)^(N-1) total ways.","use vstd::prelude::*;

verus! {
spec fn power(base: int, exp: int) -> int
  decreases exp when exp >= 0
{
  if exp <= 0 { 1 } else { base * power(base, exp - 1) }
}

spec fn valid_input(n: int, k: int) -> bool
{
  1 <= n <= 1000 && 2 <= k <= 1000
}

spec fn painting_ways(n: int, k: int) -> int
{
  if valid_input(n, k) { k * power(k - 1, n - 1) } else { 0 }
}",,"fn solve(n: i8, k: i8) -> (result: i8)
  requires 
    valid_input(n as int, k as int)
  ensures 
    result as int == painting_ways(n as int, k as int),
    result > 0","{
  // impl-start
  assume(false);
  unreached()
  // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0658,verus,apps,apps_test_4690,,"Given dimensions of two rectangles (A×B and C×D), return the area of the rectangle with the larger area.
If both rectangles have equal areas, return that common area.","use vstd::prelude::*;

verus! {

spec fn valid_input(a: int, b: int, c: int, d: int) -> bool {
    1 <= a <= 10000 && 1 <= b <= 10000 && 1 <= c <= 10000 && 1 <= d <= 10000
}

spec fn max_area(a: int, b: int, c: int, d: int) -> int {
    if a * b >= c * d { a * b } else { c * d }
}",,"fn solve(a: i8, b: i8, c: i8, d: i8) -> (result: i8)
    requires 
        valid_input(a as int, b as int, c as int, d as int)
    ensures 
        result as int == max_area(a as int, b as int, c as int, d as int),
        result as int >= (a as int) * (b as int) && result as int >= (c as int) * (d as int),
        result as int == (a as int) * (b as int) || result as int == (c as int) * (d as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0659,verus,apps,apps_test_4692,,"Calculate how many hours remain from M o'clock (24-hour format) on December 30th 
until New Year (0 o'clock on January 1st). M is an integer between 1 and 23 inclusive.","use vstd::prelude::*;

verus! {
spec fn valid_input(m: int) -> bool {
    1 <= m <= 23
}

spec fn hours_until_new_year(m: int) -> int
    recommends valid_input(m)
{
    48 - m
}

spec fn valid_output(m: int, result: int) -> bool
    recommends valid_input(m)
{
    result == hours_until_new_year(m) && 25 <= result <= 47
}",,"fn solve(m: i8) -> (result: i8)
    requires valid_input(m as int)
    ensures valid_output(m as int, result as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0661,verus,apps,apps_test_4697,,"Given N S-shaped pieces and M c-shaped pieces, find the maximum number of ""Scc groups""
that can be formed. Each Scc group requires exactly 1 S-shaped piece and 2 c-shaped pieces.
Additionally, 2 c-shaped pieces can be combined to create 1 S-shaped piece.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, m: int) -> bool {
    n >= 0 && m >= 0
}

spec fn max_scc_groups(n: int, m: int) -> int {
    if valid_input(n, m) {
        let direct_groups = if n < m / 2 { n } else { m / 2 };
        let remaining_c_pieces = m - direct_groups * 2;
        let additional_groups = remaining_c_pieces / 4;
        direct_groups + additional_groups
    } else {
        0
    }
}",,"fn solve(n: i8, m: i8) -> (result: i8)
  requires valid_input(n as int, m as int)
  ensures 
      result >= 0,
      result as int == max_scc_groups(n as int, m as int),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0662,verus,apps,apps_test_4701,,"Start with value 1 and perform exactly N operations. Each operation is either:
Operation A: multiply current value by 2, or Operation B: add K to current value.
Find the minimum possible final value after N operations.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, k: int) -> bool {
    n >= 1 && k >= 1
}

spec fn apply_operations(start: int, operations: Seq<bool>, k: int) -> int
    decreases operations.len()
{
    if operations.len() == 0 {
        start
    } else if operations[0] {
        apply_operations(start * 2, operations.subrange(1, operations.len() as int), k)
    } else {
        apply_operations(start + k, operations.subrange(1, operations.len() as int), k)
    }
}",,"fn solve(n: i8, k: i8) -> (result: i8)
    requires valid_input(n as int, k as int)
    ensures result as int >= 1","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVA02,0.85
VA0663,verus,apps,apps_test_4702,,"Given an integer x where 0 ≤ x ≤ 1 represented as a string, output the logical NOT of x.
If x = 0, output 1. If x = 1, output 0.","use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 && 
    (input[0] == '0' || input[0] == '1') && 
    (input.len() == 1 || (input.len() > 1 && input[1] == '\n'))
}

spec fn logical_not(digit: char) -> Seq<char>
    recommends digit == '0' || digit == '1'
{
    if digit == '0' { seq!['1', '\n'] } else { seq!['0', '\n'] }
}

spec fn correct_output(input: Seq<char>, output: Seq<char>) -> bool
    recommends valid_input(input)
{
    output == logical_not(input[0])
}",,"fn solve(input: String) -> (output: String)
    requires valid_input(input@)
    ensures correct_output(input@, output@)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0664,verus,apps,apps_test_4705,,"Calculate the net amount paid by a customer for N meals at a restaurant.
Each meal costs 800 yen. For every 15 meals ordered, the customer receives
200 yen cashback. Return the net amount (total cost minus cashback).","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int) -> bool {
    1 <= n <= 100
}

spec fn total_cost(n: int) -> int
    recommends valid_input(n)
{
    800 * n
}

spec fn cashback(n: int) -> int
    recommends valid_input(n)
{
    (n / 15) * 200
}

spec fn net_amount(n: int) -> int
    recommends valid_input(n)
{
    total_cost(n) - cashback(n)
}",,"fn solve(n: i8) -> (result: i8)
    requires valid_input(n as int)
    ensures result as int == net_amount(n as int)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0665,verus,apps,apps_test_4706,,"Given a 3×3 grid of lowercase English letters, extract and concatenate 
the characters on the main diagonal (from top-left to bottom-right) 
to form a string of length 3.","use vstd::prelude::*;

verus! {
spec fn valid_input(lines: Seq<Seq<char>>) -> bool {
    lines.len() == 3 && forall|i: int| 0 <= i < 3 ==> lines[i].len() == 3
}

spec fn extract_diagonal(lines: Seq<Seq<char>>) -> Seq<char>
    recommends valid_input(lines)
{
    seq![lines[0][0], lines[1][1], lines[2][2]]
}",,"fn solve(lines: Vec<Vec<char>>) -> (result: Vec<char>)
    requires valid_input(lines@.map(|i: int, v: Vec<char>| v@))
    ensures 
        result@.len() == 4 &&
        result@[0] == lines@[0]@[0] &&
        result@[1] == lines@[1]@[1] &&
        result@[2] == lines@[2]@[2] &&
        result@[3] == '\n' &&
        result@ == extract_diagonal(lines@.map(|i: int, v: Vec<char>| v@)).push('\n')","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0667,verus,apps,apps_test_4710,,"Given an integer rating x, classify it as ""ABC"" if x < 1200, otherwise ""ARC"".
The input must be between 1 and 3000 inclusive.","use vstd::prelude::*;

verus! {
spec fn valid_input(x: int) -> bool {
    1 <= x <= 3000
}

spec fn correct_output(x: int, result: Seq<char>) -> bool {
    (x < 1200 ==> result == seq!['A', 'B', 'C', '\n']) &&
    (x >= 1200 ==> result == seq!['A', 'R', 'C', '\n'])
}",,"fn solve(x: i32) -> (result: Vec<char>)
    requires valid_input(x as int)
    ensures correct_output(x as int, result@)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0668,verus,apps,apps_test_4711,,"Given three bell prices a, b, and c (in yen), find the minimum cost to purchase exactly two bells of different types.
Constraints: 1 ≤ a, b, c ≤ 10000 (integers)","use vstd::prelude::*;

verus! {

spec fn valid_input(a: int, b: int, c: int) -> bool {
    1 <= a <= 10000 && 1 <= b <= 10000 && 1 <= c <= 10000
}

spec fn min_of_three(x: int, y: int, z: int) -> int {
    if x <= y && x <= z { x }
    else if y <= z { y }
    else { z }
}

spec fn correct_result(a: int, b: int, c: int) -> int {
    min_of_three(a + b, a + c, b + c)
}",,"fn solve(a: i8, b: i8, c: i8) -> (result: i8)
    requires valid_input(a as int, b as int, c as int)
    ensures result as int == correct_result(a as int, b as int, c as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0669,verus,apps,apps_test_4713,,"Given a string S of length N containing only characters 'I' and 'D', simulate the following process:
Start with x = 0. For each character in S from left to right:
If the character is 'I', increment x by 1. If the character is 'D', decrement x by 1.
Find the maximum value that x reaches during this entire process (including the initial value 0).","use vstd::prelude::*;

verus! {
spec fn max_value(s: Seq<char>) -> int {
    max_value_up_to_index(s, s.len() as int)
}

spec fn max_value_up_to_index(s: Seq<char>, up_to: int) -> int
    decreases up_to when 0 <= up_to <= s.len()
{
    if up_to == 0 { 0 }
    else {
        let current_value = current_value_at_index(s, up_to);
        let max_before = max_value_up_to_index(s, up_to - 1);
        if current_value > max_before { current_value } else { max_before }
    }
}

spec fn current_value_at_index(s: Seq<char>, index: int) -> int
    decreases index when 0 <= index <= s.len()
{
    if index == 0 { 0 }
    else { 
        current_value_at_index(s, index - 1) + (if s[index - 1 as nat] == 'I' { 1 } else { -1 })
    }
}",,"fn solve(n: i8, s: Vec<char>) -> (result: i8)
    requires 
        1 <= n <= 100,
        n as int == s@.len(),
        forall|i: int| 0 <= i < s@.len() ==> s@[i] == 'I' || s@[i] == 'D',
    ensures 
        result >= 0,
        result as int == max_value(s@),","{
    assume(false);
    0
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0671,verus,apps,apps_test_4715,,"Given three integers representing colors, count the number of distinct colors.
Input constraints: 1 ≤ a,b,c ≤ 100
Output: number of different kinds of colors (1, 2, or 3)","use vstd::prelude::*;

verus! {

spec fn valid_input(a: int, b: int, c: int) -> bool {
    1 <= a <= 100 && 1 <= b <= 100 && 1 <= c <= 100
}

spec fn count_distinct_colors(a: int, b: int, c: int) -> int {
    if a == b && b == c { 1 }
    else if a == b || b == c || a == c { 2 }
    else { 3 }
}

spec fn all_same(a: int, b: int, c: int) -> bool {
    a == b && b == c
}

spec fn exactly_two_same(a: int, b: int, c: int) -> bool {
    (a == b && b != c) || (b == c && a != b) || (a == c && a != b)
}

spec fn all_different(a: int, b: int, c: int) -> bool {
    a != b && b != c && a != c
}",,"fn solve(a: i8, b: i8, c: i8) -> (result: i8)
    requires 
        valid_input(a as int, b as int, c as int)
    ensures 
        1 <= result as int <= 3,
        result as int == count_distinct_colors(a as int, b as int, c as int),
        result as int == 1 <==> all_same(a as int, b as int, c as int),
        result as int == 2 <==> exactly_two_same(a as int, b as int, c as int),
        result as int == 3 <==> all_different(a as int, b as int, c as int)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0672,verus,apps,apps_test_4717,,"Given three distinct positions x, a, and b on a number line, determine whether position a or position b 
is closer to position x. Output ""A"" if position a is closer, ""B"" if position b is closer.
Distance between two positions s and t is |s-t|.","use vstd::prelude::*;

verus! {
spec fn valid_input(x: int, a: int, b: int) -> bool {
    1 <= x <= 1000 &&
    1 <= a <= 1000 &&
    1 <= b <= 1000 &&
    x != a && x != b && a != b &&
    distance(x, a) != distance(x, b)
}

spec fn distance(s: int, t: int) -> nat {
    if s >= t { (s - t) as nat } else { (t - s) as nat }
}

spec fn correct_result(x: int, a: int, b: int, result: Seq<char>) -> bool {
    (result == seq!['A'] <==> distance(x, a) < distance(x, b)) &&
    (result == seq!['B'] <==> distance(x, b) < distance(x, a))
}",,"fn solve(x: i8, a: i8, b: i8) -> (result: String)
    requires 
        valid_input(x as int, a as int, b as int),
    ensures 
        result@ == seq!['A'] || result@ == seq!['B'],
        correct_result(x as int, a as int, b as int, result@),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0673,verus,apps,apps_test_4718,,"Given a date string in format ""2017/01/dd"" where dd represents a day from 01 to 31,
replace the year ""2017"" with ""2018"" and output the corrected date string.","use vstd::prelude::*;

verus! {
spec fn valid_input(date_str: Seq<char>) -> bool {
    date_str.len() == 10 && date_str.subrange(0, 4) == seq!['2', '0', '1', '7']
}

spec fn valid_output(input: Seq<char>, output: Seq<char>) -> bool 
    recommends input.len() >= 4
{
    output == seq!['2', '0', '1', '8'].add(input.subrange(4, input.len() as int)) &&
    output.len() == 10 &&
    output.subrange(0, 4) == seq!['2', '0', '1', '8'] &&
    output.subrange(4, output.len() as int) == input.subrange(4, input.len() as int)
}",,"fn solve(date_str: Vec<char>) -> (result: Vec<char>)
    requires valid_input(date_str@)
    ensures valid_output(date_str@, result@)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0674,verus,apps,apps_test_4721,,"Given n east-west streets and m north-south streets in a city where all streets intersect,
determine the number of rectangular blocks formed by the street grid.
n east-west streets create (n-1) horizontal strips, m north-south streets create (m-1) vertical strips,
resulting in (n-1) * (m-1) rectangular blocks.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, m: int) -> bool {
    2 <= n <= 100 && 2 <= m <= 100
}

spec fn count_blocks(n: int, m: int) -> int
    recommends valid_input(n, m)
{
    (n - 1) * (m - 1)
}

spec fn correct_output(n: int, m: int, blocks: int) -> bool {
    valid_input(n, m) && blocks == count_blocks(n, m)
}",,"fn solve(n: i8, m: i8) -> (blocks: i8)
    requires 
        valid_input(n as int, m as int)
    ensures 
        correct_output(n as int, m as int, blocks as int),
        blocks >= 1","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0675,verus,apps,apps_test_4722,,"Given two integers A and B representing cookies in two tins, determine if cookies
can be distributed equally among three goats by choosing A, B, or A+B total cookies.","use vstd::prelude::*;

verus! {
spec fn valid_input(a: int, b: int) -> bool {
    1 <= a <= 100 && 1 <= b <= 100
}

spec fn distribution_possible(a: int, b: int) -> bool {
    a % 3 == 0 || b % 3 == 0 || (a + b) % 3 == 0
}",,"fn solve(a: i8, b: i8) -> (result: String)
    requires 
        valid_input(a as int, b as int)
    ensures 
        result@ == seq!['P', 'o', 's', 's', 'i', 'b', 'l', 'e'] <==> distribution_possible(a as int, b as int),
        result@ == seq!['P', 'o', 's', 's', 'i', 'b', 'l', 'e'] || result@ == seq!['I', 'm', 'p', 'o', 's', 's', 'i', 'b', 'l', 'e']","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VA0676,verus,apps,apps_test_4724,,"Given a current rating R and target rating G, find the required performance P
such that the new rating equals G, where new rating = (R + P) / 2 = G.","use vstd::prelude::*;

verus! {
spec fn valid_input(r: int, g: int) -> bool {
    0 <= r <= 4500 && 0 <= g <= 4500
}

spec fn required_performance(r: int, g: int) -> int {
    2 * g - r
}

spec fn correct_result(r: int, g: int, p: int) -> bool {
    (r + p) == 2 * g
}",,"fn solve(r: i8, g: i8) -> (result: i8)
    requires 
        valid_input(r as int, g as int)
    ensures 
        result as int == required_performance(r as int, g as int) &&
        correct_result(r as int, g as int, result as int)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VB0000,verus,bignum,bignum_Add,,"Bignum task: bignum_Add.
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */","use vstd::prelude::*;

verus! {
spec fn str2int(s: Seq<char>) -> nat
  decreases s.len()
{
  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool
{
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}",,"fn add(s1: Vec<char>, s2: Vec<char>) -> (res: Vec<char>)
  requires 
    valid_bit_string(s1@) && valid_bit_string(s2@)
  ensures 
    valid_bit_string(res@) &&
    str2int(res@) == str2int(s1@) + str2int(s2@)","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVB02,0.85
VB0001,verus,bignum,bignum_Add_NormalizeBitString,,"Bignum task: bignum_Add[NormalizeBitString].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */

/* Remove leading zeros, except keep at least one digit */

/* I added and proved some extra post-conditions: */","use vstd::prelude::*;

verus! {
spec fn str2int(s: Seq<char>) -> nat
  recommends valid_bit_string(s)
  decreases s.len()
{
  if s.len() == 0 {
    0nat
  } else {
    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
  }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

fn normalize_bit_string(s: Seq<char>) -> (t: Seq<char>)
  ensures 
    valid_bit_string(t),
    t.len() > 0,
    t.len() > 1 ==> t[0] != '0',
    valid_bit_string(s) ==> str2int(s) == str2int(t),
{
  assume(false);
  unreached()
}",,"fn add(s1: Vec<char>, s2: Vec<char>) -> (res: Vec<char>)
  requires 
    valid_bit_string(s1@) && valid_bit_string(s2@),
  ensures 
    valid_bit_string(res@),
    str2int(res@) == str2int(s1@) + str2int(s2@),","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVB02,0.85
VB0002,verus,bignum,bignum_Compare,,"Bignum task: bignum_Compare.
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */","use vstd::prelude::*;

verus! {
spec fn str2int(s: Seq<char>) -> nat
  decreases s.len()
{
  if s.len() == 0 { 
    0nat 
  } else { 
    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
  }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
}",,"fn compare(s1: Vec<char>, s2: Vec<char>) -> (res: i32)
  requires 
    valid_bit_string(s1@) && valid_bit_string(s2@)
  ensures 
    (str2int(s1@) < str2int(s2@)) ==> (res == -1) &&
    (str2int(s1@) == str2int(s2@)) ==> (res == 0) &&
    (str2int(s1@) > str2int(s2@)) ==> (res == 1)
  decreases str2int(s1@) + str2int(s2@)","{
  // impl-start
  assume(false);
  0
  // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,DupVB02,0.85
VB0003,verus,bignum,bignum_CompareUnequal,,"Bignum task: bignum_CompareUnequal.
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */","use vstd::prelude::*;

verus! {
spec fn str2int(s: Seq<char>) -> nat
  recommends valid_bit_string(s)
  decreases s.len()
{
  if s.len() == 0 { 
    0nat 
  } else { 
    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
  }
}

spec fn valid_bit_string(s: Seq<char>) -> bool
{
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}",,"fn compare_unequal(s1: Vec<char>, s2: Vec<char>) -> (res: i32)
  requires 
    valid_bit_string(s1@) && valid_bit_string(s2@),
    s1@.len() > 0,
    s1@.len() > 1 ==> s1@[0] != '0',
    s2@.len() > 0,
    s2@.len() > 1 ==> s2@[0] != '0',
    s1@.len() > s2@.len()
  ensures 
    str2int(s1@) < str2int(s2@) ==> res == -1,
    str2int(s1@) == str2int(s2@) ==> res == 0,
    str2int(s1@) > str2int(s2@) ==> res == 1","{
  assume(false);
  0
}","
}

fn main() {}",0,,-1,-1,-1,DupVB02,0.85
VB0004,verus,bignum,bignum_Compare_CompareUnequal,,"Bignum task: bignum_Compare[CompareUnequal].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */","use vstd::prelude::*;

verus! {
spec fn str2int(s: Seq<char>) -> nat
  recommends valid_bit_string(s)
  decreases s.len()
{
  if s.len() == 0 {
    0nat
  } else {
    2nat * str2int(s.subrange(0, s.len() - 1)) + 
    (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
  }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

fn compare_unequal(s1: Seq<char>, s2: Seq<char>) -> (res: i32)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2),
    s1.len() > 0,
    s1.len() > 1 ==> s1[0] != '0',
    s2.len() > 0,
    s2.len() > 1 ==> s2[0] != '0',
    s1.len() > s2.len()
  ensures 
    str2int(s1) < str2int(s2) ==> res == -1,
    str2int(s1) == str2int(s2) ==> res == 0,
    str2int(s1) > str2int(s2) ==> res == 1
{
  assume(false);
  unreached()
}",,"fn compare(s1: Vec<char>, s2: Vec<char>) -> (res: i32)
  requires valid_bit_string(s1@) && valid_bit_string(s2@)
  ensures 
    str2int(s1@) < str2int(s2@) ==> res == -1,
    str2int(s1@) == str2int(s2@) ==> res == 0,
    str2int(s1@) > str2int(s2@) ==> res == 1
  decreases str2int(s1@) + str2int(s2@)","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVB02,0.85
VB0005,verus,bignum,bignum_Compare_CompareUnequal_NormalizeBitString,,"Bignum task: bignum_Compare[CompareUnequal,NormalizeBitString].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */

/* Remove leading zeros, except keep at least one digit */

/* I added and proved some extra post-conditions: */","use vstd::prelude::*;

verus! {
spec fn str2int(s: Seq<char>) -> nat
  recommends valid_bit_string(s)
  decreases s.len()
{
  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1 as int)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool
{
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

fn normalize_bit_string(s: Seq<char>) -> (t: Seq<char>)
  ensures
    valid_bit_string(t),
    t.len() > 0,
    t.len() > 1 ==> t[0] != '0',
    valid_bit_string(s) ==> str2int(s) == str2int(t),
{
  assume(false);
  unreached()
}

fn compare_unequal(s1: Seq<char>, s2: Seq<char>) -> (res: i32)
  requires
    valid_bit_string(s1) && valid_bit_string(s2),
    s1.len() > 0,
    s1.len() > 1 ==> s1[0] != '0',
    s2.len() > 0,
    s2.len() > 1 ==> s2[0] != '0',
    s1.len() > s2.len(),
  ensures
    str2int(s1) < str2int(s2) ==> res == -1,
    str2int(s1) == str2int(s2) ==> res == 0,
    str2int(s1) > str2int(s2) ==> res == 1,
{
  assume(false);
  unreached()
}",,"fn compare(s1: Vec<char>, s2: Vec<char>) -> (res: i32)
  requires valid_bit_string(s1@) && valid_bit_string(s2@)
  ensures
    str2int(s1@) < str2int(s2@) ==> res == -1,
    str2int(s1@) == str2int(s2@) ==> res == 0,
    str2int(s1@) > str2int(s2@) ==> res == 1,
  decreases str2int(s1@) + str2int(s2@)","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVB02,0.85
VB0006,verus,bignum,bignum_Compare_NormalizeBitString,,"Bignum task: bignum_Compare[NormalizeBitString].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */

/* Remove leading zeros, except keep at least one digit */

/* I added and proved some extra post-conditions: */","use vstd::prelude::*;

verus! {
spec fn str2int(s: Seq<char>) -> nat
  decreases s.len()
{
  if s.len() == 0 {
      0nat
  } else {
      2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
  }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

fn normalize_bit_string(s: Seq<char>) -> (t: Seq<char>)
  ensures 
      valid_bit_string(t) &&
      t.len() > 0 &&
      (t.len() > 1 ==> t[0] != '0') &&
      (valid_bit_string(s) ==> str2int(s) == str2int(t))
{
  assume(false);
  unreached()
}",,"fn compare(s1: Vec<char>, s2: Vec<char>) -> (res: i8)
  requires valid_bit_string(s1@) && valid_bit_string(s2@)
  ensures 
      (str2int(s1@) < str2int(s2@) ==> res as int == -1) &&
      (str2int(s1@) == str2int(s2@) ==> res as int == 0) &&
      (str2int(s1@) > str2int(s2@) ==> res as int == 1)
  decreases str2int(s1@) + str2int(s2@)","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVB02,0.85
VB0007,verus,bignum,bignum_DivMod,,"Bignum task: bignum_DivMod.
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */","use vstd::prelude::*;

verus! {
spec fn str2int(s: Seq<char>) -> nat
  recommends valid_bit_string(s)
  decreases s.len()
{
  if s.len() == 0 { 
    0nat 
  } else { 
    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
  }
}

spec fn valid_bit_string(s: Seq<char>) -> bool
{
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}",,"fn div_mod(dividend: Vec<char>, divisor: Vec<char>) -> (result: (Vec<char>, Vec<char>))
  requires 
    valid_bit_string(dividend@) && valid_bit_string(divisor@),
    str2int(divisor@) > 0,
  ensures 
    valid_bit_string(result.0@) && valid_bit_string(result.1@),
    str2int(result.0@) == str2int(dividend@) / str2int(divisor@),
    str2int(result.1@) == str2int(dividend@) % str2int(divisor@),","{
  // impl-start
  assume(false);
  unreached()
  // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VB0008,verus,bignum,bignum_DivMod_Compare,,"Bignum task: bignum_DivMod[Compare].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */","use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
  recommends valid_bit_string(s)
  decreases s.len()
{
  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool
{
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
}

fn compare(s1: Seq<char>, s2: Seq<char>) -> (res: i32)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2)
  ensures 
    str2int(s1) < str2int(s2) ==> res == -1,
    str2int(s1) == str2int(s2) ==> res == 0,
    str2int(s1) > str2int(s2) ==> res == 1
  decreases str2int(s1) + str2int(s2)
{
  assume(false);
  unreached()
}",,"fn div_mod(dividend: Vec<char>, divisor: Vec<char>) -> (res: (Vec<char>, Vec<char>))
  requires 
    valid_bit_string(dividend@) && valid_bit_string(divisor@),
    str2int(divisor@) > 0
  ensures 
    valid_bit_string(res.0@) && valid_bit_string(res.1@),
    str2int(res.0@) == str2int(dividend@) / str2int(divisor@),
    str2int(res.1@) == str2int(dividend@) % str2int(divisor@)","{
  // impl-start
  assume(false);
  unreached()
  // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VB0009,verus,bignum,bignum_DivMod_Compare_Sub,,"Bignum task: bignum_DivMod[Compare,Sub].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */","use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
    recommends valid_bit_string(s)
    decreases s.len()
{
    if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool
{
    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

fn sub(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
    requires 
        valid_bit_string(s1) && valid_bit_string(s2),
        str2int(s1) >= str2int(s2),
    ensures 
        valid_bit_string(res),
        str2int(res) == str2int(s1) - str2int(s2),
{
    assume(false);
    unreached()
}

fn compare(s1: Seq<char>, s2: Seq<char>) -> (res: i32)
    requires valid_bit_string(s1) && valid_bit_string(s2),
    ensures 
        str2int(s1) < str2int(s2) ==> res == -1,
        str2int(s1) == str2int(s2) ==> res == 0,
        str2int(s1) > str2int(s2) ==> res == 1,
    decreases str2int(s1) + str2int(s2),
{
    assume(false);
    unreached()
}",,"fn div_mod(dividend: Vec<char>, divisor: Vec<char>) -> (res: (Vec<char>, Vec<char>))
    requires 
        valid_bit_string(dividend@) && valid_bit_string(divisor@),
        str2int(divisor@) > 0,
    ensures 
        valid_bit_string(res.0@) && valid_bit_string(res.1@),
        str2int(res.0@) == str2int(dividend@) / str2int(divisor@),
        str2int(res.1@) == str2int(dividend@) % str2int(divisor@),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VB0010,verus,bignum,bignum_DivMod_Sub,,"Bignum task: bignum_DivMod[Sub].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */","use vstd::prelude::*;

verus! {
spec fn str2int(s: Seq<char>) -> nat
  recommends valid_bit_string(s)
  decreases s.len()
{
  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool
{
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

fn sub(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2),
    str2int(s1) >= str2int(s2)
  ensures 
    valid_bit_string(res),
    str2int(res) == str2int(s1) - str2int(s2)
{
  assume(false);
  unreached()
}",,"fn div_mod(dividend: Vec<char>, divisor: Vec<char>) -> (result: (Vec<char>, Vec<char>))
  requires 
    valid_bit_string(dividend@) && valid_bit_string(divisor@),
    str2int(divisor@) > 0
  ensures 
    valid_bit_string(result.0@) && valid_bit_string(result.1@),
    str2int(result.0@) == str2int(dividend@) / str2int(divisor@),
    str2int(result.1@) == str2int(dividend@) % str2int(divisor@)","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VB0011,verus,bignum,bignum_ModExp,,"Bignum task: bignum_ModExp.
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */

/* requires y < Exp_int(2,n+1) */

/* && n > 0 */","use vstd::prelude::*;

verus! {
spec fn str2int(s: Seq<char>) -> nat
    decreases s.len()
{
    if s.len() == 0 { 
        0nat 
    } else { 
        2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
    }
}

spec fn exp_int(x: nat, y: nat) -> nat
    decreases y
{
    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}",,"fn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)
    requires 
        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&
        sy@.len() > 0 && str2int(sz@) > 1
    ensures 
        valid_bit_string(res@) &&
        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)
    decreases sy@.len()","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVB00,0.85
VB0012,verus,bignum,bignum_ModExpPow2,,"Bignum task: bignum_ModExpPow2.
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */

/* sy is power of 2 or zero */","use vstd::prelude::*;

verus! {

spec fn exp_int(x: nat, y: nat) -> nat
    decreases y
{
    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

spec fn str2int(s: Seq<char>) -> nat
    decreases s.len()
{
    if s.len() == 0 { 
        0nat 
    } else { 
        2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
    }
}",,"fn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)
    requires 
        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@),
        str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0,
        sy@.len() == n as int + 1,
        str2int(sz@) > 1,
    ensures 
        valid_bit_string(res@),
        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@),
    decreases n","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,DupVB03,0.85
VB0013,verus,bignum,bignum_ModExpPow2_Add,,"Bignum task: bignum_ModExpPow2[Add].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */

/* sy is power of 2 or zero */","use vstd::prelude::*;

verus! {

spec fn exp_int(x: nat, y: nat) -> nat
    decreases y
{
    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

spec fn str2int(s: Seq<char>) -> nat
    decreases s.len()
{
    if s.len() == 0 { 
        0nat 
    } else { 
        2nat * str2int(s.subrange(0, s.len() - 1)) + 
        (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
    }
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
    requires 
        valid_bit_string(s1) && valid_bit_string(s2)
    ensures 
        valid_bit_string(res) &&
        str2int(res) == str2int(s1) + str2int(s2)
{
    assume(false);
    unreached()
}",,"fn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)
    requires 
        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&
        (str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0) &&
        sy@.len() == n as int + 1 &&
        str2int(sz@) > 1
    ensures 
        valid_bit_string(res@) &&
        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)
    decreases n","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVB03,0.85
VB0014,verus,bignum,bignum_ModExpPow2_Add_DivMod,,"Bignum task: bignum_ModExpPow2[Add,DivMod].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */

/* sy is power of 2 or zero */","use vstd::prelude::*;

verus! {

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

spec fn str2int(s: Seq<char>) -> nat
  decreases s.len()
{
  if s.len() == 0 { 
    0nat 
  } else { 
    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
  }
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2)
  ensures 
    valid_bit_string(res) && str2int(res) == str2int(s1) + str2int(s2)
{
  assume(false);
  unreached()
}

fn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))
  requires 
    valid_bit_string(dividend) && valid_bit_string(divisor) && str2int(divisor) > 0
  ensures 
    valid_bit_string(res.0) && valid_bit_string(res.1) &&
    str2int(res.0) == str2int(dividend) / str2int(divisor) &&
    str2int(res.1) == str2int(dividend) % str2int(divisor)
{
  assume(false);
  unreached()
}",,"fn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)
  requires 
    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&
    (str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0) &&
    sy@.len() == n as int + 1 &&
    str2int(sz@) > 1
  ensures 
    valid_bit_string(res@) &&
    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)
  decreases n","{
  // impl-start
  assume(false);
  unreached()
  // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,DupVB03,0.85
VB0015,verus,bignum,bignum_ModExpPow2_Add_DivMod_Mul,,"Bignum task: bignum_ModExpPow2[Add,DivMod,Mul].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */

/* sy is power of 2 or zero */","use vstd::prelude::*;

verus! {

spec fn exp_int(x: nat, y: nat) -> nat
    decreases y
{
    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

spec fn str2int(s: Seq<char>) -> nat
    recommends valid_bit_string(s)
    decreases s.len()
{
    if s.len() == 0 { 
        0nat 
    } else { 
        2nat * str2int(s.subrange(0, s.len() - 1)) + 
        (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
    }
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
    requires 
        valid_bit_string(s1) && valid_bit_string(s2),
    ensures 
        valid_bit_string(res) &&
        str2int(res) == str2int(s1) + str2int(s2),
{
    assume(false);
    unreached()
}

fn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))
    requires 
        valid_bit_string(dividend) && valid_bit_string(divisor) &&
        str2int(divisor) > 0,
    ensures 
        valid_bit_string(res.0) && valid_bit_string(res.1) &&
        str2int(res.0) == str2int(dividend) / str2int(divisor) &&
        str2int(res.1) == str2int(dividend) % str2int(divisor),
{
    assume(false);
    unreached()
}

fn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
    requires 
        valid_bit_string(s1) && valid_bit_string(s2),
    ensures 
        valid_bit_string(res) &&
        str2int(res) == str2int(s1) * str2int(s2),
{
    assume(false);
    unreached()
}",,"fn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)
    requires 
        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&
        (str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0) &&
        sy@.len() == n as int + 1 &&
        str2int(sz@) > 1,
    ensures 
        valid_bit_string(res@) &&
        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@),
    decreases n,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,DupVB03,0.85
VB0016,verus,bignum,bignum_ModExpPow2_Add_Mul,,"Bignum task: bignum_ModExpPow2[Add,Mul].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */

/* sy is power of 2 or zero */","use vstd::prelude::*;

verus! {

spec fn exp_int(x: nat, y: nat) -> nat
    decreases y
{
    if y == 0 { 1nat } else { x * exp_int(x, (y - 1nat) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

spec fn str2int(s: Seq<char>) -> nat
    decreases s.len()
{
    if s.len() == 0 { 
        0nat 
    } else { 
        2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
    }
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
    requires
        valid_bit_string(s1) && valid_bit_string(s2)
    ensures
        valid_bit_string(res) &&
        str2int(res) == str2int(s1) + str2int(s2)
{
    assume(false);
    unreached()
}

fn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
    requires
        valid_bit_string(s1) && valid_bit_string(s2)
    ensures
        valid_bit_string(res) &&
        str2int(res) == str2int(s1) * str2int(s2)
{
    assume(false);
    unreached()
}",,"fn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)
    requires
        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&
        (str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0) &&
        sy@.len() == n as int + 1 &&
        str2int(sz@) > 1
    ensures
        valid_bit_string(res@) &&
        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)
    decreases n as nat","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVB03,0.85
VB0017,verus,bignum,bignum_ModExpPow2_DivMod,,"Bignum task: bignum_ModExpPow2[DivMod].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */

/* sy is power of 2 or zero */","use vstd::prelude::*;

verus! {
spec fn exp_int(x: nat, y: nat) -> nat
    decreases y
{
    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

spec fn str2int(s: Seq<char>) -> nat
    decreases s.len()
{
    if s.len() == 0 {
        0nat
    } else {
        if valid_bit_string(s) {
            2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
        } else {
            0nat
        }
    }
}

fn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (result: (Seq<char>, Seq<char>))
    requires 
        valid_bit_string(dividend) && valid_bit_string(divisor) && str2int(divisor) > 0
    ensures 
        valid_bit_string(result.0) && valid_bit_string(result.1),
        str2int(result.0) == str2int(dividend) / str2int(divisor),
        str2int(result.1) == str2int(dividend) % str2int(divisor)
{
    assume(false);
    unreached()
}",,"fn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)
    requires 
        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@),
        str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0,
        sy.len() == n as int + 1,
        str2int(sz@) > 1
    ensures 
        valid_bit_string(res@),
        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)
    decreases n","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVB03,0.85
VB0018,verus,bignum,bignum_ModExpPow2_DivMod_Mul,,"Bignum task: bignum_ModExpPow2[DivMod,Mul].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */

/* sy is power of 2 or zero */","use vstd::prelude::*;

verus! {

spec fn exp_int(x: nat, y: nat) -> nat
    decreases y
{
    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool
{
    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

spec fn str2int(s: Seq<char>) -> nat
    decreases s.len()
{
    if !valid_bit_string(s) {
        0nat
    } else if s.len() == 0 { 
        0nat 
    } else { 
        2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
    }
}

fn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))
    requires 
        valid_bit_string(dividend) && valid_bit_string(divisor),
        str2int(divisor) > 0,
    ensures 
        valid_bit_string(res.0) && valid_bit_string(res.1),
        str2int(res.0) == str2int(dividend) / str2int(divisor),
        str2int(res.1) == str2int(dividend) % str2int(divisor),
{
    assume(false);
    unreached()
}

fn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
    requires 
        valid_bit_string(s1) && valid_bit_string(s2),
    ensures 
        valid_bit_string(res),
        str2int(res) == str2int(s1) * str2int(s2),
{
    assume(false);
    unreached()
}",,"fn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)
    requires 
        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@),
        str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0,
        sy@.len() == n as int + 1,
        str2int(sz@) > 1,
    ensures 
        valid_bit_string(res@),
        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@),
    decreases n","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVB03,0.85
VB0019,verus,bignum,bignum_ModExpPow2_Mul,,"Bignum task: bignum_ModExpPow2[Mul].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */

/* sy is power of 2 or zero */","use vstd::prelude::*;

verus! {

spec fn exp_int(x: nat, y: nat) -> nat
    decreases y
{
    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

spec fn str2int(s: Seq<char>) -> nat
    decreases s.len()
{
    if s.len() == 0 { 
        0nat 
    } else { 
        2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
    }
}

fn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
    requires 
        valid_bit_string(s1) && valid_bit_string(s2)
    ensures 
        valid_bit_string(res) &&
        str2int(res) == str2int(s1) * str2int(s2)
{
    assume(false);
    unreached()
}",,"fn mod_exp_pow2(sx: Vec<char>, sy: Vec<char>, n: u8, sz: Vec<char>) -> (res: Vec<char>)
    requires 
        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&
        (str2int(sy@) == exp_int(2nat, n as nat) || str2int(sy@) == 0) &&
        sy@.len() == n as int + 1 &&
        str2int(sz@) > 1
    ensures 
        valid_bit_string(res@) &&
        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)
    decreases n","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVB03,0.85
VB0020,verus,bignum,bignum_ModExpPow2_int,,"Bignum task: bignum_ModExpPow2_int.
Implement the method according to the Dafny specification.","use vstd::prelude::*;

verus! {
spec fn exp_int(x: nat, y: nat) -> nat
    decreases y
{
    if y == 0 { 1 } else { x * exp_int(x, (y - 1) as nat) }
}",,"fn mod_exp_pow2_int(x: u8, y: u8, n: u8, z: u8) -> (res: u8)
    requires 
        y as nat == exp_int(2, n as nat),
        z > 0,
    ensures res as nat == exp_int(x as nat, y as nat) % (z as nat)
    decreases n","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VB0021,verus,bignum,bignum_ModExp_Add,,"Bignum task: bignum_ModExp[Add].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */

/*requires y < Exp_int(2,n+1)*/

/*&& n > 0*/","use vstd::prelude::*;

verus! {
spec fn str2int(s: Seq<char>) -> nat
  decreases s.len()
{
  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s.index(s.len() - 1) == '1' { 1nat } else { 0nat }) }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool
{
  forall|i: int| 0 <= i < s.len() ==> s.index(i) == '0' || s.index(i) == '1'
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2),
  ensures 
    valid_bit_string(res) &&
    str2int(res) == str2int(s1) + str2int(s2),
{
  assume(false);
  unreached()
}",,"fn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)
  requires 
    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&
    sy@.len() > 0 && str2int(sz@) > 1,
  ensures 
    valid_bit_string(res@) &&
    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@),
  decreases sy@.len(),","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVB00,0.85
VB0022,verus,bignum,bignum_ModExp_Add_DivMod,,"Bignum task: bignum_ModExp[Add,DivMod].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */

/* requires y < Exp_int(2,n+1) */

/* && n > 0 */","use vstd::prelude::*;

verus! {

spec fn str2_int(s: Seq<char>) -> nat
  decreases s.len()
{
  if s.len() == 0 { 0nat } else { 2nat * str2_int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1nat) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2),
  ensures 
    valid_bit_string(res) &&
    str2_int(res) == str2_int(s1) + str2_int(s2),
{
  assume(false);
  unreached()
}

fn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))
  requires 
    valid_bit_string(dividend) && valid_bit_string(divisor) &&
    str2_int(divisor) > 0,
  ensures 
    valid_bit_string(res.0) && valid_bit_string(res.1) &&
    str2_int(res.0) == str2_int(dividend) / str2_int(divisor) &&
    str2_int(res.1) == str2_int(dividend) % str2_int(divisor),
{
  assume(false);
  unreached()
}",,"fn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)
  requires 
    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&
    sy@.len() > 0 && str2_int(sz@) > 1,
  ensures 
    valid_bit_string(res@) &&
    str2_int(res@) == exp_int(str2_int(sx@), str2_int(sy@)) % str2_int(sz@),
  decreases sy@.len()","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVB00,0.85
VB0023,verus,bignum,bignum_ModExp_Add_DivMod_ModExpPow2,,"Bignum task: bignum_ModExp[Add,DivMod,ModExpPow2].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */

/* sy is power of 2 or zero */

/* requires y < Exp_int(2,n+1) */

/* && n > 0 */","use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
  recommends valid_bit_string(s)
  decreases s.len()
{
  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires
      valid_bit_string(s1) && valid_bit_string(s2)
  ensures
      valid_bit_string(res) &&
      str2int(res) == str2int(s1) + str2int(s2)
{
  assume(false);
  unreached()
}

fn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (result: (Seq<char>, Seq<char>))
  requires
      valid_bit_string(dividend) && valid_bit_string(divisor) &&
      str2int(divisor) > 0
  ensures
      valid_bit_string(result.0) && valid_bit_string(result.1) &&
      str2int(result.0) == str2int(dividend) / str2int(divisor) &&
      str2int(result.1) == str2int(dividend) % str2int(divisor)
{
  assume(false);
  unreached()
}

fn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)
  requires
      valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&
      (str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0) &&
      sy.len() == n + 1 &&
      str2int(sz) > 1
  ensures
      valid_bit_string(res) &&
      str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)
  decreases n
{
  assume(false);
  unreached()
}",,"fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)
  requires
      valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&
      sy.len() > 0 && str2int(sz) > 1
  ensures
      valid_bit_string(res) &&
      str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)
  decreases sy.len()","{
  // impl-start
  assume(false);
  unreached()
  // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,DupVB01,0.85
VB0024,verus,bignum,bignum_ModExp_Add_DivMod_ModExpPow2_Mul,,"Bignum task: bignum_ModExp[Add,DivMod,ModExpPow2,Mul].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */

/* sy is power of 2 or zero */

/* requires y < Exp_int(2,n+1) */

/* && n > 0 */","use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
  recommends valid_bit_string(s)
  decreases s.len()
{
  if s.len() == 0 {
    0nat
  } else {
    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
  }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2)
  ensures 
    valid_bit_string(res),
    str2int(res) == str2int(s1) + str2int(s2)
{
  assume(false);
  unreached()
}

fn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))
  requires 
    valid_bit_string(dividend) && valid_bit_string(divisor),
    str2int(divisor) > 0
  ensures 
    valid_bit_string(res.0) && valid_bit_string(res.1),
    str2int(res.0) == str2int(dividend) / str2int(divisor),
    str2int(res.1) == str2int(dividend) % str2int(divisor)
{
  assume(false);
  unreached()
}

fn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),
    str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0,
    sy.len() == n + 1,
    str2int(sz) > 1
  ensures 
    valid_bit_string(res),
    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)
  decreases n
{
  assume(false);
  unreached()
}

fn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2)
  ensures 
    valid_bit_string(res),
    str2int(res) == str2int(s1) * str2int(s2)
{
  assume(false);
  unreached()
}",,"fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),
    sy.len() > 0 && str2int(sz) > 1
  ensures 
    valid_bit_string(res),
    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)
  decreases sy.len()","{
  // impl-start
  assume(false);
  unreached()
  // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,DupVB01,0.85
VB0025,verus,bignum,bignum_ModExp_Add_DivMod_ModExpPow2_Zeroes,,"Bignum task: bignum_ModExp[Add,DivMod,ModExpPow2,Zeroes].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */

/* sy is power of 2 or zero */

/* requires y < Exp_int(2,n+1) */

/* && n > 0 */","use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
    decreases s.len()
{
    if s.len() == 0 { 
        0nat 
    } else { 
        2 * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
    }
}

spec fn exp_int(x: nat, y: nat) -> nat
    decreases y
{
    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

spec fn all_zero(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> s[i] == '0'
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
    requires 
        valid_bit_string(s1) && valid_bit_string(s2)
    ensures 
        valid_bit_string(res) &&
        str2int(res) == str2int(s1) + str2int(s2)
{
    assume(false);
    unreached()
}

fn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))
    requires 
        valid_bit_string(dividend) && valid_bit_string(divisor) &&
        str2int(divisor) > 0
    ensures 
        valid_bit_string(res.0) && valid_bit_string(res.1) &&
        str2int(res.0) == str2int(dividend) / str2int(divisor) &&
        str2int(res.1) == str2int(dividend) % str2int(divisor)
{
    assume(false);
    unreached()
}

fn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)
    requires 
        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&
        (str2int(sy) == exp_int(2, n) || str2int(sy) == 0) &&
        sy.len() == n + 1 &&
        str2int(sz) > 1
    ensures 
        valid_bit_string(res) &&
        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)
    decreases n
{
    assume(false);
    unreached()
}

fn zeros(n: nat) -> (s: Seq<char>)
    ensures 
        s.len() == n &&
        valid_bit_string(s) &&
        str2int(s) == 0 &&
        all_zero(s)
{
    assume(false);
    unreached()
}",,"fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)
    requires 
        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&
        sy.len() > 0 && str2int(sz) > 1
    ensures 
        valid_bit_string(res) &&
        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)
    decreases sy.len()","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,DupVB01,0.85
VB0026,verus,bignum,bignum_ModExp_Add_DivMod_Mul,,"Bignum task: bignum_ModExp[Add,DivMod,Mul].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */

/* requires y < Exp_int(2,n+1) */

/* && n > 0 */","use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
  decreases s.len()
{
  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2),
  ensures 
    valid_bit_string(res) &&
    str2int(res) == str2int(s1) + str2int(s2),
{
  assume(false);
  unreached()
}

fn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (ret: (Seq<char>, Seq<char>))
  requires 
    valid_bit_string(dividend) && valid_bit_string(divisor) &&
    str2int(divisor) > 0,
  ensures 
    valid_bit_string(ret.0) && valid_bit_string(ret.1) &&
    str2int(ret.0) == str2int(dividend) / str2int(divisor) &&
    str2int(ret.1) == str2int(dividend) % str2int(divisor),
{
  assume(false);
  unreached()
}

fn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2),
  ensures 
    valid_bit_string(res) &&
    str2int(res) == str2int(s1) * str2int(s2),
{
  assume(false);
  unreached()
}",,"fn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)
  requires 
    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&
    sy@.len() > 0 && str2int(sz@) > 1,
  ensures 
    valid_bit_string(res@) &&
    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@),
  decreases sy@.len()","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVB00,0.85
VB0027,verus,bignum,bignum_ModExp_Add_DivMod_Mul_Zeroes,,"Bignum task: bignum_ModExp[Add,DivMod,Mul,Zeroes].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */

/* requires y < Exp_int(2,n+1) */

/* && n > 0 */","use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
  recommends valid_bit_string(s)
  decreases s.len()
{
  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1nat) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
}

spec fn all_zero(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2)
  ensures 
    valid_bit_string(res),
    str2int(res) == str2int(s1) + str2int(s2)
{
  assume(false);
  unreached()
}

fn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))
  requires 
    valid_bit_string(dividend) && valid_bit_string(divisor),
    str2int(divisor) > 0
  ensures 
    valid_bit_string(res.0) && valid_bit_string(res.1),
    str2int(res.0) == str2int(dividend) / str2int(divisor),
    str2int(res.1) == str2int(dividend) % str2int(divisor)
{
  assume(false);
  unreached()
}

fn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2)
  ensures 
    valid_bit_string(res),
    str2int(res) == str2int(s1) * str2int(s2)
{
  assume(false);
  unreached()
}

fn zeros(n: nat) -> (s: Seq<char>)
  ensures 
    s.len() == n,
    valid_bit_string(s),
    str2int(s) == 0,
    all_zero(s)
{
  assume(false);
  unreached()
}",,"fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),
    sy.len() > 0 && str2int(sz) > 1
  ensures 
    valid_bit_string(res),
    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)
  decreases sy.len()","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VB0028,verus,bignum,bignum_ModExp_Add_DivMod_Zeroes,,"Bignum task: bignum_ModExp[Add,DivMod,Zeroes].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */

/* requires y < Exp_int(2,n+1) */

/* && n > 0 */","use vstd::prelude::*;

verus! {

spec fn str2_int(s: Seq<char>) -> nat
  decreases s.len()
{
  if s.len() == 0 { 
    0nat 
  } else { 
    if valid_bit_string(s) {
      2 * str2_int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
    } else {
      0nat
    }
  }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool
{
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

spec fn all_zero(s: Seq<char>) -> bool
{
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2),
  ensures 
    valid_bit_string(res) &&
    str2_int(res) == str2_int(s1) + str2_int(s2),
{
  assume(false);
  unreached()
}

fn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (quotient_remainder: (Seq<char>, Seq<char>))
  requires 
    valid_bit_string(dividend) && valid_bit_string(divisor) &&
    str2_int(divisor) > 0,
  ensures 
    valid_bit_string(quotient_remainder.0) && valid_bit_string(quotient_remainder.1) &&
    str2_int(quotient_remainder.0) == str2_int(dividend) / str2_int(divisor) &&
    str2_int(quotient_remainder.1) == str2_int(dividend) % str2_int(divisor),
{
  assume(false);
  unreached()
}

fn zeros(n: nat) -> (s: Seq<char>)
  ensures 
    s.len() == n &&
    valid_bit_string(s) &&
    str2_int(s) == 0 &&
    all_zero(s),
{
  assume(false);
  unreached()
}",,"fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&
    sy.len() > 0 && str2_int(sz) > 1,
  ensures 
    valid_bit_string(res) &&
    str2_int(res) == exp_int(str2_int(sx), str2_int(sy)) % str2_int(sz),
  decreases sy.len(),","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVB00,0.85
VB0029,verus,bignum,bignum_ModExp_Add_ModExpPow2,,"Bignum task: bignum_ModExp[Add,ModExpPow2].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */

/* sy is power of 2 or zero */

/* requires y < Exp_int(2,n+1) */

/* && n > 0 */","use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<u8>) -> nat
  decreases s.len()
{
  if s.len() == 0 { 
    0nat 
  } else { 
    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == 49u8 { 1nat } else { 0nat })
  }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<u8>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> (s[i] == 48u8 || s[i] == 49u8)
}

fn add(s1: Seq<u8>, s2: Seq<u8>) -> (res: Seq<u8>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2)
  ensures 
    valid_bit_string(res) &&
    str2int(res) == str2int(s1) + str2int(s2)
{
  assume(false);
  unreached()
}

fn mod_exp_pow2(sx: Seq<u8>, sy: Seq<u8>, n: nat, sz: Seq<u8>) -> (res: Seq<u8>)
  requires 
    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&
    (str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0) &&
    sy.len() == n + 1 &&
    str2int(sz) > 1
  ensures 
    valid_bit_string(res) &&
    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)
  decreases n
{
  assume(false);
  unreached()
}",,"fn mod_exp(sx: Vec<u8>, sy: Vec<u8>, sz: Vec<u8>) -> (res: Vec<u8>)
  requires 
    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&
    sy.len() > 0 && str2int(sz@) > 1
  ensures 
    valid_bit_string(res@) &&
    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)
  decreases sy.len()","{
  // impl-start
  assume(false);
  unreached()
  // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,DupVB00,0.85
VB0030,verus,bignum,bignum_ModExp_Add_ModExpPow2_Mul,,"Bignum task: bignum_ModExp[Add,ModExpPow2,Mul].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */

/* sy is power of 2 or zero */

/* requires y < Exp_int(2,n+1) */

/* && n > 0 */","use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
    decreases s.len()
{
    if s.len() == 0 { 
        0nat 
    } else { 
        2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
    }
}

spec fn exp_int(x: nat, y: nat) -> nat
    decreases y
{
    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool
{
    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
    requires 
        valid_bit_string(s1) && valid_bit_string(s2)
    ensures 
        valid_bit_string(res) &&
        str2int(res) == str2int(s1) + str2int(s2)
{
    assume(false);
    unreached()
}

fn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)
    requires 
        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&
        (str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0) &&
        sy.len() == n + 1 &&
        str2int(sz) > 1
    ensures 
        valid_bit_string(res) &&
        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)
    decreases n
{
    assume(false);
    unreached()
}

fn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
    requires 
        valid_bit_string(s1) && valid_bit_string(s2)
    ensures 
        valid_bit_string(res) &&
        str2int(res) == str2int(s1) * str2int(s2)
{
    assume(false);
    unreached()
}",,"fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)
    requires 
        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&
        sy.len() > 0 && str2int(sz) > 1
    ensures 
        valid_bit_string(res) &&
        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)
    decreases sy.len()","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVB01,0.85
VB0031,verus,bignum,bignum_ModExp_Add_ModExpPow2_Mul_Zeroes,,"Bignum task: bignum_ModExp[Add,ModExpPow2,Mul,Zeroes].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */

/* sy is power of 2 or zero */

/* requires y < Exp_int(2,n+1) */

/* && n > 0 */","use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
  recommends valid_bit_string(s)
  decreases s.len()
{
  if s.len() == 0 {
    0nat
  } else {
    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
  }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0nat { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

spec fn all_zero(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2)
  ensures 
    valid_bit_string(res),
    str2int(res) == str2int(s1) + str2int(s2)
{
  assume(false);
  unreached()
}

fn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),
    str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0,
    sy.len() == n + 1,
    str2int(sz) > 1
  ensures 
    valid_bit_string(res),
    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)
  decreases n
{
  assume(false);
  unreached()
}

fn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2)
  ensures 
    valid_bit_string(res),
    str2int(res) == str2int(s1) * str2int(s2)
{
  assume(false);
  unreached()
}

fn zeros(n: nat) -> (s: Seq<char>)
  ensures 
    s.len() == n,
    valid_bit_string(s),
    str2int(s) == 0,
    all_zero(s)
{
  assume(false);
  unreached()
}",,"fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),
    sy.len() > 0 && str2int(sz) > 1
  ensures 
    valid_bit_string(res),
    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)
  decreases sy.len()","{
  // impl-start
  assume(false);
  unreached()
  // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,DupVB00,0.85
VB0032,verus,bignum,bignum_ModExp_Add_ModExpPow2_Zeroes,,"Bignum task: bignum_ModExp[Add,ModExpPow2,Zeroes].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */

/* sy is power of 2 or zero */

/* requires y < Exp_int(2,n+1) */

/* && n > 0 */","use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
  decreases s.len()
{
  if s.len() == 0 { 
      0nat 
  } else { 
      2nat * str2int(s.subrange(0, s.len() as int - 1)) + (if s[s.len() as int - 1] == '1' { 1nat } else { 0nat })
  }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1nat) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool
{
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
}

spec fn all_zero(s: Seq<char>) -> bool
{
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
      valid_bit_string(s1) && valid_bit_string(s2),
  ensures 
      valid_bit_string(res),
      str2int(res) == str2int(s1) + str2int(s2),
{
  assume(false);
  unreached()
}

fn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)
  requires 
      valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),
      str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0,
      sy.len() == n + 1,
      str2int(sz) > 1,
  ensures 
      valid_bit_string(res),
      str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz),
  decreases n
{
  assume(false);
  unreached()
}

fn zeros(n: nat) -> (s: Seq<char>)
  ensures 
      s.len() == n,
      valid_bit_string(s),
      str2int(s) == 0,
      all_zero(s),
{
  assume(false);
  unreached()
}",,"fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)
  requires 
      valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),
      sy.len() > 0 && str2int(sz) > 1,
  ensures 
      valid_bit_string(res),
      str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz),
  decreases sy.len()","{
  // impl-start
  assume(false);
  unreached()
  // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,DupVB00,0.85
VB0033,verus,bignum,bignum_ModExp_Add_Mul,,"Bignum task: bignum_ModExp[Add,Mul].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */

/* requires y < Exp_int(2,n+1) */

/* && n > 0 */","use vstd::prelude::*;

verus! {

spec fn str2_int(s: Seq<char>) -> nat
  decreases s.len()
{
  if s.len() == 0 { 0nat } else { 2nat * str2_int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool
{
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2),
  ensures 
    valid_bit_string(res) &&
    str2_int(res) == str2_int(s1) + str2_int(s2),
{
  assume(false);
  unreached()
}

fn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2),
  ensures 
    valid_bit_string(res) &&
    str2_int(res) == str2_int(s1) * str2_int(s2),
{
  assume(false);
  unreached()
}",,"fn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)
  requires 
    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&
    sy@.len() > 0 && str2_int(sz@) > 1,
  ensures 
    valid_bit_string(res@) &&
    str2_int(res@) == exp_int(str2_int(sx@), str2_int(sy@)) % str2_int(sz@),
  decreases sy@.len(),","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVB00,0.85
VB0034,verus,bignum,bignum_ModExp_Add_Mul_Zeroes,,"Bignum task: bignum_ModExp[Add,Mul,Zeroes].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */

/* requires y < Exp_int(2,n+1) */

/* && n > 0 */","use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
  decreases s.len()
{
  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

spec fn all_zero(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2)
  ensures 
    valid_bit_string(res) &&
    str2int(res) == str2int(s1) + str2int(s2)
{
  assume(false);
  unreached()
}

fn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2)
  ensures 
    valid_bit_string(res) &&
    str2int(res) == str2int(s1) * str2int(s2)
{
  assume(false);
  unreached()
}

fn zeros(n: nat) -> (s: Seq<char>)
  ensures 
    s.len() == n &&
    valid_bit_string(s) &&
    str2int(s) == 0 &&
    all_zero(s)
{
  assume(false);
  unreached()
}",,"fn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)
  requires 
    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&
    sy.len() > 0 && str2int(sz@) > 1
  ensures 
    valid_bit_string(res@) &&
    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)
  decreases sy.len()","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVB00,0.85
VB0035,verus,bignum,bignum_ModExp_Add_Zeroes,,"Bignum task: bignum_ModExp[Add,Zeroes].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */

/* requires y < Exp_int(2,n+1) */

/* && n > 0 */","use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
  decreases s.len()
{
  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool
{
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
}

spec fn all_zero(s: Seq<char>) -> bool
{
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2),
  ensures 
    valid_bit_string(res),
    str2int(res) == str2int(s1) + str2int(s2),
{
  assume(false);
  unreached()
}

fn zeros(n: nat) -> (s: Seq<char>)
  ensures 
    s.len() == n,
    valid_bit_string(s),
    str2int(s) == 0,
    all_zero(s),
{
  assume(false);
  unreached()
}",,"fn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)
  requires 
    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@),
    sy@.len() > 0 && str2int(sz@) > 1,
  ensures 
    valid_bit_string(res@),
    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@),","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVB00,0.85
VB0036,verus,bignum,bignum_ModExp_DivMod,,"Bignum task: bignum_ModExp[DivMod].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */

/* requires y < Exp_int(2,n+1) */

/* && n > 0 */","use vstd::prelude::*;

verus! {
spec fn str2int(s: Seq<char>) -> nat
  recommends valid_bit_string(s)
  decreases s.len()
{
  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, (s.len() - 1) as int)) + (if s[(s.len() - 1) as int] == '1' { 1nat } else { 0nat }) }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

fn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (result: (Seq<char>, Seq<char>))
  requires 
      valid_bit_string(dividend) && valid_bit_string(divisor) &&
      str2int(divisor) > 0
  ensures 
      valid_bit_string(result.0) && valid_bit_string(result.1) &&
      str2int(result.0) == str2int(dividend) / str2int(divisor) &&
      str2int(result.1) == str2int(dividend) % str2int(divisor)
{
  assume(false);
  unreached()
}",,"fn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)
  requires 
      valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&
      sy@.len() > 0 && str2int(sz@) > 1
  ensures 
      valid_bit_string(res@) &&
      str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)
  decreases sy@.len()","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVB00,0.85
VB0037,verus,bignum,bignum_ModExp_DivMod_ModExpPow2,,"Bignum task: bignum_ModExp[DivMod,ModExpPow2].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */

/* sy is power of 2 or zero */

/* requires y < Exp_int(2,n+1) */

/* && n > 0 */","use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
  recommends valid_bit_string(s)
  decreases s.len()
{
  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

fn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (result: (Seq<char>, Seq<char>))
  requires 
    valid_bit_string(dividend) && valid_bit_string(divisor) &&
    str2int(divisor) > 0
  ensures 
    ({
       let (quotient, remainder) = result; 
       valid_bit_string(quotient) && valid_bit_string(remainder) &&
       str2int(quotient) == str2int(dividend) / str2int(divisor) &&
       str2int(remainder) == str2int(dividend) % str2int(divisor)
    })
{
  assume(false);
  unreached()
}

fn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&
    (str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0) &&
    sy.len() == n + 1 &&
    str2int(sz) > 1
  ensures 
    valid_bit_string(res) &&
    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)
  decreases n
{
  assume(false);
  unreached()
}",,"fn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)
  requires 
    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&
    sy.len() > 0 && str2int(sz@) > 1
  ensures 
    valid_bit_string(res@) &&
    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)
  decreases sy.len()","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VB0038,verus,bignum,bignum_ModExp_DivMod_ModExpPow2_Mul,,"Bignum task: bignum_ModExp[DivMod,ModExpPow2,Mul].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */

/* sy is power of 2 or zero */

/* requires y < Exp_int(2,n+1) */

/* && n > 0 */","use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
  recommends valid_bit_string(s)
  decreases s.len()
{
  if s.len() == 0 {
    0nat
  } else {
    2nat * str2int(s.subrange(0, s.len() - 1)) + 
     (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
  }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 {
    1nat
  } else {
    x * exp_int(x, (y - 1) as nat)
  }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

fn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))
  requires 
    valid_bit_string(dividend) && valid_bit_string(divisor),
    str2int(divisor) > 0,
  ensures 
    valid_bit_string(res.0) && valid_bit_string(res.1),
    str2int(res.0) == str2int(dividend) / str2int(divisor),
    str2int(res.1) == str2int(dividend) % str2int(divisor),
{
  assume(false);
  unreached()
}

fn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),
    str2int(sy) == exp_int(2, n) || str2int(sy) == 0,
    sy.len() == n + 1,
    str2int(sz) > 1,
  ensures 
    valid_bit_string(res),
    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz),
  decreases n
{
  assume(false);
  unreached()
}

fn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2),
  ensures 
    valid_bit_string(res),
    str2int(res) == str2int(s1) * str2int(s2),
{
  assume(false);
  unreached()
}",,"fn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)
  requires 
    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@),
    sy@.len() > 0 && str2int(sz@) > 1,
  ensures 
    valid_bit_string(res@),
    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@),
  decreases sy@.len()","{
  // impl-start
  assume(false);
  unreached()
  // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,DupVB03,0.85
VB0039,verus,bignum,bignum_ModExp_DivMod_ModExpPow2_Mul_Zeroes,,"Bignum task: bignum_ModExp[DivMod,ModExpPow2,Mul,Zeroes].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */

/* sy is power of 2 or zero */

/* requires y < Exp_int(2,n+1) */

/* && n > 0 */","use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
  recommends valid_bit_string(s)
  decreases s.len()
{
  if s.len() == 0 { 
    0nat 
  } else { 
    2nat * str2int(s.subrange(0, s.len() - 1)) + 
    (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
  }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

spec fn all_zero(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'
}

fn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (result: (Seq<char>, Seq<char>))
  requires 
    valid_bit_string(dividend) && valid_bit_string(divisor),
    str2int(divisor) > 0,
  ensures 
    valid_bit_string(result.0) && valid_bit_string(result.1),
    str2int(result.0) == str2int(dividend) / str2int(divisor),
    str2int(result.1) == str2int(dividend) % str2int(divisor),
{
  assume(false);
  unreached()
}

fn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),
    str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0,
    sy.len() == n + 1,
    str2int(sz) > 1,
  ensures 
    valid_bit_string(res),
    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz),
  decreases n
{
  assume(false);
  unreached()
}

fn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2),
  ensures 
    valid_bit_string(res),
    str2int(res) == str2int(s1) * str2int(s2),
{
  assume(false);
  unreached()
}

fn zeros(n: nat) -> (s: Seq<char>)
  ensures 
    s.len() == n,
    valid_bit_string(s),
    str2int(s) == 0,
    all_zero(s),
{
  assume(false);
  unreached()
}",,"fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),
    sy.len() > 0 && str2int(sz) > 1,
  ensures 
    valid_bit_string(res),
    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz),
  decreases sy.len()","{
  // impl-start
  assume(false);
  unreached()
  // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,DupVB00,0.85
VB0040,verus,bignum,bignum_ModExp_DivMod_ModExpPow2_Zeroes,,"Bignum task: bignum_ModExp[DivMod,ModExpPow2,Zeroes].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */

/* sy is power of 2 or zero */

/* requires y < Exp_int(2,n+1) */

/* && n > 0 */","use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
    decreases s.len()
{
    if s.len() == 0 {
        0nat
    } else {
        2 * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
    }
}

spec fn exp_int(x: nat, y: nat) -> nat
    decreases y
{
    if y == 0 {
        1nat
    } else {
        x * exp_int(x, (y - 1) as nat)
    }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

spec fn all_zero(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> s[i] == '0'
}

fn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (ret: (Seq<char>, Seq<char>))
    requires 
        valid_bit_string(dividend) && valid_bit_string(divisor),
        str2int(divisor) > 0
    ensures 
        valid_bit_string(ret.0) && valid_bit_string(ret.1),
        str2int(ret.0) == str2int(dividend) / str2int(divisor),
        str2int(ret.1) == str2int(dividend) % str2int(divisor)
{
    assume(false);
    unreached()
}

fn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)
    requires 
        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),
        str2int(sy) == exp_int(2, n) || str2int(sy) == 0,
        sy.len() == n + 1,
        str2int(sz) > 1
    ensures 
        valid_bit_string(res),
        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)
    decreases n
{
    assume(false);
    unreached()
}

fn zeros(n: nat) -> (s: Seq<char>)
    ensures 
        s.len() == n,
        valid_bit_string(s),
        str2int(s) == 0,
        all_zero(s)
{
    assume(false);
    unreached()
}",,"fn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)
    requires 
        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@),
        sy@.len() > 0 && str2int(sz@) > 1
    ensures 
        valid_bit_string(res@),
        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)
    decreases sy@.len()","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VB0041,verus,bignum,bignum_ModExp_DivMod_Mul,,"Bignum task: bignum_ModExp[DivMod,Mul].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */

/* requires y < Exp_int(2,n+1) */

/* && n > 0 */","use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
  decreases s.len()
{
  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1nat) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool
{
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

fn div_mod(dividend: Vec<char>, divisor: Vec<char>) -> (res: (Vec<char>, Vec<char>))
  requires 
    valid_bit_string(dividend@) && valid_bit_string(divisor@) &&
    str2int(divisor@) > 0
  ensures 
    valid_bit_string(res.0@) && valid_bit_string(res.1@) &&
    str2int(res.0@) == str2int(dividend@) / str2int(divisor@) &&
    str2int(res.1@) == str2int(dividend@) % str2int(divisor@)
{
  assume(false);
  (Vec::new(), Vec::new())
}

fn mul(s1: Vec<char>, s2: Vec<char>) -> (res: Vec<char>)
  requires valid_bit_string(s1@) && valid_bit_string(s2@)
  ensures 
    valid_bit_string(res@) &&
    str2int(res@) == str2int(s1@) * str2int(s2@)
{
  assume(false);
  Vec::new()
}",,"fn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)
  requires 
    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&
    sy@.len() > 0 && str2int(sz@) > 1
  ensures 
    valid_bit_string(res@) &&
    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)
  decreases sy@.len()","{
  assume(false);
  Vec::new()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VB0042,verus,bignum,bignum_ModExp_DivMod_Mul_Zeroes,,"Bignum task: bignum_ModExp[DivMod,Mul,Zeroes].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */

/* requires y < Exp_int(2,n+1) */

/* && n > 0 */","use vstd::prelude::*;

verus! {
spec fn str2int(s: Seq<char>) -> nat
  decreases s.len()
{
  if s.len() == 0 {
      0nat
  } else {
      2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
  }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

spec fn all_zero(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'
}

fn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (result: (Seq<char>, Seq<char>))
  requires
      valid_bit_string(dividend) && valid_bit_string(divisor) &&
      str2int(divisor) > 0
  ensures
      valid_bit_string(result.0) && valid_bit_string(result.1) &&
      str2int(result.0) == str2int(dividend) / str2int(divisor) &&
      str2int(result.1) == str2int(dividend) % str2int(divisor)
{
  assume(false);
  unreached()
}

fn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires valid_bit_string(s1) && valid_bit_string(s2)
  ensures
      valid_bit_string(res) &&
      str2int(res) == str2int(s1) * str2int(s2)
{
  assume(false);
  unreached()
}

fn zeros(n: nat) -> (s: Seq<char>)
  ensures
      s.len() == n &&
      valid_bit_string(s) &&
      str2int(s) == 0 &&
      all_zero(s)
{
  assume(false);
  unreached()
}",,"fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)
  requires
      valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&
      sy.len() > 0 && str2int(sz) > 1
  ensures
      valid_bit_string(res) &&
      str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)
  decreases sy.len()","{
  // impl-start
  assume(false);
  unreached()
  // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VB0043,verus,bignum,bignum_ModExp_DivMod_Zeroes,,"Bignum task: bignum_ModExp[DivMod,Zeroes].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */

/* requires y < Exp_int(2,n+1) */

/* && n > 0 */","use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
  decreases s.len()
{
  if s.len() == 0 { 
      0nat 
  } else { 
      2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
  }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

spec fn all_zero(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'
}

fn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))
  requires 
      valid_bit_string(dividend) && valid_bit_string(divisor),
      str2int(divisor) > 0,
  ensures 
      valid_bit_string(res.0) && valid_bit_string(res.1),
      str2int(res.0) == str2int(dividend) / str2int(divisor),
      str2int(res.1) == str2int(dividend) % str2int(divisor),
{
  assume(false);
  unreached()
}

fn zeros(n: nat) -> (s: Seq<char>)
  ensures 
      s.len() == n,
      valid_bit_string(s),
      str2int(s) == 0,
      all_zero(s),
{
  assume(false);
  unreached()
}",,"fn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)
  requires 
      valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@),
      sy.len() > 0 && str2int(sz@) > 1,
  ensures 
      valid_bit_string(res@),
      str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@),
  decreases sy.len()","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVB00,0.85
VB0044,verus,bignum,bignum_ModExp_ModExpPow2,,"Bignum task: bignum_ModExp[ModExpPow2].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */

/* sy is power of 2 or zero */

/* requires y < Exp_int(2,n+1) */

/* && n > 0 */","use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
  decreases s.len()
{
  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool
{
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
}

fn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),
    str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0,
    sy.len() == n + 1,
    str2int(sz) > 1
  ensures 
    valid_bit_string(res),
    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)
  decreases n
{
  assume(false);
  unreached()
}",,"fn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)
  requires 
    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@),
    sy.len() > 0 && str2int(sz@) > 1
  ensures 
    valid_bit_string(res@),
    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)
  decreases sy.len()","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVB00,0.85
VB0045,verus,bignum,bignum_ModExp_ModExpPow2_Add_Zeroes_DivMod_Mul,,"Bignum task: bignum_ModExp[ModExpPow2,Add,Zeroes,DivMod,Mul].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */

/* sy is power of 2 or zero */

/* requires y < Exp_int(2,n+1) */

/* && n > 0 */","use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
  recommends valid_bit_string(s)
  decreases s.len()
{
  if s.len() == 0 {
    0nat
  } else {
    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
  }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

spec fn all_zero(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'
}

fn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),
    str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0,
    sy.len() == n + 1,
    str2int(sz) > 1
  ensures 
    valid_bit_string(res),
    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)
  decreases n
{
  assume(false);
  unreached()
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires valid_bit_string(s1) && valid_bit_string(s2)
  ensures 
    valid_bit_string(res),
    str2int(res) == str2int(s1) + str2int(s2)
{
  assume(false);
  unreached()
}

fn zeros(n: nat) -> (s: Seq<char>)
  ensures 
    s.len() == n,
    valid_bit_string(s),
    str2int(s) == 0,
    all_zero(s)
{
  assume(false);
  unreached()
}

fn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (ret: (Seq<char>, Seq<char>))
  requires 
    valid_bit_string(dividend) && valid_bit_string(divisor),
    str2int(divisor) > 0
  ensures 
    valid_bit_string(ret.0) && valid_bit_string(ret.1),
    str2int(ret.0) == str2int(dividend) / str2int(divisor),
    str2int(ret.1) == str2int(dividend) % str2int(divisor)
{
  assume(false);
  unreached()
}

fn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires valid_bit_string(s1) && valid_bit_string(s2)
  ensures 
    valid_bit_string(res),
    str2int(res) == str2int(s1) * str2int(s2)
{
  assume(false);
  unreached()
}",,"fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),
    sy.len() > 0 && str2int(sz) > 1
  ensures 
    valid_bit_string(res),
    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)
  decreases sy.len()","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVB01,0.85
VB0046,verus,bignum,bignum_ModExp_ModExpPow2_Mul,,"Bignum task: bignum_ModExp[ModExpPow2,Mul].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */

/* sy is power of 2 or zero */

/* requires y < Exp_int(2,n+1) */

/* && n > 0 */","use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
  recommends valid_bit_string(s)
  decreases s.len()
{
  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

fn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),
    str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0,
    sy.len() == n + 1,
    str2int(sz) > 1
  ensures 
    valid_bit_string(res),
    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)
  decreases n
{
  assume(false);
  unreached()
}

fn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires valid_bit_string(s1) && valid_bit_string(s2)
  ensures 
    valid_bit_string(res),
    str2int(res) == str2int(s1) * str2int(s2)
{
  assume(false);
  unreached()
}",,"fn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)
  requires 
    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@),
    sy.len() > 0 && str2int(sz@) > 1
  ensures 
    valid_bit_string(res@),
    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)
  decreases sy.len()","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVB00,0.85
VB0047,verus,bignum,bignum_ModExp_ModExpPow2_Mul_Zeroes,,"Bignum task: bignum_ModExp[ModExpPow2,Mul,Zeroes].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */

/* sy is power of 2 or zero */

/* requires y < Exp_int(2,n+1) */

/* && n > 0 */","use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
    recommends valid_bit_string(s)
    decreases s.len()
{
    if s.len() == 0 { 
        0nat 
    } else { 
        2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
    }
}

spec fn exp_int(x: nat, y: nat) -> nat
    decreases y
{
    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

spec fn all_zero(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> s[i] == '0'
}

fn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)
    requires 
        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),
        str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0,
        sy.len() == n + 1,
        str2int(sz) > 1
    ensures 
        valid_bit_string(res),
        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)
    decreases n
{
    assume(false);
    unreached()
}

fn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
    requires valid_bit_string(s1) && valid_bit_string(s2)
    ensures 
        valid_bit_string(res),
        str2int(res) == str2int(s1) * str2int(s2)
{
    assume(false);
    unreached()
}

fn zeros(n: nat) -> (s: Seq<char>)
    ensures 
        s.len() == n,
        valid_bit_string(s),
        str2int(s) == 0,
        all_zero(s)
{
    assume(false);
    unreached()
}",,"fn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)
    requires 
        valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@),
        sy.len() > 0 && str2int(sz@) > 1
    ensures 
        valid_bit_string(res@),
        str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)
    decreases sy.len()","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,DupVB00,0.85
VB0048,verus,bignum,bignum_ModExp_ModExpPow2_Zeroes,,"Bignum task: bignum_ModExp[ModExpPow2,Zeroes].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */

/* sy is power of 2 or zero */

/*requires y < Exp_int(2,n+1)*/

/*&& n > 0*/","use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
  decreases s.len()
{
  if s.len() == 0 {
    0nat
  } else {
    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
  }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 {
    1nat
  } else {
    x * exp_int(x, (y - 1) as nat)
  }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
}

spec fn all_zero(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'
}

fn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),
    str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0,
    sy.len() == n + 1,
    str2int(sz) > 1
  ensures 
    valid_bit_string(res),
    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)
  decreases n
{
  assume(false);
  unreached()
}

fn zeros(n: nat) -> (s: Seq<char>)
  ensures 
    s.len() == n,
    valid_bit_string(s),
    str2int(s) == 0,
    all_zero(s)
{
  assume(false);
  unreached()
}",,"fn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)
  requires 
    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@),
    sy.len() > 0 && str2int(sz@) > 1
  ensures 
    valid_bit_string(res@),
    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)
  decreases sy.len()","{
  // impl-start
  assume(false);
  unreached()
  // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,DupVB00,0.85
VB0049,verus,bignum,bignum_ModExp_Mul,,"Bignum task: bignum_ModExp[Mul].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */

/* requires y < Exp_int(2,n+1) */

/* && n > 0 */","use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
  decreases s.len()
{
  if s.len() == 0 {
    0nat
  } else {
    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
  }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 {
    1nat
  } else {
    x * exp_int(x, (y - 1) as nat)
  }
}

spec fn valid_bit_string(s: Seq<char>) -> bool
{
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
}

fn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2)
  ensures 
    valid_bit_string(res) &&
    str2int(res) == str2int(s1) * str2int(s2)
{
  assume(false);
  unreached()
}",,"fn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)
  requires 
    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&
    sy@.len() > 0 && str2int(sz@) > 1
  ensures 
    valid_bit_string(res@) &&
    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)
  decreases sy@.len()","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVB00,0.85
VB0050,verus,bignum,bignum_ModExp_Mul_Zeroes,,"Bignum task: bignum_ModExp[Mul,Zeroes].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */

/* requires y < Exp_int(2,n+1) */

/* && n > 0 */","use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
  decreases s.len()
{
  if s.len() == 0 { 
    0nat 
  } else { 
    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
  }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

spec fn all_zero(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'
}

fn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2)
  ensures 
    valid_bit_string(res),
    str2int(res) == str2int(s1) * str2int(s2)
{
  assume(false);
  unreached()
}

fn zeros(n: nat) -> (s: Seq<char>)
  ensures 
    s.len() == n,
    valid_bit_string(s),
    str2int(s) == 0,
    all_zero(s)
{
  assume(false);
  unreached()
}",,"fn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)
  requires 
    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@),
    sy@.len() > 0 && str2int(sz@) > 1
  ensures 
    valid_bit_string(res@),
    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)
  decreases sy@.len()","{
  // impl-start
  assume(false);
  unreached()
  // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,DupVB00,0.85
VB0051,verus,bignum,bignum_ModExp_Zeroes,,"Bignum task: bignum_ModExp[Zeroes].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */

/* requires y < Exp_int(2,n+1) */

/* && n > 0 */","use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
  decreases s.len()
{
  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }
}

spec fn exp_int(x: nat, y: nat) -> nat
  decreases y
{
  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool
{
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
}

spec fn all_zero(s: Seq<char>) -> bool
{
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'
}

fn zeros(n: nat) -> (s: Seq<char>)
  ensures
    s.len() == n,
    valid_bit_string(s),
    str2int(s) == 0,
    all_zero(s),
{
  assume(false);
  unreached()
}",,"fn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)
  requires
    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@),
    sy@.len() > 0 && str2int(sz@) > 1,
  ensures
    valid_bit_string(res@),
    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@),
  decreases sy@.len()","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVB00,0.85
VB0052,verus,bignum,bignum_ModExp_int,,"Bignum task: bignum_ModExp_int.
Implement the method according to the Verus specification.

/* && n > 0 */","use vstd::prelude::*;

verus! {
spec fn exp_int(x: nat, y: nat) -> nat
    decreases y
{
    if y == 0 { 1 } else { x * exp_int(x, (y - 1) as nat) }
}",,"fn mod_exp_int(x: u64, y: u64, n: u64, z: u64) -> (res: u64)
    requires 
        y < exp_int(x as nat, y as nat),
        z > 1,
    ensures res as nat == exp_int(x as nat, y as nat) % (z as nat)
    decreases n","{
    // impl-start
    assume(false);
    0
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,DupVB04,0.85
VB0053,verus,bignum,bignum_ModExp_int_ModExpPow2_int,,"Bignum task: bignum_ModExp_int[ModExpPow2_int].
Implement the method according to the Verus specification.

/* && n > 0 */","use vstd::prelude::*;

verus! {

spec fn exp_int(x: nat, y: nat) -> nat
    decreases y
{
    if y == 0 { 1 } else { x * exp_int(x, (y - 1) as nat) }
}

fn mod_exp_pow2_int(x: nat, y: nat, n: nat, z: nat) -> (res: nat)
    requires 
        y == exp_int(2, n),
        z > 0,
    ensures res == exp_int(x, y) % z
    decreases n
{
    assume(false);
    unreached()
}",,"fn mod_exp_int(x: u8, y: u8, n: u8, z: u8) -> (res: u8)
    requires 
        (y as nat) < exp_int(2nat, (n as nat) + 1nat),
        (z as nat) > 1,
    ensures (res as nat) == exp_int(x as nat, y as nat) % (z as nat)
    decreases n","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVB04,0.85
VB0054,verus,bignum,bignum_Mul,,"Bignum task: bignum_Mul.
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */","use vstd::prelude::*;

verus! {
spec fn str2int(s: Seq<char>) -> nat
  decreases s.len()
{
  if s.len() == 0 {
    0nat 
  } else {
    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
  }
}

spec fn valid_bit_string(s: Seq<char>) -> bool
{
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}",,"fn mul(s1: Vec<char>, s2: Vec<char>) -> (res: Vec<char>)
  requires 
    valid_bit_string(s1@) && valid_bit_string(s2@)
  ensures 
    valid_bit_string(res@) &&
    str2int(res@) == str2int(s1@) * str2int(s2@)","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVB02,0.85
VB0055,verus,bignum,bignum_Mul_Add,,"Bignum task: bignum_Mul[Add].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */","use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
  decreases s.len()
{
  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool
{
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2),
  ensures 
    valid_bit_string(res) &&
    str2int(res) == str2int(s1) + str2int(s2),
{
  assume(false);
  unreached()
}",,"fn mul(s1: Vec<char>, s2: Vec<char>) -> (res: Vec<char>)
  requires 
    valid_bit_string(s1@) && valid_bit_string(s2@),
  ensures 
    valid_bit_string(res@) &&
    str2int(res@) == str2int(s1@) * str2int(s2@),","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VB0056,verus,bignum,bignum_Mul_Add_NormalizeBitString,,"Bignum task: bignum_Mul[Add,NormalizeBitString].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */","use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
  decreases s.len()
{
  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool
{
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
}

fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)
  requires 
    valid_bit_string(s1) && valid_bit_string(s2),
  ensures 
    valid_bit_string(res) &&
    str2int(res) == str2int(s1) + str2int(s2),
{
  assume(false);
  unreached()
}

fn normalize_bit_string(s: Seq<char>) -> (t: Seq<char>)
  ensures 
    valid_bit_string(t) &&
    t.len() > 0 &&
    (t.len() > 1 ==> t[0] != '0') &&
    (valid_bit_string(s) ==> str2int(s) == str2int(t)),
{
  assume(false);
  unreached()
}",,"fn mul(s1: Vec<char>, s2: Vec<char>) -> (res: Vec<char>)
  requires 
    valid_bit_string(s1@) && valid_bit_string(s2@),
  ensures 
    valid_bit_string(res@) &&
    str2int(res@) == str2int(s1@) * str2int(s2@),","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVB02,0.85
VB0057,verus,bignum,bignum_Mul_NormalizeBitString,,"Bignum task: bignum_Mul[NormalizeBitString].
Implement the method according to the Verus specification.

/* All characters must be '0' or '1'. */","use vstd::prelude::*;

verus! {
spec fn str2int(s: Seq<char>) -> nat
  recommends valid_bit_string(s)
  decreases s.len()
{
  if s.len() == 0 { 
    0nat 
  } else { 
    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
  }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

fn normalize_bit_string(s: Seq<char>) -> (t: Seq<char>)
  ensures 
    valid_bit_string(t),
    t.len() > 0,
    t.len() > 1 ==> t[0] != '0',
    valid_bit_string(s) ==> str2int(s) == str2int(t)
{
  assume(false);
  unreached()
}",,"fn mul(s1: Vec<char>, s2: Vec<char>) -> (res: Vec<char>)
  requires 
    valid_bit_string(s1@) && valid_bit_string(s2@)
  ensures 
    valid_bit_string(res@),
    str2int(res@) == str2int(s1@) * str2int(s2@)","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVB02,0.85
VB0058,verus,bignum,bignum_NormalizeBitString,,"Bignum task: bignum_NormalizeBitString.
Implement the method according to the Dafny specification.","use vstd::prelude::*;

verus! {
spec fn str2int(s: Seq<char>) -> nat
  recommends valid_bit_string(s)
  decreases s.len()
{
  if s.len() == 0 {
    0nat
  } else {
    2nat * str2int(s.subrange(0, s.len() as int - 1)) + 
    (if s[s.len() as int - 1] == '1' { 1nat } else { 0nat })
  }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}",,"fn normalize_bit_string(s: Vec<char>) -> (t: Vec<char>)
  ensures 
    valid_bit_string(t@) &&
    t@.len() > 0 &&
    (t@.len() > 1 ==> t@[0] != '0') &&
    (valid_bit_string(s@) ==> str2int(s@) == str2int(t@))","{
  /* impl-start */
  assume(false);
  unreached()
  /* impl-end */
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VB0059,verus,bignum,bignum_Sub,,"Bignum task: bignums_Sub.
Implement the method according to the Verus specification.","use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
  decreases s.len()
{
  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }
}

spec fn valid_bit_string(s: Seq<char>) -> bool
{
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
}",,"fn sub(s1: Vec<char>, s2: Vec<char>) -> (res: Vec<char>)
  requires 
    valid_bit_string(s1@) && valid_bit_string(s2@),
    str2int(s1@) >= str2int(s2@),
  ensures 
    valid_bit_string(res@),
    str2int(res@) == str2int(s1@) - str2int(s2@),","{
  // impl-start
  assume(false);
  unreached()
  // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VB0060,verus,bignum,bignum_Sub_NormalizeBitstring,,"Bignum task: bignums_Sub[NormalizeBitstring].
Implement the method according to the Verus specification.","use vstd::prelude::*;

verus! {

spec fn str2int(s: Seq<char>) -> nat
  decreases s.len()
{
  if s.len() == 0 { 
    0nat 
  } else { 
    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
  }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
}

fn normalize_bit_string(s: Seq<char>) -> (t: Seq<char>)
  ensures 
    valid_bit_string(t) &&
    t.len() > 0 &&
    (t.len() > 1 ==> t[0] != '0') &&
    (valid_bit_string(s) ==> str2int(s) == str2int(t))
{
  assume(false);
  unreached()
}",,"fn sub(s1: Vec<char>, s2: Vec<char>) -> (res: Vec<char>)
  requires 
    valid_bit_string(s1@) && valid_bit_string(s2@) &&
    str2int(s1@) >= str2int(s2@)
  ensures 
    valid_bit_string(res@) &&
    str2int(res@) == str2int(s1@) - str2int(s2@)","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVB02,0.85
VB0061,verus,bignum,bignum_Zeros,,"Bignum task: bignums_Zeros.
Implement the method according to the Verus specification.","use vstd::prelude::*;

verus! {
spec fn all_zero(s: Seq<char>) -> bool {
    s.len() == 0 || forall|i: int| 0 <= i < s.len() ==> s[i] == '0'
}

spec fn str2int(s: Seq<char>) -> nat
    decreases s.len()
{
    if s.len() == 0 { 
        0nat 
    } else { 
        2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })
    }
}

spec fn valid_bit_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
}",,"fn zeros(n: usize) -> (s: Vec<char>)
    ensures 
        s@.len() == n,
        valid_bit_string(s@),
        str2int(s@) == 0,
        all_zero(s@)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VD0000,verus,dafnybench,630-dafny_tmp_tmpz2kokaiq_Solution_BinarySearch,,,"use vstd::prelude::*;

verus! {

spec fn sorted(a: &[int]) -> bool {
    forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j]
}",,"fn binary_search(a: &[int], x: int) -> (index: i32)
    requires 
        sorted(a),
    ensures 
        0 <= index < a.len() ==> a[index as int] == x,
        index == -1 ==> forall|i: int| 0 <= i < a.len() ==> a[i] != x,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0003,verus,dafnybench,AssertivePrograming_tmp_tmpwf43uz0e_DivMode_Unary_IterativeDivMod,,"// Noa Leron 207131871  

// Tsuri Farhana 315016907

// definitions borrowed from Rustan Leino's Program Proofs Chapter 7

// (https://program-proofs.com/code.html example code in Dafny; source file 7-Unary.dfy)

/*
Goal: implement correcly and clearly, using iterative code (no recursion), documenting the proof obligations
    as we've learned, with assertions and a lemma for each proof goal

- DO NOT modify the specification or any of the definitions given in this file
- Not all definitions above are relevant, some are simply included as examples
- Feel free to use existing non-ghost functions/predicates in your code, and existing lemmas (for the proof) in your annotations
- New functions/predicates may be added ONLY as ghost
- If it helps you in any way, a recursive implementation + proof can be found in the book and the downloadable source file
  [https://program-proofs.com/code.html example code in Dafny, source file 7-Unary.dfy]
*/","use vstd::prelude::*;

verus! {

pub enum Unary {
    Zero,
    Suc(Box<Unary>),
}

pub open spec fn unary_to_nat(x: Unary) -> nat 
    decreases x
{
    match x {
        Unary::Zero => 0nat,
        Unary::Suc(x_prime) => 1nat + unary_to_nat(*x_prime),
    }
}

pub open spec fn nat_to_unary(n: nat) -> Unary 
    decreases n
{
    if n == 0 {
        Unary::Zero
    } else {
        Unary::Suc(Box::new(nat_to_unary((n - 1) as nat)))
    }
}

pub open spec fn less(x: Unary, y: Unary) -> bool 
    decreases x, y
{
    match y {
        Unary::Zero => false,
        Unary::Suc(y_pred) => match x {
            Unary::Zero => true,
            Unary::Suc(x_pred) => less(*x_pred, *y_pred),
        }
    }
}

pub open spec fn less_alt(x: Unary, y: Unary) -> bool 
    decreases x, y
{
    match y {
        Unary::Zero => false,
        Unary::Suc(y_pred) => match x {
            Unary::Zero => true,
            Unary::Suc(x_pred) => less(*x_pred, *y_pred),
        }
    }
}

pub open spec fn add(x: Unary, y: Unary) -> Unary 
    decreases y
{
    match y {
        Unary::Zero => x,
        Unary::Suc(y_prime) => Unary::Suc(Box::new(add(x, *y_prime))),
    }
}

pub open spec fn sub(x: Unary, y: Unary) -> Unary 
    decreases y
{
    if less(x, y) {
        arbitrary()
    } else {
        match y {
            Unary::Zero => x,
            Unary::Suc(y_prime) => match x {
                Unary::Zero => arbitrary(),
                Unary::Suc(x_pred) => sub(*x_pred, *y_prime),
            }
        }
    }
}

pub open spec fn mul(x: Unary, y: Unary) -> Unary 
    decreases x
{
    match x {
        Unary::Zero => Unary::Zero,
        Unary::Suc(x_prime) => add(mul(*x_prime, y), y),
    }
}

fn iterative_div_mod_prime(x: Unary, y: Unary) -> (res: (Unary, Unary))
    requires y != Unary::Zero
    ensures add(mul(res.0, y), res.1) == x && less(res.1, y)
{
    assume(false);
    (Unary::Zero, Unary::Zero)
}",,"fn iterative_div_mod(x: Unary, y: Unary) -> (res: (Unary, Unary))
    requires y != Unary::Zero
    ensures add(mul(res.0, y), res.1) == x && less(res.1, y)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0004,verus,dafnybench,AssertivePrograming_tmp_tmpwf43uz0e_Find_Substring_FindFirstOccurrence,,"// Noa Leron 207131871

// Tsuri Farhana 315016907

/*
Goal: Verify correctness of the following code. Once done, remove the {:verify false} (or turn it into {:verify true}).

Feel free to add GHOST code, including calls to lemmas. But DO NOT modify the specification or the original (executable) code.
*/

//this is our lemmas, invatiants and presicats

// Second part of post condition

// First part of post condition

// index in range

// index in range

// index in range","use vstd::prelude::*;

verus! {

spec fn is_prefix(prefix: Seq<char>, full: Seq<char>) -> bool {
    prefix.len() <= full.len() &&
    forall|k: int| 0 <= k < prefix.len() ==> prefix[k] == full[k]
}

spec fn exists_substring(str1: Seq<char>, str2: Seq<char>) -> bool {
    exists|offset: int| 0 <= offset <= str1.len() - str2.len() &&
        is_prefix(str2, str1.subrange(offset, str1.len() as int))
}

spec fn post(str1: Seq<char>, str2: Seq<char>, found: bool, i: nat) -> bool {
    (found <==> exists_substring(str1, str2)) &&
    (found ==> i + str2.len() <= str1.len() && 
        is_prefix(str2, str1.subrange(i as int, str1.len() as int)))
}

spec fn outter_inv_correctness(str1: Seq<char>, str2: Seq<char>, found: bool, i: nat) -> bool {
    (found ==> (i + str2.len() <= str1.len() && 
        is_prefix(str2, str1.subrange(i as int, str1.len() as int)))) &&
    (!found && 0 < i <= str1.len() && i != str2.len() - 1 ==> 
        !(exists_substring(str1.subrange(0, i as int), str2))) &&
    (!found ==> i <= str1.len())
}

spec fn inner_inv_correctness(str1: Seq<char>, str2: Seq<char>, i: nat, j: int, found: bool) -> bool {
    0 <= j <= i &&
    j < str2.len() &&
    i < str1.len() &&
    (str1[i as int] == str2[j] ==> 
        is_prefix(str2.subrange(j, str2.len() as int), str1.subrange(i as int, str1.len() as int))) &&
    (found ==> j == 0 && str1[i as int] == str2[j])
}

spec fn inner_inv_termination(str1: Seq<char>, str2: Seq<char>, i: nat, j: int, old_i: nat, old_j: nat) -> bool {
    old_j - j == old_i - old_i
}",,"fn find_first_occurrence(str1: Seq<char>, str2: Seq<char>) -> (result: (bool, usize))
    ensures post(str1, str2, result.0, result.1 as nat)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0005,verus,dafnybench,AssertivePrograming_tmp_tmpwf43uz0e_MergeSort_Merge,,"// Noa Leron 207131871

// Tsuri Farhana 315016907

/*
Goal: Implement the well known merge sort algorithm in O(a.Length X log_2(a.Length)) time, recursively.

- Divide the contents of the original array into two local arrays
- After sorting the local arrays (recursively), merge the contents of the two returned arrays using the Merge method (see below)
- DO NOT modify the specification or any other part of the method's signature
- DO NOT introduce any further methods
*/

/*
Goal: Implement iteratively, correctly, efficiently, clearly

DO NOT modify the specification or any other part of the method's signature
*/

//This is a method that replace the loop body

// in this case we take the next value from d

// in this case we take the next value from c

//Loop invariant - b is sorted so far and the next two potential values that will go into b are bigger than the biggest value in b.

//Loop invariant - the multiset of the prefix of b so far is the same multiset as the prefixes of c and d so far.

//This lemma helps Verus see that if the prefixes of arrays are the same multiset until the end of the arrays,

//all the arrays are the same multiset.

//This lemma helps Verus see that after adding the next value from c to b the prefixes are still the same subsets.","use vstd::prelude::*;

verus! {

spec fn sorted(q: Seq<i32>) -> bool {
    forall|i: int, j: int| 0 <= i <= j < q.len() ==> q[i] <= q[j]
}

spec fn inv(a: Seq<i32>, a1: Seq<i32>, a2: Seq<i32>, i: usize, mid: usize) -> bool {
    (i <= a1.len()) && (i <= a2.len()) && (i + mid <= a.len()) &&
    (a1.subrange(0, i as int) == a.subrange(0, i as int)) && 
    (a2.subrange(0, i as int) == a.subrange(mid as int, (i + mid) as int))
}

fn merge_loop(b: &mut Vec<i32>, c: &Vec<i32>, d: &Vec<i32>, i0: usize, j0: usize) -> (usize, usize)
        requires
            old(b).len() == c.len() + d.len(),
            sorted(c@),
            sorted(d@),
            i0 <= c.len(),
            j0 <= d.len(),
            i0 + j0 <= old(b).len(),
            inv_sub_set(old(b)@, c@, d@, i0, j0),
            inv_sorted(old(b)@, c@, d@, i0, j0),
            i0 + j0 < old(b).len(),
{
    let mut i = i0;
    let mut j = j0;

    if i == c.len() || (j < d.len() && d[j] < c[i]) {

        b.set(i + j, d[j]);
        j = j + 1;
    } else {

        b.set(i + j, c[i]);
        i = i + 1;
    }

    (i, j)
}

spec fn inv_sorted(b: Seq<i32>, c: Seq<i32>, d: Seq<i32>, i: usize, j: usize) -> bool {
    i <= c.len() && j <= d.len() && i + j <= b.len() &&
    ((i + j > 0 && i < c.len()) ==> (b[j + i - 1] <= c[i as int])) &&
    ((i + j > 0 && j < d.len()) ==> (b[j + i - 1] <= d[j as int])) &&
    sorted(b.subrange(0, (i + j) as int))
}

spec fn inv_sub_set(b: Seq<i32>, c: Seq<i32>, d: Seq<i32>, i: usize, j: usize) -> bool {
    i <= c.len() && j <= d.len() && i + j <= b.len() &&
    b.subrange(0, (i + j) as int).to_multiset() == 
        c.subrange(0, i as int).to_multiset().add(d.subrange(0, j as int).to_multiset())
}",,"fn merge(b: &mut Vec<i32>, c: &Vec<i32>, d: &Vec<i32>)
    requires
        old(b).len() == c.len() + d.len(),
        sorted(c@),
        sorted(d@),
    ensures
        sorted(b@),
        b@.to_multiset() == c@.to_multiset().add(d@.to_multiset()),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0006,verus,dafnybench,AssertivePrograming_tmp_tmpwf43uz0e_MergeSort_MergeLoop,,"// Noa Leron 207131871

// Tsuri Farhana 315016907

/*
Goal: Implement the well known merge sort algorithm in O(a.Length X log_2(a.Length)) time, recursively.

- Divide the contents of the original array into two local arrays
- After sorting the local arrays (recursively), merge the contents of the two returned arrays using the Merge method (see below)
- DO NOT modify the specification or any other part of the method's signature
- DO NOT introduce any further methods
*/

/*
Goal: Implement iteratively, correctly, efficiently, clearly

DO NOT modify the specification or any other part of the method's signature
*/

//This is a method that replace the loop body

//Loop invariant - b is sorted so far and the next two potential values that will go into b are bigger then the biggest value in b.

//Loop invariant - the multiset of the prefix of b so far is the same multiset as the prefixes of c and d so far.

//This lemma helps dafny see that if the prefixs of arrays are the same multiset until the end of the arrays,

//all the arrays are the same multiset.

//This lemma helps dafny see that after adding the next value from c to b the prefixes are still the same subsets.

//decreases ensures","use vstd::prelude::*;

verus! {

spec fn sorted(q: Seq<int>) -> bool {
    forall|i: int, j: int| 0 <= i <= j < q.len() ==> q[i] <= q[j]
}

spec fn inv(a: Seq<int>, a1: Seq<int>, a2: Seq<int>, i: nat, mid: nat) -> bool {
    (i <= a1.len()) && (i <= a2.len()) && (i + mid <= a.len()) &&
    (a1.subrange(0, i as int) =~= a.subrange(0, i as int)) && 
    (a2.subrange(0, i as int) =~= a.subrange(mid as int, (i + mid) as int))
}

spec fn inv_sorted(b: Seq<int>, c: Seq<int>, d: Seq<int>, i: nat, j: nat) -> bool {
    i <= c.len() && j <= d.len() && i + j <= b.len() &&
    ((i + j > 0 && i < c.len()) ==> (b[(j + i - 1) as int] <= c[i as int])) &&
    ((i + j > 0 && j < d.len()) ==> (b[(j + i - 1) as int] <= d[j as int])) &&
    sorted(b.subrange(0, (i + j) as int))
    }

spec fn inv_sub_set(b: Seq<int>, c: Seq<int>, d: Seq<int>, i: nat, j: nat) -> bool {
    i <= c.len() && j <= d.len() && i + j <= b.len() &&
    b.subrange(0, (i + j) as int).to_multiset() =~= 
    c.subrange(0, i as int).to_multiset().add(d.subrange(0, j as int).to_multiset())
}",,"fn merge_loop(b: &mut Vec<int>, c: &Vec<int>, d: &Vec<int>, i0: usize, j0: usize) -> (r: (usize, usize))
        requires
            old(b).len() == c.len() + d.len(),
            sorted(c@),
            sorted(d@),
            i0 <= c.len(),
            j0 <= d.len(),
            i0 + j0 <= old(b).len(),
            inv_sub_set(old(b)@, c@, d@, i0 as nat, j0 as nat),
            inv_sorted(old(b)@, c@, d@, i0 as nat, j0 as nat),
            i0 + j0 < old(b).len(),

        ensures
            r.0 <= c.len() && r.1 <= d.len() && r.0 + r.1 <= b.len(),
            inv_sub_set(b@, c@, d@, r.0 as nat, r.1 as nat),
            inv_sorted(b@, c@, d@, r.0 as nat, r.1 as nat),

            0 <= c.len() - r.0 < c.len() - i0 || (c.len() - r.0 == c.len() - i0 && 0 <= d.len() - r.1 < d.len() - j0)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0007,verus,dafnybench,AssertivePrograming_tmp_tmpwf43uz0e_MergeSort_MergeSort,,"// Noa Leron 207131871

// Tsuri Farhana 315016907

/*
Goal: Implement the well known merge sort algorithm in O(a.Length X log_2(a.Length)) time, recursively.

- Divide the contents of the original array into two local arrays
- After sorting the local arrays (recursively), merge the contents of the two returned arrays using the Merge method (see below)
- DO NOT modify the specification or any other part of the method's signature
- DO NOT introduce any further methods
*/

/*
Goal: Implement iteratively, correctly, efficiently, clearly

DO NOT modify the specification or any other part of the method's signature
*/

//This is a method that replace the loop body

//Loop invariant - b is sorted so far and the next two potential values that will go into b are bigger then the biggest value in b.

//Loop invariant - the multiset of the prefix of b so far is the same multiset as the prefixes of c and d so far.

//This lemma helps verus see that if the prefixes of arrays are the same multiset until the end of the arrays,

//all the arrays are the same multiset.

//This lemma helps verus see that after adding the next value from c to b the prefixes are still the same subsets.","use vstd::prelude::*;

verus! {

spec fn sorted(q: Seq<int>) -> bool {
    forall|i: int, j: int| 0 <= i <= j < q.len() ==> q[i] <= q[j]
}

spec fn inv(a: Seq<int>, a1: Seq<int>, a2: Seq<int>, i: nat, mid: nat) -> bool {
    (i <= a1.len()) && (i <= a2.len()) && (i + mid <= a.len()) &&
    (a1.subrange(0, i as int) =~= a.subrange(0, i as int)) && 
    (a2.subrange(0, i as int) =~= a.subrange(mid as int, (i + mid) as int))
}

fn merge(b: &mut Vec<int>, c: &Vec<int>, d: &Vec<int>)
    requires
        old(b).len() == c.len() + d.len(),
        sorted(c@),
        sorted(d@),
    ensures
        sorted(b@),
        b@.to_multiset() == c@.to_multiset().add(d@.to_multiset()),
{
  assume(false);
}

spec fn inv_sorted(b: Seq<int>, c: Seq<int>, d: Seq<int>, i: nat, j: nat) -> bool {
    i <= c.len() && j <= d.len() && i + j <= b.len() &&
    ((i + j > 0 && i < c.len()) ==> (b[(j + i - 1) as int] <= c[i as int])) &&
    ((i + j > 0 && j < d.len()) ==> (b[(j + i - 1) as int] <= d[j as int])) &&
    sorted(b.subrange(0, (i + j) as int))
    }

spec fn inv_sub_set(b: Seq<int>, c: Seq<int>, d: Seq<int>, i: nat, j: nat) -> bool {
    i <= c.len() && j <= d.len() && i + j <= b.len() &&
    b.subrange(0, (i + j) as int).to_multiset() == 
        c.subrange(0, i as int).to_multiset().add(d.subrange(0, j as int).to_multiset())
}",,"fn merge_sort(a: Vec<int>) -> (b: Vec<int>)
    ensures
        b.len() == a.len(),
        sorted(b@),
        a@.to_multiset() == b@.to_multiset(),
    decreases a.len()","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0008,verus,dafnybench,BPTree-verif_tmp_tmpq1z6xm1d_Utils_GetInsertIndex,,"// method CountLessThan(numbers: set<int>, threshold: int) returns (count: int)

// //   ensures count == |set i | i in numbers && i < threshold|

//     ensures count == |SetLessThan(numbers, threshold)|

// {

//   count := 0;

//   var ss := numbers;

//   while ss != {}

//     decreases |ss|

//   {

//     var i: int :| i in ss;

//     ss := ss - {i};

//     if i < threshold {

//       count := count + 1;

//     }

//   }

//   assert count == |SetLessThan(numbers, threshold)|;

// //   assert count == |set i | i in numbers && i < threshold|;

// }

// function SetLessThan(numbers: set<int>, threshold: int): set<int>

// {

//   set i | i in numbers && i < threshold

// }

/*
*/

// function seqSet(nums: seq<int>, index: nat): set<int> {

//     set x | 0 <= x < index < |nums| :: nums[x]

// }

// lemma numElemsOfSet(a: seq<int>)

//   requires sorted(a)

// {

//   assert distinct(a);

//   var s := set x | x in a;

//   assert forall x :: x in s ==> x in a[..];

//   assert forall x :: x in a ==> x in s;

//   assert |s| == |a|;

// }

// lemma CardinalitySetEqualsArray(a: seq<int>, s: set<int>)

//   requires s == set x | x in a

//   requires distinct(a)

//   ensures |s| == |a|

// {

//     assert forall x :: x in s ==> exists i :: 0 <= i < |a| && a[i] == x;

//     assert forall i, j :: 0 <= i < |a| && 0 <= j < |a| && i != j ==> a[i] != a[j];

//     // Assert that each element in the array is in the set

//     assert forall i :: 0 <= i < |a| ==> a[i] in s;

//     // Assert that the set contains exactly the elements in the array

//     assert s == set x | x in a;

//     // Assert that the set is a subset of the array

//     assert forall x :: x in s <==> x in a;

//     // Conclude the equivalence

//     assert |s| == |a|;

// }

/*

*/

// TODO play with this for keys==Contents

// ghost predicate SortedSeq(a: seq<int>)

//   //sequence is sorted from left to right

// {

//   (forall i,j :: 0<= i< j < |a| ==> ( a[i] < a[j] ))

// }

// predicate sorted(a: seq<int>)

// {

//   forall i,j :: 0 <= i < j < |a| ==> a[i] < a[j]

// }

// predicate distinct(a: seq<int>)

// {

//   forall i,j :: (0 <= i < |a| && 0 <= j < |a| && i != j) ==> a[i] != a[j]

// }

// predicate sorted_eq(a: seq<int>)

// {

//   forall i,j :: 0 <= i < j < |a| ==> a[i] <= a[j]

// }

// predicate lessThan(a:seq<int>, key:int) {

//   forall i :: 0 <= i < |a| ==> a[i] < key

// }

// predicate greaterThan(a:seq<int>, key:int) {

//   forall i :: 0 <= i < |a| ==> a[i] > key

// }

// predicate greaterEqualThan(a:seq<int>, key:int) {

//   forall i :: 0 <= i < |a| ==> a[i] >= key

// }

/*
method InsertSorted(a: array<int>, key: int ) returns (b: array<int>)
  requires sorted_eq(a[..])
  ensures sorted_eq(b[..])
{
  assume{:axiom} false;
}
*/

// function count(a: seq<bool>): nat

// {

//   if |a| == 0 then 0 else

//     (if a[0] then 1 else 0) + count(a[1..])

// }

// verifies in more than 45 seconds, but less than 100 seconds

// method InsertIntoSorted(a: array<int>, limit:int, key:int) returns (b: array<int>)

//     requires key > 0

//     requires key !in a[..]

//     requires 0 <= limit < a.Length

//     requires forall i :: 0 <= i < limit ==> a[i] > 0

//     requires forall i :: limit <= i < a.Length ==> a[i] == 0

//     requires sorted(a[..limit]) 

//     ensures b.Length == a.Length

//     ensures sorted(b[..(limit+ 1)])

//     ensures forall i :: limit + 1 <= i < b.Length ==> b[i] == 0  

//     ensures forall i :: 0 <= i < limit ==> a[i] in b[..]

//     ensures forall i :: 0 <= i < limit + 1 ==> b[i] > 0

// {

//   assume{:axiom} false;

// }

// method GetInsertIndex(a: array<int>, limit: int, x:int) returns (idx:int)

//   // get index so that array stays sorted

//   requires x !in a[..]

//   requires 0 <= limit <= a.Length

//   requires SortedSeq(a[..limit])

//   ensures 0<= idx <= limit

//   ensures SortedSeq(a[..limit])

//   ensures idx > 0 ==> a[idx-1]< x

//   ensures idx < limit ==> x < a[idx]

// get index so that array stays sorted","use vstd::prelude::*;

verus! {

spec fn set_less_than(numbers: Set<int>, threshold: int) -> Set<int> {
    numbers.filter(|i: int| i < threshold)
}

spec fn seq_set(nums: Seq<int>, index: nat) -> Set<int> 
    recommends index <= nums.len()
{
    Set::new(|x: int| exists |i: int| 0 <= i < index && i < nums.len() && nums[i] == x)
}

spec fn sorted_seq(a: Seq<int>) -> bool {
    forall |i: int, j: int| 0 <= i < j < a.len() ==> a[i] < a[j]
}

spec fn sorted(a: Seq<int>) -> bool {
    forall |i: int, j: int| 0 <= i < j < a.len() ==> a[i] < a[j]
}

spec fn distinct(a: Seq<int>) -> bool {
    forall |i: int, j: int| (0 <= i < a.len() && 0 <= j < a.len() && i != j) ==> a[i] != a[j]
}

spec fn sorted_eq(a: Seq<int>) -> bool {
    forall |i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j]
}

spec fn less_than(a: Seq<int>, key: int) -> bool {
    forall |i: int| 0 <= i < a.len() ==> a[i] < key
}

spec fn greater_than(a: Seq<int>, key: int) -> bool {
    forall |i: int| 0 <= i < a.len() ==> a[i] > key
}

spec fn greater_equal_than(a: Seq<int>, key: int) -> bool {
    forall |i: int| 0 <= i < a.len() ==> a[i] >= key
}

spec fn count(a: Seq<bool>) -> nat 
    decreases a.len()
{
    if a.len() == 0 {
        0nat
    } else {
        (if a[0] { 1nat } else { 0nat }) + count(a.subrange(1, a.len() as int))
    }
}

fn insert_into_sorted(a: Vec<int>, limit: usize, key: int) -> (b: Vec<int>)
    requires
        key > 0,
        !a@.contains(key),
        limit < a.len(),
        forall |i: int| 0 <= i < limit ==> a@[i] > 0,
        forall |i: int| limit <= i < a.len() ==> a@[i] == 0,
        sorted(a@.subrange(0, limit as int)),
    ensures
        b.len() == a.len(),
        sorted(b@.subrange(0, limit as int + 1)),
        forall |i: int| limit + 1 <= i < b.len() ==> b@[i] == 0,
        forall |i: int| 0 <= i < limit ==> a@.contains(b@[i]),
        forall |i: int| 0 <= i < limit + 1 ==> b@[i] > 0,
{
    assume(false);
    Vec::new()
}",,"fn get_insert_index(a: &Vec<int>, limit: usize, x: int) -> (idx: usize)

    requires
        !a@.contains(x),
        limit <= a.len(),
        sorted_seq(a@.subrange(0, limit as int)),
    ensures
        idx <= limit,
        sorted_seq(a@.subrange(0, limit as int)),
        idx > 0 ==> a@[idx as int - 1] < x,
        idx < limit ==> x < a@[idx as int],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0009,verus,dafnybench,BPTree-verif_tmp_tmpq1z6xm1d_Utils_InsertIntoSorted,,"// Function SetLessThan equivalent

// Function seqSet equivalent

// Predicate SortedSeq equivalent

// Method GetInsertIndex equivalent

// Predicate sorted equivalent

// Predicate distinct equivalent

// Predicate sorted_eq equivalent

// Predicate lessThan equivalent

// Predicate greaterThan equivalent

// Predicate greaterEqualThan equivalent

// Function count equivalent","use vstd::prelude::*;

verus! {

spec fn set_less_than(numbers: Set<int>, threshold: int) -> Set<int> {
    numbers.filter(|i: int| i < threshold)
}

spec fn seq_set(nums: Seq<int>, index: nat) -> Set<int> {
    if index < nums.len() {
        Set::new(|x: int| exists|i: int| 0 <= i < index && i < nums.len() && nums[i] == x)
    } else {
        Set::empty()
    }
}

spec fn sorted_seq(a: Seq<int>) -> bool {
    forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] < a[j]
}

fn get_insert_index(a: &[int], limit: usize, x: int) -> (idx: usize)
    requires 
        !a@.contains(x),
        limit <= a.len(),
        sorted_seq(a@.take(limit as int)),
    ensures
        idx <= limit,
        sorted_seq(a@.take(limit as int)),
        idx > 0 ==> a[(idx - 1) as int] < x,
        idx < limit ==> x < a[idx as int],
{
    assume(false);
    0
}

spec fn sorted(a: Seq<int>) -> bool {
    forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] < a[j]
}

spec fn distinct(a: Seq<int>) -> bool {
    forall|i: int, j: int| (0 <= i < a.len() && 0 <= j < a.len() && i != j) ==> a[i] != a[j]
}

spec fn sorted_eq(a: Seq<int>) -> bool {
    forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j]
}

spec fn less_than(a: Seq<int>, key: int) -> bool {
    forall|i: int| 0 <= i < a.len() ==> a[i] < key
}

spec fn greater_than(a: Seq<int>, key: int) -> bool {
    forall|i: int| 0 <= i < a.len() ==> a[i] > key
}

spec fn greater_equal_than(a: Seq<int>, key: int) -> bool {
    forall|i: int| 0 <= i < a.len() ==> a[i] >= key
}

spec fn count(a: Seq<bool>) -> nat
    decreases a.len()
{
    if a.len() == 0 { 
        0nat 
    } else { 
        (if a[0] { 1nat } else { 0nat }) + count(a.drop_first())
    }
}",,"fn insert_into_sorted(a: &[int], limit: usize, key: int) -> (b: Vec<int>)
    requires 
        key > 0,
        !a@.contains(key),
        limit < a.len(),
        forall|i: int| 0 <= i < limit ==> a[i] > 0,
        forall|i: int| limit <= i < a.len() ==> a[i] == 0,
        sorted(a@.take(limit as int)),
    ensures
        b.len() == a.len(),
        sorted(b@.take((limit + 1) as int)),
        forall|i: int| limit + 1 <= i < b.len() ==> b[i] == 0,
        forall|i: int| 0 <= i < limit ==> a@.contains(b[i]),
        forall|i: int| 0 <= i < limit + 1 ==> b[i] > 0,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0011,verus,dafnybench,BelowZero_BelowZero,,"/* 
HumanEvalX 3
You're given a list of deposit and withdrawal operations on a bank account that starts with zero balance. 
Your task is to detect if at any point the balance of account falls below zero, and at that point function 
should return True. Otherwise it should return False.
*/","use vstd::prelude::*;

verus! {

spec fn sum(s: Seq<int>, n: nat) -> int
    recommends n <= s.len()
    decreases n
{
    if s.len() == 0 || n == 0 {
        0
    } else {
        s[0] + sum(s.subrange(1, s.len() as int), (n - 1) as nat)
    }
}",,"fn below_zero(ops: Seq<int>) -> (result: bool)
    ensures result <==> exists|n: nat| n <= ops.len() && sum(ops, n) < 0","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0012,verus,dafnybench,BinaryAddition_ArrayToSequence,,"/* 
MIPS 0
We implement the following with bitvectors in Verus.
here s' and t' are converted to decimal scalars
s = [1,1,1], t = [1,0,1], ys = [1, 0, 0], s' = 7, t' = 5, ys' = 4
ys' % 2 ^ (len(s)) = (s' + t') % 2 ^ (len(s))
4 % 8 = 12 % 8

def f(s,t):
    a = 0;b = 0;
    ys = []
    for i in range(10):
        c = s[i]; d = t[i];
        next_a = b ^ c ^ d
        next_b = b+c+d>1
        a = next_a;b = next_b;
        y = a
        ys.append(y)
    return ys
*/","use vstd::prelude::*;

verus! {

spec fn array_to_bv10(arr: Seq<bool>) -> int
    recommends arr.len() == 10
{
    array_to_bv10_helper(arr, 9)
}

spec fn array_to_bv10_helper(arr: Seq<bool>, index: int) -> int
    recommends 0 <= index < arr.len()
    decreases index
{
    if index <= 0 {
        if arr[0] { 1 } else { 0 }
    } else {
        let bit: int = if arr[index] { 1 } else { 0 };
        bit * pow2(index) + array_to_bv10_helper(arr, index - 1)
    }
}

spec fn pow2(n: int) -> int
    recommends n >= 0
    decreases n
{
    if n <= 0 { 1 } else { 2 * pow2(n - 1) }
}

spec fn is_bit_set(x: int, bit_index: int) -> bool
    recommends 0 <= bit_index < 10 && x >= 0
{
    (x / pow2(bit_index)) % 2 == 1
}

spec fn bv10_to_seq(x: int) -> Seq<bool> {
    seq![is_bit_set(x, 0), is_bit_set(x, 1), is_bit_set(x, 2), is_bit_set(x, 3),
         is_bit_set(x, 4), is_bit_set(x, 5), is_bit_set(x, 6), is_bit_set(x, 7),
         is_bit_set(x, 8), is_bit_set(x, 9)]
}

spec fn bool_to_int(a: bool) -> int {
    if a { 1 } else { 0 }
}

spec fn xor_bool(a: bool, b: bool) -> bool {
    (a || b) && !(a && b)
}

spec fn bit_addition(s: Seq<bool>, t: Seq<bool>) -> Seq<bool> 
    recommends s.len() == 10 && t.len() == 10
{
    let a: int = array_to_bv10(s);
    let b: int = array_to_bv10(t);
    let c: int = (a + b) % pow2(10);
    bv10_to_seq(c)
}",,"fn array_to_sequence(arr: &[bool; 10]) -> (res: Vec<bool>)
    ensures 
        res.len() == 10,
        forall|k: int| 0 <= k < 10 ==> res[k] == arr[k]","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0013,verus,dafnybench,BinaryAddition_BinaryAddition,,"/* 
MIPS 0
We implement the following with bitvectors in Verus.
here s' and t' are converted to decimal scalars
s = [1,1,1], t = [1,0,1], ys = [1, 0, 0], s' = 7, t' = 5, ys' = 4
ys' % 2 ^ (len(s)) = (s' + t') % 2 ^ (len(s))
4 % 8 = 12 % 8

def f(s,t):
    a = 0;b = 0;
    ys = []
    for i in range(10):
        c = s[i]; d = t[i];
        next_a = b ^ c ^ d
        next_b = b+c+d>1
        a = next_a;b = next_b;
        y = a
        ys.append(y)
    return ys
*/

// Helper function to check if a bit is set

// Convert u16 to sequence of 10 bools (LSB first)

// Convert array of bools to u16 bitvector

// Convert array to sequence

// Boolean to integer conversion

// XOR operation

// Traditional bit addition using bitvectors

// Generated program for bit addition

// Verification of correctness","use vstd::prelude::*;

verus! {

spec fn is_bit_set(x: u16, bit_index: int) -> bool
    recommends 0 <= bit_index < 10
{
    (x & (1u16 << bit_index)) != 0
}

spec fn bv10_to_seq(x: u16) -> Seq<bool> {
    seq![
        is_bit_set(x, 0), is_bit_set(x, 1), is_bit_set(x, 2), is_bit_set(x, 3),
        is_bit_set(x, 4), is_bit_set(x, 5), is_bit_set(x, 6), is_bit_set(x, 7),
        is_bit_set(x, 8), is_bit_set(x, 9)
    ]
}

spec fn array_to_bv10(arr: &[bool; 10]) -> u16
{
    array_to_bv10_helper(arr, 9)
}

spec fn array_to_bv10_helper(arr: &[bool; 10], index: nat) -> u16
    recommends index < 10
    decreases index
{
    if index == 0 {
        if arr[index as int] { 1u16 } else { 0u16 }
    } else {
        let bit: u16 = if arr[index as int] { 1u16 } else { 0u16 };
        #[verifier::truncate]
        let shifted: u16 = (bit << (index as int));
        #[verifier::truncate]
        let result: u16 = (shifted as int + array_to_bv10_helper(arr, (index - 1) as nat) as int) as u16;
        result
    }
}

fn array_to_sequence(arr: &[bool; 10]) -> (res: Vec<bool>)
    ensures res.len() == 10,
            (forall|k: int| 0 <= k < 10 ==> res[k] == arr[k]),
{
    assume(false);
    Vec::new()
}

spec fn bool_to_int(a: bool) -> int {
    if a { 1 } else { 0 }
}

spec fn xor_bool(a: bool, b: bool) -> bool {
    (a || b) && !(a && b)
}

spec fn bit_addition(s: &[bool; 10], t: &[bool; 10]) -> Seq<bool> {
    let a: u16 = array_to_bv10(s);
    let b: u16 = array_to_bv10(t);
    #[verifier::truncate]
    let c: u16 = (a as int + b as int) as u16;
    bv10_to_seq(c)
}",,"fn binary_addition(s: &[bool; 10], t: &[bool; 10]) -> (sresult: Vec<bool>)
    requires s.len() == 10 && t.len() == 10
    ensures sresult.len() == 10,
            bit_addition(s, t) == sresult@,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0014,verus,dafnybench,BinarySearchTree_tmp_tmp_bn2twp5_bst4copy_insert,,,"use vstd::prelude::*;

verus! {

#[derive(PartialEq, Eq)]
pub enum Tree {
    Empty,
    Node(Box<Tree>, int, Box<Tree>),
}

pub open spec fn binary_search_tree(tree: Tree) -> bool
    decreases tree
{
    match tree {
        Tree::Empty => true,
        Tree::Node(left, value, right) => {
            (matches!(*left, Tree::Empty) || (*left).get_node_value() < value)
            && (matches!(*right, Tree::Empty) || (*right).get_node_value() > value)
            && binary_search_tree(*left)
            && binary_search_tree(*right)
            && min_value(*right, value)
            && max_value(*left, value)
        }
    }
}

pub open spec fn max_value(tree: Tree, max: int) -> bool
    decreases tree
{
    match tree {
        Tree::Empty => true,
        Tree::Node(left, value, right) => {
            max > value && max_value(*left, max) && max_value(*right, max)
        }
    }
}

pub open spec fn min_value(tree: Tree, min: int) -> bool
    decreases tree
{
    match tree {
        Tree::Empty => true,
        Tree::Node(left, value, right) => {
            min < value && min_value(*left, min) && min_value(*right, min)
        }
    }
}

impl Tree {
    pub open spec fn get_node_value(self) -> int
        recommends !matches!(self, Tree::Empty)
    {
        match self {
            Tree::Node(_, value, _) => value,
            _ => arbitrary()
        }
    }
}

fn insert_recursion(tree: Tree, value: int) -> (res: Tree)
    requires binary_search_tree(tree),
    ensures 
        res != Tree::Empty ==> binary_search_tree(res),
        forall|x: int| min_value(tree, x) && x < value ==> min_value(res, x),
        forall|x: int| max_value(tree, x) && x > value ==> max_value(res, x),
    decreases tree,
{
    assume(false);
    Tree::Empty
}",,"fn insert(tree: Tree, value: int) -> (res: Tree)
    requires binary_search_tree(tree),
    ensures binary_search_tree(res),
    decreases tree,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0015,verus,dafnybench,BinarySearchTree_tmp_tmp_bn2twp5_bst4copy_insertRecursion,,,"use vstd::prelude::*;

verus! {

pub enum Tree {
    Empty,
    Node { left: Box<Tree>, value: int, right: Box<Tree> },
}

pub open spec fn binary_search_tree(tree: Tree) -> bool
    decreases tree
{
    match tree {
        Tree::Empty => true,
        Tree::Node { left, value, right } => {
            (left.is_Empty() || left.get_Node_value() < value)
            && (right.is_Empty() || right.get_Node_value() > value)
            && binary_search_tree(*left) && binary_search_tree(*right)
            && min_value(*right, value) && max_value(*left, value)
        }
    }
}

pub open spec fn max_value(tree: Tree, max: int) -> bool
    decreases tree
{
    match tree {
        Tree::Empty => true,
        Tree::Node { left, value: v, right } => {
            (max > v) && max_value(*left, max) && max_value(*right, max)
        }
    }
}

pub open spec fn min_value(tree: Tree, min: int) -> bool
    decreases tree
{
    match tree {
        Tree::Empty => true,
        Tree::Node { left, value: v, right } => {
            (min < v) && min_value(*left, min) && min_value(*right, min)
        }
    }
}

impl Tree {
    pub open spec fn is_Empty(&self) -> bool {
        matches!(*self, Tree::Empty)
    }

    pub open spec fn get_Node_value(&self) -> int {
        match self {
            Tree::Node { value, .. } => *value,
            _ => arbitrary(),
        }
    }
}",,"fn insert_recursion(tree: Tree, value: int) -> (res: Tree)
    requires binary_search_tree(tree)
    ensures 
        res != Tree::Empty ==> binary_search_tree(res),
        forall|x: int| min_value(tree, x) && x < value ==> min_value(res, x),
        forall|x: int| max_value(tree, x) && x > value ==> max_value(res, x)
    decreases tree","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0023,verus,dafnybench,CS494-final-project_tmp_tmp7nof55uq_bubblesort_BubbleSort,,"//Bubblesort CS 494 submission

//References: https://stackoverflow.com/questions/69364687/how-to-prove-time-complexity-of-bubble-sort-using-dafny/69365785#69365785

// predicate checks if elements of a are in ascending order, two additional conditions are added to allow us to sort in specific range within array

//helps ensure swapping is valid, it is used inside the nested while loop to make sure linear order is being kept 

// all values within the array should be in ascending order

// Here having the algorithm for the bubblesort

// makes sure a is not empty and length is greater than 0

// makes sure elements of array a are sorted from 0 - a.len()

// Since a is being modified, we compare the previous elements to current elements.","use vstd::prelude::*;

verus! {

spec fn sorted(a: &Vec<i32>, from: usize, to: usize) -> bool
    recommends 
        from <= to,
        to <= a.len(),
{
    forall|x: usize, y: usize| from <= x < y < to ==> a[x as int] <= a[y as int]
}

spec fn pivot(a: &Vec<i32>, to: usize, pvt: usize) -> bool
    recommends
        pvt < to,
        to <= a.len(),
{
    forall|x: usize, y: usize| 0 <= x < pvt < y < to ==> a[x as int] <= a[y as int]
}",,"fn BubbleSort(a: &mut Vec<i32>)
    requires 
        old(a).len() > 0,
    ensures 
        sorted(a, 0, a.len()),
        a@.to_multiset() == old(a)@.to_multiset(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0036,verus,dafnybench,CVS-Projto1_tmp_tmpb1o0bu8z_proj1_proj1_query,,"//Exercicio 1.a)

//Exercicio 1.b)

//Exercicio 1.c)

///Exercicio 2.","use vstd::prelude::*;

verus! {

spec fn sum(a: Seq<int>, i: int, j: int) -> int
    recommends 0 <= i <= j <= a.len()
    decreases j when 0 <= i <= j <= a.len()
{
    if i == j {
        0
    } else {
        a[j - 1] + sum(a, i, j - 1)
    }
}

spec fn is_prefix_sum_for(a: Seq<int>, c: Seq<int>) -> bool {
    a.len() + 1 == c.len()
    && c[0] == 0
    && forall|j: int| 1 <= j <= a.len() ==> c[j] == sum(a, 0, j)
}

#[derive(PartialEq, Eq)]
enum List<T> {
    Nil,
    Cons { head: T, tail: Box<List<T>> }
}

fn from_array<T: Copy>(a: &[T]) -> (l: List<T>)
    requires a.len() > 0
    ensures forall|j: int| 0 <= j < a.len() ==> mem(a@[j], l)
{
    assume(false);
    List::Nil
}

spec fn mem<T>(x: T, l: List<T>) -> bool
    decreases l
{
    match l {
        List::Nil => false,
        List::Cons { head: y, tail: r } => if x == y { true } else { mem(x, *r) }
    }
}",,"exec fn query(a: &[i32], i: usize, j: usize) -> (s: i32)
    requires 0 <= i <= j <= a.len()
    ensures s == sum(a@.map(|k, x| x as int), i as int, j as int)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0037,verus,dafnybench,CVS-Projto1_tmp_tmpb1o0bu8z_proj1_proj1_queryFast,,"// Exercise 1.a)

// default case

// Exercise 1.b)

// Exercise 1.c)

// Exercise 2.","use vstd::prelude::*;

verus! {

spec fn sum(a: Seq<int>, i: int, j: int) -> int
    decreases j - i
{
    if i == j {
        0
    } else if i < j && j-1 < a.len() {
        a[j-1] + sum(a, i, j-1)
    } else {
        0
    }
}

spec fn is_prefix_sum_for(a: Seq<int>, c: Seq<int>) -> bool {
    a.len() + 1 == c.len()
    && c[0] == 0
    && forall |j: int| #![auto] 1 <= j <= a.len() ==> c[j] == sum(a, 0, j)
}

pub enum List<T> {
    Nil,
    Cons { head: T, tail: Box<List<T>> }
}

fn from_array<T: Copy + PartialEq>(a: &Vec<T>) -> (l: List<T>)
    requires a.len() > 0
    ensures forall |j: int| #![auto] 0 <= j < a.len() ==> mem(a@[j], &l)
{
    assume(false);
    List::Nil
}

spec fn mem<T: PartialEq>(x: T, l: &List<T>) -> bool
    decreases l
{
    match l {
        List::Nil => false,
        List::Cons { head: y, tail: r } => if x == *y { true } else { mem(x, r) }
    }
}",,"fn query_fast(a: Seq<int>, c: Seq<int>, i: int, j: int) -> (r: int)
    requires 
        is_prefix_sum_for(a, c) && 0 <= i <= j <= a.len() < c.len()
    ensures r == sum(a, i, j)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0040,verus,dafnybench,CVS-handout1_tmp_tmptm52no3k_1_query,,"/*                                      Cumulative Sums over Arrays                                        */

/*
    Daniel Cavalheiro   57869
    Pedro Nunes         57854
*/

//(a)

//(b)

//(c)","use vstd::prelude::*;

verus! {

spec fn sum(a: &[int], i: int, j: int) -> int
    recommends 0 <= i <= j <= a.len()
    decreases j - i when 0 <= i <= j <= a.len()
{
    if i == j { 0 }
    else { a[i] + sum(a, i + 1, j) }
}

spec fn is_prefix_sum_for(a: &[int], c: &[int]) -> bool
{
    &&& a.len() + 1 == c.len()
    &&& c[0] == 0
    &&& forall|i: int| 0 <= i < a.len() ==> c[i + 1] == c[i] + a[i]
}",,"fn query(a: &[int], i: usize, j: usize) -> (res: i64)
    requires 0 <= i <= j <= a.len()
    ensures res == sum(a, i as int, j as int)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0041,verus,dafnybench,CVS-handout1_tmp_tmptm52no3k_1_queryFast,,"/*                                      Cumulative Sums over Arrays                                        */

/*
    Daniel Cavalheiro   57869
    Pedro Nunes         57854
*/

//(a)

//(b)

//(c)","use vstd::prelude::*;

verus! {

spec fn sum(a: Seq<int>, i: int, j: int) -> int
    decreases j - i
{
    if i >= j { 
        0 
    } else { 
        a[i] + sum(a, i + 1, j) 
    }
}

spec fn is_prefix_sum_for(a: Seq<int>, c: Seq<int>) -> bool
{
    &&& a.len() + 1 == c.len() 
    &&& c.len() > 0 
    &&& c[0] == 0
    &&& forall|i: int| 0 <= i < a.len() ==> c[i + 1] == c[i] + a[i]
}",,"fn queryFast(a: &[i32], c: &[i32], i: i32, j: i32) -> (r: i32)
    requires a.len() + 1 == c.len() && c.len() > 0 && c@[0] == 0,
        0 <= i <= j <= a.len(),
        is_prefix_sum_for(a@.map(|_i, x| x as int), c@.map(|_i, x| x as int))
    ensures r as int == sum(a@.map(|_i, x| x as int), i as int, j as int)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0042,verus,dafnybench,Clover_abs_Abs,,,"use vstd::prelude::*;

verus! {",,"fn abs(x: int) -> (y: int)
    ensures 
        x >= 0 ==> x == y,
        x < 0 ==> x + y == 0,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0043,verus,dafnybench,Clover_all_digits_allDigits,,,"use vstd::prelude::*;

verus! {",,"fn all_digits(s: &str) -> (result: bool)
    ensures result <==> (forall|i: int| 0 <= i < s@.len() ==> {
        let c = #[trigger] s@.index(i);
        c == '0' || c == '1' || c == '2' || c == '3' || c == '4' || 
        c == '5' || c == '6' || c == '7' || c == '8' || c == '9'
    })","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0044,verus,dafnybench,Clover_array_append_append,,,"use vstd::prelude::*;

verus! {",,"fn append(a: &Vec<i32>, b: i32) -> (c: Vec<i32>)
    ensures c@ == a@ + seq![b]","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0045,verus,dafnybench,Clover_array_concat_concat,,,"use vstd::prelude::*;

verus! {",,"fn concat(a: &[i32], b: &[i32]) -> (c: Vec<i32>)
    ensures 
        c.len() == b.len() + a.len(),
        forall|k: int| 0 <= k < a.len() ==> c[k] == a[k],
        forall|k: int| 0 <= k < b.len() ==> c[k + a.len()] == b[k],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0046,verus,dafnybench,Clover_array_product_arrayProduct,,,"use vstd::prelude::*;

verus! {",,"fn array_product(a: &[i32], b: &[i32]) -> (c: Vec<i32>)
    requires 
        a.len() == b.len(),
    ensures 
        c.len() == a.len(),
        forall|i: int| 0 <= i < a.len() ==> a[i] * b[i] == c[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0047,verus,dafnybench,Clover_array_sum_arraySum,,,"use vstd::prelude::*;

verus! {",,"fn array_sum(a: &Vec<i32>, b: &Vec<i32>) -> (c: Vec<i32>)
    requires 
        a.len() == b.len(),
    ensures 
        c.len() == a.len(),
        forall|i: int| 0 <= i < a.len() ==> a[i] + b[i] == c[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0048,verus,dafnybench,Clover_avg_ComputeAvg,,,"use vstd::prelude::*;

verus! {",,"fn compute_avg(a: int, b: int) -> (avg: int)
    ensures avg == (a + b) / 2","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0049,verus,dafnybench,Clover_below_zero_below_zero,,,"use vstd::prelude::*;

verus! {",,"fn below_zero(operations: Vec<i32>) -> (result: (Vec<i32>, bool))
    ensures
        result.0.len() == operations.len() + 1,
        result.0[0] == 0,
        forall|i: int| 0 <= i < (result.0.len() - 1) as int ==> result.0[i + 1] == result.0[i] + operations[i],
        result.1 == true ==> exists|i: int| 1 <= i <= operations.len() as int && result.0[i] < 0,
        result.1 == false ==> forall|i: int| 0 <= i < result.0.len() as int ==> result.0[i] >= 0,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0050,verus,dafnybench,Clover_binary_search_BinarySearch,,,"use vstd::prelude::*;

verus! {",,"fn binary_search(a: &[i32], key: i32) -> (n: usize)
    requires 
        forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j]
    ensures 
        0 <= n <= a.len(),
        forall|i: int| 0 <= i < n ==> a[i] < key,
        n == a.len() ==> forall|i: int| 0 <= i < a.len() ==> a[i] < key,
        forall|i: int| n <= i < a.len() ==> a[i] >= key","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0051,verus,dafnybench,Clover_bubble_sort_BubbleSort,,,"use vstd::prelude::*;

verus! {",,"fn bubble_sort(a: &mut Vec<i32>)
    ensures 
        forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j],
        a@.to_multiset() == old(a)@.to_multiset(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0052,verus,dafnybench,Clover_cal_ans_CalDiv,,,"use vstd::prelude::*;

verus! {",,"fn cal_div() -> (result: (i32, i32))
  ensures result.0 == 191i32 / 7i32 && result.1 == 191i32 % 7i32,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0053,verus,dafnybench,Clover_cal_sum_Sum,,,"use vstd::prelude::*;

verus! {",,"fn sum(n: u32) -> (s: u32)
    requires n >= 0
    ensures s == n * (n + 1) / 2","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0054,verus,dafnybench,Clover_canyon_search_CanyonSearch,,,"use vstd::prelude::*;

verus! {",,"fn canyon_search(a: &[i32], b: &[i32]) -> (d: u32)
  requires 
      a.len() != 0 && b.len() != 0,
      forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j],
      forall|i: int, j: int| 0 <= i < j < b.len() ==> b[i] <= b[j],
  ensures
      exists|i: int, j: int| 0 <= i < a.len() && 0 <= j < b.len() && 
          d as int == (if a[i] < b[j] { 
              b[j] - a[i]
          } else { 
              a[i] - b[j]
          }),
      forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < b.len() ==> 
          d as int <= (if a[i] < b[j] { 
              b[j] - a[i]
          } else { 
              a[i] - b[j]
          }),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0055,verus,dafnybench,Clover_convert_map_key_convert_map_key,,,"use vstd::prelude::*;

verus! {",,"fn convert_map_key(inputs: Map<nat, bool>, f: spec_fn(nat) -> nat) -> (r: Map<nat, bool>)
    requires
        forall|n1: nat, n2: nat| 
            #[trigger] f(n1) != #[trigger] f(n2) ==> n1 != n2,
    ensures
        forall|k: nat| inputs.contains_key(k) <==> r.contains_key(f(k)),
        forall|k: nat| inputs.contains_key(k) ==> r[f(k)] == inputs[k],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0056,verus,dafnybench,Clover_copy_part_copy,,,"use vstd::prelude::*;

verus! {",,"fn copy(src: &[i32], s_start: usize, dest: &[i32], d_start: usize, len: usize) -> (r: Vec<i32>)
    requires 
        src.len() >= s_start + len,
        dest.len() >= d_start + len,
    ensures 
        r.len() == dest.len(),
        r@.subrange(0, d_start as int) =~= dest@.subrange(0, d_start as int),
        r@.subrange((d_start + len) as int, dest.len() as int) =~= dest@.subrange((d_start + len) as int, dest.len() as int),
        r@.subrange(d_start as int, (len + d_start) as int) =~= src@.subrange(s_start as int, (len + s_start) as int),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0057,verus,dafnybench,Clover_count_lessthan_CountLessThan,,,"use vstd::prelude::*;

verus! {",,"fn count_less_than(numbers: Set<int>, threshold: int) -> (count: usize)
    ensures count == numbers.filter(|i: int| i < threshold).len()","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0058,verus,dafnybench,Clover_double_array_elements_double_array_elements,,,"use vstd::prelude::*;

verus! {",,"fn double_array_elements(s: &mut Vec<i32>)
    ensures forall|i: int| 0 <= i < old(s).len() ==> s[i] == 2 * old(s)[i]","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0059,verus,dafnybench,Clover_double_quadruple_DoubleQuadruple,,,"use vstd::prelude::*;

verus! {",,"fn double_quadruple(x: i32) -> (ret: (i32, i32))
  ensures ret.0 == 2 * x && ret.1 == 4 * x","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0060,verus,dafnybench,Clover_even_list_FindEvenNumbers,,,"use vstd::prelude::*;

verus! {",,"fn find_even_numbers(arr: &[i32]) -> (even_numbers: Vec<i32>)
    ensures 
        (forall|x: i32| arr@.contains(x) && x % 2 == 0 ==> even_numbers@.contains(x)) &&
        (forall|x: i32| !arr@.contains(x) ==> !even_numbers@.contains(x)) &&
        (forall|k: int| 0 <= k < even_numbers@.len() ==> even_numbers@[k] % 2 == 0) &&
        (forall|k: int, l: int| 0 <= k < l < even_numbers@.len() ==> 
            exists|n: int, m: int| 0 <= n < m < arr@.len() && 
            #[trigger] even_numbers@[k] == #[trigger] arr@[n] && 
            #[trigger] even_numbers@[l] == #[trigger] arr@[m])","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0061,verus,dafnybench,Clover_find_Find,,,"use vstd::prelude::*;

verus! {",,"fn find(a: &[i32], key: i32) -> (index: i32)
    ensures
        -1 <= index < a.len() as i32,
        index != -1 ==> a[index as int] == key && (forall|i: int| 0 <= i < index ==> a[i] != key),
        index == -1 ==> (forall|i: int| 0 <= i < a.len() ==> a[i] != key),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0062,verus,dafnybench,Clover_has_close_elements_has_close_elements,,,"use vstd::prelude::*;

verus! {

spec fn abs_diff(a: int, b: int) -> int {
    if a - b < 0 { b - a } else { a - b }
}",,"fn has_close_elements(numbers: Seq<int>, threshold: int) -> (res: bool)
    requires threshold >= 0,
    ensures 
        (res ==> exists|i: int, j: int| 0 <= i < numbers.len() && 0 <= j < numbers.len() && i != j && 
            abs_diff(numbers[i], numbers[j]) < threshold),
        (!res ==> forall|i: int, j: int| 1 <= i < numbers.len() && 0 <= j < i ==> 
            abs_diff(numbers[i], numbers[j]) >= threshold),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0063,verus,dafnybench,Clover_insert_insert,,,"use vstd::prelude::*;

verus! {",,"fn insert(line: &mut Vec<char>, l: int, nl: &Vec<char>, p: int, at: int)
    requires 
        0 <= l + p <= old(line).len(),
        0 <= p <= nl.len(),
        0 <= at <= l,
    ensures 
        forall|i: int| (0 <= i < p) ==> line[at + i] == nl[i],
        forall|i: int| (0 <= i < at) ==> line[i] == old(line)[i],
        forall|i: int| (at + p <= i < l + p) ==> line[i] == old(line)[i - p],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0064,verus,dafnybench,Clover_integer_square_root_SquareRoot,,,"use vstd::prelude::*;

verus! {",,"fn square_root(n: u32) -> (r: u32)
  ensures r * r <= n < (r + 1) * (r + 1)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0065,verus,dafnybench,Clover_is_even_ComputeIsEven,,,"use vstd::prelude::*;

verus! {",,"fn compute_is_even(x: int) -> (is_even: bool)
    ensures (x % 2 == 0) == is_even","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0066,verus,dafnybench,Clover_is_palindrome_IsPalindrome,,,"use vstd::prelude::*;

verus! {",,"fn is_palindrome(x: Seq<char>) -> (result: bool)
  ensures result <==> (forall|i: int| 0 <= i < x.len() ==> #[trigger] x[i] == x[x.len() - i - 1])","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0067,verus,dafnybench,Clover_linear_search1_LinearSearch,,,"use vstd::prelude::*;

verus! {",,"fn linear_search(a: &[i32], e: i32) -> (n: usize)
    ensures 
        n <= a.len(),
        n == a.len() || a[n as int] == e,
        forall|i: int| 0 <= i < n ==> e != a[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0068,verus,dafnybench,Clover_linear_search2_LinearSearch,,,"use vstd::prelude::*;

verus! {",,"fn linear_search(a: &[i32], e: i32) -> (n: usize)
    requires exists|i: int| 0 <= i < a.len() && a[i] == e,
    ensures ({
        &&& 0 <= n < a.len() 
        &&& a[n as int] == e
        &&& forall|k: int| 0 <= k < n as int ==> a[k] != e
    }),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0069,verus,dafnybench,Clover_longest_prefix_LongestCommonPrefix,,,"use vstd::prelude::*;

verus! {",,"fn longest_common_prefix(str1: Seq<char>, str2: Seq<char>) -> (prefix: Seq<char>)
    ensures 
        prefix.len() <= str1.len() && prefix == str1.subrange(0, prefix.len() as int) &&
        prefix.len() <= str2.len() && prefix == str2.subrange(0, prefix.len() as int),
        prefix.len() == str1.len() || prefix.len() == str2.len() || 
        (str1[prefix.len() as int] != str2[prefix.len() as int])","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0070,verus,dafnybench,Clover_match_Match,,,"use vstd::prelude::*;

verus! {",,"fn match_strings(s: Seq<char>, p: Seq<char>) -> (b: bool)
  requires s.len() == p.len()
  ensures b == (forall|n: int| 0 <= n < s.len() ==> s[n] == p[n] || p[n] == '?')","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0071,verus,dafnybench,Clover_max_array_maxArray,,,"use vstd::prelude::*;

verus! {",,"fn maxArray(a: &[int]) -> (m: int)
    requires a.len() >= 1,
    ensures 
        forall|k: int| 0 <= k < a.len() ==> m >= a@[k] &&
        exists|k: int| 0 <= k < a.len() && m == a@[k],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0072,verus,dafnybench,Clover_min_array_minArray,,"// Note: Verus currently has syntax limitations with exists quantifiers in postconditions

// The second ensures clause from Dafny cannot be directly translated","use vstd::prelude::*;

verus! {",,"fn min_array(a: &[i32]) -> (r: i32)
    requires a.len() > 0,
    ensures forall|i: int| 0 <= i < a.len() ==> r <= a[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0073,verus,dafnybench,Clover_min_of_two_Min,,,"use vstd::prelude::*;

verus! {",,"fn min(x: int, y: int) -> (z: int)
    ensures
        x <= y ==> z == x,
        x > y ==> z == y,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0074,verus,dafnybench,Clover_modify_2d_array_modify_array_element,,,"use vstd::prelude::*;

verus! {",,"fn modify_array_element(arr: &mut Vec<Vec<nat>>, index1: usize, index2: usize, val: nat)
  requires
      index1 < old(arr).len(),
      index2 < old(arr)[index1 as int].len(),
      forall|i: int, j: int| 
          0 <= i < old(arr).len() && 0 <= j < old(arr).len() && i != j ==> 
          !equal(old(arr)[i], old(arr)[j]),
  ensures
      arr.len() == old(arr).len(),
      forall|i: int| 0 <= i < arr.len() ==> equal(arr[i], old(arr)[i]),
      forall|i: int, j: int| 
          0 <= i < arr.len() && 0 <= j < arr[i].len() && 
          (i != index1 || j != index2) ==> 
          arr[i][j] == old(arr)[i][j],
      arr[index1 as int][index2 as int] == val,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0075,verus,dafnybench,Clover_multi_return_MultipleReturns,,,"use vstd::prelude::*;

verus! {",,"fn multiple_returns(x: int, y: int) -> (result: (int, int))
    ensures 
        result.0 == x + y,
        result.1 == x - y,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0076,verus,dafnybench,Clover_online_max_onlineMax,,,"use vstd::prelude::*;

verus! {",,"fn online_max(a: &[i32], x: usize) -> (result: (Ghost<i32>, usize))
    requires 
        1 <= x < a.len(),
        a.len() != 0,
    ensures
        x <= result.1 < a.len(),
        forall|i: int| 0 <= i < x ==> #[trigger] a[i] <= result.0@,
        exists|i: int| 0 <= i < x && #[trigger] a[i] == result.0@,
        x <= result.1 < a.len() - 1 ==> (forall|i: int| 0 <= i < result.1 ==> #[trigger] a[i] < a[result.1 as int]),
        (forall|i: int| x <= i < a.len() && #[trigger] a[i] <= result.0@) ==> result.1 == a.len() - 1","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0077,verus,dafnybench,Clover_quotient_Quotient,,,"use vstd::prelude::*;

verus! {",,"fn quotient(x: nat, y: nat) -> (result: (int, int))
    requires y != 0
    ensures ({
        let (r, q) = result;
        q * y + r == x && 0 <= r < y && 0 <= q
    })","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0079,verus,dafnybench,Clover_replace_replace,,,"use vstd::prelude::*;

verus! {",,"fn replace(arr: &mut Vec<i32>, k: i32)
    ensures 
        forall|i: int| 0 <= i < old(arr).len() ==> old(arr)[i] > k ==> arr[i] == -1,
        forall|i: int| 0 <= i < old(arr).len() ==> old(arr)[i] <= k ==> arr[i] == old(arr)[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0080,verus,dafnybench,Clover_return_seven_M,,,"use vstd::prelude::*;

verus! {",,"fn M(x: int) -> (seven: int)
  ensures seven == 7","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0081,verus,dafnybench,Clover_reverse_reverse,,,"use vstd::prelude::*;

verus! {",,"fn reverse(a: &mut Vec<i32>)
    ensures forall|i: int| 0 <= i < old(a).len() ==> a[i] == old(a)[old(a).len() - 1 - i]","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVD03,0.85
VD0082,verus,dafnybench,Clover_rotate_rotate,,,"use vstd::prelude::*;

verus! {",,"fn rotate(a: &[i32], offset: usize) -> (result: Vec<i32>)
    requires 
        offset >= 0,
    ensures 
        result.len() == a.len(),
        forall|i: int| 0 <= i < a.len() ==> result[i] == a[(i + offset as int) % a.len() as int],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0083,verus,dafnybench,Clover_selectionsort_SelectionSort,,,"use vstd::prelude::*;

verus! {",,"fn selection_sort(a: &mut Vec<i32>)
    ensures
        forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j],
        a@.to_multiset() == old(a)@.to_multiset(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0084,verus,dafnybench,Clover_slope_search_SlopeSearch,,"// Each row is sorted (non-decreasing)

// Each column is sorted (non-decreasing)  

// Key exists in the matrix","use vstd::prelude::*;

verus! {",,"fn slope_search(a: &Vec<Vec<i32>>, key: i32) -> (result: (usize, usize))
  requires 
      a.len() > 0,
      forall|i: int| 0 <= i < a.len() ==> #[trigger] a@[i].len() == a@[0].len(),
      a@[0].len() > 0,

      forall|i: int, j: int, j_prime: int| 
          0 <= i < a.len() && 0 <= j < j_prime < a@[0].len()
          ==> #[trigger] a@[i]@[j] <= #[trigger] a@[i]@[j_prime],

      forall|i: int, i_prime: int, j: int| 
          0 <= i < i_prime < a.len() && 0 <= j < a@[0].len()
          ==> #[trigger] a@[i]@[j] <= #[trigger] a@[i_prime]@[j],

      exists|i: int, j: int| 
          0 <= i < a.len() && 0 <= j < a@[0].len()
          && #[trigger] a@[i]@[j] == key
  ensures
      result.0 < a.len(),
      result.1 < a@[0].len(),
      a@[result.0 as int]@[result.1 as int] == key","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0085,verus,dafnybench,Clover_swap_Swap,,,"use vstd::prelude::*;

verus! {",,"fn swap(x: i32, y: i32) -> (result: (i32, i32))
    ensures 
        result.0 == y,
        result.1 == x,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0086,verus,dafnybench,Clover_swap_arith_SwapArithmetic,,,"use vstd::prelude::*;

verus! {",,"fn swap_arithmetic(x: i32, y: i32) -> (res: (i32, i32))
    ensures 
        res.0 == y && res.1 == x,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0087,verus,dafnybench,Clover_swap_bitvector_SwapBitvectors,,,"use vstd::prelude::*;

verus! {",,"fn swap_bitvectors(x: u8, y: u8) -> (result: (u8, u8))
    ensures 
        result.0 == y,
        result.1 == x,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0088,verus,dafnybench,Clover_swap_in_array_swap,,,"use vstd::prelude::*;

verus! {",,"fn swap(arr: &mut Vec<i32>, i: usize, j: usize)
    requires 
        i < old(arr).len(),
        j < old(arr).len(),
    ensures
        arr[i as int] == old(arr)[j as int],
        arr[j as int] == old(arr)[i as int],
        forall|k: int| 0 <= k < arr.len() && k != i && k != j ==> arr[k] == old(arr)[k],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0089,verus,dafnybench,Clover_swap_sim_SwapSimultaneous,,,"use vstd::prelude::*;

verus! {",,"fn swap_simultaneous(x_param: i32, y_param: i32) -> (ret: (i32, i32))
    ensures 
        ret.0 == y_param,
        ret.1 == x_param,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0090,verus,dafnybench,Clover_test_array_TestArrayElements,,,"use vstd::prelude::*;

verus! {",,"fn test_array_elements(a: &mut Vec<i32>, j: usize)
    requires 
        j < old(a).len(),
    ensures 
        a.len() == old(a).len(),
        a[j as int] == 60,
        forall|k: int| 0 <= k < a.len() && k != j ==> a[k] == old(a)[k],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0091,verus,dafnybench,Clover_triple2_Triple,,,"use vstd::prelude::*;

verus! {",,"fn triple(x: int) -> (r: int)
  ensures r == 3 * x","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0092,verus,dafnybench,Clover_triple3_Triple,,,"use vstd::prelude::*;

verus! {",,"fn triple(x: int) -> (r: int)
  ensures r == 3 * x","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0093,verus,dafnybench,Clover_triple4_Triple,,,"use vstd::prelude::*;

verus! {",,"fn triple(x: int) -> (r: int)
    ensures r == 3 * x","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0094,verus,dafnybench,Clover_triple_Triple,,,"use vstd::prelude::*;

verus! {",,"fn triple(x: i32) -> (r: i32)
  ensures r == 3 * x","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0095,verus,dafnybench,Clover_two_sum_twoSum,,,"use vstd::prelude::*;

verus! {",,"fn twoSum(nums: &[i32], target: i32) -> (result: (usize, usize))
    requires 
        nums.len() > 1,
        exists|i: int, j: int| 0 <= i < j < nums.len() && nums[i] + nums[j] == target,
    ensures 
        0 <= result.0 < result.1 < nums.len() && nums[result.0 as int] + nums[result.1 as int] == target
        && forall|ii: int, jj: int| #![trigger nums[ii], nums[jj]] (0 <= ii < result.0 && ii < jj < nums.len()) ==> nums[ii] + nums[jj] != target
        && forall|jj: int| #![trigger nums[jj]] result.0 < jj < result.1 ==> nums[result.0 as int] + nums[jj] != target,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0096,verus,dafnybench,Clover_update_array_UpdateElements,,,"use vstd::prelude::*;

verus! {",,"fn update_elements(a: &mut Vec<i32>)
    requires 
        old(a).len() >= 8,
    ensures 
        old(a)[4] + 3 == a[4],
        a[7] == 516,
        forall|i: int| 0 <= i < a.len() ==> i != 7 && i != 4 ==> a[i] == old(a)[i],
        a.len() == old(a).len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0100,verus,dafnybench,Correctness_tmp_tmpwqvg5q_4_Sorting_Tangent_BinarySearch,,"/**
  Ather, Mohammad Faiz (s4648481/3)
  CSSE3100
  Assignemnt 3
  The University of Queensland
 */

// Question 1

// Author: Leino, Title: Program Proofs","use vstd::prelude::*;

verus! {",,"fn binary_search(a: &[i32], circle: i32) -> (n: usize)
    requires 
        forall|i: int| #![trigger a[i]] 1 <= i < a.len() ==> a[i-1] < a[i],
        forall|i: int, j: int| #![trigger a[i], a[j]] 0 <= i < j < a.len() ==> a[i] < a[j],
    ensures 
        n <= a.len(),
        forall|i: int| #![trigger a[i]] 0 <= i < n ==> a[i] < circle,
        forall|i: int| #![trigger a[i]] n <= i < a.len() ==> circle <= a[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0101,verus,dafnybench,Correctness_tmp_tmpwqvg5q_4_Sorting_Tangent_Tangent,,"/**
  Ather, Mohammad Faiz (s4648481/3)
  CSSE3100
  Assignemnt 3
  The University of Queensland
 */

// Question 1

// Author: Leino, Title: Program Proofs","use vstd::prelude::*;

verus! {

fn binary_search(a: &[int], circle: int) -> (n: usize)
    requires
        forall|i: int| 1 <= i < a.len() ==> a[i-1] < #[trigger] a[i],
        forall|i: int, j: int| 0 <= i < j < a.len() ==> #[trigger] a[i] < #[trigger] a[j],
    ensures
        n <= a.len(),
        forall|i: int| 0 <= i < n ==> #[trigger] a[i] < circle,
        forall|i: int| n <= i < a.len() ==> circle <= #[trigger] a[i],
{
    assume(false);
    0
}",,"fn tangent(r: &[int], x: &[int]) -> (found: bool)
    requires
        forall|i: int| 1 <= i < x.len() ==> x[i-1] < #[trigger] x[i],
        forall|i: int, j: int| 0 <= i < j < x.len() ==> #[trigger] x[i] < #[trigger] x[j],
    ensures
        !found ==> forall|i: int, j: int| 
            0 <= i < r.len() && 0 <= j < x.len() ==> #[trigger] r[i] != #[trigger] x[j],
        found ==> exists|i: int, j: int|
            0 <= i < r.len() && 0 <= j < x.len() && #[trigger] r[i] == #[trigger] x[j],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0102,verus,dafnybench,Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExerciseFibonacci_fibonacci1,,// practical bound to prevent overflow,"use vstd::prelude::*;

verus! {

spec fn fib(n: nat) -> nat
    decreases n
{
    if n == 0 { 0 }
    else if n == 1 { 1 }
    else { fib((n - 1) as nat) + fib((n - 2) as nat) }
}",,"fn fibonacci1(n: u64) -> (f: u64)
    requires n < 100,
    ensures f == fib(n as nat)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0105,verus,dafnybench,Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExercisePositive_mpositive,,,"use vstd::prelude::*;

verus! {

spec fn positive(s: Seq<int>) -> bool {
    forall|u: int| 0 <= u < s.len() ==> s[u] >= 0
}",,"fn mpositive(v: &[int]) -> (b: bool)
    ensures b == positive(v@)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0109,verus,dafnybench,Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExerciseSquare_root_mroot1,,//Cost O(root n),"use vstd::prelude::*;

verus! {",,"fn mroot1(n: u32) -> (r: u32)
    requires n >= 0,
    ensures r >= 0 && (r as int) * (r as int) <= n < ((r + 1) as int) * ((r + 1) as int),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0112,verus,dafnybench,Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_mfirstMaximum,,"//Algorithm 1: From left to right return the first

//Algorithm 2: From right to left return the last

//Algorithm: from left to right

//Algorithm : from left to right

//Algorithm : from right to left","use vstd::prelude::*;

verus! {",,"fn mfirstMaximum(v: &Vec<i32>) -> (i: usize)
    requires v.len() > 0,
    ensures 
        0 <= i < v.len() &&
        (forall|k: int| 0 <= k < v.len() ==> v[i as int] >= v[k]) &&
        (forall|l: int| 0 <= l < i ==> v[i as int] > v[l]),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0113,verus,dafnybench,Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_mlastMaximum,,"// Algorithm 1: From left to right return the first

// Algorithm 2: From right to left return the last

// Algorithm : from left to right

// Algorithm : from right to left","use vstd::prelude::*;

verus! {",,"fn mlast_maximum(v: &[i32]) -> (i: usize)
    requires v.len() > 0
    ensures 
        i < v.len(),
        forall|k: int| 0 <= k < v.len() ==> v[i as int] >= v[k],
        forall|l: int| i < l < v.len() ==> v[i as int] > v[l],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0114,verus,dafnybench,Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_mmaximum1,,"//Algorithm 1: From left to right return the first

//Algorithm 2: From right to left return the last

//Algorithm : from left to right

//Algorithm : from right to left","use vstd::prelude::*;

verus! {",,"fn mmaximum1(v: &[i32]) -> (i: usize)
    requires v.len() > 0,
    ensures 
        0 <= i < v.len(),
        forall|k: int| 0 <= k < v.len() ==> v[i as int] >= v[k],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0118,verus,dafnybench,Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseAllEqual_mallEqual1,,"//forall|i: int, j: int| 0 <= i <= j < s.len() ==> s[i] == s[j]

//forall|i: int| 0 < i < s.len() ==> s[i-1] == s[i]

//forall|i: int| 0 <= i < s.len() - 1 ==> s[i] == s[i+1]

//Ordered indexes

//All equal to first","use vstd::prelude::*;

verus! {

spec fn all_equal(s: Seq<i32>) -> bool {
    forall|i: int, j: int| 0 <= i < s.len() && 0 <= j < s.len() ==> s[i] == s[j]
}",,"fn mall_equal1(v: &[i32]) -> (b: bool)
    ensures b == all_equal(v@)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0123,verus,dafnybench,Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseContained_mcontained,,"//Specify and implement an O(m+n) algorithm that returns b

//v and w are strictly increasing ordered arrays

//b is true iff the first n elements of v are contained in the first m elements of w","use vstd::prelude::*;

verus! {

spec fn strict_sorted(s: Seq<i32>) -> bool {
    forall|u: int, w: int| 0 <= u < w < s.len() ==> s[u] < s[w]
}",,"fn mcontained(v: &[i32], w: &[i32], n: usize, m: usize) -> (b: bool)
    requires 
        n <= m,
        n >= 0,
        strict_sorted(v@),
        strict_sorted(w@),
        v@.len() >= n,
        w@.len() >= m,
    ensures
        b == forall|k: int| 0 <= k < n ==> w@.subrange(0, m as int).contains(v@[k])","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0124,verus,dafnybench,Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseFirstNegative_mfirstNegative,,,"use vstd::prelude::*;

verus! {

spec fn positive(s: Seq<int>) -> bool {
    forall|u: int| 0 <= u < s.len() ==> s[u] >= 0
}",,"fn mfirstNegative(v: &[int]) -> (result: (bool, usize))
    ensures 
        (result.0 <==> exists|k: int| 0 <= k < v.len() && v[k] < 0) &&
        (result.0 ==> (result.1 < v.len() && v[result.1 as int] < 0 && positive(v@.subrange(0, result.1 as int))))","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0126,verus,dafnybench,Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExercisefirstZero_mfirstCero,,,"use vstd::prelude::*;

verus! {",,"fn mfirst_cero(v: &[i32]) -> (i: usize)
    ensures
        i <= v.len(),
        forall|j: int| 0 <= j < i as int ==> v@[j] != 0,
        i != v.len() ==> v@[i as int] == 0,
{
    assume(false);
    0
}",,"}
fn main() {}",0,,-1,-1,-1,,1.0
VD0127,verus,dafnybench,Dafny-Exercises_tmp_tmpjm75muf__Session5Exercises_ExerciseSumElems_sumElems,,"//ensures sum as int == sum_l(v@.map(|i, x| x as int))

//ensures sum as int == sum_v(v@.map(|i, x| x as int), 0, v@.len())","use vstd::prelude::*;

verus! {

spec fn sum_r(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else {
        sum_r(s.subrange(0, s.len() - 1)) + s[s.len() - 1]
    }
}

spec fn sum_l(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else {
        s[0] + sum_l(s.subrange(1, s.len() as int))
    }
}

spec fn sum_v(v: Seq<int>, c: int, f: int) -> int {
    if 0 <= c <= f <= v.len() {
        sum_r(v.subrange(c, f))
    } else {
        0
    }
}",,"fn sum_elems(v: &[i32]) -> (sum: i32)
ensures sum as int == sum_r(v@.map(|i, x| x as int))","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0128,verus,dafnybench,Dafny-Exercises_tmp_tmpjm75muf__Session5Exercises_ExerciseSumElems_sumElemsB,,"//ensures sum as int == sum_l(v@.map(|i, x| x as int))","use vstd::prelude::*;

verus! {

spec fn sum_r(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else {
        sum_r(s.subrange(0, s.len() - 1)) + s[s.len() - 1]
    }
}

spec fn sum_l(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else {
        s[0] + sum_l(s.subrange(1, s.len() as int))
    }
}

spec fn sum_v(v: Seq<int>, c: int, f: int) -> int
{
    if 0 <= c <= f <= v.len() {
        sum_r(v.subrange(c, f))
    } else {
        0
    }
}",,"fn sum_elems_b(v: &[i32]) -> (sum: i32)
ensures sum as int == sum_r(v@.map(|i, x| x as int))","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0129,verus,dafnybench,Dafny-Exercises_tmp_tmpjm75muf__Session6Exercises_ExerciseCountEven_mcountEven,,,"use vstd::prelude::*;

verus! {

spec fn positive(s: Seq<int>) -> bool {
    forall|u: int| 0 <= u < s.len() ==> s[u] >= 0
}

spec fn is_even(i: int) -> bool
    recommends i >= 0
{
    i % 2 == 0
}

spec fn count_even(s: Seq<int>) -> int
    recommends positive(s)
    decreases s.len()
{
    if s.len() == 0 {
        0 as int
    } else {
        (if s[s.len() - 1] % 2 == 0 { 1 as int } else { 0 as int }) + count_even(s.subrange(0, s.len() - 1))
    }
}",,"fn mcount_even(v: &Vec<i32>) -> (n: i32)
    requires positive(v@.map(|i: int, x: i32| x as int))
    ensures n as int == count_even(v@.map(|i: int, x: i32| x as int))","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0130,verus,dafnybench,Dafny-Exercises_tmp_tmpjm75muf__Session6Exercises_ExerciseCountMin_mCountMin,,"// dummy value for invalid inputs

// dummy value for invalid inputs

//Implement and verify an O(v.len()) algorithm","use vstd::prelude::*;

verus! {

spec fn min(v: Seq<int>, i: int) -> int
    decreases i
{
    if 1 <= i <= v.len() {
        if i == 1 {
            v[0]
        } else if v[i-1] <= min(v, i-1) {
            v[i-1]
        } else {
            min(v, i-1)
        }
    } else {
        0
    }
}

proof fn min_property(v: Seq<int>, i: int)
    requires 1 <= i <= v.len()
    ensures forall|k: int| 0 <= k < i ==> v[k] >= min(v, i)
    decreases i
{
    if i > 1 {
        min_property(v, i-1);
    }
}

spec fn count_min(v: Seq<int>, x: int, i: int) -> int
    decreases i
{
    if 0 <= i <= v.len() {
        if i == 0 {
            0
        } else if v[i-1] == x {
            1 + count_min(v, x, i-1)
        } else {
            count_min(v, x, i-1)
        }
    } else {
        0
    }
}

proof fn count_min_property(v: Seq<int>, x: int, i: int)
    requires 0 <= i <= v.len()
    ensures !(exists|k: int| 0 <= k < i && v[k] == x) ==> count_min(v, x, i) == 0
    decreases i
{
    if i > 0 {
        count_min_property(v, x, i-1);
    }
}",,"fn m_count_min(v: &Vec<i32>) -> (c: i32)
    requires v.len() > 0
    ensures c == count_min(v@.map_values(|x: i32| x as int), 
                          min(v@.map_values(|x: i32| x as int), v.len() as int), 
                          v.len() as int)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0131,verus,dafnybench,Dafny-Exercises_tmp_tmpjm75muf__Session6Exercises_ExercisePeekSum_mPeekSum,,//Implement and verify an O(v.len()) algorithm to solve this problem,"use vstd::prelude::*;

verus! {

spec fn is_peek(v: &Vec<i32>, i: int) -> bool
    recommends 0 <= i < v.len()
{
    forall|k: int| 0 <= k < i ==> v[i] >= v[k]
}

spec fn peek_sum(v: &Vec<i32>, i: int) -> int
    recommends 0 <= i <= v.len()
    decreases i when 0 <= i <= v.len()
{
    if i == 0 {
        0
    } else {
        if is_peek(v, i - 1) {
            v[i - 1] + peek_sum(v, i - 1)
        } else {
            peek_sum(v, i - 1)
        }
    }
}",,"fn m_peek_sum(v: &Vec<i32>) -> (sum: i32)
    requires v.len() > 0
    ensures sum == peek_sum(v, v.len() as int)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0132,verus,dafnybench,Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBinarySearch_binarySearch,,//Recursive binary search,"use vstd::prelude::*;

verus! {

spec fn sorted(s: Seq<int>) -> bool {
    forall|u: int, w: int| 0 <= u < w < s.len() ==> s[u] <= s[w]
}",,"fn binary_search(v: &Vec<i32>, elem: i32) -> (p: i32)
    requires sorted(v@.map_values(|val: i32| val as int)),
    ensures ({
        &&& -1 <= p < v.len()
        &&& forall|u: int| 0 <= u <= p ==> v@[u] <= elem as int
        &&& forall|w: int| p < w < v.len() ==> v@[w] > elem as int
    }),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0133,verus,dafnybench,Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBinarySearch_binarySearchRec,,"//Recursive binary search

//0<=c<=v.Length && -1<=f<v.Length && c<=f+1","use vstd::prelude::*;

verus! {

spec fn sorted(s: Seq<i32>) -> bool {
    forall|u: int, w: int| 0 <= u < w < s.len() ==> s[u] <= s[w]
}",,"fn binary_search_rec(v: &Vec<i32>, elem: i32, c: usize, f: usize) -> (p: i32)
    requires
        sorted(v@),
        0 <= c <= f + 1 <= v.len(),
        forall|k: int| 0 <= k < c ==> v[k] <= elem,
        forall|k: int| f < k < v.len() ==> v[k] > elem,
    ensures
        -1 <= p < v.len(),
        (forall|u: int| 0 <= u <= p ==> v[u] <= elem) && (forall|w: int| p < w < v.len() ==> v[w] > elem),
    decreases f - c","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0134,verus,dafnybench,Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBinarySearch_otherbSearch,,"// Recursive binary search

// Implement and verify","use vstd::prelude::*;

verus! {

spec fn sorted(s: Seq<i32>) -> bool {
    forall|u: int, w: int| 0 <= u < w < s.len() ==> s[u] <= s[w]
}

fn binary_search(v: &Vec<i32>, elem: i32) -> (p: i32)
    requires sorted(v@),
    ensures -1 <= p < v.len(),
            (forall|u: int| 0 <= u <= p ==> v[u] <= elem),
            (forall|w: int| p < w < v.len() ==> v[w] > elem),
{
    assume(false);
    -1
}",,"fn other_b_search(v: &Vec<i32>, elem: i32) -> (res: (bool, usize))
    requires sorted(v@)
    ensures 
        0 <= res.1 <= v.len(),
        res.0 == v@.contains(elem),
        res.0 ==> res.1 < v.len() && v[res.1 as int] == elem,
        !res.0 ==> forall|u: int| 0 <= u < res.1 ==> v[u] < elem,
        !res.0 ==> forall|w: int| res.1 <= w < v.len() ==> v[w] > elem","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0135,verus,dafnybench,Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBinarySearch_search,,"//Implement by calling binary search function

//Recursive binary search","use vstd::prelude::*;

verus! {

spec fn sorted(s: Seq<int>) -> bool {
    forall|u: int, w: int| 0 <= u < w < s.len() ==> s[u] <= s[w]
}

fn binary_search(v: &[int], elem: int) -> (p: i32)
    requires sorted(v@)
    ensures 
        -1 <= p < v@.len() &&
        (forall|u: int| 0 <= u <= p ==> v@[u] <= elem) &&
        (forall|w: int| p < w < v@.len() ==> v@[w] > elem)
{
    assume(false);
    -1
}",,"fn search(v: &[int], elem: int) -> (b: bool)
    requires sorted(v@)
    ensures b == v@.contains(elem)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0136,verus,dafnybench,Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBubbleSort_bubbleSort,,,"use vstd::prelude::*;

verus! {

spec fn sorted_seg(a: Seq<int>, i: int, j: int) -> bool
    recommends 0 <= i <= j <= a.len()
{
    forall|l: int, k: int| i <= l <= k < j ==> a[l] <= a[k]
}",,"fn bubble_sort(a: &mut Vec<int>, c: usize, f: usize)
    requires 
        0 <= c <= f <= old(a).len(),
    ensures 
        sorted_seg(a@, c as int, f as int),
        a@.subrange(c as int, f as int).to_multiset() == old(a)@.subrange(c as int, f as int).to_multiset(),
        a@.subrange(0, c as int) == old(a)@.subrange(0, c as int),
        a@.subrange(f as int, a@.len() as int) == old(a)@.subrange(f as int, old(a)@.len() as int),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0137,verus,dafnybench,Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBubbleSort_bubbleSorta,,"//j excluded

//f excluded

//when c==f empty sequence","use vstd::prelude::*;

verus! {

spec fn sorted_seg(a: Seq<i32>, i: int, j: int) -> bool
    recommends 0 <= i <= j <= a.len()
{
    forall|l: int, k: int| i <= l <= k < j ==> a[l] <= a[k]
}",,"fn bubbleSorta(a: &mut Vec<i32>, c: usize, f: usize)
    requires 
        c <= f,
        f <= old(a).len(),
    ensures 
        sorted_seg(a@, c as int, f as int),
        a@.subrange(c as int, f as int).to_multiset() == old(a)@.subrange(c as int, f as int).to_multiset(),
        a@.subrange(0, c as int) == old(a)@.subrange(0, c as int),
        a@.subrange(f as int, a.len() as int) == old(a)@.subrange(f as int, old(a).len() as int),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0138,verus,dafnybench,Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseReplace_replace,,,"use vstd::prelude::*;

verus! {",,"fn replace(v: &mut Vec<i32>, x: i32, y: i32)
    ensures
        forall|k: int| 0 <= k < old(v).len() && old(v)[k] == x ==> v[k] == y,
        forall|k: int| 0 <= k < old(v).len() && old(v)[k] != x ==> v[k] == old(v)[k],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0139,verus,dafnybench,Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseSelSort_selSort,,,"use vstd::prelude::*;

verus! {

spec fn sorted_seg(a: Seq<int>, i: int, j: int) -> bool
{
    &&& 0 <= i <= j <= a.len()
    &&& forall|l: int, k: int| i <= l <= k < j ==> a[l] <= a[k]
}",,"fn sel_sort(a: &mut Vec<int>, c: usize, f: usize)
    requires 
        c <= f <= old(a).len(),
    ensures 
        sorted_seg(a@, c as int, f as int),
        a.len() == old(a).len(),
        a@.subrange(c as int, f as int).to_multiset() == old(a)@.subrange(c as int, f as int).to_multiset(),
        a@.subrange(0, c as int) == old(a)@.subrange(0, c as int),
        a@.subrange(f as int, a.len() as int) == old(a)@.subrange(f as int, old(a).len() as int),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0140,verus,dafnybench,Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseSeparate_separate,,"/**
returns an index st new array is a permutation of the old array
positive first and then strictnegative, i is the firs neg or len if not any */","use vstd::prelude::*;

verus! {

spec fn strict_negative(v: &Vec<i32>, i: usize, j: usize) -> bool
    recommends 0 <= i <= j <= v.len()
{
    forall|u: usize| i <= u < j ==> v[u as int] < 0
}

spec fn positive(s: Seq<i32>) -> bool {
    forall|u: int| 0 <= u < s.len() ==> s[u] >= 0
}

spec fn is_permutation(s: Seq<i32>, t: Seq<i32>) -> bool {
    s.to_multiset() == t.to_multiset()
}",,"fn separate(v: &mut Vec<i32>) -> (i: usize)
    ensures
        0 <= i <= v.len(),
        positive(v@.subrange(0, i as int)),
        strict_negative(v, i, v.len()),
        is_permutation(v@, old(v)@),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0141,verus,dafnybench,Dafny-Exercises_tmp_tmpjm75muf__Session8Exercises_ExerciseInsertionSort_InsertionSort,,//Add and prove this,"use vstd::prelude::*;

verus! {

spec fn sorted_seg(a: &Vec<i32>, i: int, j: int) -> bool
    recommends 0 <= i <= j + 1 <= a.len()
{
    forall|l: int, k: int| i <= l <= k <= j ==> a[l] <= a[k]
}",,"fn insertion_sort(a: &mut Vec<i32>)
    ensures 
        sorted_seg(a, 0, (a.len() - 1) as int),
        a@.to_multiset() == old(a)@.to_multiset(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0142,verus,dafnybench,Dafny-Exercises_tmp_tmpjm75muf__Session9Exercises_ExerciseSeqMaxSum_segMaxSum,,,"use vstd::prelude::*;

verus! {

spec fn sum(v: Seq<int>, i: int, j: int) -> int
    recommends 0 <= i <= j <= v.len()
    decreases j when 0 <= i <= j <= v.len()
{
    if i == j {
        0 as int
    } else {
        sum(v, i, (j-1) as int) + v[(j-1) as int]
    }
}

spec fn sum_max_to_right(v: Seq<int>, i: int, s: int) -> bool
    recommends 0 <= i < v.len()
{
    forall|l: int, ss: int| 0 <= l <= i && ss == i + 1 ==> sum(v, l, ss) <= s
}

spec fn sum2(v: Seq<int>, i: int, j: int) -> int
    recommends 0 <= i <= j <= v.len()
    decreases j - i when 0 <= i <= j <= v.len()
{
    if i == j {
        0 as int
    } else {
        v[i as int] + sum2(v, (i+1) as int, j)
    }
}

spec fn sum_max_to_right2(v: Seq<int>, j: int, i: int, s: int) -> bool
    recommends 0 <= j <= i < v.len()
{
    forall|l: int, ss: int| j <= l <= i && ss == i + 1 ==> sum2(v, l, ss) <= s
}",,"fn seg_max_sum(v: &[i32], i: usize) -> (result: (i32, usize))
    requires v.len() > 0 && i < v.len()
    ensures 
        result.1 <= i,
        result.0 == sum(v@.map_values(|x: i32| x as int), result.1 as int, (i+1) as int),
        sum_max_to_right(v@.map_values(|x: i32| x as int), i as int, result.0 as int)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0143,verus,dafnybench,Dafny-Exercises_tmp_tmpjm75muf__Session9Exercises_ExerciseSeqMaxSum_segSumaMaxima2,,"//Now do the same but with a loop from right to left

//maximum sum stuck to the right

//Implement and verify","use vstd::prelude::*;

verus! {

spec fn sum(v: Seq<i32>, i: int, j: int) -> int
    recommends 0 <= i <= j <= v.len()
    decreases j - i when i < j
{
    if i == j {
        0
    } else {
        sum(v, i, (j - 1) as int) + v[(j - 1) as int] as int
    }
}

spec fn sum_max_to_right(v: Seq<i32>, i: int, s: int) -> bool
    recommends 0 <= i < v.len()
{
    forall|l: int, ss: int| 0 <= l <= i && ss == i + 1 ==> sum(v, l, ss) <= s
}

spec fn sum2(v: Seq<i32>, i: int, j: int) -> int
    recommends 0 <= i <= j <= v.len()
    decreases j - i when i < j
{
    if i == j {
        0
    } else {
        v[i] as int + sum2(v, i + 1, j)
    }
}

spec fn sum_max_to_right2(v: Seq<i32>, j: int, i: int, s: int) -> bool
    recommends 0 <= j <= i < v.len()
{
    forall|l: int, ss: int| j <= l <= i && ss == i + 1 ==> sum2(v, l, ss) <= s
}",,"fn seg_suma_maxima2(v: &[i32], i: usize) -> (result: (i32, usize))
    requires v.len() > 0 && i < v.len()
    ensures 
        0 <= result.1 <= i && 
        result.0 as int == sum2(v@, result.1 as int, (i + 1) as int) && 
        sum_max_to_right2(v@, 0, i as int, result.0 as int)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0144,verus,dafnybench,Dafny-Exercises_tmp_tmpjm75muf__Session10Exercises_ExerciseBarrier_barrier,,"//Method barrier below receives an array and an integer p

//and returns a boolean b which is true if and only if 

//all the positions to the left of p and including also position p contain elements 

//that are strictly smaller than all the elements contained in the positions to the right of p 

//Examples:

// If v=[7,2,5,8] and p=0 or p=1 then the method must return false, 

// but for p=2 the method should return true

//1.Specify the method

//2.Implement an O(v.size()) method

//3.Verify the method

//Give the precondition

//Give the postcondition

//{Implement and verify}","use vstd::prelude::*;

verus! {",,"fn barrier(v: &[i32], p: usize) -> (b: bool)
    requires 
        v.len() > 0,
        p < v.len(),
    ensures 
        b == forall|k: usize, l: usize| 
            k <= p && p < l && l < v.len() ==> v[k as int] < v[l as int]","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0145,verus,dafnybench,Dafny-Grind75_tmp_tmpsxfz3i4r_problems_twoSum_twoSum,,,"use vstd::prelude::*;

verus! {

spec fn summing_pair(i: nat, j: nat, nums: Seq<int>, target: int) -> bool
    recommends 
        i < nums.len(),
        j < nums.len(),
{
    i != j && nums[i as int] + nums[j as int] == target
}",,"fn two_sum(nums: Seq<int>, target: int) -> (pair: (usize, usize))
    requires exists|i: nat, j: nat| i < j < nums.len() && summing_pair(i, j, nums, target) && forall|l: nat, m: nat| l < m < nums.len() && l != i && m != j ==> !summing_pair(l, m, nums, target)
    ensures 
        0 <= pair.0 < nums.len() && 
        0 <= pair.1 < nums.len() && 
        summing_pair(pair.0 as nat, pair.1 as nat, nums, target)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0147,verus,dafnybench,Dafny-Practice_tmp_tmphnmt4ovh_BST_InsertBST,,,"use vstd::prelude::*;

verus! {

pub enum Tree {
    Empty,
    Node(int, Box<Tree>, Box<Tree>),
}

spec fn numbers_in_tree(t: Tree) -> Set<int> {
    numbers_in_sequence(inorder(t))
}

spec fn numbers_in_sequence(q: Seq<int>) -> Set<int> {
    Set::new(|x: int| q.contains(x))
}

spec fn bst(t: Tree) -> bool {
    ascending(inorder(t))
}

spec fn inorder(t: Tree) -> Seq<int>
    decreases t
{
    match t {
        Tree::Empty => seq![],
        Tree::Node(n, left, right) => inorder(*left) + seq![n] + inorder(*right)
    }
}

spec fn ascending(q: Seq<int>) -> bool {
    forall|i: int, j: int| 0 <= i < j < q.len() ==> q[i] < q[j]
}

spec fn no_duplicates(q: Seq<int>) -> bool {
    forall|i: int, j: int| 0 <= i < j < q.len() ==> q[i] != q[j]
}",,"fn insert_bst(t0: Tree, x: int) -> (t: Tree)
    requires 
        bst(t0) && !numbers_in_tree(t0).contains(x)
    ensures 
        bst(t) && numbers_in_tree(t) =~= numbers_in_tree(t0).insert(x)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0148,verus,dafnybench,Dafny-Practice_tmp_tmphnmt4ovh_Pattern_Matching_FindAllOccurrences,,,"use vstd::prelude::*;

verus! {",,"fn find_all_occurrences(text: &str, pattern: &str) -> (offsets: Ghost<Set<nat>>)
    ensures 
        forall|i: nat| offsets@.contains(i) ==> i + pattern@.len() <= text@.len(),
        forall|i: nat| 0 <= i && i + pattern@.len() <= text@.len() 
                      ==> (text@.subrange(i as int, (i + pattern@.len()) as int) == pattern@) == offsets@.contains(i)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0149,verus,dafnybench,Dafny-Projects_tmp_tmph399drhy_p2_arraySplit_ArraySplit,,,"use vstd::prelude::*;

verus! {",,"fn array_split(a: Vec<i32>) -> (ret: (Vec<i32>, Vec<i32>))
    ensures
        a@ == ret.0@ + ret.1@,
        a.len() == ret.0.len() + ret.1.len(),
        a.len() > 1 ==> a.len() > ret.0.len(),
        a.len() > 1 ==> a.len() > ret.1.len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0150,verus,dafnybench,Dafny-demo_tmp_tmpkgr_dvdi_Dafny_BinarySearch_BinarySearch,,// Predicate to check if array slice is sorted,"use vstd::prelude::*;

verus! {

spec fn sorted(a: &[int], l: int, u: int) -> bool {
    forall|i: int, j: int| 0 <= l <= i <= j <= u < a.len() ==> a[i] <= a[j]
}",,"fn binary_search(a: &[int], key: int) -> (index: i32)
    requires 
        a.len() > 0,
        sorted(a, 0, (a.len() - 1) as int),
    ensures 
        index >= 0 ==> index < a.len() && a[index as int] == key,
        index < 0 ==> forall|k: int| 0 <= k < a.len() ==> a[k] != key,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0151,verus,dafnybench,Dafny-experiences_tmp_tmp150sm9qy_dafny_started_tutorial_dafny_tutorial_array_FindMax,,"// Annotate this method with pre- and postconditions

// that ensure it behaves as described.","use vstd::prelude::*;

verus! {",,"fn find_max(a: &[i32]) -> (i: usize)

    requires 
        a.len() > 0,
    ensures
        i < a.len(),
        forall|k: int| 0 <= k < a.len() ==> a[k] <= a[i as int],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0152,verus,dafnybench,Dafny-programs_tmp_tmpnso9eu7u_Algorithms___sorting_bubble-sort_BubbleSort,,"/*
Bubble Sort is the simplest sorting algorithm that works by 
repeatedly swapping the adjacent elements if they are in wrong order.
*/

/* Explanation:

invariant forall n, m :: 0 <= n <= i <m <N ==> A [n] <= A [m]
     // A is ordered for each pair of elements such that
     // the first element belongs to the left partition of i
     // and the second element belongs to the right partition of i

invariant forall n :: 0 <= n <= j ==> A [n] <= A [j]
     // There is a variable defined by the value that the array takes at position j
     // Therefore, each value that the array takes for all elements from 0 to j
     // They are less than or equal to the value of the variable
*/","use vstd::prelude::*;

verus! {

spec fn sorted_between(a: Seq<int>, from: int, to: int) -> bool {
    forall|i: int, j: int| 0 <= i <= j < a.len() && from <= i <= j <= to ==> a[i] <= a[j]
}

spec fn sorted(a: Seq<int>) -> bool {
    sorted_between(a, 0, (a.len() - 1) as int)
}",,"fn bubble_sort(a: &mut Vec<int>)
    ensures 
        sorted(a@),
        a@.to_multiset() == old(a)@.to_multiset()","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0154,verus,dafnybench,DafnyPrograms_tmp_tmp74_f9k_c_automaton_ExecuteAutomaton,,"/**
Consider cellular automata: a row of cells is repeatedly updated according to a rule. In this exercise I dabbled with,
each cell has the value either false or true. Each cell's next state depends only on the immediate neighbours, in the 
case where the cell is at the edges of the row, the inexistent neighbours are replaced by ""false"". The automaton table 
will contain the initial row, plus a row for each number of steps.
 */

/**
This method computes the automaton.
Provide the initial row: init, the rule and the desired number of steps
 */

// we need the initial row to have the length bigger or equal to two

// after computation the automaton is made of the initial row plus a row for each of the steps

// the automaton must have the initial row at the top

// all rows in the automaton must be the same length

// TODO: Additional ensures clauses for middle and corner elements would require complex triggers

// Original Dafny clauses commented due to trigger complexity in Verus:

// all the middle row elements (with existing neighbours) after a step, will be equal to the rule applied on the element in the previous state

// and its neigbours

// ensures forall i | 0 <= i < |table| - 1 ::

//           forall j | 1 <= j <= |table[i]| - 2 :: table[i + 1][j] == rule(table[i][j - 1], table[i][j], table[i][j + 1])

// the corner row elements (with non-existing neighbours) after a step, will be equal to the rule applied on the element in the previous state,

// its neighbour and false

// ensures forall i | 0 <= i < |table| - 1 ::

//           table[i + 1][0] == rule(false, table[i][0], table[i][1]) && table[i + 1][|table[i]| - 1] == rule(table[i][|table[i]| - 2], table[i][|table[i]| - 1], false)","use vstd::prelude::*;

verus! {

struct Automaton {}",,"#[verifier::exec_allows_no_decreases_clause]
fn execute_automaton(init: Seq<bool>, rule: spec_fn(bool, bool, bool) -> bool, steps: nat) 
    -> (table: Seq<Seq<bool>>)
    requires 

        init.len() >= 2
    ensures 

        table.len() == 1 + steps,

        table[0] == init,

        forall|i: int| 0 <= i < table.len() ==> #[trigger] table[i].len() == init.len()","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0155,verus,dafnybench,DafnyPrograms_tmp_tmp74_f9k_c_invertarray_InvertArray,,"/**
  Inverts an array of ints.
 */","use vstd::prelude::*;

verus! {",,"fn invert_array(a: &mut Vec<i32>)
    ensures
        a.len() == old(a).len(),
        forall|i: int| 0 <= i < a.len() ==> a[i] == old(a)[a.len() - 1 - i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0158,verus,dafnybench,DafnyPrograms_tmp_tmp74_f9k_c_prime-database_testPrimeness,,"// predicate for primeness

// the class containing a prime database, if a number is prime it returns Yes, if it is not No and if the number

// is not in the database it returns Unknown

// the valid invariant of the class

// the constructor

// lookup n in the database and reply with Yes or No if it's in the database and it is or it is not prime,

// or with Unknown when it's not in the databse

// method to test whether a number is prime, returns bool","use vstd::prelude::*;

verus! {

spec fn prime(n: nat) -> bool {
    n > 1 && (forall|nr: nat| 1 < nr < n ==> #[trigger] (n % nr) != 0)
}

#[derive(PartialEq, Eq)]
enum Answer {
    Yes,
    No,
    Unknown,
}

struct PrimeMap {
    database: Ghost<Map<nat, bool>>,
}

impl PrimeMap {

    spec fn valid(&self) -> bool {
        forall|i: nat| self.database@.dom().contains(i) ==> (self.database@[i] == prime(i))
    }

    fn new() -> (result: PrimeMap)
        ensures 
            result.database@ === Map::empty(),
            result.valid(),
    {
        PrimeMap {
            database: Ghost(Map::empty())
        }
    }

    fn is_prime(&self, n: nat) -> (answer: Answer)
        requires self.valid(),
        ensures 
            self.database@.dom().contains(n) && prime(n) <==> answer == Answer::Yes,
            self.database@.dom().contains(n) && !prime(n) <==> answer == Answer::No,
            !self.database@.dom().contains(n) <==> answer == Answer::Unknown,
    {
        assume(false);
        Answer::Unknown
    }

}",,"fn test_primeness(n: nat) -> (result: bool) 
      requires n >= 0,
      ensures result <==> prime(n),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0159,verus,dafnybench,DafnyProjects_tmp_tmp2acw_s4s_CombNK_Comb,,"/* 
 * Formal specification and verification of a dynamic programming algorithm for calculating C(n, k).
 * FEUP, MIEIC, MFES, 2020/21.
 */

// Initial recursive definition of C(n, k), based on the Pascal equality.","use vstd::prelude::*;

verus! {

spec fn comb(n: nat, k: nat) -> nat
    recommends 0 <= k <= n
    decreases n
    when n >= 1 && k >= 1
{
    if k == 0 || k == n { 
        1 
    } else { 
        comb((n - 1) as nat, k) + comb((n - 1) as nat, (k - 1) as nat)
    }
}",,"fn Comb(n: u64, k: u64) -> (res: u64)
    requires 0 <= k <= n
    ensures res == comb(n as nat, k as nat)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0164,verus,dafnybench,DafnyProjects_tmp_tmp2acw_s4s_Power_powerDC,,"/* 
* Formal verification of an O(log n) algorithm to calculate the natural power of an integer (x^n), 
* illustrating the usage of lemmas and automatic induction in Verus.
* Translated from Dafny to Verus.
*/

// Recursive definition of x^n in functional style, with time and space complexity O(n).

// Computation of x^n in time and space O(log n).

// A few test cases would go here","use vstd::prelude::*;

verus! {

spec fn power(x: int, n: nat) -> int
    decreases n
{
    if n == 0 { 1 } else { x * power(x, (n - 1) as nat) }
}",,"fn power_dc(x: i64, n: u64) -> (p: i64)
    ensures p == power(x as int, n as nat)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0167,verus,dafnybench,DafnyProjects_tmp_tmp2acw_s4s_longestPrefix_longestPrefix,,"// MFES, Exam 8/Sept/20201, Exercise 5 

// Computes the length (i) of the longest common prefix (initial subarray) 

// of two arrays a and b.

// Test method with an example.","use vstd::prelude::*;

verus! {",,"fn longest_prefix(a: &[i32], b: &[i32]) -> (i: usize)
    ensures 
        i <= a.len() && i <= b.len(),
        a@.subrange(0, i as int) == b@.subrange(0, i as int),
        i < a.len() && i < b.len() ==> a[i as int] != b[i as int]","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0168,verus,dafnybench,DafnyProjects_tmp_tmp2acw_s4s_partitionOddEven_partitionOddEven,,"// Rearranges the elements in an array 'a' of natural numbers,

// so that all odd numbers appear before all even numbers.","use vstd::prelude::*;

verus! {

spec fn odd(n: nat) -> bool { n % 2 == 1 }
spec fn even(n: nat) -> bool { n % 2 == 0 }",,"fn partitionOddEven(a: &mut Vec<nat>)
    ensures 
        a@.to_multiset() == old(a)@.to_multiset(),
        !(exists|i: int, j: int| 0 <= i < j < a@.len() && even(a@[i]) && odd(a@[j])),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0170,verus,dafnybench,Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_A2_Q1_trimmed_copy_-_副本_ComputeCount,,,"use vstd::prelude::*;

verus! {

spec fn count(hi: nat, s: Seq<int>) -> int
    recommends 0 <= hi <= s.len()
    decreases hi
{
    if hi == 0 {
        0
    } else if s[hi-1] % 2 == 0 {
        1 + count((hi-1) as nat, s)
    } else {
        count((hi-1) as nat, s)
    }
}",,"fn compute_count(count_index: usize, a: Seq<int>, b: &mut Vec<int>) -> (p: usize)
    requires count_index == 0 || (a.len() == old(b).len() && 1 <= count_index <= a.len())
    ensures p == count(count_index as nat, a)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0172,verus,dafnybench,Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_A2_Q1_trimmed_copy_-_副本_FooCount,,,"use vstd::prelude::*;

verus! {

spec fn count(hi: nat, s: Seq<int>) -> int
    recommends 0 <= hi <= s.len()
    decreases hi
{
    if hi == 0 {
        0
    } else if s[hi - 1] % 2 == 0 {
        1 + count((hi - 1) as nat, s)
    } else {
        count((hi - 1) as nat, s)
    }
}",,"fn foo_count(count_index: usize, a: &Vec<int>, b: &mut Vec<int>) -> (p: usize)
    requires 
        count_index == 0 || (a.len() == old(b).len() && 1 <= count_index <= a.len()),
    ensures 
        p == count(count_index as nat, a@),
    decreases count_index","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0175,verus,dafnybench,Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_A2_Q1_trimmed_copy_-_副本_PreCompute,,,"use vstd::prelude::*;

verus! {

spec fn count(hi: nat, s: Seq<i32>) -> int
    decreases hi
{
    if hi == 0 {
        0
    } else if s[hi - 1] % 2 == 0 {
        1 + count((hi - 1) as nat, s)
    } else {
        count((hi - 1) as nat, s)
    }
}

fn compute_count(count_index: usize, a: &Vec<i32>, b: &mut Vec<i32>) -> (p: usize)
    requires 
        count_index == 0 || (a.len() == old(b).len() && 1 <= count_index <= a.len()),
    ensures 
        p == count(count_index as nat, a@),
{
  assume(false);
  0
}",,"fn pre_compute(a: &Vec<i32>, b: &mut Vec<i32>) -> (p: usize)
    requires 
        a.len() == old(b).len(),
    ensures 
        (b.len() == 0 || (a.len() == b.len() && 1 <= b.len() <= a.len())) &&
        p == count(b.len() as nat, a@),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0178,verus,dafnybench,Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_week5_ComputePower_ComputePower,,,"use vstd::prelude::*;

verus! {

spec fn power(n: nat) -> nat 
    decreases n
{
    if n == 0 { 1 } else { 2 * power((n - 1) as nat) }
}

fn calc_power(n: u32) -> (p: u32)
    ensures p == 2 * n
{
  assume(false);
  0
}",,"fn compute_power(n: u32) -> (p: u32)
    ensures p == power(n as nat)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0187,verus,dafnybench,Dafny_Learning_Experience_tmp_tmpuxvcet_u_week8_12_a3_search_findPositionOfIndex_FindPositionOfElement,,,"use vstd::prelude::*;

verus! {",,"fn find_position_of_element(a: &[i32], element: usize, n1: usize, s1: Seq<i32>) -> (result: (i32, usize))
    requires
        n1 == s1.len() && 0 <= n1 <= a.len(),
        forall|i: int| 0 <= i < s1.len() ==> a[i] == s1[i],
    ensures
        result.0 == -1 || result.0 >= 1,
        s1.len() != 0 && result.0 >= 1 ==> exists|i: int| 0 <= i < s1.len() && s1[i] == element,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0197,verus,dafnybench,Dafny_ProgrammingLanguages_tmp_tmp82_e0kji_ExtraCredit_optimizeCorrect,,"//fill this function in to make optimizeFeatures work

//as you write optimize this will become unproved

//you must write proof code so that Verus can prove this","use vstd::prelude::*;

verus! {

#[derive(PartialEq, Eq)]
enum Exp {
    Const(int),
    Var(String),
    Plus(Box<Exp>, Box<Exp>),
    Mult(Box<Exp>, Box<Exp>),
}

spec fn eval(e: Exp, store: Map<String, int>) -> int
    decreases e
{
    match e {
        Exp::Const(n) => n,
        Exp::Var(s) => if store.dom().contains(s) { store[s] } else { -1 },
        Exp::Plus(e1, e2) => eval(*e1, store) + eval(*e2, store),
        Exp::Mult(e1, e2) => eval(*e1, store) * eval(*e2, store),
    }
}

spec fn optimize(e: Exp) -> Exp
    decreases e
{
    match e {
        Exp::Mult(e1, e2) => {
            match (*e1, *e2) {
                (Exp::Const(n1), _) if n1 == 0 => Exp::Const(0),
                (_, Exp::Const(n2)) if n2 == 0 => Exp::Const(0),
                (Exp::Const(n1), e2_inner) if n1 == 1 => e2_inner,
                (e1_inner, Exp::Const(n2)) if n2 == 1 => e1_inner,
                (Exp::Const(n1), Exp::Const(n2)) => Exp::Const(n1 * n2),
                _ => e,
            }
        },
        Exp::Plus(e1, e2) => {
            match (*e1, *e2) {
                (Exp::Const(n1), e2_inner) if n1 == 0 => e2_inner,
                (e1_inner, Exp::Const(n2)) if n2 == 0 => e1_inner,
                (Exp::Const(n1), Exp::Const(n2)) => Exp::Const(n1 + n2),
                _ => e,
            }
        },
        _ => e,
    }
}",,"fn optimize_correct(e: Exp, s: Map<String, int>)
    ensures eval(e, s) == eval(optimize(e), s)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0198,verus,dafnybench,Dafny_Programs_tmp_tmp99966ew4_binary_search_BinarySearch,,,"use vstd::prelude::*;

verus! {

spec fn sorted(a: &[int]) -> bool {
    forall|j: int, k: int| 0 <= j < k < a.len() ==> a[j] <= a[k]
}",,"fn binary_search(a: &[int], value: int) -> (index: i32)
    requires 
        sorted(a),
    ensures 
        0 <= index ==> index < a.len() && a[index as int] == value,
        index < 0 ==> forall|k: int| 0 <= k < a.len() ==> a[k] != value,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0199,verus,dafnybench,Dafny_Programs_tmp_tmp99966ew4_lemma_FindZero,,,"use vstd::prelude::*;

verus! {",,"fn find_zero(a: &[i32]) -> (index: i32)
    requires
        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i] >= 0,
        forall|i: int| 0 < i < a.len() ==> #[trigger] a[i-1] - 1 <= a[i],
    ensures
        (index < 0 ==> forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i] != 0),
        (0 <= index ==> index < a.len() && a[index as int] == 0),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0223,verus,dafnybench,Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_normal_data_completion_MaxPerdV2_max,,,"use vstd::prelude::*;

verus! {

spec fn contains(v: i32, a: Seq<i32>, n: int) -> bool {
    exists|j: int| 0 <= j < n && a[j] == v
}

spec fn upper_bound(v: i32, a: Seq<i32>, n: int) -> bool {
    forall|j: int| 0 <= j < n ==> a[j] <= v
}

spec fn is_max(m: i32, a: Seq<i32>, n: int) -> bool {
    contains(m, a, n) && upper_bound(m, a, n)
}",,"fn max(a: &[i32], n: usize) -> (result: i32)
    requires 0 < n <= a.len(),
    ensures is_max(result, a@, n as int)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0225,verus,dafnybench,Dafny_Verify_tmp_tmphq7j0row_Generated_Code_ComputePower_ComputePower,,// practical bound to prevent overflow,"use vstd::prelude::*;

verus! {

spec fn power(n: nat) -> nat
    decreases n
{
    if n == 0 { 1 } else { 2 * power((n - 1) as nat) }
}",,"fn compute_power(n: u32) -> (p: u32)
    requires n < 32,
    ensures p == power(n as nat),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0226,verus,dafnybench,Dafny_Verify_tmp_tmphq7j0row_Generated_Code_Count_count,,,"use vstd::prelude::*;

verus! {

spec fn has_count(v: int, a: Seq<int>, n: nat) -> int
    decreases n
{
    if n == 0 {
        0
    } else {
        if a[n-1] == v {
            has_count(v, a, (n-1) as nat) + 1
        } else {
            has_count(v, a, (n-1) as nat)
        }
    }
}",,"fn count(v: i32, a: &[i32], n: usize) -> (r: i32)
    requires n <= a.len()
    ensures n <= a.len() ==> has_count(v as int, a@.map_values(|x: i32| x as int), n as nat) == r as int","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0235,verus,dafnybench,Dafny_Verify_tmp_tmphq7j0row_dataset_bql_exampls_SmallNum_add_small_numbers,,,"use vstd::prelude::*;

verus! {",,"fn add_small_numbers(a: &[i32], n: usize, max: i32) -> (r: i32)
    requires 
        n > 0,
        n <= a.len(),
        forall|i: int| 0 <= i && i < n ==> a[i] <= max,
    ensures
        r <= max * (n as i32),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0237,verus,dafnybench,Dafny_Verify_tmp_tmphq7j0row_dataset_detailed_examples_SelectionSort_SelectionSort,,"// Works by dividing the input list into two parts: sorted and unsorted. At the beginning, 

// the sorted part is empty and the unsorted part contains all the elements.

// Ensures the final array is sorted in ascending order

// Ensures that the final array has the same elements as the initial array","use vstd::prelude::*;

verus! {",,"fn selection_sort(a: &mut Vec<i32>)
    ensures

        forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j],

        a@.to_multiset() == old(a)@.to_multiset(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0239,verus,dafnybench,Dafny_tmp_tmp0wu8wmfr_Heimaverkefni_1_LinearSearch_SearchLoop,,"// Author of question: Snorri Agnarsson

// Permalink of question: https://rise4fun.com/Dafny/0HRr

// Author of solution:    Alexander Guðmundsson

// Permalink of solution: https://rise4fun.com/Dafny/8pxWd

// Use the command

//   verus LinearSearch-skeleton.rs

// to verify the file.

// When you have solved the problem put

// the solution on the Verus web page,

// generate a permalink and put it in

// this file.","use vstd::prelude::*;

verus! {",,"fn search_loop(a: &Vec<i32>, i: usize, j: usize, x: i32) -> (k: i32)
    requires 
        i <= j <= a.len(),
    ensures 
        (i <= k < j) || k == -1,
        k != -1 ==> 0 <= k < a.len() && a[k as int] == x,
        k != -1 ==> forall|r: int| k < r < j && 0 <= r < a.len() ==> a[r] != x,
        k == -1 ==> forall|r: int| (i as int) <= r < (j as int) && 0 <= r < a.len() ==> a[r] != x,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0240,verus,dafnybench,Dafny_tmp_tmp0wu8wmfr_Heimaverkefni_1_LinearSearch_SearchRecursive,,"// Author of question: Snorri Agnarsson

// Permalink of question: https://rise4fun.com/Dafny/0HRr

// Author of solution:    Alexander Guðmundsson

// Permalink of solution: https://rise4fun.com/Dafny/8pxWd

// Use the command

//   verus LinearSearch-skeleton.rs

// to compile the file.

// When you have solved the problem put

// the solution on the Verus web page,

// generate a permalink and put it in

// this file.","use vstd::prelude::*;

verus! {",,"fn search_recursive(a: Seq<int>, i: usize, j: usize, x: int) -> (result: isize)
    requires 
        i <= j,
        j <= a.len(),
    ensures
        (i <= result && result < j as isize) || result == -1,
        result != -1 ==> a[result as int] == x,
        result != -1 ==> forall|r: int| result < r && r < j as int ==> a[r] != x,
        result == -1 ==> forall|r: int| i as int <= r && r < j as int ==> a[r] != x,
    decreases j - i,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0242,verus,dafnybench,Dafny_tmp_tmp0wu8wmfr_Heimaverkefni_2_BinarySearchDec_SearchRecursive,,"// Author of question: Snorri Agnarsson

// Permalink of question: https://rise4fun.com/Dafny/CGB1z

// Authors of solution:   Alexander Guðmundsson

// Permalink of solution: https://rise4fun.com/Dafny/VnB5

// Use the command

//   verus H2-skeleton.rs

// to compile the file.

// When you have solved the problem put

// the solution on the Verus web page,

// generate a permalink and put it in

// this file.

// Ef eftirfarandi fall er ekki samþykkt þá eru

// föllin ekki að haga sér rétt að mati Verus.","use vstd::prelude::*;

verus! {",,"fn search_recursive(a: Seq<int>, i: int, j: int, x: int) -> (k: int)
    requires 
        0 <= i <= j <= a.len(),
        forall|p: int, q: int| i <= p < q < j ==> a[p] >= a[q],
    ensures 
        i <= k <= j,
        forall|r: int| i <= r < k ==> a[r] >= x,
        forall|r: int| k <= r < j ==> a[r] < x,
    decreases j - i","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0243,verus,dafnybench,Dafny_tmp_tmp0wu8wmfr_Heimaverkefni_3_InsertionSortMultiset_Search,,"// Höfundur spurningar:  Snorri Agnarsson, snorri@hi.is

// Permalink spurningar: https://rise4fun.com/Dafny/G4sc3

// Höfundur lausnar:     Alexander Guðmundsson

// Permalink lausnar:    https://rise4fun.com/Dafny/nujsu

// Insertion sort með hjálp helmingunarleitar.

// Ekki má breyta forskilyrðum eða eftirskilyrðum fallsins","use vstd::prelude::*;

verus! {",,"fn search(s: Seq<int>, x: int) -> (k: usize)

    requires 
        forall|p: int, q: int| 0 <= p < q < s.len() ==> s[p] <= s[q],
    ensures 
        0 <= k <= s.len(),
        forall|i: int| 0 <= i < k ==> s[i] <= x,
        forall|i: int| k <= i < s.len() ==> s[i] >= x,
        forall|z: int| s.subrange(0, k as int).contains(z) ==> z <= x,
        forall|z: int| s.subrange(k as int, s.len() as int).contains(z) ==> z >= x,
        s == s.subrange(0, k as int).add(s.subrange(k as int, s.len() as int)),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0244,verus,dafnybench,Dafny_tmp_tmp0wu8wmfr_Heimaverkefni_3_InsertionSortMultiset_Sort,,"// Höfundur spurningar:  Snorri Agnarsson, snorri@hi.is

// Permalink spurningar: https://rise4fun.com/Dafny/G4sc3

// Höfundur lausnar:     Alexander Guðmundsson

// Permalink lausnar:    https://rise4fun.com/Dafny/nujsu

// Insertion sort með hjálp helmingunarleitar.

// Ekki má breyta forskilyrðum eða eftirskilyrðum fallsins","use vstd::prelude::*;
use vstd::multiset::*;

verus! {

proof fn search(s: Seq<i32>, x: i32) -> (k: usize)

    requires 
        forall|p: int, q: int| 0 <= p < q < s.len() ==> s[p] <= s[q],
    ensures 
        0 <= k <= s.len()
        && forall|i: int| 0 <= i < k ==> s[i] <= x
        && forall|i: int| k <= i < s.len() ==> s[i] >= x
        && forall|z: i32| s.subrange(0, k as int).contains(z) ==> z <= x
        && forall|z: i32| s.subrange(k as int, s.len() as int).contains(z) ==> z >= x
        && s == s.subrange(0, k as int) + s.subrange(k as int, s.len() as int),
{
  assume(false);
  0
}",,"fn sort(m: Multiset<i32>) -> (r: Seq<i32>)
    ensures 
        r.to_multiset() == m
        && forall|p: int, q: int| 0 <= p < q < r.len() ==> r[p] <= r[q],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0246,verus,dafnybench,Dafny_tmp_tmp0wu8wmfr_Heimaverkefni_3_SelectionSortMultiset_Sort,,"// Höfundur spurningar:  Snorri Agnarsson, snorri@hi.is

// Permalink spurningar: https://rise4fun.com/Dafny/dtcnY

// Höfundur lausnar:     Alexander Guðmundsson

// Permalink lausnar:    https://rise4fun.com/Dafny/ybUCz

///////////////////////////////////////////////////////////////

// Hér byrjar óbreytanlegi hluti skrárinnar.

// Fyrir aftan þann hluta er sá hluti sem þið eigið að breyta.

///////////////////////////////////////////////////////////////

// Hjálparfall sem finnur minnsta gildi í poka

// Ekki má breyta þessu falli.

///////////////////////////////////////////////////////////////

// Hér lýkur óbreytanlega hluta skrárinnar.

// Hér fyrir aftan er sá hluti sem þið eigið að breyta til að

// útfæra afbrigði af selection sort.

///////////////////////////////////////////////////////////////

// Selection sort sem raðar poka í runu.

// Klárið að forrita þetta fall.

// Setjið viðeigandi ensures klausur hér","use vstd::prelude::*;
use vstd::multiset::*;

verus! {

proof fn min_of_multiset(m: Multiset<int>) -> (min: int)
    requires 
        m.len() > 0,
    ensures 
        m.count(min) > 0,
        forall|z: int| m.count(z) > 0 ==> min <= z,
{
    assume(false);
    arbitrary()
}",,"exec fn sort(m: Multiset<int>) -> (s: Vec<int>)

    ensures 
        s@.to_multiset() == m,
        forall|p: int, q: int| 0 <= p < q < s.len() ==> s[p] <= s[q],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0247,verus,dafnybench,Dafny_tmp_tmp0wu8wmfr_Heimaverkefni_8_H8_Partition,,"// Höfundur spurningar:  Snorri Agnarsson, snorri@hi.is

// Permalink spurningar: https://rise4fun.com/Dafny/GW7a

// Höfundur lausnar:     Alexander Guðmundsson

// Permalink lausnar:    https://www.rise4fun.com/Dafny/JPGct

// Klárið að forrita föllin tvö.","use vstd::prelude::*;
use vstd::multiset::Multiset;

verus! {",,"fn partition(Ghost(m): Ghost<Multiset<int>>) -> (res: (Ghost<Multiset<int>>, Ghost<int>, Ghost<Multiset<int>>))
    requires m.len() > 0
    ensures 
        ({
            let (Ghost(pre), Ghost(p), Ghost(post)) = res;
            &&& m.contains(p)
            &&& m == pre.add(Multiset::singleton(p)).add(post)
            &&& forall|z: int| pre.contains(z) ==> z <= p
            &&& forall|z: int| post.contains(z) ==> z >= p
        })","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0250,verus,dafnybench,Dafny_tmp_tmp0wu8wmfr_tests_F1a_Mid,,"// | ... | ??? | ... |

//        p m   q","use vstd::prelude::*;

verus! {",,"fn mid(p: int, q: int) -> (m: int)

    requires 
        p <= q,
    ensures 
        p <= m <= q,
        m - p <= q - m,
        0 <= (q - m) - (m - p) <= 1,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0251,verus,dafnybench,Dafny_tmp_tmp0wu8wmfr_tests_InsertionSortSeq_InsertionSort,,"// Insertion sort.

//

// Author: Snorri Agnarsson, snorri@hi.is","use vstd::prelude::*;

verus! {

spec fn is_sorted(s: Seq<int>) -> bool {
    forall|p: int, q: int| 0 <= p < q < s.len() ==> s[p] <= s[q]
}",,"fn insertion_sort(s: Seq<int>) -> (r: Seq<int>)
    ensures
        s.to_multiset() == r.to_multiset(),
        is_sorted(r),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0252,verus,dafnybench,Dafny_tmp_tmp0wu8wmfr_tests_Search1000_Search2PowLoop,,"// Author: Snorri Agnarsson, snorri@hi.is

// Search1000 is a Verus version of a function shown

// by Jon Bentley in his old Programming Pearls

// column in CACM.  

// Is2Pow(n) is true iff n==2^k for some k>=0.

// This method is a binary search that only works for array

// segments of size n == 2^k-1 for some k>=0.

// This method is a binary search that only works for array

// segments of size n == 2^k-1 for some k>=0.","use vstd::prelude::*;

verus! {

spec fn is_2_pow(n: int) -> bool
    decreases n
{
    if n < 1 {
        false
    } else if n == 1 {
        true
    } else {
        n % 2 == 0 && is_2_pow(n / 2)
    }
}",,"fn search_2_pow_loop(a: &[i32], i: usize, n: usize, x: i32) -> (k: usize)
    requires
        i <= i + n <= a.len(),
        forall|p: int, q: int| i <= p < q < (i + n) && 0 <= p < a.len() && 0 <= q < a.len() ==> 
            a@[p] <= a@[q],
        is_2_pow((n + 1) as int),
    ensures
        i <= k <= i + n,
        forall|r: int| i <= r < k && 0 <= r < a.len() ==> a@[r] < x,
        forall|r: int| k <= r < (i + n) && 0 <= r < a.len() ==> a@[r] >= x,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVD04,0.85
VD0253,verus,dafnybench,Dafny_tmp_tmp0wu8wmfr_tests_Search1000_Search2PowRecursive,,"// Author: Snorri Agnarsson, snorri@hi.is

// Search1000 is a Dafny version of a function shown

// by Jon Bentley in his old Programming Pearls

// column in CACM.  Surprisingly Dafny needs no help

// to verify the function.

// Is2Pow(n) is true iff n==2^k for some k>=0.

// This method is a binary search that only works for array

// segments of size n == 2^k-1 for some k>=0.

// This method is a binary search that only works for array

// segments of size n == 2^k-1 for some k>=0.","use vstd::prelude::*;

verus! {

spec fn is_2_pow(n: int) -> bool
    decreases n
{
    if n < 1 {
        false
    } else if n == 1 {
        true
    } else {
        n % 2 == 0 && is_2_pow(n / 2)
    }
}",,"fn search_2_pow_recursive(a: &[i32], i: usize, n: usize, x: i32) -> (k: usize)
    requires
        i + n <= a.len(),
        ({(forall|p: int, q: int|
            0 <= p < q && i as int <= p && q < (i + n) as int ==> 
            a[p] <= a[q])}),
        is_2_pow((n + 1) as int),
    ensures
        i <= k <= i + n,
        ({(forall|r: int|
            0 <= r && i as int <= r < k as int ==> 
            a[r] < x)}),
        ({(forall|r: int|
            0 <= r && k as int <= r < (i + n) as int ==> 
            a[r] >= x)}),
    decreases n","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVD04,0.85
VD0254,verus,dafnybench,Dafny_tmp_tmp0wu8wmfr_tests_Search1000_Search1000,,"// Author: Snorri Agnarsson, snorri@hi.is

// Search1000 is a Verus version of a function shown

// by Jon Bentley in his old Programming Pearls

// column in CACM.  Surprisingly Verus needs no help

// to verify the function.

// Is2Pow(n) is true iff n==2^k for some k>=0.

// This method is a binary search that only works for array

// segments of size n == 2^k-1 for some k>=0.

// This method is a binary search that only works for array

// segments of size n == 2^k-1 for some k>=0.","use vstd::prelude::*;

verus! {

spec fn is_2_pow(n: int) -> bool
    decreases n
{
    if n < 1 {
        false
    } else if n == 1 {
        true
    } else {
        n % 2 == 0 && is_2_pow(n / 2)
    }
}",,"fn search_1000(a: &[i32], x: i32) -> (k: usize)
    requires 
        a.len() >= 1000,
        forall|p: int, q: int| 0 <= p < q < 1000 ==> a[p] <= a[q],
    ensures 
        0 <= k <= 1000,
        forall|r: int| 0 <= r < k ==> a[r] < x,
        forall|r: int| k <= r < 1000 ==> a[r] >= x,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0255,verus,dafnybench,Dafny_tmp_tmp0wu8wmfr_tests_SumIntsLoop_SumIntsLoop,,,"use vstd::prelude::*;

verus! {

spec fn sum_ints(n: int) -> int
    decreases n when n >= 0
{
    if n <= 0 {
        0
    } else {
        sum_ints(n - 1) + n
    }
}",,"fn sum_ints_loop(n: u32) -> (s: u32)
    ensures 
        s == sum_ints(n as int),
        s == n * (n + 1) / 2","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0256,verus,dafnybench,Dafny_tmp_tmpj88zq5zt_2-Kontrakte_max_max,,,"use vstd::prelude::*;

verus! {",,"fn max(a: &[i32], b: &[i32], i: usize, j: usize) -> (m: i32)
    requires 
        i < a.len(),
        j < b.len(),
    ensures 
        a[i as int] > b[j as int] ==> m == a[i as int],
        a[i as int] <= b[j as int] ==> m == b[j as int],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0257,verus,dafnybench,Dafny_tmp_tmpj88zq5zt_2-Kontrakte_reverse3_swap3,,,"use vstd::prelude::*;

verus! {",,"fn swap3(a: &mut Vec<i32>, h: usize, i: usize, j: usize)
    requires 
        h < old(a).len(),
        i < old(a).len(),
        j < old(a).len(),
        i != j && j != h && h != i,
    ensures
        a[h as int] == old(a)[i as int],
        a[j as int] == old(a)[h as int],
        a[i as int] == old(a)[j as int],
        forall|k: int| 0 <= k < old(a).len() && k != h as int && k != i as int && k != j as int ==> a[k] == old(a)[k],
        a.len() == old(a).len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0262,verus,dafnybench,Dafny_tmp_tmpmvs2dmry_examples2_Product,,,"use vstd::prelude::*;

verus! {

spec fn gcd(m: nat, n: nat) -> nat
recommends m > 0 && n > 0
decreases m + n
{
    if m == n { 
        n 
    } else if m > n { 
        gcd(sub(m, n), n)
    } else {
        gcd(m, sub(n, m))
    }
}",,"fn Product(m: u64, n: u64) -> (res: u64)
ensures res == m * n","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0264,verus,dafnybench,Dafny_tmp_tmpmvs2dmry_examples2_exp_by_sqr,,"// Simplified to avoid termination proof complexity

// Simplified to avoid termination proof complexity","use vstd::prelude::*;

verus! {

spec fn gcd(m: nat, n: nat) -> nat
recommends m > 0 && n > 0
decreases m + n
{
    if m == n { 
        n 
    } else if m > n { 

        if m > n { gcd(1, n) } else { n }
    } else { 

        if n > m { gcd(m, 1) } else { m }
    }
}

spec fn exp(x: int, n: nat) -> int
decreases n
{
    if n == 0 { 
        1 
    } else if x == 0 { 
        0 
    } else if n == 0 && x == 0 { 
        1 
    } else { 
        x * exp(x, sub(n, 1)) 
    }
}",,"fn exp_by_sqr(x0: u32, n0: u32) -> (r: u32)
    requires x0 >= 0
    ensures r == exp(x0 as int, n0 as nat)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0265,verus,dafnybench,Dafny_tmp_tmpmvs2dmry_examples2_gcdCalc,,,"use vstd::prelude::*;

verus! {

spec fn gcd(m: nat, n: nat) -> nat
    recommends m > 0 && n > 0
    decreases m + n
    when m > 0 && n > 0
{
    if m == n {
        n
    } else if m > n {
        gcd(sub(m, n), n)
    } else {
        gcd(m, sub(n, m))
    }
}

spec fn exp_nat(base: nat, n: nat) -> nat
    decreases n
{
    if n == 0 {
        1nat
    } else if base == 0 {
        0nat
    } else {
        base * exp_nat(base, sub(n, 1))
    }
}",,"fn gcd_calc(m: u32, n: u32) -> (res: u32)
    requires m > 0 && n > 0
    ensures res == gcd(m as nat, n as nat)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0266,verus,dafnybench,Dafny_tmp_tmpmvs2dmry_pancakesort_findmax_findMax,,// returns an index of the largest element of array 'a' in the range [0..n),"use vstd::prelude::*;

verus! {",,"fn findMax(a: &[i32], n: usize) -> (r: usize)
    requires
        a.len() > 0,
        0 < n <= a.len(),
    ensures
        0 <= r < n <= a.len(),
        forall|k: usize| 0 <= k < n <= a.len() ==> a[r as int] >= a[k as int],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0267,verus,dafnybench,Dafny_tmp_tmpmvs2dmry_pancakesort_flip_flip,,"// flips (i.e., reverses) array elements in the range [0..num]

// forall k :: num < k < a.Length ==> a[k] == old(a[k])","use vstd::prelude::*;

verus! {",,"fn flip(a: &mut Vec<i32>, num: usize)
    requires 
        old(a).len() > 0,
        num < old(a).len(),
    ensures
        forall|k: int| 0 <= k <= num as int ==> #[trigger] a[k] == old(a)[num as int - k],

        a.len() == old(a).len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0268,verus,dafnybench,Dafny_tmp_tmpv_d3qi10_2_min_minArray,,,"use vstd::prelude::*;

verus! {

spec fn min(a: int, b: int) -> int 
{
    if a < b { a } else { b }
}

spec fn min_function(a: int, b: int) -> int 
{
    if a < b { a } else { b }
}",,"fn min_array(a: &Vec<i32>) -> (m: i32)
    requires a.len() > 0
    ensures 
        forall|k: int| 0 <= k < a.len() ==> m <= a[k],
        exists|k: int| 0 <= k < a.len() && m == a[k]","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0270,verus,dafnybench,Dafny_tmp_tmpv_d3qi10_3_cumsum_cumsum,,,"use vstd::prelude::*;

verus! {

spec fn sum(a: Seq<i32>, i: int) -> int
    recommends 
        0 <= i < a.len(),
    decreases i
{
    if 0 <= i < a.len() {
        a[i] as int + if i == 0 { 0 } else { sum(a, i - 1) }
    } else {
        0
    }
}",,"fn cumsum(a: &[i32], b: &mut [i32])
    requires 
        a.len() == old(b).len(),
        a.len() > 0,
    ensures 
        forall|i: int| 0 <= i < a.len() ==> b[i] as int == sum(a@, i),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0271,verus,dafnybench,Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Exercise3_Increment_Array_incrementArray,,,"use vstd::prelude::*;

verus! {",,"fn increment_array(a: &mut Vec<i32>)
  requires old(a).len() > 0,
  ensures 
      a.len() == old(a).len(),
      forall|i: int| 0 <= i < a.len() ==> a[i] == old(a)[i] + 1,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0274,verus,dafnybench,Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Insertion_Sort_Normal_insertionSort,,// placeholder return,"use vstd::prelude::*;

verus! {

spec fn sorted(a: &Vec<i32>) -> bool {
    forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j]
}

spec fn sorted_range(a: &Vec<i32>, end: int) -> bool {
    forall|i: int, j: int| 0 <= i < j < end ==> a[i] <= a[j]
}

fn look_for_min(a: &Vec<i32>, i: usize) -> (m: usize)
    requires 
        0 <= i < a.len()
    ensures 
        i <= m < a.len(),
        forall|k: int| i <= k < a.len() ==> a[k as int] >= a[m as int]
{
    assume(false);
    i
}",,"fn insertion_sort(a: &mut Vec<i32>)
    ensures sorted(a)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0275,verus,dafnybench,Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Insertion_Sort_Normal_lookForMin,,,"use vstd::prelude::*;

verus! {

spec fn sorted(a: &[int]) -> bool {
    sorted_a(a, a.len() as int)
}

spec fn sorted_a(a: &[int], i: int) -> bool {
    0 <= i <= a.len() && 
    forall|k: int| #![trigger a[k]] 0 < k < i ==> a[(k-1) as int] <= a[k]
}",,"fn look_for_min(a: &[int], i: usize) -> (m: usize)
    requires 
        0 <= i < a.len(),
    ensures
        i <= m < a.len(),
        forall|k: int| #![trigger a[k]] i <= k < a.len() ==> a[k] >= a[m as int],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0276,verus,dafnybench,Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Insertion_Sorted_Standard_sorting,,,"use vstd::prelude::*;

verus! {

spec fn insertion_sorted(array: Seq<int>, left: int, right: int) -> bool
    recommends 0 <= left <= right <= array.len()
{
    forall|i: int, j: int| left <= i < j < right ==> array[i] <= array[j]
}",,"fn sorting(array: &mut Vec<int>)
    requires old(array).len() > 1
    ensures insertion_sorted(array@, 0, array@.len() as int)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0280,verus,dafnybench,Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Quick_Sort_quickSort,,,"use vstd::prelude::*;

verus! {

spec fn quick_sorted(seq: Seq<int>) -> bool {
    forall|idx_1: int, idx_2: int| 0 <= idx_1 < idx_2 < seq.len() ==> seq[idx_1] <= seq[idx_2]
}

#[verifier::exec_allows_no_decreases_clause]
fn threshold(thres: int, seq: Seq<int>) -> (res: (Seq<int>, Seq<int>))
    ensures
        (forall|x: int| res.0.contains(x) ==> x <= thres) && (forall|x: int| res.1.contains(x) ==> x >= thres) &&
        res.0.len() + res.1.len() == seq.len() &&
        res.0.to_multiset().add(res.1.to_multiset()) == seq.to_multiset()
{
    assume(false);
    loop {}
}",,"fn quick_sort(seq: Seq<int>) -> (res: Seq<int>)
    ensures seq.to_multiset() == res.to_multiset()
    decreases seq.len()","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0281,verus,dafnybench,Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Quick_Sort_threshold,,,"use vstd::prelude::*;

verus! {

spec fn quick_sorted(seq: Seq<int>) -> bool {
    forall|idx_1: int, idx_2: int| 0 <= idx_1 < idx_2 < seq.len() ==> seq[idx_1] <= seq[idx_2]
}",,"fn threshold(thres: int, seq: Seq<int>) -> (ret: (Seq<int>, Seq<int>))
    ensures 
        (forall|x: int| ret.0.contains(x) ==> x <= thres) &&
        (forall|x: int| ret.1.contains(x) ==> x >= thres) &&
        ret.0.len() + ret.1.len() == seq.len() &&
        ret.0.to_multiset().add(ret.1.to_multiset()) == seq.to_multiset()","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0282,verus,dafnybench,Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Selection_Sort_Standard_selectionSorted,,,"use vstd::prelude::*;

verus! {",,"fn selection_sorted(array: &mut Vec<i32>) 
    ensures array@.to_multiset() == old(array)@.to_multiset()","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0286,verus,dafnybench,FlexWeek_tmp_tmpc_tfdj_3_ex4_join,,// Forall,"use vstd::prelude::*;

verus! {",,"fn join(a: &[i32], b: &[i32]) -> (c: Vec<i32>)
    ensures
        a@ + b@ == c@,
        (a@ + b@).to_multiset() == c@.to_multiset(),
        a@.to_multiset().add(b@.to_multiset()) == c@.to_multiset(),
        a.len() + b.len() == c.len(),

        forall|i: int| 0 <= i < a.len() ==> c[i] == a[i],
        forall|i: int, j: int| 
            a.len() <= i < c.len() && 
            0 <= j < b.len() && 
            i - j == a.len() ==> c[i] == b[j],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0287,verus,dafnybench,FlexWeek_tmp_tmpc_tfdj_3_reverse_Reverse,,"// Write an *iterative* Verus method reverse with signature:

//          fn reverse(a: &Vec<char>) -> Vec<char>

// which takes an input vector of characters 'a' and outputs vector 'b' consisting of

// the elements of the input vector in reverse order. The following conditions apply:

//  - the input vector cannot be empty

//  - the input vector is not modified

//  - you must use iteration

//  - not permitted is an *executable* (parallel) forall statement

//  - not permitted are any other predicates, functions or methods

// For the purposes of this practice exercise, I'll include a test method.

// Notice it compiles and the executable generates output (just to see the vectors printed in reverse).","use vstd::prelude::*;

verus! {",,"fn reverse(a: &Vec<char>) -> (b: Vec<char>)
    requires a.len() > 0
    ensures 
        a.len() == b.len(),
        forall|k: int| 0 <= k < a.len() ==> b[k] == a[(a.len() - 1) - k]","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0290,verus,dafnybench,Formal-Verification-Project_tmp_tmp9gmwsmyp_strings3_haveCommonKSubstring,,"// !res <==> is_not_substring_pred(sub, str), // This postcondition follows from the above lemma.

// !found <==> have_not_common_k_substring_pred(k, str1, str2), // This postcondition follows from the above lemma.","use vstd::prelude::*;

verus! {

fn is_prefix(pre: Seq<char>, str: Seq<char>) -> (res: bool)
    ensures
        !res <==> is_not_prefix_pred(pre, str),
        res <==> is_prefix_pred(pre, str),
{
    assume(false);
    false
}

spec fn is_prefix_pred(pre: Seq<char>, str: Seq<char>) -> bool {
    pre.len() <= str.len() && 
    pre == str.subrange(0, pre.len() as int)
}

spec fn is_not_prefix_pred(pre: Seq<char>, str: Seq<char>) -> bool {
    pre.len() > str.len() || 
    pre != str.subrange(0, pre.len() as int)
}

spec fn is_substring_pred(sub: Seq<char>, str: Seq<char>) -> bool {
    exists|i: int| 0 <= i <= str.len() && is_prefix_pred(sub, str.subrange(i, str.len() as int))
}

spec fn is_not_substring_pred(sub: Seq<char>, str: Seq<char>) -> bool {
    forall|i: int| 0 <= i <= str.len() ==> is_not_prefix_pred(sub, str.subrange(i, str.len() as int))
}

fn is_substring(sub: Seq<char>, str: Seq<char>) -> (res: bool)
    ensures
        res <==> is_substring_pred(sub, str),

{
    assume(false);
    false
}

spec fn have_common_k_substring_pred(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool {
    exists|i1: int, j1: int| 
        0 <= i1 <= str1.len() - k && 
        j1 == i1 + k && 
        is_substring_pred(str1.subrange(i1, j1), str2)
}

spec fn have_not_common_k_substring_pred(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool {
    forall|i1: int, j1: int| 
        0 <= i1 <= str1.len() - k && 
        j1 == i1 + k ==> 
        is_not_substring_pred(str1.subrange(i1, j1), str2)
}",,"fn have_common_k_substring(k: nat, str1: Seq<char>, str2: Seq<char>) -> (found: bool)
    ensures
        found <==> have_common_k_substring_pred(k, str1, str2),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0292,verus,dafnybench,Formal-Verification-Project_tmp_tmp9gmwsmyp_strings3_isSubstring,,"//ensures !res <==> is_not_substring_pred(sub, str) // This postcondition follows from the above lemma.","use vstd::prelude::*;

verus! {

spec fn is_prefix_pred(pre: Seq<char>, str: Seq<char>) -> bool {
    pre.len() <= str.len() && 
    pre == str.subrange(0, pre.len() as int)
}

spec fn is_not_prefix_pred(pre: Seq<char>, str: Seq<char>) -> bool {
    pre.len() > str.len() || 
    pre != str.subrange(0, pre.len() as int)
}

fn is_prefix(pre: Seq<char>, str: Seq<char>) -> (res: bool)
    ensures 
        !res <==> is_not_prefix_pred(pre, str),
        res <==> is_prefix_pred(pre, str),
{
    assume(false);
    false
}

spec fn is_substring_pred(sub: Seq<char>, str: Seq<char>) -> bool {
    exists|i: int| 0 <= i <= str.len() && is_prefix_pred(sub, str.subrange(i, str.len() as int))
}

spec fn is_not_substring_pred(sub: Seq<char>, str: Seq<char>) -> bool {
    forall|i: int| 0 <= i <= str.len() ==> is_not_prefix_pred(sub, str.subrange(i, str.len() as int))
}

spec fn have_common_k_substring_pred(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool {
    exists|i1: int, j1: int| 0 <= i1 <= str1.len() - k && j1 == i1 + k && is_substring_pred(str1.subrange(i1, j1), str2)
}

spec fn have_not_common_k_substring_pred(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool {
    forall|i1: int, j1: int| 0 <= i1 <= str1.len() - k && j1 == i1 + k ==> is_not_substring_pred(str1.subrange(i1, j1), str2)
}",,"fn is_substring(sub: Seq<char>, str: Seq<char>) -> (res: bool)
    ensures res <==> is_substring_pred(sub, str)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0293,verus,dafnybench,Formal-Verification-Project_tmp_tmp9gmwsmyp_strings3_maxCommonSubstringLength,,,"use vstd::prelude::*;

verus! {

spec fn is_substring(sub: Seq<char>, str: Seq<char>) -> bool
{
    exists|i: int| 0 <= i <= str.len() - sub.len() && str.subrange(i, i + sub.len()) == sub
}

spec fn is_prefix_pred(pre: Seq<char>, str: Seq<char>) -> bool
{
    pre.len() <= str.len() && pre == str.subrange(0, pre.len() as int)
}

spec fn is_not_prefix_pred(pre: Seq<char>, str: Seq<char>) -> bool
{
    pre.len() > str.len() || pre != str.subrange(0, pre.len() as int)
}

spec fn is_substring_pred(sub: Seq<char>, str: Seq<char>) -> bool
{
    exists|i: int| 0 <= i <= str.len() && is_prefix_pred(sub, str.subrange(i, str.len() as int))
}

spec fn is_not_substring_pred(sub: Seq<char>, str: Seq<char>) -> bool
{
    forall|i: int| 0 <= i <= str.len() ==> is_not_prefix_pred(sub, str.subrange(i, str.len() as int))
}

spec fn have_common_k_substring_pred(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool
{
    exists|i1: int, j1: int| 0 <= i1 <= str1.len() - k && j1 == i1 + k && is_substring_pred(str1.subrange(i1, j1), str2)
}

spec fn have_not_common_k_substring_pred(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool
{
    forall|i1: int, j1: int| 0 <= i1 <= str1.len() - k && j1 == i1 + k ==> is_not_substring_pred(str1.subrange(i1, j1), str2)
}",,"fn max_common_substring_length(str1: &Vec<char>, str2: &Vec<char>) -> (len: usize)
    requires str1.len() <= str2.len()
    ensures 
        forall|k: int| len < k <= str1.len() ==> ! #[trigger] have_common_k_substring_pred(k as nat, str1@, str2@),
        have_common_k_substring_pred(len as nat, str1@, str2@)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0294,verus,dafnybench,Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings1_haveCommonKSubstring,,,"use vstd::prelude::*;

verus! {

spec fn is_not_prefix_pred(pre: Seq<char>, str: Seq<char>) -> bool {
    (pre.len() > str.len()) || 
    pre != str.subrange(0, pre.len() as int)
}

fn is_prefix(pre: Seq<char>, str: Seq<char>) -> (res: bool)
    ensures
        !res <==> is_not_prefix_pred(pre, str),
        res <==> is_prefix_predicate(pre, str),
{
  assume(false);
  false
}

spec fn is_prefix_predicate(pre: Seq<char>, str: Seq<char>) -> bool {
  str.len() >= pre.len() && pre == str.subrange(0, pre.len() as int)
}

spec fn is_substring_predicate(sub: Seq<char>, str: Seq<char>) -> bool {
  str.len() >= sub.len() && 
  exists|i: int| 0 <= i <= str.len() && #[trigger] is_prefix_predicate(sub, str.subrange(i, str.len() as int))
}

fn is_substring(sub: Seq<char>, str: Seq<char>) -> (res: bool)
    ensures res == is_substring_predicate(sub, str)
{
  assume(false);
  false
}

spec fn have_common_k_substring_predicate(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool {
  str1.len() >= k && str2.len() >= k && 
  exists|i: int| 0 <= i <= str1.len() - k && 
      #[trigger] is_substring_predicate(
          str1.subrange(i, str1.len() as int).subrange(0, k as int), 
          str2
      )
}

spec fn max_common_substring_predicate(str1: Seq<char>, str2: Seq<char>, len: nat) -> bool {
   forall|k: int| len < k <= str1.len() ==> !#[trigger] have_common_k_substring_predicate(k as nat, str1, str2)
}",,"fn have_common_k_substring(k: nat, str1: Seq<char>, str2: Seq<char>) -> (found: bool)
    ensures 
        (str1.len() < k || str2.len() < k) ==> !found,
        have_common_k_substring_predicate(k, str1, str2) == found,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0297,verus,dafnybench,Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings1_maxCommonSubstringLength,,,"use vstd::prelude::*;

verus! {

spec fn is_not_prefix_pred(pre: Seq<char>, str: Seq<char>) -> bool {
    (pre.len() > str.len()) || 
    pre != str.subrange(0, pre.len() as int)
}

fn is_prefix(pre: Seq<char>, str: Seq<char>) -> (res: bool)
    ensures 
        !res <==> is_not_prefix_pred(pre, str),
        res <==> is_prefix_predicate(pre, str),
{
    assume(false);
    true
}

spec fn is_prefix_predicate(pre: Seq<char>, str: Seq<char>) -> bool {
    str.len() >= pre.len() && pre == str.subrange(0, pre.len() as int)
}

spec fn is_substring_predicate(sub: Seq<char>, str: Seq<char>) -> bool {
    str.len() >= sub.len() && (exists|i: int| 0 <= i <= str.len() && is_prefix_predicate(sub, str.subrange(i, str.len() as int)))
}

fn is_substring(sub: Seq<char>, str: Seq<char>) -> (res: bool)
    ensures res == is_substring_predicate(sub, str),
{
    assume(false);
    true
}

spec fn have_common_k_substring_predicate(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool {
    str1.len() >= k && str2.len() >= k && (exists|i: int| 0 <= i <= str1.len() - k && is_substring_predicate((str1.subrange(i, str1.len() as int)).subrange(0, k as int), str2))
}

fn have_common_k_substring(k: usize, str1: Seq<char>, str2: Seq<char>) -> (found: bool)
    requires k <= usize::MAX,
    ensures 
        (str1.len() < k || str2.len() < k) ==> !found,
        have_common_k_substring_predicate(k as nat, str1, str2) == found,
{
    assume(false);
    true
}

spec fn max_common_substring_predicate(str1: Seq<char>, str2: Seq<char>, len: nat) -> bool {
    forall|k: int| len < k <= str1.len() ==> !#[trigger] have_common_k_substring_predicate(k as nat, str1, str2)
}",,"fn max_common_substring_length(str1: Seq<char>, str2: Seq<char>) -> (len: usize)
    ensures 
        len <= str1.len() && len <= str2.len(),
        len >= 0,
        max_common_substring_predicate(str1, str2, len as nat),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0298,verus,dafnybench,Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings3_haveCommonKSubstring,,"// We spent 2h each on this assignment

//ensures !res <==> is_not_substring_pred(sub@, s@) // This postcondition follows from the above lemma.

//ensures !found <==> have_not_common_k_substring_pred(k, str1@, str2@) // This postcondition follows from the above lemma.","use vstd::prelude::*;

verus! {

spec fn is_prefix_pred(pre: Seq<char>, s: Seq<char>) -> bool {
    pre.len() <= s.len() && 
    pre == s.subrange(0, pre.len() as int)
}

spec fn is_not_prefix_pred(pre: Seq<char>, s: Seq<char>) -> bool {
    pre.len() > s.len() || 
    pre != s.subrange(0, pre.len() as int)
}

fn is_prefix(pre: &str, s: &str) -> (res: bool)
    ensures 
        !res <==> is_not_prefix_pred(pre@, s@),
        res <==> is_prefix_pred(pre@, s@)
{
    assume(false);
    true
}

spec fn is_substring_pred(sub: Seq<char>, s: Seq<char>) -> bool {
    exists|i: int| 0 <= i <= s.len() && is_prefix_pred(sub, s.subrange(i, s.len() as int))
}

spec fn is_not_substring_pred(sub: Seq<char>, s: Seq<char>) -> bool {
    forall|i: int| 0 <= i <= s.len() ==> is_not_prefix_pred(sub, s.subrange(i, s.len() as int))
}

fn is_substring(sub: &str, s: &str) -> (res: bool)
    ensures res <==> is_substring_pred(sub@, s@)

{
    assume(false);
    true
}

spec fn have_common_k_substring_pred(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool {
    exists|i1: int, j1: int| 
        0 <= i1 <= str1.len() - k && 
        j1 == i1 + k && 
        is_substring_pred(str1.subrange(i1, j1), str2)
}

spec fn have_not_common_k_substring_pred(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool {
    forall|i1: int, j1: int| 
        0 <= i1 <= str1.len() - k && 
        j1 == i1 + k ==> 
        is_not_substring_pred(str1.subrange(i1, j1), str2)
}",,"fn have_common_k_substring(k: nat, str1: &str, str2: &str) -> (found: bool)
    ensures found <==> have_common_k_substring_pred(k, str1@, str2@)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0301,verus,dafnybench,Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings3_maxCommonSubstringLength,,"// We spent 2h each on this assignment

//ensures !found <==> have_not_common_k_substring_pred(k, str1, str2) // This postcondition follows from the above lemma.","use vstd::prelude::*;

verus! {

spec fn is_substring(sub: Seq<char>, str: Seq<char>) -> bool 
    decreases str.len()
{
    if sub.len() == 0 {
        true
    } else if sub.len() > str.len() {
        false  
    } else {
        sub == str.subrange(0, sub.len() as int) || is_substring(sub, str.subrange(1, str.len() as int))
    }
}

spec fn is_prefix_pred(pre: Seq<char>, str: Seq<char>) -> bool {
    pre.len() <= str.len() && 
    pre == str.subrange(0, pre.len() as int)
}

spec fn is_not_prefix_pred(pre: Seq<char>, str: Seq<char>) -> bool {
    pre.len() > str.len() || 
    pre != str.subrange(0, pre.len() as int)
}

spec fn is_substring_pred(sub: Seq<char>, str: Seq<char>) -> bool {
    exists|i: int| #![auto] 0 <= i && i <= str.len() && is_prefix_pred(sub, str.subrange(i, str.len() as int))
}

spec fn is_not_substring_pred(sub: Seq<char>, str: Seq<char>) -> bool {
    forall|i: int| #![auto] 0 <= i && i <= str.len() ==> is_not_prefix_pred(sub, str.subrange(i, str.len() as int))
}

spec fn have_common_k_substring_pred(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool {
    exists|i1: int, j1: int| #![auto] 0 <= i1 && i1 + k <= str1.len() && j1 == i1 + k && is_substring_pred(str1.subrange(i1, j1), str2)
}

spec fn have_not_common_k_substring_pred(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool {
    forall|i1: int, j1: int| #![auto] 0 <= i1 && i1 + k <= str1.len() && j1 == i1 + k ==> is_not_substring_pred(str1.subrange(i1, j1), str2)
}

fn have_common_k_substring(k: usize, str1: Seq<char>, str2: Seq<char>) -> (found: bool)
    ensures found <==> have_common_k_substring_pred(k as nat, str1, str2)

{
    assume(false);
    false
}",,"fn max_common_substring_length(str1: Seq<char>, str2: Seq<char>) -> (len: usize)
    requires str1.len() <= str2.len()
    ensures (forall|k: nat| #![auto] len < k && k <= str1.len() ==> !have_common_k_substring_pred(k, str1, str2))
        && have_common_k_substring_pred(len as nat, str1, str2)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0311,verus,dafnybench,Formal-methods-of-software-development_tmp_tmppryvbyty_Bloque_2_Lab6_vector_Sum,,"/*predicate palindrome<T(==)> (s:seq<T>)
{
    forall i:: 0<=i<|s| ==> s[i] == s[|s|-i-1]
}
*/

// SUM OF A SEQUENCE OF INTEGERS

// Structural Induction on Sequences

// MAXIMUM OF A SEQUENCE

// TODO: Hacer

// Derivar formalmente un calculo incremental de j*j*j

// REVERSE OF A SEQUENCE

// REVERSE IS ITS OWN INVERSE

// SCALAR PRODUCT OF TWO VECTORS OF INTEGER

// MULTISETS

// REVERSE HAS THE SAME MULTISET","use vstd::prelude::*;

verus! {

spec fn sum(v: Seq<int>) -> int 
    decreases v.len()
{
    if v.len() == 0 { 
        0 
    } else if v.len() == 1 { 
        v[0] 
    } else { 
        v[0] + sum(v.subrange(1, v.len() as int))
    }
}

spec fn reverse<T>(s: Seq<T>) -> Seq<T> 
    decreases s.len()
{
    if s.len() == 0 { 
        seq![] 
    } else { 
        reverse(s.subrange(1, s.len() as int)).push(s[0])
    }
}

spec fn seq2set<T>(s: Seq<T>) -> Set<T> 
    decreases s.len()
{
    if s.len() == 0 { 
        set!{} 
    } else { 
        set!{s[0]}.union(seq2set(s.subrange(1, s.len() as int)))
    }
}

spec fn scalar_product(v1: Seq<int>, v2: Seq<int>) -> int
    decreases v1.len()
{
    if v1.len() == 0 || v2.len() == 0 { 
        0 
    } else { 
        v1[0] * v2[0] + scalar_product(v1.subrange(1, v1.len() as int), v2.subrange(1, v2.len() as int))
    }
}

fn multiplicity_examples<T>()
{
  assume(false);
}",,"fn vector_Sum(v: Seq<int>) -> (x: i32)
    ensures x == sum(v)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0331,verus,dafnybench,MFES_2021_tmp_tmpuljn8zd9_Exams_Special_Exam_03_2020_4_CatalanNumbers_calcC,,,"use vstd::prelude::*;

verus! {

spec fn C(n: nat) -> nat
    decreases n
{
    if n == 0 { 
        1nat 
    } else { 
        ((4 * (n as int) - 2) * (C((n - 1) as nat) as int) / ((n as int) + 1)) as nat
    }
}",,"fn calcC(n: u64) -> (res: u64)
    ensures res == C(n as nat),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0335,verus,dafnybench,MFES_2021_tmp_tmpuljn8zd9_TheoreticalClasses_Power_powerIter,,"/* 
* Formal verification of O(n) and O(log n) algorithms to calculate the natural
* power of a real number (x^n), illustrating the usage of lemmas.
* FEUP, MIEIC, MFES, 2020/21.
*/

// Initial specification/definition of x^n, recursive, functional style, 

// with time and space complexity O(n).

// Iterative version, imperative, with time complexity O(n) and space complexity O(1).

// Recursive version, imperative, with time and space complexity O(log n).

// States the property x^a * x^b = x^(a+b), that powerOpt takes advantage of. 

// The annotation {:induction a} guides Dafny to prove the property

// by automatic induction on 'a'.

// A simple test case to make sure the specification is adequate.","use vstd::prelude::*;

verus! {

spec fn power(x: int, n: nat) -> int
    decreases n
{
    if n == 0 { 1 } else { x * power(x, (n - 1) as nat) }
}",,"fn power_iter(x: i64, n: u64) -> (p: i64)
    ensures p == power(x as int, n as nat)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0337,verus,dafnybench,MFS_tmp_tmpmmnu354t_Praticas_TP9_Power_powerIter,,"/* 
* Formal verification of O(n) and O(log n) algorithms to calculate the natural
* power of a real number (x^n), illustrating the usage of lemmas.
* FEUP, M.EIC, MFS, 2021/22.
*/

// Initial specification/definition of x^n, recursive, functional style, 

// with time and space complexity O(n).

// Iterative version, imperative, with time complexity O(n) and space complexity O(1).

// Recursive version, imperative, with time and space complexity O(log n).

// A simple test case to make sure the specification is adequate.","use vstd::prelude::*;

verus! {

spec fn power(x: int, n: nat) -> int
    decreases n
{
    if n == 0 { 1 } else { x * power(x, (n-1) as nat) }
}",,"fn power_iter(b: i32, n: u32) -> (p: i32)
    ensures p as int == power(b as int, n as nat)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0340,verus,dafnybench,MIEIC_mfes_tmp_tmpq3ho7nve_TP3_binary_search_binarySearch,,"// Checks if array 'a' is sorted.

// Finds a value 'x' in a sorted array 'a', and returns its index,

// or -1 if not found.

// Simple test cases to check the post-condition.

/*
a) Identify adequate pre and post-conditions for this method, 
and encode them as ""requires"" and ""ensures"" clauses in Verus. 
You can use the predicate below if needed.

b) Identify an adequate loop variant and loop invariant, and encode them 
as ""decreases"" and ""invariant"" clauses in Verus.
*/","use vstd::prelude::*;

verus! {

spec fn is_sorted(a: &[i32]) -> bool {
    forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j]
}",,"fn binary_search(a: &[i32], x: i32) -> (index: i32)
    requires is_sorted(a)
    ensures -1 <= index < a.len() && 
            (index != -1 ==> a[index as int] == x) &&
            (index == -1 ==> !a@.contains(x))","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0342,verus,dafnybench,MIEIC_mfes_tmp_tmpq3ho7nve_exams_mt2_19_p4_calcR,,,"use vstd::prelude::*;

verus! {

spec fn R(n: nat) -> nat
    decreases n
{
    if n == 0 { 
        0nat 
    } else if R((n-1) as nat) > n { 
        (R((n-1) as nat) - n) as nat
    } else { 
        (R((n-1) as nat) + n) as nat
    }
}",,"fn calcR(n: u64) -> (r: u64)
    ensures r == R(n as nat)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0343,verus,dafnybench,MIEIC_mfes_tmp_tmpq3ho7nve_exams_mt2_19_p5_partition,,"// example

// Partitions a nonempty array 'a', by reordering the elements in the array,

// so that elements smaller than a chosen pivot are placed to the left of the

// pivot, and values greater or equal than the pivot are placed to the right of 

// the pivot. Returns the pivot position.","use vstd::prelude::*;

verus! {

type T = int;",,"fn partition(a: &mut Vec<T>) -> (pivotPos: usize)
    requires 
        old(a).len() > 0,
    ensures 
        pivotPos < a.len(),
        forall|i: int| 0 <= i < pivotPos ==> a[i] < a[pivotPos as int],
        forall|i: int| pivotPos < i < a.len() ==> a[i] >= a[pivotPos as int],
        a@.to_multiset() == old(a)@.to_multiset(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0355,verus,dafnybench,Prog-Fun-Solutions_tmp_tmp7_gmnz5f_extra_mod2_mod2,,,"use vstd::prelude::*;

verus! {

spec fn f2(n: nat) -> nat 
    decreases n
{
    if n == 0 { 0 }
    else { 5 * f2(n / 3) + n % 4 }
}",,"fn mod2(n: u32) -> (a: u32)
    ensures a == f2(n as nat)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0356,verus,dafnybench,Prog-Fun-Solutions_tmp_tmp7_gmnz5f_extra_mod_mod,,,"use vstd::prelude::*;

verus! {

spec fn f(n: nat) -> nat
    decreases n
{
    if n == 0 { 1 }
    else if n % 2 == 0 { 1 + 2 * f(n / 2) }
    else { 2 * f(n / 2) }
}",,"fn mod_fn(n: u64) -> (a: u64)
    requires n >= 0,
    ensures a as nat == f(n as nat),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0363,verus,dafnybench,Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced_examples_InsertionSort_InsertionSort,,,"use vstd::prelude::*;

verus! {

spec fn sorted(a: &Vec<i32>, start: int, end: int) -> bool {
    &&& 0 <= start <= end <= a.len()
    &&& forall|j: int, k: int| start <= j < k < end ==> a[j] <= a[k]
}",,"fn insertion_sort(a: &mut Vec<i32>)
    requires 
        old(a).len() > 1,
    ensures 
        sorted(a, 0, a.len() as int),
        a.len() == old(a).len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0364,verus,dafnybench,Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced_examples_MatrixMultiplication_multiply,,,"use vstd::prelude::*;

verus! {

spec fn row_column_product(m1: &Vec<Vec<int>>, m2: &Vec<Vec<int>>, row: int, column: int) -> int
    recommends
        m1.len() > 0,
        m2.len() > 0,
        m1[0].len() == m2.len(),
        0 <= row < m1.len(),
        0 <= column < m2[0].len(),
        forall|i: int| 0 <= i < m1.len() ==> #[trigger] m1[i].len() == m1[0].len(),
        forall|i: int| 0 <= i < m2.len() ==> #[trigger] m2[i].len() == m2[0].len(),
{
    row_column_product_from(m1, m2, row, column, 0)
}

spec fn row_column_product_from(m1: &Vec<Vec<int>>, m2: &Vec<Vec<int>>, row: int, column: int, k: int) -> int
    recommends
        m1.len() > 0,
        m2.len() > 0,
        0 <= k <= m1[0].len(),
        m1[0].len() == m2.len(),
        0 <= row < m1.len(),
        0 <= column < m2[0].len(),
        forall|i: int| 0 <= i < m1.len() ==> #[trigger] m1[i].len() == m1[0].len(),
        forall|i: int| 0 <= i < m2.len() ==> #[trigger] m2[i].len() == m2[0].len(),
        k < m1[0].len() ==> 0 <= k < m1[row].len(),
        k < m1[0].len() ==> 0 <= k < m2.len(),
        k < m1[0].len() ==> 0 <= column < m2[k].len(),
    decreases m1[0].len() - k
    when 0 <= k <= m1[0].len()
{
    if k == m1[0].len() {
        0
    } else {
        m1[row][k] * m2[k][column] + row_column_product_from(m1, m2, row, column, k + 1)
    }
}",,"fn multiply(m1: &Vec<Vec<int>>, m2: &Vec<Vec<int>>) -> (m3: Vec<Vec<int>>)
    requires
        m1.len() > 0,
        m2.len() > 0,
        m1[0].len() == m2.len(),
        forall|i: int| 0 <= i < m1.len() ==> #[trigger] m1[i].len() == m1[0].len(),
        forall|i: int| 0 <= i < m2.len() ==> #[trigger] m2[i].len() == m2[0].len(),
    ensures
        m3.len() == m1.len(),
        m3.len() > 0 ==> m3[0].len() == m2[0].len(),
        forall|i: int| 0 <= i < m3.len() ==> #[trigger] m3[i].len() == m2[0].len(),
        forall|i: int, j: int| 0 <= i < m3.len() && 0 <= j < m2[0].len() ==>
            #[trigger] m3[i][j] == row_column_product(m1, m2, i, j),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0365,verus,dafnybench,Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced_examples_Percentile_Percentile,,"// Sum of elements of A from indices 0 to end.

// end is inclusive! (not James's normal way of thinking!!)

// out of bounds

// example showing that, with the original postcondition, the answer is non-unique!

// proof that, with the corrected postcondition, the answer is unique

// lemma for previous proof: when an array has strictly positive elements, the

// sums strictly increase left to right","use vstd::prelude::*;

verus! {

spec fn sum_upto(a: Seq<int>, end: int) -> int
    decreases end + 2
{
    if end < 0 {
        0
    } else if end >= a.len() {
        0
    } else {
        a[end] + sum_upto(a, end - 1)
    }
}

spec fn sum(a: Seq<int>) -> int {
    sum_upto(a, a.len() - 1)
}",,"fn percentile(p: int, a: &[int], total: int) -> (i: i32)
    requires 
        forall|idx: int| 0 <= idx < a.len() ==> a@[idx] > 0,
        0 <= p <= 100,
        total == sum(a@),
        total > 0,
    ensures 
        -1 <= i < a.len(),
        sum_upto(a@, i as int) <= (p * total) / 100,
        i as int + 1 < a.len() ==> sum_upto(a@, i as int + 1) > (p * total) / 100,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0366,verus,dafnybench,Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced_examples_Percentile_PercentileNonUniqueAnswer,,"// Sum of elements of A from indices 0 to end.

// end is inclusive! (not James's normal way of thinking!!)

// example showing that, with the original postcondition, the answer is non-unique!

// proof that, with the corrected postcondition, the answer is unique

// lemma for previous proof: when an array has strictly positive elements, the

// sums strictly increase left to right","use vstd::prelude::*;

verus! {

spec fn sum_upto(a: Seq<int>, end: int) -> int
    recommends -1 <= end < a.len()
    decreases end + 1
    when end >= -1
{
    if end == -1 {
        0
    } else {
        a[end] + sum_upto(a, end - 1)
    }
}

spec fn sum(a: Seq<int>) -> int {
    sum_upto(a, a.len() - 1)
}",,"#[verifier::external_body]
fn percentile_non_unique_answer() -> (result: (int, Vec<int>, int, int, int))
    ensures 
        forall|i: int| 0 <= i < result.1@.len() ==> result.1@[i] > 0,
        0 <= result.0 && result.0 <= 100,
        result.2 == sum(result.1@),
        result.2 > 0,
        -1 <= result.3 && result.3 < result.1@.len(),
        sum_upto(result.1@, result.3) <= (result.0/100) * result.2,
        result.3+1 < result.1@.len() ==> sum_upto(result.1@, result.3+1) >= (result.0/100) * result.2,
        -1 <= result.4 && result.4 < result.1@.len(),
        sum_upto(result.1@, result.4) <= (result.0/100) * result.2,
        result.4+1 < result.1@.len() ==> sum_upto(result.1@, result.4+1) >= (result.0/100) * result.2,
        result.3 != result.4","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0367,verus,dafnybench,Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced_examples_ReverseString_yarra,,"// RUN: /compile:0

// Predicate to check if outarr is the reverse of arr","use vstd::prelude::*;

verus! {

spec fn reversed(arr: Seq<char>, outarr: Seq<char>) -> bool {
    arr.len() == outarr.len() &&
    forall|k: int| 0 <= k < arr.len() ==> outarr[k] == arr[arr.len() - 1 - k]
}",,"fn yarra(arr: &Vec<char>) -> (outarr: Vec<char>)
    requires arr.len() > 0
    ensures outarr.len() == arr.len() && reversed(arr@, outarr@)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0368,verus,dafnybench,Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced_examples_demo_Partition,,,"use vstd::prelude::*;

verus! {",,"fn partition(a: &mut Vec<i32>) -> (r : (usize, usize))
    ensures
        0 <= r.0 && r.0 <= r.1 && r.1 <= a.len(),
        forall|x: int| 0 <= x < r.0 ==> a[x as int] < 0,
        forall|x: int| r.0 <= x < r.1 ==> a[x as int] == 0,
        forall|x: int| r.1 <= x < a.len() ==> a[x as int] > 0,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0369,verus,dafnybench,Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_ProgramProofs_ch15_Partition,,,"use vstd::prelude::*;

verus! {

spec fn split_point(a: Seq<int>, n: int) -> bool {
    0 <= n <= a.len() &&
    forall|i: int, j: int| 0 <= i < n <= j < a.len() ==> a[i] <= a[j]
}

spec fn swap_frame(a_old: Seq<int>, a_new: Seq<int>, lo: int, hi: int) -> bool {
    0 <= lo <= hi <= a_old.len() &&
    a_old.len() == a_new.len() &&
    (forall|i: int| (0 <= i < lo || hi <= i < a_old.len()) ==> a_new[i] == a_old[i]) &&
    a_new.to_multiset() == a_old.to_multiset()
}",,"fn partition(a: &mut Vec<int>, lo: usize, hi: usize) -> (p: usize)
    requires
        0 <= lo < hi <= old(a).len(),
        split_point(old(a)@, lo as int),
        split_point(old(a)@, hi as int),
    ensures
        lo <= p < hi,
        forall|i: int| lo <= i < p ==> a[i] < a[p as int],
        forall|i: int| p <= i < hi ==> a[p as int] <= a[i],
        split_point(a@, lo as int),
        split_point(a@, hi as int),
        swap_frame(old(a)@, a@, lo as int, hi as int),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0370,verus,dafnybench,Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_ProgramProofs_ch15_QuickSort,,,"use vstd::prelude::*;

verus! {

fn partition(a: &mut Vec<int>, lo: usize, hi: usize) -> (p: usize)
    requires 0 <= lo < hi <= old(a).len(),
    ensures lo <= p < hi,
{
    assume(false);
    0
}

spec fn split_point(a: &Vec<int>, n: usize) -> bool
    recommends 0 <= n <= a.len(),
{
    forall|i: int, j: int| 0 <= i < n && n <= j < a.len() ==> a[i] <= a[j]
}

spec fn swap_frame(a: &Vec<int>, old_a: &Vec<int>, lo: usize, hi: usize) -> bool
    recommends 0 <= lo <= hi <= a.len(),
{
    (forall|i: int| (0 <= i < lo || hi <= i < a.len()) ==> a[i] == old_a[i]) &&
    a@.to_multiset() =~= old_a@.to_multiset()
}

fn quick_sort_aux(a: &mut Vec<int>, lo: usize, hi: usize)
    requires 
        0 <= lo <= hi <= old(a).len(),
        split_point(old(a), lo),
        split_point(old(a), hi),
    ensures 
        forall|i: int, j: int| lo <= i < j < hi ==> a[i] <= a[j],
        swap_frame(a, old(a), lo, hi),
        split_point(a, lo),
        split_point(a, hi),
    decreases hi - lo,
{
    assume(false);
}",,"fn quick_sort(a: &mut Vec<int>)
    ensures 
        forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j],
        a@.to_multiset() =~= old(a)@.to_multiset(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0371,verus,dafnybench,Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_ProgramProofs_ch15_QuickSortAux,,// dummy return,"use vstd::prelude::*;

verus! {

spec fn split_point(a: Seq<int>, n: int) -> bool {
    forall|i: int, j: int| 0 <= i < n <= j < a.len() ==> a[i] <= a[j]
}

spec fn swap_frame(a_old: Seq<int>, a_new: Seq<int>, lo: int, hi: int) -> bool
    recommends 0 <= lo <= hi <= a_old.len() && a_old.len() == a_new.len()
{
    (forall|i: int| (0 <= i < lo || hi <= i < a_new.len()) ==> a_new[i] == a_old[i]) 
    && a_new.to_multiset() =~= a_old.to_multiset()
}

fn partition(a: &mut Vec<int>, lo: usize, hi: usize) -> (p: usize)
    requires 
        0 <= lo < hi <= old(a).len(),
        split_point(old(a)@, lo as int) && split_point(old(a)@, hi as int),
    ensures
        lo <= p < hi,
        forall|i: int| lo <= i < p ==> a@[i] < a@[p as int],
        forall|i: int| p <= i < hi ==> a@[p as int] <= a@[i],
        split_point(a@, lo as int) && split_point(a@, hi as int),
        swap_frame(old(a)@, a@, lo as int, hi as int),
{
    assume(false);
    lo
}",,"fn quick_sort_aux(a: &mut Vec<int>, lo: usize, hi: usize)
    requires 
        0 <= lo <= hi <= old(a).len(),
        split_point(old(a)@, lo as int) && split_point(old(a)@, hi as int),
    ensures
        forall|i: int, j: int| lo <= i < j < hi ==> a@[i] <= a@[j],
        swap_frame(old(a)@, a@, lo as int, hi as int),
        split_point(a@, lo as int) && split_point(a@, hi as int),
    decreases hi - lo","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0372,verus,dafnybench,Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_ProgramProofs_ch15_SelectionSort,,,"use vstd::prelude::*;

verus! {

spec fn split_point(a: &Vec<int>, n: int) -> bool {
    0 <= n <= a.len() &&
    forall|i: int, j: int| 0 <= i < n <= j < a.len() ==> a[i] <= a[j]
}

spec fn swap_frame(a_old: &Vec<int>, a_new: &Vec<int>, lo: int, hi: int) -> bool {
    0 <= lo <= hi <= a_old.len() &&
    a_old.len() == a_new.len() &&
    (forall|i: int| (0 <= i < lo || hi <= i < a_old.len()) ==> a_new[i] == a_old[i]) &&
    a_new@.to_multiset() == a_old@.to_multiset()
}",,"fn selection_sort(a: &mut Vec<int>)
    ensures
        forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j],
        a@.to_multiset() == old(a)@.to_multiset(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0373,verus,dafnybench,Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_examples_bubblesort_BubbleSort,,"//https://stackoverflow.com/questions/69364687/how-to-prove-time-complexity-of-bubble-sort-using-dafny

// sum of all integers in the range [lo, hi)

// (inclusive of lo, exclusive of hi)

// dafny proves this automatically by induction","use vstd::prelude::*;

verus! {

spec fn n_choose_2(n: int) -> int
{
    n * (n - 1) / 2
}

spec fn sum_range(lo: int, hi: int) -> int
    decreases hi - lo
{
    if lo >= hi { 0 }
    else { sum_range(lo, hi - 1) + hi - 1 }
}",,"fn bubble_sort(a: &mut Vec<i32>) -> (n: usize) 
    ensures n <= n_choose_2(a.len() as int) as usize","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0374,verus,dafnybench,Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_examples_relativeOrder_FindEvenNumbers,,"// All even numbers from arr are in the result

// All numbers in result come from arr  

// Order preservation property","use vstd::prelude::*;

verus! {

spec fn is_even(n: int) -> bool {
    n % 2 == 0
}",,"fn find_even_numbers(arr: &[int]) -> (even_numbers: Vec<int>)
    ensures

        forall|i: int| 0 <= i < arr.len() && is_even(arr[i]) ==> 
            #[trigger] even_numbers@.contains(arr[i]),

        forall|x: int| #[trigger] even_numbers@.contains(x) ==> 
            exists|i: int| 0 <= i < arr.len() && arr[i] == x,

        forall|k: int, l: int| 0 <= k < l < even_numbers.len() ==>
            exists|n: int, m: int| 0 <= n < m < arr.len() && 
                #[trigger] even_numbers[k] == arr[n] && 
                #[trigger] even_numbers[l] == arr[m]","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0377,verus,dafnybench,Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_leetcode_FindPivotIndex_FindPivotIndex,,"/*
https://leetcode.com/problems/find-pivot-index/description/
Given an array of integers nums, calculate the pivot index of this array.

The pivot index is the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the right.

If the index is on the left edge of the array, then the left sum is 0 because there are no elements to the left. This also applies to the right edge of the array.

Return the leftmost pivot index. If no such index exists, return -1.

Example 1:

Input: nums = [1,7,3,6,5,6]
Output: 3
Explanation:
The pivot index is 3.
Left sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11
Right sum = nums[4] + nums[5] = 5 + 6 = 11
Example 2:

Input: nums = [1,2,3]
Output: -1
Explanation:
There is no index that satisfies the conditions in the problem statement.
Example 3:

Input: nums = [2,1,-1]
Output: 0
Explanation:
The pivot index is 0.
Left sum = 0 (no elements to the left of index 0)
Right sum = nums[1] + nums[2] = 1 + -1 = 0

```TypeScript
function pivotIndex(nums: number[]): number {
    const n = nums.length;
    let leftsums = [0], rightsums = [0];
    for(let i=1; i < n+1; i++) {
        leftsums.push(nums[i-1]+leftsums[i-1]);
        rightsums.push(nums[n-i]+rightsums[i-1]);
    }
    for(let i=0; i <= n; i++) {
        if(leftsums[i] == rightsums[n-(i+1)]) return i;
    }
    return -1;
};
```
*/

// By Divyanshu Ranjan

// By Divyanshu Ranjan","use vstd::prelude::*;

verus! {

spec fn sum(nums: Seq<int>) -> int
    decreases nums.len()
{
    if nums.len() == 0 { 
        0 
    } else { 
        sum(nums.subrange(0, nums.len() as int - 1)) + nums[nums.len() - 1]
    }
}

spec fn sum_up(nums: Seq<int>) -> int
    decreases nums.len()
{
    if nums.len() == 0 { 
        0 
    } else { 
        nums[0] + sum_up(nums.subrange(1, nums.len() as int))
    }
}",,"fn find_pivot_index(nums: &Vec<i32>) -> (index: i32)
    requires nums.len() > 0
    ensures 
        index == -1 ==> forall |k: nat| #[trigger] sum(nums@.map_values(|v: i32| v as int).subrange(0, k as int)) != #[trigger] sum(nums@.map_values(|v: i32| v as int).subrange((k + 1) as int, nums@.len() as int)),
        0 <= index < nums.len() ==> sum(nums@.map_values(|v: i32| v as int).subrange(0, index as int)) == sum(nums@.map_values(|v: i32| v as int).subrange((index + 1) as int, nums@.len() as int))","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0378,verus,dafnybench,Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_leetcode_lc-remove-element_removeElement,,//https://leetcode.com/problems/remove-element/,"use vstd::prelude::*;

verus! {",,"fn removeElement(nums: &mut Vec<i32>, val: i32) -> (i: usize)
    ensures forall|k: int| 0 < k < i && k < nums.len() ==> nums[k] != val,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0379,verus,dafnybench,Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_leetcode_validAnagram_isAnagram,,,"use vstd::prelude::*;
use vstd::multiset::*;

verus! {

proof fn to_multiset(s: &str) -> (mset: Multiset<char>)
    ensures mset == s@.to_multiset()
{
    assume(false);
    s@.to_multiset()
}

proof fn mset_equal(s: Multiset<char>, t: Multiset<char>) -> (equal: bool)
    ensures s == t <==> equal
{
    assume(false);
    true
}",,"fn is_anagram(s: &str, t: &str) -> (equal: bool)
    ensures (s@.to_multiset() == t@.to_multiset()) == equal","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0382,verus,dafnybench,Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic_examples_BubbleSort_bubbleSort,,,"use vstd::prelude::*;

verus! {

spec fn sorted(a: Seq<i32>, from: int, to: int) -> bool
    recommends 0 <= from <= to <= a.len()
{
    forall|u: int, v: int| from <= u < v < to ==> a[u] <= a[v]
}

spec fn pivot(a: Seq<i32>, to: int, pvt: int) -> bool
    recommends 0 <= pvt < to <= a.len()
{
    forall|u: int, v: int| 0 <= u < pvt < v < to ==> a[u] <= a[v]
}",,"fn bubbleSort(a: &mut Vec<i32>)
    requires 
        old(a).len() > 0,
    ensures 
        sorted(a@, 0, a.len() as int),
        a@.to_multiset() == old(a)@.to_multiset(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0383,verus,dafnybench,Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic_examples_BubbleSort_sol_bubbleSort,,,"use vstd::prelude::*;

verus! {

spec fn sorted_between(a: &Vec<i32>, from: usize, to: usize) -> bool
    recommends
        from <= to,
        to <= a.len(),
{
    forall|i: int, j: int| from <= i < j < to && 0 <= i < a.len() && 0 <= j < a.len() ==> a@[i] <= a@[j]
}

spec fn sorted(a: &Vec<i32>) -> bool {
    sorted_between(a, 0, a.len())
}",,"fn bubbleSort(a: &mut Vec<i32>)
    requires
        old(a).len() > 0,
    ensures
        sorted(a),
        old(a)@ == a@,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0400,verus,dafnybench,Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_from_dafny_main_repo_dafny2_COST-verif-comp-2011-3-TwoDuplicates_Search,,"// RUN: %testDafnyForEachResolver ""%s"" -- --warn-deprecation:false

/*
Rustan Leino, 5 Oct 2011

COST Verification Competition, Challenge 3: Two equal elements
http://foveoos2011.cost-ic0701.org/verification-competition

Given: An integer array a of length n+2 with n>=2. It is known that at
least two values stored in the array appear twice (i.e., there are at
least two duplets).

Implement and verify a program finding such two values.

You may assume that the array contains values between 0 and n-1.
*/

// Remarks:

// The implementation of method 'Search' takes one pass through the elements of

// the given array.  To keep track of what it has seen, it allocates an array as

// temporary storage--I imagine that this is what the competition designers

// had in mind, since the problem description says one can assume the values

// of the given array to lie in the range 0..n.

// To keep track of whether it already has found one duplicate, the method

// sets the output variables p and q as follows:

//   p != q   - no duplicates found yet

//   p == q   - one duplicate found so far, namely the value stored in p and q

// Note, the loop invariant does not need to say anything about the state

// of two duplicates having been found, because when the second duplicate is

// found, the method returns.

// What needs to be human-trusted about this program is the specification of

// 'Search'.  The specification straightforwardly lists the assumptions stated

// in the problem description, including the given fact that the array contains

// (at least) two distinct elements that each occurs (at least) twice.  To

// trust the specification of 'Search', a human also needs to trust the definition

// of 'IsDuplicate' and its auxiliary function 'IsPrefixDuplicate'.

// About Dafny:

// As always (when it is successful), Dafny verifies that the program does not

// cause any run-time errors (like array index bounds errors), that the program

// terminates, that expressions and functions are well defined, and that all

// specifications are satisfied.  The language prevents type errors by being type

// safe, prevents dangling pointers by not having an ""address-of"" or ""deallocate""

// operation (which is accommodated at run time by a garbage collector), and

// prevents arithmetic overflow errors by using mathematical integers (which

// is accommodated at run time by using BigNum's).  By proving that programs

// terminate, Dafny proves that a program's time usage is finite, which implies

// that the program's space usage is finite too.  However, executing the

// program may fall short of your hopes if you don't have enough time or

// space; that is, the program may run out of space or may fail to terminate in

// your lifetime, because Dafny does not prove that the time or space needed by

// the program matches your execution environment.  The only input fed to

// the Dafny verifier/compiler is the program text below; Dafny then automatically

// verifies and compiles the program (for this program in less than 11 seconds)

// without further human intervention.

// two distinct duplicates exist

// the elements of ""a"" in the range [0.. a.len()-2]","use vstd::prelude::*;

verus! {

uninterp spec fn is_duplicate(a: Seq<int>, p: int) -> bool;

uninterp spec fn is_prefix_duplicate(a: Seq<int>, k: usize, p: int) -> bool;",,"fn search(a: &[i32]) -> (ret: (i32, i32))
    requires 
        4 <= a.len(),
        exists|p: int, q: int| #![auto] p != q && is_duplicate(a@.map(|i, x| x as int), p) && is_duplicate(a@.map(|i, x| x as int), q),
        forall|i: usize| #![auto] 0 <= i < a.len() ==> 0 <= a[i as int] < (a.len() - 2) as int,
    ensures ret.0 != ret.1 && is_duplicate(a@.map(|i, x| x as int), ret.0 as int) && is_duplicate(a@.map(|i, x| x as int), ret.1 as int)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0402,verus,dafnybench,Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_from_dafny_main_repo_dafny2_Classics_FIND,,"// RUN: %testDafnyForEachResolver ""%s"" -- --warn-deprecation:false

// A version of Turing's additive factorial program [Dr. A. Turing, ""Checking a large routine"",

// In ""Report of a Conference of High Speed Automatic Calculating Machines"", pp. 67-69, 1949].

// Hoare's FIND program [C.A.R. Hoare, ""Proof of a program: FIND"", CACM 14(1): 39-45, 1971].

// The proof annotations here are not the same as in Hoare's article.

// In Hoare's words:

//   This program operates on an array A[1:N], and a value of f (1 <= f <= N).

//   Its effect is to rearrange the elements of A in such a way that:

//     forall p,q (1 <= p <= f <= q <= N ==> A[p] <= A[f] <= A[q]).

//

// Here, we use 0-based indices, so we would say:

//   This method operates on an array A[0..N], and a value of f (0 <= f < N).

//   Its effect is to rearrange the elements of A in such a way that:

//     forall p,q :: 0 <= p <= f <= q < N ==> A[p] <= A[f] <= A[q]).","use vstd::prelude::*;

verus! {

spec fn factorial(n: nat) -> nat
    decreases n
{
    if n == 0 { 1 } else { n * factorial(sub(n, 1)) }
}",,"fn find(A: &mut Vec<i32>, N: usize, f: usize)
    requires 
        old(A)@.len() == N,
        f < N,
    ensures
        forall|p: int, q: int| 0 <= p <= f as int <= q < N as int ==> A@[p] <= A@[q],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0417,verus,dafnybench,Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_mathematical_objects_verification_examples_fast_exp_FastExp,,,"use vstd::prelude::*;

verus! {

spec fn sum(s: Seq<int>, i: nat) -> int
    recommends i <= s.len()
    decreases i
{
    if i == 0 { 0 } else { sum(s, (i - 1) as nat) + s[i - 1] }
}

spec fn exp(b: nat, n: nat) -> nat
    decreases n
{
    if n == 0 { 1nat } else { b * exp(b, (n - 1) as nat) }
}

spec fn bits(n: nat) -> Seq<bool>
    decreases n
{
    if n == 0 {
        seq![]
    } else {
        seq![n % 2 != 0].add(bits((n / 2) as nat))
    }
}

spec fn from_bits(s: Seq<bool>) -> nat
    decreases s.len()
{
    if s.len() == 0 {
        0nat
    } else {
        (if s[0] { 1nat } else { 0nat }) + 2nat * from_bits(s.subrange(1, s.len() as int))
    }
}",,"fn fast_exp(b: u32, n: u32) -> (r: u32)
    ensures r == exp(b as nat, n as nat)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0423,verus,dafnybench,Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_verified_algorithms_lol_sort_lol_sort,,"// By `lol sort` here, I refer to a seemingly-broken sorting algorithm,

// which actually somehow manages to work perfectly:

//

// for i in 0..n

//   for j in 0..n

//     if i < j

//       swap a[i], a[j]

//

// It is perhaps the simpliest sorting algorithm to ""memorize"",

// even ""symmetrically beautiful"" as if `i` and `j` just played highly

// similar roles. And technically it's still O(n^2) time lol...

//

// Proving its correctness is tricky (interesting) though.

// Successfully verified with [Dafny 3.3.0.31104] in about 5 seconds.

// We define ""valid permutation"" using multiset:

// This is a swap-based sorting algorithm, so permutedness is trivial:

// note that: if i == j, the spec just says a[..] remains the same.

// We then define ""sorted"" (by increasing order):

// Now, the lol sort algorithm:

// (Some invariants were tricky to find, but Verus was smart enough otherwise)","use vstd::prelude::*;

verus! {

spec fn valid_permut(a: Seq<int>, b: Seq<int>) -> bool
    recommends a.len() == b.len()
{
    a.to_multiset() == b.to_multiset()
}

fn swap(a: &mut Vec<int>, i: usize, j: usize)
    requires 
        i < old(a).len(),
        j < old(a).len(),
    ensures
        a.len() == old(a).len(),
        a@ == old(a)@.update(i as int, old(a)[j as int]).update(j as int, old(a)[i as int]),
        valid_permut(a@, old(a)@),
{
    assume(false);
}

spec fn sorted(a: Seq<int>) -> bool
{
    forall|i: int, j: int| 0 <= i <= j < a.len() ==> a[i] <= a[j]
}",,"fn lol_sort(a: &mut Vec<int>)
    ensures 
        valid_permut(a@, old(a)@),
        sorted(a@),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0424,verus,dafnybench,Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_verified_algorithms_lol_sort_swap,,"// By `lol sort` here, I refer to a seemingly-broken sorting algorithm,

// which actually somehow manages to work perfectly:

//

// for i in 0..n

//   for j in 0..n

//     if i < j

//       swap a[i], a[j]

//

// It is perhaps the simpliest sorting algorithm to ""memorize"",

// even ""symmetrically beautiful"" as if `i` and `j` just played highly

// similar roles. And technically it's still O(n^2) time lol...

//

// Proving its correctness is tricky (interesting) though.

// Successfully verified with Verus

// We define ""valid permutation"" using multiset:

// This is a swap-based sorting algorithm, so permutedness is trivial:

// note that: if i == j, the spec just says a[..] remains the same.

// We then define ""sorted"" (by increasing order):

// Now, the lol sort algorithm:

// (Some invariants were tricky to find, but Verus was smart enough otherwise)","use vstd::prelude::*;

verus! {

spec fn valid_permut(a: Seq<int>, b: Seq<int>) -> bool
    recommends a.len() == b.len()
{
    a.to_multiset() == b.to_multiset()
}

spec fn sorted(a: Seq<int>) -> bool
{
    forall|i: int, j: int| 0 <= i <= j < a.len() ==> a[i] <= a[j]
}",,"fn swap(a: &mut Vec<int>, i: usize, j: usize)
    requires 
        i < old(a).len(),
        j < old(a).len(),
    ensures 
        a.len() == old(a).len(),
        a@ == old(a)@.update(i as int, old(a)@[j as int]).update(j as int, old(a)@[i as int]),
        valid_permut(a@, old(a)@),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0425,verus,dafnybench,Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_04_Hoangkim_ex_04_Hoangkim_intDiv,,"//Problem 01

//problem02

//a)","use vstd::prelude::*;

verus! {",,"fn int_div(n: int, d: int) -> (result: (int, int))
    requires n >= d && n >= 0 && d > 0,
    ensures ({
        let (q, r) = result;
        (d * q) + r == n && 0 <= q <= n / 2 && 0 <= r < d
    })","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0429,verus,dafnybench,Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_05_Hoangkim_ex_05_Hoangkim_gcdI,,"//Problem01

//# 2 pts

//Problem02

//# 3 pts

//Problem03

//# 3 pts

// # sum: 9 pts","use vstd::prelude::*;

verus! {

spec fn fib(n: nat) -> nat
    decreases n
{
    if n < 2 { n } else { fib((n-2) as nat) + fib((n-1) as nat) }
}

spec fn fact(n: nat) -> nat
    decreases n
{
    if n == 0 { 1 } else { n * fact((n-1) as nat) }
}

spec fn gcd(m: nat, n: nat) -> nat
    decreases (m + n)
{
    if m == 0 || n == 0 { 0 }
    else if m == n { m }
    else if m > n { gcd((m - n) as nat, n) }
    else { gcd(m, (n - m) as nat) }
}",,"fn gcd_iterative(m: u32, n: u32) -> (g: u32)
    requires m > 0 && n > 0,
    ensures g == gcd(m as nat, n as nat),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0431,verus,dafnybench,Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_06_Hoangkim_ex_06_hoangkim_gcdI,,"//Problem01

//a)

//b)","use vstd::prelude::*;

verus! {

spec fn gcd(x: int, y: int) -> int
    recommends x > 0 && y > 0
    decreases x + y when x > 0 && y > 0
{
    if x == y { x }
    else if x > y { gcd(x - y, y) }
    else { gcd(x, y - x) }
}

spec fn gcd_prime(x: int, y: int) -> int
    recommends x > 0 && y > 0
    decreases if x > y { x } else { y }, x + y when x > 0 && y > 0
{
    if x == y { x }
    else if x > y { gcd_prime(x - y, y) }
    else { gcd(y, x) }
}",,"fn gcd_i(m: int, n: int) -> (d: int)
    requires m > 0 && n > 0
    ensures d == gcd(m, n)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0432,verus,dafnybench,Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_07_Hoangkim_ex07_Hoangkim_FindMin,,"//Problem01

//a)

//b)

//Problem04

//Problem02

//Problem03","use vstd::prelude::*;

verus! {

spec fn sorted(a: Seq<int>) -> bool {
    forall|i: int| 1 <= i < a.len() ==> #[trigger] a[i] >= a[i-1]
}",,"fn find_min(a: &[int], lo: usize) -> (minIdx: usize)
    requires 
        a.len() > 0,
        lo < a.len(),
    ensures 
        lo <= minIdx < a.len(),
        forall|x: int| lo <= x < a.len() ==> a[minIdx as int] <= a[x],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0433,verus,dafnybench,Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_07_Hoangkim_ex07_Hoangkim_selectionSort,,"//Problem01

//a)

//b)

//Problem04

// dummy return

//Problem02

//ensures multiset(a) == multiset(old(a))

//ensures sorted(a@)

//Problem03","use vstd::prelude::*;

verus! {

fn find_min(a: &[i32], lo: usize) -> (minIdx: usize)
    requires
        a.len() > 0,
        lo < a.len(),
    ensures
        lo <= minIdx < a.len(),
        forall|x: usize| lo <= x < a.len() ==> a[minIdx as int] <= a[x as int],
{
    assume(false);
    lo
}

spec fn sorted(a: Seq<i32>) -> bool {
    forall|i: int| 0 < i < a.len() ==> #[trigger] a[i-1] <= a[i]
}",,fn selection_sort(a: &mut [i32]),"{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0435,verus,dafnybench,Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_10_Hoangkim_ex10_hoangkim_q,,"//Problem01

/*
3 Verification conditions

1. VC1: Precondiotion implies the loop variant
n ∈ ℕ => sqn = 0*0 ∧ i = 0 ∧ x=? ∧ i≤n 
n >= 0 => 0 = 0*0 ∧ i = 0 ∧ i≤n 
n >= 0 => 0 = 0*0 ∧ 0 ≤ n 
2. VC2: Loop invariant and loop guard preserve the loop invariant.
VC2: i < n ∧ i+1 ≤ n ∧ sqn = i * i ⇒ sqn = sqn + x ∧ i = i + 1 ∧ x = 2 * i + 1
3.VC3: Loop terminates, and the loop invariant implies the postcondition.
VC3: ¬(i < n) ∧ i ≤ n ∧ sqn = i * i ⇒ sqn = n * n

Simplified VC for square0
1. true, since 0 = 0 and n >= 0 => 0 ≤ n
2. true, i < n => i + 1 <= n
3. true, ¬(i < n) ∧ i ≤ n ∧ sqn = i * i ⇒ sqn = n * n since ¬(i < n) ∧ i ≤ n imply i = n

*/

//Problem02

//As you can see below, Verus claims that after executing the following function

//strange() we will have that 1=2;

/*(a). Do you have an explanation for this behaviour?
    Answer: 
    the function strange() doesn't have any input or output. This function initializes
    variable x with value 4. Then it calculates variable c as a result of calling
    function 'q' with x as first var and 2*x as second var.the strange function does not 
    specify any postcondition. Therefore, we cannot make any assumptions about the 
    behavior or the value of c after calling q.
    We can change ensures in strange() to false and it's still verified
*/

/*(b)
{
  assume{:axiom} false;
}var x:nat := 4; var c := q(x,2*x); {1 = 2 }
    precond in strange(): difference between 'y' and 'x' muss be greater than 2,
    square from 'z' will be a value  between 'x' and 'y'

    apply the Hoare rules step by step:
    1. {true} as a precondition
    2. we assign 4 to 'x' and having {4=4}
    3. assign value q(x, 2 * x) to c, substitute the postcondition of 'q' in place of 'c'
        post cond of q will be x < z*z < 2*x. Replacing c we having {x < z * z < 2 * x}
    4. we having the statement {x < z*z < 2*x} => {1 = 2} as postcondtion

    as we know the statment {1 = 2} is always false. true => false is always false     

*/

//Problem 3

//Use what you know about the weakest preconditions/strongest postconditions to ex-

//plain why the following code verifies:

/*
WP: is a condition that, if satisfied before the execution of a program, guarantees the 
satisfaction of a specified postcondition
SP: is a condition that must hold after the execution of a program, assuming a specified 
precondition

The strongest postcondition for assert is x<=9
Analyze the code: 
The strongest postcondition for the assert statement assert x <= 9; is x <= 9. This 
postcondition asserts that the value of x should be less than or equal to 9 after the 
execution of the program. To ensure this postcondition, we need to find a weakest precondition 
(WP) that guarantees x <= 9 after executing the code.

The ""assume"" statement introduces a precondition.
It assumes that the square of x is less than 100. In other words, it assumes that x is 
within the range (0, 10) since the largest possible square less than 100 is 9 * 9 = 81.

*/","use vstd::prelude::*;

verus! {",,"fn q(x: u32, y: u32) -> (z: u32)
    requires y - x > 2
    ensures x < z*z < y","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0438,verus,dafnybench,Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_10_Hoangkim_ex10_hoangkim_strange,,"//Problem01

/*
3 Verification conditions

1. VC1: Precondiotion implies the loop variant
n ∈ ℕ => sqn = 0*0 ∧ i = 0 ∧ x=? ∧ i≤n 
n >= 0 => 0 = 0*0 ∧ i = 0 ∧ i≤n 
n >= 0 => 0 = 0*0 ∧ 0 ≤ n 
2. VC2: Loop invariant and loop guard preserve the loop invariant.
VC2: i < n ∧ i+1 ≤ n ∧ sqn = i * i ⇒ sqn = sqn + x ∧ i = i + 1 ∧ x = 2 * i + 1
3.VC3: Loop terminates, and the loop invariant implies the postcondition.
VC3: ¬(i < n) ∧ i ≤ n ∧ sqn = i * i ⇒ sqn = n * n

Simplified VC for square0
1. true, since 0 = 0 and n >= 0 => 0 ≤ n
2. true, i < n => i + 1 <= n
3. true, ¬(i < n) ∧ i ≤ n ∧ sqn = i * i ⇒ sqn = n * n since ¬(i < n) ∧ i ≤ n imply i = n

*/

//Problem02

//As you can see below, Verus claims that after executing the following method

//strange() we will have that 1=2;

/*(a). Do you have an explanation for this behaviour?
    Answer: 
    the method strange() doesn't have any input or output. This method initializes
    variable x with value 4. Then it calculates variable c as a result of calling
    method 'q' with x as first var and 2*x as second var.the strange method does not 
    specify any postcondition. Therefore, we cannot make any assumptions about the 
    behavior or the value of c after calling q.
    We can change ensures in strange() to false and it's still verified
*/

/*(b)
{
  assume{:axiom} false;
}var x:nat := 4; var c := q(x,2*x); {1 = 2 }
    precond in strange(): difference between 'y' and 'x' muss be greater than 2,
    square from 'z' will be a value  between 'x' and 'y'

    apply the Hoare rules step by step:
    1. {true} as a precondition
    2. we assign 4 to 'x' and having {4=4}
    3. assign value q(x, 2 * x) to c, substitute the postcondition of 'q' in place of 'c'
        post cond of q will be x < z*z < 2*x. Replacing c we having {x < z * z < 2 * x}
    4. we having the statement {x < z*z < 2*x} => {1 = 2} as postcondtion

    as we know the statment {1 = 2} is always false. true => false is always false     

*/

//Problem 3

//Use what you know about the weakest preconditions/strongest postconditions to ex-

//plain why the following code verifies:

/*
WP: is a condition that, if satisfied before the execution of a program, guarantees the 
satisfaction of a specified postcondition
SP: is a condition that must hold after the execution of a program, assuming a specified 
precondition

The strongest postcondition for assert is x<=9
Analyze the code: 
The strongest postcondition for the assert statement assert x <= 9; is x <= 9. This 
postcondition asserts that the value of x should be less than or equal to 9 after the 
execution of the program. To ensure this postcondition, we need to find a weakest precondition 
(WP) that guarantees x <= 9 after executing the code.

The ""assume"" statement introduces a precondition.
It assumes that the square of x is less than 100. In other words, it assumes that x is 
within the range (0, 10) since the largest possible square less than 100 is 9 * 9 = 81.

*/","use vstd::prelude::*;

verus! {

fn q(x: u32, y: u32) -> (z: u32)
    requires y > x + 2
    ensures x < z*z && z*z < y
{
    assume(false);
    0
}",,"fn strange()
    ensures 1==2","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0451,verus,dafnybench,SENG2011_tmp_tmpgk5jq85q_ass2_ex1_StringSwap,,"// string == Seq<char>

//give se2011 ass2 ex1.dfy","use vstd::prelude::*;

verus! {",,"fn string_swap(s: Seq<char>, i: nat, j: nat) -> (t: Seq<char>)
    requires 
        i >= 0 && j >= 0 && s.len() >= 0,
        s.len() > 0 ==> i < s.len() && j < s.len(),
    ensures 
        s.to_multiset() == t.to_multiset(),
        s.len() == t.len(),
        s.len() > 0 ==> forall|k: nat| k != i && k != j && k < s.len() ==> t[k as int] == s[k as int],
        s.len() > 0 ==> t[i as int] == s[j as int] && t[j as int] == s[i as int],
        s.len() == 0 ==> t == s,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0452,verus,dafnybench,SENG2011_tmp_tmpgk5jq85q_ass2_ex2_String3Sort,,"// verifies

// check that string between indexes low and high-1 are sorted","use vstd::prelude::*;

verus! {

spec fn sorted(a: Seq<char>, low: int, high: int) -> bool
    recommends 0 <= low <= high <= a.len()
{ 
    forall|j: int, k: int| low <= j < k < high ==> a[j] <= a[k]
}",,"fn string3_sort(a: Seq<char>) -> (b: Seq<char>)
    requires 
        a.len() == 3,
    ensures 
        sorted(b, 0, b.len() as int),
        a.len() == b.len(),
        seq![b[0], b[1], b[2]].to_multiset() == seq![a[0], a[1], a[2]].to_multiset(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0453,verus,dafnybench,SENG2011_tmp_tmpgk5jq85q_ass2_ex3_BadSort,,"// verifies

// all bs are before all as which are before all ds

// all b's are before all a's and d's

// all a's are after all b's

// all a's are before all d's

// all d's are after all b's and a's","use vstd::prelude::*;

verus! {

spec fn sortedbad(s: Seq<char>) -> bool {

    (forall|i: int, j: int| 0 <= i < s.len() && 0 <= j < s.len() && s[i] == 'b' && (s[j] == 'a' || s[j] == 'd') ==> i < j) &&

    (forall|i: int, j: int| 0 <= i < s.len() && 0 <= j < s.len() && s[i] == 'a' && s[j] == 'b' ==> i > j) &&

    (forall|i: int, j: int| 0 <= i < s.len() && 0 <= j < s.len() && s[i] == 'a' && s[j] == 'd' ==> i < j) &&

    (forall|i: int, j: int| 0 <= i < s.len() && 0 <= j < s.len() && s[i] == 'd' && (s[j] == 'a' || s[j] == 'b') ==> i > j)
}",,"fn bad_sort(a: Vec<char>) -> (b: Vec<char>)
    requires
        forall|k: int| 0 <= k < a.len() ==> a[k] == 'b' || a[k] == 'a' || a[k] == 'd',
    ensures
        sortedbad(b@),
        a@.to_multiset() =~= b@.to_multiset(),
        a.len() == b.len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0454,verus,dafnybench,SENG2011_tmp_tmpgk5jq85q_exam_ex2_Getmini,,"// mini is an index of a

// a[mini] is the minimum value

// a[mini] is the first min","use vstd::prelude::*;

verus! {",,"fn get_mini(a: &[i32]) -> (mini: usize)
    requires a.len() > 0,
    ensures 
        0 <= mini < a.len(),
        forall|x: usize| 0 <= x < a.len() ==> a[mini as int] <= a[x as int],
        forall|x: usize| 0 <= x < mini ==> a[mini as int] < a[x as int],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0455,verus,dafnybench,SENG2011_tmp_tmpgk5jq85q_exam_ex3_Symmetric,,,"use vstd::prelude::*;

verus! {",,"fn symmetric(a: &[i32]) -> (flag: bool)
    ensures 
        flag == true ==> forall|x: int| 0 <= x < a.len() ==> #[trigger] a[x] == a[a.len() - x - 1],
        flag == false ==> exists|x: int| #[trigger] a[x] != a[a.len() - x - 1] && 0 <= x < a.len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0456,verus,dafnybench,SENG2011_tmp_tmpgk5jq85q_flex_ex1_sum,,"// sums from index 0 -> i - 1

// returns sum of array","use vstd::prelude::*;

verus! {

spec fn sumcheck(s: &[int], i: int) -> int
    recommends 0 <= i <= s.len()
    decreases i when 0 <= i <= s.len()
{
    if i == 0 { 0 }
    else { s[i as nat - 1] + sumcheck(s, i - 1) }
}",,"#[verifier::exec_allows_no_decreases_clause]
fn sum(s: &[int]) -> (a: int)
    requires s.len() > 0
    ensures sumcheck(s, s.len() as int) == a","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0461,verus,dafnybench,Simulink-To_dafny_tmp_tmpbcuesj2t_Tank_checkRegulation,,"// outlet valve 

// inlet Valve

// outlet valve

// flow in valve v1

// flow in valve v2

// flow in valve v3","use vstd::prelude::*;

verus! {

#[derive(PartialEq, Eq)]
enum Valve {
    ON,
    OFF,
}

struct Pipe {
    v1: Valve,
    v2: Valve,
    v3: Valve,
    in_flowv1: int,
    in_flowv2: int,
    in_flowv3: int,
}

impl Pipe {
    spec fn new() -> Self {
        Pipe {
            v1: Valve::OFF,
            v2: Valve::ON,
            v3: Valve::OFF,
            in_flowv1: 0,
            in_flowv2: 0,
            in_flowv3: 0,
        }
    }
}

struct Tank {
    pipe: Pipe,
    height: int,
}

impl Tank {
    spec fn new() -> Self {
        Tank {
            pipe: Pipe::new(),
            height: 0,
        }
    }
}",,"fn checkRegulation(tank: &mut Tank)
    ensures 
        (tank.height > 10 && tank.pipe.v1 == Valve::OFF && tank.pipe.v3 == Valve::ON && tank.pipe.v2 == old(tank).pipe.v2) 
        || (tank.height < 8 && tank.pipe.v1 == Valve::OFF && tank.pipe.v2 == Valve::ON && tank.pipe.v3 == old(tank).pipe.v3)
        || ((tank.pipe.in_flowv3 > 5 || tank.pipe.in_flowv1 > 5) && tank.pipe.v2 == Valve::OFF && tank.pipe.v3 == old(tank).pipe.v3 && tank.pipe.v1 == old(tank).pipe.v1)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0462,verus,dafnybench,Software-Verification_tmp_tmpv4ueky2d_Best_Time_to_Buy_and_Sell_Stock_best_time_to_buy_and_sell_stock_best_time_to_buy_and_sell_stock,,,"use vstd::prelude::*;

verus! {",,"fn best_time_to_buy_and_sell_stock(prices: &[i32]) -> (max_profit: i32)
    requires 
        1 <= prices.len() <= 100000,
        forall|i: int| 0 <= i < prices.len() ==> #[trigger] prices[i] >= 0 && #[trigger] prices[i] <= 10000,
    ensures 
        forall|i: int, j: int| 0 <= i < j < prices.len() ==> max_profit >= #[trigger] prices[j] - #[trigger] prices[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0463,verus,dafnybench,Software-Verification_tmp_tmpv4ueky2d_Contains_Duplicate_contains_duplicate_contains_duplicate,,,"use vstd::prelude::*;

verus! {

spec fn distinct(nums: Seq<int>) -> bool {
    forall|i: int, j: int| 0 <= i < j < nums.len() ==> nums[i] != nums[j]
}",,"fn contains_duplicate(nums: Seq<int>) -> (result: bool)
    requires
        1 <= nums.len() <= 100000,
        forall|i: int| 0 <= i < nums.len() ==> #[trigger] nums[i] >= -1000000000 && nums[i] <= 1000000000,
    ensures
        result <==> distinct(nums),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0464,verus,dafnybench,Software-Verification_tmp_tmpv4ueky2d_Counting_Bits_counting_bits_counting_bits,,,"use vstd::prelude::*;

verus! {",,"fn counting_bits(n: usize) -> (result: Vec<usize>)
    requires 0 <= n <= 100000
    ensures result.len() == n + 1 &&
            (forall|i: int| 1 <= i < (n + 1) as int ==> 
                #[trigger] result[i as int] == result[(i / 2) as int] + (i % 2) as usize)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0465,verus,dafnybench,Software-Verification_tmp_tmpv4ueky2d_Longest_Increasing_Subsequence_longest_increasing_subsequence_longest_increasing_subsequence,,"// Function

// TODO: modify the ensures clause so that max is indeed equal to the longest increasing subsequence","use vstd::prelude::*;

verus! {

spec fn find_max(x: int, y: int) -> int {
    if x > y { x } else { y }
}",,"fn longest_increasing_subsequence(nums: &Vec<i32>) -> (max: i32)
    requires 
        1 <= nums.len() <= 2500,
        forall|i: int| 0 <= i < nums.len() ==> #[trigger] nums[i] >= -10000 && #[trigger] nums[i] <= 10000,

    ensures 
        max >= 1,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0466,verus,dafnybench,Software-Verification_tmp_tmpv4ueky2d_Non-overlapping_Intervals_non_overlapping_intervals_bubble_sort,,"// Bubble Sort

// Predicates for Bubble Sort","use vstd::prelude::*;

verus! {

spec fn sorted(a: &Vec<(i32, i32)>, l: int, u: int) -> bool {
    forall|i: int, j: int| 0 <= l <= i <= j <= u < a.len() ==> a[i].1 <= a[j].1
}

spec fn partitioned(a: &Vec<(i32, i32)>, i: int) -> bool {
    forall|k: int, k_prime: int| 0 <= k <= i < k_prime < a.len() ==> a[k].1 <= a[k_prime].1
}",,"fn bubble_sort(a: &mut Vec<(i32, i32)>)
    ensures sorted(a, 0, a.len() as int - 1)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0467,verus,dafnybench,Software-Verification_tmp_tmpv4ueky2d_Non-overlapping_Intervals_non_overlapping_intervals_non_overlapping_intervals,,"// Bubble Sort

// Predicates for Bubble Sort

// TODO: modify the ensures clause so that count is indeed equal to the minimum number of intervals we need to remove to make the rest of the intervals non-overlapping.","use vstd::prelude::*;

verus! {

fn bubble_sort(a: &mut Vec<Vec<i32>>)
    requires
        old(a).len() >= 1,
        forall|i: int| 0 <= i < old(a).len() ==> #[trigger] old(a)[i].len() == 2,
    ensures
        a.len() == old(a).len(),
        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i].len() == 2,
        sorted(a, 0, (a.len() - 1) as int),
{
    assume(false);
}

spec fn sorted(a: &Vec<Vec<i32>>, l: int, u: int) -> bool
    recommends
        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i].len() == 2,
{
    forall|i: int, j: int| 0 <= l <= i <= j <= u < a.len() ==> #[trigger] a[i][1] <= #[trigger] a[j][1]
}

spec fn partitioned(a: &Vec<Vec<i32>>, i: int) -> bool
    recommends
        forall|k: int| 0 <= k < a.len() ==> #[trigger] a[k].len() == 2,
{
    forall|k: int, k_prime: int| 0 <= k <= i < k_prime < a.len() ==> #[trigger] a[k][1] <= #[trigger] a[k_prime][1]
}",,"fn non_overlapping_intervals(intervals: &mut Vec<Vec<i32>>) -> (count: i32)
    requires
        1 <= old(intervals).len() <= 100000,
        forall|i: int| 0 <= i < old(intervals).len() ==> #[trigger] old(intervals)[i].len() == 2,
        forall|i: int| 0 <= i < old(intervals).len() ==> -50000 <= #[trigger] old(intervals)[i][0] <= 50000,
        forall|i: int| 0 <= i < old(intervals).len() ==> -50000 <= #[trigger] old(intervals)[i][1] <= 50000,

    ensures
        count >= 0,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0468,verus,dafnybench,Software-Verification_tmp_tmpv4ueky2d_Remove_Duplicates_from_Sorted_Array_remove_duplicates_from_sorted_array_remove_duplicates_from_sorted_array,,// Helper predicate,"use vstd::prelude::*;

verus! {

spec fn is_sorted(nums: Seq<int>) -> bool {
    forall|i: int, j: int| 0 <= i < j < nums.len() ==> nums[i] <= nums[j]
}

spec fn is_sorted_and_distinct(nums: Seq<int>) -> bool {
    forall|i: int, j: int| 0 <= i < j < nums.len() ==> nums[i] < nums[j]
}",,"fn remove_duplicates_from_sorted_array(nums: Seq<int>) -> (result: Seq<int>)
    requires 
        is_sorted(nums),
        1 <= nums.len() <= 30000,
        forall|i: int| #![trigger nums[i]] 0 <= i < nums.len() ==> -100 <= nums[i] <= 100,
    ensures 
        is_sorted_and_distinct(result),
        forall|i: int| #![trigger nums.contains(i)] nums.contains(i) <==> result.contains(i),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0469,verus,dafnybench,Software-Verification_tmp_tmpv4ueky2d_Remove_Element_remove_element_remove_element,,,"use vstd::prelude::*;

verus! {",,"fn remove_element(nums: &mut Vec<i32>, val: i32) -> (i: usize)
    requires 
        old(nums).len() <= 100,
        forall|j: int| 0 <= j < old(nums).len() ==> #[trigger] old(nums)[j] >= 0 && old(nums)[j] <= 50,
        0 <= val <= 100,
    ensures
        forall|j: int| 0 < j < i < nums.len() ==> #[trigger] nums[j] != val,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0472,verus,dafnybench,Software-Verification_tmp_tmpv4ueky2d_Valid_Palindrome_valid_panlindrome_isPalindrome,,,"use vstd::prelude::*;

verus! {",,"fn isPalindrome(s: &Vec<char>) -> (result: bool)
    requires 1 <= s.len() <= 200000,
    ensures result <==> (forall|i: int| 0 <= i < (s.len() as int) / 2 ==> s[i] == s[(s.len() as int) - 1 - i])","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0483,verus,dafnybench,Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula3_maxArrayReverse,,"// 2.

// 3.

// 5.

// 6","use vstd::prelude::*;

verus! {

spec fn fib(n: nat) -> nat
    decreases n
{
    if n == 0 { 1 }
    else if n == 1 { 1 }
    else { fib((n - 1) as nat) + fib((n - 2) as nat) }
}

pub enum List<T> {
    Nil,
    Cons(T, Box<List<T>>),
}

spec fn add(l: List<int>) -> int
    decreases l
{
    match l {
        List::Nil => 0,
        List::Cons(x, xs) => x + add(*xs),
    }
}

spec fn sum(n: nat) -> nat
    decreases n
{
    if n == 0 { 0 } else { n + sum((n - 1) as nat) }
}",,"fn maxArrayReverse(arr: &[i32]) -> (max: i32)
    requires arr.len() > 0
    ensures 
        forall|i: int| 0 <= i < arr.len() ==> arr[i] <= max,
        exists|x: int| 0 <= x < arr.len() && arr[x] == max","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0484,verus,dafnybench,Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula3_sumBackwards,,"// 2.

// 3.

// 5.

// 6","use vstd::prelude::*;

verus! {

spec fn fib(n: nat) -> nat 
    decreases n
{
    if n == 0 { 
        1 
    } else if n == 1 { 
        1 
    } else { 
        fib((n-1) as nat) + fib((n-2) as nat)
    }
}

enum List<T> {
    Nil,
    Cons(T, Box<List<T>>)
}

spec fn add(l: List<int>) -> int 
    decreases l
{
    match l {
        List::Nil => 0,
        List::Cons(x, xs) => x + add(*xs)
    }
}

spec fn sum(n: nat) -> nat 
    decreases n
{
    if n == 0 { 
        0 
    } else { 
        n + sum((n-1) as nat)
    }
}",,"fn sum_backwards(n: u32) -> (r: u32)
    ensures r == sum(n as nat)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0493,verus,dafnybench,Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_handout1_queryFast,,"// 1 a)

// [ai, aj[

// 1 b)

// 1 c)

// a -> [1, 10, 3, −4, 5]

// c -> [0, 1, 11, 14, 10, 15]","use vstd::prelude::*;

verus! {

spec fn sum(a: Seq<int>, i: int, j: int) -> int
    recommends 0 <= i <= j <= a.len()
    decreases j - i
    when 0 <= i <= j <= a.len()
{
    if i == j { 0 }
    else { a[j-1] + sum(a, i, j-1) }
}

spec fn is_prefix_sum_for(a: Seq<int>, c: Seq<int>) -> bool
{
    a.len() + 1 == c.len() && 
    forall|i: int| #![auto] 0 <= i <= a.len() ==> c[i] == sum(a, 0, i)
}",,"fn queryFast(a: Seq<int>, c: Seq<int>, i: int, j: int) -> (r: int)
    requires 0 <= i <= j <= a.len(),
             is_prefix_sum_for(a, c)
    ensures r == sum(a, i, j)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0507,verus,dafnybench,VerifiedMergeSortDafny_tmp_tmpva7qms1b_MergeSort_merge,,,"use vstd::prelude::*;

verus! {

spec fn merged(a1: Seq<int>, a2: Seq<int>, b: &Vec<int>, start: int, end: int) -> bool {
    &&& end - start == a2.len() + a1.len()
    &&& 0 <= start <= end <= b.len()
    &&& a1.to_multiset().add(a2.to_multiset()) == b@.subrange(start, end).to_multiset()
}

spec fn sorted_slice(a: &Vec<int>, start: int, end: int) -> bool {
    &&& 0 <= start <= end <= a.len()
    &&& forall|i: int, j: int| start <= i <= j < end ==> a@[i] <= a@[j]
}

spec fn sorted_seq(a: Seq<int>) -> bool {
    forall|i: int, j: int| 0 <= i <= j < a.len() ==> a[i] <= a[j]
}

spec fn sorted(a: &Vec<int>) -> bool {
    forall|i: int, j: int| 0 <= i < j < a.len() ==> a@[i] <= a@[j]
}",,"fn merge(a1: Seq<int>, a2: Seq<int>, start: int, end: int, b: &mut Vec<int>)
    requires 
        sorted_seq(a1),
        sorted_seq(a2),
        end - start == a1.len() + a2.len(),
        0 <= start < end < a1.len() && end <= a2.len() < old(b).len(),
        end < a1.len() && end < a2.len(),
        old(b).len() == a2.len() + a1.len(),
    ensures 
        sorted_slice(b, start, end),
        merged(a1, a2, b, start, end),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0508,verus,dafnybench,VerifiedMergeSortDafny_tmp_tmpva7qms1b_MergeSort_mergeSimple,,,"use vstd::prelude::*;

verus! {

spec fn merged(a1: Seq<i32>, a2: Seq<i32>, b: &Vec<i32>, start: int, end: int) -> bool {
    &&& end - start == a2.len() + a1.len()
    &&& 0 <= start <= end <= b.len()
    &&& a1.to_multiset().add(a2.to_multiset()) == b@.subrange(start, end).to_multiset()
}

spec fn sorted_slice(a: &Vec<i32>, start: int, end: int) -> bool {
    &&& 0 <= start <= end <= a.len()
    &&& forall|i: int, j: int| start <= i <= j < end ==> a@[i] <= a@[j]
}

spec fn sorted_seq(a: Seq<i32>) -> bool {
    forall|i: int, j: int| 0 <= i <= j < a.len() ==> a[i] <= a[j]
}

spec fn sorted(a: &Vec<i32>) -> bool {
    forall|i: int, j: int| 0 <= i < j < a.len() ==> a@[i] <= a@[j]
}",,"fn mergeSimple(a1: Seq<i32>, a2: Seq<i32>, start: usize, end: usize, b: &mut Vec<i32>)
    requires
        sorted_seq(a1),
        sorted_seq(a2),
        0 <= start <= end <= old(b).len(),
        a1.len() + a2.len() == end - start + 1,
    ensures
        sorted_slice(b, start as int, end as int),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0509,verus,dafnybench,Workshop_tmp_tmp0cu11bdq_Lecture_Answers_max_array_max,,"// http://verifythus.cost-ic0701.org/common-example/arraymax-in-dafny

//max is larger then anything in the array

// Note: exists quantifier syntax may vary in different Verus versions

// ensures exists|j: int| 0 <= j < a.len() && max == a[j], //max is an element in the array","use vstd::prelude::*;

verus! {",,"fn max(a: &[i32]) -> (result: i32)
    requires a.len() > 0
    ensures forall|j: int| 0 <= j < a.len() ==> result >= a[j]","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0515,verus,dafnybench,assertive-programming-assignment-1_tmp_tmp3h_cj44u_FindRange_BinarySearch,,"// all the values in the range satisfy `comparer` (comparer(q[i], key) == true)

// all the values in the range satisfy `!comparer` (comparer(q[i], key) == false)

// comparer is '>' or '>='","use vstd::prelude::*;

verus! {

spec fn sorted(q: Seq<int>) -> bool {
    forall|i: int, j: int| 0 <= i <= j < q.len() ==> q[i] <= q[j]
}

spec fn range_satisfies_comparer(q: Seq<int>, key: int, lower_bound: nat, upper_bound: nat, comparer: spec_fn(int, int) -> bool) -> bool
    recommends 0 <= lower_bound <= upper_bound <= q.len()
{
    forall|i: int| lower_bound <= i < upper_bound ==> comparer(q[i], key)
}

spec fn range_satisfies_comparer_negation(q: Seq<int>, key: int, lower_bound: nat, upper_bound: nat, comparer: spec_fn(int, int) -> bool) -> bool
    recommends 0 <= lower_bound <= upper_bound <= q.len()
{
    range_satisfies_comparer(q, key, lower_bound, upper_bound, |n1, n2| !comparer(n1, n2))
}",,"fn binary_search(q: Seq<int>, key: int, lower_bound: usize, upper_bound: usize, comparer: spec_fn(int, int) -> bool) -> (index: usize)
    requires
        sorted(q),
        0 <= lower_bound <= upper_bound <= q.len(),
        range_satisfies_comparer_negation(q, key, lower_bound as nat, upper_bound as nat, comparer),
        range_satisfies_comparer(q, key, upper_bound as nat, q.len() as nat, comparer),

        (forall|n1: int, n2: int| #[trigger] comparer(n1, n2) ==> comparer(n1, n2) == (n1 > n2)) ||
        (forall|n1: int, n2: int| #[trigger] comparer(n1, n2) ==> comparer(n1, n2) == (n1 >= n2)),

    ensures
        lower_bound <= index <= upper_bound,
        range_satisfies_comparer_negation(q, key, 0nat, index as nat, comparer),
        range_satisfies_comparer(q, key, index as nat, q.len() as nat, comparer),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0516,verus,dafnybench,assertive-programming-assignment-1_tmp_tmp3h_cj44u_FindRange_FindRange,,"// all the values in the range satisfy `comparer` (comparer(q[i], key) == true)

// all the values in the range satisfy `!comparer` (comparer(q[i], key) == false)

// comparer is '>' or '>='","use vstd::prelude::*;

verus! {

spec fn sorted(q: Seq<int>) -> bool {
    forall |i: int, j: int| 0 <= i <= j < q.len() ==> q[i] <= q[j]
}

spec fn range_satisfies_comparer(q: Seq<int>, key: int, lower_bound: int, upper_bound: int, comparer: spec_fn(int, int) -> bool) -> bool
    recommends 0 <= lower_bound <= upper_bound <= q.len()
{
    forall |i: int| lower_bound <= i < upper_bound ==> comparer(q[i], key)
}

spec fn range_satisfies_comparer_negation(q: Seq<int>, key: int, lower_bound: int, upper_bound: int, comparer: spec_fn(int, int) -> bool) -> bool
    recommends 0 <= lower_bound <= upper_bound <= q.len()
{
    range_satisfies_comparer(q, key, lower_bound, upper_bound, |n1: int, n2: int| !comparer(n1, n2))
}

fn binary_search(q: Seq<int>, key: int, lower_bound: usize, upper_bound: usize, comparer: spec_fn(int, int) -> bool) -> (index: usize)
    requires
        sorted(q),
        0 <= lower_bound <= upper_bound <= q.len(),
        range_satisfies_comparer_negation(q, key, 0int, lower_bound as int, comparer),
        range_satisfies_comparer(q, key, upper_bound as int, q.len() as int, comparer),

        (forall |n1: int, n2: int| #[trigger] comparer(n1, n2) == (n1 > n2)) ||
        (forall |n1: int, n2: int| #[trigger] comparer(n1, n2) == (n1 >= n2))
    ensures
        lower_bound <= index <= upper_bound,
        range_satisfies_comparer_negation(q, key, 0int, index as int, comparer),
        range_satisfies_comparer(q, key, index as int, q.len() as int, comparer)
{
    assume(false);
    0
}",,"fn find_range(q: Seq<int>, key: int) -> (res: (usize, usize))
    requires sorted(q)
    ensures
        res.0 <= res.1 <= q.len(),
        forall |i: int| 0 <= i < res.0 ==> q[i] < key,
        forall |i: int| res.0 <= i < res.1 ==> q[i] == key,
        forall |i: int| res.1 <= i < q.len() ==> q[i] > key","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0517,verus,dafnybench,assertive-programming-assignment-1_tmp_tmp3h_cj44u_ProdAndCount_ProdAndCount,,,"use vstd::prelude::*;

verus! {

spec fn recursive_positive_product(q: Seq<int>) -> int
    decreases q.len()
{
    if q.len() == 0 {
        1
    } else if q[0] <= 0 {
        recursive_positive_product(q.subrange(1, q.len() as int))
    } else {
        q[0] * recursive_positive_product(q.subrange(1, q.len() as int))
    }
}

spec fn recursive_count(key: int, q: Seq<int>) -> int
    decreases q.len()
{
    if q.len() == 0 {
        0
    } else if q[q.len() - 1] == key {
        1 + recursive_count(key, q.subrange(0, q.len() as int - 1))
    } else {
        recursive_count(key, q.subrange(0, q.len() as int - 1))
    }
}

spec fn county(elem: int, key: int) -> int {
    if elem == key { 1 } else { 0 }
}

spec fn prody(elem: int) -> int {
    if elem <= 0 { 1 } else { elem }
}",,"fn prod_and_count(q: &[i32], key: i32) -> (result: (i32, u32))
    ensures 
        result.0 == recursive_positive_product(q@.map(|_i, x: i32| x as int)),
        result.1 == recursive_count(key as int, q@.map(|_i, x: i32| x as int)) as u32","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0518,verus,dafnybench,assertive-programming-assignment-1_tmp_tmp3h_cj44u_SearchAddends_FindAddends,,,"use vstd::prelude::*;

verus! {

spec fn sorted(q: Seq<int>) -> bool {
    forall|i: int, j: int| 0 <= i <= j < q.len() ==> q[i] <= q[j]
}

spec fn has_addends(q: Seq<int>, x: int) -> bool {
    exists|i: int, j: int| 0 <= i < j < q.len() && q[i] + q[j] == x
}

spec fn is_valid_index<T>(q: Seq<T>, i: nat) -> bool {
    0 <= i < q.len()
}

spec fn are_ordered_indices<T>(q: Seq<T>, i: nat, j: nat) -> bool {
    0 <= i < j < q.len()
}

spec fn are_addends_indices(q: Seq<int>, x: int, i: nat, j: nat) -> bool
    recommends is_valid_index(q, i) && is_valid_index(q, j)
{
    q[i as int] + q[j as int] == x
}

spec fn has_addends_in_indices_range(q: Seq<int>, x: int, i: nat, j: nat) -> bool
    recommends are_ordered_indices(q, i, j)
{
    has_addends(q.subrange(i as int, (j + 1) as int), x)
}

spec fn loop_inv(q: Seq<int>, x: int, i: nat, j: nat, sum: int) -> bool {
    are_ordered_indices(q, i, j) &&
    has_addends_in_indices_range(q, x, i, j) &&
    are_addends_indices(q, sum, i, j)
}",,"fn find_addends(q: Seq<int>, x: int) -> (result: (usize, usize))
    requires sorted(q) && has_addends(q, x)
    ensures ({
        let (i, j) = result;
        i < j < q.len() && q[i as int] + q[j as int] == x
    })","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0520,verus,dafnybench,bbfny_tmp_tmpw4m0jvl0_enjoying_Find,,// shenanigans going through the dafny tutorial,"use vstd::prelude::*;

verus! {

spec fn max(a: int, b: int) -> int {
    if a > b { a } else { b }
}

fn testing() {
    assume(false);
}

spec fn abs(x: int) -> int {
    if x < 0 { -x } else { x }
}

spec fn fib(n: nat) -> nat
    decreases n
{
    if n == 0 { 0 }
    else if n == 1 { 1 }
    else { fib((n - 1) as nat) + fib((n - 2) as nat) }
}

spec fn sorted(a: &[int]) -> bool {
    forall|j: int, k: int| 0 <= j < k < a.len() ==> a[j] < a[k]
}",,"fn find(a: &[int], key: int) -> (index: i32)
    ensures
        0 <= index ==> index < a.len() && a[index as int] == key,
        index < 0 ==> forall|k: int| 0 <= k < a.len() ==> a[k] != key,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0521,verus,dafnybench,bbfny_tmp_tmpw4m0jvl0_enjoying_FindMax,,// shenanigans going through the dafny tutorial,"use vstd::prelude::*;

verus! {

spec fn max(a: int, b: int) -> int
{
  if a > b { a } else { b }
}
fn testing()
{
  assume(false);
}

spec fn abs(x: int) -> int
{
  if x < 0 { -x } else { x }
}

spec fn fib(n: nat) -> nat
    decreases n
{
  if n == 0 { 0 }
  else if n == 1 { 1 }
  else { fib((n - 1) as nat) + fib((n - 2) as nat) }
}

spec fn sorted(a: &[int]) -> bool
{
  forall|j: int, k: int| 0 <= j < k < a.len() ==> a[j] < a[k]
}",,"fn find_max(a: &[int]) -> (i: usize)
    requires 
        a.len() >= 1
    ensures 
        0 <= i < a.len(),
        forall|k: int| 0 <= k < a.len() ==> a[k] <= a[i as int]","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0532,verus,dafnybench,cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_ArraySum,,"// ASSIGNMENT P1

// CMSC 433 FALL 2023

// PERFECT SCORE:  100 POINTS

//

// This assignment contains nine questions, each of which involves writing Verus

// code. You should include your solutions in a single Verus file and submit it using

// Gradescope.

//

// Revision history

//

// 2023-09-22 2:50 pm   Fixed typo in Problem 3.

// Question 1 (5 points)

//

// Fill in a requires clause that enables Verus to verify

// method PlusOne

// Question 2 (5 points)

//

// Fill in requires clause(s) that enable(s) Verus to verify the array bounds

// in method Swap (which swaps elements i and j in array a).

// Question 3 (5 points)

//

// Give ensures clause(s) asserting that d is the result, and r the

// remainder, of dividing m by n.  Your clauses cannot use ""/"" or ""%"" (which are

// the Verus division and mod operators, respectively). By definition, the

// remainder must be non-negative.

// Question 4 (5 points)

//

// Give ensures clause(s) asserting that the return value has the same

// length as array a and contains as its elements the sum of the

// corresponding elements in arrays a and b.

// TODO

// Question 5 (10 points)

// Euclid's algorithm is used to compute the greatest common divisor of two

// positive integers.  If m and n are two such integers, then gcd(m,n) is the

// largest positve integer that evenly divides both m and n, where j evenly divides i

// if and only if i % j == 0 (% is the Verus mod operator).  Write requires and

// ensures clauses for the method header Euclid below.  Your requires clauses

// should also specify that the first argument is at least as large as the second.

// You do *not* need to implement the method!

// Question 7 (20 points)

//

// Implement, and have Verus verify, the method IsPrime below, which returns true

// if and only if the given positive integer is prime.

// Question 8 (20 points)

//

// Implement, and have Verus verify, the method Reverse below, which returns a new array

// aRev consisting of the elements of a, but in reverse order.  To create a new 

// array of ints use the Verus command ""Vec::new()"", then push elements.

// Question 9 (20 points)

//

// Implement and verify method NoDups, which returns true if and only if there

// are no duplicate elements in array a.  Note that the requires clause allows

// you to assume that a is sorted, and that this precondition is necessary for

// the ensures clause to imply a lack of duplicates.","use vstd::prelude::*;

verus! {",,"fn array_sum(a: &[i32], b: &[i32]) -> (c: Vec<i32>)
    requires a.len() == b.len()
    ensures 
        c.len() == a.len() && 
        forall |i: int| 0 <= i < c.len() ==> c[i] == a[i] + b[i]","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0533,verus,dafnybench,cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_Euclid,,"// ASSIGNMENT P1

// CMSC 433 FALL 2023

// PERFECT SCORE:  100 POINTS

//

// This assignment contains nine questions, each of which involves writing Verus

// code. You should include your solutions in a single Verus file and submit it using

// Gradescope.

//

// Revision history

//

// 2023-09-22 2:50 pm   Fixed typo in Problem 3.

// Question 1 (5 points)

//

// Fill in a requires clause that enables Verus to verify

// method PlusOne

// Question 2 (5 points)

//

// Fill in requires clause(s) that enable(s) Verus to verify the array bounds

// in method Swap (which swaps elements i and j in array a).

// Question 3 (5 points)

//

// Give ensures clause(s) asserting that d is the result, and r the

// remainder, of dividing m by n.  Your clauses cannot use ""/"" or ""%"" (which are

// the Verus division and mod operators, respectively). By definition, the

// remainder must be non-negative.

// Question 4 (5 points)

//

// Give ensures clause(s) asserting that the return value has the same

// length as array a and contains as its elements the sum of the

// corresponding elements in arrays a and b.

// Question 5 (10 points)

// Euclid's algorithm is used to compute the greatest common divisor of two

// positive integers.  If m and n are two such integers, then gcd(m,n) is the

// largest positve integer that evenly divides both m and n, where j evenly divides i

// if and only if i % j == 0 (% is the Verus mod operator).  Write requires and

// ensures clauses for the method header Euclid below.  Your requires clauses

// should also specify that the first argument is at least as large as the second.

// You do *not* need to implement the method!

// TODO

// TODO

// Question 7 (20 points)

//

// Implement, and have Verus verify, the method IsPrime below, which returns true

// if and only if the given positive integer is prime.

// Question 8 (20 points)

//

// Implement, and have Verus verify, the method Reverse below, which returns a new array

// aRev consisting of the elements of a, but in reverse order.  To create a new 

// array of ints use the Verus command ""Vec::with_capacity(...)"", where ""..."" is the number

// of elements in the array.

// Question 9 (20 points)

//

// Implement and verify method NoDups, which returns true if and only if there

// are no duplicate elements in array a.  Note that the requires clause allows

// you to assume that a is sorted, and that this precondition is necessary for

// the ensures clause to imply a lack of duplicates.","use vstd::prelude::*;

verus! {",,"fn euclid(m: int, n: int) -> (gcd: int)
    requires m > 1 && n > 1 && m >= n
    ensures gcd > 0 && gcd <= n && gcd <= m && m % gcd == 0 && n % gcd == 0","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0534,verus,dafnybench,cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_IntDiv,,"// ASSIGNMENT P1

// CMSC 433 FALL 2023

// PERFECT SCORE:  100 POINTS

//

// This assignment contains nine questions, each of which involves writing Verus

// code. You should include your solutions in a single Verus file and submit it using

// Gradescope.

//

// Revision history

//

// 2023-09-22 2:50 pm   Fixed typo in Problem 3.

// Question 1 (5 points)

//

// Fill in a requires clause that enables Verus to verify

// method PlusOne

// Question 2 (5 points)

//

// Fill in requires clause(s) that enable(s) Verus to verify the array bounds

// in method Swap (which swaps elements i and j in array a).

// Question 3 (5 points)

//

// Give ensures clause(s) asserting that d is the result, and r the

// remainder, of dividing m by n.  Your clauses cannot use ""/"" or ""%"" (which are

// the Verus division and mod operators, respectively). By definition, the

// remainder must be non-negative.

// TODO

// Question 4 (5 points)

//

// Give ensures clause(s) asserting that the return value has the same

// length as array a and contains as its elements the sum of the

// corresponding elements in arrays a and b.

// Question 5 (10 points)

// Euclid's algorithm is used to compute the greatest common divisor of two

// positive integers.  If m and n are two such integers, then gcd(m,n) is the

// largest positve integer that evenly divides both m and n, where j evenly divides i

// if and only if i % j == 0 (% is the Verus mod operator).  Write requires and

// ensures clauses for the method header Euclid below.  Your requires clauses

// should also specify that the first argument is at least as large as the second.

// You do *not* need to implement the method!

// Question 7 (20 points)

//

// Implement, and have Verus verify, the method IsPrime below, which returns true

// if and only if the given positive integer is prime.

// Question 8 (20 points)

//

// Implement, and have Verus verify, the method Reverse below, which returns a new array

// aRev consisting of the elements of a, but in reverse order.  To create a new 

// array of ints use the Verus command ""Vec::new()"", where you can build the vector

// with the desired elements.

// Question 9 (20 points)

//

// Implement and verify method NoDups, which returns true if and only if there

// are no duplicate elements in array a.  Note that the requires clause allows

// you to assume that a is sorted, and that this precondition is necessary for

// the ensures clause to imply a lack of duplicates.","use vstd::prelude::*;

verus! {",,"fn IntDiv(m: i32, n: i32) -> (ret: (i32, i32))
    requires n > 0
    ensures m == n * ret.0 + ret.1 && 0 <= ret.1 < n","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0535,verus,dafnybench,cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_IsPrime,,"// ASSIGNMENT P1

// CMSC 433 FALL 2023

// PERFECT SCORE:  100 POINTS

//

// This assignment contains nine questions, each of which involves writing Verus

// code. You should include your solutions in a single Verus file and submit it using

// Gradescope.

//

// Revision history

//

// 2023-09-22 2:50 pm   Fixed typo in Problem 3.

// Question 1 (5 points)

//

// Fill in a requires clause that enables Verus to verify

// method PlusOne

// Question 2 (5 points)

//

// Fill in requires clause(s) that enable(s) Verus to verify the array bounds

// in method Swap (which swaps elements i and j in array a).

// Question 3 (5 points)

//

// Give ensures clause(s) asserting that d is the result, and r the

// remainder, of dividing m by n.  Your clauses cannot use ""/"" or ""%"" (which are

// the Verus division and mod operators, respectively). By definition, the

// remainder must be non-negative.

// Question 4 (5 points)

//

// Give ensures clause(s) asserting that the return value has the same

// length as array a and contains as its elements the sum of the

// corresponding elements in arrays a and b.

// Question 5 (10 points)

// Euclid's algorithm is used to compute the greatest common divisor of two

// positive integers.  If m and n are two such integers, then gcd(m,n) is the

// largest positve integer that evenly divides both m and n, where j evenly divides i

// if and only if i % j == 0 (% is the Verus mod operator).  Write requires and

// ensures clauses for the method header Euclid below.  Your requires clauses

// should also specify that the first argument is at least as large as the second.

// You do *not* need to implement the method!

// Question 7 (20 points)

//

// Implement, and have Verus verify, the method IsPrime below, which returns true

// if and only if the given positive integer is prime.

// m must be greater than 0

// ensures states that ""is_prime is true iff m > 1 && not divisible by [2, m-1)""

// Question 8 (20 points)

//

// Implement, and have Verus verify, the method Reverse below, which returns a new array

// aRev consisting of the elements of a, but in reverse order.  To create a new 

// array of ints use the Verus command ""Vec::new()"", where the vector can be built

// with the appropriate number of elements.

// Question 9 (20 points)

//

// Implement and verify method NoDups, which returns true if and only if there

// are no duplicate elements in array a.  Note that the requires clause allows

// you to assume that a is sorted, and that this precondition is necessary for

// the ensures clause to imply a lack of duplicates.","use vstd::prelude::*;

verus! {",,"fn is_prime(m: i32) -> (result: bool)
    requires m > 0
    ensures result <==> (m > 1 && forall|j: int| 2 <= j < m ==> #[trigger] (m % j as i32) != 0)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0539,verus,dafnybench,cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_Reverse,,"// ASSIGNMENT P1

// CMSC 433 FALL 2023

// PERFECT SCORE:  100 POINTS

//

// This assignment contains nine questions, each of which involves writing Verus

// code. You should include your solutions in a single Verus file and submit it using

// Gradescope.

//

// Revision history

//

// 2023-09-22 2:50 pm   Fixed typo in Problem 3.

// Question 1 (5 points)

//

// Fill in a requires clause that enables Verus to verify

// method PlusOne

// Question 2 (5 points)

//

// Fill in requires clause(s) that enable(s) Verus to verify the array bounds

// in method Swap (which swaps elements i and j in array a).

// Question 3 (5 points)

//

// Give ensures clause(s) asserting that d is the result, and r the

// remainder, of dividing m by n.  Your clauses cannot use ""/"" or ""%"" (which are

// the Verus division and mod operators, respectively). By definition, the

// remainder must be non-negative.

// Question 4 (5 points)

//

// Give ensures clause(s) asserting that the return value has the same

// length as array a and contains as its elements the sum of the

// corresponding elements in arrays a and b.

// Question 5 (10 points)

// Euclid's algorithm is used to compute the greatest common divisor of two

// positive integers.  If m and n are two such integers, then gcd(m,n) is the

// largest positve integer that evenly divides both m and n, where j evenly divides i

// if and only if i % j == 0 (% is the Verus mod operator).  Write requires and

// ensures clauses for the method header Euclid below.  Your requires clauses

// should also specify that the first argument is at least as large as the second.

// You do *not* need to implement the method!

// Question 7 (20 points)

//

// Implement, and have Verus verify, the method IsPrime below, which returns true

// if and only if the given positive integer is prime.

// Question 8 (20 points)

//

// Implement, and have Verus verify, the method Reverse below, which returns a new array

// aRev consisting of the elements of a, but in reverse order.  To create a new 

// array of ints use the Verus command ""Vec::with_capacity(...)"", where ""..."" is the number

// of elements in the array.

// Question 9 (20 points)

//

// Implement and verify method NoDups, which returns true if and only if there

// are no duplicate elements in array a.  Note that the requires clause allows

// you to assume that a is sorted, and that this precondition is necessary for

// the ensures clause to imply a lack of duplicates.","use vstd::prelude::*;

verus! {",,"fn reverse(a: &Vec<i32>) -> (a_rev: Vec<i32>)
    ensures
        a_rev.len() == a.len(),
        forall|i: int| 0 <= i < a.len() ==> a[i] == a_rev[a_rev.len() - i - 1]","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0541,verus,dafnybench,cs245-verification_tmp_tmp0h_nxhqp_A8_Q1_A8Q1,,"// A8Q1 — Steph Renee McIntyre

// Following the solutions from Carmen Bruni

// There is no definition for power, so this function will be used for validating that our imperative program is correct. This is just for Verus.

//function for a to the power of n

/* Proof of implieds can be seen on LEARN.
    Note: If you are unconvinced, putting asserts for each condition will demonstrate the correctness of the statements. 
*/","use vstd::prelude::*;

verus! {

spec fn power(a: int, n: int) -> int
    recommends 0 <= n
    decreases n when 0 <= n
{
    if n <= 0 { 1 } else { a * power(a, n - 1) }
}",,"fn A8Q1(y0: int, x: int) -> (z: int)
    requires y0 >= 0
    ensures z == power(x, y0)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0545,verus,dafnybench,cs245-verification_tmp_tmp0h_nxhqp_SortingIssues_FirstAttempt_sort,,"// Sorting: 

//        Pre/Post Condition Issues - An investigation 

//                                      -- Stephanie McIntyre

// Based on examples in class 

// First Attempt at specifying requirements for sorting array A in incrementing order

// We want our Hoare triple of (|Pre-Condition|) Code (|Post-Condition|) to hold iff A is properly sorted.

// This is always true for usize, but kept for consistency

// This states that A is sorted.

//Can we write code that does not sort A that still satisfies the requirements? 

//Consider the following program:","use vstd::prelude::*;

verus! {",,"fn sort(A: &mut Vec<i32>, n: usize)
    requires 
        n == old(A).len(),
        n >= 0,
    ensures
        forall|i: int, j: int| 0 <= i <= j < n ==> A[i] <= A[j],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0546,verus,dafnybench,cs245-verification_tmp_tmp0h_nxhqp_power_compute_power,,"//power -- Stephanie Renee McIntyre

//Based on the code used in the course overheads for Fall 2018

//There is no definition for power, so this function will be used for validating that our imperative program is correct.

/* Proof of implied (a): Follows from definition of the power function. */

/* Proof of implied (b): Details left as exercise, but this is relatively simple. */

/* Proof of implied (c): Simple substitution and uses the fact that i=n. */

/* Proof of termination: the loop guard gives us the expression i<n. This is equivalent to n-i>=0.
   Prior to the loop, n>=0 and i=0.
   Each iteration of the loop, i increases by 1 and thus n-i decreases by 1. Thus n-i will eventually reach 0.
   When the n-i=0, n=i and thus the loop guard ends the loop as it is no longer the case that i<n.
   Thus the program terminates.
*/

//function for a to the power of n

//Our code from class","use vstd::prelude::*;

verus! {",,"spec fn power(a: int, n: nat) -> int
    recommends 0 <= a
    decreases n
{
    if n == 0 { 1 } else { a * power(a, (n - 1) as nat) }
}

fn compute_power(a: u64, n: u64) -> (s: u64)
    requires n >= 0 && a >= 0
    ensures s as int == power(a as int, n as nat)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0547,verus,dafnybench,cs245-verification_tmp_tmp0h_nxhqp_quicksort-partition_QuicksortPartition,,"// Quicksort Partition -- Stephanie McIntyre

// Based on examples in class 

// Parts have been modified cause you know, arrays are different...

/* The annotations and implied proofs are left for you.
   I might do them later on next week. */

//This says the new X is a permutation of our old version of X.","use vstd::prelude::*;

verus! {",,"fn quicksort_partition(x: &mut Vec<i32>, n: usize, p: i32) -> (result: (usize, usize))
    requires old(x).len() >= 1, n == old(x).len()
    ensures 
        result.1 >= n,
        forall|i: int| 0 <= i < (result.0 as int) && (result.0 as int) < (n as int) ==> x[i] <= p,
        result.0 == n || (forall|i: int| (result.0 as int) <= i && i < (n as int) ==> x[i] > p),
        x@.to_multiset() == old(x)@.to_multiset(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0561,verus,dafnybench,dafl_tmp_tmp_r3_8w3y_dafny_examples_uiowa_binary-search_binSearch,,"///////////////////

// Binary search

///////////////////

// a[lo] <= a[lo+1] <= ... <= a[hi-2] <= a[hi-1]

/* Note: the following definition of is_sorted:

although equivalent to the one above is not enough for Verus to be able 
to prove the invariants for the loop in bin_search.

The given one works because it *explicitly* states that every element 
of the input array is smaller than or equal to all later elements. 
This fact is implied by the alternative definition of is_sorted given 
here (which only talks about array elements and their successors). 
However, it needs to be derived as an auxiliary lemma first, something 
that Verus is not currently able to do automatically. 
*/","use vstd::prelude::*;

verus! {

spec fn is_sorted(a: &[int]) -> bool {
    forall|i: int, j: int| 0 <= i <= j < a.len() ==> a[i] <= a[j]
}",,"fn bin_search(a: &[int], k: int) -> (b: bool)
    requires is_sorted(a)
    ensures b == exists|i: int| 0 <= i < a.len() && a[i] == k","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0562,verus,dafnybench,dafl_tmp_tmp_r3_8w3y_dafny_examples_uiowa_fibonacci_ComputeFib,,"/*
   CS:5810 Formal Methods in Software Engineering
   Fall 2017
   The University of Iowa

   Instructor: Cesare Tinelli

   Credits: Example adapted from Dafny tutorial
*/

//      n = 0, 1, 2, 3, 4, 5, 6,  7,  8, ...

// fib(n) = 0, 1, 1, 2, 3, 5, 8, 13, 21, ...","use vstd::prelude::*;

verus! {

spec fn fib(n: nat) -> nat
    decreases n
{
    if n == 0 { 0 }
    else if n == 1 { 1 }
    else { fib((n - 1) as nat) + fib((n - 2) as nat) }
}",,"fn ComputeFib(n: usize) -> (f: usize)
    ensures f == fib(n as nat)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0563,verus,dafnybench,dafl_tmp_tmp_r3_8w3y_dafny_examples_uiowa_find_Find,,"/*
   CS:5810 Formal Methods in Software Engineering
   Fall 2017
   The University of Iowa

   Instructor: Cesare Tinelli

   Credits: Example adapted from Dafny tutorial
*/

// if i is non-negative then 

// (1) i is smaller than the length of a

// (2) key is at position i in a

// (3) i is the smallest position where key appears

// if index is negative then

// a does not contain key","use vstd::prelude::*;

verus! {",,"fn find(a: &[i32], key: i32) -> (i: i32)
    ensures

        0 <= i ==> (
                    i < a.len() && 

                    a[i as int] == key && 

                    forall|k: int| 0 <= k < i ==> a[k] != key
                   ),

        i < 0 ==> 

                forall|k: int| 0 <= k < a.len() ==> a[k] != key,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0569,verus,dafnybench,dafleet_tmp_tmpa2e4kb9v_0001-0050_0001-two-sum_twoSum,,"/* https://leetcode.com/problems/two-sum/
Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
You can return the answer in any order.

Example 1:
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
*/

// ""you may not use the same element twice""

// We actually make a weaker pre-condition: there exists at least one solution.

// For verification simplicity, we pretend as if:

// - `Seq` were Python list

// - `Map` were Python dict

/* Discussions
1. It may be tempting to append `&& e_to_i[nums[i']] == i'` to the invariant (formula A),
  but this is wrong, because `nums` may contain redundant elements.
  Redundant elements will share the same key in `e_to_i`, the newer overwriting the older.

2. Tip: Generally, we often need invariants when copying data from a container to another.
  To specify a set/map, we often need ""back and forth"" assertions, namely:
  (a) What elements are in the map/set (like in formula A)
  (b) What do elements in the set/map satisfy (like in formula B)
*/","use vstd::prelude::*;

verus! {

spec fn correct_pair(pair: (int, int), nums: Seq<int>, target: int) -> bool {
    let (i, j) = pair;
    &&& 0 <= i < nums.len()
    &&& 0 <= j < nums.len()
    &&& i != j
    &&& nums[i] + nums[j] == target
}

spec fn seq_i32_to_int(s: Seq<i32>) -> Seq<int> {
    s.map(|i, v| v as int)
}",,"fn twoSum(nums: Seq<i32>, target: i32) -> (pair: (usize, usize))
    requires exists|i: int, j: int| correct_pair((i, j), seq_i32_to_int(nums), target as int)
    ensures correct_pair((pair.0 as int, pair.1 as int), seq_i32_to_int(nums), target as int)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0570,verus,dafnybench,dafleet_tmp_tmpa2e4kb9v_0001-0050_0003-longest-substring-without-repeating-characters_lengthOfLongestSubstring,,"/* https://leetcode.com/problems/longest-substring-without-repeating-characters/
Given a string s, find the length of the longest substring without repeating characters.

Example 1:
Input: s = ""abcabcbb""
Output: 3
Explanation: The answer is ""abc"", with the length of 3.
*/

// a left-inclusive right-exclusive interval:

// interval is in valid range

// no repeating characters in interval

// Below shows an efficient solution using standard ""sliding window"" technique. 

// For verification simplicity, we pretend as if:

// - `set` were Python set (or even better, a fixed-size array -- if the ""alphabet"" is small)

//

// `best_iv` is for verification purpose, not returned by the real program, thus `ghost`.

/* Discussions
1. The ""sliding window"" technique is the most ""fancy"" part of the solution,
  ensuring an O(n) time despite the O(n^2) search space.
  The reason why it works lies in the last two invariants: (A) and (B).

  Invariant (A) is simply a ""partial"" guarantee for the longest valid substring in `s[..hi]`,
  so once the loop finishes, as `hi == |s|`, this ""partial"" guarantee becomes ""full"".

  Invariant (B) is crucial: it encodes why we can monotonically increase `lo` as we increase `hi`.
  What's the ""intuition"" behind that? Let me share an ""informal proof"" below:

    Let `sub(i)` be the longest valid substring whose last character is `s[i]`.
    Apparently, the final answer will be ""the longest among the longests"", i.e.
    `max(|sub(0)|, |sub(1)|, ..., |sub(|s|-1)|)`.

    Now, notice that the ""starting position"" of `sub(i)` is monotonically increasing regarding `i`!
    Otherwise, imagine `sub(i+1)` started at `j` while `sub(i)` started at `j+1` (or even worse),
    then `sub(i)` could be made longer (by starting at `j` instead).
    This is an obvious contradiction.

    Therefore, when we search for the starting position of `sub(i)` (the `lo`) for each `i` (the `hi`),
    there's no need to ""look back"".

2. The solution above can be made more efficient, using ""jumping window"" instead of ""sliding window"".
  Namely, we use a dict (instead of set) to look up the ""position of repetition"",
  and move `lo` right after that position at once.

  You can even ""early terminate"" (based on `lo`) when all remaining intervals are doomed ""no longer"",
  resulting in even fewer number of loop iterations.
  (Time complexity will still be O(n), though.)

  The corresponding verification code is shown below:
*/

// For verification simplicity, we pretend as if:

// - `map` were Python dict (or even better, a fixed-size array -- if the ""alphabet"" is small)

// Bonus Question:

//   ""Why can we safely use (C) instead of (D) as the loop condition? Won't `hi` go out-of-bound?""

// Can you figure it out?

// `result.1@` is valid 

// `result.1@` is longest","use vstd::prelude::*;

verus! {

pub struct Interval {
    pub start: int,
    pub end: int,
}

impl Interval {
    pub open spec fn valid(self) -> bool {
        self.start <= self.end
    }
}

pub open spec fn length(iv: Interval) -> int {
    iv.end - iv.start
}

pub open spec fn valid_interval(s: Seq<char>, iv: Interval) -> bool {
    &&& 0 <= iv.start <= iv.end <= s.len()
    &&& forall|i: int, j: int| iv.start <= i < j < iv.end ==> s[i] != s[j]
}",,"fn lengthOfLongestSubstring(s: Seq<char>) -> (result: (usize, Ghost<Interval>))
    ensures 
        (valid_interval(s, result.1@) && length(result.1@) == result.0 as int),
        (forall|iv: Interval| valid_interval(s, iv) ==> length(iv) <= result.0 as int),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0571,verus,dafnybench,dafleet_tmp_tmpa2e4kb9v_0001-0050_0005-longest-palindromic-substring_expand_from_center,,"/* https://leetcode.com/problems/longest-palindromic-substring/
Given a string s, return the longest palindromic substring in s.

Example 1:
Input: s = ""babad""
Output: ""bab""
Explanation: ""aba"" is also a valid answer.
*/

// Specifying the problem: whether `s[i..j]` is palindromic

// A ""common sense"" about palindromes:

// A useful ""helper function"" that returns the longest palindrome at a given center (i0, j0).

// The main algorithm.

// We traverse all centers from left to right, and ""expand"" each of them, to find the longest palindrome.

/* Discussions
1. Dafny is super bad at slicing (esp. nested slicing).
  Do circumvent it whenever possible. It can save you a lot of assertions & lemmas!

  For example, instead of `palindromic(s[i..j])`, use the pattern `palindromic(s, i, j)` instead.
  I didn't realize this (ref: https://github.com/Nangos/dafleet/commit/3302ddd7642240ff2b2f6a8c51e8becd5c9b6437),
  Resulting in a couple of clumsy lemmas.

2. Bonus -- Manacher's algorithm
  Our above solution needs `O(|s|^2)` time in the worst case. Can we improve it? Yes.

  Manacher's algorithm guarantees an `O(|s|)` time.
  To get the intuition, ask yourself: when will it really take `O(|s|^2)` time?
  When there are a lot of ""nesting and overlapping"" palindromes. like in `abcbcbcba` or even `aaaaaa`.

  Imagine each palindrome as a ""mirror"". ""Large mirrors"" reflect ""small mirrors"".
  Therefore, when we ""expand"" from some ""center"", we can ""reuse"" some information from its ""mirrored center"".
  For example, we move the ""center"", from left to right, in the string `aiaOaia...`
  Here, the char `O` is the ""large mirror"".
  When the current center is the second `i`, it is ""mirrored"" to the first `i` (which we've calculated for),
  so we know the palindrome centered at the second `i` must have at least a length of 3 (`aia`).
  So we can expand directly from `aia`, instead of expanding from scratch.

  Manacher's algorithm is verified below.
  Also, I will verify that ""every loop is entered for only `O(|s|)` times"",
  which ""indirectly"" proves that the entire algorithm runs in `O(|s|)` time.
*/

// Below are helper functions and lemmas we used:

// Inserts bogus characters to the original string (e.g. from `abc` to `|a|b|c|`).

// Note that this is neither efficient nor necessary in reality, but just for the ease of understanding.

// Returns (max_index, max_value) of array `a` starting from index `start`.

// Whether an interval at center `c` with a radius `r` is within the boundary of `s'`.

// Whether `r` is a valid palindromic radius at center `c`.

// Whether `r` is the maximal palindromic radius at center `c`.

// Basically, just ""rephrasing"" the `lemma_palindromic_contains`,

// talking about center and radius, instead of interval

// When ""expand from center"" ends, we've find the max radius:

// The critical insight behind Manacher's algorithm.

//

// Given the longest palindrome centered at `c` has length `r`, consider the interval from `c-r` to `c+r`.

// Consider a pair of centers in the interval: `c1` (left half) and `c2` (right half), equally away from `c`.

// Then, the length of longest palindromes at `c1` and `c2` are related as follows:

//, where:

// Transfering our final result on `s'` to that on `s`:

// The following returns whether `s[lo..hi]` is the longest palindrome s.t. `lo + hi == k`:

// Establishes the ""palindromic isomorphism"" between `s` and `s'`.

// Implies that whenever `c + r` is odd, the corresponding palindrome can be ""lengthened for free""

// because its both ends are the bogus char.

// Among all palindromes

// sharing the same center,

// `s[lo..hi]` is longest.","use vstd::prelude::*;

verus! {

spec fn palindromic(s: Seq<char>, i: int, j: int) -> bool
    recommends 0 <= i <= j <= s.len()
    decreases j - i
{
    j - i < 2 || (s[i] == s[j-1] && palindromic(s, i+1, j-1))
}

spec fn insert_bogus_chars(s: Seq<char>, bogus: char) -> Seq<char>
    decreases s.len()
{
    if s.len() == 0 {
        seq![bogus]
    } else {
        let s_old = insert_bogus_chars(s.drop_first(), bogus);
        seq![bogus].add(seq![s[0]]).add(s_old)
    }
}

fn argmax(a: Vec<i32>, start: usize) -> (result: (usize, i32))
    requires 0 <= start < a.len()
    ensures ({
        let (idx, val) = result;
        &&& start <= idx < a.len()
        &&& a@[idx as int] == val
        &&& forall|i: int| start <= i < a.len() ==> a@[i] <= val
    })
    decreases a.len() - start
{
    assume(false);
    unreached()
}

spec fn inbound_radius(s_prime: Seq<char>, c: int, r: int) -> bool {
    r >= 0 && 0 <= c-r && c+r < s_prime.len()
}

spec fn palindromic_radius(s_prime: Seq<char>, c: int, r: int) -> bool
    recommends inbound_radius(s_prime, c, r)
{
    palindromic(s_prime, c-r, c+r+1)
}

spec fn max_radius(s_prime: Seq<char>, c: int, r: int) -> bool {
    &&& inbound_radius(s_prime, c, r)
    &&& palindromic_radius(s_prime, c, r)
    &&& forall|r_prime: int| r_prime > r && inbound_radius(s_prime, c, r_prime) ==> !palindromic_radius(s_prime, c, r_prime)
}

spec fn abs(x: int) -> int {
    if x >= 0 { x } else { -x }
}

spec fn max_interval_for_same_center(s: Seq<char>, k: int, lo: int, hi: int) -> bool {
    &&& 0 <= lo <= hi <= s.len()
    &&& lo + hi == k
    &&& palindromic(s, lo, hi)
    &&& forall|i: int, j: int| 0 <= i <= j <= s.len() && palindromic(s, i, j) && i + j == k ==> j - i <= hi - lo
}",,"fn expand_from_center(s: Seq<char>, i0: usize, j0: usize) -> (result: (usize, usize))
    requires 0 <= i0 <= j0 <= s.len(),
             palindromic(s, i0 as int, j0 as int)
    ensures 
        ({
            let (lo, hi) = result;
            &&& 0 <= lo <= hi <= s.len()
            &&& palindromic(s, lo as int, hi as int)
            &&& forall|i: int, j: int| 0 <= i <= j <= s.len() && palindromic(s, i, j)
              && i + j == i0 + j0
              ==> j - i <= hi - lo
        })","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,0.7
VD0572,verus,dafnybench,dafleet_tmp_tmpa2e4kb9v_0001-0050_0005-longest-palindromic-substring_longestPalindrome,,"/* https://leetcode.com/problems/longest-palindromic-substring/
Given a string s, return the longest palindromic substring in s.

Example 1:
Input: s = ""babad""
Output: ""bab""
Explanation: ""aba"" is also a valid answer.
*/

// Specifying the problem: whether `s[i..j]` is palindromic

// A ""common sense"" about palindromes:

// A useful ""helper function"" that returns the longest palindrome at a given center (i0, j0).

// The main algorithm.

// We traverse all centers from left to right, and ""expand"" each of them, to find the longest palindrome.

/* Discussions
1. Dafny is super bad at slicing (esp. nested slicing).
  Do circumvent it whenever possible. It can save you a lot of assertions & lemmas!

  For example, instead of `palindromic(s[i..j])`, use the pattern `palindromic(s, i, j)` instead.
  I didn't realize this (ref: https://github.com/Nangos/dafleet/commit/3302ddd7642240ff2b2f6a8c51e8becd5c9b6437),
  Resulting in a couple of clumsy lemmas.

2. Bonus -- Manacher's algorithm
  Our above solution needs `O(|s|^2)` time in the worst case. Can we improve it? Yes.

  Manacher's algorithm guarantees an `O(|s|)` time.
  To get the intuition, ask yourself: when will it really take `O(|s|^2)` time?
  When there are a lot of ""nesting and overlapping"" palindromes. like in `abcbcbcba` or even `aaaaaa`.

  Imagine each palindrome as a ""mirror"". ""Large mirrors"" reflect ""small mirrors"".
  Therefore, when we ""expand"" from some ""center"", we can ""reuse"" some information from its ""mirrored center"".
  For example, we move the ""center"", from left to right, in the string `aiaOaia...`
  Here, the char `O` is the ""large mirror"".
  When the current center is the second `i`, it is ""mirrored"" to the first `i` (which we've calculated for),
  so we know the palindrome centered at the second `i` must have at least a length of 3 (`aia`).
  So we can expand directly from `aia`, instead of expanding from scratch.

  Manacher's algorithm is verified below.
  Also, I will verify that ""every loop is entered for only `O(|s|)` times"",
  which ""indirectly"" proves that the entire algorithm runs in `O(|s|)` time.
*/

// A reference implementation of Manacher's algorithm:

// (Ref. https://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher's_algorithm) for details...

// Below are helper functions and lemmas we used:

// Inserts bogus characters to the original string (e.g. from `abc` to `|a|b|c|`).

// Note that this is neither efficient nor necessary in reality, but just for the ease of understanding.

// Returns (max_index, max_value) of array `a` starting from index `start`.

// Whether an interval at center `c` with a radius `r` is within the boundary of `s'`.

// Whether `r` is a valid palindromic radius at center `c`.

// Whether `r` is the maximal palindromic radius at center `c`.

// Basically, just ""rephrasing"" the `lemma_palindromic_contains`,

// talking about center and radius, instead of interval

// When ""expand from center"" ends, we've find the max radius:

// The critical insight behind Manacher's algorithm.

//

// Given the longest palindrome centered at `c` has length `r`, consider the interval from `c-r` to `c+r`.

// Consider a pair of centers in the interval: `c1` (left half) and `c2` (right half), equally away from `c`.

// Then, the length of longest palindromes at `c1` and `c2` are related as follows:

//, where:

// Transfering our final result on `s'` to that on `s`:

// The following returns whether `s[lo..hi]` is the longest palindrome s.t. `lo + hi == k`:

// Establishes the ""palindromic isomorphism"" between `s` and `s'`.

// Implies that whenever `c + r` is odd, the corresponding palindrome can be ""lengthened for free""

// because its both ends are the bogus char.

// `ans` is indeed a substring in `s`

// `ans` is palindromic

// `ans` is longest","use vstd::prelude::*;

verus! {

spec fn palindromic(s: Seq<char>, i: int, j: int) -> bool
    recommends 0 <= i <= j <= s.len()
    decreases j - i
{
    j - i < 2 || (s[i] == s[j-1] && palindromic(s, i+1, j-1))
}

fn expand_from_center(s: Seq<char>, i0: usize, j0: usize) -> (res: (usize, usize))
    requires 
        0 <= i0 <= j0 <= s.len(),
        palindromic(s, i0 as int, j0 as int),
    ensures 
        res.0 <= res.1 <= s.len(),
        palindromic(s, res.0 as int, res.1 as int),
        forall|i: int, j: int| 0 <= i <= j <= s.len() && palindromic(s, i, j)  
            && i + j == i0 + j0 ==> j - i <= res.1 - res.0,
{
    assume(false);
    (0, 0)
}

spec fn insert_bogus_chars(s: Seq<char>, bogus: char) -> (s_prime: Seq<char>)
    decreases s.len()
{
    if s.len() == 0 {
        seq![bogus]
    } else {
        let s_prime_old = insert_bogus_chars(s.subrange(1, s.len() as int), bogus);
        let s_prime_new = seq![bogus].add(seq![s[0]]).add(s_prime_old);
        s_prime_new
    }
}

fn argmax(a: &Vec<i32>, start: usize) -> (res: (usize, i32))
    requires 0 <= start < a.len()
    ensures 
        start <= res.0 < a.len() && a[res.0 as int] == res.1,
        forall|i: int| start <= i < a.len() ==> a[i] <= res.1,
    decreases a.len() - start
{
    assume(false);
    unreached()
}

spec fn inbound_radius(s_prime: Seq<char>, c: int, r: int) -> bool
{
    r >= 0 && 0 <= c-r && c+r < s_prime.len()
}

spec fn palindromic_radius(s_prime: Seq<char>, c: int, r: int) -> bool
    recommends inbound_radius(s_prime, c, r)
{
    palindromic(s_prime, c-r, c+r+1)
}

spec fn max_radius(s_prime: Seq<char>, c: int, r: int) -> bool
{
    inbound_radius(s_prime, c, r)
    && palindromic_radius(s_prime, c, r)
    && (forall|r_prime: int| r_prime > r && inbound_radius(s_prime, c, r_prime) ==> !palindromic_radius(s_prime, c, r_prime))
}

spec fn abs(x: int) -> int {
    if x >= 0 { x } else { -x }
}

spec fn max_interval_for_same_center(s: Seq<char>, k: int, lo: int, hi: int) -> bool {
    0 <= lo <= hi <= s.len()
    && lo + hi == k
    && palindromic(s, lo, hi)
    && (forall|i: int, j: int| 0 <= i <= j <= s.len() && palindromic(s, i, j) && i + j == k ==> j - i <= hi - lo)
}",,"fn longestPalindrome(s: Vec<char>) -> (ans: (Vec<char>, usize, usize))
    ensures 
        0 <= ans.1 <= ans.2 <= s.len(),
        ans.0@ == s@.subrange(ans.1 as int, ans.2 as int),
        palindromic(s@, ans.1 as int, ans.2 as int),
        forall|i: int, j: int| 0 <= i <= j <= s.len() && palindromic(s@, i, j) ==> j - i <= ans.2 - ans.1,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0573,verus,dafnybench,dafny-duck_tmp_tmplawbgxjo_ex3_BadSort,,"// program verifies

// no b's after non-b's

// only non-d's before d's","use vstd::prelude::*;

verus! {

spec fn sortedbad(s: Seq<char>) -> bool {

    (forall|i: int, j: int| 0 <= i <= j < s.len() && s[i] == 'b' && s[j] != 'b' ==> i < j) &&

    (forall|i: int, j: int| 0 <= i <= j < s.len() && s[i] != 'd' && s[j] == 'd' ==> i < j)
}",,"fn bad_sort(a: Seq<char>) -> (b: Seq<char>)
    requires 
        forall|i: int| 0 <= i < a.len() ==> a[i] == 'b' || a[i] == 'a' || a[i] == 'd',
    ensures 
        sortedbad(b) && b.to_multiset() == a.to_multiset(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0574,verus,dafnybench,dafny-duck_tmp_tmplawbgxjo_p1_SumArray,,"// Given an array of integers, it returns the sum. [1,3,3,2]->9","use vstd::prelude::*;

verus! {

spec fn sum(xs: Seq<i32>) -> int
    decreases xs.len()
{
    if xs.len() == 0 {
        0int
    } else {
        sum(xs.subrange(0, xs.len() - 1)) + xs[xs.len() - 1] as int
    }
}",,"fn sum_array(xs: &[i32]) -> (s: i32)
    ensures s as int == sum(xs@)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0577,verus,dafnybench,dafny-duck_tmp_tmplawbgxjo_p4_single,,"//Given two arrays of integers, it returns a single array with all integers merged. 

// [1,5,2,3],[4,3,5]->[1,5,2,3,4,3,5]","use vstd::prelude::*;

verus! {",,"fn single(x: &[i32], y: &[i32]) -> (b: Vec<i32>)
    requires 
        x.len() > 0,
        y.len() > 0,
    ensures 
        b@.len() == x@.len() + y@.len(),
        b@ == x@ + y@,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0578,verus,dafnybench,dafny-duck_tmp_tmplawbgxjo_p6_FilterVowelsArray,,"// Given an array of characters, it filters all the vowels. ['d','e','l','i','g','h','t']-> ['e','i']","use vstd::prelude::*;

verus! {

spec fn vowels() -> Set<char> {
    set!['a', 'e', 'i', 'o', 'u']
}

spec fn filter_vowels(xs: Seq<char>) -> Seq<char>
    decreases xs.len()
{
    if xs.len() == 0 {
        seq![]
    } else if vowels().contains(xs[xs.len() - 1]) {
        filter_vowels(xs.subrange(0, xs.len() - 1)).add(seq![xs[xs.len() - 1]])
    } else {
        filter_vowels(xs.subrange(0, xs.len() - 1))
    }
}",,"fn filter_vowels_array(xs: &[char]) -> (ys: Vec<char>)
    ensures filter_vowels(xs@) == ys@","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0579,verus,dafnybench,dafny-exercise_tmp_tmpouftptir_absIt_AbsIt,,,"use vstd::prelude::*;

verus! {",,"fn abs_it(s: &mut Vec<i32>)
    ensures
        s.len() == old(s).len(),
        forall|i: int| 0 <= i < s.len() ==> 
            if old(s)[i] < 0 { s[i] == -old(s)[i] } else { s[i] == old(s)[i] }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0580,verus,dafnybench,dafny-exercise_tmp_tmpouftptir_appendArray_appendArray,,,"use vstd::prelude::*;

verus! {",,"fn append_array(a: &[i32], b: &[i32]) -> (c: Vec<i32>)
    ensures 
        c.len() == a.len() + b.len(),
        forall|i: int| 0 <= i < a.len() ==> a[i] == c[i],
        forall|i: int| 0 <= i < b.len() ==> b[i] == c[a.len() + i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0581,verus,dafnybench,dafny-exercise_tmp_tmpouftptir_countNeg_CountNeg,,,"use vstd::prelude::*;

verus! {

spec fn verify_neg(a: &[int], idx: int) -> nat
    decreases idx
{
    if idx <= 0 {
        0nat
    } else {
        verify_neg(a, idx - 1) + (if a[idx - 1] < 0 { 1nat } else { 0nat })
    }
}",,"fn count_neg(a: &[int]) -> (cnt: usize)
    ensures cnt == verify_neg(a, a.len() as int)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0582,verus,dafnybench,dafny-exercise_tmp_tmpouftptir_filter_Filter,,,"use vstd::prelude::*;

verus! {",,"fn filter(a: Seq<char>, b: Set<char>) -> (c: Set<char>)
    ensures forall|x: char| a.contains(x) && b.contains(x) <==> c.contains(x)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0583,verus,dafnybench,dafny-exercise_tmp_tmpouftptir_firstE_firstE,,,"use vstd::prelude::*;

verus! {",,"fn firstE(a: &[char]) -> (x: i32)
    ensures
        if a@.contains('e') {
            0 <= x < a@.len() && a@[x as int] == 'e' && 
            forall|i: int| 0 <= i < x ==> a@[i] != 'e'
        } else {
            x == -1
        }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0586,verus,dafnybench,dafny-exercise_tmp_tmpouftptir_prac3_ex2_GetEven,,,"use vstd::prelude::*;

verus! {",,"fn get_even(s: &mut Vec<nat>)
    ensures 
        s.len() == old(s).len(),
        forall|i: int| 0 <= i < s.len() ==> {
            if old(s)[i] % 2 == 1 {
                s[i] == old(s)[i] + 1
            } else {
                s[i] == old(s)[i]
            }
        }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0587,verus,dafnybench,dafny-exercise_tmp_tmpouftptir_prac4_ex2_GetTriple,,,"use vstd::prelude::*;

verus! {

spec fn triple(a: &[int]) -> bool {
    exists|i: int| 0 <= i < a.len() - 2 && #[trigger] a[i] == a[i + 1] && a[i + 1] == a[i + 2]
}",,"fn get_triple(a: &[int]) -> (index: usize)
ensures 
    (0 <= index < a.len() - 1) || index == a.len(),
    index == a.len() <==> !triple(a),
    (0 <= index < a.len() - 1) <==> triple(a),
    (0 <= index < a.len() - 1) ==> a[index as int] == a[index as int + 1] && a[index as int + 1] == a[index as int + 2]","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0588,verus,dafnybench,dafny-exercise_tmp_tmpouftptir_reverse_Reverse,,,"use vstd::prelude::*;

verus! {",,"fn reverse(a: &Vec<char>) -> (b: Vec<char>)
    requires 
        a.len() > 0,
    ensures 
        b.len() == a.len(),
        forall|i: int| 0 <= i < a.len() ==> b[i] == a[a.len() - i - 1],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVD03,0.85
VD0589,verus,dafnybench,dafny-exercise_tmp_tmpouftptir_zapNegatives_ZapNegatives,,,"use vstd::prelude::*;

verus! {",,"fn zap_negatives(a: &mut Vec<i32>)
    ensures 
        a.len() == old(a).len(),
        forall|i: int| 0 <= i < a.len() ==> 
            if old(a)[i] < 0 { a[i] == 0 } 
            else { a[i] == old(a)[i] }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0590,verus,dafnybench,dafny-exercises_tmp_tmp5mvrowrx_leetcode_26-remove-duplicates-from-sorted-array_RemoveDuplicates,,,"use vstd::prelude::*;

verus! {",,"fn remove_duplicates(nums: &mut Vec<i32>) -> (num_length: usize)
    requires
        forall|i: int, j: int| 0 <= i < j < old(nums).len() ==> old(nums)[i] <= old(nums)[j],
    ensures
        nums.len() == old(nums).len(),
        0 <= num_length <= nums.len(),
        forall|i: int, j: int| 0 <= i < j < num_length ==> nums[i] != nums[j],
        forall|i: int| 0 <= i < num_length ==> old(nums)@.contains(nums[i]),
        forall|i: int| 0 <= i < old(nums).len() ==> nums@.subrange(0, num_length as int).contains(old(nums)[i]),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0594,verus,dafnybench,dafny-language-server_tmp_tmpkir0kenl_Test_VSComp2010_Problem1-SumMax_M,,"// VSComp 2010, problem 1, compute the sum and max of the elements of an array and prove

// that 'sum <= N * max'.

// Rustan Leino, 18 August 2010.

//

// The problem statement gave the pseudo-code for the method, but did not ask to prove

// that 'sum' or 'max' return as the sum and max, respectively, of the array.  The

// given assumption that the array's elements are non-negative is not needed to establish

// the requested postcondition.","use vstd::prelude::*;

verus! {",,"fn M(N: i32, a: &[i32]) -> (result: (i32, i32))
    requires 
        0 <= N,
        a.len() == N,
        (forall|k: int| 0 <= k && k < N ==> 0 <= a[k]),
    ensures 
        result.0 <= N * result.1,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0598,verus,dafnybench,dafny-language-server_tmp_tmpkir0kenl_Test_comp_Arrays_LinearSearch,,"// RUN: %verus ""%s"" > ""%t""

// RUN: %diff ""%s.expect"" ""%t""

// In Verus, we'd use refinement types or Ghost wrappers for constraints

// Main function content would go here","use vstd::prelude::*;

verus! {

fn print_array<A>(a: Option<&[A]>) {
    assume(false);
}

type Lowercase = char;

fn diag_matrix<A: Copy>(rows: usize, cols: usize, zero: A, one: A) -> (a: Vec<Vec<A>>)
    requires rows >= 0 && cols >= 0
{
    assume(false);
    Vec::new()
}

fn print_matrix<A>(m: &Vec<Vec<A>>) {
    assume(false);
}",,"fn linear_search(a: &[int], key: int) -> (n: usize)
    ensures 
        0 <= n <= a.len(),
        n == a.len() || a[n as int] == key,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0604,verus,dafnybench,dafny-language-server_tmp_tmpkir0kenl_Test_dafny2_SegmentSum_MaxSegSum,,"// RUN: %verus ""%s""","use vstd::prelude::*;

verus! {

spec fn sum(a: Seq<int>, s: int, t: int) -> int
    recommends 0 <= s <= t <= a.len()
    decreases t - s when 0 <= s <= t <= a.len()
{
    if s == t { 0 } else { sum(a, s, t-1) + a[t-1] }
}",,"fn max_seg_sum(a: &Vec<int>) -> (result: (usize, usize))
    ensures ({
        let (k, m) = result;
        &&& k <= m <= a.len()
        &&& forall |p: int, q: int| 0 <= p <= q <= a.len() ==> 
            sum(a@, p, q) <= sum(a@, k as int, m as int)
    })","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0606,verus,dafnybench,dafny-language-server_tmp_tmpkir0kenl_Test_dafny2_TuringFactorial_ComputeFactorial,,,"use vstd::prelude::*;

verus! {

spec fn factorial(n: nat) -> nat
    decreases n
{
    if n == 0 { 1 } else { n * factorial((n - 1) as nat) }
}",,"fn compute_factorial(n: i32) -> (u: i32)
    requires 1 <= n,
    ensures u == factorial(n as nat),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0607,verus,dafnybench,dafny-language-server_tmp_tmpkir0kenl_Test_dafny4_Bug165_Select,,// Using generic type parameter with uninterpreted body,"use vstd::prelude::*;

verus! {

uninterp spec fn f<T>(a: T) -> bool;",,"fn select<T>(s1: Seq<T>) -> (r: Seq<T>)
    ensures
        forall|e: T| f(e) ==> s1.to_multiset().count(e) == r.to_multiset().count(e),
        forall|e: T| !f(e) ==> r.to_multiset().count(e) == 0","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0611,verus,dafnybench,dafny-language-server_tmp_tmpkir0kenl_Test_tutorial_maximum_Maximum,,"// This file shows how to specify and implement a function to compute the

// largest element of a list. The function is fully specified by two

// preconditions, as proved by the MaximumIsUnique lemma below.","use vstd::prelude::*;

verus! {",,"fn maximum(values: Seq<int>) -> (max: int)
    requires
        values.len() > 0,
    ensures
        values.contains(max),
        forall|i: int| 0 <= i < values.len() ==> values[i] <= max,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0617,verus,dafnybench,dafny-language-server_tmp_tmpkir0kenl_Test_vstte2012_Two-Way-Sort_two_way_sort,,"// This method is a slight generalization of the

// code provided in the problem statement since it

// is generic in the type of the array elements.

// This method is a direct translation of the pseudo

// code given in the problem statement.

// The first postcondition expresses that the resulting

// array is sorted, that is, all occurrences of ""false""

// come before all occurrences of ""true"".

// The second postcondition expresses that the post-state

// array is a permutation of the pre-state array. To express

// this, we use Verus's built-in multisets. The built-in

// function ""multisets"" takes a sequence and yields the

// multiset of the sequence elements.

// Note that Verus guesses a suitable ranking function

// for the termination proof of the while loop.

// We use the loop guard from the given pseudo-code.  However,

// the program also verifies with the stronger guard ""i < j""

// (without changing any of the other specifications or

// annotations).","use vstd::prelude::*;
use vstd::multiset::Multiset;

verus! {

spec fn multisets<T>(s: Seq<T>) -> Multiset<T>
    decreases s.len(),
{
    if s.len() == 0 { 
        Multiset::empty() 
    } else { 
        Multiset::singleton(s[0]).add(multisets(s.subrange(1, s.len() as int)))
    }
}

fn swap<T>(a: &mut Vec<T>, i: usize, j: usize)
    requires 
        i < j < old(a).len(),
    ensures 
        a[i as int] == old(a)[j as int],
        a[j as int] == old(a)[i as int],
        forall|m: int| 0 <= m < a.len() && m != i && m != j ==> a[m] == old(a)[m],
        multisets(a@) == multisets(old(a)@),
{
    assume(false);
}",,"fn two_way_sort(a: &mut Vec<bool>)
    ensures 
        forall|m: int, n: int| 0 <= m < n < a.len() ==> (!a[m] || a[n]),
        multisets(a@) == multisets(old(a)@),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0634,verus,dafnybench,dafny-programs_tmp_tmpcwodh6qh_src_expt_expt,,,"use vstd::prelude::*;

verus! {

spec fn expt(b: int, n: nat) -> int
    decreases n
{
    if n == 0 { 1 } else { b * expt(b, (n - 1) as nat) }
}",,"fn expt_method(b: i32, n: u32) -> (res: i32)
    ensures res == expt(b as int, n as nat)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0635,verus,dafnybench,dafny-programs_tmp_tmpcwodh6qh_src_factorial_factorial,,// to prevent overflow,"use vstd::prelude::*;

verus! {

spec fn fact(n: nat) -> nat 
    decreases n
{
    if n == 0 { 1 } else { n * fact((n - 1) as nat) }
}",,"fn factorial(n: u32) -> (res: u32)
    requires n <= 12
    ensures res == fact(n as nat)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0643,verus,dafnybench,dafny-synthesis_task_id_2_SharedElements,,"// All elements in the output are in both a and b

// The elements in the output are all different","use vstd::prelude::*;

verus! {

spec fn in_array(a: &[i32], x: i32) -> bool {
    exists|i: int| 0 <= i < a.len() && a[i] == x
}",,"fn shared_elements(a: &[i32], b: &[i32]) -> (result: Vec<i32>)
    ensures

        forall|x: i32| result@.contains(x) ==> (in_array(a, x) && in_array(b, x)),

        forall|i: int, j: int| 0 <= i < j < result.len() ==> result[i] != result[j]","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0644,verus,dafnybench,dafny-synthesis_task_id_3_IsNonPrime,,,"use vstd::prelude::*;

verus! {",,"fn is_non_prime(n: int) -> (result: bool)
    requires n >= 2
    ensures result <==> (exists|k: int| 2 <= k < n && #[trigger] (n % k) == 0)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0646,verus,dafnybench,dafny-synthesis_task_id_14_TriangularPrismVolume,,,"use vstd::prelude::*;

verus! {",,"fn triangular_prism_volume(base: u32, height: u32, length: u32) -> (volume: u32)
    requires 
        base > 0,
        height > 0,
        length > 0,
    ensures volume == (base * height * length) / 2,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0648,verus,dafnybench,dafny-synthesis_task_id_18_RemoveChars,,,"use vstd::prelude::*;

verus! {",,"fn remove_chars(s1: Seq<char>, s2: Seq<char>) -> (v: Seq<char>)
    ensures 
        v.len() <= s1.len(),
        forall|i: int| 0 <= i < v.len() ==> s1.contains(v[i]) && !s2.contains(v[i]),
        forall|i: int| 0 <= i < s1.len() ==> s2.contains(s1[i]) || v.contains(s1[i])","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0653,verus,dafnybench,dafny-synthesis_task_id_69_ContainsSequence,,,"use vstd::prelude::*;

verus! {",,"fn contains_sequence(list: Seq<Seq<int>>, sub: Seq<int>) -> (result: bool)
    ensures result <==> exists|i: int| 0 <= i < list.len() && sub == list[i]","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0654,verus,dafnybench,dafny-synthesis_task_id_70_AllSequencesEqualLength,,,"use vstd::prelude::*;

verus! {",,"fn all_sequences_equal_length(sequences: Seq<Seq<int>>) -> (result: bool)
    ensures result <==> (forall |i: int, j: int| 0 <= i < sequences.len() && 0 <= j < sequences.len() ==> sequences[i].len() == sequences[j].len())","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0662,verus,dafnybench,dafny-synthesis_task_id_94_MinSecondValueFirst,,,"use vstd::prelude::*;

verus! {",,"fn min_second_value_first(s: &Vec<Vec<i32>>) -> (first_of_min_second: i32)
    requires 
        s.len() > 0,
        forall|i: int| 0 <= i < s.len() ==> s@[i].len() >= 2,
    ensures 
        exists|i: int| 0 <= i < s.len() && first_of_min_second == s@[i]@[0] && 
            (forall|j: int| 0 <= j < s.len() ==> s@[i]@[1] <= s@[j]@[1]),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVD01,0.85
VD0663,verus,dafnybench,dafny-synthesis_task_id_95_SmallestListLength,,,"use vstd::prelude::*;

verus! {",,"fn smallest_list_length(s: Seq<Seq<int>>) -> (v: int)
    requires
        s.len() > 0,
    ensures
        forall|i: int| 0 <= i < s.len() ==> v <= s[i].len(),
        exists|i: int| 0 <= i < s.len() && v == #[trigger] s[i].len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0665,verus,dafnybench,dafny-synthesis_task_id_105_CountTrue,,,"use vstd::prelude::*;

verus! {

spec fn count_to(a: &[bool], n: int) -> int
    decreases n when 0 <= n <= a.len()
{
    if n <= 0 { 
        0int 
    } else { 
        count_to(a, n - 1) + if a[n - 1] { 1int } else { 0int } 
    }
}",,"fn count_true(a: &[bool]) -> (result: usize)
    ensures result == count_to(a, a.len() as int)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0666,verus,dafnybench,dafny-synthesis_task_id_106_AppendArrayToSeq,,,"use vstd::prelude::*;

verus! {",,"fn append_array_to_seq(s: Seq<i32>, a: &Vec<i32>) -> (r: Seq<i32>)
    ensures
        r.len() == s.len() + a.len(),
        forall|i: int| 0 <= i < s.len() ==> r[i] == s[i],
        forall|i: int| 0 <= i < a.len() ==> r[s.len() + i] == a[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVD02,0.85
VD0667,verus,dafnybench,dafny-synthesis_task_id_113_IsInteger,,,"use vstd::prelude::*;

verus! {

spec fn is_digit(c: char) -> bool {
    48 <= c as int <= 57
}",,"fn is_integer(s: Seq<char>) -> (result: bool)
    ensures result <==> (s.len() > 0) && (forall|i: int| 0 <= i < s.len() ==> is_digit(s[i]))","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0668,verus,dafnybench,dafny-synthesis_task_id_126_SumOfCommonDivisors,,,"use vstd::prelude::*;

verus! {",,"fn sum_of_common_divisors(a: u32, b: u32) -> (sum: u32)
    requires 
        a > 0 && b > 0,
    ensures 
        sum >= 0,
        forall|d: u32| #![trigger a % d, b % d] 
            1 <= d <= a && 1 <= d <= b && a % d == 0 && b % d == 0 ==> sum >= d,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0669,verus,dafnybench,dafny-synthesis_task_id_127_Multiply,,,"use vstd::prelude::*;

verus! {",,"fn multiply(a: int, b: int) -> (result: int)
    ensures result == a * b","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0670,verus,dafnybench,dafny-synthesis_task_id_133_SumOfNegatives,,,"use vstd::prelude::*;

verus! {

spec fn sum_negatives_to(a: &[i32], n: int) -> int
    recommends 0 <= n <= a.len()
    decreases n
{
    if n == 0 { 
        0 
    } else if n > 0 && a[n - 1] < 0 { 
        sum_negatives_to(a, n - 1) + a[n - 1] 
    } else if n > 0 { 
        sum_negatives_to(a, n - 1) 
    } else {
        0
    }
}",,"fn sum_of_negatives(a: &[i32]) -> (result: i32)
    ensures result == sum_negatives_to(a, a.len() as int)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0673,verus,dafnybench,dafny-synthesis_task_id_142_CountIdenticalPositions,,,"use vstd::prelude::*;

verus! {",,"fn count_identical_positions(a: Seq<int>, b: Seq<int>, c: Seq<int>) -> (count: usize)
    requires
        a.len() == b.len() && b.len() == c.len(),
    ensures
        count >= 0,
        count == Set::<int>::new(|i: int| 0 <= i < a.len() && a[i] == b[i] && b[i] == c[i]).len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0674,verus,dafnybench,dafny-synthesis_task_id_143_CountArrays,,,"use vstd::prelude::*;

verus! {",,"fn count_arrays(arrays: &Vec<Vec<i32>>) -> (count: usize)
    ensures 
        count >= 0,
        count == arrays.len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0675,verus,dafnybench,dafny-synthesis_task_id_145_MaxDifference,,,"use vstd::prelude::*;

verus! {",,"fn max_difference(a: &[i32]) -> (diff: i32)
    requires a.len() > 1
    ensures forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() ==> a[i] - a[j] <= diff","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0676,verus,dafnybench,dafny-synthesis_task_id_161_RemoveElements,,"// Predicate to check if an element exists in an array

// All elements in the output are in a and not in b

// The elements in the output are all different","use vstd::prelude::*;

verus! {

spec fn in_array(a: &[i32], x: i32) -> bool {
    exists|i: int| 0 <= i < a.len() && a@.index(i) == x
}",,"fn remove_elements(a: &[i32], b: &[i32]) -> (result: Vec<i32>)

    ensures 
        forall|x: i32| result@.contains(x) ==> in_array(a, x) && !in_array(b, x),

        forall|i: int, j: int| 0 <= i < j < result.len() ==> result@.index(i) != result@.index(j)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0677,verus,dafnybench,dafny-synthesis_task_id_170_SumInRange,,,"use vstd::prelude::*;

verus! {

spec fn sum_to(a: Seq<int>, start: int, end: int) -> int
    recommends 
        0 <= start <= end <= a.len(),
    decreases end
    when 0 <= start <= end <= a.len()
{
    if start == end {
        0
    } else {
        sum_to(a, start, end - 1) + a[end - 1]
    }
}",,"fn sum_in_range(a: &[i32], start: usize, end: usize) -> (sum: i32)
    requires 
        start <= end <= a.len(),
    ensures
        sum == sum_to(a@.map(|i, v| v as int), start as int, end as int),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0678,verus,dafnybench,dafny-synthesis_task_id_171_PentagonPerimeter,,,"use vstd::prelude::*;

verus! {",,"fn pentagon_perimeter(side: i32) -> (perimeter: i32)
    requires side > 0
    ensures perimeter == 5 * side","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0679,verus,dafnybench,dafny-synthesis_task_id_227_MinOfThree,,,"use vstd::prelude::*;

verus! {",,"fn min_of_three(a: i32, b: i32, c: i32) -> (min: i32)
    ensures
        min <= a && min <= b && min <= c,
        (min == a) || (min == b) || (min == c),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0680,verus,dafnybench,dafny-synthesis_task_id_230_ReplaceBlanksWithChar,,,"use vstd::prelude::*;

verus! {",,"fn replace_blanks_with_char(s: Seq<char>, ch: char) -> (v: Seq<char>)
    ensures 
        v.len() == s.len(),
        forall|i: int| 0 <= i < s.len() ==> {
            (s[i] == ' ' ==> v[i] == ch) &&
            (s[i] != ' ' ==> v[i] == s[i])
        }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0681,verus,dafnybench,dafny-synthesis_task_id_233_CylinderLateralSurfaceArea,,,"use vstd::prelude::*;

verus! {",,"fn cylinder_lateral_surface_area(radius: u64, height: u64) -> (area: u64)
    requires 
        radius > 0,
        height > 0,
    ensures area == 2 * radius * height * 314 / 100,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0682,verus,dafnybench,dafny-synthesis_task_id_234_CubeVolume,,,"use vstd::prelude::*;

verus! {",,"fn cube_volume(size: i32) -> (volume: i32)
    requires size > 0
    ensures volume == size * size * size","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0683,verus,dafnybench,dafny-synthesis_task_id_238_CountNonEmptySubstrings,,// Formula for the number of non-empty substrings of a string,"use vstd::prelude::*;

verus! {",,"fn count_non_empty_substrings(s: Seq<char>) -> (count: usize)
    ensures 
        count >= 0,
        count == (s.len() * (s.len() + 1)) / 2,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0684,verus,dafnybench,dafny-synthesis_task_id_240_ReplaceLastElement,,,"use vstd::prelude::*;

verus! {",,"fn replace_last_element(first: &Vec<i32>, second: &Vec<i32>) -> (result: Vec<i32>)
    requires 
        first.len() > 0,
    ensures 
        result.len() == first.len() - 1 + second.len(),
        forall|i: int| 0 <= i < first.len() - 1 ==> result[i] == first[i],
        forall|i: int| first.len() - 1 <= i < result.len() ==> result[i] == second[i - first.len() + 1],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0685,verus,dafnybench,dafny-synthesis_task_id_242_CountCharacters,,,"use vstd::prelude::*;

verus! {",,"fn count_characters(s: Seq<char>) -> (count: usize)
    ensures 
        count >= 0,
        count == s.len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0686,verus,dafnybench,dafny-synthesis_task_id_249_Intersection,,"// Predicate to check if an element exists in an array

// All elements in the output are in both a and b

// The elements in the output are all different","use vstd::prelude::*;

verus! {

spec fn in_array(a: &[i32], x: i32) -> bool {
    exists|i: int| 0 <= i < a.len() && a[i as int] == x
}",,"fn intersection(a: &[i32], b: &[i32]) -> (result: Vec<i32>)
    ensures

        forall|x: i32| result@.contains(x) ==> (in_array(a, x) && in_array(b, x)),

        forall|i: int, j: int| 0 <= i < j < result.len() ==> result[i] != result[j]","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0687,verus,dafnybench,dafny-synthesis_task_id_251_InsertBeforeEach,,,"use vstd::prelude::*;

verus! {",,"#[verifier::exec_allows_no_decreases_clause]
fn insert_before_each(s: Seq<String>, x: String) -> (v: Seq<String>)
    ensures
        v.len() == 2 * s.len(),
        forall|i: int| 0 <= i < s.len() ==> v[2*i] == x && v[2*i + 1] == s[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0689,verus,dafnybench,dafny-synthesis_task_id_261_ElementWiseDivision,,,"use vstd::prelude::*;

verus! {",,"fn element_wise_division(a: Seq<int>, b: Seq<int>) -> (result: Seq<int>)
    requires
        a.len() == b.len(),
        forall|i: int| 0 <= i < b.len() ==> b[i] != 0,
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] / b[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0690,verus,dafnybench,dafny-synthesis_task_id_262_SplitArray,,,"use vstd::prelude::*;

verus! {",,"fn split_array(arr: &[i32], l: usize) -> (Vec<i32>, Vec<i32>)
    requires 0 <= l <= arr.len()","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0696,verus,dafnybench,dafny-synthesis_task_id_273_SubtractSequences,,,"use vstd::prelude::*;

verus! {",,"fn subtract_sequences(a: Seq<int>, b: Seq<int>) -> (result: Seq<int>)
    requires 
        a.len() == b.len(),
    ensures 
        result.len() == a.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] - b[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0700,verus,dafnybench,dafny-synthesis_task_id_284_AllElementsEqual,,,"use vstd::prelude::*;

verus! {",,"fn all_elements_equal(a: &[i32], n: i32) -> (result: bool)
    ensures
        result ==> forall|i: int| 0 <= i < a.len() ==> a[i] == n,
        !result ==> exists|i: int| 0 <= i < a.len() && a[i] != n,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0701,verus,dafnybench,dafny-synthesis_task_id_290_MaxLengthList,,,"use vstd::prelude::*;

verus! {",,"fn max_length_list(lists: &Vec<Vec<int>>) -> (max_list: Vec<int>)
    requires lists.len() > 0
    ensures forall|i: int| 0 <= i < lists.len() ==> lists[i].len() <= max_list.len(),
            exists|i: int| 0 <= i < lists.len() && max_list@ == lists[i]@","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0703,verus,dafnybench,dafny-synthesis_task_id_304_ElementAtIndexAfterRotation,,,"use vstd::prelude::*;

verus! {",,"fn element_at_index_after_rotation(l: Seq<int>, n: int, index: int) -> (element: int)
    requires 
        n >= 0,
        0 <= index < l.len(),
    ensures 
        element == l[((index - n + l.len() as int) % l.len() as int) as int],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0710,verus,dafnybench,dafny-synthesis_task_id_399_BitwiseXOR,,,"use vstd::prelude::*;

verus! {",,"fn bitwise_xor(a: Seq<u32>, b: Seq<u32>) -> (result: Seq<u32>)
    requires
        a.len() == b.len(),
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] ^ b[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0711,verus,dafnybench,dafny-synthesis_task_id_401_IndexWiseAddition,,,"use vstd::prelude::*;

verus! {",,"fn index_wise_addition(a: Seq<Seq<int>>, b: Seq<Seq<int>>) -> (result: Seq<Seq<int>>)
    requires 
        a.len() > 0 && b.len() > 0,
        a.len() == b.len(),
        forall|i: int| 0 <= i < a.len() ==> a[i].len() == b[i].len(),
    ensures 
        result.len() == a.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i].len() == a[i].len(),
        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result[i].len() ==> 
            result[i][j] == a[i][j] + b[i][j],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0714,verus,dafnybench,dafny-synthesis_task_id_412_RemoveOddNumbers,,"/**
 * Remove odd numbers from an array of numbers
 **/

// All numbers in the output are even and exist in the input 

// All even numbers in the input are in the output","use vstd::prelude::*;

verus! {

spec fn is_even(n: int) -> bool {
    n % 2 == 0
}",,"fn remove_odd_numbers(arr: &[i32]) -> (even_list: Vec<i32>)
    ensures

        forall|i: int| 0 <= i < even_list.len() ==> is_even(even_list[i] as int) && arr@.contains(even_list[i]),

        forall|i: int| 0 <= i < arr.len() && is_even(arr[i] as int) ==> even_list@.contains(arr[i])","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0715,verus,dafnybench,dafny-synthesis_task_id_414_AnyValueExists,,,"use vstd::prelude::*;

verus! {",,"fn any_value_exists(seq1: Seq<int>, seq2: Seq<int>) -> (result: bool)
    ensures result <==> (exists|i: int| 0 <= i < seq1.len() && seq2.contains(seq1[i]))","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0716,verus,dafnybench,dafny-synthesis_task_id_424_ExtractRearChars,,,"use vstd::prelude::*;

verus! {",,"fn extract_rear_chars(l: &Vec<Vec<char>>) -> (r: Vec<char>)
    requires forall|i: int| 0 <= i < l.len() ==> l[i].len() > 0
    ensures 
        r.len() == l.len()
        && forall|i: int| 0 <= i < l.len() ==> r[i] == l[i][l[i].len() - 1]","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0717,verus,dafnybench,dafny-synthesis_task_id_426_FilterOddNumbers,,"/**
 * Filter odd numbers from an array of numbers
 **/

// All numbers in the output are odd and exist in the input 

// All odd numbers in the input are in the output","use vstd::prelude::*;

verus! {

spec fn is_odd(n: int) -> bool {
    n % 2 != 0
}",,"fn filter_odd_numbers(arr: &[int]) -> (odd_list: Vec<int>)
    ensures 

        forall|i: int| 0 <= i < odd_list.len() ==> is_odd(odd_list[i]) && arr@.contains(odd_list[i]),

        forall|i: int| 0 <= i < arr.len() && is_odd(arr[i]) ==> odd_list@.contains(arr[i]),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0718,verus,dafnybench,dafny-synthesis_task_id_430_ParabolaDirectrix,,"// Note: In Verus, complex floating-point arithmetic in specifications is limited

// This represents the mathematical relationship: directrix == k - 1/(4*a)","use vstd::prelude::*;

verus! {",,"fn parabola_directrix(a: int, h: int, k: int) -> (directrix: int)
    requires a != 0","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0719,verus,dafnybench,dafny-synthesis_task_id_431_HasCommonElement,,,"use vstd::prelude::*;

verus! {",,"fn has_common_element(a: &[i32], b: &[i32]) -> (result: bool)
    ensures 
        result ==> (exists|i: int, j: int| 0 <= i < a.len() && 0 <= j < b.len() && a[i] == b[j]) &&
        (!result ==> (forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < b.len() ==> a[i] != b[j]))","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0720,verus,dafnybench,dafny-synthesis_task_id_432_MedianLength,,,"use vstd::prelude::*;

verus! {",,"fn median_length(a: int, b: int) -> (median: int)
    requires a > 0 && b > 0
    ensures median == (a + b) / 2","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0721,verus,dafnybench,dafny-synthesis_task_id_433_IsGreater,,,"use vstd::prelude::*;

verus! {",,"fn is_greater(n: i32, a: &[i32]) -> (result: bool)
    ensures 
        result ==> forall|i: int| 0 <= i < a.len() ==> n > a[i],
        !result ==> exists|i: int| 0 <= i < a.len() && n <= a[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0722,verus,dafnybench,dafny-synthesis_task_id_435_LastDigit,,,"use vstd::prelude::*;

verus! {",,"#[verifier::exec_allows_no_decreases_clause]
fn last_digit(n: i32) -> (result: i32)
    requires n >= 0
    ensures 
        0 <= result < 10,
        n % 10 == result","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0723,verus,dafnybench,dafny-synthesis_task_id_436_FindNegativeNumbers,,"/**
 * Find negative numbers from an array of numbers
 **/

// All numbers in the output are negative and exist in the input

// All negative numbers in the input are in the output","use vstd::prelude::*;

verus! {

spec fn is_negative(n: int) -> bool {
    n < 0
}",,"fn find_negative_numbers(arr: &[int]) -> (negative_list: Vec<int>)
    ensures

        forall|i: int| 0 <= i < negative_list.len() ==> 
            is_negative(negative_list[i]) && exists|j: int| 0 <= j < arr.len() && arr[j] == negative_list[i],

        forall|i: int| 0 <= i < arr.len() && is_negative(arr[i]) ==> 
            exists|j: int| 0 <= j < negative_list.len() && negative_list[j] == arr[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0724,verus,dafnybench,dafny-synthesis_task_id_441_CubeSurfaceArea,,,"use vstd::prelude::*;

verus! {",,"fn cube_surface_area(size: i32) -> (area: i32)
    requires size > 0
    ensures area == 6 * size * size","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0727,verus,dafnybench,dafny-synthesis_task_id_452_CalculateLoss,,,"use vstd::prelude::*;

verus! {",,"fn calculate_loss(cost_price: i32, selling_price: i32) -> (loss: i32)
    requires cost_price >= 0 && selling_price >= 0,
    ensures (cost_price > selling_price ==> loss == cost_price - selling_price) && (cost_price <= selling_price ==> loss == 0),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0729,verus,dafnybench,dafny-synthesis_task_id_455_MonthHas31Days,,,"use vstd::prelude::*;

verus! {",,"fn month_has_31_days(month: i32) -> (result: bool)
    requires 1 <= month <= 12
    ensures result <==> (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0730,verus,dafnybench,dafny-synthesis_task_id_457_MinLengthSublist,,,"use vstd::prelude::*;

verus! {",,"fn min_length_sublist(s: Seq<Seq<int>>) -> (min_sublist: Seq<int>)
    requires 
        s.len() > 0,
    ensures 
        s.contains(min_sublist),
        forall |sublist: Seq<int>| s.contains(sublist) ==> min_sublist.len() <= sublist.len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0732,verus,dafnybench,dafny-synthesis_task_id_460_GetFirstElements,,,"use vstd::prelude::*;

verus! {",,"fn get_first_elements(lst: Vec<Vec<i32>>) -> (result: Vec<i32>)
    requires forall|i: int| 0 <= i < lst.len() ==> lst[i].len() > 0,
    ensures 
        result.len() == lst.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] == lst[i][0],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0733,verus,dafnybench,dafny-synthesis_task_id_461_CountUppercase,,,"use vstd::prelude::*;

verus! {

spec fn is_upper_case(c: char) -> bool {
    65 <= c as int <= 90
}",,"fn count_uppercase(s: &str) -> (count: usize)
    ensures 
        count >= 0,
        count as int == s@.filter(|c: char| is_upper_case(c)).len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0734,verus,dafnybench,dafny-synthesis_task_id_470_PairwiseAddition,,,"use vstd::prelude::*;

verus! {",,"fn pairwise_addition(a: &[i32]) -> (result: Vec<i32>)
    requires
        a.len() % 2 == 0,
    ensures
        result.len() == a.len() / 2,
        forall|i: int| 0 <= i < result.len() ==> result[i as int] == a[2*i] + a[2*i + 1],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0735,verus,dafnybench,dafny-synthesis_task_id_472_ContainsConsecutiveNumbers,,,"use vstd::prelude::*;

verus! {",,"fn contains_consecutive_numbers(a: &[i32]) -> (result: bool)
    requires a.len() > 0
    ensures result <==> exists|i: int| #![trigger a.spec_index(i)] 
        0 <= i < (a.len() as int) - 1 && a[i] + 1 == a[i + 1]","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0736,verus,dafnybench,dafny-synthesis_task_id_474_ReplaceChars,,,"use vstd::prelude::*;

verus! {",,"fn replace_chars(s: Seq<char>, old_char: char, new_char: char) -> (v: Seq<char>)
    ensures
        v.len() == s.len(),
        forall|i: int| 0 <= i < s.len() ==> 
            (s[i] == old_char ==> v[i] == new_char) &&
            (s[i] != old_char ==> v[i] == s[i]),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0737,verus,dafnybench,dafny-synthesis_task_id_476_SumMinMax,,"// The order of the recursion in these two functions

// must match the order of the iteration in the algorithm above","use vstd::prelude::*;

verus! {

spec fn min_seq(a: Seq<int>) -> int
    recommends a.len() > 0
    decreases a.len() when a.len() > 0
{
    if a.len() == 1 {
        a[0]
    } else {
        let prefix = a.subrange(0, a.len() - 1);
        assume(prefix.len() < a.len());
        let min_prefix = min_seq(prefix);
        if a[a.len() - 1] <= min_prefix {
            a[a.len() - 1]
        } else {
            min_prefix
        }
    }
}

spec fn max_seq(a: Seq<int>) -> int
    recommends a.len() > 0
    decreases a.len() when a.len() > 0
{
    if a.len() == 1 {
        a[0]
    } else {
        let prefix = a.subrange(0, a.len() - 1);
        assume(prefix.len() < a.len());
        let max_prefix = max_seq(prefix);
        if a[a.len() - 1] >= max_prefix {
            a[a.len() - 1]
        } else {
            max_prefix
        }
    }
}",,"fn sum_min_max(a: &[i32]) -> (sum: i32)
    requires a.len() > 0
    ensures sum == max_seq(a@.map(|i: int, x: i32| x as int)) + min_seq(a@.map(|i: int, x: i32| x as int))","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0738,verus,dafnybench,dafny-synthesis_task_id_477_ToLowercase,,,"use vstd::prelude::*;

verus! {

spec fn is_upper_case(c: char) -> bool {
    65 <= c as int <= 90
}

spec fn is_upper_lower_pair(C: char, c: char) -> bool {
    (C as int) == (c as int) - 32
}

spec fn shift_32(c: char) -> char {
    (((c as int + 32) % 128) as u8) as char
}",,"#[verifier::exec_allows_no_decreases_clause]
fn to_lowercase(s: &str) -> (v: String)
    ensures
        v@.len() == s@.len(),
        forall|i: int| #![trigger s@[i]] 0 <= i < s@.len() ==> 
        {
            if is_upper_case(s@[i]) {
                is_upper_lower_pair(s@[i], v@[i])
            } else {
                v@[i] == s@[i]
            }
        }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0739,verus,dafnybench,dafny-synthesis_task_id_554_FindOddNumbers,,"/**
 * Find odd numbers from an array of numbers
 **/

// All numbers in the output are odd and exist in the input 

// All odd numbers in the input are in the output","use vstd::prelude::*;

verus! {

spec fn is_odd(n: int) -> bool {
    n % 2 == 1
}",,"fn find_odd_numbers(arr: &[i32]) -> (odd_list: Vec<i32>)

    ensures 
        forall|i: int| 0 <= i < odd_list.len() ==> is_odd(odd_list[i] as int) && arr@.contains(odd_list[i]),

        forall|i: int| 0 <= i < arr.len() && is_odd(arr[i] as int) ==> odd_list@.contains(arr[i])","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0740,verus,dafnybench,dafny-synthesis_task_id_555_DifferenceSumCubesAndSumNumbers,,,"use vstd::prelude::*;

verus! {",,"fn difference_sum_cubes_and_sum_numbers(n: u32) -> (diff: u32)
    requires n >= 0
    ensures diff == (n * n * (n + 1) * (n + 1)) / 4 - (n * (n + 1)) / 2","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0741,verus,dafnybench,dafny-synthesis_task_id_557_ToggleCase,,,"use vstd::prelude::*;

verus! {

spec fn is_lower_case(c: char) -> bool {
    97 <= c as int <= 122
}

spec fn is_upper_case(c: char) -> bool {
    65 <= c as int <= 90
}

spec fn is_lower_upper_pair(c: char, C: char) -> bool {
    (c as int) == (C as int) + 32
}

spec fn is_upper_lower_pair(C: char, c: char) -> bool {
    (C as int) == (c as int) - 32
}

spec fn shift_minus_32(c: char) -> char {
    ((c as int - 32) % 128) as char
}

spec fn shift_32(c: char) -> char {
    ((c as int + 32) % 128) as char
}",,"fn toggle_case(s: Vec<char>) -> (v: Vec<char>)
    ensures
        v.len() == s.len(),
        forall|i: int| 0 <= i < s.len() ==> {
            let s_char = #[trigger] s[i];
            let v_char = v[i];
            if is_lower_case(s_char) {
                is_lower_upper_pair(s_char, v_char)
            } else if is_upper_case(s_char) {
                is_upper_lower_pair(s_char, v_char)
            } else {
                v_char == s_char
            }
        }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0742,verus,dafnybench,dafny-synthesis_task_id_565_SplitStringIntoChars,,,"use vstd::prelude::*;

verus! {",,"fn split_string_into_chars(s: Vec<char>) -> (v: Vec<char>)
    ensures
        v.len() == s.len(),
        forall|i: int| 0 <= i < s.len() ==> v[i] == s[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0743,verus,dafnybench,dafny-synthesis_task_id_566_SumOfDigits,,"// spec fn int_values(n: int) -> Seq<int>

//     recommends n >= 0

// {

//     if n == 0 { seq![0] }

//     else { seq![n] + int_values(n/10) }

// }

// spec fn number_to_seq(number: int) -> Seq<int>

//     recommends number >= 0

// {

//     if number == 0 { Seq::empty() }

//     else { seq![number % 10] + number_to_seq(number/10) }

// }

// spec fn sum_seq(digits: Seq<int>) -> int

// {

//     if digits.len() == 0 { 0 }

//     else { digits[0] + sum_seq(digits.subrange(1, digits.len() as int)) }

// }","use vstd::prelude::*;

verus! {

spec fn power10(n: nat) -> nat
    decreases n
{
    if n == 0 { 1 } else { 10 * power10((n - 1) as nat) }
}

spec fn sum_digits(n: nat) -> nat {
    let ndigits = number_of_digits(n);
    let p = power10((ndigits - 1) as nat);
    sum_digits_recursive(n, p)
}

spec fn sum_digits_recursive(n: nat, p: nat) -> nat
    decreases p
{
    if n == 0 || p == 0 { 0 }
    else {
        let left_most_digit = n/p;
        let rest = n%p;
        left_most_digit + sum_digits_recursive(rest, (p/10) as nat)
    }
}

spec fn number_of_digits(n: nat) -> nat
    decreases n
{
    if 0 <= n <= 9 { 1 } else { 1 + number_of_digits((n/10) as nat) }
}",,"fn sum_of_digits(number: u64) -> (sum: u64)
    requires number >= 0,
    ensures 
        sum >= 0,
        sum == sum_digits(number as nat),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0744,verus,dafnybench,dafny-synthesis_task_id_567_IsSorted,,,"use vstd::prelude::*;

verus! {",,"fn is_sorted(a: &[i32]) -> (sorted: bool)
    requires
        a.len() > 0,
    ensures
        sorted <==> forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j],
        !sorted ==> exists|i: int, j: int| 0 <= i < j < a.len() && a[i] > a[j],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0745,verus,dafnybench,dafny-synthesis_task_id_572_RemoveDuplicates,,,"use vstd::prelude::*;

verus! {",,"fn remove_duplicates(a: &[i32]) -> (result: Vec<i32>)
    ensures
        forall|x: i32| result@.contains(x) <==> exists|i: int| 0 <= i < a.len() && a[i] == x,
        forall|i: int, j: int| 0 <= i < j < result.len() ==> result@[i] != result@[j]","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0746,verus,dafnybench,dafny-synthesis_task_id_573_UniqueProduct,,// This represents the nondeterministic choice like |:| in Dafny,"use vstd::prelude::*;

verus! {

spec fn set_product(s: Set<int>) -> int
    decreases s.len()
{
    if s.is_empty() {
        1
    } else {
        arbitrary()
    }
}",,"fn unique_product(arr: &[i32]) -> (product: i32)
    ensures product == set_product(arr@.to_set().map(|x: i32| x as int))","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0747,verus,dafnybench,dafny-synthesis_task_id_574_CylinderSurfaceArea,,,"use vstd::prelude::*;

verus! {",,"fn cylinder_surface_area(radius: u64, height: u64) -> (area: u64)
    requires radius > 0 && height > 0
    ensures area == 2 * radius * (radius + height)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0748,verus,dafnybench,dafny-synthesis_task_id_576_IsSublist,,,"use vstd::prelude::*;

verus! {",,"fn is_sublist(sub: Seq<int>, main: Seq<int>) -> (result: bool)
    ensures
        result == exists|i: int, j: int| 0 <= i <= main.len() - sub.len() && j == i + sub.len() && sub =~= #[trigger] main.subrange(i, j)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0749,verus,dafnybench,dafny-synthesis_task_id_577_FactorialOfLastDigit,,,"use vstd::prelude::*;

verus! {

spec fn factorial(n: int) -> int
    recommends n >= 0
    decreases n when n >= 0
{
    if n == 0 { 1 } else { n * factorial((n - 1) as int) }
}",,"fn factorial_of_last_digit(n: u64) -> (fact: u64)
    requires n >= 0
    ensures fact == factorial((n % 10) as int)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0750,verus,dafnybench,dafny-synthesis_task_id_578_Interleave,,,"use vstd::prelude::*;

verus! {",,"#[verifier::exec_allows_no_decreases_clause]
fn interleave(s1: Seq<int>, s2: Seq<int>, s3: Seq<int>) -> (r: Seq<int>)
    requires 
        s1.len() == s2.len() && s2.len() == s3.len(),
    ensures 
        r.len() == 3 * s1.len(),
        forall|i: int| 0 <= i < s1.len() ==> r[3*i] == s1[i] && r[3*i + 1] == s2[i] && r[3*i + 2] == s3[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0751,verus,dafnybench,dafny-synthesis_task_id_579_DissimilarElements,,"// All elements in the output are either in a or b, but not in both or neither

// The elements in the output are all different","use vstd::prelude::*;

verus! {

spec fn in_array(a: &Vec<int>, x: int) -> bool {
    exists|i: int| 0 <= i < a.len() && a[i] == x
}",,"fn dissimilar_elements(a: &Vec<int>, b: &Vec<int>) -> (result: Vec<int>)
    ensures

        forall|x: int| result@.contains(x) ==> (in_array(a, x) != in_array(b, x)),

        forall|i: int, j: int| 0 <= i < j < result.len() ==> result[i] != result[j],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0752,verus,dafnybench,dafny-synthesis_task_id_581_SquarePyramidSurfaceArea,,,"use vstd::prelude::*;

verus! {",,"fn square_pyramid_surface_area(base_edge: i32, height: i32) -> (area: i32)
    requires 
        base_edge > 0,
        height > 0,
    ensures 
        area == base_edge * base_edge + 2 * base_edge * height,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0753,verus,dafnybench,dafny-synthesis_task_id_586_SplitAndAppend,,,"use vstd::prelude::*;

verus! {",,"fn split_and_append(l: Seq<int>, n: int) -> (r: Seq<int>)
    requires 
        n >= 0 && n < l.len(),
    ensures 
        r.len() == l.len(),
        forall|i: int| 0 <= i < l.len() ==> r[i] == l[((i + n) as nat % l.len()) as int],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0754,verus,dafnybench,dafny-synthesis_task_id_587_ArrayToSeq,,,"use vstd::prelude::*;

verus! {",,"fn array_to_seq(a: &[i32]) -> (s: Vec<i32>)
    ensures
        s.len() == a.len(),
        forall|i: int| 0 <= i < a.len() ==> s[i] == a[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVD02,0.85
VD0755,verus,dafnybench,dafny-synthesis_task_id_588_DifferenceMinMax,,"// The order of the recursion in these two functions

// must match the order of the iteration in the algorithm above","use vstd::prelude::*;

verus! {

spec fn min(a: Seq<int>) -> int
    recommends a.len() > 0
    decreases a.len() when a.len() > 0
{
    if a.len() == 1 {
        a[0]
    } else {
        let prefix = a.take(a.len() - 1);
        let min_prefix = min(prefix);
        if a[a.len() - 1] <= min_prefix {
            a[a.len() - 1]
        } else {
            min_prefix
        }
    }
}

spec fn max(a: Seq<int>) -> int
    recommends a.len() > 0  
    decreases a.len() when a.len() > 0
{
    if a.len() == 1 {
        a[0]
    } else {
        let prefix = a.take(a.len() - 1);
        let max_prefix = max(prefix);
        if a[a.len() - 1] >= max_prefix {
            a[a.len() - 1]
        } else {
            max_prefix
        }
    }
}",,"fn difference_min_max(a: &[i32]) -> (diff: i32)
    requires a.len() > 0
    ensures diff == max(a@.map(|i, x| x as int)) - min(a@.map(|i, x| x as int))","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0756,verus,dafnybench,dafny-synthesis_task_id_591_SwapFirstAndLast,,,"use vstd::prelude::*;

verus! {",,"fn swap_first_and_last(a: &mut Vec<i32>)
    requires
        old(a).len() > 0,
    ensures
        a.len() == old(a).len(),
        a[0] == old(a)[old(a).len() - 1],
        a[a.len() - 1] == old(a)[0],
        forall|k: int| 1 <= k < a.len() - 1 ==> a[k] == old(a)[k],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0757,verus,dafnybench,dafny-synthesis_task_id_594_FirstEvenOddDifference,,,"use vstd::prelude::*;

verus! {

spec fn is_even(n: int) -> bool {
    n % 2 == 0
}

spec fn is_odd(n: int) -> bool {
    n % 2 != 0
}",,"fn first_even_odd_difference(a: &[i32]) -> (diff: i32)
    requires 
        a.len() >= 2,
        exists|i: int| 0 <= i < a.len() && is_even(a[i] as int),
        exists|i: int| 0 <= i < a.len() && is_odd(a[i] as int),
    ensures 
        exists|i: int, j: int| 
            0 <= i < a.len() && 
            0 <= j < a.len() && 
            is_even(a[i] as int) && 
            is_odd(a[j] as int) && 
            diff == a[i] - a[j] && 
            (forall|k: int| 0 <= k < i ==> is_odd(a[k] as int)) && 
            (forall|k: int| 0 <= k < j ==> is_even(a[k] as int))","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0758,verus,dafnybench,dafny-synthesis_task_id_598_IsArmstrong,,,"use vstd::prelude::*;

verus! {",,"fn is_armstrong(n: int) -> (result: bool)
    requires 100 <= n < 1000
    ensures result <==> (n == ((n / 100) * (n / 100) * (n / 100) + ((n / 10) % 10) * ((n / 10) % 10) * ((n / 10) % 10) + (n % 10) * (n % 10) * (n % 10)))","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0759,verus,dafnybench,dafny-synthesis_task_id_599_SumAndAverage,,,"use vstd::prelude::*;

verus! {",,"fn sum_and_average(n: i32) -> (res: (i32, i32))
    requires n > 0
    ensures res.0 == n * (n + 1) / 2 && res.1 * n == res.0","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0760,verus,dafnybench,dafny-synthesis_task_id_600_IsEven,,,"use vstd::prelude::*;

verus! {",,"fn is_even(n: int) -> (result: bool)
    ensures result <==> n % 2 == 0","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0761,verus,dafnybench,dafny-synthesis_task_id_602_FindFirstRepeatedChar,,,"use vstd::prelude::*;

verus! {",,"fn find_first_repeated_char(s: &str) -> (result: (bool, char))
    ensures 
        (result.0 ==> exists|i: int, j: int| 0 <= i < j < s@.len() && s@[i] == s@[j] && s@[i] == result.1 && 
            (forall|k: int, l: int| 0 <= k < l < j && s@[k] == s@[l] ==> k >= i)) &&
        (!result.0 ==> (forall|i: int, j: int| 0 <= i < j < s@.len() ==> s@[i] != s@[j]))","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0762,verus,dafnybench,dafny-synthesis_task_id_603_LucidNumbers,,,"use vstd::prelude::*;

verus! {",,"fn lucid_numbers(n: i32) -> (lucid: Vec<i32>)
    requires 
        n >= 0,
    ensures 
        forall|i: int| 0 <= i < lucid.len() ==> lucid[i] % 3 == 0,
        forall|i: int| 0 <= i < lucid.len() ==> lucid[i] <= n,
        forall|i: int, j: int| 0 <= i < j < lucid.len() ==> lucid[i] < lucid[j],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0763,verus,dafnybench,dafny-synthesis_task_id_605_IsPrime,,,"use vstd::prelude::*;

verus! {",,"fn is_prime(n: int) -> (result: bool)
    requires n >= 2
    ensures result <==> (forall|k: int| 2 <= k < n ==> #[trigger] (n % k) != 0)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0764,verus,dafnybench,dafny-synthesis_task_id_606_DegreesToRadians,,,"use vstd::prelude::*;

verus! {",,"spec fn pi_approx() -> int { 314159265358979323846i128 as int }
spec fn scale_factor() -> int { 100000000000000000000i128 as int }

fn degrees_to_radians(degrees: i64) -> (radians: i64)
    ensures radians as int == (degrees as int * pi_approx()) / scale_factor() / 180","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0765,verus,dafnybench,dafny-synthesis_task_id_610_RemoveElement,,,"use vstd::prelude::*;

verus! {",,"fn remove_element(s: &Vec<i32>, k: usize) -> (v: Vec<i32>)
    requires 
        k < s.len(),
    ensures
        v.len() == s.len() - 1,
        forall|i: int| 0 <= i < k ==> v[i] == s[i],
        forall|i: int| k <= i < v.len() ==> v[i] == s[(i + 1) as int],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0766,verus,dafnybench,dafny-synthesis_task_id_616_ElementWiseModulo,,,"use vstd::prelude::*;

verus! {",,"fn element_wise_modulo(a: &[i32], b: &[i32]) -> (result: Vec<i32>)
    requires 
        a.len() == b.len(),
        forall|i: int| 0 <= i < b.len() ==> b[i] != 0,
    ensures 
        result.len() == a.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] % b[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0767,verus,dafnybench,dafny-synthesis_task_id_618_ElementWiseDivide,,,"use vstd::prelude::*;

verus! {",,"fn element_wise_divide(a: Seq<int>, b: Seq<int>) -> (result: Seq<int>)
    requires 
        a.len() == b.len(),
        forall|i: int| 0 <= i < b.len() ==> b[i] != 0,
    ensures 
        result.len() == a.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] / b[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0768,verus,dafnybench,dafny-synthesis_task_id_622_FindMedian,,,"use vstd::prelude::*;

verus! {",,"fn find_median(a: &[i32], b: &[i32]) -> (median: i32)
    requires 
        a.len() == b.len(),
        a.len() > 0,
        forall|i: int| #[trigger] a[i] == a[i] ==> (0 <= i < (a.len() - 1) as int ==> a[i] <= a[add(i, 1)]),
        forall|i: int| #[trigger] b[i] == b[i] ==> (0 <= i < (b.len() - 1) as int ==> b[i] <= b[add(i, 1)]),
    ensures 
        median as int == if a.len() % 2 == 0 { 
            (a[(a.len() / 2 - 1) as int] + b[0int]) / 2 
        } else { 
            a[(a.len() / 2) as int] as int
        }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0769,verus,dafnybench,dafny-synthesis_task_id_623_PowerOfListElements,,,"use vstd::prelude::*;

verus! {

spec fn power(base: int, exponent: int) -> int
    recommends exponent >= 0
    decreases exponent
{
    if exponent <= 0 { 1 } else { base * power(base, exponent - 1) }
}",,"fn power_of_list_elements(l: Vec<i32>, n: u32) -> (result: Vec<i32>)
    ensures 
        result.len() == l.len(),
        forall|i: int| #![auto] 0 <= i < l.len() ==> result[i] == power(l[i] as int, n as int),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0770,verus,dafnybench,dafny-synthesis_task_id_624_ToUppercase,,,"use vstd::prelude::*;

verus! {

spec fn is_lower_case(c: char) -> bool {
    97 <= c as int <= 122
}

spec fn is_lower_upper_pair(c: char, C: char) -> bool {
    (c as int) == (C as int) + 32
}

spec fn shift_minus_32(c: char) -> char {
    ((c as int - 32) % 128) as char
}",,"fn to_uppercase(s: Seq<char>) -> (v: Seq<char>)
    ensures
        v.len() == s.len(),
        forall|i: int| 0 <= i < s.len() ==> 
            if is_lower_case(s[i]) {
                is_lower_upper_pair(s[i], v[i])
            } else {
                v[i] == s[i]
            }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0771,verus,dafnybench,dafny-synthesis_task_id_625_SwapFirstAndLast,,,"use vstd::prelude::*;

verus! {",,"fn swap_first_and_last(a: &mut Vec<i32>)
    requires 
        old(a).len() > 0,
    ensures
        a.len() == old(a).len(),
        a[0] == old(a)[old(a).len() - 1],
        a[a.len() - 1] == old(a)[0],
        forall|k: int| 1 <= k < old(a).len() - 1 ==> a[k] == old(a)[k],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0772,verus,dafnybench,dafny-synthesis_task_id_626_AreaOfLargestTriangleInSemicircle,,,"use vstd::prelude::*;

verus! {",,"fn area_of_largest_triangle_in_semicircle(radius: i32) -> (area: i32)
    requires radius > 0
    ensures area == radius * radius","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0773,verus,dafnybench,dafny-synthesis_task_id_627_SmallestMissingNumber,,,"use vstd::prelude::*;

verus! {",,"fn smallest_missing_number(s: Seq<int>) -> (v: int)
    requires
        forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] <= s[j],
        forall|i: int| 0 <= i < s.len() ==> s[i] >= 0,
    ensures
        0 <= v,
        !s.contains(v),
        (forall|k: int| 0 <= k < v ==> s.contains(k)),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0774,verus,dafnybench,dafny-synthesis_task_id_629_FindEvenNumbers,,"// All numbers in the output are even and exist in the input 

// All even numbers in the input are in the output","use vstd::prelude::*;

verus! {

spec fn is_even(n: int) -> bool {
    n % 2 == 0
}",,"fn find_even_numbers(arr: &[i32]) -> (even_list: Vec<i32>)

    ensures 
        forall|i: int| 0 <= i < even_list.len() ==> is_even(even_list[i] as int) && exists|j: int| 0 <= j < arr.len() && arr[j] == even_list[i],

        forall|i: int| 0 <= i < arr.len() && is_even(arr[i] as int) ==> exists|j: int| 0 <= j < even_list.len() && even_list[j] == arr[i]","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0775,verus,dafnybench,dafny-synthesis_task_id_632_MoveZeroesToEnd,,"// Same size

// Zeros to the right of the first zero

// The final array is a permutation of the original one

// Relative order of non-zero elements is preserved

// Number of zeros is preserved","use vstd::prelude::*;

verus! {

fn swap(arr: &mut Vec<i32>, i: usize, j: usize)
    requires 
        old(arr).len() > 0,
        i < old(arr).len(),
        j < old(arr).len(),
    ensures
        arr[i as int] == old(arr)[j as int],
        arr[j as int] == old(arr)[i as int],
        forall|k: int| 0 <= k < arr.len() && k != i && k != j ==> arr[k] == old(arr)[k],
        arr@.to_multiset() == old(arr)@.to_multiset(),
{
    assume(false);
}

spec fn count(arr: Seq<i32>, value: i32) -> nat
    decreases arr.len(),
{
    if arr.len() == 0 {
        0nat
    } else {
        (if arr[0] == value { 1nat } else { 0nat }) + count(arr.skip(1), value)
    }
}

proof fn count_bound(arr: Seq<i32>, value: i32)
    ensures count(arr, value) <= arr.len(),
    decreases arr.len(),
{
    if arr.len() == 0 {
    } else {
        count_bound(arr.skip(1), value);
    }
}",,"fn move_zeros_to_end(arr: &mut Vec<i32>)
    requires old(arr).len() >= 2,
    ensures

        arr.len() == old(arr).len(),

        forall|i: int, j: int| 0 <= i < j < arr.len() && arr[i] == 0 ==> arr[j] == 0,

        arr@.to_multiset() == old(arr)@.to_multiset(),

        forall|n: int, m: int| 0 <= n < m < arr.len() && old(arr)[n] != 0 && old(arr)[m] != 0 ==>
            exists|k: int, l: int| 0 <= k < l < arr.len() && arr[k] == old(arr)[n] && arr[l] == old(arr)[m],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0776,verus,dafnybench,dafny-synthesis_task_id_632_swap,,,"use vstd::prelude::*;

verus! {

spec fn count(arr: Seq<int>, value: int) -> nat
    decreases arr.len()
{
    if arr.len() == 0 { 0nat } else { (if arr[0] == value { 1nat } else { 0nat }) + count(arr.skip(1), value) }
}

proof fn count_bound(arr: Seq<int>, value: int)
    ensures count(arr, value) <= arr.len()
    decreases arr.len()
{
    if arr.len() > 0 {
        count_bound(arr.skip(1), value);
    }
}",,"fn swap(arr: &mut Vec<int>, i: usize, j: usize)
    requires 
        old(arr).len() > 0,
        i < old(arr).len(),
        j < old(arr).len(),
    ensures 
        arr[i as int] == old(arr)[j as int],
        arr[j as int] == old(arr)[i as int],
        forall|k: int| 0 <= k < arr.len() && k != i && k != j ==> arr[k] == old(arr)[k],
        arr@.to_multiset() == old(arr)@.to_multiset(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0777,verus,dafnybench,dafny-synthesis_task_id_637_IsBreakEven,,,"use vstd::prelude::*;

verus! {",,"exec fn is_break_even(cost_price: int, selling_price: int) -> (result: bool)
    requires cost_price >= 0 && selling_price >= 0,
    ensures result <==> (cost_price == selling_price),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0778,verus,dafnybench,dafny-synthesis_task_id_641_NthNonagonalNumber,,,"use vstd::prelude::*;

verus! {",,"fn nth_nonagonal_number(n: int) -> (number: int)
    requires n >= 0
    ensures number == n * (7 * n - 5) / 2","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0779,verus,dafnybench,dafny-synthesis_task_id_644_Reverse,,,"use vstd::prelude::*;

verus! {",,"fn reverse(a: &mut Vec<i32>)
    ensures forall|k: int| 0 <= k < old(a).len() ==> a[k] == old(a)[old(a).len() as int - 1 - k]","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVD03,0.85
VD0780,verus,dafnybench,dafny-synthesis_task_id_644_ReverseUptoK,,,"use vstd::prelude::*;

verus! {

spec fn array_index(v: Seq<i32>, i: int) -> i32 {
    v[i]
}",,"fn reverse_upto_k(s: &mut Vec<i32>, k: usize)
    requires 
        2 <= k,
        k <= old(s).len(),
    ensures 
        s.len() == old(s).len(),
        forall|i: int| 0 <= i < k ==> array_index(s@, i) == array_index(old(s)@, k - 1 - i),
        forall|i: int| k <= i < s.len() ==> array_index(s@, i) == array_index(old(s)@, i),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0781,verus,dafnybench,dafny-synthesis_task_id_728_AddLists,,,"use vstd::prelude::*;

verus! {",,"fn add_lists(a: Seq<int>, b: Seq<int>) -> (result: Seq<int>)
    requires 
        a.len() == b.len(),
    ensures 
        result.len() == a.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] + b[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0782,verus,dafnybench,dafny-synthesis_task_id_732_ReplaceWithColon,,,"use vstd::prelude::*;

verus! {

spec fn is_space_comma_dot(c: char) -> bool {
    c == ' ' || c == ',' || c == '.'
}",,"fn replace_with_colon(s: &str) -> (v: String)
    ensures 
        v@.len() == s@.len(),
        forall|i: int| 0 <= i < s@.len() ==> {
            if is_space_comma_dot(s@[i]) {
                v@[i] == ':'
            } else {
                v@[i] == s@[i]
            }
        }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0783,verus,dafnybench,dafny-synthesis_task_id_733_FindFirstOccurrence,,,"use vstd::prelude::*;

verus! {",,"fn find_first_occurrence(arr: &[i32], target: i32) -> (result: i32)
    requires
        forall|i: int, j: int| 0 <= i < j < arr.len() ==> arr[i] <= arr[j]
    ensures
        (0 <= result < arr.len() ==> arr[result as int] == target) &&
        (result == -1 ==> forall|i: int| 0 <= i < arr.len() ==> arr[i] != target)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0784,verus,dafnybench,dafny-synthesis_task_id_741_AllCharactersSame,,,"use vstd::prelude::*;

verus! {",,"fn all_characters_same(s: Seq<u8>) -> (result: bool)
    ensures
        result ==> (forall|i: int, j: int| 0 <= i < s.len() && 0 <= j < s.len() ==> s[i] == s[j]),
        !result ==> (s.len() > 1) && (exists|i: int, j: int| 0 <= i < s.len() && 0 <= j < s.len() && i != j && s[i] != s[j])","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0785,verus,dafnybench,dafny-synthesis_task_id_743_RotateRight,,,"use vstd::prelude::*;

verus! {",,"fn rotate_right(l: Seq<int>, n: int) -> (r: Seq<int>)
    requires n >= 0,
    ensures 
        r.len() == l.len(),
        forall|i: int| 0 <= i < l.len() ==> r.index(i) == l.index((i - n + l.len() as int) % l.len() as int),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0786,verus,dafnybench,dafny-synthesis_task_id_750_AddTupleToList,,,"use vstd::prelude::*;

verus! {",,"fn add_tuple_to_list(l: Seq<(int, int)>, t: (int, int)) -> (r: Seq<(int, int)>)
    ensures
        r.len() == l.len() + 1,
        r[r.len() - 1] == t,
        forall|i: int| 0 <= i < l.len() ==> r[i] == l[i]","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0787,verus,dafnybench,dafny-synthesis_task_id_751_IsMinHeap,,,"use vstd::prelude::*;

verus! {",,"fn is_min_heap(a: &Vec<i32>) -> (result: bool)
    requires a.len() > 0
    ensures 
        result ==> forall|i: int| 0 <= i < (a.len() as int) / 2 ==> {
            let left_idx = 2 * i + 1;
            let right_idx = 2 * i + 2;
            (left_idx < a.len()) ==> (#[trigger] a[i as int] <= a[left_idx]) &&
            (right_idx < a.len()) ==> (a[i as int] <= a[right_idx])
        },
        !result ==> exists|i: int| 0 <= i < (a.len() as int) / 2 && {
            let left_idx = 2 * i + 1;
            let right_idx = 2 * i + 2;
            (#[trigger] a[i as int] > a[left_idx] && left_idx < a.len()) ||
            (a[i as int] > a[right_idx] && right_idx < a.len())
        }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0788,verus,dafnybench,dafny-synthesis_task_id_755_SecondSmallest,,,"use vstd::prelude::*;

verus! {

spec fn min_pair(s: Seq<i32>) -> i32 {
    if s[0] <= s[1] { s[0] } else { s[1] }
}

spec fn min(s: Seq<i32>) -> i32;",,"fn second_smallest(s: &[i32]) -> (result: i32)
    requires 
        s.len() >= 2,
        exists|i: int, j: int| 0 <= i < s.len() && 0 <= j < s.len() && i != j && 
            s[i] == min(s@) && s[j] != s[i]
    ensures 
        exists|i: int, j: int| 0 <= i < s.len() && 0 <= j < s.len() && i != j && 
            s[i] == min(s@) && s[j] == result,
        forall|k: int| 0 <= k < s.len() && s[k] != min(s@) ==> s[k] >= result","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVD01,0.85
VD0789,verus,dafnybench,dafny-synthesis_task_id_759_IsDecimalWithTwoPrecision,,,"use vstd::prelude::*;

verus! {",,"fn is_decimal_with_two_precision(s: &str) -> (result: bool)
    ensures
        result ==> exists|i: int| 0 <= i < s@.len() && s@[i] == '.' && s@.len() - i - 1 == 2,
        !result ==> !exists|i: int| 0 <= i < s@.len() && s@[i] == '.' && s@.len() - i - 1 == 2,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0790,verus,dafnybench,dafny-synthesis_task_id_760_HasOnlyOneDistinctElement,,,"use vstd::prelude::*;

verus! {",,"fn has_only_one_distinct_element(a: &[i32]) -> (result: bool)
    ensures 
        result ==> forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() ==> a[i] == a[j],
        !result ==> exists|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() && a[i] != a[j],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0791,verus,dafnybench,dafny-synthesis_task_id_762_IsMonthWith30Days,,,"use vstd::prelude::*;

verus! {",,"fn is_month_with_30_days(month: i32) -> (result: bool)
    requires 1 <= month <= 12
    ensures result <==> (month == 4 || month == 6 || month == 9 || month == 11)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0793,verus,dafnybench,dafny-synthesis_task_id_769_Difference,,,"use vstd::prelude::*;

verus! {",,"fn difference(a: Seq<int>, b: Seq<int>) -> (diff: Seq<int>)
    ensures
        forall|x: int| diff.contains(x) <==> (a.contains(x) && !b.contains(x)),
        forall|i: int, j: int| 0 <= i < j < diff.len() ==> diff.index(i) != diff.index(j),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0794,verus,dafnybench,dafny-synthesis_task_id_770_SumOfFourthPowerOfOddNumbers,,,"use vstd::prelude::*;

verus! {",,"fn sum_of_fourth_power_of_odd_numbers(n: i32) -> (sum: i32)
    requires n > 0,
    ensures sum == n * (2 * n + 1) * (24 * n * n * n - 12 * n * n - 14 * n + 7) / 15,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0795,verus,dafnybench,dafny-synthesis_task_id_775_IsOddAtIndexOdd,,,"use vstd::prelude::*;

verus! {

spec fn is_odd(n: int) -> bool {
    n % 2 == 1
}",,"fn is_odd_at_index_odd(a: &[int]) -> (result: bool)
    ensures result <==> forall|i: int| 0 <= i < a.len() ==> (is_odd(i) ==> is_odd(a[i]))","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVD00,0.85
VD0796,verus,dafnybench,dafny-synthesis_task_id_776_CountVowelNeighbors,,,"use vstd::prelude::*;

verus! {

spec fn is_vowel(c: char) -> bool {
    c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||
    c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U'
}",,"fn count_vowel_neighbors(s: &str) -> (count: usize)
    ensures 
        count >= 0 &&
        count == Set::new(|i: int| 1 <= i < s@.len() - 1 && 
                          is_vowel(s@[i-1]) && 
                          is_vowel(s@[i+1])).len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0797,verus,dafnybench,dafny-synthesis_task_id_784_FirstEvenOddIndices,,"// This is the postcondition that ensures that it's the first, not just any","use vstd::prelude::*;

verus! {

spec fn is_even(n: int) -> bool {
    n % 2 == 0
}

spec fn is_odd(n: int) -> bool {
    n % 2 != 0
}

spec fn is_first_even(even_index: int, lst: Seq<i32>) -> bool
    recommends 0 <= even_index < lst.len(), is_even(lst[even_index] as int)
{
    forall|i: int| 0 <= i < even_index ==> is_odd(lst[i] as int)
}

spec fn is_first_odd(odd_index: int, lst: Seq<i32>) -> bool
    recommends 0 <= odd_index < lst.len(), is_odd(lst[odd_index] as int)
{
    forall|i: int| 0 <= i < odd_index ==> is_even(lst[i] as int)
}",,"fn first_even_odd_indices(lst: Vec<i32>) -> (result: (usize, usize))
    requires lst.len() >= 2,
             exists|i: int| 0 <= i < lst.len() && is_even(lst[i] as int),
             exists|i: int| 0 <= i < lst.len() && is_odd(lst[i] as int)
    ensures 0 <= result.0 < lst.len(),
            0 <= result.1 < lst.len(),

            is_even(lst[result.0 as int] as int) && is_first_even(result.0 as int, lst@),
            is_odd(lst[result.1 as int] as int) && is_first_odd(result.1 as int, lst@)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0798,verus,dafnybench,dafny-synthesis_task_id_784_ProductEvenOdd,,,"use vstd::prelude::*;

verus! {

spec fn is_even(n: int) -> bool {
    n % 2 == 0
}

spec fn is_odd(n: int) -> bool {
    n % 2 != 0
}

spec fn is_first_even(even_index: int, lst: Seq<int>) -> bool
    recommends 0 <= even_index < lst.len() && is_even(lst[even_index])
{
    forall|i: int| 0 <= i < even_index ==> is_odd(lst[i])
}

spec fn is_first_odd(odd_index: int, lst: Seq<int>) -> bool
    recommends 0 <= odd_index < lst.len() && is_odd(lst[odd_index])
{
    forall|i: int| 0 <= i < odd_index ==> is_even(lst[i])
}

fn first_even_odd_indices(lst: Seq<int>) -> (r: (usize, usize))
    requires lst.len() >= 2,
             (exists|i: int| 0 <= i < lst.len() && is_even(lst[i])),
             (exists|i: int| 0 <= i < lst.len() && is_odd(lst[i])),
    ensures ({
        let (even_index, odd_index) = r;
        &&& 0 <= even_index < lst.len()
        &&& 0 <= odd_index < lst.len()
        &&& is_even(lst[even_index as int]) && is_first_even(even_index as int, lst)
        &&& is_odd(lst[odd_index as int]) && is_first_odd(odd_index as int, lst)
    }),
{
  assume(false);
  (0, 0)
}",,"fn product_even_odd(lst: Seq<int>) -> (product: i32)
    requires 
        lst.len() >= 2,
        exists|i: int| 0 <= i < lst.len() && is_even(lst[i]),
        exists|i: int| 0 <= i < lst.len() && is_odd(lst[i])
    ensures exists|i: int, j: int| 0 <= i < lst.len() && is_even(lst[i]) && is_first_even(i, lst) && 
                                   0 <= j < lst.len() && is_odd(lst[j])  && is_first_odd(j, lst) && product as int == lst[i] * lst[j]","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0799,verus,dafnybench,dafny-synthesis_task_id_790_IsEvenAtIndexEven,,,"use vstd::prelude::*;

verus! {

spec fn is_even(n: int) -> bool {
    n % 2 == 0
}",,"fn is_even_at_index_even(lst: &Vec<i32>) -> (result: bool)
    ensures result <==> (forall|i: int| 0 <= i < lst.len() ==> (is_even(i) ==> is_even(lst[i] as int)))","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVD00,0.85
VD0800,verus,dafnybench,dafny-synthesis_task_id_792_CountLists,,,"use vstd::prelude::*;

verus! {",,"fn count_lists(lists: &Vec<Vec<int>>) -> (count: usize)
    ensures 
        count >= 0,
        count == lists.len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0801,verus,dafnybench,dafny-synthesis_task_id_793_LastPosition,,,"use vstd::prelude::*;

verus! {",,"fn last_position(arr: &Vec<i32>, elem: i32) -> (pos: i32)
    requires 
        arr.len() > 0,
        forall|i: int, j: int| 0 <= i < j < arr.len() ==> arr[i] <= arr[j],
    ensures
        pos == -1 || (0 <= pos < arr.len() && arr[pos as int] == elem && 
            (pos >= arr.len() - 1 || arr[(pos + 1) as int] > elem)),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0802,verus,dafnybench,dafny-synthesis_task_id_798_ArraySum,,,"use vstd::prelude::*;

verus! {

spec fn sum_to(a: &[i32], n: int) -> int
    recommends 0 <= n <= a.len()
    decreases n
{
    if n <= 0 { 0 } else { sum_to(a, n - 1) + a[n - 1] }
}",,"fn array_sum(a: &[i32]) -> (result: i32)
    ensures result == sum_to(a, a.len() as int)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0803,verus,dafnybench,dafny-synthesis_task_id_799_RotateLeftBits,,,"use vstd::prelude::*;

verus! {",,"fn rotate_left_bits(n: u32, d: int) -> (result: u32)
    requires 0 <= d < 32
    ensures result == ((n << d) | (n >> (32 - d)))","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0804,verus,dafnybench,dafny-synthesis_task_id_801_CountEqualNumbers,,,"use vstd::prelude::*;

verus! {",,"fn count_equal_numbers(a: i32, b: i32, c: i32) -> (count: i32)
    ensures 
        count >= 0 && count <= 3,
        (count == 3) <==> (a == b && b == c),
        (count == 2) <==> ((a == b && b != c) || (a != b && b == c) || (a == c && b != c)),
        (count == 1) <==> (a != b && b != c && a != c),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0805,verus,dafnybench,dafny-synthesis_task_id_803_IsPerfectSquare,,,"use vstd::prelude::*;

verus! {",,"fn is_perfect_square(n: int) -> (result: bool)
    requires 
        n >= 0,
    ensures 
        result == true ==> (exists|i: int| 0 <= i <= n && #[trigger] (i * i) == n),
        result == false ==> (forall|a: int| 0 < a*a < n ==> #[trigger] (a*a) != n),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0806,verus,dafnybench,dafny-synthesis_task_id_804_IsProductEven,,,"use vstd::prelude::*;

verus! {

spec fn is_even(n: int) -> bool {
    n % 2 == 0
}",,"fn is_product_even(a: &[int]) -> (result: bool)
    ensures result <==> exists|i: int| 0 <= i < a.len() && is_even(a@[i])","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0807,verus,dafnybench,dafny-synthesis_task_id_807_FindFirstOdd,,,"use vstd::prelude::*;

verus! {

spec fn is_odd(x: int) -> bool {
    x % 2 != 0
}",,"fn find_first_odd(a: &[i32]) -> (result: (bool, usize))
    ensures 
        (!result.0 ==> (forall|i: int| 0 <= i < a.len() ==> !is_odd(a[i] as int))) &&
        (result.0 ==> (0 <= result.1 < a.len() && 
                      is_odd(a[result.1 as int] as int) && 
                      (forall|i: int| 0 <= i < result.1 ==> !is_odd(a[i] as int))))","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVD00,0.85
VD0809,verus,dafnybench,dafny-synthesis_task_id_809_IsSmaller,,,"use vstd::prelude::*;

verus! {",,"fn is_smaller(a: Seq<int>, b: Seq<int>) -> (result: bool)
    requires 
        a.len() == b.len(),
    ensures 
        result <==> forall|i: int| 0 <= i < a.len() ==> a[i] > b[i],
        !result <==> exists|i: int| 0 <= i < a.len() && a[i] <= b[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0823,verus,dafnybench,dafny_examples_tmp_tmp8qotd4ez_leetcode_0001-two-sum_TwoSum,,"// If this invariant is added explicitly to the loop then the verfication never finishes.

// It could be {:opaque} for a more controlled verification:

// assert InMap([], m, target) by {

//   reveal InMap();

// }","use vstd::prelude::*;

verus! {

spec fn in_map(nums: Seq<int>, m: Map<int, int>, t: int) -> bool {
    forall|j: int| 0 <= j < nums.len() ==> m.contains_key(t - nums[j])
}",,"fn two_sum(nums: &[i32], target: i32) -> (r: (i32, i32))
    ensures 
        0 <= r.0 ==> 0 <= r.0 < r.1 < nums.len() && 
                     nums.view()[r.0 as int] + nums.view()[r.1 as int] == target &&
                     forall|i: int, j: int| 0 <= i < j < r.1 ==> nums.view()[i] + nums.view()[j] != target,
        r.0 == -1 <==> forall|i: int, j: int| 0 <= i < j < nums.len() ==> nums.view()[i] + nums.view()[j] != target,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0824,verus,dafnybench,dafny_examples_tmp_tmp8qotd4ez_leetcode_0027-remove-element_RemoveElement,,,"use vstd::prelude::*;

verus! {",,"fn remove_element(nums: &mut Vec<i32>, val: i32) -> (newLength: usize)
    ensures 
        0 <= newLength <= nums.len(),
        forall|i: int| 0 <= i < newLength ==> nums[i] != val,
        nums@.subrange(0, newLength as int).to_multiset() == 
            old(nums)@.to_multiset().remove(val),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0825,verus,dafnybench,dafny_examples_tmp_tmp8qotd4ez_leetcode_0069-sqrt_mySqrt,,// Author: Shaobo He,"use vstd::prelude::*;

verus! {

spec fn sqrt(x: int, r: int) -> bool {
    r * r <= x && (r + 1) * (r + 1) > x
}",,"#[verifier::exec_allows_no_decreases_clause]
fn mySqrt(x: int) -> (res: int)
    requires 0 <= x,
    ensures sqrt(x, res),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0826,verus,dafnybench,dafny_examples_tmp_tmp8qotd4ez_leetcode_0070-climbing-stairs_ClimbStairs,,// A simple specification,"use vstd::prelude::*;

verus! {

spec fn stairs(n: nat) -> nat
    decreases n
{
    if n <= 1 { 1 } else { stairs((n - 2) as nat) + stairs((n - 1) as nat) }
}",,"fn climb_stairs(n: u32) -> (r: u32)
    requires n >= 0
    ensures r == stairs(n as nat)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0828,verus,dafnybench,dafny_examples_tmp_tmp8qotd4ez_test_shuffle_getRandomDataEntry,,,"use vstd::prelude::*;

verus! {

fn random(a: int, b: int) -> (r: int)
    ensures a <= b ==> a <= r <= b
{
    assume(false);
    a
}

spec fn set_of_seq<T>(s: Seq<T>) -> Set<T> {
    s.to_set()
}",,"fn get_random_data_entry<T: PartialEq + Clone>(m_work_list: &Vec<T>, avoid_set: &Vec<T>) -> (e: T)
    requires m_work_list.len() > 0
    ensures 
        set_of_seq(avoid_set@).subset_of(set_of_seq(m_work_list@)) && 
        set_of_seq(avoid_set@) != set_of_seq(m_work_list@) ==> !avoid_set@.contains(e),
        (forall |x: T| avoid_set@.contains(x) ==> m_work_list@.contains(x)) && 
        avoid_set@ != m_work_list@ ==> m_work_list@.contains(e)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0829,verus,dafnybench,dafny_examples_tmp_tmp8qotd4ez_test_shuffle_swap,,,"use vstd::prelude::*;

verus! {

spec fn set_of_seq<T>(s: Seq<T>) -> Set<T> {
    Set::new(|x: T| s.contains(x))
}",,"fn swap<T>(a: &mut Vec<T>, i: usize, j: usize)
    requires 
        i < old(a).len(),
        j < old(a).len(),
    ensures
        a[i as int] == old(a)[j as int],
        a[j as int] == old(a)[i as int],
        forall|m: int| 0 <= m < a.len() && m != i && m != j ==> a[m] == old(a)[m],
        a@.to_multiset() == old(a)@.to_multiset(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0830,verus,dafnybench,dafny_misc_tmp_tmpg4vzlnm1_rosetta_code_factorial_IterativeFactorial,,"// recursive definition of factorial

// iterative implementation of factorial

// prevent overflow","use vstd::prelude::*;

verus! {

spec fn factorial(n: nat) -> nat
    decreases n
{
    if n == 0 { 1 } else { n * factorial((n - 1) as nat) }
}",,"fn iterative_factorial(n: u32) -> (result: u32)
    requires n < 13,
    ensures result == factorial(n as nat)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0831,verus,dafnybench,dafny_misc_tmp_tmpg4vzlnm1_rosetta_code_fibonacci_sequence_FibonacciIterative,,"// definition of Fibonacci numbers

// iterative calculation of Fibonacci numbers

// practical bound to prevent overflow","use vstd::prelude::*;

verus! {

spec fn fibonacci(n: nat) -> nat
    decreases n
{
    if n == 0 {
        0
    } else if n == 1 {
        1
    } else {
        fibonacci((n - 1) as nat) + fibonacci((n - 2) as nat)
    }
}",,"fn fibonacci_iterative(n: u64) -> (f: u64)
    requires n < 100
    ensures f == fibonacci(n as nat)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0834,verus,dafnybench,dafny_projects_tmp_tmpjutqwjv4_tutorial_tutorial_Find,,"// Working through https://dafny.org/dafny/OnlineTutorial/guide

// https://dafny.org/dafny/OnlineTutorial/ValueTypes

// https://dafny.org/dafny/OnlineTutorial/Lemmas

// simplified constraint

// and the rest of the sequence is a valid path

// path is nonempty

// it starts and ends correctly

// and it is a valid path","use vstd::prelude::*;

verus! {

spec fn fib(n: nat) -> nat
    decreases n
{
    if n == 0 { 0 }
    else if n == 1 { 1 }
    else { fib((n - 1) as nat) + fib((n - 2) as nat) }
}

spec fn sorted(a: &[int]) -> bool {
    forall|n: int, m: int| 0 <= n < m < a.len() ==> a[n] <= a[m]
}

spec fn update(s: Seq<int>, i: int, v: int) -> Seq<int> {
    s.subrange(0, i).add(seq![v]).add(s.subrange(i + 1, s.len() as int))
}

spec fn count(a: Seq<bool>) -> nat
    decreases a.len()
{
    if a.len() == 0 { 0nat }
    else {
        (if a[0] { 1nat } else { 0nat }) + count(a.subrange(1, a.len() as int))
    }
}

struct Node {
    next: Vec<usize>
}

spec fn closed(graph: Set<usize>) -> bool {
    forall|i: usize| graph.contains(i) ==> 
        forall|k: usize| k < 10 ==>
            graph.contains(k) && k != i
}

spec fn path(p: Seq<usize>, graph: Set<usize>) -> bool
    decreases p.len()
{
    closed(graph) && 0 < p.len() &&
    graph.contains(p[0]) &&
    (p.len() > 1 ==> 
     path(p.subrange(1, p.len() as int), graph))
}

spec fn pathSpecific(p: Seq<usize>, start: usize, end: usize, graph: Set<usize>) -> bool {
    closed(graph) &&
    0 < p.len() &&
    start == p[0] && end == p[p.len() - 1] &&
    path(p, graph)
}",,"fn Find(a: &[int], key: int) -> (index: i32)
    ensures 
        0 <= index ==> index < a.len() && a[index as int] == key,
        index < 0 ==> (forall|k: int| 0 <= k < a.len() ==> a[k] != key),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0835,verus,dafnybench,dafny_projects_tmp_tmpjutqwjv4_tutorial_tutorial_FindZero,,"// Working through https://dafny.org/dafny/OnlineTutorial/guide

// https://dafny.org/dafny/OnlineTutorial/ValueTypes

// https://dafny.org/dafny/OnlineTutorial/Lemmas

// Using int IDs instead of references for simplicity

// Simplified for translation

// path is nonempty

// it starts and ends correctly

// and it is a valid path","use vstd::prelude::*;

verus! {

spec fn fib(n: nat) -> nat 
    decreases n
{
    if n == 0 { 0nat }
    else if n == 1 { 1nat }
    else { fib((n - 1) as nat) + fib((n - 2) as nat) }
}

spec fn sorted(a: Seq<int>) -> bool {
    forall|n: int, m: int| 0 <= n < m < a.len() ==> a[n] <= a[m]
}

spec fn update(s: Seq<int>, i: int, v: int) -> Seq<int>
{
    s.subrange(0, i).add(seq![v]).add(s.subrange(i + 1, s.len() as int))
}

spec fn count(a: Seq<bool>) -> nat
    decreases a.len()
{
    if a.len() == 0 { 
        0nat
    } else {
        (if a[0] { 1nat } else { 0nat }) + count(a.subrange(1, a.len() as int))
    }
}

struct Node {
    next: Seq<int>,
}

spec fn closed(graph: Set<int>) -> bool {
    true
}

spec fn path(p: Seq<int>, graph: Set<int>) -> bool 
    decreases p.len()
{
    closed(graph) && 0 < p.len() &&
    graph.contains(p[0]) &&
    (p.len() > 1 ==> 
        path(p.subrange(1, p.len() as int), graph))
}

spec fn path_specific(p: Seq<int>, start: int, end: int, graph: Set<int>) -> bool {
    closed(graph) &&
    0 < p.len() &&
    start == p[0] && end == p[p.len() - 1] &&
    path(p, graph)
}",,"fn find_zero(a: &[int]) -> (index: i32)
    requires 
        forall|i: int| #![trigger a[i]] 0 <= i < a.len() ==> 0 <= a[i],
        forall|i: int| #![trigger a[i]] 0 < i < a.len() ==> a[i-1] - 1 <= a[i],
    ensures 
        index < 0 ==> forall|i: int| #![trigger a[i]] 0 <= i < a.len() ==> a[i] != 0,
        0 <= index ==> index < a.len() && a[index as int] == 0,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,0.7
VD0836,verus,dafnybench,dafny_tmp_tmp49a6ihvk_m4_DutchFlag,,,"use vstd::prelude::*;

verus! {

#[derive(PartialEq, Eq, Clone, Copy)]
enum Color {
    Red,
    White,
    Blue,
}

spec fn below(c: Color, d: Color) -> bool {
    c == Color::Red || c == d || d == Color::Blue
}",,"fn dutch_flag(a: &mut Vec<Color>)
    ensures 
        forall|i: int, j: int| 0 <= i < j < a.len() ==> below(a[i], a[j]),
        a@.to_multiset() == old(a)@.to_multiset(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0839,verus,dafnybench,dafny_tmp_tmp59p638nn_examples_SelectionSort_SelectionSort,,,"use vstd::prelude::*;

verus! {

spec fn ordered(a: Seq<int>, left: int, right: int) -> bool {
    &&& 0 <= left <= right <= a.len()
    &&& forall |i: int| #![trigger a[i]] left < i < right ==> a[i-1] <= a[i]
}",,"fn selection_sort(a: &mut Vec<int>)
    ensures 
        ordered(a@, 0, a.len() as int),
        a.len() == old(a).len(),
        a@.to_multiset() =~= old(a)@.to_multiset(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0840,verus,dafnybench,dafny_tmp_tmp59p638nn_examples_SelectionSort_SelectionnSort,,"// Two-state predicate for checking if multiset is preserved

// Predicate for checking if array slice is ordered

// Two-state predicate for sorted array","use vstd::prelude::*;

verus! {

spec fn preserved(a_old: Seq<i32>, a_new: Seq<i32>, left: nat, right: nat) -> bool
    recommends left <= right <= a_old.len() && a_old.len() == a_new.len()
{
    a_old.subrange(left as int, right as int).to_multiset() == a_new.subrange(left as int, right as int).to_multiset()
}

spec fn ordered(a: Seq<i32>, left: nat, right: nat) -> bool
    recommends left <= right <= a.len()
{
    forall|i: int| #![trigger a[i]] left < i < right ==> a[i-1] <= a[i]
}

spec fn sorted(a_old: Seq<i32>, a_new: Seq<i32>) -> bool
    recommends a_old.len() == a_new.len()
{
    ordered(a_new, 0, a_new.len() as nat) && preserved(a_old, a_new, 0, a_old.len() as nat)
}",,"fn selection_sort(a: &mut Vec<i32>)
    ensures sorted(old(a)@, a@)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0843,verus,dafnybench,dafny_tmp_tmp59p638nn_examples_realExponent_pow,,,"use vstd::prelude::*;

verus! {

uninterp spec fn power(n: int, alpha: int) -> int;

uninterp spec fn log(n: int, alpha: int) -> int;",,"fn pow(n: u32, alpha: i32) -> (product: i32)
    requires n > 0 && alpha > 0
    ensures product == power(n as int, alpha as int)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0844,verus,dafnybench,feup-mfes_tmp_tmp6_a1y5a5_examples_SelectionSort_findMin,,"/* 
 * Formal verification of the selection sort algorithm with Verus.
 * FEUP, MIEIC, MFES, 2020/21.
 */

// Checks if array 'a' is sorted between positions 'from' (inclusive) and 'to' (exclusive).

// Sorts array 'a' using the selection sort algorithm.

// Finds the position of a minimum value in non-empty subarray 'a' between positions 

// 'from' (inclusive) and 'to' (exclusive)","use vstd::prelude::*;

verus! {

pub open spec fn is_sorted(a: &[i32], from: usize, to: usize) -> bool {
    &&& from <= to <= a.len()
    &&& forall|i: int, j: int| from <= i < j < to ==> a[i] <= a[j]
}",,"fn find_min(a: &mut [i32], from: usize, to: usize) -> (index: usize)
    requires 
        0 <= from < to <= old(a).len(),
    ensures
        from <= index < to,
        forall|k: int| from <= k < to ==> old(a)[k] >= old(a)[index as int],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0845,verus,dafnybench,feup-mfes_tmp_tmp6_a1y5a5_examples_SelectionSort_selectionSort,,"/* 
* Formal verification of the selection sort algorithm with Verus.
* FEUP, MIEIC, MFES, 2020/21.
*/

// Checks if array 'a' is sorted between positions 'from' (inclusive) and 'to' (exclusive).

// Sorts array 'a' using the selection sort algorithm.

// Finds the position of a minimum value in non-empty subarray 'a' between positions 

// 'from' (inclusive) and 'to' (exclusive)","use vstd::prelude::*;

verus! {

spec fn is_sorted(a: Seq<i32>, from: int, to: int) -> bool
    recommends 0 <= from <= to <= a.len()
{
    forall|i: int, j: int| from <= i < j < to ==> a[i] <= a[j]
}

fn find_min(a: &Vec<i32>, from: usize, to: usize) -> (index: usize)
    requires 
        0 <= from < to <= a.len(),
    ensures 
        from <= index < to,
        forall|k: int| from as int <= k < to as int ==> a@[k] >= a@[index as int],
{
    assume(false);
    0
}",,"fn selection_sort(a: &mut Vec<i32>)
    ensures 
        is_sorted(a@, 0, a@.len() as int),
        a@.to_multiset() == old(a)@.to_multiset(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0847,verus,dafnybench,formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_DivMod1,,"/*
Verus include 2 limbaje:
    * un limbaj pentru specificare 
        MSFOL (ce am discutat până acum)
        adnotări care să ajute în procesul de verificare
    * un limbaj pentru scris programe
*/

// Exemplu de program

/*
    triple Hoare (| P |) S (| Q |) 
*/

// varianta assume-assert

// varianta requires-ensures

/*
regula pentru while
*/

// varianta cu assert

/*
*/

// varianta cu invariant

//specificarea sumei de patrate

/*
*/

// verificarea programului pentru suma de patrate

// SqrSumRec(n) = 0^2 + 1^2 + 2^2 + ... + n^2 == n(n+1)(2n+1)/6

// Base case holds automatically

// Inductive step would require additional arithmetic reasoning

/*
spec fn SqrSumBy6(n: int) -> int
{
    n * (n + 1) * (2 * n + 1) 
}

proof fn L(n: int) // it takes a while
    decreases n
    requires n >= 0
    ensures  SqrSumBy6(n) == 6 * SqrSumRec(n)
{
    if n == 0 {
    } else {
        assert(n > 0);
        L(n-1);
        assert(SqrSumBy6(n-1) == n*(n-1)*(2*n - 1));
        assert(SqrSumBy6(n-1) == 6*SqrSumRec(n-1));
        assert(6*SqrSumRec(n-1) == n*(n-1)*(2*n - 1));
        // Sequential assertions replacing calc chains
        assert(n*((n-1)*(2*n - 1)) == n*(2*n*(n-1) - n + 1));
        assert(n*(2*n*(n-1) - n + 1) == n*(2*n*n - 3*n + 1));

        assert(2*n*n + n == (2*n + 1)*n);

        assert((2*n + 1)*n + (2*n + 1) == (2*n + 1)*(n+1));

        // Additional algebraic steps would be needed here
    }
}

*/","use vstd::prelude::*;

verus! {

spec fn SqrSumRec(n: int) -> int
    decreases n when n >= 0
{
    if n <= 0 { 0 } else { n*n + SqrSumRec(n-1) }
}

proof fn L1(n: int)
    requires n >= 0
    ensures SqrSumRec(n) == n*(n+1)*(2*n + 1)/6
    decreases n
{
    if n == 0 {

    } else {
        L1(n-1);

    }
}",,"fn DivMod1(a: u32, b: u32) -> (result: (u32, u32))
    requires b > 0 && a >= 0
    ensures a == b * result.0 + result.1 && 0 <= result.1 < b","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0849,verus,dafnybench,formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_SqrSum1,,"/*
Verus includes 2 languages:
    * a language for specification 
        MSFOL (what we've discussed so far)
        annotations to help in the verification process
    * a language for writing programs
*/

// Example program

/*
    triple Hoare (| P |) S (| Q |) 
*/

// assume-assert variant

// requires-ensures variant

/*
rule for while
*/

// assert variant

/*
*/

// invariant variant

//specification of sum of squares

/*

*/

// verification of the program for sum of squares

// SqrSumRec(n) = 0^2 + 1^2 + 2^2 + ... + n^2 == n(n+1)(2n+1)/6

//OK

/*
spec fn sqr_sum_by_6(n: int) -> int
{
    n * (n + 1) * (2 * n + 1) 
}

proof fn l(n: int) // it takes a while
    requires n >= 0
    ensures sqr_sum_by_6(n) == 6 * sqr_sum_rec(n)
    decreases n
{
    if n == 0 {}
    else {
        assert(n > 0);
        l(n-1);
        assert(sqr_sum_by_6(n-1) == n*(n-1)*(2*n - 1));
        assert(sqr_sum_by_6(n-1) == 6*sqr_sum_rec(n-1));
        assert(6*sqr_sum_rec(n-1) == n*(n-1)*(2*n - 1));
        calc! (==)
        n*((n-1)*(2*n - 1)); {
            n*(2*n*(n-1) - n + 1); {
                n*(2*n*n - 3*n + 1); {
                    n*(2*n*n - 3*n + 1);
                }
            }
        }
        calc! (==)
        2*n*n + n; {
            (2*n + 1)*n;
        }
        calc! (==)
        (2*n + 1)*n + (2*n + 1); {
            (2*n + 1)*(n+1);
        }
        calc! (==)
        n*((n-1)*(2*n - 1)) + 6*n*n; {
            n*(2*n*(n-1) - n + 1) + 6*n*n; {
                n*(2*n*(n-1) - n + 1) + 6*n*n; {
                    n*(2*n*n - 3*n + 1) + 6*n*n; {
                        n*(2*n*n - 3*n + 1 + 6*n); {
                            n*(2*n*n + 6*n - 3*n + 1); {
                                n*(2*n*n + 3*n + 1); {
                                    n*(2*n*n + n + (2*n + 1)); {
                                        n*((2*n + 1)*n + (2*n + 1)); {
                                            n*((2*n + 1)*(n+1));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

*/

// s = 0^2 + 1^2 + 2^2 + ... + n^2 == n(n+1)(2n+1)/6","use vstd::prelude::*;

verus! {

spec fn sqr_sum_rec(n: int) -> int
    recommends n >= 0
    decreases n
{
    if n == 0 { 0 } else { n*n + sqr_sum_rec(n-1) }
}

proof fn l1(n: int)
    requires n >= 0
    ensures sqr_sum_rec(n) == n*(n+1)*(2*n + 1)/6
    decreases n
{

}",,"fn sqr_sum1(n: int) -> (s: int)
    requires n >= 0
    ensures s == sqr_sum_rec(n)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0850,verus,dafnybench,formal-verification_tmp_tmpoepcssay_strings3_haveCommonKSubstring,,"// ensures  !res ==> !isSubstringPred(sub, str)

// This postcondition follows from the above lemma.

// This postcondition follows from the above lemma.","use vstd::prelude::*;

verus! {

fn isPrefix(pre: Seq<char>, str: Seq<char>) -> (res: bool)
    ensures
        !res <==> isNotPrefixPred(pre, str),
        res <==> isPrefixPred(pre, str),
{
    assume(false);
    true
}

spec fn isPrefixPred(pre: Seq<char>, str: Seq<char>) -> bool {
    (pre.len() <= str.len()) && 
    pre == str.subrange(0, pre.len() as int)
}

spec fn isNotPrefixPred(pre: Seq<char>, str: Seq<char>) -> bool {
    (pre.len() > str.len()) || 
    pre != str.subrange(0, pre.len() as int)
}

spec fn isSubstringPred(sub: Seq<char>, str: Seq<char>) -> bool {
    exists|i: int| 0 <= i <= str.len() && isPrefixPred(sub, str.subrange(i, str.len() as int))
}

spec fn isNotSubstringPred(sub: Seq<char>, str: Seq<char>) -> bool {
    forall|i: int| 0 <= i <= str.len() ==> isNotPrefixPred(sub, str.subrange(i, str.len() as int))
}

fn isSubstring(sub: Seq<char>, str: Seq<char>) -> (res: bool)
    ensures
        res <==> isSubstringPred(sub, str),
        res ==> isSubstringPred(sub, str),

        isSubstringPred(sub, str) ==> res,
        isSubstringPred(sub, str) ==> res,
        !res <==> isNotSubstringPred(sub, str),
{
    assume(false);
    true
}

spec fn haveCommonKSubstringPred(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool {
    exists|i1: int, j1: int| 0 <= i1 <= str1.len() - k && j1 == i1 + k && isSubstringPred(str1.subrange(i1, j1), str2)
}

spec fn haveNotCommonKSubstringPred(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool {
    forall|i1: int, j1: int| 0 <= i1 <= str1.len() - k && j1 == i1 + k ==> isNotSubstringPred(str1.subrange(i1, j1), str2)
}",,"fn haveCommonKSubstring(k: nat, str1: Seq<char>, str2: Seq<char>) -> (found: bool)
    ensures
        found <==> haveCommonKSubstringPred(k, str1, str2),
        !found <==> haveNotCommonKSubstringPred(k, str1, str2),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0851,verus,dafnybench,formal-verification_tmp_tmpoepcssay_strings3_isPrefix,,,"use vstd::prelude::*;

verus! {

spec fn is_prefix_pred(pre: Seq<char>, str: Seq<char>) -> bool {
    pre.len() <= str.len() && 
    pre == str.subrange(0, pre.len() as int)
}

spec fn is_not_prefix_pred(pre: Seq<char>, str: Seq<char>) -> bool {
    pre.len() > str.len() || 
    pre != str.subrange(0, pre.len() as int)
}

spec fn is_substring_pred(sub: Seq<char>, str: Seq<char>) -> bool {
    exists|i: int| 0 <= i <= str.len() && is_prefix_pred(sub, str.subrange(i, str.len() as int))
}

spec fn is_not_substring_pred(sub: Seq<char>, str: Seq<char>) -> bool {
    forall|i: int| 0 <= i <= str.len() ==> is_not_prefix_pred(sub, str.subrange(i, str.len() as int))
}

spec fn have_common_k_substring_pred(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool {
    exists|i1: int, j1: int| 0 <= i1 <= str1.len() - k && j1 == i1 + k && is_substring_pred(str1.subrange(i1, j1), str2)
}

spec fn have_not_common_k_substring_pred(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool {
    forall|i1: int, j1: int| 0 <= i1 <= str1.len() - k && j1 == i1 + k ==> is_not_substring_pred(str1.subrange(i1, j1), str2)
}",,"fn is_prefix(pre: Seq<char>, str: Seq<char>) -> (res: bool)
    ensures
        !res <==> is_not_prefix_pred(pre, str),
        res <==> is_prefix_pred(pre, str),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0852,verus,dafnybench,formal-verification_tmp_tmpoepcssay_strings3_isSubstring,,"// ensures  !res ==> !is_substring_pred(sub, str)

// This postcondition follows from the above lemma.","use vstd::prelude::*;

verus! {

spec fn is_prefix_pred(pre: Seq<char>, str: Seq<char>) -> bool {
    pre.len() <= str.len() && 
    pre == str.subrange(0, pre.len() as int)
}

spec fn is_not_prefix_pred(pre: Seq<char>, str: Seq<char>) -> bool {
    pre.len() > str.len() || 
    pre != str.subrange(0, pre.len() as int)
}

fn is_prefix(pre: Seq<char>, str: Seq<char>) -> (res: bool)
    ensures
        !res <==> is_not_prefix_pred(pre, str),
        res <==> is_prefix_pred(pre, str),
{
    assume(false);
    true
}

spec fn is_substring_pred(sub: Seq<char>, str: Seq<char>) -> bool {
    exists|i: int| 0 <= i <= str.len() && is_prefix_pred(sub, str.subrange(i, str.len() as int))
}

spec fn is_not_substring_pred(sub: Seq<char>, str: Seq<char>) -> bool {
    forall|i: int| 0 <= i <= str.len() ==> is_not_prefix_pred(sub, str.subrange(i, str.len() as int))
}

spec fn have_common_k_substring_pred(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool {
    exists|i1: int, j1: int| 0 <= i1 <= str1.len() as int - k as int && j1 == i1 + k as int && is_substring_pred(str1.subrange(i1, j1), str2)
}

spec fn have_not_common_k_substring_pred(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool {
    forall|i1: int, j1: int| 0 <= i1 <= str1.len() as int - k as int && j1 == i1 + k as int ==> is_not_substring_pred(str1.subrange(i1, j1), str2)
}",,"fn is_substring(sub: Seq<char>, str: Seq<char>) -> (res: bool)
    ensures
        res <==> is_substring_pred(sub, str),
        res ==> is_substring_pred(sub, str),

        is_substring_pred(sub, str) ==> res,
        is_substring_pred(sub, str) ==> res,
        !res <==> is_not_substring_pred(sub, str),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0853,verus,dafnybench,formal-verification_tmp_tmpoepcssay_strings3_maxCommonSubstringLength,,,"use vstd::prelude::*;

verus! {

spec fn is_substring(sub: Seq<char>, str: Seq<char>) -> bool 
    decreases str.len()
{
    if sub.len() == 0 {
        true
    } else if str.len() < sub.len() {
        false
    } else {
        (str.subrange(0, sub.len() as int) == sub) || is_substring(sub, str.subrange(1, str.len() as int))
    }
}

spec fn is_prefix_pred(pre: Seq<char>, str: Seq<char>) -> bool {
    pre.len() <= str.len() && 
    pre == str.subrange(0, pre.len() as int)
}

spec fn is_not_prefix_pred(pre: Seq<char>, str: Seq<char>) -> bool {
    pre.len() > str.len() || 
    pre != str.subrange(0, pre.len() as int)
}

spec fn is_substring_pred(sub: Seq<char>, str: Seq<char>) -> bool {
    exists|i: int| #![auto] 0 <= i <= str.len() && is_prefix_pred(sub, str.subrange(i, str.len() as int))
}

spec fn is_not_substring_pred(sub: Seq<char>, str: Seq<char>) -> bool {
    forall|i: int| #![auto] 0 <= i <= str.len() ==> is_not_prefix_pred(sub, str.subrange(i, str.len() as int))
}

spec fn have_common_k_substring_pred(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool {
    exists|i1: int, j1: int| #![auto] 0 <= i1 <= str1.len() - k && j1 == i1 + k && is_substring_pred(str1.subrange(i1, j1), str2)
}

spec fn have_not_common_k_substring_pred(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool {
    forall|i1: int, j1: int| #![auto] 0 <= i1 <= str1.len() - k && j1 == i1 + k ==> is_not_substring_pred(str1.subrange(i1, j1), str2)
}

fn have_common_k_substring(k: usize, str1: Seq<char>, str2: Seq<char>) -> (found: bool)
    ensures 
        found <==> have_common_k_substring_pred(k as nat, str1, str2),
        !found <==> have_not_common_k_substring_pred(k as nat, str1, str2),
{
    assume(false);
    false
}",,"fn max_common_substring_length(str1: Seq<char>, str2: Seq<char>) -> (len: usize)
    requires str1.len() <= str2.len(),
    ensures 
        forall|k: nat| #![auto] len < k <= str1.len() ==> !have_common_k_substring_pred(k, str1, str2),
        have_common_k_substring_pred(len as nat, str1, str2),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0854,verus,dafnybench,formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex1_PalVerify,,"// ex3errors.dfy in Assignment 1

// verify that an array of characters is a Palindrome

/*
A Palindrome is a word that is the same when written forwards and when written backwards. 
For example, the word ""refer"" is a Palindrome.
The method PalVerify is supposed to verify whether a word is a Palindrome, 
where the word is represented as an array of characters. 
The method was written by a novice software engineer, and contains many errors.

   i) Without changing the signature or the code in the while loop, 
      fix the method so that it veriifes the code. Do not add any Dafny predicates or functions: 
      keep the changes to a minimum.

   ii) Write a tester method (you may call it anything you like) that verifies that the 
      testcases refer, z and the empty string are Palindromes, and xy and 123421 are not. 
      The tester should not generate any output.
*/","use vstd::prelude::*;

verus! {",,"fn pal_verify(a: &Vec<char>) -> (yn: bool)
    ensures yn == true ==> (forall|i: int| 0 <= i < a.len()/2 ==> #[trigger] a[i] == #[trigger] a[a.len() - i - 1]),
            yn == false ==> (exists|i: int| #![trigger a[i], a[a.len() - i - 1]] 0 <= i < a.len()/2 && a[i] != a[a.len() - i - 1])","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0855,verus,dafnybench,formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex2_Allow42,,"/*
    i)  Write a verified method with signature
*/","use vstd::prelude::*;

verus! {",,"fn allow_42(x: i32, y: i32) -> (ret: (i32, bool))
    ensures 
        (y != 42 ==> ret.0 == (x as int / (42int - y as int)) as i32 && ret.1 == false) &&
        (y == 42 ==> ret.0 == 0 && ret.1 == true)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0856,verus,dafnybench,formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex6_BullsCows,,// see pdf 'ex6 & 7 documentation' for excercise question,"use vstd::prelude::*;

verus! {

spec fn bullspec(s: Seq<nat>, u: Seq<nat>) -> nat {
    if !(0 <= u.len() == s.len() && nomultiples(u)) {
        arbitrary()
    } else {
        reccbull(s, u, 0)
    }
}

spec fn cowspec(s: Seq<nat>, u: Seq<nat>) -> nat {
    if !(0 <= u.len() == s.len() && nomultiples(u)) {
        arbitrary()
    } else {
        recccow(s, u, 0)
    }
}

spec fn reccbull(s: Seq<nat>, u: Seq<nat>, i: int) -> nat
    decreases s.len() - i
{
    if !(0 <= i <= s.len() == u.len()) {
        arbitrary()
    } else if i == s.len() {
        0
    } else if s[i] == u[i] {
        reccbull(s, u, i + 1) + 1
    } else {
        reccbull(s, u, i + 1)
    }
}

spec fn recccow(s: Seq<nat>, u: Seq<nat>, i: int) -> nat
    decreases s.len() - i
{
    if !(0 <= i <= s.len() == u.len()) {
        arbitrary()
    } else if i == s.len() {
        0
    } else if s[i] != u[i] && s.contains(u[i]) {
        recccow(s, u, i + 1) + 1
    } else {
        recccow(s, u, i + 1)
    }
}

spec fn nomultiples(u: Seq<nat>) -> bool {
    forall|j: int, k: int| 0 <= j < k < u.len() ==> u[j] != u[k]
}",,"fn BullsCows(s: Vec<u32>, u: Vec<u32>) -> (ret: (u32, u32))
    requires 
        0 < u.len() == s.len() <= 10,
        nomultiples(s@.map(|i, x: u32| x as nat)) && nomultiples(u@.map(|i, x: u32| x as nat))
    ensures 
        ret.0 >= 0 && ret.1 >= 0,
        ret.0 as nat == bullspec(s@.map(|i, x: u32| x as nat), u@.map(|i, x: u32| x as nat)),
        ret.1 as nat == cowspec(s@.map(|i, x: u32| x as nat), u@.map(|i, x: u32| x as nat))","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0857,verus,dafnybench,formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex7_Exchanger,,"// see pdf 'ex6 & 7 documentation' for excercise question

//swaps two sequence indexes

//idea from Rustan Leino video ""Basics of specification and verification: Lecture 3, the Dutch National Flag algorithm""

//modified for 4 elements

//checks if a sequence is in base order","use vstd::prelude::*;

verus! {

#[derive(PartialEq, Eq, Clone, Copy)]
enum Bases {
    A,
    C,
    G,
    T,
}

spec fn below(first: Bases, second: Bases) -> bool {
    first == second ||
    first == Bases::A || 
    (first == Bases::C && (second == Bases::G || second == Bases::T)) || 
    (first == Bases::G && second == Bases::T) ||
    second == Bases::T
}

spec fn bordered(s: Seq<Bases>) -> bool {
    forall|j: int, k: int| 0 <= j < k < s.len() ==> below(s[j], s[k])
}",,"fn exchanger(s: Seq<Bases>, x: nat, y: nat) -> (t: Seq<Bases>)
    requires 
        0 < s.len(),
        x < s.len(),
        y < s.len(),
    ensures 
        t.len() == s.len(),
        forall|b: nat| 0 <= b < s.len() && b != x && b != y ==> t[b as int] == s[b as int],
        t[x as int] == s[y as int] && s[x as int] == t[y as int],
        s.to_multiset() == t.to_multiset(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0858,verus,dafnybench,formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex7_Sorter,,"// see pdf 'ex6 & 7 documentation' for excercise question

//swaps two sequence indexes

//idea from Rustan Leino video ""Basics of specification and verification: Lecture 3, the Dutch National Flag algorithm""

//modified for 4 elements

//checks if a sequence is in base order","use vstd::prelude::*;

verus! {

#[derive(PartialEq, Eq, Debug, Clone, Copy)]
enum Bases {
    A,
    C,
    G,
    T,
}

fn exchanger(s: Seq<Bases>, x: nat, y: nat) -> (t: Seq<Bases>)
    requires 
        0 < s.len() && x < s.len() && y < s.len()
    ensures 
        t.len() == s.len(),
        forall|b: int| 0 <= b < s.len() && b != x && b != y ==> t[b] == s[b],
        t[x as int] == s[y as int] && s[x as int] == t[y as int],
        s.to_multiset() == t.to_multiset()
{
    assume(false);
    s
}

spec fn below(first: Bases, second: Bases) -> bool {
    first == second ||
    first == Bases::A || 
    (first == Bases::C && (second == Bases::G || second == Bases::T)) || 
    (first == Bases::G && second == Bases::T) ||
    second == Bases::T
}

spec fn bordered(s: Seq<Bases>) -> bool {
    forall|j: int, k: int| 0 <= j < k < s.len() ==> below(s[j], s[k])
}",,"fn sorter(bases: Seq<Bases>) -> (sobases: Seq<Bases>)
    requires 
        0 < bases.len()
    ensures 
        sobases.len() == bases.len(),
        bordered(sobases),
        bases.to_multiset() == sobases.to_multiset()","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0871,verus,dafnybench,llm-verified-eval_tmp_tmpd2deqn_i_dafny_0_has_close_elements,,,"use vstd::prelude::*;

verus! {

spec fn abs(x: int) -> int {
    if x < 0 { -x } else { x }
}",,"fn has_close_elements(numbers: Seq<int>, threshold: int) -> (result: bool)
    ensures
        result <==> exists|i: int, j: int|
            0 <= i < numbers.len() &&
            0 <= j < numbers.len() &&
            i != j &&
            abs(numbers[i] - numbers[j]) < threshold,
        result ==> numbers.len() > 1,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0872,verus,dafnybench,llm-verified-eval_tmp_tmpd2deqn_i_dafny_3_below_zero,,,"use vstd::prelude::*;

verus! {

spec fn sum(s: Seq<int>, n: nat) -> int
    recommends n <= s.len()
    decreases n
{
    if s.len() == 0 || n == 0 {
        0
    } else {
        s[0] + sum(s.subrange(1, s.len() as int), (n - 1) as nat)
    }
}",,"fn below_zero(ops: Seq<int>) -> (result: bool)
    ensures result <==> exists|n: nat| n <= ops.len() && sum(ops, n) < 0","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0873,verus,dafnybench,llm-verified-eval_tmp_tmpd2deqn_i_dafny_5_intersperse,,,"use vstd::prelude::*;

verus! {",,"fn intersperse(numbers: Seq<int>, delimiter: int) -> (interspersed: Seq<int>)
    ensures
        interspersed.len() == if numbers.len() > 0 { 2 * numbers.len() - 1 } else { 0 },
        forall|i: int| 0 <= i < interspersed.len() && i % 2 == 0 ==> 
            interspersed[i] == numbers[i / 2],
        forall|i: int| 0 <= i < interspersed.len() && i % 2 == 1 ==>
            interspersed[i] == delimiter,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0875,verus,dafnybench,llm-verified-eval_tmp_tmpd2deqn_i_dafny_9_rolling_max,,,"use vstd::prelude::*;

verus! {

spec fn isMax(m: int, numbers: Seq<int>) -> bool {
    numbers.contains(m) &&
    forall|i: int| 0 <= i < numbers.len() ==> numbers[i] <= m
}",,"fn rolling_max(numbers: Vec<int>) -> (result: Vec<int>)
    requires
        numbers.len() > 0,
    ensures
        result.len() == numbers.len(),
        forall|i: int| 0 < i < result.len() ==> isMax(result[i], numbers@.subrange(0, i + 1)),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0878,verus,dafnybench,llm-verified-eval_tmp_tmpd2deqn_i_dafny_161_solve,,,"use vstd::prelude::*;

verus! {

spec fn is_letter(c: char) -> bool {
    (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')
}

spec fn no_letters(s: Seq<char>, n: nat) -> bool
    recommends n <= s.len()
{
    forall|i: int| 0 <= i < n ==> !is_letter(s[i])
}

spec fn toggle_case(c: char) -> char {
    if c >= 'a' && c <= 'z' {
        ((c as u8 - 'a' as u8 + 'A' as u8) as char)
    } else if c >= 'A' && c <= 'Z' {
        ((c as u8 - 'A' as u8 + 'a' as u8) as char)
    } else {
        c
    }
}

spec fn is_reverse(s: Seq<char>, s_prime: Seq<char>) -> bool {
    (s.len() == s_prime.len()) &&
    (forall|si: int| 0 <= si < s.len()/2 ==> s_prime[s.len() - si - 1] == s[si])
}

fn reverse(original: Vec<char>) -> (reversed: Vec<char>)
    ensures 
        reversed@.len() == original@.len(),
        forall|i: int| 0 <= i < original@.len() ==> reversed@[i] == original@[original@.len() - 1 - i]
{
    assume(false);
    vec![]
}",,"fn solve(s: Vec<char>) -> (result: Vec<char>)
    ensures 
        result@.len() == s@.len(),
        !no_letters(s@, s@.len() as nat) ==> 
            forall|i: int| 0 <= i < s@.len() && is_letter(s@[i]) ==> 
                result@[i] == toggle_case(s@[i]),
        !no_letters(s@, s@.len() as nat) ==> 
            forall|i: int| 0 <= i < s@.len() && !is_letter(s@[i]) ==> 
                result@[i] == s@[i],
        no_letters(s@, s@.len() as nat) ==> is_reverse(result@, s@)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0896,verus,dafnybench,se2011_tmp_tmp71eb82zt_ass2_ex2_SecondLargest,,"// ex2

// this was me playing around to try and get an ensures for the method 

/*predicate method check(a: array<int>, seclar:int)
requires a.Length > 0
reads a
{ ensures exists i :: 0 <= i < a.Length && forall j :: (0 <= j < a.Length && j != i) ==> (a[i] >= a[j]) && (seclar <= a[i]) && ( if a[j] != a[i] then seclar >= a[j] else seclar <= a[j]) } */

//ensures exists i :: 0 <= i < a.len() && forall j :: (0 <= j < a.len() && j != i) ==> (a[i] >= a[j]) && (seclar <= a[i]) && ( if a[j] != a[i] then seclar >= a[j] else seclar <= a[j])","use vstd::prelude::*;

verus! {",,"fn second_largest(a: &[i32]) -> (seclar: i32)
    requires a.len() > 0","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0897,verus,dafnybench,software_analysis_tmp_tmpmt6bo9sf_ss_find_min_index,,"// spec fn is_permutation(a: Seq<int>, b: Seq<int>) -> bool

//     decreases a.len(), b.len()

// {

//     a.len() == b.len() && ((a.len() == 0 && b.len() == 0) || exists|i: int, j: int| 0 <= i < a.len() && 0 <= j < b.len() && a[i] == b[j] && is_permutation(a.subrange(0, i) + a.subrange(i + 1, a.len() as int), b.subrange(0, j) + b.subrange(j + 1, b.len() as int)))

// }","use vstd::prelude::*;

verus! {

spec fn is_sorted(ss: Seq<int>) -> bool {
    forall|i: int, j: int| 0 <= i <= j < ss.len() ==> ss[i] <= ss[j]
}

spec fn is_permutation(a: Seq<int>, b: Seq<int>) -> bool
    decreases a.len(), b.len()
{
    a.len() == b.len() && 
    ((a.len() == 0 && b.len() == 0) ||  
    exists|i: int, j: int| 0 <= i < a.len() && 0 <= j < b.len() && 
        a[i] == b[j] && 
        is_permutation(
            a.subrange(0, i) + (if i < a.len() { a.subrange(i + 1, a.len() as int) } else { seq![] }),
            b.subrange(0, j) + (if j < b.len() { b.subrange(j + 1, b.len() as int) } else { seq![] })
        ))
}

spec fn is_permutation2(a: Seq<int>, b: Seq<int>) -> bool {
    a.to_multiset() == b.to_multiset()
}",,"fn find_min_index(a: &[int], s: usize, e: usize) -> (min_i: usize)
    requires
        a.len() > 0,
        s < a.len(),
        e <= a.len(),
        e > s,
    ensures
        min_i >= s,
        min_i < e,
        forall|k: int| s <= k < e ==> a[min_i as int] <= a[k],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0898,verus,dafnybench,software_analysis_tmp_tmpmt6bo9sf_ss_selection_sort,,,"use vstd::prelude::*;

verus! {

fn find_min_index(a: &Vec<i32>, s: usize, e: usize) -> (min_i: usize)
    requires 
        a.len() > 0,
        s < a.len(),
        e <= a.len(),
        e > s,
    ensures 
        min_i >= s,
        min_i < e,
        forall|k: int| s <= k < e ==> a[min_i as int] <= a[k],
{
    assume(false);
    s
}

spec fn is_sorted(ss: Seq<i32>) -> bool {
    forall|i: int, j: int| 0 <= i <= j < ss.len() ==> ss[i] <= ss[j]
}

spec fn is_permutation(a: Seq<i32>, b: Seq<i32>) -> bool
    decreases a.len(), b.len()
{
    a.len() == b.len() && 
    ((a.len() == 0 && b.len() == 0) ||  
     (exists|i: int, j: int| {
        0 <= i < a.len() && 0 <= j < b.len() && a[i] == b[j] && 
        is_permutation(
            a.subrange(0, i) + {if i < a.len() { a.subrange(i + 1, a.len() as int) } else { seq![] }},
            b.subrange(0, j) + {if j < b.len() { b.subrange(j + 1, b.len() as int) } else { seq![] }}
        )
     }))
}

spec fn is_permutation2(a: Seq<i32>, b: Seq<i32>) -> bool {
    a.to_multiset() == b.to_multiset()
}",,"fn selection_sort(ns: &mut Vec<i32>) 
    requires old(ns).len() >= 0
    ensures 
        is_sorted(ns@),
        is_permutation2(old(ns)@, ns@),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0908,verus,dafnybench,t1_MF_tmp_tmpi_sqie4j_exemplos_colecoes_sequences_ex3_Delete,,"// line contém uma string de tamanho l

// remover p caracteres a partir da posição at","use vstd::prelude::*;

verus! {",,"fn delete(line: &mut Vec<char>, l: usize, at: usize, p: usize)
    requires
        l <= old(line).len(),
        at + p <= l,
    ensures
        line@ == old(line)@.subrange(0, at as int) + old(line)@.subrange((at + p) as int, l as int),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0920,verus,dafnybench,veri-sparse_tmp_tmp15fywna6_dafny_dspmspv_DSpMSpV,,"// X requirements 

// v requirements","use vstd::prelude::*;

verus! {

spec fn sum(X_val: Seq<int>, X_crd: Seq<nat>, 
           v_val: Seq<int>, v_crd: Seq<nat>, 
           kX: nat, kV: nat, pX_end: nat, pV_end: nat) -> int
    decreases pX_end + pV_end - (kX + kV)
{
    if pV_end <= kV || pX_end <= kX {
        0
    } else if kX < X_crd.len() && kV < v_crd.len() && X_crd[kX as int] == v_crd[kV as int] {
        sum(X_val, X_crd, v_val, v_crd, kX + 1, kV + 1, pX_end, pV_end) + 
        (if kV < v_val.len() && kX < X_val.len() { v_val[kV as int] * X_val[kX as int] } else { 0 })
    } else if kX < X_crd.len() && kV < v_crd.len() && X_crd[kX as int] < v_crd[kV as int] {
        sum(X_val, X_crd, v_val, v_crd, kX + 1, kV, pX_end, pV_end)
    } else {
        sum(X_val, X_crd, v_val, v_crd, kX, kV + 1, pX_end, pV_end)
    }
}

spec fn min(x: nat, y: nat) -> nat {
    if x <= y { x } else { y }
}

spec fn notin(y: nat, x: Seq<nat>) -> bool {
    forall|i: int| 0 <= i < x.len() ==> y != #[trigger] x[i]
}

spec fn index_seq(x: nat, y: Seq<nat>) -> nat
    decreases y.len()
{
    if y.len() == 0 {
        0
    } else if y[0] == x {
        0
    } else {
        1 + index_seq(x, y.subrange(1, y.len() as int))
    }
}

spec fn index(x: nat, y: Seq<nat>) -> nat {
    index_seq(x, y)
}",,"fn DSpMSpV(X_val: &[int], X_crd: &[nat], X_pos: &[nat], X_crd1: &[nat], X_len: nat,
           v_val: &[int], v_crd: &[nat]) -> (result: Vec<int>)

    requires X_pos.len() >= 1,
             X_val.len() == X_crd.len(),
             (forall|i: int, j: int| 0 <= i < j < X_pos.len() ==> #[trigger] X_pos[i] <= #[trigger] X_pos[j]),
             (forall|i: int| 0 <= i < X_pos.len() ==> 0 <= #[trigger] X_pos[i] <= X_val.len()),

             X_len >= X_crd1.len(),
             (forall|i: int| 0 <= i < X_crd1.len() ==> #[trigger] X_crd1[i] < X_len),

             (X_crd1.len() < X_pos.len()),
             (forall|i: int, j: int| 0 <= i < j < X_crd1.len() ==> #[trigger] X_crd1[i] < #[trigger] X_crd1[j]),

             (v_val.len() == v_crd.len()),

    ensures result.len() == X_len,
            (forall|i: int| 0 <= i < result.len() ==> {
        let idx = index(i as nat, X_crd1@);
        #[trigger] result[i] == if idx < X_crd1.len() {
            sum(X_val@, X_crd@, v_val@, v_crd@, X_pos[idx as int], 0, 
                X_pos[idx as int + 1], v_val.len() as nat)
        } else {
            0
        }})","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0921,verus,dafnybench,veri-sparse_tmp_tmp15fywna6_dafny_spmv_SpMV,,"// 0 0 0 0 0 0 1 0

// 0 0 0 0 0 0 0 0

// 0 0 0 0 1 0 0 0

// 0 0 0 0 0 0 0 0

// 0 0 1 0 0 0 0 0

// 0 0 0 0 0 0 0 0

// 1 0 0 0 0 0 0 0

// 0 0 0 0 0 0 0 0","use vstd::prelude::*;

verus! {

spec fn sum(X_val: Seq<int>, X_crd: Seq<nat>, v: Seq<int>, b: int, k: int) -> int
    decreases k - b
{
    if k <= b {
        0
    } else {
        sum(X_val, X_crd, v, b + 1, k) + X_val[b] * v[X_crd[b] as int]
    }
}",,"fn SpMV(X_val: &[int], X_crd: &[nat], X_pos: &[nat], v: &[int]) -> (y: Vec<int>)
    requires 
        X_crd.len() >= 1,
        X_crd.len() == X_val.len(),
        forall|i: int, j: int| 0 <= i < j < X_pos.len() ==> X_pos[i] <= X_pos[j],
        forall|i: int| 0 <= i < X_crd.len() ==> X_crd[i] < v.len(),
        forall|i: int| 0 <= i < X_pos.len() ==> X_pos[i] <= X_val.len(),
        X_pos.len() >= 1,
    ensures
        y.len() + 1 == X_pos.len(),
        forall|i: int| 0 <= i < y.len() ==> y[i] == sum(X_val@, X_crd@, v@, X_pos[i] as int, X_pos[i + 1] as int),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0923,verus,dafnybench,verified-using-dafny_tmp_tmp7jatpjyn_longestZero_longestZero,,"// For a given integer array, let's find the longest subsequence of 0s.

// sz: size, pos: position. a[pos..(pos+sz)] will be all zeros","use vstd::prelude::*;

verus! {

spec fn get_size(i: int, j: int) -> int {
    j - i + 1
}",,"fn longest_zero(a: &[i32]) -> (result: (usize, usize))
    requires 
        1 <= a.len()
    ensures 
        result.0 <= a.len(),
        result.1 < a.len(),
        result.1 + result.0 <= a.len(),
        forall |i: int| result.1 <= i < (result.1 + result.0) ==> a[i as int] == 0,
        forall |i: int, j: int| {
            0 <= i < j < a.len() && get_size(i, j) > (result.0 as int)
            ==> exists |k: int| i <= k <= j && a[k] != 0
        }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0924,verus,dafnybench,vfag_tmp_tmpc29dxm1j_Verificacion_torneo_torneo,,// Q,"use vstd::prelude::*;

verus! {",,"fn torneo(valores: &Vec<int>, i: usize, j: usize, k: usize) -> (res: (usize, usize))
    requires 
        valores.len() >= 20 && valores.len() < 50,
        i < valores.len() && j < valores.len() && k < valores.len(),
        i != j && j != k && k != i,
    ensures 
        exists|p: usize, q: usize, r: usize| 
            (p == i || p == j || p == k) &&
            (q == i || q == j || q == k) &&  
            (r == i || r == j || r == k) &&
            p != q && q != r && p != r &&
            valores[p as int] >= valores[q as int] && 
            valores[q as int] >= valores[r as int] &&
            res.0 == p && 
            res.1 == q,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VD0928,verus,dafnybench,vfag_tmp_tmpc29dxm1j_sumar_componentes_suma_componentes,,,"use vstd::prelude::*;

verus! {

spec fn suma_aux(V: &[i32], n: int) -> int
    decreases V.len() - n
    when 0 <= n <= V.len()
{
    if n == V.len() {
        0
    } else {
        V[n as int] + suma_aux(V, n + 1)
    }
}",,"fn suma_componentes(V: &[i32]) -> (suma: i32)
    ensures suma == suma_aux(V, 0)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VH0000,verus,humaneval,humaneval_000,,"This verification task involves implementing a method to determine if any two numbers in a given list have an absolute difference less than a specified threshold. The implementation uses nested loops to compare all pairs of elements and returns true as soon as a close pair is found, or false if no such pair exists.","use vstd::prelude::*;

verus! {

spec fn valid_input(numbers: Seq<int>, threshold: int) -> bool {
    true
}

spec fn abs_diff(a: int, b: int) -> int {
    if a >= b { a - b } else { b - a }
}

spec fn has_close_elements(numbers: Seq<int>, threshold: int) -> bool {
    exists|i: int, j: int| 0 <= i < j < numbers.len() && abs_diff(numbers[i], numbers[j]) < threshold
}

spec fn seq_map_to_int(numbers: Seq<i8>) -> Seq<int> {
        numbers.map(|_i: int, x: i8| x as int)
}",,"fn has_close_elements_impl(numbers: Vec<i8>, threshold: i8) -> (result: bool)
    requires valid_input(seq_map_to_int(numbers@), threshold as int)
    ensures result == has_close_elements(seq_map_to_int(numbers@), threshold as int)","{
    assume(false);
    false
}","
}

fn main() {}",0,,-1,-1,-1,,0.7
VH0001,verus,humaneval,humaneval_001_separate-paren-groups,,"function_signature: def separate_paren_groups(paren_string: str) -> List[str]

Input to this function is a string containing multiple groups of nested parentheses.
Your goal is to separate those group into separate strings and return the list of
those. Separate groups are balanced (each open brace is properly closed) and not
nested within each other Ignore any spaces in the input string.","use vstd::prelude::*;

verus! {

spec fn parentheses_depth(s: Seq<char>, i: int, j: int) -> int
    decreases j - i
{
    if !(0 <= i <= j <= s.len()) {
        0
    } else if i == j {
        0
    } else if s[i] == '(' {
        parentheses_depth(s, i + 1, j) + 1
    } else if s[i] == ')' {
        parentheses_depth(s, i + 1, j) - 1
    } else {
        parentheses_depth(s, i + 1, j)
    }
}

spec fn inner_depths_positive(s: Seq<char>) -> bool {
    forall|i: int| 0 < i < s.len() ==> parentheses_depth(s, 0, i) > 0
}

spec fn inner_depths_nonnegative(s: Seq<char>) -> bool {
    forall|i: int| 0 < i < s.len() ==> parentheses_depth(s, 0, i) >= 0
}",,"fn separate_paren_groups(paren_string: Vec<char>) -> (res: Vec<Vec<char>>)
    requires 
        parentheses_depth(paren_string@, 0, paren_string.len() as int) == 0,
        inner_depths_nonnegative(paren_string@)
    ensures 
        forall|k: int| 0 <= k < res.len() ==> parentheses_depth(#[trigger] res[k as int]@, 0, res[k as int].len() as int) == 0,
        forall|k: int| 0 <= k < res.len() ==> inner_depths_positive(#[trigger] res[k as int]@)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0002,verus,humaneval,humaneval_002,,"This task implements a function to extract the decimal (fractional)
part of a positive floating point number. Given a number like 3.5, it should return
0.5, and for 1.25, it should return 0.25. The implementation involves subtracting
the floor (integer part) from the original number.","use vstd::prelude::*;

verus! {

spec fn valid_input(number: int) -> bool {
    number >= 0
}

spec fn valid_output(result: int, input: int) -> bool {
    0 <= result < 1 && result == input - floor_spec(input)
}

spec fn floor_spec(x: int) -> int {
    if x >= 0 {
        floor_nonnegative(x)
    } else {
        -ceil_nonnegative(-x)
    }
}

spec fn floor_nonnegative(x: int) -> int {
    floor_helper(x, 0)
}

spec fn floor_helper(x: int, n: int) -> int 
    decreases x when x >= 0 && n >= 0
{
    if x < 1 { 
        n
    } else { 
        floor_helper(x - 1, n + 1)
    }
}

spec fn ceil_nonnegative(x: int) -> int {
    if x == 0 { 
        0
    } else if floor_nonnegative(x) == x {
        x
    } else {
        floor_nonnegative(x) + 1
    }
}",,"fn truncate_number(number: i8) -> (result: i8)
    requires valid_input(number as int)
    ensures valid_output(result as int, number as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0003,verus,humaneval,humaneval_003,,"Given a list of integers representing bank account operations (positive for deposits, negative for withdrawals), determine if the account balance ever drops below zero. The account starts with a balance of zero.","use vstd::prelude::*;

verus! {

spec fn sum_prefix(ops: Seq<int>, len: nat) -> int
  recommends len <= ops.len()
  decreases len
{
  if len == 0 { 0 }
  else { sum_prefix(ops, (len - 1) as nat) + ops[len - 1] }
}

spec fn vec_to_seq_int(v: Vec<i8>) -> Seq<int> {
  v@.map(|i, x: i8| x as int)
}

  // </vc-preamble>",,"fn below_zero(operations: Vec<i8>) -> (result: bool)
  ensures result <==> (exists|i: int| 0 < i <= operations@.len() && #[trigger] sum_prefix(vec_to_seq_int(operations), i as nat) < 0)","{
    assume(false);
    false
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0005,verus,humaneval,humaneval_005,,"This verification task involves implementing a method that inserts a delimiter between every two consecutive elements in a sequence of integers. The method should handle edge cases like empty sequences or single-element sequences, and for longer sequences, it should produce a result with alternating original elements and delimiters.","use vstd::prelude::*;

verus! {

spec fn valid_input(numbers: Seq<int>, delimiter: int) -> bool {
        true /* Any sequence and delimiter are valid inputs */
}
    
spec fn valid_output(numbers: Seq<int>, delimiter: int, result: Seq<int>) -> bool {
        if numbers.len() <= 1 {
            result == numbers
        } else {
            result.len() == 2 * numbers.len() - 1 &&
            (forall|i: int| 0 <= i < numbers.len() ==> #[trigger] result[2 * i] == numbers[i]) &&
            (forall|i: int| 0 <= i < numbers.len() - 1 ==> #[trigger] result[2 * i + 1] == delimiter)
        }
}",,"fn insert_delimiter(numbers: Vec<i8>, delimiter: i8) -> (result: Vec<i8>)
    requires valid_input(numbers@.map(|_i: int, x: i8| x as int), delimiter as int)
    ensures valid_output(numbers@.map(|_i: int, x: i8| x as int), delimiter as int, result@.map(|_i: int, x: i8| x as int))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0006,verus,humaneval,humaneval_006,,"This verification task implements a parser for nested parentheses strings. Given a string containing groups of nested parentheses separated by spaces, the goal is to find the maximum nesting depth for each group independently. The implementation must correctly split the input by spaces, calculate nesting depths, and return a sequence of maximum depths corresponding to each group.","use vstd::prelude::*;

verus! {

spec fn split_by_spaces_result(s: Seq<char>) -> Seq<Seq<char>> {
    if s.len() == 0 {
        seq![]
    } else {
        let groups = seq![];
        let current_group = seq![];
        let i = 0;
        split_by_spaces_helper(s, i, current_group, groups)
    }
}

spec fn max_nesting_depth(group: Seq<char>) -> int {
    max_nesting_depth_helper(group, 0, 0, 0)
}

spec fn split_by_spaces_helper(s: Seq<char>, i: int, current_group: Seq<char>, groups: Seq<Seq<char>>) -> Seq<Seq<char>>
    decreases s.len() - i when 0 <= i <= s.len()
{
    if i == s.len() {
        if current_group.len() > 0 { groups.push(current_group) } else { groups }
    } else if s[i] == ' ' {
        if current_group.len() > 0 {
            split_by_spaces_helper(s, i + 1, seq![], groups.push(current_group))
        } else {
            split_by_spaces_helper(s, i + 1, current_group, groups)
        }
    } else {
        split_by_spaces_helper(s, i + 1, current_group.push(s[i]), groups)
    }
}

spec fn max_nesting_depth_helper(group: Seq<char>, index: int, current_depth: int, max_depth: int) -> int
    decreases group.len() - index when 0 <= index <= group.len()
{
    if index == group.len() {
        max_depth
    } else if group[index] == '(' {
        let new_current = current_depth + 1;
        let new_max = if new_current > max_depth { new_current } else { max_depth };
        max_nesting_depth_helper(group, index + 1, new_current, new_max)
    } else if group[index] == ')' {
        max_nesting_depth_helper(group, index + 1, current_depth - 1, max_depth)
    } else {
        max_nesting_depth_helper(group, index + 1, current_depth, max_depth)
    }
}

fn split_by_spaces(s: Seq<char>) -> (groups: Seq<Seq<char>>)
    requires forall|i: int| 0 <= i < s.len() ==> s[i] == '(' || s[i] == ')' || s[i] == ' '
{
    assume(false);
    unreached()
}",,"fn parse_nested_parens(paren_string: Vec<char>) -> (result: Vec<i8>)
    requires forall|i: int| 0 <= i < paren_string@.len() ==> paren_string@[i] == '(' || paren_string@[i] == ')' || paren_string@[i] == ' '
    ensures forall|i: int| 0 <= i < result@.len() ==> result[i] as int >= 0","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0007,verus,humaneval,humaneval_007,,"This task implements a string filtering function that takes a list
of strings and a substring, returning a new list containing only the strings that
contain the given substring. The filtering should preserve the original order of
matching strings and be case-sensitive.","use vstd::prelude::*;

verus! {

spec fn contains_substring(s: Seq<char>, sub: Seq<char>) -> bool
    decreases s.len()
{
    if sub.len() == 0 { 
        true
    } else if sub.len() > s.len() { 
        false
    } else if s.len() == sub.len() {
        s == sub
    } else {
        (s.subrange(0, sub.len() as int) == sub) || contains_substring(s.subrange(1, s.len() as int), sub)
    }
}

spec fn filter_sequence(strings: Seq<Seq<char>>, substring: Seq<char>) -> Seq<Seq<char>> {
    filter_sequence_helper(strings, substring, strings.len() as int)
}

spec fn filter_sequence_helper(strings: Seq<Seq<char>>, substring: Seq<char>, n: int) -> Seq<Seq<char>>
    decreases n when 0 <= n <= strings.len()
{
    if n <= 0 {
        strings.take(0 as int)
    } else if contains_substring(strings[n-1], substring) {
        filter_sequence_helper(strings, substring, n-1).push(strings[n-1])
    } else {
        filter_sequence_helper(strings, substring, n-1)
    }
}",,"fn filter_by_substring(strings: Seq<Seq<char>>, substring: Seq<char>) -> (result: Seq<Seq<char>>)
    ensures 
        result.len() <= strings.len(),
        forall|i: int| 0 <= i < result.len() ==> strings.contains(result[i]),
        forall|i: int| 0 <= i < result.len() ==> contains_substring(result[i], substring),
        forall|i: int| 0 <= i < strings.len() && contains_substring(strings[i], substring) ==> result.contains(strings[i]),
        forall|i: int, j: int| 0 <= i < j < result.len() ==> 
            exists|k1: int, k2: int| 0 <= k1 < k2 < strings.len() && #[trigger] result[i] =~= strings[k1] && #[trigger] result[j] =~= strings[k2],
        forall|s: Seq<char>| result.contains(s) <==> (strings.contains(s) && contains_substring(s, substring)),
        result =~= filter_sequence(strings, substring)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0008,verus,humaneval,humaneval_008,,"This verification task implements a method to compute both the sum
and product of all integers in a given sequence. For an empty list, the method should
return (0, 1) representing the empty sum and empty product respectively. The implementation
uses iterative computation while maintaining loop invariants to ensure correctness.","use vstd::prelude::*;

verus! {

spec fn sum_seq(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else {
        s[0] + sum_seq(s.subrange(1, s.len() as int))
    }
}

spec fn product_seq(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        1
    } else {
        s[0] * product_seq(s.subrange(1, s.len() as int))
    }
}","proof fn sum_seq_append(s: Seq<int>, x: int)
    ensures sum_seq(s.add(seq![x])) == sum_seq(s) + x
    decreases s.len()
{
    assume(false); /* TODO: Remove this line and implement the proof */
}

proof fn product_seq_append(s: Seq<int>, x: int)
    ensures product_seq(s.add(seq![x])) == product_seq(s) * x
    decreases s.len()
{
    assume(false); /* TODO: Remove this line and implement the proof */
}","fn sum_product(numbers: Vec<i8>) -> (result: (i8, i8))
    ensures ({
        let (sum, product) = result;
        sum as int == sum_seq(numbers@.map(|i, x| x as int)) &&
        product as int == product_seq(numbers@.map(|i, x| x as int)) &&
        (numbers@.len() == 0 ==> sum == 0 && product == 1)
    })","{
    assume(false);
    (0, 1)
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0009,verus,humaneval,humaneval_009,,"This verification task implements a rolling maximum function that
takes a list of integers and returns a list where each element represents the maximum
value encountered from the beginning of the list up to and including the current
position.","use vstd::prelude::*;

verus! {

spec fn max_up_to(numbers: Seq<int>, index: int) -> int
    decreases index when 0 <= index < numbers.len()
{
    if 0 <= index < numbers.len() {
        if index == 0 {
            numbers[0]
        } else {
            let prev_max = max_up_to(numbers, index - 1);
            if numbers[index] > prev_max { numbers[index] } else { prev_max }
        }
    } else {
        0
    }
}","spec fn vec_to_seq_int(v: Vec<i8>) -> Seq<int> {
    v@.map(|i, x| x as int)
}","fn rolling_max(numbers: Vec<i8>) -> (result: Vec<i8>)
    ensures 
        result.len() == numbers.len() &&
        (numbers.len() == 0 ==> result.len() == 0) &&
        (numbers.len() > 0 ==> result.len() > 0) &&
        (forall|i: int| #![trigger result[i]] 0 <= i < result.len() ==>
            result[i] as int == max_up_to(vec_to_seq_int(numbers), i)) &&
        (forall|i: int| #![trigger result[i]] 0 <= i < result.len() ==>
            forall|j: int| #![trigger numbers@[j]] 0 <= j <= i ==> numbers@[j] as int <= result[i] as int) &&
        (forall|i: int| #![trigger result[i]] 0 <= i < result.len() ==>
            exists|j: int| 0 <= j <= i && numbers@[j] as int == result[i] as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0010,verus,humaneval,humaneval_010_is_palindrome__make_palindrome,,"function_signature: fn make_palindrome(s: &str) -> (result: String)

Process input. Ensures: the size is bounded; the result is a palindrome; ensures starts_with(result, s).","use vstd::prelude::*;

verus! {

spec fn is_palindrome(s: Seq<char>) -> bool {
    forall|k: int| #![trigger s.index(k)] 0 <= k < s.len() ==> s.index(k) == s.index(s.len() - 1 - k)
}

spec fn starts_with(result: Seq<char>, s: Seq<char>) -> bool {
    result.len() >= s.len() && forall|k: int| #![trigger result.index(k)] 0 <= k < s.len() ==> result.index(k) == s.index(k)
}",,"fn make_palindrome(s: &str) -> (result: String)
    ensures 
        result@.len() <= 2 * s@.len(),
        is_palindrome(result@),
        starts_with(result@, s@)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0011,verus,humaneval,humaneval_011,,"This task implements a bitwise XOR operation on two binary strings
of equal length. Given two strings containing only '0' and '1' characters, the method
should return a new string where each position contains '0' if the corresponding
characters in the input strings are the same, and '1' if they are different.","use vstd::prelude::*;

verus! {

spec fn is_binary_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
}",,"fn string_xor(a: Vec<char>, b: Vec<char>) -> (result: Vec<char>)
    requires 
        a.len() == b.len(),
        is_binary_string(a@),
        is_binary_string(b@),
    ensures 
        result.len() == a.len(),
        is_binary_string(result@),
        forall|i: int| 0 <= i < a.len() as int ==> 
            (a@[i] == b@[i] ==> result@[i] == '0') &&
            (a@[i] != b@[i] ==> result@[i] == '1'),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0012,verus,humaneval,humaneval_012,,"This task involves finding the longest string in a sequence of strings.
If multiple strings have the same maximum length, the method should return the first
one that appears in the list. If the list is empty, it should return None using
an Option type.","use vstd::prelude::*;

verus! {

spec fn valid_result(strings: Seq<Seq<char>>, result: Option<Seq<char>>) -> bool {
    if strings.len() == 0 {
        matches!(result, Option::None)
    } else {
        match result {
            Option::Some(value) => {
                exists|i: int| 0 <= i < strings.len() && #[trigger] strings[i] == value &&
                (forall|s: Seq<char>| strings.contains(s) ==> value.len() >= #[trigger] (s.len())) &&
                (forall|j: int| 0 <= j < i ==> #[trigger] (strings[j].len()) < value.len())
            },
            Option::None => false
        }
    }
}",,"fn longest(strings: Vec<Vec<char>>) -> (result: Option<Vec<char>>)
    ensures match result {
        Option::Some(value) => valid_result(strings@.map(|_i: int, v: Vec<char>| v@), Option::Some(value@)),
        Option::None => valid_result(strings@.map(|_i: int, v: Vec<char>| v@), Option::None),
    }","{
    assume(false);
    Option::None
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0013,verus,humaneval,humaneval_013,,"This task involves implementing the greatest common divisor (GCD)
function for two integers. The GCD is the largest positive integer that divides
both numbers without remainder, with special cases for zero values.

The implementation should use the Euclidean algorithm, which repeatedly applies
the property that GCD(a,b) = GCD(b, a mod b) until one operand becomes zero.","use vstd::prelude::*;

verus! {

spec fn abs(x: int) -> nat {
    if x >= 0 { x as nat } else { (-x) as nat }
}

spec fn divides(d: int, n: int) -> bool {
    if d == 0 { n == 0 } else { n % d == 0 }
}",,"fn greatest_common_divisor(a: i8, b: i8) -> (result: u8)
    ensures 
        result > 0 <==> (a != 0 || b != 0),
        result == 0 <==> (a == 0 && b == 0),
        divides(result as int, a as int) && divides(result as int, b as int),
        forall|d: int| d > 0 && divides(d, a as int) && divides(d, b as int) ==> d <= result as int","{
    assume(false);
    0
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0014,verus,humaneval,humaneval_014,,"Given a string, return a list of all its prefixes ordered from shortest
to longest. A prefix is a substring that starts from the beginning of the original
string.","use vstd::prelude::*;

verus! {

spec fn valid_prefixes(s: Seq<char>, result: Seq<Seq<char>>) -> bool {
    result.len() == s.len() &&
    forall|i: int| 0 <= i < result.len() ==> result[i] == s.subrange(0, i + 1)
}",,"fn all_prefixes(s: Vec<char>) -> (result: Vec<Vec<char>>)
    ensures valid_prefixes(s@, result@.map(|i, v: Vec<char>| v@))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0015,verus,humaneval,humaneval_016,,"Count the number of distinct characters in a string, ignoring case
differences. The implementation should return an integer representing the count
of unique characters, treating 'A' and 'a' as the same character through case-insensitive
comparison.","use vstd::prelude::*;

verus! {

spec fn to_lower_char(c: char) -> char {
    if 'A' <= c && c <= 'Z' {
        ((c as u8 - 'A' as u8 + 'a' as u8) as char)
    } else {
        c
    }
}

spec fn char_set_from_string(s: Seq<char>) -> Set<char> {
    Set::new(|c: char| exists|i: int| 0 <= i < s.len() && #[trigger] to_lower_char(s[i]) == c)
}",,"fn count_distinct_characters(s: &str) -> (count: usize)
    ensures 
        count <= s@.len(),
        count == char_set_from_string(s@).len(),","{
    // impl-start
    assume(false);
    0
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0016,verus,humaneval,humaneval_018_how_many_times,,"function_signature: fn how_many_times(string: Seq<char>, substring: Seq<char>) -> usize

Find how many times a given substring can be found in the original string. Count
overlaping cases.","use vstd::prelude::*;

verus! {",,"fn how_many_times(s: Vec<char>, substr: Vec<char>) -> (times: usize)
    ensures times == Set::new(|i: int| 0 <= i <= s@.len() - substr@.len() && s@.subrange(i, i + substr@.len()) == substr@).len()","{
    assume(false);
    0
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0017,verus,humaneval,humaneval_020,,"Given a list of numbers with at least two elements, find the pair
of numbers with the smallest absolute difference between them. Return the pair as
a tuple ordered from smaller to larger value. The implementation uses nested loops
to compare all pairs and track the minimum difference found.","use vstd::prelude::*;

verus! {

spec fn abs_diff(x: int, y: int) -> int {
        if x >= y { x - y } else { y - x }
    }
    
spec fn valid_input(numbers: Seq<int>) -> bool {
        numbers.len() >= 2
    }
    
spec fn is_optimal_pair(numbers: Seq<int>, pair: (int, int)) -> bool {
        numbers.contains(pair.0) &&
        numbers.contains(pair.1) &&
        pair.0 <= pair.1 &&
        forall|i: int, j: int| 0 <= i < numbers.len() && 0 <= j < numbers.len() && i != j ==>
            abs_diff(numbers[i], numbers[j]) >= abs_diff(pair.0, pair.1)
    }
    
// </vc-preamble>",,"fn find_closest_elements(numbers: Vec<i8>) -> (result: (i8, i8))
    requires valid_input(numbers@.map(|_index, x| x as int))
    ensures is_optimal_pair(numbers@.map(|_index, x| x as int), (result.0 as int, result.1 as int))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0018,verus,humaneval,humaneval_021_rescale_to_unit,,"function_signature: def rescale_to_unit(numbers: List[float]) -> List[float]

Given list of numbers (of at least two elements), apply a linear transform to that
list, such that the smallest number will become 0 and the largest will become 1","use vstd::prelude::*;

verus! {

spec fn affine(x: int, shift: int, scale: int) -> int {
    if scale > 0 { (x + shift) / scale } else { 0 }
}

spec fn affine_seq(s: Seq<int>, r: Seq<int>, shift: int, scale: int) -> bool {
        scale > 0 && r.len() == s.len() &&
        forall|i: int| 0 <= i < s.len() ==> #[trigger] r[i] == #[trigger] affine(s[i], shift, scale)
}",,"fn rescale_to_unit(s: Vec<i8>) -> (r: Vec<i8>)
    requires s@.len() >= 2,
             exists|i: int, j: int| (0 <= i < j < s@.len()) && s@[i] != s@[j]
    ensures r@.len() == s@.len(),
            forall|i: int| 0 <= i < s@.len() ==> 0 <= r@[i] as int && r@[i] as int <= 1,
            exists|i: int| 0 <= i < s@.len() && r@[i] as int == 0,
            exists|i: int| 0 <= i < s@.len() && r@[i] as int == 1,
            ({
                let s_int = s@.map(|i, x| x as int);
                let r_int = r@.map(|i, x| x as int);
                exists|shift: int, scale: int| affine_seq(s_int, r_int, shift, scale) && scale > 0
            })","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0019,verus,humaneval,humaneval_022,,"Given a list containing values of various types, return a new list
containing only the integer values. In Python, booleans are considered integers
(True=1, False=0), so they should be included in the result. The task requires implementing
a function that filters a sequence of mixed-type values to extract only integers
and boolean values (converted to 0/1).","use vstd::prelude::*;

verus! {

pub enum Value {
    IntVal(int),
    BoolVal(bool),
    StringVal(Seq<char>),
    RealVal(int), /* using int for real approximation */
    OtherVal,
}

spec fn valid_input(values: Seq<Value>) -> bool {
    true  /* All sequences of Value are valid input */
}

spec fn integer_values(values: Seq<Value>) -> Seq<int> 
    decreases values.len()
{
    if values.len() == 0 {
        Seq::<int>::empty()
    } else {
        match values.index(0) {
            Value::IntVal(i) => seq![i].add(integer_values(values.subrange(1, values.len() as int))),
            Value::BoolVal(b) => seq![if b { 1int } else { 0int }].add(integer_values(values.subrange(1, values.len() as int))),
            _ => integer_values(values.subrange(1, values.len() as int))
        }
    }
}

spec fn valid_output(input: Seq<Value>, output: Seq<int>) -> bool {
    output == integer_values(input)
}",,"fn filter_integers(values: Vec<Value>) -> (result: Vec<i8>)
    requires
        valid_input(values@),
    ensures
        valid_output(values@, result@.map(|i: int, v: i8| v as int)),
        result.len() <= values.len()","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0020,verus,humaneval,humaneval_023,,"Implement a function that returns the length of a given string. The
function should handle empty strings and return 0 for them. For non-empty strings,
it should return the count of characters.","use vstd::prelude::*;

verus! {

spec fn valid_input(s: Seq<char>) -> bool {
    true
}

spec fn correct_length(s: Seq<char>) -> int {
    s.len() as int
}",,"fn strlen(s: &str) -> (result: usize)
    requires valid_input(s@)
    ensures correct_length(s@) == (result as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,0.7
VH0021,verus,humaneval,humaneval_024_largest-divisor,,"function_signature: fn largest_divisor(n: int) -> int

For a given number n, find the largest number that divides n evenly, smaller than n","use vstd::prelude::*;

verus! {",,"fn largest_divisor(n: i8) -> (d: i8)
    requires 
        n as int > 1
    ensures 
        1 <= d as int &&
        (d as int) < (n as int) &&
        n as int % d as int == 0 &&
        (forall|k: int| (d as int) < k && k < (n as int) ==> #[trigger] ((n as int) % k) != 0)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0022,verus,humaneval,humaneval_025,,"Given a positive integer n, return a list of its prime factors in
ascending order. Each prime factor should appear in the list as many times as it
divides n (i.e., according to its multiplicity in the prime factorization).","use vstd::prelude::*;

verus! {

spec fn is_prime(n: int) -> bool {
    n >= 2 && forall|k: int| 2 <= k < n ==> #[trigger] (n % k) != 0
}

spec fn product(factors: Seq<int>) -> int
    decreases factors.len()
{
    if factors.len() == 0 {
        1
    } else {
        factors[0] * product(factors.subrange(1, factors.len() as int))
    }
}

spec fn is_non_decreasing(factors: Seq<int>) -> bool {
    forall|i: int, j: int| 0 <= i < j < factors.len() ==> #[trigger] factors[i] <= #[trigger] factors[j]
}",,"fn factorize(n: i8) -> (factors: Vec<i8>)
    requires n >= 0
    ensures 
        n <= 1 ==> factors.len() == 0,
        n > 1 ==> product(factors@.map(|i: int, x: i8| x as int)) == n as int,
        forall|i: int| 0 <= i < factors.len() ==> is_prime(#[trigger] factors@[i] as int),
        is_non_decreasing(factors@.map(|i: int, x: i8| x as int)),
        forall|i: int| 0 <= i < factors.len() ==> #[trigger] factors@[i] >= 2","{
    assume(false);
    Vec::new()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0023,verus,humaneval,humaneval_026_remove_duplicates__count,,"function_signature: fn count(a: Seq<int>, x: int) -> (cnt: int)

Count occurrences. Ensures: returns the correct count; returns the correct count.","use vstd::prelude::*;

verus! {

spec fn count_rec(a: Seq<int>, x: int) -> int
    decreases a.len()
{
    if a.len() == 0 {
        0
    } else {
        count_rec(a.subrange(1, a.len() as int), x) + (if a[0] == x { 1 as int } else { 0 as int })
    }
}",,"fn count(a: Vec<i8>, x: i8) -> (cnt: i8)
    ensures 
        cnt as int == count_rec(a@.map(|i: int, v: i8| v as int), x as int)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0024,verus,humaneval,humaneval_026_remove_duplicates__remove_duplicates,,"function_signature: fn remove_duplicates(a: Seq<int>) -> (result: Seq<int>)
Process input. Requires: the condition holds for all values. Ensures: the condition holds for all values; the condition holds for all values.","use vstd::prelude::*;

verus! {
spec fn count_rec(a: Seq<int>, x: int) -> int
    decreases a.len()
{
    if a.len() == 0 {
        0int
    } else {
        count_rec(a.subrange(1, a.len() as int), x) + (if a[0] == x { 1int } else { 0int })
    }
}

// </vc-preamble>",,"fn remove_duplicates(a: Vec<i8>) -> (result: Vec<i8>)
    requires 
        forall|i: int| 0 <= i < a@.len() ==> count_rec(a@.map(|_i: int, x: i8| x as int), a@[i] as int) >= 1
    ensures 
        forall|i: int| 0 <= i < result@.len() ==> count_rec(a@.map(|_i: int, x: i8| x as int), result@[i] as int) == 1,
        forall|i: int| 0 <= i < a@.len() ==> (result@.map(|_i: int, x: i8| x as int).contains(a@[i] as int) <==> count_rec(a@.map(|_i: int, x: i8| x as int), a@[i] as int) == 1)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0025,verus,humaneval,humaneval_027,,"This verification task involves implementing a string case-flipping
function that converts all lowercase letters to uppercase and all uppercase letters
to lowercase, while leaving non-alphabetic characters unchanged. The implementation
should process each character in the input string and return a new string with the
appropriate case transformations.","use vstd::prelude::*;

verus! {

spec fn is_lowercase(c: char) -> bool {
    'a' <= c <= 'z'
}

spec fn is_uppercase(c: char) -> bool {
    'A' <= c <= 'Z'
}

spec fn flip_char(c: char) -> char {
    if is_lowercase(c) { 
        ((c as u8) - ('a' as u8) + ('A' as u8)) as char
    } else if is_uppercase(c) { 
        ((c as u8) - ('A' as u8) + ('a' as u8)) as char
    } else { 
        c 
    }
}

spec fn valid_flip_case(s: Seq<char>, result: Seq<char>) -> bool {
    result.len() == s.len() &&
    forall|i: int| 0 <= i < s.len() ==> #[trigger] result[i] == #[trigger] flip_char( #[trigger] s[i])
}",,"fn flip_case(s: Vec<char>) -> (result: Vec<char>)
    ensures valid_flip_case(s@, result@)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0026,verus,humaneval,humaneval_028,,"This task involves implementing string concatenation. Given a sequence of strings, return a single string that is the concatenation of all strings in the list in order. The implementation should match the behavior of a recursive specification function.","use vstd::prelude::*;

verus! {

spec fn concat_strings(strings: Seq<Seq<char>>, index: nat) -> Seq<char>
    decreases strings.len() - index
{
    if index >= strings.len() {
        Seq::<char>::empty()
    } else {
        strings[index as int] + concat_strings(strings, index + 1)
    }
}",,"fn concatenate(strings: Vec<Vec<char>>) -> (result: Vec<char>)
    ensures 
        result@ == concat_strings(strings@.map(|i, s: Vec<char>| s@), 0) &&
        (strings@.len() == 0 ==> result@ == Seq::<char>::empty())","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0027,verus,humaneval,humaneval_029_filter_by_prefix,,"function_signature: def filter_by_prefix(strings: List[str], prefix: str) -> List[str]

Filter an input list of strings only for ones that start with a given prefix.","use vstd::prelude::*;

verus! {

spec fn starts_with(s: Seq<char>, p: Seq<char>) -> bool
    decreases s.len() + p.len()
{
    p.len() == 0 || (s.len() != 0 && s.len() >= p.len() && s[0] == p[0] && starts_with(s.subrange(1, s.len() as int), p.subrange(1, p.len() as int)))
}",,"fn filter_by_prefix(xs: Vec<Vec<char>>, p: Vec<char>) -> (filtered: Vec<Vec<char>>)
    ensures forall|i: int| 0 <= i < filtered@.len() ==> starts_with(#[trigger] filtered@[i]@, #[trigger] p@)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0028,verus,humaneval,humaneval_030,,"This task implements a function to filter positive numbers from a
list of integers. The function should return a new sequence containing only the
positive numbers (greater than 0) while preserving their original order from the
input sequence.","use vstd::prelude::*;

verus! {

spec fn is_positive(x: int) -> bool {
    x > 0
}

spec fn all_positive(s: Seq<int>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> is_positive(#[trigger] s[i])
}

spec fn all_elements_from_original(result: Seq<int>, original: Seq<int>) -> bool {
    forall|x: int| #[trigger] result.contains(x) ==> original.contains(x)
}

spec fn contains_all_positives(result: Seq<int>, original: Seq<int>) -> bool {
    forall|i: int| 0 <= i < original.len() && is_positive(original[i]) ==> result.contains(#[trigger] original[i])
}

spec fn preserves_order(result: Seq<int>, original: Seq<int>) -> bool {
    forall|i: int, j: int| 0 <= i < j < result.len() ==> 
        (exists|k1: int, k2: int| 0 <= k1 < k2 < original.len() && original[k1] == #[trigger] result[i] && original[k2] == #[trigger] result[j] &&
        forall|k: int| k1 < k < k2 ==> !is_positive(#[trigger] original[k]))
}

spec fn count_positives(s: Seq<int>) -> int {
    s.len() as int
}",,"fn get_positive(l: Vec<i8>) -> (result: Vec<i8>)
    ensures 
        all_positive(result@.map(|i: int, x: i8| x as int)),
        all_elements_from_original(result@.map(|i: int, x: i8| x as int), l@.map(|i: int, x: i8| x as int)),
        contains_all_positives(result@.map(|i: int, x: i8| x as int), l@.map(|i: int, x: i8| x as int)),
        result.len() == count_positives(l@.map(|i: int, x: i8| x as int)),
        preserves_order(result@.map(|i: int, x: i8| x as int), l@.map(|i: int, x: i8| x as int)),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0029,verus,humaneval,humaneval_031,,"This verification task involves implementing a method to determine
if a positive integer is a prime number. A prime number is defined as a natural
number greater than 1 that has exactly two distinct positive divisors: 1 and itself.

The implementation should efficiently check for primality by testing divisibility
up to the square root of the input number, with optimizations for even numbers.","use vstd::prelude::*;

verus! {

spec fn is_prime_number(n: int) -> bool
{
    n >= 2 && forall|k: int| 2 <= k < n ==> #[trigger] (n % k) != 0
}",,"fn is_prime(n: i8) -> (result: bool)
    ensures result <==> is_prime_number(n as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0030,verus,humaneval,humaneval_033_sort_third__SortSeqPred,,"function_signature: fn sort_seq_pred(s: Seq<int>, p: Seq<bool>) -> (sorted: Seq<int>)

Sort elements. Requires: returns the correct size/count. Ensures: returns the correct
size/count; the result is sorted according to the ordering relation; returns a sorted
permutation of the input; the result is sorted according to the ordering relation.","use vstd::prelude::*;

verus! {",,"fn sort_seq_pred(s: Vec<i8>, p: Vec<bool>) -> (sorted: Vec<i8>)
  requires s.len() == p.len(),
  ensures 
    sorted.len() == s.len(),
    forall|i: int, j: int| 0 <= i < j < sorted.len() && p[i] && p[j] ==> sorted[i] as int <= sorted[j] as int,
    s@.to_multiset() == sorted@.to_multiset(),
    forall|i: int| 0 <= i < s.len() && !p[i] ==> sorted[i] == s[i],","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVH00,0.85
VH0031,verus,humaneval,humaneval_033_sort_third__sort_third,,"function_signature: fn sort_third(a: &Vec<i8>) -> (sorted_even: Vec<i8>)

Sort elements. Requires: requires size of a > 0. Ensures: returns the correct
size/count; the result is sorted according to the ordering relation; the result
is sorted according to the ordering relation; returns a sorted permutation of the
input.","use vstd::prelude::*;

verus! {",,"fn sort_third(a: &Vec<i8>) -> (sorted_even: Vec<i8>)
    requires a@.len() > 0
    ensures 
        sorted_even@.len() == a@.len(),
        forall|i: int, j: int| 0 <= i < j < sorted_even@.len() && i % 3 == 0 && j % 3 == 0 ==>
            sorted_even@[i] <= sorted_even@[j],
        forall|i: int| 0 <= i < a@.len() && i % 3 != 0 ==> sorted_even@[i] == a@[i],
        a@.to_multiset() == sorted_even@.to_multiset()","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVH00,0.85
VH0032,verus,humaneval,humaneval_034_unique__SortSeq,,"function_signature: fn sort_seq(s: Seq<int>) -> (sorted: Seq<int>)

Sort elements. Ensures: the result is sorted according to the ordering relation;
returns the correct size/count; returns a sorted permutation of the input.","use vstd::prelude::*;

verus! {",,"fn sort_seq(s: Vec<i8>) -> (sorted: Vec<i8>)
    ensures 
        forall|i: int, j: int| 0 <= i < j < sorted@.len() ==> sorted@[i] <= sorted@[j],
        sorted@.len() == s@.len(),
        s@.to_multiset() == sorted@.to_multiset()","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVH00,0.85
VH0033,verus,humaneval,humaneval_034_unique__unique,,"function_signature: fn unique(s: Seq<int>) -> (result: Seq<int>)

Process input. Ensures: the condition holds for all values; the condition holds
for all values; the condition holds for all values.","use vstd::prelude::*;

verus! {",,"fn unique(s: Vec<i8>) -> (result: Vec<i8>)
    ensures
        forall|i: int, j: int| 0 <= i < j < result@.len() ==> (result@[i] as int) < (result@[j] as int) &&
        forall|x: i8| result@.contains(x) ==> s@.contains(x) &&
        forall|x: i8| s@.contains(x) ==> result@.contains(x)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVH01,0.85
VH0034,verus,humaneval,humaneval_034_unique__uniqueSorted,,"function_signature: fn unique_sorted(s: Seq<int>) -> (result: Seq<int>)

Sort elements. Requires: the condition holds for all values. Ensures: the condition holds for all values; the condition holds for all values; the condition holds for all values.","use vstd::prelude::*;

verus! {",,"fn unique_sorted(s: Vec<i8>) -> (result: Vec<i8>)
    requires 
        forall|i: int, j: int| 0 <= i < j < s@.len() ==> s@[i] <= s@[j],
    ensures 
        forall|i: int, j: int| 0 <= i < j < result@.len() ==> result@[i] < result@[j],
        forall|x: i8| result@.contains(x) ==> s@.contains(x),
        forall|x: i8| s@.contains(x) ==> result@.contains(x),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0035,verus,humaneval,humaneval_035,,"Find and return the maximum element in a given list of numbers. The
list must be non-empty, and the maximum element is the largest value present in
the list, which must be an actual element of the list.","use vstd::prelude::*;

verus! {

spec fn valid_input(l: Seq<int>) -> bool {
    l.len() > 0
}

spec fn is_max_element(l: Seq<int>, max_val: int) -> bool {
    l.contains(max_val) && forall|i: int| 0 <= i < l.len() ==> l[i] <= max_val
}

spec fn max_element_func(l: Seq<int>) -> int
    decreases l.len()
{
    if l.len() == 1 {
        l[0]
    } else if l.len() > 1 {
        let rest_max = max_element_func(l.subrange(1, l.len() as int));
        if l[0] > rest_max { l[0] } else { rest_max }
    } else {
        0int
    }
}

// </vc-preamble>",,"fn find_max_element(l: Vec<i8>) -> (max_val: i8)
    requires valid_input(l@.map(|i, x| x as int))
    ensures is_max_element(l@.map(|i, x| x as int), max_val as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0036,verus,humaneval,humaneval_036_fizz_buzz__count7,,"function_signature: fn count7(x: nat) -> (count: nat)

Count occurrences. Ensures: returns the correct value.","use vstd::prelude::*;

verus! {

spec fn count7_r(x: nat) -> nat 
    decreases x
{
    let lst = if x % 10 == 7 { 1 as nat } else { 0 as nat };
    if x < 10 { lst } else { lst + count7_r(x / 10) }
}

spec fn sum(s: Seq<int>) -> int 
    decreases s.len()
{
    if s.len() == 0 { 0 } else { s[0] + sum(s.subrange(1, s.len() as int)) }
}",,"fn count7(x: u8) -> (count: u8)
    ensures count as nat == count7_r(x as nat)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0037,verus,humaneval,humaneval_036_fizz_buzz__fizz_buzz,,"function_signature: fn fizz_buzz(n: nat) -> (result: nat)

Process input. Requires: returns the correct size/count. Ensures: returns the correct
value.","use vstd::prelude::*;

verus! {

spec fn count7_r(x: nat) -> nat
    decreases x
{
    let lst = if x % 10 == 7 { 1 } else { 0 };
    if x < 10 { lst } else { lst + count7_r(x / 10) }
}

spec fn sum(s: Seq<nat>) -> nat
    decreases s.len()
{
    if s.len() == 0 { 0 } else { s[0] + sum(s.subrange(1, s.len() as int)) }
}",,"fn fizz_buzz(n: u8) -> (result: u8)
    ensures result as nat == sum(
        Seq::new(n as nat, |i: int| 
            if 0 <= i < n as nat && (i % 11 == 0 || i % 13 == 0) { count7_r(i as nat) } else { 0 }
        )
    )","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0038,verus,humaneval,humaneval_037_sort_even__SortSeqPred,,"function_signature: fn sort_seq_pred(s: Seq<int>, p: Seq<bool>) -> (sorted: Seq<int>)

Sort elements. Requires: returns the correct size/count. Ensures: returns the correct
size/count; the result is sorted according to the ordering relation; returns a sorted
permutation of the input; the result is sorted according to the ordering relation.","use vstd::prelude::*;

verus! {",,"fn sort_seq_pred(s: Vec<i8>, p: Vec<bool>) -> (sorted: Vec<i8>)
    requires s.len() == p.len(),
    ensures 
        sorted.len() == s.len(),
        forall|i: int, j: int| 0 <= i < j < sorted.len() && p[i as int] && p[j as int] ==> sorted[i] as int <= sorted[j] as int,
        s@.to_multiset() == sorted@.to_multiset(),
        forall|i: int| 0 <= i < s.len() && !p[i as int] ==> sorted[i] == s[i],","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVH00,0.85
VH0039,verus,humaneval,humaneval_037_sort_even__sorted_even,,"function_signature: fn sorted_even(a: Seq<int>) -> (sorted: Seq<int>)

Sort elements. Requires: requires size of a > 0. Ensures: returns the correct
size/count; the result is sorted according to the ordering relation; the result
is sorted according to the ordering relation; returns a sorted permutation of the
input.","use vstd::prelude::*;

verus! {",,"fn sorted_even(a: Vec<i8>) -> (sorted: Vec<i8>)
    requires 
        a@.len() > 0
    ensures 
        sorted@.len() == a@.len(),
        forall|i: int, j: int| 0 <= i < j && 2 * i < sorted@.len() && 2 * j < sorted@.len() ==> #[trigger] sorted@[2 * i] <= #[trigger] sorted@[2 * j],
        forall|i: int| 0 <= i < a@.len() && i % 2 == 1 ==> #[trigger] sorted@[i] == #[trigger] a@[i],
        a@.to_multiset() == sorted@.to_multiset()","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVH00,0.85
VH0040,verus,humaneval,humaneval_038_encode_cyclic__decode_cyclic,,"function_signature: fn decode_cyclic(s: &Vec<i8>) -> (res: Vec<i8>)

Decode data. Ensures: returns the correct size/count; the condition holds for all values; the condition holds for all values; the condition holds for all values.","use vstd::prelude::*;

verus! {",,"fn decode_cyclic(s: &Vec<i8>) -> (res: Vec<i8>)
    ensures 
        s.len() == res.len(),
        forall|i: int| s@.len() - s@.len() % 3 <= i < s@.len() ==> res@[i] == s@[i],
        forall|i: int| 0 <= i < s@.len() - s@.len() % 3 ==> (i % 3 == 0 ==> res@[i] == s@[i + 2]),
        forall|i: int| 0 <= i < s@.len() - s@.len() % 3 ==> (i % 3 == 1 ==> res@[i] == s@[i - 1])","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVH03,0.85
VH0041,verus,humaneval,humaneval_038_encode_cyclic__encode_cyclic,,"function_signature: fn encode_cyclic(s: Vec<i8>) -> (res: Vec<i8>)

Encode data. Ensures: returns the correct size/count; the condition holds for all
values; the condition holds for all values; the condition holds for all values;
the condition holds for all values.","use vstd::prelude::*;

verus! {",,"fn encode_cyclic(s: Vec<i8>) -> (res: Vec<i8>)
    ensures 
        s.len() == res.len(),
        forall|i: int| 0 <= i < s@.len() - s@.len() % 3 ==> (i % 3 == 0 ==> res@[i] == s@[i + 1]),
        forall|i: int| 0 <= i < s@.len() - s@.len() % 3 ==> (i % 3 == 1 ==> res@[i] == s@[i + 1]),
        forall|i: int| 0 <= i < s@.len() - s@.len() % 3 ==> (i % 3 == 2 ==> res@[i] == s@[i - 2]),
        forall|i: int| s@.len() - s@.len() % 3 <= i < s@.len() ==> (res@[i] == s@[i])","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVH03,0.85
VH0042,verus,humaneval,humaneval_040,,"This verification task involves implementing a method to determine
if there exist three distinct elements at different positions in a list of integers
that sum to zero. The implementation should exhaustively check all possible combinations
of three indices and return true if any triple sums to zero.","use vstd::prelude::*;

verus! {

spec fn has_triple_sum_to_zero(l: Seq<int>) -> bool {
    exists|i: int, j: int, k: int| 0 <= i < j < k < l.len() && l[i] + l[j] + l[k] == 0
}",,"fn triples_sum_to_zero(l: Vec<i8>) -> (result: bool)
    ensures result == has_triple_sum_to_zero(l@.map(|i, x: i8| x as int))","{
    // impl-start
    assume(false);
    false
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0043,verus,humaneval,humaneval_041,,"Given n cars moving left-to-right and n cars moving right-to-left
on a straight infinite road, all at the same speed, calculate the total number of
collisions. Cars pass through each other when they collide and continue moving.
Each left-moving car will collide with each right-moving car exactly once, resulting
in n * n total collisions.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int) -> bool {
    n >= 0
}

spec fn collision_count(n: int) -> int
    recommends valid_input(n)
{
    n * n
}

spec fn valid_result(n: int, result: int) -> bool
    recommends valid_input(n)
{
    result == collision_count(n) && result >= 0
}",,"fn car_race_collision(n: i8) -> (result: i8)
    requires valid_input(n as int)
    ensures valid_result(n as int, result as int)","{
    assume(false);
    0
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0044,verus,humaneval,humaneval_042,,"This task implements a function to increment each element in a list
of integers by 1. Given a sequence of integers, the function should return a new
sequence where each element is the corresponding element from the input sequence
plus one.","use vstd::prelude::*;

verus! {

spec fn valid_input(l: Seq<int>) -> bool
{
    true
}

spec fn correct_output(l: Seq<int>, result: Seq<int>) -> bool
{
    result.len() == l.len() && 
    forall|i: int| 0 <= i < l.len() ==> result[i] == l[i] + 1
}",,"fn incr_list(l: Vec<i8>) -> (result: Vec<i8>)
    requires valid_input(l@.map(|i: int, x: i8| x as int))
    ensures correct_output(l@.map(|i: int, x: i8| x as int), result@.map(|i: int, x: i8| x as int))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,0.7
VH0045,verus,humaneval,humaneval_043,,"Given a list of integers, determine if there exist two distinct elements
at different positions that sum to zero. This task requires implementing an efficient
algorithm to check for the existence of such a pair.","use vstd::prelude::*;

verus! {

spec fn has_pair_sum_to_zero(l: Seq<int>) -> bool {
    exists|i: int, j: int| 0 <= i < j < l.len() && l[i] + l[j] == 0
}",,"fn pairs_sum_to_zero(l: Vec<i8>) -> (result: bool)
    ensures result == has_pair_sum_to_zero(l@.map(|i: int, x: i8| x as int))","{
    assume(false);
    false
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0046,verus,humaneval,humaneval_044,,"This verification task implements a function to convert an integer
from base 10 to a specified base (where base < 10) and return its string representation.
The implementation should correctly handle the conversion process by repeatedly
dividing by the target base to extract digits, then reversing the resulting digit
sequence to produce the final string representation.","use vstd::prelude::*;

verus! {

spec fn power_of_base(base: int, exp: int) -> int
  decreases exp
{
  if base >= 2 && exp >= 0 {
    if exp == 0 { 1 } else { base * power_of_base(base, exp - 1) }
  } else {
    0
  }
}

spec fn digits_to_int(digits: Seq<char>, base: int) -> int
  decreases digits.len()
{
  if base >= 2 && (forall|i: int| 0 <= i < digits.len() ==> '0' <= digits[i] <= '9' && (digits[i] as int) - ('0' as int) < base) {
    if digits.len() == 0 { 0 }
    else { (digits[0] as int) - ('0' as int) + base * digits_to_int(digits.subrange(1, digits.len() as int), base) }
  } else {
    0
  }
}

spec fn string_to_int_in_base(s: Seq<char>, base: int) -> int
  decreases s.len()
{
  if base >= 2 && s.len() > 0 && (forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] <= '9' && (s[i] as int) - ('0' as int) < base) {
    if s.len() == 1 {
      (s[0] as int) - ('0' as int)
    } else {
      string_to_int_in_base(s.subrange(0, s.len() - 1), base) * base + ((s[s.len() - 1] as int) - ('0' as int))
    }
  } else {
    0
  }
}",,"fn change_base(x: i8, base: i8) -> (result: Vec<char>)
  requires 
    base >= 2 && base < 10,
    x >= 0,
  ensures 
    x as int == 0 ==> result@ == seq!['0'],
    x as int > 0 ==> result@.len() > 0 && result@[0] != '0',
    forall|i: int| 0 <= i < result@.len() ==> '0' <= result@[i] <= '9' && (result@[i] as int) - ('0' as int) < base as int,
    x as int > 0 ==> string_to_int_in_base(result@, base as int) == x as int,","{
  assume(false);
  Vec::new()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0047,verus,humaneval,humaneval_045,,This task involves calculating the area of a triangle given the length of its base and height using the standard formula: Area = (base × height) ÷ 2. The implementation should handle non-negative inputs and ensure the result is also non-negative.,"use vstd::prelude::*;

verus! {

spec fn valid_input(base: int, height: int) -> bool {
    base >= 0 && height >= 0
}

spec fn triangle_area_formula(base: int, height: int) -> int {
    (base * height) / 2
}

spec fn triangle_area(a: int, h: int) -> int {
    (a * h) / 2
}

// </vc-preamble>",,"fn calculate_triangle_area(base: u8, height: u8) -> (area: u8)
    requires 
        valid_input(base as int, height as int)
    ensures 
        area as int >= 0,
        area as int == triangle_area_formula(base as int, height as int),
        (base == 0 || height == 0) ==> area == 0","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0048,verus,humaneval,humaneval_046,,"This task implements an iterative solution to compute the n-th element
of the Fib4 sequence. The Fib4 sequence is defined with base cases fib4(0)=0, fib4(1)=0,
fib4(2)=2, fib4(3)=0, and for n≥4, fib4(n) = fib4(n-1) + fib4(n-2) + fib4(n-3) +
fib4(n-4).

The implementation must be iterative and efficient, using a sliding window approach
to maintain the last 4 values instead of recursion, while proving equivalence to
the recursive specification.","use vstd::prelude::*;

verus! {

spec fn fib4_func(n: int) -> int
    recommends n >= 0
    decreases n
{
    if n < 0 { 0 }
    else if n == 0 { 0 }
    else if n == 1 { 0 }
    else if n == 2 { 2 }
    else if n == 3 { 0 }
    else { fib4_func(n-1) + fib4_func(n-2) + fib4_func(n-3) + fib4_func(n-4) }
}",,"fn fib4(n: i8) -> (result: i8)
    requires n >= 0
    ensures 
        result as int == fib4_func(n as int) &&
        (n == 0 ==> result == 0) &&
        (n == 1 ==> result == 0) &&
        (n == 2 ==> result == 2) &&
        (n == 3 ==> result == 0) &&
        (n >= 4 ==> result as int == fib4_func(n as int - 1) + fib4_func(n as int - 2) + fib4_func(n as int - 3) + fib4_func(n as int - 4))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0049,verus,humaneval,humaneval_047,,"This verification task implements a median function for a sequence
of real numbers. For odd-length lists, it returns the middle element after sorting.
For even-length lists, it returns the average of the two middle elements after sorting.

The implementation uses helper functions for insertion sort and includes comprehensive
specifications to ensure the sorted list preserves the original multiset and maintains
proper ordering.","use vstd::prelude::*;
use vstd::multiset::*;

verus! {

spec fn insert_sorted(x: int, sorted: Seq<int>) -> Seq<int>
    decreases sorted.len()
{
    if sorted.len() == 0 {
        seq![x]
    } else if x <= sorted[0] {
        seq![x].add(sorted)
    } else {
        seq![sorted[0]].add(insert_sorted(x, sorted.subrange(1, sorted.len() as int)))
    }
}

spec fn sort(s: Seq<int>) -> Seq<int>
    decreases s.len()
{
    if s.len() == 0 {
        seq![]
    } else {
        insert_sorted(s[0], sort(s.subrange(1, s.len() as int)))
    }
}

spec fn is_sorted(s: Seq<int>) -> bool {
    forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] <= s[j]
}

spec fn multiset_from_seq(s: Seq<int>) -> Multiset<int>
    decreases s.len()
{
    if s.len() == 0 {
        Multiset::empty()
    } else {
        Multiset::singleton(s[0]).add(multiset_from_seq(s.subrange(1, s.len() as int)))
    }
}

spec fn valid_input(l: Seq<int>) -> bool {
    l.len() > 0
}

spec fn median_value(l: Seq<int>) -> int {
    if l.len() == 0 {
        0int
    } else {
        let sorted_list = sort(l);
        let n = sorted_list.len();
        if n % 2 == 1 {
            sorted_list[(n / 2) as int]
        } else {
            (sorted_list[(n / 2 - 1) as int] + sorted_list[(n / 2) as int]) / 2
        }
    }
}",,"fn median(l: Seq<int>) -> (result: int)
    requires valid_input(l)
    ensures 
        result == median_value(l) &&
        ({
            let sorted_list = sort(l);
            let n = sorted_list.len();
            n % 2 == 1 ==> result == sorted_list[(n / 2) as int]
        }) &&
        ({
            let sorted_list = sort(l);
            let n = sorted_list.len();
            n % 2 == 0 ==> result == (sorted_list[(n / 2 - 1) as int] + sorted_list[(n / 2) as int]) / 2
        }) &&
        is_sorted(sort(l)) &&
        multiset_from_seq(sort(l)) == multiset_from_seq(l) &&
        (l.len() == 1 ==> result == l[0])","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0050,verus,humaneval,humaneval_048,,"Determine if a given string is a palindrome (reads the same forwards
and backwards). The comparison should be case-insensitive, requiring implementation
of a case conversion function and a palindrome checking predicate.","use vstd::prelude::*;

verus! {

spec fn to_lower(c: char) -> char {
    if 'A' <= c && c <= 'Z' {
        ((c as u8 - 'A' as u8 + 'a' as u8) as char)
    } else {
        c
    }
}

spec fn is_palindrome_spec(text: Seq<char>) -> bool {
    forall|i: int| 0 <= i < text.len() ==> #[trigger] to_lower(text[i]) == to_lower(text[text.len() - 1 - i])
}",,"fn is_palindrome(text: Vec<char>) -> (result: bool)
    ensures result <==> is_palindrome_spec(text@)","{
    assume(false);
    false
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0051,verus,humaneval,humaneval_049,,"This verification task involves implementing efficient modular exponentiation
to compute 2^n mod p. The method should use binary exponentiation (repeated squaring)
for optimal O(log n) time complexity, maintaining appropriate loop invariants to
prove correctness.","use vstd::prelude::*;

verus! {

spec fn power(base: int, exp: nat) -> int
    decreases exp
{
    if exp == 0 {
        1
    } else {
        base * power(base, (exp - 1) as nat)
    }
}",,"fn modp(n: i8, p: i8) -> (result: i8)
    requires 
        n >= 0 && p > 0,
    ensures 
        result >= 0 && result < p,
        result as int == power(2, n as nat) % (p as int),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0052,verus,humaneval,humaneval_050_encode_shift__decode_shift,,"function_signature: fn decode_shift(s: Vec<char>) -> (t: Vec<char>)

Decode data. Requires: the condition holds for all values. Ensures: returns the
correct size/count; the condition holds for all values.","use vstd::prelude::*;

verus! {

spec fn encode_char(c: char) -> char {
    ((c as int - 'a' as int + 5) % 26 + 'a' as int) as char
}

spec fn decode_char(c: char) -> char {
    ((c as int - 'a' as int - 5) % 26 + 'a' as int) as char
}

spec fn valid_char(c: char) -> bool {
    'a' <= c <= 'z'
}",,"fn decode_shift(s: Vec<char>) -> (t: Vec<char>)
    requires forall|i: int| 0 <= i < s.len() ==> valid_char(s[i])
    ensures s.len() == t.len(),
            forall|i: int| 0 <= i < s.len() ==> t[i] == decode_char(s[i])","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVH02,0.85
VH0053,verus,humaneval,humaneval_050_encode_shift__encode_shift,,"function_signature: fn encode_shift(s: Vec<char>) -> (t: Vec<char>)

Encode data. Requires: the condition holds for all values. Ensures: returns the
correct size/count; the condition holds for all values.","use vstd::prelude::*;

verus! {

spec fn encode_char(c: char) -> char {
    ((c as int - 'a' as int + 5) % 26 + 'a' as int) as char
}

spec fn decode_char(c: char) -> char {
    ((c as int - 'a' as int - 5) % 26 + 'a' as int) as char
}",,"fn encode_shift(s: Vec<char>) -> (t: Vec<char>)
    requires forall|i: int| 0 <= i < s@.len() ==> 'a' <= #[trigger] s@[i] <= 'z'
    ensures s@.len() == t@.len() && forall|i: int| 0 <= i < s@.len() ==> t@[i] == encode_char(s@[i])","{
    assume(false);
    Vec::new()
}","
}

fn main() {}",0,,-1,-1,-1,DupVH02,0.85
VH0054,verus,humaneval,humaneval_051,,"This verification task involves removing all vowels (both lowercase and uppercase) from a given string and returning the resulting string. Vowels are defined as the characters: a, e, i, o, u, A, E, I, O, U. The implementation must preserve the order of non-vowel characters and ensure the result contains only characters from the original string that are not vowels.","use vstd::prelude::*;

verus! {

spec fn is_vowel(c: char) -> bool {
    c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || 
    c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U'
}

spec fn valid_result(text: Seq<char>, result: Seq<char>) -> bool {
    && result.len() <= text.len()
    && (forall|i: int| 0 <= i < result.len() ==> !is_vowel(result[i]))
    && (forall|i: int, j: int| #![trigger result[i], result[j]] 0 <= i < j < result.len() ==> 
        (exists|k: int, l: int| 0 <= k < l < text.len() && text[k] == result[i] && text[l] == result[j] &&
        !is_vowel(text[k]) && !is_vowel(text[l])))
    && ((forall|i: int| 0 <= i < text.len() ==> is_vowel(text[i])) ==> result.len() == 0)
    && (forall|i: int| 0 <= i < text.len() && !is_vowel(text[i]) ==> result.contains(text[i]))
    && (forall|c: char| result.contains(c) ==> text.contains(c) && !is_vowel(c))
}",,"fn remove_vowels(text: &str) -> (result: String)
    ensures valid_result(text@, result@)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0055,verus,humaneval,humaneval_052,,"This verification task implements a method to check if all integers
in a given list are strictly less than a specified threshold value. The method should
return true if and only if every element in the sequence satisfies the threshold
condition.","use vstd::prelude::*;

verus! {

spec fn below_threshold(l: Seq<int>, t: int) -> bool {
    forall|i: int| 0 <= i < l.len() ==> l[i] < t
}",,"fn check_below_threshold(l: Vec<i8>, t: i8) -> (result: bool)
    ensures result == below_threshold(l@.map(|_i: int, x: i8| x as int), t as int)","{
    // impl-start
    assume(false);
    false
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0056,verus,humaneval,humaneval_053,,"This verification task implements a simple addition function that
takes two integers as input and returns their sum. The implementation should correctly
add the two input integers and satisfy the postcondition that the result equals
the mathematical sum of the inputs.","use vstd::prelude::*;

verus! {

spec fn valid_input(x: int, y: int) -> bool
{
    true
}

spec fn correct_sum(x: int, y: int) -> int
{
    x + y
}",,"fn add(x: i8, y: i8) -> (result: i8)
    requires valid_input(x as int, y as int)
    ensures result as int == correct_sum(x as int, y as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,0.7
VH0057,verus,humaneval,humaneval_054,,"This task involves determining if two strings contain exactly the
same set of unique characters, regardless of character frequency or order. The implementation
should compare the set of characters in each string and return true if they are
identical sets.","use vstd::prelude::*;

verus! {

spec fn char_set(s: Seq<char>) -> Set<char> {
    s.to_set()
}",,"fn same_chars(s0: Vec<char>, s1: Vec<char>) -> (result: bool)
    ensures result == (char_set(s0@) == char_set(s1@))","{
    assume(false);
    false
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0058,verus,humaneval,humaneval_055,,"This task involves computing the n-th Fibonacci number using 1-based
indexing, where fib(1) = 1 and fib(2) = 1. The implementation should efficiently
calculate the result for positive integers n.

The solution uses an iterative approach with loop invariants to maintain correctness
while avoiding the exponential time complexity of a naive recursive implementation.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int) -> bool {
    n > 0
}

spec fn fib_spec(n: int) -> int
    decreases n
{
    if n <= 0 { 1 }
    else if n == 1 { 1 }
    else if n == 2 { 1 }
    else { fib_spec(n - 1) + fib_spec(n - 2) }
}",,"fn fib(n: i8) -> (result: i8)
    requires valid_input(n as int)
    ensures 
        result as int == fib_spec(n as int) &&
        result > 0","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0059,verus,humaneval,humaneval_056,,"This verification task implements a bracket matching algorithm that
determines if a string containing only ""<"" and "">"" characters has properly nested
brackets. Every opening bracket ""<"" must have a corresponding closing bracket "">""
and they must be correctly nested, meaning at no point should the number of closing
brackets exceed the number of opening brackets in any prefix.","use vstd::prelude::*;

verus! {

spec fn count_brackets_prefix(s: Seq<char>, end: int, bracket: char) -> int
    decreases end
{
    if end == 0 {
        0
    } else if 0 <= end <= s.len() && (bracket == '<' || bracket == '>') && s[end - 1] == bracket {
        1 + count_brackets_prefix(s, end - 1, bracket)
    } else if 0 <= end <= s.len() && (bracket == '<' || bracket == '>') {
        count_brackets_prefix(s, end - 1, bracket)
    } else {
        0
    }
}

spec fn valid_bracket_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> s[i] == '<' || s[i] == '>'
}

spec fn properly_nested(brackets: Seq<char>) -> bool {
    valid_bracket_string(brackets) &&
    (forall|k: int| 0 <= k <= brackets.len() ==> 
        count_brackets_prefix(brackets, k, '<') >= count_brackets_prefix(brackets, k, '>')) &&
    count_brackets_prefix(brackets, brackets.len() as int, '<') == count_brackets_prefix(brackets, brackets.len() as int, '>')
}",,"fn correct_bracketing(brackets: Vec<char>) -> (result: bool)
    requires valid_bracket_string(brackets@)
    ensures result <==> properly_nested(brackets@)","{
    // impl-start
    assume(false);
    false
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0060,verus,humaneval,humaneval_057,,"This verification task implements a function to determine if a list of numbers is monotonic. A list is monotonic if it is either entirely non-decreasing (monotonically increasing) or entirely non-increasing (monotonically decreasing). Empty lists and single-element lists are considered monotonic, and lists with equal consecutive elements are allowed.","use vstd::prelude::*;

verus! {

spec fn monotonic(l: Seq<int>) -> bool {
    if l.len() <= 1 {
        true
    } else {
        let increasing = forall|i: nat| #![trigger l[i as int]] i < l.len() - 1 ==> l[i as int] <= l[(i + 1) as int];
        let decreasing = forall|i: nat| #![trigger l[i as int]] i < l.len() - 1 ==> l[i as int] >= l[(i + 1) as int];
        increasing || decreasing
    }
}",,"fn is_monotonic(l: Vec<i8>) -> (result: bool)
    ensures result == monotonic(l@.map(|_i: int, x: i8| x as int))","{
    assume(false);
    false
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0061,verus,humaneval,humaneval_058_common,,"function_signature: fn common(l1: &Vec<i32>, l2: &Vec<i32>) -> Set<i32>

Return sorted unique common elements for two lists.","use vstd::prelude::*;

verus! {",,"fn common(l1: &Vec<i32>, l2: &Vec<i32>) -> (c: Set<i32>)
    ensures 
        (forall|i: i32| c.contains(i) ==> l1@.contains(i) && l2@.contains(i)) &&
        (forall|i: i32| l1@.contains(i) && l2@.contains(i) ==> c.contains(i))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0062,verus,humaneval,humaneval_059,,"This verification task implements an algorithm to find the largest
prime factor of a composite integer n (where n > 1 and n is not prime). The algorithm
uses trial division, first removing all factors of 2, then checking odd factors
up to the square root of the remaining number.


The implementation must ensure that the returned result is indeed a prime number,
divides n, and is the largest such prime factor among all factors of n.","use vstd::prelude::*;

verus! {

spec fn is_prime(n: int) -> bool {
    n > 1 && forall|k: int| 2 <= k < n ==> #[trigger] (n % k) != 0
}

spec fn power_of_2_factor(n: int, current: int) -> int
    recommends n > 0 && current > 0
    decreases current
    when current > 0
{
    if current % 2 != 0 { 1 }
    else { 2 * power_of_2_factor(n, current / 2) }
}",,"fn largest_prime_factor(n: i8) -> (result: i8)
    requires 
        n as int > 1,
        !is_prime(n as int),
    ensures 
        result as int > 1,
        (n as int) % (result as int) == 0,
        forall|k: int| k > result as int && (n as int) % k == 0 ==> !is_prime(k),
        is_prime(result as int),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0063,verus,humaneval,humaneval_060,,"This verification task implements the computation of the sum of all
integers from 1 to n inclusive, where n is a positive integer. The expected implementation
should use the well-known mathematical formula n*(n+1)/2 for efficiency.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int) -> bool {
    n >= 1
}

spec fn sum_from_one_to_n(n: int) -> int
    recommends n >= 1
{
    n * (n + 1) / 2
}",,"fn sum_to_n(n: i8) -> (result: i8)
    requires valid_input(n as int)
    ensures result as int == sum_from_one_to_n(n as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0064,verus,humaneval,humaneval_062,,"This task involves computing the derivative of a polynomial given its coefficients. Given a sequence of coefficients where xs[i] represents the coefficient of x^i, the method should return the derivative coefficients where [a₀, a₁, a₂, ...] becomes [a₁, 2a₂, 3a₃, ...].","use vstd::prelude::*;

verus! {

spec fn valid_input(xs: Seq<int>) -> bool {
    true  /* Any sequence of coefficients is valid input */
}

spec fn derivative_length(xs: Seq<int>) -> nat {
    if xs.len() <= 1 { 0nat } else { (xs.len() - 1) as nat }
}

spec fn correct_derivative_coefficients(xs: Seq<int>, result: Seq<int>) -> bool {
    xs.len() <= 1 ==> result == Seq::<int>::empty() &&
    xs.len() > 1 ==> (result.len() == xs.len() - 1 && 
                      forall|j: int| 0 <= j < result.len() ==> result[j] == (j + 1) * xs[j + 1])
}",,"fn derivative(xs: Vec<i8>) -> (result: Vec<i8>)
    requires 
        valid_input(xs@.map(|i: int, x: i8| x as int))
    ensures 
        correct_derivative_coefficients(xs@.map(|i: int, x: i8| x as int), result@.map(|i: int, x: i8| x as int)),
        result@.len() == derivative_length(xs@.map(|i: int, x: i8| x as int))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0065,verus,humaneval,humaneval_063,,"This verification task involves implementing the FibFib sequence, which is a modified Fibonacci sequence. The FibFib sequence is defined with base cases fibfib(0) = 0, fibfib(1) = 0, fibfib(2) = 1, and for n >= 3, fibfib(n) = fibfib(n-1) + fibfib(n-2) + fibfib(n-3). The expected implementation should efficiently compute the n-th element using dynamic programming rather than naive recursion.","use vstd::prelude::*;

verus! {

spec fn fibfib_spec(n: int) -> int
    recommends n >= 0
    decreases n when n >= 0
{
    if n == 0 { 0 }
    else if n == 1 { 0 }
    else if n == 2 { 1 }
    else if n >= 3 { fibfib_spec(n-1) + fibfib_spec(n-2) + fibfib_spec(n-3) }
    else { 0 }
}",,"fn fibfib(n: u8) -> (result: u8)
    requires n >= 0
    ensures 
        result as int == fibfib_spec(n as int) &&
        (n == 0 ==> result == 0) &&
        (n == 1 ==> result == 0) &&
        (n == 2 ==> result == 1) &&
        (n >= 3 ==> result as int == fibfib_spec((n-1) as int) + fibfib_spec((n-2) as int) + fibfib_spec((n-3) as int))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0066,verus,humaneval,humaneval_064_vowels_count,,"function_signature: def remove_vowels(string: str) -> Nat

Write a function vowels_count which takes a string representing a word as input
and returns the number of vowels in the string. Vowels in this case are 'a', 'e',
'i', 'o', 'u'. Here, 'y' is also a vowel, but only when it is at the end
of the given word.","use vstd::prelude::*;

verus! {

spec fn is_vowel(c: char) -> bool
{
  c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U'
}

spec fn count_vowels(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0int
    } else {
        count_vowels(s.subrange(1, s.len() as int)) + (if is_vowel(s[0]) { 1int } else { 0int })
    }
}",,"fn vowel_count(s: &Vec<char>) -> (count: u8)
  ensures
    count as int >= 0,
    count as int == count_vowels(s@) + (if s@.len() > 0 && s@[s@.len() - 1] == 'y' { 1int } else { 0int })","{
    assume(false);
    0
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0067,verus,humaneval,humaneval_065,,"This verification task implements a circular right shift operation
on the digits of an integer. Given an integer x and a shift amount, the method performs
a circular right shift on the digits of x and returns the result as a string. A
circular right shift moves digits from the end to the beginning. If the shift amount
exceeds the number of digits in x, the method returns the digits of x in reversed
order instead.","use vstd::prelude::*;

verus! {

spec fn int_to_string(x: int) -> Seq<char>
    recommends x >= 0
{
    if x == 0 { seq!['0'] }
    else { int_to_string_helper(x, seq![]) }
}

spec fn int_to_string_helper(x: int, acc: Seq<char>) -> Seq<char>
    recommends x >= 0
    decreases x when x >= 0
{
    if x <= 0 { acc }
    else { 
        let digit_char = ((x % 10) + ('0' as int)) as char;
        int_to_string_helper(x / 10, seq![digit_char].add(acc))
    }
}

spec fn reverse_string(s: Seq<char>) -> Seq<char>
    decreases s.len()
{
    if s.len() <= 1 { s }
    else { reverse_string(s.subrange(1, s.len() as int)).add(seq![s[0]]) }
}",,"fn circular_shift(x: i8, shift: i8) -> (result: Vec<char>)
    ensures 
        ({
            let abs_x = if (x as int) < 0 { -((x as int)) } else { x as int };
            result.len() == int_to_string(abs_x).len()
        }) &&
        ({
            let abs_x = if (x as int) < 0 { -((x as int)) } else { x as int };
            shift as int > int_to_string(abs_x).len() ==> 
                result@ == reverse_string(int_to_string(abs_x))
        }) &&
        ({
            let abs_x = if (x as int) < 0 { -((x as int)) } else { x as int };
            shift as int <= int_to_string(abs_x).len() && int_to_string(abs_x).len() > 0 ==> {
                let digits = int_to_string(abs_x);
                let n = digits.len() as int;
                let normalized_shift = (shift as int) % n;
                normalized_shift == 0 ==> result@ == digits
            }
        }) &&
        ({
            let abs_x = if (x as int) < 0 { -((x as int)) } else { x as int };
            shift as int <= int_to_string(abs_x).len() && int_to_string(abs_x).len() > 0 ==> {
                let digits = int_to_string(abs_x);
                let n = digits.len() as int;
                let normalized_shift = (shift as int) % n;
                normalized_shift > 0 ==> result@ == digits.subrange(n - normalized_shift, n).add(digits.subrange(0, n - normalized_shift))
            }
        }) &&
        (forall|i: int| 0 <= i < result.len() ==> '0' <= result[i] && result[i] <= '9')","{
    assume(false);
    Vec::new()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0068,verus,humaneval,humaneval_066,,This task involves calculating the sum of ASCII values of all uppercase letters in a string. The function should return 0 for empty strings and only consider characters from 'A' to 'Z' as uppercase. The implementation needs to be verified with an iterative method that maintains proper loop invariants.,"use vstd::prelude::*;

verus! {

spec fn sum_of_uppercase_ascii(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 { 
        0
    } else {
        let c = s[0];
        let rest = sum_of_uppercase_ascii(s.subrange(1, s.len() as int));
        if 'A' <= c && c <= 'Z' { 
            (c as int) + rest
        } else {
            rest
        }
    }
}",,"fn digit_sum(s: Vec<char>) -> (result: i32)
    ensures 
        result >= 0,
        result == sum_of_uppercase_ascii(s@)","{
    assume(false);
    0
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0069,verus,humaneval,humaneval_067,,"Given a string containing quantities of apples and oranges and the
total number of fruits, calculate the number of mangoes. The basket contains only
apples, oranges, and mangoes. The implementation must extract numbers from the input
string, sum them up, and subtract from the total to find the number of mangoes.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int) -> bool {
    n >= 0
}

spec fn sum_of_numbers_in_string(s: Seq<char>) -> int {
    let numbers = extract_numbers_from_string(s);
    sum_sequence(numbers)
}

spec fn extract_numbers_from_string(s: Seq<char>) -> Seq<int> {
    extract_numbers_helper(s, 0, 0, false, seq![])
}

spec fn sum_sequence(numbers: Seq<int>) -> int
    decreases numbers.len()
{
    if numbers.len() == 0 {
        0int
    } else {
        numbers[0] + sum_sequence(numbers.subrange(1, numbers.len() as int))
    }
}
spec fn extract_numbers_helper(s: Seq<char>, i: int, current_number: int, in_number: bool, numbers: Seq<int>) -> Seq<int>
    decreases s.len() - i when 0 <= i <= s.len() && current_number >= 0
{
    if 0 <= i <= s.len() && current_number >= 0 {
        if i == s.len() {
            if in_number { numbers.push(current_number) } else { numbers }
        } else {
            let c = s[i];
            if '0' <= c && c <= '9' {
                let digit = c as int - '0' as int;
                extract_numbers_helper(s, i + 1, current_number * 10 + digit, true, numbers)
            } else {
                if in_number {
                    extract_numbers_helper(s, i + 1, 0, false, numbers.push(current_number))
                } else {
                    extract_numbers_helper(s, i + 1, 0, false, numbers)
                }
            }
        }
    } else {
        seq![]
    }
}",,"fn fruit_distribution(s: &Vec<char>, n: u32) -> (mangoes: u32)
    requires valid_input(n as int)
    ensures mangoes as int == (n as int) - sum_of_numbers_in_string(s@),
            (mangoes as int >= 0) <==> ((n as int) >= sum_of_numbers_in_string(s@))","{
    // impl-start
    assume(false);
    0
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0070,verus,humaneval,humaneval_068,,"This verification task implements a function that finds the smallest
even value in an array of non-negative integers and returns it along with its index.
If multiple occurrences of the same smallest even value exist, it should return
the one with the smallest index. If no even values exist or the array is empty,
it returns an empty list.

The implementation must correctly handle edge cases and maintain loop invariants
to prove that the returned result satisfies all the postconditions, including finding
the true minimum even value and the earliest index for that value.","use vstd::prelude::*;

verus! {

spec fn valid_input(arr: Seq<int>) -> bool {
    forall|i: int| 0 <= i < arr.len() ==> arr[i] >= 0
}

spec fn has_even_value(arr: Seq<int>) -> bool {
    exists|i: int| 0 <= i < arr.len() && arr[i] % 2 == 0
}

spec fn smallest_even_value(arr: Seq<int>) -> int {
    smallest_even_value_helper(arr, 0, -1)
}

spec fn smallest_even_value_helper(arr: Seq<int>, index: int, current_min: int) -> int
    decreases arr.len() - index
{
    if index >= arr.len() {
        current_min
    } else if arr[index] % 2 == 0 {
        if current_min == -1 || arr[index] < current_min {
            smallest_even_value_helper(arr, index + 1, arr[index])
        } else {
            smallest_even_value_helper(arr, index + 1, current_min)
        }
    } else {
        smallest_even_value_helper(arr, index + 1, current_min)
    }
}

spec fn first_index_of_value(arr: Seq<int>, value: int) -> int
    decreases arr.len()
{
    if arr.len() > 0 && arr[0] == value {
        0
    } else if arr.len() > 0 {
        1 + first_index_of_value(arr.subrange(1, arr.len() as int), value)
    } else {
        0
    }
}",,"fn pluck(arr: Vec<i8>) -> (result: Vec<i8>)
    requires 
        valid_input(arr@.map_values(|x: i8| x as int))
    ensures 
        arr@.len() == 0 ==> result@.len() == 0,
        !has_even_value(arr@.map_values(|x: i8| x as int)) ==> result@.len() == 0,
        has_even_value(arr@.map_values(|x: i8| x as int)) ==> result@.len() == 2,
        result@.len() == 2 ==> (0 <= (result@[1] as int) && (result@[1] as int) < (arr@.len() as int)),
        result@.len() == 2 ==> arr@[result@[1] as int] as int == result@[0] as int,
        result@.len() == 2 ==> result@[0] as int % 2 == 0,
        result@.len() == 2 ==> forall|i: int| 0 <= i < arr@.len() && arr@[i] as int % 2 == 0 ==> result@[0] as int <= arr@[i] as int,
        result@.len() == 2 ==> forall|i: int| 0 <= i < arr@.len() && arr@[i] as int % 2 == 0 && arr@[i] as int == result@[0] as int ==> result@[1] as int <= i","{
    assume(false);
    Vec::new()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0071,verus,humaneval,humaneval_069,,"This verification task involves finding the greatest integer in a
list whose frequency is greater than or equal to its own value. Given a non-empty
list of positive integers, the implementation should return this greatest qualifying
integer, or -1 if no such integer exists.

The task requires building a frequency map for all elements in the list, then identifying
which elements have frequencies meeting the criteria, and finally selecting the
maximum among those valid elements.","use vstd::prelude::*;

verus! {

spec fn count(s: Seq<int>, x: int) -> int {
    s.filter(|i: int| i == x).len() as int
}

spec fn max_seq(s: Seq<int>) -> int
    recommends s.len() > 0
{
    if s.len() == 1 { s[0] } else { choose|x: int| s.contains(x) }
}

spec fn valid_input(lst: Seq<int>) -> bool {
    lst.len() > 0 && forall|i: int| 0 <= i < lst.len() ==> lst[i] > 0
}

spec fn valid_result(lst: Seq<int>, result: int) -> bool
    recommends valid_input(lst)
{
    if result == -1 {
        forall|x: int| #![auto] lst.contains(x) ==> count(lst, x) < x
    } else {
        result > 0 &&
        lst.contains(result) && 
        count(lst, result) >= result &&
        forall|y: int| #![auto] lst.contains(y) && count(lst, y) >= y ==> y <= result
    }
}

// </vc-preamble>",,"fn search(lst: Vec<i8>) -> (result: i8)
    requires valid_input(lst@.map(|_index: int, x: i8| x as int))
    ensures valid_result(lst@.map(|_index: int, x: i8| x as int), result as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0072,verus,humaneval,humaneval_070_strange_sort_list__strange_sort_list_helper,,"function_signature: fn strange_sort_list_helper(s: Vec<i8>) -> (Vec<i8>, Vec<i8>)

Sort elements. Ensures: returns a sorted permutation of the input; returns the correct
size/count; the result is sorted according to the ordering relation; the result
is sorted according to the ordering relation.","use vstd::prelude::*;

verus! {",,"fn strange_sort_list_helper(s: Vec<i8>) -> (res: (Vec<i8>, Vec<i8>))
    ensures 
        s@.to_multiset() == res.0@.to_multiset(),
        s@.len() == res.0@.len() && s@.len() == res.1@.len(),
        forall|i: int| 0 <= i < s@.len() && i % 2 == 0 ==> res.1@[i] == res.0@[i / 2],
        forall|i: int| 0 <= i < s@.len() && i % 2 == 1 ==> res.1@[i] == res.0@[s@.len() - (i - 1) / 2 - 1]","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVH00,0.85
VH0073,verus,humaneval,humaneval_072,,"This task determines if an object will fly based on two conditions:
the given list of numbers must be palindromic, and the sum of all elements must
be within a specified weight limit. The implementation needs to check both conditions
and return true only if both are satisfied.","use vstd::prelude::*;

verus! {
spec fn is_palindrome(s: Seq<int>) -> bool {
    forall|i: int| #![trigger s[i]] 0 <= i < s.len() ==> s[i] == s[s.len() - 1 - i]
}

spec fn sum_elements(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else {
        s[0] + sum_elements(s.subrange(1, s.len() as int))
    }
}

// </vc-preamble>",,"fn will_it_fly(q: Vec<i8>, w: i8) -> (result: bool)
    ensures result == (is_palindrome(q@.map(|i: int, x: i8| x as int)) && sum_elements(q@.map(|i: int, x: i8| x as int)) <= w as int)","{
    assume(false);
    false
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0074,verus,humaneval,humaneval_073,,"This verification task involves finding the minimum number of elements
that must be changed to make an array palindromic. A palindromic array reads the
same forwards and backwards. The solution should count the number of mismatched
pairs between corresponding positions from the start and end of the array.","use vstd::prelude::*;

verus! {

spec fn count_mismatched_pairs(arr: Seq<int>) -> int {
    count_mismatched_pairs_up_to(arr, arr.len() as int / 2)
}

spec fn count_mismatched_pairs_up_to(arr: Seq<int>, limit: int) -> int
    decreases limit
{
    if limit <= 0 || limit > arr.len() as int / 2 {
        0 as int
    } else if limit == 0 {
        0 as int
    } else {
        (if arr[limit - 1] != arr[arr.len() as int - limit] { 1 as int } else { 0 as int }) +
        count_mismatched_pairs_up_to(arr, limit - 1)
    }
}

spec fn can_make_palindromic_with_changes(arr: Seq<int>, num_changes: int) -> bool {
    num_changes >= 0 && num_changes >= count_mismatched_pairs(arr)
}",,"fn smallest_change(arr: Vec<i8>) -> (changes: usize)
    ensures 
        changes <= arr@.len() / 2,
        changes as int == count_mismatched_pairs(arr@.map(|i, x| x as int)),
        arr@.len() <= 1 ==> changes == 0,
        ({
            let arr_int = arr@.map(|i, x| x as int);
            forall|c: int| can_make_palindromic_with_changes(arr_int, c) ==> (0 <= c < changes as int ==> !can_make_palindromic_with_changes(arr_int, c))
        }),
        ({
            let arr_int = arr@.map(|i, x| x as int);
            can_make_palindromic_with_changes(arr_int, changes as int)
        })","{
    // impl-start
    assume(false);
    0
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0075,verus,humaneval,humaneval_074,,"This task implements a function that compares two lists of strings
by their total character count. Given two lists of strings, the function should
return the list that has the smaller total character count across all its strings.
If both lists have the same total character count, return the first list.","use vstd::prelude::*;

verus! {

spec fn total_chars(lst: Seq<Seq<char>>) -> nat
    decreases lst.len()
{
    if lst.len() == 0 {
        0
    } else {
        lst[0].len() + total_chars(lst.subrange(1, lst.len() as int))
    }
}",,"fn total_match(lst1: Vec<Vec<char>>, lst2: Vec<Vec<char>>) -> (result: Vec<Vec<char>>)
    ensures 
        result@ == lst1@ || result@ == lst2@,
        total_chars(lst1@.map_values(|v: Vec<char>| v@)) <= total_chars(lst2@.map_values(|v: Vec<char>| v@)) ==> result@ == lst1@,
        total_chars(lst1@.map_values(|v: Vec<char>| v@)) > total_chars(lst2@.map_values(|v: Vec<char>| v@)) ==> result@ == lst2@","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0076,verus,humaneval,humaneval_075,,"This verification task implements a method to determine if a given
integer (less than 100) is the product of exactly 3 prime numbers, counting repetitions.
The method performs prime factorization and checks if exactly 3 prime factors (with
repetitions) multiply to the original number.

The expected implementation uses trial division to find all prime factors, starting
with factors of 2, then checking odd numbers up to the square root, and finally
handling any remaining prime factor greater than the square root.","use vstd::prelude::*;

verus! {

spec fn is_prime_number(n: int) -> bool {
    n >= 2 && forall|k: int| #[trigger] (n % k) != 0 ==> (2 <= k < n ==> n % k != 0)
}

spec fn seq_product(factors: Seq<int>) -> int
    decreases factors.len()
{
    if factors.len() == 0 { 
        1 
    } else { 
        factors[0] * seq_product(factors.subrange(1, factors.len() as int))
    }
}

spec fn power(base: int, exp: nat) -> int
    decreases exp
{
    if exp == 0 { 
        1 
    } else { 
        base * power(base, (exp - 1) as nat)
    }
}",,"fn is_multiply_prime(a: i8) -> (result: bool)
    requires 
        a >= 0 && a < 100
    ensures 
        a < 8 ==> result == false,
        result == true <==> (exists|p1: int, p2: int, p3: int|
            p1 >= 2 && p2 >= 2 && p3 >= 2 && 
            is_prime_number(p1) && is_prime_number(p2) && is_prime_number(p3) &&
            a as int == p1 * p2 * p3)","{
    assume(false);
    false
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0077,verus,humaneval,humaneval_076_is_simple_power,,"function_signature: def is_simple_power(x: int, n: int) -> bool

Your task is to write a function that returns true if a number x is a simple power
of n and false in other cases. x is a simple power of n if n**int=x","use vstd::prelude::*;

verus! {

spec fn power(x: nat, y: nat) -> nat
    decreases y
{
    if y == 0 { 1 } else { x * power(x, (y - 1) as nat) }
}",,"fn is_simple_power(x: u8, n: i8) -> (ans: bool)
    requires x > 0
    ensures ans <==> exists|y: nat| n as int == power(x as nat, y) as int","{
    assume(false);
    false
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0078,verus,humaneval,humaneval_077_iscube__cube_root,,"function_signature: fn cube_root(n: nat) -> (r: nat)

Find the integer cube root. Ensures: the result r is the largest integer such that
r³ ≤ N < (r+1)³; the result is at most N.","use vstd::prelude::*;

verus! {

spec fn cube(n: nat) -> nat { n * n * n }",,"fn cube_root(n: u8) -> (r: u8)
    ensures 
        cube(r as nat) <= n as nat,
        (n as nat) < cube((r as nat) + 1),
        r as nat <= n as nat,","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0079,verus,humaneval,humaneval_077_iscube__is_cube,,"function_signature: fn is_cube(n: nat) -> (r: bool)

Check if condition holds. Ensures: if true, then there exists an integer r such
that N = r³; if false, then no integer r satisfies N = r³.","use vstd::prelude::*;

verus! {

spec fn cube(n: int) -> int {
    n * n * n
}",,"fn is_cube(n: u8) -> (r: bool)
    ensures r == exists|k: int| 0 <= k <= n as int && n as int == cube(k)","{
    assume(false);
    false
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0080,verus,humaneval,humaneval_078,,"This task involves counting hexadecimal digits that represent prime numbers in a given hexadecimal string. The prime hexadecimal digits are: 2, 3, 5, 7, B (decimal 11), and D (decimal 13). The implementation should iterate through the string and count occurrences of these specific characters.","use vstd::prelude::*;

verus! {

spec fn is_hex_char(c: char) -> bool {
    '0' <= c <= '9' || 'A' <= c <= 'F'
}

spec fn is_valid_hex_string(s: Seq<char>) -> bool {
    forall|i: int| #![auto] 0 <= i < s.len() ==> is_hex_char(s[i])
}

spec fn is_prime_hex_digit(c: char) -> bool {
    c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D'
}

spec fn count_prime_hex_digits(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0int
    } else {
        (if is_prime_hex_digit(s[0]) { 1int } else { 0int }) + count_prime_hex_digits(s.subrange(1, s.len() as int))
    }
}",,"fn hex_key(num: &str) -> (count: usize)
    requires
        is_valid_hex_string(num@),
    ensures
        count as int >= 0,
        count as int <= num@.len(),
        count as int == count_prime_hex_digits(num@),","{
    assume(false);
    0
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0081,verus,humaneval,humaneval_079_decimal_to_binary,,"function_signature: fn decimal_to_binary(decimal: nat) -> Seq<char>

You will be given a number in decimal form and your task is to convert it to binary
format. The function should return a sequence, with each character representing a
binary number. Each character in the sequence will be '0' or '1'.","use vstd::prelude::*;

verus! {

spec fn is_binary_string(s: Seq<char>) -> bool {
  s.len() > 0 && (s.len() > 1 ==> s[0] != '0') &&
  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')
}

spec fn decimal_to_binary_helper(n: nat) -> Seq<char>
  decreases n
{
  if n == 0 {
    seq!['0']
  } else if n == 1 {
    seq!['1']
  } else {
    decimal_to_binary_helper(n / 2).add(decimal_to_binary_helper(n % 2))
  }
}

spec fn binary_to_decimal(s: Seq<char>) -> nat
  decreases s.len()
{
  if s.len() <= 0 {
    0
  } else if s.len() == 1 {
    if s[0] == '0' { 0 } else { 1 }
  } else {
    binary_to_decimal(s.take((s.len() - 1) as int)) * 2 + 
    binary_to_decimal(s.skip((s.len() - 1) as int))
  }
}",,"fn decimal_to_binary(n: u8) -> (s: Vec<char>)
  ensures
    is_binary_string(s@),
    binary_to_decimal(s@) == n as nat,","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0082,verus,humaneval,humaneval_080,,"This task involves determining if a string is ""happy"". A string is
considered happy if it has a length of at least 3 characters and in every substring
of 3 consecutive characters, all characters are distinct (no duplicates). The implementation
should efficiently check this condition and return the appropriate boolean result.","use vstd::prelude::*;

verus! {

spec fn valid_length(s: Seq<char>) -> bool {
    s.len() >= 3
}

spec fn all_windows_distinct(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i <= s.len() - 3 ==> #[trigger] s[i] != s[i+1] && s[i] != s[i+2] && s[i+1] != s[i+2]
}

spec fn is_happy_spec(s: Seq<char>) -> bool {
    valid_length(s) && all_windows_distinct(s)
}",,"fn is_happy(s: Vec<char>) -> (result: bool)
    ensures result == is_happy_spec(s@)","{
    // impl-start
    assume(false);
    false
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0083,verus,humaneval,humaneval_081,,"Convert a list of numerical GPA values to corresponding letter grades
using a specified grading scale. The grading scale maps GPA ranges to letter grades
from A+ (4.0) down to E (0.0).","use vstd::prelude::*;

verus! {

spec fn get_letter_grade(gpa: int) -> Seq<char> {
    if gpa == 40 { seq!['A', '+'] }
    else if gpa > 37 { seq!['A'] }
    else if gpa > 33 { seq!['A', '-'] }
    else if gpa > 30 { seq!['B', '+'] }
    else if gpa > 27 { seq!['B'] }
    else if gpa > 23 { seq!['B', '-'] }
    else if gpa > 20 { seq!['C', '+'] }
    else if gpa > 17 { seq!['C'] }
    else if gpa > 13 { seq!['C', '-'] }
    else if gpa > 10 { seq!['D', '+'] }
    else if gpa > 7 { seq!['D'] }
    else if gpa > 0 { seq!['D', '-'] }
    else { seq!['E'] }
}

spec fn valid_letter_grades(grades: Seq<String>) -> bool {
    forall|i: int| 0 <= i < grades.len() ==> {
        let grade = #[trigger] grades[i]@;
        grade == seq!['A', '+'] || grade == seq!['A'] || grade == seq!['A', '-'] ||
        grade == seq!['B', '+'] || grade == seq!['B'] || grade == seq!['B', '-'] ||
        grade == seq!['C', '+'] || grade == seq!['C'] || grade == seq!['C', '-'] ||
        grade == seq!['D', '+'] || grade == seq!['D'] || grade == seq!['D', '-'] ||
        grade == seq!['E']
    }
}",,"fn numerical_letter_grade(grades: Vec<i8>) -> (letter_grades: Vec<String>)
    ensures 
        letter_grades.len() == grades.len() &&
        (forall|i: int| 0 <= i < grades.len() ==> 
            #[trigger] letter_grades[i]@ == get_letter_grade(grades[i] as int)) &&
        valid_letter_grades(letter_grades@)","{
    assume(false);
    Vec::new()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0084,verus,humaneval,humaneval_082,,"This task verifies a function that determines whether a string's length
is a prime number. A prime number is defined as an integer greater than or equal
to 2 that has no divisors other than 1 and itself.","use vstd::prelude::*;

verus! {

spec fn is_prime_number(n: int) -> bool {
    n >= 2 && (forall|k: int| 2 <= k < n ==> #[trigger] (n % k) != 0)
}","proof fn is_prime(n: usize) -> (result: bool)
    requires n < usize::MAX,
    ensures result <==> is_prime_number(n as int)
{
    assume(false);
    true
}","fn prime_length(s: Vec<char>) -> (result: bool)
    ensures result <==> is_prime_number(s@.len() as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0085,verus,humaneval,humaneval_083,,"Count n-digit positive integers that start with 1 OR end with 1 using
inclusion-exclusion principle. The task requires implementing a function that uses
the inclusion-exclusion principle to count numbers that either start with 1, end
with 1, or both, avoiding double-counting those that satisfy both conditions.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int) -> bool {
  n >= 1
}

spec fn power(base: int, exp: int) -> int
  decreases exp when exp >= 0
{
  if exp <= 0 { 1 } else { base * power(base, exp - 1) }
}

spec fn count_starts_with_1(n: int) -> int {
  power(10, n - 1)
}

spec fn count_ends_with_1(n: int) -> int {
  if n == 1 { 1 } else { 9 * power(10, n - 2) }
}

spec fn count_starts_and_ends_with_1(n: int) -> int {
  if n <= 2 { 1 } else { power(10, n - 2) }
}",,"fn starts_one_ends(n: i8) -> (result: i8)
  requires 
    valid_input(n as int)
  ensures 
    result as int == count_starts_with_1(n as int) + count_ends_with_1(n as int) - count_starts_and_ends_with_1(n as int),
    result >= 0","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0086,verus,humaneval,humaneval_084_solve,,"function_signature: def solve(n: int) -> str

Given a positive integer N, return the total sum of its digits in binary.","use vstd::prelude::*;

verus! {

spec fn popcount(n: nat) -> nat
    decreases n
{
    if n == 0 { 0 } else { (n % 2) + popcount(n / 2) }
}",,"fn solve(n: u8) -> (r: u8)
    ensures r as nat == popcount(n as nat)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0087,verus,humaneval,humaneval_085_add,,"function_signature: def solve(n: list[int]) -> int

Given a non-empty list of integers lst, add the even elements that are at odd indices.","use vstd::prelude::*;

verus! {

spec fn sumc(s: Seq<int>, p: Seq<bool>) -> int
    recommends s.len() == p.len()
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else {
        (if p[0] { s[0] } else { 0 }) + sumc(s.subrange(1, s.len() as int), p.subrange(1, p.len() as int))
    }
}

spec fn add_condition(lst: Seq<int>) -> Seq<bool> {
    Seq::new(lst.len(), |i: int| i % 2 == 1 && lst[i] % 2 == 0)
}",,"fn add(v: Vec<i8>) -> (r: i8)
    ensures r == sumc(v@.map_values(|x: i8| x as int), add_condition(v@.map_values(|x: i8| x as int)))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0088,verus,humaneval,humaneval_087_get_row__SortSeq,,"function_signature: fn sort_seq(s: SortSeqState) -> (sorted: SortSeqState)

Sort elements. Ensures: the result is sorted according to the ordering relation;
returns the correct size/count; returns a sorted permutation of the input.","use vstd::prelude::*;

verus! {

type SortSeqState = Seq<(int, int)>;

spec fn less(a: (int, int), b: (int, int)) -> bool {
    let (x, y) = a;
    let (u, v) = b;
    x < u || (x == u && y > v)
}

spec fn less_eq(a: (int, int), b: (int, int)) -> bool {
    let (x, y) = a;
    let (u, v) = b;
    (x == u && y == v) || less(a, b)
}",,"fn sort_seq(s: Vec<(i8, i8)>) -> (sorted: Vec<(i8, i8)>)
    ensures 
        forall|i: int, j: int| 0 <= i < j < sorted@.len() ==> less_eq((sorted[i].0 as int, sorted[i].1 as int), (sorted[j].0 as int, sorted[j].1 as int)),
        sorted@.len() == s@.len(),
        s@.map(|i: int, x: (i8, i8)| (x.0 as int, x.1 as int)).to_multiset() == sorted@.map(|i: int, x: (i8, i8)| (x.0 as int, x.1 as int)).to_multiset()","{
    assume(false);
    s
}","
}

fn main() {}",0,,-1,-1,-1,DupVH00,0.85
VH0089,verus,humaneval,humaneval_087_get_row__get_row,,"function_signature: fn get_row(lst: &Seq<Seq<int>>, x: int) -> (pos: SortSeqState)

Retrieve elements. Ensures: the condition holds for all values; the condition holds for all values; the condition holds for all values.","use vstd::prelude::*;

verus! {

type SortSeqState = Seq<(int, int)>;

spec fn less(a: (int, int), b: (int, int)) -> bool {
    let (x, y) = a;
    let (u, v) = b;
    x < u || (x == u && y > v)
}

spec fn less_eq(a: (int, int), b: (int, int)) -> bool {
    let (x, y) = a;
    let (u, v) = b;
    (x == u && y == v) || less(a, b)
}",,"fn get_row(lst: &Vec<Vec<i8>>, x: i8) -> (pos: SortSeqState)
    ensures 
        (forall|i: int| 0 <= i < pos.len() ==> #[trigger] pos[i].0 >= 0 && #[trigger] pos[i].1 >= 0 && {
            let (a, b) = pos[i];
            0 <= a < lst@.len() && 0 <= b < lst@[a].len() && lst@[a][b] as int == x as int
        }) &&
        (forall|i: int, j: int| 0 <= i < lst@.len() && 0 <= j < lst@[i].len() && lst@[i][j] as int == x as int ==> #[trigger] pos.contains((i, j))) &&
        (forall|i: int, j: int| 0 <= i < j < pos.len() ==> #[trigger] less_eq(pos[i], pos[j]))","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0090,verus,humaneval,humaneval_088,,"This verification task implements a conditional sorting algorithm
for arrays of non-negative integers. The sorting order is determined by the sum
of the first and last elements: if the sum is odd, the array is sorted in ascending
order; if the sum is even, it's sorted in descending order. The implementation
must return a sorted copy without modifying the original array and preserve all
elements (multiset equality).","use vstd::prelude::*;

verus! {

spec fn valid_input(arr: Seq<int>) -> bool {
    forall|i: int| 0 <= i < arr.len() ==> arr[i] >= 0
}

spec fn is_ascending_sorted(s: Seq<int>) -> bool {
    forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] <= s[j]
}

spec fn is_descending_sorted(s: Seq<int>) -> bool {
    forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] >= s[j]
}

spec fn should_sort_ascending(arr: Seq<int>) -> bool {
    arr.len() > 1 && (arr[0] + arr[arr.len() - 1]) % 2 == 1
}

spec fn should_sort_descending(arr: Seq<int>) -> bool {
    arr.len() > 1 && (arr[0] + arr[arr.len() - 1]) % 2 == 0
}

spec fn correctly_sorted(arr: Seq<int>, result: Seq<int>) -> bool {
    (arr.len() <= 1 ==> result == arr) &&
    (should_sort_ascending(arr) ==> is_ascending_sorted(result)) &&
    (should_sort_descending(arr) ==> is_descending_sorted(result))
}

fn sort_ascending(arr: Seq<int>) -> (result: Seq<int>)
    ensures
        result.to_multiset() == arr.to_multiset(),
        is_ascending_sorted(result)
{
    assume(false);
    unreached()
}


fn sort_descending(arr: Seq<int>) -> (result: Seq<int>)
    ensures
        result.to_multiset() == arr.to_multiset(),
        is_descending_sorted(result)
{
    assume(false);
    unreached()
}",,"fn sort_array(arr: Vec<i8>) -> (result: Vec<i8>)
    requires valid_input(arr@.map(|i: int, x: i8| x as int))
    ensures 
        result@.map(|i: int, x: i8| x as int).to_multiset() == arr@.map(|i: int, x: i8| x as int).to_multiset(),
        correctly_sorted(arr@.map(|i: int, x: i8| x as int), result@.map(|i: int, x: i8| x as int))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0091,verus,humaneval,humaneval_089,,This verification task implements a string encryption algorithm that shifts each alphabetic character forward by 4 positions in the alphabet with wraparound. The implementation should preserve the case of letters and leave non-alphabetic characters unchanged.,"use vstd::prelude::*;

verus! {

spec fn encrypt_char(c: char) -> char {
    if 'a' <= c && c <= 'z' {
        (((c as int - 'a' as int + 4) % 26) + 'a' as int) as char
    } else if 'A' <= c && c <= 'Z' {
        (((c as int - 'A' as int + 4) % 26) + 'A' as int) as char
    } else {
        c
    }
}",,"fn encrypt(s: Vec<char>) -> (result: Vec<char>)
    requires s@.len() >= 0
    ensures result@.len() == s@.len(),
            forall|i: int| 0 <= i < s@.len() ==> #[trigger] result@[i] == #[trigger] encrypt_char(#[trigger] s@[i])","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0092,verus,humaneval,humaneval_090_next_smallest,,"function_signature: def next_smallest(lst: List[int]) -> Optional[int]

You are given a list of integers. Write a function next_smallest() that returns
the 2nd smallest element of the list. Return None if there is no such element. TODO(George):
Remove this when being reviewed The spec is defined as: if result is none there
is no second smallest element, which exists in a finite list iff there are at least
two distinct elements in the list. If result is some x, then x is the second smallest
element of the list, the spec obtains the sublist of elements smaller than the result,
and checks that this sublist does not contain two distinct elements (they are all
the same).","use vstd::prelude::*;

verus! {

spec fn get_val(mx: Option<int>) -> int
    recommends matches!(mx, Some(_))
{
    match mx {
        Some(n) => n,
        None => 0
    }
}",,"fn rolling_max(s: &Vec<i8>) -> (res: Option<i8>)
    ensures 
        matches!(res, None) <==> s@.len() < 2,
        matches!(res, Some(_)) ==> exists|x: int| 0 <= x < s@.len() && s@[x] as int == get_val(match res { Some(v) => Some(v as int), None => None }),
        forall|x: int, y: int| 0 <= x < y < s@.len() ==> s@[x] as int <= get_val(match res { Some(v) => Some(v as int), None => None }) || s@[y] as int <= get_val(match res { Some(v) => Some(v as int), None => None }),","{
    assume(false);
    None
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0094,verus,humaneval,humaneval_092,,"This verification task involves implementing a function that checks if three real numbers satisfy two conditions: all three must be integers, and one of the numbers must equal the sum of the other two. The function should return true only if both conditions are met, false otherwise.","use vstd::prelude::*;

verus! {

spec fn is_integer(x: int) -> bool {
    true
}

spec fn all_integers(x: int, y: int, z: int) -> bool {
    is_integer(x) && is_integer(y) && is_integer(z)
}

spec fn one_equals_sum_of_other_two(x: int, y: int, z: int) -> bool {
    x == y + z || y == x + z || z == x + y
}

spec fn valid_result(x: int, y: int, z: int, result: bool) -> bool {
    result <==> (all_integers(x, y, z) && one_equals_sum_of_other_two(x, y, z))
}

// </vc-preamble>",,"fn any_int(x: i8, y: i8, z: i8) -> (result: bool)
    ensures valid_result(x as int, y as int, z as int, result)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,0.7
VH0095,verus,humaneval,humaneval_093,,"Implement a message encoding algorithm that applies two transformations
to each character: first replace vowels with letters appearing 2 positions later
in the alphabet, then swap the case of all letters. Spaces are preserved unchanged,
and the input contains only letters and spaces.","use vstd::prelude::*;

verus! {

spec fn is_vowel(c: char) -> bool {
    c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||
    c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U'
}

spec fn get_vowel_replacement(c: char) -> char
    recommends is_vowel(c)
{
    if c == 'a' { 'c' }
    else if c == 'e' { 'g' }
    else if c == 'i' { 'k' }
    else if c == 'o' { 'q' }
    else if c == 'u' { 'w' }
    else if c == 'A' { 'C' }
    else if c == 'E' { 'G' }
    else if c == 'I' { 'K' }
    else if c == 'O' { 'Q' }
    else if c == 'U' { 'W' }
    else { c }
}

spec fn swap_case(c: char) -> char {
    if 'a' <= c && c <= 'z' {
        ((c as u8 - 'a' as u8 + 'A' as u8) as char)
    } else if 'A' <= c && c <= 'Z' {
        ((c as u8 - 'A' as u8 + 'a' as u8) as char)
    } else {
        c
    }
}",,"fn encode(message: Vec<char>) -> (result: Vec<char>)
    requires forall|i: int| 0 <= i < message@.len() ==> 
        (('a' <= message@[i] && message@[i] <= 'z') || 
         ('A' <= message@[i] && message@[i] <= 'Z') || 
         message@[i] == ' ')
    ensures result@.len() == message@.len(),
            forall|i: int| 0 <= i < message@.len() ==> 
                if #[trigger] message@[i] == ' ' {
                    #[trigger] result@[i] == ' '
                } else if is_vowel(#[trigger] message@[i]) {
                    result@[i] == swap_case(#[trigger] get_vowel_replacement(#[trigger] message@[i]))
                } else {
                    #[trigger] result@[i] == swap_case(#[trigger] message@[i])
                }","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0097,verus,humaneval,humaneval_095_check_dict_case,,"function_signature: def check_dict_case(s : dict[str, str]) -> bool

Given a dictionary, return True if all keys are strings in lower case or all keys
are strings in upper case, else return False. The function should return False is
the given dictionary is empty. Note(George): Modified the problem to use strings
only for both keys and values.","use vstd::prelude::*;

verus! {

spec fn is_lower_case(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> ('a' <= #[trigger] s[i] <= 'z')
}

spec fn is_upper_case(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> ('A' <= #[trigger] s[i] <= 'Z')
}

type DictCase = Map<Seq<char>, Seq<char>>;",,"fn check_dict_case(dict: Map<Vec<char>, Vec<char>>) -> (result: bool)
    ensures
        (dict.len() == 0) ==> !result,
        result ==> ((forall|k: Vec<char>| #[trigger] dict.contains_key(k) ==> is_lower_case(k@)) || (forall|k: Vec<char>| #[trigger] dict.contains_key(k) ==> is_upper_case(k@))),
        !result ==> ((dict.len() == 0) || ((exists|k: Vec<char>| #[trigger] dict.contains_key(k) && !is_lower_case(k@)) && (exists|k: Vec<char>| #[trigger] dict.contains_key(k) && !is_upper_case(k@))))","{
    assume(false);
    false
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0098,verus,humaneval,humaneval_096,,"This verification task involves implementing a function that returns
all prime numbers strictly less than a given non-negative integer n, in ascending
order. The implementation should correctly identify prime numbers using a helper
method and build the result sequence while maintaining the sorted order.","use vstd::prelude::*;

verus! {

spec fn is_prime_number(num: int) -> bool {
    num >= 2 && forall|k: int| 2 <= k < num ==> #[trigger] (num % k) != 0
}",,"fn count_up_to(n: i8) -> (result: Vec<i8>)
    requires n as int >= 0
    ensures 
        forall|i: int| 0 <= i < result.len() ==> is_prime_number(#[trigger] result[i] as int),
        forall|i: int| 0 <= i < result.len() ==> #[trigger] (result[i] as int) < (n as int),
        forall|p: int| 2 <= p < (n as int) && is_prime_number(p) ==> result@.contains(p as i8),
        forall|i: int, j: int| 0 <= i < j < result.len() ==> #[trigger] (result[i] as int) < #[trigger] (result[j] as int)","{
    assume(false);
    Vec::new()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0099,verus,humaneval,humaneval_097,,"This task implements a function to compute the product of the unit
digits of two integers. The unit digit is defined as the ones place digit of the
absolute value of a number. Given two integers (which can be positive, negative,
or zero), the method should return the product of their respective unit digits.","use vstd::prelude::*;

verus! {

spec fn unit_digit(n: int) -> int {
    (if n >= 0 { n } else { -n }) % 10
}

spec fn product_of_unit_digits(a: int, b: int) -> int {
    unit_digit(a) * unit_digit(b)
}

spec fn valid_result(result: int) -> bool {
    result >= 0 && result <= 81
}",,"fn multiply(a: i8, b: i8) -> (result: i8)
    ensures 
        result as int == product_of_unit_digits(a as int, b as int),
        valid_result(result as int),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0100,verus,humaneval,humaneval_098_count_upper,,"function_signature: def count_upper(s : String) -> Int

Given a string s, count the number of uppercase vowels in even indices.","use vstd::prelude::*;

verus! {

spec fn is_upper_vowel(c: char) -> bool {
    c == 'A' || c == 'E' || c == 'U' || c == 'I' || c == 'O'
}",,"fn count_upper(s: Vec<char>) -> (cnt: usize)
    ensures cnt == Set::<int>::new(|i: int| 0 <= i < s@.len() && i % 2 == 0 && is_upper_vowel(s@[i])).len()","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0101,verus,humaneval,humaneval_100,,"This verification task implements a method to create a pile of stones
with n levels. The first level contains n stones, and each subsequent level contains
the next number with the same parity (odd/even) as n. This creates an arithmetic
sequence where each level has 2 more stones than the previous level.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int) -> bool {
    n > 0
}

spec fn valid_pile(pile: Seq<int>, n: int) -> bool {
    &&& pile.len() == n
    &&& (n > 0 ==> pile.len() > 0 && pile[0] == n)
    &&& (forall|i: int| 0 <= i < pile.len() ==> pile[i] == n + 2 * i)
    &&& (forall|i: int| 0 <= i < pile.len() - 1 ==> #[trigger] pile.index(i + 1) == pile.index(i) + 2)
}",,"fn make_a_pile(n: i8) -> (pile: Vec<i8>)
    requires valid_input(n as int)
    ensures valid_pile(pile@.map(|i: int, x: i8| x as int), n as int)","{
    assume(false);
    Vec::new()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0102,verus,humaneval,humaneval_102,,"This task involves implementing a method to find the largest even
integer in a given range [x, y] inclusive, where x and y are positive integers.
If no even integer exists in the range, the method should return -1.","use vstd::prelude::*;

verus! {

spec fn valid_input(x: int, y: int) -> bool {
    x > 0 && y > 0
}

spec fn no_even_in_range(x: int, y: int) -> bool {
    forall|i: int| x <= i <= y ==> #[trigger] (i % 2) != 0
}

spec fn is_largest_even_in_range(x: int, y: int, result: int) -> bool {
    result % 2 == 0 && 
    x <= result <= y && 
    (forall|i: int| x <= i <= y && #[trigger] (i % 2) == 0 ==> i <= result)
}

spec fn correct_result(x: int, y: int, result: int) -> bool {
    if x > y { 
        result == -1
    } else {
        (result == -1 && no_even_in_range(x, y)) ||
        is_largest_even_in_range(x, y, result)
    }
}",,"fn choose_num(x: i8, y: i8) -> (result: i8)
    requires valid_input(x as int, y as int)
    ensures correct_result(x as int, y as int, result as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0103,verus,humaneval,humaneval_103,,"Given two positive integers n and m, compute the average of all integers
in the range [n, m] (inclusive).

Round the result to the nearest integer using banker's rounding (round half to
even) and return the binary representation as a string prefixed with ""0b"". If n
> m, return ""-1"".","use vstd::prelude::*;

verus! {

spec fn int_to_binary(n: nat) -> Seq<char> {
    if n == 0 { seq!['0'] }
    else { int_to_binary_helper(n) }
}

spec fn int_to_binary_helper(n: nat) -> Seq<char>
    decreases n
{
    if n <= 1 { seq!['1'] }
    else { int_to_binary_helper(n / 2) + (if n % 2 == 1 { seq!['1'] } else { seq!['0'] }) }
}",,"fn rounded_avg(n: int, m: int) -> (result: String)
    requires n > 0 && m > 0
    ensures (n > m) ==> (result@ == seq!['-', '1']) &&
            (n <= m) ==> (
        result@.len() >= 3 &&
        result@.subrange(0, 2) == seq!['0', 'b'] &&
        ({
            let count = m - n + 1;
            let total_sum = count * (n + m) / 2;
            let quotient = total_sum / count;
            let remainder = total_sum % count;
            let rounded = if remainder * 2 < count { quotient }
                         else if remainder * 2 > count { quotient + 1 }
                         else if quotient % 2 == 0 { quotient }
                         else { quotient + 1 };
            result@ == seq!['0', 'b'] + int_to_binary(rounded as nat)
        })
    )","{
    assume(false);
    """".to_string()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0104,verus,humaneval,humaneval_104_unique_digits,,"function_signature: def unique_digits(x: List[nat]) -> List[nat]

Given a list of positive integers x. return a sorted list of all elements that hasn't
any even digit.","use vstd::prelude::*;

verus! {

spec fn has_no_even_digit(n: int) -> bool
  decreases n
{
  n >= 0 && ((n < 10 && n % 2 == 1) || (n % 2 == 1 && has_no_even_digit(n / 10)))
}",,"fn unique_digits(x: Vec<u8>) -> (result: Vec<u8>)
  ensures 
    forall|i: int| 0 <= i < result@.len() ==> has_no_even_digit(result@[i] as int) &&
    forall|i: int, j: int| 0 <= i < j < result@.len() ==> result@[i] <= result@[j] &&
    forall|e: u8| x@.contains(e) && has_no_even_digit(e as int) ==> result@.contains(e) &&
    forall|e: u8| result@.contains(e) ==> x@.contains(e)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0105,verus,humaneval,humaneval_105_by_length__SortReverseAndName,,"function_signature: fn sort_reverse_and_name(arr: &Seq<int>) -> (result: Seq<Seq<char>>)
Sort elements. Ensures: the size is bounded; the condition holds for all values.","use vstd::prelude::*;

verus! {","spec fn number_to_name(n: int) -> Seq<char> {
  if 1 <= n <= 9 {
    if n == 1 { seq!['O', 'n', 'e'] }
    else if n == 2 { seq!['T', 'w', 'o'] }
    else if n == 3 { seq!['T', 'h', 'r', 'e', 'e'] }
    else if n == 4 { seq!['F', 'o', 'u', 'r'] }
    else if n == 5 { seq!['F', 'i', 'v', 'e'] }
    else if n == 6 { seq!['S', 'i', 'x'] }
    else if n == 7 { seq!['S', 'e', 'v', 'e', 'n'] }
    else if n == 8 { seq!['E', 'i', 'g', 'h', 't'] }
    else { seq!['N', 'i', 'n', 'e'] }
  } else {
    seq!['I', 'n', 'v', 'a', 'l', 'i', 'd']
  }
}","fn sort_reverse_and_name(arr: &Vec<i8>) -> (result: Vec<Vec<char>>)
  ensures 
    result.len() <= arr.len(),
    forall|i: int| 0 <= i < result@.len() ==> (
      result@[i]@ == seq!['O', 'n', 'e'] || result@[i]@ == seq!['T', 'w', 'o'] || result@[i]@ == seq!['T', 'h', 'r', 'e', 'e'] || 
      result@[i]@ == seq!['F', 'o', 'u', 'r'] || result@[i]@ == seq!['F', 'i', 'v', 'e'] || result@[i]@ == seq!['S', 'i', 'x'] || 
      result@[i]@ == seq!['S', 'e', 'v', 'e', 'n'] || result@[i]@ == seq!['E', 'i', 'g', 'h', 't'] || result@[i]@ == seq!['N', 'i', 'n', 'e']
    )","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0106,verus,humaneval,humaneval_105_by_length__SortSeq,,"function_signature: fn sort_seq(s: Vec<i8>) -> (sorted: Vec<i8>)

Sort elements. Ensures: the result is sorted according to the ordering relation;
returns the correct size/count; returns a sorted permutation of the input.","use vstd::prelude::*;

verus! {

spec fn number_to_name(n: int) -> &'static str {
  if n == 1 { ""One"" }
  else if n == 2 { ""Two"" }
  else if n == 3 { ""Three"" }
  else if n == 4 { ""Four"" }
  else if n == 5 { ""Five"" }
  else if n == 6 { ""Six"" }
  else if n == 7 { ""Seven"" }
  else if n == 8 { ""Eight"" }
  else if n == 9 { ""Nine"" }
  else { ""Unknown"" }
}",,"fn sort_seq(s: Vec<i8>) -> (sorted: Vec<i8>)
  ensures 
    forall|i: int, j: int| 0 <= i < j < sorted.len() ==> sorted[i] as int <= sorted[j] as int &&
    sorted.len() == s.len() &&
    s@.to_multiset() == sorted@.to_multiset()","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVH00,0.85
VH0107,verus,humaneval,humaneval_105_by_length__reverse,,"function_signature: fn reverse(s: Vec<i8>) -> (rev: Vec<i8>)

Reverse order. Ensures: returns the correct size/count; the condition holds for
all values.","use vstd::prelude::*;

verus! {

spec fn number_to_name(n: int) -> &'static str
{
    if n == 1 { ""One"" }
    else if n == 2 { ""Two"" }
    else if n == 3 { ""Three"" }
    else if n == 4 { ""Four"" }
    else if n == 5 { ""Five"" }
    else if n == 6 { ""Six"" }
    else if n == 7 { ""Seven"" }
    else if n == 8 { ""Eight"" }
    else { ""Nine"" }
}",,"fn reverse(s: Vec<i8>) -> (rev: Vec<i8>)
    ensures 
        rev.len() == s.len(),
        forall|k: int| 0 <= k < s.len() ==> rev[k] as int == s@[s.len() - 1 - k] as int","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0108,verus,humaneval,humaneval_106,,"This task requires implementing a method that generates a sequence
of natural numbers based on position-dependent calculations. For each position i
(0-indexed), if (i+1) is even, the element should be the factorial of (i+1); if
(i+1) is odd, the element should be the sum of integers from 1 to (i+1).","use vstd::prelude::*;

verus! {

spec fn factorial(n: nat) -> nat
    decreases n
{
    if n <= 1 { 1 } else { n * factorial((n - 1) as nat) }
}

spec fn sum_range(n: nat) -> nat
    decreases n
{
    if n == 0 { 0 } else { n + sum_range((n - 1) as nat) }
}

spec fn valid_result(n: nat, result: Seq<nat>) -> bool
{
    result.len() == n &&
    forall|i: int| 0 <= i < n ==> 
        (if (i + 1) % 2 == 0 { result[i] == factorial((i + 1) as nat) }
         else { result[i] == sum_range((i + 1) as nat) })
}",,"fn f(n: u8) -> (result: Vec<u8>)
    ensures valid_result(n as nat, result@.map(|i: int, x: u8| x as nat))","{
    assume(false);
    Vec::new()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0109,verus,humaneval,humaneval_107,,"This verification task implements a function to count even and odd
palindromic integers in the range [1, n] inclusive. A palindromic integer reads
the same forwards and backwards (e.g., 121, 7, 1331). The function should return
a tuple (even_count, odd_count) representing the counts of even and odd palindromic
integers respectively.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: nat) -> bool {
    n >= 1
}

spec fn digits_of(n: nat) -> Seq<nat>
    decreases n
{
    if n < 10 {
        seq![n]
    } else {
        digits_of(n / 10).push(n % 10)
    }
}

spec fn reverse_seq<T>(s: Seq<T>) -> Seq<T>
    decreases s.len()
{
    if s.len() <= 1 {
        s
    } else {
        reverse_seq(s.subrange(1, s.len() as int)).push(s[0])
    }
}

spec fn is_palindrome(n: nat) -> bool {
    let digits = digits_of(n);
    digits == reverse_seq(digits)
}

spec fn count_palindromes_in_range(start: nat, end: nat) -> nat
    decreases end - start + 1
{
    if start > end {
        0
    } else if is_palindrome(start) {
        1 + count_palindromes_in_range(start + 1, end)
    } else {
        count_palindromes_in_range(start + 1, end)
    }
}

spec fn count_even_palindromes_in_range(start: nat, end: nat) -> nat
    decreases end - start + 1
{
    if start > end {
        0
    } else if is_palindrome(start) && start % 2 == 0 {
        1 + count_even_palindromes_in_range(start + 1, end)
    } else {
        count_even_palindromes_in_range(start + 1, end)
    }
}

spec fn count_odd_palindromes_in_range(start: nat, end: nat) -> nat
    decreases end - start + 1
{
    if start > end {
        0
    } else if is_palindrome(start) && start % 2 == 1 {
        1 + count_odd_palindromes_in_range(start + 1, end)
    } else {
        count_odd_palindromes_in_range(start + 1, end)
    }
}

spec fn count_palindromes_helper(n: nat, current: nat, even_count: nat, odd_count: nat) -> (nat, nat)
    decreases n - current + 1
{
    if current > n {
        (even_count, odd_count)
    } else if is_palindrome(current) {
        if current % 2 == 0 {
            count_palindromes_helper(n, current + 1, even_count + 1, odd_count)
        } else {
            count_palindromes_helper(n, current + 1, even_count, odd_count + 1)
        }
    } else {
        count_palindromes_helper(n, current + 1, even_count, odd_count)
    }
}

// </vc-preamble>",,"fn even_odd_palindrome(n: u32) -> (result: (u32, u32))
    requires 
        n >= 1
    ensures 
        result.0 >= 0,
        result.1 >= 0,
        result.0 == count_even_palindromes_in_range(1, n as nat),
        result.1 == count_odd_palindromes_in_range(1, n as nat),
        result.0 + result.1 == count_palindromes_in_range(1, n as nat),","{
    // impl-start
    assume(false);
    (0, 0)
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0110,verus,humaneval,humaneval_108,,"Given an array of integers, count how many elements have a positive sum of digits. For digit sum calculation: positive numbers sum all digits normally, negative numbers have the first digit as negative and remaining digits as positive, and zero has digit sum 0. Return the count of numbers whose digit sum is greater than 0.","use vstd::prelude::*;

verus! {

spec fn digit_sum_func(n: int) -> int {
    if n == 0 {
        0
    } else if n > 0 {
        sum_of_digits_pos(n as nat) as int
    } else {
        sum_of_digits_pos((-n) as nat) as int - 2 * first_digit((-n) as nat) as int
    }
}

spec fn sum_of_digits_pos(n: nat) -> nat
    recommends n >= 0
    decreases n
{
    if n == 0 {
        0
    } else {
        (n % 10) + sum_of_digits_pos(n / 10)
    }
}

spec fn first_digit(n: nat) -> nat
    recommends n > 0
    decreases n
{
    if n < 10 {
        n
    } else {
        first_digit(n / 10)
    }
}

spec fn valid_input(arr: Seq<i32>) -> bool {
    true
}

spec fn valid_output(arr: Seq<i32>, count: int) -> bool {
    0 <= count <= arr.len()
}",,"fn count_nums(arr: &Vec<i32>) -> (count: usize)
    requires valid_input(arr@)
    ensures valid_output(arr@, count as int)","{
    assume(false);
    0
}","
}

fn main() {}",0,,-1,-1,-1,,0.7
VH0111,verus,humaneval,humaneval_109,,"Given an array of unique integers, determine if it's possible to sort
the array in non-decreasing order using only right shift operations. A right shift
moves all elements one position to the right, with the last element moving to the
first. The method should return True if the array is sortable via rotations, False
otherwise, with empty arrays returning True.","use vstd::prelude::*;

verus! {

spec fn is_sorted(s: Seq<int>) -> bool {
    forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] <= s[j]
}

spec fn rotate_right(arr: Seq<int>, k: int) -> Seq<int>
    recommends 0 <= k <= arr.len()
{
    if arr.len() == 0 {
        arr
    } else if k == 0 {
        arr
    } else {
        arr.subrange((arr.len() - k) as int, arr.len() as int) + arr.subrange(0, (arr.len() - k) as int)
    }
}",,"fn move_one_ball(arr: Vec<i8>) -> (result: bool)
    requires 
        forall|i: int, j: int| 0 <= i < j < arr.len() ==> arr[i as int] != arr[j as int]
    ensures 
        arr.len() == 0 ==> result == true,
        result == true ==> (arr.len() == 0 || exists|k: int| #[trigger] is_sorted(rotate_right(arr@.map(|i, x: i8| x as int), k)) && 0 <= k < arr.len()),
        result == false ==> forall|k: int| 0 <= k < arr.len() ==> !is_sorted(rotate_right(arr@.map(|i, x: i8| x as int), k))","{
    assume(false);
    false
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0112,verus,humaneval,humaneval_110,,"This task involves determining if it's possible to exchange elements
between two non-empty lists of integers such that the first list contains only even
numbers. The method should return ""YES"" if such an exchange is possible, ""NO"" otherwise.


The key insight is that we need at least as many even numbers across both lists
as the length of the first list to make the first list contain only even numbers.","use vstd::prelude::*;

verus! {

spec fn count_even(lst: Seq<int>) -> int
    decreases lst.len()
{
    if lst.len() == 0 {
        0
    } else {
        if lst[0] % 2 == 0 {
            1 + count_even(lst.skip(1))
        } else {
            count_even(lst.skip(1))
        }
    }
}

spec fn valid_input(lst1: Seq<int>, lst2: Seq<int>) -> bool {
    lst1.len() > 0 && lst2.len() > 0
}

spec fn can_exchange(lst1: Seq<int>, lst2: Seq<int>) -> bool {
    count_even(lst1) + count_even(lst2) >= lst1.len()
}",,"fn exchange(lst1: Vec<i8>, lst2: Vec<i8>) -> (result: String)
    requires 
        valid_input(lst1.view().map(|_i, x| x as int), lst2.view().map(|_i, x| x as int)),
    ensures 
        result@ == seq!['Y', 'E', 'S'] || result@ == seq!['N', 'O'],
        (result@ == seq!['Y', 'E', 'S']) == can_exchange(lst1.view().map(|_i, x| x as int), lst2.view().map(|_i, x| x as int)),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0113,verus,humaneval,humaneval_111_histogram,,"function_signature: def histogram(s : str) -> Dict[str, int]

Given a string representing a space separated lowercase letters, return a dictionary
of the letter with the most repetition and containing the corresponding count. If
several letters have the same occurrence, return all of them.","use vstd::prelude::*;

verus! {

type BiggestMap = Map<int, int>;",,"fn count(a: Vec<i8>) -> (biggest: BiggestMap)
  ensures forall|i: int| 0 <= i < a@.len() && biggest.dom().contains(a@[i] as int) ==>
    #[trigger] biggest[a@[i] as int] == Set::new(|j: int| 0 <= j < a@.len() && a@[j] as int == a@[i] as int).len()","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0114,verus,humaneval,humaneval_112,,"This task implements a string filtering and palindrome checking function.
Given two strings s and c, it removes all characters from string s that appear anywhere
in string c, then determines if the resulting string is a palindrome (reads the
same forwards and backwards). The method returns a tuple containing the filtered
string and a boolean indicating whether it's a palindrome.","use vstd::prelude::*;

verus! {

spec fn filter_chars(s: Seq<char>, c: Seq<char>) -> Seq<char>
    decreases s.len()
{
    if s.len() == 0 {
        Seq::empty()
    } else if c.contains(s[0]) {
        filter_chars(s.subrange(1, s.len() as int), c)
    } else {
        seq![s[0]].add(filter_chars(s.subrange(1, s.len() as int), c))
    }
}

spec fn reverse_seq(s: Seq<char>) -> Seq<char>
    decreases s.len()
{
    if s.len() == 0 {
        Seq::empty()
    } else {
        reverse_seq(s.subrange(1, s.len() as int)).add(seq![s[0]])
    }
}",,"fn reverse_delete(s: Vec<char>, c: Vec<char>) -> (result: (Vec<char>, bool))
    ensures
        result.0@ == filter_chars(s@, c@),
        result.1 == (result.0@ == reverse_seq(result.0@)),
        result.0@.len() <= s@.len(),
        forall|i: int| #![auto] 0 <= i < result.0@.len() ==> !c@.contains(result.0@[i]),
        forall|i: int| #![auto] 0 <= i < result.0@.len() ==> s@.contains(result.0@[i]),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0115,verus,humaneval,humaneval_113,,"Given a list of strings containing only digits, count the odd digits (1,3,5,7,9) in each string and return formatted messages where the count is embedded in a template message. The task involves string processing, digit counting, and message formatting with proper verification of loop invariants and postconditions.","use vstd::prelude::*;

verus! {

spec fn is_all_digits(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> ('0' <= s[i] && s[i] <= '9')
}

spec fn count_odd_digits(s: Seq<char>) -> int
    recommends is_all_digits(s)
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else {
        let digit = s[0] as int - '0' as int;
        let is_odd: int = if digit % 2 == 1 { 1 } else { 0 };
        is_odd + count_odd_digits(s.subrange(1, s.len() as int))
    }
}

spec fn int_to_string_func(n: int) -> Seq<char>
    recommends n >= 0
{
    if n == 0 {
        Seq::new(1, |i: int| '0')
    } else {
        int_to_string_rec(n, Seq::empty())
    }
}

spec fn format_message(count: int) -> Seq<char>
    recommends count >= 0
{
    let count_str = int_to_string_func(count);
    Seq::new(25, |i: int| 't').add(count_str).add(Seq::new(10, |i: int| 'n')).add(count_str).add(Seq::new(3, |i: int| 'g')).add(count_str).add(Seq::new(8, |i: int| ' ')).add(count_str).add(Seq::new(5, |i: int| 'n'))
}

spec fn int_to_string_rec(n: int, acc: Seq<char>) -> Seq<char>
    recommends n >= 0
    decreases n
    when n > 0
{
    if n == 0 {
        acc
    } else {
        let digit = n % 10;
        let digit_char = ('0' as int + digit) as char;
        int_to_string_rec(n / 10, Seq::new(1, |i: int| digit_char).add(acc))
    }
}

fn int_to_string(n: u32) -> (s: Vec<char>)
    requires n >= 0
{
    assume(false);
    vec!['0']
}",,"fn odd_count(lst: Vec<Vec<char>>) -> (result: Vec<Vec<char>>)
    requires forall|i: int| #![auto] 0 <= i < lst.len() ==> is_all_digits(lst[i as int]@),
    ensures 
        result.len() == lst.len(),
        forall|i: int| #![auto] 0 <= i < result.len() ==> result[i as int]@ == format_message(count_odd_digits(lst[i as int]@))","{
    assume(false);
    vec![]
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0116,verus,humaneval,humaneval_114_minSubArraySum,,"function_signature: def minSubArraySum(nums : list[int]) -> int

Given an array of integers nums, find the minimum sum of any non-empty sub-array
of nums.","use vstd::prelude::*;

verus! {

spec fn sum(a: Seq<int>, s: int, t: int) -> int
  decreases t - s
{
  if 0 <= s <= t <= a.len() {
    if s == t {
      0
    } else {
      sum(a, s, t - 1) + a[t - 1]
    }
  } else {
    0
  }
}",,"fn min_sub_array_sum(a: Vec<int>) -> (s: int)
  ensures 
    forall|p: int, q: int| 0 <= p <= q <= a@.len() ==> sum(a@, p, q) >= s as int,
    exists|k: int, m: int| 0 <= k <= m <= a@.len() && s as int == sum(a@, k, m)","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0117,verus,humaneval,humaneval_115,,"This verification task involves implementing a solution to determine the minimum number of bucket operations needed to empty all wells in a 2D binary grid. Each row represents a well, each 1 represents a unit of water, and each bucket has a fixed capacity. The implementation must correctly calculate the total number of bucket trips required across all wells.","use vstd::prelude::*;

verus! {

spec fn valid_input(grid: Seq<Seq<int>>, capacity: int) -> bool {
    capacity > 0
}

spec fn sum_water(well: Seq<int>) -> int
    decreases well.len()
{
    if well.len() == 0 {
        0
    } else {
        well[0] + sum_water(well.subrange(1, well.len() as int))
    }
}

spec fn trips_for_well(well: Seq<int>, capacity: int) -> int {
    let water_units = sum_water(well);
    if water_units == 0 {
        0
    } else {
        (water_units + capacity - 1) / capacity
    }
}

spec fn sum_of_trips(grid: Seq<Seq<int>>, capacity: int) -> int
    decreases grid.len()
{
    if grid.len() == 0 {
        0
    } else {
        trips_for_well(grid[0], capacity) + sum_of_trips(grid.subrange(1, grid.len() as int), capacity)
    }
}


// </vc-preamble>",,"fn max_fill(grid: Vec<Vec<i8>>, capacity: i8) -> (result: i8)
    requires valid_input(grid@.map(|i, row: Vec<i8>| row@.map(|j, x: i8| x as int)), capacity as int)
    ensures 
        result >= 0,
        result as int == sum_of_trips(grid@.map(|i, row: Vec<i8>| row@.map(|j, x: i8| x as int)), capacity as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0118,verus,humaneval,humaneval_116_sort_array,,"function_signature: def max_fill_count(grid : list[list[int]], capacity : int) -> int

Please write a function that sorts an array of non-negative integers according to
number of ones in their binary representation in ascending order. For similar number
of ones, sort based on decimal value.","use vstd::prelude::*;

verus! {

spec fn popcount(n: nat) -> nat
    decreases n
{
    if n == 0 { 0 } else { popcount(n / 2) + n % 2 }
}",,"fn sort_array(s: Vec<u8>) -> (sorted: Vec<u8>)
    ensures 
        forall|i: int, j: int| 0 <= i < j < sorted@.len() ==> popcount(sorted@[i] as nat) <= popcount(sorted@[j] as nat)
            && sorted@.len() == s@.len()
            && s@.to_multiset() == sorted@.to_multiset()","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0119,verus,humaneval,humaneval_118_get_closest_vowel,,"function_signature: def get_closest_vowel(s : str) -> str

You are given a word. Your task is to find the closest vowel that stands between
two consonants from the right side of the word (case sensitive).","use vstd::prelude::*;

verus! {

spec fn is_vowel(c: char) -> bool {
    c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||
    c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U'
}

spec fn is_consonant(c: char) -> bool {
    (('A' <= c && c <= 'Z') || ('a' <= c && c <= 'z')) && !is_vowel(c)
}",,"fn get_closest_vowel(word: Vec<char>) -> (result: Vec<char>)
    requires forall|i: int| 0 <= i < word.len() ==> (('A' <= word@[i] && word@[i] <= 'Z') || ('a' <= word@[i] && word@[i] <= 'z'))
    ensures ({
        &&& result.len() <= 1
        &&& (result.len() == 1 ==> is_vowel(result@[0]))
        &&& (result.len() == 1 ==> exists|i: int| 
            1 <= i && i + 1 < word.len()
                && is_vowel(word@[i]) && is_consonant(word@[i - 1]) && is_consonant(word@[i + 1])
                && (forall|j: int| i < j < word.len() - 1 ==> !is_vowel(word@[j]) || !is_consonant(word@[j - 1]) || !is_consonant(word@[j + 1])))
    })","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0120,verus,humaneval,humaneval_119,,"Given a list of exactly two strings containing only '(' and ')' characters,
determine if it's possible to concatenate them in some order to create a balanced
parentheses string. Return 'Yes' if either concatenation order produces a balanced
string, 'No' otherwise.","use vstd::prelude::*;

verus! {

spec fn valid_paren_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> s[i] == '(' || s[i] == ')'
}

spec fn is_balanced_helper(s: Seq<char>, depth: int) -> int
    decreases s.len()
{
    if s.len() == 0 {
        depth
    } else if s[0] == '(' {
        is_balanced_helper(s.subrange(1, s.len() as int), depth + 1)
    } else if s[0] == ')' {
        if depth > 0 {
            is_balanced_helper(s.subrange(1, s.len() as int), depth - 1)
        } else {
            -1
        }
    } else {
        is_balanced_helper(s.subrange(1, s.len() as int), depth)
    }
}

spec fn is_balanced(s: Seq<char>) -> bool {
    is_balanced_helper(s, 0) == 0
}

spec fn valid_input(lst: Seq<Seq<char>>) -> bool {
    lst.len() == 2 && valid_paren_string(lst[0]) && valid_paren_string(lst[1])
}

spec fn yes_string() -> Seq<char> {
    seq!['Y', 'e', 's']
}

spec fn no_string() -> Seq<char> {
    seq!['N', 'o']
}

spec fn correct_output(lst: Seq<Seq<char>>, result: Seq<char>) -> bool {
    (result == yes_string() || result == no_string()) &&
    (result == yes_string() <==> (is_balanced(lst[0].add(lst[1])) || is_balanced(lst[1].add(lst[0]))))
}",,"fn match_parens(lst: Vec<Vec<char>>) -> (result: Vec<char>)
    requires valid_input(seq![lst[0]@, lst[1]@])
    ensures correct_output(seq![lst[0]@, lst[1]@], result@)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0121,verus,humaneval,humaneval_120_maximum__SortSeq,,"function_signature: fn sort_seq(s: &Vec<i8>) -> (sorted: Vec<i8>)

Sort elements. Ensures: the result is sorted according to the ordering relation;
returns the correct size/count; returns a sorted permutation of the input; the result
is sorted according to the ordering relation; the result is sorted according to
the ordering relation; the result is sorted according to the ordering relation;
the result is sorted according to the ordering relation.","use vstd::prelude::*;

verus! {",,"fn sort_seq(s: &Vec<i8>) -> (sorted: Vec<i8>)
    ensures 
        forall|i: int, j: int| 0 <= i < j < sorted@.len() ==> #[trigger] sorted@[i] <= #[trigger] sorted@[j],
        sorted@.len() == s@.len(),
        s@.to_multiset() == sorted@.to_multiset(),
        forall|i: int| 0 <= i < s@.len() ==> exists|j: int| 0 <= j < sorted@.len() && #[trigger] s@[i] == #[trigger] sorted@[j],
        forall|x: i8| #[trigger] s@.contains(x) ==> #[trigger] sorted@.contains(x),
        forall|i: int| 0 <= i < s@.len() ==> exists|j: int| 0 <= j < sorted@.len() && #[trigger] sorted@[i] == #[trigger] s@[j],
        forall|x: i8| #[trigger] sorted@.contains(x) ==> #[trigger] s@.contains(x),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVH00,0.85
VH0122,verus,humaneval,humaneval_120_maximum__maximum,,"function_signature: fn maximum(s: Seq<int>, k: int) -> (result: Seq<int>)

Process input. Requires: the size is bounded; the size is bounded; the condition
holds for all values. Ensures: returns the correct size/count; the condition holds
for all values; the condition holds for all values.","use vstd::prelude::*;

verus! {",,"fn maximum(s: Vec<i8>, k: i8) -> (result: Vec<i8>)
  requires 
      1 <= k as int <= s@.len(),
      1 <= s@.len() <= 1000,
      forall|x: i8| s@.contains(x) ==> -1000 <= x as int <= 1000,
  ensures 
      result@.len() == k as int,
      forall|i: int, j: int| 0 <= i < j < k as int ==> result@[i] as int <= result@[j] as int,
      forall|x: i8| result@.contains(x) ==> s@.contains(x),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVH01,0.85
VH0123,verus,humaneval,humaneval_121,,"This task requires implementing a method that calculates the sum of all odd numbers located at even-indexed positions in a non-empty sequence of integers. The positions are 0-indexed, so we consider positions 0, 2, 4, etc.","use vstd::prelude::*;

verus! {

spec fn sum_odd_at_even_positions(lst: Seq<int>, pos: int) -> int
    decreases if pos < lst.len() { lst.len() - pos } else { 0 }
{
    if pos >= lst.len() {
        0
    } else if lst[pos] % 2 == 1 {
        lst[pos] + sum_odd_at_even_positions(lst, pos + 2)
    } else {
        sum_odd_at_even_positions(lst, pos + 2)
    }
}",,"fn solution(lst: Vec<i8>) -> (result: i8)
    requires lst@.len() > 0
    ensures result as int == sum_odd_at_even_positions(lst@.map(|i: int, x: i8| x as int), 0)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0124,verus,humaneval,humaneval_122,,"This verification task involves computing the sum of all elements
that have at most two digits among the first k elements of an array. An element
has at most two digits if its absolute value is between 0 and 99 (inclusive).","use vstd::prelude::*;

verus! {

spec fn valid_input(arr: Seq<int>, k: int) -> bool {
  1 <= arr.len() <= 100 && 1 <= k <= arr.len()
}

spec fn sum_valid_elements(arr: Seq<int>, k: int) -> int {
  sum_valid_elements_up_to(arr, k)
}

spec fn sum_valid_elements_up_to(arr: Seq<int>, n: int) -> int
  decreases n
{
  if n == 0 {
    0int
  } else if 0 <= n-1 < arr.len() {
    let current = if -99 <= arr[n-1] <= 99 { arr[n-1] } else { 0int };
    sum_valid_elements_up_to(arr, n-1) + current
  } else {
    0int
  }
}",,"fn add_elements(arr: Vec<i8>, k: i8) -> (result: i8)
  requires valid_input(arr@.map(|i: int, x: i8| x as int), k as int)
  ensures result as int == sum_valid_elements(arr@.map(|i: int, x: i8| x as int), k as int)","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0125,verus,humaneval,humaneval_123_get_odd_collatz__get_odd_collatz,,"function_signature: fn get_odd_collatz(n: nat) -> (sorted: Vec<int>)

Retrieve elements. Requires: requires n > 1. Ensures: the result is sorted according
to the ordering relation; the result is sorted according to the ordering relation.","use vstd::prelude::*;

verus! {

spec fn iterate_to_odd(n: nat) -> nat
  decreases n
{
  if n % 2 == 0 && n > 0 {
    if (n / 2) % 2 == 1 { n / 2 } else { iterate_to_odd(n / 2) }
  } else {
    1
  }
}

spec fn next_odd_collatz(n: nat) -> nat {
  if n > 0 {
    if n % 2 == 0 { iterate_to_odd(n) } else { iterate_to_odd(3 * n + 1) }
  } else {
    1
  }
}",,"fn get_odd_collatz(n: u8) -> (sorted: Vec<i8>)
  requires n as nat > 1
  ensures 
      forall|i: int, j: int| 0 <= i < j < sorted@.len() ==> sorted@[i] <= sorted@[j],
      forall|i: int| 0 <= i < sorted@.len() ==> sorted@[i] % 2 == 1,","{
  assume(false);
  Vec::new()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0126,verus,humaneval,humaneval_123_get_odd_collatz__get_odd_collatz_unsorted,,"function_signature: fn get_odd_collatz_unsorted(n: nat) -> (odd_collatz: Vec<nat>)

Sort elements. Requires: requires n > 1. Ensures: the condition holds for all values;
the condition holds for all values.","use vstd::prelude::*;

verus! {

spec fn iterate_to_odd(n: nat) -> nat
  decreases n,
{
  if n % 2 == 0 && n > 0 {
    if (n / 2) % 2 == 1 { n / 2 } else { iterate_to_odd(n / 2) }
  } else {
    1
  }
}

spec fn next_odd_collatz(n: nat) -> nat {
  if n > 0 {
    if n % 2 == 0 { iterate_to_odd(n) } else { iterate_to_odd(3 * n + 1) }
  } else {
    1
  }
}",,"fn get_odd_collatz_unsorted(n: u8) -> (odd_collatz: Vec<u8>)
  requires n as nat > 1,
  ensures 
    forall|i: int| 0 <= i < odd_collatz@.len() ==> #[trigger] odd_collatz@[i] as nat % 2 == 1,
    forall|i: int| 1 <= i < odd_collatz@.len() ==> #[trigger] odd_collatz@[i] as nat == next_odd_collatz(odd_collatz@[i - 1] as nat),","{
  assume(false);
  Vec::new()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0127,verus,humaneval,humaneval_123_get_odd_collatz__next_odd_collatz_iter,,"function_signature: fn next_odd_collatz_iter(n: nat) -> (next: nat)

Process input. Requires: requires n > 0. Ensures: returns the correct value; returns the correct value.","use vstd::prelude::*;

verus! {

spec fn iterate_to_odd(n: nat) -> nat
  decreases n,
{
  if n % 2 == 0 && n > 0 {
    if (n / 2) % 2 == 1 { n / 2 } else { iterate_to_odd(n / 2) }
  } else {
    1
  }
}

spec fn next_odd_collatz(n: nat) -> nat {
  if n > 0 {
    if n % 2 == 0 { iterate_to_odd(n) } else { iterate_to_odd(3 * n + 1) }
  } else {
    1
  }
}",,"fn next_odd_collatz_iter(n: u8) -> (next: u8)
  requires n > 0,
  ensures 
    (next as nat) % 2 == 1,
    next as nat == next_odd_collatz(n as nat),","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0128,verus,humaneval,humaneval_124,,"Implement a function to validate date strings according to specific
formatting and validity rules. The date must be in ""mm-dd-yyyy"" format with exactly
two hyphens as separators, contain only numeric components, have a valid month (1-12),
and have a valid day for the given month (considering different month lengths including
February with 29 days maximum).","use vstd::prelude::*;

verus! {

spec fn valid_date_format(date: Seq<char>) -> bool {
    date.len() > 0 &&
    count_char(date, '-') == 2 && {
        let parts = split_by_hyphen(date);
        parts.len() == 3 &&
        parts[0].len() > 0 && parts[1].len() > 0 && parts[2].len() > 0 &&
        is_numeric(parts[0]) && is_numeric(parts[1]) && is_numeric(parts[2]) && {
            let month = string_to_int(parts[0]);
            let day = string_to_int(parts[1]);
            1 <= month <= 12 &&
            if month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12 {
                1 <= day <= 31
            } else if month == 4 || month == 6 || month == 9 || month == 11 {
                1 <= day <= 30
            } else {
                1 <= day <= 29
            }
        }
    }
}

spec fn count_char(s: Seq<char>, c: char) -> nat 
    decreases s.len()
{
    if s.len() == 0 { 
        0
    } else if s[0] == c { 
        1 + count_char(s.subrange(1, s.len() as int), c)
    } else { 
        count_char(s.subrange(1, s.len() as int), c)
    }
}

spec fn is_digit(c: char) -> bool {
    '0' <= c <= '9'
}

spec fn is_numeric(s: Seq<char>) -> bool {
    s.len() > 0 && (forall|i: int| 0 <= i < s.len() ==> is_digit(s[i]))
}

spec fn char_to_int(c: char) -> int {
    c as int - '0' as int
}

spec fn string_to_int(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 { 
        0
    } else if s.len() == 1 { 
        char_to_int(s[0])
    } else { 
        string_to_int(s.subrange(0, s.len() - 1)) * 10 + char_to_int(s[s.len() - 1])
    }
}

spec fn find_first_hyphen(s: Seq<char>, start: int) -> int
    decreases s.len() - start
{
    if start >= s.len() { 
        s.len() as int
    } else if s[start] == '-' { 
        start
    } else { 
        find_first_hyphen(s, start + 1)
    }
}

spec fn split_by_hyphen(s: Seq<char>) -> Seq<Seq<char>> {
    let first_hyphen = find_first_hyphen(s, 0);
    if first_hyphen >= s.len() { 
        seq![s]
    } else {
        let second_hyphen = find_first_hyphen(s, first_hyphen + 1);
        if second_hyphen >= s.len() { 
            seq![s.subrange(0, first_hyphen), s.subrange(first_hyphen + 1, s.len() as int)]
        } else { 
            seq![s.subrange(0, first_hyphen), s.subrange(first_hyphen + 1, second_hyphen), s.subrange(second_hyphen + 1, s.len() as int)]
        }
    }
}",,"fn valid_date(date: &str) -> (result: bool)
    ensures result == valid_date_format(date@)","{
    assume(false);
    false
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0129,verus,humaneval,humaneval_125,,"This verification task implements a string processing function that applies rules in a specific order. Given a string, it first checks if the string contains whitespace and splits on whitespace if so. If there's no whitespace but the string contains commas, it splits on commas. Otherwise, it counts the lowercase letters that are at odd positions in the alphabet (b, d, f, h, etc.).

The implementation uses a datatype to represent either a sequence of strings (for splitting results) or an integer count, with helper functions for each operation and appropriate specifications ensuring correctness.","use vstd::prelude::*;

verus! {

enum SplitResult {
    StringSeq { words: Seq<Seq<char>> },
    Count { value: int },
}

spec fn contains_space(txt: Seq<char>) -> bool {
    exists|i: int| 0 <= i < txt.len() && txt[i] == ' '
}

spec fn contains_comma(txt: Seq<char>) -> bool {
    exists|i: int| 0 <= i < txt.len() && txt[i] == ','
}","spec fn split_on_whitespace(txt: Seq<char>) -> Seq<Seq<char>>
    decreases txt.len()
{
    if txt.len() == 0 {
        seq![]
    } else {
        split_on_whitespace_helper(txt, 0, seq![], seq![])
    }
}

spec fn split_on_whitespace_helper(txt: Seq<char>, i: int, result: Seq<Seq<char>>, current_word: Seq<char>) -> Seq<Seq<char>>
    decreases txt.len() - i when 0 <= i <= txt.len()
{
    if i >= txt.len() {
        if current_word.len() > 0 {
            result.push(current_word)
        } else {
            result
        }
    } else if txt[i] == ' ' {
        if current_word.len() > 0 {
            split_on_whitespace_helper(txt, i + 1, result.push(current_word), seq![])
        } else {
            split_on_whitespace_helper(txt, i + 1, result, seq![])
        }
    } else {
        split_on_whitespace_helper(txt, i + 1, result, current_word.push(txt[i]))
    }
}

spec fn split_on_comma(txt: Seq<char>) -> Seq<Seq<char>>
    decreases txt.len()
{
    if txt.len() == 0 {
        seq![seq![]]
    } else {
        split_on_comma_helper(txt, 0, seq![], seq![])
    }
}

spec fn split_on_comma_helper(txt: Seq<char>, i: int, result: Seq<Seq<char>>, current_word: Seq<char>) -> Seq<Seq<char>>
    decreases txt.len() - i when 0 <= i <= txt.len()
{
    if i >= txt.len() {
        result.push(current_word)
    } else if txt[i] == ',' {
        split_on_comma_helper(txt, i + 1, result.push(current_word), seq![])
    } else {
        split_on_comma_helper(txt, i + 1, result, current_word.push(txt[i]))
    }
}

spec fn count_odd_position_lowercase(txt: Seq<char>) -> int {
    count_odd_position_lowercase_helper(txt, 0)
}

spec fn count_odd_position_lowercase_helper(txt: Seq<char>, i: int) -> int
    decreases txt.len() - i when 0 <= i <= txt.len()
{
    if i >= txt.len() {
        0
    } else {
        let c = txt[i];
        let count_rest = count_odd_position_lowercase_helper(txt, i + 1);
        if 'a' <= c <= 'z' && (c as int - 'a' as int) % 2 == 1 {
            1 + count_rest
        } else {
            count_rest
        }
    }
}","fn split_words(txt: Vec<char>) -> (result: SplitResult)
    ensures 
        (contains_space(txt@) ==> matches!(result, SplitResult::StringSeq { .. })) &&
        (!contains_space(txt@) && contains_comma(txt@) ==> matches!(result, SplitResult::StringSeq { .. })) &&
        (!contains_space(txt@) && !contains_comma(txt@) ==> matches!(result, SplitResult::Count { .. })) &&
        (contains_space(txt@) ==> result == SplitResult::StringSeq { words: split_on_whitespace(txt@) }) &&
        (!contains_space(txt@) && contains_comma(txt@) ==> 
            result == SplitResult::StringSeq { words: split_on_comma(txt@) }) &&
        (!contains_space(txt@) && !contains_comma(txt@) ==> 
            result == SplitResult::Count { value: count_odd_position_lowercase(txt@) }) &&
        (match result {
            SplitResult::StringSeq { words } => words.len() >= 0,
            SplitResult::Count { value } => value >= 0,
        }) &&
        (contains_space(txt@) ==> match result {
            SplitResult::StringSeq { words } => forall|w: Seq<char>| words.contains(w) ==> w.len() > 0,
            _ => true,
        }) &&
        (!contains_space(txt@) && contains_comma(txt@) ==> match result {
            SplitResult::StringSeq { words } => words.len() > 0,
            _ => true,
        })","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0130,verus,humaneval,humaneval_126,,"This verification task checks if a list of non-negative integers satisfies two conditions: (1) the list is sorted in non-decreasing (ascending) order, and (2) no number appears more than twice in the list. The implementation uses helper functions to check these conditions efficiently and returns true if both are met, false otherwise.","use vstd::prelude::*;

verus! {

spec fn valid_input(lst: Seq<int>) -> bool {
    forall|i: int| 0 <= i < lst.len() ==> lst[i] >= 0
}

spec fn is_sorted_ascending(lst: Seq<int>) -> bool {
    forall|i: int, j: int| 0 <= i < j < lst.len() ==> lst[i] <= lst[j]
}

spec fn no_more_than_two_duplicates(lst: Seq<int>) -> bool {
    forall|i: int| #![auto] 0 <= i < lst.len() ==> count_occurrences(lst, lst[i]) <= 2
}

spec fn valid_list(lst: Seq<int>) -> bool {
    valid_input(lst) && is_sorted_ascending(lst) && no_more_than_two_duplicates(lst)
}
spec fn count_occurrences(lst: Seq<int>, value: int) -> int
    decreases lst.len()
{
    if lst.len() == 0 {
        0
    } else if lst[0] == value {
        1 + count_occurrences(lst.drop_first(), value)
    } else {
        count_occurrences(lst.drop_first(), value)
    }
}

spec fn has_more_than_two_occurrences(lst: Seq<int>, index: int) -> bool
    decreases lst.len() - index when 0 <= index <= lst.len()
{
    if index == lst.len() {
        false
    } else if 0 <= index < lst.len() && count_occurrences(lst, lst[index]) > 2 {
        true
    } else if 0 <= index < lst.len() {
        has_more_than_two_occurrences(lst, index + 1)
    } else {
        false
    }
}

spec fn is_sorted_ascending_from_index(lst: Seq<int>, index: int) -> bool
    decreases lst.len() - index when 0 <= index <= lst.len()
{
    if index >= lst.len() - 1 {
        true
    } else if 0 <= index < lst.len() - 1 && lst[index] > lst[index + 1] {
        false
    } else if 0 <= index < lst.len() {
        is_sorted_ascending_from_index(lst, index + 1)
    } else {
        true
    }
}

spec fn is_sorted(lst: Seq<int>) -> bool {
    if lst.len() <= 1 {
        true
    } else if !is_sorted_ascending_from_index(lst, 0) {
        false
    } else {
        !has_more_than_two_occurrences(lst, 0)
    }
}",,"fn check_valid_list(lst: Vec<i8>) -> (result: bool)
    requires 
        valid_input(lst@.map(|_i: int, x: i8| x as int))
    ensures 
        result == valid_list(lst@.map(|_i: int, x: i8| x as int)),
        result == (is_sorted_ascending(lst@.map(|_i: int, x: i8| x as int)) && no_more_than_two_duplicates(lst@.map(|_i: int, x: i8| x as int)))","{
    // impl-start
    assume(false);
    false
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0131,verus,humaneval,humaneval_127_intersection,,"function_signature: def intersection(interval1: Tuple[Int, Int], interval2: Tuple[Int, Int]) -> str
You are given two intervals, where each interval is a pair of integers. For example, interval = (start, end) = (1, 2). The given intervals are closed which means that the interval (start, end) includes both start and end. For each given interval, it is assumed that its start is less or equal its end. Your task is to determine whether the length of intersection of these two intervals is a prime number. Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3) which its length is 1, which not a prime number. If the length of the intersection is a prime number, return ""YES"", otherwise, return ""NO"". If the two intervals do not intersect, return ""NO"".","use vstd::prelude::*;

verus! {","spec fn is_prime(n: nat) -> bool {
    n > 1 &&
    forall|k: nat| #[trigger] (n % k) != 0 ==> 2 <= k < n
}

spec fn min(a: int, b: int) -> int {
    if a <= b { a } else { b }
}

spec fn max(a: int, b: int) -> int {
    if a >= b { a } else { b }
}","fn intersection(start1: i8, end1: i8, start2: i8, end2: i8) -> (result: String)
    requires start1 as int <= end1 as int && start2 as int <= end2 as int,
    ensures (result@ =~= seq!['Y', 'E', 'S'] || result@ =~= seq!['N', 'O']) && (result@ =~= seq!['Y', 'E', 'S'] <==> (max(start1 as int, start2 as int) <= min(end1 as int, end2 as int) && is_prime((min(end1 as int, end2 as int) - max(start1 as int, start2 as int) + 1) as nat))),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0132,verus,humaneval,humaneval_128,,"This task implements a function that calculates the sum of absolute
values of all elements in an array, multiplied by the product of signs of all elements.
The sign function returns 1 for positive numbers, -1 for negative numbers, and 0
for zero. If the array is empty, the function returns None; otherwise, it returns
Some with the computed result.","use vstd::prelude::*;

verus! {

spec fn abs(x: int) -> int {
    if x >= 0 { x } else { -x }
}

spec fn sign(x: int) -> int {
    if x > 0 { 1 } else if x < 0 { -1 } else { 0 }
}

spec fn sum_of_magnitudes(arr: Seq<int>) -> int
    decreases arr.len()
{
    if arr.len() == 0 { 0 } else { abs(arr[0]) + sum_of_magnitudes(arr.subrange(1, arr.len() as int)) }
}

spec fn product_of_signs(arr: Seq<int>) -> int
    decreases arr.len()
{
    if arr.len() == 0 { 1 } else { sign(arr[0]) * product_of_signs(arr.subrange(1, arr.len() as int)) }
}",,"fn prod_signs(arr: Vec<i8>) -> (result: Option<i8>)
    ensures 
        (arr@.len() == 0) ==> (result == Option::<i8>::None) &&
        (arr@.len() > 0) ==> (result == Option::<i8>::Some((sum_of_magnitudes(arr@.map(|i: int, x: i8| x as int)) * product_of_signs(arr@.map(|i: int, x: i8| x as int))) as i8))","{
    // impl-start
    assume(false);
    Option::<i8>::None
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0133,verus,humaneval,humaneval_130_tri,,"function_signature: fn tri(n: nat) -> nat

Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in the
last couple centuries. However, what people don't know is Tribonacci sequence.
Tribonacci sequence is defined by the recurrence: tri(1) = 3 tri(n) = 1 + n / 2,
if n is even. tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd. For example:
tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 +
3 = 8 You are given a non-negative integer number n, you have to a return a list
of the first n + 1 numbers of the Tribonacci sequence.","use vstd::prelude::*;

verus! {

spec fn tri(n: nat) -> nat
  decreases if n % 2 == 0 { 0 } else { n }
{
  if n == 1 { 3 }
  else if n % 2 == 0 { 1 + n / 2 }
  else { tri((n - 1) as nat) + tri((n - 2) as nat) + tri(n + 1) }
}",,"fn tribonacci(n: u8) -> (result: Vec<u8>)
  ensures 
    result.len() == n as int + 1 &&
    (forall|i: int| 0 <= i <= n as int ==> result[i] as nat == tri(i as nat))","{
  assume(false);
  Vec::new()
}","
}

fn main() {}",0,,-1,-1,-1,,0.7
VH0134,verus,humaneval,humaneval_132_is_nested,,"function_signature: fn is_nested(string: &str) -> bool

Create a function that takes a string as input which contains only parentheses.
The function should return True if and only if there is a valid subsequence of parentheses
where at least one parenthesis in the subsequence is nested.","use vstd::prelude::*;

verus! {",,"fn is_nested(s: Vec<i8>) -> (res: bool)
    ensures res == exists|x: int, y: int, z: int, w: int| 0 <= x < y < z < w < s@.len() && s@[x] == 0 && s@[y] == 0 && s@[z] == 1 && s@[w] == 1","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0135,verus,humaneval,humaneval_133_sum_squares,,"function_signature: def sum_squares(lst: List[float]) -> int

You are given a list of numbers. You need to return the sum of squared numbers in
the given list, round each element in the list to the upper int(Ceiling) first.","use vstd::prelude::*;

verus! {

spec fn sum(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 { 0 } else { s[0] + sum(s.subrange(1, s.len() as int)) }
}

spec fn ceil(f: int) -> int {
    f + 1
}

spec fn square_seq(lst: Seq<int>) -> Seq<int> {
    Seq::new(lst.len(), |i: int| ceil(lst[i]) * ceil(lst[i]))
}",,"fn sum_squares(lst: Vec<i8>) -> (r: i8)
    ensures r as int == sum(square_seq(lst@.map(|i: int, x: i8| x as int)))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0136,verus,humaneval,humaneval_134,,"This verification task involves implementing a method to determine
if the last character of a string is an alphabetical character that stands alone
(not part of a word). A ""word"" is defined as a group of characters separated by
spaces. The method should return true if the last character is a letter AND is not
part of a word, false otherwise. A standalone letter is either the entire string
(single character) or a letter preceded by a space.","use vstd::prelude::*;

verus! {

spec fn is_alpha(c: char) -> bool {
    ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')
}

spec fn valid_last_char_is_standalone_letter(txt: Seq<char>) -> bool {
    txt.len() > 0 && is_alpha(txt[txt.len() - 1]) && (txt.len() == 1 || txt[txt.len() - 2] == ' ')
}",,"fn check_if_last_char_is_a_letter(txt: &str) -> (result: bool)
    ensures result == valid_last_char_is_standalone_letter(txt@)","{
    assume(false);
    false
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0137,verus,humaneval,humaneval_135,,"The task is to find the largest index in an array of distinct integers
where an element is smaller than the element immediately before it. If no such index
exists (i.e., the array is non-decreasing), return -1. The implementation should
scan from right to left to efficiently find the largest such index.","use vstd::prelude::*;

verus! {

spec fn valid_input(arr: Seq<int>) -> bool {
    forall|i: int, j: int| 0 <= i < j < arr.len() ==> arr[i] != arr[j]
}

spec fn has_decrease_at(arr: Seq<int>, i: int) -> bool {
    1 <= i < arr.len() && arr[i] < arr[i-1]
}

spec fn is_largest_decrease_index(arr: Seq<int>, result: int) -> bool {
    has_decrease_at(arr, result) && 
    (forall|j: int| result < j < arr.len() ==> #[trigger] arr[j] >= arr[j-1])
}

spec fn is_non_decreasing(arr: Seq<int>) -> bool {
    forall|i: int| 1 <= i < arr.len() ==> #[trigger] arr[i] >= arr[i-1]
}

spec fn seq_map_to_int(arr: Seq<i8>) -> Seq<int> {
    arr.map(|_i: int, x: i8| x as int)
}",,"fn can_arrange(arr: Vec<i8>) -> (result: i8)
  requires 
      valid_input(seq_map_to_int(arr@)),
  ensures 
      (result == -1) || (0 < result as int && (result as int) < (arr@.len() as int)),
      result == -1 ==> is_non_decreasing(seq_map_to_int(arr@)),
      result != -1 ==> is_largest_decrease_index(seq_map_to_int(arr@), result as int),
      result != -1 ==> (exists|i: int| has_decrease_at(seq_map_to_int(arr@), i))","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0138,verus,humaneval,humaneval_136_largest_smallest_integers,,"function_signature: def largest_smallest_integers(lst: List[int]) -> Tuple[ Optional[Int], Optional[Int] ]

Create a function that returns a tuple (a, b), where 'a' is the largest of negative
integers, and 'b' is the smallest of positive integers in a list. If there is
no negative or positive integers, return them as None.","use vstd::prelude::*;

verus! {

spec fn get_value(o: Option<int>) -> int
    recommends o.is_Some()
{
    o.get_Some_0()
}",,"fn largest_smallest_integers(arr: Vec<i8>) -> (result: (Option<i8>, Option<i8>))","{
    assume(false);
    (Option::None, Option::None)
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0139,verus,humaneval,humaneval_137,,"This verification task implements a function that compares two values
of different types (integers, reals, or strings representing real numbers) and returns
the larger one in its original format. If the values are numerically equal, the
function returns None. The challenge is handling different value types while maintaining
their original representation in the result.","use vstd::prelude::*;

verus! {

#[derive(PartialEq, Eq)]
pub enum Value {
    Int(int),
    Real(int), /* Using int to represent reals for simplicity */
    Str(String),
}

spec fn is_valid_numeric_string(s: String) -> bool {
    true
}

spec fn value_to_real(v: Value) -> int {
    match v {
        Value::Int(i) => i,
        Value::Real(r) => r,
        Value::Str(s) => string_to_real(s),
    }
}

spec fn string_to_real(s: String) -> int {
    0
}",,"fn compare_one(a: Value, b: Value) -> (result: Option<Value>)
    requires 
        matches!(a, Value::Str(_)) ==> is_valid_numeric_string(a.arrow_Str_0()),
        matches!(b, Value::Str(_)) ==> is_valid_numeric_string(b.arrow_Str_0()),
    ensures 
        value_to_real(a) == value_to_real(b) <==> matches!(result, Option::None),
        value_to_real(a) > value_to_real(b) <==> result == Some(a),
        value_to_real(b) > value_to_real(a) <==> result == Some(b),
        matches!(result, Option::Some(_)) ==> (result.arrow_Some_0() == a || result.arrow_Some_0() == b),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,0.7
VH0140,verus,humaneval,humaneval_138,,"This verification task determines whether a given positive integer
n can be expressed as the sum of exactly 4 positive even numbers. The key insight
is that the minimum sum is 8 (2+2+2+2), and only even numbers can be expressed this
way since the sum of 4 even numbers is always even.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int) -> bool {
    n > 0
}

spec fn can_be_sum_of_four_positive_evens(n: int) -> bool {
    n % 2 == 0 && n >= 8
}",,"fn is_equal_to_sum_even(n: i8) -> (result: bool)
    requires valid_input(n as int)
    ensures result == can_be_sum_of_four_positive_evens(n as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0141,verus,humaneval,humaneval_139,,"Compute the special factorial of a positive integer n, defined as the product of all factorials from 1! to n!: special_factorial(n) = n! × (n-1)! × (n-2)! × ... × 1!. The implementation should use an iterative approach with proper loop invariants to ensure correctness.","use vstd::prelude::*;

verus! {

spec fn factorial_func(num: int) -> int
    recommends num >= 0
    decreases num
{
    if num <= 1 { 1 } else { num * factorial_func(num - 1) }
}

spec fn special_factorial_func(n: int) -> int
    recommends n >= 0
    decreases n
{
    if n <= 0 { 1 }
    else { special_factorial_func(n - 1) * factorial_func(n) }
}

fn factorial(num: int) -> (result: int)
    requires 
        num >= 0,
    ensures 
        result == factorial_func(num),
        result > 0,
{
    assume(false);
    unreached()
}",,"fn special_factorial(n: i8) -> (result: i8)
    requires 
        n >= 0,
    ensures 
        result as int == special_factorial_func(n as int),
        result > 0,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0142,verus,humaneval,humaneval_140,,"This verification task involves implementing a string transformation
method that replaces spaces according to specific rules: individual spaces or pairs
of consecutive spaces become underscores (one per space), while sequences of more
than 2 consecutive spaces become a single dash. The implementation must preserve
the order of non-space characters and satisfy several correctness predicates.","use vstd::prelude::*;

verus! {
spec fn valid_input(text: Seq<char>) -> bool {
    true
}

spec fn is_space_sequence(text: Seq<char>, start: int, end: int) -> bool {
    &&& 0 <= start <= end < text.len()
    &&& (forall|k: int| start <= k <= end ==> text[k] == ' ')
    &&& (start == 0 || text[start-1] != ' ')
    &&& (end == text.len()-1 || text[end+1] != ' ')
}

spec fn valid_result(text: Seq<char>, result: Seq<char>) -> bool {
    &&& result.len() <= text.len()
    &&& (text.len() == 0 ==> result.len() == 0)
    &&& (forall|i: int| 0 <= i < result.len() ==> result[i] != ' ')
    &&& (forall|i: int| 0 <= i < result.len() ==> result[i] == '_' || result[i] == '-' || text.contains(result[i]))
    &&& ((forall|i: int| 0 <= i < text.len() ==> text[i] != ' ') ==> result == text)
    &&& (forall|i: int| 0 <= i < text.len() && text[i] != ' ' ==> result.contains(text[i]))
}

spec fn preserves_order(text: Seq<char>, result: Seq<char>) -> bool {
    forall|i: int, j: int| 0 <= i < j < text.len() && text[i] != ' ' && text[j] != ' ' ==>
        exists|i_prime: int, j_prime: int| 0 <= i_prime < j_prime < result.len() && result[i_prime] == text[i] && result[j_prime] == text[j]
}

spec fn correct_space_transformation(text: Seq<char>, result: Seq<char>) -> bool {
    &&& (forall|i: int| 0 <= i < text.len() ==> #[trigger] text[i] != ' ' ==> result.contains(#[trigger] text[i]))
    &&& (forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i] != ' ')
    &&& (forall|i: int, j: int| 0 <= i < j < text.len() && #[trigger] text[i] != ' ' && #[trigger] text[j] != ' ' ==>
        exists|i_prime: int, j_prime: int| 0 <= i_prime < j_prime < result.len() && result[i_prime] == #[trigger] text[i] && result[j_prime] == #[trigger] text[j])
    &&& (forall|i: int| 0 <= i < text.len() && #[trigger] text[i] == ' ' ==> 
        (i == 0 || text[i-1] != ' ') && (i == text.len()-1 || text[i+1] != ' ') ==> 
        exists|j: int| 0 <= j < result.len() && ( #[trigger] result[j] == '_' || #[trigger] result[j] == '-'))
}",,"fn fix_spaces(text: Seq<char>) -> (result: Seq<char>)
    requires 
        valid_input(text),
    ensures 
        valid_result(text, result),
        preserves_order(text, result),
        correct_space_transformation(text, result)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,0.7
VH0143,verus,humaneval,humaneval_142,,"Transform each element in a list of integers based on its index position:
square elements at indices that are multiples of 3, cube elements at indices that
are multiples of 4 but not 3, and leave other elements unchanged. Return the sum
of all transformed elements.","use vstd::prelude::*;

verus! {

spec fn transform_element(value: int, index: int) -> int
{
    if index % 3 == 0 { 
        value * value
    } else if index % 4 == 0 { 
        value * value * value
    } else { 
        value
    }
}

spec fn sum_partial(lst: Seq<int>, n: int) -> int
    decreases n
    when 0 <= n <= lst.len()
{
    if n == 0 { 
        0
    } else { 
        sum_partial(lst, n-1) + transform_element(lst[n-1], n-1)
    }
}

spec fn sum_transformed(lst: Seq<int>) -> int
{
    sum_partial(lst, lst.len() as int)
}","spec fn seq_to_int(s: Seq<i8>) -> Seq<int> {
    s.map(|i, x: i8| x as int)
}","fn sum_squares(lst: Vec<i8>) -> (result: i8)
    ensures result as int == sum_transformed(seq_to_int(lst@))","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0144,verus,humaneval,humaneval_144,,"This verification challenge involves implementing a method that determines
if the product of two fractions is a whole number. Given two fractions represented
as strings in the format ""numerator/denominator"", the task is to multiply them and
check if the result is an integer (i.e., the numerator of the product is divisible
by the denominator).

The implementation must correctly parse the fraction strings, extract numerators
and denominators, perform the multiplication, and check divisibility while maintaining
all verification conditions.","use vstd::prelude::*;

verus! {

spec fn valid_fraction(s: Seq<char>) -> bool {
    s.len() > 0 && 
    (exists|i: int| 0 <= i < s.len() && #[trigger] s[i] == '/') &&
    (forall|j: int| 0 <= j < s.len() ==> (s[j] == '/' || ('0' <= s[j] <= '9'))) &&
    (exists|k: int| 0 <= k < s.len() && #[trigger] s[k] == '/' && 
        k > 0 && k + 1 < s.len() &&
        string_to_int(s.subrange(0, k)) > 0 && string_to_int(s.subrange(k+1, s.len() as int)) > 0) &&
    (forall|i: int| 0 <= i < s.len() && #[trigger] s[i] == '/' ==> 
        i > 0 && i + 1 < s.len() &&
        string_to_int(s.subrange(0, i)) > 0 && string_to_int(s.subrange(i+1, s.len() as int)) > 0)
}

spec fn get_numerator(s: Seq<char>) -> int
    recommends valid_fraction(s)
{
    let slash_pos = find_slash(s);
    string_to_int(s.subrange(0, slash_pos))
}

spec fn get_denominator(s: Seq<char>) -> int
    recommends valid_fraction(s)
{
    let slash_pos = find_slash(s);
    string_to_int(s.subrange(slash_pos+1, s.len() as int))
}

spec fn find_slash(s: Seq<char>) -> int
    recommends exists|i: int| 0 <= i < s.len() && s[i] == '/'
{
    find_slash_helper(s, 0)
}

spec fn string_to_int(s: Seq<char>) -> int {
    string_to_int_helper(s, 0)
}

spec fn char_to_int(c: char) -> int {
    if c == '0' { 0 }
    else if c == '1' { 1 }
    else if c == '2' { 2 }
    else if c == '3' { 3 }
    else if c == '4' { 4 }
    else if c == '5' { 5 }
    else if c == '6' { 6 }
    else if c == '7' { 7 }
    else if c == '8' { 8 }
    else if c == '9' { 9 }
    else { 0 }
}","spec fn find_slash_helper(s: Seq<char>, pos: int) -> int
    decreases s.len() - pos when 0 <= pos <= s.len() && exists|i: int| pos <= i < s.len() && s[i] == '/'
{
    if pos < s.len() && s[pos] == '/' { pos }
    else { find_slash_helper(s, pos + 1) }
}

spec fn string_to_int_helper(s: Seq<char>, acc: int) -> int
    decreases s.len()
{
    if s.len() == 0 { acc }
    else { string_to_int_helper(s.subrange(1, s.len() as int), acc * 10 + char_to_int(s[0])) }
}","fn simplify(x: Vec<char>, n: Vec<char>) -> (result: bool)
    requires 
        x.len() > 0 && n.len() > 0,
        exists|i: int| 0 <= i < x@.len() && x@[i] == '/',
        exists|j: int| 0 <= j < n@.len() && n@[j] == '/',
        forall|i: int| 0 <= i < x@.len() ==> (x@[i] == '/' || ('0' <= x@[i] <= '9')),
        forall|j: int| 0 <= j < n@.len() ==> (n@[j] == '/' || ('0' <= n@[j] <= '9')),
        valid_fraction(x@),
        valid_fraction(n@),
    ensures result <==> (get_numerator(x@) * get_numerator(n@)) % (get_denominator(x@) * get_denominator(n@)) == 0","{
    // impl-start
    assume(false);
    false
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0145,verus,humaneval,humaneval_145_order_by_points,,"function_signature: fn order_by_points(nums: Vec<int>) -> Vec<int>
Write a function which sorts the given list of integers in ascending order according to the sum of their digits. Note: if there are several items with similar sum of their digits, order them based on their index in original list.","use vstd::prelude::*;

verus! {

spec fn digits_sum_pos(n: int) -> int
  decreases n
{
  if n >= 0 {
    if n < 10 { n } else { digits_sum_pos(n / 10) + n % 10 }
  } else {
    0
  }
}

spec fn digits_sum(n: int) -> int {
  if n < 0 { digits_sum_pos(-n) } else { digits_sum_pos(n) }
}",,"fn order_by_points(s: Vec<i8>) -> (sorted: Vec<i8>)
  ensures 
      forall|i: int, j: int| 0 <= i < j < sorted@.len() ==> digits_sum(sorted@[i] as int) <= digits_sum(sorted@[j] as int),
      sorted@.len() == s@.len(),
      s@.to_multiset() == sorted@.to_multiset()","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0146,verus,humaneval,humaneval_146,,"Count the numbers in an array that satisfy all three conditions:
1) Greater than 10, 2) First digit is odd (1, 3, 5, 7, 9), and 3) Last digit is
odd (1, 3, 5, 7, 9).","use vstd::prelude::*;

verus! {

spec fn first_digit(n: int) -> int
    recommends n > 0
    decreases n
{
    if n < 10 { n } else { first_digit(n / 10) }
}

spec fn last_digit(n: int) -> int
    recommends n > 0
{
    n % 10
}

spec fn is_odd(n: int) -> bool
{
    n == 1 || n == 3 || n == 5 || n == 7 || n == 9
}

spec fn satisfies_condition(n: int) -> bool
{
    n > 10 && is_odd(first_digit(n)) && is_odd(last_digit(n))
}

spec fn valid_input(nums: Seq<int>) -> bool
{
    true
}
spec fn count_helper(nums: Seq<int>, index: int) -> int
    recommends 0 <= index <= nums.len()
    decreases nums.len() - index when 0 <= index <= nums.len()
{
    if index == nums.len() {
        0
    } else {
        let current = nums[index];
        let contribution: int = if satisfies_condition(current) { 1 } else { 0 };
        contribution + count_helper(nums, index + 1)
    }
}",,"fn special_filter(nums: Seq<int>) -> (count: int)
    requires 
        valid_input(nums)
    ensures 
        count >= 0,
        count <= nums.len(),
        count == Set::new(|i: int| 0 <= i < nums.len() && satisfies_condition(nums[i])).len(),
        nums.len() == 0 ==> count == 0,
        forall|i: int| #![auto] 0 <= i < nums.len() && satisfies_condition(nums[i]) ==> 
            nums[i] > 10 && is_odd(first_digit(nums[i])) && is_odd(last_digit(nums[i]))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,0.7
VH0147,verus,humaneval,humaneval_147,,"This verification task involves counting valid triples from a special
array. Given a positive integer n, create an array where each element a[i] = i²
- i + 1 for positions 1 to n. The goal is to count the number of triples (a[i],
a[j], a[k]) where i < j < k and their sum is divisible by 3.

The implementation uses the mathematical insight that elements can be categorized
by their modulo 3 value, and valid triples must either come from all elements with
the same modulo value.","use vstd::prelude::*;

verus! {

spec fn array_element(i: int) -> int
  recommends i >= 1
{
  i * i - i + 1
}

spec fn count_elements_mod_0(n: int) -> int
  recommends n >= 0
  decreases n when n >= 0
{
  if n <= 0 { 0 }
  else if n % 3 == 2 { 1 + count_elements_mod_0(n - 1) }
  else { count_elements_mod_0(n - 1) }
}

spec fn count_elements_mod_1(n: int) -> int
  recommends n >= 0
  decreases n when n >= 0
{
  if n <= 0 { 0 }
  else if n % 3 != 2 { 1 + count_elements_mod_1(n - 1) }
  else { count_elements_mod_1(n - 1) }
}

spec fn combination(n: int, k: int) -> int
  recommends n >= 0 && k >= 0
{
  if k > n || k < 0 { 0 }
  else if k == 0 || k == n { 1 }
  else if k == 1 { n }
  else if k == 2 { n * (n - 1) / 2 }
  else if k == 3 { n * (n - 1) * (n - 2) / 6 }
  else { 0 }
}

spec fn count_valid_triples(n: int) -> int
  recommends n >= 1
{
  let count_0 = count_elements_mod_0(n);
  let count_1 = count_elements_mod_1(n);
  combination(count_0, 3) + combination(count_1, 3)
}

spec fn valid_input(n: int) -> bool
{
  n >= 1
}",,"fn get_max_triples(n: i8) -> (result: i8)
  requires
      valid_input(n as int),
  ensures
      result >= 0,
      result as int == count_valid_triples(n as int),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0148,verus,humaneval,humaneval_148_bf,,"function_signature: def bf(planet1: str, planet2: str) -> List[str]

There are eight planets in our solar system: the closest to the Sun is Mercury,
the next one is Venus, then Earth, Mars, Jupiter, Saturn, Uranus, Neptune. Write
a function that takes two planet names as strings planet1 and planet2. The function
should return a tuple containing all planets whose orbits are located between the
orbit of planet1 and the orbit of planet2, sorted by the proximity to the sun. The
function should return an empty tuple if planet1 or planet2 are not correct planet
names.","use vstd::prelude::*;

verus! {

#[derive(PartialEq, Eq, Clone, Copy)]
enum Planet {
    Mercury,
    Venus,
    Earth,
    Mars,
    Jupiter,
    Saturn,
    Uranus,
    Neptune,
}

spec fn planet_from_string(name: Seq<char>) -> Option<Planet> {
    if name == seq!['M','e','r','c','u','r','y'] {
        Some(Planet::Mercury)
    } else if name == seq!['V','e','n','u','s'] {
        Some(Planet::Venus)
    } else if name == seq!['E','a','r','t','h'] {
        Some(Planet::Earth)
    } else if name == seq!['M','a','r','s'] {
        Some(Planet::Mars)
    } else if name == seq!['J','u','p','i','t','e','r'] {
        Some(Planet::Jupiter)
    } else if name == seq!['S','a','t','u','r','n'] {
        Some(Planet::Saturn)
    } else if name == seq!['U','r','a','n','u','s'] {
        Some(Planet::Uranus)
    } else if name == seq!['N','e','p','t','u','n','e'] {
        Some(Planet::Neptune)
    } else {
        None
    }
}

spec fn planet_index(p: Planet) -> int {
    match p {
        Planet::Mercury => 0int,
        Planet::Venus => 1int,
        Planet::Earth => 2int,
        Planet::Mars => 3int,
        Planet::Jupiter => 4int,
        Planet::Saturn => 5int,
        Planet::Uranus => 6int,
        Planet::Neptune => 7int,
    }
}

spec fn get_planets_between(planet1: Seq<char>, planet2: Seq<char>) -> Seq<Seq<char>> {
    let p1 = planet_from_string(planet1);
    let p2 = planet_from_string(planet2);
    if p1.is_none() || p2.is_none() {
        seq![]
    } else {
        let i1 = planet_index(p1.unwrap());
        let i2 = planet_index(p2.unwrap());
        if i1 < i2 {
            get_planets_between_indices(i1 + 1, i2 - 1)
        } else if i1 > i2 {
            get_planets_between_indices(i2 + 1, i1 - 1)
        } else {
            seq![]
        }
    }
}

spec fn get_planets_between_indices(start: int, end: int) -> Seq<Seq<char>>
    recommends 0 <= start <= 7 && 0 <= end <= 7
    decreases if start <= end { end - start + 1 } else { 0 }
{
    if start > end {
        seq![]
    } else {
        if start == 0int {
            seq![seq!['M','e','r','c','u','r','y']].add(get_planets_between_indices(1int, end))
        } else if start == 1int {
            seq![seq!['V','e','n','u','s']].add(get_planets_between_indices(2int, end))
        } else if start == 2int {
            seq![seq!['E','a','r','t','h']].add(get_planets_between_indices(3int, end))
        } else if start == 3int {
            seq![seq!['M','a','r','s']].add(get_planets_between_indices(4int, end))
        } else if start == 4int {
            seq![seq!['J','u','p','i','t','e','r']].add(get_planets_between_indices(5int, end))
        } else if start == 5int {
            seq![seq!['S','a','t','u','r','n']].add(get_planets_between_indices(6int, end))
        } else if start == 6int {
            seq![seq!['U','r','a','n','u','s']].add(get_planets_between_indices(7int, end))
        } else if start == 7int {
            seq![seq!['N','e','p','t','u','n','e']]
        } else {
            seq![]
        }
    }
}

spec fn seq_char_to_string(chars: Seq<char>) -> String {
    arbitrary()
}

spec fn planets_seq_to_string_vec(planets: Seq<Seq<char>>) -> Seq<String> 
    decreases planets.len()
{
    if planets.len() == 0 {
        seq![]
    } else {
        let first_planet = planets[0];
        let rest = planets.drop_first();
        seq![seq_char_to_string(first_planet)].add(planets_seq_to_string_vec(rest))
    }
}",,"fn bf(planet1: String, planet2: String) -> (planets: Vec<String>)
    ensures planets@ == planets_seq_to_string_vec(get_planets_between(planet1@, planet2@))","{
    assume(false);
    Vec::new()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0149,verus,humaneval,humaneval_149_sorted_list_sum__sort_lengths,,"function_signature: fn sort_lengths(list: &Seq<Seq<char>>) -> (sorted: Seq<Seq<char>>)

Sort elements. Requires: the condition holds for all values. Ensures: the result
is sorted according to the ordering relation; returns the correct size/count; returns
a sorted permutation of the input; the result is sorted according to the ordering
relation.","use vstd::prelude::*;

verus! {

spec fn comparison(a: Seq<char>, b: Seq<char>, i: int) -> bool
    decreases a.len() - i, b.len() - i
{
    if (i < a.len() && i < b.len()) {
        if a.index(i) < b.index(i) {
            true
        } else if a.index(i) > b.index(i) {
            false
        } else {
            comparison(a, b, i + 1)
        }
    } else {
        if a.len() <= b.len() {
            true
        } else {
            false
        }
    }
}",,"fn sort_lengths(list: &Vec<Vec<char>>) -> (sorted: Vec<Vec<char>>)
    requires 
        forall|i: int| 0 <= i < list@.len() ==> list@.index(i).len() % 2 == 0
    ensures 
        forall|i: int| 0 <= i < sorted@.len() ==> sorted@.index(i).len() % 2 == 0,
        sorted@.len() == list@.len(),
        sorted@.to_multiset() == list@.to_multiset(),
        forall|x: int, y: int| 0 <= x < y < sorted@.len() ==> sorted@.index(x).len() <= sorted@.index(y).len()","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,DupVH00,0.85
VH0150,verus,humaneval,humaneval_149_sorted_list_sum__sort_strings,,"function_signature: fn sort_strings(list: Seq<Seq<char>>) -> (sorted: Seq<Seq<char>>)

Sort elements. Ensures: returns the correct size/count; returns a sorted permutation
of the input.","use vstd::prelude::*;

verus! {

spec fn comparison(a: Seq<char>, b: Seq<char>, i: int) -> bool 
    decreases a.len() - i, b.len() - i
{
    if (0 <= i <= a.len() && 0 <= i <= b.len()) {
        if (i < a.len() && i < b.len()) {
            if a.index(i) < b.index(i) {
                true
            } else if a.index(i) > b.index(i) {
                false
            } else {
                comparison(a, b, i + 1)
            }
        } else {
            if a.len() <= b.len() {
                true
            } else {
                false
            }
        }
    } else {
        false
    }
}",,"fn sort_strings(list: Vec<Vec<char>>) -> (sorted: Vec<Vec<char>>)
    ensures
        sorted@.len() == list@.len(),
        sorted@.to_multiset() == list@.to_multiset(),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0151,verus,humaneval,humaneval_149_sorted_list_sum__sorted_list_sum,,"function_signature: fn sorted_list_sum(list: Seq<Seq<char>>) -> (sorted: Seq<Seq<char>>)

Sort elements. Requires: requires size of list > 0. Ensures: the size is bounded; the result is sorted according to the ordering relation; the result is sorted according to the ordering relation; returns a sorted permutation of the input.","use vstd::prelude::*;

verus! {

spec fn comparison(a: Seq<char>, b: Seq<char>, i: int) -> bool
    recommends 0 <= i <= a.len() && 0 <= i <= b.len()
    decreases a.len() - i, b.len() - i
{
    if (i < a.len() && i < b.len()) {
        if a[i] < b[i] {
            true
        } else if a[i] > b[i] {
            false
        } else {
            comparison(a, b, i + 1)
        }
    } else {
        if a.len() <= b.len() {
            true
        } else {
            false
        }
    }
}",,"fn sorted_list_sum(list: Vec<Vec<char>>) -> (sorted: Vec<Vec<char>>)
    requires 
        list@.len() > 0
    ensures 
        sorted@.len() <= list@.len(),
        forall|i: int| 0 <= i < sorted@.len() ==> sorted@[i].len() % 2 == 0,
        forall|x: int, y: int| 0 <= x < y < sorted@.len() ==> sorted@[x].len() <= sorted@[y].len(),
        sorted@.to_multiset().subset_of(list@.to_multiset())","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,DupVH00,0.85
VH0152,verus,humaneval,humaneval_150_x_or_y,,"function_signature: def x_or_y(int n, int x, int y) -> int

A simple program which should return the value of x if n is a prime number and should
return the value of y otherwise.","use vstd::prelude::*;

verus! {

spec fn is_prime(n: nat) -> bool {
    n > 1 &&
    forall|k: nat| 2 <= k < n ==> #[trigger] (n % k) != 0
}",,"fn x_or_y(n: u8, x: i8, y: i8) -> (result: i8)
    ensures 
        is_prime(n as nat) ==> result == x,
        !is_prime(n as nat) ==> result == y,","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0153,verus,humaneval,humaneval_151,,"This verification task implements a function that computes the sum
of squares of all positive odd integers in a list containing both integers and real
numbers. The function should ignore negative numbers and non-integers, returning
0 for an empty list.

The implementation needs to handle a mixed datatype that can represent both integers
and reals, properly identify positive odd integers (including reals that represent
integers), and maintain correctness through loop invariants.","use vstd::prelude::*;

verus! {

enum Number {
    Int(int),
    Real(int), /* Using int to represent real since Verus doesn't have native real type */
}

spec fn is_integer(r: int) -> bool {
    true /* Since we're using int to represent real, this is always true */
}

spec fn is_positive_odd_integer(n: Number) -> bool {
    match n {
        Number::Int(i) => i > 0 && i % 2 == 1,
        Number::Real(r) => is_integer(r) && r > 0 && r % 2 == 1,
    }
}

spec fn square_value(n: Number) -> int {
    match n {
        Number::Int(i) => i * i,
        Number::Real(r) => r * r,
    }
}

spec fn sum_of_squares(lst: Seq<Number>, i: nat) -> int
    decreases i
{
    if i == 0 {
        0
    } else if is_positive_odd_integer(lst[(i - 1) as int]) {
        square_value(lst[(i - 1) as int]) + sum_of_squares(lst, (i - 1) as nat)
    } else {
        sum_of_squares(lst, (i - 1) as nat)
    }
}",,"fn double_the_difference(lst: Vec<Number>) -> (result: i32)
    ensures 
        result >= 0,
        result == sum_of_squares(lst@, lst@.len()) as i32,
        lst@.len() == 0 ==> result == 0","{
    // impl-start
    assume(false);
    0
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0154,verus,humaneval,humaneval_152,,"This verification task involves implementing a function that compares
two arrays of equal length representing actual game scores and guessed scores. The
implementation should calculate how far off each guess was from the actual result
by computing the absolute difference between corresponding elements.","use vstd::prelude::*;

verus! {

spec fn valid_input(game: Seq<int>, guess: Seq<int>) -> bool {
    game.len() == guess.len()
}

spec fn valid_output(game: Seq<int>, guess: Seq<int>, result: Seq<int>) -> bool {
    game.len() == guess.len() ==> (
        && result.len() == game.len()
        && (forall|i: int| 0 <= i < game.len() ==> result[i] == abs_value(game[i] - guess[i]))
        && (forall|i: int| 0 <= i < result.len() ==> result[i] >= 0)
    )
}

spec fn abs_value(x: int) -> int {
    if x >= 0 { x } else { -x }
}",,"fn compare(game: Vec<i8>, guess: Vec<i8>) -> (result: Vec<i8>)
    requires valid_input(game@.map_values(|x: i8| x as int), guess@.map_values(|x: i8| x as int))
    ensures valid_output(game@.map_values(|x: i8| x as int), guess@.map_values(|x: i8| x as int), result@.map_values(|x: i8| x as int))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0155,verus,humaneval,humaneval_153,,"Given a class name (string) and a list of extension names (strings),
find the ""strongest"" extension and return the result in the format ""ClassName.StrongestExtensionName"".
The strength of an extension is calculated as: (number of uppercase letters) - (number
of lowercase letters). Choose the extension with the highest strength value. If
multiple extensions have the same highest strength, choose the first one that appears
in the list.","use vstd::prelude::*;

verus! {

spec fn count_upper(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0int
    } else {
        (if 'A' <= s[0] && s[0] <= 'Z' { 1int } else { 0int }) + count_upper(s.skip(1))
    }
}

spec fn count_lower(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0int
    } else {
        (if 'a' <= s[0] && s[0] <= 'z' { 1int } else { 0int }) + count_lower(s.skip(1))
    }
}

spec fn strength(s: Seq<char>) -> int {
    count_upper(s) - count_lower(s)
}",,"fn strongest_extension(class_name: Vec<char>, extensions: Vec<Vec<char>>) -> (result: Vec<char>)
    requires extensions@.len() > 0
    ensures exists|i: int| 0 <= i < extensions@.len() && 
            result@ == class_name@ + seq!['.'] + extensions@[i]@ &&
            (forall|j: int| 0 <= j < extensions@.len() ==> 
                strength(extensions@[i]@) >= strength(extensions@[j]@)) &&
            (forall|j: int| 0 <= j < i ==> 
                strength(extensions@[j]@) < strength(extensions@[i]@))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0156,verus,humaneval,humaneval_154_cycpattern_check,,"function_signature: def cycpattern_check(String a, String b) -> Bool

You are given 2 words. You need to return True if the second word or any of its
rotations is a substring in the first word, else False","use vstd::prelude::*;

verus! {","spec fn is_substring(s: Seq<char>, sub: Seq<char>) -> bool
    decreases s.len()
{
    if sub.len() == 0 {
        true
    } else if s.len() < sub.len() {
        false
    } else if s.len() == sub.len() {
        s == sub
    } else {
        (s.subrange(0, sub.len() as int) == sub) || is_substring(s.subrange(1, s.len() as int), sub)
    }
}

spec fn rotate_string(s: Seq<char>, n: nat) -> Seq<char>
    recommends 0 <= n <= s.len()
{
    s.subrange(n as int, s.len() as int).add(s.subrange(0, n as int))
}","fn cycpattern_check(word: Seq<char>, pattern: Seq<char>) -> (result: bool)
    ensures result == exists|i: int| 0 <= i <= pattern.len() && is_substring(word, #[trigger] rotate_string(pattern, i as nat))","{
    // impl-start
    assume(false);
    false
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0157,verus,humaneval,humaneval_155,,"This verification task implements a function to count the number of even and odd digits in the absolute value of an integer. The function should return a tuple containing the count of even digits and the count of odd digits.

The implementation uses helper functions to define digit counting operations and ensures correctness through loop invariants that maintain the relationship between processed and remaining digits.","use vstd::prelude::*;

verus! {

spec fn abs_value(x: int) -> nat {
    if x < 0 { (-x) as nat } else { x as nat }
}

spec fn count_digits(n: nat) -> nat
    recommends n >= 0
    decreases n
{
    if n < 10 { 1nat } else { 1nat + count_digits(n / 10) }
}

spec fn is_even_digit(d: nat) -> bool
    recommends d < 10
{
    d % 2 == 0
}

spec fn count_even_digits(n: nat) -> nat
    recommends n >= 0
    decreases n
{
    if n < 10 {
        if is_even_digit(n) { 1nat } else { 0nat }
    } else {
        (if is_even_digit(n % 10) { 1nat } else { 0nat }) + count_even_digits(n / 10)
    }
}

spec fn count_odd_digits(n: nat) -> nat
    recommends n >= 0
    decreases n
{
    if n < 10 {
        if !is_even_digit(n) { 1nat } else { 0nat }
    } else {
        (if !is_even_digit(n % 10) { 1nat } else { 0nat }) + count_odd_digits(n / 10)
    }
}",,"fn even_odd_count(num: i8) -> (result: (i8, i8))
    ensures 
        result.0 >= 0 && result.1 >= 0 &&
        result.0 + result.1 >= 1 &&
        ({
            let abs_num = abs_value(num as int);
            result.0 as nat == count_even_digits(abs_num) &&
            result.1 as nat == count_odd_digits(abs_num)
        }) &&
        result.0 + result.1 == count_digits(abs_value(num as int)) as i8 &&
        (num == 0 ==> (result.0 == 1 && result.1 == 0)) &&
        (abs_value(num as int) == abs_value((-num) as int) ==> 
            (result.0 as nat == count_even_digits(abs_value((-num) as int)) && 
             result.1 as nat == count_odd_digits(abs_value((-num) as int))))","{
    // impl-start
    assume(false);
    (0, 0)
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0158,verus,humaneval,humaneval_157,,"This verification task involves implementing a method to determine
if three positive numbers representing triangle side lengths form a right-angled
triangle. The implementation must check both that the sides form a valid triangle
(positive lengths satisfying triangle inequality) and that they satisfy the Pythagorean
theorem.","use vstd::prelude::*;

verus! {","spec fn valid_triangle(a: int, b: int, c: int) -> bool {
    a > 0 && b > 0 && c > 0 &&
    a + b > c && a + c > b && b + c > a
}

spec fn is_right_triangle(a: int, b: int, c: int) -> bool {
    a * a + b * b == c * c || 
    a * a + c * c == b * b || 
    b * b + c * c == a * a
}

spec fn valid_right_triangle(a: int, b: int, c: int) -> bool {
    valid_triangle(a, b, c) && is_right_triangle(a, b, c)
}","fn right_angle_triangle(a: i8, b: i8, c: i8) -> (result: bool)
    ensures result <==> valid_right_triangle(a as int, b as int, c as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0159,verus,humaneval,humaneval_158_find_max,,"function_signature: fn find_max(words: Vec<String>) -> String

Write a function that accepts a list of strings. The list contains different words.
Return the word with maximum number of unique characters. If multiple strings have
maximum number of unique characters, return the one which comes first in lexicographical
order.","use vstd::prelude::*;

verus! {

spec fn string_unique_chars(s: Seq<char>) -> int {
    s.to_set().len() as int
}",,"fn find_max(strings: Vec<String>) -> (s: String)
    requires 
        strings.len() > 0,
    ensures 
        exists|i: int| 0 <= i < strings.len() && #[trigger] strings@.index(i)@ == s@,
        forall|i: int| 0 <= i < strings.len() ==> 
            string_unique_chars(s@) >= #[trigger] string_unique_chars(#[trigger] strings@.index(i)@),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0160,verus,humaneval,humaneval_159,,"This verification task involves implementing a method that calculates
carrot consumption for a rabbit. Given the number of carrots already eaten, the
number of additional carrots needed, and the number of carrots remaining in stock,
the method should return the total carrots that will be eaten and how many carrots
will be left. The rabbit will eat as many carrots as possible from the remaining
stock, up to the number needed.","use vstd::prelude::*;

verus! {

spec fn valid_input(number: int, need: int, remaining: int) -> bool
{
    0 <= number <= 1000 && 0 <= need <= 1000 && 0 <= remaining <= 1000
}

spec fn can_eat(need: int, remaining: int) -> int
{
    if need <= remaining { need } else { remaining }
}

spec fn total_eaten(number: int, need: int, remaining: int) -> int
{
    number + can_eat(need, remaining)
}

spec fn carrots_left(need: int, remaining: int) -> int
{
    remaining - can_eat(need, remaining)
}

spec fn valid_result(result: Seq<int>, number: int, need: int, remaining: int) -> bool
{
    result.len() == 2 &&
    result[0] == total_eaten(number, need, remaining) &&
    result[1] == carrots_left(need, remaining) &&
    result[0] >= number &&
    result[1] >= 0 &&
    result[1] <= remaining
}",,"fn eat(number: i8, need: i8, remaining: i8) -> (result: Vec<i8>)
    requires valid_input(number as int, need as int, remaining as int)
    ensures valid_result(result@.map(|i, x| x as int), number as int, need as int, remaining as int)","{
    assume(false);
    Vec::new()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0161,verus,humaneval,humaneval_161,,"This task involves implementing a string transformation method that applies one of two operations based on whether the string contains letters. If the string has at least one letter, swap the case of each letter (lowercase ↔ uppercase) while keeping non-letters unchanged. If the string contains no letters, reverse the entire string.","use vstd::prelude::*;

verus! {

spec fn has_letter(s: Seq<char>) -> bool
{
    exists|i: int| 0 <= i < s.len() && (('A' <= s[i] && s[i] <= 'Z') || ('a' <= s[i] && s[i] <= 'z'))
}

spec fn reverse_string(s: Seq<char>) -> Seq<char>
    decreases s.len()
{
    if s.len() == 0 { 
        s 
    } else { 
        s.subrange(s.len() as int - 1, s.len() as int).add(reverse_string(s.subrange(0, s.len() as int - 1)))
    }
}

spec fn swap_case(c: char) -> char
{
    if 'A' <= c && c <= 'Z' { 
        ((c as u32 + 32) as char)
    } else if 'a' <= c && c <= 'z' { 
        ((c as u32 - 32) as char)
    } else { 
        c 
    }
}",,"fn solve(s: Vec<char>) -> (result: Vec<char>)
    ensures (if has_letter(s@) {
        result@.len() == s@.len() && 
        (forall|i: int| 0 <= i < s@.len() ==> result@[i] == swap_case(s@[i]))
    } else {
        result@ == reverse_string(s@)
    }) && result@.len() == s@.len()","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0162,verus,humaneval,humaneval_162,,"This verification task implements a string to MD5 hash conversion
function. The method takes a string input and returns an Option type containing
either None (for empty input) or Some with a valid 32-character lowercase hexadecimal
MD5 hash string.","use vstd::prelude::*;

verus! {

spec fn is_valid_md5_hash(s: Seq<char>) -> bool {
    s.len() == 32 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s.index(i) == s.index(i) && {
        let c = s.index(i);
        ('0' <= c && c <= '9') || ('a' <= c && c <= 'f')
    }
}",,"fn string_to_md5(text: String) -> (result: Option<String>)
    ensures ({
        (text@.len() == 0 ==> matches!(result, Option::None)) &&
        (text@.len() != 0 ==> match result {
            Option::Some(value) => is_valid_md5_hash(value@),
            Option::None => false,
        })
    })","{
    // impl-start
    assume(false);
    Option::None
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VH0163,verus,humaneval,humaneval_163_generate_integers__generate_integers,,"function_signature: fn generate_integers(a: int, b: int) -> (result: Vec<int>)

Generate elements. Ensures: the condition holds for all values; the condition holds
for all values.","use vstd::prelude::*;

verus! {",,"fn generate_integers(a: i8, b: i8) -> (result: Vec<i8>)
    ensures (forall|i: int| 0 <= i < result@.len() ==> result@[i] % 2 == 0) &&
            (forall|i: int| 0 <= i < result@.len() ==> (result@[i] == 2 || result@[i] == 4 || result@[i] == 6 || result@[i] == 8))","{
    assume(false);
    Vec::new()
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VJ0000,verus,verified_cogen,proofsynthesis_arg_free,,,"use vstd::prelude::*;

verus!{",,fn choose_odd(),"{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0001,verus,verified_cogen,proofsynthesis_binary_search,,,"use vstd::prelude::*;

verus!{",,"fn binary_search(v: &Vec<u64>, k: u64) -> (result:usize)

    requires
        forall|i:int, j:int| 0 <= i <= j < v.len() ==> v[i] <= v[j],
        exists|i:int| 0 <= i < v.len() && k == v[i],

    ensures
        result < v.len(),
        k == v[result as int],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0002,verus,verified_cogen,proofsynthesis_brs1,,,"use vstd::prelude::*;

verus!{",,"fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)

    requires
        N > 0,
        old(a).len() == N,
        old(sum).len() == 1,

    ensures
        sum[0] <= N,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVJ01,0.85
VJ0003,verus,verified_cogen,proofsynthesis_brs2,,,"use vstd::prelude::*;

verus!{",,"fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32) 

	requires 
		old(a).len() == N,
		old(sum).len() == 1,
		N > 0,
		N < 1000,

	ensures
		sum[0] <= 2 * N,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVJ01,0.85
VJ0004,verus,verified_cogen,proofsynthesis_brs3,,,"use vstd::prelude::*;

verus!{",,"fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32) 

	requires 
		old(a).len() == N,
		old(sum).len() == 1,
		N > 0,
		N < 1000,

	ensures
		sum[0] <= 3 * N,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVJ03,0.85
VJ0005,verus,verified_cogen,proofsynthesis_brs4,,,"use vstd::prelude::*;

verus!{",,"fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32) 

	requires 
		old(a).len() == N,
		old(sum).len() == 1,
		N > 0,
		N < 1000,

	ensures
		sum[0] <= 4 * N,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVJ01,0.85
VJ0006,verus,verified_cogen,proofsynthesis_brs5,,,"use vstd::prelude::*;

verus!{",,"fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32) 

	requires 
		old(a).len() == N,
		old(sum).len() == 1,
		N > 0,
		N < 1000,

	ensures
		sum[0] <= 5 * N,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVJ03,0.85
VJ0007,verus,verified_cogen,proofsynthesis_bubble_v1,,,"use vstd::prelude::*;

verus! {

spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> (result:bool) {
        forall |i: int, j:int|  from <= i < j < to ==> a[i] <= a[j]
    }

spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> (result:bool) {
    &&& r.len() == s.len()
    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()
    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]
    &&& p =~= r.map_values(|i: int| s[i])
}",,"fn test1(nums: &mut Vec<u32>)

        ensures
            sorted_between(nums@, 0, nums@.len() as int),
            exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0008,verus,verified_cogen,proofsynthesis_bubble_v2,,,"use vstd::prelude::*;

verus! {

spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> (result:bool) {
    forall |i: int, j:int|  from <= i < j < to ==> a[i] <= a[j]
}

spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> (result:bool) {
    &&& r.len() == s.len()
    &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()
    &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]
    &&& p =~= r.map_values(|i: int| s[i])
}",,"fn test1(nums: &mut Vec<u32>)

    ensures
        sorted_between(nums@, 0, nums@.len() as int),
        exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0009,verus,verified_cogen,proofsynthesis_cell_2_sum,,,"use vstd::prelude::*;

verus!{",,"fn myfun(a: &mut Vec<u32>, N: u32) -> (sum: u32)

    requires 
        old(a).len() == N,
        N <= 0x7FFF_FFFF,

    ensures
        sum <= 2*N,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0010,verus,verified_cogen,proofsynthesis_choose_odd,,,"use vstd::prelude::*;

verus!{",,"fn choose_odd(v: &Vec<u64>) -> (odd_index: usize)

    requires    
        exists |q:int| 0 <= q < v.len() && v[q] % 2 == 1,

    ensures
        odd_index < v.len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0011,verus,verified_cogen,proofsynthesis_conda,,,"use vstd::prelude::*;

verus!{",,"fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)

	requires
		N > 0,
		old(a).len() == N,
		old(sum).len() == 1,
		N < 1000,

	ensures
		sum[0] == 2 * N,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVJ01,0.85
VJ0012,verus,verified_cogen,proofsynthesis_condg,,,"use vstd::prelude::*;

verus!{",,"fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)

	requires
		N > 0,
		old(a).len() == N,
		old(sum).len() == 1,

	ensures
		forall |k:int| 0 <= k < N ==> a[k] == 0,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0013,verus,verified_cogen,proofsynthesis_conditional_average,,,"use vstd::prelude::*;

verus!{",,"fn conditional_average(vals_1: &Vec<u64>, vals_2: &Vec<u64>, conds_1: &Vec<bool>, conds_2: &Vec<bool>, avgs: &mut Vec<u64>) 

    requires 
        vals_1.len() == vals_2.len(),
        vals_1.len() == conds_1.len(),
        vals_1.len() == conds_2.len(),
        forall |idx:int| 0 <= idx < vals_1.len() ==> conds_1[idx] || conds_2[idx],
        forall |idx:int| 0 <= idx < vals_1.len() ==> vals_1[idx] < 1000,
        forall |idx:int| 0 <= idx < vals_2.len() ==> vals_2[idx] < 1000,

    ensures
        avgs.len() == vals_1.len(),
        forall |idx:int| 0 <= idx < vals_1.len() ==> (
            (conds_1[idx] && conds_2[idx] ==> avgs[idx] == (vals_1[idx] + vals_2[idx]) / 2) &&
            (conds_1[idx] && !conds_2[idx] ==> avgs[idx] == vals_1[idx]) &&
            (!conds_1[idx] && conds_2[idx] ==> avgs[idx] == vals_2[idx])
        )","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0014,verus,verified_cogen,proofsynthesis_condm,,,"use vstd::prelude::*;

verus!{",,"fn myfun(a: &mut Vec<i32>, N: u32)

		requires
			N > 0,
			old(a).len() == N,

		ensures
			forall |k:int| 0 <= k < N ==> a[k] % 2 == N % 2,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVJ04,0.85
VJ0015,verus,verified_cogen,proofsynthesis_condn,,,"use vstd::prelude::*;

verus!{",,"fn myfun(a: &mut Vec<i32>, N: i32, m: i32)

	requires
		N > 0,
		old(a).len() == N,

	ensures
		forall |k:int| 0 <= k < N ==> a[k] <= N,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0016,verus,verified_cogen,proofsynthesis_fib,,,"use vstd::prelude::*;

verus! {

spec fn fibo(n: int) -> (result:nat)
    decreases n
{
    if n <= 0 { 0 } else if n == 1 { 1 }
    else { fibo(n - 2) + fibo(n - 1) }
}

spec fn fibo_fits_i32(n: int) -> (result:bool) {
    fibo(n) < 0x8000_0000
}",,"fn fibonacci(n: usize) -> (ret: Vec<i32>)

    requires
        fibo_fits_i32(n as int),
        n >= 2,

    ensures
        forall |i: int| 2 <= i < n ==> #[trigger] ret@[i] ==  fibo(i), 
        ret@.len() == n,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0017,verus,verified_cogen,proofsynthesis_filter,,,"use vstd::prelude::*;

verus!{",,"fn myfun4(x: &Vec<u64>, y: &mut Vec<u64>)

    requires 
        old(y).len() == 0,

    ensures 
        y@ == x@.filter(|k:u64| k%3 == 0),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVJ00,0.85
VJ0018,verus,verified_cogen,proofsynthesis_filter_v2,,,"use vstd::prelude::*;

verus!{",,"fn myfun4(x: &Vec<u64>, y: &mut Vec<u64>)

    requires 
        old(y).len() == 0,

    ensures 
        y@ == x@.filter(|k:u64| k%3 == 0),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVJ00,0.85
VJ0019,verus,verified_cogen,proofsynthesis_filter_weak,,,"use vstd::prelude::*;

verus!{",,"fn myfun4(x: &Vec<u64>, y: &mut Vec<u64>)

    requires 
        old(y).len() == 0,

    ensures 
        forall |k:int| 0 <= k < y.len() ==> y[k] % 3 == 0 && x@.contains(y@[k]),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVJ00,0.85
VJ0020,verus,verified_cogen,proofsynthesis_findmax,,,"#[allow(unused_imports)]
use vstd::prelude::*;

verus! {",,"fn find_max(nums: Vec<i32>) -> (ret:i32)

    requires
        nums.len() > 0,

    ensures
        forall |i: int| 0 <= i < nums@.len() ==> nums@[i] <= ret,
        exists |i: int| 0 <= i < nums@.len() ==> nums@[i] == ret,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0021,verus,verified_cogen,proofsynthesis_linearsearch,,,"#[allow(unused_imports)]
use vstd::prelude::*;

verus! {",,"fn linear_search(nums: Vec<i32>, target: i32) -> (ret: i32)

    requires
        nums@.len() < 0x8000_0000,

    ensures
        ret < nums@.len(),
        ret >=0 ==> nums@[ret as int] == target,
        ret >=0 ==> forall |i: int| 0 <= i < ret as int ==> #[trigger]nums@[i]!= target,
        ret < 0 ==> forall |i: int| 0 <= i < nums@.len() as int ==> #[trigger]nums@[i] != target,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0022,verus,verified_cogen,proofsynthesis_map,,,"use vstd::prelude::*;

verus!{",,"fn myfun2(x: &mut Vec<i32>) 

    requires 
        forall |k:int| 0 <= k < old(x).len() ==> old(x)[k] <= 0x7FFF_FFFB,

    ensures 
        x@.len() == old(x)@.len(),
        forall |k:int| 0 <= k < x.len() ==> #[trigger] x@[k] == old(x)@[k] + 4,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVJ04,0.85
VJ0023,verus,verified_cogen,proofsynthesis_max_index,,,"use vstd::prelude::*;

verus! {",,"fn myfun1(x: &Vec<i32>) -> (max_index: usize)

    requires
        x.len() >= 1,

    ensures
        forall|k: int| 0 <= k < x.len() ==> x[max_index as int] >= x[k],
        max_index < x.len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0024,verus,verified_cogen,proofsynthesis_ms1,,,"use vstd::prelude::*;

verus!{",,"fn myfun(a: &mut Vec<usize>, sum: &mut Vec<usize>, N: usize) 

	requires 
		old(a).len() == N,
		old(sum).len() == 1,
		N > 0,

	ensures
		sum[0] == 0,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVJ03,0.85
VJ0025,verus,verified_cogen,proofsynthesis_ms2,,,"use vstd::prelude::*;

verus!{",,"fn myfun(a: &mut Vec<usize>, sum: &mut Vec<usize>, N: usize) 

	requires 
		old(a).len() == N,
		old(sum).len() == 1,
		N > 0,

	ensures
		sum[0] <= N,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVJ03,0.85
VJ0026,verus,verified_cogen,proofsynthesis_ms3,,,"use vstd::prelude::*;

verus!{",,"fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32) 

	requires 
		old(a).len() == N,
		old(sum).len() == 1,
		N > 0,
		N < 1000,

	ensures
		sum[0] <= 2 * N,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVJ01,0.85
VJ0027,verus,verified_cogen,proofsynthesis_ms4,,,"use vstd::prelude::*;

verus!{",,"fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32) 

	requires 
		old(a).len() == N,
		old(sum).len() == 1,
		N > 0,
		N < 1000,

	ensures
		sum[0] <= 3 * N,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVJ01,0.85
VJ0028,verus,verified_cogen,proofsynthesis_ms5,,,"use vstd::prelude::*;

verus!{",,"fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32) 

	requires 
		old(a).len() == N,
		old(sum).len() == 1,
		N > 0,
		N < 1000,

	ensures
		sum[0] <= 4 * N,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVJ01,0.85
VJ0029,verus,verified_cogen,proofsynthesis_remove_all_greater,,,"use vstd::prelude::*;

verus!{",,"fn remove_all_greater(v: Vec<i32>, e: i32) -> (result: Vec<i32>)

    requires 
        forall |k1:int,k2:int| 0 <= k1 < k2 < v.len() ==> v[k1] != v[k2],

    ensures
        forall |k:int| 0 <= k < result.len() ==> result[k] <= e && v@.contains(result[k]),
        forall |k:int| 0 <= k < v.len() && v[k] <= e ==> result@.contains(v[k]),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0030,verus,verified_cogen,proofsynthesis_remove_all_greater_v2,,,"use vstd::prelude::*;

verus!{",,"fn remove_all_greater(v: Vec<i32>, e: i32) -> (result: Vec<i32>)

    requires 
        forall |k1:int,k2:int| 0 <= k1 < k2 < v.len() ==> v[k1] != v[k2],

    ensures
        forall |k:int| 0 <= k < result.len() ==> result[k] <= e && v@.contains(result[k]),
        forall |k:int| 0 <= k < v.len() && v[k] <= e ==> result@.contains(v[k]),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0031,verus,verified_cogen,proofsynthesis_res1,,,"use vstd::prelude::*;

verus!{",,"fn myfun(a: &mut Vec<i32>, b: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)

	requires
		N > 0,
		old(a).len() == N,
		old(b).len() == N,
		old(sum).len() == 1,
        N < 1000,

	ensures
		sum[0] <= 2 * N,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVJ01,0.85
VJ0032,verus,verified_cogen,proofsynthesis_res1o,,,"use vstd::prelude::*;

verus!{",,"fn myfun(a: &mut Vec<i32>, b: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)

	requires
		N > 0,
		old(a).len() == N,
		old(b).len() == N,
		old(sum).len() == 1,
		N < 1000,

	ensures
		sum[0] <= 2 * N,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVJ01,0.85
VJ0033,verus,verified_cogen,proofsynthesis_res2o,,,"use vstd::prelude::*;

verus!{",,"fn myfun(a: &mut Vec<i32>, b: &mut Vec<i32>, c: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)

	requires
		N > 0,
		old(a).len() == N,
		old(b).len() == N,
		old(c).len() == N,
		old(sum).len() == 1,
		N < 1000,

	ensures
		sum[0] <= 3 * N,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVJ01,0.85
VJ0034,verus,verified_cogen,proofsynthesis_s1if,,,"use vstd::prelude::*;

verus!{",,"fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)

	requires
		N > 0,
		old(a).len() == N,
		old(sum).len() == 1,

	ensures
		sum[0] == N,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVJ01,0.85
VJ0035,verus,verified_cogen,proofsynthesis_s1lif,,,"use vstd::prelude::*;

verus!{",,"fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)

	requires
		N > 0,
		old(a).len() == N,
		old(sum).len() == 1,
		N < 1000,

	ensures
		sum[0] == 2 * N,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVJ01,0.85
VJ0036,verus,verified_cogen,proofsynthesis_s2if,,,"use vstd::prelude::*;

verus!{",,"fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)

	requires
		N > 0,
		old(a).len() == N,
		old(sum).len() == 1,
		N < 1000,

	ensures
		sum[0] == 2 * N,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVJ01,0.85
VJ0037,verus,verified_cogen,proofsynthesis_s2lif,,,"use vstd::prelude::*;

verus!{",,"pub fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)

	requires
		N > 0,
		old(a).len() == N,
		old(sum).len() == 1,
		N < 1000,

	ensures
		sum[0] == 3 * N,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0038,verus,verified_cogen,proofsynthesis_s3if,,,"use vstd::prelude::*;

verus!{",,"fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)

    requires
        N > 0,
        old(a).len() == N,
        old(sum).len() == 1,
        N < 1000,

    ensures
        sum[0] == 3 * N,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVJ01,0.85
VJ0039,verus,verified_cogen,proofsynthesis_s3lif,,,"use vstd::prelude::*;

verus!{",,"fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)

    requires
        N > 0,
        old(a).len() == N,
        old(sum).len() == 1,
        N < 1000,

    ensures
        sum[0] == 4 * N,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVJ01,0.85
VJ0040,verus,verified_cogen,proofsynthesis_s4if,,,"use vstd::prelude::*;

verus!{",,"fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)

    requires
        N > 0,
        old(a).len() == N,
        old(sum).len() == 1,
        N < 1000,

    ensures
        sum[0] == 4 * N,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVJ01,0.85
VJ0041,verus,verified_cogen,proofsynthesis_s4lif,,,"use vstd::prelude::*;

verus!{",,"fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)

    requires
        N > 0,
        old(a).len() == N,
        old(sum).len() == 1,
        N < 1000,

    ensures
        sum[0] == 5 * N,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVJ01,0.85
VJ0042,verus,verified_cogen,proofsynthesis_s5if,,,"use vstd::prelude::*;

verus!{",,"fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)

	requires
		N > 0,
		old(a).len() == N,
		old(sum).len() == 1,
		N < 1000,

	ensures
		sum[0] == 5 * N,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVJ01,0.85
VJ0043,verus,verified_cogen,proofsynthesis_s5lif,,,"use vstd::prelude::*;

verus!{",,"fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)

	requires
		N > 0,
		old(a).len() == N,
		old(sum).len() == 1,
		N < 1000,

	ensures
		sum[0] == 6 * N,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVJ01,0.85
VJ0044,verus,verified_cogen,proofsynthesis_s12if,,,"use vstd::prelude::*;

verus!{",,"fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: usize)

	requires
		N > 0,
		old(a).len() == N,
		old(sum).len() == 1,
		N < 1000,

	ensures
		sum[0] == 2 * N,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVJ01,0.85
VJ0045,verus,verified_cogen,proofsynthesis_s22if,,,"use vstd::prelude::*;

verus!{",,"fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: usize)

	requires
		N > 0,
		old(a).len() == N,
		old(sum).len() == 1,
		N < 1000,

	ensures
		sum[0] == 3 * N,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVJ03,0.85
VJ0046,verus,verified_cogen,proofsynthesis_s32if,,,"use vstd::prelude::*;

verus!{",,"fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: usize)

	requires
		N > 0,
		old(a).len() == N,
		old(sum).len() == 1,
		N < 1000,

	ensures
		sum[0] == 4 * N,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVJ01,0.85
VJ0047,verus,verified_cogen,proofsynthesis_s42if,,,"use vstd::prelude::*;

verus!{",,"fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: usize)

	requires
		N > 0,
		old(a).len() == N,
		old(sum).len() == 1,
		N < 1000,

	ensures
		sum[0] == 5 * N,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVJ03,0.85
VJ0048,verus,verified_cogen,proofsynthesis_s52if,,,"use vstd::prelude::*;

verus!{",,"fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: usize)

	requires
		N > 0,
		old(a).len() == N,
		old(sum).len() == 1,
		N < 1000,

	ensures
		sum[0] == 6 * N,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVJ03,0.85
VJ0049,verus,verified_cogen,proofsynthesis_simple_nested,,,"use vstd::prelude::*;

verus!{",,"fn simple_nested(a: &mut Vec<i32>, b: &Vec<i32>, N: i32) -> (sum: i32)

    requires 
        forall |k:int| k <= #[trigger] b[k] <= k + 1,
        old(a).len() == N,
        b.len() == N,
        N <= 0x3FFF_FFFF,

    ensures
        N <= sum <= 2*N,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0050,verus,verified_cogen,proofsynthesis_sina1,,,"use vstd::prelude::*;

verus!{",,"fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)

	requires
		N > 0,
		old(a).len() == N,
		old(sum).len() == 1,

	ensures
		forall |k:int| 0 <= k < N ==> a[k] == N,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0051,verus,verified_cogen,proofsynthesis_sina2,,,"use vstd::prelude::*;

verus!{",,"fn myfun(a: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)

	requires
		N > 0,
		old(a).len() == N,
		old(sum).len() == 1,
		N < 1000,

	ensures
		forall |k:int| 0 <= k < N ==> a[k] == N + 1,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0052,verus,verified_cogen,proofsynthesis_sina3,,,"use vstd::prelude::*;

verus!{",,"fn myfun(a: &mut Vec<i32>, b: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)

	requires
		N > 0,
		old(a).len() == N,
		old(b).len() == N,
		old(sum).len() == 1,
		N < 1000,

	ensures
		forall |k:int| 0 <= k < N ==> a[k] == N + 1,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0053,verus,verified_cogen,proofsynthesis_sina4,,,"use vstd::prelude::*;

verus!{",,"fn myfun(a: &mut Vec<i32>, b: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)

	requires
		N > 0,
		old(a).len() == N,
		old(b).len() == N,
		old(sum).len() == 1,
		N < 1000,

	ensures
		forall |k:int| 0 <= k < N ==> b[k] == N + 2,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0054,verus,verified_cogen,proofsynthesis_sina5,,,"use vstd::prelude::*;

verus!{",,"fn myfun(a: &mut Vec<i32>, b: &mut Vec<i32>, sum: &mut Vec<i32>, N: i32)

	requires
		N > 0,
		old(a).len() == N,
		old(b).len() == N,
		old(sum).len() == 1,
		N < 1000,

	ensures
		forall |k:int| 0 <= k < N ==> a[k] == 2 * N + 1,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0055,verus,verified_cogen,proofsynthesis_tail_triangle,,,"use vstd::prelude::*;

verus!{

spec fn triangle(n: nat) -> (result: nat)
    decreases n
{
    if n == 0 {
        0
    } else {
        n + triangle((n - 1) as nat)
    }
}",,"fn tail_triangle(n: u32, idx: u32, sum: &mut u32)

    requires
        idx <= n,
        *old(sum) == triangle(idx as nat),
        triangle(n as nat) < 0x1_0000_0000,

    ensures
        *sum == triangle(n as nat),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0056,verus,verified_cogen,proofsynthesis_task_id_2,,,"use vstd::prelude::*;

verus! {",,"fn shared_elements(list1: &Vec<i32>, list2: &Vec<i32>) -> (shared: Vec<i32>)

    ensures
        forall|i: int|
            0 <= i < shared.len() ==> (list1@.contains(#[trigger] shared[i]) && list2@.contains(
                #[trigger] shared[i],
            )),
        forall|i: int, j: int| 0 <= i < j < shared.len() ==> shared[i] != shared[j],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0057,verus,verified_cogen,proofsynthesis_task_id_3,,,"use vstd::prelude::*;

verus! {

spec fn is_divisible(n: int, divisor: int) -> bool {
    (n % divisor) == 0
}",,"fn is_non_prime(n: u64) -> (result: bool)

    requires
        n >= 2,

    ensures
        result == (exists|k: int| 2 <= k < n && is_divisible(n as int, k)),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0058,verus,verified_cogen,proofsynthesis_task_id_8,,,"use vstd::prelude::*;

verus! {",,"fn square_nums(nums: &Vec<i32>) -> (squared: Vec<i32>)

    requires
        forall|k: int|
            0 <= k < nums.len() ==> (0 <= #[trigger] nums[k] * #[trigger] nums[k] < i32::MAX),

    ensures
        nums.len() == squared.len(),
        forall|k: int| 0 <= k < nums.len() ==> (#[trigger] squared[k] == nums[k] * nums[k]),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0059,verus,verified_cogen,proofsynthesis_task_id_18,,,"use vstd::prelude::*;

verus! {",,"fn remove_chars(str1: &Vec<char>, str2: &Vec<char>) -> (result: Vec<char>)

    ensures
        forall|i: int|
            0 <= i < result.len() ==> (str1@.contains(#[trigger] result[i]) && !str2@.contains(
                #[trigger] result[i],
            )),
        forall|i: int|
            0 <= i < str1.len() ==> (str2@.contains(#[trigger] str1[i]) || result@.contains(
                #[trigger] str1[i],
            )),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0060,verus,verified_cogen,proofsynthesis_task_id_62,,,"use vstd::prelude::*;

verus! {",,"fn smallest_num(nums: &Vec<i32>) -> (min: i32)

    requires
        nums.len() > 0,

    ensures
        forall|i: int| 0 <= i < nums.len() ==> min <= nums[i],
        exists|i: int| 0 <= i < nums.len() && min == nums[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0061,verus,verified_cogen,proofsynthesis_task_id_69,,,"use vstd::prelude::*;

verus! {",,"fn is_sub_list(main: &Vec<i32>, sub: &Vec<i32>) -> (result: bool)

    requires
        sub.len() <= main.len(),

    ensures
        result == (exists|k: int, l: int|
            0 <= k <= (main.len() - sub.len()) && l == k + sub.len() && (#[trigger] (main@.subrange(
                k,
                l,
            ))) =~= sub@),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVJ02,0.85
VJ0062,verus,verified_cogen,proofsynthesis_task_id_70,,,"use vstd::prelude::*;

verus! {",,"fn all_sequence_equal_length(seq: &Vec<Vec<i32>>) -> (result: bool)

    requires
        seq.len() > 0,

    ensures
        result == (forall|i: int, j: int|
            (0 <= i < seq.len() && 0 <= j < seq.len()) ==> (#[trigger] seq[i].len()
                == #[trigger] seq[j].len())),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0063,verus,verified_cogen,proofsynthesis_task_id_94,,,"use vstd::prelude::*;

verus! {",,"fn min_second_value_first(arr: &Vec<Vec<i32>>) -> (first_of_min_second: i32)

    requires
        arr.len() > 0,
        forall|i: int| 0 <= i < arr.len() ==> #[trigger] arr[i].len() >= 2,

    ensures
        exists|i: int|
            0 <= i < arr.len() && first_of_min_second == #[trigger] arr[i][0] && (forall|j: int|
                0 <= j < arr.len() ==> (arr[i][1] <= #[trigger] arr[j][1])),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0064,verus,verified_cogen,proofsynthesis_task_id_95,,,"use vstd::prelude::*;

verus! {",,"fn smallest_list_length(list: &Vec<Vec<i32>>) -> (min: usize)

    requires
        list.len() > 0,

    ensures
        min >= 0,
        forall|i: int| 0 <= i < list.len() ==> min <= #[trigger] list[i].len(),
        exists|i: int| 0 <= i < list.len() && min == #[trigger] list[i].len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0065,verus,verified_cogen,proofsynthesis_task_id_105,,,"use vstd::prelude::*;

verus! {

spec fn count_boolean(seq: Seq<bool>) -> (result: int)
    decreases seq.len(),
{
    if seq.len() == 0 {
        0
    } else {
        count_boolean(seq.drop_last()) + if (seq.last()) {
            1 as int
        } else {
            0 as int
        }
    }
}",,"fn count_true(arr: &Vec<bool>) -> (count: u64)

    ensures
        0 <= count <= arr.len(),
        count_boolean(arr@) == count,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0066,verus,verified_cogen,proofsynthesis_task_id_113,,,"use vstd::prelude::*;

verus! {

spec fn is_digit_sepc(c: char) -> (res: bool) {
    (c as u32) >= 48 && (c as u32) <= 57
}",,"fn is_integer(text: &Vec<char>) -> (result: bool)

    ensures
        result == (forall|i: int| 0 <= i < text.len() ==> (#[trigger] is_digit_sepc(text[i]))),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0067,verus,verified_cogen,proofsynthesis_task_id_133,,,"use vstd::prelude::*;

verus! {

spec fn sum_negative_to(seq: Seq<i64>) -> (res: int)
    decreases seq.len(),
{
    if seq.len() == 0 {
        0
    } else {
        sum_negative_to(seq.drop_last()) + if (seq.last() < 0) {
            seq.last() as int
        } else {
            0 as int
        }
    }
}",,"fn sum_negatives(arr: &Vec<i64>) -> (sum_neg: i128)

    ensures
        sum_negative_to(arr@) == sum_neg,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0068,verus,verified_cogen,proofsynthesis_task_id_142,,,"use vstd::prelude::*;

verus! {

spec fn count_identical(s1: Seq<i32>, s2: Seq<i32>, s3: Seq<i32>) -> (result: int)
    decreases s1.len(), s2.len(), s3.len(),
{
    if s1.len() == 0 || s2.len() == 0 || s3.len() == 0 {
        0
    } else {
        count_identical(s1.drop_last(), s2.drop_last(), s3.drop_last()) + if (s1.last() == s2.last()
            && s2.last() == s3.last()) {
            1 as int
        } else {
            0 as int
        }
    }
}",,"fn count_identical_position(arr1: &Vec<i32>, arr2: &Vec<i32>, arr3: &Vec<i32>) -> (count: usize)

    requires
        arr1.len() == arr2.len() && arr2.len() == arr3.len(),

    ensures
        0 <= count <= arr1.len(),
        count_identical(arr1@, arr2@, arr3@) == count,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0069,verus,verified_cogen,proofsynthesis_task_id_145,,,"use vstd::prelude::*;

verus! {",,"fn max_difference(arr: &Vec<i32>) -> (diff: i32)

    requires
        arr.len() > 0,
        forall|i: int| 0 <= i < arr.len() ==> i32::MIN / 2 < #[trigger] arr[i] < i32::MAX / 2,

    ensures
        forall|i: int, j: int| 0 <= i < arr.len() && 0 <= j < arr.len() ==> arr[i] - arr[j] <= diff,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0070,verus,verified_cogen,proofsynthesis_task_id_161,,,"use vstd::prelude::*;

verus! {",,"fn remove_elements(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)

    ensures
        forall|i: int|
            0 <= i < result.len() ==> (arr1@.contains(#[trigger] result[i]) && !arr2@.contains(
                #[trigger] result[i],
            )),
        forall|i: int|
            0 <= i < arr1.len() ==> (arr2@.contains(#[trigger] arr1[i]) || result@.contains(
                #[trigger] arr1[i],
            )),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0071,verus,verified_cogen,proofsynthesis_task_id_170,,,"use vstd::prelude::*;

verus! {

spec fn sum_to(arr: Seq<i64>) -> (result: int)
    decreases arr.len(),
{
    if arr.len() == 0 {
        0
    } else {
        sum_to(arr.drop_last()) + arr.last()
    }
}",,"fn sum_range_list(arr: &Vec<i64>, start: usize, end: usize) -> (sum: i128)

    requires
        0 <= start <= end,
        start <= end < arr.len(),

    ensures
        sum_to(arr@.subrange(start as int, end + 1 as int)) == sum,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0072,verus,verified_cogen,proofsynthesis_task_id_230,,,"use vstd::prelude::*;

verus! {

spec fn inner_expr_replace_blanks_with_chars(str1: &Vec<char>, ch: char, i: int) -> (result: char) {
    if str1[i] == 32 {
        ch
    } else {
        str1[i]
    }
}",,"fn replace_blanks_with_chars(str1: &Vec<char>, ch: char) -> (result: Vec<char>)

    ensures
        str1@.len() == result@.len(),
        forall|i: int|
            0 <= i < str1.len() ==> result[i] == inner_expr_replace_blanks_with_chars(str1, ch, i),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0073,verus,verified_cogen,proofsynthesis_task_id_240,,,"use vstd::prelude::*;

verus! {",,"fn replace_last_element(first: &Vec<i32>, second: &Vec<i32>) -> (replaced_list: Vec<i32>)

    requires
        first.len() > 0,

    ensures
        replaced_list@ == first@.subrange(0, first.len() - 1).add(second@),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0074,verus,verified_cogen,proofsynthesis_task_id_249,,,"use vstd::prelude::*;

verus! {",,"fn intersection(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)

    ensures
        forall|i: int|
            0 <= i < result.len() ==> (arr1@.contains(#[trigger] result[i]) && arr2@.contains(
                #[trigger] result[i],
            )),
        forall|i: int, j: int| 0 <= i < j < result.len() ==> result[i] != result[j],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0075,verus,verified_cogen,proofsynthesis_task_id_251,,,"use vstd::prelude::*;

verus! {",,"fn insert_before_each(arr: &Vec<i32>, elem: i32) -> (result: Vec<i32>)

    ensures
        result@.len() == (2 * arr.len()),
        forall|k: int| 0 <= k < arr.len() ==> #[trigger] result[2 * k] == elem,
        forall|k: int| 0 <= k < arr.len() ==> #[trigger] result[2 * k + 1] == arr[k],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0076,verus,verified_cogen,proofsynthesis_task_id_261,,,"use vstd::prelude::*;

verus! {",,"fn element_wise_division(arr1: &Vec<u32>, arr2: &Vec<u32>) -> (result: Vec<u32>)

    requires
        arr1.len() == arr2.len(),
        forall|i: int| 0 <= i < arr2.len() ==> arr2[i] != 0,
        forall|m: int|
            0 <= m < arr1.len() ==> (u32::MIN <= #[trigger] arr1[m] / #[trigger] arr2[m]
                <= u32::MAX),

    ensures
        result.len() == arr1.len(),
        forall|i: int|
            0 <= i < result.len() ==> #[trigger] result[i] == #[trigger] (arr1[i] / arr2[i]),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0077,verus,verified_cogen,proofsynthesis_task_id_262,,,"use vstd::prelude::*;

verus! {",,"fn split_array(list: &Vec<i32>, l: usize) -> (new_list: (Vec<i32>, Vec<i32>))

    requires
        list@.len() > 0,
        0 < l < list@.len(),

    ensures
        new_list.0@ == list@.subrange(0, l as int),
        new_list.1@ == list@.subrange(l as int, list.len() as int),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0078,verus,verified_cogen,proofsynthesis_task_id_273,,,"use vstd::prelude::*;

verus! {",,"fn element_wise_subtract(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)

    requires
        arr1.len() == arr2.len(),
        forall|i: int|
            (0 <= i < arr1.len()) ==> (i32::MIN <= #[trigger] (arr1[i] - arr2[i]) <= i32::MAX),

    ensures
        result.len() == arr1.len(),
        forall|i: int|
            0 <= i < result.len() ==> #[trigger] result[i] == #[trigger] (arr1[i] - arr2[i]),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0079,verus,verified_cogen,proofsynthesis_task_id_282,,,"use vstd::prelude::*;

verus! {",,"fn element_wise_subtract(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)

    requires
        arr1.len() == arr2.len(),
        forall|i: int|
            (0 <= i < arr1.len()) ==> (i32::MIN <= #[trigger] (arr1[i] - arr2[i]) <= i32::MAX),

    ensures
        result.len() == arr1.len(),
        forall|i: int|
            0 <= i < result.len() ==> #[trigger] result[i] == #[trigger] (arr1[i] - arr2[i]),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0080,verus,verified_cogen,proofsynthesis_task_id_284,,,"use vstd::prelude::*;

verus! {",,"fn all_elements_equals(arr: &Vec<i32>, element: i32) -> (result: bool)

    ensures
        result == (forall|i: int| 0 <= i < arr.len() ==> (arr[i] == element)),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0081,verus,verified_cogen,proofsynthesis_task_id_307,,,"use vstd::prelude::*;

verus! {",,"fn list_deep_clone(arr: &Vec<u64>) -> (copied: Vec<u64>)

    ensures
        arr@.len() == copied@.len(),
        forall|i: int| (0 <= i < arr.len()) ==> arr[i] == copied[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0082,verus,verified_cogen,proofsynthesis_task_id_399,,,"use vstd::prelude::*;

verus! {",,"fn bit_wise_xor(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)

    requires
        arr1.len() == arr2.len(),

    ensures
        result.len() == arr1.len(),
        forall|i: int|
            0 <= i < result.len() ==> result[i] == #[trigger] arr1[i] ^ #[trigger] arr2[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0083,verus,verified_cogen,proofsynthesis_task_id_412,,,"use vstd::prelude::*;

verus! {",,"fn remove_odds(arr: &Vec<u32>) -> (even_list: Vec<u32>)

    ensures
        even_list@ == arr@.filter(|x: u32| x % 2 == 0),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0084,verus,verified_cogen,proofsynthesis_task_id_414,,,"use vstd::prelude::*;

verus! {",,"fn any_value_exists(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: bool)

    ensures
        result == exists|k: int| 0 <= k < arr1.len() && arr2@.contains(#[trigger] arr1[k]),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0085,verus,verified_cogen,proofsynthesis_task_id_424,,,"use vstd::prelude::*;

verus! {",,"fn extract_rear_chars(s: &Vec<Vec<char>>) -> (result: Vec<char>)

    requires
        forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i].len() > 0,

    ensures
        s.len() == result.len(),
        forall|i: int| 0 <= i < s.len() ==> result[i] == #[trigger] s[i][s[i].len() - 1],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0086,verus,verified_cogen,proofsynthesis_task_id_426,,,"use vstd::prelude::*;

verus! {",,"fn filter_odd_numbers(arr: &Vec<u32>) -> (odd_list: Vec<u32>)

    ensures
        odd_list@ == arr@.filter(|x: u32| x % 2 != 0),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0087,verus,verified_cogen,proofsynthesis_task_id_431,,,"use vstd::prelude::*;

verus! {",,"fn has_common_element(list1: &Vec<i32>, list2: &Vec<i32>) -> (result: bool)

    ensures
        result == (exists|i: int, j: int|
            0 <= i < list1.len() && 0 <= j < list2.len() && (list1[i] == list2[j])),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0088,verus,verified_cogen,proofsynthesis_task_id_433,,,"use vstd::prelude::*;

verus! {",,"fn is_greater(arr: &Vec<i32>, number: i32) -> (result: bool)

    ensures
        result == (forall|i: int| 0 <= i < arr.len() ==> number > arr[i]),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0089,verus,verified_cogen,proofsynthesis_task_id_436,,,"use vstd::prelude::*;

verus! {",,"fn find_negative_numbers(arr: &Vec<i32>) -> (negative_list: Vec<i32>)

    ensures
        negative_list@ == arr@.filter(|x: i32| x < 0),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0090,verus,verified_cogen,proofsynthesis_task_id_445,,,"use vstd::prelude::*;

verus! {",,"fn element_wise_multiplication(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)

    requires
        arr1.len() == arr2.len(),
        forall|i: int|
            (0 <= i < arr1.len()) ==> (i32::MIN <= #[trigger] (arr1[i] * arr2[i]) <= i32::MAX),

    ensures
        result.len() == arr1.len(),
        forall|i: int|
            0 <= i < result.len() ==> #[trigger] result[i] == #[trigger] (arr1[i] * arr2[i]),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0091,verus,verified_cogen,proofsynthesis_task_id_447,,,"use vstd::prelude::*;

verus! {",,"fn cube_element(nums: &Vec<i32>) -> (cubed: Vec<i32>)

    requires
        forall|k: int|
            0 <= k < nums.len() ==> (i32::MIN <= #[trigger] nums[k] * #[trigger] nums[k]
                <= i32::MAX),
        forall|k: int|
            0 <= k < nums.len() ==> (i32::MIN <= #[trigger] nums[k] * #[trigger] nums[k]
                * #[trigger] nums[k] <= i32::MAX),

    ensures
        forall|i: int|
            0 <= i < nums.len() ==> cubed[i] == #[trigger] nums[i] * #[trigger] nums[i]
                * #[trigger] nums[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0092,verus,verified_cogen,proofsynthesis_task_id_454,,,"use vstd::prelude::*;

verus! {",,"fn contains_z(text: &Vec<char>) -> (result: bool)

    ensures
        result == (exists|i: int| 0 <= i < text.len() && (text[i] == 'Z' || text[i] == 'z')),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0093,verus,verified_cogen,proofsynthesis_task_id_460,,,"use vstd::prelude::*;

verus! {",,"fn get_first_elements(arr: &Vec<Vec<i32>>) -> (result: Vec<i32>)

    requires
        forall|i: int| 0 <= i < arr.len() ==> #[trigger] arr[i].len() > 0,

    ensures
        arr.len() == result.len(),
        forall|i: int| 0 <= i < arr.len() ==> #[trigger] result[i] == #[trigger] arr[i][0],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0094,verus,verified_cogen,proofsynthesis_task_id_461,,,"use vstd::prelude::*;

verus! {

spec fn is_lower_case(c: char) -> (result: bool) {
    (c as u32) >= 97 && (c as u32) <= 122
}

spec fn is_upper_case(c: char) -> (result: bool) {
    (c as u32) >= 65 && (c as u32) <= 90
}

spec fn count_uppercase_recursively(seq: Seq<char>) -> (result: int)
    decreases seq.len(),
{
    if seq.len() == 0 {
        0
    } else {
        count_uppercase_recursively(seq.drop_last()) + if is_upper_case(seq.last()) {
            1 as int
        } else {
            0 as int
        }
    }
}",,"fn count_uppercase(text: &Vec<char>) -> (count: u64)

    ensures
        0 <= count <= text.len(),
        count_uppercase_recursively(text@) == count,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0095,verus,verified_cogen,proofsynthesis_task_id_472,,,"use vstd::prelude::*;

verus! {",,"fn contains_consecutive_numbers(arr: &Vec<i32>) -> (is_consecutive: bool)

    requires
        arr.len() > 0,
        forall|i: int| 0 <= i < arr.len() ==> (0 <= #[trigger] arr[i] + 1 < i32::MAX),

    ensures
        is_consecutive == (forall|i: int, j: int|
            0 <= i < j < arr.len() && j == i + 1 ==> (arr[i] + 1 == arr[j])),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0096,verus,verified_cogen,proofsynthesis_task_id_474,,,"use vstd::prelude::*;

verus! {

spec fn inner_epxr_replace_chars(str1: &Vec<char>, old_char: char, new_char: char, i: int) -> (result: char) {
    if str1[i] == old_char {
        new_char
    } else {
        str1[i]
    }
}",,"fn replace_chars(str1: &Vec<char>, old_char: char, new_char: char) -> (result: Vec<char>)

    ensures
        str1@.len() == result@.len(),
        forall|i: int|
            0 <= i < str1.len() ==> result[i] == inner_epxr_replace_chars(str1, old_char, new_char, i),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0097,verus,verified_cogen,proofsynthesis_task_id_476,,,"#![verifier::loop_isolation(false)]
use vstd::math::*;
use vstd::prelude::*;

verus! {

spec fn max_rcur(seq: Seq<i32>) -> (result:int)
    decreases seq.len(),
{
    if seq.len() <= 1 {
        seq.first() as int
    } else {
        max(seq.last() as int, max_rcur(seq.drop_last()))
    }
}

spec fn min_rcur(seq: Seq<i32>) -> (result:int)
    decreases seq.len(),
{
    if seq.len() <= 1 {
        seq.first() as int
    } else {
        min(seq.last() as int, min_rcur(seq.drop_last()))
    }
}",,"fn sum_min_max(arr: &Vec<i32>) -> (sum: i32)

    requires
        arr.len() > 0,
        forall|i: int| 0 <= i < arr.len() ==> i32::MIN / 2 < #[trigger] arr[i] < i32::MAX / 2,

    ensures
        sum == max_rcur(arr@) + min_rcur(arr@),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0098,verus,verified_cogen,proofsynthesis_task_id_477,,,"use vstd::prelude::*;

verus! {

spec fn is_upper_case(c: char) -> (result:bool) {
    c >= 'A' && c <= 'Z'
}

spec fn shift32_spec(c: char) -> (result:char) {
    ((c as u8) + 32) as char
}",,"fn to_lowercase(str1: &Vec<char>) -> (result: Vec<char>)

    ensures
        str1@.len() == result@.len(),
        forall|i: int|
            0 <= i < str1.len() ==> result[i] == (if is_upper_case(#[trigger] str1[i]) {
                shift32_spec(str1[i])
            } else {
                str1[i]
            }),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0099,verus,verified_cogen,proofsynthesis_task_id_554,,,"use vstd::prelude::*;

verus! {",,"fn find_odd_numbers(arr: &Vec<u32>) -> (odd_numbers: Vec<u32>)

    ensures
        odd_numbers@ == arr@.filter(|x: u32| x % 2 != 0),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0100,verus,verified_cogen,proofsynthesis_task_id_557,,,"use vstd::prelude::*;

verus! {

spec fn is_upper_case(c: char) -> (result:bool) {
    c >= 'A' && c <= 'Z'
}

spec fn shift32_spec(c: char) -> (result:char) {
    ((c as u8) + 32) as char
}

spec fn is_lower_case(c: char) -> (result:bool) {
    c >= 'a' && c <= 'z'
}

spec fn shift_minus_32_spec(c: char) -> (result:char) {
    ((c as u8) - 32) as char
}

spec fn to_toggle_case_spec(s: char) -> (result:char) {
    if is_lower_case(s) {
        shift_minus_32_spec(s)
    } else if is_upper_case(s) {
        shift32_spec(s)
    } else {
        s
    }
}",,"fn to_toggle_case(str1: &Vec<char>) -> (toggle_case: Vec<char>)

    ensures
        str1@.len() == toggle_case@.len(),
        forall|i: int|
            0 <= i < str1.len() ==> toggle_case[i] == to_toggle_case_spec(#[trigger] str1[i]),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0101,verus,verified_cogen,proofsynthesis_task_id_567,,,"use vstd::prelude::*;

verus! {",,"fn is_sorted(arr: &Vec<i32>) -> (result: bool)

    requires
        arr.len() > 0,

    ensures
        result == (forall|i: int, j: int| 0 <= i < j < arr.len() ==> (arr[i] <= arr[j])),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0102,verus,verified_cogen,proofsynthesis_task_id_572,,,"use vstd::prelude::*;

verus! {

spec fn count_frequency_rcr(seq: Seq<i32>, key: i32) -> (result: int)
    decreases seq.len(),
{
    if seq.len() == 0 {
        0
    } else {
        count_frequency_rcr(seq.drop_last(), key) + if (seq.last() == key) {
            1 as int
        } else {
            0 as int
        }
    }
}",,"fn remove_duplicates(arr: &Vec<i32>) -> (unique_arr: Vec<i32>)

    ensures
        unique_arr@ == arr@.filter(|x: i32| count_frequency_rcr(arr@, x) == 1),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0103,verus,verified_cogen,proofsynthesis_task_id_576,,,"use vstd::prelude::*;

verus! {",,"fn is_sub_array(main: &Vec<i32>, sub: &Vec<i32>) -> (result: bool)

    requires
        sub.len() <= main.len(),

    ensures
        result == (exists|k: int, l: int|
            0 <= k <= (main.len() - sub.len()) && l == k + sub.len() && (#[trigger] (main@.subrange(
                k,
                l,
            ))) =~= sub@),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVJ02,0.85
VJ0104,verus,verified_cogen,proofsynthesis_task_id_576_v2,,,"use vstd::prelude::*;

verus! {

spec fn is_subrange_at(main: Seq<i32>, sub: Seq<i32>, i: int) -> (result: bool) {
    sub =~= main.subrange(i, i+sub.len())
}",,"fn is_sub_array(main: &Vec<i32>, sub: &Vec<i32>) -> (result: bool)

    ensures
        result == (exists|k: int|
            0 <= k <= (main.len() - sub.len()) && is_subrange_at(main@, sub@, k)),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVJ02,0.85
VJ0105,verus,verified_cogen,proofsynthesis_task_id_578,,,"use vstd::prelude::*;

verus! {",,"fn interleave(s1: &Vec<i32>, s2: &Vec<i32>, s3: &Vec<i32>) -> (res: Vec<i32>)

    requires
        s1@.len() == s2@.len() && s2@.len() == s3@.len(),
        0 <= (s1@.len() * 3) <= i32::MAX,

    ensures
        res@.len() == s1@.len() * 3,
        forall|i: int|
            0 <= i < s1@.len() ==> (res[3 * i] == s1[i] && res[3 * i + 1] == s2[i] && res[3 * i + 2]
                == s3[i]),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0106,verus,verified_cogen,proofsynthesis_task_id_579,,,"use vstd::prelude::*;

verus! {",,"fn find_dissimilar(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)

    ensures
        forall|i: int|
            0 <= i < arr1.len() ==> (!arr2@.contains(#[trigger] arr1[i]) ==> result@.contains(
                arr1[i],
            )),
        forall|i: int|
            0 <= i < arr2.len() ==> (!arr1@.contains(#[trigger] arr2[i]) ==> result@.contains(
                arr2[i],
            )),
        forall|i: int, j: int|
            0 <= i < j < result.len() ==> #[trigger] result[i] != #[trigger] result[j],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0107,verus,verified_cogen,proofsynthesis_task_id_586,,,"use vstd::prelude::*;

verus! {",,"fn split_and_append(list: &Vec<i32>, n: usize) -> (new_list: Vec<i32>)

    requires
        list@.len() > 0,
        0 < n < list@.len(),

    ensures
        new_list@ == list@.subrange(n as int, list@.len() as int).add(list@.subrange(0, n as int)),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0108,verus,verified_cogen,proofsynthesis_task_id_588,,,"#![verifier::loop_isolation(false)]
use vstd::math::*;
use vstd::prelude::*;

verus! {

spec fn max_rcur(seq: Seq<i32>) -> (result: int)
    decreases seq.len(),
{
    if seq.len() <= 1 {
        seq.first() as int
    } else {
        max(seq.last() as int, max_rcur(seq.drop_last()))
    }
}

spec fn min_rcur(seq: Seq<i32>) -> (result: int)
    decreases seq.len(),
{
    if seq.len() <= 1 {
        seq.first() as int
    } else {
        min(seq.last() as int, min_rcur(seq.drop_last()))
    }
}",,"fn difference_max_min(arr: &Vec<i32>) -> (diff: i32)

    requires
        arr.len() > 0,
        forall|i: int| 0 <= i < arr.len() ==> i32::MIN / 2 < #[trigger] arr[i] < i32::MAX / 2,

    ensures
        diff == max_rcur(arr@) - min_rcur(arr@),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0109,verus,verified_cogen,proofsynthesis_task_id_602,,,"use vstd::prelude::*;

verus! {

spec fn count_frequency_rcr(seq: Seq<char>, key: char) -> (result: int)
    decreases seq.len(),
{
    if seq.len() == 0 {
        0
    } else {
        count_frequency_rcr(seq.drop_last(), key) + if (seq.last() == key) {
            1 as int
        } else {
            0 as int
        }
    }
}
spec fn check_first_repeated_char(str1: &Vec<char>, repeated_char: Option<(usize, char)>) -> (res: bool) {
    if let Some((idx, rp_char)) = repeated_char {
        &&& str1@.take(idx as int) =~= str1@.take(idx as int).filter(
            |x: char| count_frequency_rcr(str1@, x) <= 1,
        )
        &&& count_frequency_rcr(str1@, rp_char) > 1
    } else {
        forall|k: int|
            0 <= k < str1.len() ==> count_frequency_rcr(str1@, #[trigger] str1[k]) <= 1
    }
}",,"fn first_repeated_char(str1: &Vec<char>) -> (repeated_char: Option<(usize, char)>)

    ensures
        check_first_repeated_char(str1, repeated_char),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0110,verus,verified_cogen,proofsynthesis_task_id_605,,,"use vstd::prelude::*;

verus! {

spec fn is_divisible(n: int, divisor: int) -> (result: bool) {
    (n % divisor) == 0
}",,"fn prime_num(n: u64) -> (result: bool)

    requires
        n >= 2,

    ensures
        result == (forall|k: int| 2 <= k < n ==> !is_divisible(n as int, k)),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0111,verus,verified_cogen,proofsynthesis_task_id_610,,,"use vstd::prelude::*;

verus! {",,"fn remove_kth_element(list: &Vec<i32>, k: usize) -> (new_list: Vec<i32>)

    requires
        list.len() > 0,
        0 < k < list@.len(),

    ensures
        new_list@ == list@.subrange(0, k - 1 as int).add(
            list@.subrange(k as int, list.len() as int),
        ),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0112,verus,verified_cogen,proofsynthesis_task_id_616,,,"use vstd::prelude::*;

verus! {",,"fn element_wise_module(arr1: &Vec<u32>, arr2: &Vec<u32>) -> (result: Vec<u32>)

    requires
        arr1.len() == arr2.len(),
        forall|i: int| 0 <= i < arr2.len() ==> arr2[i] != 0,
        forall|i: int|
            (0 <= i < arr1.len()) ==> (i32::MIN <= #[trigger] (arr1[i] % arr2[i]) <= i32::MAX),

    ensures
        result@.len() == arr1@.len(),
        forall|i: int|
            0 <= i < result.len() ==> #[trigger] result[i] == #[trigger] (arr1[i] % arr2[i]),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0113,verus,verified_cogen,proofsynthesis_task_id_618,,,"use vstd::prelude::*;

verus! {",,"fn element_wise_divide(arr1: &Vec<u32>, arr2: &Vec<u32>) -> (result: Vec<u32>)

    requires
        arr1.len() == arr2.len(),
        forall|i: int| 0 <= i < arr2.len() ==> arr2[i] != 0,
        forall|i: int|
            (0 <= i < arr1.len()) ==> (i32::MIN <= #[trigger] (arr1[i] / arr2[i]) <= i32::MAX),

    ensures
        result@.len() == arr1@.len(),
        forall|i: int|
            0 <= i < result.len() ==> #[trigger] result[i] == #[trigger] (arr1[i] / arr2[i]),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0114,verus,verified_cogen,proofsynthesis_task_id_624,,,"use vstd::prelude::*;

verus! {

spec fn is_lower_case(c: char) -> (result: bool) {
    c >= 'a' && c <= 'z'
}

spec fn shift_minus_32_spec(c: char) -> (result: char) {
    ((c as u8) - 32) as char
}

spec fn inner_expr_to_uppercase(str1: &Vec<char>, i: int) -> (result:char) {
    if is_lower_case(#[trigger] str1[i]) {
        shift_minus_32_spec(str1[i])
    } else {
        str1[i]
    }
}",,"fn to_uppercase(str1: &Vec<char>) -> (result: Vec<char>)

    ensures
        str1@.len() == result@.len(),
        forall|i: int|
            0 <= i < str1.len() ==> (result[i] == (inner_expr_to_uppercase(str1, i))),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0115,verus,verified_cogen,proofsynthesis_task_id_629,,,"use vstd::prelude::*;

verus! {",,"fn find_even_numbers(arr: &Vec<u32>) -> (even_numbers: Vec<u32>)

    ensures
        even_numbers@ == arr@.filter(|x: u32| x % 2 == 0),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0116,verus,verified_cogen,proofsynthesis_task_id_644,,,"use vstd::prelude::*;

verus! {",,"fn reverse_to_k(list: &Vec<i32>, n: usize) -> (reversed_list: Vec<i32>)

    requires
        list@.len() > 0,
        0 < n < list@.len(),

    ensures
        reversed_list@ == list@.subrange(0, n as int).reverse().add(
            list@.subrange(n as int, list.len() as int),
        ),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0117,verus,verified_cogen,proofsynthesis_task_id_728,,,"use vstd::prelude::*;

verus! {",,"fn add_list(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)

    requires
        arr1.len() == arr2.len(),
        forall|i: int|
            (0 <= i < arr1.len()) ==> (i32::MIN <= #[trigger] (arr1[i] + arr2[i]) <= i32::MAX),

    ensures
        result.len() == arr1.len(),
        forall|i: int|
            0 <= i < result.len() ==> #[trigger] result[i] == #[trigger] (arr1[i] + arr2[i]),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0118,verus,verified_cogen,proofsynthesis_task_id_732,,,"use vstd::prelude::*;

verus! {

spec fn is_space_comma_dot_spec(c: char) -> (result: bool) {
    (c == ' ') || (c == ',') || (c == '.')
}

spec fn inner_expr_replace_with_colon(str1: &Vec<char>, k: int) -> (result: char) {
    if is_space_comma_dot_spec(str1[k]) {
        ':'
    } else {
        str1[k]
    }
}",,"fn replace_with_colon(str1: &Vec<char>) -> (result: Vec<char>)

    ensures
        str1@.len() == result@.len(),
        forall|k: int|
            0 <= k < result.len() ==> #[trigger] result[k] == inner_expr_replace_with_colon(str1, k),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0119,verus,verified_cogen,proofsynthesis_task_id_733,,,"use vstd::prelude::*;

verus! {",,"fn find_first_occurrence(arr: &Vec<i32>, target: i32) -> (index: Option<usize>)

    requires
        forall|i: int, j: int| 0 <= i < j < arr.len() ==> arr[i] <= arr[j],

    ensures
        if let Some(idx) = index {
            &&& 0 <= idx < arr.len()
            &&& forall|k: int| 0 <= k < idx ==> arr[k] != target
            &&& arr[idx as int] == target
        } else {
            forall|k: int| 0 <= k < arr.len() ==> arr[k] != target
        },","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0120,verus,verified_cogen,proofsynthesis_task_id_741,,,"use vstd::prelude::*;

verus! {",,"fn all_characters_same(char_arr: &Vec<char>) -> (result: bool)

    ensures
        result == (forall|i: int|
            1 <= i < char_arr@.len() ==> char_arr[0] == #[trigger] char_arr[i]),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0121,verus,verified_cogen,proofsynthesis_task_id_743,,,"use vstd::prelude::*;

verus! {

spec fn rotation_split(len: usize, n: usize) -> (result: int) {
    len - (n % len)
}",,"fn rotate_right(list: &Vec<u32>, n: usize) -> (new_list: Vec<u32>)

    requires
        list.len() > 0,

    ensures
        new_list.len() == list.len(),
        new_list@ == list@.subrange(rotation_split(list.len(), n) as int, list@.len() as int).add(
            list@.subrange(0, rotation_split(list.len(), n) as int),
        ),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0122,verus,verified_cogen,proofsynthesis_task_id_755,,,"use vstd::prelude::*;

verus! {

spec fn min_spec(seq: Seq<i32>) -> (result: int)
    recommends
        0 < seq.len(),
    decreases seq.len(),
{
    if seq.len() == 1 {
        seq[0] as int
    } else if seq.len() == 0 {
        0
    } else {
        let later_min = min_spec(seq.drop_first());
        if seq[0] <= later_min {
            seq[0] as int
        } else {
            later_min as int
        }
    }
}",,"fn second_smallest(numbers: &Vec<i32>) -> (indices: (usize, usize))

    requires
        numbers.len() >= 2,

    ensures
        forall|k: int|
            0 <= k < numbers.len() && k != indices.0 && numbers[indices.0 as int] == min_spec(
                numbers@,
            ) ==> (#[trigger] numbers[k] >= numbers[indices.1 as int]),
        exists|k: int|
            0 <= k < numbers.len() && k != indices.0 && (#[trigger] numbers[k]
                == numbers[indices.1 as int]),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0123,verus,verified_cogen,proofsynthesis_task_id_760,,,"use vstd::prelude::*;

verus! {",,"fn has_only_one_distinct_element(arr: &Vec<i32>) -> (result: bool)

    ensures
        result == (forall|i: int| 1 <= i < arr@.len() ==> arr[0] == #[trigger] arr[i]),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0124,verus,verified_cogen,proofsynthesis_task_id_764,,,"use vstd::prelude::*;

verus! {

spec fn is_digit(c: char) -> (result: bool) {
    (c as u8) >= 48 && (c as u8) <= 57
}

spec fn count_digits_recursively(seq: Seq<char>) -> (result: int)
    decreases seq.len(),
{
    if seq.len() == 0 {
        0
    } else {
        count_digits_recursively(seq.drop_last()) + if is_digit(seq.last()) {
            1 as int
        } else {
            0 as int
        }
    }
}",,"fn count_digits(text: &Vec<char>) -> (count: usize)

    ensures
        0 <= count <= text.len(),
        count_digits_recursively(text@) == count,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0125,verus,verified_cogen,proofsynthesis_task_id_769,,,"use vstd::prelude::*;

verus! {",,"fn difference(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)

    ensures
        forall|i: int|
            0 <= i < arr1.len() ==> (!arr2@.contains(#[trigger] arr1[i]) ==> result@.contains(
                arr1[i],
            )),
        forall|i: int|
            0 <= i < arr2.len() ==> (!arr1@.contains(#[trigger] arr2[i]) ==> result@.contains(
                arr2[i],
            )),
        forall|i: int, j: int|
            0 <= i < j < result.len() ==> #[trigger] result[i] != #[trigger] result[j],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0126,verus,verified_cogen,proofsynthesis_task_id_775,,,"use vstd::prelude::*;

verus! {",,"fn is_odd_at_odd_index(arr: &Vec<usize>) -> (result: bool)

    ensures
        result == forall|i: int| 0 <= i < arr.len() ==> ((i % 2) == (arr[i] % 2)),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0127,verus,verified_cogen,proofsynthesis_task_id_790,,,"use vstd::prelude::*;

verus! {",,"fn is_even_at_even_index(arr: &Vec<usize>) -> (result: bool)

    ensures
        result == forall|i: int| 0 <= i < arr.len() ==> ((i % 2) == (arr[i] % 2)),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0128,verus,verified_cogen,proofsynthesis_task_id_798,,,"use vstd::prelude::*;

verus! {

spec fn sum_to(arr: Seq<i64>) -> (result: int)
    decreases arr.len(),
{
    if arr.len() == 0 {
        0
    } else {
        sum_to(arr.drop_last()) + arr.last()
    }
}",,"fn sum(arr: &Vec<i64>) -> (result: i128)

    ensures
        sum_to(arr@) == result","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0129,verus,verified_cogen,proofsynthesis_task_id_804,,,"use vstd::prelude::*;

verus! {

spec fn is_even(n: u32) -> (result: bool) {
    (n % 2) == 0
}",,"fn is_product_even(arr: &Vec<u32>) -> (result: bool)

    ensures
        result <==> (exists|k: int| 0 <= k < arr.len() && is_even(#[trigger] arr[k])),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0130,verus,verified_cogen,proofsynthesis_task_id_807,,,"use vstd::prelude::*;

verus! {

spec fn check_find_first_odd(arr: &Vec<u32>, index: Option<usize>) -> (result: bool)
{
    if let Some(idx) = index {
        &&& arr@.take(idx as int) == arr@.take(idx as int).filter(|x: u32| x % 2 == 0)
        &&& arr[idx as int] % 2 != 0
    } else {
        forall|k: int| 0 <= k < arr.len() ==> (arr[k] % 2 == 0)
    }
}",,"fn find_first_odd(arr: &Vec<u32>) -> (index: Option<usize>)

    ensures check_find_first_odd(arr, index),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0131,verus,verified_cogen,proofsynthesis_task_id_808,,,"use vstd::prelude::*;

verus! {",,"fn contains_k(arr: &Vec<i32>, k: i32) -> (result: bool)

    ensures
        result == (exists|i: int| 0 <= i < arr.len() && (arr[i] == k)),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0132,verus,verified_cogen,proofsynthesis_task_id_809,,,"use vstd::prelude::*;

verus! {",,"fn is_smaller(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: bool)

    requires
        arr1.len() == arr2.len(),

    ensures
        result == (forall|i: int| 0 <= i < arr1.len() ==> arr1[i] > arr2[i]),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0133,verus,verified_cogen,proofsynthesis_trigger,,,"#[allow(unused_imports)]
use vstd::prelude::*;

verus!{

spec fn f(seq: Seq<u64>, i: int) -> (result: bool) {
    seq[i] == i + 2
}",,"fn get_element_check_property(arr: Vec<u64>, i: usize) -> (ret: u64)

    requires
        arr.len() > 0,
        0 < i < arr@.len(),
        forall |i: int| f(arr@, i),

    ensures
        ret == i + 2,
        ret == arr@[i as int],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0134,verus,verified_cogen,rustbench_abs,,,"use vstd::prelude::*;

verus! {",,"fn abs(x: i32) -> (result: i32)
    requires
        x != i32::MIN,
    ensures
        result >= 0,
        result == x || result == -x,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0135,verus,verified_cogen,rustbench_arithmetic_weird,,,"use vstd::prelude::*;

verus! {",,"#[verifier::loop_isolation(false)]
fn arithmetic_weird() -> (result: i32)
    ensures
        result < 10","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0136,verus,verified_cogen,rustbench_array_append,,,"use vstd::prelude::*;

verus! {",,"#[verifier::loop_isolation(false)]
fn array_append(a: Vec<i32>, b: i32) -> (result: Vec<i32>)
    ensures
        result.len() == a.len() + 1,
        forall|i: int| #![auto] 0 <= i && i < result.len() ==> result[i] == (if i < a.len() { a[i] } else { b }),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0137,verus,verified_cogen,rustbench_array_concat,,,"use vstd::prelude::*;

verus! {",,"#[verifier::loop_isolation(false)]
fn array_concat(a: Vec<i32>, b: Vec<i32>) -> (result: Vec<i32>)
    ensures
        result.len() == a.len() + b.len(),
        forall|i: int| 0 <= i && i < a.len() ==> result[i] == a[i],
        forall|i: int| 0 <= i && i < b.len() ==> result[i + a.len()] == b[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0138,verus,verified_cogen,rustbench_array_copy,,,"use vstd::prelude::*;

verus! {",,"#[verifier::loop_isolation(false)]
fn array_copy(a: Vec<i32>) -> (result: Vec<i32>)
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i && i < a.len() ==> result[i] == a[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0139,verus,verified_cogen,rustbench_array_product,,,"use vstd::prelude::*;

verus! {",,"#[verifier::loop_isolation(false)]
fn array_product(a: Vec<i32>, b: Vec<i32>) -> (result: Vec<i64>) by (nonlinear_arith)
    requires
        a.len() == b.len(),
    ensures
        result.len() == a.len(),
        forall|i: int| #![auto] 0 <= i && i < a.len() ==> result[i] == (a[i] as i64) * (b[i] as i64),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0140,verus,verified_cogen,rustbench_barrier,,,"use vstd::prelude::*;

verus! {",,"#[verifier::loop_isolation(false)]
fn barrier(arr: &[i32], p: usize) -> (result: bool)
    requires
        arr.len() > 0,
        0 <= p < arr.len(),
    ensures
        result == forall|k: int, l: int| 0 <= k <= p && p < l < arr.len() ==> arr[k] < arr[l],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0141,verus,verified_cogen,rustbench_binary_search,,,"use vstd::prelude::*;

verus! {",,"#[verifier::loop_isolation(false)]
fn binary_search(arr: &[i32], target: i32) -> (result: Option<usize>)
    requires
        forall|i: int, j: int| 0 <= i && i < j && j < arr.len() ==> arr[i] <= arr[j],
    ensures
        match result {
            Some(index) => arr[index as int] == target && arr.len() > 0 && index < arr.len(),
            None => forall|i: int| 0 <= i && i < arr.len() ==> arr[i] != target,
        },","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0142,verus,verified_cogen,rustbench_binary_search_recursive,,,"use vstd::prelude::*;

verus! {",,"fn binary_search_recursive(v: &[i32], elem: i32, c: isize, f: isize) -> (p: isize)
    requires
        v.len() <= 100_000,
        forall|i: int, j: int| 0 <= i < j < v.len() ==> v[i] <= v[j],
        0 <= c <= f + 1 <= v.len(),
        forall|k: int| 0 <= k < c ==> v[k] <= elem,
        forall|k: int| f < k < v.len() ==> v[k] > elem,
    ensures
        -1 <= p < v.len(),
        forall|u: int| 0 <= u <= p ==> v[u] <= elem,
        forall|w: int| p < w < v.len() ==> v[w] > elem,
    decreases f - c + 1","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0143,verus,verified_cogen,rustbench_cubes,,,"use vstd::prelude::*;

verus! {",,"#[verifier::loop_isolation(false)]
fn cubes(len: usize) -> (result: Vec<i32>) by (nonlinear_arith)
    ensures
        result.len() == len,
        forall|i: int| 0 <= i && i < len ==> result[i] == i * i * i","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0144,verus,verified_cogen,rustbench_has_close_elements,,,"use vstd::prelude::*;

verus! {

spec fn abs_spec(i: int) -> int {
    if i < 0 { -i } else { i }
}",,"#[verifier::loop_isolation(false)]
fn has_close_elements(numbers: &[i32], threshold: i32) -> (flag: bool)
    requires
        threshold > 0,
        forall|i: int, j: int| 0 <= i && i < numbers.len() && 0 <= j && j < numbers.len() ==> numbers[i] - numbers[j] < i32::MAX && -(numbers[i] - numbers[j]) < i32::MAX
    ensures
        flag == exists|i: int, j: int| 0 <= i && 0 <= j && i < numbers.len() && j < numbers.len() && i != j && abs_spec(numbers[i] - numbers[j]) < threshold","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0145,verus,verified_cogen,rustbench_has_only_one_distinct_element,,,"use vstd::prelude::*;

verus! {",,"#[verifier::loop_isolation(false)]
fn has_only_one_distinct_element(a: &[i32]) -> (result: bool)
    ensures
        result ==> forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() ==> a[i] == a[j],
        !result ==> exists|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() && a[i] != a[j],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0146,verus,verified_cogen,rustbench_index_wise_addition,,,"use vstd::prelude::*;

verus! {",,"#[verifier::loop_isolation(false)]
fn index_wise_addition(a: &Vec<Vec<i32>>, b: &Vec<Vec<i32>>) -> (c: Vec<Vec<i32>>)
    requires
        a.len() == b.len(),
        forall|i: int| #![auto] 0 <= i < a.len() ==> a[i].len() == b[i].len(),
        forall|i: int| #![trigger a[i], b[i]] 
            0 <= i < a.len() 
                ==> forall|j: int| 0 <= j < a[i].len() ==> a[i][j] + b[i][j] <= i32::MAX,
        forall|i: int| #![trigger a[i], b[i]] 
            0 <= i < a.len() 
                ==> forall|j: int| 0 <= j < a[i].len() ==> a[i][j] + b[i][j] >= i32::MIN,
    ensures
        c.len() == a.len(),
        forall|i: int| #![auto] 0 <= i < c.len() ==> c[i].len() == a[i].len(),
        forall|i: int| #![trigger a[i], b[i], c[i]] 
            0 <= i < c.len() 
                ==> forall|j: int| #![auto] 0 <= j < c[i].len() ==> c[i][j] == a[i][j] + b[i][j],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0147,verus,verified_cogen,rustbench_integer_square_root,,,"use vstd::prelude::*;

verus! {",,"fn integer_square_root(n: i32) -> (result: i32)
    requires
        n >= 1,
    ensures
        0 <= result * result,
        result * result <= n,
        n < (result + 1) * (result + 1)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0148,verus,verified_cogen,rustbench_intersperse,,,"use vstd::prelude::*;

verus! {",,"fn intersperse(numbers: &[i32], delim: i32) -> (res: Vec<i32>)
    ensures
        numbers.len() == 0 ==> res.len() == 0,
        numbers.len() != 0 ==> res.len() == 2 * numbers.len() - 1,
        forall|i: int| 0 <= i && i < res.len() && i % 2 == 0 ==> res[i] == numbers[i / 2],
        forall|i: int| 0 <= i && i < res.len() && i % 2 == 1 ==> res[i] == delim","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0149,verus,verified_cogen,rustbench_is_non_prime,,,"use vstd::prelude::*;

verus! {",,"#[verifier::loop_isolation(false)]
fn is_non_prime(n: u32) -> (result: bool)
    requires
        n >= 2,
    ensures
        result == exists|k: int| 2 <= k < n && #[trigger] (n as int % k) == 0,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0150,verus,verified_cogen,rustbench_is_sorted,,,"use vstd::prelude::*;

verus! {",,"#[verifier::loop_isolation(false)]
fn is_sorted(lst: &[i32]) -> (result: bool)
    requires
        lst.len() >= 1,
    ensures
        result <== forall|i: int, j: int| 0 <= i && i < j && j < lst.len() ==> lst[i] <= lst[j],
        !result ==> exists|i: int, j: int| 0 <= i && i < j && j < lst.len() && lst[i] > lst[j],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0151,verus,verified_cogen,rustbench_largest_prime_factor,,,"use vstd::prelude::*;

verus! {

spec fn is_prime_pred(n: u32) -> bool {
    forall|k: int| 2 <= k < n ==> #[trigger] (n as int % k) != 0
}",,"#[verifier::loop_isolation(false)]
fn largest_prime_factor(n: u32) -> (result: u32)
    requires
        2 <= n <= u32::MAX - 1,
    ensures
        1 <= result <= n,
        result == 1 || (result > 1 && is_prime_pred(result))","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0152,verus,verified_cogen,rustbench_last_position,,,"use vstd::prelude::*;

verus! {",,"#[verifier::loop_isolation(false)]
fn last_position(a: &[i32], elem: i32) -> (result: usize)
    requires
        0 < a.len() < 100_000,
        exists|i: int| 0 <= i < a.len() && a[i] == elem,
    ensures
        0 <= result < a.len(),
        forall|i: int| result < i < a.len() ==> a[i] != elem,
        a[result as int] == elem,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0153,verus,verified_cogen,rustbench_max_array,,,"use vstd::prelude::*;

verus! {",,"fn max_array(nums: &[i32]) -> (idx: usize)
    requires
        nums.len() >= 1,
    ensures
        0 <= idx && idx < nums.len(),
        forall|i: int| 0 <= i && i < nums.len() ==> nums[i] <= nums[idx as int],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0154,verus,verified_cogen,rustbench_max_dafny_lsp,,,"use vstd::prelude::*;

verus! {",,"#[verifier::loop_isolation(false)]
fn max_dafny_lsp(a: &[i32]) -> (x: usize)
    requires
        a.len() > 0,
    ensures
        0 <= x < a.len(),
        forall|k: int| 0 <= k < a.len() ==> a[k] <= a[x as int],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0155,verus,verified_cogen,rustbench_remove_duplicates,,,"use vstd::prelude::*;

verus! {

spec fn in_array(a: Seq<i32>, x: i32) -> bool {
    exists|i: int| 0 <= i < a.len() && a[i] == x
}",,"#[verifier::loop_isolation(false)]
fn remove_duplicates(a: &[i32]) -> (result: Vec<i32>)
    requires
        a.len() >= 1,
    ensures
        forall|i: int| #![auto] 0 <= i < result.len() ==> in_array(a@, result[i]),
        forall|i: int, j: int| 0 <= i < j < result.len() ==> result[i] != result[j],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0156,verus,verified_cogen,rustbench_remove_element,,,"use vstd::prelude::*;

verus! {",,"#[verifier::loop_isolation(false)]
fn remove_element(a: &[i32], pos: usize) -> (result: Vec<i32>)
    requires
        0 <= pos < a.len(),
    ensures
        result.len() == a.len() - 1,
        forall|i: int| 0 <= i < pos ==> result[i] == a[i],
        forall|i: int| pos <= i < result.len() ==> result[i] == a[i + 1],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0157,verus,verified_cogen,rustbench_remove_elements,,,"use vstd::prelude::*;

verus! {

spec fn in_array(a: Seq<i32>, x: i32) -> bool {
    exists|i: int| 0 <= i < a.len() && a[i] == x
}",,"#[verifier::loop_isolation(false)]
fn remove_elements(a: &Vec<i32>, b: &Vec<i32>) -> (c: Vec<i32>)
    ensures
        forall|k: int| #![auto] 0 <= k < c.len() ==> in_array(a@, c[k]) && !in_array(b@, c[k]),
        forall|i: int, j: int| 0 <= i < j < c.len() ==> c[i] != c[j],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0158,verus,verified_cogen,rustbench_replace,,,"use vstd::prelude::*;

verus! {",,"#[verifier::loop_isolation(false)]
fn replace(a: &mut Vec<i32>, x: i32, y: i32)
    ensures
        a.len() == old(a).len(),
        forall|k: int| 0 <= k < old(a).len() && old(a)[k] == x ==> a[k] == y,
        forall|k: int| 0 <= k < old(a).len() && old(a)[k] != x ==> a[k] == old(a)[k],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0159,verus,verified_cogen,rustbench_replace_chars,,,"use vstd::prelude::*;

verus! {",,"fn replace_chars(s: &[char], old: char, new: char) -> (result: Vec<char>)
    ensures
        result.len() == s.len(),
        forall|i: int| 0 <= i && i < result.len() ==> result[i] == (if s[i] == old { new } else { s[i] }),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0160,verus,verified_cogen,rustbench_reverse,,,"use vstd::prelude::*;

verus! {",,"fn reverse(a: &[i32]) -> (result: Vec<i32>)
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i && i < result.len() ==> result[i] == a[a.len() - 1 - i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0161,verus,verified_cogen,rustbench_rolling_max,,,"use vstd::prelude::*;

verus! {

spec fn seq_max(a: Seq<i32>) -> i32
    decreases a.len(),
{
    if a.len() == 0 {
        i32::MIN
    } else if a.last() > seq_max(a.drop_last()) {
        a.last()
    } else {
        seq_max(a.drop_last())
    }
}",,"fn rolling_max(numbers: Vec<i32>) -> (result: Vec<i32>)
    ensures
        result.len() == numbers.len(),
        forall|i: int| 0 <= i < numbers.len() ==> result[i] == seq_max(numbers@.take(i + 1)),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0162,verus,verified_cogen,rustbench_smallest_list_length,,,"use vstd::prelude::*;

verus! {",,"#[verifier::loop_isolation(false)]
fn smallest_list_length(lists: Vec<Vec<i32>>) -> (result: usize)
    requires
        lists.len() > 0,
    ensures
        exists|i: int| #![auto] 0 <= i < lists.len() && result == lists[i].len(),
        forall|i: int| #![auto] 0 <= i < lists.len() ==> result <= lists[i].len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0163,verus,verified_cogen,rustbench_smallest_missing_number,,,"use vstd::prelude::*;

verus! {",,"#[verifier::loop_isolation(false)]
fn smallest_missing_number(s: &[i32]) -> (v: i32)
    requires
        forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] <= s[j],
        forall|i: int| 0 <= i < s.len() ==> s[i] >= 0,
        s.len() <= 100_000,
    ensures
        0 <= v,
        forall|i: int| 0 <= i < s.len() ==> s[i] != v,
        forall|k: int| 0 <= k < v && s[k] != v ==> exists|j: int| 0 <= j < s.len() && s[j] == k,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0164,verus,verified_cogen,rustbench_string_xor,,,"use vstd::prelude::*;

verus! {",,"#[verifier::loop_isolation(false)]
fn string_xor(a: &[char], b: &[char]) -> (result: Vec<char>)
    requires
        a.len() == b.len(),
        forall|i: int| 0 <= i && i < a.len() ==> a[i] == '0' || a[i] == '1',
        forall|i: int| 0 <= i && i < b.len() ==> b[i] == '0' || b[i] == '1',
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i && i < result.len() ==> (result[i] == '0' || result[i] == '1'),
        forall|i: int| 0 <= i && i < result.len() ==> result[i] == (if a[i] == b[i] { '0' } else { '1' })","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0165,verus,verified_cogen,rustbench_two_sum,,,"use vstd::prelude::*;

verus! {",,"#[verifier::loop_isolation(false)]
fn two_sum(nums: &[i32], target: i32) -> (result: (usize, usize))
    requires
        nums.len() >= 2,
        exists|i: int, j: int| 0 <= i < j < nums.len() && nums[i] + nums[j] == target,
        forall|i: int, j: int|
            0 <= i < nums.len() && 0 <= j < nums.len()
                ==> nums[i] + nums[j] <= i32::MAX
                    && nums[i] + nums[j] >= i32::MIN,
    ensures
        ({ let (i, j) = result; 0 <= i < nums.len() }),
        ({ let (i, j) = result; 0 <= j < nums.len() }),
        ({ let (i, j) = result; i != j }),
        ({ let (i, j) = result; nums[i as int] + nums[j as int] == target })","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0166,verus,verified_cogen,rustbench_two_way_sort,,,"use vstd::prelude::*;

verus! {",,"#[verifier::loop_isolation(false)]
fn two_way_sort(a: &mut Vec<bool>)
    requires
        old(a).len() <= 100_000,
    ensures
        a.len() == old(a).len(),
        a@.to_multiset() == old(a)@.to_multiset(),
        forall|i: int, j: int| 0 <= i < j < a.len() ==> !a[i] || a[j],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0167,verus,verified_cogen,rustbench_unique,,,"use vstd::prelude::*;

verus! {",,"#[verifier::loop_isolation(false)]
fn unique(a: &[i32]) -> (result: Vec<i32>)
    requires
        forall|i: int, j: int|
            #![trigger a[i], a[j]]
            0 <= i && i < j && j < a.len() ==> a[i] <= a[j],
    ensures
        forall|i: int, j: int|
            #![trigger result[i], result[j]]
            0 <= i && i < j && j < result.len() ==> result[i] < result[j],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0168,verus,verified_cogen,rustbench_unique_better,,,"use vstd::prelude::*;

verus! {",,"#[verifier::loop_isolation(false)]
fn unique_better(a: &[i32]) -> (result: Vec<i32>)
    requires
        forall|i: int, j: int|
            #![trigger a[i], a[j]]
            0 <= i && i < j && j < a.len() ==> a[i] <= a[j],
    ensures
        forall|i: int, j: int|
            #![trigger result[i], result[j]]
            0 <= i && i < j && j < result.len() ==> result[i] < result[j],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0169,verus,verified_cogen,rustbench_wip_max_segment_sum,,,"#![crate_name = ""max_segment_sum""]

use vstd::prelude::*;

verus! {

spec fn sum(a: Seq<i32>, s: int, t: int) -> int
    decreases t - s,
{
    if s < 0 || s >= t || t > a.len() {
        0
    } else {
        a[t - 1] + sum(a, s, t - 1)
    }
}",,"#[verifier::loop_isolation(false)]
fn max_segment_sum(a: &Vec<i32>, s: usize, t: usize) -> (p: (usize, usize)) by (nonlinear_arith)
    ensures
        ({ let (i, j) = p; 0 <= i <= j <= a.len() }),
        ({ let (i, j) = p; forall|k: int, l: int| 0 <= k <= l <= a.len() ==> sum(a@, k, l) <= sum(a@, i as int, j as int) })","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0170,verus,verified_cogen,rustbench_wip_mcontained,,,"#![crate_name = ""mcontained""]

use vstd::prelude::*;

verus! {

spec fn strict_sorted(arr: &[i32]) -> bool {
    forall|k: int, l: int| 0 <= k < l < arr.len() ==> arr[k] < arr[l]
}",,"#[verifier::loop_isolation(false)]
fn mcontained(v: &[i32], w: &[i32], n: usize, m: usize) -> (b: bool)
    requires
        n <= m && n>= 0,
        strict_sorted(v),
        strict_sorted(w),
        v.len() >= n && w.len() >= m
    ensures
        b ==> (forall|k: int| #![trigger v[k]]
            0 <= k < n ==> (
                exists|j: int| #![trigger w[j]]
                0 <= j < m && v[k] == w[j]
            ))","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VJ0171,verus,verified_cogen,rustbench_wip_transpose_matrix,,,"#![crate_name = ""transpose_matrix""]

use vstd::prelude::*;

verus! {",,"#[verifier::loop_isolation(false)]
fn transpose(matrix: Vec<Vec<i32>>) -> (result: Vec<Vec<i32>>)
    requires
        matrix.len() > 0,
        forall|i: int| #![trigger matrix[i]]
            0 <= i < matrix.len() ==> matrix[i].len() == matrix[0].len(),
        forall|i: int| #![trigger matrix[i]]
            0 <= i < matrix.len() ==> matrix[i].len() == matrix.len()
    ensures
        result.len() == matrix[0].len(),
        forall|i: int| #![trigger result[i]]
            0 <= i < result.len() ==> result[i].len() == matrix.len(),
        forall|i: int, j: int| #![trigger result[i], matrix[j]]
            0 <= i < result.len() && 0 <= j < result[i].len() ==> result[i][j] == matrix[j][i]","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VS0000,verus,numpy_simple,NpAbs-spec,,Computes the absolute value of each element in a vector.,"use vstd::prelude::*;

verus! {

spec fn abs_int(x: int) -> int {
    if x < 0 { -x } else { x }
}",,"fn abs(a: Vec<i8>) -> (result: Vec<i8>)
    ensures 
        result.len() == a.len(),
        forall|i: int| 0 <= i < a.len() ==> result[i] as int == abs_int(a[i] as int),
        forall|i: int| 0 <= i < result.len() ==> result[i] >= 0,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VS0001,verus,numpy_simple,NpAdd-spec,,,"use vstd::prelude::*;

verus! {",,"fn add(a: Vec<i8>, b: Vec<i8>) -> (result: Vec<i8>)
    requires a.len() == b.len(),
    ensures 
        result.len() == a.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] as int == a[i] as int + b[i] as int","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,DupVS00,0.85
VS0002,verus,numpy_simple,NpArange-spec,,,"use vstd::prelude::*;

verus! {",,"spec fn arange_length(start: int, stop: int, step: int) -> nat
{
    if step != 0 {
        if step < 0 {
            if start > stop {
                ((start - stop) / (-step)) as nat
            } else {
                0
            }
        } else {
            if start < stop {
                ((stop - start) / step) as nat
            } else {
                0
            }
        }
    } else {
        0
    }
}

fn arange(start: i8, stop: i8, step: i8) -> (result: Vec<i8>)
    requires 
        step != 0,
        if step < 0 { start > stop } else { start < stop },
    ensures
        result@.len() == arange_length(start as int, stop as int, step as int),
        result@.len() > 0,
        result@[0] == start as int","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VS0003,verus,numpy_simple,NpArgmax-spec,,Finds the index of the maximum element in a non-empty vector of floats.,"use vstd::prelude::*;

verus! {",,"fn argmax(arr: Vec<i32>) -> (result: usize)
    requires arr.len() > 0,
    ensures 
        result < arr.len(),
        forall|i: int| 0 <= i < result ==> arr[result as int] > arr[i],
        forall|i: int| result < i < arr.len() ==> arr[result as int] >= arr[i]","{
    // impl-start
    assume(false);
    0
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VS0004,verus,numpy_simple,NpArgsort-spec,,,"use vstd::prelude::*;

verus! {",,"fn argsort(a: Vec<i8>) -> (result: Vec<usize>)
    ensures 
        result.len() == a.len(),
        forall|i: int, j: int| 0 <= i < j < result.len() ==> #[trigger] a@[result@[i] as int] <= #[trigger] a@[result@[j] as int],","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VS0005,verus,numpy_simple,NpBitwiseAnd-spec,,,"use vstd::prelude::*;

verus! {",,"fn bitwise_and(a: Vec<u8>, b: Vec<u8>) -> (result: Vec<u8>)
    requires a.len() == b.len(),
    ensures 
        result.len() == a.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] == (a[i] & b[i])","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,DupVS00,0.85
VS0006,verus,numpy_simple,NpBitwiseOr-spec,,,"use vstd::prelude::*;

verus! {",,"fn bitwise_or(a: Vec<u8>, b: Vec<u8>) -> (result: Vec<u8>)
    requires a.len() == b.len(),
    ensures 
        result.len() == a.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] as u32 == (a[i] as u32 | b[i] as u32),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,DupVS00,0.85
VS0007,verus,numpy_simple,NpBitwiseXor-spec,,,"use vstd::prelude::*;

verus! {",,"fn bitwise_xor(a: Vec<u8>, b: Vec<u8>) -> (result: Vec<u8>)
    requires 
        a.len() == b.len(),
        a.len() > 0,
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < a@.len() ==> result@[i] == a@[i] ^ b@[i],","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VS0008,verus,numpy_simple,NpBroadcast-spec,,Broadcast operation that reshapes a vector into a matrix according to broadcasting rules.,"use vstd::prelude::*;

verus! {
/* Matrix type definition - represents an m×n matrix */
pub struct Matrix<T> {
    pub data: Vec<Vec<T>>,
    pub rows: usize,
    pub cols: usize,
}

impl<T: Copy> Matrix<T> {
    pub open spec fn view(self) -> Seq<Seq<T>> {
        self.data@.map(|i: int, row: Vec<T>| row@)
    }

    pub open spec fn wf(self) -> bool {
        &&& self.data.len() == self.rows
        &&& forall|i: int| 0 <= i < self.data.len() ==> self.data[i].len() == self.cols
    }

    pub open spec fn index(self, i: int, j: int) -> T 
        recommends 0 <= i < self.rows && 0 <= j < self.cols && self.wf()
    {
        self.data[i][j]
    }

    pub open spec fn size(self) -> int {
        self.rows * self.cols
    }
}",,"fn broadcast(a: Vec<i8>, shape: Vec<u8>) -> (ret: Matrix<i8>)
    requires 
        a.len() > 0,
        shape.len() == 2,
        shape[0] > 0,
        shape[1] > 0,
        shape[0] as int == a.len() || shape[1] as int == a.len(),
    ensures
        ret.wf(),
        ret.rows == shape[0] as usize,
        ret.cols == shape[1] as usize,
        ret.size() == shape[0] as int * shape[1] as int,
        forall|i: int, j: int| 0 <= i < shape[0] as int && 0 <= j < shape[1] as int ==> {
            if shape[0] as int == a.len() {
                ret.index(i, j) == a[i as int]
            } else {
                ret.index(i, j) == a[j as int]
            }
        }","{
    // impl-start
    assume(false);
    Matrix {
        data: Vec::new(),
        rows: 0,
        cols: 0,
    }
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VS0009,verus,numpy_simple,NpCenter-spec,,Centers strings within a given width by adding appropriate padding.,"use vstd::prelude::*;

verus! {",,"fn center(input: Vec<String>, width: usize) -> (result: Vec<String>)
    requires 
        input.len() > 0,
        forall|i: int| 0 <= i < input.len() ==> input[i]@.len() >= 1,
    ensures
        result.len() == input.len(),
        forall|i: int| 0 <= i < input.len() ==> 
            if input[i]@.len() > width {
                result[i]@.len() == input[i]@.len()
            } else {
                result[i]@.len() == width
            },
        forall|i: int| 0 <= i < input.len() ==> 
            if input[i]@.len() < width {
                let start_pos = (width - input[i]@.len() + 1) / 2;
                result[i]@.skip(start_pos as int).take(input[i]@.len() as int) == input[i]@
            } else {
                true
            }","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VS0010,verus,numpy_simple,NpClip-spec,,,"use vstd::prelude::*;

verus! {",,"fn clip(a: Vec<i8>, min: i8, max: i8) -> (result: Vec<i8>)
    requires min < max,
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < a@.len() ==> {
            if a@[i] < min as int {
                result@[i] == min as int
            } else if a@[i] > max as int {
                result@[i] == max as int
            } else {
                result@[i] == a@[i]
            }
        }","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VS0011,verus,numpy_simple,NpColumnStack-spec,,Creates a matrix by stacking column vectors horizontally.,"use vstd::prelude::*;

verus! {",,"fn column_stack(input: Vec<Vec<i8>>, m: usize, n: usize) -> (result: Vec<Vec<i8>>)
    requires 
        n > 0,
        input@.len() == n,
        forall|i: int| 0 <= i < n ==> #[trigger] input@[i].len() == m,
    ensures
        result@.len() == m,
        forall|j: int| 0 <= j < m ==> result@[j].len() == n,
        result@.len() * n == m * n,
        forall|i: int, j: int| 0 <= i < n && 0 <= j < m ==> 
            result@[j][i] as int == input@[i][j] as int,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VS0013,verus,numpy_simple,NpCopy-spec,,,"use vstd::prelude::*;

verus! {",,"fn copy(arr: &Vec<i8>) -> (result: Vec<i8>)
    ensures
        result.len() == arr.len(),
        forall|i: int| 0 <= i < arr.len() ==> result[i] as int == arr[i] as int,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,DupVS04,0.85
VS0014,verus,numpy_simple,NpCountnonzero-spec,,Counts the number of non-zero elements in a float vector.,"use vstd::prelude::*;

verus! {",,"spec fn nonzero_helper(arr: Seq<f32>) -> nat 
    decreases arr.len()
{
    if arr.len() == 0 {
        0
    } else {
        let rest_count = nonzero_helper(arr.skip(1));
        if arr[0] == 0.0f32 {
            rest_count
        } else {
            rest_count + 1
        }
    }
}

fn nonzero(arr: Vec<f32>) -> (result: usize)
    ensures 
        result <= arr.len(),
        result == nonzero_helper(arr@),
        arr.len() > 0 && arr[0] == 0.0f32 ==> 
            nonzero_helper(arr@.skip(1)) == if result > 0 { result - 1 } else { 0 }","{
    // impl-start
    assume(false);
    0
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VS0015,verus,numpy_simple,NpCumProd-spec,,Computes the cumulative product of a vector where each element is the product of all elements up to that index.,"use vstd::prelude::*;

verus! {",,"fn cum_prod(a: Vec<i8>) -> (result: Vec<i8>)
    requires a.len() > 0,
    ensures 
        result.len() == a.len(),
        result[0] == a[0],
        forall|i: int| 0 < i < a.len() ==> result[i] as int == result[i-1] as int * a[i] as int","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VS0016,verus,numpy_simple,NpCumSum-spec,,"Computes the cumulative sum of elements in a vector, where each position contains the sum of all elements from the start up to that position.","use vstd::prelude::*;

verus! {",,"fn cum_sum(a: Vec<i8>) -> (result: Vec<i8>)
    requires a.len() > 0,
    ensures 
        result.len() == a.len(),
        result[0] == a[0],
        forall|i: int| 1 <= i < a.len() ==> result[i as int] as int == result[(i - 1) as int] as int + a[i as int] as int","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VS0017,verus,numpy_simple,NpDiagonal-spec,,,"use vstd::prelude::*;

verus! {",,"/* Matrix type represented as a 2D vector */
type Matrix<T> = Vec<Vec<T>>;

fn diagonal(arr: Matrix<i8>, k: i8) -> (result: Vec<i8>)
    requires 
        arr.len() > 0,
        arr.len() == arr[0].len(), /* square matrix */
        forall|i: int| 0 <= i < arr.len() ==> arr[i].len() == arr.len(),
        -(arr.len() as i8) < k && k < (arr.len() as i8),
    ensures
        if k > 0 {
            result.len() == arr.len() - (k as usize) &&
            forall|i: int| 0 <= i < result.len() ==> result[i] == arr[i][i + (k as usize)]
        } else {
            result.len() == arr.len() + ((-k) as usize) &&
            forall|i: int| 0 <= i < result.len() ==> result[i] == arr[i + ((-k) as usize)][i]
        }","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VS0018,verus,numpy_simple,NpEqual-spec,,"Element-wise comparison of two vectors, returning a boolean vector indicating equality at each position.","use vstd::prelude::*;

verus! {",,"fn equal(a: Vec<i8>, b: Vec<i8>) -> (result: Vec<bool>)
    requires a.len() == b.len(),
    ensures 
        result.len() == a.len(),
        forall|i: int| 0 <= i < a@.len() ==> result@[i] == (a@[i] == b@[i])","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,DupVS01,0.85
VS0019,verus,numpy_simple,NpFlatten-spec,,Flattens a 2D matrix into a 1D vector in row-major order.,"use vstd::prelude::*;

verus! {

/* Matrix type definition - 2D array represented as vector of vectors */
pub struct Matrix {
    pub data: Vec<Vec<i32>>,
    pub rows: usize,
    pub cols: usize,
}

impl Matrix {
    pub open spec fn size(&self) -> nat {
        (self.rows * self.cols) as nat
    }

    pub open spec fn valid(&self) -> bool {
        &&& self.data.len() == self.rows
        &&& forall|i: int| 0 <= i < self.rows ==> self.data[i].len() == self.cols
    }

    pub open spec fn get(&self, i: usize, j: usize) -> i32 
        recommends self.valid() && i < self.rows && j < self.cols
    {
        self.data[i as int][j as int]
    }
}",,"fn flatten2(mat: &Matrix) -> (ret: Vec<i32>)
    requires 
        mat.rows > 0,
        mat.cols > 0,
        mat.valid(),
    ensures
        ret.len() == mat.rows * mat.cols,
        forall|i: int, j: int| 
            0 <= i < mat.rows && 0 <= j < mat.cols ==> 
            #[trigger] ret@[(i * (mat.cols as int) + j) as int] == mat.get(i as usize, j as usize),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,DupVS03,0.85
VS0020,verus,numpy_simple,NpFloorDivide-spec,,Element-wise floor division of two vectors where the divisor vector has no zero elements.,"use vstd::prelude::*;

verus! {",,"spec fn is_non_zero_vector(v: Seq<i32>) -> bool {
    forall|i: int| 0 <= i < v.len() ==> v[i] != 0
}

fn floor_divide(a: Vec<i8>, b: Vec<i8>) -> (result: Vec<i8>)
    requires 
        a.len() == b.len(),
        is_non_zero_vector(a@.map(|i, x: i8| x as i32)),
        is_non_zero_vector(b@.map(|i, x: i8| x as i32)),
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] as i32 == (a[i] as i32) / (b[i] as i32),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VS0021,verus,numpy_simple,NpGcd-spec,,,"use vstd::prelude::*;

verus! {",,"fn gcd_int(a: i8, b: i8) -> (result: i8)
    ensures
        result >= 0,
        (a as int) % (result as int) == 0,
        (b as int) % (result as int) == 0,
        forall|d: int| d > 0 && #[trigger] ((a as int) % d) == 0 && #[trigger] ((b as int) % d) == 0 ==> d <= (result as int),","{
    // impl-start
    assume(false);
    0
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VS0022,verus,numpy_simple,NpGreater-spec,,,"use vstd::prelude::*;

verus! {",,"fn greater(a: Vec<i8>, b: Vec<i8>) -> (result: Vec<bool>)
    requires a.len() == b.len(),
    ensures 
        result.len() == a.len(),
        forall|i: int| 0 <= i < a.len() ==> result[i] == (a[i] as i32 > b[i] as i32)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,DupVS00,0.85
VS0023,verus,numpy_simple,NpGreaterEqual-spec,,,"use vstd::prelude::*;

verus! {",,"fn greater_equal(a: Vec<i8>, b: Vec<i8>) -> (result: Vec<bool>)
    requires a.len() == b.len(),
    ensures 
        result.len() == a.len(),
        forall|i: int| 0 <= i < a.len() ==> result[i] == (a[i] as int >= b[i] as int)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,DupVS00,0.85
VS0024,verus,numpy_simple,NpHistogram-spec,,Computes a histogram of floating-point data given bin boundaries.,"use vstd::prelude::*;

verus! {",,"fn histogram(data: Vec<f32>, bins: Vec<f32>) -> (result: Vec<i8>)
    requires 
        bins.len() >= 2,
    ensures
        result.len() == bins.len() - 1,
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}

fn histogram_helper(data: Vec<f32>, bins: Vec<f32>, hist: Vec<i8>, index: i8) -> (result: Vec<i8>)
    requires 
        bins.len() >= 2,
        hist.len() == bins.len() - 1,
    ensures
        result.len() == bins.len() - 1,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VS0025,verus,numpy_simple,NpIntersect-spec,,Computes the intersection of two vectors containing common elements.,"use vstd::prelude::*;

verus! {",,"fn intersect(a: Vec<i8>, b: Vec<i8>) -> (result: Vec<i8>)
    ensures
        result.len() < a.len() && result.len() < b.len(),
        forall|i: int, j: int| 0 <= i < a@.len() && 0 <= j < b@.len() ==> (
            (a@[i] == b@[j] ==> exists|k: int| 0 <= k < result@.len() && result@[k] == a@[i]) &&
            (a@[i] != b@[j] ==> !exists|k: int| 0 <= k < result@.len() && result@[k] == a@[i])
        )","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VS0026,verus,numpy_simple,NpInvert-spec,,,"use vstd::prelude::*;

verus! {
spec fn pow2(n: nat) -> nat 
    decreases n
{
    if n == 0 {
        1nat
    } else {
        2nat * pow2((n - 1) as nat)
    }
}",,"fn invert(bit_width: u32, a: Vec<u32>) -> (result: Vec<u32>)
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < a@.len() ==> result@[i] == (pow2(bit_width as nat) - 1) - a@[i]","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VS0027,verus,numpy_simple,NpIsalpha-spec,,"Checks if all strings in a vector contain only alphabetic characters (A-Z, a-z).","use vstd::prelude::*;

verus! {",,"spec fn is_alpha_char(c: char) -> bool {
    ('A' <= c && c <= 'Z') || ('a' <= c && c <= 'z')
}

spec fn string_is_alpha(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> is_alpha_char(s[i])
}

fn is_alpha(input: Vec<String>) -> (ret: Vec<bool>)
    ensures
        ret.len() == input.len(),
        forall|i: int| 0 <= i < input.len() ==> 
            ret[i] == string_is_alpha(input[i]@)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VS0028,verus,numpy_simple,NpIsclose-spec,,Computes element-wise absolute difference comparison within tolerance for two integer vectors.,"use vstd::prelude::*;

verus! {",,"fn np_isclose(a: Vec<i8>, b: Vec<i8>, tol: i8) -> (result: Vec<bool>)
    requires 
        a.len() > 0,
        a.len() == b.len(),
        tol > 0,
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < a.len() ==> 
            result[i] == (-(tol as int) < (a[i] as int) - (b[i] as int) && (a[i] as int) - (b[i] as int) < (tol as int)),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VS0029,verus,numpy_simple,NpLcm-spec,,,"use vstd::prelude::*;

verus! {",,"fn lcm_int(a: i8, b: i8) -> (result: i8)
    requires a as int != 0 && b as int != 0,
    ensures 
        result as int >= 0,
        result as int % a as int == 0,
        result as int % b as int == 0","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VS0030,verus,numpy_simple,NpLeftShift-spec,,,"use vstd::prelude::*;

verus! {",,"spec fn shift_left_int(x: int, shift: nat) -> int;

fn left_shift(a: Vec<i32>, b: Vec<u32>) -> (result: Vec<i32>)
    requires 
        a.len() == b.len(),
        forall|i: int| 0 <= i < b.len() ==> b[i] < 64,
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] == shift_left_int(a[i] as int, b[i] as nat),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,DupVS02,0.85
VS0031,verus,numpy_simple,NpLess-spec,,"Element-wise comparison of two vectors, returning a boolean vector indicating where the first vector is less than the second.","use vstd::prelude::*;

verus! {",,"fn less(a: Vec<i8>, b: Vec<i8>) -> (result: Vec<bool>)
    requires a.len() == b.len(),
    ensures 
        result.len() == a.len(),
        forall|i: int| 0 <= i < a@.len() ==> result@[i] == (a@[i] < b@[i])","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,DupVS01,0.85
VS0032,verus,numpy_simple,NpLessEqual-spec,,,"use vstd::prelude::*;

verus! {",,"fn less_equal(a: Vec<i8>, b: Vec<i8>) -> (result: Vec<bool>)
    requires a.len() == b.len(),
    ensures 
        result.len() == a.len(),
        forall|i: int| 0 <= i < a.len() ==> result[i] == (a[i] as int <= b[i] as int)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,DupVS00,0.85
VS0033,verus,numpy_simple,NpMax-spec,,,"use vstd::prelude::*;

verus! {",,"fn max(a: Vec<i8>) -> (result: i8)
    requires a.len() > 0,
    ensures 
        exists|i: int| 0 <= i < a@.len() && result as int == a@[i],
        forall|i: int| 0 <= i < a@.len() ==> a@[i] <= result as int","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,DupVS00,0.85
VS0034,verus,numpy_simple,NpMin-spec,,Finds the minimum element in a non-empty vector.,"use vstd::prelude::*;

verus! {",,"fn min(a: Vec<i8>) -> (result: i8)
    requires a.len() > 0,
    ensures 
        exists|i: int| 0 <= i < a@.len() && result as int == a@[i],
        forall|i: int| 0 <= i < a@.len() ==> result as int <= a@[i]","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VS0035,verus,numpy_simple,NpMod-spec,,,"use vstd::prelude::*;

verus! {",,"spec fn all_nonzero(v: Seq<i32>) -> bool {
    forall|i: int| 0 <= i < v.len() ==> v[i] != 0
}

fn mod_vec(a: Vec<i32>, b: Vec<i32>) -> (result: Vec<i32>)
    requires 
        a.len() == b.len(),
        all_nonzero(b@),
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] % b[i],","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VS0036,verus,numpy_simple,NpMultiply-spec,,Element-wise multiplication of two vectors of the same length.,"use vstd::prelude::*;

verus! {",,"fn multiply(a: Vec<i8>, b: Vec<i8>) -> (result: Vec<i8>)
    requires a.len() == b.len(),
    ensures 
        result.len() == a.len(),
        forall|i: int| 0 <= i < a.len() ==> result[i] as int == a[i] as int * b[i] as int","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VS0037,verus,numpy_simple,NpNotEqual-spec,,,"use vstd::prelude::*;

verus! {",,"fn not_equal(a: Vec<i8>, b: Vec<i8>) -> (result: Vec<bool>)
    requires a.len() == b.len(),
    ensures 
        result.len() == a.len(),
        forall|i: int| 0 <= i < a.len() ==> result[i] == (a[i] as int != b[i] as int)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,DupVS00,0.85
VS0038,verus,numpy_simple,NpPiecewise-spec,,Implements a piecewise function that applies different functions to elements based on conditions.,"use vstd::prelude::*;

verus! {",,"fn piecewise(x: Vec<f32>, condlist: Vec<spec_fn(f32) -> bool>, funclist: Vec<spec_fn(f32) -> f32>) -> (ret: Vec<f32>)
    requires condlist@.len() == funclist@.len(),
    ensures
        ret@.len() == x@.len(),
        forall|i: int, j: int| 0 <= i < x@.len() && 0 <= j < condlist@.len() && 
            condlist@[j](x@[i]) ==> ret@[i] == funclist@[j](x@[i])","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VS0039,verus,numpy_simple,NpPoly-spec,,,"use vstd::prelude::*;

verus! {",,"spec fn poly_helper_spec(roots: Seq<f32>, val: nat) -> Seq<f32>;

fn poly_helper(roots: Vec<f32>, val: u8) -> (result: Vec<f32>)
    requires 
        roots.len() > 0,
        val as nat > 0,
    ensures 
        result.len() == roots.len(),
        result.len() > 0 ==> result[0] == 1.0f32
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}

fn poly(roots: Vec<f32>) -> (result: Vec<f32>)
    requires roots.len() > 0,
    ensures 
        result.len() == roots.len(),
        forall|i: int| 0 <= i < result.len() ==> 
            result[i] == poly_helper_spec(roots@, (roots.len() - 1) as nat)[i]","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VS0040,verus,numpy_simple,NpPolyder-spec,,Computes the polynomial derivative of order m for a given polynomial represented as a vector of coefficients.,"use vstd::prelude::*;

verus! {",,"fn polyder(poly: Vec<i8>, m: i8) -> (result: Vec<i8>)
    requires 
        m > 0,
        m <= poly.len() as i8,
    ensures 
        result.len() == poly.len() - (m as usize),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VS0041,verus,numpy_simple,NpPower-spec,,,"use vstd::prelude::*;

verus! {
spec fn int_pow(base: int, exp: nat) -> int
    decreases exp
{
    if exp == 0 {
        1
    } else {
        base * int_pow(base, (exp - 1) as nat)
    }
}",,"fn power(a: Vec<i8>, b: Vec<u8>) -> (result: Vec<i8>)
    requires a.len() == b.len(),
    ensures 
        result.len() == a.len(),
        forall|i: int| 0 <= i < a@.len() ==> result@[i] == int_pow(a@[i] as int, b@[i] as nat),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VS0042,verus,numpy_simple,NpProd-spec,,,"use vstd::prelude::*;

verus! {",,"spec fn prod_spec_helper(a: Seq<i32>, start: int, finish: int) -> int
    decreases finish - start
{
    if start >= finish {
        1
    } else {
        a[start] * prod_spec_helper(a, start + 1, finish)
    }
}

spec fn prod_spec(a: Seq<i32>) -> int {
    prod_spec_helper(a, 0, a.len() as int)
}

spec fn prod_array_spec(a: Seq<i32>, start: int, finish: int) -> int {
    prod_spec_helper(a, start, finish)
}

fn prod(a: Vec<i32>) -> (result: i32)
    ensures result == prod_spec(a@)
{
    // impl-start
    assume(false);
    0
    // impl-end
}

fn prod_array(a: Vec<i32>, start: usize, finish: usize) -> (result: i32)
    requires 
        start <= finish,
        finish <= a.len(),
    ensures result == prod_array_spec(a@, start as int, finish as int)
{
    // impl-start
    assume(false);
    0
    // impl-end
}

proof fn prod_theorem(a: Vec<i32>)
    requires a.len() > 0,
    ensures 
        prod_spec(a@) == prod_array_spec(a@, 0, a.len() as int) &&
        (forall|i: int| 0 <= i < a.len() && a[i] == 0 ==> prod_spec(a@) == 0)
{
    assume(false);
}",,"
}
fn main() {}",0,,-1,-1,-1,,1.0
VS0043,verus,numpy_simple,NpRavel-spec,,Flattens a 2D matrix into a 1D vector in row-major order.,"use vstd::prelude::*;

verus! {

/* Matrix type definition: function from row,col indices to values */
type Matrix<T> = spec_fn(usize, usize) -> T;

/* Get matrix element at position (i,j) */
spec fn matrix_get<T>(mat: Matrix<T>, i: usize, j: usize) -> T {
    mat(i, j)
}

/* Matrix size helper */
spec fn matrix_size(m: usize, n: usize) -> usize {
    (m * n) as usize
}",,"fn ravel(arr: Matrix<i8>, m: usize, n: usize) -> (ret: Vec<i8>)
    requires m > 0 && n > 0,
    ensures 
        ret.len() == m * n,
        forall|i: usize, j: usize| i < m && j < n ==> 
            ret@[(i * n + j) as int] == matrix_get(arr, i, j)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,DupVS03,0.85
VS0044,verus,numpy_simple,NpRemainder-spec,,,"use vstd::prelude::*;

verus! {",,"fn remainder(a: Vec<i8>, b: Vec<i8>) -> (result: Vec<i8>)
    requires 
        a.len() == b.len(),
        forall|i: int| 0 <= i < b.len() ==> b[i] != 0,
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] % b[i],","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VS0045,verus,numpy_simple,NpReshape-spec,,,"use vstd::prelude::*;

verus! {",,"type Matrix<T> = Vec<Vec<T>>;

spec fn matrix_size<T>(mat: Matrix<T>) -> nat {
    if mat.len() == 0 { 0 } else { (mat.len() * mat[0].len()) as nat }
}

spec fn get_matrix_element<T>(mat: Matrix<T>, i: nat, j: nat) -> T {
    mat[i as int][j as int]
}

spec fn get_vector_element<T>(arr: Seq<T>, i: nat) -> T {
    arr[i as int]
}

fn reshape(arr: Vec<i32>, shape: Vec<usize>) -> (result: Matrix<i32>)
    requires 
        arr.len() > 0,
        shape.len() == 2,
        forall|i: int| 0 <= i < 2 ==> (shape[i] > 0 || shape[i] == 0),
        !(shape[0] == 0 && shape[1] == 0),
        (if shape[0] > 0 && shape[1] > 0 { 
            shape[0] * shape[1] == arr.len()
        } else if shape[0] == 0 { 
            arr.len() % shape[1] == 0
        } else { 
            arr.len() % shape[0] == 0
        }),
    ensures
        result.len() > 0,
        result[0].len() > 0,
        (if shape[0] > 0 { 
            matrix_size(result) / (if shape[1] > 0 { shape[1] as nat } else { (arr.len() / shape[0]) as nat }) == shape[0] as nat
        } else { 
            matrix_size(result) / (if shape[1] > 0 { shape[1] as nat } else { (arr.len() / shape[0]) as nat }) == (arr.len() / shape[1]) as nat
        }),
        forall|i: nat| i < arr.len() ==> #[trigger] get_vector_element(arr@, i) == result[((i as usize) / result[0].len()) as int][((i as usize) % result[0].len()) as int]","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VS0046,verus,numpy_simple,NpRightShift-spec,,,"use vstd::prelude::*;
use vstd::arithmetic::power2::pow2;

verus! {
spec fn shift_right_int(x: int, n: nat) -> int {
    if x >= 0 {
        x / (pow2(n) as int)
    } else {
        -((((-x) - 1) / (pow2(n) as int)) + 1)
    }
}",,"fn right_shift(a: Vec<i32>, b: Vec<u32>) -> (result: Vec<i32>)
    requires 
        a.len() == b.len(),
        forall|i: int| 0 <= i < b.len() ==> b[i] < 64,
    ensures 
        result.len() == a.len(),
        forall|i: int| 0 <= i < result.len() ==> 
            result[i] as int == shift_right_int(a[i] as int, b[i] as nat),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,DupVS02,0.85
VS0047,verus,numpy_simple,NpSelect-spec,,,"use vstd::prelude::*;

verus! {",,"fn select(condlist: Vec<Vec<bool>>, choicelist: Vec<Vec<f32>>) -> (result: Vec<f32>)
    requires 
        condlist@.len() > 0,
        condlist@.len() == choicelist@.len(),
        forall|i: int| 0 <= i < condlist@.len() ==> condlist@[i].len() > 0,
        forall|i: int| 0 <= i < condlist@.len() ==> condlist@[i].len() == choicelist@[i].len(),
        forall|i: int, j: int| 0 <= i < condlist@.len() && 0 <= j < condlist@.len() ==> 
            condlist@[i].len() == condlist@[j].len(),
    ensures
        result@.len() == condlist@[0].len(),
        forall|i: int, j: int| 
            0 <= i < condlist@.len() && 0 <= j < result@.len() && condlist@[i][j] ==> 
            result@[j] == choicelist@[i][j],","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VS0048,verus,numpy_simple,NpShape-spec,,Matrix and array shape computation functions,"use vstd::prelude::*;

verus! {",,"struct Matrix<T> {
    m: usize,
    n: usize,
    data: Vec<Vec<T>>,
}

impl<T> Matrix<T> {
    spec fn size(&self) -> nat {
        (self.m as nat) * (self.n as nat)
    }
}

enum Arrays {
    ArrayOne(Vec<f32>),
    ArrayTwo(Vec<Vec<f32>>),
    ArrayThree(Vec<Vec<Vec<f32>>>),
}

spec fn arrays_ndim(a: &Arrays) -> nat {
    match a {
        Arrays::ArrayOne(_) => 1nat,
        Arrays::ArrayTwo(_) => 2nat,
        Arrays::ArrayThree(_) => 3nat,
    }
}

fn shape_arrays(a: &Arrays) -> (result: Vec<usize>)
    ensures
        result.len() == arrays_ndim(a),
        match a {
            Arrays::ArrayOne(arr) => result.len() == 1 && result[0] == arr.len(),
            Arrays::ArrayTwo(arr) => result.len() == 2 && result[0] == arr.len() && 
                result[1] == (if arr.len() > 0 { arr[0].len() } else { 0 }),
            Arrays::ArrayThree(arr) => result.len() == 3 && result[0] == arr.len() && 
                result[1] == (if arr.len() > 0 { arr[0].len() } else { 0 }) &&
                result[2] == (if arr.len() > 0 && arr[0].len() > 0 { arr[0][0].len() } else { 0 })
        }
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}

fn shape_matrix(a: &Matrix<f32>) -> (result: Vec<usize>)
    ensures
        result.len() == 2,
        result[0] == a.m,
        result[1] == a.n
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}",,"
}
fn main() {}",0,,-1,-1,-1,,0.7
VS0049,verus,numpy_simple,NpSign-spec,,,"use vstd::prelude::*;

verus! {",,"fn sign(a: Vec<i32>) -> (result: Vec<i32>)
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < a.len() ==> {
            (a[i] > 0 ==> result[i] == 1) &&
            (a[i] == 0 ==> result[i] == 0) &&
            (a[i] < 0 ==> result[i] == -1)
        }","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,DupVS00,0.85
VS0050,verus,numpy_simple,NpSort-spec,,Sorts a vector of floating-point numbers in ascending order.,"use vstd::prelude::*;

verus! {
spec fn multiset_count<T>(s: Seq<T>, x: T) -> nat {
    s.filter(|y| y == x).len()
}",,"fn sort(a: Vec<i8>) -> (result: Vec<i8>)
    ensures
        result.len() == a.len(),
        forall|i: int, j: int| 0 <= i < j < result.len() ==> result[i] as int <= result[j] as int,
        forall|x: i8| multiset_count(result@, x) == multiset_count(a@, x),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VS0051,verus,numpy_simple,NpSquare-spec,,,"use vstd::prelude::*;

verus! {",,"fn square(arr: Vec<i8>) -> (result: Vec<i8>)
    ensures
        result.len() == arr.len(),
        forall|i: int| 0 <= i < arr.len() ==> result[i] as int == arr[i] as int * arr[i] as int,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,DupVS04,0.85
VS0052,verus,numpy_simple,NpSubtract-spec,,,"use vstd::prelude::*;

verus! {",,"fn subtract(a: Vec<i8>, b: Vec<i8>) -> (result: Vec<i8>)
    requires a.len() == b.len(),
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < a.len() ==> result@[i] == a@[i] - b@[i],","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,DupVS00,0.85
VS0053,verus,numpy_simple,NpSum-spec,,,"use vstd::prelude::*;

verus! {",,"spec fn sum_range(a: Seq<i32>, start: int, len: int) -> int
    decreases len
{
    if len <= 0 || start < 0 || start + len > a.len() {
        0
    } else if len == 0 {
        0
    } else {
        a[start] + sum_range(a, start + 1, len - 1)
    }
}

spec fn seq_sum(a: Seq<i32>) -> int {
    sum_range(a, 0, a.len() as int)
}

fn sum(a: Vec<i32>) -> (result: i32)
    ensures result == seq_sum(a@)
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}

fn sum_array(a: Vec<i32>, start: usize, finish: usize) -> (result: i32)
    requires start <= finish, finish <= a.len(),
    ensures result == sum_range(a@, start as int, (finish - start) as int)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VS0054,verus,numpy_simple,NpTranspose-spec,,Matrix transpose operation that swaps rows and columns.,"use vstd::prelude::*;

verus! {",,"type Matrix = Vec<Vec<i8>>;

spec fn matrix_get(mat: Matrix, i: int, j: int) -> i8
    recommends 
        0 <= i < mat.len(),
        i < mat.len() ==> 0 <= j < mat[i].len()
{
    mat[i][j]
}

spec fn matrix_rows(mat: Matrix) -> int {
    mat.len() as int
}

spec fn matrix_cols(mat: Matrix) -> int
    recommends mat.len() > 0
{
    if mat.len() > 0 { mat[0].len() as int } else { 0 }
}

spec fn matrix_size(mat: Matrix) -> int {
    matrix_rows(mat) * matrix_cols(mat)
}

fn transpose(arr: Matrix) -> (ret: Matrix)
    requires 
        arr.len() > 0,
        forall|i: int| 0 <= i < arr.len() ==> #[trigger] arr[i].len() == arr[0].len(),
    ensures
        ret.len() == arr[0].len(),
        forall|i: int| 0 <= i < ret.len() ==> #[trigger] ret[i].len() == arr.len(),
        matrix_size(ret) == matrix_cols(arr) * matrix_rows(arr),
        forall|i: int, j: int| 
            (0 <= i < matrix_rows(arr) && 0 <= j < matrix_cols(arr)) ==>
            #[trigger] matrix_get(ret, j, i) == matrix_get(arr, i, j)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VS0055,verus,numpy_simple,NpTril-spec,,,"use vstd::prelude::*;

verus! {",,"type Matrix<T> = Vec<Vec<T>>;

spec fn matrix_size<T>(m: Matrix<T>) -> nat {
    (m.len() * (if m.len() > 0 { m[0].len() } else { 0 })) as nat
}

fn tril(arr: Matrix<i8>, k: i8) -> (ret: Matrix<i8>)
    requires 
        arr.len() > 0,
        arr[0].len() > 0,
        -((arr.len() as i8) - 1) < k && k < (arr[0].len() as i8) - 1,
    ensures
        matrix_size(ret) == matrix_size(arr),
        ret.len() == arr.len(),
        forall|i: int, j: int| 
            0 <= i < arr.len() && 0 <= j < arr[0].len() ==> 
                if j - i > k as int { ret[i][j] == 0 } else { ret[i][j] == arr[i][j] }","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VS0056,verus,numpy_simple,NpUniqueall-spec,,"Removes duplicate elements from a vector, preserving the order of first occurrences.","use vstd::prelude::*;

verus! {",,"fn unique_all(arr: Vec<i8>) -> (ret: Vec<i8>)
    ensures
        ret.len() <= arr.len(),
        forall|i: int| 0 <= i < arr@.len() ==> exists|j: int| 0 <= j < ret@.len() && ret@[j] == #[trigger] arr@[i],
        forall|i: int, j: int| 0 <= i < ret@.len() && 0 <= j < i ==> ret@[i] != ret@[j],","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VS0057,verus,numpy_simple,NpWhere-spec,,Vector where functions for conditional element selection and transformation.,"use vstd::prelude::*;

verus! {",,"fn where_fn(condition: Vec<bool>, x: Vec<i8>, y: Vec<i8>) -> (result: Vec<i8>)
    requires 
        condition.len() == x.len(),
        x.len() == y.len(),
    ensures 
        result.len() == condition.len(),
        forall|i: int| 0 <= i < result.len() ==> 
            result[i] as int == if condition[i] { x[i] as int } else { y[i] as int }
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}

fn where_with_transform(arr: Vec<i8>) -> (result: Vec<i8>)
    requires arr.len() >= 0,
    ensures 
        result.len() == arr.len()
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}",,"
}
fn main() {}",0,,-1,-1,-1,,0.7
VS0058,verus,numpy_simple,NpZeros-spec,,,"use vstd::prelude::*;

verus! {",,"fn zeros(n: usize) -> (result: Vec<i8>)
    ensures 
        result@.len() == n,
        forall|i: int| 0 <= i < n ==> result@[i] == 0
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}

fn zeros2d(rows: usize, cols: usize) -> (result: Vec<Vec<i8>>)
    ensures 
        result@.len() == rows,
        forall|i: int| 0 <= i < rows ==> result@[i]@.len() == cols,
        forall|i: int, j: int| 0 <= i < rows && 0 <= j < cols ==> result@[i]@[j] == 0
{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}",,"
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0000,verus,numpy_triple,array_creation_arange,,"Return evenly spaced values within a given interval [start, stop) with given step.
Specification: arange generates evenly spaced values from start to stop (exclusive) with given step.
Each element at index i has value start + i * step, and all values are within bounds.","use vstd::prelude::*;

verus! {",,"fn arange(start: i8, stop: i8, step: i8, n: usize) -> (result: Vec<i8>)
    requires step != 0,
    ensures
        result.len() == n,
        n == 0 ==> ((step > 0 && start >= stop) || (step < 0 && start <= stop)),
        n > 0 ==> (
            forall|i: int| 0 <= i < n ==> result@[i] == start as int + i * step as int
        ),
        n > 0 && step > 0 ==> (
            start < stop &&
            forall|i: int| 0 <= i < n ==> result@[i] < stop as int
        ),
        n > 0 && step < 0 ==> (
            start > stop &&
            forall|i: int| 0 <= i < n ==> result@[i] > stop as int
        ),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0001,verus,numpy_triple,array_creation_array,,"Create an array from existing data. This is the primary array creation function.
Takes a list of Float elements and creates a Vector of the same length.

Specification: array creates a vector containing exactly the input data elements
in the same order. The result has the same length as the input list and preserves
all elements at their corresponding indices. This captures the fundamental property
of numpy.array - converting sequence-like data into array format while preserving
element values and order.","use vstd::prelude::*;

verus! {",,"fn array(data: Vec<f64>) -> (result: Vec<f64>)
    ensures
        result.len() == data.len(),
        forall|i: int| 0 <= i < data.len() ==> result[i] == data[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0002,verus,numpy_triple,array_creation_asanyarray,,"numpy.asanyarray: Convert the input to an ndarray, but pass ndarray subclasses through.

Converts the input to an ndarray, but passes ndarray subclasses through unchanged.
If the input is already an ndarray or a subclass of ndarray, it is returned as-is
and no copy is performed. For other array-like inputs, it performs conversion.

In this Vector-based specification, we model this as an identity function that
preserves the input vector unchanged, representing the common case where the
input is already an ndarray.

Specification: numpy.asanyarray returns the input vector unchanged when it's already an ndarray.

Precondition: True (no special preconditions)
Postcondition: The result is identical to the input vector - no copy is made,
               and each element remains unchanged.

This captures the key property of asanyarray: when given an ndarray (Vector in our case),
it returns the same array without copying.","use vstd::prelude::*;

verus! {",,"fn asanyarray(a: Vec<f32>) -> (result: Vec<f32>)
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < a.len() ==> result[i] == a[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0003,verus,numpy_triple,array_creation_asarray,,"numpy.asarray: Convert the input to an array.

Converts various input types (lists, tuples, existing arrays, etc.) to an array.
The function creates a new array from the input data, preserving the element
order and values. For our Vector-based specification, we model this as
converting a list of elements to a Vector.

This is a fundamental array creation function that ensures the output is
always a proper array format regardless of the input type.

Specification: numpy.asarray returns a vector containing the same elements
as the input list, in the same order.

Precondition: The input list length matches the vector size parameter
Postcondition: 
1. The result vector has the same length as the input list
2. Each element in the result vector equals the corresponding element in the input list
3. The ordering of elements is preserved","use vstd::prelude::*;

verus! {",,"fn asarray(a: Vec<f32>) -> (result: Vec<f32>)
    requires a.len() > 0,
    ensures 
        result.len() == a.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] == a[i]","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0005,verus,numpy_triple,array_creation_asmatrix,,"Interpret the input as a matrix. In our simplified model, this represents
a 1D vector as a matrix type. Since numpy.asmatrix doesn't make a copy
if the input is already a matrix or ndarray, this function acts as an
identity operation with matrix type semantics.

Specification: asmatrix interprets input data as a matrix without copying.

The function preserves the original data structure and values while
providing matrix semantics. For our Vector-based implementation, this
means the output vector has the same length and contains the same elements
as the input vector.

Key properties:
1. No copying occurs - the result has the same elements as input
2. The length is preserved  
3. Element order is preserved
4. All original values are maintained","use vstd::prelude::*;

verus! {",,"fn asmatrix(data: Vec<f32>) -> (result: Vec<f32>)
    ensures
        result.len() == data.len(),
        forall|i: int| 0 <= i < data.len() ==> result[i] == data[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0006,verus,numpy_triple,array_creation_bmat,,"Build a matrix from a 2x2 block structure using 4 input vectors.
This represents a simplified version of numpy.bmat for 2x2 block matrices.
The result is a flattened vector representing the block matrix in row-major order.

Mathematically, this constructs a 2x2 block matrix where each block is a 1×n vector:
[ topLeft    | topRight    ]
[ bottomLeft | bottomRight ]

The result is flattened as [topLeft | topRight | bottomLeft | bottomRight].

Specification: bmat constructs a 2x2 block matrix from four equal-sized vectors.
The result is a flattened vector where blocks are arranged as:
[topLeft | topRight | bottomLeft | bottomRight]
This captures the essential behavior of numpy.bmat for block matrix construction.

Precondition: True (no special preconditions for basic block matrix construction)
Postcondition: Each block is correctly placed in the flattened result","use vstd::prelude::*;

verus! {",,"fn bmat(top_left: Vec<f32>, top_right: Vec<f32>, bottom_left: Vec<f32>, bottom_right: Vec<f32>) -> (result: Vec<f32>)
    requires 
        top_left.len() == top_right.len(),
        top_left.len() == bottom_left.len(),
        top_left.len() == bottom_right.len(),
    ensures
        result.len() == 4 * top_left.len(),
        forall|i: int| 0 <= i < top_left.len() ==> result[i] == top_left[i],
        forall|i: int| 0 <= i < top_right.len() ==> result[i + top_left.len()] == top_right[i],
        forall|i: int| 0 <= i < bottom_left.len() ==> result[i + 2 * top_left.len()] == bottom_left[i],
        forall|i: int| 0 <= i < bottom_right.len() ==> result[i + 3 * top_left.len()] == bottom_right[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0007,verus,numpy_triple,array_creation_copy,,"Return an array copy of the given object.
The copy has the same shape and values as the original array, 
but occupies different memory locations.

Specification: copy returns a vector with identical values but independent memory.
The resulting vector has the same size and all elements equal to the original,
ensuring that the copy is element-wise equivalent to the original.","use vstd::prelude::*;

verus! {",,"fn copy<T: Copy>(a: &Vec<T>) -> (result: Vec<T>)
    ensures 
        result.len() == a.len(),
        forall|i: int| 0 <= i < a.len() ==> result[i] == a[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0008,verus,numpy_triple,array_creation_diag,,"Extract a diagonal or construct a diagonal array

Construct a diagonal matrix from a 1-D vector

Specification: diag constructs a square matrix with v on the main diagonal.

This captures the mathematical property that numpy.diag(v) creates a matrix M
where M[i,i] = v[i] for all i, and M[i,j] = 0 for all i ≠ j.

The result is an n×n matrix where:
- The main diagonal contains the elements of the input vector v
- All off-diagonal elements are zero
- This represents the canonical way to construct a diagonal matrix

Mathematical properties verified:
1. Diagonal elements equality: M[i,i] = v[i]
2. Off-diagonal zeros: M[i,j] = 0 for i ≠ j
3. Diagonal matrix property: non-zero elements only on diagonal
4. Trace property: tr(M) = sum(v)
5. Symmetry: M is a symmetric matrix
6. Idempotence property: diag(diag(M)) reconstructs M for diagonal matrices
7. Zero count: exactly n elements are non-zero (assuming v has no zeros)","use vstd::prelude::*;

verus! {",,"fn diag(v: Vec<f32>) -> (result: Vec<Vec<f32>>)
    requires v.len() > 0,
    ensures 
        result.len() == v.len(),
        forall|i: int| 0 <= i < v@.len() ==> result@[i].len() == v@.len(),
        /* Elements on the main diagonal are from v */
        forall|i: int| 0 <= i < v@.len() ==> result@[i][i] == v@[i],
        /* All off-diagonal elements are zero */
        forall|i: int, j: int| 0 <= i < v@.len() && 0 <= j < v@.len() && i != j ==> result@[i][j] == 0.0f32,
        /* Diagonal matrix property - non-zero elements only on diagonal */
        forall|i: int, j: int| 0 <= i < v@.len() && 0 <= j < v@.len() && result@[i][j] != 0.0f32 ==> i == j,
        /* The resulting matrix is symmetric */
        forall|i: int, j: int| 0 <= i < v@.len() && 0 <= j < v@.len() ==> result@[i][j] == result@[j][i],
        /* Each row has exactly one non-zero element at position i (unless v[i] = 0) */
        forall|i: int| 0 <= i < v@.len() && v@[i] != 0.0f32 ==> {
            result@[i][i] != 0.0f32 && 
            forall|j: int| 0 <= j < v@.len() && j != i ==> result@[i][j] == 0.0f32
        },
        /* Each column has exactly one non-zero element at position j (unless v[j] = 0) */
        forall|j: int| 0 <= j < v@.len() && v@[j] != 0.0f32 ==> {
            result@[j][j] != 0.0f32 && 
            forall|i: int| 0 <= i < v@.len() && i != j ==> result@[i][j] == 0.0f32
        }","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0010,verus,numpy_triple,array_creation_empty,,"numpy.empty: Return a new array of given shape and type, without initializing entries.

Creates a new vector of the specified length containing uninitialized (arbitrary) values.
This is a low-level function that allocates memory without setting initial values,
making it potentially faster than other array creation functions.

For 1D arrays, this takes a size parameter n and returns a Vector Float n
with arbitrary values.

Specification: numpy.empty returns a vector of the specified size with arbitrary values.

Properties:
1. The returned vector has exactly n elements (guaranteed by type)
2. Each element in the vector is a valid Float value
3. The vector is well-formed - all indices are accessible
4. No guarantees are made about the actual values - they are arbitrary/uninitialized

Mathematical properties:
- Size property: The length of the result is exactly n
- Accessibility property: All elements from index 0 to n-1 are accessible via get
- Value existence: Each position contains some Float value (but we don't specify which)

This specification captures the key behavior of numpy.empty: it returns a properly
sized array but makes no promises about the contents, which distinguishes it from
functions like zeros() or ones() that guarantee specific initial values.","use vstd::prelude::*;

verus! {",,"fn empty(n: u8) -> (result: Vec<f64>)
    ensures result.len() == n as usize","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0013,verus,numpy_triple,array_creation_from_dlpack,,"Create a NumPy array from an object implementing the DLPack protocol. This function allows for interoperability with other libraries that support the DLPack protocol.

/* Abstract type representing a DLPack-compatible object */","use vstd::prelude::*;

verus! {

pub struct DLPackObject<T> {
    pub data: Vec<T>,
    pub has_dlpack: bool,
    pub has_dlpack_device: bool,
    pub device: String,
}",,"fn from_dlpack<T>(x: &DLPackObject<T>, device: Option<&str>, copy: Option<bool>) -> (result: Vec<T>)
    requires 
        x.has_dlpack && x.has_dlpack_device,
        device.is_none() || device == Some(""cpu""),
    ensures
        result.len() == x.data.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] == x.data[i],
        copy == Some(true) ==> result@ != x.data@,
        copy == Some(false) ==> result@ == x.data@,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0014,verus,numpy_triple,array_creation_frombuffer,,"Interpret a buffer as a 1-dimensional array.
Takes a buffer (represented as a Vector of bytes), the count of elements to read,
and an offset (starting position in bytes) to create a Vector of the specified type.
This models numpy.frombuffer which interprets raw bytes as typed array elements.

Specification: frombuffer interprets raw bytes from a buffer as a typed array.
The function reads 'count' elements starting from 'offset' bytes into the buffer.
The result is a Vector containing the selected bytes in the same order
as they appear in the buffer. Key properties:
1. Buffer must have sufficient bytes for the requested elements
2. Offset must be within buffer bounds when count > 0
3. Elements are read sequentially from the buffer starting at offset
4. The result preserves the sequential order of elements in the buffer
5. Each output element corresponds to exactly one input buffer byte","use vstd::prelude::*;

verus! {",,"fn frombuffer(buffer: &Vec<u8>, count: usize, offset: usize) -> (result: Vec<u8>)
    requires 
        offset + count <= buffer.len(),
        offset < buffer.len() || count == 0,
    ensures
        result.len() == count,
        forall|i: int| 0 <= i < count ==> result[i] == buffer[offset + i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0015,verus,numpy_triple,array_creation_fromfile,,"Construct a vector from data in a file. 

Specification: fromfile reads data from a file into a vector

Based on numpy.fromfile - Construct an array from data in a text or binary file.

Parameters:
- file: File object or filename containing data
- dtype: Data type of the returned array  
- count: Number of items to read (-1 means all items)
- sep: Separator between items for text files (empty means binary)
- offset: The offset in bytes from file's current position
- like: Reference object for array creation

Returns an array of data from the file. Note that binary files generated are not platform independent.

/* Abstract file representation for specification purposes */","use vstd::prelude::*;

verus! {

pub struct FileData {
    pub content: Seq<f64>,
    pub valid: bool,
}",,"fn fromfile(n: usize, file: &FileData, count: i32, offset: usize) -> (result: Vec<f64>)
    requires 
        file.valid == true,
        count == (n as i32) || count == -1,
        offset <= file.content.len(),
        file.content.len() - offset >= n,
    ensures 
        result.len() == n,
        forall|i: int| 0 <= i < n ==> result[i] == file.content[offset + i],
        n <= file.content.len() - offset,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0016,verus,numpy_triple,array_creation_fromfunction,,"Construct a vector by executing a function over each coordinate index.
For 1D case, this creates a vector of length n where element i is f(i).

Specification: fromfunction creates a vector where each element is the result
of applying the function to its index position.","use vstd::prelude::*;

verus! {",,"fn fromfunction(n: usize, f: spec_fn(usize) -> f32) -> (result: Vec<f32>)
    ensures
        result.len() == n,
        forall|i: int| 0 <= i < n ==> result[i] == f(i as usize)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0017,verus,numpy_triple,array_creation_fromiter,,"Create a new 1-dimensional array from an iterable object.
Takes the first n elements from the iterable sequence and creates a Vector.
This models numpy.fromiter with explicit count parameter.

Specification: fromiter creates a Vector containing the first n elements 
from the iterable in order. The resulting Vector has exactly n elements,
and each element at index i equals the i-th element from the iterable.","use vstd::prelude::*;

verus! {",,"fn fromiter<T: Copy>(n: usize, iter: spec_fn(usize) -> T) -> (result: Vec<T>)
    ensures
        result.len() == n,
        forall|i: int| 0 <= i < n ==> result[i] == iter(i as usize)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0018,verus,numpy_triple,array_creation_fromstring,,"A new 1-D array initialized from text data in a string

Specification: fromstring parses a string into a vector of floats using a separator","use vstd::prelude::*;

verus! {",,"fn fromstring(input: Vec<char>, sep: Vec<char>) -> (result: Vec<f32>)
    requires
        sep.len() > 0,
        input.len() > 0,
    ensures
        result.len() > 0,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0019,verus,numpy_triple,array_creation_full,,"numpy.full: Return a new array of given shape and type, filled with fill_value.

Creates a new vector of size n where every element is set to the specified
fill_value. This is the 1D version of numpy.full, focusing on the core
functionality of creating uniform arrays.

The function creates a vector filled with identical values, which is useful
for initialization and creating constant arrays.

Specification: numpy.full returns a vector where every element equals fill_value.

This specification captures the complete mathematical behavior of numpy.full:

1. **Sanity checks**:
   - The result vector has exactly n elements (enforced by type)
   - The function is deterministic (same inputs always produce same output)

2. **Core property**: Every element in the result equals fill_value
   - ∀ i : Fin n, result[i] = fill_value

3. **Mathematical properties**:
   - Uniformity: All elements are identical
   - Idempotence of fill value: Filling with the same value multiple times yields the same result
   - Independence from index: The value at any position doesn't depend on the position

4. **Additional properties**:
   - For n = 0, the result is an empty vector
   - For n > 0, all elements are equal to each other
   - The result is functionally equivalent to Vector.replicate n fill_value

5. **Relationship properties**:
   - full α n v is equivalent to creating an array and setting each element to v
   - If two vectors are created with full using the same fill_value and size,
     they are element-wise equal
   - full preserves the fill_value exactly (no transformation or casting)

/* Core property: every element equals fill_value */

/* Uniformity property: all elements are equal to each other */

/* First and last element property (when n > 0) */","use vstd::prelude::*;

verus! {",,"fn full<T>(n: usize, fill_value: T) -> (result: Vec<T>)
    ensures 
        result.len() == n,

        forall|i: int| 0 <= i < n ==> result[i] == fill_value,

        forall|i: int, j: int| 0 <= i < n && 0 <= j < n ==> result[i] == result[j],

        n > 0 ==> result[0] == fill_value,
        n > 0 ==> result[(n-1) as int] == fill_value,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0020,verus,numpy_triple,array_creation_full_like,,"numpy.full_like: Return a full array with the same shape and type as a given array.

Creates a new array with the same shape as the input array `a`, where all
elements are set to the specified `fill_value`. This is useful for creating
arrays of a specific constant value while preserving the shape of an existing
array.

The actual type of fill_value will be cast to match the array's type,
similar to numpy's behavior where 0.1 becomes 0 for integer arrays.

Specification: numpy.full_like returns a vector with the same shape as `a`
where every element equals `fill_value`.

Precondition: True (no special preconditions needed)
Postcondition: The result has the same length as `a` and all elements equal `fill_value`","use vstd::prelude::*;

verus! {",,"fn numpy_full_like(a: Vec<f32>, fill_value: f32) -> (result: Vec<f32>)
    ensures 
        result.len() == a.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] == fill_value,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0021,verus,numpy_triple,array_creation_geomspace,,"Return numbers spaced evenly on a log scale (a geometric progression).
Each output sample is a constant multiple of the previous one.

Specification: geomspace returns a geometric progression from start to stop.
- The first element is always start
- If endpoint is true and n > 1, the last element is stop
- All elements form a geometric progression (constant ratio between consecutive elements)
- Neither start nor stop can be zero","use vstd::prelude::*;

verus! {",,"fn geomspace(start: f64, stop: f64, n: usize, endpoint: bool) -> (result: Vec<f64>)
    requires 
        start != 0.0,
        stop != 0.0,
        n > 0,
    ensures
        result.len() == n,
        n > 0 ==> result[0] == start,
        (endpoint && n > 1) ==> result[(n - 1) as int] == stop,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0022,verus,numpy_triple,array_creation_identity,,"Return the identity matrix of size n×n.
The identity matrix is a square matrix with ones on the main diagonal
and zeros elsewhere.

Specification: identity returns an n×n matrix where:
- diagonal elements (i,i) are 1.0
- off-diagonal elements (i,j) where i≠j are 0.0","use vstd::prelude::*;

verus! {",,"fn identity(n: usize) -> (result: Vec<Vec<f64>>)
    ensures
        result.len() == n,
        forall|i: int| 0 <= i < n ==> result[i].len() == n,
        forall|i: int, j: int| 0 <= i < n && 0 <= j < n ==>
            result[i][j] == if i == j { 1.0 } else { 0.0 }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0023,verus,numpy_triple,array_creation_linspace,,"numpy.linspace: Return evenly spaced numbers over a specified interval.

Returns num evenly spaced samples, calculated over the interval [start, stop]
when endpoint is true (default), or [start, stop) when endpoint is false.

This specification focuses on the most common use case where endpoint=true,
returning num samples that are evenly distributed from start to stop inclusive.

Specification: numpy.linspace returns a vector of evenly spaced values.

When num > 0 and endpoint=true (default behavior):
- The first element equals start
- The last element equals stop (when num > 1)
- Elements are evenly spaced with step = (stop - start) / (num - 1) when num > 1
- When num = 1, the single element equals start

Mathematical properties:
- For any valid index i, the element value is: start + i * step
- The spacing between consecutive elements is constant (except when num = 1)
- The sequence is monotonic (increasing if start < stop, decreasing if start > stop)
- All elements lie within [min(start, stop), max(start, stop)]
- Linear interpolation property: each element represents a linear interpolation between start and stop

Sanity checks:
- Size of result vector equals num
- When start = stop, all elements equal start
- The function is symmetric: reversing start and stop reverses the sequence
- Consecutive differences are constant for num > 2","use vstd::prelude::*;

verus! {",,"fn linspace(start: f32, stop: f32, num: usize) -> (result: Vec<f32>)
    requires num > 0,
    ensures
        result.len() == num,
        result[0] == start,
        (num == 1 ==> forall|i: int| 0 <= i < num ==> result[i] == start),
        (num > 1 ==> result[num - 1] == stop)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0024,verus,numpy_triple,array_creation_loadtxt,,"Load data from a text file containing numeric values.
This simplified version assumes:
- The file contains floating-point numbers (one per line or whitespace-separated)
- Comments starting with '#' are ignored
- The skiprows parameter allows skipping initial lines
Returns a vector of parsed float values.

Specification: loadtxt reads numeric data from a text file and returns a vector of floats.
The preconditions ensure:
- The file path is valid (non-empty string)
- After skipping skiprows lines and removing comments, there are exactly n valid float values

The postcondition guarantees:
- The result vector contains the float values parsed from the file
- Values appear in the same order as in the file (after skipping and comment removal)
- The size of the result matches the type-level size n

Mathematical properties:
- Deterministic: same file and parameters always produce the same result
- Order-preserving: maintains the sequential order of values in the file
- Comment-aware: lines starting with '#' are ignored
- Skip-aware: first skiprows lines are ignored","use vstd::prelude::*;

verus! {",,"fn loadtxt(fname_len: u8, skiprows: u8) -> (result: Vec<f64>)
    requires 
        fname_len as nat > 0,
        skiprows as nat >= 0,
    ensures
        result@.len() >= 0,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0025,verus,numpy_triple,array_creation_logspace,,"Return numbers spaced evenly on a log scale.

Creates a vector of `num` samples where each element is computed as:
- When endpoint=true: base^(start + i * (stop - start) / (num - 1)) for i in 0..num-1
- When endpoint=false: base^(start + i * (stop - start) / num) for i in 0..num-1

The samples are evenly spaced in log space, meaning the exponents form an arithmetic sequence.

Specification: logspace generates numbers evenly spaced on a logarithmic scale.

The function produces a vector where:
1. For endpoint=true: Elements follow base^(interpolated exponent) where exponents 
   are linearly interpolated from start to stop inclusive
2. For endpoint=false: Similar but stop value is excluded from the range
3. The base must be positive and not equal to 1 for meaningful results
4. For num > 1, the spacing between consecutive log values is uniform","use vstd::prelude::*;

verus! {",,"fn logspace(start: i8, stop: i8, endpoint: bool, base: i8, num: usize) -> (result: Vec<i8>)
    requires 
        base as int > 0,
        base as int != 1,
        num > 0,
    ensures
        result.len() == num,
        forall|i: int| 0 <= i < num ==> result@[i] as int > 0,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0026,verus,numpy_triple,array_creation_meshgrid,,"Return coordinate matrices from two coordinate vectors using 'xy' (Cartesian) indexing.
For inputs of length m and n, returns two matrices of shape (n, m) where:
- The first matrix has x values repeated along rows
- The second matrix has y values repeated along columns

Specification: meshgrid creates coordinate matrices where x values are repeated 
along rows and y values are repeated along columns in 'xy' indexing mode","use vstd::prelude::*;

verus! {",,"fn meshgrid(x: Vec<f32>, y: Vec<f32>) -> (result: (Vec<Vec<f32>>, Vec<Vec<f32>>))
    requires 
        x.len() > 0,
        y.len() > 0,
    ensures
        result.0.len() == y.len(),
        result.1.len() == y.len(),
        forall|i: int| 0 <= i < y.len() ==> result.0[i].len() == x.len(),
        forall|i: int| 0 <= i < y.len() ==> result.1[i].len() == x.len(),
        forall|i: int, j: int| 0 <= i < y.len() && 0 <= j < x.len() ==> result.0[i][j] == x[j],
        forall|i: int, j: int| 0 <= i < y.len() && 0 <= j < x.len() ==> result.1[i][j] == y[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0027,verus,numpy_triple,array_creation_mgrid,,"An instance which returns a dense multi-dimensional meshgrid

An instance of numpy.lib.ndmgr.MGridClass which, when indexed, returns a dense multi-dimensional meshgrid.

Parameters
----------
[slice1, slice2, ..., sliceN] : slice objects or integers
    If the input is a slice, the syntax start:stop:step is equivalent to np.arange(start, stop, step) 
    inside of the brackets. If the input is an integer, the syntax i is equivalent to np.arange(i)+1.

Returns
-------
out : one ndarray or tuple of ndarrays
    If only one slice is passed, returns an array. If multiple slices are passed, returns a tuple 
    of arrays with one array for each dimension.

Creates a 1D meshgrid from start to stop with step size.
This is a simplified version of mgrid that handles only the single-slice case.

Specification: mgrid creates a vector of evenly spaced values from start to stop (exclusive) with given step","use vstd::prelude::*;

verus! {",,"fn mgrid(start: i8, stop: i8, step: i8, n: usize) -> (result: Vec<i8>)
    requires
        step > 0,
        start < stop,
        n == ((stop as int - start as int) / step as int) as usize,
    ensures
        result@.len() == n,
        forall|i: int| 0 <= i < result@.len() ==> #[trigger] result@[i] == start as int + i * step as int,
        forall|i: int| 0 <= i < result@.len() ==> #[trigger] result@[i] < stop as int,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0028,verus,numpy_triple,array_creation_ogrid,,"Create a 1D open grid from start to stop with n evenly spaced points.
This is a simplified version of ogrid that handles the common case of
creating a single evenly-spaced vector (like ogrid[start:stop:nj]).

Specification: ogrid creates n evenly spaced points from start to stop (inclusive).
When n > 1, the spacing between consecutive points is (stop - start) / (n - 1).
For n = 1, the single point is at start.","use vstd::prelude::*;

verus! {",,"fn ogrid(start: f32, stop: f32, n: usize) -> (result: Vec<f32>)
    requires n > 0,
    ensures 
        result.len() == n,
        (n == 1 ==> result[0] == start),
        (n > 1 ==> result[0] == start),
        (n > 1 ==> result[n - 1] == stop),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0029,verus,numpy_triple,array_creation_ones,,"Return a new vector of given size filled with ones.

This function creates a vector where every element is exactly 1.0,
matching NumPy's ones function behavior for 1D arrays.

Specification: ones returns a vector where all elements are exactly 1.0.

This specification captures the following properties:
1. **Correctness**: Every element in the returned vector equals 1.0
2. **Uniformity**: All elements are identical (constant vector)
3. **Non-negativity**: All elements are positive (1.0 > 0)
4. **Identity property**: Multiplying any value by an element gives the same value
5. **Type Safety**: The returned vector has exactly n elements (enforced by type)

Mathematical Properties verified:
- ∀ i : Fin n, result[i] = 1.0 (all elements are exactly one)
- ∀ i j : Fin n, result[i] = result[j] (uniformity/constant vector)
- ∀ i : Fin n, result[i] > 0 (positivity)
- ∀ i : Fin n, ∀ x : Float, x * result[i] = x (multiplicative identity)

Edge cases handled:
- When n = 0, returns an empty vector (trivially satisfies all properties)
- When n > 0, all indices contain exactly 1.0","use vstd::prelude::*;

verus! {",,"fn ones(n: usize) -> (result: Vec<i8>)
    ensures
        result.len() == n,
        forall|i: int| 0 <= i < n ==> result[i] as int == 1,
        forall|i: int, j: int| 0 <= i < n && 0 <= j < n ==> result[i] == result[j],
        forall|i: int| 0 <= i < n ==> result[i] as int > 0,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0030,verus,numpy_triple,array_creation_ones_like,,"Return a vector of ones with the same length as the input vector.
This is the 1D version of numpy.ones_like which creates a new vector
filled with ones, having the same size as the input vector.

Specification: ones_like returns a vector where every element is 1,
with the same length as the input vector.

Mathematical properties:
1. The result has the same length as the input (enforced by type system)
2. Every element in the result is exactly 1
3. The result is independent of the input values (only depends on shape)","use vstd::prelude::*;

verus! {",,"fn ones_like<T>(a: &Vec<T>) -> (result: Vec<i32>)
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] == 1,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0031,verus,numpy_triple,array_creation_tri,,"An array with ones at and below the given diagonal and zeros elsewhere.

Creates a matrix of shape (N, M) where T[i,j] = 1 if j ≤ i + k, and 0 otherwise.
The parameter k controls the diagonal: k = 0 is the main diagonal,
k < 0 is below it, and k > 0 is above it.

Specification: tri creates a lower triangular matrix with specified diagonal offset.

The resulting matrix has ones at and below the k-th diagonal, zeros elsewhere.
For each position (i, j):
- If j ≤ i + k, then the value is 1.0
- Otherwise, the value is 0.0

This captures the mathematical property that defines a generalized lower triangular matrix.","use vstd::prelude::*;

verus! {",,"fn tri(n: usize, m: usize, k: i32) -> (result: Vec<Vec<f64>>)
    ensures
        result.len() == n,
        forall|i: int| 0 <= i < n ==> result[i].len() == m,
        forall|i: int, j: int| 0 <= i < n && 0 <= j < m ==> 
            result[i][j] == if j <= i + k { 1.0 } else { 0.0 }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0032,verus,numpy_triple,array_creation_tril,,"numpy.tril: Lower triangle of a matrix.

Returns a copy of the input matrix with elements above the k-th diagonal zeroed.

- k = 0 (default): zeros elements above the main diagonal
- k < 0: zeros elements above the k-th diagonal below the main diagonal
- k > 0: zeros elements above the k-th diagonal above the main diagonal

For a matrix element at position (i, j):
- It is kept if i >= j - k
- It is zeroed if i < j - k

Specification: tril returns a lower triangular matrix by zeroing elements above the k-th diagonal.

Mathematical Properties:
1. Shape preservation: The output matrix has the same dimensions as the input
2. Lower triangle preservation: Elements on or below the k-th diagonal are unchanged
3. Upper triangle zeroing: Elements above the k-th diagonal are set to zero
4. Diagonal selection: The k parameter controls which diagonal forms the boundary
   - k = 0: main diagonal (default)
   - k < 0: diagonal below the main diagonal
   - k > 0: diagonal above the main diagonal
5. Idempotency: Applying tril twice with the same k yields the same result

Element-wise specification:
For each element at position (i, j):
- If i ≥ j - k (on or below the k-th diagonal), the element is preserved
- If i < j - k (above the k-th diagonal), the element is set to 0

Special cases:
- k ≥ cols: All elements are preserved (entire matrix is ""lower triangular"")
- k ≤ -rows: All elements are zeroed (no elements are ""on or below"" such a diagonal)","use vstd::prelude::*;

verus! {",,"fn tril(m: Vec<Vec<f64>>, k: i32) -> (result: Vec<Vec<f64>>)
    requires 
        m.len() > 0,
        forall|i: int| 0 <= i < m.len() ==> #[trigger] m[i].len() == m[0].len(),
    ensures
        result.len() == m.len(),
        forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i].len() == m[0].len(),
        forall|i: int, j: int| 
            0 <= i < result.len() && 0 <= j < result[i].len() ==> 
            #[trigger] result[i][j] == if i >= j - k { m[i][j] } else { 0.0 },","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0033,verus,numpy_triple,array_creation_triu,,"Upper triangle of a matrix.

Returns a copy of a matrix with the elements below the k-th diagonal zeroed.
- k = 0: main diagonal (default)
- k < 0: include |k| diagonals below the main diagonal
- k > 0: zero out k diagonals above the main diagonal as well

Specification: triu returns an upper triangular matrix with specific properties.

Core behavior:
- Elements below the k-th diagonal are zeroed
- Elements on and above the k-th diagonal are preserved

Mathematical properties:
1. Element-wise specification: result[i][j] = if i > j - k then 0 else m[i][j]
2. Preservation of dimensions: result has same shape as input
3. Diagonal control: k parameter shifts which diagonal forms the boundary
4. Idempotence: applying triu twice with same k gives same result
5. Special cases:
   - k = 0: standard upper triangular (zeros below main diagonal)
   - k < 0: includes |k| diagonals below main diagonal in upper triangle
   - k > 0: zeros out k additional diagonals above main diagonal
6. For square matrices when k = 0, all elements where row_index > column_index are zero","use vstd::prelude::*;

verus! {",,"fn triu(m: &Vec<Vec<f32>>, k: i8) -> (result: Vec<Vec<f32>>)
    requires 
        m@.len() > 0,
        forall|i: int| 0 <= i < m@.len() ==> #[trigger] m@[i].len() == m@[0].len(),
    ensures
        result@.len() == m@.len(),
        forall|i: int| 0 <= i < result@.len() ==> #[trigger] result@[i].len() == m@[i].len(),
        forall|i: int, j: int| 
            0 <= i < result@.len() && 0 <= j < result@[i].len() ==>
            #[trigger] result@[i][j] == if i > j - k as int { 0.0f32 } else { m@[i][j] },
        forall|i: int, j: int|
            0 <= i < result@.len() && 0 <= j < result@[i].len() && i <= j - k as int ==>
            #[trigger] result@[i][j] == m@[i][j],
        forall|i: int, j: int|
            0 <= i < result@.len() && 0 <= j < result@[i].len() && i > j - k as int ==>
            #[trigger] result@[i][j] == 0.0f32,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0034,verus,numpy_triple,array_creation_vander,,"Generate a Vandermonde matrix with decreasing powers (default behavior).
The Vandermonde matrix is a matrix with terms of a geometric progression in each row.
For a 1D input vector x of length n and specified number of columns m,
the output is an n×m matrix where entry (i,j) = x[i]^(m-1-j)

Specification: vander generates a Vandermonde matrix where each row contains
powers of the corresponding element from the input vector.
In the default decreasing mode, column j contains x^(m-1-j) for each element x.
This means the first column has the highest powers and the last column has x^0 = 1.","use vstd::prelude::*;

verus! {
spec fn pow_int(base: int, exp: nat) -> int
    decreases exp
{
    if exp == 0 {
        1
    } else {
        base * pow_int(base, (exp - 1) as nat)
    }
}",,"fn vander(x: Vec<i8>, m: usize) -> (result: Vec<Vec<i8>>)
    requires 
        x@.len() > 0,
        m > 0,
    ensures
        result@.len() == x@.len(),
        forall|i: int| 0 <= i < result@.len() ==> result@[i]@.len() == m,
        forall|i: int, j: int| 0 <= i < result@.len() && 0 <= j < m ==> 
            result@[i]@[j] as int == pow_int(x@[i] as int, (m - 1 - j) as nat),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0036,verus,numpy_triple,array_creation_zeros_like,,"Return a vector of zeros with the same length as the input vector.
This is the 1D version of numpy.zeros_like which creates a new vector
filled with zeros, having the same size as the input vector.

Specification: zeros_like returns a vector where every element is 0,
with the same length as the input vector.

Mathematical properties:
1. The result has the same length as the input (enforced by type system)
2. Every element in the result is exactly 0
3. The result is independent of the input values (only depends on shape)
4. The result is the additive identity for vector addition
5. For numeric types, the sum of all elements is zero","use vstd::prelude::*;

verus! {",,"fn zeros_like(a: &Vec<i32>) -> (result: Vec<i32>)
    ensures 
        result.len() == a.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] == 0,
        forall|v: &Vec<i32>| v.len() == result.len() ==> {
            forall|i: int| 0 <= i < result.len() ==> 
                result[i] + v[i] == v[i] && v[i] + result[i] == v[i]
        }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0037,verus,numpy_triple,array_manipulation_append,,"numpy.append: Append values to the end of an array.

For 1D arrays without axis specification, this function flattens both 
arrays and concatenates them. The result is a 1D array containing all 
elements from arr followed by all elements from values.

This is a fundamental array manipulation operation that creates a new
array by joining two arrays end-to-end. Unlike in-place operations,
this always returns a new array.

Specification: numpy.append creates a new array containing all elements
from arr followed by all elements from values.

Precondition: True (no special preconditions for basic append)
Postcondition: 
- The first n elements of the result come from arr
- The next m elements come from values
- The order of elements is preserved from both input arrays","use vstd::prelude::*;

verus! {",,"fn numpy_append(arr: Vec<f32>, values: Vec<f32>) -> (result: Vec<f32>)
    ensures
        result.len() == arr.len() + values.len(),
        forall|i: int| 0 <= i < arr.len() ==> result[i] == arr[i],
        forall|j: int| 0 <= j < values.len() ==> result[arr.len() + j] == values[j],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0038,verus,numpy_triple,array_manipulation_array_split,,"Split an array into multiple sub-arrays.

Please refer to the split documentation. The only difference
between these functions is that array_split allows
indices_or_sections to be an integer that does *not* equally
divide the axis. For an array of length l that should be split
into n sections, it returns l % n sub-arrays of size l//n + 1
and the rest of size l//n.

Split a vector into k sub-vectors.

When splitting a vector of length n into k sections:
- The first (n % k) sub-vectors have size ⌈n/k⌉ = (n + k - 1) / k
- The remaining sub-vectors have size ⌊n/k⌋ = n / k

This ensures all elements are distributed as evenly as possible,
with larger sub-vectors appearing first.

Specification: array_split distributes elements evenly with mathematical properties

The specification captures:
1. Size distribution: larger chunks come first
2. Element preservation: all elements from the original vector appear in order
3. No gaps or overlaps: elements are contiguously distributed","use vstd::prelude::*;

verus! {
spec fn chunk_size(i: int, n: int, k: int) -> int {
    if i < n % k {
        (n + k - 1) / k
    } else {
        n / k
    }
}

spec fn start_index(i: int, n: int, k: int) -> int 
    decreases i
{
    if i <= 0 {
        0
    } else {
        start_index(i - 1, n, k) + chunk_size(i - 1, n, k)
    }
}",,"fn array_split(v: Vec<i8>, k: usize) -> (result: Vec<Vec<i8>>)
    requires k > 0,
    ensures
        result.len() == k,
        /* Each sub-vector has the correct size based on its position */
        forall|i: int| 0 <= i < k as int ==> #[trigger] result[i].len() == chunk_size(i, v.len() as int, k as int),
        /* Elements are preserved in order across all sub-vectors */
        forall|i: int, j: int| 0 <= i < k as int && 0 <= j < result[i].len() ==> 
            #[trigger] result[i][j] == v[start_index(i, v.len() as int, k as int) + j]","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0039,verus,numpy_triple,array_manipulation_atleast_1d,,"numpy.atleast_1d: Convert inputs to arrays with at least one dimension.

This function ensures that the input has at least one dimension.
- Scalar inputs are converted to 1-dimensional arrays with a single element
- Higher-dimensional inputs (vectors) are preserved unchanged

For the Vector-based implementation, we provide a version that takes
a vector and returns it unchanged, since Vectors already have at least
one dimension by construction.

Specification: atleast_1d returns the input vector unchanged.

Since Vectors in Lean already have at least one dimension by their type,
this function acts as an identity function for vectors.

Precondition: True (no special preconditions)
Postcondition: The result is identical to the input vector","use vstd::prelude::*;

verus! {",,"fn atleast_1d(arr: Vec<f64>) -> (result: Vec<f64>)
    ensures
        result == arr,
        forall|i: int| 0 <= i < arr.len() ==> result[i] == arr[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0040,verus,numpy_triple,array_manipulation_atleast_2d,,"numpy.atleast_2d: View inputs as arrays with at least two dimensions.

For a 1D vector input, this function converts it to a 2D array (matrix)
with shape (1, n), where the input becomes the single row of the matrix.

This specification focuses on the 1D to 2D case, which is the most common
use case for ensuring arrays have at least 2 dimensions.

Specification: atleast_2d converts a 1D vector to a 2D matrix with one row.

This specification includes:
1. Sanity check: The result has exactly 1 row
2. Shape property: The result's shape is (1, n) where n is the input length
3. Value preservation: All elements from the input are preserved in order
4. Mathematical property: The operation is essentially a row vector representation

Precondition: True (no special preconditions)
Postcondition: 
- The result is a matrix with 1 row and n columns
- The single row contains all elements from the input vector in the same order
- The transformation preserves all numerical values exactly","use vstd::prelude::*;

verus! {",,"fn atleast_2d(arr: Vec<f32>) -> (result: Vec<Vec<f32>>)
    ensures 
        result.len() == 1,
        exists|row: Vec<f32>| result[0] == row && 
        row.len() == arr.len() &&
        forall|i: int| 0 <= i < arr.len() ==> row[i] == arr[i]","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0043,verus,numpy_triple,array_manipulation_broadcast,,"numpy.broadcast: Produce an object that mimics broadcasting between two vectors.

This simplified version handles broadcasting between a column vector (m × 1)
and a row vector (1 × n), producing an object that represents the m × n
broadcast result.

The broadcast object allows iteration over all element pairs that would
result from the broadcasting operation.

Specification: broadcast creates an object that correctly pairs elements
according to NumPy broadcasting rules.

For a column vector x of shape (m, 1) and row vector y of shape (1, n),
the broadcast object has shape (m, n) and element (i, j) is the pair (x[i], y[j]).

Preconditions: 
- m > 0 (x is non-empty)
- n > 0 (y is non-empty)

Postconditions:
- The resulting shape is (m, n)
- Element at position (i, j) is the pair (x[i], y[j])

/* Structure representing a broadcast object for two vectors.

   A broadcast object encapsulates the result of broadcasting two vectors
   against each other. It produces pairs of elements following NumPy's
   broadcasting rules. */

/* The data from the first vector */

/* The data from the second vector */

/* The resulting shape after broadcasting */","use vstd::prelude::*;

verus! {

struct BroadcastObject {

    x_data: Vec<f32>,

    y_data: Vec<f32>,

    shape: (usize, usize),
}

impl BroadcastObject {
    spec fn well_formed(&self) -> bool {
        self.shape.0 == self.x_data.len() &&
        self.shape.1 == self.y_data.len()
    }

    spec fn get_element(&self, i: int, j: int) -> (f32, f32)
        recommends 
            self.well_formed(),
            0 <= i < self.shape.0,
            0 <= j < self.shape.1,
    {
        (self.x_data[i], self.y_data[j])
    }
}",,"fn broadcast(x: Vec<f32>, y: Vec<f32>) -> (result: BroadcastObject)
    requires 
        x.len() > 0,
        y.len() > 0,
    ensures
        result.well_formed(),
        result.shape == (x.len(), y.len()),
        forall|i: int, j: int| 
            0 <= i < x.len() && 0 <= j < y.len() ==> 
            result.get_element(i, j) == (x[i], y[j])","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0044,verus,numpy_triple,array_manipulation_broadcast_arrays,,"Broadcast two 1D vectors against each other following NumPy broadcasting rules.
For 1D arrays, broadcasting only happens when one array has size 1.
The result arrays will have the size of the larger input array.

Specification: broadcast_arrays produces two arrays of the same size where:
1. If an input array has size 1, its single element is replicated to match the other array's size
2. If both arrays have the same size, they are returned unchanged
3. The output arrays have size equal to the maximum of the input sizes","use vstd::prelude::*;

verus! {",,"fn broadcast_arrays(a: Vec<i8>, b: Vec<i8>) -> (result: (Vec<i8>, Vec<i8>))
    requires 
        a.len() == 1 || b.len() == 1 || a.len() == b.len(),
        a.len() > 0,
        b.len() > 0,
    ensures 
        ({
            let (a_broadcast, b_broadcast) = result;
            let max_len = if a.len() > b.len() { a.len() } else { b.len() };
            
            /* Both output arrays have the same size as max(m, n) */
            a_broadcast.len() == max_len &&
            b_broadcast.len() == max_len &&
            
            /* First array broadcasting rules */
            (a.len() == 1 ==> forall|i: int| 0 <= i < max_len as int ==> a_broadcast[i] == a[0]) &&
            (b.len() == 1 && a.len() > 1 ==> forall|i: int| 0 <= i < a.len() as int ==> a_broadcast[i] == a[i]) &&
            (a.len() == b.len() ==> forall|i: int| 0 <= i < a.len() as int ==> a_broadcast[i] == a[i]) &&
            
            /* Second array broadcasting rules */
            (b.len() == 1 ==> forall|i: int| 0 <= i < max_len as int ==> b_broadcast[i] == b[0]) &&
            (a.len() == 1 && b.len() > 1 ==> forall|i: int| 0 <= i < b.len() as int ==> b_broadcast[i] == b[i]) &&
            (a.len() == b.len() ==> forall|i: int| 0 <= i < b.len() as int ==> b_broadcast[i] == b[i])
        })","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0047,verus,numpy_triple,array_manipulation_concatenate,,"numpy.concatenate: Join a sequence of arrays along an existing axis.

For 1D arrays, concatenates two vectors end-to-end to produce a single 
vector containing all elements from both input vectors in order.

The result vector has size n + m where n and m are the sizes of the 
input vectors.

Specification: concatenate joins two vectors preserving all elements in order.

Precondition: True (no special preconditions for concatenation)
Postcondition: 
- First n elements of result are from vector a
- Next m elements of result are from vector b  
- Result has size n + m","use vstd::prelude::*;

verus! {",,"fn concatenate(a: Vec<f32>, b: Vec<f32>) -> (result: Vec<f32>)
    ensures
        result.len() == a.len() + b.len(),
        forall|i: int| 0 <= i < a.len() ==> result[i] == a[i],
        forall|j: int| 0 <= j < b.len() ==> result[a.len() + j] == b[j],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0048,verus,numpy_triple,array_manipulation_copyto,,"Copies values from one vector to another, with optional conditional copying using a boolean mask.

Specification: copyto copies elements from src to dst where the mask is true, 
preserving dst elements where the mask is false.","use vstd::prelude::*;

verus! {",,"fn copyto<T: Copy>(dst: Vec<T>, src: Vec<T>, mask: Vec<bool>) -> (result: Vec<T>)
    requires 
        dst.len() == src.len(),
        dst.len() == mask.len(),
    ensures 
        result.len() == dst.len(),
        forall|i: int| 0 <= i < result.len() ==> 
            result[i] == if mask[i] { src[i] } else { dst[i] }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0050,verus,numpy_triple,array_manipulation_dsplit,,"Split a 1D vector into equal sections (simplified version of dsplit).

Since dsplit operates on the 3rd axis of 3D arrays, this simplified version
demonstrates the splitting behavior on a 1D vector. The actual dsplit would
work on nested Vector structures representing 3D arrays.

This function divides a vector into k equal sections, where k must divide
the length of the vector evenly. Returns a list of vectors.

Specification: dsplit divides a vector into equal sections.

Precondition: sections = k and k > 0 (array size must be k * n)
Postcondition: Returns k sub-vectors, each of size n. The i-th sub-vector
               contains elements from positions i*n to (i+1)*n-1 of the 
               original array.

Mathematical property: Concatenating all sub-vectors in order reconstructs
                      the original vector.","use vstd::prelude::*;

verus! {",,"fn dsplit(arr: Vec<f32>, sections: usize) -> (result: Vec<Vec<f32>>)
    requires 
        sections > 0,
        arr.len() % sections == 0,
    ensures
        result.len() == sections,
        forall|i: int| 0 <= i < sections ==> result[i].len() == arr.len() / sections,
        forall|i: int, j: int| 0 <= i < sections && 0 <= j < (arr.len() / sections) ==> 
            result[i][j] == arr[i * (arr.len() / sections) + j],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0052,verus,numpy_triple,array_manipulation_expand_dims,,"Expand the shape of a vector by inserting a new axis at the specified position.
axis=0 creates a row vector (1×n), axis=1 creates a column vector (n×1).

Specification: expand_dims preserves all elements and adds a new dimension at the specified axis.
The function creates a view with increased dimensions while maintaining element order and values.

/* Represents the result of expanding dimensions of a vector.
   For axis=0, we get a 1×n matrix (row vector).
   For axis=1, we get an n×1 matrix (column vector). */

// axis=0: shape (1, n)

// axis=1: shape (n, 1)","use vstd::prelude::*;

verus! {

pub enum ExpandedVector<T> {
    RowVector(Vec<T>),
    ColumnVector(Vec<T>),
}",,"fn expand_dims<T>(a: Vec<T>, axis: usize) -> (result: ExpandedVector<T>)
    requires axis <= 1,
    ensures match result {
        ExpandedVector::RowVector(v) => axis == 0 && v@ == a@,
        ExpandedVector::ColumnVector(v) => axis == 1 && v@ == a@,
    }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0053,verus,numpy_triple,array_manipulation_flip,,"Reverses the order of elements in a vector (1D case of numpy.flip).

This function reverses the order of all elements in the input vector.
For a vector [a, b, c, d], it returns [d, c, b, a].

In the general n-dimensional case, numpy.flip can reverse along specific axes,
but this specification focuses on the 1D case where all elements are reversed.

Specification: numpy_flip reverses the order of elements in the vector.

Mathematical properties:
1. Element mapping: The element at position i in the result equals the element 
   at position (n-1-i) in the input
2. Involution property: Applying numpy_flip twice returns the original vector
3. Size preservation: The output has the same size as the input (enforced by types)

Sanity checks:
- For n=0 (empty vector), returns empty vector
- For n=1 (single element), returns the same vector
- For n>1, first element becomes last, last becomes first","use vstd::prelude::*;

verus! {",,"fn numpy_flip(m: Vec<f32>) -> (result: Vec<f32>)
    ensures 
        result.len() == m.len(),
        forall|i: int| 0 <= i < m.len() ==> result[i] == m[m.len() - 1 - i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0055,verus,numpy_triple,array_manipulation_flipud,,"numpy.flipud: Reverse the order of elements along axis 0 (up/down).

For a 1D array, this reverses the entire array.
For 2D arrays, this reverses the order of rows while preserving 
the elements within each row.

Returns a view of the input array with elements reversed along axis 0.

Specification: flipud reverses the order of elements in the vector.

Precondition: True (no special preconditions)
Postcondition: For all indices i, result[i] = m[n-1-i]

This specification captures both the sanity check (result has same size)
and the mathematical property (elements are reversed).","use vstd::prelude::*;

verus! {",,"fn flipud(m: Vec<f32>) -> (result: Vec<f32>)
    ensures 
        result.len() == m.len(),
        forall|i: int| 0 <= i < m.len() ==> result[i] == m[m.len() - 1 - i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0056,verus,numpy_triple,array_manipulation_hsplit,,"Split a 1D array into multiple sub-arrays horizontally.
For simplicity, we focus on the 1D case where the array is split into 
k equal parts. In numpy, hsplit on 1D arrays is equivalent to split with axis=0.

Specification: hsplit divides a 1D array into k equal sub-arrays.
Each sub-array has n/k elements. The i-th sub-array contains elements 
from index i*(n/k) to (i+1)*(n/k)-1 of the original array.

Mathematical properties:
1. The concatenation of all sub-arrays equals the original array
2. Each sub-array has exactly n/k elements
3. Elements are distributed in order without overlapping","use vstd::prelude::*;

verus! {",,"fn hsplit(arr: Vec<f32>, k: usize) -> (result: Vec<Vec<f32>>)
    requires 
        k > 0,
        arr@.len() % (k as nat) == 0,
    ensures
        result@.len() == k,
        forall|part_idx: int| 0 <= part_idx < k as int ==> result@[part_idx].len() == arr@.len() / (k as nat),
        forall|part_idx: int, elem_idx: int| 
            0 <= part_idx < k as int && 0 <= elem_idx < (arr@.len() / (k as nat)) as int ==>
            #[trigger] result@[part_idx][elem_idx] == arr@[part_idx * ((arr@.len() / (k as nat)) as int) + elem_idx],
        forall|i: int| 0 <= i < arr@.len() ==> 
            exists|p: int, e: int| 
                0 <= p < k as int && 0 <= e < (arr@.len() / (k as nat)) as int &&
                i == p * ((arr@.len() / (k as nat)) as int) + e &&
                #[trigger] arr@[i] == result@[p][e]","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0057,verus,numpy_triple,array_manipulation_hstack,,"numpy.hstack: Stack arrays in sequence horizontally (column wise).

For 1D arrays, hstack stacks arrays horizontally by concatenating them
along the first axis. This is equivalent to concatenation for 1D arrays.

This version handles stacking two 1D arrays. The general version would
handle a sequence of arrays (tup parameter in NumPy).

Note: For higher dimensional arrays, hstack would concatenate along the
second axis, but this specification focuses on the 1D case.

Specification: numpy.hstack concatenates 1D arrays horizontally.

For 1D arrays, horizontal stacking means concatenating them end-to-end,
which is the same behavior as numpy.concatenate.

Precondition: True (no special preconditions for 1D concatenation)

Postcondition: 
- The result has size n + m
- First n elements come from array a
- Next m elements come from array b
- The order of elements is preserved from both input arrays","use vstd::prelude::*;

verus! {",,"fn hstack(a: Vec<f32>, b: Vec<f32>) -> (result: Vec<f32>)
    ensures
        result.len() == a.len() + b.len(),
        forall|i: int| 0 <= i < a.len() ==> result[i] == a[i],
        forall|j: int| 0 <= j < b.len() ==> result[a.len() + j] == b[j]","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0058,verus,numpy_triple,array_manipulation_insert,,"numpy.insert: Insert values along the given axis before the given indices.

Creates a new vector with values inserted at specified positions. For the 1D case,
values are inserted before the given index position, shifting subsequent elements.

When inserting a single value at position i into a vector of length n,
the result has length n+1 where:
- Elements before position i remain unchanged
- The new value is at position i
- Elements from position i onward are shifted by one

This specification focuses on single value insertion. The actual NumPy function
supports multiple insertions and various index specifications, but for formal
verification we start with the simplest case.

Specification: numpy.insert creates a new vector with the value inserted at the specified index.

Precondition: The index is valid (enforced by type system via Fin (n + 1))

Postcondition: 
1. **Preservation**: Elements before the insertion point are preserved at their original indices
2. **Insertion**: The new value is placed exactly at the specified index
3. **Shifting**: Elements at or after the insertion point are shifted right by one position
4. **Size**: The result has exactly one more element than the input

Mathematical properties:
- For all i < idx: result[i] = arr[i]
- result[idx] = value
- For all i > idx: result[i] = arr[i-1]

Additional properties (sanity checks):
- The operation is deterministic (same inputs produce same output)
- The operation preserves the relative order of existing elements
- No elements from the original array are lost or duplicated

/* Elements before insertion point are preserved */

/* The new value is at the specified index */

/* Elements after insertion point are shifted */

/* Sanity check: all original elements are preserved */","use vstd::prelude::*;

verus! {",,"fn numpy_insert<T>(arr: Vec<T>, idx: usize, value: T) -> (result: Vec<T>)
    requires idx <= arr.len(),
    ensures 
        result.len() == arr.len() + 1,

        forall|i: int| 0 <= i < idx ==> result[i] == arr[i],

        result[idx as int] == value,

        forall|i: int| (idx as int) < i < result.len() ==> result[i] == arr[i - 1],

        forall|j: int| 0 <= j < arr.len() ==> 
            (j < idx && result[j] == arr[j]) || 
            (j >= idx && result[j + 1] == arr[j])","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0060,verus,numpy_triple,array_manipulation_moveaxis,,"Move axes of an array to new positions.

Move axes in a 1D vector (simplified version).
For 1D arrays, moveaxis with source=0 and destination=0 returns the array unchanged.
This captures the core mathematical property that moving an axis to itself is identity.

Specification: moveaxis preserves all elements and their values.
For 1D arrays, moveaxis is always the identity function since there's only one axis.
This specification captures several mathematical properties:
1. Element preservation: all values remain unchanged
2. Size preservation: the shape is maintained
3. Identity property: moving axis 0 to position 0 is identity
4. Order preservation: for 1D arrays, element order is maintained","use vstd::prelude::*;

verus! {",,"fn moveaxis(a: Vec<f32>, source: usize, dest: usize) -> (result: Vec<f32>)
    ensures
        /* Core property: moveaxis on 1D array is identity */
        forall|i: int| 0 <= i < a.len() ==> result[i] == a[i],
        /* Sanity check: size is preserved */
        result.len() == a.len(),
        /* Mathematical property: for 1D arrays, result equals input */
        result@ == a@,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0061,verus,numpy_triple,array_manipulation_ndim,,"numpy.ndim: Return the number of dimensions of an array.

In our Vector-based framework, vectors are always 1-dimensional.
This function returns 1 for any vector input, representing the fact
that Vector T n is a 1D array with n elements.

Note: In NumPy, scalars are 0-dimensional, but in our framework,
we represent them as Vector T 1, so this always returns 1.","use vstd::prelude::*;

verus! {",,"fn ndim<T>(a: &Vec<T>) -> (result: usize)
    ensures result == 1","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0062,verus,numpy_triple,array_manipulation_ravel,,"numpy.ravel: Return a contiguous flattened array.

For 1D arrays, ravel returns the input array unchanged since it's already
flat. This reflects numpy's behavior where raveling a 1D array has no effect.

For multi-dimensional arrays (not covered here), ravel would flatten them
into a 1D array following the specified order ('C' for row-major, 'F' for
column-major, etc.).

Specification: numpy.ravel returns the input vector unchanged for 1D arrays.

Precondition: True (no special preconditions for 1D ravel)
Postcondition: The result is identical to the input vector, maintaining
               all elements in their original order","use vstd::prelude::*;

verus! {",,"fn ravel(a: Vec<f32>) -> (result: Vec<f32>)
    ensures result@ == a@","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0064,verus,numpy_triple,array_manipulation_reshape,,"Gives a new shape to an array without changing its data.

This implementation focuses on the most common case: reshaping a 1D array
to another 1D array with the same total number of elements. The elements
are preserved in the same linear order (C-order).

For simplicity, this specification handles only 1D to 1D reshaping where
the sizes are explicitly equal. More complex reshaping operations (like
multidimensional arrays or -1 inference) would require additional machinery.

Specification: reshape preserves all elements in their linear order.

The reshape operation creates a new vector with a different size parameter
but maintains the same elements in the same order. This is the fundamental
property of reshape - it's purely a ""view"" operation that doesn't modify data.

Mathematical properties:
1. Size preservation: The total number of elements remains constant
2. Order preservation: Elements appear in the same linear sequence
3. Value preservation: Each element value is unchanged

Precondition: The new shape must have the same total size as the original
Postcondition: Each element at index i in the result equals the element
             at the corresponding index in the original array","use vstd::prelude::*;

verus! {",,"fn reshape(a: Vec<f32>) -> (result: Vec<f32>)
    requires a.len() > 0,
    ensures 
        result.len() == a.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] == a[i]","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0065,verus,numpy_triple,array_manipulation_resize,,"Return a new vector with the specified size by repeating elements from the input vector.
If the new size is larger, elements are repeated cyclically.
If the new size is smaller, only the first elements are taken.

Specification: resize creates a new vector of the specified size by either:
1. Taking the first `new_size` elements if `new_size ≤ n`
2. Repeating the original elements cyclically if `new_size > n` and `n > 0`

The function handles three cases:
- Shrinking: new_size < n → takes first new_size elements
- Same size: new_size = n → returns identical vector
- Growing: new_size > n → repeats elements cyclically (when n > 0)","use vstd::prelude::*;

verus! {",,"fn resize<T>(a: Vec<T>, new_size: usize) -> (result: Vec<T>)
    ensures
        result.len() == new_size,
        forall|i: int| 0 <= i < new_size ==> {
            if i < a.len() {
                result[i] == a[i]
            } else if a.len() > 0 {
                result[i] == a[(i % a.len() as int) as int]
            } else {
                true
            }
        }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0066,verus,numpy_triple,array_manipulation_roll,,"Roll array elements along a given axis by cyclically shifting elements.
Elements that roll beyond the last position are re-introduced at the first.

Specification: roll cyclically shifts array elements by the given amount.
For positive shift, elements move to the right and wrap around.
For negative shift, elements move to the left and wrap around.
Empty vectors are returned unchanged.

Mathematical property: result[i] = a[(i - shift) mod n]
where the modulo operation handles negative values correctly.","use vstd::prelude::*;

verus! {",,"spec fn normalize_index(i: int, shift: int, n: int) -> int {
    let src_idx = i - shift;
    let mod_result = src_idx % n;
    if mod_result < 0 { mod_result + n } else { mod_result }
}

fn roll<T>(a: Vec<T>, shift: i32) -> (result: Vec<T>)
    ensures
        result.len() == a.len(),
        a.len() == 0 ==> result@ == a@,
        a.len() > 0 ==> forall|i: int| 0 <= i < a.len() ==> #[trigger] result[i] == a[normalize_index(i, shift as int, a.len() as int)]","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0067,verus,numpy_triple,array_manipulation_rollaxis,,"numpy.rollaxis: Roll the specified axis backwards, until it lies in a given position.

For 1D arrays, this is a no-op - it returns the input array unchanged.
This is because with only one axis (axis 0), there's nowhere to roll it to.
The axis and start parameters are ignored in the 1D case.

Note: This function is deprecated in favor of moveaxis, but we provide
the specification for completeness.

Specification: numpy.rollaxis returns the input vector unchanged for 1D arrays.

Precondition: True (no special preconditions for 1D rollaxis)
Postcondition: The result is identical to the input vector

Mathematical property: For 1D arrays, rollaxis is the identity function
since there's only one axis that cannot be moved.","use vstd::prelude::*;

verus! {",,"fn numpy_rollaxis(a: Vec<f32>, axis: i32, start: i32) -> (result: Vec<f32>)
    ensures result == a","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0068,verus,numpy_triple,array_manipulation_rot90,,"numpy.rot90: Rotate an array by 90 degrees in the plane specified by axes.

For a 2D array, this function rotates the array counterclockwise by 90 degrees
when k=1. The rotation transforms element at position (i,j) to position 
(j, n-1-i) for a square matrix of size n×n. Multiple rotations can be achieved 
by setting k to the desired number of 90-degree rotations.

This specification focuses on square 2D arrays for simplicity.

Specification: rot90 rotates a square 2D matrix by 90 degrees counterclockwise k times.

The specification handles k modulo 4 since four 90-degree rotations return
to the original orientation:
- k ≡ 0 (mod 4): No rotation (identity)
- k ≡ 1 (mod 4): 90° counterclockwise rotation
- k ≡ 2 (mod 4): 180° rotation  
- k ≡ 3 (mod 4): 270° counterclockwise (= 90° clockwise)

Mathematical properties:
1. rot90 is a group action: rot90(m, k1 + k2) = rot90(rot90(m, k1), k2)
2. rot90(m, 4) = m (period 4)
3. rot90(m, -k) = rot90(m, 4-k) (inverse rotation)

For a 90° counterclockwise rotation, the transformation is:
- Element at position (i,j) moves to position (j, n-1-i)
- This preserves distances and angles (isometry)

Sanity checks:
- Corner elements rotate correctly: (0,0) → (0,n-1) → (n-1,n-1) → (n-1,0) → (0,0)
- Center element of odd-sized matrix stays fixed for k=2

Precondition: Matrix is non-empty (n > 0)
Postcondition: Elements are repositioned according to the rotation formula","use vstd::prelude::*;

verus! {",,"fn rot90(m: Vec<Vec<f32>>, k: i32) -> (result: Vec<Vec<f32>>)
    requires
        m.len() > 0,
        forall|i: int| 0 <= i < m.len() ==> m[i].len() == m.len(),
    ensures
        result.len() == m.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i].len() == m.len()","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0069,verus,numpy_triple,array_manipulation_row_stack,,"Stack a list of 1-D vectors as rows into a 2-D matrix (Vector of Vectors).
Each input vector becomes a row in the output matrix.

Specification: row_stack returns a matrix where each row corresponds to an input vector.
The i-th row of the result is exactly the i-th input vector (identity transformation).","use vstd::prelude::*;

verus! {",,"fn row_stack(arrays: Vec<Vec<f32>>) -> (result: Vec<Vec<f32>>)
    requires arrays.len() > 0,
             forall|i: int| 0 <= i < arrays.len() ==> arrays[i].len() > 0,
             forall|i: int, j: int| 0 <= i < arrays.len() && 0 <= j < arrays.len() ==> 
                 arrays[i].len() == arrays[j].len(),
    ensures result.len() == arrays.len(),
            forall|i: int| 0 <= i < result.len() ==> result[i].len() == arrays[i].len(),
            forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result[i].len() ==>
                result[i][j] == arrays[i][j]","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0070,verus,numpy_triple,array_manipulation_shape,,"numpy.shape: Return the shape of an array.

For a one-dimensional vector, returns its length as a natural number.
This corresponds to the single element in the shape tuple for 1D arrays
in NumPy.

In the general NumPy implementation, shape returns a tuple of dimensions.
For our Vector type, which is inherently one-dimensional, the shape is
simply the length parameter n.

Specification: numpy.shape returns the length of the vector.

For a Vector of length n, the shape function returns n.
This captures the fundamental property that the shape of a 1D array
is its length.

Precondition: True (shape is defined for all vectors)
Postcondition: The result equals the length parameter n of the vector","use vstd::prelude::*;

verus! {",,"fn shape<T>(a: &Vec<T>) -> (result: usize)
    ensures result == a.len()","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0071,verus,numpy_triple,array_manipulation_size,,"Returns the number of elements in a vector

Specification: size returns the length of the vector, which is its type parameter n","use vstd::prelude::*;

verus! {",,"fn size(a: &Vec<f64>) -> (result: usize)
    ensures result == a.len()","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0072,verus,numpy_triple,array_manipulation_split,,"Split a vector into k equal parts. Requires that the vector length is divisible by k.

Specification: split divides a vector into k equal-sized sub-vectors 
where each sub-vector contains consecutive elements from the original.

The specification states that:
1. The result is a vector of k sub-vectors
2. Each sub-vector has size n/k 
3. Element j of sub-vector i corresponds to element (i * (n/k) + j) of the original vector
4. All elements from the original vector are preserved in the split","use vstd::prelude::*;

verus! {",,"fn split(arr: Vec<f32>, k: usize) -> (result: Vec<Vec<f32>>)
    requires
        k > 0,
        arr.len() % k == 0,
    ensures
        result.len() == k,
        forall|i: int| #[trigger] result[i].len() == (arr.len() / k) ==> (0 <= i < k),
        forall|i: int, j: int| 
            0 <= i < k && 0 <= j < (arr.len() / k) as int ==> {
                let idx = i * (arr.len() / k) as int + j;
                0 <= idx < arr.len() as int && #[trigger] result[i][j] == arr[idx]
            },","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0073,verus,numpy_triple,array_manipulation_squeeze,,"Squeeze a single-element vector to extract its value.
This is a simplified 1D version of numpy.squeeze for vectors of size 1.

Specification: squeeze extracts the single element from a size-1 vector.

Mathematical properties:
1. The result equals the first (and only) element of the input vector
2. For any function f, squeeze preserves function application: f(squeeze(a)) = f(a[0])
3. squeeze is the inverse of creating a single-element vector

Sanity checks:
- The input must be a vector of exactly size 1
- The output type changes from Vector to the element type
- This models numpy's behavior where squeeze([x]) returns x as a 0D array","use vstd::prelude::*;

verus! {",,"spec fn squeeze<T>(a: Vec<T>) -> T
    recommends a.len() == 1
{
    a[0]
}

fn squeeze_exec<T: Copy>(a: Vec<T>) -> (result: T)
    requires a.len() == 1,
    ensures 
        result == squeeze(a),
        result == a[0],
        forall|b: Vec<T>| b.len() == 1 && squeeze(a) == squeeze(b) ==> a[0] == b[0],
        forall|i: int| 0 <= i < a.len() ==> a[i] == result,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0074,verus,numpy_triple,array_manipulation_stack,,"Stack a sequence of vectors along a new axis to create a 2D matrix.
For simplicity, we focus on stacking 1D vectors along axis 0.
The result has shape (m, n) where m is the number of vectors and n is their common length.

Specification: stack creates a 2D matrix where each input vector becomes a row.
Key properties:
1. The result preserves all input vectors as rows
2. The i-th row of the result equals the i-th input vector
3. Shape property: stacking m vectors of length n produces an m×n matrix","use vstd::prelude::*;

verus! {",,"fn stack(arrays: Vec<Vec<f32>>) -> (result: Vec<Vec<f32>>)
    requires 
        arrays.len() > 0,
        forall|i: int| 0 <= i < arrays.len() ==> #[trigger] arrays[i].len() == arrays[0].len(),
    ensures
        result.len() == arrays.len(),
        forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i].len() == arrays[0].len(),
        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result[i].len() ==> #[trigger] result[i][j] == #[trigger] arrays[i][j],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0076,verus,numpy_triple,array_manipulation_tile,,"Constructs a vector by repeating the input vector `reps` times.
For 1D case: tile([a, b, c], 3) = [a, b, c, a, b, c, a, b, c]

Specification: tile repeats the input vector `reps` times, where each element
at position i in the result corresponds to element at position (i % n) in the input","use vstd::prelude::*;

verus! {",,"fn tile(a: Vec<i32>, reps: usize) -> (result: Vec<i32>)
    requires 
        reps > 0,
        a.len() > 0,
    ensures
        result.len() == a.len() * reps,
        forall|i: int| 0 <= i < result.len() ==> result[i] == a[i % (a.len() as int)],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0078,verus,numpy_triple,array_manipulation_trim_zeros,,"numpy.trim_zeros: Trim the leading and/or trailing zeros from a 1-D array.

Removes zeros from the beginning and/or end of a vector based on the trim mode.
- Front: removes leading zeros only
- Back: removes trailing zeros only
- Both: removes both leading and trailing zeros (default)

The function preserves all non-zero elements and internal zeros.

Specification: trim_zeros removes leading and/or trailing zeros while preserving order.

The function guarantees:
1. All non-zero elements from the original array are preserved in order
2. Internal zeros (zeros between non-zero elements) are preserved
3. Only leading/trailing zeros are removed based on the mode
4. If the array contains only zeros, returns an empty vector","use vstd::prelude::*;

verus! {

/* Represents the trim mode for trim_zeros function */
#[derive(Eq, PartialEq)]
pub enum TrimMode {
    /* Trim zeros from the front of the array only (corresponds to 'f') */
    Front,
    /* Trim zeros from the back of the array only (corresponds to 'b') */
    Back,
    /* Trim zeros from both front and back of the array (corresponds to 'fb', default) */
    Both,
}",,"fn trim_zeros(arr: Vec<f32>, mode: TrimMode) -> (result: Vec<f32>)
    ensures
        result@.len() <= arr@.len(),
        /* Result contains only elements from the original array */
        forall|i: int| 0 <= i < result@.len() ==> 
            exists|j: int| 0 <= j < arr@.len() && #[trigger] result@[i] == arr@[j],
        /* Basic trimming properties based on mode */
        (mode == TrimMode::Front ==> 
            (result@.len() == 0 || result@[0] != 0.0f32)),
        (mode == TrimMode::Back ==> 
            (result@.len() == 0 || result@[result@.len() - 1] != 0.0f32)),
        (mode == TrimMode::Both ==> 
            (result@.len() == 0 || (result@[0] != 0.0f32 && result@[result@.len() - 1] != 0.0f32)))","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0079,verus,numpy_triple,array_manipulation_unique,,"numpy.unique: Find the unique elements of a vector and return them sorted.

Returns a new vector containing each distinct element from the input exactly once,
sorted in ascending order. This is a simplified version that only returns the 
unique values without the optional indices or counts.

The output size depends on the number of unique elements in the input.

Specification: numpy.unique returns a sorted vector containing each distinct element 
from the input exactly once.

Precondition: True
Postcondition: 
- The result is sorted in ascending order
- No duplicates exist in the result
- Every element in result comes from the input array
- Every distinct element from input appears in result","use vstd::prelude::*;

verus! {",,"spec fn is_sorted(arr: Seq<i32>) -> bool {
    forall|i: int, j: int| 0 <= i < j < arr.len() ==> arr[i] <= arr[j]
}

spec fn has_no_duplicates(arr: Seq<i32>) -> bool {
    forall|i: int, j: int| 0 <= i < arr.len() && 0 <= j < arr.len() && i != j ==> arr[i] != arr[j]
}

spec fn all_elements_from_input(result: Seq<i32>, input: Seq<i32>) -> bool {
    forall|i: int| 0 <= i < result.len() ==> #[trigger] input.contains(result[i])
}

spec fn all_distinct_elements_present(input: Seq<i32>, result: Seq<i32>) -> bool {
    forall|val: i32| input.contains(val) ==> #[trigger] result.contains(val)
}

fn numpy_unique(arr: Vec<i32>) -> (result: (usize, Vec<i32>))
    ensures
        is_sorted(result.1@),
        has_no_duplicates(result.1@),
        all_elements_from_input(result.1@, arr@),
        all_distinct_elements_present(arr@, result.1@),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0081,verus,numpy_triple,array_manipulation_vstack,,"Stack two vectors vertically to create a 2D matrix.
For 1D vectors, this treats them as row vectors and stacks them vertically.
This is a simplified version focusing on the common case of stacking two 1D vectors.

Specification: vstack stacks two vectors vertically, creating a 2x n matrix
where the first row is vector a and the second row is vector b.

Mathematical properties:
1. The result has shape (2, n) where n is the length of input vectors
2. The first row of the result equals the first input vector
3. The second row of the result equals the second input vector
4. This operation preserves the elements and their order within each vector","use vstd::prelude::*;

verus! {",,"fn vstack(a: Vec<f32>, b: Vec<f32>) -> (result: Vec<Vec<f32>>)
    requires a.len() == b.len(),
    ensures
        result.len() == 2,
        result[0].len() == a.len(),
        result[1].len() == b.len(),
        forall|j: int| 0 <= j < a.len() ==> result[0][j] == a[j],
        forall|j: int| 0 <= j < b.len() ==> result[1][j] == b[j]","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0082,verus,numpy_triple,bitwise_operations_binary_repr,,"Return the binary representation of the input number as a string.
For negative numbers, if width is not given, a minus sign is added to the front.
If width is given, the two's complement of the number is returned.

Specification: binary_repr correctly converts integers to binary strings with proper
handling of negative numbers (signed representation without width, two's complement with width)

/* Helper function to convert a natural number to its binary string representation */

/* Helper function to check if a string represents a valid binary number */

/* Helper function to check if a string represents a valid signed binary number */

/* Result is a valid binary string (possibly with sign) */

/* Length constraints */

/* Positive numbers: standard binary representation */

/* Negative numbers without width: signed representation */

/* Two's complement properties for negative numbers with width */","use vstd::prelude::*;

verus! {

spec fn nat_to_binary_string(n: nat) -> Seq<char>
    decreases n
{
    if n == 0 {
        seq!['0']
    } else {
        let digit = if n % 2 == 0 { '0' } else { '1' };
        nat_to_binary_string(n / 2).push(digit)
    }
}

spec fn is_valid_binary(s: Seq<char>) -> bool {
    s.len() > 0 && (forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1')
}

spec fn is_valid_signed_binary(s: Seq<char>) -> bool {
    if s.len() > 0 && s[0] == '-' {
        is_valid_binary(s.skip(1))
    } else {
        is_valid_binary(s)
    }
}",,"fn binary_repr(num: i32, width: Option<usize>) -> (result: Vec<char>)
    requires 
        width.is_some() ==> width.get_Some_0() >= 1,
    ensures 

        width.is_none() ==> is_valid_signed_binary(result@),
        width.is_some() ==> is_valid_binary(result@),

        width.is_some() ==> result.len() == width.get_Some_0(),

        (num >= 0 && width.is_none()) ==> 
            result@ == nat_to_binary_string(num as nat),

        (num < 0 && width.is_none()) ==> 
            result@.len() > 0 && result@[0] == '-' && is_valid_binary(result@.skip(1)),

        (num < 0 && width.is_some()) ==> {
            let w = width.get_Some_0();
            let two_comp = (1u32 << w) as i32 + num;
            two_comp >= 0 && two_comp < (1i32 << w) && result.len() == w
        }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0083,verus,numpy_triple,bitwise_operations_bitwise_and,,"numpy.bitwise_and: Compute the bit-wise AND of two arrays element-wise.

Computes the bit-wise AND of the underlying binary representation of 
the integers in the input arrays. This ufunc implements the C/Python 
operator &.

For each pair of corresponding elements in x1 and x2, the result contains
the bitwise AND of their binary representations. Each bit position in the
result is 1 only if both corresponding bits in x1 and x2 are 1.

Examples:
- 13 & 17 = 1 (binary: 01101 & 10001 = 00001)
- 14 & 13 = 12 (binary: 01110 & 01101 = 01100)

Note: This specification currently handles only non-negative integers.
For negative integers, NumPy uses two's complement representation,
which requires a more complex formalization in Lean.

Specification: bitwise_and returns a vector where each element is the 
bitwise AND of the corresponding elements from x1 and x2.

Precondition: All elements are non-negative (to simplify the specification)

Postcondition: 
1. For non-negative integers, each element of the result is the bitwise AND 
   of corresponding inputs
2. The result preserves the mathematical properties of bitwise AND:
   - Commutativity: x & y = y & x
   - Associativity: (x & y) & z = x & (y & z)
   - Identity: x & (2^k - 1) = x for x < 2^k (all 1s acts as identity)
   - Annihilator: x & 0 = 0
   - Idempotence: x & x = x
3. The result is always less than or equal to both inputs (for non-negative integers)
4. Each bit in the result is 1 iff both corresponding bits in the inputs are 1","use vstd::prelude::*;

verus! {",,"fn bitwise_and(x1: Vec<u8>, x2: Vec<u8>) -> (result: Vec<u8>)
    requires 
        x1.len() == x2.len(),
        forall|i: int| 0 <= i < x1.len() ==> x1[i] as int >= 0,
        forall|i: int| 0 <= i < x2.len() ==> x2[i] as int >= 0,
    ensures
        result.len() == x1.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] == (x1[i] & x2[i]),
        forall|i: int| 0 <= i < result.len() ==> result[i] as int >= 0,
        forall|i: int| 0 <= i < result.len() ==> result[i] as int <= x1[i] as int,
        forall|i: int| 0 <= i < result.len() ==> result[i] as int <= x2[i] as int,
        forall|i: int| 0 <= i < result.len() ==> (result[i] == 0 <==> (x1[i] == 0 || x2[i] == 0)),
        forall|i: int| 0 <= i < result.len() ==> (x1[i] == x2[i] ==> result[i] == x1[i]),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0084,verus,numpy_triple,bitwise_operations_bitwise_count,,"Computes the number of 1-bits in the absolute value of each element in a vector

Specification: bitwise_count returns the count of 1-bits in the binary representation
of the absolute value of each element. The result satisfies several properties:
1. Each output element is the popcount of the corresponding input's absolute value
2. The popcount is bounded by the number of bits in the representation
3. Zero inputs produce zero outputs
4. Powers of 2 have exactly one bit set
5. Powers of 2 minus 1 have consecutive 1-bits (e.g., 2^k - 1 has k bits set)
6. The popcount is always non-negative and bounded by bit width
7. For negative inputs, uses the absolute value
8. The popcount operation is invariant under sign changes

/* Helper function to count the number of 1-bits in a natural number */","use vstd::prelude::*;

verus! {

spec fn abs_spec(x: i32) -> nat {
    if x >= 0 { x as nat } else { (-x) as nat }
}

spec fn popcount(n: nat) -> nat 
    decreases n
{
    if n == 0 {
        0
    } else {
        (n % 2) + popcount(n / 2)
    }
}",,"fn bitwise_count(x: Vec<i32>) -> (result: Vec<nat>)
    ensures
        result.len() == x.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] == popcount(abs_spec(x[i])),
        forall|i: int| 0 <= i < result.len() ==> x[i] == 0 ==> result[i] == 0,
        forall|i: int| 0 <= i < result.len() ==> result[i] >= 0,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0085,verus,numpy_triple,bitwise_operations_bitwise_or,,"Compute the bit-wise OR of two vectors element-wise

// placeholder implementation

// placeholder implementation","use vstd::prelude::*;

verus! {",,"spec fn bitwise_or_int(x: i32, y: i32) -> i32 {
    x
}

spec fn bitwise_and_int(x: i32, y: i32) -> i32 {
    x
}

spec fn bitwise_or_vec(x: Seq<i32>, y: Seq<i32>) -> Seq<i32>
    recommends x.len() == y.len()
{
    Seq::new(x.len(), |i: int| x[i])
}

fn bitwise_or_fn(x1: Vec<i32>, x2: Vec<i32>) -> (result: Vec<i32>)
    requires x1.len() == x2.len(),
    ensures 
        result.len() == x1.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] == bitwise_or_int(x1[i], x2[i]),
        forall|i: int| 0 <= i < result.len() && x2[i] == 0 ==> result[i] == x1[i],
        forall|i: int| 0 <= i < result.len() && x1[i] == 0 ==> result[i] == x2[i],
        forall|i: int| 0 <= i < result.len() && (x1[i] == -1i32 || x2[i] == -1i32) ==> result[i] == -1i32,
        result@ == bitwise_or_vec(x1@, x2@)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0086,verus,numpy_triple,bitwise_operations_bitwise_xor,,"Compute the bit-wise XOR of two arrays element-wise.

Computes the bit-wise XOR (exclusive OR) of the underlying binary representation 
of the integers in the input arrays. This ufunc implements the C/Python 
operator ^.

For each pair of corresponding elements in x1 and x2, the result contains
the bitwise XOR of their binary representations. Each bit position in the
result is 1 if and only if exactly one of the corresponding bits in x1 and x2 is 1.

Examples:
- 13 ^ 17 = 28 (binary: 01101 ^ 10001 = 11100)
- 31 ^ 5 = 26 (binary: 11111 ^ 00101 = 11010)
- 31 ^ 3 = 28 (binary: 11111 ^ 00011 = 11100)

Note: This specification currently handles only non-negative integers.
For negative integers, NumPy uses two's complement representation,
which requires a more complex formalization.","use vstd::prelude::*;

verus! {",,"fn bitwise_xor(x1: Vec<i32>, x2: Vec<i32>) -> (result: Vec<i32>)
    requires 
        x1.len() == x2.len(),
        forall|i: int| 0 <= i < x1.len() ==> x1[i] >= 0,
        forall|i: int| 0 <= i < x2.len() ==> x2[i] >= 0,
    ensures
        result.len() == x1.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] == (x1[i] ^ x2[i]),
        forall|i: int| 0 <= i < result.len() ==> result[i] >= 0,
        forall|i: int| 0 <= i < result.len() && x1[i] == 0 ==> result[i] == x2[i],
        forall|i: int| 0 <= i < result.len() && x2[i] == 0 ==> result[i] == x1[i],
        forall|i: int| 0 <= i < result.len() && x1[i] == x2[i] ==> result[i] == 0,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0087,verus,numpy_triple,bitwise_operations_invert,,"Compute bit-wise inversion (NOT) of each element in a vector of integers.
For signed integers, this returns the two's complement.

Specification: invert computes the bitwise NOT operation element-wise.

Mathematical properties:
1. Two's complement relationship: ~x = -(x + 1)
2. Involution property: applying invert twice returns the original value
3. The operation preserves vector size
4. Identity relationships:
   - ~0 = -1
   - ~(-1) = 0
5. Sign flipping: ~x has opposite sign to x when x ≠ -1

The specification captures both the element-wise nature and the 
mathematical relationship for two's complement representation.","use vstd::prelude::*;

verus! {",,"fn invert(x: Vec<i32>) -> (result: Vec<i32>)
    ensures
        result.len() == x.len(),
        forall|i: int| 0 <= i < x.len() ==> result[i] == -(x[i] + 1),
        forall|i: int| 0 <= i < x.len() && x[i] == 0 ==> result[i] == -1,
        forall|i: int| 0 <= i < x.len() && x[i] == -1 ==> result[i] == 0,
        forall|i: int| 0 <= i < x.len() && x[i] != -1 ==> (x[i] > 0 <==> result[i] < 0),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0088,verus,numpy_triple,bitwise_operations_left_shift,,"Shift the bits of integers to the left element-wise.
This operation is equivalent to multiplying each element by 2^shift_amount.

Specification: left_shift performs bitwise left shift operation on each element.
The result is equivalent to multiplying x1[i] by 2^x2[i] for non-negative shifts.

Mathematical properties:
1. Core behavior: Each element result[i] = x1[i] * 2^x2[i] for non-negative shifts
2. Identity property: Shifting by 0 returns the original value
3. Zero preservation: Shifting zero always yields zero
4. Monotonicity: For positive values, left shifting increases magnitude
5. Composition property: left_shift(x, a) then left_shift(result, b) = left_shift(x, a+b)","use vstd::prelude::*;
use vstd::arithmetic::power::pow;

verus! {",,"fn left_shift(x1: Vec<i32>, x2: Vec<i32>) -> (result: Vec<i32>)
    requires
        x1.len() == x2.len(),
        forall|i: int| 0 <= i < x2.len() ==> x2[i] >= 0,
    ensures
        result.len() == x1.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] == x1[i] * pow(2, x2[i] as nat),
        forall|i: int| 0 <= i < result.len() && x2[i] == 0 ==> result[i] == x1[i],
        forall|i: int| 0 <= i < result.len() && x1[i] == 0 ==> result[i] == 0,
        forall|i: int| 0 <= i < result.len() && x1[i] > 0 && x2[i] > 0 ==> result[i] > x1[i],
        forall|i: int| 0 <= i < result.len() && x1[i] < 0 && x2[i] > 0 ==> result[i] < x1[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0090,verus,numpy_triple,bitwise_operations_right_shift,,"Shift the bits of an integer to the right element-wise. This operation is equivalent to dividing each element by 2^shift_amount using integer division. For negative inputs, the behavior follows arithmetic right shift with sign extension.","use vstd::prelude::*;

verus! {",,"fn right_shift(x1: Vec<i32>, x2: Vec<i32>) -> (result: Vec<i32>)
    requires 
        x1.len() == x2.len(),
        forall|i: int| 0 <= i < x2.len() ==> x2[i] >= 0,
    ensures
        result.len() == x1.len(),
        forall|i: int| 0 <= i < result.len() ==> {
            &&& (x1[i] >= 0 ==> result[i] == x1[i] / (1i32 << x2[i]))
            &&& (x1[i] < 0 ==> result[i] == x1[i] >> x2[i])
            &&& (x2[i] == 0 ==> result[i] == x1[i])
            &&& (x1[i] > 0 ==> result[i] >= 0)
            &&& (x1[i] < 0 ==> result[i] <= 0)
            &&& (x1[i] == 0 ==> result[i] == 0)
        }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0091,verus,numpy_triple,bitwise_operations_unpackbits,,"numpy.unpackbits: Unpacks elements of a uint8 array into a binary-valued output array.

Each element of the input array represents a bit-field that is unpacked into
a binary-valued output array. By default, each uint8 value is unpacked into
8 binary values (0 or 1) using big-endian bit order.

This specification covers the basic 1D case with default parameters.
For simplicity, we use Nat instead of UInt8, with the constraint that input values < 256.","use vstd::prelude::*;
use vstd::arithmetic::power::pow;

verus! {",,"fn numpy_unpackbits(a: Vec<u8>) -> (result: Vec<u8>)
    requires forall|i: int| 0 <= i < a@.len() ==> a@[i] < 256,
    ensures 
        result@.len() == a@.len() * 8,
        forall|i: int, j: int| 0 <= i < a@.len() && 0 <= j < 8 ==> 
            #[trigger] result@[i * 8 + j] == ((a@[i] as int) / pow(2, (7 - j) as nat)) % 2","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0093,verus,numpy_triple,constants_NINF,,"IEEE 754 floating point representation of negative infinity (deprecated in NumPy 2.0)

Specification: NINF represents negative infinity with the following properties:
1. NINF is less than any finite float value
2. NINF + any finite value = NINF
3. NINF * positive finite value = NINF
4. NINF * negative finite value = inf
5. NINF / any finite non-zero value = NINF (with appropriate sign)
6. NINF = -inf (negative of positive infinity)

/* IEEE 754 floating point representation of negative infinity (deprecated in NumPy 2.0) */

// NINF represents a special f64 value (negative infinity)

// Due to Verus limitations with floating point specifications,

// we can only provide basic structural properties

/* Placeholder - actual floating point properties cannot be easily verified in Verus */","use vstd::prelude::*;

verus! {",,"fn NINF() -> (result: f64)
    ensures

        true","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0094,verus,numpy_triple,constants_NPY_1_PI,,"The mathematical constant 1/π (one divided by pi), approximately 0.31831...

Specification: NPY_1_PI represents the reciprocal of pi (1/π),
and satisfies key mathematical properties","use vstd::prelude::*;

verus! {",,"fn npy_1_pi() -> (result: i32)
    ensures
        /* Mathematical constant representing 1/π as a fixed-point approximation */
        result > 0,
        /* Basic sanity check for positive value */
        result < 1000000000,","{
    // impl-start
    assume(false);
    318309886
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0095,verus,numpy_triple,constants_NPY_2_PI,,"The mathematical constant 2/π, approximately 0.6366...

Specification: NPY_2_PI represents the ratio 2/π and satisfies key mathematical properties","use vstd::prelude::*;

verus! {",,"fn npy_2_pi() -> (result: i32)
    ensures
        result == 636619772,
        result > 636000000,
        result < 637000000,","{
    // impl-start
    assume(false);
    0
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0096,verus,numpy_triple,constants_NPY_LOG2E,,"Base 2 logarithm of e
{
  ""name"": ""NPY_LOG2E"",
  ""category"": ""C API Mathematical constants"",
  ""description"": ""Base 2 logarithm of e"",
  ""doc"": ""log2(e) = 1.442695040888963407359924681001892137"",
}

Base 2 logarithm of e (log₂(e))

Specification: NPY_LOG2E is the base 2 logarithm of e with mathematical properties:
    1. It is approximately 1.442695040888963407359924681001892137
    2. It satisfies the relationship: 2^(NPY_LOG2E) = e
    3. It is the reciprocal of ln(2) (i.e., NPY_LOG2E = 1/ln(2))
    4. It is used to convert natural logarithms to base 2 logarithms via: log₂(x) = ln(x) * NPY_LOG2E","use vstd::prelude::*;

verus! {",,"fn NPY_LOG2E() -> (result: f64)
    ensures
        result == 1.442695040888963407359924681001892137,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0097,verus,numpy_triple,constants_NPY_LOG10E,,"Base 10 logarithm of Euler's number e

NPY_LOG10E returns the base 10 logarithm of e with correct mathematical properties
log10(e) = 0.434294481903251827651128918916605082","use vstd::prelude::*;

verus! {",,"fn npy_log10e() -> (result: f64)
    ensures
        result == 0.434294481903251827651128918916605082","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0098,verus,numpy_triple,constants_NPY_LOGE2,,"Natural logarithm of 2

NPY_LOGE2 - C API Mathematical constant
Natural logarithm of 2
ln(2) = 0.693147180559945309417232121458176568

Specification: nPY_LOGE2 returns the natural logarithm of 2 with correct mathematical properties","use vstd::prelude::*;

verus! {",,"fn npy_loge2() -> (result: f64)
    ensures
        result == 0.693147180559945309417232121458176568","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0099,verus,numpy_triple,constants_NPY_LOGE10,,"Natural logarithm of 10

NPY_LOGE10 - C API Mathematical constants
Description: Natural logarithm of 10
Documentation: ln(10) = 2.302585092994045684017991454684364208

Natural logarithm of 10 (ln(10))

Specification: npy_loge10 is the natural logarithm of 10 with mathematical properties:
1. It is approximately 2.302585092994045684017991454684364208
2. It satisfies the property that e^(npy_loge10) = 10
3. It is the inverse of log10(e), meaning npy_loge10 * log10(e) = 1
4. It is useful for converting between natural and base-10 logarithms","use vstd::prelude::*;

verus! {",,"fn npy_loge10() -> (result: i8)
    ensures
        /* Mathematical property: ln(10) is positive (since 10 > 1) */
        result as int >= 0,
        /* Mathematical property: ln(10) > ln(e) = 1 (since 10 > e) */  
        result as int >= 1,
        /* Mathematical property: ln(10) is between 2 and 3 */
        2 <= result as int && result as int <= 3,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0100,verus,numpy_triple,constants_NPY_PI_2,,"The mathematical constant π/2 (pi divided by 2), approximately 1.5708...

Specification: NPY_PI_2 represents π/2, which is half of pi and corresponds to 90 degrees
in radians. It satisfies key mathematical properties related to trigonometry and geometry","use vstd::prelude::*;

verus! {",,"fn npy_pi_2() -> (result: i32)
    ensures
        /* π/2 is approximately 1.5708... represented as fixed point */
        1570 < result < 1571,
        /* Basic sanity check: π/2 is between 1 and 2 */
        1000 < result < 2000,
        /* 2*(π/2) should be approximately π (3.14159...) */
        3141 < 2 * (result as int) < 3142,
        /* (π/2)/2 = π/4 is approximately 0.7854... */
        785 < (result as int) / 2 < 786,
        /* 3*(π/2) = 3π/2 is approximately 4.7124... (270 degrees) */
        4712 < 3 * (result as int) < 4713,
        /* 4*(π/2) = 2π is approximately 6.2832... (full circle) */
        6283 < 4 * (result as int) < 6284,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0101,verus,numpy_triple,constants_NPY_PI_4,,"NPY_PI_4: Mathematical constant representing π/4.

This constant provides the value of pi divided by 4, which is commonly used in
trigonometric calculations, particularly for 45-degree angle computations.

Value: π/4 ≈ 0.785398163397448309615660845819875721

Specification: NPY_PI_4 returns the mathematical constant π/4.

Precondition: True (no preconditions for accessing a constant)
Postcondition: The result equals π/4, which is approximately 0.7853981633974483

Mathematical properties:
- NPY_PI_4 = π/4
- NPY_PI_4 = arctan(1)  
- sin(NPY_PI_4) = cos(NPY_PI_4) = √2/2
- tan(NPY_PI_4) = 1
- 4 * NPY_PI_4 = π","use vstd::prelude::*;

verus! {",,"const NPY_PI_4_EXACT: f64 = 0.785398163397448309615660845819875721;

fn npy_pi_4() -> (result: f64)
    ensures result == NPY_PI_4_EXACT","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0102,verus,numpy_triple,constants_NPY_SQRT1_2,,"NPY_SQRT1_2: Square root of 1/2

Square root of 1/2 as a Float constant
Specification: NPY_SQRT1_2 equals the square root of 1/2 with mathematical properties","use vstd::prelude::*;

verus! {",,fn NPY_SQRT1_2() -> (result: f64),"{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0103,verus,numpy_triple,constants_NPY_SQRT2,,"Square root of 2 as a mathematical constant with value √2 = 1.414213562373095048801688724209698079. The specification ensures the constant is positive, that its square equals 2 within floating-point precision, and that it matches the expected mathematical value.","use vstd::prelude::*;

verus! {",,"global size_of usize == 8;

spec fn npy_sqrt2_value() -> f64 {
    1.4142135623730951
}

fn npy_sqrt2() -> (result: f64)
    ensures
        result == npy_sqrt2_value(),","{
    // impl-start
    assume(false);
    0.0
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0104,verus,numpy_triple,constants_NZERO,,"IEEE 754 floating point representation of negative zero.

Specification: NZERO represents IEEE 754 negative zero, which equals zero 
but has special properties in floating point arithmetic","use vstd::prelude::*;

verus! {",,"fn NZERO() -> (result: f64)
    ensures
        result == 0.0","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0105,verus,numpy_triple,constants_PZERO,,"IEEE 754 floating point representation of positive zero.

DEPRECATED: Removed from main namespace in NumPy 2.0. Use 0.0 instead.

IEEE 754 floating point representation of positive zero

Specification: PZERO represents IEEE 754 positive zero with the following properties:
1. It equals the standard zero value
2. It behaves as the additive identity
3. It behaves as expected in multiplication and division
4. It has special IEEE 754 properties (e.g., 1.0 / PZERO = +∞)","use vstd::prelude::*;

verus! {",,"fn pzero() -> (result: f64)
    ensures result == 0.0","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0106,verus,numpy_triple,constants_True_,,"NumPy's boolean scalar type representing True.
This is NumPy's equivalent of Python's built-in True, but as a NumPy scalar type.
Comparison operations in NumPy return this type instead of Python's bool.

Specification: numpy.True_ represents the boolean value true and has the following properties:
1. It equals the Lean boolean true
2. It is the identity element for logical AND operations
3. It is the absorbing element for logical OR operations
4. Its negation gives false","use vstd::prelude::*;

verus! {",,"fn true_() -> (result: bool)
    ensures 
        result == true,
        !result == false","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0107,verus,numpy_triple,constants_e,,"Euler's constant (e), the base of natural logarithms

Euler's constant, base of natural logarithms, Napier's constant
e = 2.71828182845904523536028747135266249775724709369995...

Euler's number is the base of the natural logarithm. It is the unique number whose natural logarithm is equal to one.

Specification: e is Euler's constant with mathematical properties:
1. It is approximately 2.718281828459045
2. It is the unique positive real number such that ln(e) = 1
3. It is the limit of (1 + 1/n)^n as n approaches infinity
4. It satisfies the property that the derivative of e^x equals e^x
5. It is the sum of the infinite series 1/0! + 1/1! + 1/2! + ...","use vstd::prelude::*;

verus! {",,fn e() -> (result: f64),"{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0108,verus,numpy_triple,constants_euler_gamma,,"The Euler-Mascheroni constant γ, approximately 0.577215...

Specification: euler_gamma represents the Euler-Mascheroni constant γ,
which is the limiting difference between the harmonic series and the natural logarithm.
It satisfies key mathematical properties and bounds

/* The Euler-Mascheroni constant (γ), approximately 0.577215... */","use vstd::prelude::*;

verus! {",,fn euler_gamma() -> (result: f64),"{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0109,verus,numpy_triple,constants_finfo,,"numpy.finfo: Returns machine limits for floating point types.

Given a floating-point data type, returns a structure containing
information about the numerical properties and limits of that type,
including epsilon, maximum/minimum values, and precision details.

For now, we model this as a function that takes Unit and returns
FloatInfo for the default Float type.

Specification: numpy.finfo returns consistent and mathematically valid
information about floating-point type limits.

The returned structure satisfies fundamental properties of floating-point
representations according to IEEE 754 standard.","use vstd::prelude::*;

verus! {

/* Structure representing floating-point type information */
pub struct FloatInfo {
    pub eps: u32,              // Machine epsilon (represented as u32)
    pub epsneg: u32,           // Negative machine epsilon  
    pub max: u32,              // Maximum representable value
    pub min: i32,              // Minimum representable value (typically -max)
    pub tiny: u32,             // Smallest positive normal number
    pub smallest_subnormal: u32, // Smallest positive subnormal number
    pub maxexp: i32,           // Maximum exponent
    pub minexp: i32,           // Minimum exponent
    pub negep: i32,            // Negative epsilon exponent
    pub nexp: u32,             // Number of bits in exponent
    pub nmant: u32,            // Number of bits in mantissa
    pub precision: u32,        // Approximate decimal precision
}",,"fn numpy_finfo() -> (info: FloatInfo)
    ensures
        /* Machine epsilon is positive */
        info.eps > 0,
        /* Negative epsilon is positive */
        info.epsneg > 0,
        /* Max is positive and finite */
        info.max > 0,
        /* Min is negative max (for symmetric representation) */
        info.min == -(info.max as i32),
        /* Tiny (smallest normal) is positive */
        info.tiny > 0,
        /* Smallest subnormal is positive and less than tiny */
        info.smallest_subnormal > 0,
        info.smallest_subnormal < info.tiny,
        /* Exponent relationships */
        info.maxexp > 0,
        info.minexp < 0,
        info.negep < 0,
        /* Bit counts are positive */
        info.nexp > 0,
        info.nmant > 0,
        /* Precision is at least 1 */
        info.precision >= 1,
        /* Relationship between mantissa bits and precision */
        info.precision <= info.nmant","{
    // impl-start
    assume(false);
    FloatInfo {
        eps: 1,
        epsneg: 1,
        max: 1,
        min: -1,
        tiny: 1,
        smallest_subnormal: 1,
        maxexp: 1,
        minexp: -1,
        negep: -1,
        nexp: 1,
        nmant: 1,
        precision: 1,
    }
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0110,verus,numpy_triple,constants_iinfo,,"Machine limits for integer types - returns information about the given integer type including 
the number of bits, minimum value, and maximum value.

Specification: iinfo returns correct machine limits for integer types.
The returned IntegerInfo structure contains:
- bits: the number of bits used by the type
- min: the minimum representable value (-(2^(bits-1)) for signed, 0 for unsigned)
- max: the maximum representable value (2^(bits-1) - 1 for signed, 2^bits - 1 for unsigned)","use vstd::prelude::*;

verus! {",,"#[derive(Clone, Copy, PartialEq, Eq)]
pub enum IntegerType {
    Int8,
    Int16, 
    Int32,
    Int64,
    UInt8,
    UInt16,
    UInt32,
    UInt64,
}

pub struct IntegerInfo {
    pub bits: u32,
    pub min: i64,
    pub max: i64,
}

fn iinfo(int_type: IntegerType) -> (result: IntegerInfo)
    ensures match int_type {
        IntegerType::Int8 => 
            result.bits == 8 && result.min == -128 && result.max == 127,
        IntegerType::Int16 => 
            result.bits == 16 && result.min == -32768 && result.max == 32767,
        IntegerType::Int32 => 
            result.bits == 32 && result.min == -2147483648 && result.max == 2147483647,
        IntegerType::Int64 => 
            result.bits == 64 && result.min == -9223372036854775808 && result.max == 9223372036854775807,
        IntegerType::UInt8 => 
            result.bits == 8 && result.min == 0 && result.max == 255,
        IntegerType::UInt16 => 
            result.bits == 16 && result.min == 0 && result.max == 65535,
        IntegerType::UInt32 => 
            result.bits == 32 && result.min == 0 && result.max == 4294967295,
        IntegerType::UInt64 => 
            result.bits == 64 && result.min == 0 && result.max == 18446744073709551615,
    }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0111,verus,numpy_triple,constants_inf,,"IEEE 754 floating point representation of (positive) infinity

Specification: inf represents positive infinity with the following properties:
1. inf is greater than any finite float value
2. inf + any finite value = inf
3. inf * positive finite value = inf
4. inf * negative finite value = -inf
5. inf / any finite non-zero value = inf (with appropriate sign)

/* IEEE 754 floating point representation of (positive) infinity */","use vstd::prelude::*;

verus! {",,fn inf() -> (result: f32),"{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0112,verus,numpy_triple,constants_nan,,"IEEE 754 floating point representation of Not a Number (NaN)

IEEE 754 floating point representation of Not a Number (NaN)

Specification: nan represents Not a Number with the following IEEE 754 properties:
1. Float.isNaN returns true for NaN (primary property)
2. Any arithmetic operation with NaN results in NaN
3. NaN is not ordered (comparisons with any value are false except ≠)
4. NaN is not finite
5. Standard operations preserve NaN propagation

// NaN is not equal to itself","use vstd::prelude::*;

verus! {",,"fn nan() -> (result: f64)
    ensures result != result,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0113,verus,numpy_triple,constants_newaxis,,"A convenient alias for None, useful for indexing arrays. newaxis is an alias for None and is used to expand the dimensions of an array. Expands a vector to a column matrix (n × 1) using newaxis. This models the behavior of a[:, np.newaxis] which converts a 1D array of shape (n,) to a 2D array of shape (n, 1). Specification: expandToColumn creates a column matrix where each element is a singleton vector containing the corresponding element from the input vector. Mathematical property: The resulting matrix has shape (n, 1), each row contains exactly one element from the original vector, result[i][0] = v[i] for all valid indices.

/* Represents the newaxis constant used for dimension expansion.
   In NumPy, newaxis is used in indexing to add new dimensions to arrays.
   For our Vector-based implementation, we model this as a function that
   converts a 1D vector into a 2D vector (matrix) with either shape (n, 1) or (1, n). */","use vstd::prelude::*;

verus! {

pub enum NewAxis {
    Newaxis,
}",,"fn expand_to_column(v: Vec<i8>, axis: NewAxis) -> (result: Vec<Vec<i8>>)
    ensures
        result@.len() == v@.len(),
        forall|i: int| 0 <= i < result@.len() ==> (
            result@[i].len() == 1 &&
            result@[i][0] == v@[i]
        ),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0114,verus,numpy_triple,constants_pi,,"The mathematical constant pi (π), approximately 3.14159...

Specification: pi represents the ratio of a circle's circumference to its diameter,
and satisfies key mathematical properties","use vstd::prelude::*;

verus! {",,"fn pi() -> (result: i32)
    ensures
        result > 3 && result < 4","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0115,verus,numpy_triple,data_type_routines_as_strided,,"numpy.as_strided: Create a view into the array with the given shape and strides.

Creates a new view of an array with specified shape and strides.
This is a simplified version that focuses on the core mathematical
property: creating a view with a different shape but accessing
elements from the original array based on stride patterns.

For safety, we restrict to cases where the new shape is smaller
than or equal to the original array size.

Specification: numpy.as_strided creates a view with specified strides.

Precondition: The strided access must be valid (m * stride ≤ n)
Postcondition: Each element in the result is taken from the original
array at positions determined by the stride pattern.

For element i in the result, it equals x[i * stride].","use vstd::prelude::*;

verus! {",,"fn numpy_as_strided(x: &Vec<f32>, stride: usize, m: usize) -> (result: Vec<f32>)
    requires 
        stride > 0,
        m * stride <= x@.len(),
    ensures
        result@.len() == m,
        forall|i: int| 0 <= i < m ==> result@[i] == x@[i * stride as int],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0116,verus,numpy_triple,data_type_routines_can_cast,,"Returns True if cast between data types can occur according to the casting rule

/* Data type enumeration for casting rules */

/* no casting is allowed */

/* only byte-order changes are allowed */

/* only casts which can preserve values are allowed */

/* safe casts or casts within a kind */

/* any data conversions may be done */

/* Data type enumeration for supported numeric types */

/* Basic reflexivity: any type can cast to itself with any rule */

/* No casting rule: only identical types allowed */

/* Safe casting preserves values */

/* Integer widening is safe */

/* Float widening is safe */

/* Integer to float can be safe if no precision loss */

/* Complex widening is safe */

/* Float to complex is safe */

/* Same type is always safe */

/* Same kind casting allows within numeric families */

/* Integer family */

/* Float family */

/* Complex family */

/* Cross-family safe casts */

/* Unrestricted casting allows any conversion */

/* Equiv casting allows same types (byte-order changes only) */","use vstd::prelude::*;

verus! {

#[derive(PartialEq, Eq)]
pub enum CastingRule {
    No,
    Equiv,
    Safe,
    SameKind,
    Unrestricted,
}

#[derive(PartialEq, Eq)]
pub enum DType {
    Int8,
    Int16,
    Int32,
    Int64,
    Float32,
    Float64,
    Complex64,
    Complex128,
    Bool,
}",,"fn can_cast(from_dtype: DType, to_dtype: DType, casting: CastingRule) -> (result: bool)
    ensures

        (from_dtype == to_dtype ==> result == true) &&

        (casting == CastingRule::No ==> (result == true <==> from_dtype == to_dtype)) &&

        (casting == CastingRule::Safe ==> 
            (result == true ==> 

                ((from_dtype == DType::Int8 && (to_dtype == DType::Int16 || to_dtype == DType::Int32 || to_dtype == DType::Int64)) ||
                 (from_dtype == DType::Int16 && (to_dtype == DType::Int32 || to_dtype == DType::Int64)) ||
                 (from_dtype == DType::Int32 && to_dtype == DType::Int64) ||

                 (from_dtype == DType::Float32 && to_dtype == DType::Float64) ||

                 ((from_dtype == DType::Int8 || from_dtype == DType::Int16) && (to_dtype == DType::Float32 || to_dtype == DType::Float64)) ||
                 (from_dtype == DType::Int32 && to_dtype == DType::Float64) ||

                 (from_dtype == DType::Complex64 && to_dtype == DType::Complex128) ||

                 ((from_dtype == DType::Float32 || from_dtype == DType::Float64) && (to_dtype == DType::Complex64 || to_dtype == DType::Complex128)) ||

                 (from_dtype == to_dtype)))) &&

        (casting == CastingRule::SameKind ==> 
            (result == true ==> 

                (((from_dtype == DType::Int8 || from_dtype == DType::Int16 || from_dtype == DType::Int32 || from_dtype == DType::Int64) && 
                  (to_dtype == DType::Int8 || to_dtype == DType::Int16 || to_dtype == DType::Int32 || to_dtype == DType::Int64)) ||

                 ((from_dtype == DType::Float32 || from_dtype == DType::Float64) && 
                  (to_dtype == DType::Float32 || to_dtype == DType::Float64)) ||

                 ((from_dtype == DType::Complex64 || from_dtype == DType::Complex128) && 
                  (to_dtype == DType::Complex64 || to_dtype == DType::Complex128)) ||

                 ((from_dtype == DType::Int8 || from_dtype == DType::Int16 || from_dtype == DType::Int32 || from_dtype == DType::Int64) && 
                  (to_dtype == DType::Float32 || to_dtype == DType::Float64 || to_dtype == DType::Complex64 || to_dtype == DType::Complex128)) ||
                 ((from_dtype == DType::Float32 || from_dtype == DType::Float64) && 
                  (to_dtype == DType::Complex64 || to_dtype == DType::Complex128))))) &&

        (casting == CastingRule::Unrestricted ==> result == true) &&

        (casting == CastingRule::Equiv ==> (result == true <==> from_dtype == to_dtype))","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0118,verus,numpy_triple,data_type_routines_dtype,,"numpy.dtype: Create a data type object.

A numpy array is homogeneous, and contains elements described by a dtype object. 
A dtype object can be constructed from different combinations of fundamental numeric types.

This specification focuses on creating basic numeric data types like int16, int32, float32, float64.
The function maps type specifications to their corresponding DType objects with proper
attributes like size, alignment, and signedness.

Specification: numpy.dtype creates a valid data type object with consistent attributes.

Precondition: The type_spec is a valid NumPy type specification
Postcondition: The resulting DType has consistent attributes that match the specified type","use vstd::prelude::*;

verus! {

/* Represents a NumPy data type object with its essential attributes */
pub struct DType {
    /* The fundamental numeric type category */
    pub kind: &'static str,
    /* The element size in bytes */
    pub itemsize: usize,
    /* The alignment requirement in bytes */
    pub alignment: usize,
    /* A descriptive name for the data type */
    pub name: &'static str,
    /* Whether the data type is signed (for numeric types) */
    pub signed: bool,
}",,"fn numpy_dtype(type_spec: &str) -> (result: DType)
    requires type_spec == ""int8"" || type_spec == ""int16"" || type_spec == ""int32"" || 
             type_spec == ""int64"" || type_spec == ""float32"" || type_spec == ""float64"" || 
             type_spec == ""bool"",
    ensures
        /* The data type has a valid kind character */
        (result.kind == ""i"" || result.kind == ""f"" || result.kind == ""b"") &&
        /* The itemsize is positive and matches the type specification */
        (result.itemsize > 0) &&
        /* The alignment is positive and does not exceed the itemsize */
        (result.alignment > 0 && result.alignment <= result.itemsize) &&
        /* The name is non-empty */
        (result.name != """") &&
        /* Size consistency for specific types */
        ((type_spec == ""int8"" ==> result.itemsize == 1 && result.signed == true && result.kind == ""i"") &&
         (type_spec == ""int16"" ==> result.itemsize == 2 && result.signed == true && result.kind == ""i"") &&
         (type_spec == ""int32"" ==> result.itemsize == 4 && result.signed == true && result.kind == ""i"") &&
         (type_spec == ""int64"" ==> result.itemsize == 8 && result.signed == true && result.kind == ""i"") &&
         (type_spec == ""float32"" ==> result.itemsize == 4 && result.kind == ""f"") &&
         (type_spec == ""float64"" ==> result.itemsize == 8 && result.kind == ""f"") &&
         (type_spec == ""bool"" ==> result.itemsize == 1 && result.kind == ""b""))","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0119,verus,numpy_triple,data_type_routines_find_common_type,,"numpy.find_common_type: Determine common type following standard coercion rules.

This function determines the common data type by following NumPy's type promotion rules.
It returns the maximum of array_types ignoring scalar_types, unless the maximum of 
scalar_types is of a different kind (dtype.kind).

Note: This function is deprecated in NumPy 1.25.0 in favor of numpy.result_type.

Specification: find_common_type implements NumPy's type promotion rules correctly.

The function should:
1. Return the maximum precedence type from array_types if scalar_types is empty
2. Return the maximum precedence type from scalar_types if array_types is empty  
3. If both are non-empty, return the maximum from array_types unless the maximum
   from scalar_types has a different kind, in which case return the scalar maximum
4. Handle the case where type promotion results in a valid common type

Precondition: At least one of the input vectors is non-empty
Postcondition: The result follows NumPy's documented type promotion rules","use vstd::prelude::*;

verus! {

/* Data type representation for NumPy types */
#[derive(PartialEq, Eq, Clone, Copy)]
enum DType {
    /* 8-bit signed integer */
    Int8,
    /* 16-bit signed integer */
    Int16,
    /* 32-bit signed integer */
    Int32,
    /* 64-bit signed integer */
    Int64,
    /* 8-bit unsigned integer */
    UInt8,
    /* 16-bit unsigned integer */
    UInt16,
    /* 32-bit unsigned integer */
    UInt32,
    /* 64-bit unsigned integer */
    UInt64,
    /* 32-bit floating point */
    Float32,
    /* 64-bit floating point */
    Float64,
    /* 64-bit complex number */
    Complex64,
    /* 128-bit complex number */
    Complex128,
    /* Boolean type */
    Bool,
    /* Object type */
    Object,
}

/* Type hierarchy for promotion rules */
spec fn dtype_kind(dt: DType) -> char {
    match dt {
        DType::Bool => 'b',
        DType::Int8 | DType::Int16 | DType::Int32 | DType::Int64 => 'i',
        DType::UInt8 | DType::UInt16 | DType::UInt32 | DType::UInt64 => 'u',
        DType::Float32 | DType::Float64 => 'f',
        DType::Complex64 | DType::Complex128 => 'c',
        DType::Object => 'O',
    }
}

/* Type precedence for promotion (higher values have higher precedence) */
spec fn dtype_precedence(dt: DType) -> nat {
    match dt {
        DType::Bool => 0,
        DType::Int8 => 1,
        DType::Int16 => 2,
        DType::Int32 => 3,
        DType::Int64 => 4,
        DType::UInt8 => 5,
        DType::UInt16 => 6,
        DType::UInt32 => 7,
        DType::UInt64 => 8,
        DType::Float32 => 9,
        DType::Float64 => 10,
        DType::Complex64 => 11,
        DType::Complex128 => 12,
        DType::Object => 13,
    }
}",,"fn find_common_type(array_types: Vec<DType>, scalar_types: Vec<DType>) -> (result: Option<DType>)
    requires array_types.len() > 0 || scalar_types.len() > 0,
    ensures 
        /* Case 1: Only array types provided */
        (scalar_types.len() == 0 && array_types.len() > 0) ==> (
            exists|dt: DType| result == Some(dt) &&
            array_types@.contains(dt) &&
            forall|other: DType| array_types@.contains(other) ==> dtype_precedence(other) <= dtype_precedence(dt)
        ),
        /* Case 2: Only scalar types provided */
        (array_types.len() == 0 && scalar_types.len() > 0) ==> (
            exists|dt: DType| result == Some(dt) &&
            scalar_types@.contains(dt) &&
            forall|other: DType| scalar_types@.contains(other) ==> dtype_precedence(other) <= dtype_precedence(dt)
        ),
        /* Case 3: Both array and scalar types provided */
        (array_types.len() > 0 && scalar_types.len() > 0) ==> (
            exists|max_array: DType, max_scalar: DType|
                array_types@.contains(max_array) && scalar_types@.contains(max_scalar) &&
                (forall|dt: DType| array_types@.contains(dt) ==> dtype_precedence(dt) <= dtype_precedence(max_array)) &&
                (forall|dt: DType| scalar_types@.contains(dt) ==> dtype_precedence(dt) <= dtype_precedence(max_scalar)) &&
                ((dtype_kind(max_array) == dtype_kind(max_scalar)) ==> result == Some(max_array)) &&
                ((dtype_kind(max_array) != dtype_kind(max_scalar)) ==> result == Some(max_scalar))
        )","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0120,verus,numpy_triple,data_type_routines_finfo,,"Machine limits for floating point types.

Returns machine limits for the Float type in Lean.
This provides information about the precision and range of Float values.

In NumPy, this would accept different dtypes, but in Lean we work with the built-in Float type.

Specification: numpy.finfo returns floating point type information with correct properties.

Precondition: True (no special preconditions)
Postcondition: The returned FloatInfo has mathematically consistent properties","use vstd::prelude::*;

verus! {",,"/* Structure representing floating point type information returned by numpy.finfo */
struct FloatInfo {
    /* The number of bits occupied by the type */
    bits: u8,
    /* The smallest representable positive number such that 1.0 + eps != 1.0 */
    eps: i8,
    /* The largest representable number */
    max: i8,
    /* The smallest representable number, typically -max */
    min: i8,
    /* The approximate number of decimal digits to which this kind of float is precise */
    precision: u8,
    /* The approximate decimal resolution of this type */
    resolution: i8,
    /* The smallest positive floating point number with 1 as leading bit in the mantissa */
    smallest_normal: i8,
    /* The smallest positive floating point number with 0 as leading bit in the mantissa */
    smallest_subnormal: i8,
}

fn numpy_finfo() -> (info: FloatInfo)
    ensures
        /* Basic sanity checks */
        (info.bits as nat) > 0,
        (info.precision as nat) > 0,
        /* eps is positive and small */
        (info.eps as int) > 0,
        (info.eps as int) < 1,
        /* max is positive, min is negative */
        (info.max as int) > 0,
        (info.min as int) < 0,
        /* min is typically -max for symmetric floating point types */
        (info.min as int) == -((info.max as int)),
        /* resolution is positive */
        (info.resolution as int) > 0,
        /* smallest_normal is positive and smaller than 1 */
        (info.smallest_normal as int) > 0,
        (info.smallest_normal as int) < 1,
        /* smallest_subnormal is positive and smaller than smallest_normal */
        (info.smallest_subnormal as int) > 0,
        (info.smallest_subnormal as int) <= (info.smallest_normal as int),
        /* eps represents the machine epsilon property */
        (info.eps as int) == (info.resolution as int),
        /* The number of bits should be reasonable (32 or 64 for common float types) */
        (info.bits as nat) == 32 || (info.bits as nat) == 64,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0121,verus,numpy_triple,data_type_routines_format_parser,,"numpy.format_parser: Class to convert formats, names, titles description to a dtype.

This function takes format descriptions, field names, and optional titles
and produces a structured data type specification. It validates that the
formats are well-formed and that the number of names matches the number
of format descriptors.

The function handles common NumPy format strings like 'f8' (float64),
'i4' (int32), 'S5' (string of length 5), etc.

Specification: numpy.format_parser creates a structured data type from format descriptions.

Precondition: All format strings in formats are valid NumPy format descriptors
Postcondition: 
1. The result has the same number of fields as input vectors
2. Each field has the correct name from the names vector
3. Each field has the correct format descriptor parsed from the formats vector
4. If titles are provided, each field has the corresponding title
5. The alignment setting is preserved","use vstd::prelude::*;

verus! {

/* A format descriptor for structured data types */
#[derive(Eq, PartialEq)]
pub enum FormatDescriptor {
    /* 64-bit floating point ('f8') */
    Float64,
    /* 32-bit integer ('i4') */
    Int32,
    /* Variable length string ('S5' for string of length 5) */
    String(nat),
    /* 64-bit integer ('i8') */
    Int64,
    /* 32-bit floating point ('f4') */
    Float32,
}

/* A field in a structured data type */
#[derive(Eq, PartialEq)]
pub struct Field {
    /* Field name */
    pub name: String,
    /* Format descriptor */
    pub format: FormatDescriptor,
    /* Optional title for the field */
    pub title: Option<String>,
}

/* A structured data type specification */
#[derive(Eq, PartialEq)]
pub struct DType {
    /* Vector of fields */
    pub fields: Vec<Field>,
    /* Whether fields are aligned as C-compiler would */
    pub aligned: bool,
}",,"spec fn is_valid_format(format: String) -> bool {
    format@ == ""f8"".view() || format@ == ""f4"".view() || format@ == ""i4"".view() || format@ == ""i8"".view() || 
    (format@.len() > 1 && format@.index(0) == 'S')
}

spec fn parse_format_descriptor(format: String) -> FormatDescriptor {
    if format@ == ""f8"".view() {
        FormatDescriptor::Float64
    } else if format@ == ""f4"".view() {
        FormatDescriptor::Float32
    } else if format@ == ""i4"".view() {
        FormatDescriptor::Int32
    } else if format@ == ""i8"".view() {
        FormatDescriptor::Int64
    } else {
        FormatDescriptor::String(5) // simplified for spec
    }
}

fn numpy_format_parser(
    formats: Vec<String>,
    names: Vec<String>,
    titles: Option<Vec<String>>,
    aligned: bool
) -> (result: DType)
    requires 
        formats.len() == names.len(),
        titles.is_some() ==> titles.unwrap().len() == names.len(),
        forall|i: int| 0 <= i < formats.len() ==> is_valid_format(formats@[i]),
    ensures
        result.fields.len() == formats.len(),
        forall|i: int| 0 <= i < result.fields.len() ==> result.fields@[i].name == names@[i],
        forall|i: int| 0 <= i < result.fields.len() ==> 
            result.fields@[i].format == parse_format_descriptor(formats@[i]),
        match titles {
            Some(title_vec) => forall|i: int| 0 <= i < result.fields.len() ==> 
                result.fields@[i].title == Some(title_vec@[i]),
            None => forall|i: int| 0 <= i < result.fields.len() ==> 
                result.fields@[i].title.is_none(),
        },
        result.aligned == aligned,","{
    // impl-start
    assume(false);
    DType {
        fields: Vec::new(),
        aligned: false,
    }
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0122,verus,numpy_triple,data_type_routines_iinfo,,"Machine limits for integer types

Takes an integer type specification and returns information about 
the number of bits, minimum value, and maximum value for that type.
This provides access to the fundamental machine limits for integer
representation in numerical computing.

Specification: numpy.iinfo returns correct machine limits for integer types.

Precondition: True (no special preconditions for type information)
Postcondition: The returned IntInfo structure contains:
  - Correct bit count for the specified type
  - Correct minimum value (negative for signed types, 0 for unsigned)
  - Correct maximum value based on the bit representation
  - Consistency between bits and min/max values

/* Integer type information structure containing machine limits for integer types */

/* Number of bits occupied by the type */

/* Smallest integer expressible by the type */

/* Largest integer expressible by the type */

/* Enumeration of supported integer types */

/* 8-bit signed integer type */

/* 16-bit signed integer type */

/* 32-bit signed integer type */

/* 64-bit signed integer type */

/* 8-bit unsigned integer type */

/* 16-bit unsigned integer type */

/* 32-bit unsigned integer type */

/* 64-bit unsigned integer type */","use vstd::prelude::*;

verus! {",,"struct IntInfo {

    bits: u32,

    min: i64,

    max: i64,
}

enum IntType {

    Int8,

    Int16,

    Int32,

    Int64,

    UInt8,

    UInt16,

    UInt32,

    UInt64,
}

fn iinfo(int_type: IntType) -> (info: IntInfo)
    ensures
        match int_type {
            IntType::Int8 => info.bits == 8 && info.min == -128 && info.max == 127,
            IntType::Int16 => info.bits == 16 && info.min == -32768 && info.max == 32767,
            IntType::Int32 => info.bits == 32 && info.min == -2147483648 && info.max == 2147483647,
            IntType::Int64 => info.bits == 64 && info.min == -9223372036854775808 && info.max == 9223372036854775807,
            IntType::UInt8 => info.bits == 8 && info.min == 0 && info.max == 255,
            IntType::UInt16 => info.bits == 16 && info.min == 0 && info.max == 65535,
            IntType::UInt32 => info.bits == 32 && info.min == 0 && info.max == 4294967295,
            IntType::UInt64 => info.bits == 64 && info.min == 0 && info.max == 18446744073709551615,
        }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0123,verus,numpy_triple,data_type_routines_isdtype,,"numpy.isdtype: Determine if a provided dtype is of a specified data type kind.

This function checks whether a given NumPy dtype belongs to a specified
category of data types. It supports checking against specific dtype kinds
like 'bool', 'signed integer', 'unsigned integer', 'integral', 
'real floating', 'complex floating', and 'numeric'.

The function performs type introspection and classification of NumPy dtypes
according to their fundamental characteristics.

Specification: numpy.isdtype correctly identifies dtype kinds.

Precondition: True (works for any valid dtype and kind)
Postcondition: Returns true iff the dtype belongs to the specified kind category.

The function implements the following classification rules:
- Bool: dtype is boolean
- SignedInteger: dtype is signed integer (int8, int16, int32, int64)
- UnsignedInteger: dtype is unsigned integer (uint8, uint16, uint32, uint64)
- Integral: dtype is any integer type (signed or unsigned)
- RealFloating: dtype is real floating point (float16, float32, float64)
- ComplexFloating: dtype is complex floating point (complex64, complex128)
- Numeric: dtype is any numeric type (bool, integers, floats, complex)

/* NumPy data type representation */

/* Boolean data type */

/* 8-bit signed integer */

/* 16-bit signed integer */

/* 32-bit signed integer */

/* 64-bit signed integer */

/* 8-bit unsigned integer */

/* 16-bit unsigned integer */

/* 32-bit unsigned integer */

/* 64-bit unsigned integer */

/* 16-bit floating point */

/* 32-bit floating point */

/* 64-bit floating point */

/* 64-bit complex number */

/* 128-bit complex number */

/* NumPy data type kind categories */

/* Boolean kind */

/* Signed integer kind */

/* Unsigned integer kind */

/* Any integer kind (signed or unsigned) */

/* Real floating point kind */

/* Complex floating point kind */

/* Any numeric kind */

/* Get the fundamental kind of a NumPy dtype */

/* Check if a NumPy dtype belongs to a specific kind category */","use vstd::prelude::*;

verus! {

#[derive(PartialEq, Eq)]
pub enum NumpyDType {

    Bool,

    Int8,

    Int16,

    Int32,

    Int64,

    UInt8,

    UInt16,

    UInt32,

    UInt64,

    Float16,

    Float32,

    Float64,

    Complex64,

    Complex128,
}

#[derive(PartialEq, Eq)]
pub enum DTypeKind {

    Bool,

    SignedInteger,

    UnsignedInteger,

    Integral,

    RealFloating,

    ComplexFloating,

    Numeric,
}

spec fn get_dtype_kind(dtype: NumpyDType) -> DTypeKind {
    match dtype {
        NumpyDType::Bool => DTypeKind::Bool,
        NumpyDType::Int8 | NumpyDType::Int16 | NumpyDType::Int32 | NumpyDType::Int64 => DTypeKind::SignedInteger,
        NumpyDType::UInt8 | NumpyDType::UInt16 | NumpyDType::UInt32 | NumpyDType::UInt64 => DTypeKind::UnsignedInteger,
        NumpyDType::Float16 | NumpyDType::Float32 | NumpyDType::Float64 => DTypeKind::RealFloating,
        NumpyDType::Complex64 | NumpyDType::Complex128 => DTypeKind::ComplexFloating,
    }
}

spec fn is_of_kind(dtype: NumpyDType, kind: DTypeKind) -> bool {
    match kind {
        DTypeKind::Bool => get_dtype_kind(dtype) == DTypeKind::Bool,
        DTypeKind::SignedInteger => get_dtype_kind(dtype) == DTypeKind::SignedInteger,
        DTypeKind::UnsignedInteger => get_dtype_kind(dtype) == DTypeKind::UnsignedInteger,
        DTypeKind::Integral => get_dtype_kind(dtype) == DTypeKind::SignedInteger || get_dtype_kind(dtype) == DTypeKind::UnsignedInteger,
        DTypeKind::RealFloating => get_dtype_kind(dtype) == DTypeKind::RealFloating,
        DTypeKind::ComplexFloating => get_dtype_kind(dtype) == DTypeKind::ComplexFloating,
        DTypeKind::Numeric => get_dtype_kind(dtype) == DTypeKind::Bool || 
                             get_dtype_kind(dtype) == DTypeKind::SignedInteger || 
                             get_dtype_kind(dtype) == DTypeKind::UnsignedInteger || 
                             get_dtype_kind(dtype) == DTypeKind::RealFloating || 
                             get_dtype_kind(dtype) == DTypeKind::ComplexFloating,
    }
}",,"fn numpy_isdtype(dtype: NumpyDType, kind: DTypeKind) -> (result: bool)
    ensures result == is_of_kind(dtype, kind)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0124,verus,numpy_triple,data_type_routines_issctype,,"Determines whether the given object represents a scalar data-type

/* Represents different kinds of data types that can be tested */

/* Scalar integer type */

/* Scalar floating point type */

/* Scalar complex number type */

/* Scalar boolean type */

/* Scalar string type */

/* Array type */

/* Composite type */

/* Unknown type */

/* Helper function to check if a DataType is a scalar type */","use vstd::prelude::*;

verus! {

enum DataType {

    ScalarInt,

    ScalarFloat,

    ScalarComplex,

    ScalarBool,

    ScalarString,

    ArrayType,

    CompositeType,

    UnknownType,
}

spec fn is_scalar_type(dt: DataType) -> bool {
    match dt {
        DataType::ScalarInt => true,
        DataType::ScalarFloat => true,
        DataType::ScalarComplex => true,
        DataType::ScalarBool => true,
        DataType::ScalarString => true,
        DataType::ArrayType => false,
        DataType::CompositeType => false,
        DataType::UnknownType => false,
    }
}",,"fn issctype(rep: DataType) -> (result: bool)
    ensures result == (rep == DataType::ScalarInt || 
                      rep == DataType::ScalarFloat || 
                      rep == DataType::ScalarComplex || 
                      rep == DataType::ScalarBool || 
                      rep == DataType::ScalarString)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0125,verus,numpy_triple,data_type_routines_issubclass_,,"numpy.issubclass_: Determine if a class is a subclass of a second class.

This function is equivalent to the Python built-in issubclass, except that it returns 
False instead of raising a TypeError if one of the arguments is not a class.

In the context of NumPy, this tests relationships between NumPy data type classes
such as whether int32 is a subclass of integer, or whether float64 is a subclass of float.

Specification: issubclass_ correctly determines class hierarchy relationships.

This function tests whether arg1 is a subclass of arg2 according to NumPy's type
hierarchy. The specification ensures that:
1. The function respects the established type hierarchy (e.g., int32 ⊆ integer ⊆ number ⊆ scalar)
2. It handles reflexivity correctly (every class is a subclass of itself)
3. It returns False for unrelated classes
4. It never raises exceptions (returns False instead of error for invalid inputs)

Precondition: True (no special preconditions, handles all inputs gracefully)
Postcondition: Returns True if arg1 is a subclass of arg2, False otherwise

/* Represents a NumPy type class for hierarchy testing */

/* Integer types */

/* Floating point types */

/* Complex number types */

/* Boolean type */

/* Scalar types (superclass of all numeric types) */

/* Number types (excludes boolean) */

/* Inexact types (floating and complex) */

/* 8-bit signed integer type */

/* 16-bit signed integer type */

/* 32-bit signed integer type */

/* 64-bit signed integer type */

/* 8-bit unsigned integer type */

/* 16-bit unsigned integer type */

/* 32-bit unsigned integer type */

/* 64-bit unsigned integer type */

/* 32-bit floating point type */

/* 64-bit floating point type */

/* 64-bit complex number type */

/* 128-bit complex number type */

/* Generic object type */

/* Defines the class hierarchy relationships for NumPy types */

/* Reflexivity: every class is a subclass of itself */

/* Concrete integer types are subclasses of IntegerType */

/* Concrete floating types are subclasses of FloatingType */

/* Concrete complex types are subclasses of ComplexType */

/* Integer types are subclasses of NumberType */

/* Floating types are subclasses of InexactType and NumberType */

/* Complex types are subclasses of InexactType and NumberType */

/* All numeric types are subclasses of ScalarType */

/* Default case */

/* Result matches the defined hierarchy */

/* Reflexivity: every class is a subclass of itself */

/* Concrete examples from NumPy documentation */

/* Transitivity: int32 → integer → number → scalar */

/* All numeric types are subclasses of ScalarType */","use vstd::prelude::*;

verus! {

#[derive(PartialEq, Eq)]
enum NumpyTypeClass {

    IntegerType,

    FloatingType,

    ComplexType,

    BooleanType,

    ScalarType,

    NumberType,

    InexactType,

    Int8Type,

    Int16Type,

    Int32Type,

    Int64Type,

    UInt8Type,

    UInt16Type,

    UInt32Type,

    UInt64Type,

    Float32Type,

    Float64Type,

    Complex64Type,

    Complex128Type,

    ObjectType,
}

spec fn is_subclass_spec(t: NumpyTypeClass, t_prime: NumpyTypeClass) -> bool {

    if t == t_prime {
        true
    } else {
        match (t, t_prime) {

            (NumpyTypeClass::Int8Type, NumpyTypeClass::IntegerType) => true,
            (NumpyTypeClass::Int16Type, NumpyTypeClass::IntegerType) => true,
            (NumpyTypeClass::Int32Type, NumpyTypeClass::IntegerType) => true,
            (NumpyTypeClass::Int64Type, NumpyTypeClass::IntegerType) => true,
            (NumpyTypeClass::UInt8Type, NumpyTypeClass::IntegerType) => true,
            (NumpyTypeClass::UInt16Type, NumpyTypeClass::IntegerType) => true,
            (NumpyTypeClass::UInt32Type, NumpyTypeClass::IntegerType) => true,
            (NumpyTypeClass::UInt64Type, NumpyTypeClass::IntegerType) => true,

            (NumpyTypeClass::Float32Type, NumpyTypeClass::FloatingType) => true,
            (NumpyTypeClass::Float64Type, NumpyTypeClass::FloatingType) => true,

            (NumpyTypeClass::Complex64Type, NumpyTypeClass::ComplexType) => true,
            (NumpyTypeClass::Complex128Type, NumpyTypeClass::ComplexType) => true,

            (NumpyTypeClass::IntegerType, NumpyTypeClass::NumberType) => true,

            (NumpyTypeClass::FloatingType, NumpyTypeClass::InexactType) => true,
            (NumpyTypeClass::FloatingType, NumpyTypeClass::NumberType) => true,

            (NumpyTypeClass::ComplexType, NumpyTypeClass::InexactType) => true,
            (NumpyTypeClass::ComplexType, NumpyTypeClass::NumberType) => true,

            (NumpyTypeClass::NumberType, NumpyTypeClass::ScalarType) => true,
            (NumpyTypeClass::BooleanType, NumpyTypeClass::ScalarType) => true,
            (NumpyTypeClass::IntegerType, NumpyTypeClass::ScalarType) => true,
            (NumpyTypeClass::FloatingType, NumpyTypeClass::ScalarType) => true,
            (NumpyTypeClass::ComplexType, NumpyTypeClass::ScalarType) => true,
            (NumpyTypeClass::InexactType, NumpyTypeClass::ScalarType) => true,

            _ => false,
        }
    }
}",,"fn issubclass_(arg1: NumpyTypeClass, arg2: NumpyTypeClass) -> (result: bool)
    ensures

        result == is_subclass_spec(arg1, arg2),

        (arg1 == arg2) ==> (result == true),

        (arg1 == NumpyTypeClass::Int32Type && arg2 == NumpyTypeClass::IntegerType) ==> (result == true),
        (arg1 == NumpyTypeClass::Float64Type && arg2 == NumpyTypeClass::FloatingType) ==> (result == true),
        (arg1 == NumpyTypeClass::Int32Type && arg2 == NumpyTypeClass::FloatingType) ==> (result == false),

        (arg1 == NumpyTypeClass::Int32Type && arg2 == NumpyTypeClass::NumberType) ==> 
         (is_subclass_spec(NumpyTypeClass::Int32Type, NumpyTypeClass::IntegerType) &&
          is_subclass_spec(NumpyTypeClass::IntegerType, NumpyTypeClass::NumberType)),

        (arg1 == NumpyTypeClass::IntegerType && arg2 == NumpyTypeClass::ScalarType) ==> (result == true),
        (arg1 == NumpyTypeClass::FloatingType && arg2 == NumpyTypeClass::ScalarType) ==> (result == true),
        (arg1 == NumpyTypeClass::ComplexType && arg2 == NumpyTypeClass::ScalarType) ==> (result == true)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0126,verus,numpy_triple,data_type_routines_issubdtype,,"numpy.issubdtype: Returns True if first argument is a typecode lower/equal in type hierarchy.

This function checks if the first data type is a subtype of the second data type
in the NumPy type hierarchy. It's similar to Python's built-in issubclass but
operates on NumPy data types.

The function implements the NumPy type hierarchy where types are organized
in a tree structure with 'generic' at the root.

Specification: issubdtype returns True if arg1 is a subtype of arg2 in the NumPy type hierarchy.

Precondition: True (works with any valid NumPy data types)
Postcondition: The result is True if and only if arg1 is a subtype of arg2 
according to the NumPy type hierarchy rules.

Key properties:
1. Reflexivity: Every type is a subtype of itself
2. Transitivity: If A is subtype of B and B is subtype of C, then A is subtype of C
3. Hierarchy rules: Specific types are subtypes of their parent categories
4. Root type: All types are subtypes of 'generic'

/* Define a NumPy-like type hierarchy representing the data type system in NumPy */

/* Generic root type */

/* Inexact numeric type */

/* Floating point type */

/* 32-bit floating point */

/* 64-bit floating point */

/* Numeric type */

/* Integer type */

/* Signed integer type */

/* 8-bit signed integer */

/* 16-bit signed integer */

/* 32-bit signed integer */

/* 64-bit signed integer */

/* Unsigned integer type */

/* 8-bit unsigned integer */

/* 16-bit unsigned integer */

/* 32-bit unsigned integer */

/* 64-bit unsigned integer */

/* Character type */

/* Bytes type */

/* String type */

/* Boolean type */

/* Define the subtype relation for NumPy types */

/* Float hierarchy */

/* Integer hierarchy */

/* Character hierarchy */

/* Boolean hierarchy */

/* Number hierarchy */

/* Reflexivity property */

/* Generic is supertype of all types */

/* Specific hierarchy rules */

/* Non-subtype examples */","use vstd::prelude::*;

verus! {

pub enum NumpyDType {

    Generic,

    Inexact(Box<NumpyDType>),

    Floating(Box<NumpyDType>),

    Float32,

    Float64,

    Number(Box<NumpyDType>),

    Integer(Box<NumpyDType>),

    SignedInteger(Box<NumpyDType>),

    Int8,

    Int16,

    Int32,

    Int64,

    UnsignedInteger(Box<NumpyDType>),

    UInt8,

    UInt16,

    UInt32,

    UInt64,

    Character(Box<NumpyDType>),

    Bytes_,

    Str_,

    Bool_,
}

spec fn is_sub_dtype_spec(dtype1: NumpyDType, dtype2: NumpyDType) -> bool {
    if dtype1 == dtype2 {
        true
    } else {
        match (dtype1, dtype2) {

            (NumpyDType::Float32, NumpyDType::Floating(_)) => true,
            (NumpyDType::Float64, NumpyDType::Floating(_)) => true,
            (NumpyDType::Floating(_), NumpyDType::Inexact(_)) => true,
            (NumpyDType::Floating(_), NumpyDType::Number(_)) => true,
            (NumpyDType::Floating(_), NumpyDType::Generic) => true,

            (NumpyDType::Int8, NumpyDType::SignedInteger(_)) => true,
            (NumpyDType::Int16, NumpyDType::SignedInteger(_)) => true,
            (NumpyDType::Int32, NumpyDType::SignedInteger(_)) => true,
            (NumpyDType::Int64, NumpyDType::SignedInteger(_)) => true,
            (NumpyDType::UInt8, NumpyDType::UnsignedInteger(_)) => true,
            (NumpyDType::UInt16, NumpyDType::UnsignedInteger(_)) => true,
            (NumpyDType::UInt32, NumpyDType::UnsignedInteger(_)) => true,
            (NumpyDType::UInt64, NumpyDType::UnsignedInteger(_)) => true,
            (NumpyDType::SignedInteger(_), NumpyDType::Integer(_)) => true,
            (NumpyDType::UnsignedInteger(_), NumpyDType::Integer(_)) => true,
            (NumpyDType::Integer(_), NumpyDType::Number(_)) => true,
            (NumpyDType::Integer(_), NumpyDType::Generic) => true,

            (NumpyDType::Str_, NumpyDType::Character(_)) => true,
            (NumpyDType::Bytes_, NumpyDType::Character(_)) => true,
            (NumpyDType::Character(_), NumpyDType::Generic) => true,

            (NumpyDType::Bool_, NumpyDType::Generic) => true,

            (NumpyDType::Number(_), NumpyDType::Generic) => true,
            (NumpyDType::Inexact(_), NumpyDType::Generic) => true,
            _ => false,
        }
    }
}",,"fn issubdtype(arg1: NumpyDType, arg2: NumpyDType) -> (result: bool)
    ensures 
        result == is_sub_dtype_spec(arg1, arg2) &&

        (arg1 == arg2 ==> result == true) &&

        (arg2 == NumpyDType::Generic ==> result == true) &&

        (arg1 == NumpyDType::Float32 && matches!(arg2, NumpyDType::Floating(_)) ==> result == true) &&
        (arg1 == NumpyDType::Float64 && matches!(arg2, NumpyDType::Floating(_)) ==> result == true) &&
        (arg1 == NumpyDType::Int32 && matches!(arg2, NumpyDType::SignedInteger(_)) ==> result == true) &&
        (arg1 == NumpyDType::UInt32 && matches!(arg2, NumpyDType::UnsignedInteger(_)) ==> result == true) &&

        (arg1 == NumpyDType::Float32 && arg2 == NumpyDType::Float64 ==> result == false) &&
        (arg1 == NumpyDType::Float64 && arg2 == NumpyDType::Float32 ==> result == false) &&
        (arg1 == NumpyDType::Int32 && matches!(arg2, NumpyDType::Floating(_)) ==> result == false)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0128,verus,numpy_triple,data_type_routines_maximum_sctype,,"Return the scalar type of highest precision of the same kind as the input.

This function implements numpy.maximum_sctype functionality, which takes a numeric type
and returns the highest precision type of the same kind. For example, int8 becomes int64,
float32 becomes float128, complex64 becomes complex256.

/* Define a type hierarchy for numeric types */

/* Signed integer types */

/* Unsigned integer types */

/* Floating point types */

/* Complex number types */

/* String types */

/* Boolean types */

/* Define precision levels for each kind */

/* 8-bit precision */

/* 16-bit precision */

/* 32-bit precision */

/* 64-bit precision */

/* 128-bit precision */

/* 256-bit precision */

/* A numeric type representation */

/* The kind of numeric type */

/* The precision level */

/* Define the maximum precision for each kind */

// Represents max string length handling

/* Define precision ordering */","use vstd::prelude::*;

verus! {

#[derive(PartialEq, Eq, Structural)]
enum NumericKind {

    Integer,

    UnsignedInteger,

    Float,

    Complex,

    String,

    Boolean,
}

#[derive(PartialEq, Eq, Structural)]
enum Precision {

    P8,

    P16,

    P32,

    P64,

    P128,

    P256,
}

#[derive(PartialEq, Eq, Structural)]
struct NumericType {

    kind: NumericKind,

    precision: Precision,
}

spec fn max_precision_for(kind: NumericKind) -> Precision {
    match kind {
        NumericKind::Integer => Precision::P64,
        NumericKind::UnsignedInteger => Precision::P64,
        NumericKind::Float => Precision::P128,
        NumericKind::Complex => Precision::P256,
        NumericKind::String => Precision::P64,
        NumericKind::Boolean => Precision::P8,
    }
}

spec fn precision_le(p1: Precision, p2: Precision) -> bool {
    match (p1, p2) {
        (Precision::P8, _) => true,
        (Precision::P16, Precision::P8) => false,
        (Precision::P16, _) => true,
        (Precision::P32, Precision::P8) => false,
        (Precision::P32, Precision::P16) => false,
        (Precision::P32, _) => true,
        (Precision::P64, Precision::P8) => false,
        (Precision::P64, Precision::P16) => false,
        (Precision::P64, Precision::P32) => false,
        (Precision::P64, _) => true,
        (Precision::P128, Precision::P256) => true,
        (Precision::P128, _) => false,
        (Precision::P256, _) => false,
    }
}",,"fn maximum_sctype(t: NumericType) -> (result: NumericType)
    ensures 
        result.kind == t.kind &&
        result.precision == max_precision_for(t.kind) &&
        precision_le(t.precision, result.precision)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0129,verus,numpy_triple,data_type_routines_may_share_memory,,"numpy.may_share_memory: Determine if two arrays might share memory.

This function conservatively checks if two arrays might share memory.
A return of True does not necessarily mean that the two arrays share any element.
It just means that they might.

Only the memory bounds of a and b are checked by default.

Specification: may_share_memory returns a boolean indicating whether two arrays might share memory.

Precondition: True (no special preconditions needed)
Postcondition: The function returns a boolean value. If the arrays are identical references,
it must return True. For independent arrays, it may return False.
The function is conservative - it can return True even when arrays don't actually share memory.

/* Basic sanity check: result is a boolean */

/* Conservative property: function is sound - may return True even when arrays don't share memory */

/* but will detect potential memory overlap based on bounds analysis */

/* Deterministic property: same inputs always produce same output */

/* Reflexive property: an array compared with itself would return consistent result */","use vstd::prelude::*;

verus! {",,"fn may_share_memory(a: &Vec<i8>, b: &Vec<i8>) -> (result: bool)
    ensures

        (result == true || result == false) &&

        (result == true ==> true) &&

        true &&

        true","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0130,verus,numpy_triple,data_type_routines_min_scalar_type,,"numpy.min_scalar_type: For scalar a, returns the data type with the smallest size 
and smallest scalar kind which can hold its value.

This function determines the minimal NumPy data type that can represent a given scalar value.
The function prioritizes:
1. Smallest possible size (in bits)
2. Smallest scalar kind (unsigned int < signed int < float < complex)

For integer values, it finds the smallest integer type that can hold the value.
For floating point values, it finds the smallest float type that can represent it.

Specification: min_scalar_type returns the minimal data type that can hold the given value.

Precondition: True (works for any scalar value)
Postcondition: The returned type is the minimal type that can hold the value, meaning:
1. The type can represent the given value
2. No type with smaller size can represent the value
3. Among types of the same size, it has the smallest kind order","use vstd::prelude::*;

verus! {
/* Enumeration for NumPy data types */
#[derive(PartialEq, Eq, Structural)]
pub enum NumpyDType {
    UInt8,
    UInt16,
    UInt32,
    UInt64,
    Int8,
    Int16,
    Int32,
    Int64,
    Float16,
    Float32,
    Float64,
    Complex64,
    Complex128,
}

/* Define type sizes in bits */
spec fn dtype_size(dt: NumpyDType) -> nat {
    match dt {
        NumpyDType::UInt8 => 8,
        NumpyDType::UInt16 => 16,
        NumpyDType::UInt32 => 32,
        NumpyDType::UInt64 => 64,
        NumpyDType::Int8 => 8,
        NumpyDType::Int16 => 16,
        NumpyDType::Int32 => 32,
        NumpyDType::Int64 => 64,
        NumpyDType::Float16 => 16,
        NumpyDType::Float32 => 32,
        NumpyDType::Float64 => 64,
        NumpyDType::Complex64 => 64,
        NumpyDType::Complex128 => 128,
    }
}

/* Define type hierarchy (order of preference) */
spec fn dtype_kind_order(dt: NumpyDType) -> nat {
    match dt {
        NumpyDType::UInt8 | NumpyDType::UInt16 | NumpyDType::UInt32 | NumpyDType::UInt64 => 0,
        NumpyDType::Int8 | NumpyDType::Int16 | NumpyDType::Int32 | NumpyDType::Int64 => 1,
        NumpyDType::Float16 | NumpyDType::Float32 | NumpyDType::Float64 => 2,
        NumpyDType::Complex64 | NumpyDType::Complex128 => 3,
    }
}

/* Check if a type can represent a given integer value */
spec fn can_represent_value(dt: NumpyDType, value: int) -> bool {
    match dt {
        NumpyDType::UInt8 => 0 <= value <= 255,
        NumpyDType::UInt16 => 0 <= value <= 65535,
        NumpyDType::UInt32 => 0 <= value <= 4294967295,
        NumpyDType::UInt64 => 0 <= value <= 18446744073709551615,
        NumpyDType::Int8 => -128 <= value <= 127,
        NumpyDType::Int16 => -32768 <= value <= 32767,
        NumpyDType::Int32 => -2147483648 <= value <= 2147483647,
        NumpyDType::Int64 => -9223372036854775808 <= value <= 9223372036854775807,
        NumpyDType::Float16 | NumpyDType::Float32 | NumpyDType::Float64 | NumpyDType::Complex64 | NumpyDType::Complex128 => true,
    }
}",,"fn min_scalar_type(value: i8) -> (result: NumpyDType)
    ensures
        can_represent_value(result, value as int),
        forall|dt: NumpyDType| dtype_size(dt) < dtype_size(result) ==> !can_represent_value(dt, value as int),
        forall|dt: NumpyDType| dtype_size(dt) == dtype_size(result) && can_represent_value(dt, value as int) ==> dtype_kind_order(result) <= dtype_kind_order(dt)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,1.0
VT0131,verus,numpy_triple,data_type_routines_mintypecode,,"Return the character for the minimum-size type to which given types can be safely cast

/* NumPy type character to precedence mapping based on the default typeset 'GDFgdf'
   Lower values indicate higher precedence (smaller/more restrictive types) */

// longdouble (most restrictive in numerical sense)

// double

// float

// csingle (complex float)

// cdouble (complex double)

// clongdouble (complex long double)

// other types (lowest precedence)

/* Check if a type character is in the given typeset */

/* Filter characters that are in the typeset */

/* Find minimum precedence character in a sequence */

// default fallback

// Case 1: No input types in typeset - return default

// Case 2 & 3: When intersection is non-empty

// Special rule - if both 'F' and 'd' are in intersection, return 'D'

// Normal case - return minimum precedence type from intersection

// Validity: result is either from intersection or default","use vstd::prelude::*;

verus! {

spec fn typechar_precedence(c: char) -> nat {
    match c {
        'g' => 0,
        'd' => 1,
        'f' => 2,
        'F' => 3,
        'D' => 4,
        'G' => 5,
        _   => 6,
    }
}

spec fn char_in_typeset(c: char, typeset: Seq<char>) -> bool {
    typeset.contains(c)
}

spec fn filter_chars_in_typeset(typechars: Seq<char>, typeset: Seq<char>) -> Seq<char> {
    typechars.filter(|c: char| char_in_typeset(c, typeset))
}

spec fn min_precedence_char(chars: Seq<char>) -> char
    decreases chars.len()
{
    if chars.len() == 0 {
        'G'
    } else if chars.len() == 1 {
        chars[0]
    } else {
        let first = chars[0];
        let rest_min = min_precedence_char(chars.skip(1));
        if typechar_precedence(first) <= typechar_precedence(rest_min) {
            first
        } else {
            rest_min
        }
    }
}",,"fn mintypecode(typechars: Vec<char>, typeset: Vec<char>, default: char) -> (result: char)
    requires typeset@ == seq!['G', 'D', 'F', 'g', 'd', 'f'],
    ensures ({
        let intersection = filter_chars_in_typeset(typechars@, typeset@);

        (intersection.len() == 0 ==> result == default) &&

        (intersection.len() > 0 ==> {

            if intersection.contains('F') && intersection.contains('d') {
                result == 'D'
            } else {

                intersection.contains(result) &&
                (forall|c: char| intersection.contains(c) ==> typechar_precedence(result) <= typechar_precedence(c))
            }
        }) &&

        (intersection.contains(result) || result == default)
    })","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0132,verus,numpy_triple,data_type_routines_obj2sctype,,"numpy.obj2sctype: Return the scalar dtype or NumPy equivalent of Python type of an object.

Takes any object and returns its corresponding NumPy scalar data type.
If the object's type cannot be determined, returns the default value if provided,
otherwise returns none.

This function performs type introspection to determine the appropriate NumPy
scalar type for any given object, including arrays, scalars, and generic objects.

Specification: obj2sctype returns the appropriate NumPy scalar type for the input object.

The function correctly identifies:
1. Scalar types from their corresponding objects
2. Array element types from array objects
3. Generic object types
4. Returns default for unrecognized types
5. Returns none when no default is provided for unrecognized types

Precondition: True (works with any object)
Postcondition: The result correctly represents the scalar type of the input object

/* NumPy scalar data types represented as an enum */

/* Object representation for type introspection */

/* Helper predicate: Check if object matches given scalar type */

/* Helper predicate: Check if object is an array with given element type */

/* Helper predicate: Check if object is a generic object */","use vstd::prelude::*;

verus! {

#[derive(PartialEq, Eq)]
pub enum NumpyScalarType {
    Int32,
    Int64,
    Float32,
    Float64,
    Complex64,
    Complex128,
    Object,
    String,
    Bool,
}

pub enum NumpyObject {
    IntVal(i64),
    FloatVal(f64),
    ArrayInt(Vec<i64>),
    ArrayFloat(Vec<f64>),
    ArrayComplex(Vec<(f64, f64)>),
    GenericObj,
    StringVal(String),
    BoolVal(bool),
}

pub open spec fn matches_scalar_type(obj: NumpyObject, dtype: NumpyScalarType) -> bool {
    match (obj, dtype) {
        (NumpyObject::IntVal(_), NumpyScalarType::Int64) => true,
        (NumpyObject::FloatVal(_), NumpyScalarType::Float64) => true,
        (NumpyObject::StringVal(_), NumpyScalarType::String) => true,
        (NumpyObject::BoolVal(_), NumpyScalarType::Bool) => true,
        _ => false,
    }
}

pub open spec fn is_array_with_element_type(obj: NumpyObject, dtype: NumpyScalarType) -> bool {
    match (obj, dtype) {
        (NumpyObject::ArrayInt(_), NumpyScalarType::Int64) => true,
        (NumpyObject::ArrayFloat(_), NumpyScalarType::Float64) => true,
        (NumpyObject::ArrayComplex(_), NumpyScalarType::Complex128) => true,
        _ => false,
    }
}

pub open spec fn is_generic_object(obj: NumpyObject) -> bool {
    match obj {
        NumpyObject::GenericObj => true,
        _ => false,
    }
}",,"fn obj2sctype(rep: NumpyObject, default: Option<NumpyScalarType>) -> (result: Option<NumpyScalarType>)
    ensures
        match rep {
            NumpyObject::IntVal(_) => result == Some(NumpyScalarType::Int64),
            NumpyObject::FloatVal(_) => result == Some(NumpyScalarType::Float64),
            NumpyObject::ArrayInt(_) => result == Some(NumpyScalarType::Int64),
            NumpyObject::ArrayFloat(_) => result == Some(NumpyScalarType::Float64),
            NumpyObject::ArrayComplex(_) => result == Some(NumpyScalarType::Complex128),
            NumpyObject::StringVal(_) => result == Some(NumpyScalarType::String),
            NumpyObject::BoolVal(_) => result == Some(NumpyScalarType::Bool),
            NumpyObject::GenericObj => result == default,
        },
        match result {
            Some(dtype) => 
                matches_scalar_type(rep, dtype) || 
                is_array_with_element_type(rep, dtype) ||
                (is_generic_object(rep) && result == default),
            None => is_generic_object(rep) && default.is_None(),
        }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0133,verus,numpy_triple,data_type_routines_promote_types,,"numpy.promote_types: Returns the data type with the smallest size and smallest scalar kind to which both type1 and type2 may be safely cast. This function is symmetric but rarely associative. It returns a ""canonical"" dtype. Examples from NumPy documentation: promote_types('f4', 'f8') = 'f8' (float64), promote_types('i8', 'f4') = 'f8' (float64), promote_types('i4', 'S8') = 'S11' (string, but we focus on numeric types). Specification: promote_types returns the smallest safe common type for two dtypes. Key properties based on NumPy's type promotion rules: 1. Symmetry: promote_types(a, b) = promote_types(b, a), 2. Safety: Both input types can be safely cast to the result type, 3. Minimality: The result is the smallest type that satisfies the safety requirement, 4. Type promotion hierarchy: If either input is complex, result is complex; If either input is float, result is float (unless both are complex); Signed integers promote to larger signed integers; Unsigned integers promote to larger unsigned integers; Mixed signed/unsigned promote to signed of sufficient size, 5. Size consideration: Result has size >= max(size(type1), size(type2)), 6. Specific examples: Float32 + Float64 → Float64 (larger precision); Int64 + Float32 → Float64 (float with sufficient precision); Complex64 + Float32 → Complex64 (complex dominates).

/* Symmetry property - function is commutative */

/* Type promotion hierarchy rules */

/* If either input is complex, result must be complex */

/* If either input is float (and not complex), result is float or complex */

/* Size constraint: result size >= max of input sizes */

/* Promotion hierarchy: result rank >= max of input ranks */

/* Same types promote to themselves (reflexivity) */

/* Float precision promotion */","use vstd::prelude::*;

verus! {

#[derive(Copy, Clone, PartialEq, Eq)]
pub enum NumpyDType {
    UInt8,
    UInt16,
    UInt32,
    UInt64,
    Int8,
    Int16,
    Int32,
    Int64,
    Float16,
    Float32,
    Float64,
    Complex64,
    Complex128,
}

spec fn dtype_size(dt: NumpyDType) -> nat {
    match dt {
        NumpyDType::UInt8 => 8,
        NumpyDType::UInt16 => 16,
        NumpyDType::UInt32 => 32,
        NumpyDType::UInt64 => 64,
        NumpyDType::Int8 => 8,
        NumpyDType::Int16 => 16,
        NumpyDType::Int32 => 32,
        NumpyDType::Int64 => 64,
        NumpyDType::Float16 => 16,
        NumpyDType::Float32 => 32,
        NumpyDType::Float64 => 64,
        NumpyDType::Complex64 => 64,
        NumpyDType::Complex128 => 128,
    }
}

spec fn promotion_hierarchy(dt: NumpyDType) -> nat {
    match dt {
        NumpyDType::UInt8 => 0,
        NumpyDType::UInt16 => 1,
        NumpyDType::UInt32 => 2,
        NumpyDType::UInt64 => 3,
        NumpyDType::Int8 => 4,
        NumpyDType::Int16 => 5,
        NumpyDType::Int32 => 6,
        NumpyDType::Int64 => 7,
        NumpyDType::Float16 => 8,
        NumpyDType::Float32 => 9,
        NumpyDType::Float64 => 10,
        NumpyDType::Complex64 => 11,
        NumpyDType::Complex128 => 12,
    }
}

spec fn is_signed_integer(dt: NumpyDType) -> bool {
    match dt {
        NumpyDType::Int8 | NumpyDType::Int16 | NumpyDType::Int32 | NumpyDType::Int64 => true,
        _ => false,
    }
}

spec fn is_unsigned_integer(dt: NumpyDType) -> bool {
    match dt {
        NumpyDType::UInt8 | NumpyDType::UInt16 | NumpyDType::UInt32 | NumpyDType::UInt64 => true,
        _ => false,
    }
}

spec fn is_float(dt: NumpyDType) -> bool {
    match dt {
        NumpyDType::Float16 | NumpyDType::Float32 | NumpyDType::Float64 => true,
        _ => false,
    }
}

spec fn is_complex(dt: NumpyDType) -> bool {
    match dt {
        NumpyDType::Complex64 | NumpyDType::Complex128 => true,
        _ => false,
    }
}",,"spec fn promote_types_spec(type1: NumpyDType, type2: NumpyDType) -> NumpyDType;

fn promote_types(type1: NumpyDType, type2: NumpyDType) -> (result: NumpyDType)
    ensures
        result == promote_types_spec(type1, type2),

        promote_types_spec(type1, type2) == promote_types_spec(type2, type1),

        (is_complex(type1) || is_complex(type2)) ==> is_complex(result),

        (is_float(type1) || is_float(type2)) ==> (is_float(result) || is_complex(result)),

        dtype_size(result) >= if dtype_size(type1) >= dtype_size(type2) { dtype_size(type1) } else { dtype_size(type2) },

        promotion_hierarchy(result) >= if promotion_hierarchy(type1) >= promotion_hierarchy(type2) { promotion_hierarchy(type1) } else { promotion_hierarchy(type2) },

        (type1 == type2) ==> (result == type1),

        (is_float(type1) && is_float(type2)) ==> (
            is_float(result) && dtype_size(result) >= if dtype_size(type1) >= dtype_size(type2) { dtype_size(type1) } else { dtype_size(type2) }
        ),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0134,verus,numpy_triple,data_type_routines_result_type,,"Returns the data type that results from applying NumPy type promotion rules to the arguments. 

Type promotion in NumPy works similarly to the rules in languages like C++, with some differences. When both scalars and arrays are used, the array's type takes precedence and the scalar's actual value is considered.

The function takes operands of some operation and returns the result type according to NumPy's type promotion hierarchy.

/* Define NumPy data types for type promotion */

/* 8-bit signed integer */

/* 16-bit signed integer */

/* 32-bit signed integer */

/* 64-bit signed integer */

/* 32-bit floating point */

/* 64-bit floating point */

/* 64-bit complex number */

/* 128-bit complex number */

/* Boolean type */

/* Define type promotion hierarchy (higher number = higher precedence) */

/* Define operand types (either scalar or array) */

/* Scalar value with data type */

/* Array with data type and vector of values */

/* Extract the data type from an operand */

/* Type promotion function for two types */

/* The result type is at least as high in the hierarchy as any input type */

/* The result type is the minimum type that can represent all inputs */

/* Type promotion follows the standard hierarchy */","use vstd::prelude::*;

verus! {

#[derive(PartialEq, Eq, Structural)]
pub enum NumpyDType {

    Int8,

    Int16,

    Int32,

    Int64,

    Float32,

    Float64,

    Complex64,

    Complex128,

    Bool,
}

spec fn type_rank(dtype: NumpyDType) -> nat {
    match dtype {
        NumpyDType::Bool => 0,
        NumpyDType::Int8 => 1,
        NumpyDType::Int16 => 2,
        NumpyDType::Int32 => 3,
        NumpyDType::Int64 => 4,
        NumpyDType::Float32 => 5,
        NumpyDType::Float64 => 6,
        NumpyDType::Complex64 => 7,
        NumpyDType::Complex128 => 8,
    }
}

pub enum NumpyOperand {

    Scalar(NumpyDType),

    Array(NumpyDType, Vec<i32>),
}

spec fn operand_type(operand: NumpyOperand) -> NumpyDType {
    match operand {
        NumpyOperand::Scalar(dtype) => dtype,
        NumpyOperand::Array(dtype, _) => dtype,
    }
}

spec fn promote_types(t1: NumpyDType, t2: NumpyDType) -> NumpyDType {
    if type_rank(t1) >= type_rank(t2) { t1 } else { t2 }
}",,"fn result_type(operands: Vec<NumpyOperand>) -> (result: NumpyDType)
    requires operands.len() > 0,
    ensures

        forall|i: int| 0 <= i < operands.len() as int ==> 
            type_rank(result) >= type_rank(operand_type(operands@[i])),

        exists|i: int| 0 <= i < operands.len() as int && 
            type_rank(result) == type_rank(operand_type(operands@[i])),

        forall|i: int, j: int| 0 <= i < operands.len() as int && 0 <= j < operands.len() as int ==>
            type_rank(result) >= type_rank(promote_types(operand_type(operands@[i]), operand_type(operands@[j]))),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0135,verus,numpy_triple,data_type_routines_sctype2char,,"numpy.sctype2char: Return the string representation of a scalar dtype

Converts a scalar data type to its corresponding single-character string representation.
This is used internally by numpy to represent data types in a compact form.

The mapping follows numpy's dtype.char convention:
- int32 → 'l'
- float64 (double) → 'd'  
- complex128 → 'D'
- bytes → 'S'
- object → 'O'

Specification: sctype2char returns the correct character representation
for each scalar type.

Precondition: Valid scalar type (guaranteed by type system)
Postcondition: Returns the standard numpy character for the given type","use vstd::prelude::*;

verus! {

/* Scalar data type enumeration for numpy types */
pub enum ScalarType {
    /* 32-bit signed integer */
    Int32,
    /* 64-bit signed integer */
    Int64,
    /* 32-bit floating point */
    Float32,
    /* 64-bit floating point */
    Float64,
    /* 64-bit complex number */
    Complex64,
    /* 128-bit complex number */
    Complex128,
    /* Byte string */
    Bytes,
    /* Generic object */
    Object,
}",,"fn sctype2char(sctype: ScalarType) -> (result: &'static str)
    ensures
        (sctype == ScalarType::Int32) ==> (result == ""l""),
        (sctype == ScalarType::Int64) ==> (result == ""q""),
        (sctype == ScalarType::Float32) ==> (result == ""f""),
        (sctype == ScalarType::Float64) ==> (result == ""d""),
        (sctype == ScalarType::Complex64) ==> (result == ""F""),
        (sctype == ScalarType::Complex128) ==> (result == ""D""),
        (sctype == ScalarType::Bytes) ==> (result == ""S""),
        (sctype == ScalarType::Object) ==> (result == ""O"")","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0136,verus,numpy_triple,data_type_routines_shares_memory,,"Determine if two arrays share memory.

This function determines if two arrays share memory by checking
if they reference the same underlying memory locations.

Unlike may_share_memory, this function provides a definitive answer
about memory sharing rather than a conservative estimate.

The function can be exponentially slow for some inputs due to the
complexity of the overlap detection algorithm.

Specification: shares_memory returns a boolean indicating whether two arrays actually share memory.

Precondition: True (no special preconditions needed)
Postcondition: The function returns a boolean value that accurately reflects memory sharing.
If the arrays are identical references, it must return True.
If the arrays are independent (non-overlapping memory), it must return False.
The function is precise - it returns True if and only if the arrays share memory.

// Basic sanity check: result is a boolean - always true

// Reflexive property: an array shares memory with itself when identical

// Independence property: different arrays with different contents don't share memory

// Precision property: the function provides definitive answers about memory sharing

// Basic sanity check: result is a boolean

// Reflexive property: an array shares memory with itself when identical

// Precision property: the function provides definitive answers about memory sharing","use vstd::prelude::*;

verus! {",,"spec fn shares_memory(a: Vec<i8>, b: Vec<i8>) -> bool
{

    true &&

    (a.len() == b.len() && a@ == b@) &&

    true &&

    true
}

fn shares_memory_fn(a: Vec<i8>, b: Vec<i8>) -> (result: bool)
    ensures

        (result == true || result == false) &&

        (a.len() == b.len() && a@ == b@ ==> result == true) &&

        true","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0137,verus,numpy_triple,data_type_routines_typecodes,,"Dictionary mapping strings to corresponding type character codes

A dictionary with string keys that represent NumPy dtype categories and string values that contain type codes for the NumPy data types in each category.

Keys include:
- 'Character': 'S1'
- 'Integer': 'bhilqnp'
- 'UnsignedInteger': 'BHILQNP'
- 'Float': 'fdg'
- 'Complex': 'FDG'
- 'AllInteger': 'bBhHiIlLqQnNpP'
- 'AllFloat': 'fdgFDG'
- 'Datetime': 'Mm'
- 'All': '?bhilqnpBHILQNPfdgFDGSUVOMm'

This is useful for iterating over all dtypes of a certain kind.","use vstd::prelude::*;

verus! {",,"fn typecodes(category: &str) -> (result: Option<&str>)
    ensures
        (category@ == ""Character""@) ==> (result == Some(""S1"")),
        (category@ == ""Integer""@) ==> (result == Some(""bhilqnp"")),
        (category@ == ""UnsignedInteger""@) ==> (result == Some(""BHILQNP"")),
        (category@ == ""Float""@) ==> (result == Some(""fdg"")),
        (category@ == ""Complex""@) ==> (result == Some(""FDG"")),
        (category@ == ""AllInteger""@) ==> (result == Some(""bBhHiIlLqQnNpP"")),
        (category@ == ""AllFloat""@) ==> (result == Some(""fdgFDG"")),
        (category@ == ""Datetime""@) ==> (result == Some(""Mm"")),
        (category@ == ""All""@) ==> (result == Some(""?bhilqnpBHILQNPfdgFDGSUVOMm"")),
        (category@ != ""Character""@ && category@ != ""Integer""@ && category@ != ""UnsignedInteger""@ && 
         category@ != ""Float""@ && category@ != ""Complex""@ && category@ != ""AllInteger""@ && 
         category@ != ""AllFloat""@ && category@ != ""Datetime""@ && category@ != ""All""@) ==> (result == None::<&str>)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0138,verus,numpy_triple,data_type_routines_typename,,"Return a description for the given data type code

{
  ""name"": ""numpy.typename"",
  ""category"": ""Miscellaneous Type Utilities"", 
  ""description"": ""Return a description for the given data type code"",
  ""url"": ""https://numpy.org/doc/stable/reference/generated/numpy.typename.html"",
  ""doc"": ""Return a description for the given data type code.\n\nParameters\n----------\nchar : str\n    Data type code.\n\nReturns\n-------\nout : str\n    Description of the input data type code.\n\nExamples\n--------\n>>> typechars = ['S1', '?', 'B', 'D', 'G', 'F', 'I', 'H', 'L', 'O', 'Q',\n...              'S', 'U', 'V', 'b', 'd', 'g', 'f', 'i', 'h', 'l', 'q']\n>>> for typechar in typechars:\n...     print(typechar, ' : ', np.typename(typechar))\n...\nS1  :  character\n?  :  bool\nB  :  unsigned char\nD  :  complex double precision\nG  :  complex long double precision\nF  :  complex single precision\nI  :  unsigned integer\nH  :  unsigned short\nL  :  unsigned long integer\nO  :  object\nQ  :  unsigned long long integer\nS  :  character\nU  :  unicode\nV  :  void\nb  :  signed char\nd  :  double precision\ng  :  long precision\nf  :  single precision\ni  :  integer\nh  :  short\nl  :  long integer\nq  :  long long integer"",
}

Return a description for the given data type code

Specification: typename maps data type codes to their descriptions","use vstd::prelude::*;

verus! {",,"fn typename(char: &str) -> (result: String)
    ensures
        /* Known type code mappings from NumPy documentation */
        (char == ""S1"" ==> result@ == seq!['c','h','a','r','a','c','t','e','r']) &&
        (char == ""?"" ==> result@ == seq!['b','o','o','l']) &&
        (char == ""B"" ==> result@ == seq!['u','n','s','i','g','n','e','d',' ','c','h','a','r']) &&
        (char == ""D"" ==> result@ == seq!['c','o','m','p','l','e','x',' ','d','o','u','b','l','e',' ','p','r','e','c','i','s','i','o','n']) &&
        (char == ""G"" ==> result@ == seq!['c','o','m','p','l','e','x',' ','l','o','n','g',' ','d','o','u','b','l','e',' ','p','r','e','c','i','s','i','o','n']) &&
        (char == ""F"" ==> result@ == seq!['c','o','m','p','l','e','x',' ','s','i','n','g','l','e',' ','p','r','e','c','i','s','i','o','n']) &&
        (char == ""I"" ==> result@ == seq!['u','n','s','i','g','n','e','d',' ','i','n','t','e','g','e','r']) &&
        (char == ""H"" ==> result@ == seq!['u','n','s','i','g','n','e','d',' ','s','h','o','r','t']) &&
        (char == ""L"" ==> result@ == seq!['u','n','s','i','g','n','e','d',' ','l','o','n','g',' ','i','n','t','e','g','e','r']) &&
        (char == ""O"" ==> result@ == seq!['o','b','j','e','c','t']) &&
        (char == ""Q"" ==> result@ == seq!['u','n','s','i','g','n','e','d',' ','l','o','n','g',' ','l','o','n','g',' ','i','n','t','e','g','e','r']) &&
        (char == ""S"" ==> result@ == seq!['c','h','a','r','a','c','t','e','r']) &&
        (char == ""U"" ==> result@ == seq!['u','n','i','c','o','d','e']) &&
        (char == ""V"" ==> result@ == seq!['v','o','i','d']) &&
        (char == ""b"" ==> result@ == seq!['s','i','g','n','e','d',' ','c','h','a','r']) &&
        (char == ""d"" ==> result@ == seq!['d','o','u','b','l','e',' ','p','r','e','c','i','s','i','o','n']) &&
        (char == ""g"" ==> result@ == seq!['l','o','n','g',' ','p','r','e','c','i','s','i','o','n']) &&
        (char == ""f"" ==> result@ == seq!['s','i','n','g','l','e',' ','p','r','e','c','i','s','i','o','n']) &&
        (char == ""i"" ==> result@ == seq!['i','n','t','e','g','e','r']) &&
        (char == ""h"" ==> result@ == seq!['s','h','o','r','t']) &&
        (char == ""l"" ==> result@ == seq!['l','o','n','g',' ','i','n','t','e','g','e','r']) &&
        (char == ""q"" ==> result@ == seq!['l','o','n','g',' ','l','o','n','g',' ','i','n','t','e','g','e','r']) &&
        /* For unknown type codes, return default description */
        (char != ""S1"" && char != ""?"" && char != ""B"" && char != ""D"" && 
         char != ""G"" && char != ""F"" && char != ""I"" && char != ""H"" && 
         char != ""L"" && char != ""O"" && char != ""Q"" && char != ""S"" && 
         char != ""U"" && char != ""V"" && char != ""b"" && char != ""d"" && 
         char != ""g"" && char != ""f"" && char != ""i"" && char != ""h"" && 
         char != ""l"" && char != ""q"" ==>
         (result@ == seq!['u','n','k','n','o','w','n',' ','t','y','p','e'] || result@ == char@)),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0142,verus,numpy_triple,datetime_support_datetime64,,"Create a datetime64 object representing an offset from 1970-01-01T00:00:00

{
  ""name"": ""numpy.datetime64"",
  ""category"": ""Datetime types"", 
  ""description"": ""Create a datetime64 object representing an offset from 1970-01-01T00:00:00"",
  ""url"": ""https://numpy.org/doc/stable/reference/arrays.datetime.html#numpy.datetime64"",
  ""doc"": ""If created from a 64-bit integer, it represents an offset from ``1970-01-01T00:00:00``. If created from string, the string can be in ISO 8601 date or datetime format.\n\nWhen parsing a string to create a datetime object, if the string contains a trailing timezone (A 'Z' or a timezone offset), the timezone will be dropped and a User Warning is given.\n\nDatetime64 objects should be considered to be UTC and therefore have an offset of +0000.\n\n>>> np.datetime64(10, 'Y')\nnp.datetime64('1980')\n>>> np.datetime64('1980', 'Y')\nnp.datetime64('1980')\n>>> np.datetime64(10, 'D')\nnp.datetime64('1970-01-11')\n\nSee :ref:`arrays.datetime` for more information.\n\n:Character code: ``'M'``""
}

Create a datetime64 object from an integer offset and time unit

Specification: datetime64 creates a UTC datetime object with the specified offset and unit.
The datetime64 object represents a specific moment in time as an offset from the Unix epoch
(1970-01-01T00:00:00 UTC) in the specified time unit. The function preserves the input
parameters and ensures the result is always in UTC timezone.

/* Time unit for datetime64 */

/* Years unit ('Y') */

/* Days unit ('D') */

/* Hours unit ('h') */

/* Minutes unit ('m') */

/* Seconds unit ('s') */

/* Milliseconds unit ('ms') */

/* Microseconds unit ('us') */

/* Nanoseconds unit ('ns') */

/* DateTime64 structure representing offset from Unix epoch */

/* Offset value from 1970-01-01T00:00:00 */

/* Time unit of the offset */

/* Always UTC with +0000 offset */

/* Unit-specific validity constraints based on NumPy datetime64 limits */

/* Valid year range */

/* Days since epoch */

/* Hours since epoch */

/* Minutes since epoch */

/* Seconds since epoch */

/* Milliseconds can use full Int range */

/* Microseconds can use full Int range */

/* Nanoseconds can use full Int range */","use vstd::prelude::*;

verus! {

pub enum TimeUnit {

    Years,

    Days,

    Hours,

    Minutes,

    Seconds,

    Milliseconds,

    Microseconds,

    Nanoseconds,
}

pub struct DateTime64 {

    pub offset: i64,

    pub unit: TimeUnit,

    pub is_utc: bool,
}",,"fn datetime64(offset: i64, unit: TimeUnit) -> (result: DateTime64)
    ensures 
        result.offset == offset,
        result.unit == unit,
        result.is_utc == true,

        match unit {
            TimeUnit::Years => result.offset + 1970 >= 1 && result.offset + 1970 <= 9999,
            TimeUnit::Days => result.offset >= -2147483648 && result.offset <= 2147483647,
            TimeUnit::Hours => result.offset >= -2147483648 && result.offset <= 2147483647,
            TimeUnit::Minutes => result.offset >= -2147483648 && result.offset <= 2147483647,
            TimeUnit::Seconds => result.offset >= -2147483648 && result.offset <= 2147483647,
            TimeUnit::Milliseconds => true,
            TimeUnit::Microseconds => true,
            TimeUnit::Nanoseconds => true,
        }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0143,verus,numpy_triple,datetime_support_datetime_as_string,,"Convert an array of datetime64 values to an array of strings.

Converts each datetime64 value in the input vector to its string representation.
The format depends on the timezone option: 'naive' produces no suffix,
'UTC' adds 'Z' suffix, and 'local' would add timezone offset.

For simplicity, we focus on the core conversion from datetime64 to ISO format strings.

Specification: datetime_as_string converts each datetime64 to its string representation.

Precondition: True (no special preconditions)
Postcondition: Each datetime64 is converted to a properly formatted ISO 8601 string

/* Time unit for datetime64 */

/* Years unit ('Y') */

/* Days unit ('D') */

/* Hours unit ('h') */

/* Minutes unit ('m') */

/* Seconds unit ('s') */

/* Milliseconds unit ('ms') */

/* Microseconds unit ('us') */

/* Nanoseconds unit ('ns') */

/* DateTime64 structure representing offset from Unix epoch */

/* Offset value from 1970-01-01T00:00:00 */

/* Time unit of the offset */

/* Always UTC with +0000 offset */

/* Timezone formatting options */

/* No timezone suffix */

/* Add 'Z' suffix for UTC */

/* Add local timezone offset */","use vstd::prelude::*;

verus! {

#[derive(PartialEq, Eq)]
enum TimeUnit {

    Years,

    Days,

    Hours,

    Minutes,

    Seconds,

    Milliseconds,

    Microseconds,

    Nanoseconds,
}

#[derive(PartialEq, Eq)]
struct DateTime64 {

    offset: i64,

    unit: TimeUnit,

    is_utc: bool,
}

#[derive(PartialEq, Eq)]
enum TimezoneOption {

    Naive,

    UTC,

    Local,
}",,"fn datetime_as_string(arr: Vec<DateTime64>, timezone: TimezoneOption) -> (result: Vec<String>)
    requires arr@.len() > 0,
    ensures 
        result@.len() == arr@.len(),
        forall|i: int| 0 <= i < result@.len() ==> #[trigger] result@[i]@.len() > 0,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0144,verus,numpy_triple,datetime_support_datetime_data,,"Get information about the step size of a date or time type.

Returns a tuple containing the datetime unit and count for the given dtype.
This information can be used to construct datetime64 and timedelta64 objects.

For example, 'timedelta64[25s]' would return ('s', 25).

Specification: datetime_data extracts the unit and count from a datetime dtype.

Precondition: The dtype must be a valid datetime64 or timedelta64 type.
Postcondition: The returned tuple contains the unit and count that define the dtype.

For datetime64[N unit], returns (unit, N).
For timedelta64[N unit], returns (unit, N).

This ensures that the returned information can be used to reconstruct
the original dtype or create compatible datetime objects.","use vstd::prelude::*;

verus! {

/* Datetime unit enumeration representing the time scales used in datetime operations */
#[derive(PartialEq, Eq, Structural)]
pub enum DatetimeUnit {
    /* Years */
    Y,
    /* Months */
    M,
    /* Weeks */
    W,
    /* Days */
    D,
    /* Hours */
    H,
    /* Minutes */
    Min,
    /* Seconds */
    S,
    /* Milliseconds */
    Ms,
    /* Microseconds */
    Us,
    /* Nanoseconds */
    Ns,
}

/* Structure containing datetime type information including unit and count */
#[derive(PartialEq, Eq, Structural)]
pub struct DatetimeTypeInfo {
    /* The time unit (seconds, minutes, hours, etc.) */
    pub unit: DatetimeUnit,
    /* The count of base units in a step (e.g., 25 for ""25 seconds"") */
    pub count: nat,
}

/* Datetime dtype representing either datetime64 or timedelta64 types */
#[derive(PartialEq, Eq, Structural)]
pub enum DatetimeDtype {
    /* A datetime64 type with specified unit and count */
    Datetime64(DatetimeTypeInfo),
    /* A timedelta64 type with specified unit and count */
    Timedelta64(DatetimeTypeInfo),
}",,"fn datetime_data(dtype: DatetimeDtype) -> (result: (DatetimeUnit, u8))
    ensures
        match dtype {
            DatetimeDtype::Datetime64(info) => result == (info.unit, info.count as u8) && info.count > 0,
            DatetimeDtype::Timedelta64(info) => result == (info.unit, info.count as u8) && info.count > 0,
        }","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0146,verus,numpy_triple,datetime_support_timedelta64,,"A timedelta stored as a 64-bit integer.

See arrays.datetime for more information.

Character code: 'm'

Create a timedelta64 object from a numeric value and time unit

Specification: timedelta64 creates a time duration object with given value and unit

/* Time unit codes for timedelta64 */

/* Year unit ('Y') */

/* Month unit ('M') */

/* Week unit ('W') */

/* Day unit ('D') */

/* Hour unit ('h') */

/* Minute unit ('m') */

/* Second unit ('s') */

/* Millisecond unit ('ms') */

/* Microsecond unit ('us') */

/* Nanosecond unit ('ns') */

/* Picosecond unit ('ps') */

/* Femtosecond unit ('fs') */

/* Attosecond unit ('as') */

/* Represents a time duration value */

/* The numeric value of the time duration */

/* The time unit for the duration */","use vstd::prelude::*;

verus! {

#[derive(PartialEq, Eq, Structural)]
pub enum TimeUnit {

    Year,

    Month,

    Week,

    Day,

    Hour,

    Minute,

    Second,

    Millisecond,

    Microsecond,

    Nanosecond,

    Picosecond,

    Femtosecond,

    Attosecond,
}

#[derive(PartialEq, Eq, Structural)]
pub struct TimeDelta64 {

    pub value: i64,

    pub unit: TimeUnit,
}",,"fn timedelta64(value: i64, unit: TimeUnit) -> (result: TimeDelta64)
    ensures 
        result.value == value,
        result.unit == unit,
        result.value >= -9223372036854775808i64,
        result.value <= 9223372036854775807i64,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0147,verus,numpy_triple,fft_fft,,"Compute the one-dimensional discrete Fourier Transform

The FFT computes the DFT defined as:
X[k] = Σ(n=0 to N-1) x[n] * exp(-2πi*k*n/N)

where:
- x is the input vector
- X is the output vector
- N is the length of the vector
- i is the imaginary unit

Specification: FFT computes the discrete Fourier transform

The FFT satisfies the DFT equation and has the following properties:
1. Each output element is the sum of input elements weighted by complex exponentials
2. The transform is linear
3. Parseval's theorem: energy is preserved (with proper normalization)
4. FFT(FFT^(-1)(x)) = x (inverse property when combined with IFFT)

The specification captures the fundamental DFT formula where each output
element k is computed as the sum over all input elements j, multiplied
by the complex exponential exp(-2πi*k*j/n).

/* placeholder for cos(theta) */

/* placeholder for sin(theta) */

/* placeholder for complex multiplication real part */

/* placeholder for complex multiplication imaginary part */

/* placeholder for complex addition real part */

/* placeholder for complex addition imaginary part */","use vstd::prelude::*;

verus! {

pub struct Complex {
    pub re: f64,
    pub im: f64,
}

pub open spec fn cexp(theta: f64) -> Complex {
    Complex {
        re: 1.0,
        im: 0.0,
    }
}

pub open spec fn complex_mul(z: Complex, w: Complex) -> Complex {
    Complex {
        re: 0.0,
        im: 0.0,
    }
}

pub open spec fn complex_add(z: Complex, w: Complex) -> Complex {
    Complex {
        re: 0.0,
        im: 0.0,
    }
}

pub open spec fn complex_zero() -> Complex {
    Complex { re: 0.0, im: 0.0 }
}

pub open spec fn f64_to_complex(x: f64) -> Complex {
    Complex { re: x, im: 0.0 }
}

pub open spec fn complex_sum(n: nat, f: spec_fn(nat) -> Complex) -> Complex
    decreases n
{
    if n == 0 {
        complex_zero()
    } else {
        complex_add(f((n - 1) as nat), complex_sum((n - 1) as nat, f))
    }
}",,"pub fn fft(a: Vec<Complex>) -> (result: Vec<Complex>)
    requires a.len() > 0,
    ensures 
        result.len() == a.len(),
        forall|k: usize| k < result.len() ==> 
            result@[k as int] == complex_sum(a.len() as nat, |j: nat| 
                if j < a.len() {
                    complex_mul(a@[j as int], cexp(0.0))
                } else {
                    complex_zero()
                }
            ),
        result.len() > 0 ==> result@[0] == complex_sum(a.len() as nat, |j: nat|
            if j < a.len() { a@[j as int] } else { complex_zero() }
        ),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0149,verus,numpy_triple,fft_fftfreq,,"numpy.fft.fftfreq: Return the Discrete Fourier Transform sample frequencies.

The function returns the discrete Fourier Transform sample frequencies
with frequency bin centers in cycles per unit of sample spacing.

For even n: frequencies are [0, 1, ..., n/2-1, -n/2, ..., -1] / (d*n)
For odd n: frequencies are [0, 1, ..., (n-1)/2, -(n-1)/2, ..., -1] / (d*n)

The frequencies are arranged in standard DFT order: positive frequencies
first, then negative frequencies.

Specification: fftfreq returns sample frequencies according to the DFT convention.

The frequencies are arranged so that:
- The first half contains non-negative frequencies [0, 1, ..., N-1] / (d*n)
- The second half contains negative frequencies for the remaining indices

where N = (n + 1) / 2 is the number of non-negative frequencies.

Preconditions:
- n > 0 (non-empty frequency array)
- d ≠ 0 (valid sample spacing)

Postconditions:
- For indices i < N: result[i] = i / (d*n)
- For indices i ≥ N: result[i] = (i - n) / (d*n)
- The DC component (index 0) is always 0
- The frequencies are symmetric around the Nyquist frequency","use vstd::prelude::*;

verus! {",,"spec fn fft_freq_val(i: int, n: int, d: f64) -> f64;

fn fftfreq(n: usize, d: f64) -> (result: Vec<f64>)
    requires 
        n > 0,
        d != 0.0,
    ensures
        result.len() == n,
        forall|i: int| 0 <= i < ((n as int + 1) / 2) ==> 
            result[i as int] == fft_freq_val(i, n as int, d),
        forall|i: int| ((n as int + 1) / 2) <= i < n as int ==>
            result[i as int] == fft_freq_val(i, n as int, d),
        result[0] == 0.0,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,DupVT04,0.85
VT0151,verus,numpy_triple,fft_fftshift,,"Shift the zero-frequency component to the center of the spectrum.

This function rearranges the FFT output such that the zero-frequency 
component is moved from the beginning to the center of the array.
For even-length arrays, it performs a circular shift by n/2.
For odd-length arrays, it performs a circular shift by (n-1)/2.

Specification: fftshift performs a circular shift that moves the zero-frequency 
component to the center of the array.

The function rearranges elements by performing a circular shift:
- Each element at position i in the result comes from position (i + n - n/2) % n in the input
- This is equivalent to swapping the first and second halves of the array
- The zero-frequency component (originally at index 0) moves to the center

Key mathematical properties:
1. Bijective mapping: every element is preserved and appears exactly once
2. Circular shift property: implements a specific permutation
3. Involution property: for even n, fftshift(fftshift(x)) = x
4. Sum preservation: the sum of all elements remains unchanged","use vstd::prelude::*;

verus! {",,"fn fftshift(x: Vec<f32>) -> (result: Vec<f32>)
    ensures
        result.len() == x.len(),
        forall|i: int| 0 <= i < result.len() as int ==> 
            result[i as int] == x[((i + (x.len() as int) - (x.len() as int) / 2) % (x.len() as int)) as int]","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0152,verus,numpy_triple,fft_hfft,,"numpy.fft.hfft: Compute the FFT of a signal that has Hermitian symmetry.

The Hermitian FFT assumes that the input signal has Hermitian symmetry,
which means that the signal in the frequency domain is real-valued.
This is the inverse operation of rfft.

For a signal with Hermitian symmetry, the output will be real-valued
and the length of the transform is determined by the input length.
If input has length m, the output has length 2*(m-1).

The function essentially computes the inverse of rfft by taking
the conjugate of the input and then computing the inverse real FFT.

Specification: numpy.fft.hfft computes the FFT of a signal with Hermitian symmetry.

Precondition: The input vector represents a Hermitian symmetric signal
Postcondition: The output is a real-valued vector of length 2*m where
the input had length m+1, and the transformation preserves certain mathematical 
properties of the Hermitian FFT including:
1. The output is real-valued (no imaginary parts)
2. The length relationship: if input has m+1 elements, output has 2*m elements
3. Hermitian symmetry properties are preserved in the transform
4. The conjugate relationship: this is effectively the inverse of an rfft operation","use vstd::prelude::*;

verus! {

#[derive(PartialEq)]
pub struct Complex {
    pub real: f32,
    pub imag: f32,
}",,"fn hfft(a: Vec<Complex>, m: u8) -> (result: Vec<f32>)
    requires 
        m > 0,
        a.len() == m as nat + 1,
    ensures
        result.len() == 2 * m as nat,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0153,verus,numpy_triple,fft_ifft,,"Compute the one-dimensional inverse discrete Fourier Transform (IFFT).

The IFFT transforms frequency domain data back to the time domain,
computing the inverse of the DFT such that ifft(fft(x)) ≈ x.

For a vector of length n, the k-th coefficient is computed as:
X[k] = (1/n) * Σ(j=0 to n-1) a[j] * exp(2πi*j*k/n)

Specification: The inverse FFT correctly computes the inverse discrete Fourier transform.

The IFFT satisfies the inverse DFT equation where each output element k is 
computed as (1/n) times the sum over all input elements j, multiplied by the 
complex exponential exp(2πi*k*j/n).

This is the mathematical inverse of the FFT operation, with a positive sign 
in the exponential and a normalization factor of 1/n.

/* Simplified for spec purposes */","use vstd::prelude::*;

verus! {",,"#[derive(PartialEq, Eq, Structural)]
pub struct Complex {
    pub re: int,
    pub im: int,
}

impl Complex {
    pub open spec fn add(self, other: Complex) -> Complex {
        Complex { re: self.re + other.re, im: self.im + other.im }
    }

    pub open spec fn mul(self, other: Complex) -> Complex {
        Complex { 
            re: self.re * other.re - self.im * other.im, 
            im: self.re * other.im + self.im * other.re 
        }
    }

    pub open spec fn scalar_mul(self, s: int) -> Complex {
        Complex { re: s * self.re, im: s * self.im }
    }
}

pub open spec fn cexp(theta: int) -> Complex {
    Complex { re: 1, im: 0 }
}

pub open spec fn complex_sum(n: nat, f: spec_fn(nat) -> Complex) -> Complex
    decreases n
{
    if n == 0 {
        Complex { re: 0, im: 0 }
    } else {
        f((n - 1) as nat).add(complex_sum((n - 1) as nat, f))
    }
}

fn ifft(a: Vec<Complex>) -> (result: Vec<Complex>)
    requires a.len() > 0,
    ensures
        result.len() == a.len(),
        forall|k: int| #[trigger] result[k] == result[k] && 0 <= k < result.len() ==> {
            let n = a.len() as nat;
            let expected = complex_sum(n, |j: nat| {
                if j < n {
                    a[j as int].mul(cexp(2 * k * (j as int)))
                } else {
                    Complex { re: 0, im: 0 }
                }
            }).scalar_mul(1);
            result[k] == expected
        }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0155,verus,numpy_triple,fft_ifftn,,"Compute the N-dimensional inverse discrete Fourier Transform (IFFTN).

The IFFTN extends the 1D inverse FFT to multiple dimensions, computing
the inverse of the N-dimensional DFT. For a 2D array, this applies the
inverse transform along both dimensions.

For a 2D array of size m×n, the (i,j)-th output element is computed as:
X[i,j] = (1/(m*n)) * Σ(k=0 to m-1) Σ(l=0 to n-1) a[k,l] * exp(2πi*(i*k/m + j*l/n))

This is the mathematical inverse of the N-dimensional FFT.","use vstd::prelude::*;

verus! {

/* Sum of integers over finite indices */
pub open spec fn int_sum(n: nat, f: spec_fn(int) -> int) -> int
    decreases n
{
    if n == 0 {
        0
    } else {
        f((n - 1) as int) + int_sum((n - 1) as nat, f)
    }
}",,"fn ifftn(a: Vec<Vec<i8>>) -> (result: Vec<Vec<i8>>)
    requires 
        a.len() > 0,
        a.len() < usize::MAX,
        forall|i: int| 0 <= i < a@.len() ==> a@[i].len() > 0,
        forall|i: int| 0 <= i < a@.len() ==> a@[i].len() < usize::MAX,
        forall|i: int, j: int| 0 <= i < a@.len() && 0 <= j < a@.len() ==> a@[i].len() == a@[j].len(),
    ensures 
        result@.len() == a@.len(),
        forall|i: int| 0 <= i < result@.len() ==> result@[i].len() == a@[0].len(),
        forall|i: int, j: int| #[trigger] result@[i][j] == 0 || 
            (0 <= i < result@.len() && 0 <= j < result@[i].len()),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0156,verus,numpy_triple,fft_ifftshift,,"The inverse of fftshift - undoes the frequency domain shifting.

This function performs the inverse operation of fftshift, moving the 
zero-frequency component from the center back to the beginning of the array.
For even-length arrays, it is identical to fftshift.
For odd-length arrays, it differs by one sample position.

The function performs a circular shift by -(n/2) positions.

Specification: ifftshift performs the inverse of fftshift.

The function performs a circular shift that undoes the centering of 
the zero-frequency component:
- For even n: shifts by -(n/2), identical to fftshift
- For odd n: shifts by -(n/2), which differs from fftshift by one sample

This ensures that:
- Elements from the center move back to the beginning
- The DC component at the center returns to index 0
- The function is the left inverse of fftshift

Mathematical properties:
- For even-length arrays: ifftshift(fftshift(x)) = x and fftshift(ifftshift(x)) = x
- For odd-length arrays: ifftshift(fftshift(x)) = x but fftshift(ifftshift(x)) ≠ x
- Preserves the total energy/sum of the array
- Is a bijection (permutation) of array elements

The specification states that each element at position i in the result
comes from position (i + n/2) % n in the input, which is equivalent
to a circular left shift by n/2 positions (or right shift by n - n/2).","use vstd::prelude::*;

verus! {",,"fn ifftshift(x: Vec<f32>) -> (result: Vec<f32>)
    requires x.len() > 0,
    ensures 
        result.len() == x.len(),
        forall|i: int| 0 <= i < x@.len() ==> 
            result[i] == x[((i + (x@.len() as int) / 2) % (x@.len() as int)) as int]","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0157,verus,numpy_triple,fft_ihfft,,"numpy.fft.ihfft: Compute the inverse FFT of a signal that has Hermitian symmetry.

This function computes the inverse FFT of a signal that has Hermitian symmetry,
which means the signal is real in the frequency domain. The input should be
a complex signal with Hermitian symmetry, and the output is a real signal.

The function is analogous to rfft/irfft but for signals with Hermitian symmetry.
According to the NumPy documentation and source code, it essentially computes 
the conjugate of the rfft of the input: conjugate(rfft(a, n, axis, new_norm, out))

Unlike hfft which takes a Hermitian symmetric input and produces a real output,
ihfft takes a general complex input and produces a complex output with the 
inverse Hermitian FFT properties.

Specification: ihfft computes the inverse FFT of a signal with Hermitian symmetry.

According to NumPy documentation:
- ihfft is analogous to rfft/irfft but for signals with Hermitian symmetry
- The implementation is conjugate(rfft(a, n, axis, new_norm, out))

Key mathematical properties:
1. Length preservation: output has same length as input
2. Conjugate relationship: ihfft is related to rfft by conjugation
3. Linearity: ihfft preserves linear combinations
4. Hermitian symmetry handling: if input has Hermitian symmetry, special properties hold","use vstd::prelude::*;

verus! {

/* Complex number type for FFT operations */
#[derive(PartialEq, Eq)]
struct Complex {
    /* Real part */
    re: int,
    /* Imaginary part */
    im: int,
}

impl Complex {
    /* Complex conjugate */
    spec fn conj(self) -> Complex {
        Complex { re: self.re, im: -self.im }
    }

    /* Complex addition */
    spec fn add(self, other: Complex) -> Complex {
        Complex { re: self.re + other.re, im: self.im + other.im }
    }

    /* Complex multiplication */
    spec fn mul(self, other: Complex) -> Complex {
        Complex { 
            re: self.re * other.re - self.im * other.im, 
            im: self.re * other.im + self.im * other.re 
        }
    }

    /* Check if complex number is real (imaginary part is zero) */
    spec fn is_real(self) -> bool {
        self.im == 0
    }
}

/* Convert int to Complex */
spec fn int_to_complex(x: int) -> Complex {
    Complex { re: x, im: 0 }
}

/* Complex scaling */
spec fn scale_complex(z: Complex, alpha: int) -> Complex {
    Complex { re: alpha * z.re, im: alpha * z.im }
}",,"fn ihfft(a: Vec<Complex>) -> (result: Vec<Complex>)
    ensures
        /* Length preservation: output has same length as input */
        result.len() == a.len(),
        /* Hermitian symmetry property: if input has Hermitian symmetry,
           then ihfft should produce a real-valued result */
        (forall|i: int, j: int| 
            (0 <= i < a@.len() && 0 <= j < a@.len() && i + j + 1 == a@.len()) ==> 
                a@[i] == a@[j].conj()) ==>
        (forall|i: int| (0 <= i < result@.len()) ==> result@[i].is_real())","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0158,verus,numpy_triple,fft_irfft,,"Computes the inverse of rfft (real-valued inverse FFT).
Specification: irfft computes the inverse of rfft with proper length restoration.

numpy.fft.irfft computes the inverse of the one-dimensional discrete Fourier Transform for real input, 
such that irfft(rfft(a), len(a)) == a within numerical accuracy.

Parameters:
- a: Input array (Hermitian-symmetric complex numbers)
- n: Length of transformed axis (default calculates based on input)
- axis: Axis to compute inverse FFT (default is last axis)
- norm: Normalization mode (""backward"", ""ortho"", ""forward"")
- out: Optional output array

Returns:
- Real-valued array transformed along specified axis

Notes:
- Handles Hermitian-symmetric input from rfft
- Requires specifying original data length to avoid information loss
- Can resample a series via Fourier interpolation","use vstd::prelude::*;

verus! {

/* Complex number type for FFT operations */
pub struct Complex {
    /* Real part of the complex number */
    pub re: f64,
    /* Imaginary part of the complex number */
    pub im: f64,
}
/* Helper function to check if a vector is Hermitian-symmetric */
spec fn is_hermitian_symmetric(a: Seq<Complex>) -> bool {
    a.len() > 0 
}",,"fn irfft(a: Vec<Complex>, n: usize) -> (result: Vec<f64>)
    requires 
        a.len() > 0,
        n == 2 * (a.len() - 1),
        is_hermitian_symmetric(a@),
    ensures
        /* Length preservation: output length matches specified n */
        result.len() == n,
        /* DC component preservation: first element is real when input DC is real */
        a@[0].im == 0.0 ==> exists|i: int| 0 <= i < result.len() && result[i] == a@[0].re,
        /* Hermitian input constraint: the input must be Hermitian-symmetric */
        is_hermitian_symmetric(a@),
        /* Length relationship: output length is twice the input length minus 2 */
        n == 2 * (a.len() - 1),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0159,verus,numpy_triple,fft_irfft2,,"numpy.fft.irfft2: Computes the inverse of rfft2.

Performs the inverse 2-dimensional discrete Fourier Transform for real input.
This function converts a complex frequency domain representation back to the
real spatial domain. It is the inverse of rfft2.

The function takes a complex-valued 2D array (represented as nested vectors)
and returns a real-valued 2D array. The output shape is determined by the
input shape and the original real signal dimensions.

This is essentially irfftn with axes=(-2, -1) as defaults.

Specification: numpy.fft.irfft2 returns the inverse 2D real FFT.

Precondition: True (input is a well-formed 2D array)
Postcondition: The result is a real-valued 2D array with the same dimensions.

Key properties:
1. The output preserves the matrix structure and dimensions
2. The transformation processes all elements of the input
3. The inverse operation produces finite real values
4. Shape preservation ensures correct 2D FFT behavior","use vstd::prelude::*;

verus! {",,"fn numpy_irfft2(a: Vec<Vec<f32>>) -> (result: Vec<Vec<f32>>)
    requires
        a@.len() > 0,
        forall|i: int| 0 <= i < a@.len() ==> a@[i].len() > 0,
        forall|i: int, j: int| 0 <= i < a@.len() && 0 <= j < a@.len() ==> a@[i].len() == a@[j].len(),
    ensures
        /* Preserve matrix dimensions */
        result@.len() == a@.len(),
        forall|i: int| 0 <= i < result@.len() ==> result@[i].len() == a@[0].len(),
        /* Non-trivial transformation: if input is non-zero, result depends on input */
        (exists|i: int, j: int| 0 <= i < a@.len() && 0 <= j < a@[i].len() && a@[i][j] != 0.0f32) ==>
        (exists|k: int, l: int| 0 <= k < result@.len() && 0 <= l < result@[k].len() && result@[k][l] != 0.0f32),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0160,verus,numpy_triple,fft_irfftn,,"Computes the inverse of rfftn. This function performs the inverse N-dimensional discrete Fourier Transform for real input using the Fast Fourier Transform (FFT).

For simplicity, we model this as a 1D version of irfftn, taking complex frequency domain input and producing real time-domain output. The function computes the inverse of rfftn, transforming N-dimensional frequency domain data back to real-valued time domain.

This is the inverse operation to rfftn, where the input is expected to be Hermitian-symmetric complex data representing the frequency domain, and the output is real-valued time domain data.

Specification: irfftn computes the inverse N-dimensional discrete Fourier Transform for real output.

The irfftn function is the inverse of rfftn, satisfying the property that irfftn(rfftn(x), x.shape) ≈ x within numerical accuracy.

Mathematical properties:
1. Inverse relationship: irfftn(rfftn(x)) ≈ x for real input x
2. The input should be Hermitian-symmetric to produce real output
3. Output length is determined by the shape parameter or derived from input
4. Energy conservation (Parseval's theorem) holds with proper normalization
5. The transform preserves the mathematical structure of the inverse DFT

The function implements the inverse N-dimensional DFT formula:
x[j] = (1/N) * Σ(k) a[k] * exp(2πi*k*j/N)

Sanity checks:
- For DC-only input (single non-zero frequency), output is constant
- Transform is linear: irfftn(α*a + β*b) = α*irfftn(a) + β*irfftn(b)
- Output is real-valued when input satisfies Hermitian symmetry
- Proper length relationship between input and output dimensions","use vstd::prelude::*;

verus! {

/* Complex number type for FFT operations */
pub struct Complex {
    /* Real part */
    pub re: f32,
    /* Imaginary part */
    pub im: f32,
}

impl Complex {
    pub closed spec fn new(re: f32, im: f32) -> Complex {
        Complex { re, im }
    }
}",,"fn irfftn(a: Vec<Complex>, n: u8) -> (result: Vec<f32>)
    requires 
        a.len() > 0,
        n > 0,
        a[0].im == 0.0f32,
    ensures
        result.len() == n as nat,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0161,verus,numpy_triple,fft_rfft,,"Compute the one-dimensional discrete Fourier Transform for real input.
Returns only the non-negative frequency terms, exploiting Hermitian symmetry.
The output length is (n/2)+1 for even n, or (n+1)/2 for odd n.

Specification for rfft: 
The real FFT computes the DFT of real-valued input, returning only non-negative frequency components.

Mathematical properties:
1. Output contains (n/2)+1 complex values representing frequencies 0 to n/2
2. DC component (k=0) is always real (imaginary part is 0)
3. For even n, Nyquist frequency (k=n/2) is also real
4. The result represents the Discrete Fourier Transform for k = 0, 1, ..., n/2
5. Each output[k] = Σ(j=0 to n-1) input[j] * exp(-2πi*k*j/n)

Sanity checks:
- For constant input signals, only the DC component is non-zero
- The transform is linear: rfft(a + b) = rfft(a) + rfft(b)
- Energy is preserved according to Parseval's theorem","use vstd::prelude::*;

verus! {

/* Complex number type for FFT results */
#[derive(PartialEq, Eq)]
pub struct Complex {
    pub re: int,
    pub im: int,
}

impl Complex {
    pub open spec fn zero() -> Complex {
        Complex { re: 0, im: 0 }
    }

    pub open spec fn add(self, other: Complex) -> Complex {
        Complex { re: self.re + other.re, im: self.im + other.im }
    }

    pub open spec fn mul(self, other: Complex) -> Complex {
        Complex { 
            re: self.re * other.re - self.im * other.im,
            im: self.re * other.im + self.im * other.re
        }
    }

    pub open spec fn from_real(x: int) -> Complex {
        Complex { re: x, im: 0 }
    }
}

pub open spec fn complex_sum(values: Seq<Complex>) -> Complex 
    decreases values.len()
{
    if values.len() == 0 {
        Complex::zero()
    } else {
        values[0].add(complex_sum(values.skip(1)))
    }
}

pub open spec fn dft_coefficient(a: Seq<int>, k: nat, j: nat) -> Complex {
    Complex::from_real(a[j as int])
}

pub open spec fn compute_dft_sum(a: Seq<int>, k: nat, n: nat) -> Complex 
    decreases n
{
    if n == 0 {
        Complex::zero()
    } else {
        dft_coefficient(a, k, (n - 1) as nat).add(compute_dft_sum(a, k, (n - 1) as nat))
    }
}

spec fn vec_to_int_seq(v: Seq<i32>) -> Seq<int> 
    decreases v.len()
{
    if v.len() == 0 {
        seq![]
    } else {
        seq![v[0] as int] + vec_to_int_seq(v.skip(1))
    }
}",,"fn rfft(a: Vec<i32>) -> (result: Vec<Complex>)
    requires a.len() > 0,
    ensures 
        result.len() == (a.len() / 2) + 1,
        forall|k: int| 0 <= k < result.len() ==> 
            result[k] == compute_dft_sum(vec_to_int_seq(a@), k as nat, a.len() as nat),
        result[0].im == 0,
        a.len() % 2 == 0 ==> result[(a.len() / 2) as int].im == 0","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0162,verus,numpy_triple,fft_rfft2,,"Compute the 2-dimensional FFT of a real array.

This function transforms a real 2D array into the frequency domain using
a 2D Fast Fourier Transform. The transformation is performed over the
last two axes by default.

The key difference from fft2 is that this function starts with real input
and exploits the Hermitian symmetry property to compute only the 
non-negative frequency components along the last axis, making it more
efficient for real-valued input data.

Output dimensions: For input of shape (m+1, n+1), output has shape (m+1, (n+1)/2+1)
where the last dimension is reduced due to Hermitian symmetry.","use vstd::prelude::*;

verus! {

/* Complex number type for FFT results */
#[derive(PartialEq, Eq)]
pub struct Complex {
    /* Real part */
    pub re: int,
    /* Imaginary part */
    pub im: int,
}

impl Complex {
    pub open spec fn zero() -> Complex {
        Complex { re: 0, im: 0 }
    }
    
    pub open spec fn add(self, other: Complex) -> Complex {
        Complex { re: self.re + other.re, im: self.im + other.im }
    }
    
    pub open spec fn mul(self, other: Complex) -> Complex {
        Complex { 
            re: self.re * other.re - self.im * other.im, 
            im: self.re * other.im + self.im * other.re 
        }
    }
}

/* Convert int to Complex */
spec fn int_to_complex(x: int) -> Complex {
    Complex { re: x, im: 0 }
}",,"fn rfft2(a: Vec<Vec<i8>>) -> (result: Vec<Vec<Complex>>)
    requires 
        a.len() > 0,
        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i]@.len() > 0,
        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i]@.len() == a[0]@.len(),
    ensures
        result.len() == a.len(),
        forall|k: int| 0 <= k < result.len() ==> 
            #[trigger] result[k]@.len() == (a[0]@.len() / 2) + 1,
        /* DC component is real (imaginary part is zero) */
        result[0]@[0].im == 0,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0163,verus,numpy_triple,fft_rfftfreq,,"numpy.fft.rfftfreq: Return the Discrete Fourier Transform sample frequencies for rfft.

The function generates frequency bin centers in cycles per unit of sample spacing,
with zero at the start. This is specifically designed for use with rfft and irfft.

Parameters:
- n: Window length (input size)
- d: Sample spacing (defaults to 1.0)

Returns:
- f: Array of length n//2 + 1 containing sample frequencies

The frequency calculation follows:
- For any n: f = [0, 1, ..., n//2] / (d*n)
- The result length is always n//2 + 1 (for both even and odd n)

Specification: numpy.fft.rfftfreq generates frequency sample points for rfft.

The function returns a vector of frequencies from 0 to the Nyquist frequency.

Precondition: n > 0 and d > 0 (positive sample spacing)
Postcondition: 
1. The result has length n//2 + 1
2. The first element is always 0
3. Each element i represents frequency i / (d * n)
4. The last element is (n//2) / (d * n) (Nyquist frequency)","use vstd::prelude::*;

verus! {",,"fn numpy_rfftfreq(n: usize, d: i8) -> (result: Vec<i8>)
    requires 
        n > 0,
        d > 0,
    ensures
        result.len() == n / 2 + 1,
        result@[0] == 0,
        forall|i: int| 0 <= i < result.len() ==> result@[i] == i / ((d as int) * (n as int)),
        result@[(n / 2) as int] == (n / 2) as int / ((d as int) * (n as int)),
        forall|i: int, j: int| 0 <= i <= j < result.len() ==> result@[i] <= result@[j],","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,DupVT04,0.85
VT0165,verus,numpy_triple,indexing_slicing_argmax,,"Returns the index of the maximum value in a non-empty vector (first occurrence)

Specification: argmax returns the index of the first maximum element
This comprehensive specification captures:
1. The returned index points to a maximum element
2. All elements to the left of the returned index are strictly less than the maximum
3. All elements to the right of the returned index are less than or equal to the maximum
4. The function returns the first occurrence of the maximum value
5. The returned index is valid (type-safe with Fin)
6. The result is deterministic for the same input","use vstd::prelude::*;

verus! {",,"fn argmax(arr: &Vec<i8>) -> (result: usize)
    requires arr.len() > 0,
    ensures 
        result < arr.len(),
        forall|i: int| 0 <= i && i < arr.len() ==> arr@[i] <= arr@[result as int],
        forall|i: int| 0 <= i && i < result as int ==> arr@[i] < arr@[result as int],
        forall|i: int| (result as int) < i && i < arr.len() ==> arr@[i] <= arr@[result as int],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0166,verus,numpy_triple,indexing_slicing_argmin,,"numpy.argmin: Returns the index of the minimum value in a vector.

Returns the index of the minimum value among all elements in the array.
Requires a non-empty array since there is no minimum of an empty set.

This function returns the position of the smallest element in the array.
In case of multiple occurrences of the minimum value, the index of the
first occurrence is returned.

Specification: argmin returns the index of the minimum element.

Precondition: True (non-empty constraint is in the type)
Postcondition: The element at the returned index is the minimum value,
and it is the first occurrence of this minimum value in the array.","use vstd::prelude::*;

verus! {",,"fn argmin(a: Vec<i8>) -> (result: usize)
    requires a.len() > 0,
    ensures
        result < a.len(),
        forall|j: int| 0 <= j < a.len() ==> a[result as int] <= a[j],
        forall|k: int| 0 <= k < result ==> a[k] > a[result as int],","{
    // impl-start
    assume(false);
    0
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0167,verus,numpy_triple,indexing_slicing_argwhere,,"Find the indices of array elements that are non-zero, grouped by element.

For a 1D vector, returns a list of indices where elements are non-zero.
Each index corresponds to a position in the original vector where the element is non-zero.
The returned indices are in the same order as they appear in the original vector.

This function is equivalent to finding all positions i such that a[i] ≠ 0.
The result is a list of indices, not suitable for direct array indexing but useful
for analysis and conditional processing.","use vstd::prelude::*;

verus! {",,"fn argwhere(a: &Vec<f64>) -> (indices: Vec<usize>)
    ensures
        forall|i: int| 0 <= i < indices@.len() ==> (#[trigger] indices@[i] as int) < a@.len(),
        forall|i: int| 0 <= i < indices@.len() ==> a@[indices@[i] as int] != 0.0,
        forall|i: int| 0 <= i < a@.len() && a@[i] != 0.0 ==> exists|j: int| 0 <= j < indices@.len() && indices@[j] as int == i,
        forall|i: int, j: int| 0 <= i < indices@.len() && 0 <= j < indices@.len() && i != j ==> indices@[i] != indices@[j],
        forall|i: int, j: int| 0 <= i < indices@.len() && 0 <= j < indices@.len() && (indices@[i] as int) < (indices@[j] as int) ==> i < j,
        (indices@.len() == 0) == (forall|i: int| 0 <= i < a@.len() ==> a@[i] == 0.0),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0168,verus,numpy_triple,indexing_slicing_c_,,"numpy.c_: Translates slice objects to concatenation along the second axis.

This function takes two vectors and stacks them as columns to create a 2-D array.
Each input vector becomes a column in the resulting matrix.

This is equivalent to column_stack([arr1, arr2]) for 1-D arrays.","use vstd::prelude::*;

verus! {",,"fn c_(arr1: Vec<i8>, arr2: Vec<i8>) -> (result: Vec<Vec<i8>>)
    requires arr1.len() == arr2.len(),
    ensures 
        result.len() == arr1.len(),
        forall|i: int| 0 <= i < result.len() ==> 
            result[i]@.len() == 2 &&
            result[i][0] == arr1[i] &&
            result[i][1] == arr2[i]","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0169,verus,numpy_triple,indexing_slicing_choose,,"Construct an array from an index array and a set of arrays to choose from.
Given an index vector 'indices' and a vector of choice vectors 'choices',
constructs a result vector where each element is selected from the corresponding
choice vector based on the index value at that position.

For each position i in the result, result[i] = choices[indices[i]][i]

This is a simplified version focusing on the core functionality with 'raise' mode,
where all indices must be valid (in range [0, num_choices-1]).","use vstd::prelude::*;

verus! {",,"fn choose(indices: Vec<u8>, choices: Vec<Vec<f64>>) -> (result: Vec<f64>)
    requires 
        indices.len() > 0,
        choices.len() > 0,
        forall|i: int| 0 <= i < indices@.len() ==> (indices[i] as int) < (choices@.len() as int),
        forall|j: int| 0 <= j < choices@.len() ==> choices[j]@.len() == indices@.len(),
    ensures 
        result@.len() == indices@.len(),
        forall|i: int| 0 <= i < indices@.len() ==> result[i] == choices[indices[i] as int][i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0170,verus,numpy_triple,indexing_slicing_compress,,"Compresses a vector by selecting only elements where the corresponding 
condition is true. Returns a new vector containing only the selected elements.
The result size is the number of true values in the condition vector.

Specification: compress returns a new vector containing only the elements 
from the input vector where the corresponding condition element is true.

Mathematical properties:
1. The result size equals the number of true values in the condition
2. The result preserves the order of elements from the original vector
3. Each element in the result corresponds to a true condition at the same index
4. The result is empty if and only if all condition elements are false

This function implements array compression/masking, a fundamental operation
in array programming that allows selective extraction of elements based on
a boolean mask. It's equivalent to boolean indexing in NumPy.","use vstd::prelude::*;

verus! {",,"spec fn count_true(condition: Seq<bool>) -> int
    decreases condition.len()
{
    if condition.len() == 0 {
        0
    } else {
        (if condition[0] { 1int } else { 0int }) + count_true(condition.skip(1))
    }
}

fn compress(condition: Vec<bool>, a: Vec<f32>) -> (result: Vec<f32>)
    requires condition.len() == a.len(),
    ensures
        result.len() == count_true(condition@),
        exists|mapping: Seq<int>|
            mapping.len() == result.len() &&
            (forall|i: int| 0 <= i < mapping.len() ==> 
                0 <= mapping[i] < condition.len() &&
                condition@[mapping[i]] == true) &&
            (forall|i: int| 0 <= i < result.len() ==> 
                result@[i] == a@[mapping[i]]) &&
            (forall|i: int, j: int| 0 <= i < j < mapping.len() ==> 
                mapping[i] < mapping[j]),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0171,verus,numpy_triple,indexing_slicing_diag,,"Extract a diagonal or construct a diagonal array.

numpy.diag: Extract a diagonal or construct a diagonal array.

For simplicity, this specification focuses on extracting the diagonal
from a square matrix represented as a flattened vector.
Given a flattened n×n matrix, returns the diagonal elements.

This specification captures the essential mathematical property of
diagonal extraction in a type-safe manner using Vector types.

Specification: diag extracts diagonal elements from a flattened matrix.

Mathematical Properties:
1. Diagonal Extraction: For a flattened n×n matrix stored in row-major order,
   the diagonal elements are located at positions i*n + i for i ∈ [0, n).

2. Type Safety: The function maintains type safety by using Vector types
   that encode the size information at the type level.

3. Correctness: Each element in the result vector corresponds to a diagonal
   element from the original matrix, preserving the mathematical structure.

This specification provides a foundation for formal verification of diagonal
operations in numerical computing.","use vstd::prelude::*;

verus! {",,"fn diag(matrix: Vec<f32>, n: usize) -> (result: Vec<f32>)
    requires 
        matrix.len() == n * n,
        n > 0,
    ensures
        result.len() == n,
        forall|i: int| 0 <= i < n as int ==> result@[i] == matrix@[i * n as int + i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0172,verus,numpy_triple,indexing_slicing_diagflat,,"numpy.diagflat: Create a two-dimensional array with the flattened input as a diagonal.

Creates a square matrix where the input vector is placed along the main diagonal.
All other elements are zero. The resulting matrix has size n×n where n is the
length of the input vector.

For the main diagonal (k=0), the matrix element at position (i,i) contains
the i-th element of the input vector.

Specification: diagflat returns a square matrix where the input vector forms the main diagonal.

Properties:
1. The result is a square n×n matrix
2. For all i, j: if i = j then result[i][j] = v[i] (diagonal elements)
3. For all i, j: if i ≠ j then result[i][j] = 0 (off-diagonal elements are zero)","use vstd::prelude::*;

verus! {",,"fn diagflat(v: Vec<f32>) -> (result: Vec<Vec<f32>>)
    requires v@.len() > 0,
    ensures
        result@.len() == v@.len(),
        forall|i: int| 0 <= i < result@.len() ==> result@[i].len() == v@.len(),
        forall|i: int, j: int| 0 <= i < v@.len() && 0 <= j < v@.len() && i == j ==> result@[i][j] == v@[i],
        forall|i: int, j: int| 0 <= i < v@.len() && 0 <= j < v@.len() && i != j ==> result@[i][j] == 0.0f32,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0173,verus,numpy_triple,indexing_slicing_diagonal,,"Extract diagonal elements from a 2D matrix with optional offset.

Takes a 2D matrix and returns a 1D vector containing the diagonal elements.
For offset=0, returns main diagonal elements [a[0,0], a[1,1], ...].
For offset>0, returns elements above main diagonal [a[0,offset], a[1,offset+1], ...].
For offset<0, returns elements below main diagonal [a[-offset,0], a[-offset+1,1], ...].","use vstd::prelude::*;

verus! {",,"fn diagonal(a: Vec<Vec<f64>>, offset: i32) -> (result: Vec<f64>)
    requires 
        a@.len() > 0,
        a@.len() > 0 ==> a@[0].len() > 0,
        forall|i: int| 0 <= i < a@.len() ==> #[trigger] a@[i].len() == a@[0].len(),
        if offset >= 0 { 
            offset as int <= a@[0].len() as int
        } else { 
            (-offset) as int <= a@.len() as int
        },
    ensures
        result@.len() == (if offset >= 0 { 
            if a@.len() as int <= (a@[0].len() as int - offset as int) { a@.len() as int } else { a@[0].len() as int - offset as int }
        } else { 
            if (a@.len() as int + (-offset) as int) <= a@[0].len() as int { a@.len() as int + (-offset) as int } else { a@[0].len() as int }
        }) as usize,
        forall|i: int| 0 <= i < result@.len() ==> {
            if offset >= 0 {
                #[trigger] result@[i] == a@[i][i + offset as int]
            } else {
                #[trigger] result@[i] == a@[i + (-offset) as int][i]
            }
        },","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0174,verus,numpy_triple,indexing_slicing_extract,,"numpy.extract: Return the elements of an array that satisfy some condition.

Extracts elements from an array where the corresponding condition is True.
Both arrays must have the same size, and the result contains only the elements
from `arr` where `condition` is True, in the same order they appear in `arr`.

The result size `k` must equal the number of True elements in the condition array.

Specification: numpy.extract returns elements where condition is True.

Precondition: k equals the count of True elements in condition
Postcondition: The result contains exactly the elements from arr where condition is True,
              in the same order they appear in arr.","use vstd::prelude::*;

verus! {",,"spec fn count_true(condition: Seq<bool>) -> int 
    decreases condition.len()
{
    if condition.len() == 0 {
        0int
    } else {
        (if condition[0] { 1int } else { 0int }) + count_true(condition.skip(1))
    }
}

fn extract(condition: Vec<bool>, arr: Vec<f32>) -> (result: Vec<f32>)
    requires 
        condition.len() == arr.len(),
        count_true(condition@) >= 0,
    ensures
        result.len() == count_true(condition@),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0175,verus,numpy_triple,indexing_slicing_fill_diagonal,,"Fill the main diagonal of a 2D matrix with a specified value

/* Diagonal elements are filled with val */

/* Non-diagonal elements remain unchanged */","use vstd::prelude::*;

verus! {",,"fn fill_diagonal<T: Copy>(mat: Vec<Vec<T>>, val: T) -> (result: Vec<Vec<T>>)
    requires 
        mat@.len() > 0,
        forall|i: int| 0 <= i < mat@.len() ==> #[trigger] mat@[i].len() == mat@[0].len(),
    ensures
        result@.len() == mat@.len(),
        forall|i: int| 0 <= i < result@.len() ==> #[trigger] result@[i].len() == mat@[i].len(),

        forall|i: int, j: int| 
            0 <= i < result@.len() && 0 <= j < result@[i].len() && i == j 
            ==> #[trigger] result@[i][j] == val,

        forall|i: int, j: int| 
            0 <= i < result@.len() && 0 <= j < result@[i].len() && i != j 
            ==> #[trigger] result@[i][j] == mat@[i][j]","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0176,verus,numpy_triple,indexing_slicing_flatiter,,"numpy.flatiter: Flat iterator object to iterate over arrays.

A flatiter iterator provides a flattened view of an array for iteration purposes.
It allows accessing elements of a multi-dimensional array as if it were 1-dimensional,
following row-major (C-style) order where the last index varies fastest.

The iterator supports indexing and provides sequential access to all elements
in the array following the memory layout order.

Specification: numpy.flatiter creates a flat iterator over the array.

Precondition: True (no special preconditions for creating a flat iterator)
Postcondition: The result preserves all elements in row-major order,
               providing sequential access to the flattened array elements","use vstd::prelude::*;

verus! {",,"fn numpy_flatiter(a: Vec<i8>) -> (result: Vec<i8>)
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] == a[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0177,verus,numpy_triple,indexing_slicing_indices,,"Generate indices for a 1D grid of given size.
Returns a 2D array where the first dimension has size 1 and contains 
the indices [0, 1, 2, ..., n-1]

Specification: indices generates a grid of index values
This comprehensive specification captures:
1. The output has the correct shape: (1, n) for 1D case
2. The single row contains exactly the indices [0, 1, 2, ..., n-1]
3. Each position i contains the value i
4. The indices are in ascending order
5. The result covers all valid indices for the given dimension","use vstd::prelude::*;

verus! {",,"fn indices(n: u8) -> (grid: Vec<Vec<u8>>)
    ensures 
        grid.len() == 1,
        grid@[0].len() == n as nat,
        forall|i: int| 0 <= i < n as int ==> grid@[0][i] == i as u8,
        forall|i: int, j: int| 0 <= i < j < n as int ==> grid@[0][i] < grid@[0][j],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0178,verus,numpy_triple,indexing_slicing_ix_,,"Construct an open mesh from multiple sequences

Construct an open mesh from two 1-D sequences. 
This simplified version handles the case of two input sequences,
returning two 2D arrays that form an open mesh for indexing operations.
The first array has shape (m, 1) containing values from the first sequence,
and the second array has shape (1, n) containing values from the second sequence.

Specification: ix_ creates an open mesh from two sequences
This comprehensive specification captures:
1. The function takes two 1-D sequences of integers
2. Returns a pair of 2D arrays (represented as vectors of vectors)
3. First array has shape (m, 1) - m rows, 1 column
4. Second array has shape (1, n) - 1 row, n columns
5. First array contains values from seq1 repeated in column format
6. Second array contains values from seq2 repeated in row format
7. Together they form an open mesh for advanced indexing operations
8. Each element of the first array's i-th row equals seq1[i]
9. Each element of the second array's single row equals the corresponding seq2 element
10. The mesh property: for any indices (i,j), the pair (first[i][0], second[0][j]) 
    represents a coordinate in the mesh grid

/* First array has correct shape and values */

/* Second array has correct shape and values */

/* Mesh property: coordinates are preserved */","use vstd::prelude::*;

verus! {",,"fn ix_(seq1: Vec<i8>, seq2: Vec<i8>) -> (result: (Vec<Vec<i8>>, Vec<Vec<i8>>))
    requires 
        seq1.len() > 0,
        seq2.len() > 0,
    ensures 

        result.0.len() == seq1.len(),
        forall|i: int| 0 <= i < seq1@.len() ==> result.0@[i].len() == 1,
        forall|i: int| 0 <= i < seq1@.len() ==> result.0@[i][0] == seq1@[i],

        result.1.len() == 1,
        result.1@[0].len() == seq2.len(),
        forall|j: int| 0 <= j < seq2@.len() ==> result.1@[0][j] == seq2@[j],

        forall|i: int, j: int| 0 <= i < seq1@.len() && 0 <= j < seq2@.len() ==> 
            result.0@[i][0] == seq1@[i] && result.1@[0][j] == seq2@[j],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0179,verus,numpy_triple,indexing_slicing_mgrid,,"numpy.mgrid: Dense multi-dimensional ""meshgrid"" creation for 2D case.

Creates a dense mesh-grid from two 1D coordinate arrays, returning a pair of 2D arrays
where each output array has the same shape (rows × cols). The first array contains
row coordinates repeated across columns, and the second array contains column
coordinates repeated across rows.

This is the 2D case of numpy.mgrid[start_r:stop_r, start_c:stop_c] which creates
coordinate arrays suitable for evaluating functions over a 2D grid.

For 2D case with rows and cols dimensions, this returns a tuple of two matrices:
- First matrix: row coordinates repeated across columns
- Second matrix: column coordinates repeated across rows","use vstd::prelude::*;

verus! {",,"type Matrix = Vec<Vec<f32>>;

fn mgrid(rows: u8, cols: u8, start_r: f32, stop_r: f32, start_c: f32, stop_c: f32) -> (result: (Matrix, Matrix))
    requires rows > 0 && cols > 0,
    ensures 
        result.0.len() == rows as nat && result.1.len() == rows as nat,
        forall|i: int| 0 <= i < rows as int ==> result.0[i].len() == cols as nat && result.1[i].len() == cols as nat,
        forall|i: int, j: int, k: int| 0 <= i < rows as int && 0 <= j < cols as int && 0 <= k < cols as int ==> 
            result.0[i][j] == result.0[i][k],
        forall|j: int, i: int, k: int| 0 <= j < cols as int && 0 <= i < rows as int && 0 <= k < rows as int ==> 
            result.1[i][j] == result.1[k][j],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0180,verus,numpy_triple,indexing_slicing_nanargmax,,"Returns the index of the maximum value in a non-empty vector, ignoring NaN values.

This function finds the index of the maximum value among all non-NaN elements in the vector.
Requires that at least one element is not NaN, otherwise it would raise an error.

In case of multiple occurrences of the maximum values, the indices
corresponding to the first occurrence are returned.

Specification: nanargmax returns the index of the first maximum element among non-NaN values.

This comprehensive specification captures:
1. The returned index points to an element that is not NaN
2. The element at the returned index is the maximum among all non-NaN elements
3. The function returns the first occurrence of the maximum value (among non-NaN elements)
4. The returned index is valid (type-safe with Fin)
5. The precondition ensures at least one element is not NaN
6. All non-NaN elements are less than or equal to the maximum
7. Among elements with the same maximum value, the first index is returned

/* Maximum property: all finite values are <= max value */

/* First occurrence property: returns earliest index among ties */","use vstd::prelude::*;

verus! {",,"spec fn is_finite(x: f32) -> bool;

fn nanargmax(a: Vec<f32>) -> (result: usize)
    requires
        a.len() > 0,
        exists|i: int| 0 <= i < a@.len() && is_finite(a[i]),
    ensures
        result < a.len(),
        is_finite(a[result as int]),

        forall|j: int| 0 <= j < a@.len() && is_finite(a[j]) ==> true,

        forall|j: int| 0 <= j < a@.len() && is_finite(a[j]) ==> (result as int) <= j || true,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0181,verus,numpy_triple,indexing_slicing_nanargmin,,"Returns the index of the minimum value in a non-empty vector, ignoring NaN values.

This function finds the index of the minimum value among all non-NaN elements in the vector.
Requires that at least one element is not NaN, otherwise it would raise an error.

In case of multiple occurrences of the minimum values, the indices
corresponding to the first occurrence are returned.","use vstd::prelude::*;

verus! {

spec fn f32_is_nan(x: f32) -> bool;
spec fn f32_le(a: f32, b: f32) -> bool;",,"fn nanargmin(a: Vec<f32>) -> (result: usize)
    requires 
        a.len() > 0,
        exists|i: int| 0 <= i < a.len() && !f32_is_nan(a[i]),
    ensures
        result < a.len(),
        !f32_is_nan(a[result as int]),
        forall|j: int| 0 <= j < a.len() && !f32_is_nan(a[j]) ==> f32_le(a[result as int], a[j]),
        forall|j: int| 0 <= j < a.len() && !f32_is_nan(a[j]) && f32_le(a[j], a[result as int]) && f32_le(a[result as int], a[j]) ==> result as int <= j,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0182,verus,numpy_triple,indexing_slicing_ndenumerate,,"numpy.ndenumerate: Multidimensional index iterator that yields pairs of array coordinates and values.

For a 1D array, this creates a vector of tuples where each tuple contains
the index and the corresponding value from the input array.

The function essentially enumerates through the array, providing both
the position (index) and the value at that position.

Specification: ndenumerate returns a vector of index-value pairs.

For each position i in the input array, the result contains a tuple
(i, arr[i]) where i is the index and arr[i] is the value at that index.

Precondition: True (no special preconditions needed)
Postcondition: For all indices i, result[i] = (i, arr[i])","use vstd::prelude::*;

verus! {",,"fn ndenumerate(arr: Vec<f32>) -> (result: Vec<(usize, f32)>)
    ensures 
        result.len() == arr.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i as int].0 == i && result[i as int].1 == arr[i as int]","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0184,verus,numpy_triple,indexing_slicing_nditer,,"numpy.nditer: Creates an iterator for a vector that provides position and element access.

This is a simplified 1D version of numpy's nditer functionality.
Returns an iterator that starts at position 0 and holds the original data.
The iterator can be used to traverse the vector elements sequentially.

In numpy, nditer is a powerful multi-dimensional iterator, but for our
Vector-based specification, we simplify it to basic position tracking.

Specification: nditer creates a valid iterator that starts at position 0.

This comprehensive specification captures:
1. The iterator starts at position 0
2. The iterator contains the original data unchanged
3. The iterator position is valid (within bounds)
4. The iterator provides access to all elements of the original vector
5. The iterator follows numpy's iteration semantics
6. The iterator state is consistent and predictable","use vstd::prelude::*;

verus! {",,"fn nditer(arr: Vec<i8>) -> (iter: (usize, Vec<i8>))
    ensures
        iter.0 == 0,
        iter.1@ == arr@,
        iter.0 <= arr.len(),
        forall|i: int| 0 <= i < arr.len() ==> iter.1[i] == arr[i]","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0186,verus,numpy_triple,indexing_slicing_ogrid,,"numpy.ogrid: Open multi-dimensional ""meshgrid"".

Returns an open (i.e. not fleshed out) mesh-grid when indexed, 
so that only one dimension of each returned array is greater than 1.

This is a simplified 1D version that generates a linear sequence
similar to arange but with the ogrid interface. The dimension and 
number of the output arrays are equal to the number of indexing dimensions.

For the 1D case, it returns a single vector with evenly spaced values
from start to stop (exclusive) with the given step size.

Specification: ogrid returns a vector of evenly spaced values.

Precondition: step ≠ 0 and n = ⌊(stop - start) / step⌋
Postcondition: The result is a vector where each element i satisfies:
- result[i] = start + i * step
- All elements are in the range [start, stop)
- The sequence is arithmetic with common difference step","use vstd::prelude::*;

verus! {",,"fn ogrid(start: i8, stop: i8, step: i8, n: usize) -> (result: Vec<i8>)
    requires 
        step != 0,
    ensures
        result.len() == n,
        forall|i: int| 0 <= i < n ==> result@[i] == start as int + i * (step as int),
        forall|i: int| 0 <= i < n ==> 
            if step > 0 { 
                (start as int) <= result@[i] && result@[i] < (stop as int)
            } else {
                (stop as int) < result@[i] && result@[i] <= (start as int)
            },","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0187,verus,numpy_triple,indexing_slicing_place,,"numpy.place: Change elements of an array based on conditional and input values.

Modifies elements of an array where the corresponding mask is True, using values 
from the vals array. The function uses the first N elements of vals, where N is 
the number of True values in mask. If vals is smaller than N, it will be repeated.

The parameter `k` must equal the number of True elements in the mask array.
The parameter `v` is the size of the vals array, which must be non-empty.","use vstd::prelude::*;

verus! {",,"spec fn count_true(mask: Seq<bool>) -> nat
    decreases mask.len()
{
    if mask.len() == 0 {
        0
    } else {
        (if mask[0] { 1nat } else { 0nat }) + count_true(mask.skip(1))
    }
}

fn place(arr: Vec<f32>, mask: Vec<bool>, vals: Vec<f32>) -> (result: Vec<f32>)
    requires 
        arr.len() == mask.len(),
        vals.len() > 0,
    ensures 
        result.len() == arr.len(),
        forall|i: int| 0 <= i < arr.len() ==> !mask@[i] ==> result@[i] == arr@[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0188,verus,numpy_triple,indexing_slicing_put,,"numpy.put: Replaces specified elements of an array with given values.

The indexing works on the flattened target array. This operation mutates the input array
in-place by placing values from `v` at the positions specified by `ind`.

For simplicity, we ignore the `mode` parameter and assume all indices are valid.

Specification: numpy.put modifies specific elements of the input array.

This theorem captures the core mathematical properties:
1. Elements at specified indices are replaced with corresponding values from `v`
2. All other elements remain unchanged
3. The result vector has the same length as the input vector
4. Index bounds are respected (enforced by precondition)

Precondition: All indices in `ind` must be valid (less than array length)
Postcondition: Elements at specified indices are replaced with corresponding values from `v`,
              while all other elements remain unchanged.

This specification handles the case where indices may be duplicated - in such cases,
the later occurrence in the index vector takes precedence.","use vstd::prelude::*;

verus! {",,"fn put(a: Vec<f64>, ind: Vec<usize>, v: Vec<f64>) -> (result: Vec<f64>)
    requires 
        ind.len() == v.len(),
        forall|i: int| 0 <= i < ind@.len() ==> (ind[i] as int) < (a@.len() as int),
    ensures
        result@.len() == a@.len(),
        forall|i: int| 0 <= i < ind@.len() ==> result@[ind[i] as int] == v@[i],
        forall|j: int| 0 <= j < result@.len() ==> 
            (forall|i: int| 0 <= i < ind@.len() ==> j != ind[i] as int) ==> result@[j] == a@[j],
        ind@.len() == 0 ==> result@ == a@,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0189,verus,numpy_triple,indexing_slicing_putmask,,"Changes elements of an array based on conditional and input values.

This function modifies the target array in-place, setting elements to values
from the values array where the corresponding mask element is True.
If values is smaller than the target array, it will repeat cyclically.

Parameters:
- a: Target array to modify
- mask: Boolean mask array with same shape as a
- values: Values to put into a where mask is True
- m: Size of values array (must be positive for repetition)","use vstd::prelude::*;

verus! {",,"fn putmask(a: Vec<f32>, mask: Vec<bool>, values: Vec<f32>) -> (result: Vec<f32>)
    requires 
        a.len() == mask.len(),
        values.len() > 0,
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < a@.len() ==> (
            mask@[i] ==> exists|j: int| 0 <= j < values@.len() && result@[i] == values@[j]
        ),
        forall|i: int| 0 <= i < a@.len() ==> (
            mask@[i] ==> result@[i] == values@[(i as int) % (values@.len() as int)]
        ),
        forall|i: int| 0 <= i < a@.len() ==> (
            !mask@[i] ==> result@[i] == a@[i]
        ),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0190,verus,numpy_triple,indexing_slicing_r_,,"numpy.r_: Translates slice objects to concatenation along the first axis.

This is a simple way to build up arrays quickly. There are two main use cases:
1. If the index expression contains comma separated arrays, then stack them along their first axis
2. If the index expression contains slice notation or scalars then create a 1-D array with a range

This implementation focuses on the first use case - concatenating two 1D arrays along the first axis.
The r_ object provides a convenient way to concatenate arrays by using index notation.

For example, numpy.r_[array1, array2] concatenates array1 and array2.

Specification: numpy.r_ concatenates arrays along the first axis.

Precondition: True (no special preconditions for basic concatenation)
Postcondition: The result contains all elements from the first array followed by all elements from the second array.
This comprehensive specification captures:
1. First n elements come from array a (preserving order and values)
2. Next m elements come from array b (preserving order and values)
3. Total length is n + m (enforced by type system)
4. No elements are duplicated or lost (bijective mapping)
5. The concatenation preserves all original values exactly
6. Order is preserved within each original array","use vstd::prelude::*;

verus! {",,"fn r_(a: Vec<i8>, b: Vec<i8>) -> (result: Vec<i8>)
    ensures
        result.len() == a.len() + b.len(),
        forall|i: int| 0 <= i < a.len() ==> result[i] == a[i],
        forall|j: int| 0 <= j < b.len() ==> result[a.len() + j] == b[j]","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0191,verus,numpy_triple,indexing_slicing_ravel_multi_index,,"Converts a tuple of index arrays into an array of flat indices, applying boundary modes to the multi-index.

Convert 2D multi-indices to flat indices using C-style (row-major) ordering.

Takes arrays of row and column indices and converts them to flat indices
for an array with given dimensions. The conversion uses row-major ordering
where flat_index = row_index * cols + col_index.

The function requires that all indices are within bounds of the specified dimensions.

Specification: ravel_multi_index converts 2D indices to flat indices using row-major ordering.

Precondition: All row and column indices must be within bounds
Postcondition: Each flat index is computed as row_index * cols + col_index

Mathematical properties:
1. The flat index correctly represents the 2D position in a flattened array
2. All resulting indices are within bounds of the flattened array
3. The conversion preserves the ordering relationship between multi-indices

This specification captures the essential behavior of NumPy's ravel_multi_index
for the 2D case with C-style ordering. The function maps 2D coordinates to
their corresponding positions in a flattened representation of the array.","use vstd::prelude::*;

verus! {",,"fn ravel_multi_index(row_indices: &Vec<u8>, col_indices: &Vec<u8>, rows: u8, cols: u8) -> (result: Vec<u8>)
    requires 
        row_indices.len() == col_indices.len(),
        forall|i: int| 0 <= i < row_indices.len() ==> (row_indices[i] as nat) < (rows as nat),
        forall|i: int| 0 <= i < col_indices.len() ==> (col_indices[i] as nat) < (cols as nat),
    ensures 
        result.len() == row_indices.len(),
        forall|i: int| 0 <= i < result.len() ==> 
            (result[i] as nat) == (row_indices[i] as nat) * (cols as nat) + (col_indices[i] as nat) && 
            (result[i] as nat) < (rows as nat) * (cols as nat),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0192,verus,numpy_triple,indexing_slicing_s_,,"Index expression builder that creates slice objects for array indexing.
This is a simplified version of numpy.s_ that creates slice objects
for use in array indexing operations.

Specification: s_ creates a well-formed slice object
This comprehensive specification captures:
1. The slice object contains the provided start, stop, and step values
2. If step is provided, it must be positive (non-zero)
3. If start and stop are both provided, start should be less than or equal to stop
4. The resulting slice is valid for array indexing operations
5. The slice preserves the ordering constraints (start ≤ stop when both present)
6. The step value, if present, is positive for forward slicing

/* A slice object representing a range of indices for array slicing.
   Contains start, stop, and step parameters for creating slices. */

/* The starting index of the slice (inclusive). If None, starts from the beginning. */

/* The stopping index of the slice (exclusive). If None, goes to the end. */

/* The step size for the slice. If None, defaults to 1. */","use vstd::prelude::*;

verus! {

pub struct Slice {

    pub start: Option<usize>,

    pub stop: Option<usize>,

    pub step: Option<usize>,
}",,"fn s_(start: Option<usize>, stop: Option<usize>, step: Option<usize>) -> (slice: Slice)
    requires 
        step.is_some() ==> step.unwrap() > 0,
        (start.is_some() && stop.is_some()) ==> start.unwrap() <= stop.unwrap(),
    ensures 
        slice.start == start,
        slice.stop == stop,
        slice.step == step,
        slice.step.is_some() ==> slice.step.unwrap() > 0,
        (slice.start.is_some() && slice.stop.is_some()) ==> slice.start.unwrap() <= slice.stop.unwrap(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0193,verus,numpy_triple,indexing_slicing_select,,"numpy.select: Return an array drawn from elements in choicelist, depending on conditions.

For each element position, returns the element from the first choice array
where the corresponding condition is True. If no conditions are True,
returns the default value.

This function enables multi-way conditional selection between arrays.

Specification: numpy.select performs element-wise multi-conditional selection.

Precondition: condlist and choicelist have the same length
Postcondition: Each element is selected from the first matching choice array,
               or default if no conditions match","use vstd::prelude::*;

verus! {",,"fn select(condlist: Vec<Vec<bool>>, choicelist: Vec<Vec<i8>>, default: i8) -> (result: Vec<i8>)
    requires 
        condlist.len() == choicelist.len(),
        condlist.len() > 0 ==> (forall|i: int| 0 <= i < condlist.len() ==> #[trigger] condlist[i].len() == condlist[0].len()),
        choicelist.len() > 0 ==> (forall|i: int| 0 <= i < choicelist.len() ==> #[trigger] choicelist[i].len() == choicelist[0].len()),
        condlist.len() > 0 && choicelist.len() > 0 ==> condlist[0].len() == choicelist[0].len(),
    ensures
        condlist.len() == 0 ==> result.len() == 0,
        condlist.len() > 0 ==> result.len() == condlist[0].len(),
        forall|i: int| 0 <= i < result.len() ==> {
            (exists|j: int| 0 <= j < condlist.len() && condlist[j][i] == true && 
                #[trigger] result[i] == choicelist[j][i] &&
                (forall|j_prime: int| 0 <= j_prime < j ==> #[trigger] condlist[j_prime][i] == false)) ||
            (forall|j: int| 0 <= j < condlist.len() ==> #[trigger] condlist[j][i] == false && result[i] == default)
        },","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0194,verus,numpy_triple,indexing_slicing_take,,"Take elements from a source array at specified indices.
Given a source array 'arr' and a vector of indices 'indices',
returns a new array containing the elements from 'arr' at the positions
specified by 'indices'. The indices must be valid positions in the source array.

This is a simplified 1D version of numpy.take with 'raise' mode,
where all indices must be valid (in range [0, n-1]).

Specification: take extracts elements from a source array at specified indices.

Mathematical properties:
1. The result has the same length as the indices array
2. For each position i in the result, result[i] = arr[indices[i]]
3. All indices must be valid (enforced by Fin type)
4. The order of elements in the result follows the order of indices
5. The same index can appear multiple times, resulting in duplicated elements

The function implements: result[i] = arr.get (indices.get i)

This captures the core behavior of numpy.take in 'raise' mode where indices
must be in valid range. The use of Fin type ensures type safety and eliminates
the need for runtime bounds checking. The result preserves the element type
of the source array.","use vstd::prelude::*;

verus! {",,"fn take(arr: Vec<f32>, indices: Vec<usize>) -> (result: Vec<f32>)
    requires
        forall|i: int| 0 <= i < indices@.len() ==> indices[i] < arr@.len(),
    ensures
        result@.len() == indices@.len(),
        forall|i: int| 0 <= i < indices@.len() ==> result[i] == arr[indices[i] as int],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0195,verus,numpy_triple,indexing_slicing_trace,,"Return the sum along diagonals of the array.

For a 2D matrix, computes the sum of elements along the diagonal
with an optional offset. For offset=0, it computes the sum of 
elements a[i,i] for all valid i. For positive offset, it sums
a[i,i+offset], and for negative offset, it sums a[i-offset,i].

This implementation focuses on the 2D case as the core functionality.","use vstd::prelude::*;

verus! {",,"fn trace(a: Vec<Vec<f32>>, offset: i32) -> (result: f32)
    ensures true","{
    // impl-start
    assume(false);
    0.0
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0196,verus,numpy_triple,indexing_slicing_tril,,"numpy.tril: Lower triangle of an array.

Return a copy of an array with elements above the k-th diagonal zeroed.
For simplicity, this specification focuses on square matrices and k=0 (main diagonal).

Given a flattened square matrix (stored in row-major order), returns a copy
where elements above the main diagonal are set to zero.

This captures the essential mathematical property of extracting the lower
triangular part of a matrix.

Specification: tril returns the lower triangle of a matrix with elements above the main diagonal zeroed.

Mathematical Properties:
1. Shape Preservation: The output has the same shape as the input
2. Lower Triangle Preservation: Elements at or below the main diagonal are unchanged
3. Upper Triangle Zeroing: Elements above the main diagonal are set to zero
4. Diagonal Definition: For a square matrix stored in row-major order,
   element at position (i,j) corresponds to index i*n + j in the flattened vector

The main diagonal consists of elements where i = j.
Lower triangle consists of elements where i ≥ j.
Upper triangle consists of elements where i < j.

This specification provides a foundation for formal verification of
triangular matrix operations in numerical computing.","use vstd::prelude::*;

verus! {",,"fn tril(matrix: Vec<f32>, n: usize) -> (result: Vec<f32>)
    requires 
        n > 0,
        matrix.len() == n * n,
    ensures
        result.len() == matrix.len(),
        forall|i: usize, j: usize| #[trigger] result@[i * n + j] == matrix@[i * n + j] <==
            i < n && j < n && i >= j,
        forall|i: usize, j: usize| #[trigger] result@[i * n + j] == 0.0f32 <==
            i < n && j < n && i < j,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0197,verus,numpy_triple,indexing_slicing_triu,,"Upper triangle of a matrix. Returns a copy of the matrix with elements below the k-th diagonal zeroed.

Given a matrix m and an integer k, this function returns a new matrix where:
- Elements at position (i,j) where i+k <= j are preserved (upper triangle including k-th diagonal)
- Elements at position (i,j) where i+k > j are set to zero (below k-th diagonal)

The diagonal offset k works as follows:
- k = 0: main diagonal (default)
- k > 0: diagonal above the main diagonal
- k < 0: diagonal below the main diagonal

Specification: triu returns the upper triangle of a matrix with elements below the k-th diagonal set to zero.

Mathematical properties:
1. Elements on and above the k-th diagonal are preserved: if i+k <= j, then result[i][j] = m[i][j]
2. Elements below the k-th diagonal are zeroed: if i+k > j, then result[i][j] = 0
3. The result matrix has the same dimensions as the input matrix

The k-th diagonal is defined as positions (i,j) where i+k = j:
- When k=0: main diagonal (i=j)
- When k>0: diagonal above main diagonal 
- When k<0: diagonal below main diagonal

This captures the essential behavior of numpy.triu which extracts the upper triangular part
of a matrix relative to the k-th diagonal.","use vstd::prelude::*;

verus! {",,"fn triu(m: Vec<Vec<f64>>, k: i8) -> (result: Vec<Vec<f64>>)
    requires 
        m.len() > 0,
        forall|i: int| 0 <= i < m@.len() ==> #[trigger] m@[i].len() == m@[0].len(),
    ensures
        result.len() == m.len(),
        forall|i: int| 0 <= i < result@.len() ==> #[trigger] result@[i].len() == m@[0].len(),
        forall|i: int, j: int| 0 <= i < result@.len() && 0 <= j < result@[i].len() && i + (k as int) <= j ==> #[trigger] result@[i][j] == m@[i][j],
        forall|i: int, j: int| 0 <= i < result@.len() && 0 <= j < result@[i].len() && i + (k as int) > j ==> #[trigger] result@[i][j] == 0.0,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0198,verus,numpy_triple,indexing_slicing_unravel_index,,"Converts a flat index or array of flat indices into a tuple of coordinate arrays.
This is the inverse operation of ravel_multi_index.
Specification: unravel_index converts flat indices to multi-dimensional coordinates
such that the coordinates are valid for the given shape and represent the correct
positions in the multi-dimensional array.","use vstd::prelude::*;

verus! {

spec fn vec_product(shape: Seq<usize>) -> nat
    decreases shape.len()
{
    if shape.len() == 0 {
        1nat
    } else {
        (shape[0] as nat) * vec_product(shape.skip(1))
    }
}",,"fn unravel_index(indices: Vec<usize>, shape: Vec<usize>) -> (result: Vec<Vec<usize>>)
    requires 
        shape.len() > 0,
        forall|i: int| 0 <= i < shape.len() ==> shape[i] > 0,
        forall|i: int| 0 <= i < indices.len() ==> (indices[i] as nat) < vec_product(shape@),
    ensures
        result.len() == indices.len(),
        forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i].len() == shape.len(),
        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < shape.len() ==> 
            #[trigger] result[i][j] < shape[j],
        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result.len() && i != j ==> 
            (indices[i] != indices[j] ==> result[i]@ != result[j]@)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0199,verus,numpy_triple,indexing_slicing_where,,"Return elements chosen from x or y depending on condition.
Given vectors of equal length for condition, x, and y, constructs a result vector
where each element is selected from x if the corresponding condition is true,
otherwise from y.

This implements the core ternary conditional operation:
result[i] = condition[i] ? x[i] : y[i]

The function requires all three input vectors to have the same length, which
is enforced by the type system using Vector types.

Specification: where returns elements chosen from x or y based on condition.
This captures the essential behavior of numpy.where function:

Mathematical properties:
1. The result has the same length as all input vectors
2. For each position i, if condition[i] is true, then result[i] = x[i]
3. For each position i, if condition[i] is false, then result[i] = y[i]
4. The function is deterministic - same inputs always produce same output
5. The result is well-defined for all inputs (no partial functions)

This specification captures the core ternary conditional semantics:
result[i] = if condition.get i then x.get i else y.get i

The use of Vector types ensures type safety and eliminates the need for
size compatibility checks at runtime. All vectors must have the same length
by construction.","use vstd::prelude::*;

verus! {",,"fn where_fn(condition: Vec<bool>, x: Vec<f32>, y: Vec<f32>) -> (result: Vec<f32>)
    requires 
        condition.len() == x.len(),
        x.len() == y.len(),
    ensures 
        result.len() == condition.len(),
        forall|i: int| 0 <= i < condition.len() ==> 
            result@[i] == if condition@[i] { x@[i] } else { y@[i] }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0200,verus,numpy_triple,io_operations_array2string,,"numpy.array2string: Return a string representation of an array

Converts an array to its string representation with customizable separator.
This function provides a way to format arrays for display purposes.

The separator parameter controls how elements are separated in the output.

Specification: array2string returns a string representation of the array

Precondition: True (no special preconditions)
Postcondition: result is non-empty string that starts with '[' and ends with ']'","use vstd::prelude::*;

verus! {",,"fn array2string(arr: Vec<f32>, separator: &str) -> (result: Vec<char>)
    ensures
        result@.len() > 0,
        result@[0] == '[',
        result@[result@.len() - 1] == ']'","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0201,verus,numpy_triple,io_operations_array_repr,,"Return the string representation of a vector, formatted as ""array([v1, v2, ..., vn])"".
This provides a structured string representation that includes the ""array()"" wrapper
and properly formatted element values.

Specification: array_repr returns a well-formatted string representation of the vector.

The specification captures:
1. Basic format: the string starts with ""array("" and ends with "")""
2. Element representation: each element is formatted as a string
3. Proper bracketing: elements are enclosed in square brackets
4. Separator consistency: elements are separated by commas and spaces
5. Precision handling: floating point numbers are formatted to specified precision
6. Small number suppression: very small numbers can be represented as zero
7. Non-emptiness: the result is always a non-empty string
8. Structural integrity: the string format is parseable and well-formed","use vstd::prelude::*;

verus! {",,"fn array_repr(arr: Vec<f32>, max_line_width: u8, precision: u8, suppress_small: bool) -> (result: String)
    requires 
        precision as nat > 0,
        max_line_width as nat > 0,
    ensures
        /* Non-empty result: string representation is always non-empty */
        result@.len() > 0,
        /* Precision constraint: reasonable string length bounds */
        result@.len() <= max_line_width as nat + 20,
        /* Basic format constraints - minimum length for valid array representation */
        result@.len() >= 9,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0202,verus,numpy_triple,io_operations_array_str,,"Return a string representation of the data in a vector

Specification: array_str returns a formatted string representation of the vector data","use vstd::prelude::*;

verus! {",,"fn array_str(a: Vec<i8>) -> (result: String)
    ensures 
        result@.len() > 0,
        a.len() == 0 ==> result@ == ""[]""@,
        a.len() > 0 ==> result@[0] == '[' && result@[(result@.len() - 1) as int] == ']',","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0205,verus,numpy_triple,io_operations_fromfile,,"Construct an array from data in a text or binary file

This function provides a highly efficient way of reading binary data with a known data-type, 
as well as parsing simply formatted text files. Data written using the tofile method can be 
read using this function.

Construct a vector from data in a text or binary file
Parameters:
- file: File handle for the input file
- dtype: Data type of the returned array
- count: Number of items to read (-1 means entire file)
- sep: Separator between items (empty string means binary file)
- offset: Byte offset from file's current position (binary files only)

Specification: fromfile reads data from a file and constructs a vector
Properties:
1. For binary files (sep = """"), reads exactly count items if count > 0
2. For text files (sep ≠ """"), parses items separated by sep
3. If count = -1, reads all available data
4. Binary files respect the offset parameter
5. The resulting vector has the correct size and data type
6. Data is read sequentially from the file

/* File handle abstraction for I/O operations */

/* Path to the file */

/* Whether the file is opened in binary mode */

/* Current position in the file (in bytes) */

/* Represents different data types that can be read from files */

/* 32-bit floating point */

/* 64-bit floating point */

/* 32-bit signed integer */

/* 64-bit signed integer */

/* 8-bit unsigned integer */

/* Get the size in bytes for each data type */

/* For binary files, data is read sequentially from offset */

/* Sequential reading property: elements maintain file order preserved */

/* placeholder for ordering properties */

/* Type consistency: all elements are well-typed */

/* placeholder for type consistency */","use vstd::prelude::*;

verus! {

struct FileHandle {

    path: String,

    is_binary: bool,

    position: nat,
}

enum DType {

    Float32,

    Float64,

    Int32,

    Int64,

    UInt8,
}

spec fn dtype_size_bytes(dtype: DType) -> nat {
    match dtype {
        DType::Float32 => 4,
        DType::Float64 => 8,
        DType::Int32 => 4,
        DType::Int64 => 8,
        DType::UInt8 => 1,
    }
}",,"fn fromfile(file: FileHandle, dtype: DType, count: i8, sep: &str, offset: u8) -> (result: Vec<i8>)
    requires
        count == -1 || count > 0,
        sep == """" ==> file.is_binary == true,
        file.is_binary == true ==> sep == """",
    ensures
        count > 0 ==> result.len() == count as int as usize,

        file.is_binary == true ==> (
            #[trigger] (result@.len() * dtype_size_bytes(dtype))
            >= 0
        ),

        true,

        true,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0206,verus,numpy_triple,io_operations_fromregex,,"Construct an array from a text file using regular expression parsing

Construct a structured array from a text file using regular expression parsing

Specification: fromregex constructs a structured array from regex matches in file content","use vstd::prelude::*;

verus! {

/* A simple abstraction for regular expressions */
struct RegExp {
    /* The regular expression pattern */
    pattern: String,
}

/* A simple abstraction for structured data types */
struct StructuredDataType {
    /* List of field names and their types */
    fields: Vec<(String, String)>,
}

/* A simple abstraction for structured array elements */
struct StructuredElement {
    /* List of field values as strings */
    values: Vec<String>,
}",,"fn fromregex(file_content: Vec<u8>, regexp: RegExp, dtype: StructuredDataType) -> (result: Vec<StructuredElement>)
    requires dtype.fields@.len() > 0,
    ensures
        forall|i: int| 0 <= i < result@.len() ==> result@[i].values@.len() == dtype.fields@.len(),
        forall|i: int, j: int| 0 <= i < result@.len() && 0 <= j < result@.len() ==> 
            result@[i].values@.len() == result@[j].values@.len(),
        result@.len() > 0 ==> file_content@.len() > 0","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0207,verus,numpy_triple,io_operations_fromstring,,"Create a 1-D array from text data in a string.
Parses a string containing numeric data separated by a specified separator
and returns a vector of the parsed values.
Specification: fromstring creates a vector by parsing numeric values from a string.
The function parses the input string using the given separator and converts
the resulting substrings to floating-point numbers.

/* All parsed elements are valid */","use vstd::prelude::*;

verus! {",,"fn fromstring(input: &str, sep: &str, n: u8) -> (result: Vec<f64>)
    requires n > 0,
    ensures 
        result@.len() <= n as int,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0208,verus,numpy_triple,io_operations_genfromtxt,,"Load data from a text file, with missing values handled as specified. Load data from a text file with missing value handling. This is a simplified version focusing on numeric data parsing from delimited text. Specification: genfromtxt parses delimited text data into a matrix structure, handling missing values by filling them with the specified default value. The function skips the specified number of header lines and parses the remaining lines into a structured matrix.","use vstd::prelude::*;

verus! {",,"fn genfromtxt(input: Vec<String>, delimiter: String, fill_value: f32, skip_header: usize) -> (result: Vec<Vec<f32>>)
    requires 
        skip_header < input.len(),
    ensures
        result.len() == input.len() - skip_header,
        forall|i: int| 0 <= i < result@.len() ==> #[trigger] (i + skip_header as int) >= skip_header as int,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0209,verus,numpy_triple,io_operations_get_printoptions,,"numpy.get_printoptions: Return the current print options

Returns a structure containing the current print options that control
how arrays are formatted when displayed. These options include precision
for floating point numbers, threshold for array summarization, and
various string representations.

This function reads the current state of NumPy's print formatting system.

Specification: get_printoptions returns a valid PrintOptions structure
with sensible default values.

Precondition: True (no special preconditions)
Postcondition: Result contains valid print options with proper constraints","use vstd::prelude::*;

verus! {",,"/* Structure representing NumPy print options */
struct PrintOptions {
    /* Number of digits of precision for floating point output */
    precision: u8,
    /* Total number of array elements which trigger summarization */
    threshold: u8,
    /* Number of array items in summary at beginning and end */
    edgeitems: u8,
    /* Number of characters per line for line breaks */
    linewidth: u8,
    /* Whether to suppress small floating point values */
    suppress: bool,
    /* String representation of floating point not-a-number */
    nanstr: Vec<char>,
    /* String representation of floating point infinity */
    infstr: Vec<char>,
    /* Controls printing of the sign of floating-point types */
    sign: Vec<char>,
    /* Controls interpretation of precision option */
    floatmode: Vec<char>,
    /* Legacy printing mode setting */
    legacy: Option<Vec<char>>,
}

fn get_printoptions() -> (result: PrintOptions)
    ensures
        result.precision as nat > 0,
        result.threshold as nat > 0,
        result.edgeitems as nat > 0,
        result.linewidth as nat > 0,
        result.nanstr@.len() > 0,
        result.infstr@.len() > 0,
        (result.sign@ == seq!['-'] || result.sign@ == seq!['+'] || result.sign@ == seq![' ']),
        (result.floatmode@ == seq!['f','i','x','e','d'] ||
         result.floatmode@ == seq!['u','n','i','q','u','e'] ||
         result.floatmode@ == seq!['m','a','x','p','r','e','c'] ||
         result.floatmode@ == seq!['m','a','x','p','r','e','c','_','e','q','u','a','l'])","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0211,verus,numpy_triple,io_operations_loadtxt,,"Load data from a text file into a 2D array.
For simplicity, this specification focuses on loading a rectangular matrix of floats.

Specification: loadtxt reads numeric data from a text file into a well-formed 2D array.
The function preserves the structure of the input data and handles parsing correctly.","use vstd::prelude::*;

verus! {",,"fn loadtxt(filename: Vec<char>, delimiter: Vec<char>, skiprows: usize, rows: usize, cols: usize) -> (result: Vec<Vec<f64>>)
    requires 
        rows > 0,
        cols > 0,
        filename@.len() > 0,
    ensures
        result@.len() == rows,
        forall|i: int| 0 <= i < result@.len() ==> result@[i]@.len() == cols,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0212,verus,numpy_triple,io_operations_memmap,,"numpy.memmap: Create a memory-map to an array stored in a binary file on disk.

Memory-mapped files are used for accessing small segments of large files
on disk, without reading the entire file into memory. The memmap provides
an array-like interface to the file contents.

This function creates a Vector view into a binary file on disk with the
specified shape and access mode. The file is accessed starting at the
given offset.

Specification: numpy.memmap creates a memory-mapped view of a file.

This specification captures the essential properties of memory mapping:
1. The result is a valid vector of the specified size
2. The mapping respects the file access mode constraints
3. The offset is within valid bounds for the file
4. Read-only modes preserve data integrity
5. Write modes allow modification of the underlying file

Preconditions:
- The filename represents a valid file path
- The offset is non-negative and within the file bounds
- For WriteNew mode, the file will be created if it doesn't exist
- For ReadOnly mode, the file must exist and be readable

Postconditions:
- Returns a vector of the specified size n
- The vector provides a view into the file starting at the given offset
- Read operations reflect the file contents at the mapped region
- Write operations (when mode allows) modify the underlying file
- The mapping preserves the mathematical properties of array access","use vstd::prelude::*;

verus! {

/* A simplified representation of file access mode for memory mapping */
#[derive(PartialEq, Eq)]
enum FileMode {
    /* ReadOnly mode ('r') - read-only access to existing file */
    ReadOnly,
    /* ReadWrite mode ('r+') - read-write access to existing file */
    ReadWrite,
    /* WriteNew mode ('w+') - create new file with read-write access */
    WriteNew,
    /* CopyOnWrite mode ('c') - copy-on-write access, changes don't persist to disk */
    CopyOnWrite,
}",,"fn memmap(filename_valid: bool, mode: FileMode, offset: usize, n: usize) -> (result: Vec<f32>)
    requires 
        filename_valid,
    ensures
        result@.len() == n as int,
        forall|i: int| 0 <= i < n as int ==> #[trigger] result@[i] == result@[i],","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0213,verus,numpy_triple,io_operations_printoptions,,"numpy.printoptions: Context manager for setting print options.

Creates a context manager that temporarily sets print options and restores
the original options afterward. This allows for local formatting changes
without affecting global state.

The context manager returns the current print options that are active
within the context.

Specification: numpy.printoptions creates a context with temporary print options.

Precondition: Valid print options are provided
Postcondition: Returns a context that contains both old and new options,
               where the new options are the ones that would be active
               within the context","use vstd::prelude::*;

verus! {

/* Print options structure to represent configuration */
struct PrintOptions {
    /* Number of digits of precision for floating point output */
    precision: usize,
    /* Total number of array elements which trigger summarization */
    threshold: usize,
    /* Number of array items in summary at beginning and end */
    edgeitems: usize,
    /* Number of characters per line for inserting line breaks */
    linewidth: usize,
    /* Whether to suppress small floating point values */
    suppress: bool,
    /* String representation of floating point NaN */
    nanstr: String,
    /* String representation of floating point infinity */
    infstr: String,
}

/* Context manager result representing the temporary state change */
struct PrintOptionsContext {
    /* The original print options before the context change */
    old_options: PrintOptions,
    /* The new print options active within the context */
    new_options: PrintOptions,
}",,"fn numpy_printoptions(new_opts: PrintOptions) -> (context: PrintOptionsContext)
    ensures 
        context.new_options == new_opts,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0214,verus,numpy_triple,io_operations_save,,"numpy.save: Save an array to a binary file in NumPy .npy format.

Saves Vector data to a binary file in NumPy .npy format. This operation serializes 
the array data and writes it to disk storage. The function supports:
- Automatic .npy extension appending if not present
- Binary format writing for efficient storage and loading
- Security control via allow_pickle parameter

The file parameter represents the path where the data should be saved.
For security reasons, object arrays with pickled data should be avoided 
unless explicitly allowed.

This is a file output operation that creates or overwrites the target file.

Specification: numpy.save persists vector data to disk in a recoverable format.

This specification captures the essential properties of the save operation:

1. Data Persistence: The vector data is written to the specified file
2. Format Consistency: Data is saved in .npy format for later loading
3. File Creation: The target file is created or overwritten
4. Extension Management: .npy extension is added if not present
5. Security Control: Object arrays are only saved when explicitly allowed

Mathematical Properties:
- Determinism: Saving the same vector to the same file produces identical results
- Completeness: All vector elements are preserved in the saved format
- Recoverability: The saved data can be loaded back to reconstruct the original vector
- Idempotence: Multiple saves of the same data to the same file yield identical files

Precondition: The file path is valid and writable
Postcondition: The file exists and contains the serialized vector data","use vstd::prelude::*;

verus! {",,"fn save(file: String, arr: Vec<f32>, allow_pickle: bool) -> (result: ())
    ensures result == (),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0216,verus,numpy_triple,io_operations_savez,,"numpy.savez: Save several arrays into a single file in uncompressed .npz format.

Saves multiple Vector arrays to a single .npz archive file. This operation
serializes multiple arrays into a compressed archive, where each array
is stored as a separate .npy file within the archive.

Key functionality:
- Multiple arrays can be saved in a single operation
- Each array is stored with an associated name within the archive
- The resulting .npz file can be loaded later to recover the arrays
- Arrays are stored in uncompressed .npy format within the archive

The function takes a file path and multiple arrays to save. For simplicity,
this specification focuses on saving exactly two arrays (commonly used case).

Security considerations:
- Pickle support is controlled by allow_pickle parameter
- Invalid file paths or write permissions can cause failures
- The archive format ensures data integrity through checksums

Specification: numpy.savez creates a .npz archive containing multiple arrays.

This specification captures the essential properties of the savez operation:

1. Data Persistence: Arrays are written to disk in a retrievable format
2. Archive Structure: Multiple arrays are bundled into a single .npz file
3. Data Integrity: Saved arrays can be loaded with identical values
4. Name Association: Arrays are stored with identifiable names in the archive
5. Format Compliance: Output follows .npz format specification

Mathematical Properties:
- Bijection: There exists a one-to-one correspondence between saved and loaded arrays
- Preservation: All array values are preserved exactly in the archive
- Atomicity: Either all arrays are saved successfully or none are saved
- Idempotence: Saving the same arrays multiple times produces identical files

Security Properties:
- Pickle safety: Object arrays are only saved when explicitly allowed
- File system safety: Operation respects file system permissions

Precondition: File path is writable and arrays are valid
Postcondition: Archive file exists and contains both arrays with recoverable data

/* h_writable and h_valid_path assumptions */","use vstd::prelude::*;

verus! {",,"fn savez(file: String, arr1: Vec<f32>, arr2: Vec<f32>, allow_pickle: bool) -> (result: ())
    requires 
        true,
    ensures 
        result == (),
        exists|recoverable_arr1: Vec<f32>| #[trigger] recoverable_arr1.len() == arr1.len() &&
            forall|i: int| 0 <= i < arr1.len() ==> recoverable_arr1[i] == arr1[i],
        exists|recoverable_arr2: Vec<f32>| #[trigger] recoverable_arr2.len() == arr2.len() &&
            forall|i: int| 0 <= i < arr2.len() ==> recoverable_arr2[i] == arr2[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0217,verus,numpy_triple,io_operations_savez_compressed,,"Save several arrays into a single file in compressed .npz format.

This function saves multiple arrays to a compressed archive file.
Arrays are stored with either provided names or automatic names (arr_0, arr_1, etc.).
The resulting file can be loaded back using numpy.load.

Specification: savez_compressed saves arrays to a compressed archive file.

The function should:
1. Create a compressed .npz file at the specified path
2. Store each array in the archive with proper naming
3. Ensure the file is readable by compatible loading functions
4. Handle filename extension automatically (.npz appended if not present)","use vstd::prelude::*;
use vstd::string::*;

verus! {",,"fn savez_compressed(filename: &str, arrays: &Vec<Vec<i8>>) -> (result: ())
    requires 
        filename@.len() > 0,
        arrays@.len() > 0,
    ensures
        /* File creation and data preservation properties are ensured */
        true","{
    // impl-start
    assume(false);
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0218,verus,numpy_triple,io_operations_set_printoptions,,"numpy.set_printoptions: Set printing options for NumPy arrays

Sets the global printing options that control how floating point numbers,
arrays and other NumPy objects are displayed. This function modifies the
global state of NumPy's print formatting system.

All parameters are optional and only modify the corresponding option if
provided. Options not specified retain their current values.

Specification: set_printoptions correctly updates the global print options
according to the provided parameters while validating input constraints.

Precondition: All optional parameters must satisfy their validation constraints
Postcondition: The global print state is updated with the provided options","use vstd::prelude::*;

verus! {

/* Structure representing NumPy print options */
struct PrintOptions {
    /* Number of digits of precision for floating point output */
    precision: nat,
    /* Total number of array elements which trigger summarization */
    threshold: nat,
    /* Number of array items in summary at beginning and end */
    edgeitems: nat,
    /* Number of characters per line for line breaks */
    linewidth: nat,
    /* Whether to suppress small floating point values */
    suppress: bool,
    /* String representation of floating point not-a-number */
    nanstr: String,
    /* String representation of floating point infinity */
    infstr: String,
    /* Controls printing of the sign of floating-point types */
    sign: String,
    /* Controls interpretation of precision option */
    floatmode: String,
    /* Legacy printing mode setting */
    legacy: Option<String>,
}",,"fn set_printoptions(
    precision: Option<u8>,
    threshold: Option<u8>,
    edgeitems: Option<u8>,
    linewidth: Option<u8>,
    suppress: Option<bool>,
    nanstr: Option<String>,
    infstr: Option<String>,
    sign: Option<String>,
    floatmode: Option<String>,
    legacy: Option<String>
) -> (result: ())
    requires
        forall|p: u8| precision == Some(p) ==> p as nat > 0,
        forall|t: u8| threshold == Some(t) ==> t as nat > 0,
        forall|e: u8| edgeitems == Some(e) ==> e as nat > 0,
        forall|l: u8| linewidth == Some(l) ==> l as nat > 0,
        forall|n: String| nanstr == Some(n) ==> n@.len() > 0,
        forall|i: String| infstr == Some(i) ==> i@.len() > 0,
        forall|s: String| sign == Some(s) ==> (s@.len() == 1 && (s@ == seq!['-'] || s@ == seq!['+'] || s@ == seq![' '])),
        forall|f: String| floatmode == Some(f) ==> 
            (f@ == seq!['f','i','x','e','d'] || f@ == seq!['u','n','i','q','u','e'] || f@ == seq!['m','a','x','p','r','e','c'] || f@ == seq!['m','a','x','p','r','e','c','_','e','q','u','a','l']),
        forall|l: String| legacy == Some(l) ==> 
            (l@ == seq!['1','.','1','3'] || l@ == seq!['1','.','2','1'] || l@ == seq!['1','.','2','5'] || l@ == seq!['2','.','1'] || l@ == seq!['2','.','2']),
    ensures result == ()","{
    // impl-start
    assume(false);
    ()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0219,verus,numpy_triple,linalg_LinAlgError,,"Generic Python-exception-derived object raised by linalg functions.
Error checking predicate for linear algebra operations.
Specification: Linear algebra error detection correctly identifies error conditions.

/* Linear algebra error type representing conditions that prevent correct execution of linalg functions */

/* Error when numerical algorithm fails to converge */

/* Error when matrix is singular (non-invertible) */

/* Error when operation requires square matrix but input is not square */

/* Error when matrix dimensions are incompatible for the operation */

/* Error when input parameters are invalid */

/* Error when numerical computation becomes unstable */

/* Generic error for other linear algebra failures */","use vstd::prelude::*;

verus! {

pub enum LinAlgError {

    NonConvergence(String),

    SingularMatrix(String),

    NonSquareMatrix(String),

    IncompatibleDimensions(String),

    InvalidInput(String),

    NumericalInstability(String),

    Other(String),
}",,"fn check_lin_alg_error(condition: bool, error_variant: u8, message: String) -> (result: Option<LinAlgError>)
    ensures 
        condition == true ==> result.is_some(),
        condition == false ==> result == None::<LinAlgError>,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0221,verus,numpy_triple,linalg_cond,,"Compute the condition number of a matrix.

The condition number measures how sensitive the solution x is to errors in b for Ax=b.

Parameters:
- x: The matrix
- p: Order of the norm

Returns:
- c: The condition number

Compute the condition number of a square matrix using the 2-norm.

The condition number of a matrix A is defined as ||A|| * ||A^(-1)||,
where ||.|| is the matrix norm. For the 2-norm, this equals the ratio
of the largest singular value to the smallest singular value.

The condition number measures how sensitive the solution x is to errors 
in b for the linear system Ax = b. A condition number of 1 indicates
a perfectly conditioned matrix, while large condition numbers indicate
ill-conditioned matrices.

Specification: The condition number is always non-negative and is at least 1 
for any invertible matrix. This captures the fundamental mathematical 
properties of condition numbers in linear algebra.","use vstd::prelude::*;

verus! {",,"fn condition_number(x: Vec<Vec<i8>>) -> (result: i8)
    requires 
        x.len() > 0,
        forall|i: int| 0 <= i < x.len() ==> x[i].len() == x.len(),
    ensures 
        result as int >= 0,
        result as int >= 1,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0222,verus,numpy_triple,linalg_cross,,"numpy.linalg.cross: Return the cross product of 3-element vectors.

Computes the cross product of two 3-element vectors. The cross product
of two vectors a and b is a vector perpendicular to both a and b.

For 3D vectors a = [a₀, a₁, a₂] and b = [b₀, b₁, b₂], the cross product
is defined as:
a × b = [a₁b₂ - a₂b₁, a₂b₀ - a₀b₂, a₀b₁ - a₁b₀]

This follows the right-hand rule convention.

Specification: numpy.linalg.cross returns the cross product of two 3D vectors.

Precondition: True (both vectors must be 3-dimensional, enforced by type)

Postcondition: The result is a 3D vector where:
- result[0] = x1[1] * x2[2] - x1[2] * x2[1]
- result[1] = x1[2] * x2[0] - x1[0] * x2[2]  
- result[2] = x1[0] * x2[1] - x1[1] * x2[0]

The cross product has the mathematical property that it is perpendicular
to both input vectors (i.e., result · x1 = 0 and result · x2 = 0).","use vstd::prelude::*;

verus! {",,"fn numpy_linalg_cross(x1: [i8; 3], x2: [i8; 3]) -> (result: [i8; 3])
    ensures
        result[0] as int == x1[1] as int * x2[2] as int - x1[2] as int * x2[1] as int,
        result[1] as int == x1[2] as int * x2[0] as int - x1[0] as int * x2[2] as int,
        result[2] as int == x1[0] as int * x2[1] as int - x1[1] as int * x2[0] as int","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0223,verus,numpy_triple,linalg_det,,"Compute the determinant of a square matrix. The determinant satisfies fundamental mathematical properties including explicit formulas for small matrices, multilinear properties, and behavior under elementary row operations.","use vstd::prelude::*;

verus! {",,"fn det(a: Vec<Vec<i8>>) -> (result: i8)
    requires 
        a.len() > 0,
        forall|i: int| 0 <= i < a@.len() ==> a@[i].len() == a@.len(),
    ensures
        /* For 1x1 matrices, the determinant is the single element */
        a@.len() == 1 ==> result as int == a@[0][0],
        /* For 2x2 matrices, the determinant is ad - bc */
        a@.len() == 2 ==> result as int == a@[0][0] * a@[1][1] - a@[0][1] * a@[1][0],","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0224,verus,numpy_triple,linalg_diagonal,,"numpy.linalg.diagonal: Returns specified diagonals of a matrix.

Extracts the diagonal elements from a matrix. The offset parameter
controls which diagonal to extract:
- offset = 0: main diagonal (elements at position [i,i])
- offset > 0: diagonals above the main diagonal (elements at [i,i+offset])
- offset < 0: diagonals below the main diagonal (elements at [i-offset,i])

For simplicity, we return a vector of size min(m,n) which is valid for offset=0.
The actual diagonal length depends on the offset value and matrix dimensions.

Specification: numpy.linalg.diagonal returns the diagonal elements of a matrix.

Precondition: The matrix must be non-empty (both dimensions > 0)
Postcondition: The result contains the diagonal elements extracted from the matrix.
               - For offset = 0: result[i] = x[i][i] (main diagonal)
               - The result vector has the same type as the input matrix elements
               - The extraction respects the mathematical definition of matrix diagonals","use vstd::prelude::*;

verus! {",,"spec fn spec_min(a: int, b: int) -> int {
    if a <= b { a } else { b }
}

fn numpy_diagonal(x: Vec<Vec<f32>>, offset: i32) -> (result: Vec<f32>)
    requires 
        x@.len() > 0,
        x@.len() < usize::MAX,
        forall|i: int| 0 <= i < x@.len() ==> #[trigger] x@[i].len() > 0,
        forall|i: int| 0 <= i < x@.len() ==> #[trigger] x@[i].len() == x@[0].len(),
    ensures
        result@.len() == spec_min(x@.len() as int, x@[0].len() as int),
        offset == 0 ==> forall|i: int| 0 <= i < result@.len() ==> 
            result@[i] == x@[i][i],
        forall|i: int| 0 <= i < result@.len() ==> 
            exists|r: int, c: int| 
                0 <= r < x@.len() && 0 <= c < x@[0].len() &&
                #[trigger] result@[i] == x@[r][c],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0225,verus,numpy_triple,linalg_eig,,"Compute the eigenvalues and right eigenvectors of a square matrix.

For a square matrix A, this function computes vectors v and scalars λ such that:
A * v = λ * v

Returns a pair (eigenvalues, eigenvectors) where:
- eigenvalues: Vector of eigenvalues λ_i
- eigenvectors: Matrix where column i is the eigenvector corresponding to eigenvalue λ_i

Specification: eig computes the eigenvalues and right eigenvectors of a square matrix.

The fundamental eigenvalue equation is: A * v = λ * v, where:
- A is the input matrix
- v is an eigenvector (non-zero vector)
- λ is the corresponding eigenvalue

This specification captures the mathematical properties of eigenvalues and eigenvectors:
1. The eigenvalue equation holds for each eigenvalue-eigenvector pair
2. Eigenvectors are normalized (unit length) 
3. For diagonal matrices, eigenvalues are the diagonal elements
4. Identity matrix has eigenvalue 1 with multiplicity n

/* Main eigenvalue equation: A * v = λ * v (simplified specification) */

/* Placeholder for eigenvalue equation */

/* For diagonal matrices, eigenvalues are diagonal elements */

/* Eigenvectors are non-zero */","use vstd::prelude::*;

verus! {",,"fn eig(a: Vec<Vec<f32>>) -> (result: (Vec<f32>, Vec<Vec<f32>>))
    requires 
        a.len() > 0,
        forall|i: int| 0 <= i < a.len() ==> a@[i].len() == a.len(),
    ensures
        result.0.len() == a.len() && result.1.len() == a.len(),
        forall|i: int| 0 <= i < result.1.len() ==> result.1@[i].len() == a.len(),

        true,

        (forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() && i != j ==> a@[i]@[j] == 0.0f32) ==> 
        (forall|i: int| #![trigger a@[i]] 0 <= i < a.len() ==> 
            exists|j: int| 0 <= j < result.0.len() && result.0@[j] == a@[i]@[i]),

        forall|col: int| #![trigger result.1@[col]] 0 <= col < a.len() ==> 
            exists|row: int| 0 <= row < a.len() && result.1@[row]@[col] != 0.0f32,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0226,verus,numpy_triple,linalg_eigh,,"Compute eigenvalues and eigenvectors of a Hermitian or symmetric matrix.

Returns the eigenvalues and eigenvectors of a complex Hermitian or symmetric matrix.
The function takes a Hermitian or symmetric matrix and returns eigenvalues in ascending order
and the normalized eigenvectors satisfying the eigenvalue equation.","use vstd::prelude::*;

verus! {",,"struct EighResult {
    eigenvalues: Vec<f32>,
    eigenvectors: Vec<Vec<f32>>,
}

fn eigh(a: Vec<Vec<f32>>) -> (result: EighResult)
    requires 
        a.len() > 0,
        forall|i: int| 0 <= i < a.len() ==> a[i]@.len() == a.len(),
        forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() ==> a[i][j] == a[j][i],
    ensures
        result.eigenvalues.len() == a.len(),
        result.eigenvectors.len() == a.len(),
        forall|i: int| 0 <= i < result.eigenvectors.len() ==> result.eigenvectors[i]@.len() == a.len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0227,verus,numpy_triple,linalg_eigvals,,"Compute the eigenvalues of a general square matrix

Specification: eigvals computes eigenvalues of a square matrix","use vstd::prelude::*;

verus! {
/* Complex number type for eigenvalues */
struct Complex {
    re: f64,
    im: f64,
}

/* Matrix represented as a vector of vectors (rows) */
type Matrix<T> = Vec<Vec<T>>;",,"fn eigvals(a: &Matrix<f64>) -> (result: Vec<Complex>)
    requires 
        a@.len() > 0,
        forall|i: int| 0 <= i < a@.len() ==> a@[i].len() == a@.len(),
    ensures
        result@.len() == a@.len()","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0228,verus,numpy_triple,linalg_eigvalsh,,"Compute the eigenvalues of a complex Hermitian or real symmetric matrix

Compute the eigenvalues of a real symmetric matrix.
Returns eigenvalues in ascending order without computing eigenvectors.
This is the eigenvalues-only version of the symmetric eigenvalue problem.

Specification: eigvalsh computes eigenvalues of a real symmetric matrix.

The eigenvalues are real (since the matrix is symmetric) and returned in ascending order.
Key mathematical properties:
1. The eigenvalues are real for symmetric matrices
2. They are returned in ascending order
3. The trace equals the sum of eigenvalues
4. The determinant equals the product of eigenvalues
5. For the identity matrix, all eigenvalues are 1
6. For diagonal matrices, eigenvalues are the diagonal elements (sorted)
7. Matrix symmetry: a[i][j] = a[j][i] for all i,j","use vstd::prelude::*;

verus! {",,"fn eigvalsh(a: Vec<Vec<i8>>) -> (eigenvals: Vec<i8>)
    requires
        a.len() > 0,
        forall|i: int| 0 <= i < a.len() ==> a[i].len() == a.len(),
        forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() ==> a[i][j] == a[j][i],
    ensures
        eigenvals.len() == a.len(),
        /* Eigenvalues are in ascending order */
        forall|i: int, j: int| 0 <= i < j < eigenvals.len() ==> eigenvals[i] <= eigenvals[j],
        /* Identity matrix has all eigenvalues equal to 1 */
        (forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() ==> 
            a[i][j] == (if i == j { 1i8 } else { 0i8 })) ==> 
            (forall|i: int| 0 <= i < eigenvals.len() ==> eigenvals[i] == 1i8),
        /* Zero matrix has all eigenvalues equal to 0 */
        (forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() ==> a[i][j] == 0i8) ==> 
            (forall|i: int| 0 <= i < eigenvals.len() ==> eigenvals[i] == 0i8)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0230,verus,numpy_triple,linalg_lstsq,,"Return the least-squares solution to a linear matrix equation.

Solves the equation a @ x = b by minimizing ||b - ax||^2.

Parameters:
- a: Coefficient matrix (M, N)
- b: Ordinate values (M,) or (M, K)
- rcond: Cut-off ratio for small singular values

Returns tuple of:
- x: Least-squares solution
- residuals: Sums of squared residuals
- rank: Rank of matrix a
- s: Singular values of a","use vstd::prelude::*;

verus! {",,"fn lstsq(a: Vec<Vec<f32>>, b: Vec<f32>) -> (result: Vec<f32>)
    requires 
        a.len() > 0,
        b.len() > 0,
        a.len() == b.len(),
        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i].len() > 0,
        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i].len() == a[0].len(),
    ensures
        result.len() == a[0].len()","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0231,verus,numpy_triple,linalg_matmul,,"Matrix multiplication for 2D matrices. Computes the matrix product of two 2D arrays following standard matrix multiplication rules. The result matrix C has dimensions (m x p) where A is (m x n) and B is (n x p).

Specification: Matrix multiplication produces a result where each element is the dot product of the corresponding row from the first matrix and column from the second matrix.

Mathematical properties:
1. Dimensions are compatible: A is m×n, B is n×p, result is m×p
2. Each element C[i][j] = sum of A[i][k] * B[k][j] for k from 0 to n-1
3. The operation preserves the fundamental matrix multiplication identity
4. Non-commutativity: A*B ≠ B*A in general (handled by type system)
5. Associativity: (A*B)*C = A*(B*C) when dimensions are compatible","use vstd::prelude::*;

verus! {",,"fn matmul(A: Vec<Vec<i8>>, B: Vec<Vec<i8>>) -> (result: Vec<Vec<i8>>)
    requires
        A.len() > 0,
        B.len() > 0,
        A@[0].len() == B.len(),
        forall|i: int| 0 <= i < A.len() ==> #[trigger] A@[i].len() == A@[0].len(),
        forall|i: int| 0 <= i < B.len() ==> #[trigger] B@[i].len() == B@[0].len(),
    ensures
        result.len() == A.len(),
        result.len() > 0 ==> result@[0].len() == B@[0].len(),
        forall|i: int| 0 <= i < result.len() ==> #[trigger] result@[i].len() == B@[0].len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0232,verus,numpy_triple,linalg_matrix_norm,,"Compute matrix norm of a matrix (Frobenius norm by default)

Specification: matrix_norm computes the Frobenius norm of a matrix 
The Frobenius norm is the square root of the sum of squares of all elements.

Properties:
1. Non-negativity: norm is always ≥ 0
2. Zero property: norm is 0 iff all elements are 0
3. Homogeneity: norm(c*A) = |c| * norm(A) for scalar c
4. Triangle inequality: norm(A + B) ≤ norm(A) + norm(B)
5. Submultiplicativity: norm(A) dominates the absolute value of any element","use vstd::prelude::*;

verus! {
spec fn abs_val(x: int) -> int {
    if x >= 0 { x } else { -x }
}",,"fn matrix_norm(x: Vec<Vec<i8>>) -> (result: i8)
    requires 
        x@.len() > 0,
        forall|i: int| 0 <= i < x@.len() ==> #[trigger] x@[i].len() > 0,
        forall|i: int| 0 <= i < x@.len() ==> #[trigger] x@[i].len() == x@[0].len(),
    ensures
        result as int >= 0,
        (result as int == 0) == (forall|i: int, j: int| 
            0 <= i < x@.len() && 0 <= j < x@[i].len() ==> #[trigger] x@[i][j] == 0),
        forall|i: int, j: int| 
            0 <= i < x@.len() && 0 <= j < x@[i].len() ==> abs_val(#[trigger] x@[i][j] as int) <= result as int,
        (exists|i: int, j: int| 
            0 <= i < x@.len() && 0 <= j < x@[i].len() && #[trigger] x@[i][j] != 0) ==> result as int > 0,","{
    // impl-start
    assume(false);
    0i8
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0233,verus,numpy_triple,linalg_matrix_power,,"numpy.linalg.matrix_power: Raise a square matrix to the (integer) power n.

For positive integers n, the power is computed by repeated matrix squarings and 
matrix multiplications. If n == 0, the identity matrix is returned. 
If n < 0, the inverse is computed and raised to abs(n).

This implements the mathematical operation A^n for square matrices A.
The operation follows the standard mathematical definition:
- A^0 = I (identity matrix)
- A^1 = A
- A^n = A * A^(n-1) for n > 1
- A^(-n) = (A^(-1))^n for n < 0

Specification: matrix_power raises a square matrix to an integer power.

Precondition: The matrix A must be square (n×n). For negative powers,
the matrix must be invertible (non-singular).

Postcondition: The result satisfies the mathematical definition of matrix exponentiation:
1. For exp = 0: result is the identity matrix
2. For exp = 1: result equals the input matrix A
3. For exp > 1: result = A * A^(exp-1) (recursive definition)
4. For exp < 0: result = (A^(-1))^|exp| (inverse raised to absolute value)

Mathematical properties:
- A^0 = I (identity matrix) for any square matrix A
- A^1 = A for any square matrix A
- A^m * A^n = A^(m+n) for any integers m, n (when A is invertible for negative powers)
- (A^m)^n = A^(m*n) for any integers m, n (when A is invertible for negative powers)
- If A is invertible, then A^(-1) * A = A * A^(-1) = I
- Matrix power preserves the dimension: n×n input produces n×n output

This captures the complete mathematical characterization of matrix exponentiation.","use vstd::prelude::*;

verus! {",,"fn matrix_power(a: Vec<Vec<i8>>) -> (result: Vec<Vec<i8>>)
    requires 
        a.len() > 0,
        forall|i: int| 0 <= i < a.len() ==> a@[i].len() == a.len(),
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < result.len() ==> result@[i].len() == a.len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0234,verus,numpy_triple,linalg_matrix_rank,,"numpy.linalg.matrix_rank: Return matrix rank of array using SVD method.

The rank of a matrix is the number of linearly independent columns
(or rows). For numerical computation, this is determined by counting
the number of singular values greater than a threshold.

This implementation focuses on the core mathematical behavior for
square matrices, using default tolerance.

Specification: matrix_rank computes the rank of a matrix using SVD method.

The rank is the number of singular values greater than a numerical threshold.
This corresponds to the number of linearly independent columns (or rows).

Mathematical definition:
- For a matrix A, rank(A) = number of non-zero singular values
- In numerical computation, ""non-zero"" means above a threshold

Key properties verified:
1. Bounds: 0 ≤ rank(A) ≤ min(m, n) for m×n matrix
2. Zero matrix: rank(0) = 0 (all elements zero)
3. Identity matrix: rank(I) = n for n×n identity matrix
4. Rank deficiency: If a row/column is all zeros, rank < full rank
5. Linear dependence: If rows/columns are linearly dependent, rank < full rank

The threshold behavior ensures numerical stability but is not explicitly
specified here for simplicity.

/* Zero matrix has rank 0 */

/* Identity matrix has full rank */

/* For 1x1 matrices */","use vstd::prelude::*;

verus! {",,"spec fn min_usize(a: usize, b: usize) -> usize {
    if a <= b { a } else { b }
}

fn matrix_rank(A: Vec<Vec<f32>>) -> (result: usize)
    requires 
        A.len() > 0,
        A[0].len() > 0,
        forall|i: int| 0 <= i < A.len() ==> #[trigger] A[i as int].len() == A[0].len(),
    ensures
        result <= min_usize(A.len(), A[0].len()),

        (forall|i: int, j: int| 0 <= i < A.len() && 0 <= j < A[0].len() ==> #[trigger] A[i as int][j as int] == 0.0f32) ==> result == 0,

        (A.len() == A[0].len() && forall|i: int, j: int| 0 <= i < A.len() && 0 <= j < A[0].len() ==> #[trigger] A[i as int][j as int] == (if i == j { 1.0f32 } else { 0.0f32 })) ==> result == A.len(),

        (A.len() == 1 && A[0].len() == 1) ==> ((result == 1) <==> (A[0][0] != 0.0f32)),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0235,verus,numpy_triple,linalg_matrix_transpose,,"numpy.linalg.matrix_transpose: Transposes a matrix (or a stack of matrices).

For a 2D matrix, this operation swaps the rows and columns.
The element at position (i, j) in the input matrix becomes the element
at position (j, i) in the output matrix.

Input: A matrix with rows × cols dimensions
Output: A matrix with cols × rows dimensions (transposed)

Specification: numpy.linalg.matrix_transpose returns the transpose of the input matrix.

For a matrix x with dimensions rows × cols, the transpose x_T has dimensions cols × rows.
The element at position (i, j) in the original matrix x becomes the element at position (j, i) in x_T.

Precondition: True (no special preconditions for matrix transpose)
Postcondition: For all valid indices i and j, x_T[j][i] = x[i][j]","use vstd::prelude::*;

verus! {",,"fn numpy_matrix_transpose(x: Vec<Vec<f32>>) -> (result: Vec<Vec<f32>>)
    requires 
        x@.len() > 0,
        forall|i: int| 0 <= i < x@.len() ==> x@[i].len() > 0,
        forall|i: int, j: int| 0 <= i < x@.len() && 0 <= j < x@.len() ==> x@[i].len() == x@[j].len(),
    ensures
        result@.len() == (if x@.len() > 0 { x@[0].len() } else { 0 }),
        forall|i: int| 0 <= i < result@.len() ==> result@[i].len() == x@.len(),
        forall|i: int, j: int| 0 <= i < x@.len() && 0 <= j < x@[0].len() ==> result@[j][i] == x@[i][j],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0236,verus,numpy_triple,linalg_multi_dot,,"Multi-dot product: compute the dot product of multiple matrices in a single function call
with optimal parenthesization. This function performs a chain of matrix multiplications
A₁ × A₂ × ... × Aₙ where the parenthesization is chosen to minimize computational cost.

For three matrices A, B, C, this computes A × B × C with the optimal evaluation order.
The result is independent of parenthesization due to associativity of matrix multiplication.

Specification: Multi-dot performs a chain of matrix multiplications with optimal parenthesization.

Mathematical properties:
1. Associativity: (A × B) × C = A × (B × C) - the result is independent of parenthesization
2. Dimension compatibility: A is n₁×n₂, B is n₂×n₃, C is n₃×n₄, result is n₁×n₄
3. Element-wise computation: result[i][j] equals the triple sum over intermediate indices
4. Optimal evaluation order: the implementation chooses the parenthesization that minimizes 
   the total number of scalar multiplications needed
5. Correctness: the result equals the sequential application of matrix multiplications
6. Non-empty constraint: at least two matrices are required (enforced by signature)

This specification captures the essential mathematical behavior while abstracting away 
the optimization details. The key insight is that matrix multiplication is associative,
so different parenthesizations yield the same mathematical result.","use vstd::prelude::*;

verus! {",,"fn multi_dot(A: Vec<Vec<i8>>, B: Vec<Vec<i8>>, C: Vec<Vec<i8>>) -> (result: Vec<Vec<i8>>)
    requires 
        A.len() > 0,
        B.len() > 0, 
        C.len() > 0,
        forall|i: int| 0 <= i < A.len() ==> A[i]@.len() == B@.len(),
        forall|i: int| 0 <= i < B.len() ==> B[i]@.len() == C@.len(),
        forall|i: int| 0 <= i < C.len() ==> C[i]@.len() > 0,
    ensures
        result@.len() == A@.len(),
        forall|i: int| 0 <= i < result@.len() ==> result[i]@.len() == C[0]@.len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0237,verus,numpy_triple,linalg_norm,,"numpy.linalg.norm: Compute the 2-norm (Euclidean norm) of a vector.

This is the default vector norm when ord=None. For a vector x,
the 2-norm is defined as: ||x||_2 = sqrt(sum(x[i]^2))

This implementation focuses on the most common use case: computing
the Euclidean norm of a 1D vector.

Specification: norm computes the Euclidean norm (2-norm) of a vector.

The 2-norm is defined as the square root of the sum of squares of all elements.
This is the most common vector norm used in numerical computing and is the
default norm in NumPy when ord=None.

Mathematical definition:
- For a vector x = [x₁, x₂, ..., xₙ], the 2-norm is: ||x||₂ = √(Σᵢ xᵢ²)

Key properties verified:
1. Definition: result equals sqrt of sum of squared elements
2. Non-negativity: norm(x) ≥ 0 for all x
3. Definiteness: norm(x) = 0 if and only if x is the zero vector
4. Empty vector: norm of empty vector is 0

Note: Properties like triangle inequality and homogeneity follow from
the definition but are not explicitly stated in this specification.","use vstd::prelude::*;

verus! {",,"fn norm(x: Vec<i8>) -> (result: i8)
    requires true,
    ensures true,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0238,verus,numpy_triple,linalg_outer,,"Compute the outer product of two vectors.
Given vectors a of size m and b of size n, produces an m×n matrix
where element (i,j) equals a[i] * b[j].

Specification: The outer product produces a matrix where each element (i,j)
is the product of the i-th element of the first vector and the j-th element
of the second vector. This captures the fundamental mathematical property
that outer(a,b)[i,j] = a[i] * b[j].

The specification includes:
1. Core property: Each matrix element equals the product of corresponding vector elements
2. Row structure: Each row i is the vector b scaled by a[i]
3. Column structure: Each column j is the vector a scaled by b[j]
4. Bilinearity: The outer product is linear in both arguments

This captures the essential mathematical behavior of the outer product operation,
which is fundamental in linear algebra and tensor analysis.","use vstd::prelude::*;

verus! {",,"fn outer_i32(a: Vec<i8>, b: Vec<i8>) -> (result: Vec<Vec<i8>>)
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i].len() == b.len(),
        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result[i].len() ==> 
            result[i][j] as int == a[i] as int * b[j] as int,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0239,verus,numpy_triple,linalg_pinv,,"numpy.linalg.pinv: Compute the (Moore-Penrose) pseudo-inverse of a matrix.

Calculate the generalized inverse of a matrix using its
singular-value decomposition (SVD) and including all
large singular values.

For a matrix A, the pseudo-inverse A+ is defined as the matrix that
'solves' the least-squares problem Ax = b. If A is invertible,
then pinv(A) == inv(A).

The pseudo-inverse has the property that A * A+ * A = A and
A+ * A * A+ = A+ (Moore-Penrose conditions).

Specification: pinv computes the Moore-Penrose pseudo-inverse of a matrix.

The pseudo-inverse satisfies the fundamental Moore-Penrose conditions:
1. A * A+ * A = A  (the pseudo-inverse is a generalized inverse)
2. A+ * A * A+ = A+  (the pseudo-inverse is reflexive)
3. (A * A+)† = A * A+  (A * A+ is Hermitian)
4. (A+ * A)† = A+ * A  (A+ * A is Hermitian)

For practical purposes, we focus on the first two conditions and
the dimensional correctness.

Precondition: True (pinv is defined for any matrix)
Postcondition: The result is the pseudo-inverse with correct dimensions
and satisfies the Moore-Penrose conditions.","use vstd::prelude::*;

verus! {",,"fn pinv(a: Vec<Vec<f32>>) -> (result: Vec<Vec<f32>>)
    requires 
        a@.len() > 0,
        forall|i: int| 0 <= i < a@.len() ==> a@[i].len() > 0,
    ensures 
        result@.len() > 0,
        forall|i: int| 0 <= i < result@.len() ==> result@[i].len() == a@.len(),
        (forall|i: int, j: int| (0 <= i < a@.len() && 0 <= j < a@[i].len()) ==> a@[i][j] == 0.0f32) ==> 
            (forall|i: int, j: int| (0 <= i < result@.len() && 0 <= j < result@[i].len()) ==> result@[i][j] == 0.0f32)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0241,verus,numpy_triple,linalg_slogdet,,"Compute the sign and (natural) logarithm of the determinant of a square matrix.

This function is more numerically stable than computing log(det(a)) directly,
especially for very small or very large determinants.

For real matrices, the sign is -1, 0, or 1.
For complex matrices, the sign has absolute value 1 (on the unit circle) or 0.

The determinant can be recovered as: det = sign * exp(logabsdet)

Specification: slogdet computes the sign and natural logarithm of the determinant

The function returns a tuple (sign, logabsdet) where:
- sign is -1, 0, or 1 for real matrices
- logabsdet is the natural log of the absolute value of the determinant
- The original determinant can be recovered as: det = sign * exp(logabsdet)
- The function provides a numerically stable way to compute logarithms of determinants","use vstd::prelude::*;

verus! {",,"fn slogdet(a: Vec<Vec<f32>>) -> (result: (f32, f32))
    requires 
        a@.len() > 0,
        forall|i: int| 0 <= i < a@.len() ==> #[trigger] a@[i].len() == a@.len(),
    ensures ({
        let (sign, logabsdet) = result;
        (sign == -1.0f32 || sign == 0.0f32 || sign == 1.0f32)
    }),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0242,verus,numpy_triple,linalg_solve,,"Solve a linear matrix equation ax = b, where a is an n×n matrix and b is a vector.
Returns the solution vector x such that ax = b.
For non-empty matrices (n > 0), the solution exists and is unique when a is invertible.

Specification: solve returns a vector x such that ax = b when a is invertible.
This specification captures the mathematical properties of linear system solving:

1. **Correctness**: The solution satisfies the matrix equation ax = b
2. **Invertibility requirement**: Matrix a must be invertible (non-singular)
3. **Uniqueness**: The solution is unique when it exists
4. **Mathematical consistency**: The solution preserves linear algebra properties

The specification handles the general case where:
- a is an n×n square matrix (represented as Vector of Vector Float)
- b is an n-dimensional vector
- The solution x is unique when a is invertible","use vstd::prelude::*;

verus! {",,"fn solve(a: Vec<Vec<f64>>, b: Vec<f64>) -> (result: Vec<f64>)
    requires 
        a.len() > 0,
        a.len() == b.len(),
        forall|i: int| 0 <= i < a.len() ==> a[i].len() == a.len(),
        /* Matrix a is invertible - there exists an inverse matrix a_inv such that a * a_inv = I and a_inv * a = I */
        exists|a_inv: Seq<Seq<f64>>| 
            a_inv.len() == a.len() &&
            forall|k: int| 0 <= k < a_inv.len() ==> a_inv[k].len() == a.len(),
    ensures
        result.len() == a.len(),
        /* Primary property: The solution satisfies ax = b */
        /* For each row i, the sum of products a[i][j] * result[j] equals b[i] */
        true, /* Placeholder for matrix equation ax = b */
        /* Uniqueness: The solution is unique */
        /* If any other vector y also satisfies ay = b, then y = result */
        true, /* Placeholder for uniqueness property */
        /* Mathematical consistency: The solution can be expressed as x = a^(-1)b */
        true /* Placeholder for inverse relationship */","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0243,verus,numpy_triple,linalg_svd,,"numpy.linalg.svd: Singular Value Decomposition.

Computes the singular value decomposition of a matrix, factorizing it as
A = U @ diag(S) @ Vh, where U and Vh are unitary matrices and S is a 
vector of singular values sorted in descending order.

This specification focuses on the 2D case with full_matrices=False
and compute_uv=True (the most common use case).

The decomposition satisfies: A = U @ diag(S) @ Vh
where U has orthonormal columns, Vh has orthonormal rows,
and S contains non-negative singular values in descending order.

Specification: numpy.linalg.svd returns matrices U, S, Vh such that:

1. Matrix reconstruction: A = U @ diag(S) @ Vh
2. U has orthonormal columns (U^T @ U = I)
3. Vh has orthonormal rows (Vh @ Vh^T = I)  
4. S contains non-negative singular values in descending order

This captures the essential mathematical properties of SVD as implemented in NumPy.

Precondition: True (SVD is defined for any real matrix)
Postcondition: The returned decomposition satisfies all SVD properties","use vstd::prelude::*;

verus! {",,"fn numpy_svd(a: Vec<Vec<f32>>) -> (result: (Vec<Vec<f32>>, Vec<f32>, Vec<Vec<f32>>))
    requires
        a.len() > 0,
        forall|i: int| 0 <= i < a.len() ==> a@[i].len() > 0,
        forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() ==> a@[i].len() == a@[j].len(),
    ensures
        ({
            let (u, s, vh) = result;
            let m = a.len() as int;
            let n = a@[0].len() as int;
            let min_mn = if m <= n { m } else { n };
            
            /* Basic structural properties */
            (u.len() == m) &&
            (s.len() == min_mn) &&
            (vh.len() == min_mn) &&
            (forall|i: int| 0 <= i < u.len() ==> u@[i].len() == min_mn) &&
            (forall|i: int| 0 <= i < vh.len() ==> vh@[i].len() == n)
        })","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0244,verus,numpy_triple,linalg_svdvals,,"numpy.linalg.svdvals: Compute singular values of a matrix.

Computes the singular values of a matrix without computing the U and V matrices.
The singular values are the square roots of the eigenvalues of A^T @ A (or A @ A^T),
returned in descending order.

This is equivalent to calling numpy.linalg.svd(x, compute_uv=False).
For an m×n matrix, this returns min(m,n) singular values.

Specification: svdvals returns the singular values of the input matrix.

The singular values are:
1. Non-negative real numbers
2. Sorted in descending order
3. Square roots of eigenvalues of x^T @ x
4. Measure the ""magnitude"" of the matrix in each singular direction

Precondition: True (singular values are defined for any matrix)
Postcondition: Returns singular values in descending order with mathematical properties","use vstd::prelude::*;

verus! {",,"spec fn min_nat(a: nat, b: nat) -> nat {
    if a <= b { a } else { b }
}

fn svdvals(x: Vec<Vec<i8>>) -> (result: Vec<i8>)
    requires 
        x@.len() > 0,
        x@.len() < usize::MAX,
        x@[0].len() > 0,
    ensures 
        result@.len() == min_nat(x@.len() as nat, x@[0].len() as nat),
        /* Property 1: All singular values are non-negative */
        forall|i: int| 0 <= i < result@.len() ==> #[trigger] result@[i] >= 0,
        /* Property 2: Singular values are sorted in descending order */
        forall|i: int, j: int| 0 <= i <= j < result@.len() ==> #[trigger] result@[i] >= #[trigger] result@[j],
        /* Property 4: If the matrix is zero, all singular values are zero */
        (forall|i: int, j: int| 0 <= i < x@.len() && 0 <= j < x@[i].len() ==> #[trigger] x@[i][j] == 0) ==>
            (forall|i: int| 0 <= i < result@.len() ==> #[trigger] result@[i] == 0)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0245,verus,numpy_triple,linalg_tensordot,,"numpy.tensordot: Compute tensor dot product along specified axes.

Given two tensors a and b, and axes, sums the products of a's and b's 
elements over the axes specified. For 1-D arrays (vectors) with axes=1,
this computes the inner product of vectors.

This specification focuses on the 1-D case with axes=1, which is equivalent
to the dot product operation.

Specification: tensordot computes the tensor dot product along specified axes.

For 1-D vectors with axes=1, this is equivalent to the inner product:
result = sum(a[i] * b[i] for i in 0..n-1)

Mathematical properties:
- Commutative: tensordot(a, b, 1) = tensordot(b, a, 1)
- Bilinear: tensordot(α*a + β*c, b, 1) = α*tensordot(a, b, 1) + β*tensordot(c, b, 1)
- Zero vector: tensordot(zeros, b, 1) = 0
- Self-product: tensordot(a, a, 1) = ||a||²

Precondition: axes = 1 (for 1-D vector case)
Postcondition: result equals the sum of element-wise products","use vstd::prelude::*;

verus! {",,"spec fn dot_product_recursive(a: Seq<i32>, b: Seq<i32>, i: nat) -> int
    decreases a.len() - i
{
    if i >= a.len() {
        0
    } else {
        a[i as int] * b[i as int] + dot_product_recursive(a, b, i + 1)
    }
}

spec fn dot_product(a: Seq<i32>, b: Seq<i32>) -> int {
    dot_product_recursive(a, b, 0)
}

fn tensordot(a: Vec<i32>, b: Vec<i32>, axes: usize) -> (result: i32)
    requires 
        a.len() == b.len(),
        axes == 1,
    ensures result == dot_product(a@, b@)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0246,verus,numpy_triple,linalg_tensorinv,,"Compute the 'inverse' of an N-dimensional array

The result is an inverse for a relative to the tensordot operation tensordot(a, b, ind), i.e., up to floating-point accuracy, tensordot(tensorinv(a), a, ind) is the identity tensor.

Compute the 'inverse' of an N-dimensional array.
For simplicity, we implement the case where the tensor is represented as a 2D matrix
(viewed as a flattened N-dimensional array) and we compute its matrix inverse.
The result should be the inverse for the tensordot operation.

Specification: tensorinv computes the tensor inverse such that when composed
with the original tensor via tensordot operation, it yields the identity tensor.
The key properties are:
1. The result has the same square dimensions as the input
2. The tensor inverse, when applied via tensordot, acts as a left inverse
3. The tensor must be 'square' (equal first and last dimensions products)
4. The index parameter must be positive","use vstd::prelude::*;

verus! {",,"fn tensorinv(a: Vec<Vec<f32>>, ind: usize) -> (result: Vec<Vec<f32>>)
    requires 
        a.len() > 0,
        ind > 0,
        forall|i: int| 0 <= i < a@.len() ==> a[i].len() == a.len(),
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < result@.len() ==> result[i].len() == a.len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0247,verus,numpy_triple,linalg_tensorsolve,,"Solve the tensor equation a x = b for x.

This function solves for x in the tensor equation a x = b, where:
- a is a coefficient tensor that can be reshaped to a square matrix
- b is the right-hand tensor  
- x is the solution tensor

For simplicity, we model this as solving a square linear system where the 
coefficient matrix a is reshaped from tensor form to a 2D matrix, and the 
solution is reshaped back to tensor form.

Specification: tensorsolve solves the tensor equation a x = b for x.

This specification captures the mathematical properties of tensor equation solving:

1. **Correctness**: The solution x satisfies the matrix equation a x = b
2. **Invertibility**: The coefficient matrix a must be invertible
3. **Uniqueness**: The solution is unique when a is invertible

The specification handles the basic case where:
- a is an n×n coefficient matrix (representing a reshaped tensor)
- b is an n-dimensional right-hand vector
- x is the n-dimensional solution vector","use vstd::prelude::*;

verus! {",,"spec fn is_square_matrix(a: Seq<Seq<f64>>) -> bool {
    a.len() > 0 && forall|i: int| 0 <= i < a.len() ==> a[i].len() == a.len()
}

spec fn is_invertible_matrix(a: Seq<Seq<f64>>) -> bool {
    is_square_matrix(a) &&
    exists|a_inv: Seq<Seq<f64>>| 
        is_square_matrix(a_inv) && 
        a_inv.len() == a.len() &&
        forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() ==> #[trigger] a[i][j] == a[i][j]
}

fn tensorsolve(a: Vec<Vec<f64>>, b: Vec<f64>) -> (result: Vec<f64>)
    requires
        a.len() > 0,
        forall|i: int| 0 <= i < a@.len() ==> a@[i].len() == a@.len(),
        b@.len() == a@.len(),
        is_square_matrix(a@.map(|i, row: Vec<f64>| row@)),
        is_invertible_matrix(a@.map(|i, row: Vec<f64>| row@)),
    ensures
        result@.len() == b@.len(),
        forall|i: int| 0 <= i < a@.len() ==> #[trigger] b@[i] == b@[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0248,verus,numpy_triple,linalg_trace,,"Return the sum along diagonals of the array

If a is 2-D, returns the sum along the diagonal. If a has more dimensions, then axes along which the trace is taken can be specified.

Returns the sum along the main diagonal of a square matrix.
The trace is the sum of diagonal elements at positions (i, i) for i = 0 to n-1.

Specification: trace computes the sum of the main diagonal elements of a square matrix.
The trace is mathematically defined as the sum of elements x[i][i] for i from 0 to n-1.
This is a fundamental operation in linear algebra with important mathematical properties:
- trace(A + B) = trace(A) + trace(B) (linearity)
- trace(cA) = c * trace(A) (scalar multiplication)
- trace(A) = trace(A^T) (transpose invariance)","use vstd::prelude::*;

verus! {",,"fn trace(x: Vec<Vec<f32>>) -> (result: f32)
    requires 
        x@.len() > 0,
        forall|i: int| 0 <= i < x@.len() ==> x@[i].len() == x@.len(),
    ensures 
        true, /* The trace equals the sum of diagonal elements matrix[i][i] for i in 0..n-1 */
        forall|i: int| 0 <= i < x@.len() ==> x@[i][i] != 0.0f32 ==> result != 0.0f32,","{
    // impl-start
    assume(false);
    0.0
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0249,verus,numpy_triple,linalg_vecdot,,"Compute the vector dot product of two vectors

Specification: vecdot computes the mathematical dot product as the sum of element-wise products.
This captures the mathematical definition: a · b = Σ(i=0 to n-1) a_i * b_i.

Key properties:
- Commutativity: vecdot(x1, x2) = vecdot(x2, x1)
- Linearity: vecdot(c*x1, x2) = c * vecdot(x1, x2)
- Zero vector: vecdot(0, x) = 0
- Self-dot gives sum of squares: vecdot(x, x) = Σ(x_i²)","use vstd::prelude::*;

verus! {",,"spec fn dot_product_spec(x1: Seq<i32>, x2: Seq<i32>) -> int
    decreases x1.len()
{
    if x1.len() == 0 || x1.len() != x2.len() {
        0
    } else {
        x1[0] * x2[0] + dot_product_spec(x1.skip(1), x2.skip(1))
    }
}

fn vecdot(x1: Vec<i32>, x2: Vec<i32>) -> (result: i32)
    requires x1.len() == x2.len(),
    ensures 
        result as int == dot_product_spec(x1@, x2@),
        result as int == dot_product_spec(x2@, x1@)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0250,verus,numpy_triple,linalg_vector_norm,,"numpy.linalg.vector_norm: Compute the p-norm of a vector for a given order p.

This function computes vector norms of different orders (p-norms).
For a vector x and order p, the p-norm is defined as:
||x||_p = (sum(|x[i]|^p))^(1/p) for p ≥ 1

Special cases:
- p = 1: Manhattan norm (sum of absolute values)
- p = 2: Euclidean norm (square root of sum of squares)
- p = ∞: Maximum norm (largest absolute value)
- p = -∞: Minimum norm (smallest absolute value)
- p = 0: Zero norm (count of non-zero elements)

This implementation focuses on the most common p-norm cases for 1D vectors.

Specification: vector_norm computes the p-norm of a vector for various values of p.

The p-norm is a generalization of the common vector norms used in numerical computing.
This specification covers the mathematical definition and key properties of p-norms.

Mathematical definition:
- For p ≥ 1: ||x||_p = (Σᵢ |xᵢ|^p)^(1/p)
- For p = 1: ||x||_1 = Σᵢ |xᵢ| (Manhattan norm)
- For p = 2: ||x||_2 = √(Σᵢ xᵢ²) (Euclidean norm)
- For p = 0: ||x||_0 = count of non-zero elements

Key properties verified:
1. Definition: For p ≥ 1, result equals (sum of |xi|^p)^(1/p)
2. Non-negativity: norm(x, p) ≥ 0 for all x and valid p
3. Definiteness: norm(x, p) = 0 iff x is zero vector (for p > 0)
4. Special cases: p=1 (Manhattan), p=2 (Euclidean), p=0 (zero norm)
5. Empty vector: norm of empty vector is 0

Preconditions:
- p must be a non-negative real number
- For p = 0, it counts non-zero elements (special case)
- For p ≥ 1, it computes the standard p-norm","use vstd::prelude::*;

verus! {",,"fn vector_norm(x: Vec<i8>, p: i8) -> (result: i8)
    requires p as int >= 0,
    ensures 
        result as int >= 0,
        x@.len() == 0 ==> result as int == 0,
        result as int >= 0","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0251,verus,numpy_triple,logic_functions_all,,"Test whether all array elements evaluate to True.
Elements are considered True if they are non-zero.
NaN, positive infinity and negative infinity evaluate to True.

Specification: all returns True if and only if all elements are non-zero.
This includes proper handling of special float values:
- NaN evaluates to True (it is not equal to zero)
- Positive and negative infinity evaluate to True (they are not equal to zero)
- Only 0.0 and -0.0 evaluate to False

Mathematical properties:
- Empty vector returns True (vacuous truth)
- all is monotonic: if all(a) is True and b has same non-zero elements, then all(b) is True
- all(a) = not(any(map(λx. x = 0, a))) - equivalent to checking no element is zero

Sanity checks:
- For empty vector (n = 0), the result is True by vacuous truth
- For single element [x], result is True iff x ≠ 0
- For vector with all non-zero elements, result is True
- For vector with at least one zero element, result is False

Additional properties:
- Idempotent: all(all(a)) = all(a) (when treating Bool as numeric)
- Distributive over logical AND: all(a) ∧ all(b) → all(pointwise_and(a, b))
- Relationship to logical AND reduction: all(a) = fold(∧, true, map(≠ 0, a))","use vstd::prelude::*;

verus! {",,"fn all(a: Vec<f32>) -> (result: bool)
    ensures
        result == (forall|i: int| 0 <= i < a@.len() ==> a@[i] != 0.0f32),
        (a@.len() == 0 ==> result == true),
        ((exists|i: int| 0 <= i < a@.len() && a@[i] == 0.0f32) ==> result == false),
        ((forall|i: int| 0 <= i < a@.len() ==> a@[i] != 0.0f32) ==> result == true),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0252,verus,numpy_triple,logic_functions_allclose,,"numpy.allclose: Returns True if two arrays are element-wise equal within a tolerance.

The tolerance values are positive, typically very small numbers. The
relative difference (rtol * abs(b)) and the absolute difference
atol are added together to compare against the absolute difference
between a and b.

For each element, the condition is:
absolute(a - b) <= (atol + rtol * absolute(b))

This function returns True if ALL elements satisfy this condition,
False otherwise.

Specification: allclose returns true iff all elements are within tolerance.

Precondition: rtol >= 0 and atol >= 0 (tolerance values must be non-negative)
Postcondition: result = true iff all elements satisfy the tolerance condition
               abs(a[i] - b[i]) <= atol + rtol * abs(b[i]) for all i","use vstd::prelude::*;

verus! {

spec fn int_abs(x: int) -> int {
    if x >= 0 { x } else { -x }
}",,"fn allclose(a: Vec<i8>, b: Vec<i8>, rtol: i8, atol: i8) -> (result: bool)
    requires 
        a.len() == b.len(),
        rtol >= 0,
        atol >= 0,
    ensures 
        result == (forall|i: int| 0 <= i < a@.len() ==> 
            int_abs((a[i] - b[i]) as int) <= (atol as int + rtol as int * int_abs(b[i] as int)))","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0253,verus,numpy_triple,logic_functions_any,,"Test whether any element in a vector evaluates to True.

For numeric types, returns true if any element is non-zero.
Special values like NaN, positive/negative infinity are considered True.
This follows NumPy's convention where non-zero values are truthy.

This is a reduction operation that performs logical OR across all elements,
treating non-zero values as True and zero as False.

Specification: `any` returns true if and only if at least one element in the vector is non-zero.

The specification captures comprehensive mathematical properties:
1. Logical equivalence: result is true iff there exists a non-zero element
2. Completeness: result is false iff all elements are zero
3. Empty vector behavior: returns false for empty vectors
4. Monotonicity: adding more elements can only increase the chance of being true

This matches NumPy's behavior where:
- Non-zero values (including NaN, ±∞) evaluate to True
- Only zero evaluates to False
- Empty arrays return False","use vstd::prelude::*;

verus! {",,"fn any(v: Vec<f32>) -> (result: bool)
    ensures 
        (result == true <==> exists|i: int| 0 <= i < v@.len() && v@[i] != 0.0f32) &&
        (result == false <==> forall|i: int| 0 <= i < v@.len() ==> v@[i] == 0.0f32) &&
        (v@.len() == 0 ==> result == false) &&
        (forall|i: int| 0 <= i < v@.len() ==> v@[i] == 0.0f32 ==> result == false) &&
        (exists|i: int| 0 <= i < v@.len() && v@[i] != 0.0f32 ==> result == true) &&
        (result == true || result == false) &&
        !(result == true && result == false)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0254,verus,numpy_triple,logic_functions_array_equal,,"numpy.array_equal: True if two arrays have the same shape and elements, False otherwise.

Compares two arrays element-wise and returns a single boolean value indicating
whether the arrays are completely equal. Unlike element-wise comparison functions,
this returns a single boolean result for the entire comparison.

The function returns True if and only if:
1. The arrays have the same shape (enforced by Vector type system)
2. All corresponding elements are equal

For Vector types, the shape constraint is automatically satisfied by the type system,
so we only need to check element-wise equality.

Specification: numpy.array_equal returns True if and only if all corresponding 
elements in the two vectors are equal.

Precondition: True (vectors have the same length by the type system)
Postcondition: The result is True if and only if all corresponding elements are equal

Mathematical properties:
- Array equality is reflexive: arrayEqual(a, a) = True for any array a
- Array equality is symmetric: arrayEqual(a, b) = arrayEqual(b, a)
- Array equality is transitive: if arrayEqual(a, b) and arrayEqual(b, c), then arrayEqual(a, c)
- Empty arrays are equal: arrayEqual([], []) = True (vacuous truth)
- arrayEqual(a, b) = all(elementwise_equal(a, b)) - equivalent to checking all elements are equal

Sanity checks:
- For empty vectors (n = 0), the result is True by vacuous truth
- For single element vectors [x] and [y], result is True iff x == y
- For identical vectors, result is True
- For vectors differing in any element, result is False
- arrayEqual is the logical AND of all element-wise comparisons","use vstd::prelude::*;

verus! {",,"fn array_equal<T>(a1: &Vec<T>, a2: &Vec<T>) -> (result: bool)
    where T: PartialEq<T>,
    requires a1.len() == a2.len(),
    ensures 
        result == true <==> (forall|i: int| 0 <= i < a1.len() as int ==> a1@[i] == a2@[i]) &&
        (a1.len() == 0 ==> result == true) &&
        (exists|i: int| 0 <= i < a1.len() as int && !(a1@[i] == a2@[i]) ==> result == false)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0255,verus,numpy_triple,logic_functions_array_equiv,,"numpy.array_equiv: Returns True if input arrays are shape consistent and all elements equal.

Shape consistent means they are either the same shape, or one input array
can be broadcasted to create the same shape as the other one.

For 1D arrays of the same size, this means element-wise comparison.
The function returns True if all corresponding elements are equal.

Specification: array_equiv returns true iff all corresponding elements are equal.

Precondition: True (works for any two vectors of the same size)
Postcondition: result = true iff all elements at corresponding indices are equal

Mathematical properties satisfied:
- Reflexivity: array_equiv a a = true (any array is equivalent to itself)
- Symmetry: array_equiv a b = array_equiv b a (equivalence is symmetric)
- Element-wise equality: result = true iff ∀ i, a1[i] = a2[i]
- Empty array handling: for n=0, the result is vacuously true
- Finite precision: uses Float equality (may have precision limitations)","use vstd::prelude::*;

verus! {",,"fn array_equiv(a1: Vec<f32>, a2: Vec<f32>) -> (result: bool)
    requires a1.len() == a2.len(),
    ensures result == (forall|i: int| 0 <= i < a1@.len() ==> a1@[i] == a2@[i])","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0256,verus,numpy_triple,logic_functions_bitwise_and,,"Compute the bit-wise AND of two vectors element-wise.
Computes the bit-wise AND of the underlying binary representation of
the natural numbers in the input vectors.

Specification: bitwise_and computes element-wise bitwise AND operation 

This specification captures the mathematical properties of bitwise AND:
- Commutativity: a & b = b & a
- Associativity: (a & b) & c = a & (b & c)
- Identity with all bits set: a & (-1) = a (but using max value for Nat)
- Absorption with zero: a & 0 = 0
- Idempotent: a & a = a
- Monotonicity: if a ≤ b, then a & c ≤ b & c

/* Commutativity property */

/* Absorption with zero */

/* Idempotent property */

/* Result is bounded by both operands */","use vstd::prelude::*;

verus! {",,"fn bitwise_and(x1: &Vec<u8>, x2: &Vec<u8>) -> (result: Vec<u8>)
    requires x1@.len() == x2@.len(),
    ensures 
        result@.len() == x1@.len(),
        forall|i: int| 0 <= i < result@.len() ==> 
            result@[i] == (x1@[i] & x2@[i]) &&

            (x1@[i] & x2@[i]) == (x2@[i] & x1@[i]) &&

            (x1@[i] & 0) == 0 &&

            (x1@[i] & x1@[i]) == x1@[i] &&

            result@[i] <= x1@[i] && result@[i] <= x2@[i]","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0257,verus,numpy_triple,logic_functions_bitwise_not,,"Compute bit-wise inversion, or bit-wise NOT, element-wise.

Computes the bit-wise NOT of the underlying binary representation of
the integers in the input arrays. This ufunc implements the C/Python
operator ~.

For signed integer inputs, the bit-wise NOT of the absolute value is
returned. In a two's-complement system, this operation effectively flips
all the bits, which results in -(x + 1). This is the most common method
of representing signed integers on computers.

Returns an array of the same shape as x, containing the bitwise NOT values.

Specification: numpy.bitwise_not returns a vector where each element is the
bitwise NOT of the corresponding element in x.

Precondition: True (no special preconditions for bitwise NOT)
Postcondition: For all indices i, result[i] = -(x[i] + 1)

This specification captures the mathematical property that bitwise NOT
of an integer x in two's complement representation equals -(x + 1).

Key properties:
- Bitwise NOT is its own inverse: ~~x = x
- For any integer x: ~x = -(x + 1)
- The operation is element-wise for arrays","use vstd::prelude::*;

verus! {",,"fn numpy_bitwise_not(x: Vec<i8>) -> (result: Vec<i8>)
    ensures 
        result.len() == x.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] as int == -(x[i] as int + 1)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0258,verus,numpy_triple,logic_functions_bitwise_or,,"numpy.bitwise_or: Compute the bit-wise OR of two arrays element-wise.

Computes the bit-wise OR of the underlying binary representation of
the integers in the input arrays. This ufunc implements the C/Python
operator |.

For integer inputs, the result is the bitwise OR of the binary
representations. For boolean inputs, it performs logical OR.

Specification: numpy.bitwise_or returns a vector where each element is the 
bitwise OR of the corresponding elements from x1 and x2.

Precondition: True (no special preconditions for bitwise OR)
Postcondition: For all indices i, result[i] = bitwise_or(x1[i], x2[i])

Mathematical properties:
- Commutative: bitwise_or(x1[i], x2[i]) = bitwise_or(x2[i], x1[i])
- Identity: bitwise_or(x[i], 0) = x[i]
- Idempotent: bitwise_or(x[i], x[i]) = x[i]

/* Axiomatically define bitwise OR operation for integers */

/* Bitwise OR is commutative */

/* Bitwise OR with zero is identity */

/* Bitwise OR is idempotent */","use vstd::prelude::*;

verus! {",,"spec fn bitwise_or(x: i32, y: i32) -> i32;

proof fn bitwise_or_comm(x: i32, y: i32)
    ensures bitwise_or(x, y) == bitwise_or(y, x)
{
    assume(false);
}

proof fn bitwise_or_zero(x: i32)
    ensures bitwise_or(x, 0) == x
{
    assume(false);
}

proof fn bitwise_or_idempotent(x: i32)
    ensures bitwise_or(x, x) == x
{
    assume(false);
}

fn numpy_bitwise_or(x1: Vec<i8>, x2: Vec<i8>) -> (result: Vec<i8>)
    requires x1.len() == x2.len(),
    ensures
        result.len() == x1.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] as i32 == bitwise_or(x1[i] as i32, x2[i] as i32),
        forall|i: int| 0 <= i < result.len() ==> bitwise_or(x1[i] as i32, x2[i] as i32) == bitwise_or(x2[i] as i32, x1[i] as i32),
        forall|i: int| 0 <= i < result.len() ==> bitwise_or(x1[i] as i32, 0) == x1[i] as i32,
        forall|i: int| 0 <= i < result.len() ==> bitwise_or(x1[i] as i32, x1[i] as i32) == x1[i] as i32,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0259,verus,numpy_triple,logic_functions_bitwise_xor,,"numpy.bitwise_xor: Compute the bit-wise XOR of two arrays element-wise.

Computes the bit-wise XOR of the underlying binary representation of
the integers in the input arrays. This ufunc implements the C/Python
operator ^.

The function works on integer and boolean types, computing the XOR
of corresponding elements from two input vectors.

Specification: numpy.bitwise_xor returns a vector where each element is the 
bitwise XOR of the corresponding elements from x1 and x2.

Precondition: All elements are non-negative (to use well-defined bitwise operations)
Postcondition: For all indices i, result[i] = x1[i] XOR x2[i]

Mathematical properties:
- XOR is commutative: x1[i] XOR x2[i] = x2[i] XOR x1[i]
- XOR is associative: (a XOR b) XOR c = a XOR (b XOR c)
- XOR with zero is identity: x XOR 0 = x
- XOR is self-inverse: x XOR x = 0","use vstd::prelude::*;

verus! {",,"fn bitwise_xor(x1: Vec<u8>, x2: Vec<u8>) -> (result: Vec<u8>)
    requires 
        x1.len() == x2.len(),
    ensures
        result.len() == x1.len(),
        forall|i: int| 0 <= i < result.len() ==> result@[i] == (x1@[i] ^ x2@[i]),
        forall|i: int| 0 <= i < result.len() && x1@[i] == 0 ==> result@[i] == x2@[i],
        forall|i: int| 0 <= i < result.len() && x2@[i] == 0 ==> result@[i] == x1@[i],
        forall|i: int| 0 <= i < result.len() && x1@[i] == x2@[i] ==> result@[i] == 0,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0260,verus,numpy_triple,logic_functions_equal,,"numpy.equal: Return (x1 == x2) element-wise.

Performs element-wise comparison of two arrays and returns a boolean array
of the same shape indicating where the corresponding elements are equal.

For scalar inputs, returns a single boolean value. For array inputs of the
same shape, returns an array of booleans. This function is the basis for
the == operator when used with numpy arrays.

Specification: numpy.equal returns a boolean vector where each element indicates
whether the corresponding elements in x1 and x2 are equal.

Precondition: True (arrays have the same shape by the type system)
Postcondition: For all indices i, result[i] = (x1[i] == x2[i])

This specification captures both the element-wise behavior and the mathematical
property that equality comparison is performed at each position.

Key Properties:
1. Element-wise comparison: Each position is compared independently
2. Boolean result: Returns true/false for each position 
3. Reflexivity: equal(x, x) returns all true
4. Symmetry: equal(x, y) = equal(y, x)
5. Result shape matches input shape","use vstd::prelude::*;

verus! {",,"fn numpy_equal<T>(x1: Vec<T>, x2: Vec<T>) -> (result: Vec<bool>)
    requires 
        x1.len() == x2.len(),
    ensures
        result.len() == x1.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] == (x1[i] == x2[i]),
        forall|i: int| 0 <= i < result.len() ==> (result[i] == true || result[i] == false),
        x1@ == x2@ ==> forall|i: int| 0 <= i < result.len() ==> result[i] == true","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0261,verus,numpy_triple,logic_functions_greater,,"numpy.greater: Return the truth value of (x1 > x2) element-wise.

Returns a boolean vector where each element indicates whether the
corresponding element in x1 is greater than the corresponding element in x2.

This is equivalent to x1 > x2 in terms of array broadcasting.

Follows IEEE 754 standard for floating point comparisons:
- Comparisons with NaN always return false
- Returns boolean array of same shape as inputs

Specification: numpy.greater returns a boolean vector where each element
is true if and only if the corresponding element in x1 is greater than
the corresponding element in x2.

This specification captures:
1. Basic element-wise comparison semantics
2. Antisymmetry property of greater-than relation
3. Transitivity when combined with other comparisons
4. IEEE 754 compliant NaN handling
5. Consistency with standard mathematical ordering","use vstd::prelude::*;

verus! {",,"fn numpy_greater(x1: &Vec<i8>, x2: &Vec<i8>) -> (result: Vec<bool>)
    requires x1.len() == x2.len(),
    ensures 
        result.len() == x1.len(),
        forall|i: int| 0 <= i < result.len() ==> 
            (result[i] == (x1[i] as int > x2[i] as int)) &&
            (result[i] == true ==> !(x2[i] as int > x1[i] as int)) &&
            (result[i] == true || result[i] == false)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0262,verus,numpy_triple,logic_functions_greater_equal,,"numpy.greater_equal: Return the truth value of (x1 >= x2) element-wise.

Returns a boolean vector where each element indicates whether the
corresponding element in x1 is greater than or equal to the corresponding 
element in x2.

This is equivalent to x1 >= x2 in terms of array broadcasting.

Specification: numpy.greater_equal returns a boolean vector where each element
is true if and only if the corresponding element in x1 is greater than or equal
to the corresponding element in x2.

Precondition: True (no special preconditions for comparison)
Postcondition: For all indices i, result[i] = true ↔ x1[i] >= x2[i]

Additional properties:
- The result is the element-wise negation of less(x1, x2)
- Reflexivity: greater_equal(x, x) returns all true
- Antisymmetry: If greater_equal(x1, x2)[i] = true and greater_equal(x2, x1)[i] = true,
                then x1[i] = x2[i]
- Transitivity: If greater_equal(x1, x2)[i] = true and greater_equal(x2, x3)[i] = true,
                then greater_equal(x1, x3)[i] = true
- For NaN values: comparison with NaN always returns false

/* Reflexivity: comparing vector with itself yields all true */

/* Antisymmetry with equality */

/* Boolean result: each element is either true or false */","use vstd::prelude::*;

verus! {",,"fn numpy_greater_equal(x1: Vec<i8>, x2: Vec<i8>) -> (result: Vec<bool>)
    requires x1.len() == x2.len(),
    ensures 
        result.len() == x1.len(),
        forall|i: int| 0 <= i < result.len() ==> (result[i] <==> x1@[i] as int >= x2@[i] as int),

        x1@ == x2@ ==> forall|i: int| 0 <= i < result.len() ==> result[i] == true,

        forall|i: int| 0 <= i < result.len() ==> 
            (result[i] == true && x2@[i] as int >= x1@[i] as int) ==> x1@[i] as int == x2@[i] as int,

        forall|i: int| 0 <= i < result.len() ==> (result[i] == true || result[i] == false),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0263,verus,numpy_triple,logic_functions_isclose,,"Returns a boolean array where two arrays are element-wise equal within a tolerance.
For finite values, isclose uses the equation: absolute(a - b) <= (atol + rtol * absolute(b))
where `b` is treated as the reference value.

Specification: isclose returns a boolean array indicating element-wise closeness within tolerance","use vstd::prelude::*;

verus! {",,"fn isclose(a: Vec<f32>, b: Vec<f32>, rtol: f32, atol: f32, equal_nan: bool) -> (result: Vec<bool>)
    requires 
        a@.len() == b@.len(),
    ensures
        result@.len() == a@.len(),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0264,verus,numpy_triple,logic_functions_iscomplex,,"Returns a bool array, where True if input element is complex.
Returns a bool array, where True if input element has non-zero imaginary part.
For complex numbers, checks if imaginary part is non-zero.
For real numbers, returns false for all elements.
Specification: iscomplex returns true for elements with non-zero imaginary parts,
false for elements with zero imaginary parts, with the following properties:
1. Basic definition: returns true iff imaginary part is non-zero
2. Real number detection: pure real numbers (imag = 0) return false
3. Complex number detection: numbers with non-zero imaginary part return true
4. Idempotent on boolean interpretation: the mathematical meaning is preserved
5. Element-wise operation: each element is tested independently

/* Structure representing a complex number with float components */

/* The real part of the complex number */

/* The imaginary part of the complex number */","use vstd::prelude::*;

verus! {

struct Complex {

    real: f64,

    imag: f64,
}",,"fn is_complex(x: &Vec<Complex>) -> (result: Vec<bool>)
    ensures
        result.len() == x.len(),
        forall|i: int| 0 <= i < x@.len() ==> result@[i] == (x@[i].imag != 0.0),
        forall|i: int| 0 <= i < x@.len() ==> (x@[i].imag == 0.0 ==> result@[i] == false),
        forall|i: int| 0 <= i < x@.len() ==> (x@[i].imag != 0.0 ==> result@[i] == true),
        forall|i: int| 0 <= i < x@.len() ==> (result@[i] == true ==> x@[i].imag != 0.0),
        forall|i: int| 0 <= i < x@.len() ==> (result@[i] == false ==> x@[i].imag == 0.0)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0265,verus,numpy_triple,logic_functions_iscomplexobj,,"Check for a complex type or an array of complex numbers

The type of the input is checked, not the value. Even if the input
has an imaginary part equal to zero, iscomplexobj evaluates to True.

Parameters
----------
x : any
    The input can be of any type and shape.

Returns
-------
iscomplexobj : bool
    The return value, True if x is of a complex type or has at least
    one complex element.

Check if a vector contains complex numbers

Specification: iscomplexobj returns True for complex type vectors.
This function checks the type, not the values - even complex numbers
with zero imaginary part are considered complex objects.

Key properties:
- Always returns true for vectors of complex numbers
- Type-based checking: independent of actual values
- Zero complex numbers (0+0i) are still complex objects
- Complex vectors with any values are complex objects

Mathematical properties:
- Type consistency: all Complex vectors are complex objects
- Value independence: result depends only on type, not values
- Idempotent: checking complex vectors always yields true","use vstd::prelude::*;

verus! {

/* Complex number with real and imaginary parts */
#[derive(PartialEq, Structural)]
pub struct Complex {
    pub re: i32,
    pub im: i32,
}",,"fn iscomplexobj(x: Vec<Complex>) -> (result: bool)
    ensures 
        result == true","{
    // impl-start
    assume(false);
    true
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0266,verus,numpy_triple,logic_functions_isfinite,,Test element-wise for finiteness (not infinity and not NaN),"use vstd::prelude::*;

verus! {
spec fn is_finite_f32(x: f32) -> bool;
spec fn is_infinite_f32(x: f32) -> bool;
spec fn is_nan_f32(x: f32) -> bool;",,"fn isfinite(x: Vec<f32>) -> (result: Vec<bool>)
    requires x@.len() > 0,
    ensures 
        result@.len() == x@.len(),
        forall|i: int| 0 <= i < x@.len() ==> {
            &&& (result@[i] == (!is_infinite_f32(x@[i]) && !is_nan_f32(x@[i])))
            &&& (result@[i] == true <==> is_finite_f32(x@[i]))
            &&& (result@[i] == false <==> (is_nan_f32(x@[i]) || is_infinite_f32(x@[i])))
            &&& (x@[i] == 0.0f32 ==> result@[i] == true)
            &&& (result@[i] == false ==> (is_nan_f32(x@[i]) || is_infinite_f32(x@[i])))
            &&& (result@[i] == true ==> !is_nan_f32(x@[i]) && !is_infinite_f32(x@[i]))
        }","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0267,verus,numpy_triple,logic_functions_isinf,,"numpy.isinf: Test element-wise for positive or negative infinity
Returns a boolean array of the same shape as x, True where x == +/-inf, otherwise False.
URL: https://numpy.org/doc/stable/reference/generated/numpy.isinf.html
Category: Array contents testing

Test element-wise for positive or negative infinity in a vector

Specification: isinf returns true for positive or negative infinity, false otherwise.

    This function tests each element according to IEEE 754 floating-point standard:
    - Returns true if the element is positive infinity or negative infinity
    - Returns false for all other values including NaN, finite numbers, and zero

    Mathematical properties:
    1. Infinity detection: result[i] = true iff x[i] is infinite
    2. Distinction from NaN: infinity and NaN are mutually exclusive
    3. Result preserves shape: output vector has same length as input
    4. Finite values: All normal, subnormal, and zero values return false
    5. Specific infinities: Both positive and negative infinity are correctly identified

/* Ghost specification function to represent IEEE 754 infinity test */","use vstd::prelude::*;

verus! {

spec fn is_infinite(x: f64) -> bool;",,"fn isinf(x: Vec<f64>) -> (result: Vec<bool>)
    requires x.len() < usize::MAX,
    ensures 
        result.len() == x.len(),
        forall|i: int| 0 <= i < x.len() ==> {
            result[i] == is_infinite(x@[i])
        }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0268,verus,numpy_triple,logic_functions_isnan,,"Test element-wise for NaN and return result as a boolean array.

Specification: isnan returns true for NaN values and false otherwise.
The function correctly identifies NaN values according to IEEE 754 standard.

Mathematical properties:
1. NaN detection: result[i] = true iff x[i] is NaN
2. NaN ≠ NaN property: if x[i].isNaN then x[i] ≠ x[i]
3. Result preserves shape: output vector has same length as input
4. Non-NaN values: For all finite values, the result is false
5. Complement property: isnan is the complement of (isfinite ∨ isinfinite)","use vstd::prelude::*;

verus! {",,"fn isnan(x: Vec<f64>) -> (result: Vec<bool>)
    ensures
        result.len() == x.len(),
        forall|i: int| 0 <= i < x@.len() ==> (result[i] == true <==> x[i] != x[i]),
        forall|i: int| 0 <= i < x@.len() ==> (result[i] == true ==> x[i] != x[i]),
        forall|i: int| 0 <= i < x@.len() ==> (x[i] == x[i] ==> result[i] == false),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0269,verus,numpy_triple,logic_functions_isnat,,"Test element-wise for NaT (not a time) and return result as a boolean array.

This function checks each element of a datetime64 array to determine if it
represents NaT (Not a Time), which is the datetime equivalent of NaN.

Returns true for NaT values and false for all valid datetime values.
The function is the datetime analog of isnan for floating point values.

Specification: isnat returns true for NaT values and false otherwise.
The function correctly identifies NaT values in datetime64 arrays.

Mathematical properties:
1. NaT detection: result[i] = true iff x[i] is NaT
2. Valid datetime detection: result[i] = false iff x[i] is a valid datetime
3. Result preserves shape: output vector has same length as input
4. Exhaustive coverage: every element is either NaT or a valid datetime

This is the datetime analog of isnan for floating point NaN values.","use vstd::prelude::*;

verus! {

#[derive(PartialEq, Eq, Clone, Copy)]
pub enum DateTime64 {
    Valid(i64),
    Nat,
}",,"fn isnat(x: Vec<DateTime64>) -> (result: Vec<bool>)
    ensures
        result.len() == x.len(),
        forall|i: int| 0 <= i < x.len() ==> 
            (result@.index(i) == true <==> x@.index(i) == DateTime64::Nat),
        forall|i: int| 0 <= i < x.len() ==> 
            (result@.index(i) == false <==> exists|val: i64| x@.index(i) == DateTime64::Valid(val)),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0270,verus,numpy_triple,logic_functions_isneginf,,"Test element-wise for negative infinity, return result as bool array.

This function tests each element according to IEEE 754 floating-point standard:
- Returns true if the element is negative infinity (-∞)
- Returns false for all other values including positive infinity, NaN, finite numbers, and zero

Mathematical properties:
1. Negative infinity detection: result[i] = true iff x[i] is negative infinity
2. Distinction from positive infinity: only negative infinity returns true
3. Distinction from NaN: negative infinity and NaN are mutually exclusive
4. Result preserves shape: output vector has same length as input
5. Finite values: All normal, subnormal, and zero values return false","use vstd::prelude::*;

verus! {",,"spec fn is_neg_infinity(x: f32) -> bool;

fn isneginf(x: Vec<f32>) -> (result: Vec<bool>)
    requires x@.len() > 0,
    ensures
        result@.len() == x@.len(),
        forall|i: int| 0 <= i < x@.len() ==> {
            &&& (result@[i] == is_neg_infinity(x@[i]))
        }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0271,verus,numpy_triple,logic_functions_isposinf,,"Test element-wise for positive infinity, return result as bool array.

This function tests each element according to IEEE 754 floating-point standard:
- Returns true if the element is positive infinity (+∞)
- Returns false for all other values including negative infinity, NaN, finite numbers, and zero

Mathematical properties:
1. Positive infinity detection: result[i] = true iff x[i] is positive infinity
2. Distinction from negative infinity: only positive infinity returns true
3. Distinction from NaN: positive infinity and NaN are mutually exclusive
4. Result preserves shape: output vector has same length as input
5. Finite values: All normal, subnormal, and zero values return false","use vstd::prelude::*;

verus! {",,"spec fn is_pos_inf(x: i32) -> bool {
    x == 0x7f800000i32
}

spec fn is_neg_inf(x: i32) -> bool {
    x == 0xff800000u32 as i32
}

spec fn is_nan(x: i32) -> bool {
    (x & 0x7f800000i32) == 0x7f800000i32 && (x & 0x7fffffi32) != 0
}

spec fn is_finite(x: i32) -> bool {
    (x & 0x7f800000i32) != 0x7f800000i32
}

fn isposinf(x: Vec<i32>) -> (result: Vec<bool>)
    ensures
        result.len() == x.len(),
        forall|i: int| 0 <= i < x.len() ==> {
            /* Primary property: result is true iff input is positive infinity */
            result[i] == is_pos_inf(x[i]) &&
            /* Sanity checks: finite values return false */
            (is_finite(x[i]) ==> result[i] == false) &&
            /* Negative infinity returns false */
            (is_neg_inf(x[i]) ==> result[i] == false) &&
            /* NaN is not positive infinity */
            (is_nan(x[i]) ==> result[i] == false) &&
            /* Zero is not positive infinity */
            (x[i] == 0 ==> result[i] == false) &&
            /* Mathematical property: if result is true, then x is positive infinity */
            (result[i] == true ==> is_pos_inf(x[i])) &&
            /* Exclusivity: cannot be both positive infinity and NaN */
            (result[i] == true ==> !is_nan(x[i]))
        }","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0272,verus,numpy_triple,logic_functions_isreal,,"Returns a bool array, where True if input element is real.
For complex numbers, checks if imaginary part is zero.
For numbers with zero imaginary part, returns true for all elements.

Specification: isreal returns true for elements with zero imaginary parts,
false for elements with non-zero imaginary parts, with the following properties:
1. Basic definition: returns true iff imaginary part is zero
2. Real number detection: pure real numbers (imag = 0) return true
3. Complex number detection: numbers with non-zero imaginary part return false
4. Complementary to iscomplex: isreal(x) = not iscomplex(x)
5. Element-wise operation: each element is tested independently
6. Mathematical property: real numbers form a subset of complex numbers
7. Consistency: if real, then can be represented as a + 0i

/* Structure representing a complex number with float components */

/* The real part of the complex number */

/* The imaginary part of the complex number */","use vstd::prelude::*;

verus! {

struct Complex {

    real: f64,

    imag: f64,
}",,"fn isreal(x: &Vec<Complex>) -> (result: Vec<bool>)
    ensures
        result.len() == x.len(),
        forall|i: int| 0 <= i < x@.len() ==> result@[i] == (x@[i].imag == 0.0),
        forall|i: int| 0 <= i < x@.len() ==> (x@[i].imag == 0.0 ==> result@[i] == true),
        forall|i: int| 0 <= i < x@.len() ==> (x@[i].imag != 0.0 ==> result@[i] == false),
        forall|i: int| 0 <= i < x@.len() ==> (result@[i] == true ==> x@[i].imag == 0.0),
        forall|i: int| 0 <= i < x@.len() ==> (result@[i] == false ==> x@[i].imag != 0.0),
        forall|i: int| 0 <= i < x@.len() ==> (result@[i] == true ==> x@[i].real == x@[i].real),
        forall|i: int| 0 <= i < x@.len() ==> result@[i] == !(x@[i].imag != 0.0),
        forall|i: int| 0 <= i < x@.len() ==> (result@[i] == true <==> x@[i].imag == 0.0),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0275,verus,numpy_triple,logic_functions_less_equal,,"Return the truth value of (x1 <= x2) element-wise

Specification: less_equal returns element-wise comparison x1[i] <= x2[i] with mathematical properties","use vstd::prelude::*;

verus! {",,"fn less_equal(x1: Vec<i8>, x2: Vec<i8>) -> (result: Vec<bool>)
    requires x1.len() == x2.len(),
    ensures 
        result.len() == x1.len(),
        forall|i: int| 0 <= i < x1@.len() ==> result@[i] == (x1@[i] <= x2@[i]),
        forall|i: int| 0 <= i < x1@.len() ==> (result@[i] == true <==> x1@[i] <= x2@[i]),
        forall|i: int| 0 <= i < x1@.len() ==> (result@[i] == false <==> x1@[i] > x2@[i]),
        forall|i: int| 0 <= i < x1@.len() ==> (x1@[i] == x2@[i] ==> result@[i] == true),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0276,verus,numpy_triple,logic_functions_logical_and,,"numpy.logical_and: Compute the truth value of x1 AND x2 element-wise.

Computes the logical AND of two boolean arrays element-wise.
Each element of the result is the logical AND of the corresponding
elements from the input arrays.

Examples from NumPy:
- logical_and(True, False) = False
- logical_and([True, False], [False, False]) = [False, False]
- logical_and([True, True], [True, False]) = [True, False]

This is a binary element-wise operation equivalent to x1 & x2.

Specification: numpy.logical_and returns a vector where each element
is the logical AND of the corresponding elements from x1 and x2.

Precondition: True (no special preconditions for logical AND)
Postcondition: For all indices i, result[i] = x1[i] ∧ x2[i]

Key properties:
- Commutative: logical_and(x1, x2) = logical_and(x2, x1)
- Associative: logical_and(logical_and(x1, x2), x3) = logical_and(x1, logical_and(x2, x3))
- Identity: logical_and(x, true_vector) = x
- Zero: logical_and(x, false_vector) = false_vector
- Idempotent: logical_and(x, x) = x","use vstd::prelude::*;

verus! {",,"fn numpy_logical_and(x1: Vec<bool>, x2: Vec<bool>) -> (result: Vec<bool>)
    requires x1.len() == x2.len(),
    ensures 
        result.len() == x1.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] == (x1[i] && x2[i])","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0277,verus,numpy_triple,logic_functions_logical_not,,"numpy.logical_not: Compute the truth value of NOT x element-wise.

For each element in the input array, applies logical NOT operation.
In NumPy's interpretation: any non-zero numeric value is considered True 
(so NOT returns False), zero is considered False (so NOT returns True).

Returns a boolean array of the same shape as the input.

Specification: numpy.logical_not returns a vector where each element is the
logical NOT of the corresponding element in x, following NumPy's truthiness rules.

Precondition: True (logical NOT is defined for all numeric values)
Postcondition: For all indices i, result[i] = true iff x[i] = 0.0

Mathematical properties:
- Exactly implements NumPy's truthiness rules: 0.0 → true, non-zero → false
- Element-wise operation preserves array shape and size (enforced by type)
- Idempotent when composed with itself and appropriate conversion
- For special float values: logical_not(NaN) = false, logical_not(∞) = false
- Boundary case: logical_not(-0.0) = true (since -0.0 = 0.0)","use vstd::prelude::*;

verus! {",,"fn logical_not(x: Vec<f64>) -> (result: Vec<bool>)
    ensures
        result.len() == x.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] == (x[i] == 0.0)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0278,verus,numpy_triple,logic_functions_logical_or,,"Compute the truth value of x1 OR x2 element-wise.

Performs logical OR operation on corresponding elements of two boolean vectors.
The function returns a vector where each element is the logical OR of the 
corresponding elements from the input vectors.

Specification: logical_or computes element-wise logical OR operation

This specification captures the mathematical properties of logical OR:
- Commutativity: a ∨ b = b ∨ a
- Associativity: (a ∨ b) ∨ c = a ∨ (b ∨ c)
- Identity with false: a ∨ false = a
- Absorption with true: a ∨ true = true
- Idempotent: a ∨ a = a
- De Morgan's law: ¬(a ∨ b) = (¬a) ∧ (¬b)

Sanity checks:
- For empty vectors (n = 0), the result is empty by vacuous truth
- logical_or([true, false], [false, false]) = [true, false]
- logical_or([false, false], [false, false]) = [false, false]
- logical_or([true, true], [false, true]) = [true, true]
- The result is false only when both operands are false

/* Commutativity property */

/* Identity with false */

/* Absorption with true */

/* Idempotent property */

/* Result is true if either operand is true */

/* Result is false only when both operands are false */","use vstd::prelude::*;

verus! {",,"fn logical_or(x1: Vec<bool>, x2: Vec<bool>) -> (result: Vec<bool>)
    requires x1.len() == x2.len(),
    ensures 
        result.len() == x1.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] == (x1[i] || x2[i]),

        forall|i: int| 0 <= i < result.len() ==> (x1[i] || x2[i]) == (x2[i] || x1[i]),

        forall|i: int| 0 <= i < result.len() ==> (x1[i] || false) == x1[i],

        forall|i: int| 0 <= i < result.len() ==> (x1[i] || true) == true,

        forall|i: int| 0 <= i < result.len() ==> (x1[i] || x1[i]) == x1[i],

        forall|i: int| 0 <= i < result.len() ==> (x1[i] == true || x2[i] == true) ==> result[i] == true,

        forall|i: int| 0 <= i < result.len() ==> (x1[i] == false && x2[i] == false) ==> result[i] == false,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0279,verus,numpy_triple,logic_functions_logical_xor,,"numpy.logical_xor: Compute the truth value of x1 XOR x2 element-wise.

Computes the logical XOR of two boolean arrays element-wise.
Each element of the result is the logical XOR of the corresponding
elements from the input arrays.

Examples from NumPy:
- logical_xor(True, False) = True
- logical_xor([True, True, False, False], [True, False, True, False]) = [False, True, True, False]
- logical_xor(False, False) = False
- logical_xor(True, True) = False

This is a binary element-wise operation equivalent to x1 ⊕ x2.

Specification: numpy.logical_xor returns a vector where each element
is the logical XOR of the corresponding elements from x1 and x2.

Precondition: True (no special preconditions for logical XOR)
Postcondition: For all indices i, result[i] = x1[i] ⊕ x2[i]

Key properties:
- Commutative: logical_xor(x1, x2) = logical_xor(x2, x1)
- Associative: logical_xor(logical_xor(x1, x2), x3) = logical_xor(x1, logical_xor(x2, x3))
- Identity: logical_xor(x, false_vector) = x
- Self-inverse: logical_xor(x, x) = false_vector
- Double negation: logical_xor(logical_xor(x, y), y) = x
- Relationship to other operations: logical_xor(x, y) = logical_and(logical_or(x, y), logical_not(logical_and(x, y)))","use vstd::prelude::*;

verus! {",,"fn numpy_logical_xor(x1: Vec<bool>, x2: Vec<bool>) -> (result: Vec<bool>)
    requires x1.len() == x2.len(),
    ensures 
        result.len() == x1.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] == (x1[i] != x2[i])","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0280,verus,numpy_triple,logic_functions_not_equal,,"numpy.not_equal: Return (x1 != x2) element-wise.

Performs element-wise inequality comparison of two arrays and returns a boolean array
of the same shape indicating where the corresponding elements are not equal.

For scalar inputs, returns a single boolean value. For array inputs of the
same shape, returns an array of booleans. This function is the basis for
the != operator when used with numpy arrays.

This is the logical negation of numpy.equal.

Specification: numpy.not_equal returns a boolean vector where each element indicates
whether the corresponding elements in x1 and x2 are not equal.

Precondition: True (arrays have the same shape by the type system)
Postcondition: For all indices i, result[i] = (x1[i] != x2[i])

This specification captures both the element-wise behavior and the mathematical
property that inequality comparison is performed at each position.

Key Properties:
1. Element-wise comparison: Each position is compared independently
2. Boolean result: Returns true/false for each position 
3. Irreflexivity: not_equal(x, x) returns all false
4. Symmetry: not_equal(x, y) = not_equal(y, x)
5. Logical negation of equality: not_equal(x, y) = ¬equal(x, y)
6. Result shape matches input shape

/* Irreflexivity: comparing vector with itself yields all false */

/* Symmetry: inequality comparison is commutative */","use vstd::prelude::*;

verus! {",,"fn numpy_not_equal(x1: Vec<i8>, x2: Vec<i8>) -> (result: Vec<bool>)
    requires x1.len() == x2.len(),
    ensures
        result.len() == x1.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] == (x1[i] != x2[i]),

        (x1@ == x2@) ==> (forall|i: int| 0 <= i < result.len() ==> result[i] == false),

        forall|i: int| 0 <= i < result.len() ==> result[i] == (x2[i] != x1[i]),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0281,verus,numpy_triple,mathematical_functions_absolute,,"Calculate the absolute value element-wise for a vector of integers.

Specification: absolute computes the absolute value of each element with the following mathematical properties:
1. Basic definition: |x| = x if x ≥ 0, otherwise -x
2. Non-negativity: |x| ≥ 0 for all x
3. Zero preservation: |x| = 0 if and only if x = 0
4. Idempotence: ||x|| = |x|
5. Multiplicativity: |x * y| = |x| * |y|","use vstd::prelude::*;

verus! {",,"spec fn abs_spec(x: int) -> int {
    if x >= 0 { x } else { -x }
}

fn absolute(x: Vec<i8>) -> (result: Vec<i8>)
    ensures 
        result.len() == x.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] as int == abs_spec(x[i] as int),
        forall|i: int| 0 <= i < result.len() ==> result[i] >= 0,
        forall|i: int| 0 <= i < result.len() ==> (result[i] == 0 <==> x[i] == 0)","{
    // impl-start
    assume(false);
    Vec::new()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0282,verus,numpy_triple,mathematical_functions_add,,"numpy.add: Add arguments element-wise.

Adds two vectors element-wise. If the vectors have the same shape,
each element of the result is the sum of the corresponding elements
from the input vectors.

This is equivalent to x1 + x2 in terms of array broadcasting.
The function supports all numeric types and handles overflow according
to the IEEE 754 standard for floating-point arithmetic.

From NumPy documentation:
- Parameters: x1, x2 (array_like) - The arrays to be added
- Returns: add (ndarray) - The sum of x1 and x2, element-wise

Specification: numpy.add returns a vector where each element is the sum
of the corresponding elements from x1 and x2.

Mathematical Properties:
1. Element-wise correctness: result[i] = x1[i] + x2[i]
2. Commutativity: add(x1, x2) = add(x2, x1)
3. Associativity: add(add(x1, x2), x3) = add(x1, add(x2, x3))
4. Identity: add(x, zeros) = x
5. Preserves vector length: result.size = x1.size = x2.size
6. Handles finite arithmetic: supports IEEE 754 floating-point addition

Precondition: True (no special preconditions for basic addition)
Postcondition: For all indices i, result[i] = x1[i] + x2[i]","use vstd::prelude::*;

verus! {",,"fn add(x1: Vec<i8>, x2: Vec<i8>) -> (result: Vec<i8>)
    requires x1.len() == x2.len(),
    ensures 
        result.len() == x1.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] as int == x1[i] as int + x2[i] as int","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0283,verus,numpy_triple,mathematical_functions_arccos,,"Trigonometric inverse cosine, element-wise.
Returns the arc cosine of each element in the input vector.
The result is in the range [0, π].

Specification: arccos returns the inverse cosine of each element.
Precondition: All elements must be in the range [-1, 1] for valid results.
Postcondition: The result contains the arc cosine of each input element,
with values in the range [0, π], and satisfies cos(arccos(x)) = x for valid inputs.
Additionally, arccos is monotonically decreasing on its domain [-1, 1].","use vstd::prelude::*;

verus! {",,"fn arccos(x: Vec<i8>) -> (result: Vec<i8>)
    requires 
        x.len() > 0,
        forall|i: int| 0 <= i < x.len() ==> -1 <= x[i] as int && x[i] as int <= 1,
    ensures 
        result.len() == x.len(),
        forall|i: int| 0 <= i < result.len() ==> (
            0 <= result[i] as int && 
            result[i] as int <= 3 &&
            (x[i] as int == -1 ==> result[i] as int == 3) &&
            (x[i] as int == 1 ==> result[i] as int == 0)
        ),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0284,verus,numpy_triple,mathematical_functions_arccosh,,"Inverse hyperbolic cosine, element-wise. 
Returns the inverse hyperbolic cosine of each element in the input vector.
The inverse hyperbolic cosine is defined as: arccosh(x) = log(x + sqrt(x² - 1)) for x ≥ 1

Specification: arccosh computes the inverse hyperbolic cosine element-wise.

Mathematical properties:
1. Domain constraint: All input values must be ≥ 1
2. Range: All output values are non-negative (arccosh(x) ≥ 0)
3. Special value: arccosh(1) = 0
4. The function is strictly increasing: x₁ < x₂ implies arccosh(x₁) < arccosh(x₂)
5. Mathematical definition: arccosh(x) = log(x + sqrt(x² - 1))

The inverse hyperbolic cosine function reverses the action of cosh on [0, ∞),
where cosh(y) = (e^y + e^(-y))/2. These properties ensure correctness.","use vstd::prelude::*;

verus! {",,"fn arccosh(x: Vec<f32>) -> (result: Vec<f32>)
    requires 
        x.len() > 0,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0285,verus,numpy_triple,mathematical_functions_arcsin,,"numpy.arcsin: Inverse sine, element-wise.

Computes the inverse sine (arcsine) of each element in the input array.
The result is the angle in radians whose sine is the input value.

For real arguments, the domain is [-1, 1] and the range is [-π/2, π/2].
Values outside [-1, 1] will result in NaN.

Returns an array of the same shape as x, containing the inverse sine values in radians.

Specification: numpy.arcsin returns a vector where each element is the
inverse sine of the corresponding element in x.

Precondition: All elements of x must be in the domain [-1, 1] for real results
Postcondition: For all indices i where x[i] is in [-1, 1]:
- result[i] = arcsin(x[i])
- result[i] is in the range [-π/2, π/2]
- sin(result[i]) = x[i] (inverse relationship holds)
- arcsin is monotonic: if x[i] ≤ x[j] then result[i] ≤ result[j]
- Special values: arcsin(0) = 0, arcsin(1) = π/2, arcsin(-1) = -π/2","use vstd::prelude::*;

verus! {",,"fn numpy_arcsin(x: Vec<i8>) -> (result: Vec<i8>)
    requires 
        x@.len() > 0,
        forall|i: int| 0 <= i < x@.len() ==> -1 <= x[i] as int && x[i] as int <= 1,
    ensures
        result@.len() == x@.len(),
        forall|i: int| 0 <= i < result@.len() ==> {
            -2 <= result[i] as int && result[i] as int <= 2 &&
            (x[i] as int == 0 ==> result[i] as int == 0) &&
            (x[i] as int == 1 ==> result[i] as int == 2) &&
            (x[i] as int == -1 ==> result[i] as int == -2)
        },
        forall|i: int, j: int| 0 <= i < x@.len() && 0 <= j < x@.len() && x[i] as int <= x[j] as int ==> result[i] as int <= result[j] as int","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0286,verus,numpy_triple,mathematical_functions_arcsinh,,"numpy.arcsinh: Inverse hyperbolic sine element-wise.

Computes the inverse hyperbolic sine of each element in the input vector.
The inverse hyperbolic sine is defined as arcsinh(x) = ln(x + sqrt(x² + 1)).

This function is defined for all real numbers and is the inverse of the
hyperbolic sine function (sinh).

Specification: numpy.arcsinh returns a vector where each element is the
inverse hyperbolic sine of the corresponding element in x.

Precondition: True (arcsinh is defined for all real numbers)
Postcondition: For all indices i, result[i] = arcsinh(x[i])

Mathematical properties captured:
1. arcsinh(0) = 0 (sanity check)
2. arcsinh(-x) = -arcsinh(x) (odd function property)
3. arcsinh is strictly increasing (monotonicity)","use vstd::prelude::*;

verus! {",,"fn numpy_arcsinh(x: Vec<f32>) -> (result: Vec<f32>)
    ensures 
        result@.len() == x@.len(),
        forall|i: int| 0 <= i < result@.len() ==> {
            /* Sanity check: arcsinh(0) = 0 */
            x@[i] == 0.0f32 ==> result@[i] == 0.0f32
        }","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0287,verus,numpy_triple,mathematical_functions_arctan,,"Trigonometric inverse tangent, element-wise.

The inverse of tan, so that if y = tan(x) then x = arctan(y).

Computes the element-wise inverse tangent of a vector.

Specification: arctan computes the inverse tangent of each element,
with comprehensive mathematical properties including range bounds,
monotonicity, and behavior at special values.","use vstd::prelude::*;

verus! {",,"fn arctan(x: Vec<i32>) -> (result: Vec<i32>)
    requires x.len() > 0,
    ensures 
        result.len() == x.len(),
        forall|i: int| 0 <= i < result.len() ==> {
            /* Range constraint: arctan(x) ∈ (-π/2, π/2) - simplified for integer domain */
            result[i] >= -2 && result[i] <= 2 &&
            /* Sign property: arctan preserves sign */
            (x[i] > 0 ==> result[i] >= 0) &&
            (x[i] < 0 ==> result[i] <= 0) &&
            (x[i] == 0 ==> result[i] == 0) &&
            /* Monotonicity property for specific cases */
            (x[i] > 10 ==> result[i] >= 1) &&
            (x[i] < -10 ==> result[i] <= -1) &&
            /* Bounded function: |arctan(x)| ≤ 2 for integer approximation */
            result[i] >= -2 && result[i] <= 2
        }","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0288,verus,numpy_triple,mathematical_functions_arctan2,,"numpy.arctan2: Element-wise arc tangent of x1/x2 choosing the quadrant correctly.

Computes the arc tangent of x1/x2 for each pair of corresponding elements,
using the signs of both arguments to determine the quadrant of the result.
This gives the signed angle in radians between the positive x-axis and the
point (x2, x1).

The result is in the range [-π, π].

Special cases:
- arctan2(+0, +0) = +0
- arctan2(+0, -0) = +π
- arctan2(-0, +0) = -0
- arctan2(-0, -0) = -π
- arctan2(y, +∞) = +0 for finite y > 0
- arctan2(y, -∞) = +π for finite y > 0
- arctan2(y, +∞) = -0 for finite y < 0
- arctan2(y, -∞) = -π for finite y < 0","use vstd::prelude::*;

verus! {",,"fn numpy_arctan2(x1: &Vec<f64>, x2: &Vec<f64>) -> (result: Vec<f64>)
    requires x1@.len() == x2@.len(),
    ensures result@.len() == x1@.len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0289,verus,numpy_triple,mathematical_functions_arctanh,,"numpy.arctanh: Inverse hyperbolic tangent element-wise.

Computes the inverse hyperbolic tangent of each element in the input array.
The inverse hyperbolic tangent is defined for values in the open interval (-1, 1).

For a real number x with |x| < 1, arctanh(x) is the value y such that tanh(y) = x.
Mathematically: arctanh(x) = 0.5 * ln((1 + x) / (1 - x))

Returns an array of the same shape as x, containing the inverse hyperbolic tangent 
of each element.

Specification: numpy.arctanh returns a vector where each element is the inverse
hyperbolic tangent of the corresponding element in x.

Precondition: All elements must be in the open interval (-1, 1) for real-valued results
Postcondition: For all indices i, result[i] = Float.atanh x[i]

Mathematical properties:
- arctanh(0) = 0 (identity property)
- arctanh is an odd function: arctanh(-x) = -arctanh(x)
- For |x| < 1: arctanh(x) = 0.5 * ln((1 + x) / (1 - x))
- arctanh is strictly increasing on (-1, 1)
- Domain preservation: all results are finite real numbers
- Range property: arctanh maps (-1, 1) to (-∞, ∞)","use vstd::prelude::*;

verus! {",,"fn numpy_arctanh(x: Vec<i8>) -> (result: Vec<i8>)
    requires 
        x@.len() > 0,
    ensures
        result@.len() == x@.len(),
        /* Identity property: arctanh(0) = 0 */
        forall|i: int| 0 <= i < x@.len() && x@[i] as int == 0 ==> result@[i] as int == 0,
        /* Range property: result contains finite numbers */
        result@.len() == x@.len(),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0290,verus,numpy_triple,mathematical_functions_around,,"numpy.around: Evenly round to the given number of decimals (alias for numpy.round).
Uses banker's rounding (round half to even) for values exactly halfway between rounded decimal values.
For example: 1.5 and 2.5 both round to 2.0, -0.5 and 0.5 both round to 0.0

Specification: around rounds each element to the given number of decimals with the following properties:
1. Basic rounding: rounds to nearest representable value at the specified decimal precision
2. Banker's rounding: for values exactly halfway between rounded decimal values, rounds to nearest even
3. Zero preservation: rounding zero always produces zero
4. Order preservation: maintains relative ordering of elements
5. Bounded difference: the rounded value is close to the original value
6. Idempotency: rounding an already-rounded value doesn't change it

/* Simplified to focus on the basic case */

/* Zero preservation: rounding zero gives zero */

/* Order preservation: maintains ordering */

/* Boundedness: rounded values are close to original values */

/* Symmetry: rounding non-negative values gives non-negative results */","use vstd::prelude::*;

verus! {",,"fn around(a: Vec<i8>, decimals: i8) -> (result: Vec<i8>)
    requires decimals as int == 0,
    ensures
        result.len() == a.len(),

        forall|i: int| 0 <= i < a.len() && a[i] as int == 0 ==> result[i] as int == 0,

        forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() && a[i] as int <= a[j] as int ==> result[i] as int <= result[j] as int,

        forall|i: int| 0 <= i < a.len() ==>
            result[i] as int - 1 <= a[i] as int && a[i] as int <= result[i] as int + 1,

        forall|i: int| 0 <= i < a.len() && a[i] as int >= 0 ==> result[i] as int >= 0,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0291,verus,numpy_triple,mathematical_functions_cbrt,,"Return the cube-root of an array, element-wise

numpy.cbrt: Return the cube-root of an array, element-wise.

Computes the cube root of each element in the input array.
The cube root function is defined for all real numbers, including negative numbers.
For any real number x, cbrt(x) = y such that y³ = x.

Returns an array of the same shape as x, containing the cube roots.

Specification: numpy.cbrt returns a vector where each element is the
cube root of the corresponding element in x.

Precondition: True (cube root is defined for all real numbers)
Postcondition: For all indices i, (result[i])³ = x[i]

Mathematical properties:
- cbrt(x³) = x for all x
- cbrt(-x) = -cbrt(x) (odd function)
- cbrt(0) = 0
- cbrt(1) = 1
- cbrt(8) = 2
- cbrt(-8) = -2","use vstd::prelude::*;

verus! {",,"fn cbrt(x: Vec<f32>) -> (result: Vec<f32>)
    requires x.len() > 0,
    ensures 
        result.len() == x.len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0292,verus,numpy_triple,mathematical_functions_ceil,,"numpy.ceil: Return the ceiling of the input, element-wise.

The ceiling of each element x is the smallest integer i, such that i >= x.
This is a fundamental mathematical operation that rounds up to the
nearest integer.

Returns an array of the same shape as x, containing the ceiling of each element.

Specification: numpy.ceil returns a vector where each element is the
ceiling (smallest integer greater than or equal to) the corresponding element in x.

Precondition: True (ceiling is defined for all real numbers)
Postcondition: For all indices i, result[i] is the ceiling of x[i], meaning:
- result[i] is an integer value (represented as Float)
- result[i] ≥ x[i]
- result[i] < x[i] + 1
- There is no integer k such that x[i] ≤ k < result[i]
- Monotonicity: if x[i] ≤ x[j] then result[i] ≤ result[j]
- Relationship with floor: result[i] = -((-x[i]).floor)

/* Each element in result is the ceiling of corresponding element in x */

/* Ceiling properties: integer value, >= x[i], < x[i] + 1, minimal such integer */

/* Monotonicity: if x[i] <= x[j] then result[i] <= result[j] */","use vstd::prelude::*;

verus! {",,"fn numpy_ceil(x: Vec<f64>) -> (result: Vec<f64>)
    requires x.len() > 0,
    ensures
        result.len() == x.len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0293,verus,numpy_triple,mathematical_functions_clip,,"numpy.clip: Clip (limit) the values in an array.

Given an interval [min_val, max_val], values outside the interval are clipped to the interval edges.
Values smaller than min_val become min_val, and values larger than max_val become max_val.

This operation is equivalent to but faster than np.minimum(max_val, np.maximum(arr, min_val)).
The function performs element-wise clipping and preserves the shape of the input array.

From NumPy documentation:
- Parameters: 
  - a (array_like) - Array containing elements to clip
  - a_min (scalar) - Minimum value threshold
  - a_max (scalar) - Maximum value threshold
- Returns: clipped array with values limited to [a_min, a_max]

Special behavior:
- If a_min > a_max, all values become a_max
- No validation is performed to ensure a_min < a_max

Specification: numpy.clip returns a vector where each element is clipped to the interval [min_val, max_val].

Mathematical Properties:
1. Element-wise correctness: 
   - If arr[i] < min_val, then result[i] = min_val
   - If arr[i] > max_val, then result[i] = max_val  
   - If min_val ≤ arr[i] ≤ max_val, then result[i] = arr[i]
2. Boundary behavior: Values are clamped to the closed interval [min_val, max_val]
3. Preserves vector length: result.size = arr.size
4. Idempotency: clip(clip(arr, min_val, max_val), min_val, max_val) = clip(arr, min_val, max_val)
5. Monotonicity: If min_val ≤ max_val, then min_val ≤ result[i] ≤ max_val for all i
6. Special case: If min_val > max_val, then result[i] = max_val for all i

Precondition: True (no special preconditions, handles all real number inputs)
Postcondition: For all indices i, result[i] is the clipped value of arr[i]","use vstd::prelude::*;

verus! {",,"fn clip(arr: &Vec<i8>, min_val: i8, max_val: i8) -> (result: Vec<i8>)
    ensures
        result.len() == arr.len(),
        forall|i: int| 0 <= i < result.len() ==> {
            if (min_val as int) <= (max_val as int) {
                if (arr[i] as int) < (min_val as int) {
                    (result[i] as int) == (min_val as int)
                } else if (arr[i] as int) > (max_val as int) {
                    (result[i] as int) == (max_val as int)
                } else {
                    (result[i] as int) == (arr[i] as int)
                }
            } else {
                (result[i] as int) == (max_val as int)
            }
        }","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0294,verus,numpy_triple,mathematical_functions_conj,,"Return the complex conjugate of a vector of complex numbers, element-wise

Specification: conj computes the complex conjugate of each element with the following properties:
    1. Basic definition: conj(a + bi) = a - bi for complex numbers
    2. Real preservation: For purely real numbers, conj(x) = x
    3. Involution property: conj(conj(x)) = x (double conjugation returns original)
    4. Magnitude preservation: |conj(x)| = |x| (conjugate preserves magnitude)
    5. Distributive over addition: conj(x + y) = conj(x) + conj(y)
    6. Distributive over multiplication: conj(x * y) = conj(x) * conj(y)","use vstd::prelude::*;

verus! {

/* Structure representing a complex number with integer components */
#[derive(PartialEq, Eq)]
pub struct Complex {
    /* The real part of the complex number */
    pub real: int,
    /* The imaginary part of the complex number */
    pub imag: int,
}

impl Complex {
    /* Addition of complex numbers */
    pub open spec fn add(self, other: Complex) -> Complex {
        Complex { real: self.real + other.real, imag: self.imag + other.imag }
    }

    /* Multiplication of complex numbers */
    pub open spec fn mul(self, other: Complex) -> Complex {
        Complex { 
            real: self.real * other.real - self.imag * other.imag,
            imag: self.real * other.imag + self.imag * other.real
        }
    }

    /* Magnitude squared of a complex number */
    pub open spec fn norm_sq(self) -> int {
        self.real * self.real + self.imag * self.imag
    }

    /* Complex conjugate of a single complex number */
    pub open spec fn conj(self) -> Complex {
        Complex { real: self.real, imag: -self.imag }
    }
}",,"fn conj(x: Vec<Complex>) -> (result: Vec<Complex>)
    ensures
        result.len() == x.len(),
        forall|i: int| 0 <= i < x@.len() ==> 
            result@[i].real == x@[i].real && result@[i].imag == -x@[i].imag,
        forall|i: int| 0 <= i < x@.len() ==> 
            x@[i].imag == 0 ==> result@[i] == x@[i],
        forall|i: int| 0 <= i < x@.len() ==> 
            result@[i].conj() == x@[i],
        forall|i: int| 0 <= i < x@.len() ==> 
            x@[i].norm_sq() == result@[i].norm_sq(),
        forall|i: int, y: Complex| 0 <= i < x@.len() ==> 
            x@[i].add(y).conj() == result@[i].add(y.conj()),
        forall|i: int, y: Complex| 0 <= i < x@.len() ==> 
            x@[i].mul(y).conj() == result@[i].mul(y.conj())","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0295,verus,numpy_triple,mathematical_functions_convolve,,"numpy.convolve: Returns the discrete, linear convolution of two one-dimensional arrays.

The discrete convolution operation is defined as:
(a * v)[n] = sum(a[m] * v[n - m], m = -∞ to ∞)

For finite arrays, the convolution is computed over the valid range where
both arrays have elements. This implementation follows the 'full' mode
which returns a convolution of length (M + N - 1) where M and N are
the lengths of the input arrays.

Specification: numpy.convolve returns the discrete convolution of two vectors.

Precondition: Both input vectors must be non-empty (enforced by types)
Postcondition: The result vector contains the discrete convolution values

The convolution at position k is computed as:
result[k] = sum(a[i] * v[k - i] for all valid i)

Mathematical properties:
1. Result length is m + n - 1 (enforced by return type)
2. Each element follows the convolution definition
3. Boundary conditions: zero-padding is implicitly assumed outside array bounds","use vstd::prelude::*;

verus! {",,"spec fn convolution_element_sum(a: Seq<i32>, v: Seq<i32>, k: int) -> int
    decreases a.len()
{
    if a.len() == 0 {
        0
    } else {
        let i = 0;
        let contribution = if k >= i && k - i < v.len() {
            a[i] * v[k - i]
        } else {
            0
        };
        contribution + convolution_element_sum(a.skip(1), v, k)
    }
}

fn numpy_convolve(a: Vec<i32>, v: Vec<i32>) -> (result: Vec<i32>)
    requires a.len() > 0 && v.len() > 0,
    ensures 
        result.len() == a.len() + v.len() - 1,
        forall|k: int| 0 <= k < result.len() ==> result[k] == convolution_element_sum(a@, v@, k),
        result[0] == a[0] * v[0],
        result[result.len() - 1] == a[a.len() - 1] * v[v.len() - 1],","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0296,verus,numpy_triple,mathematical_functions_copysign,,"numpy.copysign: Change the sign of x1 to that of x2, element-wise.

Returns an array where each element has the magnitude of x1 but the sign of x2.
This function is useful for combining the absolute value of one array with 
the sign pattern of another.

For each element:
- If x2 >= 0, returns |x1|
- If x2 < 0, returns -|x1|

Special cases:
- copysign(x, 0) returns |x| (positive sign)
- copysign(0, y) returns 0 with the sign of y

Specification: numpy.copysign returns a vector where each element has
the magnitude of the corresponding element in x1 but the sign of the
corresponding element in x2.

Precondition: True (no special preconditions for copysign)
Postcondition: For all indices i:
  - If x2[i] >= 0, then result[i] = |x1[i]|
  - If x2[i] < 0, then result[i] = -|x1[i]|

Mathematical properties:
  1. result[i] = |x1[i]| * sign(x2[i]) where sign(x) = 1 if x >= 0, -1 if x < 0
  2. |result[i]| = |x1[i]| (magnitude preservation)
  3. sign(result[i]) = sign(x2[i]) (sign copying)
  4. copysign(x1, x2) = copysign(|x1|, x2) (idempotence on magnitude)","use vstd::prelude::*;

verus! {",,"fn copysign(x1: Vec<i8>, x2: Vec<i8>) -> (result: Vec<i8>)
    requires x1.len() == x2.len(),
    ensures 
        result.len() == x1.len(),
        forall|i: int| 0 <= i < result.len() ==> {
            /* Basic behavior: sign copying with magnitude preservation */
            (x2@[i] >= 0 ==> result@[i] as int == if x1@[i] >= 0 { x1@[i] as int } else { -(x1@[i] as int) }) &&
            (x2@[i] < 0 ==> result@[i] as int == if x1@[i] >= 0 { -(x1@[i] as int) } else { x1@[i] as int }) &&
            /* Magnitude preservation property: |result[i]| = |x1[i]| */
            (if result@[i] >= 0 { result@[i] as int } else { -(result@[i] as int) }) == 
            (if x1@[i] >= 0 { x1@[i] as int } else { -(x1@[i] as int) }) &&
            /* Sign copying property: result has same sign as x2 */
            (x2@[i] >= 0 ==> result@[i] >= 0) &&
            (x2@[i] < 0 ==> result@[i] < 0)
        }","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0297,verus,numpy_triple,mathematical_functions_cos,,"numpy.cos: Cosine element-wise.

Computes the cosine of each element in the input array.
The cosine is one of the fundamental functions of trigonometry.
For a real number x interpreted as an angle in radians, cos(x)
gives the x-coordinate of the point on the unit circle.

Returns an array of the same shape as x, containing the cosine of each element.

Specification: numpy.cos returns a vector where each element is the cosine
of the corresponding element in x (interpreted as radians).

Precondition: True (no special preconditions for cosine)
Postcondition: For all indices i, result[i] = Float.cos x[i]
              and result[i] is bounded between -1 and 1
              with cos(0) = 1","use vstd::prelude::*;

verus! {",,"fn numpy_cos(x: Vec<i8>) -> (result: Vec<i8>)
    ensures
        result.len() == x.len(),
        forall|i: int| 0 <= i < result@.len() ==> {
            -1 <= result@[i] as int <= 1 &&
            (x@[i] as int == 0 ==> result@[i] as int == 1)
        }","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0298,verus,numpy_triple,mathematical_functions_cosh,,"numpy.cosh: Hyperbolic cosine, element-wise.

The hyperbolic cosine function is defined as:
cosh(x) = (e^x + e^(-x)) / 2

It represents the x-coordinate of a point on the unit hyperbola,
analogous to how cosine represents the x-coordinate on the unit circle.

Returns an array of the same shape as x, containing the hyperbolic cosine of each element.

/* Core mathematical definition placeholder */","use vstd::prelude::*;

verus! {",,"fn numpy_cosh(x: Vec<f32>) -> (result: Vec<f32>)
    requires x@.len() > 0,
    ensures
        result@.len() == x@.len(),
        forall|i: int| 0 <= i < result@.len() ==> {
            result@[i] == result@[i]
        }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0299,verus,numpy_triple,mathematical_functions_cross,,"numpy.cross: Return the cross product of two (arrays of) vectors.

The cross product of a and b in R^3 is a vector perpendicular to both a and b.
For 3D vectors a = [a0, a1, a2] and b = [b0, b1, b2], the cross product is:
c = [a1*b2 - a2*b1, a2*b0 - a0*b2, a0*b1 - a1*b0]

This implementation focuses on the 3D case, which is the most common usage.
The result vector is perpendicular to both input vectors according to the
right-hand rule.

Specification: numpy.cross returns the cross product of two 3D vectors.

Precondition: True (vectors must be 3D, enforced by type)
Postcondition: 
1. The result components follow the cross product formula
2. The result is perpendicular to both input vectors (dot product is zero)
3. Anti-commutativity: a × b = -(b × a)
4. Bilinearity properties
5. Zero property: if a and b are parallel, then a × b = 0","use vstd::prelude::*;

verus! {",,"fn cross(a: Vec<i8>, b: Vec<i8>) -> (result: Vec<i8>)
    requires 
        a.len() == 3,
        b.len() == 3,
    ensures 
        result.len() == 3,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0300,verus,numpy_triple,mathematical_functions_cumprod,,"numpy.cumprod: Return the cumulative product of elements along a given axis.

For a vector [a₁, a₂, a₃, ..., aₙ], returns [a₁, a₁*a₂, a₁*a₂*a₃, ..., a₁*a₂*...*aₙ].

This function computes the cumulative product by applying successive multiplications
from left to right, producing a result vector of the same length as the input.

The cumulative product is computed as: result[i] = ∏(k=0 to i) input[k]

For empty vectors, returns an empty vector.

Specification: cumprod returns the cumulative product of elements.

Precondition: True (works for any vector, including empty)
Postcondition: 
- Result has same length as input
- For any index i, result[i] = product of all elements from a[0] to a[i] inclusive
- Equivalently: result[i] = a[0] * a[1] * ... * a[i]
- For empty vectors, returns empty vector (vacuous condition holds)

Mathematical Properties:
- result[0] = a[0] (when n > 0)
- result[i+1] = result[i] * a[i+1] (cumulative property)
- Each element is the product of all preceding elements (including itself)","use vstd::prelude::*;

verus! {",,"spec fn product_prefix(a: Seq<int>, end: int) -> int
    decreases end
{
    if end <= 0 {
        1
    } else if end == 1 {
        a[0]
    } else {
        product_prefix(a, end - 1) * a[end - 1]
    }
}

fn cumprod(a: Vec<i8>) -> (result: Vec<i8>)
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < a.len() ==> result[i] as int == product_prefix(a@.map(|_index, x: i8| x as int), i + 1),
        forall|i: int, j: int| 0 <= i < a.len() && j == i + 1 && j < a.len() ==> 
            result[j] as int == (result[i] as int) * (a[j] as int)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0301,verus,numpy_triple,mathematical_functions_cumsum,,"numpy.cumsum: Return the cumulative sum of the elements along a given axis.

For a 1D array, cumsum computes the cumulative sum where each element
is the sum of all previous elements plus itself. For example:
[1, 2, 3, 4] becomes [1, 3, 6, 10]

The cumulative sum is defined as:
- result[0] = a[0]
- result[i] = result[i-1] + a[i] for i > 0

Specification: numpy.cumsum returns a vector where each element is the
cumulative sum up to that position.

Precondition: True (no special preconditions)
Postcondition: 
- For non-empty vectors, the first element equals the first element of the input
- Each subsequent element equals the previous cumulative sum plus the current element
- The cumulative sum has the property that result[i] = sum of a[0] through a[i]","use vstd::prelude::*;

verus! {",,"spec fn prefix_sum(a: Seq<i32>, i: int) -> int
    decreases i
{
    if i < 0 || i >= a.len() {
        0
    } else if i == 0 {
        a[0] as int
    } else {
        prefix_sum(a, i - 1) + (a[i] as int)
    }
}

fn numpy_cumsum(a: Vec<i32>) -> (result: Vec<i32>)
    ensures 
        result.len() == a.len(),
        a.len() > 0 ==> result[0] == a[0],
        forall|i: int| 0 < i < a.len() ==> result[i] == result[i - 1] + a[i],
        forall|i: int| 0 <= i < a.len() ==> result[i] as int == prefix_sum(a@, i)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0302,verus,numpy_triple,mathematical_functions_deg2rad,,"Convert angles from degrees to radians

Convert angles from degrees to radians by multiplying by π/180.
This function performs the standard mathematical conversion from degrees to radians
where π radians = 180 degrees.

Specification: deg2rad converts each degree value to radians using the formula radians = degrees * π/180","use vstd::prelude::*;

verus! {",,"fn deg2rad(degrees: Vec<i8>) -> (radians: Vec<i8>)
    ensures 
        radians.len() == degrees.len(),
        forall|i: int| 0 <= i < degrees.len() ==> #[trigger] radians@[i] as int == degrees@[i] as int * 314 / 18000","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0304,verus,numpy_triple,mathematical_functions_diff,,"numpy.diff: Calculate the n-th discrete difference along the given axis.

The first difference is given by out[i] = a[i+1] - a[i] along the given axis.
Higher differences are calculated by using diff recursively.

For a 1D array, the first difference computes the difference between 
consecutive elements, producing an array with one less element.

The function is particularly useful for numerical analyses where 
understanding incremental changes within data is crucial.

Specification: numpy.diff returns a vector where each element is the difference
of consecutive elements from the input array.

Precondition: Input array must be non-empty (at least 2 elements for first difference)
Postcondition: For all indices i, result[i] = a[i+1] - a[i]

Mathematical Properties:
1. Length property: |result| = |input| - 1
2. Difference property: Each element represents the discrete difference
3. Type preservation: Result maintains the same numeric type as input
4. Monotonicity: If input is monotonic, result has consistent sign","use vstd::prelude::*;

verus! {",,"fn numpy_diff(a: Vec<i8>) -> (result: Vec<i8>)
    requires a.len() >= 2,
    ensures 
        result.len() == a.len() - 1,
        forall|i: int| 0 <= i < result.len() ==> result[i] as int == a[i + 1] as int - a[i] as int,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0305,verus,numpy_triple,mathematical_functions_divide,,"numpy.divide: Divide arguments element-wise.

Divides two vectors element-wise. If the vectors have the same shape,
each element of the result is the quotient of the corresponding elements
from the input vectors.

This is equivalent to x1 / x2 in terms of array broadcasting.
Division by zero results in infinity or NaN according to IEEE 754 standard.

Specification: numpy.divide returns a vector where each element is the quotient
of the corresponding elements from x1 and x2.

Precondition: True (handles division by zero according to IEEE 754)
Postcondition: For all indices i, result[i] = x1[i] / x2[i]

Additional properties:
- When x2[i] ≠ 0, result[i] * x2[i] = x1[i] (within floating point precision)
- When x2[i] = 0 and x1[i] ≠ 0, result[i] is infinite
- When x2[i] = 0 and x1[i] = 0, result[i] is NaN","use vstd::prelude::*;

verus! {",,"fn numpy_divide(x1: Vec<f32>, x2: Vec<f32>) -> (result: Vec<f32>)
    requires 
        x1.len() == x2.len(),
    ensures 
        result.len() == x1.len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0306,verus,numpy_triple,mathematical_functions_divmod,,"numpy.divmod: Return element-wise quotient and remainder simultaneously.

Performs element-wise division returning both the quotient and remainder.
For each pair of elements (x, y), returns (x // y, x % y) where:
- x // y is the floor division (largest integer ≤ x/y)
- x % y is the remainder such that x = y * (x // y) + (x % y)

This is equivalent to (x // y, x % y) but faster because it avoids
redundant work by computing both values in a single operation.

From NumPy documentation:
- Parameters: x1, x2 (array_like) - The dividend and divisor arrays
- Returns: (quotient, remainder) - tuple of ndarrays with element-wise results

Mathematical properties:
1. Division identity: x1[i] = x2[i] * quotient[i] + remainder[i]
2. Remainder bounds: 0 ≤ |remainder[i]| < |x2[i]| (for positive divisors)
3. Sign consistency: remainder has same sign as divisor (Python % semantics)

Specification: numpy.divmod returns a tuple of vectors containing the quotient 
and remainder of element-wise division.

Mathematical Properties:
1. Division identity: For all i, x1[i] = x2[i] * quotient[i] + remainder[i]
2. Quotient correctness: quotient[i] = floor(x1[i] / x2[i])
3. Remainder correctness: remainder[i] = x1[i] - x2[i] * quotient[i]
4. Remainder bounds: |remainder[i]| < |x2[i]| (when x2[i] ≠ 0)
5. Sign consistency: remainder[i] has same sign as x2[i] (Python % semantics)
6. Equivalence: divmod(x1, x2) = (floor_divide(x1, x2), mod(x1, x2))

Precondition: All elements in x2 must be non-zero
Postcondition: Returns (quotient, remainder) where the mathematical properties hold","use vstd::prelude::*;

verus! {",,"fn divmod(x1: Vec<i8>, x2: Vec<i8>) -> (result: (Vec<i8>, Vec<i8>))
    requires 
        x1.len() == x2.len(),
        forall|i: int| 0 <= i < x2.len() ==> x2[i] != 0,
    ensures ({
        let (quotient, remainder) = result;
        &&& quotient.len() == x1.len()
        &&& remainder.len() == x1.len()
        &&& forall|i: int| 0 <= i < x1.len() ==> 
            x1[i] as int == x2[i] as int * quotient[i] as int + remainder[i] as int
    })","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0307,verus,numpy_triple,mathematical_functions_ediff1d,,"numpy.ediff1d: The differences between consecutive elements of an array.

Computes the differences between consecutive elements of an array.
For an input array [a, b, c, d], returns [b-a, c-b, d-c].

The function always returns a 1D array, and if necessary, the input
will be flattened before the differences are taken.

This is equivalent to ary.flat[1:] - ary.flat[:-1] in NumPy.

Specification: numpy.ediff1d returns a vector of differences between consecutive elements.

Precondition: The input vector must have at least one element (enforced by type)
Postcondition: For all indices i, result[i] = ary[i+1] - ary[i]

Key properties:
1. The result has length n for input of length n+1
2. Each element represents the difference between consecutive elements
3. The result is always 1D regardless of input shape
4. Mathematically: result[i] = ary[i+1] - ary[i] for all valid i","use vstd::prelude::*;

verus! {",,"fn numpy_ediff1d(ary: Vec<i8>) -> (result: Vec<i8>)
    requires ary.len() > 0,
    ensures 
        result.len() == ary.len() - 1,
        forall|i: int| 0 <= i < result.len() ==> result[i] as int == ary[i + 1] as int - ary[i] as int,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0308,verus,numpy_triple,mathematical_functions_exp,,"numpy.exp: Calculate the exponential of all elements in the input array.

Computes the exponential function (e^x) element-wise. This is the inverse
of the natural logarithm function. For each element x in the input array,
the result contains e^x where e is Euler's number (approximately 2.71828).

The exponential function has the mathematical property that exp(x + y) = exp(x) * exp(y)
and exp(0) = 1.

Returns an array of the same shape as x, containing the exponential values.

Specification: numpy.exp returns a vector where each element is the
exponential (e^x) of the corresponding element in x.

Precondition: True (exponential function is defined for all real numbers)
Postcondition: For all indices i, result[i] = e^(x[i])

Mathematical properties:
- exp(0) = 1 for any zero elements
- exp(x) > 0 for all x (exponential is always positive)
- exp is monotonically increasing
- exp(x + y) = exp(x) * exp(y) (for addition in the input)

/* Mathematical specification: For all indices i, result[i] = exp(x[i])
           Note: Verus doesn't have built-in exp function for f32,
           so we provide a simplified specification that maintains array length */","use vstd::prelude::*;

verus! {",,"fn numpy_exp(x: Vec<f32>) -> (result: Vec<f32>)
    ensures
        result.len() == x.len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0309,verus,numpy_triple,mathematical_functions_exp2,,"Calculate 2**p for all p in the input array. numpy.exp2: Calculate 2 raised to the power of each element in the input vector.

Computes 2^p for all p in the input vector, element-wise.
This is equivalent to applying the exponential function with base 2
to each element of the input vector.

From NumPy documentation:
- Parameters: x (array_like) - Input values
- Returns: y (ndarray) - 2**x, element-wise

The function is implemented as a universal function (ufunc) that
operates element-wise on arrays and supports broadcasting.
For finite input values, the result is always positive.

Specification: numpy.exp2 computes 2 raised to the power of each element 
in the input vector.

Mathematical Properties:
1. Element-wise correctness: result[i] = 2^x[i] for all i
2. Fundamental exponential identity: exp2(0) = 1
3. Base property: exp2(1) = 2
4. Negative powers: exp2(-1) = 0.5
5. Positivity: exp2(x) > 0 for all finite x
6. Monotonicity: if x[i] < x[j], then exp2(x)[i] < exp2(x)[j]
7. Exponential addition rule: exp2(a + b) = exp2(a) * exp2(b)
8. Preservation of vector length: result.size = x.size
9. Handles IEEE 754 floating-point arithmetic

Precondition: True (no special preconditions for exp2)
Postcondition: For all indices i, result[i] = 2^x[i] and result[i] > 0","use vstd::prelude::*;

verus! {",,"fn exp2(x: Vec<f32>) -> (result: Vec<f32>)
    ensures
        result.len() == x.len(),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0310,verus,numpy_triple,mathematical_functions_expm1,,"Calculate exp(x) - 1 for all elements in the vector.
This function provides greater precision than exp(x) - 1 for small values of x.

Specification: expm1 computes exp(x) - 1 element-wise with enhanced numerical precision","use vstd::prelude::*;

verus! {",,"fn expm1(x: Vec<f32>) -> (result: Vec<f32>)
    requires x@.len() > 0,
    ensures 
        result@.len() == x@.len(),
        forall|i: int| 0 <= i < x@.len() ==> {
            /* Basic mathematical property: result equals exp(x) - 1 */
            true &&
            /* Identity property: expm1(0) = 0 */
            (x@[i] == 0.0f32 ==> result@[i] == 0.0f32) &&
            /* Sign preservation and bounds properties */
            true
        }","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0311,verus,numpy_triple,mathematical_functions_fabs,,"Compute the absolute values element-wise for floating-point numbers

Specification: fabs computes the absolute value of each element","use vstd::prelude::*;

verus! {",,"fn fabs(x: Vec<f32>) -> (result: Vec<f32>)
    ensures
        result.len() == x.len()","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0312,verus,numpy_triple,mathematical_functions_fix,,"Round to nearest integer towards zero, element-wise.

The fix (truncation) of each element x is the integer part of x,
obtained by discarding the fractional part. This is equivalent to
rounding towards zero.

For positive numbers: fix(x) = floor(x)
For negative numbers: fix(x) = ceil(x)

Returns an array of the same shape as x, containing the fix of each element.

Specification: numpy.fix returns a vector where each element is the
fix (truncation towards zero) of the corresponding element in x.

Precondition: True (fix is defined for all real numbers)
Postcondition: For all indices i, result[i] is the fix of x[i], meaning:
- result[i] is an integer value (represented as Float)
- |result[i]| ≤ |x[i]| (magnitude is reduced or equal)
- result[i] has the same sign as x[i] (or zero if x[i] is zero)
- |x[i] - result[i]| < 1 (difference is less than 1)
- For positive x[i]: result[i] = floor(x[i])
- For negative x[i]: result[i] = ceil(x[i])
- For zero x[i]: result[i] = 0
- Monotonicity: if x[i] ≤ x[j] then result[i] ≤ result[j]
- Truncation property: result[i] truncates towards zero

/* Round to nearest integer towards zero, element-wise.

   The fix (truncation) of each element x is the integer part of x,
   obtained by discarding the fractional part. This is equivalent to
   rounding towards zero.

   For positive numbers: fix(x) = floor(x)
   For negative numbers: fix(x) = ceil(x)

   Returns an array of the same shape as x, containing the fix of each element.
*/","use vstd::prelude::*;

verus! {",,"fn numpy_fix(x: Vec<f64>) -> (result: Vec<f64>)
    ensures result.len() == x.len()","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0313,verus,numpy_triple,mathematical_functions_float_power,,"Element-wise power operation with float promotion. 
Raises each element of the base vector to the corresponding power in the exponent vector.
All values are promoted to Float (minimum precision of Float64).

Specification: float_power computes element-wise exponentiation with appropriate constraints.
- For positive bases: result is always well-defined
- For zero bases: only non-negative exponents are valid
- For negative bases: only integer exponents are mathematically valid (though NumPy allows all)
- The result preserves the mathematical power relationship element-wise","use vstd::prelude::*;

verus! {","spec fn float_pow(base: f64, exponent: f64) -> f64;","fn float_power(base: Vec<f64>, exponent: Vec<f64>) -> (result: Vec<f64>)
    requires 
        base.len() == exponent.len()
    ensures 
        result.len() == base.len(),
        forall|i: int| 0 <= i < result.len() ==> 
            result[i] == float_pow(base[i], exponent[i])","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0314,verus,numpy_triple,mathematical_functions_floor,,"Return the floor of the input, element-wise.

The floor of each element x is the largest integer i, such that i <= x.
This is a fundamental mathematical operation that rounds down to the
nearest integer.

Returns an array of the same shape as x, containing the floor of each element.

Specification: numpy.floor returns a vector where each element is the
floor (largest integer less than or equal to) the corresponding element in x.

Precondition: True (floor is defined for all real numbers)
Postcondition: For all indices i, result[i] is the floor of x[i], meaning:
- result[i] is an integer value (represented as Float)
- result[i] ≤ x[i]
- x[i] < result[i] + 1
- There is no integer k such that result[i] < k ≤ x[i]
- Monotonicity: if x[i] ≤ x[j] then result[i] ≤ result[j]
- Idempotence: floor(floor(x)) = floor(x)
- Relationship with ceiling: result[i] = -((-x[i]).ceil) when x[i] is not an integer
- Integer preservation: if x[i] is an integer, then result[i] = x[i]","use vstd::prelude::*;

verus! {",,"fn numpy_floor(x: Vec<i32>) -> (result: Vec<i32>)
    requires x.len() > 0,
    ensures 
        result.len() == x.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] <= x[i],
        forall|i: int| 0 <= i < result.len() ==> x[i] < result[i] + 1,
        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result.len() && x[i] <= x[j] ==> result[i] <= result[j],
        forall|i: int| 0 <= i < result.len() ==> result[i] == x[i]","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0315,verus,numpy_triple,mathematical_functions_floor_divide,,"numpy.floor_divide: Return the largest integer smaller or equal to the division of the inputs.

Performs element-wise floor division of two vectors. For each pair of elements,
returns the largest integer less than or equal to their division.

This is equivalent to the Python // operator and pairs with the modulo operation
such that a = a % b + b * (a // b) up to roundoff.

Specification: numpy.floor_divide returns a vector where each element is the floor
of the division of the corresponding elements from x1 and x2.

This function implements Python's // operator behavior for element-wise operations.

Precondition: All elements in x2 must be non-zero
Postcondition: 
1. For all indices i, result[i] = floor(x1[i] / x2[i])
2. For all indices i, result[i] is the largest integer ≤ x1[i] / x2[i]
3. The fundamental floor division property: result[i] ≤ x1[i] / x2[i] < result[i] + 1
4. This pairs with modulo such that: x1[i] = x2[i] * result[i] + remainder

/* Floor division properties:
             * 1. result[i] is the floor of x1[i] / x2[i]
             * 2. result[i] <= x1[i] / x2[i] 
             * 3. x1[i] / x2[i] < result[i] + 1.0
             */","use vstd::prelude::*;

verus! {",,"spec fn floor_div_prop(x: f64, y: f64) -> bool {
    y != 0.0
}

fn numpy_floor_divide(x1: Vec<f64>, x2: Vec<f64>) -> (result: Vec<f64>)
    requires 
        x1.len() == x2.len(),
        forall|i: int| 0 <= i < x2@.len() ==> x2@[i] != 0.0,
    ensures
        result@.len() == x1@.len(),
        forall|i: int| 0 <= i < result@.len() ==> {

            floor_div_prop(x1@[i], x2@[i])
        },","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0316,verus,numpy_triple,mathematical_functions_fmax,,"Element-wise maximum of array elements.

Compare two arrays and returns a new array containing the element-wise maxima. If one of the elements being compared is a NaN, then the non-nan element is returned.

Element-wise maximum of two vectors, with special NaN handling.
If one element is NaN, returns the non-NaN element.

Specification: fmax returns element-wise maximum with NaN handling.
For each position i:
- If both elements are non-NaN, returns the maximum
- If x[i] is NaN and y[i] is not, returns y[i]  
- If y[i] is NaN and x[i] is not, returns x[i]
- If both are NaN, returns NaN
Additional mathematical properties:
- Commutative when both values are non-NaN
- Associative when all values are non-NaN
- Idempotent when values are non-NaN","use vstd::prelude::*;

verus! {
spec fn is_nan(f: f32) -> bool;

spec fn float_max(x: f32, y: f32) -> f32;",,"fn fmax(x: Vec<f32>, y: Vec<f32>) -> (result: Vec<f32>)
    requires x@.len() == y@.len(),
    ensures 
        result@.len() == x@.len(),
        forall|i: int| 0 <= i < result@.len() ==> {
            /* Core NaN handling behavior */
            (!is_nan(x@[i]) && !is_nan(y@[i])) ==> 
                (result@[i] == float_max(x@[i], y@[i])) &&
            (is_nan(x@[i]) && !is_nan(y@[i])) ==> 
                (result@[i] == y@[i]) &&
            (!is_nan(x@[i]) && is_nan(y@[i])) ==> 
                (result@[i] == x@[i]) &&
            (is_nan(x@[i]) && is_nan(y@[i])) ==> 
                is_nan(result@[i]) &&
            /* Mathematical properties for non-NaN cases */
            (!is_nan(x@[i]) && !is_nan(y@[i])) ==> 
                (result@[i] == x@[i] || result@[i] == y@[i]) &&
            /* NaN preservation: result is NaN iff both inputs are NaN */
            is_nan(result@[i]) <==> (is_nan(x@[i]) && is_nan(y@[i]))
        }","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,DupVT00,0.85
VT0317,verus,numpy_triple,mathematical_functions_fmin,,"Element-wise minimum of array elements.

Compare two arrays and returns a new array containing the element-wise minima. If one of the elements being compared is a NaN, then the non-nan element is returned.

Element-wise minimum of two vectors, with special NaN handling.
If one element is NaN, returns the non-NaN element.

Specification: fmin returns element-wise minimum with NaN handling.
For each position i:
- If both elements are non-NaN, returns the minimum
- If x[i] is NaN and y[i] is not, returns y[i]  
- If y[i] is NaN and x[i] is not, returns x[i]
- If both are NaN, returns NaN
- Mathematical properties: commutativity (ignoring NaN order), 
  idempotence for non-NaN values, and boundedness","use vstd::prelude::*;

verus! {",,"fn fmin(x: Vec<f32>, y: Vec<f32>) -> (result: Vec<f32>)
    requires x@.len() == y@.len(),
    ensures
        result@.len() == x@.len(),
        forall|i: int| 0 <= i < x@.len() ==> #[trigger] result@[i] == x@[i] || #[trigger] result@[i] == y@[i]","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVT00,0.85
VT0318,verus,numpy_triple,mathematical_functions_fmod,,Returns the element-wise remainder of division where the remainder has the same sign as the dividend,"use vstd::prelude::*;

verus! {",,"fn fmod(x1: &Vec<f32>, x2: &Vec<f32>) -> (result: Vec<f32>)
    requires x1.len() == x2.len(),
    ensures result.len() == x1.len()","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0319,verus,numpy_triple,mathematical_functions_frexp,,"numpy.frexp: Decompose the elements of x into mantissa and twos exponent.

Returns (mantissa, exponent), where x = mantissa * 2**exponent.
The mantissa is in the range [0.5, 1) for positive numbers, (-1, -0.5] for negative numbers,
or 0 if x is 0. The exponent is an integer.

For special values:
- If x is 0, returns (0.0, 0)
- If x is infinity, returns (infinity, 0)
- If x is NaN, returns (NaN, 0)

Specification: frexp decomposes each element into mantissa and exponent such that
x = mantissa * 2^exponent, where the mantissa is normalized to be in [0.5, 1) for
positive values or (-1, -0.5] for negative values.

Precondition: True (no special preconditions)
Postcondition: For all indices i:
- If x[i] = 0, then mantissa[i] = 0 and exponent[i] = 0
- If x[i] is finite and non-zero, then:
  - x[i] = mantissa[i] * 2^exponent[i] (reconstruction property)
  - 0.5 ≤ |mantissa[i]| < 1.0 (normalization property)
  - mantissa[i] has same sign as x[i] (sign preservation)
- If x[i] is infinity or NaN, then mantissa[i] = x[i] and exponent[i] = 0
- Result vectors have same length as input (length preservation)

/* Zero case: if input is zero, mantissa is zero and exponent is zero */

/* Note: More complex properties like reconstruction (x = mantissa * 2^exponent),
               normalization bounds, and sign preservation would require additional
               floating-point operations that are not readily available in Verus specs */","use vstd::prelude::*;

verus! {",,"fn frexp(x: Vec<f32>) -> (result: (Vec<f32>, Vec<i8>))
    ensures
        result.0.len() == x.len(),
        result.1.len() == x.len(),
        forall|i: int| 0 <= i < x.len() ==> {

            x[i] == 0.0f32 ==> result.0[i] == 0.0f32 && result.1[i] == 0

        }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0320,verus,numpy_triple,mathematical_functions_gcd,,"numpy.gcd: Returns the greatest common divisor of |x1| and |x2|, element-wise.

The GCD is computed on the absolute values of the inputs. For two integers a and b,
gcd(a, b) is the largest positive integer that divides both |a| and |b|.

Special cases:
- gcd(0, 0) = 0
- gcd(a, 0) = |a| for any non-zero a
- gcd(0, b) = |b| for any non-zero b

Returns an array of the same shape as the broadcasted x1 and x2.

Specification: numpy.gcd returns a vector where each element is the
greatest common divisor of the absolute values of the corresponding elements in x1 and x2.

Mathematical properties verified:
1. Correctness: result[i] = gcd(x1[i], x2[i])
2. Non-negativity: result[i] ≥ 0 (GCD is always non-negative)
3. Equivalence to absolute values: gcd(a, b) = gcd(|a|, |b|)
4. Special cases: gcd(0,0)=0, gcd(a,0)=|a|, gcd(0,b)=|b|
5. Divisibility: gcd(a,b) divides both a and b
6. Greatest property: any common divisor of a and b also divides gcd(a,b)
7. Commutativity: gcd(a,b) = gcd(b,a)","use vstd::prelude::*;

verus! {",,"#[verifier::external_body]
spec fn gcd(a: int, b: int) -> int {
    unimplemented!()
}

spec fn int_abs(x: int) -> int {
    if x >= 0 { x } else { -x }
}

fn numpy_gcd(x1: Vec<i8>, x2: Vec<i8>) -> (result: Vec<i8>)
    requires x1@.len() == x2@.len(),
    ensures
        result@.len() == x1@.len(),
        forall|i: int| 0 <= i < result@.len() ==> #[trigger] result@[i] as int == gcd(x1@[i] as int, x2@[i] as int),
        forall|i: int| 0 <= i < result@.len() ==> #[trigger] result@[i] >= 0,
        forall|i: int| 0 <= i < result@.len() ==> gcd(x1@[i] as int, x2@[i] as int) == #[trigger] gcd(int_abs(x1@[i] as int), int_abs(x2@[i] as int)),
        forall|i: int| 0 <= i < result@.len() ==> (x1@[i] == 0 && x2@[i] == 0) ==> #[trigger] result@[i] == 0,
        forall|i: int| 0 <= i < result@.len() ==> (x1@[i] != 0 && x2@[i] == 0) ==> #[trigger] result@[i] as int == int_abs(x1@[i] as int),
        forall|i: int| 0 <= i < result@.len() ==> (x1@[i] == 0 && x2@[i] != 0) ==> #[trigger] result@[i] as int == int_abs(x2@[i] as int),
        forall|i: int| 0 <= i < result@.len() ==> #[trigger] (result@[i] as int) % (x1@[i] as int) == 0 && (result@[i] as int) % (x2@[i] as int) == 0,
        forall|i: int| 0 <= i < result@.len() ==> gcd(x2@[i] as int, x1@[i] as int) == #[trigger] gcd(x1@[i] as int, x2@[i] as int),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0321,verus,numpy_triple,mathematical_functions_gradient,,"numpy.gradient: Return the gradient of an N-dimensional array.

The gradient is computed using second order accurate central differences 
in the interior points and either first or second order accurate one-sided 
(forward or backwards) differences at the boundaries.

For a 1D array, the gradient is a vector of the same size where:
- At the boundaries, one-sided differences are used
- In the interior, central differences are used

This captures the rate of change of the function represented by the array.

Specification: numpy.gradient computes the numerical gradient using finite differences.

The gradient satisfies these mathematical properties:
1. For a single point array (n = 0), the gradient is 0
2. For arrays with multiple points (n > 0):
   - At the first boundary (i = 0): uses forward difference grad[0] = f[1] - f[0]
   - At the last boundary (i = n): uses backward difference grad[n] = f[n] - f[n-1]
   - For interior points (0 < i < n): uses central difference grad[i] = (f[i+1] - f[i-1]) / 2
3. The gradient has the same size as the input array
4. The gradient approximates the derivative at each point

This specification assumes unit spacing between points. The actual numpy 
function can handle custom spacing, but we focus on the core mathematical behavior.

Mathematical properties:
- For linear functions f(x) = ax + b, the gradient is constant and equal to a
- For constant functions, the gradient is 0 everywhere
- The gradient operation is linear: grad(f + g) = grad(f) + grad(g)

Precondition: True (non-empty constraint is in the type Vector Float (n + 1))
Postcondition: The gradient is computed using appropriate finite difference formulas","use vstd::prelude::*;

verus! {",,"fn numpy_gradient(f: Vec<f64>) -> (grad: Vec<f64>)
    requires f.len() > 0,
    ensures
        grad.len() == f.len(),
        f.len() == 1 ==> grad[0] == 0.0,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0322,verus,numpy_triple,mathematical_functions_heaviside,,"Compute the Heaviside step function.

The Heaviside step function is defined as:
  0 if x1 < 0
  x2 if x1 == 0
  1 if x1 > 0

Compute the Heaviside step function element-wise.
Returns 0 if x < 0, x2 if x == 0, and 1 if x > 0.

Specification: The Heaviside function returns values based on the sign of x1 elements.
For each element:
- If x1[i] < 0, result[i] = 0
- If x1[i] = 0, result[i] = x2[i]
- If x1[i] > 0, result[i] = 1

This specification captures the complete behavior of the heaviside step function
including the crucial property that it's completely determined by the sign of x1
and uses x2 as the value at the discontinuity point.

// uninterpreted function representing x == 0.0

// uninterpreted function representing x > 0.0

// uninterpreted function representing x < 0.0","use vstd::prelude::*;

verus! {",,"spec fn is_zero(x: f32) -> bool {
    true
}

spec fn is_positive(x: f32) -> bool {
    true
}

spec fn is_negative(x: f32) -> bool {
    true
}

fn heaviside(x1: Vec<f32>, x2: Vec<f32>) -> (result: Vec<f32>)
    requires x1.len() == x2.len(),
    ensures 
        result.len() == x1.len(),
        forall|i: int| 0 <= i < x1.len() ==> {
            (is_negative(x1[i]) ==> result[i] == 0.0f32) &&
            (is_zero(x1[i]) ==> result[i] == x2[i]) &&
            (is_positive(x1[i]) ==> result[i] == 1.0f32) &&
            (result[i] == 0.0f32 || result[i] == 1.0f32 || result[i] == x2[i])
        }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0323,verus,numpy_triple,mathematical_functions_hypot,,"numpy.hypot: Given the 'legs' of a right triangle, return its hypotenuse.

Computes the hypotenuse of a right triangle given the lengths of its two legs.
This is equivalent to sqrt(x1^2 + x2^2), but is implemented in a way that
avoids overflow for large values.

The function operates element-wise on the input vectors, computing the
hypotenuse for each pair of corresponding elements.

Specification: numpy.hypot returns a vector where each element is the
hypotenuse computed from the corresponding elements of x1 and x2.

Precondition: True (no special preconditions)
Postcondition: For all indices i, result[i] = sqrt(x1[i]² + x2[i]²)

Mathematical properties:
1. The result is always non-negative
2. The result follows the Pythagorean theorem
3. The result is symmetric: hypot(a, b) = hypot(b, a)
4. For positive inputs, hypot(a, b) ≥ max(Float.abs(a), Float.abs(b))
5. hypot(0, a) = Float.abs(a) and hypot(a, 0) = Float.abs(a)","use vstd::prelude::*;

verus! {",,"fn numpy_hypot(x1: Vec<f32>, x2: Vec<f32>) -> (result: Vec<f32>)
    requires x1.len() == x2.len(),
    ensures 
        result.len() == x1.len(),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0324,verus,numpy_triple,mathematical_functions_i0,,"Modified Bessel function of the first kind, order 0.

Computes the Modified Bessel function of the first kind, order 0, element-wise.
This is a special function that arises in many mathematical contexts including
solutions to differential equations and probability theory.

The function is defined by the infinite series:
i0(x) = sum((x/2)^(2k) / (k!)^2, k=0..inf)

Returns an array of the same shape as x, containing the i0 values of each element.

Specification: numpy.i0 returns a vector where each element is the Modified
Bessel function of the first kind, order 0, of the corresponding element in x.

Mathematical properties:
1. i0(0) = 1 (by definition, the series starts with 1)
2. i0(x) > 0 for all real x (positive function)
3. i0(x) = i0(-x) (even function)
4. i0(x) is monotonically increasing for x ≥ 0
5. For large x, i0(x) ≈ exp(|x|) / sqrt(2π|x|) (asymptotic behavior)

Precondition: True (no special preconditions for i0)
Postcondition: For all indices i, result[i] = i0(x[i]) with the mathematical properties above","use vstd::prelude::*;

verus! {",,"fn i0(x: Vec<i8>) -> (result: Vec<i8>)
    requires true,
    ensures 
        result@.len() == x@.len(),
        forall|i: int| 0 <= i < result@.len() ==> {
            /* Basic function evaluation - i0(x) > 0 for all x (positive function) */
            result@[i] as int > 0 &&
            /* Zero case: i0(0) = 1 */
            (x@[i] as int == 0 ==> result@[i] as int == 1) &&
            /* Even function: i0(x) = i0(-x) */
            (forall|j: int| 0 <= j < x@.len() && x@[j] as int == -(x@[i] as int) ==> result@[j] as int == result@[i] as int) &&
            /* Monotonicity for non-negative values */
            (forall|j: int| 0 <= j < x@.len() && x@[i] as int >= 0 && x@[j] as int >= 0 && x@[i] as int <= x@[j] as int ==> result@[i] as int <= result@[j] as int)
        }","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0325,verus,numpy_triple,mathematical_functions_imag,,"Return the imaginary part of the complex argument. For a vector where each element is represented as a pair (real, imaginary), extracts the imaginary component of each element. For real numbers (where imaginary part is 0), returns 0.","use vstd::prelude::*;

verus! {",,"fn imag(val: Vec<(f64, f64)>) -> (result: Vec<f64>)
    ensures
        result.len() == val.len(),
        forall|i: int| 0 <= i < val.len() ==> result[i as int] == val[i as int].1,
        forall|i: int| 0 <= i < val.len() ==> (val[i as int].1 == 0.0 ==> result[i as int] == 0.0),
        forall|i: int| 0 <= i < val.len() ==> (val[i as int].0 != 0.0 || val[i as int].1 != 0.0 ==> result[i as int] == val[i as int].1),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0326,verus,numpy_triple,mathematical_functions_interp,,"One-dimensional linear interpolation for monotonically increasing sample points.
Returns the one-dimensional piecewise linear interpolant to a function with given
discrete data points (xp, fp), evaluated at x.","use vstd::prelude::*;

verus! {",,"fn interp(x: Vec<i32>, xp: Vec<i32>, fp: Vec<i32>) -> (result: Vec<i32>)
    requires 
        xp.len() > 0,
        fp.len() == xp.len(),
        x.len() > 0,
        forall|i: int, j: int| 0 <= i < j < xp.len() ==> xp[i] < xp[j],
    ensures 
        result.len() == x.len(),
        forall|k: int| 0 <= k < x.len() ==> (
            (x[k] <= xp[0] ==> result[k] == fp[0]) &&
            (x[k] >= xp[xp.len() - 1] ==> result[k] == fp[fp.len() - 1])
        )","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0327,verus,numpy_triple,mathematical_functions_lcm,,"Returns the lowest common multiple of |x1| and |x2| element-wise.

Computes the lowest common multiple (LCM) of the absolute values of 
the elements in x1 and x2. The LCM is the smallest non-negative integer 
that is a multiple of both |x1| and |x2|.

Mathematical Properties:
- lcm(a, b) = lcm(b, a) (commutativity)
- lcm(a, b) * gcd(a, b) = |a * b| (fundamental relationship)
- lcm(0, b) = lcm(a, 0) = 0 (zero property)
- lcm(a, b) ≥ 0 (non-negativity)
- |a| divides lcm(a, b) and |b| divides lcm(a, b) (divisibility)
- lcm(a, b) is minimal among all positive integers divisible by both |a| and |b|

/* Basic correctness: each element is the LCM of corresponding elements */

/* Non-negativity: LCM is always non-negative */

/* Zero property: LCM with zero is zero */

/* Special case: when both are non-zero, LCM is positive */","use vstd::prelude::*;

verus! {",,"spec fn gcd_spec(a: int, b: int) -> nat;

spec fn lcm_spec(a: int, b: int) -> nat;

fn lcm(x1: Vec<i8>, x2: Vec<i8>) -> (result: Vec<i8>)
    requires x1.len() == x2.len(),
    ensures 
        result.len() == x1@.len(),

        forall|i: int| 0 <= i < result@.len() ==> result@[i] >= 0,

        forall|i: int| 0 <= i < result@.len() ==> result@[i] >= 0,

        forall|i: int| 0 <= i < result@.len() ==> 
            (x1@[i] == 0 || x2@[i] == 0) ==> result@[i] == 0,

        forall|i: int| 0 <= i < result@.len() ==> 
            (x1@[i] != 0 && x2@[i] != 0) ==> result@[i] > 0","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0328,verus,numpy_triple,mathematical_functions_ldexp,,"Returns x1 * 2**x2, element-wise.
The mantissas x1 and twos exponents x2 are used to construct floating point numbers x1 * 2**x2.","use vstd::prelude::*;

verus! {",,"spec fn ldexp_value(x1: f32, x2: i32) -> f32;

fn ldexp(x1: Vec<f32>, x2: Vec<i32>) -> (result: Vec<f32>)
    requires x1.len() == x2.len(),
    ensures
        result.len() == x1.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] == ldexp_value(x1[i], x2[i])","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0329,verus,numpy_triple,mathematical_functions_log,,"numpy.log: Natural logarithm, element-wise.

The natural logarithm log is the inverse of the exponential function,
so that log(exp(x)) = x. The natural logarithm is logarithm base e.

Returns an array of the same shape as x, containing the natural logarithm
of each element in x.

Note: The domain of the natural logarithm is the positive real numbers.
Mathematically, log(x) is undefined for x ≤ 0.

Specification: log returns a vector where each element is the natural
logarithm of the corresponding element in x.

Precondition: All elements must be positive (x[i] > 0)
Postcondition: For all indices i, result[i] = log(x[i])

Mathematical properties:
- log is the inverse of exp: log(exp(x)) = x
- log(1) = 0
- log(e) = 1
- log(x*y) = log(x) + log(y) for positive x, y
- log is strictly increasing on (0, ∞)","use vstd::prelude::*;

verus! {",,"fn log(x: Vec<i8>) -> (result: Vec<i8>)
    requires 
        x@.len() > 0,
        forall|i: int| 0 <= i < x@.len() ==> x[i] as int > 0,
    ensures 
        result@.len() == x@.len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0330,verus,numpy_triple,mathematical_functions_log1p,,"numpy.log1p: Return the natural logarithm of one plus the input array, element-wise.

Calculates log(1 + x). This function provides greater precision than log(1 + x) 
for small values of x near zero, where the naive computation would suffer from 
floating-point precision loss.

Returns an array of the same shape as x, containing log(1 + x) for each element.

Note: The domain is x > -1 (since log(1 + x) requires 1 + x > 0).
For x = -1, the result is -∞ (negative infinity).
For x < -1, the result is NaN (not a number).

Specification: log1p returns a vector where each element is the natural
logarithm of one plus the corresponding element in x.

Precondition: All elements must be greater than -1 (x[i] > -1)
Postcondition: For all indices i, result[i] = log(1 + x[i])

Mathematical properties:
- log1p(0) = log(1) = 0
- log1p(e - 1) = 1
- log1p provides better precision than log(1 + x) for small x
- log1p is strictly increasing on (-1, ∞)
- log1p(x) = log(1 + x) for all valid x
- For small x, log1p(x) ≈ x - x²/2 + x³/3 - ...","use vstd::prelude::*;

verus! {",,"fn log1p(x: Vec<i8>) -> (result: Vec<i8>)
    requires 
        x.len() > 0,
        forall|i: int| 0 <= i < x.len() ==> x[i] as int > -1,
    ensures 
        result.len() == x.len(),
        forall|i: int| 0 <= i < x.len() && x[i] as int == 0 ==> result[i] as int == 0,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0331,verus,numpy_triple,mathematical_functions_log2,,"numpy.log2: Base-2 logarithm of x, element-wise.

The base-2 logarithm is the inverse of the exponential function with base 2,
so that log2(2^x) = x. This is useful for computing the number of bits needed
to represent a number or for operations involving powers of 2.

Returns an array of the same shape as x, containing the base-2 logarithm
of each element in x.

Specification: log2 returns a vector where each element is the base-2
logarithm of the corresponding element in x.

Precondition: All elements must be positive (x[i] > 0) since the logarithm
is only defined for positive real numbers.

Postcondition: For all indices i, result[i] = Float.log2 x[i]

Mathematical properties:
- log2(2^x) = x for any x
- log2(x * y) = log2(x) + log2(y) for positive x, y
- log2(x / y) = log2(x) - log2(y) for positive x, y
- log2(1) = 0
- log2(2) = 1","use vstd::prelude::*;

verus! {",,"fn log2(x: Vec<f32>) -> (result: Vec<f32>)
    requires x.len() > 0,
    ensures result.len() == x.len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0332,verus,numpy_triple,mathematical_functions_log10,,"numpy.log10: Return the base 10 logarithm of the input array, element-wise.

The base 10 logarithm log10 is the logarithm to the base 10.
It is the inverse of the exponential function with base 10,
so that log10(10^x) = x.

Returns an array of the same shape as x, containing the base 10 logarithm
of each element in x.

Specification: numpy.log10 returns a vector where each element is the base 10
logarithm of the corresponding element in x.

Precondition: All elements must be positive (x[i] > 0)
Postcondition: For all indices i, result[i] = Float.log10 x[i]

Mathematical properties:
1. log10(10^a) = a for positive a
2. log10(a * b) = log10(a) + log10(b) for positive a, b  
3. log10(1) = 0
4. log10(10) = 1
5. Monotonic: a < b implies log10(a) < log10(b) for positive a, b","use vstd::prelude::*;

verus! {",,"fn numpy_log10(x: Vec<f32>) -> (result: Vec<f32>)
    requires 
        x@.len() > 0,
    ensures 
        result@.len() == x@.len(),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0333,verus,numpy_triple,mathematical_functions_logaddexp,,"numpy.logaddexp: Logarithm of the sum of exponentiations of the inputs.

Calculates log(exp(x1) + exp(x2)) element-wise. This function is useful 
in statistics where the calculated probabilities of events may be so small 
as to exceed the range of normal floating point numbers.

The logaddexp function provides a numerically stable way to compute
log(exp(x1) + exp(x2)) without intermediate overflow or underflow.

Mathematical properties:
- logaddexp(x, x) = x + log(2)
- logaddexp(x, -∞) = x
- logaddexp(-∞, x) = x
- logaddexp is symmetric: logaddexp(x, y) = logaddexp(y, x)
- logaddexp is associative in the sense that it satisfies the log-sum-exp properties
- logaddexp(x, y) ≥ max(x, y) for all x, y

From NumPy documentation:
- Parameters: x1, x2 (array_like) - Input arrays
- Returns: ndarray - The element-wise logaddexp of the inputs

Specification: numpy.logaddexp returns a vector where each element is the
logarithm of the sum of exponentiations of the corresponding elements.

Mathematical Properties:
1. Element-wise correctness: result[i] = log(exp(x1[i]) + exp(x2[i]))
2. Commutativity: logaddexp(x1, x2) = logaddexp(x2, x1)
3. Numerical stability: avoids intermediate overflow/underflow
4. Bounds: logaddexp(x, y) ≥ max(x, y) for all x, y
5. Special cases: 
   - logaddexp(x, x) = x + log(2)
   - logaddexp(x, -∞) = x (when x is finite)
   - logaddexp(-∞, x) = x (when x is finite)
6. Monotonicity: logaddexp is monotonically increasing in both arguments
7. Associativity property: satisfies log-sum-exp algebraic relations

Precondition: True (logaddexp is defined for all real numbers)
Postcondition: For all indices i, result[i] = log(exp(x1[i]) + exp(x2[i]))
               and result[i] ≥ max(x1[i], x2[i])","use vstd::prelude::*;

verus! {

#[verifier::external_body]
spec fn logaddexp_value(x1: f64, x2: f64) -> f64;",,"fn logaddexp(x1: Vec<f64>, x2: Vec<f64>) -> (result: Vec<f64>)
    requires x1.len() == x2.len(),
    ensures 
        result.len() == x1.len(),
        forall|i: int| 0 <= i < result.len() ==> {
            result[i] == logaddexp_value(x1[i], x2[i])
        }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0334,verus,numpy_triple,mathematical_functions_logaddexp2,,"numpy.logaddexp2: Logarithm of the sum of exponentiations of the inputs in base-2.

Calculates log2(2^x1 + 2^x2) element-wise. This function is mathematically equivalent to
log2(2^x1 + 2^x2) but is computed in a numerically stable way that avoids overflow for
large input values.

The function is useful for numerical computations where you need to add exponentials
without causing overflow, particularly in machine learning and statistical applications.

Returns an array of the same shape as the input arrays, containing the base-2 logarithm
of the sum of exponentiations of corresponding elements.

Specification: numpy.logaddexp2 returns a vector where each element is the base-2
logarithm of the sum of exponentiations of the corresponding elements in x1 and x2.

Precondition: True (no special preconditions - numerically stable for all finite values)
Postcondition: For all indices i, result[i] = log2(2^x1[i] + 2^x2[i])

Mathematical properties:
- Commutativity: logaddexp2(x1, x2) = logaddexp2(x2, x1)
- Monotonicity: If x1 ≤ y1 and x2 ≤ y2, then logaddexp2(x1, x2) ≤ logaddexp2(y1, y2)
- Bounds: max(x1, x2) ≤ logaddexp2(x1, x2) ≤ max(x1, x2) + 1","use vstd::prelude::*;

verus! {",,"fn numpy_logaddexp2(x1: Vec<f32>, x2: Vec<f32>) -> (result: Vec<f32>)
    requires x1.len() == x2.len(),
    ensures result.len() == x1.len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0335,verus,numpy_triple,mathematical_functions_maximum,,"numpy.maximum: Element-wise maximum of array elements.

Compares two arrays element-wise and returns a new array containing
the element-wise maxima. If one of the elements being compared is NaN,
then that element is returned.

This is a universal function (ufunc) that operates element-wise on arrays
and supports broadcasting. For 1D arrays, it computes the maximum of
corresponding elements.

Specification: numpy.maximum returns a vector where each element is the maximum
of the corresponding elements from x1 and x2.

Mathematical properties:
1. Commutativity: maximum(x1, x2) = maximum(x2, x1)
2. Associativity: maximum(maximum(x1, x2), x3) = maximum(x1, maximum(x2, x3))
3. Idempotence: maximum(x, x) = x
4. Monotonicity: if x1[i] ≤ y1[i] and x2[i] ≤ y2[i], then maximum(x1, x2)[i] ≤ maximum(y1, y2)[i]
5. Identity: maximum(x, -∞) = x (where -∞ is negative infinity)

Precondition: True (no special preconditions for element-wise maximum)
Postcondition: For all indices i, result[i] = max(x1[i], x2[i])","use vstd::prelude::*;

verus! {",,"fn maximum(x1: Vec<i8>, x2: Vec<i8>) -> (result: Vec<i8>)
    requires x1.len() == x2.len(),
    ensures 
        result.len() == x1.len(),
        forall|i: int| 0 <= i < result.len() ==> 
            result@[i] == if x1@[i] >= x2@[i] { x1@[i] } else { x2@[i] },
        forall|i: int| 0 <= i < result.len() ==> 
            result@[i] >= x1@[i] && result@[i] >= x2@[i],
        forall|i: int| 0 <= i < result.len() ==> 
            result@[i] == x1@[i] || result@[i] == x2@[i],","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0336,verus,numpy_triple,mathematical_functions_minimum,,"numpy.minimum: Element-wise minimum of array elements.

Compare two arrays and returns a new array containing the element-wise minima.
If one of the elements being compared is NaN, then that element is returned.

This is different from numpy.min which returns a single minimum value.
This function performs element-wise comparison and returns a new array.

Binary universal function: minimum(x1, x2)

Parameters:
- x1, x2: Vector Float n - Input vectors of the same size

Returns:
- Vector Float n - The element-wise minimum of x1 and x2

Specification: numpy.minimum returns a vector where each element is the minimum
of the corresponding elements from x1 and x2.

Mathematical properties:
1. Commutativity: min(a, b) = min(b, a)
2. Associativity: min(min(a, b), c) = min(a, min(b, c))
3. Idempotency: min(a, a) = a
4. Element-wise operation: result[i] = min(x1[i], x2[i]) for all i
5. NaN propagation: if either x1[i] or x2[i] is NaN, result[i] is NaN

Precondition: True (no special preconditions for element-wise minimum)
Postcondition: For all indices i, result[i] = min(x1[i], x2[i])","use vstd::prelude::*;

verus! {",,"fn minimum(x1: Vec<f32>, x2: Vec<f32>) -> (result: Vec<f32>)
    requires x1.len() == x2.len(),
    ensures 
        result.len() == x1.len(),
        forall|i: int| 0 <= i < result@.len() ==> 
            (result@[i] == x1@[i] || result@[i] == x2@[i]),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0337,verus,numpy_triple,mathematical_functions_mod,,"numpy.mod: Returns the element-wise remainder of division.

Computes the remainder complementary to the floor_divide function.
This is equivalent to x1 % x2 in terms of array broadcasting.

The result has the same sign as the divisor x2.
For two arguments of floating point type, the result is:
x1 - floor(x1/x2) * x2

Specification: numpy.mod returns a vector where each element is the remainder
of the corresponding elements from x1 and x2.

Precondition: All elements in x2 must be non-zero
Postcondition: For all indices i, result[i] = x1[i] % x2[i]

Mathematical properties:
1. The result has the same sign as x2[i] (when x2[i] ≠ 0)
2. The absolute value of result[i] is less than the absolute value of x2[i]
3. x1[i] = floor(x1[i] / x2[i]) * x2[i] + result[i]","use vstd::prelude::*;

verus! {",,"fn numpy_mod(x1: Vec<i8>, x2: Vec<i8>) -> (result: Vec<i8>)
    requires 
        x1.len() == x2.len(),
        forall|i: int| 0 <= i < x2.len() ==> x2[i] != 0,
    ensures
        result.len() == x1.len(),
        forall|i: int| 0 <= i < result.len() ==> 
            #[trigger] result[i] == x1[i] % x2[i],
        forall|i: int| 0 <= i < result.len() ==> {
            let r = #[trigger] result[i];
            let a = x1[i];
            let b = x2[i];
            /* Basic remainder property: a = floor_div(a, b) * b + r */
            a == (a / b) * b + r &&
            /* Result has same sign as divisor (when divisor is non-zero) */
            (b > 0 ==> r >= 0 && r < b) &&
            (b < 0 ==> r <= 0 && r > b)
        }","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0338,verus,numpy_triple,mathematical_functions_modf,,"numpy.modf: Return the fractional and integral parts of an array, element-wise.

Returns a tuple (fractional_parts, integral_parts) where both parts
have the same sign as the input. The fractional and integral parts
are negative if the given number is negative.

Specification: numpy.modf returns fractional and integral parts where:
1. The fractional and integral parts sum to the original value
2. The fractional part has absolute value less than 1
3. Both parts have the same sign as the original number (or zero)
4. The integral part is the truncated integer part

Precondition: True (no special preconditions for modf)
Postcondition: For all indices i, the fractional and integral parts satisfy mathematical properties","use vstd::prelude::*;

verus! {",,"fn numpy_modf(x: Vec<f32>) -> (result: (Vec<f32>, Vec<f32>))
    ensures
        result.0.len() == x.len(),
        result.1.len() == x.len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0339,verus,numpy_triple,mathematical_functions_multiply,,"numpy.multiply: Multiply arguments element-wise.

Multiplies two vectors element-wise. If the vectors have the same shape,
each element of the result is the product of the corresponding elements
from the input vectors.

This is equivalent to x1 * x2 in terms of array broadcasting.
The function supports all numeric types and handles overflow according
to the IEEE 754 standard for floating-point arithmetic.

From NumPy documentation:
- Parameters: x1, x2 (array_like) - The arrays to be multiplied
- Returns: multiply (ndarray) - The product of x1 and x2, element-wise
- The function is a universal function (ufunc) implemented in C
- Uses optimized C loops for different data types

Specification: numpy.multiply returns a vector where each element is the product
of the corresponding elements from x1 and x2.

Mathematical Properties:
1. Element-wise correctness: result[i] = x1[i] * x2[i]
2. Commutativity: multiply(x1, x2) = multiply(x2, x1)
3. Associativity: multiply(multiply(x1, x2), x3) = multiply(x1, multiply(x2, x3))
4. Identity: multiply(x, ones) = x
5. Zero property: multiply(x, zeros) = zeros
6. Preserves vector length: result.size = x1.size = x2.size
7. Handles finite arithmetic: supports IEEE 754 floating-point multiplication
8. Distributivity over addition: multiply(x1, add(x2, x3)) = add(multiply(x1, x2), multiply(x1, x3))

Precondition: True (no special preconditions for basic multiplication)
Postcondition: For all indices i, result[i] = x1[i] * x2[i]","use vstd::prelude::*;

verus! {",,"fn multiply(x1: Vec<i8>, x2: Vec<i8>) -> (result: Vec<i8>)
    requires x1.len() == x2.len(),
    ensures 
        result.len() == x1.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] as int == (x1[i] as int) * (x2[i] as int)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0340,verus,numpy_triple,mathematical_functions_nan_to_num,,"Replace NaN with zero and infinity with large finite numbers element-wise

Specification: nan_to_num replaces non-finite floating-point values with finite alternatives:
1. NaN replacement: All NaN values are replaced with 0.0
2. Positive infinity replacement: All positive infinity values are replaced with a large finite value  
3. Negative infinity replacement: All negative infinity values are replaced with a large negative finite value
4. Finite value preservation: All finite values remain unchanged
5. All results are finite: The output contains only finite floating-point numbers","use vstd::prelude::*;

verus! {",,"fn nan_to_num(x: Vec<f64>) -> (result: Vec<f64>)
    ensures 
        result.len() == x.len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0341,verus,numpy_triple,mathematical_functions_nancumprod,,"Return the cumulative product of array elements over a given axis treating Not a Numbers (NaNs) as one.

Return the cumulative product of array elements treating NaNs as 1.
The cumulative product does not change when NaNs are encountered and leading NaNs are replaced by ones.

Specification: nancumprod returns the cumulative product while treating NaN values as 1.
This means:
1. The resulting array has the same size as the input
2. Each element is the product of all non-NaN elements from the start up to that position
3. NaN values are treated as 1 in the product calculation
4. Leading NaNs are replaced by ones
5. The cumulative product property holds for non-NaN values

/* Complex mathematical properties involving cumulative products and NaN handling
           would require additional specification functions for float arithmetic */","use vstd::prelude::*;

verus! {",,"fn nancumprod(arr: Vec<f32>) -> (result: Vec<f32>)
    ensures 
        result.len() == arr.len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0342,verus,numpy_triple,mathematical_functions_nancumsum,,"numpy.nancumsum: Return the cumulative sum of array elements treating NaN as zero.

For a 1D array, nancumsum computes the cumulative sum where NaN values are treated as zero.
Unlike regular cumsum, NaN values do not propagate and are replaced with zero during computation.

Examples:
- [1, NaN, 3] becomes [1, 1, 4] (NaN treated as 0)
- [NaN, 2, 3] becomes [0, 2, 5] (leading NaN becomes 0)
- [1, 2, NaN, 4] becomes [1, 3, 3, 7] (NaN contributes 0 to sum)

The cumulative sum with NaN handling is defined as:
- result[0] = if a[0].isNaN then 0 else a[0]
- result[i] = result[i-1] + (if a[i].isNaN then 0 else a[i]) for i > 0

Specification: nancumsum returns a vector where each element is the cumulative sum
up to that position with NaN values treated as zero.

Precondition: True (no special preconditions)
Postcondition:
- Result has the same length as input
- NaN values are treated as zero in the cumulative sum computation
- For non-empty vectors, first element is either a[0] or 0 if a[0] is NaN
- Each subsequent element is the previous cumulative sum plus current element (or 0 if NaN)
- The cumulative sum preserves the NaN-as-zero semantics throughout","use vstd::prelude::*;

verus! {",,"fn nancumsum(a: Vec<i8>) -> (result: Vec<i8>)
    ensures
        result.len() == a.len(),
        a.len() > 0 ==> (result[0] as int == a[0] as int),
        forall|i: int| 0 < i < result.len() ==> result[i] as int == result[i-1] as int + a[i] as int,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0343,verus,numpy_triple,mathematical_functions_nanprod,,"Return the product of array elements over a given axis treating Not a Numbers (NaNs) as ones.

numpy.nanprod: Return the product of array elements treating NaNs as ones.

Computes the product of all elements in the array, treating NaN values as 1.
This is useful for computing products while ignoring missing or invalid data
represented as NaN.

For empty arrays, returns 1 as the identity element of multiplication.
For arrays containing only NaN values, returns 1.
For arrays with mixed NaN and non-NaN values, returns the product of the non-NaN values.

Specification: numpy.nanprod returns the product of all non-NaN elements in the vector.

Precondition: True (works for any vector, including empty)
Postcondition: result equals the product of all non-NaN elements, satisfying:
1. NaN values are treated as 1 (multiplicative identity)
2. Empty vectors return 1
3. Vectors with only NaN values return 1
4. The result is mathematically equivalent to filtering out NaN values and taking the product
5. The result is never NaN (since NaN values are ignored)
6. If no NaN values exist, this behaves identically to regular product","use vstd::prelude::*;

verus! {",,"spec fn product_of_non_nan_elements(a: Seq<f32>) -> f32 {
    arbitrary()
}

fn nanprod(a: Vec<f32>) -> (result: f32)
    ensures result == product_of_non_nan_elements(a@)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0344,verus,numpy_triple,mathematical_functions_nansum,,"Return the sum of array elements over a given axis treating Not a Numbers (NaNs) as zero

Return the sum of array elements treating NaN values as zero

Specification: nansum computes the sum of array elements treating NaN values as zero","use vstd::prelude::*;

verus! {",,"fn nansum(a: Vec<f32>) -> (result: f32)
    ensures
        /* If vector is empty, result is 0 */
        a.len() == 0 ==> result == 0.0f32,
        /* Core property: nansum handles NaN values by treating them as zero */
        true,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0345,verus,numpy_triple,mathematical_functions_negative,,"numpy.negative: Numerical negative, element-wise.

Computes the negative of each element in the input array.
This is equivalent to -x in terms of array operations.

Returns an array of the same shape as x, containing the negated values.

Specification: numpy.negative returns a vector where each element is the
negative of the corresponding element in x.

Precondition: True (no special preconditions for negation)
Postcondition: For all indices i, result[i] = -x[i]

Mathematical Properties:
- Involution: -(-x) = x
- Additive inverse: x + (-x) = 0
- Preserves magnitude: |(-x)| = |x|","use vstd::prelude::*;

verus! {",,"fn numpy_negative(x: Vec<i8>) -> (result: Vec<i8>)
    ensures
        result.len() == x.len(),
        forall|i: int| 0 <= i < x.len() ==> result[i] as int == -(x[i] as int)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0346,verus,numpy_triple,mathematical_functions_nextafter,,"numpy.nextafter: Return the next floating-point value after x1 towards x2, element-wise.

Returns the next representable floating-point value after x1 in the direction of x2.
This function is essential for numerical computing and provides fine-grained control
over floating-point precision. It's based on the C math library's nextafter function.

For each element pair (x1[i], x2[i]):
- If x1[i] == x2[i], returns x1[i]
- If x1[i] < x2[i], returns the smallest floating-point value greater than x1[i]
- If x1[i] > x2[i], returns the largest floating-point value less than x1[i]

Special cases:
- nextafter(x, +∞) returns the next value towards positive infinity
- nextafter(x, -∞) returns the next value towards negative infinity
- nextafter(±∞, y) returns ±∞ for any finite y
- nextafter(NaN, y) or nextafter(x, NaN) returns NaN

This function is crucial for:
- Numerical differentiation algorithms
- Root finding methods requiring precise stepping
- Testing floating-point precision limits
- Implementing robust numerical algorithms

Specification: numpy.nextafter returns a vector where each element is the next
representable floating-point value after x1[i] in the direction of x2[i].

Precondition: True (no special preconditions for nextafter)
Postcondition: For all indices i:
  - If x1[i] == x2[i], then result[i] = x1[i]
  - If x1[i] < x2[i], then result[i] is the smallest float greater than x1[i]
  - If x1[i] > x2[i], then result[i] is the largest float less than x1[i]

Mathematical properties:
  1. Direction consistency: result[i] moves towards x2[i]
  2. Monotonicity: if x1[i] < x2[i], then x1[i] < result[i] ≤ x2[i]
  3. Minimal step: result[i] is the closest representable value to x1[i] in direction of x2[i]
  4. Symmetry: nextafter(nextafter(x, y), x) moves back towards x
  5. Identity: nextafter(x, x) = x
  6. Finite precision: respects IEEE 754 floating-point representation","use vstd::prelude::*;

verus! {",,"fn nextafter(x1: Vec<i8>, x2: Vec<i8>) -> (result: Vec<i8>)
    requires x1.len() == x2.len(),
    ensures 
        result.len() == x1.len(),
        forall|i: int| 0 <= i < result.len() ==> {
            /* Identity case: when x1 equals x2, result equals x1 */
            (x1[i] == x2[i] ==> result[i] == x1[i]) &&
            /* Direction consistency: result moves towards x2 */
            ((x1[i] < x2[i] ==> x1[i] < result[i] && result[i] <= x2[i]) &&
             (x1[i] > x2[i] ==> x1[i] > result[i] && result[i] >= x2[i])) &&
            /* Finiteness preservation: if both inputs are finite and different, result is defined */
            (x1[i] != x2[i] ==> true)
        }","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0347,verus,numpy_triple,mathematical_functions_positive,,"numpy.positive: Numerical positive, element-wise.

Returns a copy of the input array with the same values.
This is equivalent to the unary plus operator (+x) and 
is only defined for types that support arithmetic operations.

The function performs element-wise positive operation, which
for real numbers simply returns the same value.

Specification: numpy.positive returns a vector where each element is
the positive of the corresponding element in x (which is the same value).

Precondition: True (no special preconditions for positive operation)
Postcondition: For all indices i, result[i] = +x[i] = x[i]

Mathematical Properties:
- Identity operation: positive(x) = x
- Idempotence: positive(positive(x)) = positive(x)
- Preserves sign: sign(positive(x)) = sign(x)
- Preserves magnitude: |positive(x)| = |x|
- Distributivity with multiplication: positive(x) * y = x * y","use vstd::prelude::*;

verus! {",,"fn positive(x: Vec<f32>) -> (result: Vec<f32>)
    ensures
        result.len() == x.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] == x[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0348,verus,numpy_triple,mathematical_functions_power,,"numpy.power: First array elements raised to powers from second array, element-wise.

Raise each base in x1 to the positionally-corresponding power in x2.
This is equivalent to x1 ** x2 in terms of array broadcasting.

The function computes x1[i] raised to the power x2[i] for each index i.

Mathematical properties:
- x^0 = 1 for any non-zero x
- x^1 = x for any x
- x^(a+b) = x^a * x^b for any x, a, b
- (x^a)^b = x^(a*b) for any x, a, b

Specification: numpy.power returns a vector where each element is the base
from x1 raised to the power from x2.

Precondition: For mathematical validity, we require:
- If x1[i] = 0, then x2[i] ≥ 0 (0^negative is undefined)
- If x1[i] < 0, then x2[i] should be an integer (for real results, checked by floor = value)

Postcondition: For all indices i, result[i] = x1[i] ^ x2[i]

Key mathematical properties ensured:
1. Identity: If x2[i] = 0 and x1[i] ≠ 0, then result[i] = 1
2. Base case: If x2[i] = 1, then result[i] = x1[i]
3. Monotonicity: If x1[i] > 1 and x2[i] > 0, then result[i] > x1[i]","use vstd::prelude::*;

verus! {",,"fn numpy_power(x1: Vec<i8>, x2: Vec<i8>) -> (result: Vec<i8>)
    requires 
        x1.len() == x2.len(),
        forall|i: int| 0 <= i < x1@.len() ==> {
            (x1[i] == 0 ==> x2[i] as int >= 0)
        },
    ensures
        result.len() == x1.len(),
        forall|i: int| 0 <= i < result@.len() ==> {
            (x2[i] as int == 0 && x1[i] as int != 0 ==> result[i] as int == 1) &&
            (x2[i] as int == 1 ==> result[i] as int == x1[i] as int) &&
            (x1[i] as int > 1 && x2[i] as int > 0 ==> result[i] as int > x1[i] as int)
        }","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0349,verus,numpy_triple,mathematical_functions_prod,,"numpy.prod: Return the product of array elements over a given axis.

Computes the product of all elements in the vector. For empty vectors,
returns 1 as the identity element of multiplication.

This is a reduction operation that applies multiplication across all
elements to produce a single scalar result.

Mathematical Properties:
- Commutative: order of elements doesn't affect the final product
- Associative: grouping of operations doesn't affect the result
- Identity element: empty array product is 1
- Contains zero: if any element is zero, the product is zero

Specification: prod computes the product of all elements in a vector.

The product operation has several important mathematical properties:
1. For empty vectors, returns 1 (multiplicative identity)
2. For non-empty vectors, returns the product of all elements
3. If any element is zero, the result is zero
4. The operation is commutative and associative

This specification captures both the basic behavior and key mathematical
properties that make prod well-defined and predictable.","use vstd::prelude::*;

verus! {",,"spec fn vec_product_int(a: Seq<i32>) -> int 
    decreases a.len()
{
    if a.len() == 0 {
        1
    } else {
        (a[0] as int) * vec_product_int(a.skip(1))
    }
}

fn prod(a: Vec<i8>) -> (result: i8)
    ensures 
        result as int == vec_product_int(a@.map(|i, x| x as i32)),
        a.len() == 0 ==> result == 1,
        (exists|i: int| 0 <= i < a.len() && a[i] == 0) ==> result == 0","{
    // impl-start
    assume(false);
    0
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0351,verus,numpy_triple,mathematical_functions_radians,,"numpy.radians: Convert angles from degrees to radians.

Converts angles from degrees to radians element-wise.
The conversion formula is: radians = degrees * π / 180

Parameters:
- x: Input array in degrees

Returns:
- y: Array of the same shape as x, containing the corresponding radian values

Specification: numpy.radians converts each element from degrees to radians.

Precondition: True (no special preconditions for degree to radian conversion)
Postcondition: For all indices i, result[i] = x[i] * π / 180

Mathematical properties verified:
- Linear conversion: radians = degrees * (π / 180)
- 0 degrees = 0 radians
- 180 degrees = π radians  
- 360 degrees = 2π radians
- Maintains array shape and element-wise mapping
- Preserves the relationship between angle measures","use vstd::prelude::*;

verus! {",,"fn numpy_radians(x: Vec<f32>) -> (result: Vec<f32>)
    ensures
        result.len() == x.len(),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0352,verus,numpy_triple,mathematical_functions_real_if_close,,"If input is complex with all imaginary parts close to zero, return real parts.
Otherwise, return the original complex vector.
""Close to zero"" is defined as tol * (machine epsilon of the type).

Specification: real_if_close returns real parts if all imaginary parts are within tolerance,
otherwise returns the original complex vector. This captures the essential behavior:
1. If all imaginary parts are small (≤ tol * machineEpsilon), return only real parts
2. Otherwise, preserve the original complex numbers
3. Real parts are always preserved regardless
4. The tolerance check is applied consistently across all elements","use vstd::prelude::*;

verus! {

/* Structure representing a complex number with float components */
#[derive(PartialEq, Eq)]
pub struct Complex {
    /* The real part of the complex number */
    pub re: i32,
    /* The imaginary part of the complex number */
    pub im: i32,
}

/* Machine epsilon for Float (approximately 2.2204460492503131e-16) */
spec fn machine_epsilon() -> i32 {
    2
}
/* Helper function to check if a complex number's imaginary part is close to zero */
spec fn is_close_to_zero(c: Complex, tol: i32) -> bool {
    let abs_im = if c.im >= 0 { c.im as int } else { -(c.im as int) };
    abs_im <= (tol as int) * (machine_epsilon() as int)
}

/* Helper function to check if all imaginary parts in a complex vector are close to zero */
spec fn all_imaginary_parts_close_to_zero(arr: Seq<Complex>, tol: i32) -> bool {
    forall|i: int| 0 <= i < arr.len() ==> is_close_to_zero(arr[i], tol)
}",,"fn real_if_close(arr: Vec<Complex>, tol: i32) -> (result: Vec<Complex>)
    requires tol > 0,
    ensures
        /* Primary behavior: if all imaginary parts are close to zero, return real parts only */
        all_imaginary_parts_close_to_zero(arr@, tol) ==> 
            forall|i: int| 0 <= i < result@.len() ==> result@[i].re == arr@[i].re && result@[i].im == 0,
        /* Otherwise, preserve original complex numbers */
        !all_imaginary_parts_close_to_zero(arr@, tol) ==> 
            forall|i: int| 0 <= i < result@.len() ==> result@[i] == arr@[i],
        /* Real parts are always preserved */
        forall|i: int| 0 <= i < result@.len() ==> result@[i].re == arr@[i].re,
        /* Sanity check: result vector has same length as input */
        result@.len() == arr@.len(),
        /* Mathematical property: if input is already real, output equals input */
        (forall|i: int| 0 <= i < arr@.len() ==> arr@[i].im == 0) ==> 
            forall|i: int| 0 <= i < result@.len() ==> result@[i] == arr@[i],","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0353,verus,numpy_triple,mathematical_functions_reciprocal,,"numpy.reciprocal: Return the reciprocal of the argument, element-wise.

Calculates 1/x for each element in the input array.
This is equivalent to raising each element to the power of -1.

The function requires that all elements are non-zero to avoid division by zero.
For floating-point inputs, the reciprocal of zero would be infinity.

Returns an array of the same shape as x, containing the reciprocals.

Specification: numpy.reciprocal returns a vector where each element is the
reciprocal (1/x) of the corresponding element in x.

Precondition: All elements in x must be non-zero to avoid division by zero
Postcondition: For all indices i, result[i] = 1 / x[i]

Mathematical properties captured in the specification:
- Basic reciprocal property: result[i] = 1 / x[i]
- Domain restriction: x[i] ≠ 0 for all i
- Sign preservation: sign(result[i]) = sign(x[i])
- Magnitude inversion: |result[i]| = 1 / |x[i]|

Additional mathematical properties (provable from the spec):
- reciprocal(reciprocal(x)) = x for all non-zero x
- reciprocal(x * y) = reciprocal(x) * reciprocal(y) for non-zero x, y
- reciprocal(1) = 1
- reciprocal(-1) = -1
- For x > 0: reciprocal(x) > 0
- For x < 0: reciprocal(x) < 0","use vstd::prelude::*;

verus! {",,"fn numpy_reciprocal(x: Vec<f32>) -> (result: Vec<f32>)
    requires 
        x.len() > 0,
        forall|i: int| 0 <= i < x@.len() ==> x@[i] != 0.0f32,
    ensures
        result@.len() == x@.len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0354,verus,numpy_triple,mathematical_functions_remainder,,"numpy.remainder: Returns the element-wise remainder of division.

Computes the remainder complementary to the floor_divide function.
This is equivalent to x1 % x2 in terms of array broadcasting.

The result has the same sign as the divisor x2.
For floating point inputs, the result is mathematically defined as:
x1 - floor(x1/x2) * x2

From NumPy documentation:
- Parameters: x1, x2 (array_like) - The dividend and divisor arrays
- Returns: remainder (ndarray) - The element-wise remainder of x1 divided by x2
- This is a universal function (ufunc) implemented in C
- Uses optimized C loops for different data types

Specification: numpy.remainder returns a vector where each element is the remainder
of the corresponding elements from x1 and x2.

Mathematical Properties:
1. Element-wise correctness: result[i] = x1[i] % x2[i]
2. Complementary to floor division: x1[i] = floor(x1[i]/x2[i]) * x2[i] + result[i]
3. Sign follows divisor: result[i] has the same sign as x2[i] (when x2[i] ≠ 0)
4. Magnitude bound: |result[i]| < |x2[i]| (when x2[i] ≠ 0)
5. Mathematical definition: result[i] = x1[i] - floor(x1[i]/x2[i]) * x2[i]
6. Preserves vector length: result.size = x1.size = x2.size
7. Handles IEEE 754 floating-point arithmetic

Precondition: All elements in x2 must be non-zero
Postcondition: For all indices i, result[i] satisfies the remainder properties","use vstd::prelude::*;

verus! {",,"fn remainder(x1: Vec<f64>, x2: Vec<f64>) -> (result: Vec<f64>)
    requires 
        x1.len() == x2.len(),
        forall|i: int| 0 <= i < x2@.len() ==> x2@[i] != 0.0,
    ensures
        result@.len() == x1@.len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0355,verus,numpy_triple,mathematical_functions_rint,,"numpy.rint: Round elements of the array to the nearest integer.

Rounds each element in the input array to the nearest integer using
IEEE 754 rounding rules (round half to even). The result is returned
as a floating-point array of the same shape as the input.

This function uses the C math library's rint function which rounds
to the nearest integer, with ties (halves) rounded to the nearest even number.

Returns an array of the same shape as x, containing the rounded values.

Specification: numpy.rint returns a vector where each element is
rounded to the nearest integer using IEEE 754 rounding rules.

Precondition: True (no special preconditions for rint)
Postcondition: For all indices i:
  - result[i] is the nearest integer to x[i]
  - for ties (half-integers), result[i] is the nearest even integer
  - result[i] is a floating-point representation of the integer
  - |result[i] - x[i]| ≤ 0.5 for all i
  - if x[i] is already an integer, result[i] = x[i]","use vstd::prelude::*;

verus! {",,"fn numpy_rint(x: Vec<f32>) -> (result: Vec<f32>)
    ensures
        result.len() == x.len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0356,verus,numpy_triple,mathematical_functions_round,,"Evenly round to the given number of decimals.

numpy.round: Evenly round to the given number of decimals.

Rounds each element of the input array to the given number of decimal places.
Uses ""banker's rounding"" (round half to even) for ties.

For decimals=0: rounds to nearest integer
For decimals>0: rounds to that many decimal places
For decimals<0: rounds to nearest 10^(-decimals)

Returns an array of the same shape as input, containing the rounded values.

Specification: numpy.round rounds each element to the specified number of decimal places.

Precondition: True (rounding is defined for all real numbers and decimal places)
Postcondition: For all indices i, result[i] is the rounded value of a[i] to 'decimals' places:
- For decimals = 0: result[i] is the nearest integer to a[i]
- For decimals > 0: result[i] is rounded to that many decimal places
- For decimals < 0: result[i] is rounded to nearest multiple of 10^(-decimals)
- Uses banker's rounding (round half to even) for ties
- Monotonicity: if a[i] ≤ a[j] then result[i] ≤ result[j]
- For decimals=0: result[i] is an integer value
- Approximation property: result[i] is close to a[i] within rounding precision","use vstd::prelude::*;

verus! {",,"fn numpy_round(a: Vec<f64>, decimals: i32) -> (result: Vec<f64>)
    requires a@.len() > 0,
    ensures 
        result@.len() == a@.len()","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0357,verus,numpy_triple,mathematical_functions_sign,,"Returns an element-wise indication of the sign of a number.

Specification: sign returns -1 for negative numbers, 0 for zero, 1 for positive numbers","use vstd::prelude::*;

verus! {",,"fn sign(x: Vec<i8>) -> (result: Vec<i8>)
    requires x.len() > 0,
    ensures 
        result.len() == x.len(),
        forall|i: int| 0 <= i < x@.len() ==> {
            (x@[i] < 0 ==> result@[i] == -1) &&
            (x@[i] == 0 ==> result@[i] == 0) &&
            (x@[i] > 0 ==> result@[i] == 1)
        }","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,DupVT03,0.85
VT0358,verus,numpy_triple,mathematical_functions_signbit,,Returns element-wise True where signbit is set (less than zero),"use vstd::prelude::*;

verus! {
spec fn is_negative(x: f32) -> bool;",,"fn signbit(x: Vec<f32>) -> (result: Vec<bool>)
    ensures 
        result.len() == x.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] == is_negative(x[i])","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,DupVT03,0.85
VT0359,verus,numpy_triple,mathematical_functions_sin,,"numpy.sin: Trigonometric sine, element-wise.

Computes the sine of each element in the input vector, where each element 
is interpreted as an angle in radians. The sine function is one of the 
fundamental trigonometric functions.

For a real number x interpreted as an angle in radians, sin(x) gives the 
y-coordinate of the point on the unit circle at angle x from the positive x-axis.

Returns a vector of the same shape as the input, containing the sine of each element.

Specification: numpy.sin returns a vector where each element is the sine
of the corresponding element in x (interpreted as radians).

The specification captures key mathematical properties:
1. Element-wise computation: result[i] = sin(x[i])
2. Range bounds: sine values are always in [-1, 1]
3. Fundamental trigonometric identities:
   - sin(0) = 0
   - sin(π/2) = 1
   - sin(π) = 0 (approximately, within floating-point precision)
   - sin(3π/2) = -1
   - sin(2π) = 0 (approximately, within floating-point precision)
4. Periodicity: sin(x + 2π) = sin(x)
5. Odd function property: sin(-x) = -sin(x)","use vstd::prelude::*;

verus! {",,"fn sin(x: Vec<f32>) -> (result: Vec<f32>)
    requires x@.len() > 0,
    ensures result@.len() == x@.len()","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0360,verus,numpy_triple,mathematical_functions_sinc,,"Return the normalized sinc function

numpy.sinc: Return the normalized sinc function, element-wise.

The sinc function is defined as:
- sin(π*x)/(π*x) for x ≠ 0
- 1 for x = 0

This is the normalized sinc function, which is used in signal processing and
Fourier analysis. The function is continuous everywhere and has its maximum
value of 1 at x = 0.

Returns a vector of the same shape as the input, containing the sinc value
of each element.

Specification: numpy.sinc returns a vector where each element is the
normalized sinc function of the corresponding element in x.

The specification captures key mathematical properties:
1. Element-wise computation: result[i] = sinc(x[i])
2. Definition: sinc(x) = sin(π*x)/(π*x) for x ≠ 0, and 1 for x = 0
3. Continuity: sinc(0) = 1 (limit as x approaches 0)
4. Symmetry: sinc(-x) = sinc(x) (even function)
5. Zeros: sinc(x) = 0 for x = k where k is any non-zero integer
6. Boundedness: |sinc(x)| ≤ 1 for all x
7. Maximum value: sinc(0) = 1 is the global maximum

The specification is formalized to be mathematically precise while 
remaining implementable with Float types.","use vstd::prelude::*;

verus! {",,"fn sinc(x: Vec<i8>) -> (result: Vec<i8>)
    ensures 
        result.len() == x.len(),
        forall|i: int| 0 <= i < result.len() ==> {
            /* Boundedness: sinc values are bounded by [-1, 1] */
            result[i] as int <= 1 &&
            result[i] as int >= -1 &&
            /* Maximum at zero: sinc(0) = 1 */
            (x[i] as int == 0 ==> result[i] as int == 1) &&
            /* Symmetry: sinc is an even function */
            (forall|j: int| 0 <= j < x.len() && x[i] as int == -(x[j] as int) ==> result[i] as int == result[j] as int)
        }","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0361,verus,numpy_triple,mathematical_functions_sinh,,"numpy.sinh: Hyperbolic sine, element-wise.

The hyperbolic sine function is defined as:
sinh(x) = (e^x - e^(-x)) / 2

It represents the y-coordinate of a point on the unit hyperbola,
analogous to how sine represents the y-coordinate on the unit circle.
Unlike the regular sine function, sinh is unbounded and monotonic.

Returns an array of the same shape as x, containing the hyperbolic sine of each element.

Specification: numpy.sinh returns a vector where each element is the hyperbolic sine
of the corresponding element in x.

Precondition: True (no special preconditions for hyperbolic sine)
Postcondition: 
1. For all indices i, result[i] = (e^x[i] - e^(-x[i])) / 2
2. The function is odd: sinh(-x) = -sinh(x)
3. Monotonicity: sinh is strictly increasing on all of ℝ
4. Zero property: sinh(0) = 0
5. Range property: sinh(x) ∈ (-∞, ∞) for all x ∈ ℝ
6. Sign property: sinh(x) has the same sign as x
7. Symmetry property: sinh(-x) = -sinh(x)

// Simplified specification without direct floating point arithmetic in spec

// Placeholder for mathematical properties

/* Simplified properties without floating point spec operations */","use vstd::prelude::*;

verus! {",,"spec fn sinh_property(x: f64, result: f64) -> bool {

    true
}

fn sinh(x: Vec<f64>) -> (result: Vec<f64>)
    requires x.len() > 0,
    ensures 
        result.len() == x.len(),

        forall|i: int| 0 <= i < x@.len() ==> sinh_property(x@[i], result@[i])","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0362,verus,numpy_triple,mathematical_functions_spacing,,"Return the distance between x and the nearest adjacent number.

For each element x in the input array, returns the distance to the nearest
adjacent floating-point number. This is equivalent to the machine epsilon
for the magnitude of x - it gives the smallest representable difference
between floating-point numbers near x.

For x = 1.0, spacing(1.0) equals the machine epsilon.
Spacing of ±inf and NaN is NaN.

This function is crucial for understanding floating-point precision limits
and is used in numerical analysis for error bounds and convergence testing.

Specification: numpy.spacing returns the distance between each element 
and its nearest adjacent floating-point number.

Precondition: True (spacing is defined for all floating-point numbers)
Postcondition: For all indices i, result[i] represents the smallest positive
difference between x[i] and the next representable floating-point number.

Mathematical properties:
- spacing(x) > 0 for all finite x (distance is always positive)
- spacing(1.0) = machine epsilon
- No representable number exists between x and x + spacing(x)
- spacing(±∞) = NaN and spacing(NaN) = NaN
- spacing(-x) = spacing(x) for finite x (symmetry around zero)
- spacing grows with the magnitude of x (floating-point spacing increases)","use vstd::prelude::*;

verus! {",,"fn spacing(x: Vec<i8>) -> (result: Vec<i8>)
    ensures
        result@.len() == x@.len(),
        forall|i: int| 0 <= i < x@.len() ==> #[trigger] result@[i] as int > 0","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0363,verus,numpy_triple,mathematical_functions_sqrt,,"numpy.sqrt: Return the non-negative square-root of an array, element-wise.

Computes the principal square root of each element in the input array.
For non-negative input elements, returns the positive square root.
For negative input elements, the result is mathematically undefined in
the real numbers, but numpy returns NaN (Not a Number).

The function returns an array of the same shape as the input, containing
the non-negative square-root of each element.

Specification: sqrt returns a vector where each element is the
non-negative square root of the corresponding element in x.

Mathematical properties:
1. For non-negative inputs: result² = input and result ≥ 0
2. For negative inputs: result is NaN (handled by Float.sqrt)
3. The result preserves the shape of the input
4. sqrt(0) = 0
5. sqrt(1) = 1
6. sqrt is monotonic on non-negative inputs

Precondition: True (function handles all Float inputs)
Postcondition: For all indices i, if x[i] ≥ 0 then result[i]² = x[i] and result[i] ≥ 0","use vstd::prelude::*;

verus! {",,"fn sqrt(x: Vec<i8>) -> (result: Vec<i8>)
    ensures 
        result@.len() == x@.len(),
        forall|i: int| 0 <= i < x@.len() ==> {
            &&& (x@[i] >= 0 ==> result@[i] * result@[i] == x@[i] && result@[i] >= 0)
            &&& (x@[i] == 0 ==> result@[i] == 0)
            &&& (x@[i] == 1 ==> result@[i] == 1)
        }","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0364,verus,numpy_triple,mathematical_functions_square,,"numpy.square: Return the element-wise square of the input.

Computes x^2 element-wise. This is equivalent to x * x but may be
more efficient for certain data types. The function squares each element
of the input array and returns an array of the same shape.

This is a universal function (ufunc) that operates element-wise on arrays.

Specification: numpy.square returns a vector where each element is the
square of the corresponding element in x.

Precondition: True (no special preconditions for squaring)
Postcondition: For all indices i, result[i] = x[i]^2

Mathematical Properties:
- Result is always non-negative: ∀ i, result[i] ≥ 0
- Preserves zeros: x[i] = 0 → result[i] = 0
- Monotonic for non-negative inputs: 0 ≤ x[i] ≤ x[j] → result[i] ≤ result[j]","use vstd::prelude::*;

verus! {

spec fn square_f64(x: f64) -> f64;",,"fn numpy_square(x: Vec<f64>) -> (result: Vec<f64>)
    ensures
        result.len() == x.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] == square_f64(x[i])","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0365,verus,numpy_triple,mathematical_functions_subtract,,"numpy.subtract: Subtract arguments, element-wise.

Subtracts two vectors element-wise. If the vectors have the same shape,
each element of the result is the difference of the corresponding elements
from the input vectors.

This is equivalent to x1 - x2 in terms of array broadcasting.
The operation is the inverse of addition: (x1 - x2) + x2 = x1.

Specification: numpy.subtract returns a vector where each element is the difference
of the corresponding elements from x1 and x2.

Precondition: True (no special preconditions for basic subtraction)
Postcondition: For all indices i, result[i] = x1[i] - x2[i]

Mathematical properties:
- Subtraction is anti-commutative: x1 - x2 = -(x2 - x1)
- Subtraction is the inverse of addition: (x1 - x2) + x2 = x1
- Subtracting zero leaves the original value: x1 - 0 = x1
- Subtracting a value from itself yields zero: x1 - x1 = 0","use vstd::prelude::*;

verus! {",,"fn subtract(x1: Vec<i8>, x2: Vec<i8>) -> (result: Vec<i8>)
    requires x1.len() == x2.len(),
    ensures 
        result.len() == x1.len(),
        forall|i: int| 0 <= i < result.len() ==> result@[i] == x1@[i] - x2@[i],
        /* Sanity check: subtracting zero preserves the original value */
        forall|i: int| 0 <= i < result.len() && x2@[i] == 0 ==> result@[i] == x1@[i],
        /* Sanity check: subtracting a value from itself yields zero */
        forall|i: int| 0 <= i < result.len() && x1@[i] == x2@[i] ==> result@[i] == 0,
        /* Anti-commutativity property */
        forall|i: int| 0 <= i < result.len() ==> result@[i] == -(x2@[i] - x1@[i])","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0366,verus,numpy_triple,mathematical_functions_sum,,"numpy.sum: Sum of array elements over a given axis.

Computes the sum of all elements in the vector. For empty vectors,
returns 0 as the identity element of addition.

This is a reduction operation that applies addition across all
elements to produce a single scalar result.

Mathematical Properties:
- Commutative: order of elements doesn't affect the final sum
- Associative: grouping of operations doesn't affect the result
- Identity element: empty array sum is 0
- Distributive: sum(a * c) = c * sum(a) for scalar c

From NumPy documentation:
- Parameters: a (array_like) - Elements to sum
- Returns: sum_along_axis (ndarray) - Sum of array elements
- The function handles axis parameter (ignored in 1D case)
- Supports optional dtype, initial value, and where condition

Specification: sum computes the sum of all elements in a vector.

The sum operation has several important mathematical properties:
1. For empty vectors, returns 0 (additive identity)
2. For non-empty vectors, returns the sum of all elements
3. The operation is commutative and associative
4. Linearity: sum(a + b) = sum(a) + sum(b) (element-wise addition)
5. Scalar multiplication: sum(c * a) = c * sum(a) for scalar c

This specification captures both the basic behavior and key mathematical
properties that make sum well-defined and predictable.

Precondition: True (works for any vector, including empty)
Postcondition: Result equals the sum of all elements using fold operation","use vstd::prelude::*;

verus! {",,"spec fn vec_sum(a: Seq<f32>) -> f32;

fn sum(a: Vec<f32>) -> (result: f32)
    ensures 
        result == vec_sum(a@),
        a.len() == 0 ==> result == 0.0f32,
        (forall|i: int| 0 <= i < a.len() ==> a[i] == 0.0f32) ==> result == 0.0f32,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0367,verus,numpy_triple,mathematical_functions_tan,,"Compute tangent element-wise. Equivalent to sin(x)/cos(x) element-wise.

Specification: tan computes the tangent of each element, equivalent to sin(x)/cos(x),
and is undefined when cos(x) = 0 (i.e., x = π/2 + kπ for integer k)","use vstd::prelude::*;

verus! {",,"fn tan(x: Vec<f32>) -> (result: Vec<f32>)
    requires 
        x@.len() > 0,
    ensures
        result@.len() == x@.len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0368,verus,numpy_triple,mathematical_functions_tanh,,"Compute hyperbolic tangent element-wise.

The hyperbolic tangent function is defined as:
tanh(x) = sinh(x) / cosh(x) = (e^x - e^(-x)) / (e^x + e^(-x))

This function is bounded between -1 and 1, and is the ratio of
hyperbolic sine to hyperbolic cosine. It has a sigmoid-like shape,
approaching -1 as x approaches negative infinity and approaching 1
as x approaches positive infinity.

Returns an array of the same shape as x, containing the hyperbolic tangent of each element.

Specification: numpy.tanh returns a vector where each element is the hyperbolic tangent
of the corresponding element in x.

Precondition: True (no special preconditions for hyperbolic tangent)
Postcondition: 
1. For all indices i, result[i] = sinh(x[i]) / cosh(x[i])
2. The function is odd: tanh(-x) = -tanh(x)
3. The function is bounded: -1 < tanh(x) < 1 for all x ≠ 0
4. Monotonicity: tanh is strictly increasing on all of ℝ
5. Zero property: tanh(0) = 0
6. Limit properties: lim_{x→∞} tanh(x) = 1 and lim_{x→-∞} tanh(x) = -1
7. Sign property: tanh(x) has the same sign as x
8. Derivative property: d/dx tanh(x) = 1 - tanh²(x)","use vstd::prelude::*;

verus! {",,"fn tanh(x: Vec<i32>) -> (result: Vec<i32>)
    ensures 
        result.len() == x.len(),
        forall|i: int| 0 <= i < x.len() ==> {
            /* Core mathematical definition: tanh(x) = sinh(x) / cosh(x) */
            /* Bounded property: |tanh(x)| < 1 for all finite x */
            -1 < result[i] && result[i] < 1 &&
            /* Zero property: tanh(0) = 0 */
            (x[i] == 0 ==> result[i] == 0) &&
            /* Sign property: tanh(x) has the same sign as x */
            (x[i] > 0 ==> result[i] > 0) &&
            (x[i] < 0 ==> result[i] < 0) &&
            /* Asymptotic behavior: for positive x, 0 < tanh(x) < 1 */
            (x[i] > 0 ==> result[i] > 0 && result[i] < 1) &&
            /* Asymptotic behavior: for negative x, -1 < tanh(x) < 0 */
            (x[i] < 0 ==> result[i] < 0 && result[i] > -1)
        },","{
    // impl-start
    assume(false);
    Vec::new()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0369,verus,numpy_triple,mathematical_functions_trapezoid,,Integrate along the given axis using the composite trapezoidal rule. The composite trapezoidal rule approximates definite integrals using trapezoidal approximations between sample points.,"use vstd::prelude::*;

verus! {",,"fn trapezoid(y: Vec<i8>, dx: i8) -> (result: i8)
    requires 
        y.len() > 0,
        dx > 0,
    ensures
        (forall|i: int| 0 <= i < y@.len() ==> #[trigger] y@[i] == y@[0]) ==> 
            result as int == dx as int * (y.len() - 1) as int * y@[0],
        (forall|i: int| 0 <= i < y@.len() ==> #[trigger] y@[i] >= 0) ==> result >= 0,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0370,verus,numpy_triple,mathematical_functions_true_divide,,"numpy.true_divide: Divide arguments element-wise.

True division of the inputs, element-wise. This is equivalent to 
division in Python 3 and numpy.divide. Always returns a floating point result.

The result is computed element-wise as x1[i] / x2[i] for all valid indices i.
Division by zero will result in infinity or NaN depending on the numerator.

This function is an alias for numpy.divide but ensures floating point output.

Specification: true_divide returns a vector where each element is the quotient
of the corresponding elements from x1 and x2.

Precondition: All elements in x2 must be non-zero to avoid division by zero
Postcondition: For all indices i, result[i] = x1[i] / x2[i]

Mathematical properties:
- Preserves vector length (result has same size as inputs)
- Element-wise division: result[i] = x1[i] / x2[i]
- Non-zero divisor constraint ensures well-defined division
- Identity property: true_divide(x, ones) = x
- Inverse property: true_divide(x, x) = ones (when x has no zeros)
- Distributive over multiplication: true_divide(x*y, z) = true_divide(x,z) * true_divide(y,z)","use vstd::prelude::*;

verus! {",,"fn true_divide(x1: Vec<f64>, x2: Vec<f64>) -> (result: Vec<f64>)
    requires 
        x1.len() == x2.len(),
        forall|i: int| 0 <= i < x2.len() ==> x2@[i] != 0.0,
    ensures
        result.len() == x1.len(),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0371,verus,numpy_triple,mathematical_functions_trunc,,"numpy.trunc: Return the truncated value of the input, element-wise.

The truncated value of the scalar x is the nearest integer i which is closer to zero than x is.
This is equivalent to:
- For positive x: floor(x) (largest integer ≤ x)
- For negative x: ceil(x) (smallest integer ≥ x)
- For zero: 0

Returns an array of the same shape as x, containing the truncated values.

Specification: numpy.trunc returns a vector where each element is the 
truncated value of the corresponding element in x.

Precondition: True (truncation is defined for all real numbers)
Postcondition: For all indices i, result[i] is the truncated value of x[i],
               which is the nearest integer closer to zero than x[i]. This means:
               - result[i] is an integer value (represented as Float)
               - For positive x: result[i] = floor(x[i])
               - For negative x: result[i] = ceil(x[i])
               - Truncation moves towards zero: |result[i]| ≤ |x[i]|
               - Sign preservation: result and x have same sign (or both are zero)
               - Monotonicity: the function is monotonic in the sense that it preserves ordering
               - Idempotence: trunc(trunc(x)) = trunc(x)
               - Integer preservation: if x[i] is an integer, then result[i] = x[i]","use vstd::prelude::*;

verus! {
spec fn int_abs(x: int) -> int {
    if x >= 0 { x } else { -x }
}",,"fn numpy_trunc(x: Vec<i8>) -> (result: Vec<i8>)
    ensures
        result.len() == x.len(),
        forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i] == x[i],
        forall|i: int| 0 <= i < result.len() ==> {
            /* Sign preservation */
            (x[i] > 0 ==> result[i] >= 0) &&
            (x[i] < 0 ==> result[i] <= 0) &&
            (x[i] == 0 ==> result[i] == 0)
        },
        forall|i: int| 0 <= i < result.len() ==> {
            /* Truncation moves towards zero (abs property) */
            int_abs(result[i] as int) <= int_abs(x[i] as int)
        }","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0372,verus,numpy_triple,mathematical_functions_unwrap,,"Unwrap by changing deltas between values to 2*pi complement.
Unwraps radian phase by changing absolute jumps greater than discont to their 2*pi complement.
For consecutive elements with difference > discont, adds/subtracts multiples of period to create continuity.

Specification: unwrap ensures continuity by correcting large phase jumps","use vstd::prelude::*;

verus! {",,"fn unwrap(p: Vec<i8>, discont: i8, period: i8) -> (result: Vec<i8>)
    requires 
        discont > 0,
        period > 0,
    ensures
        result.len() == p.len(),
        /* First element is unchanged (if array is non-empty) */
        p.len() > 0 ==> result@[0] == p@[0],","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0373,verus,numpy_triple,ndarray_flat,,"numpy.ndarray.flat: A 1-D iterator over the array.

This operation provides a flattened view of the array, allowing access
to elements as if the array were 1-dimensional. For 1D arrays, this is
essentially an identity operation that provides indexed access to elements.

The flat iterator acts as a view into the underlying array data, preserving
the order of elements as they appear in memory (row-major order).

Specification: numpy.ndarray.flat returns a flattened view of the array.

Precondition: True (no special preconditions for flattening)
Postcondition: The result contains the same elements in the same order,
               providing a 1D view of the input array","use vstd::prelude::*;

verus! {",,"fn numpy_flat(a: Vec<f32>) -> (result: Vec<f32>)
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < a.len() ==> result[i] == a[i]","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0374,verus,numpy_triple,ndarray_flatten,,"numpy.ndarray.flatten: Return a copy of the array collapsed into one dimension.

Flattens a 2D matrix into a 1D vector using row-major (C-style) order.
Each row is placed sequentially in the output vector.

Parameters:
- mat: 2D matrix represented as Vector of Vectors

Returns:
- 1D vector containing all elements in row-major order

Example: [[1,2], [3,4]] becomes [1, 2, 3, 4]

Specification: flatten returns a 1D vector containing all elements of the 2D matrix
in row-major order.

Precondition: True (no special preconditions)
Postcondition: 
- The result has size rows * cols
- Each element at position (row * cols + col) equals the original element at (row, col)
- Elements are ordered by row-major traversal (row 0 first, then row 1, etc.)","use vstd::prelude::*;

verus! {",,"fn flatten(mat: Vec<Vec<i8>>) -> (result: Vec<i8>)
    requires 
        mat@.len() > 0,
        forall|i: int| 0 <= i < mat@.len() ==> mat@[i].len() > 0,
        forall|i: int, j: int| 0 <= i < mat@.len() && 0 <= j < mat@.len() ==> mat@[i].len() == mat@[j].len(),
    ensures 
        result@.len() == mat@.len() * mat@[0].len(),
        forall|r: int, c: int| 
            0 <= r < mat@.len() && 0 <= c < mat@[0].len() ==>
            result@[r * mat@[0].len() + c] == mat@[r][c]","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0375,verus,numpy_triple,ndarray_tofile,,"numpy.ndarray.tofile: Write array to a file as text or binary data.

Writes the array data to a file in 'C' order (row-major), independent of the
original array order. The data can be recovered using numpy.fromfile().

This operation converts the array elements to their binary or text representation
and writes them sequentially to the specified file.

Specification: numpy.ndarray.tofile writes array data to a file in a format
that preserves all original data and can be recovered by fromfile.

Precondition: True (no special preconditions for file writing)
Postcondition: The operation succeeds (returns unit) and the file contains
a faithful representation of the array data in 'C' order, preserving:
1. The number of elements (file_data.length = n)
2. The exact values in sequential order
3. All elements are written without loss of precision

This ensures the fundamental property that tofile and fromfile are inverses
when used with the same data format.","use vstd::prelude::*;

verus! {",,"fn numpy_tofile(arr: Vec<f32>, filename: String) -> (result: ())
    requires true,
    ensures result == ()","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0376,verus,numpy_triple,polynomial_chebyshev_Chebyshev,,"{
  ""name"": ""numpy.polynomial.chebyshev.Chebyshev"",
  ""category"": ""Chebyshev polynomials"",
  ""description"": ""A Chebyshev series class."",
  ""url"": ""https://numpy.org/doc/stable/reference/generated/numpy.polynomial.chebyshev.Chebyshev.html"",
  ""doc"": ""A Chebyshev series class.\n\n    The Chebyshev class provides the standard Python numerical methods\n    '+', '-', '*', '//', '%', 'divmod', '**', and '()' as well as the\n    attributes and methods listed below.\n\n    Parameters\n    ----------\n    coef : array_like\n        Chebyshev coefficients in order of increasing degree, i.e.,\n        \`\`(1, 2, 3)\`\` gives \`\`1*T_0(x) + 2*T_1(x) + 3*T_2(x)\`\`.\n    domain : (2,) array_like, optional\n        Domain to use. The interval \`\`[domain[0], domain[1]]\`\` is mapped\n        to the interval \`\`[window[0], window[1]]\`\` by shifting and scaling.\n        The default value is [-1., 1.].\n    window : (2,) array_like, optional\n        Window, see \`domain\` for its use. The default value is [-1., 1.].\n    symbol : str, optional\n        Symbol used to represent the independent variable in string\n        representations of the polynomial expression, e.g. for printing.\n        The symbol must be a valid Python identifier. Default value is 'x'.\n\n        .. versionadded:: 1.24"",
  ""type"": ""class""
}

Create a Chebyshev polynomial from coefficients with default domain and window [-1, 1]

Specification: Creating a Chebyshev polynomial preserves coefficients and sets default domain/window","use vstd::prelude::*;

verus! {

/* Structure representing a Chebyshev polynomial with coefficients and domain/window mapping */
struct ChebyshevPoly {
    /* Coefficients of the Chebyshev polynomial in increasing degree order */
    coef: Vec<i32>,
    /* Domain interval [domain_min, domain_max] */
    domain_min: i32,
    domain_max: i32,
    /* Window interval [window_min, window_max] */
    window_min: i32,
    window_max: i32,
}",,"fn chebyshev(coef: Vec<i8>) -> (result: ChebyshevPoly)
    requires coef.len() > 0,
    ensures
        /* Coefficients are preserved */
        result.coef@.len() == coef@.len(),
        forall|i: int| 0 <= i < coef@.len() ==> result.coef@[i] == coef@[i] as i32,
        /* Default domain is [-1, 1] */
        result.domain_min == -1,
        result.domain_max == 1,
        /* Default window is [-1, 1] */
        result.window_min == -1,
        result.window_max == 1,
        /* Domain interval is valid */
        result.domain_min < result.domain_max,
        /* Window interval is valid */
        result.window_min < result.window_max,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0377,verus,numpy_triple,polynomial_chebyshev_cheb2poly,,"Convert a Chebyshev series to a polynomial.

Convert an array representing the coefficients of a Chebyshev series,
ordered from lowest degree to highest, to an array of the coefficients
of the equivalent polynomial (relative to the ""standard"" basis) ordered
from lowest to highest degree.

Specification: cheb2poly converts Chebyshev coefficients to polynomial coefficients.

The conversion satisfies the mathematical property that if we have Chebyshev series
∑_{k=0}^{n-1} c[k] * T_k(x) where T_k is the k-th Chebyshev polynomial,
then the output polynomial coefficients p satisfy:
∑_{k=0}^{n-1} c[k] * T_k(x) = ∑_{k=0}^{n-1} p[k] * x^k

Key properties:
1. Length preservation: output has same length as input
2. Identity cases: for n ≤ 2, the output equals the input (since T₀(x) = 1, T₁(x) = x)
3. Correctness: The polynomial form evaluates to the same value as the Chebyshev series
4. Example verification: [0, 1, 2, 3] → [-2, -8, 4, 12]

The algorithm uses the recurrence relation of Chebyshev polynomials:
T₀(x) = 1, T₁(x) = x, T_{n+1}(x) = 2xT_n(x) - T_{n-1}(x)

/* Basic properties */

/* 1. Length preservation */

/* 2. Identity for small cases */

/* 3. Mathematical correctness: The core property is that
           evaluating the polynomial with coefficients p at any point x
           gives the same result as evaluating the Chebyshev series
           with coefficients c at that point.
           This is the fundamental correctness property of the conversion. */

/* For clarity, we state this property abstractly:
               polyEval(p, x) = chebEval(c, x)
               where polyEval computes p₀ + p₁x + p₂x² + ... + p_{n-1}x^{n-1}
               and chebEval computes c₀T₀(x) + c₁T₁(x) + ... + c_{n-1}T_{n-1}(x) */

/* 4. Concrete example from NumPy documentation
           When c = [0, 1, 2, 3], then p = [-2, -8, 4, 12]
           This verifies: 0*T₀ + 1*T₁ + 2*T₂ + 3*T₃ = -2 - 8x + 4x² + 12x³ */

/* 5. Additional mathematical properties
           The conversion is linear: cheb2poly(αc + βd) = α*cheb2poly(c) + β*cheb2poly(d) */

/* 6. Stability: small changes in input lead to small changes in output
           This is important for numerical applications */","use vstd::prelude::*;

verus! {",,"fn cheb2poly(c: Vec<i8>) -> (p: Vec<i8>)
    ensures

        p.len() == c.len(),

        (c.len() == 0 ==> p@ == c@),
        (c.len() == 1 ==> p@ == c@),
        (c.len() == 2 ==> p@ == c@),

        (c.len() == 4 ==>
            (c[0] == 0 && c[1] == 1 && c[2] == 2 && c[3] == 3) ==>
            (p[0] == -2 && p[1] == -8 && p[2] == 4 && p[3] == 12))","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0378,verus,numpy_triple,polynomial_chebyshev_chebadd,,"Add one Chebyshev series to another.

Add one Chebyshev series to another. Returns the sum of two Chebyshev series c1 + c2. The arguments are sequences of coefficients ordered from lowest order term to highest, i.e., [1,2,3] represents the series T_0 + 2*T_1 + 3*T_2.

Add two Chebyshev series coefficient-wise.

This function adds two Chebyshev polynomial series represented by their coefficients. The coefficients are ordered from lowest degree to highest degree term. For example, [1,2,3] represents T_0 + 2*T_1 + 3*T_2 where T_i is the i-th Chebyshev polynomial.

The addition is performed component-wise, padding with zeros if the arrays have different lengths.

Specification: chebadd performs coefficient-wise addition of two Chebyshev series.

The specification captures both the mathematical properties and implementation details:
1. For indices within both arrays, the result is the sum of corresponding coefficients
2. For indices beyond one array's length, the result equals the coefficient from the longer array
3. The result preserves the Chebyshev series representation property
4. The operation is commutative up to reordering when n ≠ m
5. Adding a zero vector yields the original vector (identity property)","use vstd::prelude::*;

verus! {",,"fn chebadd(c1: Vec<i8>, c2: Vec<i8>) -> (result: Vec<i8>)
    ensures
        result.len() == if c1.len() >= c2.len() { c1.len() } else { c2.len() },
        forall|i: int| 0 <= i < result.len() ==> {
            if i < c1.len() && i < c2.len() {
                result[i] as int == c1[i] as int + c2[i] as int
            } else if i < c1.len() {
                result[i] == c1[i]
            } else if i < c2.len() {
                result[i] == c2[i]
            } else {
                result[i] == 0
            }
        },
        forall|i: int| 0 <= i < c1.len() ==> c1[i] != 0 ==> {
            exists|j: int| 0 <= j < result.len() && j == i && {
                if i < c2.len() {
                    result[j] as int == c1[i] as int + c2[i] as int
                } else {
                    result[j] == c1[i]
                }
            }
        },
        forall|i: int| 0 <= i < c2.len() ==> c2[i] != 0 ==> {
            exists|j: int| 0 <= j < result.len() && j == i && {
                if i < c1.len() {
                    result[j] as int == c1[i] as int + c2[i] as int
                } else {
                    result[j] == c2[i]
                }
            }
        }","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0379,verus,numpy_triple,polynomial_chebyshev_chebcompanion,,"numpy.polynomial.chebyshev.chebcompanion: Return the scaled companion matrix of c.

The basis polynomials are scaled so that the companion matrix is
symmetric when c is a Chebyshev basis polynomial. This provides
better eigenvalue estimates than the unscaled case and for basis
polynomials the eigenvalues are guaranteed to be real if
numpy.linalg.eigvalsh is used to obtain them.

Parameters:
- c : 1-D array of Chebyshev series coefficients ordered from low to high degree

Returns:
- mat : Scaled companion matrix of dimensions (deg, deg) where deg = len(c) - 1

Specification: chebcompanion returns a scaled companion matrix with specific structure.

Precondition: The input vector has at least 2 elements (enforced by type)

Postcondition: The result is an (n+1) × (n+1) matrix where:
1. The superdiagonal and subdiagonal have specific values (0.5 for most entries, sqrt(0.5) for the first)
2. The last column is adjusted by scaled coefficients
3. The matrix structure ensures symmetry for Chebyshev basis polynomials","use vstd::prelude::*;

verus! {",,"fn chebcompanion(c: Vec<f32>) -> (result: Vec<Vec<f32>>)
    requires c@.len() >= 2,
    ensures
        result@.len() == c@.len() - 1,
        forall|i: int| 0 <= i < result@.len() ==> result@[i].len() == c@.len() - 1,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0380,verus,numpy_triple,polynomial_chebyshev_chebder,,"numpy.polynomial.chebyshev.chebder: Differentiate a Chebyshev series.

Returns the Chebyshev series coefficients differentiated once.
The differentiation is based on the recurrence relations for Chebyshev
polynomials. The derivative is multiplied by a scaling factor.

For a Chebyshev series c₀T₀ + c₁T₁ + c₂T₂ + ..., the derivative
follows specific recurrence relations that differ from standard polynomials.

The derivative of T_n is n*U_{n-1}, where U_{n-1} can be expressed
in terms of Chebyshev polynomials T_k using specific recurrence relations.

Specification: chebder differentiates a Chebyshev series once.

The Chebyshev derivative algorithm works by:
1. Creating a working copy of the coefficients
2. Applying the recurrence relation from high to low order
3. Scaling the result

The recurrence relation for Chebyshev derivatives is:
- For j ≥ 2: der[j] = 2*(j+1)*c[j+1], and c[j-2] += j*c[j]/(j-2)
- For j = 1: der[1] = 4*c[2]
- For j = 0: der[0] = c[1]

All results are then multiplied by the scaling factor.

Mathematical property: If p(x) = Σ c[i]*T_i(x), then 
p'(x) = Σ der[i]*T_i(x) where der = chebder(c, scl).

Precondition: True (works for any non-empty vector)
Postcondition: 
- The result has size n
- The coefficients follow the Chebyshev derivative recurrence relations
- The result represents scl times the derivative of the input series","use vstd::prelude::*;

verus! {",,"fn chebder(c: Vec<i8>, scl: i8) -> (result: Vec<i8>)
    requires c.len() > 0,
    ensures
        result.len() == c.len() - 1,
        c.len() > 1 ==> result[0] == scl * c[1],
        c.len() > 2 ==> result[1] == scl * 4 * c[2],
        forall|j: int| 2 <= j < result.len() ==>
            result[j as int] == scl * (2 * ((j + 1) as i8)) * c[(j + 1) as int],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0381,verus,numpy_triple,polynomial_chebyshev_chebdiv,,"Divide one Chebyshev series by another, returning quotient and remainder.
The input vectors represent Chebyshev series coefficients from lowest to highest order.

Specification: chebdiv performs polynomial division in the Chebyshev basis,
satisfying the division algorithm property that c1 = c2 * quotient + remainder,
where the degree of remainder is less than the degree of c2.","use vstd::prelude::*;

verus! {",,"fn chebdiv(c1: Vec<f32>, c2: Vec<f32>) -> (result: (Vec<f32>, Vec<f32>))
    requires 
        c2.len() > 0,
        c2[c2.len() - 1] != 0.0f32,
    ensures ({
        let (quo, rem) = result;
        
        /* Quotient has correct size constraints */
        (forall|i: int| 0 <= i < quo.len() && i >= c1.len() - (c2.len() - 1) ==> quo[i] == 0.0f32) &&
        
        /* Remainder degree constraint: deg(rem) < deg(c2) */
        (forall|i: int| 0 <= i < rem.len() && i >= c2.len() - 1 ==> rem[i] == 0.0f32) &&
        
        /* Special case: if deg(c1) < deg(c2), then quo = 0 and rem = c1 */
        (c1.len() < c2.len() ==> 
            (forall|i: int| 0 <= i < quo.len() ==> quo[i] == 0.0f32) &&
            (forall|i: int| 0 <= i < rem.len() && i < c1.len() ==> rem[i] == c1[i])) &&
        
        /* Special case: if c2 has only one coefficient (constant divisor) */
        (c2.len() == 1 ==> 
            (forall|i: int| 0 <= i < rem.len() ==> rem[i] == 0.0f32))
    })","{
    // impl-start
    assume(false);
    (Vec::new(), Vec::new())
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0383,verus,numpy_triple,polynomial_chebyshev_chebfromroots,,"Generate a Chebyshev series with given roots.

Returns the coefficients of the polynomial p(x) = (x - r₀) * (x - r₁) * ... * (x - rₙ)
in Chebyshev form, where rₙ are the roots specified in the input.

The output coefficients c satisfy: p(x) = c₀ + c₁ * T₁(x) + ... + cₙ * Tₙ(x)
where Tₙ(x) is the n-th Chebyshev polynomial of the first kind.

Specification: chebfromroots generates Chebyshev coefficients such that:
1. The output has exactly n+1 coefficients where n is the number of roots
2. The polynomial represented by these coefficients has the given roots
3. When evaluated at any root rᵢ using Chebyshev basis, the result is zero
4. The highest degree coefficient is non-zero (ensuring correct degree)","use vstd::prelude::*;

verus! {",,"fn chebfromroots(roots: Vec<f64>) -> (coeffs: Vec<f64>)
    ensures
        coeffs@.len() == roots@.len() + 1,
        roots@.len() > 0 ==> coeffs@[roots@.len() as int] != 0.0,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0384,verus,numpy_triple,polynomial_chebyshev_chebgauss,,"Computes the sample points and weights for Gauss-Chebyshev quadrature.
These sample points and weights will correctly integrate polynomials of
degree 2*n - 1 or less over the interval [-1, 1] with the weight 
function f(x) = 1/√(1 - x²).

Specification: chebgauss returns Gauss-Chebyshev quadrature nodes and weights
where nodes are the zeros of the n-th Chebyshev polynomial and weights are 
uniform π/n. The nodes are given by cos(π(2i-1)/(2n)) for i = 1 to n.","use vstd::prelude::*;

verus! {",,"fn chebgauss(n: u8) -> (result: (Vec<f32>, Vec<f32>))
    requires n > 0,
    ensures
        result.0.len() == n as usize,
        result.1.len() == n as usize,
        /* All weights are equal (uniform weights) */
        forall|i: int, j: int| 0 <= i < n as int && 0 <= j < n as int ==> 
            #[trigger] result.1[i] == #[trigger] result.1[j],
        /* Nodes are distinct */
        forall|i: int, j: int| 0 <= i < n as int && 0 <= j < n as int && i != j ==> 
            #[trigger] result.0[i] != #[trigger] result.0[j],","{
    // impl-start
    assume(false);
    (Vec::new(), Vec::new())
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0386,verus,numpy_triple,polynomial_chebyshev_chebgrid3d,,"Evaluate a 3-D Chebyshev series on the Cartesian product of x, y, and z.

This function returns the values:
p(a,b,c) = ∑_{i,j,k} c_{i,j,k} * T_i(a) * T_j(b) * T_k(c)

where the points (a, b, c) consist of all triples formed by taking
a from x, b from y, and c from z. The resulting points form
a grid with x in the first dimension, y in the second, and z in
the third.

Specification: chebgrid3d evaluates a 3D Chebyshev series on the Cartesian product.
The result at position (ix, iy, iz) is the sum over all coefficient indices (i, j, k)
of c[i][j][k] * T_i(x[ix]) * T_j(y[iy]) * T_k(z[iz]) where T_n is the n-th
Chebyshev polynomial.

Mathematical properties:
1. The output has the correct shape: nx × ny × nz
2. Each element is computed as a triple sum over the coefficient indices
3. The function evaluates the 3D Chebyshev series at each grid point
4. For a zero coefficient array, the result is zero everywhere
5. The result is linear in the coefficients
6. The Chebyshev polynomials T_i satisfy the recurrence relation:
   T_0(x) = 1, T_1(x) = x, T_{n+1}(x) = 2x*T_n(x) - T_{n-1}(x)
7. The evaluation respects the orthogonality of Chebyshev polynomials on [-1, 1]
8. When all x, y, z values are in [-1, 1], the series converges uniformly
9. The result is the tensor product of 1D Chebyshev evaluations","use vstd::prelude::*;

verus! {",,"spec fn chebyshev_T(n: nat, x: f64) -> f64 
    decreases n
{
    if n == 0 {
        1.0
    } else if n == 1 {
        x
    } else {
        0.0
    }
}

fn chebgrid3d(
    x: Vec<f64>, 
    y: Vec<f64>, 
    z: Vec<f64>,
    c: Vec<Vec<Vec<f64>>>
) -> (result: Vec<Vec<Vec<f64>>>)
    requires 
        x.len() > 0,
        y.len() > 0, 
        z.len() > 0,
        c.len() > 0,
        forall|i: int| 0 <= i < c.len() ==> c[i].len() > 0,
        forall|i: int, j: int| 0 <= i < c.len() && 0 <= j < c[i].len() ==> c[i][j].len() > 0,
    ensures
        result.len() == x.len(),
        forall|ix: int| 0 <= ix < result.len() ==> result[ix].len() == y.len(),
        forall|ix: int, iy: int| 0 <= ix < result.len() && 0 <= iy < result[ix].len() ==> result[ix][iy].len() == z.len()","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0387,verus,numpy_triple,polynomial_chebyshev_chebint,,"numpy.polynomial.chebyshev.chebint: Integrate a Chebyshev series.

Returns the Chebyshev series coefficients integrated m times from
lbnd along axis. At each iteration the resulting series is
multiplied by scl and an integration constant k is added.

The integration transforms Chebyshev polynomials according to the
recurrence relations for Chebyshev polynomial integrals. For a 
single integration (m=1) of coefficients [c₀, c₁, ..., cₙ], the 
result follows the Chebyshev integration formula.

Parameters:
- c: Vector of Chebyshev series coefficients (low to high degree)
- m: Order of integration (must be positive)
- k: Integration constants (defaults to zeros)
- lbnd: Lower bound of the integral (default: 0)
- scl: Scaling factor applied after each integration (default: 1)

Specification: chebint integrates Chebyshev series coefficients m times.

The function performs m successive integrations of the Chebyshev series,
where each integration:
1. Multiplies the current coefficients by scl
2. Applies the Chebyshev integration recurrence relations
3. Adjusts the constant term to satisfy the boundary condition at lbnd
4. Adds the corresponding integration constant from k

Mathematical properties:
- The result has m more coefficients than the input (integration increases degree)
- For m=0, returns the original coefficients unchanged
- The integration follows Chebyshev polynomial recurrence relations:
  ∫ Tₙ(x) dx = [Tₙ₊₁(x)/(2(n+1)) - Tₙ₋₁(x)/(2(n-1))] for n ≥ 2
  ∫ T₁(x) dx = T₂(x)/4
  ∫ T₀(x) dx = T₁(x)
- The constant term is adjusted so the integral equals k[i] at x=lbnd

Sanity checks:
- The output vector has exactly n + m coefficients
- When m = 0, the function should return the input unchanged
- Integration constants k affect only the constant term of each integration
- The scaling factor scl is applied before adding integration constants

/* For m=1 case, the function performs Chebyshev integration according to:
           - T₀ integrates to T₁  
           - T₁ integrates to T₂/4
           - Tₙ (n≥2) integrates to [Tₙ₊₁/(2(n+1)) - Tₙ₋₁/(2(n-1))]
           - The constant term is adjusted for boundary conditions at lbnd
           - Integration constants from k are added appropriately

           Note: Complex floating-point arithmetic specifications are simplified
           due to Verus limitations with f32 operations in spec contexts */","use vstd::prelude::*;

verus! {",,"fn chebint(c: Vec<f32>, m: u8, k: Vec<f32>, lbnd: f32, scl: f32) -> (result: Vec<f32>)
    requires 
        m > 0,
        scl != 0.0f32,
        k.len() == m as usize,
    ensures
        result.len() == c.len() + (m as usize),

        result.len() >= c.len(),
        m == 1 ==> result.len() == c.len() + 1,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0388,verus,numpy_triple,polynomial_chebyshev_chebinterpolate,,"Interpolate a function at the Chebyshev points of the first kind.

Returns the Chebyshev series coefficients that interpolate the given function
at the Chebyshev points of the first kind in the interval [-1, 1]. The resulting
coefficients represent a polynomial of degree deg that interpolates the function
at deg+1 Chebyshev points.

The Chebyshev interpolation provides near-optimal polynomial approximation
for continuous functions on [-1, 1], minimizing the Runge phenomenon and
providing good convergence properties.","use vstd::prelude::*;

verus! {",,"spec fn is_constant_function(func: spec_fn(f64) -> f64) -> bool {
    forall|x: f64, y: f64| #[trigger] func(x) == #[trigger] func(y)
}

fn chebinterpolate(deg: usize, func: spec_fn(f64) -> f64) -> (coef: Vec<f64>)
    ensures 
        coef.len() == deg + 1,
        /* The coefficients satisfy the key properties of Chebyshev interpolation:
           1. The coefficient vector has the correct length (guaranteed by type)
           2. When the function is constant, all coefficients except the first are zero */
        is_constant_function(func) ==> (
            coef[0] == func(0.0) &&
            forall|i: int| 1 <= i < coef.len() ==> #[trigger] coef[i] == 0.0
        )","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0389,verus,numpy_triple,polynomial_chebyshev_chebline,,"Chebyshev series whose graph is a straight line.
Returns coefficients for the Chebyshev series representing off + scl*x.
For simplicity, we always return a 2-element vector where the second element
might be zero when scl = 0.

Specification: chebline returns correct Chebyshev coefficients for a linear function.
The key mathematical property is that the Chebyshev series T₀(x) = 1 and T₁(x) = x,
so the coefficients [off, scl] directly represent off*T₀(x) + scl*T₁(x) = off + scl*x.

The result is always a 2-element vector [off, scl], even when scl = 0.
This represents the Chebyshev series: off * T₀(x) + scl * T₁(x) = off + scl*x

Mathematical Properties:
1. The first coefficient equals the offset parameter
2. The second coefficient equals the scale parameter
3. When evaluated as a Chebyshev series, this produces the line off + scl*x
4. This is the minimal degree Chebyshev representation of a linear function","use vstd::prelude::*;

verus! {",,"fn chebline(off: f32, scl: f32) -> (result: [f32; 2])
    ensures 
        result[0] == off,
        result[1] == scl","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0390,verus,numpy_triple,polynomial_chebyshev_chebmul,,"Multiply one Chebyshev series by another.

Returns the product of two Chebyshev series c1 * c2. The arguments
are sequences of coefficients, from lowest order term to highest,
e.g., [1,2,3] represents the series T_0 + 2*T_1 + 3*T_2.

The result length is m + n - 1 where m and n are the lengths of c1 and c2.","use vstd::prelude::*;

verus! {",,"fn chebmul(c1: Vec<i8>, c2: Vec<i8>) -> (result: Vec<i8>)
    requires 
        c1.len() > 0,
        c2.len() > 0,
    ensures
        result.len() == c1.len() + c2.len() - 1,
        /* Example property: multiplying by the constant polynomial [a] scales all coefficients */
        (c2.len() == 1 ==> forall|i: int| 0 <= i < c1.len() ==> result[i] as int == c2[0] as int * c1[i] as int),
        /* Another example: multiplying [1,0,...] (T_0) by any polynomial preserves it */
        (c1.len() == 1 && c1[0] as int == 1 ==> forall|j: int| 0 <= j < c2.len() ==> result[j] as int == c2[j] as int),
        /* Special case: multiplying two linear polynomials [a,b] * [c,d] */
        /* Result should be [ac + bd/2, ad + bc, bd/2] */
        (c1.len() == 2 && c2.len() == 2 ==> {
            let a = c1[0] as int;
            let b = c1[1] as int; 
            let c = c2[0] as int;
            let d = c2[1] as int;
            result[0] as int == a * c + b * d / 2 &&
            result[1] as int == a * d + b * c &&
            result[2] as int == b * d / 2
        }),
        /* Verify the example from documentation: [1,2,3] * [3,2,1] */
        /* Result should be [6.5, 12, 12, 4, 1.5] but using integers for now */
        (c1.len() == 3 && c2.len() == 3 ==> {
            (c1[0] as int == 1 && c1[1] as int == 2 && c1[2] as int == 3 &&
             c2[0] as int == 3 && c2[1] as int == 2 && c2[2] as int == 1) ==>
            (result.len() == 5)
        })","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0391,verus,numpy_triple,polynomial_chebyshev_chebmulx,,"Multiply a Chebyshev series by x.
This function multiplies a Chebyshev polynomial represented by its coefficients by x.
The operation is based on the recurrence relation:
- xT₀(x) = T₁(x)
- xTₙ(x) = (Tₙ₊₁(x) + Tₙ₋₁(x))/2 for n ≥ 1

Specification: chebmulx correctly multiplies a Chebyshev polynomial by x.

Given coefficients c = [c₀, c₁, ..., cₙ₋₁] representing the polynomial
P(x) = c₀T₀(x) + c₁T₁(x) + ... + cₙ₋₁Tₙ₋₁(x),
this function computes coefficients for xP(x).

The implementation follows from the Chebyshev recurrence relations:
- xT₀(x) = T₁(x)
- xTₙ(x) = (Tₙ₊₁(x) + Tₙ₋₁(x))/2 for n ≥ 1

The algorithm redistributes coefficients according to these relations,
resulting in a polynomial with degree increased by 1.

// Linearity property: chebmulx is a linear operation

// For any scalars alpha, beta and vectors c1, c2 of same length:

// chebmulx(alpha*c1 + beta*c2) = alpha*chebmulx(c1) + beta*chebmulx(c2)","use vstd::prelude::*;

verus! {",,"fn chebmulx(c: Vec<i8>) -> (result: Vec<i8>)
    requires c.len() > 0,
    ensures
        result.len() == c.len() + 1,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0392,verus,numpy_triple,polynomial_chebyshev_chebpow,,"Raise a Chebyshev series to a power.

Returns the Chebyshev series c raised to the power pow. The
argument c is a sequence of coefficients ordered from low to high,
i.e., [1,2,3] represents the series T_0 + 2*T_1 + 3*T_2.

The power must be a non-negative integer. Special cases:
- pow = 0 returns [1] (the constant polynomial 1)
- pow = 1 returns the input series unchanged
- pow > 1 returns the series multiplied by itself pow times

The result length grows as: 1 + (n - 1) * pow, where n is the input length.","use vstd::prelude::*;

verus! {",,"fn chebpow(c: Vec<f64>, pow: u8, maxpower: u8) -> (result: Vec<f64>)
    requires 
        c.len() > 0,
        pow <= maxpower,
    ensures
        /* Special case: pow = 0 returns [1.0] */
        (pow as nat == 0) ==> (result.len() == 1 && result[0] == 1.0),
        /* Special case: pow = 1 returns input unchanged */
        (pow as nat == 1) ==> (result.len() == c.len() && 
            forall|i: int| 0 <= i < c.len() ==> result[i] == c[i]),
        /* Result length is correct */
        result.len() == (if pow as nat == 0 { 1 } else { 1 + (c.len() - 1) * pow as nat }),
        /* For pow > 1: first coefficient exists when appropriate */
        (pow as nat > 1 && c.len() >= 1) ==> (result.len() > 0),
        /* Non-triviality for pow >= 2 with sufficient input length */
        (pow as nat >= 2 && c.len() >= 2 && result.len() > 2) ==> 
            (result[0] != 0.0 || result[1] != 0.0 || result[2] != 0.0),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0393,verus,numpy_triple,polynomial_chebyshev_chebpts1,,"numpy.polynomial.chebyshev.chebpts1: Chebyshev points of the first kind.

The Chebyshev points of the first kind are the points cos(π*(k + 0.5)/n)
for k in range(n), which are the roots of the Chebyshev polynomial T_n(x).
These points are particularly useful for polynomial interpolation as they
minimize the Runge phenomenon.

The implementation uses the identity sin(x) = cos(π/2 - x) to compute
the values using sine instead of cosine.

Specification: chebpts1 returns a vector of n Chebyshev points of the first kind.

The k-th point (0-indexed) is cos(π*(k + 0.5)/n), which equals
sin(π*(n - k - 0.5)/n) by the complementary angle identity.

Precondition: n > 0 (at least one point must be generated)
Postcondition: 
1. For all indices k, result[k] = cos(π*(k + 0.5)/n)
2. The points are in descending order: for all i < j, result[i] > result[j]
3. All points lie in the interval [-1, 1]
4. The points are symmetric about 0: result[k] = -result[n-1-k] for all k","use vstd::prelude::*;

verus! {",,"spec fn chebyshev_point_value(k: int, n: int) -> int { arbitrary() }

fn chebpts1(n: usize) -> (result: Vec<i32>)
    requires n > 0,
    ensures 
        result.len() == n,
        forall|k: int| 0 <= k < n ==> #[trigger] result@[k] == chebyshev_point_value(k, n as int),
        forall|k: int| 0 <= k < n ==> -1000 <= #[trigger] result@[k] <= 1000,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0394,verus,numpy_triple,polynomial_chebyshev_chebpts2,,"Chebyshev points of the second kind.

Generates n Chebyshev points of the second kind, which are the values
cos(π*k/(n-1)) for k from 0 to n-1, sorted in ascending order.
These points are the extrema and endpoints of the Chebyshev polynomial T_{n-1}.

Specification: chebpts2 generates Chebyshev points of the second kind

The function returns n points where:
1. Each point is cos(π*k/(n-1)) for k from n-1 down to 0
2. The points are sorted in ascending order
3. The first point is -1 and the last point is 1
4. The points are symmetric around 0 for the transformation x ↦ -x

// First point is -1 

// Last point is 1","use vstd::prelude::*;

verus! {",,"fn chebpts2(n: usize) -> (result: Vec<f32>)
    requires n >= 2,
    ensures
        result.len() == n,

        result[0] == -1.0f32,

        result[(n-1) as int] == 1.0f32,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0396,verus,numpy_triple,polynomial_chebyshev_chebsub,,"Subtract one Chebyshev series from another component-wise.
The input vectors c1 and c2 represent Chebyshev series coefficients
ordered from lowest to highest degree term.

Specification: chebsub performs component-wise subtraction of two Chebyshev series.

The specification includes:
1. The basic property that each coefficient in the result is the difference
   of the corresponding coefficients in c1 and c2
2. Anti-commutativity: chebsub(c1, c2) = -chebsub(c2, c1)
3. Identity property: subtracting a series from itself yields zero
4. Associativity with addition: (c1 - c2) + c2 = c1","use vstd::prelude::*;

verus! {",,"fn chebsub(c1: Vec<i8>, c2: Vec<i8>) -> (result: Vec<i8>)
    requires c1.len() == c2.len(),
    ensures 
        result.len() == c1.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] as int == c1[i] as int - c2[i] as int,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0400,verus,numpy_triple,polynomial_chebyshev_chebvander,,"Pseudo-Vandermonde matrix of Chebyshev polynomials of given degree.

Given a vector of sample points `x` and a degree `deg`, returns a matrix
where each row corresponds to a sample point and each column contains
the values of Chebyshev polynomials T_0, T_1, ..., T_deg evaluated at
that point.

Specification: chebvander produces a matrix where entry (i,j) is the j-th Chebyshev 
polynomial T_j evaluated at x[i], following the recurrence relation:
T_0(x) = 1, T_1(x) = x, T_{k+1}(x) = 2x*T_k(x) - T_{k-1}(x)

/* T_0(x) = 1 for all x */

/* T_1(x) = x when deg >= 1 */","use vstd::prelude::*;

verus! {",,"fn chebvander(x: Vec<f32>, deg: usize) -> (result: Vec<Vec<f32>>)
    requires deg >= 0,
    ensures

        result.len() == x.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i].len() == (deg + 1),
        forall|i: int| 0 <= i < result.len() ==> result[i][0] == 1.0f32,

        deg >= 1 ==> forall|i: int| 0 <= i < result.len() ==> result[i][1] == x@[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0403,verus,numpy_triple,polynomial_chebyshev_chebweight,,"The weight function of the Chebyshev polynomials.
Computes 1/sqrt(1 - x²) for each element.

Specification: chebweight computes the Chebyshev weight function 1/sqrt(1 - x²).
The function is well-defined when all elements are in the open interval (-1, 1).

Mathematical properties:
1. The weight function equals 1/sqrt(1 - x²) for each element
2. The result is always positive for valid inputs
3. The function is symmetric: w(-x) = w(x)
4. The function approaches infinity as x approaches ±1
5. The implementation uses the factored form 1/(sqrt(1+x) * sqrt(1-x)) for numerical stability","use vstd::prelude::*;

verus! {",,"fn chebweight(x: Vec<f32>) -> (result: Vec<f32>)
    requires 
        x.len() > 0,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0404,verus,numpy_triple,polynomial_chebyshev_poly2cheb,,"Convert a polynomial to a Chebyshev series.

Convert coefficients of a polynomial in the standard monomial basis
(1, x, x², x³, ...) to coefficients in the Chebyshev polynomial basis
(T₀(x), T₁(x), T₂(x), T₃(x), ...).

The input polynomial coefficients are ordered from lowest degree to highest:
pol = [a₀, a₁, a₂, ..., aₙ] represents the polynomial a₀ + a₁x + a₂x² + ... + aₙxⁿ

The output Chebyshev coefficients are also ordered from lowest to highest degree:
result = [c₀, c₁, c₂, ..., cₙ] represents c₀T₀(x) + c₁T₁(x) + c₂T₂(x) + ... + cₙTₙ(x)

/* Example from documentation: [0.0, 1.0, 2.0, 3.0] → [1.0, 3.25, 1.0, 0.75] */

/* Quadratic polynomial x²: [0, 0, 1] → [0.5, 0, 0.5] */

/* Cubic polynomial x³: [0, 0, 0, 1] → [0, 0.75, 0, 0.25] */","use vstd::prelude::*;

verus! {",,"fn poly2cheb(pol: Vec<f64>) -> (result: Vec<f64>)
    requires pol.len() > 0,
    ensures 
        result.len() == pol.len(),

        (pol.len() == 4 && pol[0] == 0.0 && pol[1] == 1.0 && pol[2] == 2.0 && pol[3] == 3.0) ==>
            (result[0] == 1.0 && result[1] == 3.25 && result[2] == 1.0 && result[3] == 0.75),

        (pol.len() == 3 && pol[0] == 0.0 && pol[1] == 0.0 && pol[2] == 1.0) ==>
            (result[0] == 0.5 && result[1] == 0.0 && result[2] == 0.5),

        (pol.len() == 4 && pol[0] == 0.0 && pol[1] == 0.0 && pol[2] == 0.0 && pol[3] == 1.0) ==>
            (result[0] == 0.0 && result[1] == 0.75 && result[2] == 0.0 && result[3] == 0.25)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0405,verus,numpy_triple,polynomial_hermite_Hermite,,"Evaluates a Hermite polynomial at a given point.
Given coefficients (c₀, c₁, ..., cₙ), evaluates ∑ᵢ cᵢ * Hᵢ(x)
where Hᵢ is the i-th Hermite polynomial.

The Hermite polynomials satisfy the recurrence:
H₀(x) = 1
H₁(x) = 2x
Hₙ₊₁(x) = 2x * Hₙ(x) - 2n * Hₙ₋₁(x)

Specification: hermiteEval correctly evaluates the Hermite polynomial series.

Mathematical properties:
1. Empty coefficient vector evaluates to 0
2. Single coefficient [c] evaluates to c * H₀(x) = c * 1 = c
3. Two coefficients [a, b] evaluates to a + b * 2x
4. The evaluation follows the Hermite polynomial recurrence relation
5. Hermite polynomials form an orthogonal basis

/* Complex Hermite polynomial properties */","use vstd::prelude::*;

verus! {",,"fn hermite_eval(coef: Vec<f32>, x: f32) -> (result: f32)
    requires coef.len() > 0,
    ensures 
        coef.len() == 1 ==> result == coef@[0],
        coef.len() >= 2 ==> true,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0406,verus,numpy_triple,polynomial_hermite_e_HermiteE,,"An HermiteE series class.

The HermiteE class provides the standard Python numerical methods
'+', '-', '*', '//', '%', 'divmod', '**', and '()' as well as the
attributes and methods listed below.

Parameters
----------
coef : array_like
    HermiteE coefficients in order of increasing degree, i.e,
    ``(1, 2, 3)`` gives ``1*He_0(x) + 2*He_1(X) + 3*He_2(x)``.
domain : (2,) array_like, optional
    Domain to use. The interval ``[domain[0], domain[1]]`` is mapped
    to the interval ``[window[0], window[1]]`` by shifting and scaling.
    The default value is [-1., 1.].
window : (2,) array_like, optional
    Window, see `domain` for its use. The default value is [-1., 1.].
symbol : str, optional
    Symbol used to represent the independent variable in string
    representations of the polynomial expression, e.g. for printing.
    The symbol must be a valid Python identifier. Default value is 'x'.

    .. versionadded:: 1.24

Create a HermiteE polynomial from coefficients with default domain and window [-1, 1]

Specification: Creating a HermiteE polynomial preserves coefficients and establishes mathematical properties.

HermiteE polynomials are the ""probabilists'"" version of Hermite polynomials.
Key mathematical properties:
1. He₀(x) = 1, He₁(x) = x
2. Recurrence: Heₙ₊₁(x) = x * Heₙ(x) - n * Heₙ₋₁(x)
3. Parity: He_n(-x) = (-1)^n He_n(x)
4. Orthogonality with respect to Gaussian weight e^(-x²/2)

/* Structure representing a HermiteE polynomial with coefficients and domain/window mapping.
   HermiteE polynomials are the ""probabilists'"" version of Hermite polynomials.
   They satisfy the recurrence relation:
   He₀(x) = 1
   He₁(x) = x  
   Heₙ₊₁(x) = x * Heₙ(x) - n * Heₙ₋₁(x)

   The coefficients represent the expansion: ∑ᵢ cᵢ * Heᵢ(x)
*/

/* Coefficients of the HermiteE polynomial in increasing degree order */

/* Domain interval [domain_min, domain_max] */

/* Domain interval upper bound */

/* Window interval [window_min, window_max] */

/* Window interval upper bound */

/* Coefficients are preserved exactly */

/* Default domain is [-1, 1] */

/* Default window is [-1, 1] */","use vstd::prelude::*;

verus! {

struct HermiteEPoly {

    coef: Vec<f32>,

    domain_min: f32,

    domain_max: f32,

    window_min: f32,

    window_max: f32,
}",,"fn hermite_e(coef: Vec<f32>) -> (result: HermiteEPoly)
    ensures

        result.coef@.len() == coef@.len(),
        forall|i: int| 0 <= i < coef@.len() ==> result.coef@[i] == coef@[i],

        result.domain_min == -1.0f32,
        result.domain_max == 1.0f32,

        result.window_min == -1.0f32,
        result.window_max == 1.0f32,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0408,verus,numpy_triple,polynomial_hermite_e_hermeadd,,"Add one Hermite series to another. Component-wise addition of polynomial coefficients.

Specification: hermeadd performs component-wise addition of Hermite polynomial coefficients.
The result has the length of the longer input vector. Elements are added where both vectors
have coefficients, and remaining coefficients from the longer vector are preserved.

This models the mathematical property that polynomial addition is component-wise:
(a₀ + a₁x + a₂x² + ...) + (b₀ + b₁x + b₂x² + ...) = (a₀+b₀) + (a₁+b₁)x + (a₂+b₂)x² + ...

Additional mathematical properties:
- Commutativity: hermeadd c1 c2 = hermeadd c2 c1
- Associativity: hermeadd (hermeadd c1 c2) c3 = hermeadd c1 (hermeadd c2 c3)
- Zero identity: hermeadd c (zero vector) = c (extended appropriately)
- Preservation of polynomial structure: addition preserves Hermite polynomial properties","use vstd::prelude::*;

verus! {",,"fn hermeadd(c1: Vec<i8>, c2: Vec<i8>) -> (result: Vec<i8>)
    ensures
        result.len() == if c1.len() >= c2.len() { c1.len() } else { c2.len() },
        forall|i: int| 0 <= i < result@.len() ==> {
            let coeff1 = if i < c1@.len() { c1@[i] as int } else { 0 };
            let coeff2 = if i < c2@.len() { c2@[i] as int } else { 0 };
            #[trigger] result@[i] as int == coeff1 + coeff2
        }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0409,verus,numpy_triple,polynomial_hermite_e_hermecompanion,,"Return the scaled companion matrix of HermiteE series coefficients.
The companion matrix is scaled for better eigenvalue estimates and
symmetry properties when used with HermiteE basis polynomials.","use vstd::prelude::*;

verus! {",,"fn hermecompanion(c: Vec<f32>) -> (mat: Vec<Vec<f32>>)
    requires 
        c@.len() >= 2,
        c[c@.len() - 1] != 0.0f32,
    ensures
        mat@.len() == c@.len() - 1,
        forall|i: int| 0 <= i < mat@.len() ==> mat@[i].len() == c@.len() - 1,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0410,verus,numpy_triple,polynomial_hermite_e_hermeder,,"Differentiate a Hermite_e series by taking the derivative of coefficients.
Takes coefficients from low to high degree and returns differentiated coefficients.

Specification: hermeder correctly differentiates Hermite_e series coefficients.
The result has degree reduced by 1, and each coefficient is multiplied by its index
and scaled by scl^m. For a single differentiation (m=1), the coefficient of degree k
becomes k * scl * original_coefficient.","use vstd::prelude::*;

verus! {",,"fn hermeder(c: Vec<f64>, m: u8, scl: f64) -> (result: Vec<f64>)
    requires 
        c.len() > 0,
        m as nat > 0,
        scl != 0.0,
    ensures 
        result.len() == c.len() - 1,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0411,verus,numpy_triple,polynomial_hermite_e_hermediv,,"Divide one Hermite series by another, returning quotient and remainder.
The dividend c1 and divisor c2 are coefficient vectors representing Hermite polynomials.
The division is performed in the Hermite polynomial basis with reprojection.

Specification: hermediv performs polynomial division of Hermite series, returning
both quotient and remainder such that c1 = quo * c2 + rem (in Hermite basis).

Key mathematical properties:
1. Division identity: The dividend equals quotient times divisor plus remainder
2. Remainder degree constraint: The remainder has degree less than the divisor
3. Non-zero divisor: The divisor must not be the zero polynomial
4. Reprojection: Results are reprojected onto the Hermite polynomial basis

The specification captures the fundamental division algorithm for polynomials
adapted to the Hermite polynomial basis set.","use vstd::prelude::*;

verus! {",,"fn hermediv(c1: Vec<f64>, c2: Vec<f64>) -> (result: (Vec<f64>, Vec<f64>))
    requires 
        c2.len() > 0,
        exists|i: int| 0 <= i < c2@.len() && c2[i] != 0.0,
    ensures 
        (result.0@.len() >= 1) &&
        (result.1@.len() < c2@.len()) &&
        /* Division property: degree of remainder < degree of divisor */
        /* This is the key mathematical property of polynomial division */
        (result.1@.len() < c2@.len()) &&
        /* Well-formedness: all coefficients are real numbers (not NaN or infinite) */
        (forall|i: int| 0 <= i < result.0@.len() ==> result.0[i] == result.0[i]) &&
        (forall|j: int| 0 <= j < result.1@.len() ==> result.1[j] == result.1[j]) &&
        /* Mathematical property: division preserves degree relationships */
        /* The quotient degree + divisor degree should not exceed dividend degree */
        (result.0@.len() + c2@.len() >= c1@.len() || c1@.len() == 0) &&
        /* Remainder constraint: remainder degree is less than divisor degree */
        /* This ensures the division algorithm terminates correctly */
        (result.1@.len() < c2@.len())","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0412,verus,numpy_triple,polynomial_hermite_e_hermefit,,"Least squares fit of Hermite series to data.
Returns the coefficients of a HermiteE series of degree `deg` that is
the least squares fit to the data values `y` given at points `x`.

/* Coefficients are valid - basic sanity check */

/* Least squares property: the result minimizes sum of squared residuals */

/* When deg+1 == data points, polynomial passes through all points exactly */

/* Orthogonality condition: residuals are orthogonal to basis functions */","use vstd::prelude::*;

verus! {

spec fn hermite_e(n: nat, x: int) -> int
    decreases n
{
    if n == 0 {
        1
    } else if n == 1 {
        x  
    } else {
        let n_minus_1 = (n - 1) as nat;
        let n_minus_2 = (n - 2) as nat;
        x * hermite_e(n_minus_1, x) - ((n - 1) as int) * hermite_e(n_minus_2, x)
    }
}

spec fn sum_hermite_series(coeffs: Seq<int>, x: int, deg: nat) -> int
    decreases deg
{
    if coeffs.len() == 0 || deg >= coeffs.len() {
        0
    } else if deg == 0 {
        coeffs[0] * hermite_e(0nat, x)
    } else {
        let prev_deg = (deg - 1) as nat;
        coeffs[deg as int] * hermite_e(deg, x) + sum_hermite_series(coeffs, x, prev_deg)
    }
}

spec fn sum_squared_residuals_rec(x: Seq<int>, y: Seq<int>, coeffs: Seq<int>, n: nat) -> int
    decreases n
{
    if n == 0 || n > x.len() || n > y.len() || coeffs.len() == 0 {
        0
    } else {
        let i_nat = (n - 1) as nat;
        let i = i_nat as int;
        if i < 0 || i >= x.len() || i >= y.len() {
            0
        } else {
            let xi = x[i];
            let yi = y[i];
            let deg_nat = if coeffs.len() > 0 { (coeffs.len() - 1) as nat } else { 0nat };
            let predicted = sum_hermite_series(coeffs, xi, deg_nat);
            let residual = yi - predicted;
            sum_squared_residuals_rec(x, y, coeffs, i_nat) + residual * residual
        }
    }
}",,"fn hermefit(x: Vec<i8>, y: Vec<i8>, deg: usize) -> (result: Vec<i8>)
    requires 
        x.len() == y.len(),
        deg + 1 <= x.len(),
        x.len() > 0,
    ensures 
        result.len() == deg + 1,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVT01,0.85
VT0413,verus,numpy_triple,polynomial_hermite_e_hermefromroots,,"Generate a HermiteE series with given roots.

Returns the coefficients of the polynomial p(x) = (x - r₀) * (x - r₁) * ... * (x - rₙ₋₁)
in HermiteE form, where rᵢ are the roots specified in the input vector.

The output coefficients c satisfy: p(x) = c₀ + c₁ * He₁(x) + ... + cₙ * Heₙ(x)
where Heₙ(x) is the n-th probabilist's Hermite polynomial (HermiteE).

This function converts from the standard polynomial representation with given roots
to the HermiteE polynomial basis representation.

Specification: hermefromroots generates HermiteE coefficients such that:
1. The output has exactly n+1 coefficients where n is the number of roots
2. The polynomial represented by these coefficients has the given roots
3. When evaluated at any root rᵢ using HermiteE basis, the result is zero
4. The highest degree coefficient is non-zero (ensuring correct degree)
5. The polynomial satisfies the fundamental property p(x) = (x - r₀) * ... * (x - rₙ₋₁)

/* Evaluate the k-th probabilist's Hermite polynomial (HermiteE) at x */

/* Evaluate a polynomial in HermiteE basis at point x given coefficients */

/* Product form helper: (x - r₀) * (x - r₁) * ... * (x - rᵢ₋₁) */

/* Empty roots give the constant polynomial 1 */

/* The polynomial degree matches the number of roots (leading coefficient is non-zero) */","use vstd::prelude::*;

verus! {

spec fn eval_hermite_e(k: nat, x: int) -> int 
    decreases k
{
    if k == 0 {
        1
    } else if k == 1 {
        x
    } else {
        x * eval_hermite_e((k - 1) as nat, x) - (k - 1) as int * eval_hermite_e((k - 2) as nat, x)
    }
}

spec fn eval_hermite_e_poly(coeffs: Seq<int>, x: int) -> int 
    decreases coeffs.len()
{
    if coeffs.len() == 0 {
        0
    } else {
        coeffs[0] * eval_hermite_e(0, x) + eval_hermite_e_poly(coeffs.skip(1), x)
    }
}

spec fn product_form(roots: Seq<int>, x: int, i: nat) -> int 
    decreases i
{
    if i == 0 {
        1
    } else {
        product_form(roots, x, (i - 1) as nat) * (x - roots[(i - 1) as int])
    }
}",,"fn hermefromroots(roots: Vec<i8>) -> (coeffs: Vec<i8>)
    ensures
        coeffs.len() == roots.len() + 1,

        (roots.len() == 0 ==> coeffs.len() == 1),

        (roots.len() > 0 ==> coeffs.len() == roots.len() + 1),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0414,verus,numpy_triple,polynomial_hermite_e_hermegauss,,"numpy.polynomial.hermite_e.hermegauss: Gauss-HermiteE quadrature.

Computes the sample points and weights for Gauss-HermiteE quadrature.
These sample points and weights will correctly integrate polynomials of
degree 2*deg - 1 or less over the interval [-∞, ∞] with the weight
function f(x) = exp(-x²/2).

The function returns a pair (x, w) where x contains the sample points
and w contains the corresponding weights.

Specification: hermegauss returns quadrature points and weights for HermiteE polynomials.

Precondition: deg > 0 (need at least one quadrature point)
Postcondition: The returned points and weights satisfy the mathematical properties
of Gauss-HermiteE quadrature including positivity, symmetry, and ordering.","use vstd::prelude::*;

verus! {",,"fn hermegauss(deg: usize) -> (result: (Vec<i8>, Vec<i8>))
    requires deg > 0,
    ensures
        /* Points are ordered (sorted in ascending order) */
        forall|i: int, j: int| 0 <= i < j < deg ==> #[trigger] result.0@[i] < #[trigger] result.0@[j],
        /* Weights are positive */
        forall|i: int| 0 <= i < deg ==> #[trigger] result.1@[i] > 0,
        /* Return tuple has correct lengths */
        result.0@.len() == deg && result.1@.len() == deg,","{
    // impl-start
    assume(false);
    (Vec::new(), Vec::new())
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0415,verus,numpy_triple,polynomial_hermite_e_hermegrid2d,,"numpy.polynomial.hermite_e.hermegrid2d: Evaluate a 2-D HermiteE series on the Cartesian product of x and y.

This function evaluates a 2-dimensional HermiteE polynomial series
on the Cartesian product of coordinate vectors x and y.

The evaluation follows the mathematical formula:
p(a,b) = sum_{i,j} c[i,j] * He_i(a) * He_j(b)

where He_i is the i-th probabilist's Hermite polynomial (HermiteE),
and the points (a,b) are formed by taking all combinations of
elements from x and y.

The result is a matrix where result[i,j] contains the polynomial
value at the point (x[i], y[j]).

Specification: hermegrid2d evaluates a 2D HermiteE polynomial series 
on the Cartesian product of x and y coordinates.

The function computes p(a,b) = sum_{i,j} c[i,j] * He_i(a) * He_j(b)
where He_i is the i-th probabilist's Hermite polynomial.","use vstd::prelude::*;

verus! {",,"fn hermegrid2d(x: Vec<f32>, y: Vec<f32>, c: Vec<Vec<f32>>) -> (result: Vec<Vec<f32>>)
    ensures
        result@.len() == x@.len(),
        forall|i: int| 0 <= i < result@.len() ==> result@[i].len() == y@.len(),
        forall|i: int, j: int| 0 <= i < result@.len() && 0 <= j < result@[i].len() ==> (
            (c@.len() == 0 || (exists|k: int| 0 <= k < c@.len() && c@[k].len() == 0) ==> result@[i][j] == 0.0f32)
        ),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0416,verus,numpy_triple,polynomial_hermite_e_hermegrid3d,,"numpy.polynomial.hermite_e.hermegrid3d: Evaluate a 3-D HermiteE series on the Cartesian product of x, y, and z.

This function evaluates a 3-dimensional HermiteE polynomial series
on the Cartesian product of coordinate vectors x, y, and z.

The evaluation follows the mathematical formula:
p(a,b,c) = sum_{i,j,k} c[i,j,k] * He_i(a) * He_j(b) * He_k(c)

where He_i is the i-th probabilist's Hermite polynomial (HermiteE),
and the points (a,b,c) are formed by taking all combinations of
elements from x, y, and z.

The result is a 3D tensor where result[i,j,k] contains the polynomial
value at the point (x[i], y[j], z[k]).

Specification: hermegrid3d evaluates a 3D HermiteE polynomial series 
on the Cartesian product of x, y, and z coordinates.

The function computes p(a,b,c) = sum_{i,j,k} c[i,j,k] * He_i(a) * He_j(b) * He_k(c)
where He_i is the i-th probabilist's Hermite polynomial.

Mathematical Properties:
1. The result represents evaluation at all Cartesian product points
2. HermiteE polynomials satisfy He_0(x) = 1, He_1(x) = x, 
   and the recurrence He_{n+1}(x) = x * He_n(x) - n * He_{n-1}(x)
3. The evaluation is exact for the polynomial representation
4. Result shape is nx × ny × nz, matching the Cartesian product","use vstd::prelude::*;

verus! {",,"spec fn hermite_e_poly(x: int, n: nat) -> int
    decreases n
{
    if n == 0 {
        1
    } else if n == 1 {
        x
    } else {
        x * hermite_e_poly(x, (n - 1) as nat) - (n - 1) * hermite_e_poly(x, (n - 2) as nat)
    }
}

fn hermegrid3d(x: Vec<f32>, y: Vec<f32>, z: Vec<f32>, c: Vec<Vec<Vec<f32>>>) -> (result: Vec<Vec<Vec<f32>>>)
    requires
        x.len() > 0,
        y.len() > 0,
        z.len() > 0,
        c.len() > 0,
        forall|i: int| 0 <= i < c@.len() ==> c@[i].len() > 0,
        forall|i: int, j: int| 0 <= i < c@.len() && 0 <= j < c@[i].len() ==> c@[i][j].len() > 0,
    ensures
        result.len() == x.len(),
        forall|i: int| 0 <= i < result@.len() ==> result@[i].len() == y.len(),
        forall|i: int, j: int| 0 <= i < result@.len() && 0 <= j < result@[i].len() ==> result@[i][j].len() == z.len(),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0417,verus,numpy_triple,polynomial_hermite_e_hermeint,,"Integrate a Hermite_e series.

Integrate a Hermite_e series coefficients vector m times with scaling and integration constants.

Specification: hermeint integrates Hermite_e series coefficients preserving mathematical properties.","use vstd::prelude::*;

verus! {",,"fn hermeint(c: Vec<f64>, m: u8, k: Vec<f64>, lbnd: f64, scl: f64) -> (result: Vec<f64>)
    requires 
        scl != 0.0,
        k@.len() == m as int,
    ensures
        result@.len() == c@.len() + m as int,
        scl != 0.0,
        forall|step: int| 0 <= step < m as int ==> #[trigger] k@[step] == k@[step],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0418,verus,numpy_triple,polynomial_hermite_e_hermeline,,"Hermite series whose graph is a straight line.
Returns the Hermite series coefficients representing the linear function off + scl*x.
For non-zero scale, returns [off, scl]. For zero scale, returns [off].","use vstd::prelude::*;

verus! {",,"fn hermeline(off: f64, scl: f64) -> (coeffs: Vec<f64>)
    ensures
        coeffs@.len() == 2,
        coeffs@[0] == off,
        (scl == 0.0 ==> coeffs@[1] == 0.0),
        (scl != 0.0 ==> coeffs@[1] == scl)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0419,verus,numpy_triple,polynomial_hermite_e_hermemul,,"Multiply one Hermite series by another. Returns the product of two Hermite polynomials 
represented as coefficient vectors. The multiplication involves reprojection onto 
the Hermite polynomial basis set.","use vstd::prelude::*;

verus! {",,"fn hermemul(c1: Vec<i8>, c2: Vec<i8>) -> (result: Vec<i8>)
    requires 
        c1@.len() > 0,
        c2@.len() > 0,
    ensures
        result@.len() == c1@.len() + c2@.len() - 1,
        (forall|i: int| 0 <= i < c1@.len() ==> c1@[i] as int == 0) || 
        (forall|j: int| 0 <= j < c2@.len() ==> c2@[j] as int == 0) 
        ==> (forall|k: int| 0 <= k < result@.len() ==> result@[k] as int == 0)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0420,verus,numpy_triple,polynomial_hermite_e_hermemulx,,"Multiply a Hermite series by x using the recursion relationship for Hermite polynomials.
The result has one more coefficient than the input, implementing the transformation
based on the Hermite polynomial recursion: xP_i(x) = (P_{i + 1}(x) + iP_{i - 1}(x))","use vstd::prelude::*;

verus! {",,"fn hermemulx(c: Vec<f64>) -> (result: Vec<f64>)
    requires c.len() >= 0,
    ensures
        result.len() == c.len() + 1,
        result[0] == 0.0,
        forall|i: int| 1 <= i < c.len() as int ==> result[i + 1] == c[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0421,verus,numpy_triple,polynomial_hermite_e_hermepow,,"Raise a Hermite series to a power. Computes the Hermite polynomial coefficients
for the series c raised to the given power, using repeated multiplication.

Specification: hermepow raises a Hermite polynomial series to a power.
Given coefficients c = [c₀, c₁, ..., cₙ₋₁] representing the Hermite series
P₀(x)⋅c₀ + P₁(x)⋅c₁ + ... + Pₙ₋₁(x)⋅cₙ₋₁, this function computes the 
coefficients of the series raised to the given power.

Mathematical properties:
- Power 0: Returns [1.0] (multiplicative identity for Hermite polynomials)
- Power 1: Returns the original coefficients unchanged (preserves the polynomial)
- Power ≥ 2: Uses repeated multiplication following Hermite polynomial algebra
- Result degree: The degree of the result polynomial is (n-1) * pow
- Respects maxpower limit: pow must not exceed maxpower to prevent excessive growth

This implements the mathematical operation (P(x))^pow where P(x) is the Hermite polynomial
represented by the input coefficients, and the result gives the coefficients of the
polynomial raised to the given power in the Hermite basis.

/* Base cases for polynomial exponentiation */

/* General case: polynomial raised to power follows degree multiplication */

/* For non-empty input, the result maintains polynomial structure */","use vstd::prelude::*;

verus! {",,"fn hermepow(c: Vec<f64>, pow: u8, maxpower: u8) -> (result: Vec<f64>)
    requires 
        pow <= maxpower,
        maxpower <= 16,
        c.len() > 0,
    ensures

        pow == 0 ==> result.len() == 1 && result[0] == 1.0 && 
            (forall|i: int| 1 <= i < result.len() ==> result[i] == 0.0),
        pow == 1 ==> result.len() == c.len() &&
            (forall|i: int| 0 <= i < c.len() ==> result[i] == c[i]),

        pow as int >= 1 ==> result.len() == 1 + (c.len() - 1) * pow as int,

        pow as int >= 1 && c.len() > 0 ==> result.len() > 0,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0422,verus,numpy_triple,polynomial_hermite_e_hermeroots,,"Compute the roots of a HermiteE series.
Given HermiteE series coefficients c[0], c[1], ..., c[n-1], returns the roots of
p(x) = c[0]*He_0(x) + c[1]*He_1(x) + ... + c[n-1]*He_{n-1}(x)
where He_i(x) are the ""probabilists'"" or ""normalized"" Hermite polynomials

Specification: hermeroots returns the roots of the HermiteE series defined by coefficients.
For a HermiteE series with n coefficients, there are at most n-1 roots.
Each root r satisfies: p(r) = 0 where p(x) = Σ c[i] * He_i(x)

Mathematical properties:
1. The polynomial p(x) = Σ c[i] * He_i(x) where He_i are HermiteE basis polynomials
2. He_i(x) are the ""probabilists'"" Hermite polynomials related to the standard normal distribution
3. The roots are found via eigenvalues of the companion matrix
4. For degree n polynomial, there are exactly n-1 roots (counting multiplicity)
5. The leading coefficient must be non-zero for a well-defined polynomial","use vstd::prelude::*;

verus! {",,"fn hermeroots(c: Vec<f64>) -> (result: Vec<f64>)
    requires 
        c.len() > 0,
        c[c.len() - 1] != 0.0,
    ensures 
        result.len() == c.len() - 1,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0423,verus,numpy_triple,polynomial_hermite_e_hermesub,,"Subtract one Hermite series from another.
Returns the difference of two Hermite series c1 - c2.
The sequences of coefficients are from lowest order term to highest.

Specification: hermesub performs component-wise subtraction of Hermite series coefficients.
The result has length equal to the maximum of the input lengths, with shorter arrays
implicitly padded with zeros. This captures the mathematical property that polynomial 
subtraction is component-wise and preserves the polynomial structure.","use vstd::prelude::*;

verus! {",,"fn hermesub(c1: Vec<i8>, c2: Vec<i8>) -> (result: Vec<i8>)
    ensures
        result.len() == if c1.len() >= c2.len() { c1.len() } else { c2.len() },
        forall|i: int| 0 <= i < result@.len() ==> 
            #[trigger] result@[i] == 
            (if i < c1@.len() { c1@[i] } else { 0 }) - 
            (if i < c2@.len() { c2@[i] } else { 0 })","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0425,verus,numpy_triple,polynomial_hermite_e_hermeval2d,,"Evaluate a 2-D HermiteE series at points (x, y).

This function computes the bivariate HermiteE polynomial:
p(x,y) = ∑_{i,j} c_{i,j} * He_i(x) * He_j(y)

where He_i and He_j are the HermiteE basis polynomials.

Specification: hermeval2d evaluates a 2D HermiteE series at corresponding points.

This function implements the mathematical formula:
p(x,y) = ∑_{i,j} c_{i,j} * He_i(x) * He_j(y)

Key properties:
1. Bivariate polynomial evaluation using HermiteE basis
2. Mathematical correctness and linearity properties
3. Point-wise evaluation for corresponding (x,y) pairs","use vstd::prelude::*;

verus! {",,"spec fn hermite_basis(n: nat, t: int) -> int
    decreases n
{
    if n == 0 {
        1
    } else if n == 1 {
        t
    } else {
        t * hermite_basis((n - 1) as nat, t) - (n - 1) as int * hermite_basis((n - 2) as nat, t)
    }
}

spec fn matrix_sum(c: Seq<Vec<i8>>, x: int, y: int) -> int {
    let n = c.len() as int;
    if n == 0 {
        0
    } else {
        let m = c[0].len() as int;
        matrix_sum_helper(c, x, y, 0, n, m)
    }
}

spec fn matrix_sum_helper(c: Seq<Vec<i8>>, x: int, y: int, i: int, n: int, m: int) -> int
    decreases n - i
{
    if i >= n {
        0
    } else {
        row_sum_helper(c[i], x, y, i, 0, m) + matrix_sum_helper(c, x, y, i + 1, n, m)
    }
}

spec fn row_sum_helper(row: Vec<i8>, x: int, y: int, i: int, j: int, m: int) -> int
    decreases m - j
{
    if j >= m {
        0
    } else {
        (row[j] as int) * hermite_basis(i as nat, x) * hermite_basis(j as nat, y) + 
        row_sum_helper(row, x, y, i, j + 1, m)
    }
}

fn hermeval2d(x: Vec<i8>, y: Vec<i8>, c: Vec<Vec<i8>>) -> (result: Vec<i8>)
    requires
        x.len() == y.len(),
        x.len() > 0,
        c.len() > 0,
        forall|i: int| 0 <= i < c.len() ==> #[trigger] c[i].len() == c[0].len(),
        c[0].len() > 0,
    ensures
        result.len() == x.len(),
        forall|k: int| 0 <= k < result.len() ==> 
            result[k] as int == matrix_sum(c@, x[k] as int, y[k] as int),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0427,verus,numpy_triple,polynomial_hermite_e_hermevander,,"numpy.polynomial.hermite_e.hermevander: Pseudo-Vandermonde matrix of given degree.

Returns the pseudo-Vandermonde matrix of degree `deg` and sample points
`x`. The pseudo-Vandermonde matrix is defined by

.. math:: V[..., i] = He_i(x),

where ``0 <= i <= deg``. The leading indices of `V` index the elements of
`x` and the last index is the degree of the HermiteE polynomial.

If `c` is a 1-D array of coefficients of length ``n + 1`` and `V` is the
array ``V = hermevander(x, n)``, then ``np.dot(V, c)`` and
``hermeval(x, c)`` are the same up to roundoff. This equivalence is
useful both for least squares fitting and for the evaluation of a large
number of HermiteE series of the same degree and sample points.

Parameters
----------
x : array_like
    Array of points. The dtype is converted to float64 or complex128
    depending on whether any of the elements are complex. If `x` is
    scalar it is converted to a 1-D array.
deg : int
    Degree of the resulting matrix.

Returns
-------
vander : ndarray
    The pseudo-Vandermonde matrix. The shape of the returned matrix is
    ``x.shape + (deg + 1,)``, where The last index is the degree of the
    corresponding HermiteE polynomial.  The dtype will be the same as
    the converted `x`.

Specification: hermevander returns a pseudo-Vandermonde matrix where each row
corresponds to a point in x, and each column corresponds to a HermiteE polynomial
of degree 0 through deg evaluated at that point.

The HermiteE polynomials (also called probabilist's Hermite polynomials) are
defined by the recurrence relation:
- He_0(x) = 1
- He_1(x) = x  
- He_n(x) = x * He_{n-1}(x) - (n-1) * He_{n-2}(x)

Precondition: True (no special preconditions needed)
Postcondition: 
1. The matrix has shape (n, deg + 1)
2. For each row i and column j, V[i][j] = He_j(x[i])
3. First column is all ones (He_0(x) = 1)
4. Second column equals x (He_1(x) = x) when deg > 0
5. Subsequent columns follow the HermiteE recurrence relation","use vstd::prelude::*;

verus! {",,"fn hermevander(x: Vec<f64>, deg: u8) -> (result: Vec<Vec<f64>>)
    requires deg as nat >= 0,
    ensures
        result.len() == x.len(),
        forall|i: int| 0 <= i < result@.len() ==> result@[i].len() == deg as nat + 1,
        forall|i: int| 0 <= i < result@.len() ==> result@[i][0] == 1.0,
        deg > 0 ==> forall|i: int| 0 <= i < result@.len() ==> result@[i][1] == x@[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0428,verus,numpy_triple,polynomial_hermite_e_hermevander2d,,"Pseudo-Vandermonde matrix of given degrees for 2D HermiteE polynomials.

Returns the pseudo-Vandermonde matrix of degrees (x_deg, y_deg) and sample
points (x, y). The matrix is defined by:
V[..., (y_deg + 1)*i + j] = He_i(x) * He_j(y)
where 0 <= i <= x_deg and 0 <= j <= y_deg.

This function creates a matrix where each row corresponds to a point (x[k], y[k]) and
each column corresponds to a basis function He_i(x) * He_j(y).

Mathematical properties include matrix structure, basis ordering, equivalence with
polynomial evaluation, orthogonality properties from HermiteE basis functions,
and polynomial fitting capability for least squares.","use vstd::prelude::*;

verus! {",,"spec fn hermite_basis(k: nat, t: int) -> int
    decreases k
{
    if k == 0 {
        1
    } else if k == 1 {
        t
    } else {
        t * hermite_basis((k - 1) as nat, t) - (k - 1) as int * hermite_basis((k - 2) as nat, t)
    }
}

fn hermevander2d(x: Vec<i8>, y: Vec<i8>, x_deg: usize, y_deg: usize) -> (result: Vec<Vec<i8>>)
    requires 
        x.len() == y.len(),
        x.len() > 0,
    ensures 
        result.len() == x.len(),
        forall|point_idx: int| 0 <= point_idx < result.len() ==> 
            result[point_idx].len() == (x_deg + 1) * (y_deg + 1),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0429,verus,numpy_triple,polynomial_hermite_e_hermevander3d,,"numpy.polynomial.hermite_e.hermevander3d: Pseudo-Vandermonde matrix of given degrees.

Returns the pseudo-Vandermonde matrix of degrees `deg` and sample
points `(x, y, z)`. If `l`, `m`, `n` are the given degrees in `x`, `y`, `z`,
then the pseudo-Vandermonde matrix is defined by

.. math:: V[..., (m+1)(n+1)i + (n+1)j + k] = He_i(x)*He_j(y)*He_k(z),

where `0 <= i <= l`, `0 <= j <= m`, and `0 <= k <= n`. The leading
indices of `V` index the points `(x, y, z)` and the last index encodes
the degrees of the HermiteE polynomials.

The HermiteE polynomials (also called probabilist's Hermite polynomials) are
defined by the recurrence relation:
- He_0(t) = 1
- He_1(t) = t  
- He_n(t) = t * He_{n-1}(t) - (n-1) * He_{n-2}(t)

Parameters
----------
x, y, z : Vector Float n
    Arrays of point coordinates, all of the same shape.
deg : Vector Nat 3
    Vector of maximum degrees of the form [x_deg, y_deg, z_deg].

Returns
-------
vander3d : Vector (Vector Float order) n
    The pseudo-Vandermonde matrix where order = (deg[0]+1)*(deg[1]+1)*(deg[2]+1).

Specification: hermevander3d returns a 3D pseudo-Vandermonde matrix where each row
corresponds to a point (x[i], y[i], z[i]), and each column corresponds to a product
of HermiteE polynomials He_i(x)*He_j(y)*He_k(z) for various degrees.

// Just return 1.0 as a placeholder to avoid floating point ops","use vstd::prelude::*;

verus! {",,"spec fn hermite_poly(k: int, t: f64) -> f64
    decreases k
{
    if k <= 0 {
        1.0
    } else if k == 1 {
        t
    } else {

        1.0
    }
}

fn hermevander3d(x: Vec<f64>, y: Vec<f64>, z: Vec<f64>, deg: Vec<u8>) -> (result: Vec<Vec<f64>>)
    requires 
        x.len() == y.len(),
        y.len() == z.len(),
        deg.len() == 3,
        deg[0] as int >= 0 && deg[1] as int >= 0 && deg[2] as int >= 0,
    ensures
        result.len() == x.len(),
        forall |p: int| 0 <= p < result.len() ==> {
            let x_deg = deg[0] as int;
            let y_deg = deg[1] as int; 
            let z_deg = deg[2] as int;
            let order = (x_deg + 1) * (y_deg + 1) * (z_deg + 1);
            &&& #[trigger] result[p].len() == order
            &&& (order > 0 ==> result[p][0] == 1.0)
        }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0430,verus,numpy_triple,polynomial_hermite_e_hermeweight,,"numpy.polynomial.hermite_e.hermeweight: Weight function of the Hermite_e polynomials.

The weight function is exp(-x²/2) and the interval of integration is [-∞, ∞].
The HermiteE polynomials are orthogonal, but not normalized, with respect to this weight function.

For each input value x, computes the weight function w(x) = exp(-x²/2).
This is a fundamental weight function used in probabilistic HermiteE polynomial theory.

Returns an array of the same shape as x, containing the weight function values.

Specification: hermeweight returns a vector where each element is the HermiteE weight function
applied to the corresponding element in x.

The weight function is mathematically defined as w(x) = exp(-x²/2).

Precondition: True (no special preconditions - weight function is defined for all real numbers)
Postcondition: For all indices i, result[i] = exp(-x[i]²/2)

Mathematical properties:
- Weight function is always positive: w(x) > 0 for all x
- Weight function is symmetric: w(x) = w(-x)
- Weight function achieves maximum at x = 0: w(0) = 1
- Weight function approaches 0 as |x| → ∞","use vstd::prelude::*;

verus! {",,"fn hermeweight(x: Vec<i8>) -> (result: Vec<i8>)
    ensures
        result.len() == x.len(),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0431,verus,numpy_triple,polynomial_hermite_e_poly2herme,,"Convert a polynomial to a Hermite series. 
Converts coefficients from standard polynomial basis to Hermite series basis.
Uses Horner's method with Hermite operations: for polynomial p(x) = aₙxⁿ + ... + a₁x + a₀,
builds the equivalent Hermite series by iteratively applying hermeadd(hermemulx(result), coefficient).

Specification: poly2herme converts polynomial coefficients to equivalent Hermite series coefficients.

The conversion preserves the polynomial's mathematical value but represents it in the Hermite basis.
This is a fundamental basis transformation in polynomial algebra.

Key mathematical properties:
1. Basis transformation: standard polynomial basis {1, x, x², x³, ...} → Hermite basis {He₀, He₁, He₂, He₃, ...}
2. Value preservation: ∑ᵢ polᵢ·xⁱ = ∑ᵢ resultᵢ·Heᵢ(x) for all x
3. Degree preservation: polynomial of degree n maps to Hermite series of degree n
4. Invertibility: conversion can be reversed with herme2poly
5. Horner's method: algorithm uses iterative structure for numerical stability

The algorithm implements: result = hermeadd(hermemulx(previous_result), current_coefficient)
applied from highest to lowest degree coefficients.","use vstd::prelude::*;

verus! {",,"fn poly2herme(pol: Vec<f32>) -> (result: Vec<f32>)
    ensures
        result.len() == pol.len(),
        forall|i: int| 0 <= i < pol@.len() && pol[i as int] != 0.0f32 ==> exists|j: int| 0 <= j < result@.len() && result[j as int] != 0.0f32,
        (exists|i: int| 0 <= i < pol@.len() && pol[i as int] != 0.0f32) ==> (exists|j: int| 0 <= j < result@.len() && result[j as int] != 0.0f32),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0432,verus,numpy_triple,polynomial_hermite_herm2poly,,"Convert a Hermite series to a polynomial.
Converts coefficients of a Hermite series (ordered from lowest to highest degree)
to coefficients of the equivalent standard polynomial (ordered from lowest to highest degree).

The Hermite polynomials H_n(x) satisfy the recurrence relation:
H_{n+1}(x) = 2x * H_n(x) - 2n * H_{n-1}(x)
with H_0(x) = 1 and H_1(x) = 2x

This function performs the inverse transformation, converting from Hermite basis to standard basis.","use vstd::prelude::*;

verus! {",,"fn herm2poly(c: Vec<i8>) -> (result: Vec<i8>)
    requires c.len() > 0,
    ensures
        result.len() == c.len(),
        /* Sanity checks */
        c.len() == 1 ==> result@ == c@,
        c.len() == 2 ==> result[0] == c[0] && result[1] as int == 2 * c[1] as int,
        /* Example from documentation: herm2poly([1, 2.75, 0.5, 0.375]) approximated with integers */
        (c.len() == 4 && c[0] as int == 1 && c[1] as int == 3 && c[2] as int == 1 && c[3] as int == 0) ==>
            (result[0] as int == 0 && result[1] as int == 1 && result[2] as int == 2 && result[3] as int == 3)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0433,verus,numpy_triple,polynomial_hermite_hermadd,,"numpy.polynomial.hermite.hermadd: Add one Hermite series to another.

Returns the sum of two Hermite series c1 + c2. The arguments are
sequences of coefficients ordered from lowest order term to highest,
i.e., [1,2,3] represents the series P_0 + 2*P_1 + 3*P_2.

Unlike multiplication, division, etc., the sum of two Hermite series
is a Hermite series (without having to ""reproject"" the result onto
the basis set) so addition, just like that of ""standard"" polynomials,
is simply ""component-wise.""

This version handles adding two Hermite coefficient vectors where the
result length is the maximum of the input lengths. Shorter vectors are
implicitly padded with zeros.

Specification: hermadd performs component-wise addition of Hermite series coefficients.

Precondition: True (no special preconditions for basic addition)
Postcondition: 
- If i < min(n,m), result[i] = c1[i] + c2[i]
- If min(n,m) ≤ i < n, result[i] = c1[i] (c2 is treated as 0)
- If min(n,m) ≤ i < m, result[i] = c2[i] (c1 is treated as 0)

The mathematical property: The i-th coefficient of the sum is the sum of
the i-th coefficients of the input series, treating missing coefficients as 0.","use vstd::prelude::*;

verus! {",,"fn hermadd(c1: Vec<i8>, c2: Vec<i8>) -> (result: Vec<i8>)
    ensures
        result@.len() == if c1@.len() >= c2@.len() { c1@.len() } else { c2@.len() },
        forall|i: int| 0 <= i < result@.len() ==>
            result@[i] as int == (
                if i < c1@.len() && i < c2@.len() {
                    c1@[i] as int + c2@[i] as int
                } else if i < c1@.len() {
                    c1@[i] as int
                } else if i < c2@.len() {
                    c2@[i] as int
                } else {
                    0
                }
            ),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0434,verus,numpy_triple,polynomial_hermite_hermcompanion,,"Return the scaled companion matrix of Hermite polynomial coefficients.
The companion matrix is symmetric when c represents a Hermite basis polynomial.","use vstd::prelude::*;

verus! {",,"fn hermcompanion(c: Vec<i8>) -> (result: Vec<Vec<i8>>)
    requires 
        c@.len() >= 2,
        c[c@.len() - 1] as int != 0,
    ensures
        result@.len() == c@.len() - 1,
        forall|i: int| 0 <= i < result@.len() ==> result@[i].len() == c@.len() - 1,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0435,verus,numpy_triple,polynomial_hermite_hermder,,"Differentiate a Hermite series.
Returns the Hermite series coefficients differentiated `m` times.
At each iteration the result is multiplied by `scl` (scaling factor).
The coefficients are from low to high degree.

Specification: hermder differentiates Hermite series coefficients according to
the Hermite polynomial derivative rule: d/dx H_n(x) = 2n * H_{n-1}(x).
The result has degree reduced by m (or becomes zero if m >= n).
Each differentiation multiplies by the scaling factor scl.","use vstd::prelude::*;

verus! {",,"fn hermder(c: Vec<i8>, m: usize, scl: i8) -> (result: Vec<i8>)
    ensures
        result.len() == if m >= c.len() { 0 } else { c.len() - m },
        m >= c.len() ==> result.len() == 0,
        m < c.len() ==> result.len() == c.len() - m,
        (m == 1 && c.len() > 0) ==> (
            forall|i: int| 0 <= i < result.len() ==> 
                result[i] as int == (scl as int) * (2 * ((i + 1) as int)) * (c[i + 1] as int)
        ),
        (m == 2 && c.len() > 1) ==> (
            forall|i: int| 0 <= i < result.len() ==>
                result[i] as int == (scl as int) * (scl as int) * (2 * ((i + 2) as int)) * (2 * ((i + 1) as int)) * (c[i + 2] as int)
        ),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0436,verus,numpy_triple,polynomial_hermite_hermdiv,,"Divide one Hermite series by another.

Returns the quotient-with-remainder of two Hermite series
c1 / c2. The arguments are sequences of coefficients from lowest
order term to highest, e.g., [1,2,3] represents the series
P_0 + 2*P_1 + 3*P_2.

Parameters:
- c1: 1-D array of Hermite series coefficients (dividend)
- c2: 1-D array of Hermite series coefficients (divisor)

Returns:
- (quo, rem): Pair of arrays representing quotient and remainder

Specification: hermdiv divides Hermite series c1 by c2, producing quotient and remainder
such that c1 = c2 * quo + rem in the Hermite polynomial basis, where the degree of rem
is less than the degree of c2. The divisor must have at least one non-zero coefficient.","use vstd::prelude::*;

verus! {",,"fn hermdiv(c1: Vec<f32>, c2: Vec<f32>) -> (result: (Vec<f32>, Vec<f32>))
    requires 
        c2.len() > 0,
        exists|i: int| 0 <= i < c2.len() && #[trigger] c2[i] != 0.0f32,
    ensures 
        /* The remainder has all coefficients zero or its effective degree is less than c2's */
        result.1.len() <= c1.len()","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0437,verus,numpy_triple,polynomial_hermite_hermfit,,"Least squares fit of Hermite series to data. Returns coefficients of a Hermite polynomial that best fits the given data points (x, y) with degree deg.","use vstd::prelude::*;

verus! {",,"fn hermfit(x: Vec<f64>, y: Vec<f64>, deg: usize) -> (result: Vec<f64>)
    requires 
        x@.len() > 0,
        x@.len() == y@.len(),
        deg < x@.len(),
    ensures
        result@.len() == deg + 1,
        deg + 1 > 0,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVT01,0.85
VT0438,verus,numpy_triple,polynomial_hermite_hermfromroots,,"Generate a Hermite series with given roots.

Returns the coefficients of the polynomial p(x) = (x - r₀) * (x - r₁) * ... * (x - rₙ)
in Hermite form. If a zero has multiplicity n, it must appear n times in the roots vector.

The resulting polynomial is expressed as: p(x) = c₀ + c₁ * H₁(x) + ... + cₙ * Hₙ(x)
where Hᵢ(x) are Hermite polynomials.

Specification: hermfromroots generates Hermite coefficients such that:
1. The result has length n+1 where n is the number of roots
2. The polynomial has exactly the given roots (when evaluated using Hermite polynomials)
3. The leading coefficient is non-zero (for non-empty roots)
4. For repeated roots, the multiplicity is preserved","use vstd::prelude::*;

verus! {",,"fn hermfromroots(roots: Vec<f32>) -> (coef: Vec<f32>)
    ensures
        coef@.len() == roots@.len() + 1,
        roots@.len() > 0 ==> coef@[roots@.len() as int] != 0.0f32","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0439,verus,numpy_triple,polynomial_hermite_hermgauss,,"Computes the sample points and weights for Gauss-Hermite quadrature.

Gauss-Hermite quadrature.

    Computes the sample points and weights for Gauss-Hermite quadrature.
    These sample points and weights will correctly integrate polynomials of
    degree 2*deg - 1 or less over the interval [-∞, ∞]
    with the weight function f(x) = exp(-x²).

    Parameters
    ----------
    deg : int
        Number of sample points and weights. It must be >= 1.

    Returns
    -------
    x : ndarray
        1-D ndarray containing the sample points.
    y : ndarray
        1-D ndarray containing the weights.

    Notes
    -----
    The results have only been tested up to degree 100, higher degrees may
    be problematic. The weights are determined by using the fact that

    w_k = c / (H'_n(x_k) * H_{n-1}(x_k))

    where c is a constant independent of k and x_k
    is the k'th root of H_n, and then scaling the results to get
    the right value when integrating 1.","use vstd::prelude::*;

verus! {",,"fn hermgauss(deg: usize) -> (result: (Vec<f64>, Vec<f64>))
    requires deg > 0,
    ensures
        result.0.len() == deg,
        result.1.len() == deg,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0442,verus,numpy_triple,polynomial_hermite_hermint,,"Integrate a Hermite series.

Returns the Hermite series coefficients integrated `m` times from `lbnd`.
At each iteration the resulting series is multiplied by `scl` and an
integration constant from `k` is added.

Specification: hermint integrates Hermite series coefficients.

The specification captures:
1. The output vector has size n + m (m additional coefficients from integration)
2. Each integration adds one coefficient to the series
3. The integration follows Hermite polynomial integration rules
4. Integration constants from k are applied at each integration step
5. Results are scaled by scl at each step

For Hermite polynomials, the integration rule is:
- ∫ H_n(x) dx = H_{n+1}(x)/(2(n+1)) + constant

Mathematical properties:
- The first coefficient of the result incorporates the integration constant to ensure
  the integral evaluates to the appropriate value at lbnd
- For coefficient c[i] representing H_i, integration contributes c[i]/(2*(i+1)) to H_{i+1}
- The scaling factor scl is applied after each integration step","use vstd::prelude::*;

verus! {",,"fn hermint(c: Vec<f32>, m: u8, k: Vec<f32>, lbnd: f32, scl: f32) -> (result: Vec<f32>)
    requires 
        m > 0,
        k.len() == m as nat,
        c.len() > 0,
    ensures 
        result.len() == c.len() + m as nat,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0443,verus,numpy_triple,polynomial_hermite_hermline,,"Hermite series whose graph is a straight line.

Creates a Hermite series representation for the line off + scl*x.
Returns a 2-element vector where:
- First element is the constant term (off)
- Second element is the linear coefficient (scl/2)

Note: When scl = 0, the second element is 0, representing a constant function.

Specification: hermline returns Hermite coefficients for a linear function.

The Hermite series representation of off + scl*x has coefficients:
- c₀ = off (constant term)
- c₁ = scl/2 (linear term coefficient)

These coefficients, when evaluated as a Hermite series, produce the 
original linear function. The relationship comes from the fact that
H₁(x) = 2x in the physicist's Hermite polynomials.","use vstd::prelude::*;

verus! {
spec fn half_f32(x: f32) -> f32;",,"fn hermline(off: f32, scl: f32) -> (result: Vec<f32>)
    ensures
        result.len() == 2,
        result[0] == off,
        result[1] == half_f32(scl)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0444,verus,numpy_triple,polynomial_hermite_hermmul,,"numpy.polynomial.hermite.hermmul: Multiply one Hermite series by another.

Returns the product of two Hermite series c1 * c2. The arguments
are sequences of coefficients, from lowest order term to highest,
e.g., [1,2,3] represents the series P_0 + 2*P_1 + 3*P_2 where P_i
is the i-th Hermite polynomial.

The product of two Hermite series requires reprojection onto the
Hermite basis, which uses the recurrence relation for Hermite
polynomials.

For non-empty inputs of length m and n, the result has length m + n - 1.
For empty inputs, returns a single zero coefficient.

Specification: hermmul returns the coefficients of the product of two
Hermite series.

The key mathematical properties:
1. Empty input handling: If either input is empty, returns [0]
2. Degree property: For non-empty inputs of degree m-1 and n-1,
   the product has degree (m-1) + (n-1) = m + n - 2, requiring m + n - 1 coefficients
3. Multiplication by constant: When one series has only one coefficient (constant polynomial),
   the result is element-wise scaling
4. Commutativity: hermmul c1 c2 = hermmul c2 c1 (up to floating point precision)
5. The general multiplication follows Hermite polynomial recurrence relations

Precondition: True (works for all valid inputs)
Postcondition: Captures empty input behavior, constant multiplication, and size properties

/* Empty input handling */

/* Non-empty inputs have correct output size */

/* Multiplication by constant polynomial (degree 0) */

/* Zero polynomial property */","use vstd::prelude::*;

verus! {",,"fn hermmul(c1: Vec<i8>, c2: Vec<i8>) -> (result: Vec<i8>)
    ensures

        (c1.len() == 0 || c2.len() == 0) ==> (result.len() == 1 && result[0] == 0),

        (c1.len() > 0 && c2.len() > 0) ==> result.len() == c1.len() + c2.len() - 1,

        (c2.len() == 1 && c1.len() > 0) ==>
            forall|i: int| 0 <= i < c1.len() ==> result[i] as int == c1[i] as int * c2[0] as int,
        (c1.len() == 1 && c2.len() > 0) ==>
            forall|i: int| 0 <= i < c2.len() ==> result[i] as int == c2[i] as int * c1[0] as int,

        ((forall|i: int| 0 <= i < c1.len() ==> c1[i] == 0) || 
         (forall|j: int| 0 <= j < c2.len() ==> c2[j] == 0)) ==>
            forall|k: int| 0 <= k < result.len() ==> result[k] == 0,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0445,verus,numpy_triple,polynomial_hermite_hermmulx,,"Multiply a Hermite series by x using the recursion relationship xP_i(x) = (P_{i+1}(x)/2 + i*P_{i-1}(x)).

The algorithm implements the recursion for Hermite polynomials. Given input coefficients c[0], c[1], ..., c[n-1], the output has n+1 coefficients where:
- The first coefficient is always 0
- Each c[i] contributes c[i]/2 to position i+1 and c[i]*i to position i-1

For example, with input [1, 2, 3]:
- result[0] = 0 + 2*1 = 2
- result[1] = 1/2 + 3*2 = 0.5 + 6 = 6.5
- result[2] = 2/2 = 1
- result[3] = 3/2 = 1.5
Giving [2, 6.5, 1, 1.5]","use vstd::prelude::*;

verus! {",,"fn hermmulx(c: Vec<i8>) -> (result: Vec<i8>)
    ensures
        result.len() == c.len() + 1,
        forall|k: int| 0 <= k < result.len() ==> #[trigger] result[k] as int == {
            let base_contribution: int = if k == 0 { 0 } else { 0 };
            let forward_contribution: int = if k > 0 && k - 1 < c.len() { 
                c[k - 1] as int / 2
            } else { 
                0
            };
            let backward_contribution: int = if k + 1 < c.len() { 
                c[k + 1] as int * (k + 1)
            } else { 
                0
            };
            base_contribution + forward_contribution + backward_contribution
        }","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0446,verus,numpy_triple,polynomial_hermite_hermpow,,"Raise a Hermite polynomial series to a power.
Given coefficients `c` representing a Hermite series (ordered from low to high degree),
returns the coefficients of the series raised to the power `pow`.
The `maxpower` parameter limits the maximum degree of the result.

Specification: hermpow raises a Hermite series to a power by repeated multiplication.
Key properties:
1. For pow = 0, the result is the constant polynomial [1]
2. For pow = 1, the result equals the input polynomial
3. For pow > 1, the result is obtained by repeated Hermite multiplication
4. The result degree is bounded by min(n + (n-1)*pow - 1, maxpower)
5. The operation respects the algebraic properties of polynomial exponentiation

/* Sanity check: result has bounded size */

/* Property 1: Power of 0 gives constant polynomial [1] */

/* Property 2: Power of 1 preserves the polynomial (up to size constraints) */

/* Property 3: The result represents c^pow in the Hermite polynomial basis */

/* For non-zero inputs with pow > 0, result is non-trivial */","use vstd::prelude::*;

verus! {",,"fn hermpow(c: Vec<f64>, pow: usize, maxpower: usize) -> (result: Vec<f64>)
    requires 
        c.len() > 0,
    ensures

        result.len() <= maxpower + 1,
        result.len() == if c.len() + (c.len() - 1) * pow <= maxpower + 1 {
            c.len() + (c.len() - 1) * pow
        } else {
            maxpower + 1
        },

        pow == 0 ==> result.len() == 1 && result[0] == 1.0,

        (pow == 1 && c.len() <= maxpower + 1) ==> (
            result.len() == c.len() &&
            forall|i: int| 0 <= i < c.len() ==> result[i] == c[i]
        ),

        ((exists|i: int| 0 <= i < c.len() && c[i] != 0.0) && pow > 0) ==> 
            exists|j: int| 0 <= j < result.len() && result[j] != 0.0,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0447,verus,numpy_triple,polynomial_hermite_hermroots,,"Compute the roots of a Hermite series.

Returns the roots (zeros) of the polynomial p(x) = Σᵢ c[i] * Hᵢ(x),
where Hᵢ(x) are Hermite polynomials.

The roots are obtained as eigenvalues of the companion matrix.

Specification: hermroots computes the roots of a Hermite polynomial.

Key properties:
1. Returns n-1 roots for n coefficients (degree n-1 polynomial)
2. The roots are sorted in ascending order
3. Each root is a zero of the Hermite polynomial
4. For the linear case (n=2), provides exact formula

Precondition: n > 0 to ensure valid polynomial","use vstd::prelude::*;

verus! {",,"fn hermroots(c: Vec<f32>) -> (roots: Vec<f32>)
    requires c.len() > 0,
    ensures
        /* Basic size property */
        roots.len() == c.len() - 1,
        /* For n = 1 (constant polynomial), no roots */
        c.len() == 1 ==> roots.len() == 0,
        /* For n = 2 (linear polynomial c₀ + c₁·H₁(x) where H₁(x) = 2x) */
        c.len() == 2 ==> (
            roots.len() == 1
            /* In practice: roots[0] = -0.5 * c[0] / c[1] when c[1] ≠ 0 */
        ),
        /* Roots are sorted for n > 2 - abstract property */
        c.len() > 2 ==> true,
        /* Mathematical property: roots are zeros of the Hermite polynomial */
        /* Each r in roots satisfies: Σᵢ c[i] * Hᵢ(r) ≈ 0 */
        /* Numerical accuracy: the companion matrix method is stable */
        true","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0448,verus,numpy_triple,polynomial_hermite_hermsub,,"Subtract one Hermite series from another.

Returns the difference of two Hermite series c1 - c2. The sequences of coefficients 
are from lowest order term to highest. The subtraction is component-wise, with 
missing coefficients treated as zero.

Specification: hermsub performs component-wise subtraction of Hermite series coefficients,
treating missing coefficients as zero. The result has the length of the longer input.","use vstd::prelude::*;

verus! {",,"fn hermsub(c1: Vec<i8>, c2: Vec<i8>) -> (result: Vec<i8>)
    ensures
        result.len() == if c1.len() >= c2.len() { c1.len() } else { c2.len() },
        forall|i: int| 0 <= i < c1.len() && 0 <= i < c2.len() ==> 
            result@[i] == c1@[i] - c2@[i],
        c1.len() > c2.len() ==> forall|i: int| 
            c2.len() <= i < c1.len() ==> result@[i] == c1@[i],
        c2.len() > c1.len() ==> forall|i: int| 
            c1.len() <= i < c2.len() ==> result@[i] == -c2@[i],","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0450,verus,numpy_triple,polynomial_hermite_hermval2d,,"Evaluate a 2-D Hermite series at points (x, y).

Given a 2D coefficient matrix c where c[i,j] is the coefficient for H_i(x) * H_j(y),
evaluates the sum: ∑_{i,j} c_{i,j} * H_i(x) * H_j(y)
where H_i and H_j are Hermite polynomials.

The x and y vectors must have the same length, and the function evaluates
the 2D polynomial at each pair of corresponding points (x[k], y[k]).

/* Empty coefficient cases evaluate to zero */","use vstd::prelude::*;

verus! {",,"fn hermval2d(x: Vec<f32>, y: Vec<f32>, c: Vec<Vec<f32>>) -> (result: Vec<f32>)
    requires 
        x.len() == y.len(),
    ensures 
        result.len() == x.len(),

        c.len() == 0 ==> forall|k: int| 0 <= k < result.len() ==> result[k] == 0.0f32,
        c.len() > 0 && c@[0].len() == 0 ==> forall|k: int| 0 <= k < result.len() ==> result[k] == 0.0f32,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0453,verus,numpy_triple,polynomial_hermite_hermvander2d,,"Pseudo-Vandermonde matrix of given degrees for 2D Hermite polynomials.

Returns a matrix where each row corresponds to a sample point (x[i], y[i]),
and columns represent products of Hermite polynomials H_i(x) * H_j(y).
The column at index (ydeg + 1)*i + j contains H_i(x) * H_j(y).

This creates the design matrix for fitting 2D Hermite polynomial surfaces,
where coefficients are arranged in row-major order: c_00, c_01, ..., c_10, c_11, ...

Specification: hermvander2d creates a 2D Vandermonde matrix where each element
V[k][(ydeg + 1)*i + j] equals H_i(x[k]) * H_j(y[k]), where H_i denotes the 
i-th Hermite polynomial. The Hermite polynomials follow the recurrence:
H_0(t) = 1, H_1(t) = 2t, H_n(t) = 2t * H_{n-1}(t) - 2(n-1) * H_{n-2}(t)","use vstd::prelude::*;

verus! {",,"spec fn hermite_polynomial(n: nat, t: int) -> int
    decreases n
{
    if n == 0 {
        1
    } else if n == 1 {
        2 * t
    } else {
        2 * t * hermite_polynomial((n - 1) as nat, t) - 2 * (n - 1) * hermite_polynomial((n - 2) as nat, t)
    }
}

fn hermvander2d(x: Vec<i8>, y: Vec<i8>, xdeg: usize, ydeg: usize) -> (result: Vec<Vec<i8>>)
    requires x.len() == y.len(),
    ensures 
        result.len() == x.len(),
        forall|k: int| 0 <= k < result.len() ==> #[trigger] result@[k].len() == (xdeg + 1) * (ydeg + 1),
        forall|k: int| 0 <= k < result.len() ==> #[trigger] result@[k]@[0] as int == 1","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0455,verus,numpy_triple,polynomial_hermite_hermweight,,"Weight function of the Hermite polynomials.
Computes exp(-x²) for each element in the input vector.

The weight function is exp(-x^2) and the interval of
integration is [-inf, inf]. The Hermite polynomials are
orthogonal, but not normalized, with respect to this weight function.

Parameters
----------
x : array_like
   Values at which the weight function will be computed.

Returns
-------
w : ndarray
   The weight function at x.

/* Each output element equals exp(-x²) of the corresponding input */

/* All output values are positive (since exp is always positive) */

/* The weight function achieves its maximum value of 1 at x=0 */

/* The function decreases as |x| increases */","use vstd::prelude::*;

verus! {",,"fn hermweight(x: Vec<f32>) -> (w: Vec<f32>)
    requires x.len() > 0,
    ensures
        w.len() == x.len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0456,verus,numpy_triple,polynomial_hermite_poly2herm,,"numpy.polynomial.hermite.poly2herm: Convert a polynomial to a Hermite series.

Convert an array representing the coefficients of a polynomial (relative
to the ""standard"" basis) ordered from lowest degree to highest, to an
array of the coefficients of the equivalent Hermite series, ordered
from lowest to highest degree.

The conversion transforms between different polynomial bases. The standard
polynomial basis consists of monomials {1, x, x², x³, ...} while the
Hermite polynomial basis consists of Hermite polynomials {H₀(x), H₁(x), H₂(x), ...}.

The algorithm uses Hermite polynomial operations (multiplication by x and addition)
to build up the result iteratively from the highest degree coefficient down.

Specification: poly2herm converts polynomial coefficients to Hermite series coefficients

The specification ensures:
1. The output has the same dimension as the input
2. The conversion preserves the polynomial function when evaluated using respective bases
3. For the zero polynomial (all coefficients zero), the result is also zero
4. The conversion is linear: poly2herm(a*p + b*q) = a*poly2herm(p) + b*poly2herm(q)

Additionally, for specific test cases:
- Converting [0, 1, 2, 3] should yield [1, 2.75, 0.5, 0.375]
- Converting a constant polynomial [c] should yield [c]

/* Zero polynomial maps to zero */

/* Constant polynomial preservation (when n >= 1) */

/* Specific example from documentation (when applicable) */","use vstd::prelude::*;

verus! {",,"fn poly2herm(pol: Vec<f64>) -> (result: Vec<f64>)
    ensures
        result.len() == pol.len(),

        (forall|i: int| 0 <= i < pol@.len() ==> pol@[i] == 0.0) ==> 
            (forall|i: int| 0 <= i < result@.len() ==> result@[i] == 0.0),

        pol.len() > 0 ==> 
            (forall|i: int| 1 <= i < pol@.len() ==> pol@[i] == 0.0) ==>
                result@[0] == pol@[0],

        (pol.len() == 4 && pol@[0] == 0.0 && pol@[1] == 1.0 && 
         pol@[2] == 2.0 && pol@[3] == 3.0) ==>
            (result@[0] == 1.0 && result@[1] == 2.75 && 
             result@[2] == 0.5 && result@[3] == 0.375)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0457,verus,numpy_triple,polynomial_laguerre_Laguerre,,"A Laguerre series class.

The Laguerre class provides the standard Python numerical methods
'+', '-', '*', '//', '%', 'divmod', '**', and '()' as well as the
attributes and methods listed below.

Parameters
----------
coef : array_like
    Laguerre coefficients in order of increasing degree, i.e,
    ``(1, 2, 3)`` gives ``1*L_0(x) + 2*L_1(X) + 3*L_2(x)``.
domain : (2,) array_like, optional
    Domain to use. The interval ``[domain[0], domain[1]]`` is mapped
    to the interval ``[window[0], window[1]]`` by shifting and scaling.
    The default value is [0., 1.].
window : (2,) array_like, optional
    Window, see `domain` for its use. The default value is [0., 1.].
symbol : str, optional
    Symbol used to represent the independent variable in string
    representations of the polynomial expression, e.g. for printing.
    The symbol must be a valid Python identifier. Default value is 'x'.

Constructor for Laguerre series with default domain and window

Specification for Laguerre series construction and properties","use vstd::prelude::*;

verus! {

/* Helper function to evaluate a Laguerre polynomial at a given point */
spec fn evaluate_laguerre_polynomial(coef: Seq<f32>, x: f32) -> f32 
    decreases coef.len()
{
    if coef.len() == 0 {
        0.0
    } else {
        coef[0]
    }
}

/* Domain mapping function for polynomial transformations */
spec fn map_domain(domain: [f32; 2], window: [f32; 2], x: f32) -> f32 {
    x
}

/* Helper function for individual Laguerre polynomial basis functions */
spec fn laguerre_polynomial_basis(n: nat, x: f32) -> f32 {
    1.0
}

/* A Laguerre series class representing a polynomial in the Laguerre basis.
   This structure encapsulates Laguerre coefficients with domain and window information. */
struct Laguerre {
    /* Laguerre coefficients in order of increasing degree */
    coef: Vec<f32>,
    /* Domain interval [domain[0], domain[1]] for mapping */
    domain: [f32; 2],
    /* Window interval [window[0], window[1]] for mapping */
    window: [f32; 2],
}",,"fn make_laguerre(coefficients: Vec<f32>) -> (result: Laguerre)
    ensures
        result.coef@ == coefficients@,
        result.domain[0] == 0.0f32 && result.domain[1] == 1.0f32,
        result.window[0] == 0.0f32 && result.window[1] == 1.0f32,
        forall|i: int| 0 <= i < coefficients@.len() ==> result.coef@[i] == coefficients@[i]","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0458,verus,numpy_triple,polynomial_laguerre_lag2poly,,"Convert a Laguerre series to a polynomial.
Convert an array representing the coefficients of a Laguerre series,
ordered from lowest degree to highest, to an array of the coefficients
of the equivalent polynomial (relative to the ""standard"" basis).

Specification: lag2poly converts Laguerre series coefficients to standard polynomial coefficients.
The converted polynomial evaluates to the same values as the original Laguerre series.

/* Helper function to evaluate a Laguerre polynomial at a given point */

/* Helper function to evaluate a standard polynomial at a given point */

/* The converted polynomial evaluates to the same values as the Laguerre series */

/* Single coefficient case: lag2poly([a]) = [a] */

/* The conversion preserves the polynomial degree */","use vstd::prelude::*;

verus! {

spec fn evaluate_laguerre_polynomial(c: Seq<f32>, x: f32) -> f32;

spec fn evaluate_polynomial(coeffs: Seq<f32>, x: f32) -> f32;",,"fn lag2poly(c: Vec<f32>) -> (result: Vec<f32>)
    requires c.len() > 0,
    ensures
        result.len() == c.len(),

        forall|x: f32| evaluate_polynomial(result@, x) == evaluate_laguerre_polynomial(c@, x),

        c.len() == 1 ==> result@ == c@,

        c.len() > 0 ==> evaluate_polynomial(result@, 0.0) == evaluate_laguerre_polynomial(c@, 0.0),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0459,verus,numpy_triple,polynomial_laguerre_lagadd,,"Add one Laguerre series to another.
Returns the sum of two Laguerre series c1 + c2. The arguments
are sequences of coefficients ordered from lowest order term to highest.

Specification: lagadd performs component-wise addition of two Laguerre series coefficients.
The result length is the maximum of the input lengths, with shorter arrays padded with zeros.","use vstd::prelude::*;

verus! {",,"spec fn evaluate_laguerre_polynomial(coeffs: Seq<f32>, x: f32) -> f32
{
    arbitrary()
}

spec fn f32_add(a: f32, b: f32) -> f32
{
    arbitrary()
}

spec fn max_usize(a: usize, b: usize) -> usize
{
    if a >= b { a } else { b }
}

fn lagadd(c1: Vec<f32>, c2: Vec<f32>) -> (result: Vec<f32>)
    ensures
        result.len() == max_usize(c1.len(), c2.len()),
        forall|i: int| 0 <= i < result.len() ==> {
            #[trigger] result[i] == f32_add(
                if i < c1.len() { c1[i] } else { 0.0f32 },
                if i < c2.len() { c2[i] } else { 0.0f32 }
            )
        },
        (c1.len() > 0 || c2.len() > 0) ==> result.len() > 0","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0460,verus,numpy_triple,polynomial_laguerre_lagcompanion,,"Returns the companion matrix of Laguerre polynomial coefficients. The companion matrix is a square matrix of size (deg, deg) where deg = c.size - 1. For coefficients [c₀, c₁, ..., cₙ], the companion matrix has specific structure for Laguerre polynomials with diagonal elements 2*i + 1 and off-diagonal elements. Specification: lagcompanion returns the companion matrix of Laguerre polynomial coefficients. The companion matrix is symmetric for Laguerre polynomials and has dimension (deg, deg) where deg = c.size - 1. The matrix structure follows the Laguerre polynomial recurrence relation.","use vstd::prelude::*;

verus! {",,"fn lagcompanion(c: Vec<i8>) -> (result: Vec<Vec<i8>>)
    requires 
        c.len() >= 2,
    ensures 
        result@.len() == c@.len() - 1,
        forall|i: int| 0 <= i < result@.len() ==> result@[i].len() == c@.len() - 1,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0461,verus,numpy_triple,polynomial_laguerre_lagder,,"Differentiates a Laguerre series m times with optional scaling.
Returns the coefficients of the differentiated Laguerre series.

This function implements the NumPy polynomial.laguerre.lagder functionality,
which differentiates a Laguerre series and follows Laguerre polynomial 
recurrence relations. Each differentiation is scaled by scl.","use vstd::prelude::*;

verus! {",,"fn lagder(c: Vec<f32>, m: u8, scl: f32) -> (result: Vec<f32>)
    requires c.len() > 0,
    ensures
        result.len() == c.len(),
        m as nat == 0 ==> (forall|i: int| 0 <= i < c@.len() ==> result@[i] == c@[i]),
        (m as nat >= c@.len() && c@.len() > 0) ==> (forall|i: int| 0 <= i < result@.len() ==> result@[i] == 0.0f32),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0462,verus,numpy_triple,polynomial_laguerre_lagdiv,,"Divides one Laguerre series by another, returning quotient and remainder.
The division is performed in the Laguerre polynomial basis.","use vstd::prelude::*;

verus! {",,"fn lagdiv(c1: Vec<f64>, c2: Vec<f64>) -> (result: (Vec<f64>, Vec<f64>))
    requires 
        c1@.len() > 0,
        c2@.len() > 0,
        exists|i: int| 0 <= i < c2@.len() && c2[i] != 0.0,
    ensures
        result.0@.len() == c1@.len(),
        result.1@.len() == c2@.len(),
        c2@.len() > 0 ==> exists|highest_nonzero: int| 
            0 <= highest_nonzero < c2@.len() &&
            (forall|j: int| highest_nonzero < j < result.1@.len() ==> result.1[j] == 0.0) &&
            c2[highest_nonzero] != 0.0,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0466,verus,numpy_triple,polynomial_laguerre_laggrid2d,,"numpy.polynomial.laguerre.laggrid2d: Evaluate a 2-D Laguerre series on the Cartesian product of x and y.

This function computes the values p(a,b) = ∑_{i,j} c_{i,j} * L_i(a) * L_j(b)
where the points (a,b) consist of all pairs formed by taking a from x and b from y.
The resulting points form a grid with x in the first dimension and y in the second.

The coefficients c represent a 2D matrix where c[i,j] is the coefficient for
the term of multi-degree i,j in the Laguerre series expansion.

Specification: laggrid2d evaluates a 2D Laguerre series on the Cartesian product of x and y.

The function computes p(a,b) = ∑_{i,j} c_{i,j} * L_i(a) * L_j(b) for each point (a,b)
in the Cartesian product of x and y.

Precondition: The coefficient matrix c must be non-empty (rows > 0 and cols > 0)
Postcondition: The result is a grid where result[i][j] represents the evaluation
of the Laguerre series at point (x[i], y[j]).

Mathematical properties:
1. The result has shape (nx, ny) - same as the Cartesian product of x and y
2. Each element result[i][j] is the sum over all coefficient terms c[k][l] * L_k(x[i]) * L_l(y[j])
3. For constant coefficients (c[0][0] only), the result should be constant
4. The function is linear in the coefficients","use vstd::prelude::*;

verus! {",,"fn laggrid2d(x: Vec<f64>, y: Vec<f64>, c: Vec<Vec<f64>>) -> (result: Vec<Vec<f64>>)
    requires
        c@.len() > 0,
        c@.len() > 0 ==> c@[0].len() > 0,
        forall|i: int| 0 <= i < c@.len() ==> #[trigger] c@[i].len() == c@[0].len(),
    ensures
        result@.len() == x@.len(),
        forall|i: int| 0 <= i < result@.len() ==> #[trigger] result@[i].len() == y@.len(),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0467,verus,numpy_triple,polynomial_laguerre_laggrid3d,,"numpy.polynomial.laguerre.laggrid3d: Evaluate a 3-D Laguerre series on the Cartesian product of x, y, and z.

This function computes the values p(a,b,c) = ∑_{i,j,k} c_{i,j,k} * L_i(a) * L_j(b) * L_k(c)
where the points (a,b,c) consist of all triples formed by taking a from x, b from y, and c from z.
The resulting points form a grid with x in the first dimension, y in the second, and z in the third.

The coefficients c represent a 3D tensor where c[i,j,k] is the coefficient for
the term of multi-degree i,j,k in the Laguerre series expansion.

Specification: laggrid3d evaluates a 3D Laguerre series on the Cartesian product of x, y, and z.

The function computes p(a,b,c) = ∑_{i,j,k} c_{i,j,k} * L_i(a) * L_j(b) * L_k(c) for each point (a,b,c)
in the Cartesian product of x, y, and z.

Precondition: The coefficient tensor c must be non-empty (dim1 > 0, dim2 > 0, and dim3 > 0)
Postcondition: The result is a 3D grid where result[i][j][k] represents the evaluation
of the Laguerre series at point (x[i], y[j], z[k]).

Mathematical properties:
1. The result has shape (nx, ny, nz) - same as the Cartesian product of x, y, and z
2. Each element result[i][j][k] is the sum over all coefficient terms c[l][m][n] * L_l(x[i]) * L_m(y[j]) * L_n(z[k])
3. For constant coefficients (c[0][0][0] only), the result should be constant
4. The function is linear in the coefficients","use vstd::prelude::*;

verus! {",,"fn laggrid3d(x: Vec<f64>, y: Vec<f64>, z: Vec<f64>, c: Vec<Vec<Vec<f64>>>) -> (result: Vec<Vec<Vec<f64>>>)
    requires 
        c.len() > 0,
        forall|i: int| 0 <= i < c.len() ==> c@[i].len() > 0,
        forall|i: int, j: int| 0 <= i < c.len() && 0 <= j < c@[i].len() ==> c@[i]@[j].len() > 0,
    ensures 
        result.len() == x.len(),
        forall|i: int| 0 <= i < result.len() ==> result@[i].len() == y.len(),
        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result@[i].len() ==> result@[i]@[j].len() == z.len(),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0468,verus,numpy_triple,polynomial_laguerre_lagint,,"numpy.polynomial.laguerre.lagint: Integrate a Laguerre series.

Returns the Laguerre series coefficients c integrated m times from
lbnd. At each iteration the resulting series is multiplied by scl 
and an integration constant k is added. The scaling factor is for use 
in a linear change of variable.

The argument c is a vector of coefficients from low to high degree,
e.g., [1,2,3] represents the series L_0 + 2*L_1 + 3*L_2.

Specification: lagint integrates a Laguerre series.

Returns the Laguerre series coefficients c integrated m times from lbnd.
At each iteration the resulting series is multiplied by scl and an
integration constant is added.

Precondition: Integration order m must be non-negative
Postcondition: The result represents the integrated Laguerre series
with increased degree due to integration.

Mathematical properties:
1. The result has degree n + m - 1 (m integrations increase degree by m)
2. Integration is linear: lagint(α*c1 + β*c2) = α*lagint(c1) + β*lagint(c2) 
3. For zero coefficients, integration with constants gives the constant
4. Multiple integrations accumulate degree increases","use vstd::prelude::*;

verus! {",,"fn lagint(c: Vec<f64>, m: u8, k: Vec<f64>, lbnd: f64, scl: f64) -> (result: Vec<f64>)
    requires 
        k.len() == m as usize,
        scl != 0.0,
    ensures 
        result.len() == c.len() + m as usize","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0469,verus,numpy_triple,polynomial_laguerre_lagline,,Laguerre series whose graph is a straight line off + scl*x. Specification: lagline returns the Laguerre series representation of off + scl*x.,"use vstd::prelude::*;

verus! {",,"fn lagline(off: f32, scl: f32) -> (result: Vec<f32>)
    ensures result.len() == 2","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0470,verus,numpy_triple,polynomial_laguerre_lagmul,,"Multiply one Laguerre series by another.

This function multiplies two Laguerre series represented as coefficient arrays.
Returns the product of two Laguerre series c1 * c2. The arguments are sequences 
of coefficients, from lowest order ""term"" to highest, e.g., [1,2,3] represents 
the series P_0 + 2*P_1 + 3*P_2.

Parameters:
- c1, c2: 1-D arrays of Laguerre series coefficients ordered from low to high.

Returns:
- out: Array of Laguerre series coefficients representing their product.","use vstd::prelude::*;

verus! {",,"fn lagmul(c1: Vec<f64>, c2: Vec<f64>) -> (result: Vec<f64>)
    requires c1@.len() > 0 && c2@.len() > 0,
    ensures 
        result@.len() == c1@.len() + c2@.len() - 1,
        forall|i: int| 0 <= i < result@.len() ==> 
            (result@[i] != 0.0 ==> 
                exists|j: int, k: int| 
                    0 <= j < c1@.len() && 
                    0 <= k < c2@.len() && 
                    j + k == i && 
                    c1@[j] != 0.0 && 
                    c2@[k] != 0.0)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0471,verus,numpy_triple,polynomial_laguerre_lagmulx,,"Multiply a Laguerre series by x.

Multiply the Laguerre series c by x, where x is the independent variable.

The multiplication uses the recursion relationship for Laguerre polynomials in the form:
xP_i(x) = (-(i + 1)*P_{i + 1}(x) + (2i + 1)P_{i}(x) - iP_{i - 1}(x))","use vstd::prelude::*;

verus! {",,"fn lagmulx(c: Vec<i8>) -> (result: Vec<i8>)
    requires c@.len() > 0,
    ensures 
        result@.len() == c@.len() + 1,
        result@[0] as int == c@[0] as int,
        result@.len() >= 2 ==> result@[1] as int == -(c@[0] as int)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0472,verus,numpy_triple,polynomial_laguerre_lagpow,,"Raise a Laguerre series to a power.

Returns the Laguerre series `c` raised to the power `pow`. The
argument `c` is a sequence of coefficients ordered from low to high.
i.e., [1,2,3] is the series  ``P_0 + 2*P_1 + 3*P_2.``

Specification: lagpow raises a Laguerre series to a power with proper constraints","use vstd::prelude::*;

verus! {",,"fn lagpow(c: Vec<f32>, pow: u8, maxpower: u8) -> (result: Vec<f32>)
    requires 
        pow > 0,
        pow <= maxpower,
        maxpower <= 16,
        c.len() > 0,
    ensures 
        result.len() == c.len(),
        pow == 1 ==> (forall|i: int| 0 <= i < result.len() ==> result[i] == c[i]),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0473,verus,numpy_triple,polynomial_laguerre_lagroots,,"Compute the roots of a Laguerre series.

Return the roots (a.k.a. ""zeros"") of the polynomial
p(x) = sum_i c[i] * L_i(x).

Specification: lagroots computes the roots of a Laguerre polynomial","use vstd::prelude::*;

verus! {",,"fn lagroots(c: Vec<i8>) -> (roots: Vec<i8>)
    requires
        c.len() >= 2,
        c@[c.len() - 1 as int] != 0,
    ensures
        c.len() == 2 ==> roots.len() == 1,
        c.len() == 2 ==> roots@[0] as int == 1 + c@[0] as int / c@[1] as int,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0474,verus,numpy_triple,polynomial_laguerre_lagsub,,"Subtract one Laguerre series from another.

Returns the difference of two Laguerre series `c1` - `c2`.  The
sequences of coefficients are from lowest order term to highest, i.e.,
[1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.

Specification: lagsub subtracts two Laguerre series component-wise","use vstd::prelude::*;

verus! {",,"fn lagsub(c1: Vec<i8>, c2: Vec<i8>) -> (result: Vec<i8>)
    requires c1.len() == c2.len(),
    ensures 
        result.len() == c1.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] as int == c1[i] as int - c2[i] as int,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0475,verus,numpy_triple,polynomial_laguerre_lagval,,"Evaluate a Laguerre series at points x using Clenshaw recursion.
The mathematical formula for the Laguerre series is:
p(x) = c_0 * L_0(x) + c_1 * L_1(x) + ... + c_n * L_n(x)
where L_i(x) are the Laguerre polynomials.

Specification for Laguerre series evaluation:
The result has the same shape as the input x vector.
For a single coefficient, the result is constant.
For multiple coefficients, the function evaluates the Laguerre series
using Clenshaw recursion, which is numerically stable.","use vstd::prelude::*;

verus! {",,"fn lagval(x: Vec<f64>, c: Vec<f64>) -> (result: Vec<f64>)
    requires 
        c@.len() > 0,
        x@.len() > 0,
    ensures
        result@.len() == x@.len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0476,verus,numpy_triple,polynomial_laguerre_lagval2d,,"Evaluate a 2-D Laguerre series at points (x, y).
The mathematical formula is: p(x,y) = sum_{i,j} c_{i,j} * L_i(x) * L_j(y)
where L_i(x) and L_j(y) are the Laguerre polynomials.

Specification for 2-D Laguerre series evaluation:
The result has the same shape as the input x and y vectors.
The function evaluates a bivariate Laguerre polynomial series
using the tensor product of 1-D Laguerre polynomials.

/* Base case: single coefficient returns constant */

/* General case: evaluates 2D Laguerre series */

/* Sanity check: result preserves input shape */","use vstd::prelude::*;

verus! {",,"fn lagval2d(x: Vec<f32>, y: Vec<f32>, c: Vec<Vec<f32>>) -> (result: Vec<f32>)
    requires 
        x@.len() == y@.len(),
        x@.len() > 0,
        c@.len() > 0,
        forall|i: int| 0 <= i < c@.len() ==> c@[i].len() > 0,
    ensures
        result@.len() == x@.len(),

        (c@.len() == 1 && c@[0].len() == 1) ==> 
            forall|i: int| 0 <= i < result@.len() ==> result@[i] == c@[0][0],

        result@.len() == x@.len() && result@.len() == y@.len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0477,verus,numpy_triple,polynomial_laguerre_lagval3d,,"Evaluate a 3-D Laguerre series at points (x, y, z).
The mathematical formula is: p(x,y,z) = sum_{i,j,k} c_{i,j,k} * L_i(x) * L_j(y) * L_k(z)
where L_i(x), L_j(y) and L_k(z) are the Laguerre polynomials.

Specification for 3-D Laguerre series evaluation:
The result has the same shape as the input x, y, and z vectors.
The function evaluates a trivariate Laguerre polynomial series
using the tensor product of 1-D Laguerre polynomials.

/* Base case: single coefficient returns constant */

/* General case: evaluates 3D Laguerre series */","use vstd::prelude::*;

verus! {",,"fn lagval3d(x: Vec<f32>, y: Vec<f32>, z: Vec<f32>, c: Vec<Vec<Vec<f32>>>) -> (result: Vec<f32>)
    requires 
        x.len() == y.len(),
        y.len() == z.len(),
        x.len() > 0,
        c.len() > 0,
        c[0].len() > 0,
        c[0][0].len() > 0,
    ensures
        result.len() == x.len(),
        result.len() == y.len(), 
        result.len() == z.len(),

        (c.len() == 1 && c[0].len() == 1 && c[0][0].len() == 1) ==> 
            forall|i: int| 0 <= i < result.len() ==> result[i] == c[0][0][0],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0481,verus,numpy_triple,polynomial_laguerre_lagweight,,"numpy.polynomial.laguerre.lagweight: Weight function of the Laguerre polynomials.

The weight function is exp(-x) and the interval of integration
is [0, ∞]. The Laguerre polynomials are orthogonal, but not
normalized, with respect to this weight function.

Parameters:
- x: Values at which the weight function will be computed.

Returns:
- w: The weight function at x (exp(-x) for each element).

Specification: lagweight returns a vector where each element is exp(-x[i])
for the corresponding element in x.

The mathematical property is that the weight function exp(-x) is used
for Laguerre polynomial orthogonality on the interval [0, ∞].

Precondition: True (no special preconditions for weight function)
Postcondition: For all indices i, result[i] = exp(-x[i])","use vstd::prelude::*;

verus! {",,"fn lagweight(x: Vec<f32>) -> (result: Vec<f32>)
    ensures result.len() == x.len(),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0482,verus,numpy_triple,polynomial_laguerre_poly2lag,,"numpy.polynomial.laguerre.poly2lag: Convert a polynomial to a Laguerre series.

Convert an array representing the coefficients of a polynomial (relative
to the ""standard"" basis) ordered from lowest degree to highest, to an
array of the coefficients of the equivalent Laguerre series, ordered
from lowest to highest degree.

Parameters:
- pol: 1-D array containing the polynomial coefficients

Returns:
- c: 1-D array containing the coefficients of the equivalent Laguerre series.

Note: The conversion maintains the same degree structure but transforms
the basis from standard polynomial to Laguerre polynomial basis.

Specification: poly2lag converts polynomial coefficients to Laguerre series coefficients.

The mathematical property is that the conversion preserves the polynomial
but expresses it in terms of Laguerre polynomials instead of standard monomials.

Key properties:
1. Same degree: Both input and output have the same number of coefficients
2. Basis transformation: Standard polynomial → Laguerre polynomial basis
3. Orthogonality preservation: The resulting Laguerre series represents the
   same polynomial but in a basis that is orthogonal with respect to exp(-x)

Precondition: True (no special preconditions for basis conversion)
Postcondition: The result represents the same polynomial as input but in
               Laguerre basis, and has the same length as input

/* The coefficients form a valid Laguerre series representation
           of the same polynomial as the input standard polynomial.
           Mathematical property: polynomial evaluation equivalence
           Standard polynomial: Σ(i=0 to n-1) pol[i] * x^i
           Laguerre polynomial: Σ(i=0 to n-1) result[i] * L_i(x)
           where L_i(x) is the i-th Laguerre polynomial */","use vstd::prelude::*;

verus! {",,"fn poly2lag(pol: Vec<i8>) -> (result: Vec<i8>)
    ensures
        result.len() == pol.len(),

        true,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0483,verus,numpy_triple,polynomial_legendre_Legendre,,"A Legendre series class.

    The Legendre class provides the standard Python numerical methods
    '+', '-', '*', '//', '%', 'divmod', '**', and '()' as well as the
    attributes and methods listed below.

    Parameters
    ----------
    coef : array_like
        Legendre coefficients in order of increasing degree, i.e.,
        ``(1, 2, 3)`` gives ``1*P_0(x) + 2*P_1(x) + 3*P_2(x)``.
    domain : (2,) array_like, optional
        Domain to use. The interval ``[domain[0], domain[1]]`` is mapped
        to the interval ``[window[0], window[1]]`` by shifting and scaling.
        The default value is [-1., 1.].
    window : (2,) array_like, optional
        Window, see `domain` for its use. The default value is [-1., 1.].
    symbol : str, optional
        Symbol used to represent the independent variable in string
        representations of the polynomial expression, e.g. for printing.
        The symbol must be a valid Python identifier. Default value is 'x'.

Create a Legendre series from coefficients

Specification: mkLegendre creates a valid Legendre series representation

/* A Legendre series representation with coefficients, domain, and window */

/* Legendre coefficients in order of increasing degree */

/* Domain interval for polynomial evaluation */

/* Window interval for domain mapping */

/* Symbol name for variable representation */","use vstd::prelude::*;

verus! {",,"struct Legendre {

    coef: Vec<f64>,

    domain: [f64; 2],

    window: [f64; 2],

    symbol: String,
}

fn mk_legendre(
    coef: Vec<f64>,
    domain: [f64; 2],
    window: [f64; 2],
    symbol: String
) -> (result: Legendre)
    ensures
        result.coef@ == coef@,
        result.domain == domain,
        result.window == window,
        result.symbol == symbol,
        domain[0] == -1.0 && domain[1] == 1.0 ==> result.domain[0] == -1.0 && result.domain[1] == 1.0,
        window[0] == -1.0 && window[1] == 1.0 ==> result.window[0] == -1.0 && result.window[1] == 1.0,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0484,verus,numpy_triple,polynomial_legendre_leg2poly,,"Convert a Legendre series to a polynomial.

Convert a Legendre series to a polynomial.

    Convert an array representing the coefficients of a Legendre series,
    ordered from lowest degree to highest, to an array of the coefficients
    of the equivalent polynomial (relative to the ""standard"" basis) ordered
    from lowest to highest degree.

    Parameters
    ----------
    c : array_like
        1-D array containing the Legendre series coefficients, ordered
        from lowest order term to highest.

    Returns
    -------
    pol : ndarray
        1-D array containing the coefficients of the equivalent polynomial
        (relative to the ""standard"" basis) ordered from lowest order term
        to highest.

    See Also
    --------
    poly2leg

    Notes
    -----
    The easy way to do conversions between polynomial basis sets
    is to use the convert method of a class instance.

    Examples
    --------
    >>> from numpy import polynomial as P
    >>> c = P.Legendre(range(4))
    >>> c
    Legendre([0., 1., 2., 3.], domain=[-1.,  1.], window=[-1.,  1.], symbol='x')
    >>> p = c.convert(kind=P.Polynomial)
    >>> p
    Polynomial([-1. , -3.5,  3. ,  7.5], domain=[-1.,  1.], window=[-1., ...
    >>> P.legendre.leg2poly(range(4))
    array([-1. , -3.5,  3. ,  7.5])

Convert a Legendre series to a polynomial (monomial basis)

Specification: leg2poly converts Legendre series coefficients to polynomial coefficients

/* For small cases (n < 3), the conversion is identity */

/* The conversion transforms Legendre basis to monomial basis */

/* The mathematical property is that ∑ cᵢ Pᵢ(x) = ∑ result[i] xⁱ */

/* where Pᵢ are the Legendre polynomials */

/* The transformation is well-defined and preserves polynomial degree */","use vstd::prelude::*;

verus! {",,"fn leg2poly(c: Vec<f32>) -> (result: Vec<f32>)
    ensures
        result.len() == c.len(),

        (c.len() as int) < 3 ==> forall|i: int| 0 <= i < (c.len() as int) ==> result[i] == c[i],

        (c.len() as int) > 0,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0485,verus,numpy_triple,polynomial_legendre_legadd,,"Add one Legendre series to another by component-wise addition of coefficients.

Add one Legendre series to another.

Returns the sum of two Legendre series `c1` + `c2`.  The arguments
are sequences of coefficients ordered from lowest order term to
highest, i.e., [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.

Parameters
----------
c1, c2 : array_like
    1-D arrays of Legendre series coefficients ordered from low to
    high.

Returns
-------
out : ndarray
    Array representing the Legendre series of their sum.

See Also
--------
legsub, legmulx, legmul, legdiv, legpow

Notes
-----
Unlike multiplication, division, etc., the sum of two Legendre series
is a Legendre series (without having to ""reproject"" the result onto
the basis set) so addition, just like that of ""standard"" polynomials,
is simply ""component-wise.""

Examples
--------
>>> from numpy.polynomial import legendre as L
>>> c1 = (1,2,3)
>>> c2 = (3,2,1)
>>> L.legadd(c1,c2)
array([4.,  4.,  4.])","use vstd::prelude::*;

verus! {",,"fn legadd(c1: Vec<i8>, c2: Vec<i8>) -> (result: Vec<i8>)
    ensures
        result@.len() == if c1@.len() >= c2@.len() { c1@.len() } else { c2@.len() },
        forall|i: int| 0 <= i < result@.len() ==> {
            let val1: int = if i < c1@.len() { c1@[i] as int } else { 0 };
            let val2: int = if i < c2@.len() { c2@[i] as int } else { 0 };
            #[trigger] result@[i] as int == val1 + val2
        }","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0486,verus,numpy_triple,polynomial_legendre_legcompanion,,"Return the scaled companion matrix of Legendre series coefficients.
The companion matrix is symmetric when c is a Legendre basis polynomial,
providing better eigenvalue estimates.","use vstd::prelude::*;

verus! {",,"fn legcompanion(c: Vec<i8>) -> (result: Vec<Vec<i8>>)
    requires 
        c@.len() >= 2,
        c[c@.len() - 1] as int != 0,
    ensures 
        result@.len() == c@.len() - 1,
        forall|i: int| 0 <= i < result@.len() ==> result@[i]@.len() == c@.len() - 1,
        forall|i: int, j: int| 0 <= i < result@.len() && 0 <= j < result@.len() ==> 
            result@[i]@[j] == result@[j]@[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0487,verus,numpy_triple,polynomial_legendre_legder,,"Differentiate a Legendre series.
Returns the Legendre series coefficients c differentiated m times.
Each differentiation is multiplied by scl (scaling factor).","use vstd::prelude::*;

verus! {",,"fn legder(c: Vec<f64>, m: u8, scl: f64) -> (result: Vec<f64>)
    requires c.len() >= 1,
    ensures
        result.len() == if c.len() > m as usize { c.len() - m as usize } else { 1 },
        m == 0 ==> (result.len() == c.len() && forall|i: int| 0 <= i < c.len() ==> result[i] == c[i]),
        m as usize >= c.len() ==> result.len() == 1,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0488,verus,numpy_triple,polynomial_legendre_legdiv,,"Divide one Legendre series by another.
Returns the quotient and remainder of two Legendre series c1 / c2.
The arguments are sequences of coefficients from lowest order to highest.
Specification: legdiv computes polynomial division in Legendre basis","use vstd::prelude::*;

verus! {",,"fn legdiv(c1: Vec<f32>, c2: Vec<f32>) -> (result: (Vec<f32>, Vec<f32>))
    requires 
        c1@.len() >= 1,
        c2@.len() >= 1,
        exists|i: int| 0 <= i < c2@.len() && c2@[i] != 0.0f32,
    ensures 
        result.0@.len() == (if c1@.len() >= c2@.len() { c1@.len() - c2@.len() + 1 } else { 1 }) &&
        result.1@.len() == (if c2@.len() > 1 { c2@.len() - 1 } else { 1 }) &&
        (c1@.len() < c2@.len() ==> result.0@.len() == 1 && result.0@[0] == 0.0f32) &&
        result.1@.len() <= c2@.len()","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0492,verus,numpy_triple,polynomial_legendre_leggrid2d,,"Evaluate a 2-D Legendre series on the Cartesian product of x and y.
This function computes p(a,b) = ∑_{i,j} c_{i,j} * L_i(a) * L_j(b)
for all pairs (a,b) from the Cartesian product of x and y.

Specification: leggrid2d correctly evaluates a 2-D Legendre series
on the Cartesian product of input points.

The function computes the tensor product evaluation of Legendre polynomials
according to the mathematical formula p(a,b) = ∑_{i,j} c_{i,j} * L_i(a) * L_j(b).","use vstd::prelude::*;

verus! {",,"fn leggrid2d(x: Vec<f32>, y: Vec<f32>, c: Vec<Vec<f32>>) -> (result: Vec<Vec<f32>>)
    requires 
        x@.len() > 0,
        y@.len() > 0,
        c@.len() > 0,
        forall|i: int| 0 <= i < c@.len() ==> c@[i].len() > 0,
    ensures
        /* The result has the correct shape: nx × ny grid */
        result@.len() == x@.len(),
        forall|i: int| 0 <= i < result@.len() ==> result@[i].len() == y@.len(),
        /* Grid structure preserves dimensionality */
        x@.len() > 0 && y@.len() > 0,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0493,verus,numpy_triple,polynomial_legendre_leggrid3d,,"Evaluate a 3-D Legendre series on the Cartesian product of x, y, and z.
This function computes p(a,b,c) = ∑_{i,j,k} c_{i,j,k} * L_i(a) * L_j(b) * L_k(c)
for all triples (a,b,c) from the Cartesian product of x, y, and z.

Specification: leggrid3d correctly evaluates a 3-D Legendre series
on the Cartesian product of input points.

The function computes the tensor product evaluation of Legendre polynomials
according to the mathematical formula p(a,b,c) = ∑_{i,j,k} c_{i,j,k} * L_i(a) * L_j(b) * L_k(c).

/* The result has the correct shape: nx × ny × nz grid */

/* Each grid point (i,j,k) contains the evaluation of the 3D Legendre series */

/* Grid structure preserves dimensionality */","use vstd::prelude::*;

verus! {",,"fn leggrid3d(x: Vec<f64>, y: Vec<f64>, z: Vec<f64>, c: Vec<Vec<Vec<f64>>>) -> (result: Vec<Vec<Vec<f64>>>)
    requires 
        x@.len() > 0,
        y@.len() > 0,
        z@.len() > 0,
        c@.len() > 0,
        forall|i: int| 0 <= i < c@.len() ==> c@[i].len() > 0,
        forall|i: int, j: int| 0 <= i < c@.len() && 0 <= j < c@[i].len() ==> c@[i][j].len() > 0,
    ensures

        result@.len() == x@.len(),
        forall|i: int| 0 <= i < result@.len() ==> result@[i].len() == y@.len(),
        forall|i: int, j: int| 0 <= i < result@.len() && 0 <= j < result@[i].len() ==> result@[i][j].len() == z@.len(),

        forall|i1: int, i2: int, j1: int, j2: int, k1: int, k2: int|
            0 <= i1 < x@.len() && 0 <= i2 < x@.len() && 
            0 <= j1 < y@.len() && 0 <= j2 < y@.len() &&
            0 <= k1 < z@.len() && 0 <= k2 < z@.len() ==>
            ((i1 != i2 || j1 != j2 || k1 != k2) ==> 
             (result@[i1][j1][k1] != result@[i2][j2][k2] || 
              (x@[i1] == x@[i2] && y@[j1] == y@[j2] && z@[k1] == z@[k2])))","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0494,verus,numpy_triple,polynomial_legendre_legint,,"Integrate a Legendre series, returning the coefficients of the integrated series.
The function integrates the Legendre series with coefficients c one time,
applying scaling factor scl and integration constant k.

Specification: legint correctly integrates Legendre series coefficients
according to the mathematical properties of Legendre polynomial integration.

Integration increases the degree of the polynomial by 1, and the resulting 
coefficients satisfy the Legendre integration recurrence relations.","use vstd::prelude::*;

verus! {",,"fn legint(c: Vec<f64>, k: f64, lbnd: f64, scl: f64) -> (result: Vec<f64>)
    requires scl != 0.0,
    ensures result@.len() == c@.len() + 1","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0495,verus,numpy_triple,polynomial_legendre_legline,,Creates a Legendre series representation of a straight line `off + scl*x`. This function generates the correct Legendre series coefficients for a linear function.,"use vstd::prelude::*;

verus! {",,"fn legline(off: f32, scl: f32) -> (result: Vec<f32>)
    ensures
        result@.len() == 2,
        result@[0] == off,
        result@[1] == scl","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0496,verus,numpy_triple,polynomial_legendre_legmul,,"Multiply one Legendre series by another, producing coefficients in Legendre basis","use vstd::prelude::*;

verus! {",,"fn legmul(c1: Vec<i8>, c2: Vec<i8>) -> (result: Vec<i8>)
    requires 
        c1.len() > 0,
        c2.len() > 0,
    ensures
        result.len() == c1.len() + c2.len() - 1,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0497,verus,numpy_triple,polynomial_legendre_legmulx,,"Multiply a Legendre series by x using the Legendre recurrence relation.

Specification: legmulx multiplies a Legendre series by x using the correct recurrence relation.

This function multiplies the Legendre series c by x, where x is the independent variable.
The multiplication uses the recursion relationship for Legendre polynomials in the form:
xP_i(x) = ((i + 1)*P_{i + 1}(x) + i*P_{i - 1}(x))/(2i + 1)","use vstd::prelude::*;

verus! {",,"fn legmulx(c: Vec<f32>) -> (result: Vec<f32>)
    requires c@.len() > 0,
    ensures
        result@.len() == c@.len() + 1,
        result[0] == 0.0f32,
        result[1] == c[0],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0504,verus,numpy_triple,polynomial_legendre_legvander,,"Pseudo-Vandermonde matrix of given degree based on Legendre polynomials.
Returns the pseudo-Vandermonde matrix of degree `deg` and sample points `x`.
The pseudo-Vandermonde matrix is defined by V[..., i] = L_i(x) where 0 <= i <= deg.
L_i represents the i-th Legendre polynomial.

Specification: legvander constructs a pseudo-Vandermonde matrix where each row 
corresponds to a point and each column corresponds to a Legendre polynomial evaluation.
The matrix satisfies basic properties of Legendre polynomials:
- L_0(x) = 1 (first column is all ones)
- L_1(x) = x (second column equals input values when deg > 0)
- The matrix has the correct dimensions","use vstd::prelude::*;

verus! {",,"fn legvander(x: Vec<f32>, deg: usize) -> (result: Vec<Vec<f32>>)
    requires x@.len() > 0,
    ensures
        result@.len() == x@.len(),
        forall|i: int| 0 <= i < result@.len() ==> result@[i].len() == deg + 1,
        forall|i: int| 0 <= i < result@.len() ==> result@[i][0] == 1.0f32,
        deg > 0 ==> forall|i: int| 0 <= i < result@.len() ==> result@[i][1] == x@[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0505,verus,numpy_triple,polynomial_legendre_legvander2d,,"Pseudo-Vandermonde matrix of given degrees for 2D Legendre polynomials.
Returns the pseudo-Vandermonde matrix of degrees `deg` and sample points `(x, y)`.
The pseudo-Vandermonde matrix is defined by V[..., (deg[1] + 1)*i + j] = L_i(x) * L_j(y),
where 0 <= i <= deg[0] and 0 <= j <= deg[1].

Specification: legvander2d constructs a 2D pseudo-Vandermonde matrix where each row 
corresponds to a point (x_i, y_i) and each column corresponds to a product of 
Legendre polynomials L_i(x) * L_j(y).
The matrix satisfies basic properties:
- Each entry is a product of 1D Legendre polynomial evaluations
- The ordering follows the specified indexing scheme
- The matrix has the correct dimensions","use vstd::prelude::*;

verus! {",,"fn legvander2d(x: Vec<f64>, y: Vec<f64>, deg_x: u8, deg_y: u8) -> (result: Vec<Vec<f64>>)
    requires x.len() == y.len(),
    ensures
        result.len() == x.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i].len() == (deg_x as int + 1) * (deg_y as int + 1),
        forall|i: int| 0 <= i < result.len() && result[i].len() > 0 ==> result[i][0] == 1.0","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0506,verus,numpy_triple,polynomial_legendre_legvander3d,,"Pseudo-Vandermonde matrix of given degrees for 3D Legendre polynomials.
Returns the pseudo-Vandermonde matrix of degrees `deg` and sample points `(x, y, z)`.
The pseudo-Vandermonde matrix is defined by 
V[..., (m+1)(n+1)i + (n+1)j + k] = L_i(x)*L_j(y)*L_k(z),
where 0 <= i <= l, 0 <= j <= m, and 0 <= k <= n for degrees [l, m, n].

Specification: legvander3d constructs a 3D pseudo-Vandermonde matrix where each row 
corresponds to a point (x_i, y_i, z_i) and each column corresponds to a product of 
Legendre polynomials L_i(x) * L_j(y) * L_k(z).
The matrix satisfies basic properties:
- Each entry is a product of 1D Legendre polynomial evaluations
- The ordering follows the specified 3D indexing scheme
- The matrix has the correct dimensions","use vstd::prelude::*;

verus! {",,"fn legvander3d(x: &Vec<f32>, y: &Vec<f32>, z: &Vec<f32>, deg_x: usize, deg_y: usize, deg_z: usize) -> (result: Vec<Vec<f32>>)
    requires 
        x.len() == y.len(),
        y.len() == z.len(),
        x.len() > 0,
    ensures
        result.len() == x.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i].len() == (deg_x + 1) * (deg_y + 1) * (deg_z + 1),
        forall|i: int| 0 <= i < result.len() ==> result[i][0] == 1.0f32,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0507,verus,numpy_triple,polynomial_legendre_legweight,,"Weight function of the Legendre polynomials. 
The weight function is constant 1 for all input values.

Specification: legweight returns a vector of all ones with the same length as input.
This captures the mathematical property that the Legendre weight function is constant 1.","use vstd::prelude::*;

verus! {",,"fn legweight(x: Vec<f32>) -> (result: Vec<f32>)
    ensures 
        result@.len() == x@.len(),
        forall|i: int| 0 <= i < result@.len() ==> result@[i] == 1.0f32","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0508,verus,numpy_triple,polynomial_legendre_poly2leg,,"Convert a polynomial to a Legendre series.
Converts coefficients from standard polynomial basis to Legendre basis.

Specification: poly2leg converts polynomial coefficients to Legendre series coefficients.
The transformation preserves the polynomial degree and produces valid Legendre coefficients.
The result has the same dimension as the input and represents the same polynomial
expressed in the Legendre basis instead of the standard monomial basis.","use vstd::prelude::*;

verus! {",,"fn poly2leg(pol: Vec<f32>) -> (result: Vec<f32>)
    ensures 
        result.len() == pol.len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0510,verus,numpy_triple,polynomial_polynomial_Polynomial,,"A power series class representing a polynomial with coefficients in order of increasing degree.

The Polynomial structure encapsulates coefficients from lowest to highest degree,
where coefficients[i] represents the coefficient of x^i. For example,
coefficients [1, 2, 3] represents the polynomial 1 + 2*x + 3*x^2.

The domain and window parameters support polynomial transformations by mapping
the interval [domain[0], domain[1]] to [window[0], window[1]] through scaling
and shifting.","use vstd::prelude::*;

verus! {",,"fn polynomial(coef: Vec<f64>, domain: Vec<f64>, window: Vec<f64>) -> (result: Vec<f64>)
    requires 
        domain.len() == 2,
        window.len() == 2,
        domain[0] != domain[1],
        window[0] != window[1],
    ensures 
        result.len() == coef.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] == coef[i],","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0511,verus,numpy_triple,polynomial_polynomial_polyadd,,"Add one polynomial to another.

Given two polynomials represented as coefficient vectors (from lowest to highest degree),
returns their sum. The result has length equal to the maximum of the input lengths,
with shorter polynomials implicitly padded with zeros.

Specification: polyadd computes c1 + c2 element-wise, padding with zeros.
The result has length max(n, m), and for each coefficient position i:
- If i < min(n, m): result[i] = c1[i] + c2[i]
- If min(n, m) ≤ i < n: result[i] = c1[i]
- If min(n, m) ≤ i < m: result[i] = c2[i]

Additionally, polyadd satisfies mathematical properties:
- Commutativity: polyadd c1 c2 = polyadd c2 c1
- Zero identity: polyadd c 0 = c and polyadd 0 c = c
- Associativity: polyadd (polyadd c1 c2) c3 = polyadd c1 (polyadd c2 c3)
- Leading coefficient preservation: if c1 and c2 have different degrees,
  the result preserves the leading coefficient of the higher-degree polynomial","use vstd::prelude::*;

verus! {",,"fn polyadd(c1: Vec<i8>, c2: Vec<i8>) -> (result: Vec<i8>)
    ensures
        result.len() == if c1.len() >= c2.len() { c1.len() } else { c2.len() },
        forall|i: int| 0 <= i < result.len() ==> {
            if i < c1.len() && i < c2.len() {
                result[i] as int == c1[i] as int + c2[i] as int
            } else if i < c1.len() && i >= c2.len() {
                result[i] as int == c1[i] as int
            } else if i >= c1.len() && i < c2.len() {
                result[i] as int == c2[i] as int
            } else {
                result[i] as int == 0
            }
        }","{
    // impl-start
    assume(false);
    Vec::new()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0512,verus,numpy_triple,polynomial_polynomial_polycompanion,,"Return the companion matrix of a polynomial.

The companion matrix C for a polynomial p(x) = c[0] + c[1]*x + ... + c[n]*x^n
is an (n×n) matrix where the characteristic polynomial is p(x).

For a polynomial of degree n, the companion matrix has the form:
- First (n-1) rows: [0, 0, ..., 0, 1, 0, ..., 0] (identity shifted)
- Last row: [-c[0]/c[n], -c[1]/c[n], ..., -c[n-1]/c[n]]

The companion matrix is used to find roots of the polynomial as eigenvalues.","use vstd::prelude::*;

verus! {",,"fn polycompanion(c: Vec<i8>) -> (result: Vec<Vec<i8>>)
    requires 
        c.len() >= 2,
        c[c.len() - 1] != 0,
    ensures
        result.len() == c.len() - 1,
        forall|i: int| 0 <= i < result.len() ==> result[i].len() == c.len() - 1,
        forall|i: int, j: int| 
            0 <= i < result.len() && 0 <= j < result[i].len() ==>
            (if i + 1 == j && i < c.len() - 2 {
                result[i][j] as int == 1
            } else if i == c.len() - 2 {
                result[i][j] as int * c[c.len() - 1] as int == -c[j] as int
            } else {
                result[i][j] as int == 0
            })","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0513,verus,numpy_triple,polynomial_polynomial_polyder,,"Differentiate a polynomial.

Returns the polynomial coefficients differentiated `m` times.
At each iteration the result is multiplied by `scl` (scaling factor).
The coefficients are from low to high degree, e.g., [1,2,3] represents 1 + 2*x + 3*x².

This specification handles the case where m ≤ n. When m > n, the derivative
would be the zero polynomial.

Specification: polyder computes the m-th derivative of a polynomial with scaling.

Mathematical properties: 
- d/dx(c[i] * x^i) = i * c[i] * x^(i-1)
- With scaling factor scl: d/d(scl*x)(c[i] * x^i) = scl * i * c[i] * x^(i-1)
- Taking m derivatives of x^i gives: i * (i-1) * ... * (i-m+1) * x^(i-m)

Each coefficient is multiplied by scl at each differentiation step,
resulting in multiplication by scl^m overall.

Sanity checks:
- Taking 0 derivatives returns the original polynomial
- The constant term (i=0) disappears after one derivative
- Higher order terms shift down by m positions","use vstd::prelude::*;

verus! {",,"fn polyder(c: Vec<f32>, m: u8, scl: f32) -> (result: Vec<f32>)
    requires 
        m as int <= c.len(),
    ensures
        result.len() == c.len() - m as int,
        /* Special case: m = 0 returns original polynomial */
        (m == 0 ==> forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i] == c[i]),
        /* General case: m > 0 - coefficients come from higher degree terms */
        (m > 0 ==> forall|i: int| 0 <= i < result.len() ==> 
            #[trigger] result[i] == result[i] /* Mathematical relationship preserved through differentiation */)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0514,verus,numpy_triple,polynomial_polynomial_polydiv,,"numpy.polynomial.polynomial.polydiv: Divide one polynomial by another.

Returns the quotient-with-remainder of two polynomials c1 / c2.
The arguments are sequences of coefficients, from lowest order term
to highest, e.g., [1,2,3] represents 1 + 2*x + 3*x**2.

The function performs polynomial long division, returning both
the quotient and remainder such that c1 = c2 * quotient + remainder.

Specification: polydiv performs polynomial division with remainder.

Precondition: The leading coefficient of c2 (highest degree term) is non-zero
Postcondition: 
- The division identity holds: c1 = c2 * quotient + remainder (as polynomials)
- The remainder has degree less than the divisor (leading coefficients are zero)
- When the divisor is a constant polynomial, the quotient is c1 scaled by 1/c2[0]

// leading coefficient non-zero

// Division identity: polynomial relationship holds

// Remainder has lower degree than divisor","use vstd::prelude::*;

verus! {",,"fn polydiv(c1: Vec<f32>, c2: Vec<f32>) -> (result: (Vec<f32>, Vec<f32>))
    requires 
        c1.len() > 0,
        c2.len() > 0,
        c2[(c2.len() - 1) as int] != 0.0f32,
    ensures ({
        let (quo, rem) = result;

        quo.len() == c1.len() &&
        rem.len() == c1.len() &&

        (forall|j: int| j >= (c2.len() as int - 1) && 0 <= j < rem.len() ==> rem[j] == 0.0f32)
    })","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0516,verus,numpy_triple,polynomial_polynomial_polyfromroots,,"Generate a monic polynomial with given roots.

Specification: polyfromroots generates a monic polynomial with given roots.
The resulting polynomial has the form p(x) = (x - r_0)(x - r_1)...(x - r_n),
where the coefficients are returned in ascending order of powers.","use vstd::prelude::*;

verus! {",,"fn polyfromroots(roots: Vec<f64>) -> (result: Vec<f64>)
    ensures
        result@.len() == roots@.len() + 1,
        result@[result@.len() - 1] == 1.0","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0517,verus,numpy_triple,polynomial_polynomial_polygrid2d,,"Evaluate a 2-D polynomial on the Cartesian product of x and y.

This function returns the values:
p(a,b) = sum_{i,j} c_{i,j} * a^i * b^j

where the points (a, b) consist of all pairs formed by taking
a from x and b from y. The resulting points form a grid with
x in the first dimension and y in the second.","use vstd::prelude::*;

verus! {",,"fn polygrid2d(x: Vec<f32>, y: Vec<f32>, c: Vec<Vec<f32>>) -> (result: Vec<Vec<f32>>)
    requires 
        x.len() > 0,
        y.len() > 0,
        c.len() > 0,
        forall|i: int| 0 <= i < c.len() ==> c@[i].len() > 0,
    ensures 
        result.len() == x.len(),
        forall|i: int| 0 <= i < result.len() ==> result@[i].len() == y.len(),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0518,verus,numpy_triple,polynomial_polynomial_polygrid3d,,"{
  ""name"": ""numpy.polynomial.polynomial.polygrid3d"",
  ""category"": ""Standard polynomials"",
  ""description"": ""Evaluate a 3-D polynomial on the Cartesian product of x, y and z."",
  ""url"": ""https://numpy.org/doc/stable/reference/generated/numpy.polynomial.polynomial.polygrid3d.html"",
  ""doc"": ""Evaluate a 3-D polynomial on the Cartesian product of x, y and z.\n\n    This function returns the values:\n\n    .. math:: p(a,b,c) = \\\\sum_{i,j,k} c_{i,j,k} * a^i * b^j * c^k\n\n    where the points ``(a, b, c)`` consist of all triples formed by taking\n    `a` from `x`, `b` from `y`, and `c` from `z`. The resulting points form\n    a grid with `x` in the first dimension, `y` in the second, and `z` in\n    the third.\n\n    The parameters `x`, `y`, and `z` are converted to arrays only if they\n    are tuples or a lists, otherwise they are treated as a scalars. In\n    either case, either `x`, `y`, and `z` or their elements must support\n    multiplication and addition both with themselves and with the elements\n    of `c`.\n\n    If `c` has fewer than three dimensions, ones are implicitly appended to\n    its shape to make it 3-D. The shape of the result will be c.shape[3:] +\n    x.shape + y.shape + z.shape.\n\n    Parameters\n    ----------\n    x, y, z : array_like, compatible objects\n        The three dimensional series is evaluated at the points in the\n        Cartesian product of `x`, `y`, and `z`.  If `x`, `y`, or `z` is a\n        list or tuple, it is first converted to an ndarray, otherwise it is\n        left unchanged and, if it isn't an ndarray, it is treated as a\n        scalar.\n    c : array_like\n        Array of coefficients ordered so that the coefficients for terms of\n        degree i,j are contained in ``c[i,j]``. If `c` has dimension\n        greater than two the remaining indices enumerate multiple sets of\n        coefficients.\n\n    Returns\n    -------\n    values : ndarray, compatible object\n        The values of the two dimensional polynomial at points in the Cartesian\n        product of `x` and `y`.\n\n    See Also\n    --------\n    polyval, polyval2d, polygrid2d, polyval3d\n\n    Examples\n    --------\n    >>> from numpy.polynomial import polynomial as P\n    >>> c = ((1, 2, 3), (4, 5, 6), (7, 8, 9))\n    >>> P.polygrid3d([0, 1], [0, 1], [0, 1], c)\n    array([[ 1., 13.],\n           [ 6., 51.]])""
}

Evaluate a 3-D polynomial on the Cartesian product of x, y and z

Specification: polygrid3d evaluates a 3-D polynomial on the Cartesian product of x, y and z.
The result is a 3D grid where result[i][j][k] = p(x[i], y[j], z[k]) for the polynomial 
defined by coefficients c, where p(a,b,c) = sum_{i,j,k} c[i][j][k] * a^i * b^j * c^k.","use vstd::prelude::*;

verus! {",,"fn polygrid3d(
    x: Vec<i8>, 
    y: Vec<i8>, 
    z: Vec<i8>,
    c: Vec<Vec<Vec<i8>>>
) -> (result: Vec<Vec<Vec<i8>>>)
    requires 
        x@.len() > 0,
        y@.len() > 0, 
        z@.len() > 0,
        c@.len() > 0,
        forall|i: int| 0 <= i < c@.len() ==> c@[i].len() > 0,
        forall|i: int, j: int| 0 <= i < c@.len() && 0 <= j < c@[i].len() ==> c@[i][j].len() > 0,
    ensures
        result@.len() == x@.len(),
        forall|i: int| 0 <= i < result@.len() ==> result@[i].len() == y@.len(),
        forall|i: int, j: int| 0 <= i < result@.len() && 0 <= j < result@[i].len() ==> result@[i][j].len() == z@.len()","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0519,verus,numpy_triple,polynomial_polynomial_polyint,,"Integrate a polynomial.

Returns the polynomial coefficients integrated m times from lbnd.
At each iteration the resulting series is multiplied by scl and 
an integration constant k is added. The scaling factor is for use 
in a linear change of variable.

The input coefficients are ordered from low to high degree.
For example, [1, 2, 3] represents 1 + 2*x + 3*x².

Specification: polyint integrates polynomial coefficients m times.

The integration process:
1. For each integration step i (from 0 to m-1):
   - Multiply all coefficients by scl
   - Integrate: coefficient at degree j becomes coefficient/(j+1) at degree j+1
   - Add integration constant k[i] adjusted for lower bound lbnd
2. Result has m more coefficients than input (degree increases by m)

Properties:
- Integration increases polynomial degree by m
- Each integration step preserves the polynomial structure
- The derivative of the result (m times) gives back the original scaled by scl^m
- Integration constants k determine the value of antiderivatives at lbnd","use vstd::prelude::*;

verus! {",,"fn polyint(c: Vec<i8>, m: usize, k: Vec<i8>, lbnd: i8, scl: i8) -> (result: Vec<i8>)
    requires 
        m > 0 ==> scl as int != 0,
        k.len() == m,
    ensures
        /* Size constraint: output has m more coefficients than input */
        result.len() == c.len() + m,
        
        /* For single integration (m = 1), verify the integration formula */
        m == 1 ==> {
            /* When input is empty polynomial (zero), result is just the constant */
            (c.len() == 0 ==> result@[0] as int == k@[0] as int) &&
            /* For non-empty input, apply integration rules */
            (c.len() > 0 ==> {
                /* Each coefficient c[i] at degree i becomes scl*c[i]/(i+1) at degree i+1 */
                forall|i: int| 0 <= i < c.len() ==> 
                    (i + 1) * (result@[i + 1] as int) == (scl as int) * (c@[i] as int)
            })
        },
        
        /* Property about integration constants and lower bound */
        /* The integration constant is adjusted so that the integral evaluated at lbnd equals k */
        m == 1 && c.len() > 0 ==> {
            /* If we had k = [0] and lbnd = 0, then result[0] = 0 */
            (k@[0] as int == 0 && lbnd as int == 0 ==> result@[0] as int == 0) &&
            /* Example: integrating [1,2,3] with k=3 gives result[0] = 3 when lbnd = 0 */
            (k@[0] as int == 3 && lbnd as int == 0 ==> result@[0] as int == 3)
        },
        
        /* Mathematical property: The integration operation is the inverse of differentiation */
        /* If we integrate m times then differentiate m times, we get back c scaled by scl^m */
        m > 0 && scl as int != 0 ==> true,
        
        /* Sanity check: When scl = 0, all non-constant coefficients become 0 */
        scl as int == 0 ==> forall|i: int| (m as int) <= i < result.len() ==> result@[i] as int == 0,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0520,verus,numpy_triple,polynomial_polynomial_polyline,,"Returns a vector representing a linear polynomial off + scl*x.

For the linear polynomial off + scl*x, this returns:
- [off, scl] when scl ≠ 0 (degree 1 polynomial)
- [off] when scl = 0 (degree 0 polynomial, constant)

This follows NumPy's convention where coefficients are ordered from
lowest to highest degree, so [off, scl] represents off + scl*x.

We use Vector Float 2 to represent the general case, with the understanding
that when scl = 0, the second coefficient is meaningless.

Specification: polyline creates correct linear polynomial representation.

The function returns coefficients for the linear polynomial off + scl*x:
- Always returns [off, scl] as a 2-element vector
- When scl = 0, this represents the constant polynomial off
- When scl ≠ 0, this represents the linear polynomial off + scl*x

Key properties:
1. Coefficient structure: coefficients are ordered from lowest to highest degree
2. Constant term is always off (at index 0)
3. Linear term coefficient is scl (at index 1)
4. Evaluation property: at x=0, polynomial evaluates to off
5. Slope property: derivative of polynomial is scl
6. Mathematical correctness: represents polynomial off + scl*x","use vstd::prelude::*;

verus! {",,"fn polyline(off: i8, scl: i8) -> (result: [i8; 2])
    ensures
        /* Constant term is always off */
        result[0] == off,
        /* Linear coefficient is always scl */
        result[1] == scl,
        /* Size is always 2 (representing up to degree 1 polynomial) */
        result@.len() == 2,
        /* Example evaluation: if we evaluate at x=1, we get off + scl */
        result[0] as int + result[1] as int == off as int + scl as int","{
    // impl-start
    assume(false);
    [0; 2]
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0522,verus,numpy_triple,polynomial_polynomial_polymulx,,"Multiply a polynomial by x.
Multiplies polynomial c by x, where x is the independent variable.
For polynomial p(x) = c[0] + c[1]*x + ... + c[n-1]*x^(n-1),
returns x*p(x) = 0 + c[0]*x + c[1]*x^2 + ... + c[n-1]*x^n

Specification: polymulx multiplies a polynomial by x.
The result has one more coefficient than the input.
The first coefficient is always 0, and subsequent coefficients
are the original coefficients shifted by one position.
This represents multiplying p(x) by x to get x*p(x).","use vstd::prelude::*;

verus! {",,"fn polymulx(c: Vec<f32>) -> (result: Vec<f32>)
    ensures
        result.len() == c.len() + 1,
        result[0] == 0.0f32,
        forall|i: int| 0 <= i < c@.len() ==> result[i + 1] == c[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0523,verus,numpy_triple,polynomial_polynomial_polypow,,"Raise a polynomial to a power.
Returns the polynomial c raised to the power pow.
For polynomial p(x) = c[0] + c[1]*x + ... + c[n-1]*x^(n-1),
returns p(x)^pow with appropriate coefficient expansion.

Specification: polypow raises a polynomial to a non-negative integer power.
The result represents the polynomial p(x)^pow where p(x) is defined by coefficients c.
For power 0, returns [1] (the constant polynomial 1).
For power 1, returns the original polynomial.
The degree grows as expected for polynomial multiplication.","use vstd::prelude::*;

verus! {",,"fn polypow(c: Vec<f32>, pow: u8) -> (result: Vec<f32>)
    ensures
        pow == 0 ==> (result.len() == 1 && result[0] == 1.0f32),
        pow == 1 ==> result.len() == c.len() && (forall|i: int| 0 <= i < c.len() ==> result[i] == c[i]),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0524,verus,numpy_triple,polynomial_polynomial_polyroots,,"Compute the roots of a polynomial.
Given polynomial coefficients c[0], c[1], ..., c[n-1], returns the roots of
p(x) = c[0] + c[1]*x + c[2]*x^2 + ... + c[n-1]*x^(n-1).
For a polynomial of degree n, there are exactly n roots (counting multiplicity).","use vstd::prelude::*;

verus! {",,"fn polyroots(c: Vec<f64>) -> (result: Vec<f64>)
    requires 
        c.len() > 1,
        c[c.len() - 1] != 0.0,
    ensures
        result.len() == c.len() - 1,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0525,verus,numpy_triple,polynomial_polynomial_polysub,,"Subtract one polynomial from another.
Returns the difference of two polynomials c1 - c2, where polynomials are
represented as coefficient vectors from lowest order term to highest.

Specification: polysub computes c1 - c2 element-wise, padding with zeros.
The result has length max(n, m), and for each coefficient position i:
- If i < min(n, m): result[i] = c1[i] - c2[i]
- If min(n, m) ≤ i < n: result[i] = c1[i]
- If min(n, m) ≤ i < m: result[i] = -c2[i]

Additionally, polysub satisfies mathematical properties:
- Anti-commutativity: polysub c1 c2 = -(polysub c2 c1)
- Zero identity: polysub c 0 = c and polysub 0 c = -c","use vstd::prelude::*;

verus! {",,"fn polysub(c1: Vec<i8>, c2: Vec<i8>) -> (result: Vec<i8>)
    ensures
        result.len() == if c1.len() >= c2.len() { c1.len() } else { c2.len() },
        forall|i: int| 0 <= i < result.len() ==> {
            if i < c1.len() && i < c2.len() {
                result[i] as int == c1[i] as int - c2[i] as int
            } else if i < c1.len() && i >= c2.len() {
                result[i] == c1[i]
            } else if i >= c1.len() && i < c2.len() {
                result[i] as int == 0 - c2[i] as int
            } else {
                result[i] == 0
            }
        }","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0526,verus,numpy_triple,polynomial_polynomial_polyval,,"Evaluate a polynomial at points x using Horner's method.
Given coefficients c = [c₀, c₁, ..., cₙ] and evaluation points x,
computes p(x) = c₀ + c₁·x + c₂·x² + ... + cₙ·xⁿ for each x

Specification: polyval evaluates a polynomial with coefficients c at points x.
The result at each point xᵢ is the polynomial value p(xᵢ) = c₀ + c₁·xᵢ + c₂·xᵢ² + ... + cₙ·xᵢⁿ

Mathematical properties:
- For coefficient vector c = [c₀, c₁, ..., cₙ], evaluates polynomial p(x) = Σⱼ cⱼ·xʲ
- Uses Horner's method for numerical stability: p(x) = c₀ + x·(c₁ + x·(c₂ + x·(...)))
- Linear in coefficients: p(x, αc₁ + βc₂) = α·p(x, c₁) + β·p(x, c₂)
- Polynomial evaluation at zero gives constant term: p(0) = c₀
- For degree-0 polynomial [c₀], result is constant c₀ for all x","use vstd::prelude::*;

verus! {",,"fn polyval(x: Vec<f64>, c: Vec<f64>) -> (result: Vec<f64>)
    requires 
        x@.len() > 0,
        c@.len() > 0,
    ensures
        result@.len() == x@.len(),
        forall|i: int| 0 <= i < result@.len() ==> 
            #[trigger] result@[i] == result@[i] &&
            (c@.len() == 1 ==> result@[i] == c@[0]) &&
            (forall|j: int| 0 <= j < c@.len() && c@[j] == 0.0 ==> #[trigger] result@[i] == 0.0)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0527,verus,numpy_triple,polynomial_polynomial_polyval2d,,"Evaluate a 2D polynomial at points (x, y).
Given a coefficient matrix c and evaluation points (x, y),
computes p(x,y) = Σᵢⱼ cᵢⱼ·xⁱ·yʲ for each point pair

Specification: polyval2d evaluates a 2D polynomial with coefficient matrix c at point pairs (x, y).
The result at each point (xᵢ, yᵢ) is the polynomial value p(xᵢ, yᵢ) = Σᵢⱼ cᵢⱼ·xᵢⁱ·yᵢʲ

Mathematical properties:
- For coefficient matrix c[i][j], evaluates p(x,y) = Σᵢⱼ c[i][j]·xⁱ·yʲ
- Reduces to 1D polyval when one variable is zero: p(x,0) uses first column c[*][0]
- Bilinear in coefficients: p(x,y, αc₁ + βc₂) = α·p(x,y,c₁) + β·p(x,y,c₂)  
- Constant term: p(0,0) = c[0][0]
- Degree-0 in both variables gives constant: c = [[c₀₀]] → p(x,y) = c₀₀ for all (x,y)

/* Constant term property: when both degrees are 0 */

/* Zero coefficient property: if all coefficients are zero, result is zero */

/* Evaluation at origin gives constant term */","use vstd::prelude::*;

verus! {",,"fn polyval2d(x: Vec<f32>, y: Vec<f32>, c: Vec<Vec<f32>>) -> (result: Vec<f32>)
    requires 
        x@.len() == y@.len(),
        x@.len() > 0,
        c@.len() > 0,
        forall|i: int| 0 <= i < c@.len() ==> #[trigger] c@[i].len() > 0,
        forall|i: int| 0 <= i < c@.len() ==> #[trigger] c@[i].len() == c@[0].len(),
    ensures
        result@.len() == x@.len(),

        (c@.len() == 1 && c@[0].len() == 1) ==> 
            (forall|k: int| 0 <= k < result@.len() ==> #[trigger] result@[k] == c@[0][0]),

        (forall|i: int, j: int| 0 <= i < c@.len() && 0 <= j < c@[i].len() ==> #[trigger] c@[i][j] == 0.0f32) ==> 
            (forall|k: int| 0 <= k < result@.len() ==> #[trigger] result@[k] == 0.0f32),

        forall|k: int| 0 <= k < result@.len() && x@[k] == 0.0f32 && y@[k] == 0.0f32 ==> 
            #[trigger] result@[k] == c@[0][0],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0528,verus,numpy_triple,polynomial_polynomial_polyval3d,,"Evaluate a 3-D polynomial at points (x, y, z).
This function evaluates the polynomial p(x,y,z) = Σ_{i,j,k} c[i,j,k] * x^i * y^j * z^k
where the sum is over all valid indices of the coefficient tensor c.

Specification: polyval3d evaluates a 3-dimensional polynomial at each point (x[i], y[i], z[i]).
The polynomial is defined as the sum of c[i,j,k] * x^i * y^j * z^k over all coefficient indices.","use vstd::prelude::*;

verus! {",,"fn polyval3d(
    x: Vec<f32>, 
    y: Vec<f32>, 
    z: Vec<f32>, 
    c: Vec<Vec<Vec<f32>>>
) -> (result: Vec<f32>)
    requires 
        x@.len() == y@.len(),
        y@.len() == z@.len(),
        c@.len() > 0,
        forall|i: int| 0 <= i < c@.len() ==> c@[i].len() > 0,
        forall|i: int, j: int| 0 <= i < c@.len() && 0 <= j < c@[i].len() ==> c@[i][j].len() > 0,
    ensures 
        result@.len() == x@.len(),
        forall|p: int| 0 <= p < result@.len() ==> 
            #[trigger] result@[p] == result@[p] &&
            (c@.len() == 1 && c@[0].len() == 1 && c@[0][0].len() == 1 ==> 
             result@[p] == c@[0][0][0])","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0529,verus,numpy_triple,polynomial_polynomial_polyvalfromroots,,"Evaluate a polynomial specified by its roots at points x.
If `r` is of length `N`, this function returns the value p(x) = ∏(x - r_i)
where the product is over all roots r_i in the roots vector.

Specification: polyvalfromroots evaluates the polynomial with the given roots
at each point in x. The polynomial is defined as the product of (x - r_i) for all roots r_i.","use vstd::prelude::*;

verus! {",,"spec fn poly_eval_at_point(x_val: int, roots: Seq<int>) -> int
    decreases roots.len()
{
    if roots.len() == 0 {
        1
    } else {
        (x_val - roots[0]) * poly_eval_at_point(x_val, roots.subrange(1, roots.len() as int))
    }
}

fn polyvalfromroots(x: Vec<i8>, r: Vec<i8>) -> (result: Vec<i8>)
    ensures 
        result.len() == x.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] as int == poly_eval_at_point(x[i] as int, r@.map_values(|v: i8| v as int)),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0530,verus,numpy_triple,polynomial_polynomial_polyvander,,"Vandermonde matrix of given degree.
Returns the Vandermonde matrix of degree `deg` and sample points `x`.
The Vandermonde matrix is defined by V[i,j] = x[i]^j for 0 <= j <= deg.

Specification: polyvander generates a Vandermonde matrix where each row corresponds to
powers of the corresponding element in x, from degree 0 to deg.","use vstd::prelude::*;

verus! {",,"fn polyvander(x: Vec<f32>, deg: usize) -> (result: Vec<Vec<f32>>)
    requires x.len() > 0,
    ensures
        result.len() == x.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i].len() == deg + 1,
        forall|i: int| 0 <= i < result.len() ==> result[i][0] == 1.0f32,
        deg > 0 ==> forall|i: int| 0 <= i < result.len() ==> result[i][1] == x[i]","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0531,verus,numpy_triple,polynomial_polynomial_polyvander2d,,"Pseudo-Vandermonde matrix of given degrees for 2D polynomials.
Returns a matrix where V[k, (yDeg + 1)*i + j] = x[k]^i * y[k]^j
for 0 <= i <= xDeg and 0 <= j <= yDeg.

Specification: polyvander2d creates a pseudo-Vandermonde matrix where each entry
satisfies the polynomial power relationship V[k, (yDeg + 1)*i + j] = x[k]^i * y[k]^j.
The matrix has dimensions n × ((xDeg + 1) * (yDeg + 1)) and represents all polynomial
terms x^i * y^j for 0 ≤ i ≤ xDeg and 0 ≤ j ≤ yDeg.","use vstd::prelude::*;

verus! {

spec fn pow_spec(base: int, exp: nat) -> int
    decreases exp
{
    if exp == 0 {
        1
    } else {
        base * pow_spec(base, (exp - 1) as nat)
    }
}",,"fn polyvander2d(x: Vec<f64>, y: Vec<f64>, x_deg: u8, y_deg: u8) -> (result: Vec<Vec<f64>>)
    requires 
        x.len() == y.len(),
        x.len() > 0,
    ensures
        result.len() == x.len(),
        forall|k: int| 0 <= k < result.len() ==> #[trigger] result[k].len() == (x_deg as int + 1) * (y_deg as int + 1),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0532,verus,numpy_triple,polynomial_polynomial_polyvander3d,,"Pseudo-Vandermonde matrix of given degrees for 3D polynomials.
Returns a matrix where V[p, (yDeg + 1)*(zDeg + 1)*i + (zDeg + 1)*j + k] = x[p]^i * y[p]^j * z[p]^k
for 0 <= i <= xDeg, 0 <= j <= yDeg and 0 <= k <= zDeg.

Specification: polyvander3d creates a pseudo-Vandermonde matrix where each entry
satisfies the polynomial power relationship V[p, (yDeg + 1)*(zDeg + 1)*i + (zDeg + 1)*j + k] = x[p]^i * y[p]^j * z[p]^k.
The matrix has dimensions n × ((xDeg + 1) * (yDeg + 1) * (zDeg + 1)) and represents all polynomial
terms x^i * y^j * z^k for 0 ≤ i ≤ xDeg, 0 ≤ j ≤ yDeg, and 0 ≤ k ≤ zDeg.","use vstd::prelude::*;

verus! {",,"fn polyvander3d(x: Vec<f64>, y: Vec<f64>, z: Vec<f64>, x_deg: usize, y_deg: usize, z_deg: usize) -> (result: Vec<Vec<f64>>)
    requires 
        x@.len() == y@.len(),
        y@.len() == z@.len(),
        x@.len() > 0,
    ensures
        result@.len() == x@.len(),
        forall|p: int| 0 <= p < result@.len() ==> result@[p].len() == (x_deg + 1) * (y_deg + 1) * (z_deg + 1)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0533,verus,numpy_triple,polynomial_polyutils_as_series,,"Return argument as a list of 1-d arrays. Takes a 2-d array of shape (M,N)
and returns M arrays of size N (parsed by row). Optionally trims trailing 
zeros from each array.

Specification: as_series returns a list of 1-d arrays where each row of the
input becomes a separate 1-d array. When trim is false, arrays are unchanged.
When trim is true, trailing zeros are removed from each array.","use vstd::prelude::*;

verus! {",,"fn as_series(arr: Vec<Vec<f64>>, trim: bool) -> (result: Vec<Vec<f64>>)
    requires 
        arr@.len() > 0,
        forall|i: int| 0 <= i < arr@.len() ==> arr@[i].len() > 0,
    ensures 
        result@.len() == arr@.len(),
        forall|i: int| 0 <= i < result@.len() ==> {
            if !trim {
                result@[i].len() == arr@[i].len() &&
                forall|j: int| 0 <= j < arr@[i].len() ==> result@[i][j] == arr@[i][j]
            } else {
                forall|j: int| 0 <= j < result@[i].len() ==> {
                    result@[i][j] == arr@[i][j] || result@[i][j] == 0.0
                }
            }
        }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0534,verus,numpy_triple,polynomial_polyutils_format_float,,"Format a floating-point number into a string representation.
This function takes a floating-point value and converts it to a human-readable 
string format, handling special cases like NaN and infinity, and choosing 
between scientific and positional notation based on the magnitude of the number.

Specification: format_float produces a valid string representation of a float.
The function handles special cases (NaN, infinity) and chooses appropriate 
notation based on the magnitude of the input. The output string should be 
parseable back to a float representation and preserve the essential value 
characteristics.","use vstd::prelude::*;

verus! {",,"fn format_float(x: f64, parens: bool) -> (result: String)
    ensures
        result@.len() > 0","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0535,verus,numpy_triple,polynomial_polyutils_getdomain,,"Return a domain suitable for given abscissae (real numbers).
For real inputs, returns the minimum and maximum values as a 2-element vector.
This represents the smallest interval containing all points in the input vector.","use vstd::prelude::*;

verus! {",,"fn getdomain(x: Vec<i8>) -> (result: Vec<i8>)
    requires x@.len() > 0,
    ensures
        result@.len() == 2,
        result@[0] as int <= result@[1] as int,
        forall|i: int| 0 <= i < x@.len() ==> result@[0] as int <= x@[i] as int && x@[i] as int <= result@[1] as int,
        exists|i: int| 0 <= i < x@.len() && x@[i] as int == result@[0] as int,
        exists|j: int| 0 <= j < x@.len() && x@[j] as int == result@[1] as int,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0536,verus,numpy_triple,polynomial_polyutils_mapdomain,,"numpy.polynomial.polyutils.mapdomain: Apply linear map to input points.

The linear map `offset + scale*x` that maps the domain `old` to
the domain `new` is applied to the points `x`.

This function implements the mathematical transformation:
x_out = new[0] + m(x - old[0])
where m = (new[1] - new[0]) / (old[1] - old[0])

Parameters:
- x: Points to be mapped (Vector of Float values)
- old: Two-element vector defining the old domain [old[0], old[1]]
- new: Two-element vector defining the new domain [new[0], new[1]]

Returns:
- x_out: Array of points of the same shape as x, after linear transformation

Specification: mapdomain applies linear transformation to map points from old domain to new domain.

The function computes a linear transformation that maps the interval [old[0], old[1]] 
to the interval [new[0], new[1]], then applies this transformation to each point in x.

Mathematical properties:
1. The transformation is linear: f(x) = offset + scale * x
2. The scale factor is: (new[1] - new[0]) / (old[1] - old[0])
3. The offset is: new[0] - scale * old[0]
4. Points at old[0] map to new[0], points at old[1] map to new[1]

Precondition: The old domain must be non-degenerate (old[1] ≠ old[0])
Postcondition: Each result point follows the linear transformation formula","use vstd::prelude::*;

verus! {",,"fn mapdomain(x: Vec<f32>, old: Vec<f32>, new: Vec<f32>) -> (result: Vec<f32>)
    requires 
        old.len() == 2,
        new.len() == 2,
        old[1] != old[0],
    ensures
        result.len() == x.len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0537,verus,numpy_triple,polynomial_polyutils_mapparms,,"Linear map parameters between domains. 
Returns the parameters of the linear map `offset + scale*x` that maps
`old` to `new` such that `old[i] -> new[i]`, `i = 0, 1`.

Specification: mapparms computes linear mapping parameters between domains.
The returned offset and scale define a linear map L(x) = offset + scale*x
that maps the old domain to the new domain.","use vstd::prelude::*;

verus! {",,"fn mapparms(old: [i8; 2], new: [i8; 2]) -> (result: (i8, i8))
    requires old[0] != old[1],
    ensures ({
        let (offset, scale) = result;
        let oldlen = old[1] as int - old[0] as int;
        let newlen = new[1] as int - new[0] as int;
        offset as int + scale as int * old[0] as int == new[0] as int &&
        offset as int + scale as int * old[1] as int == new[1] as int &&
        scale as int == newlen / oldlen &&
        offset as int == (old[1] as int * new[0] as int - old[0] as int * new[1] as int) / oldlen
    })","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0538,verus,numpy_triple,polynomial_polyutils_trimcoef,,"Remove ""small"" ""trailing"" coefficients from a polynomial.
Small means small in absolute value controlled by tolerance parameter.
Trailing means highest order coefficients.

Specification: trimcoef removes trailing coefficients with absolute value ≤ tol.
If all coefficients are small, returns a single zero.
The tolerance must be non-negative.","use vstd::prelude::*;

verus! {",,"fn trimcoef(c: Vec<f32>, tol: f32) -> (result: Vec<f32>)
    ensures
        result.len() >= 1,
        result.len() <= c.len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0539,verus,numpy_triple,polynomial_polyutils_trimseq,,"Remove small Poly series coefficients.

Remove trailing zeros from a sequence of polynomial coefficients.
Returns the sequence with trailing zeros removed. If the sequence would be empty 
after trimming, returns the first element. Empty sequences are handled.

Specification: trimseq removes trailing zeros while preserving at least one element.
For non-empty sequences, if the last element is non-zero, return the sequence unchanged.
If the last element is zero, trim trailing zeros but always keep at least one element.

/* If empty or last element is non-zero, return unchanged */

/* If last element is zero, trim properly */

/* There exists a position k where trimming occurs */

/* All elements after k in original sequence are zero */

/* Result preserves elements up to k, zeros after */

/* Element at k is non-zero unless k = 0 (all zeros case) */","use vstd::prelude::*;

verus! {",,"fn trimseq(seq: Vec<f32>) -> (result: Vec<f32>)
    ensures
        result.len() == seq.len(),

        (seq.len() == 0 || (seq.len() > 0 && seq[seq.len() - 1] != 0.0f32)) ==> result@ == seq@,

        (seq.len() > 0 && seq[seq.len() - 1] == 0.0f32) ==>

            exists|k: int| 
                0 <= k < seq.len() as int &&

                (forall|j: int| k < j < seq.len() as int ==> seq[j] == 0.0f32) &&

                (forall|i: int| 0 <= i <= k ==> result[i] == seq[i]) &&
                (forall|i: int| k < i < result.len() as int ==> result[i] == 0.0f32) &&

                (k > 0 ==> seq[k] != 0.0f32)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0540,verus,numpy_triple,random_BitGenerator,,"numpy.random.BitGenerator: Base class for bit generators.

The BitGenerator manages state and provides functions to produce random doubles 
and random unsigned 32- and 64-bit values. This function initializes a BitGenerator
with an optional seed value.

Parameters:
- seed: Optional seed value to initialize the generator (None uses system entropy)

Returns:
- A BitGeneratorState that can be used to generate random values

Specification: numpy.random.BitGenerator creates a properly initialized BitGenerator state.

Precondition: True (any seed value is valid, including None)
Postcondition: The returned state has the provided seed (or maintains None if no seed given)
            and has a valid internal state representation.

/* BitGenerator state representing the internal state of a pseudo-random number generator.
   This is an abstract representation that can be seeded and used to generate random values. */

/* The seed value used to initialize the generator, or None if no seed was provided */

/* The internal state of the generator used for random number generation */","use vstd::prelude::*;

verus! {

pub struct BitGeneratorState {

    pub seed: Option<u64>,

    pub internal_state: u64,
}",,"fn numpy_random_bit_generator(seed: Option<u64>) -> (result: BitGeneratorState)
    ensures 
        result.seed == seed,
        seed.is_Some() ==> result.internal_state != 0,
        seed.is_None() ==> result.internal_state == 0,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0541,verus,numpy_triple,random_MT19937,,"MT19937 BitGenerator for the Mersenne Twister pseudo-random number generator

MT19937 provides a capsule containing function pointers that produce doubles, 
and unsigned 32 and 64-bit integers. This implementation focuses on the core
state initialization and next value generation.

The Mersenne Twister is a pseudorandom number generator that maintains an
internal state and produces a sequence of 32-bit integers with a period of 2^19937 - 1.

Parameters:
- seed : u32 optional seed value to initialize the generator

The generator produces uniformly distributed values in [0, 2^32 - 1]

Specification: MT19937 initializes the generator state with proper seeding

The MT19937 generator maintains a state vector of 624 32-bit integers.
When initialized with a seed, it produces a deterministic sequence.

Precondition: None (any seed value is valid)
Postcondition: 
1. The state vector has exactly 624 elements
2. The state is deterministically initialized based on the seed
3. The first element of the state equals the seed
4. The generator produces deterministic values based on the seed
5. All state values are 32-bit unsigned integers","use vstd::prelude::*;

verus! {",,"fn mt19937(seed: u32) -> (state: Vec<u32>)
    ensures
        /* The state vector has the correct size (624 elements) */
        state@.len() == 624,
        /* The first element equals the seed */
        state@[0] == seed,
        /* State initialization follows MT19937 recurrence relation */
        forall|i: int| 0 <= i < 623 ==> #[trigger] state@[i] == state@[i] && {
            let k = i + 1;
            let prev_state = state@[i];
            let shifted = prev_state >> 30;
            let xor_result = prev_state ^ shifted;
            let mult_result = 1812433253u32.wrapping_mul(xor_result);
            let next_val = mult_result.wrapping_add(k as u32);
            state@[k] == next_val
        },","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0543,verus,numpy_triple,random_PCG64DXSM,,"BitGenerator for the PCG-64 DXSM pseudo-random number generator

PCG-64 DXSM is a 128-bit implementation of O'Neill's permutation congruential generator
with the DXSM output mixer. It has better statistical properties in parallel contexts
than the standard PCG-64.

The generator uses a linear congruential generator (LCG) to advance the state,
with a fixed odd increment. It uses a 64-bit ""cheap multiplier"" in the LCG.
The generator has a period of 2^128 and supports advancing an arbitrary number
of steps as well as 2^127 streams.

This function generates a sequence of random 64-bit unsigned integers given
a seed value.

Specification: PCG64DXSM generates a sequence of pseudo-random numbers with specific mathematical properties.

The PCG64DXSM generator satisfies the following properties:
1. Deterministic: Same seed produces same sequence
2. Uniform distribution: All 64-bit values are equally likely over the full period
3. Full period: The generator has period 2^128
4. Statistical independence: Generated values appear statistically independent
5. Non-predictability: Knowledge of some outputs doesn't easily predict others","use vstd::prelude::*;

verus! {",,"spec fn pcg64_dxsm_spec(seed: u64, n: nat) -> Seq<u64>
{
    arbitrary()
}

fn pcg64_dxsm(seed: u64, n: usize) -> (result: Vec<u64>)
    ensures
        result.len() == n,
        seed == seed ==> result@ == pcg64_dxsm_spec(seed, n as nat),
        n > 0 ==> (exists|i: int| 0 <= i < n && #[trigger] result[i] >= 0),
        n > 1 ==> true,
        forall|seed_prime: u64| seed != seed_prime ==> 
            pcg64_dxsm_spec(seed, n as nat) != pcg64_dxsm_spec(seed_prime, n as nat)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0544,verus,numpy_triple,random_Philox,,"Philox (4x64) pseudo-random number generator.

Philox is a counter-based RNG that generates pseudo-random numbers
using a counter and key. It provides high-quality random numbers
with a large period (2^256 - 1) and supports parallel generation.

The core operation takes a seed and generates a vector of random
numbers in the range [0, 1).

Specification: Philox generates pseudo-random numbers with deterministic behavior.

The Philox algorithm has several key mathematical properties:
1. Deterministic: same seed produces same sequence
2. Uniform distribution: values are uniformly distributed in [0, 1)
3. Range constraint: all values are in the half-open interval [0, 1)
4. Reproducibility: identical seeds produce identical sequences

Precondition: True (no special preconditions)
Postcondition: All values are in [0, 1) and sequence is deterministic based on seed","use vstd::prelude::*;

verus! {
spec fn philox_spec_fn(n: nat, seed: nat) -> Seq<int>;",,"fn philox(n: usize, seed: u64) -> (result: Vec<i32>)
    ensures
        result.len() == n,
        forall|i: int| 0 <= i < result.len() ==> 0 <= result[i] && result[i] < 1000000,
        forall|seed1: u64, seed2: u64| seed1 == seed2 ==> 
            philox_spec_fn(n as nat, seed1 as nat) == philox_spec_fn(n as nat, seed2 as nat)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0545,verus,numpy_triple,random_RandomState,,"Container for the slow Mersenne Twister pseudo-random number generator

Generate a random float in the range [0, 1) using the RandomState
This models the RandomState.random() method which is the most fundamental
operation for generating uniformly distributed random numbers.

Specification: random generates a float in the range [0, 1)

The random function should satisfy:
1. The result is always in the range [0, 1)
2. The result is deterministic given the same seed
3. The result follows uniform distribution properties","use vstd::prelude::*;

verus! {

/* A simple random state container that can generate random numbers
   This models the core functionality of numpy.random.RandomState.
   We focus on the random() method which generates random floats in [0, 1). */
struct RandomState {
    /* The seed value used to initialize the random number generator */
    seed: u8,
}",,fn random(state: RandomState) -> (result: f32),"{
    // impl-start
    assume(false);
    0.0
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0546,verus,numpy_triple,random_SFC64,,"SFC64 pseudo-random number generator with 256-bit state.

BitGenerator for the SFC64 pseudo-random number generator.

SFC64 is a chaotic RNG that uses a 256-bit state. It is very fast and appears to be very robust to statistical tests.

Parameters:
- seed : None, int, array_like[ints], SeedSequence, BitGenerator, Generator
    A seed to initialize the BitGenerator

Specification: SFC64 initializes a 256-bit state from seed","use vstd::prelude::*;

verus! {

/* SFC64 state containing 256 bits split into four 64-bit words */
struct SFC64State {
    a: u64,
    b: u64,
    c: u64,
    counter: u64,
}",,"fn sfc64(seed: Option<u64>) -> (state: SFC64State)
    ensures
        seed.is_none() ==> (state.a == 0 && state.b == 0 && state.c == 0 && state.counter == 0),
        seed.is_some() ==> (state.a != 0 || state.b != 0 || state.c != 0 || state.counter != 0),","{
    // impl-start
    assume(false);
    SFC64State { a: 0, b: 0, c: 0, counter: 0 }
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0547,verus,numpy_triple,random_SeedSequence,,"numpy.random.SeedSequence: Mixes sources of entropy in a reproducible way
to set the initial state for independent and very probably non-overlapping
BitGenerators.

SeedSequence takes entropy sources (integers) and mixes them using
cryptographic hash functions to produce high-quality seed states.
The mixing algorithm ensures that even low-quality entropy sources
produce high-quality, uniformly distributed output.

Key properties:
- Reproducible: Same entropy input always produces same output
- Avalanche effect: Single bit changes affect all output bits
- Independence: Spawned sequences are non-overlapping
- Uniform distribution: Output is uniformly distributed over the state space

Specification: SeedSequence produces a seed state from entropy sources
with reproducibility and non-degeneracy properties.

Precondition: True (accepts any entropy input, including empty)
Postcondition: 
1. Reproducibility: Same entropy always produces same output
2. Non-degeneracy: Output depends on input entropy
3. Deterministic: Function is deterministic for fixed inputs
4. Well-defined: Always produces valid output within expected bounds","use vstd::prelude::*;

verus! {",,"spec fn seed_sequence_spec(entropy: Seq<u32>, spawn_key: Seq<u32>, pool_size: usize) -> Seq<u32>;

fn seed_sequence(entropy: Vec<u32>, spawn_key: Vec<u32>, pool_size: usize) -> (result: Vec<u32>)
    requires spawn_key.len() == 0,
    ensures 
        /* Reproducibility property: same inputs produce same outputs */
        forall|entropy2: Seq<u32>, spawn_key2: Seq<u32>| 
            entropy@ == entropy2 && spawn_key@ == spawn_key2 ==> 
            seed_sequence_spec(entropy2, spawn_key2, pool_size) == result@,
        /* Non-degeneracy: output depends on input when entropy is present */
        entropy.len() > 0 ==> 
            exists|modified_entropy: Seq<u32>| 
                modified_entropy != entropy@ &&
                seed_sequence_spec(modified_entropy, spawn_key@, pool_size) != result@,
        /* Well-defined output: result has the correct size */
        result.len() == pool_size,
        /* Result specification matches */
        result@ == seed_sequence_spec(entropy@, spawn_key@, pool_size)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0548,verus,numpy_triple,random_default_rng,,"numpy.random.default_rng: Construct a new Generator with the default BitGenerator (PCG64).

Creates a new Generator instance using PCG64 as the underlying BitGenerator.
This is the recommended way to create random number generators in NumPy.

If seed is None, the generator will be initialized with fresh entropy from the OS.
If seed is provided, the generator will be deterministically initialized with that seed.

Specification: default_rng returns a properly initialized Generator object.

Precondition: True (no restrictions on the seed parameter)
Postcondition: The returned Generator is properly initialized with the given seed
and uses PCG64 as the underlying BitGenerator.

/* BitGenerator represents the underlying random number generator engine */

/* Internal state of the generator */

/* Seed used to initialize the generator */

/* Generator provides high-level random number generation methods */

/* The underlying BitGenerator (PCG64 by default) */

/* Whether the generator has been properly initialized */","use vstd::prelude::*;

verus! {

struct BitGenerator {

    state: u64,

    seed: Option<u64>,
}

struct Generator {

    bit_generator: BitGenerator,

    initialized: bool,
}",,"fn default_rng(seed: Option<u64>) -> (result: Generator)
    ensures
        result.initialized == true,
        result.bit_generator.seed == seed,
        seed.is_some() ==> result.bit_generator.state != 0,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0549,verus,numpy_triple,set_operations_in1d,,"Test whether each element of a 1-D array is also present in a second array.
Returns a boolean array the same length as ar1 that is True where an element 
of ar1 is in ar2 and False otherwise.

Specification: in1d tests membership of each element of ar1 in ar2.
The result is a boolean vector of the same length as ar1, where each element
indicates whether the corresponding element of ar1 is present in ar2.","use vstd::prelude::*;

verus! {",,"fn in1d<T: PartialEq>(ar1: Vec<T>, ar2: Vec<T>) -> (result: Vec<bool>)
    ensures 
        result.len() == ar1.len(),
        forall|i: int| 0 <= i < ar1@.len() ==> 
            result@[i] == exists|j: int| 0 <= j < ar2@.len() && ar1@[i] == ar2@[j]","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0550,verus,numpy_triple,set_operations_intersect1d,,"Find the intersection of two arrays.
Returns the sorted, unique values that are in both input arrays.

Specification: intersect1d returns a sorted array of unique values 
that exist in both input arrays","use vstd::prelude::*;

verus! {",,"fn intersect1d(ar1: &Vec<i8>, ar2: &Vec<i8>) -> (result: Vec<i8>)
    ensures
        /* Result contains only values that exist in both arrays */
        forall|i: int| 0 <= i < result@.len() ==> 
            (exists|j: int| 0 <= j < ar1@.len() && #[trigger] result@[i] == ar1@[j]) &&
            (exists|l: int| 0 <= l < ar2@.len() && result@[i] == ar2@[l]),
        /* Result is sorted in ascending order */
        forall|i: int, j: int| 0 <= i < j < result@.len() ==> 
            #[trigger] result@[i] <= #[trigger] result@[j],
        /* Result contains unique values (no duplicates) */
        forall|i: int, j: int| 0 <= i < j < result@.len() ==> 
            #[trigger] result@[i] != #[trigger] result@[j]","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0551,verus,numpy_triple,set_operations_isin,,"numpy.isin: Element-wise test for membership in another array.

Calculates `element in test_elements`, broadcasting over `element` only.
Returns a boolean array of the same shape as `element` that is True
where an element of `element` is in `test_elements` and False otherwise.

This is an element-wise function version of the python keyword `in`.
For 1-D arrays, this is roughly equivalent to:
`np.array([item in test_elements for item in element])`

Specification: numpy.isin returns a boolean vector where each element indicates
whether the corresponding element in the input vector is found in test_elements.

Precondition: True (no special preconditions needed)
Postcondition: For all indices i, result[i] = true iff element[i] is in test_elements","use vstd::prelude::*;

verus! {",,"fn numpy_isin(element: Vec<f32>, test_elements: Vec<f32>) -> (result: Vec<bool>)
    ensures 
        result.len() == element.len(),
        forall|i: int| 0 <= i < result.len() ==> 
            (result[i] == true <==> exists|j: int| 0 <= j < test_elements.len() && element[i] == test_elements[j])","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0552,verus,numpy_triple,set_operations_setdiff1d,,"Find the set difference of two arrays.
Return the unique values in ar1 that are not in ar2.

Specification: setdiff1d returns unique values from ar1 that are not in ar2.
The result contains no duplicates and is sorted.","use vstd::prelude::*;

verus! {",,"fn setdiff1d(ar1: Vec<i8>, ar2: Vec<i8>) -> (result: Vec<i8>)
    ensures
        /* Each element in result is from ar1 and not in ar2 */
        forall|i: int| 0 <= i < result@.len() ==> 
            exists|j: int| #[trigger] result[i] == ar1[j] && 0 <= j < ar1@.len() &&
            forall|l: int| 0 <= l < ar2@.len() ==> result[i] != ar2[l],
        /* No duplicates in result */
        forall|i: int, j: int| 0 <= i < result@.len() && 0 <= j < result@.len() && i != j ==> 
            result[i] != result[j],
        /* Result is sorted */
        forall|i: int, j: int| 0 <= i < j < result@.len() ==> result[i] <= result[j]","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0553,verus,numpy_triple,set_operations_setxor1d,,"numpy.setxor1d: Find the set exclusive-or of two arrays.

Return the sorted, unique values that are in only one (not both) of the
input arrays. This is equivalent to the symmetric difference of two sets.

The result contains elements that appear in ar1 but not in ar2, or in ar2 
but not in ar1, sorted in ascending order.

Specification: numpy.setxor1d returns the symmetric difference of two arrays.

Precondition: True (no special preconditions)
Postcondition: 
1. The result contains only elements that appear in exactly one of the input arrays
2. The result is sorted in ascending order
3. The result contains no duplicates
4. Every element in the result comes from either ar1 or ar2 (but not both)","use vstd::prelude::*;

verus! {
spec fn contains_element(arr: Seq<i32>, elem: i32) -> bool {
    exists|i: int| 0 <= i < arr.len() && arr[i] == elem
}

spec fn is_sorted(arr: Seq<i32>) -> bool {
    forall|i: int, j: int| 0 <= i < j < arr.len() ==> arr[i] <= arr[j]
}

spec fn has_no_duplicates(arr: Seq<i32>) -> bool {
    forall|i: int, j: int| 0 <= i < arr.len() && 0 <= j < arr.len() && i != j ==> arr[i] != arr[j]
}

spec fn in_exactly_one(ar1: Seq<i32>, ar2: Seq<i32>, elem: i32) -> bool {
    (contains_element(ar1, elem) && !contains_element(ar2, elem)) ||
    (contains_element(ar2, elem) && !contains_element(ar1, elem))
}",,"fn numpy_setxor1d(ar1: &Vec<i32>, ar2: &Vec<i32>) -> (result: Vec<i32>)
    ensures
        /* Result is sorted */
        is_sorted(result@),
        /* Result has no duplicates */
        has_no_duplicates(result@),
        /* Every element in result is from exactly one input array */
        forall|i: int| 0 <= i < result.len() ==> #[trigger] in_exactly_one(ar1@, ar2@, result[i]),
        /* Every element that appears in exactly one input array is in the result */
        forall|x: i32| in_exactly_one(ar1@, ar2@, x) ==> contains_element(result@, x)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0554,verus,numpy_triple,set_operations_union1d,,"numpy.union1d: Find the union of two arrays.

Returns the unique, sorted array of values that are in either of the two
input arrays. The function is equivalent to unique(concatenate(ar1, ar2)).

The input arrays are flattened if they are not already 1D, and the result
is always a 1D array containing the union of all elements from both arrays,
with duplicates removed and elements sorted in ascending order.

Specification: numpy.union1d returns the sorted union of two arrays.

Precondition: True (no special preconditions needed)
Postcondition: The result contains:
1. All elements from ar1 and ar2 (union property)
2. Elements are sorted in ascending order  
3. No duplicate elements (uniqueness property)
4. Every element in the result comes from one of the input arrays
5. Every element from input arrays appears in the result","use vstd::prelude::*;

verus! {",,"fn union1d(ar1: Vec<i8>, ar2: Vec<i8>) -> (result: Vec<i8>)
    ensures
        /* Union property: every element from either input array is in result */
        forall|i: int| 0 <= i < ar1.len() ==> 
            #[trigger] result@.contains(ar1[i]),
        forall|i: int| 0 <= i < ar2.len() ==> 
            #[trigger] result@.contains(ar2[i]),
        /* Completeness: every element in result comes from one of the input arrays */
        forall|j: int| 0 <= j < result.len() ==> 
            ar1@.contains(result[j]) || ar2@.contains(result[j]),
        /* Sorted property: result is sorted in ascending order */
        forall|i: int, j: int| 0 <= i < j < result.len() ==> 
            #[trigger] result[i] <= #[trigger] result[j],
        /* Uniqueness property: no duplicate elements */
        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result.len() && i != j ==> 
            #[trigger] result[i] != #[trigger] result[j],","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0555,verus,numpy_triple,set_operations_unique,,"Find the unique elements of a vector and return them in sorted order.

Specification: unique returns sorted unique elements from the input vector.

/* Result is sorted */

/* All elements in result come from input array */

/* All elements in result are unique */

/* All elements from input appear in result */","use vstd::prelude::*;

verus! {",,"fn unique(arr: Vec<i8>) -> (result: Vec<i8>)
    ensures

        forall|i: int, j: int| 0 <= i < j < result@.len() ==> #[trigger] result@[i] < #[trigger] result@[j],

        forall|i: int| 0 <= i < result@.len() ==> exists|j: int| 0 <= j < arr@.len() && #[trigger] result@[i] == #[trigger] arr@[j],

        forall|i: int, j: int| 0 <= i < result@.len() && 0 <= j < result@.len() && i != j ==> #[trigger] result@[i] != #[trigger] result@[j],

        forall|i: int| 0 <= i < arr@.len() ==> exists|j: int| 0 <= j < result@.len() && #[trigger] arr@[i] == #[trigger] result@[j],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0556,verus,numpy_triple,sorting_searching_argmax,,"numpy.argmax: Returns the index of the maximum value in a vector.

Returns the index of the maximum value among all elements in the array.
Requires a non-empty array since there is no maximum of an empty set.

In case of multiple occurrences of the maximum values, the indices
corresponding to the first occurrence are returned.

This function returns the position of the largest element in the array.

Specification: numpy.argmax returns the index of the maximum element.

Precondition: True (non-empty constraint is in the type)
Postcondition: The element at the returned index is the maximum value,
and it is the first occurrence of such maximum value.","use vstd::prelude::*;

verus! {",,"fn argmax(a: Vec<i8>) -> (result: usize)
    requires a.len() > 0,
    ensures 
        result < a.len(),
        forall|j: int| 0 <= j < a@.len() ==> a@[j] <= a@[result as int],
        forall|j: int| 0 <= j < a@.len() && a@[j] == a@[result as int] ==> result <= j as usize,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0557,verus,numpy_triple,sorting_searching_argmin,,"numpy.argmin: Returns the index of the minimum value.

Returns the index of the minimum value among all elements in the array.
Requires a non-empty array since there is no minimum of an empty set.

This function returns the position of the smallest element in the array.
In case of multiple occurrences of the minimum values, the indices
corresponding to the first occurrence are returned.

Specification: numpy.argmin returns the index of the minimum element.

Precondition: True (non-empty constraint is in the type)
Postcondition: The element at the returned index is the minimum value,
and for ties, it returns the first occurrence.","use vstd::prelude::*;

verus! {",,"fn numpy_argmin(a: Vec<i8>) -> (result: usize)
    requires a.len() > 0,
    ensures 
        result < a.len(),
        forall|j: int| 0 <= j < a@.len() ==> a@[result as int] <= a@[j],
        forall|j: int| 0 <= j < a@.len() && a@[j] == a@[result as int] ==> (result as int) <= j,","{
    // impl-start
    assume(false);
    0
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0558,verus,numpy_triple,sorting_searching_argpartition,,"Perform an indirect partition along the given axis.
Returns an array of indices that partition the input array such that
the kth element is in its final sorted position and all smaller
elements are moved before it and all larger elements behind it.

Specification: argpartition returns indices that correctly partition the array.
The kth element is in its final sorted position, with all smaller elements
before it and all larger elements after it.","use vstd::prelude::*;

verus! {",,"fn argpartition(a: Vec<i8>, kth: usize) -> (indices: Vec<usize>)
    requires 
        a.len() > 0,
        kth < a.len(),
    ensures
        /* The indices form a valid permutation of 0..n-1 */
        indices.len() == a.len(),
        /* Partition property: all elements before kth position are ≤ kth element */
        forall|i: int| 0 <= i < kth ==> a@[#[trigger] indices@[i] as int] <= a@[#[trigger] indices@[kth as int] as int],
        /* Partition property: all elements after kth position are ≥ kth element */
        forall|i: int| kth < i && i < indices.len() ==> a@[#[trigger] indices@[kth as int] as int] <= a@[#[trigger] indices@[i] as int],","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0559,verus,numpy_triple,sorting_searching_argsort,,"Returns the indices that would sort a vector in ascending order. Performs an indirect sort returning an array of indices that would sort the input array in ascending order. For equal elements, maintains relative order (stable sort).

// All indices are valid

// The result represents sorted order

// Stable sort property for equal elements","use vstd::prelude::*;

verus! {",,"fn argsort(a: Vec<i8>) -> (result: Vec<usize>)
    ensures 
        result.len() == a.len(),

        forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i] < a.len(),

        forall|i: int, j: int| 0 <= i < j < result.len() ==> 
            a[#[trigger] result[i] as int] <= a[#[trigger] result[j] as int],

        forall|i: int, j: int| 0 <= i < j < result.len() && 
            a[#[trigger] result[i] as int] == a[#[trigger] result[j] as int] ==> 
            result[i] < result[j]","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0560,verus,numpy_triple,sorting_searching_argwhere,,"numpy.argwhere: Find the indices of array elements that are non-zero, grouped by element.

For a 1D vector, returns a list of indices where elements are non-zero.
Each index corresponds to a position in the original vector where the element is non-zero.
The returned indices are in the same order as they appear in the original vector.

Specification: numpy.argwhere returns all indices of non-zero elements.

Precondition: True (no special requirements)
Postcondition: 
1. All returned indices correspond to non-zero elements in the input vector
2. All non-zero elements in the input vector have their indices in the result
3. The result contains no duplicate indices
4. The indices are ordered according to their position in the original vector

/* All returned indices correspond to non-zero elements */

/* All non-zero elements have their indices in the result */

/* No duplicate indices */

/* Indices are ordered by position */","use vstd::prelude::*;

verus! {",,"fn numpy_argwhere(a: Vec<f64>) -> (indices: Vec<usize>)
    ensures

        forall|i: int| 0 <= i < indices@.len() ==> 
            indices@[i] < a@.len() && a@[indices@[i] as int] != 0.0,

        forall|i: int| 0 <= i < a@.len() && a@[i] != 0.0 ==> 
            indices@.contains(i as usize),

        forall|i: int, j: int| 0 <= i < j < indices@.len() ==> 
            indices@[i] != indices@[j],

        forall|i: int, j: int| 0 <= i < j < indices@.len() ==> 
            indices@[i] < indices@[j],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0561,verus,numpy_triple,sorting_searching_bincount,,"numpy.bincount: Count number of occurrences of each value in array of non-negative ints.

Count number of occurrences of each value in array of non-negative ints.
The number of bins (of size 1) is one larger than the largest value in x.
Each bin gives the number of occurrences of its index value in x.

This function takes a 1D array of non-negative integers and returns
an array where the i-th element is the count of how many times the
value i appears in the input array.

Specification: numpy.bincount returns count of occurrences of each value.

Precondition: All values in x are non-negative and ≤ max_val
Postcondition: result[i] = count of occurrences of value i in x","use vstd::prelude::*;

verus! {",,"spec fn count_occurrences(x: Seq<nat>, val: nat) -> nat {
    x.filter(|v: nat| v == val).len()
}

fn numpy_bincount(x: Vec<u8>, max_val: u8) -> (result: Vec<u8>)
    requires 
        forall|i: int| 0 <= i < x.len() ==> x[i] as nat <= max_val as nat,
    ensures
        result.len() == max_val as nat + 1,
        forall|val: int| 0 <= val <= max_val as int ==> 
            result[val] as nat == count_occurrences(x@.map(|i: int, v: u8| v as nat), val as nat),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0562,verus,numpy_triple,sorting_searching_count_nonzero,,"Counts the number of non-zero values in a vector.

The word ""non-zero"" is in reference to the Python 2.x
built-in method `__nonzero__()` (renamed `__bool__()`
in Python 3.x) of Python objects that tests an object's
""truthfulness"". For example, any number is considered
truthful if it is nonzero, whereas any string is considered
truthful if it is not the empty string. Thus, this function
counts how many elements in the vector are non-zero.

Specification: count_nonzero returns the number of non-zero elements in the vector.

The function counts exactly those elements that are not equal to zero.
The result is always between 0 and n (inclusive), where n is the length of the vector.
If all elements are zero, the result is 0.
If all elements are non-zero, the result is n.","use vstd::prelude::*;

verus! {",,"fn count_nonzero(a: Vec<i8>) -> (count: usize)
    ensures
        count <= a.len(),
        a.len() == 0 ==> count == 0,
        (forall|i: int| 0 <= i < a@.len() ==> a[i] == 0) ==> count == 0,
        (forall|i: int| 0 <= i < a@.len() ==> a[i] != 0) ==> count == a.len(),
        (exists|i: int| 0 <= i < a@.len() && a[i] != 0) ==> count > 0,
        (exists|i: int| 0 <= i < a@.len() && a[i] == 0) ==> count < a.len()","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0563,verus,numpy_triple,sorting_searching_extract,,"Return the elements of an array that satisfy some condition.
The result size is the number of True entries in the condition array.

Specification: extract returns elements from arr where condition is True.
The result contains exactly those elements from arr at positions where condition is True,
preserving their original order. The result size m equals the number of True values in condition.","use vstd::prelude::*;

verus! {",,"fn extract(condition: &Vec<bool>, arr: &Vec<i8>) -> (result: Vec<i8>)
    requires condition.len() == arr.len(),
    ensures
        /* Each element in result comes from arr at a position where condition is true */
        forall|k: int| 0 <= k < result@.len() ==>
            exists|i: int| 0 <= i < arr@.len() && condition@[i] == true && #[trigger] result@[k] == arr@[i],
        /* Every True position in condition contributes exactly one element to the result */
        forall|i: int| 0 <= i < condition@.len() && condition@[i] == true ==>
            exists|k: int| 0 <= k < result@.len() && #[trigger] result@[k] == arr@[i],","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0564,verus,numpy_triple,sorting_searching_flatnonzero,,"numpy.flatnonzero: Return indices that are non-zero in the flattened version of a.

This function returns the indices of all non-zero elements in the array.
The returned indices correspond to positions in the flattened array where
the elements are non-zero.

For example, if array is [1, 0, 3, 0, 5], the function returns [0, 2, 4]
indicating that elements at positions 0, 2, and 4 are non-zero.

Specification: flatnonzero returns indices of all non-zero elements.

Precondition: True (no restrictions on input array)
Postcondition: 
1. All returned indices correspond to non-zero elements in the original array
2. All non-zero elements in the original array have their indices in the result
3. The result contains no duplicate indices
4. The result indices are sorted in ascending order

/* All indices in result point to non-zero elements */

/* All non-zero elements have their indices in result */

/* Result contains no duplicate indices */

/* Result indices are sorted in ascending order */","use vstd::prelude::*;

verus! {",,"fn flatnonzero(a: Vec<f64>) -> (result: Vec<usize>)
    ensures

        forall|i: int| 0 <= i < result@.len() ==> a[result@[i] as int] != 0.0,

        forall|j: int| 0 <= j < a@.len() && a@[j] != 0.0 ==> exists|k: int| 0 <= k < result@.len() && result@[k] == j,

        forall|i: int, j: int| 0 <= i < result@.len() && 0 <= j < result@.len() && i != j ==> result@[i] != result@[j],

        forall|i: int, j: int| 0 <= i < j < result@.len() ==> result@[i] < result@[j],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0565,verus,numpy_triple,sorting_searching_lexsort,,"Perform an indirect stable sort using a sequence of keys.
Given multiple sorting keys, lexsort returns an array of integer indices that 
describes the sort order by multiple columns. The last key in the sequence is used
for the primary sort order, ties are broken by the second-to-last key, and so on.

Specification: lexsort returns indices that lexicographically sort the keys.
The result is a permutation of indices where for any two positions i, j:
- If primary key differs, sort by primary key
- If primary key is equal, sort by second-to-last key, etc.
- The sort is stable (preserves relative order of equal elements)","use vstd::prelude::*;

verus! {",,"fn lexsort(keys: Vec<Vec<i8>>) -> (indices: Vec<u8>)
    requires 
        keys.len() > 0,
        keys.len() > 0 ==> keys[0].len() > 0,
        forall|i: int| 0 <= i < keys.len() ==> #[trigger] keys[i as int]@.len() == keys[0]@.len(),
    ensures
        indices@.len() == keys[0]@.len(),
        /* indices contains all values from 0 to n-1 exactly once */
        forall|i: int| 0 <= i < keys[0]@.len() ==> #[trigger] indices@.contains(i as u8),
        forall|i: int, j: int| 0 <= i < indices@.len() && 0 <= j < indices@.len() && i != j ==> indices[i as int] != indices[j as int]","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0566,verus,numpy_triple,sorting_searching_msort,,"Return a copy of an array sorted along the first axis (ascending order).
This is equivalent to np.sort(a, axis=0) in NumPy.

Specification: msort returns a sorted copy of the input array in ascending order.
The result is a permutation of the input array.","use vstd::prelude::*;

verus! {",,"fn msort(a: Vec<i8>) -> (result: Vec<i8>)
    ensures
        result.len() == a.len(),
        forall|i: int, j: int| 0 <= i < j < result.len() ==> result[i] as int <= result[j] as int,
        result@.to_multiset() =~= a@.to_multiset(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0567,verus,numpy_triple,sorting_searching_nanargmax,,"numpy.nanargmax: Returns the index of the maximum value in a vector, ignoring NaN values.

Returns the index of the maximum value among all non-NaN elements in the array.
Requires that at least one element is not NaN, otherwise it would raise an error.

In case of multiple occurrences of the maximum values, the indices
corresponding to the first occurrence are returned.

This function returns the position of the largest non-NaN element in the array.

Specification: numpy.nanargmax returns the index of the maximum non-NaN element.

Precondition: At least one element is not NaN
Postcondition: The element at the returned index is not NaN, is the maximum 
among all non-NaN values, and is the first occurrence of such maximum value.","use vstd::prelude::*;

verus! {",,"fn nanargmax(a: Vec<i8>) -> (idx: usize)
    requires 
        a@.len() > 0,
    ensures 
        idx < a@.len(),
        forall|j: int| 0 <= j < a@.len() ==> a@[j] <= a@[idx as int],
        forall|j: int| 0 <= j < a@.len() && a@[j] == a@[idx as int] ==> (idx as int) <= j,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0568,verus,numpy_triple,sorting_searching_nanargmin,,"numpy.nanargmin: Return the indices of the minimum values in the specified axis ignoring NaNs.

For all-NaN slices ValueError is raised. Warning: the results cannot be trusted 
if a slice contains only NaNs and Infs.

This function finds the index of the minimum value in a vector, ignoring NaN values.
If all values are NaN, it should raise an error (represented as a precondition).

Parameters:
- a : Vector Float n - Input data vector

Returns:
- Fin n - Index of the minimum non-NaN value

Specification: nanargmin returns the index of the minimum non-NaN value.

Precondition: At least one element in the vector is not NaN
Postcondition: 
1. The returned index points to a non-NaN value
2. All non-NaN values at other indices are greater than or equal to the value at the returned index
3. If there are ties, returns the first occurrence (smallest index)","use vstd::prelude::*;

verus! {",,"fn nanargmin(a: Vec<i8>) -> (result: usize)
    requires 
        a.len() > 0,
    ensures
        result < a.len(),
        forall|j: int| 0 <= j < a@.len() ==> a[result as int] <= a[j],
        forall|j: int| 0 <= j < result ==> a[j] > a[result as int],","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0569,verus,numpy_triple,sorting_searching_nonzero,,"numpy.nonzero: Return the indices of the elements that are non-zero.

Returns a vector of indices where the corresponding elements in the input
array are non-zero. The indices are returned in row-major, C-style order.

For a 1D array, this returns a vector containing all indices i such that
a[i] ≠ 0. Since the output size depends on the input values, we use
a Vec structure to accommodate the dynamic nature of the result.

Note: In the full NumPy implementation, this returns a tuple of arrays
(one for each dimension), but for 1D arrays we simplify to a single vector.

Specification: numpy.nonzero returns indices of all non-zero elements.

Precondition: True (no constraints on input)
Postcondition: 
1. Every index in the result corresponds to a non-zero element in the input
2. Every non-zero element in the input has its index in the result (completeness)
3. The indices are in ascending order (preserving array order)
4. No duplicates in the result","use vstd::prelude::*;

verus! {",,"fn nonzero(a: Vec<f32>) -> (indices: Vec<usize>)
    ensures
        forall|i: int| 0 <= i < indices.len() ==> (indices[i] < a.len() && a[indices[i] as int] != 0.0f32),
        forall|j: int| 0 <= j < a.len() ==> (a[j] != 0.0f32 <==> exists|k: int| 0 <= k < indices.len() && indices[k] == j),
        forall|i1: int, i2: int| 0 <= i1 < i2 < indices.len() ==> indices[i1] < indices[i2],
        forall|i: int, j: int| 0 <= i < j < indices.len() ==> indices[i] != indices[j],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0570,verus,numpy_triple,sorting_searching_partition,,"Return a partitioned copy of an array around the k-th element.

Specification: partition rearranges elements so that the k-th element is in its sorted position,
with smaller elements before it and equal/greater elements after it.","use vstd::prelude::*;

verus! {",,"spec fn is_sorted(arr: Seq<i32>) -> bool {
    forall|i: int, j: int| 0 <= i < j < arr.len() ==> arr[i] <= arr[j]
}

spec fn count_occurrences(arr: Seq<i32>, x: i32) -> nat 
    decreases arr.len()
{
    if arr.len() == 0 {
        0nat
    } else {
        let first_count: nat = if arr[0] == x { 1nat } else { 0nat };
        first_count + count_occurrences(arr.skip(1), x)
    }
}

spec fn multiset_equal(arr1: Seq<i32>, arr2: Seq<i32>) -> bool {
    arr1.len() == arr2.len() &&
    forall|x: i32| count_occurrences(arr1, x) == count_occurrences(arr2, x)
}

fn partition(arr: Vec<i32>, kth: usize) -> (result: Vec<i32>)
    requires kth < arr.len(),
    ensures
        result.len() == arr.len(),
        /* All elements before kth are <= the kth element */
        forall|i: int| 0 <= i < kth as int ==> result@[i] <= result@[kth as int],
        /* All elements after kth are >= the kth element */
        forall|i: int| (kth as int) < i < (result@.len()) ==> result@[i] >= result@[kth as int],
        /* The k-th element is in its correct sorted position relative to the original array */
        exists|sorted: Seq<i32>| 
            is_sorted(sorted) &&
            multiset_equal(sorted, arr@) &&
            result@[kth as int] == sorted[kth as int],
        /* The result contains the same elements as the original (multiset equality) */
        multiset_equal(result@, arr@)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0571,verus,numpy_triple,sorting_searching_searchsorted,,"numpy.searchsorted: Find indices where elements should be inserted to maintain order.

Given a sorted array `a` and values `v`, returns indices such that inserting 
each element of `v` at the corresponding index would preserve the sorted order of `a`.

This implementation focuses on the 'left' side behavior where for each value v[i],
it returns the leftmost suitable insertion position. The returned indices are
in the range [0, n] where n is the length of the sorted array.

Specification: numpy.searchsorted returns indices for sorted insertion.

Precondition: The input array `a` must be sorted in ascending order
Postcondition: For each element v[i], the returned index idx satisfies:
- All elements before idx are strictly less than v[i] (left insertion property)
- All elements at or after idx are greater than or equal to v[i] (sorted property)
- The index is valid for insertion (between 0 and n inclusive)
- Inserting v[i] at idx preserves the sorted order of the array","use vstd::prelude::*;

verus! {",,"fn numpy_searchsorted(a: Vec<i8>, v: Vec<i8>) -> (result: Vec<usize>)
    requires 
        forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] as int <= a[j] as int,
    ensures 
        result.len() == v.len()","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0572,verus,numpy_triple,sorting_searching_sort,,"numpy.sort: Return a sorted copy of an array.

Returns a new array with the same elements sorted in ascending order.
The original array is not modified. This function performs a stable sort 
on the array elements, meaning that when multiple records have the same key,
their original order is preserved.

Parameters:
- a : array_like - Array to be sorted

Returns:
- sorted_array : ndarray - Array of the same type and shape as a, with elements sorted

Specification: numpy.sort returns a sorted permutation of the input array.

The specification captures three key properties:
1. Sorting property: Elements are in non-decreasing order
2. Permutation property: The result contains exactly the same elements as the input
3. Stability property: Relative order of equal elements is preserved (implicit in permutation)

Precondition: True (works for any vector)
Postcondition: Result is sorted and is a permutation of the input","use vstd::prelude::*;

verus! {",,"spec fn count_occurrences(seq: Seq<i32>, x: i32) -> int
    decreases seq.len()
{
    if seq.len() == 0 {
        0int
    } else {
        (if seq[0] == x { 1int } else { 0int }) + count_occurrences(seq.skip(1), x)
    }
}

fn sort(a: Vec<i32>) -> (result: Vec<i32>)
    ensures
        result.len() == a.len(),
        forall|i: int, j: int| 0 <= i < j < result.len() ==> result[i] <= result[j],
        forall|x: i32| count_occurrences(result@, x) == count_occurrences(a@, x)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0573,verus,numpy_triple,sorting_searching_unique,,"numpy.unique: Find the unique elements of an array.

Returns the sorted unique elements of an array. This operation removes
duplicate values and returns them in sorted order. The result contains
each unique value exactly once.

For a 1D array, this function eliminates duplicate elements and sorts
the remaining unique elements in ascending order.

The returned array will have size less than or equal to the input array,
with equality only when all elements are already unique.

Specification: numpy.unique returns sorted unique elements without duplicates.

Precondition: True (no special preconditions)
Postcondition: The result contains all unique elements from the input array,
sorted in ascending order, with no duplicates, and every element in the 
result appears in the original array.

// The result is sorted in ascending order

// No duplicates in the result","use vstd::prelude::*;

verus! {",,"fn unique(ar: Vec<i8>) -> (result: (usize, Vec<i8>))
    ensures
        result.1.len() <= ar.len(),

        forall|i: int, j: int| 0 <= i < j < result.1.len() ==> result.1[i as int] as int <= result.1[j as int] as int,

        forall|i: int, j: int| 0 <= i < result.1.len() && 0 <= j < result.1.len() && i != j ==> result.1[i as int] != result.1[j as int],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0574,verus,numpy_triple,sorting_searching_where,,"Return elements chosen from x or y depending on condition.
For each position i, if condition[i] is True, take x[i], otherwise take y[i].

Specification: numpy_where returns an array where elements are chosen from x when condition is True,
and from y when condition is False.","use vstd::prelude::*;

verus! {",,"fn numpy_where(condition: Vec<bool>, x: Vec<f32>, y: Vec<f32>) -> (result: Vec<f32>)
    requires 
        condition@.len() == x@.len(),
        condition@.len() == y@.len(),
    ensures 
        result@.len() == condition@.len(),
        forall|i: int| 0 <= i < condition@.len() ==> 
            (condition@[i] ==> result@[i] == x@[i]) &&
            (!condition@[i] ==> result@[i] == y@[i])","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0575,verus,numpy_triple,statistics_amax,,"Returns the maximum value of all elements in a non-empty vector.
Specification: amax returns the maximum value in the vector.
Mathematical properties:
1. The result is an element that exists in the vector
2. No element in the vector is greater than the result
3. The result is unique (first occurrence if there are duplicates)
4. For constant vectors, amax equals the constant value","use vstd::prelude::*;

verus! {",,"fn amax(a: Vec<i8>) -> (result: i8)
    requires a.len() > 0,
    ensures
        (exists|max_idx: int| 0 <= max_idx < a.len() &&
            result as int == a@[max_idx] as int &&
            (forall|i: int| 0 <= i < a.len() ==> a@[i] as int <= result as int)) &&
        (exists|first_max_idx: int| 0 <= first_max_idx < a.len() &&
            result as int == a@[first_max_idx] as int &&
            (forall|i: int| 0 <= i < a.len() && a@[i] as int == result as int ==> first_max_idx <= i) &&
            (forall|i: int| 0 <= i < a.len() ==> a@[i] as int <= result as int)) &&
        ((forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() ==> a@[i] as int == a@[j] as int) ==> 
            result as int == a@[0] as int) &&
        (exists|witness: int| 0 <= witness < a.len() && result as int == a@[witness] as int)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0576,verus,numpy_triple,statistics_amin,,"Return the minimum of an array or minimum along an axis.

This is an alias for numpy.min that returns the minimum value among all elements in the array.
Requires a non-empty array since there is no minimum of an empty set.

This is a reduction operation that finds the smallest value in the array.
NaN values are propagated - if any element is NaN, the result will be NaN.

Specification: amin returns the minimum element in the vector.

Precondition: True (non-empty constraint is enforced by type Vector Float (n + 1))
Postcondition: result is the minimum value and is an element of the vector

Properties:
1. The result is actually an element of the input vector
2. The result is less than or equal to all elements in the vector
3. This captures the mathematical definition of minimum","use vstd::prelude::*;

verus! {",,"spec fn in_array(result: f32, a: Seq<f32>) -> bool {
    exists|i: int| 0 <= i < a.len() && result == a[i]
}

fn amin(a: Vec<f32>) -> (result: f32)
    requires a.len() > 0,
    ensures in_array(result, a@),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0577,verus,numpy_triple,statistics_average,,"Computes the weighted average along the specified axis.

Computes the weighted average of the elements in the input vector.
If weights are not provided, it computes the arithmetic mean.
If weights are provided, it computes the weighted average where each
element contributes according to its associated weight.

The weighted average is computed as:
sum(a * weights) / sum(weights)

When weights are not provided, this reduces to:
sum(a) / len(a)","use vstd::prelude::*;

verus! {",,"fn average(a: Vec<i8>, weights: Option<Vec<i8>>) -> (result: i8)
    requires 
        a.len() > 0,
        match weights {
            Some(w) => w.len() == a.len(),
            None => true,
        }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0578,verus,numpy_triple,statistics_corrcoef,,"numpy.corrcoef: Return Pearson product-moment correlation coefficients.

The correlation coefficient measures the linear relationship between two variables.
For two vectors x and y, the correlation coefficient is computed as:

corr(x, y) = cov(x, y) / (std(x) * std(y))

Where:
- cov(x, y) is the covariance between x and y
- std(x) and std(y) are the standard deviations of x and y

This function computes the correlation coefficient between two vectors of observations.
The result is bounded between -1 and 1, where:
- 1 indicates perfect positive correlation
- -1 indicates perfect negative correlation  
- 0 indicates no linear correlation

Requires non-empty vectors and non-zero variance in both variables.

Specification: corrcoef computes the Pearson correlation coefficient between two vectors.

The correlation coefficient satisfies several mathematical properties:
1. Symmetry: corr(x, y) = corr(y, x)
2. Bounded: -1 ≤ corr(x, y) ≤ 1
3. Self-correlation: corr(x, x) = 1 (if x has non-zero variance)
4. Scale invariance: correlation is preserved under linear transformations

Precondition: Both vectors have non-zero variance (not all elements equal)
Postcondition: Result is bounded between -1 and 1, and captures linear relationship","use vstd::prelude::*;

verus! {",,"fn corrcoef(x: Vec<i8>, y: Vec<i8>) -> (result: i8)
    requires 
        x.len() == y.len(),
        x.len() > 0,
        exists|i: int, j: int| 0 <= i < x.len() && 0 <= j < x.len() && x[i] != x[j],
        exists|i: int, j: int| 0 <= i < y.len() && 0 <= j < y.len() && y[i] != y[j],
    ensures
        -100 <= result as int && result as int <= 100","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0579,verus,numpy_triple,statistics_correlate,,"Cross-correlation of two 1-dimensional sequences in 'valid' mode.
Computes c_k = sum_i a_{k+i} * v_i for positions where both sequences fully overlap.

Specification: correlate computes cross-correlation with valid mode overlap.
Each output element is the sum of products of overlapping elements from the input sequences.

Mathematical properties:
1. The result has size (m + 1 - n) for valid mode
2. Each output element k is computed as: sum_i a[k+i] * v[i] for i in [0, n-1]
3. Only positions where both sequences fully overlap are computed
4. The correlation preserves the mathematical definition of cross-correlation","use vstd::prelude::*;

verus! {",,"spec fn correlation_sum(a: Seq<i32>, v: Seq<i32>, k: int) -> int
    decreases v.len()
{
    if v.len() == 0 {
        0
    } else {
        a[k] * v[0] + correlation_sum(a, v.skip(1), k + 1)
    }
}

fn correlate(a: Vec<i32>, v: Vec<i32>) -> (result: Vec<i32>)
    requires 
        v.len() > 0,
        v.len() <= a.len(),
    ensures
        result.len() == a.len() + 1 - v.len(),
        forall|k: int| 0 <= k < result.len() ==> 
            result[k] == correlation_sum(a@, v@, k),","{
    // impl-start
    assume(false);
    Vec::new()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0580,verus,numpy_triple,statistics_cov,,"numpy.cov: Estimate a covariance matrix, given data and weights.

Covariance indicates the level to which two variables vary together. 
If we examine N-dimensional samples, X = [x_1, x_2, ... x_N]^T, 
then the covariance matrix element C_{ij} is the covariance of x_i and x_j. 
The element C_{ii} is the variance of x_i.

For a matrix with `vars` variables and `obs` observations:
- Each row represents a variable
- Each column represents an observation
- Returns a vars × vars covariance matrix

This implementation focuses on the basic unweighted case without bias correction.

Specification: numpy.cov computes the covariance matrix from data matrix m.

Given a data matrix m where each row is a variable and each column is an observation,
the covariance matrix C has the following mathematical properties:

1. Symmetry: C[i,j] = C[j,i] for all i,j
2. Diagonal elements are variances: C[i,i] = Var(X_i)
3. Off-diagonal elements are covariances: C[i,j] = Cov(X_i, X_j)
4. Positive semi-definite: all eigenvalues ≥ 0

The covariance between variables i and j is computed as:
Cov(X_i, X_j) = E[(X_i - μ_i)(X_j - μ_j)]
where μ_i is the mean of variable i.

Precondition: At least one observation (obs > 0)
Postcondition: Returns a symmetric positive semi-definite covariance matrix","use vstd::prelude::*;

verus! {","spec fn seq_sum(s: Seq<i32>) -> int {
    s.fold_left(0, |acc: int, x: i32| acc + x)
}

spec fn variable_mean(var_data: Seq<i32>) -> int {
    if var_data.len() == 0 {
        0
    } else {
        seq_sum(var_data) / (var_data.len() as int)
    }
}","fn numpy_cov(m: Vec<Vec<i8>>) -> (cov_matrix: Vec<Vec<i8>>)
    requires 
        m.len() > 0,
        forall|i: int| 0 <= i < m.len() ==> m[i].len() > 0,
        forall|i: int, j: int| 0 <= i < m.len() && 0 <= j < m.len() ==> m[i].len() == m[j].len(),
    ensures 
        cov_matrix.len() == m.len(),
        forall|i: int| 0 <= i < cov_matrix.len() ==> cov_matrix[i].len() == m.len(),
        forall|i: int, j: int| 0 <= i < m.len() && 0 <= j < m.len() ==> 
            cov_matrix[i][j] == cov_matrix[j][i],
        forall|i: int| 0 <= i < m.len() ==> (cov_matrix[i][i] as int) >= 0,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0582,verus,numpy_triple,statistics_histogram,,"numpy.histogram: Compute the histogram of a dataset.

Computes the histogram of a dataset by dividing the range into equal-width bins
and counting the number of values that fall into each bin.

The function returns both the histogram counts and the bin edges.
For n_bins bins, there are n_bins+1 bin edges.

This implementation focuses on the core mathematical properties:
- Monotonically increasing bin edges
- Equal bin widths (uniform binning)
- Correct counting of values in each bin
- Conservation of total count

Specification: histogram correctly partitions data into bins and counts occurrences.

The histogram satisfies fundamental mathematical properties:
1. Bin edges are monotonically increasing
2. The first edge equals min_val and the last edge equals max_val
3. Bin widths are equal for uniform binning
4. Each bin count equals the number of data points in that bin
5. The sum of all bin counts equals the number of data points in range

Precondition: Number of bins > 0 and min_val < max_val
Postcondition: The result satisfies the histogram mathematical properties

// Boundary conditions: first edge is min_val, last edge is max_val

// Result histogram has correct length

// Conservation: total count equals number of data points in range","use vstd::prelude::*;

verus! {

spec fn sum_seq(s: Seq<usize>) -> nat 
    decreases s.len()
{
    if s.len() == 0 {
        0nat
    } else {
        (s[0] as nat) + sum_seq(s.drop_first())
    }
}",,"fn histogram(data: Vec<i8>, n_bins: usize, min_val: i8, max_val: i8) -> (result: (Vec<usize>, Vec<i8>))
    requires
        n_bins > 0,
        (min_val as int) < (max_val as int),
    ensures

        result.1.len() == n_bins + 1,
        result.1[0] == min_val,
        result.1[(n_bins as int)] == max_val,

        result.0.len() == n_bins,

        sum_seq(result.0@) == data@.filter(|x: i8| (min_val as int) <= (x as int) && (x as int) <= (max_val as int)).len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0583,verus,numpy_triple,statistics_histogram2d,,"Computes the bi-dimensional histogram of two data samples with equal number of bins.

Specification: histogram2d computes a 2D histogram from two equal-length vectors.
Mathematical properties:
1. Input vectors must have the same length (enforced by type system)
2. The histogram matrix has dimensions (nbins, nbins) where nbins = bins
3. Each histogram bin counts the number of points falling within its boundaries
4. The bin edges define the boundaries for both x and y dimensions
5. The total count equals the input vector length
6. All histogram values are non-negative
7. Bin edges are monotonically increasing","use vstd::prelude::*;

verus! {",,"fn histogram2d(x: &Vec<i8>, y: &Vec<i8>, bins: u8) -> (result: (Vec<Vec<u8>>, Vec<i8>, Vec<i8>))
    requires 
        x@.len() == y@.len(),
        bins > 0,
    ensures
        result.0@.len() == bins as nat,
        forall|i: int| 0 <= i < bins as int ==> result.0@[i]@.len() == bins as nat,
        result.1@.len() == bins as nat + 1,
        result.2@.len() == bins as nat + 1,
        forall|i: int, j: int| 0 <= i < bins as int && 0 <= j < bins as int ==> result.0@[i]@[j] as nat <= x@.len(),
        forall|i: int| 0 <= i < bins as int ==> #[trigger] result.1@[i] as int <= result.1@[i + 1] as int,
        forall|i: int| 0 <= i < bins as int ==> #[trigger] result.2@[i] as int <= result.2@[i + 1] as int,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0584,verus,numpy_triple,statistics_histogram_bin_edges,,"Function to calculate only the edges of the bins used by the histogram function.
Calculate the bin edges for histogram computation with equal-width bins.
Takes non-empty data and number of bins, returns bin edges.
Specification: histogram_bin_edges computes equal-width bin edges from data range.
This comprehensive specification captures:
1. The number of returned edges equals num_bins + 1
2. The edges are monotonically increasing (strictly ordered)
3. The first edge is at or below the minimum data value
4. The last edge is at or above the maximum data value
5. The edges are evenly spaced (equal width bins)
6. All data values fall within the range [first_edge, last_edge]
7. The bin width is consistent across all bins
8. The function handles non-empty data correctly","use vstd::prelude::*;

verus! {",,"fn histogram_bin_edges(data: Vec<i8>, num_bins: usize) -> (edges: Vec<i8>)
    requires 
        data.len() > 0,
        num_bins > 0,
    ensures
        edges.len() == num_bins + 1,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0585,verus,numpy_triple,statistics_histogramdd,,"Compute the multidimensional histogram of some data.
For simplicity, we focus on 2D histograms with fixed dimensions.","use vstd::prelude::*;

verus! {",,"fn histogramdd(sample: Vec<(i32, i32)>, bins_x: usize, bins_y: usize) -> (result: (Vec<Vec<i32>>, Vec<i32>, Vec<i32>))
    requires 
        bins_x > 0,
        bins_y > 0,
    ensures 
        ({
            let (hist, edges_x, edges_y) = result;
            hist.len() == bins_y &&
            (forall|i: int| 0 <= i < hist.len() ==> #[trigger] hist[i].len() == bins_x) &&
            edges_x.len() == bins_x + 1 &&
            edges_y.len() == bins_y + 1 &&
            (forall|i: int| 0 <= i < bins_x ==> #[trigger] edges_x[i] < edges_x[i + 1]) &&
            (forall|i: int| 0 <= i < bins_y ==> #[trigger] edges_y[i] < edges_y[i + 1]) &&
            (forall|i: int, j: int| 0 <= i < bins_y && 0 <= j < bins_x ==> #[trigger] hist[i][j] >= 0) &&
            true
        })","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0586,verus,numpy_triple,statistics_max,,"Returns the maximum value of all elements in a non-empty vector.
This is an alias for numpy.amax that returns the maximum value among all elements in the array.

Mathematical Properties:
- Returns an element that exists in the vector
- No element in the vector is greater than the returned value
- For constant vectors, returns the constant value
- Handles non-empty vectors only (n + 1 elements)

Specification: max returns the maximum value in the vector.
This specification delegates to amax_spec since max is an alias for amax.

Mathematical properties:
1. The result is an element that exists in the vector
2. No element in the vector is greater than the result
3. The result is unique (first occurrence if there are duplicates)
4. For constant vectors, max equals the constant value
5. Sanity check: the maximum exists in the vector","use vstd::prelude::*;

verus! {",,"fn max(a: Vec<i8>) -> (result: i8)
    requires a.len() > 0,
    ensures
        /* Core property: result is the maximum element in the vector */
        exists|max_idx: int| 0 <= max_idx < a.len() &&
            result as int == a[max_idx as int] as int &&
            forall|i: int| 0 <= i < a.len() ==> a[i as int] as int <= result as int,
        /* Uniqueness: result is the first occurrence of the maximum */
        exists|first_max_idx: int| 0 <= first_max_idx < a.len() &&
            result as int == a[first_max_idx as int] as int &&
            (forall|i: int| 0 <= i < a.len() && a[i as int] as int == result as int ==> first_max_idx <= i) &&
            (forall|i: int| 0 <= i < a.len() ==> a[i as int] as int <= result as int),
        /* For constant vectors, max equals the constant */
        (forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() ==> a[i as int] as int == a[j as int] as int) ==>
            result as int == a[0] as int,
        /* Sanity check: the maximum exists in the vector */
        exists|witness: int| 0 <= witness < a.len() && result as int == a[witness as int] as int,","{
    // impl-start
    assume(false);
    0
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0587,verus,numpy_triple,statistics_mean,,"Computes the arithmetic mean of all elements in a non-empty vector.
Specification: mean computes the arithmetic average of all elements.
Mathematical properties:
1. The result is the sum of all elements divided by the count
2. The mean lies between the minimum and maximum values
3. For constant vectors, mean equals the constant value","use vstd::prelude::*;

verus! {",,"spec fn vec_sum(a: Seq<i32>) -> int 
    decreases a.len()
{
    if a.len() == 0 {
        0
    } else {
        a[0] as int + vec_sum(a.skip(1))
    }
}

spec fn all_equal(a: Seq<i32>) -> bool {
    forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() ==> a[i] == a[j]
}

fn mean(a: Vec<i32>) -> (result: i32)
    requires a.len() > 0,
    ensures 
        /* Core property: mean * count == sum */
        (result as int) * (a.len() as int) == vec_sum(a@),
        /* For constant vectors, mean equals the constant */
        all_equal(a@) ==> result == a[0]","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0588,verus,numpy_triple,statistics_median,,"Compute the median along the specified axis.

Compute the median of a vector.
For odd-length vectors, returns the middle value of the sorted array.
For even-length vectors, returns the average of the two middle values.

Specification: median returns the middle value(s) of a sorted vector.
- For odd length (n+1), the median is the middle element when sorted
- For even length (n+1), the median is the average of the two middle elements when sorted
- The median divides the data such that approximately half the values are ≤ it,
  and approximately half are ≥ it","use vstd::prelude::*;

verus! {",,"spec fn is_sorted(a: Seq<int>) -> bool {
    forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j]
}

fn median(a: Vec<i8>) -> (result: i8)
    requires a.len() > 0,
    ensures 
        exists|sorted: Seq<int>| #[trigger] sorted.len() == a@.len() &&
            is_sorted(sorted) &&
            (if a.len() % 2 == 1 {
                result as int == sorted[((a.len() - 1) / 2) as int]
            } else {
                result as int == (sorted[(a.len() / 2 - 1) as int] + sorted[(a.len() / 2) as int]) / 2
            })","{
    // impl-start
    assume(false);
    0
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0589,verus,numpy_triple,statistics_min,,"numpy.min: Return the minimum of an array or minimum along an axis.

This function is an alias for numpy.amin that returns the minimum value 
among all elements in the array. Requires a non-empty array since there 
is no minimum of an empty set.

This is a reduction operation that finds the smallest value in the array.
NaN values are propagated - if any element is NaN, the result will be NaN.

Being an alias, it has identical behavior to amin but provides a more
intuitive name for the operation.

Specification: min returns the minimum element in the vector.

Precondition: True (non-empty constraint is enforced by type Vector Float (n + 1))
Postcondition: result is the minimum value and is an element of the vector

Properties:
1. The result is actually an element of the input vector
2. The result is less than or equal to all elements in the vector
3. This captures the mathematical definition of minimum
4. As an alias for amin, it has identical mathematical properties","use vstd::prelude::*;

verus! {",,"fn min(a: Vec<i8>) -> (result: i8)
    requires a.len() > 0,
    ensures
        exists|i: int| 0 <= i < a@.len() && a@[i] == result as int,
        forall|i: int| 0 <= i < a@.len() ==> result as int <= a@[i],","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0590,verus,numpy_triple,statistics_nanmax,,"Returns the maximum value of all elements in a non-empty vector, ignoring NaN values.
When all elements are NaN, returns NaN.

Mathematical Properties:
- Ignores NaN values in the computation
- Returns the maximum of all non-NaN elements
- If all elements are NaN, returns NaN
- If at least one element is not NaN, returns the maximum non-NaN value
- For vectors with no NaN values, behaves identically to regular max

Specification: nanmax returns the maximum value in the vector, ignoring NaN values.

Mathematical properties:
1. If there exists at least one non-NaN element, the result is the maximum among non-NaN elements
2. If all elements are NaN, the result is NaN
3. The result is either a non-NaN element from the vector or NaN
4. For vectors without NaN values, nanmax behaves identically to regular max
5. NaN values are completely ignored during the maximum computation
6. Sanity check: result is either NaN or exists in the vector","use vstd::prelude::*;

verus! {",,"fn nanmax(a: Vec<i8>) -> (result: i8)
    requires a.len() > 0,
    ensures
        /* Case 1: If there exists at least one element, the result is from the vector */
        (exists|max_idx: int| 
            0 <= max_idx < a.len() &&
            result as int == a[max_idx] as int) &&
        /* Case 2: Result is maximum among all elements */
        (forall|j: int| 0 <= j < a.len() ==> a[j] as int <= result as int) &&
        /* Case 3: Result exists in the vector */
        (exists|witness: int| 0 <= witness < a.len() && result as int == a[witness] as int)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0591,verus,numpy_triple,statistics_nanmean,,"Compute the arithmetic mean along the specified axis, ignoring NaNs.
Returns the average of the array elements, ignoring NaN values.
If all values are NaN, returns NaN.

Specification: nanmean computes the arithmetic mean while ignoring NaN values.

Mathematical properties:
1. If vector contains valid (non-NaN) values, result is their arithmetic mean
2. If all values are NaN, result is NaN
3. Result is never NaN when valid values exist
4. NaN values are completely ignored in the computation
5. For vectors without NaN values, behaves identically to regular mean
6. The result is bounded by the minimum and maximum of non-NaN elements

/* Case 1: If there exists at least one non-NaN element, result is their arithmetic mean */

/* Case 2: If all elements are NaN, result is NaN */

/* Case 3: NaN values are ignored (result is mean of non-NaN elements) */

/* Case 4: For vectors without NaN, behaves like regular mean */","use vstd::prelude::*;

verus! {",,"spec fn is_nan_f32(x: f32) -> bool;

spec fn valid_indices_count(a: Seq<f32>) -> nat
    decreases a.len()
{
    if a.len() == 0 {
        0
    } else {
        if is_nan_f32(a[0]) {
            valid_indices_count(a.skip(1))
        } else {
            1 + valid_indices_count(a.skip(1))
        }
    }
}

spec fn has_valid_element(a: Seq<f32>) -> bool 
{
    valid_indices_count(a) > 0
}

spec fn all_nan(a: Seq<f32>) -> bool 
{
    valid_indices_count(a) == 0
}

spec fn contains_nan(a: Seq<f32>) -> bool
    decreases a.len()
{
    if a.len() == 0 {
        false
    } else {
        is_nan_f32(a[0]) || contains_nan(a.skip(1))
    }
}

fn nanmean(a: Vec<f32>) -> (result: f32)
    ensures 

        (has_valid_element(a@) ==> !is_nan_f32(result)) &&

        (all_nan(a@) ==> is_nan_f32(result)) &&

        (!is_nan_f32(result) ==> has_valid_element(a@)) &&

        (!contains_nan(a@) && a.len() > 0 ==> !is_nan_f32(result))","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0592,verus,numpy_triple,statistics_nanmedian,,"Compute the median along the specified axis, ignoring NaNs.
Returns the median of the array elements.
For a vector V of length N, the median is the middle value of a sorted copy of V
(ignoring NaN values), when N is odd, and the average of the two middle values when N is even.
If all values are NaN, returns NaN.","use vstd::prelude::*;

verus! {",,"spec fn all_nan(a: Seq<f32>) -> bool {
    forall|i: int| #![auto] 0 <= i < a.len() ==> (a[i] != a[i])
}

spec fn has_finite_value(a: Seq<f32>) -> bool {
    exists|i: int| #![auto] 0 <= i < a.len() && (a[i] == a[i])
}

fn nanmedian(a: Vec<f32>) -> (result: f32)
    ensures
        (all_nan(a@) ==> (result != result)) &&
        (has_finite_value(a@) ==> (result == result))","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0593,verus,numpy_triple,statistics_nanmin,,"Returns the minimum value of all elements in a non-empty vector, ignoring NaN values.
When all elements are NaN, returns NaN.

Mathematical Properties:
- Ignores NaN values in the computation
- Returns the minimum of all non-NaN elements
- If all elements are NaN, returns NaN
- If at least one element is not NaN, returns the minimum non-NaN value
- For vectors with no NaN values, behaves identically to regular min

Specification: nanmin returns the minimum value in the vector, ignoring NaN values.

Mathematical properties:
1. If there exists at least one non-NaN element, the result is the minimum among non-NaN elements
2. If all elements are NaN, the result is NaN
3. The result is either a non-NaN element from the vector or NaN
4. For vectors without NaN values, nanmin behaves identically to regular min
5. NaN values are completely ignored during the minimum computation
6. Sanity check: result is either NaN or exists in the vector","use vstd::prelude::*;

verus! {",,"spec fn all_nan(a: Seq<int>) -> bool 
    decreases a.len()
{
    false  /* integers can't be NaN */
}

spec fn has_non_nan(a: Seq<int>) -> bool 
    decreases a.len()
{
    a.len() > 0  /* all integers are non-NaN */
}

spec fn is_min_of_all(result: int, a: Seq<int>) -> bool {
    exists|witness: int| 0 <= witness < a.len() &&
        result == a[witness] &&
        forall|j: int| 0 <= j < a.len() ==> result <= a[j]
}

fn nanmin(a: Vec<i8>) -> (result: i8)
    requires a.len() > 0,
    ensures is_min_of_all(result as int, a@.map(|i, x: i8| x as int))","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0594,verus,numpy_triple,statistics_nanpercentile,,"Compute the q-th percentile of the data along the specified axis, ignoring NaN values.
Returns the q-th percentile of the array elements.
If all values are NaN, returns NaN.
The percentile q must be between 0 and 100 inclusive.

Specification: nanpercentile computes the q-th percentile of non-NaN values in the array.
The result is NaN if all values are NaN, otherwise it's the q-th percentile of the finite values.
The percentile is computed by sorting the non-NaN values and finding the value at the position
corresponding to the percentile q (between 0 and 100).","use vstd::prelude::*;

verus! {",,"spec fn vec_sum(a: Seq<i32>) -> int 
    decreases a.len()
{
    if a.len() == 0 {
        0
    } else {
        a[0] + vec_sum(a.skip(1))
    }
}

fn nanpercentile(a: Vec<i8>, q: i8) -> (result: i8)
    requires 0 <= q <= 100,
    ensures
        /* Case 1: Empty array returns 0 */
        a.len() == 0 ==> result == 0,
        /* Case 2: Non-empty array */
        a.len() > 0 ==> {
            /* Result is within bounds of input values */
            (forall|i: int| 0 <= i < a.len() ==> a[i] as int <= result as int || result as int <= a[i] as int) &&
            /* For single element, result equals that element */
            (a.len() == 1 ==> result == a[0])
        }","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0595,verus,numpy_triple,statistics_nanquantile,,"Compute the q-th quantile of the data in a vector, ignoring NaN values.
When all elements are NaN, returns NaN.

Mathematical Properties:
- Ignores NaN values in the computation
- Returns the q-th quantile of all non-NaN elements 
- If all elements are NaN, returns NaN
- If at least one element is not NaN, returns the quantile of non-NaN values
- For q=0, returns the minimum of non-NaN elements
- For q=1, returns the maximum of non-NaN elements
- For vectors with no NaN values, behaves identically to regular quantile

Specification: nanquantile returns the q-th quantile of non-NaN values in the vector.

Mathematical properties:
1. The quantile parameter q must be between 0 and 1 inclusive
2. If there exists at least one non-NaN element, the result is the q-th quantile among non-NaN elements
3. If all elements are NaN, the result is NaN
4. For q=0, result is the minimum of non-NaN elements
5. For q=1, result is the maximum of non-NaN elements
6. The result is bounded by the range of non-NaN elements
7. NaN values are completely ignored during the quantile computation
8. For vectors without NaN values, nanquantile behaves identically to regular quantile","use vstd::prelude::*;

verus! {",,"fn nanquantile(a: Vec<i8>, q: i8) -> (result: i8)
    requires 
        a.len() > 0,
        0 <= q <= 100,
    ensures
        /* Result is bounded by the elements */
        (forall|min_idx: int| 0 <= min_idx < a.len() ==> 
         (forall|j: int| 0 <= j < a.len() ==> a[min_idx] as int <= a[j] as int) ==> a[min_idx] as int <= result as int),
        (forall|max_idx: int| 0 <= max_idx < a.len() ==>
         (forall|j: int| 0 <= j < a.len() ==> a[j] as int <= a[max_idx] as int) ==> result as int <= a[max_idx] as int),
        /* For q=0, result is the minimum element */
        (q == 0) ==> 
            (forall|min_idx: int| 0 <= min_idx < a.len() ==>
             (forall|j: int| 0 <= j < a.len() ==> a[min_idx] as int <= a[j] as int) ==>
             result == a[min_idx]),
        /* For q=100, result is the maximum element */
        (q == 100) ==>
            (forall|max_idx: int| 0 <= max_idx < a.len() ==>
             (forall|j: int| 0 <= j < a.len() ==> a[j] as int <= a[max_idx] as int) ==>
             result == a[max_idx])","{
    // impl-start
    assume(false);
    0
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0596,verus,numpy_triple,statistics_nanstd,,"Compute the standard deviation along the specified axis, ignoring NaNs.
Returns the standard deviation, a measure of the spread of a distribution,
of the non-NaN array elements. The standard deviation is the square root
of the variance computed from non-NaN values.

For all-NaN slices, NaN is returned.

Specification: nanstd computes the standard deviation while ignoring NaN values.
Mathematical properties:
1. If vector contains valid (non-NaN) values and ddof < valid_count, 
   result is the square root of the variance of valid values
2. If all values are NaN, result is NaN
3. If ddof >= valid_count, result is NaN
4. Result is always non-negative when valid

The standard deviation is computed as:
1. Filter out NaN values to get valid values
2. Calculate the mean of valid values
3. Calculate squared deviations from the mean for valid values
4. Sum the squared deviations
5. Divide by (valid_count - ddof)
6. Take the square root of the result","use vstd::prelude::*;

verus! {",,"spec fn count_valid_values(a: Seq<i32>) -> int {
    a.filter(|x: i32| x != 0).len() as int
}

spec fn sum_valid_values(a: Seq<i32>) -> int 
    decreases a.len()
{
    if a.len() == 0 {
        0
    } else {
        let x = a[0];
        if x == 0 {
            sum_valid_values(a.skip(1))
        } else {
            x + sum_valid_values(a.skip(1))
        }
    }
}

spec fn mean_of_valid(a: Seq<i32>) -> int {
    let valid_count = count_valid_values(a);
    if valid_count > 0 {
        sum_valid_values(a) / valid_count
    } else {
        0
    }
}

spec fn sum_squared_deviations_spec(a: Seq<i32>, mean: int) -> int 
    decreases a.len()
{
    if a.len() == 0 {
        0
    } else {
        let x = a[0];
        if x == 0 {
            sum_squared_deviations_spec(a.skip(1), mean)
        } else {
            let deviation = x - mean;
            deviation * deviation + sum_squared_deviations_spec(a.skip(1), mean)
        }
    }
}

spec fn variance_of_valid(a: Seq<i32>, ddof: int) -> int {
    let valid_count = count_valid_values(a);
    if valid_count > 0 && ddof < valid_count {
        let mean = mean_of_valid(a);
        let sum_squared_deviations = sum_squared_deviations_spec(a, mean);
        sum_squared_deviations / (valid_count - ddof)
    } else {
        0
    }
}

fn nanstd(a: Vec<i32>, ddof: usize) -> (result: i32)
    ensures ({
        let valid_count = count_valid_values(a@);
        let ddof_int = ddof as int;
        if valid_count > 0 && ddof_int < valid_count {
            let variance = variance_of_valid(a@, ddof_int);
            result >= 0
        } else {
            result == 0
        }
    })","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0597,verus,numpy_triple,statistics_nanvar,,"Compute the variance along the specified axis, while ignoring NaNs.
Uses the formula: sum((x - mean)²) / (n - ddof) for non-NaN elements.
Returns NaN if all elements are NaN or if degrees of freedom <= 0.

Specification for nanvar: Computes variance while ignoring NaN values.
Mathematical properties:
1. If vector contains valid (non-NaN) values and ddof < valid_count, 
   result is the variance of valid values
2. If all values are NaN, result is NaN
3. If ddof >= valid_count, result is NaN
4. Result is always non-negative when valid

The variance is computed as:
1. Filter out NaN values to get valid values
2. Calculate the mean of valid values
3. Calculate squared deviations from the mean for valid values
4. Sum the squared deviations
5. Divide by (valid_count - ddof)","use vstd::prelude::*;

verus! {",,"fn nanvar(a: Vec<f32>, ddof: usize) -> (result: f32)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0598,verus,numpy_triple,statistics_percentile,,"Compute the q-th percentile of the data in a vector.
For a sorted vector, the q-th percentile is the value below which q percent of the data falls.
This implementation focuses on the fundamental mathematical definition of percentiles.

Specification: percentile computes the q-th percentile value correctly.
The percentile is defined as the value v such that at least q% of the data
is less than or equal to v, and at least (100-q)% of the data is greater than or equal to v.

Mathematical properties:
1. The percentile value must be within the range of the data (or interpolated between values)
2. Special cases: q=0 gives minimum, q=100 gives maximum
3. The result is bounded by the minimum and maximum values in the array","use vstd::prelude::*;

verus! {",,"fn percentile(arr: Vec<i8>, q: i8) -> (result: i8)
    requires 
        arr.len() > 0,
        0 <= q && q <= 100,
    ensures
        (forall|i: int| 0 <= i < arr.len() ==> arr[i] as int <= result as int ==> 
            exists|j: int| 0 <= j < arr.len() && arr[j] as int >= result as int) &&
        (forall|i: int| 0 <= i < arr.len() ==> arr[i] as int >= result as int ==> 
            exists|j: int| 0 <= j < arr.len() && arr[j] as int <= result as int) &&
        (q == 0 ==> forall|i: int| 0 <= i < arr.len() ==> result as int <= arr[i] as int) &&
        (q == 100 ==> forall|i: int| 0 <= i < arr.len() ==> arr[i] as int <= result as int)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0599,verus,numpy_triple,statistics_quantile,,"Compute the q-th quantile of the data in a vector

Specification: quantile returns a value that has the property that 
approximately q proportion of the data is less than or equal to it","use vstd::prelude::*;

verus! {",,"fn quantile(a: Vec<i8>, q: i8) -> (result: i8)
    requires 
        a.len() > 0,
        0 <= q && q <= 100,
    ensures
        /* The result is within the range of the input data */
        (exists|i: int| 0 <= i < a.len() && a[i] as i8 <= result) &&
        (exists|i: int| 0 <= i < a.len() && result <= a[i] as i8) &&
        /* For 0-quantile, result should be <= minimum */
        (q == 0 ==> forall|i: int| 0 <= i < a.len() ==> result <= a[i] as i8) &&
        /* For 100-quantile, result should be >= maximum */
        (q == 100 ==> forall|i: int| 0 <= i < a.len() ==> a[i] as i8 <= result)","{
    // impl-start
    assume(false);
    0
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0600,verus,numpy_triple,statistics_std,,"numpy.std: Compute the standard deviation along the specified axis.

Returns the standard deviation, a measure of the spread of a distribution,
of the array elements. The standard deviation is computed for the flattened
array by default, otherwise over the specified axis.

The standard deviation is the square root of the average of the squared
deviations from the mean: std = sqrt(mean((x - x.mean())**2)).

With ddof parameter, the divisor used in calculations is N - ddof,
where N represents the number of elements. The ""Delta Degrees of Freedom""
parameter adjusts the divisor in the standard deviation calculation.

Specification: numpy.std returns the standard deviation of all elements.

The standard deviation is computed as the square root of the variance:
std = sqrt(sum((x_i - mean)²) / (N - ddof))

Key properties:
1. ddof must be less than the number of elements to avoid division by zero
2. The result is always non-negative (square root of non-negative variance)
3. When ddof = 0, uses population standard deviation (divide by N)
4. When ddof = 1, uses sample standard deviation (divide by N-1)
5. Mathematical correctness: the formula exactly matches NumPy's implementation","use vstd::prelude::*;

verus! {",,"fn numpy_std(a: Vec<f32>, ddof: u8) -> (result: f32)
    requires 
        a.len() > 0,
        (ddof as usize) < a.len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0601,verus,numpy_triple,statistics_var,,"Compute the variance of the elements in a vector with specified delta degrees of freedom.
The variance is the average of the squared deviations from the mean.

Specification: var computes the variance as the average of squared deviations from the mean,
divided by (n + 1 - ddof). The variance measures the spread of a distribution.

Mathematical properties:
1. The result is always non-negative
2. The variance is zero if and only if all elements are equal
3. The computation requires ddof < n + 1 to ensure a positive divisor
4. The variance equals the expected value of squared deviations from the mean
5. Translation invariance: var(a + c) = var(a) for any constant c
6. Scaling property: var(c * a) = c^2 * var(a) for any constant c

The variance formula implemented is:
var = (1/(n+1-ddof)) * sum_{i=0}^{n} (a[i] - mean)^2
where mean = (1/(n+1)) * sum_{i=0}^{n} a[i]

This specification captures both the mathematical definition of variance
and its key properties. When ddof=0, this gives the population variance;
when ddof=1, this gives the sample variance (unbiased estimator).","use vstd::prelude::*;

verus! {",,"spec fn vec_sum(a: Seq<int>) -> int 
    decreases a.len()
{
    if a.len() == 0 {
        0
    } else {
        a[0] + vec_sum(a.skip(1))
    }
}

spec fn vec_mean(a: Seq<int>) -> int 
{
    vec_sum(a) / (a.len() as int)
}

spec fn squared_deviations_sum(a: Seq<int>, mean: int) -> int 
    decreases a.len()
{
    if a.len() == 0 {
        0
    } else {
        (a[0] - mean) * (a[0] - mean) + squared_deviations_sum(a.skip(1), mean)
    }
}

fn var(a: Vec<i8>, ddof: usize) -> (result: i8)
    requires 
        a.len() > 0,
        ddof < a.len(),
    ensures 
        result >= 0,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0603,verus,numpy_triple,strings_capitalize,,Return a copy of a with only the first character of each element capitalized,"use vstd::prelude::*;

verus! {",,"fn capitalize(a: Vec<String>) -> (result: Vec<String>)
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < a.len() ==> #[trigger] result[i]@.len() == a[i]@.len()","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0604,verus,numpy_triple,strings_center,,"Return a copy of a with its elements centered in a string of length width.

Centers strings in a field of given width with optional fill character.
If the original string length is greater than or equal to the target width,
the original string is returned unchanged. Otherwise, the string is padded
symmetrically with the fill character to reach the target width.

From NumPy documentation:
- Parameters: a (array_like with StringDType), width (array_like with integer dtype), 
              fillchar (optional, default ' ') - The padding character
- Returns: out (ndarray) - Output array with centered strings

Mathematical Properties:
1. Length preservation: If original.length >= width, return original unchanged
2. Symmetric padding: If original.length < width, pad equally on both sides
3. Padding balance: Left and right padding differ by at most 1 character
4. Character preservation: Original string appears as substring in result
5. Width compliance: Result length equals max(original.length, width)","use vstd::prelude::*;

verus! {",,"fn center(a: Vec<String>, width: Vec<usize>, fillchar: char) -> (result: Vec<String>)
    requires 
        a.len() == width.len(),
    ensures 
        result.len() == a.len(),
        forall|i: int| 0 <= i < result.len() ==> 
            #[trigger] result[i]@.len() >= 0 && {
                let orig_len = a[i]@.len() as int;
                let target_width = width[i] as int;
                &&& (orig_len >= target_width ==> result[i] == a[i])
                &&& result[i]@.len() as int == if orig_len >= target_width { orig_len } else { target_width }
            }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0605,verus,numpy_triple,strings_count,,"numpy.strings.count: Returns an array with the number of non-overlapping occurrences 
of substring sub in the range [start, end] for each element.

For each string in the input array, counts how many times the substring appears
without overlapping matches within the specified range. The search is performed
within the range [start, end) where start and end are character indices.

Specification: numpy.strings.count returns the number of non-overlapping occurrences 
of substring within the specified range for each element.

Preconditions:
- start ≤ end for all elements (valid range)
- start and end indices are valid (within string bounds)
- substring is not empty for all elements (to avoid infinite loops)

Postconditions:
- Result is non-negative for all elements
- For each element, the count represents non-overlapping occurrences of substring
- If substring is longer than search range, count is 0
- The count is maximal (greedy non-overlapping matching)","use vstd::prelude::*;

verus! {",,"fn count(a: Vec<String>, sub: Vec<String>, start: Vec<i8>, end_pos: Vec<i8>) -> (result: Vec<i8>)
    requires 
        a.len() == sub.len(),
        a.len() == start.len(),
        a.len() == end_pos.len(),
        forall|i: int| 0 <= i < a.len() ==> start[i] as int <= end_pos[i] as int,
        forall|i: int| 0 <= i < a.len() ==> 0 <= start[i] as int && start[i] as int <= a[i]@.len(),
        forall|i: int| 0 <= i < a.len() ==> 0 <= end_pos[i] as int && end_pos[i] as int <= a[i]@.len(),
        forall|i: int| 0 <= i < a.len() ==> sub[i]@.len() > 0,
    ensures 
        result.len() == a.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] as int >= 0,
        forall|i: int| 0 <= i < result.len() ==> 
            (sub[i]@.len() > (end_pos[i] as int - start[i] as int) ==> result[i] as int == 0)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0606,verus,numpy_triple,strings_decode,,"numpy.strings.decode: Decode byte strings using the codec

Calls bytes.decode element-wise on a vector of byte strings.
Converts bytes to strings using the specified encoding.

This function takes a vector of byte strings and returns a vector
of decoded strings. The decoding process depends on the encoding
parameter, with UTF-8 being the default.

Specification: numpy.strings.decode returns a vector where each element is the decoded string
from the corresponding byte array in the input vector.

Mathematical Properties:
1. Element-wise decoding: result[i] = decode(a[i]) for all i
2. Deterministic behavior: same input produces same output
3. Empty byte arrays decode to empty strings
4. Identity property: decoding is consistent with the specified encoding
5. Length preservation: decoding preserves structural properties
6. Error handling: behavior depends on error mode when invalid sequences are encountered

Precondition: ByteArray elements are well-formed
Postcondition: Each element is the decoded string using the specified encoding with proper error handling","use vstd::prelude::*;

verus! {",,"fn decode(a: Vec<Vec<u8>>, encoding: &str, errors: &str) -> (result: Vec<String>)
    requires 
        encoding == ""utf-8"" || encoding == ""ascii"",
        errors == ""strict"" || errors == ""ignore"" || errors == ""replace"",
        forall|i: int| 0 <= i < a.len() as int ==> a[i]@.len() >= 0,
    ensures
        result.len() as int == a.len() as int,
        forall|i: int| 0 <= i < a.len() as int ==> (
            /* Basic well-formedness: decoded strings are valid */
            result[i]@.len() >= 0 &&
            
            /* Deterministic behavior: identical inputs produce identical outputs */
            (forall|j: int| 0 <= j < a.len() as int && a[i]@ == a[j]@ ==> result[i]@ == result[j]@) &&
            
            /* Empty byte arrays decode to empty strings */
            (a[i]@.len() == 0 ==> result[i]@.len() == 0) &&
            
            /* Identity property: encoding then decoding with same parameters is identity for valid strings */
            (encoding == ""utf-8"" ==> true) &&
            
            /* Error handling consistency: strict mode fails on invalid sequences */
            (errors == ""strict"" ==> true) &&
            
            /* Length relationship: non-empty valid byte arrays produce strings */
            (a[i]@.len() > 0 && encoding == ""utf-8"" ==> (
                result[i]@.len() > 0 || errors != ""strict""
            ))
        )","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0607,verus,numpy_triple,strings_encode,,"numpy.strings.encode: Encode strings using the codec

Calls str.encode element-wise on a vector of strings.
Converts strings to byte arrays using the specified encoding.

This function takes a vector of strings and returns a vector
of encoded byte arrays. The encoding process depends on the encoding
parameter, with UTF-8 being the default.

Specification: numpy.strings.encode returns a vector where each element is the encoded byte array
from the corresponding string in the input vector.

Key properties:
1. Deterministic encoding: same input produces same output
2. Empty strings encode to empty byte arrays
3. Encoding preserves string order and length
4. For UTF-8 encoding, ASCII characters are preserved with same byte length","use vstd::prelude::*;

verus! {",,"fn encode(a: Vec<Vec<char>>, encoding: Vec<char>, errors: Vec<char>) -> (result: Vec<Vec<u8>>)
    ensures
        result@.len() == a@.len(),
        /* Deterministic encoding: same input produces same output */
        forall|i: int, j: int| 0 <= i < a@.len() && 0 <= j < a@.len() && a@[i] == a@[j] ==> result@[i] == result@[j],
        /* Empty strings encode to empty byte arrays */
        forall|i: int| 0 <= i < a@.len() && a@[i].len() == 0 ==> result@[i].len() == 0,
        /* Non-empty strings produce non-empty byte arrays */
        forall|i: int| 0 <= i < a@.len() && a@[i].len() > 0 ==> result@[i].len() > 0,
        /* For UTF-8 encoding, encoded size is at least the string length */
        forall|i: int| 0 <= i < a@.len() ==> result@[i].len() >= a@[i].len(),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0608,verus,numpy_triple,strings_endswith,,"Check if strings in array end with given suffixes

Specification: endswith returns boolean array indicating which strings end with corresponding suffixes","use vstd::prelude::*;

verus! {",,"spec fn string_ends_with(s: Seq<char>, suffix: Seq<char>) -> bool {
    if suffix.len() > s.len() {
        false
    } else {
        s.subrange(s.len() - suffix.len(), s.len() as int) == suffix
    }
}

fn endswith(a: Vec<String>, suffix: Vec<String>) -> (result: Vec<bool>)
    requires a.len() == suffix.len(),
    ensures 
        result.len() == a.len(),
        forall|i: int| 0 <= i < a.len() ==> {
            /* Main specification: result matches string_ends_with for each pair */
            result[i] == string_ends_with(a[i]@, suffix[i]@) &&
            /* Mathematical property: if result is true, suffix appears at the end */
            (result[i] ==> {
                suffix[i]@.len() <= a[i]@.len() &&
                a[i]@.subrange(a[i]@.len() - suffix[i]@.len(), a[i]@.len() as int) == suffix[i]@
            }) &&
            /* Mathematical property: if result is false, suffix does not appear at the end */
            (!result[i] ==> {
                suffix[i]@.len() > a[i]@.len() ||
                a[i]@.subrange(a[i]@.len() - suffix[i]@.len(), a[i]@.len() as int) != suffix[i]@
            })
        }","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0609,verus,numpy_triple,strings_equal,,"numpy.strings.equal: Return (x1 == x2) element-wise for string arrays.

Performs element-wise string comparison between two vectors of strings.
Returns a boolean vector indicating whether corresponding strings are equal.

This function compares strings lexicographically and returns True for each
position where the strings are identical, False otherwise.

Specification: numpy.strings.equal returns element-wise equality comparison.

Precondition: True (no special preconditions for string equality)
Postcondition: For all indices i, result[i] = (x1[i] == x2[i])

Mathematical Properties:
- Core property: Each element of result is the boolean comparison of corresponding strings
- Equivalence: result[i] is true if and only if x1[i] equals x2[i]
- Reflexivity: If input vectors are identical, all result elements are true
- Type-safe: Result vector has same length as input vectors","use vstd::prelude::*;

verus! {",,"fn equal(x1: Vec<String>, x2: Vec<String>) -> (result: Vec<bool>)
    requires x1.len() == x2.len(),
    ensures
        result.len() == x1.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i as int] == (x1[i as int] == x2[i as int]),
        forall|i: int| 0 <= i < result.len() ==> (result[i as int] == true <==> x1[i as int] == x2[i as int]),
        x1@ == x2@ ==> forall|i: int| 0 <= i < result.len() ==> result[i as int] == true,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0610,verus,numpy_triple,strings_expandtabs,,"Return a copy of each string element where all tab characters are replaced by spaces

Expand tabs in strings to spaces with configurable tab size

Specification: expandtabs replaces tab characters with appropriate number of spaces

/* Core property: result contains no tab characters */

/* Identity property: strings without tabs remain unchanged */

/* Length property: result is at least as long as original */

/* Tab expansion property: tabs are replaced by 1 to tab_sz spaces */","use vstd::prelude::*;

verus! {",,"fn expandtabs(a: Vec<String>, tabsize: Vec<u8>) -> (result: Vec<String>)
    requires 
        a.len() == tabsize.len(),
        forall|i: int| 0 <= i < tabsize.len() ==> #[trigger] tabsize[i] > 0,
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < result.len() ==> {
            let orig_str = #[trigger] &a[i];
            let result_str = &result[i];
            let tab_sz = tabsize[i] as nat;

            (forall|c: char| #[trigger] result_str@.contains(c) ==> c != '\t') &&

            (!orig_str@.contains('\t') ==> result_str@ == orig_str@) &&

            (result_str@.len() >= orig_str@.len()) &&

            (orig_str@.contains('\t') ==> result_str@.len() > orig_str@.len())
        }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0611,verus,numpy_triple,strings_find,,"For each element, return the lowest index in the string where substring sub is found, such that sub is contained in the range [start, end]. Returns -1 if sub is not found.

// Case 1: substring not found (returns -1)

// Case 2: substring found (returns non-negative index)

// Empty substring found at start position

// Substring longer than remaining string cannot be found

// If start > end, no substring can be found","use vstd::prelude::*;

verus! {",,"spec fn find_substring_at(haystack: Seq<char>, needle: Seq<char>, pos: int) -> bool {
    pos >= 0 && pos + needle.len() <= haystack.len() &&
    haystack.subrange(pos, pos + needle.len()) == needle
}

fn find(a: Vec<String>, sub: Vec<String>, start: Vec<i32>, end_pos: Vec<i32>) -> (result: Vec<i32>)
    requires 
        a.len() == sub.len() && 
        sub.len() == start.len() && 
        start.len() == end_pos.len(),
        forall|i: int| 0 <= i < a.len() ==> 
            0 <= start[i] && 
            start[i] <= end_pos[i] && 
            end_pos[i] < a[i]@.len(),
    ensures 
        result.len() == a.len(),
        forall|i: int| 0 <= i < result.len() ==> {

            (result[i] == -1 <==> 
                forall|pos: int| start[i] as int <= pos && pos <= end_pos[i] as int && pos + sub[i]@.len() <= a[i]@.len() ==>
                    !find_substring_at(a[i]@, sub[i]@, pos)) &&

            (result[i] >= 0 ==> 
                start[i] as int <= result[i] as int && 
                result[i] as int <= end_pos[i] as int &&
                result[i] as int + sub[i]@.len() <= a[i]@.len() &&
                find_substring_at(a[i]@, sub[i]@, result[i] as int) &&
                forall|pos: int| start[i] as int <= pos && pos < result[i] as int ==> 
                    !find_substring_at(a[i]@, sub[i]@, pos)) &&

            (sub[i]@.len() == 0 ==> result[i] == start[i]) &&

            (start[i] as int + sub[i]@.len() > a[i]@.len() ==> result[i] == -1) &&

            (start[i] > end_pos[i] ==> result[i] == -1)
        }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0612,verus,numpy_triple,strings_greater,,"numpy.strings.greater: Return the truth value of (x1 > x2) element-wise for string arrays.

Performs element-wise string comparison between two vectors of strings.
Returns a boolean vector indicating whether corresponding strings from x1 
are lexicographically greater than corresponding strings from x2.

This function compares strings lexicographically and returns True for each
position where x1[i] > x2[i] in lexicographic ordering, False otherwise.

Specification: numpy.strings.greater returns element-wise lexicographic comparison.

Precondition: True (no special preconditions for string comparison)
Postcondition: For all indices i, result[i] = (x1[i] > x2[i])

Mathematical Properties:
- Asymmetric: if greater x1 x2 is True at position i, then greater x2 x1 is False at position i
- Transitive: if greater x1 x2 and greater x2 x3 are both True at position i, then greater x1 x3 is True at position i
- Irreflexive: greater x x returns all False (no string is greater than itself)
- Trichotomous: for any two strings s1 and s2, exactly one of s1 < s2, s1 = s2, or s1 > s2 holds
- Decidable: String comparison is decidable for all strings
- Type-safe: Result vector has same length as input vectors

/* Core property: result[i] = (x1[i] > x2[i]) for all indices */

/* Asymmetry: if x1[i] > x2[i], then NOT (x2[i] > x1[i]) */

/* Irreflexivity: no string is greater than itself */","use vstd::prelude::*;
use vstd::string::*;

verus! {",,"spec fn string_compare_gt(s1: Seq<char>, s2: Seq<char>) -> bool {
    true  // placeholder implementation
}

fn greater(x1: &Vec<String>, x2: &Vec<String>) -> (result: Vec<bool>)
    requires x1.len() == x2.len(),
    ensures 
        result.len() == x1.len(),

        forall|i: int| 0 <= i < result.len() as int ==> 
            result[i] == string_compare_gt(x1[i]@, x2[i]@),

        forall|i: int| 0 <= i < result.len() as int ==> 
            result[i] ==> !string_compare_gt(x2[i]@, x1[i]@),

        forall|i: int| 0 <= i < result.len() as int ==> 
            (x1[i]@ == x2[i]@) ==> (result[i] == false),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0613,verus,numpy_triple,strings_greater_equal,,"numpy.strings.greater_equal: Return the truth value of (x1 >= x2) element-wise for string arrays.

Performs element-wise string comparison between two vectors of strings.
Returns a boolean vector indicating whether each string in x1 is greater than or equal 
to the corresponding string in x2 using lexicographic ordering.

This function compares strings lexicographically and returns True for each
position where x1[i] >= x2[i], False otherwise.

Examples:
- greater_equal [""apple"", ""banana""] [""apple"", ""banana""] = [true, true]
- greater_equal [""zebra"", ""apple""] [""apple"", ""banana""] = [true, false]
- greater_equal [""a"", ""bb""] [""aa"", ""b""] = [false, true]

Specification: numpy.strings.greater_equal returns element-wise greater-than-or-equal comparison.

This specification captures the mathematical properties of lexicographic string comparison:

1. Core Property: Each position compares strings lexicographically
2. Reflexive Property: Every string is >= itself
3. Antisymmetric Property: If s1 >= s2 and s2 >= s1, then s1 = s2
4. Transitive Property: If s1 >= s2 and s2 >= s3, then s1 >= s3
5. Total Ordering: For any two strings, either s1 >= s2 or s2 >= s1 (or both)
6. Consistency: Result is deterministic for same inputs

Precondition: True (no special preconditions for string comparison)
Postcondition: Element-wise lexicographic greater-than-or-equal comparison","use vstd::prelude::*;

verus! {",,"spec fn string_lex_ge(s1: Seq<char>, s2: Seq<char>) -> bool
    decreases s1.len() + s2.len()
{
    if s1.len() == 0 {
        true
    } else if s2.len() == 0 {
        true
    } else if s1[0] == s2[0] {
        string_lex_ge(s1.skip(1), s2.skip(1))
    } else {
        s1[0] >= s2[0]
    }
}

fn greater_equal(x1: Vec<String>, x2: Vec<String>) -> (result: Vec<bool>)
    requires x1.len() == x2.len(),
    ensures 
        result.len() == x1.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] == string_lex_ge(x1[i]@, x2[i]@),
        /* Reflexive property: every string is >= itself */
        forall|i: int| 0 <= i < result.len() && x1[i] == x2[i] ==> result[i] == true,
        /* Empty string properties */
        forall|i: int| 0 <= i < result.len() && x1[i]@ == Seq::<char>::empty() && x2[i]@ == Seq::<char>::empty() ==> result[i] == true,
        forall|i: int| 0 <= i < result.len() && x1[i]@ != Seq::<char>::empty() && x2[i]@ == Seq::<char>::empty() ==> result[i] == true,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0614,verus,numpy_triple,strings_index,,"Like find, but raises ValueError when the substring is not found. For each element, return the lowest index in the string where substring is found. Unlike find, this function requires that the substring be found in each string, ensuring all results are non-negative indices. Specification: index returns the lowest index where substring is found within range. The key difference from find is that index has a stronger precondition: the substring must exist in each string within the specified range.","use vstd::prelude::*;

verus! {",,"fn index(a: Vec<Seq<char>>, sub: Vec<Seq<char>>, start: Vec<i8>, end_pos: Vec<i8>) -> (result: Vec<i8>)
    requires 
        a.len() == sub.len() && sub.len() == start.len() && start.len() == end_pos.len(),
        forall|i: int| 0 <= i < a.len() ==> {
            &&& start[i] as int >= 0 
            &&& start[i] as int <= end_pos[i] as int
            &&& end_pos[i] as int <= a[i].len() as int
            &&& sub[i].len() > 0
        },
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < result.len() ==> {
            &&& result[i] as int >= 0
            &&& start[i] as int <= result[i] as int <= end_pos[i] as int
            &&& result[i] as int + sub[i].len() as int <= a[i].len() as int
        }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0615,verus,numpy_triple,strings_isalnum,,"Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise.

For each string in the input vector, this function checks if:
1. The string is non-empty (has at least one character)
2. All characters in the string are alphanumeric (letters or digits)

Returns a boolean vector where True indicates the string meets both criteria,
and False indicates the string is either empty or contains non-alphanumeric characters.

This follows the Python str.isalnum() behavior which returns False for empty strings
and True only if all characters are alphanumeric.","use vstd::prelude::*;

verus! {",,"spec fn is_alphanumeric_char(c: char) -> bool;

spec fn all_chars_alphanumeric(s: Seq<char>) -> bool
    decreases s.len()
{
    if s.len() == 0 {
        true
    } else {
        is_alphanumeric_char(s[0]) && all_chars_alphanumeric(s.skip(1))
    }
}

fn isalnum(a: Vec<String>) -> (result: Vec<bool>)
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < a.len() ==> 
            result[i] == (a[i]@.len() > 0 && all_chars_alphanumeric(a[i]@))","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0616,verus,numpy_triple,strings_isalpha,,"numpy.strings.isalpha: Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise.

Tests whether all characters in each string are alphabetic letters.
A string is considered alphabetic if:
1. It contains at least one character
2. All characters are alphabetic (a-z, A-Z)

Empty strings return false.
Strings with numbers, symbols, or whitespace return false.

Specification: numpy.strings.isalpha returns a vector where each element indicates
whether the corresponding string element contains only alphabetic characters
and has at least one character.

Key properties:
1. Empty strings always return false
2. Non-empty strings return true iff all characters are alphabetic
3. Alphabetic characters are those satisfying Char.isAlpha (a-z, A-Z)
4. Strings with digits, whitespace, or symbols return false
5. The function is applied element-wise to each string in the vector

Mathematical properties:
- Monotonicity: removing non-alphabetic characters from a string cannot make isalpha false
- Compositionality: isalpha(s) = (s.length > 0) ∧ (∀ c ∈ s, Char.isAlpha c)
- Deterministic: same input always produces same output","use vstd::prelude::*;

verus! {",,"spec fn is_alpha_char(c: char) -> bool {
    ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')
}

spec fn all_chars_alpha(s: Seq<char>) -> bool 
    decreases s.len()
{
    if s.len() == 0 {
        true
    } else {
        is_alpha_char(s[0]) && all_chars_alpha(s.skip(1))
    }
}

fn isalpha(a: Vec<String>) -> (result: Vec<bool>)
    ensures 
        result.len() == a.len(),
        forall|i: int| 0 <= i < a.len() ==> 
            result[i as int] == (a[i as int]@.len() > 0 && all_chars_alpha(a[i as int]@)),
        forall|i: int| 0 <= i < a.len() ==> 
            (a[i as int]@.len() == 0 ==> result[i as int] == false),
        forall|i: int| 0 <= i < a.len() ==> 
            (a[i as int]@.len() > 0 ==> (result[i as int] <==> all_chars_alpha(a[i as int]@))),
        forall|i: int| 0 <= i < a.len() ==> 
            (result[i as int] == true ==> a[i as int]@.len() > 0),
        forall|i: int| 0 <= i < a.len() ==> 
            (result[i as int] == true ==> all_chars_alpha(a[i as int]@))","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0617,verus,numpy_triple,strings_isdecimal,,"For each element, return True if there are only decimal characters in the element.

For each element, return True if there are only decimal characters in the element

Specification: isdecimal returns True for each element if all characters in the string 
are decimal characters (including digit characters and all characters that can be used 
to form decimal-radix numbers), and False otherwise.

A decimal character is one that can be used to form decimal-radix numbers. This includes:
- ASCII digits (0-9)  
- Unicode decimal characters (e.g., Arabic-Indic digits like U+0660)
- Does NOT include superscript/subscript digits or other numeric characters

Note: For simplicity, we use c.isDigit which covers decimal characters in most practical cases.

Key properties:
- Empty strings return False
- Strings with only decimal characters return True
- Strings with non-decimal characters return False
- Mixed decimal/non-decimal characters return False","use vstd::prelude::*;

verus! {",,"spec fn is_decimal_char(c: char) -> bool {
    ('0' <= c && c <= '9')
}

spec fn all_chars_decimal(s: Seq<char>) -> bool
    decreases s.len()
{
    if s.len() == 0 {
        true
    } else {
        is_decimal_char(s[0]) && all_chars_decimal(s.skip(1))
    }
}

fn isdecimal(a: Vec<String>) -> (result: Vec<bool>)
    ensures 
        result.len() == a.len(),
        forall|i: int| 0 <= i < a.len() ==> {
            &&& (result[i] == true <==> (a[i]@.len() > 0 && all_chars_decimal(a[i]@)))
            &&& (a[i]@ == Seq::<char>::empty() ==> result[i] == false)
        }","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0618,verus,numpy_triple,strings_isdigit,,"Returns true for each element if all characters in the string are digits, and there is at least one character, false otherwise

numpy.strings.isdigit: Returns true for each element if all characters in the string are digits, and there is at least one character, false otherwise.

Tests whether all characters in each string are digits.
A string is considered to satisfy isdigit if:
1. It contains at least one character (non-empty)
2. All characters are digits (0-9)

Empty strings return false.
Strings with any non-digit characters return false.
Strings with only digits return true.

This follows the Python str.isdigit() behavior which returns False for empty strings
and True only if all characters are numeric digits.

Specification: numpy.strings.isdigit returns a vector where each element indicates
whether the corresponding string element contains only digits and is non-empty.

Precondition: True (no special preconditions)
Postcondition: For all indices i, result[i] = true if and only if:
1. The string a[i] is non-empty (not equal to empty string)
2. All characters in a[i] are digits (satisfy Char.isDigit)

Properties:
- Empty strings return False
- Strings with only numeric characters (0-9) return True
- Strings with any non-numeric characters return False
- Single digit characters return True","use vstd::prelude::*;

verus! {",,"spec fn all_chars_digit(s: Seq<char>) -> bool;

fn isdigit(a: Vec<String>) -> (result: Vec<bool>)
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < a.len() ==> result[i as int] == (a[i as int]@.len() > 0 && all_chars_digit(a[i as int]@))","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0619,verus,numpy_triple,strings_islower,,"numpy.strings.islower: Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise.

Tests whether all cased characters in each string are lowercase.
A string is considered to satisfy islower if:
1. It contains at least one cased character (letters that have uppercase/lowercase versions)
2. All cased characters are lowercase
3. Non-cased characters (numbers, symbols, whitespace) are ignored for the check

Examples:
- Empty string """" → false (no cased characters)
- ""123"" → false (no cased characters)
- ""abc"" → true (all lowercase, has cased characters)
- ""ABC"" → false (has uppercase)
- ""aBc"" → false (has uppercase)
- ""abc123"" → true (has lowercase, no uppercase)
- ""   "" → false (no cased characters)

Specification: numpy.strings.islower returns a vector where each element indicates
whether the corresponding string element has all cased characters in lowercase
and contains at least one cased character.

Mathematical Properties:
1. A string is considered ""islower"" if it has at least one cased character AND
   all cased characters are lowercase
2. Empty strings return false (no cased characters)
3. Strings with only non-cased characters (digits, symbols, whitespace) return false
4. Strings with any uppercase letters return false
5. Strings with at least one lowercase letter and no uppercase letters return true

Edge Cases:
- Empty string: false (no cased characters)
- ""123"": false (no cased characters) 
- ""abc"": true (all lowercase, has cased characters)
- ""ABC"": false (has uppercase)
- ""aBc"": false (has uppercase)
- ""abc123"": true (has lowercase, no uppercase)
- ""   "": false (no cased characters)","use vstd::prelude::*;

verus! {",,"spec fn is_alpha_char(c: char) -> bool {
    ('a' <= c <= 'z') || ('A' <= c <= 'Z')
}

spec fn is_lower_char(c: char) -> bool {
    'a' <= c <= 'z'
}

spec fn string_has_cased_char(s: Seq<char>) -> bool {
    exists|i: int| 0 <= i < s.len() && is_alpha_char(s[i])
}

spec fn string_all_cased_are_lowercase(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() && is_alpha_char(s[i]) ==> is_lower_char(s[i])
}

fn islower(a: Vec<String>) -> (result: Vec<bool>)
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < result.len() ==> 
            result[i as int] == (string_has_cased_char(a[i]@) && string_all_cased_are_lowercase(a[i]@))","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0621,verus,numpy_triple,strings_isspace,,"Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise

numpy.strings.isspace: Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise.

Tests whether all characters in each string are whitespace characters.
A string is considered whitespace if:
1. It contains at least one character (non-empty)
2. All characters are whitespace (space, tab, newline, form feed, carriage return, etc.)

Behavior:
- Empty strings return false
- Strings with only whitespace characters return true
- Strings with any non-whitespace character return false

Examples:
- "" "" (single space) → true
- ""\t"" (tab) → true  
- ""\n"" (newline) → true
- ""  \t\n  "" (mixed whitespace) → true
- """" (empty string) → false
- ""a"" (letter) → false
- "" a "" (space + letter + space) → false

Specification: numpy.strings.isspace returns a vector where each element indicates
whether the corresponding string element contains only whitespace characters
and has at least one character.

The function performs element-wise whitespace checking with the following properties:
1. Empty strings always return false
2. Strings with only whitespace characters return true
3. Strings with any non-whitespace character return false
4. Common whitespace characters include: space, tab, newline, carriage return, etc.

Precondition: True (no special preconditions)
Postcondition: For all indices i, result[i] = true if and only if:
1. The string a[i] is non-empty
2. All characters in a[i] are whitespace characters","use vstd::prelude::*;

verus! {",,"spec fn is_whitespace_char(c: char) -> bool {
    c == ' ' || c == '\t' || c == '\n' || c == '\r' || c == '\x0c'
}

spec fn all_chars_whitespace(s: Seq<char>) -> bool 
    decreases s.len()
{
    if s.len() == 0 {
        true
    } else {
        is_whitespace_char(s[0]) && all_chars_whitespace(s.skip(1))
    }
}

fn isspace(a: Vec<String>) -> (result: Vec<bool>)
    ensures 
        result.len() == a.len(),
        forall|i: int| 0 <= i < a.len() ==> 
            result[i] == (a[i]@.len() > 0 && all_chars_whitespace(a[i]@)),
        forall|i: int| 0 <= i < a.len() ==> 
            (a[i]@.len() == 0 ==> result[i] == false),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0622,verus,numpy_triple,strings_istitle,,"numpy.strings.istitle: Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise.

A string is considered titlecased if:
1. It contains at least one character
2. Each word starts with an uppercase letter followed by lowercase letters
3. Words are separated by non-alphabetic characters
4. There is at least one cased character in the string

Examples:
- ""Title Case"" → True
- ""Numpy Is Great"" → True  
- ""numpy is great"" → False
- ""NUMPY IS GREAT"" → False
- """" → False
- ""123"" → False

/* Helper function to check if a string is titlecased according to Python's str.istitle() logic */","use vstd::prelude::*;

verus! {

spec fn is_titlecased(s: Seq<char>) -> bool;",,"fn istitle(a: Vec<String>) -> (result: Vec<bool>)
    ensures 
        result.len() == a.len(),
        forall|i: int| 0 <= i < a.len() ==> result[i] == is_titlecased(a[i]@)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0623,verus,numpy_triple,strings_isupper,,"Checks if all cased characters in each string are uppercase and there is at least one character.

Specification: isupper returns true for each element if all cased characters 
in the string are uppercase and there is at least one character, false otherwise.
Mathematical properties:
1. Empty strings return false
2. Strings with no cased characters return false  
3. Strings with mixed case return false
4. Strings with all cased characters uppercase return true","use vstd::prelude::*;

verus! {",,"spec fn is_alpha_char(c: char) -> bool;

spec fn is_upper_char(c: char) -> bool;

spec fn has_alpha_chars(s: Seq<char>) -> bool {
    exists|i: int| 0 <= i < s.len() && is_alpha_char(s[i])
}

spec fn all_alpha_are_upper(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() && is_alpha_char(s[i]) ==> is_upper_char(s[i])
}

fn isupper(a: Vec<String>) -> (result: Vec<bool>)
    ensures 
        result.len() == a.len(),
        forall|i: int| 0 <= i < a.len() ==> #[trigger] result[i] == {
            let s = a[i]@;
            s.len() > 0 && has_alpha_chars(s) && all_alpha_are_upper(s)
        }","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0625,verus,numpy_triple,strings_less,,"numpy.strings.less: Return the truth value of (x1 < x2) element-wise for string arrays.

Performs element-wise string comparison between two vectors of strings.
Returns a boolean vector indicating whether corresponding strings from x1 
are lexicographically less than corresponding strings from x2.

This function compares strings lexicographically and returns True for each
position where x1[i] < x2[i] in lexicographic ordering, False otherwise.

Specification: numpy.strings.less returns element-wise lexicographic comparison.

This function performs element-wise lexicographic comparison between two vectors
of strings, returning a boolean vector where each element indicates whether
the corresponding element in x1 is lexicographically less than the corresponding
element in x2.

Precondition: True (no special preconditions for string comparison)
Postcondition: For all indices i, result[i] = (x1[i] < x2[i])

Mathematical Properties:
- Asymmetric: if less x1 x2 is True at position i, then less x2 x1 is False at position i
- Transitive: if less x1 x2 and less x2 x3 are both True at position i, then less x1 x3 is True at position i
- Irreflexive: less x x returns all False (no string is less than itself)
- Trichotomous: for any two strings s1 and s2, exactly one of s1 < s2, s1 = s2, or s1 > s2 holds
- Decidable: String comparison is decidable for all strings
- Type-safe: Result vector has same length as input vectors

String Comparison Properties:
- Empty string is less than any non-empty string
- Lexicographic ordering follows dictionary order (case-sensitive)
- Comparison is based on Unicode code point values
- Preserves strict ordering properties of the underlying string type

/* Core property: result[i] = (x1[i] < x2[i]) for all indices */

/* Asymmetry: if x1[i] < x2[i], then NOT (x2[i] < x1[i]) */

/* Irreflexivity: no string is less than itself */

/* Decidability: result is always boolean (true or false) */

/* Strict ordering: if result[i] is true, then x1[i] and x2[i] are different */

/* Totality of comparison: for any two strings, exactly one of <, =, > holds */","use vstd::prelude::*;
use vstd::string::*;

verus! {",,"spec fn str_less_than(s1: String, s2: String) -> bool;

fn less(x1: &Vec<String>, x2: &Vec<String>) -> (result: Vec<bool>)
    requires x1@.len() == x2@.len(),
    ensures 
        result@.len() == x1@.len(),

        forall|i: int| 0 <= i < result@.len() ==> result@[i] == str_less_than(x1@[i], x2@[i]),

        forall|i: int| 0 <= i < result@.len() && result@[i] == true ==> !str_less_than(x2@[i], x1@[i]),

        forall|i: int| 0 <= i < result@.len() && x1@[i] == x2@[i] ==> result@[i] == false,

        forall|i: int| 0 <= i < result@.len() ==> result@[i] == true || result@[i] == false,

        forall|i: int| 0 <= i < result@.len() && result@[i] == true ==> x1@[i] != x2@[i],

        forall|i: int| 0 <= i < result@.len() ==> result@[i] == true || x1@[i] == x2@[i] || str_less_than(x2@[i], x1@[i])","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0626,verus,numpy_triple,strings_less_equal,,"numpy.strings.less_equal: Return the truth value of (x1 <= x2) element-wise for string arrays.

Performs element-wise string comparison between two vectors of strings.
Returns a boolean vector indicating whether each string in x1 is lexicographically 
less than or equal to the corresponding string in x2.

This function compares strings lexicographically and returns True for each
position where x1[i] <= x2[i], False otherwise.","use vstd::prelude::*;

verus! {",,"spec fn string_le(s1: String, s2: String) -> bool;

fn less_equal(x1: Vec<String>, x2: Vec<String>) -> (result: Vec<bool>)
    requires x1@.len() == x2@.len(),
    ensures 
        result@.len() == x1@.len(),
        forall|i: int| 0 <= i < result@.len() ==> result@[i] == string_le(x1@[i], x2@[i]),
        forall|i: int| 0 <= i < result@.len() ==> (result@[i] == true <==> string_le(x1@[i], x2@[i])),
        x1@ == x2@ ==> forall|i: int| 0 <= i < result@.len() ==> result@[i] == true,
        forall|i: int| 0 <= i < result@.len() ==> (string_le(x1@[i], x2@[i]) && string_le(x2@[i], x1@[i])) ==> x1@[i] == x2@[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0627,verus,numpy_triple,strings_ljust,,"numpy.strings.ljust: Return an array with the elements left-justified in a string of length width.

Left-justifies each string in the input array by padding it with the specified
fill character (default is space) to reach the specified width. If the original
string is longer than or equal to the width, it remains unchanged.

Parameters:
- a: Input array of strings
- width: Target width for each string
- fillchar: Character to use for padding (must be exactly one character)

Returns:
- Array where each string is left-justified to the specified width

Specification: ljust returns a vector where each string is left-justified
to the specified width using the given fill character.

Mathematical Properties:
- Length preservation: Result length is max(original_length, width)
- Identity: Strings already >= width remain unchanged
- Left-justification: Original content preserved as prefix, padding on right
- Minimality: No unnecessary padding beyond required width
- Fillchar constraint: Padding uses specified fill character","use vstd::prelude::*;

verus! {",,"fn ljust(a: Vec<String>, width: u8, fillchar: char) -> (result: Vec<String>)
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < a.len() ==> #[trigger] result[i]@.len() == if a[i]@.len() >= width as nat { a[i]@.len() } else { width as nat },
        forall|i: int| 0 <= i < a.len() && a[i]@.len() >= width as nat ==> #[trigger] result[i]@ == a[i]@,
        forall|i: int| 0 <= i < a.len() && a[i]@.len() < width as nat ==> {
            &&& #[trigger] result[i]@.len() == width as nat
            &&& result[i]@.subrange(0, a[i]@.len() as int) == a[i]@
        },
        forall|i: int| 0 <= i < a.len() && a[i]@.len() == 0 ==> #[trigger] result[i]@.len() == width as nat","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0628,verus,numpy_triple,strings_lower,,"numpy.strings.lower: Return an array with the elements converted to lowercase.

Converts each string element in the input vector to lowercase. This transformation
applies to all alphabetic characters while preserving non-alphabetic characters
(digits, punctuation, whitespace) unchanged.

The function preserves the shape of the input array and handles empty strings
appropriately by returning them unchanged.

From NumPy documentation:
- Parameters: a (array_like) - Input array with string dtype
- Returns: out (ndarray) - Output array with elements converted to lowercase

Mathematical Properties:
1. Element-wise transformation: result[i] = lower(a[i]) for all i
2. Length preservation: result[i].length = a[i].length for all i
3. Case transformation: uppercase letters become lowercase, others unchanged
4. Idempotent: lower(lower(x)) = lower(x)
5. Preserves vector length: result.size = a.size","use vstd::prelude::*;

verus! {",,"spec fn char_to_lower(c: char) -> char;

spec fn string_to_lower(s: Seq<char>) -> Seq<char>
    decreases s.len()
{
    if s.len() == 0 {
        seq![]
    } else {
        seq![char_to_lower(s[0])] + string_to_lower(s.skip(1))
    }
}

fn lower(a: Vec<Vec<char>>) -> (result: Vec<Vec<char>>)
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < a.len() ==> #[trigger] result[i]@ == string_to_lower(a[i]@),
        forall|i: int| 0 <= i < a.len() ==> result[i].len() == a[i].len(),
        forall|i: int| 0 <= i < a.len() ==> (a[i].len() == 0 ==> result[i].len() == 0),
        forall|i: int| 0 <= i < a.len() ==> string_to_lower(result[i]@) == result[i]@,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0629,verus,numpy_triple,strings_lstrip,,"numpy.strings.lstrip: For each element in a vector, return a copy with the leading characters removed.

Removes leading characters from each string element in the input vector. The behavior
depends on the chars parameter:
- If chars is None, whitespace characters are removed from the beginning
- If chars is provided, any combination of those characters is removed from the beginning

The function preserves the shape of the input array and handles empty strings
appropriately by returning them unchanged.

From NumPy documentation:
- Parameters: a (array_like) - Input array with string dtype
              chars (optional) - Characters to remove from the beginning
- Returns: out (ndarray) - Output array with leading characters removed

Mathematical Properties:
1. Element-wise transformation: result[i] = lstrip(a[i], chars) for all i
2. Length preservation or reduction: result[i].length ≤ a[i].length for all i
3. Prefix removal: result[i] is a suffix of a[i] for all i
4. Character set removal: only characters in chars are removed from the beginning
5. Preserves vector length: result.size = a.size

/* Length preservation or reduction */

/* Suffix property: result is a suffix of original */

/* Empty string case: if original is empty, result is empty */","use vstd::prelude::*;

verus! {",,"fn lstrip(a: Vec<String>, chars: Option<String>) -> (result: Vec<String>)
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < result.len() as int ==> {
            let original = #[trigger] a[i];
            let result_str = #[trigger] result[i];

            result_str@.len() <= original@.len() &&

            (exists|k: int| 0 <= k <= original@.len() as int && 
             result_str@ == original@.subrange(k, original@.len() as int)) &&

            (original@.len() == 0 ==> result_str@.len() == 0)
        }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0630,verus,numpy_triple,strings_mod,,"numpy.strings.mod: Return (a % i), that is pre-Python 2.6 string formatting 
(interpolation), element-wise for a pair of array_likes of string objects.

This function performs string formatting element-wise on vectors of format strings 
and replacement values. Each element of the result is the formatted string obtained 
by interpolating the corresponding value into the format string.

This is equivalent to Python's old-style string formatting using the % operator 
for each element pair. The function handles various format specifiers like %s, %i, 
%f, etc., and produces appropriately formatted strings.

From NumPy documentation:
- Parameters: a (array_like) - Format strings with placeholders
              values (array_like) - Values to interpolate into format strings
- Returns: out (ndarray) - The formatted strings, element-wise

Mathematical Properties:
1. Element-wise formatting: result[i] = format(a[i], values[i])
2. Preserves vector length: result.size = a.size = values.size
3. Format correctness: each result follows the format specification
4. Type preservation: maintains string type characteristics
5. Handles various format specifiers: %s, %i, %f, %d, etc.

Specification: numpy.strings.mod returns a vector where each element is the 
result of formatting the corresponding format string with its value.

Mathematical Properties:
1. Identity Property: Format strings without % specifiers remain unchanged
2. Substitution Property: Format strings with % specifiers get interpolated
3. Empty String Property: Empty format strings produce empty results
4. Non-empty Preservation: Non-empty format strings with specifiers produce non-empty results
5. Length Monotonicity: Result length is non-negative and preserves structural properties
6. Format Preservation: The result maintains the original format structure with substitutions

Key format specifiers handled:
- %s: String representation
- %i, %d: Integer formatting
- %f: Floating point formatting
- %x, %X: Hexadecimal formatting
- And other standard format specifiers

Precondition: True (function handles format string validation internally)
Postcondition: For all indices i, result[i] represents the formatted string
              where format string a[i] is applied to value values[i], satisfying
              the mathematical properties of string formatting operations","use vstd::prelude::*;

verus! {",,"fn mod_func(a: Vec<String>, values: Vec<String>) -> (result: Vec<String>)
    requires a.len() == values.len(),
    ensures 
        result.len() == a.len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0631,verus,numpy_triple,strings_multiply,,"Return (a * i), that is string multiple concatenation, element-wise.
Values in i of less than 0 are treated as 0 (which yields an empty string).

Specification: multiply performs element-wise string repetition.
Each output string is the corresponding input string repeated the specified number of times.
Negative repetition counts produce empty strings. This comprehensive specification
captures the core mathematical properties of string multiplication in NumPy.","use vstd::prelude::*;

verus! {
spec fn repeat_string_spec(s: Seq<char>, n: int) -> Seq<char> 
    decreases (if n <= 0 { 0 } else { n }) as nat
{
    if n <= 0 {
        Seq::<char>::empty()
    } else if n == 1 {
        s
    } else {
        s + repeat_string_spec(s, n - 1)
    }
}",,"fn multiply(a: Vec<String>, i: Vec<i32>) -> (result: Vec<String>)
    requires a.len() == i.len(),
    ensures 
        result.len() == a.len(),
        /* Core property: Element-wise string repetition */
        forall|j: int| 0 <= j < a.len() ==> 
            result[j]@ == repeat_string_spec(a[j]@, i[j] as int),
        /* Zero/negative repetition property: Always yields empty string */
        forall|j: int| 0 <= j < a.len() && i[j] <= 0 ==> 
            result[j]@ == Seq::<char>::empty(),
        /* Identity property: Multiplying by 1 yields the original string */
        forall|j: int| 0 <= j < a.len() && i[j] == 1 ==> 
            result[j] == a[j],
        /* Zero property: Multiplying by 0 yields empty string */
        forall|j: int| 0 <= j < a.len() && i[j] == 0 ==> 
            result[j]@ == Seq::<char>::empty(),
        /* Empty string property: Empty strings remain empty regardless of repetition */
        forall|j: int| 0 <= j < a.len() && a[j]@ == Seq::<char>::empty() ==> 
            result[j]@ == Seq::<char>::empty(),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,0.7
VT0632,verus,numpy_triple,strings_not_equal,,"numpy.strings.not_equal: Return (x1 != x2) element-wise for string arrays.

Performs element-wise string inequality comparison between two vectors of strings.
Returns a boolean vector indicating whether corresponding strings are not equal.

This function compares strings lexicographically and returns True for each
position where the strings are different, False where they are identical.

Specification: numpy.strings.not_equal returns element-wise inequality comparison.

Precondition: True (no special preconditions for string inequality)
Postcondition: For all indices i, result[i] = (x1[i] != x2[i])

Mathematical Properties:
- Irreflexive: not_equal x x returns all False
- Symmetric: not_equal x y = not_equal y x  
- Negation of equality: not_equal x y = ¬(equal x y)
- Decidable: String inequality is decidable for all strings
- Type-safe: Result vector has same length as input vectors
- Complementary: for any two strings s1 and s2, exactly one of (s1 = s2) or (s1 ≠ s2) holds","use vstd::prelude::*;

verus! {",,"fn not_equal(x1: Vec<String>, x2: Vec<String>) -> (result: Vec<bool>)
    requires x1.len() == x2.len(),
    ensures 
        result.len() == x1.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] == (x1[i] != x2[i])","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0633,verus,numpy_triple,strings_partition,,"numpy.strings.partition: Partition each element in a around sep.

Partitions each string in the input vector at the first occurrence of the separator.
Returns a 3-tuple of vectors: (before_separator, separator, after_separator).

For each element in the input array, splits the element at the first occurrence
of the separator, and returns three vectors containing the part before the separator,
the separator itself, and the part after the separator. If the separator is not found,
the first vector contains the whole string, and the second and third vectors contain
empty strings.

From NumPy documentation:
- Parameters: a (array_like with StringDType), sep (array_like with StringDType)
- Returns: 3-tuple of ndarrays with StringDType

Mathematical Properties:
1. Partition semantics: For each string s, if sep occurs at position i, then:
   - before = s[0:i]
   - separator = sep (if found) or """" (if not found)
   - after = s[i+len(sep):] (if found) or """" (if not found)
2. Completeness: before ++ separator ++ after = original string (when sep is found)
3. First occurrence: Only splits at the first occurrence of sep
4. Not found case: If sep not in string, returns (original_string, """", """")
5. Preserves vector length: All three result vectors have the same length as input

Specification: numpy.strings.partition returns a 3-tuple of vectors where each
element is partitioned around the first occurrence of the separator.

Mathematical Properties:
1. Partition correctness: For each index i, the result satisfies partition semantics
2. Completeness: When separator is found, concatenation reconstructs original string
3. First occurrence: Only the first occurrence of separator is used for partitioning
4. Not found case: When separator is not found, returns (original, """", """")
5. Preserves vector length: All result vectors have the same length as input
6. Separator consistency: The separator part contains the actual separator or empty string

Precondition: True (no special preconditions for string partitioning)
Postcondition: For all indices i, the partition satisfies the partition semantics

/* Fundamental partition property: parts reconstruct original string */

/* Separator correctness: either the separator or empty string */

/* Case 2: Separator not found - before contains whole string, others empty */

/* Length preservation: total length is preserved */","use vstd::prelude::*;

verus! {",,"fn partition(a: Vec<String>, sep: String) -> (result: (Vec<String>, Vec<String>, Vec<String>))
    ensures
        result.0.len() == a.len() && result.1.len() == a.len() && result.2.len() == a.len(),
        forall|i: int| 0 <= i < a.len() as int ==> {
            let original = #[trigger] a[i]@;
            let before_i = result.0[i]@;
            let sep_i = result.1[i]@;
            let after_i = result.2[i]@;

            before_i + sep_i + after_i == original &&

            (sep_i == sep@ || sep_i.len() == 0) &&

            (sep_i.len() == 0 ==> after_i.len() == 0 && before_i == original) &&

            original.len() == before_i.len() + sep_i.len() + after_i.len()
        }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0634,verus,numpy_triple,strings_replace,,"numpy.strings.replace: For each element in a, return a copy of the string with 
occurrences of substring old replaced by new.

Replaces occurrences of the substring 'old' with 'new' in each string element.
The replacement is done from left to right, and if count is specified, only
the first 'count' occurrences are replaced. If count is -1 or negative,
all occurrences are replaced.

Specification for numpy.strings.replace: Returns a vector where each element is the
result of replacing occurrences of old substring with new substring.

Mathematical Properties:
1. Element-wise replacement: Each result element is the original string with replacements
2. Count limiting: If count[i] >= 0, at most count[i] replacements are made
3. Complete replacement: If count[i] < 0, all occurrences are replaced
4. Identity preservation: If old[i] doesn't occur in a[i], result[i] = a[i]
5. Zero count behavior: If count[i] = 0, no replacements occur

/* Zero count behavior: if count is 0, no replacements occur */

/* Identity property: if old doesn't occur in string, result equals original */","use vstd::prelude::*;

verus! {",,"fn replace(a: Vec<String>, old: Vec<String>, new: Vec<String>, count: Vec<i32>) -> (result: Vec<String>)
    requires 
        a.len() == old.len() && old.len() == new.len() && new.len() == count.len(),
        forall|i: int| 0 <= i < count.len() ==> (count[i] == 0 || old[i]@.len() > 0),
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < result.len() ==> {

            (count[i] == 0 ==> result[i] == a[i]) &&

            (old[i]@.len() == 0 ==> result[i] == a[i])
        },","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0635,verus,numpy_triple,strings_rfind,,"For each element, return the highest index in the string where substring is found, such that sub is contained within [start, end]. Returns -1 if sub is not found.","use vstd::prelude::*;

verus! {",,"spec fn string_starts_with(s: Seq<char>, prefix: Seq<char>, start_pos: int) -> bool {
    start_pos >= 0 && start_pos + prefix.len() <= s.len() &&
    forall|i: int| 0 <= i < prefix.len() ==> s[start_pos + i] == prefix[i]
}

fn rfind(a: Vec<String>, sub: Vec<String>, start: Vec<i32>, end_pos: Vec<i32>) -> (result: Vec<i32>)
    requires 
        a.len() == sub.len() && sub.len() == start.len() && start.len() == end_pos.len(),
        forall|i: int| 0 <= i < start.len() ==> 0 <= start[i] && start[i] <= end_pos[i],
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < result.len() ==> (
            /* Basic range constraint: result is -1 or within string bounds */
            (result[i] == -1 || (0 <= result[i] && result[i] < a[i]@.len())) &&
            /* If result is -1, no occurrence of substring within the specified range */
            (result[i] == -1 ==> 
                forall|j: int| start[i] <= j && j + sub[i]@.len() <= end_pos[i] + 1 && 
                               j + sub[i]@.len() <= a[i]@.len() ==> 
                    !string_starts_with(a[i]@, sub[i]@, j)) &&
            /* If result is non-negative, it's the rightmost valid occurrence */
            (result[i] >= 0 ==> 
                /* The result is within the search range */
                start[i] <= result[i] && 
                result[i] + sub[i]@.len() <= end_pos[i] + 1 &&
                /* The substring matches at this position */
                string_starts_with(a[i]@, sub[i]@, result[i] as int) &&
                /* This is the rightmost occurrence within the range */
                (forall|j: int| result[i] < j && j + sub[i]@.len() <= end_pos[i] + 1 && 
                                start[i] <= j && j + sub[i]@.len() <= a[i]@.len() ==> 
                    !string_starts_with(a[i]@, sub[i]@, j)))
        ),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0636,verus,numpy_triple,strings_rindex,,"numpy.strings.rindex - String information
Like rfind, but raises ValueError when the substring is not found

For each element, return the highest index in the string where substring is found.
Unlike rfind, this function requires that the substring be found in each string,
ensuring all results are non-negative indices.

Specification: rindex returns the highest index where substring is found within range.
The key difference from rfind is that rindex has a stronger precondition:
the substring must exist in each string within the specified range.","use vstd::prelude::*;

verus! {",,"fn rindex(a: Vec<String>, sub: Vec<String>, start: Vec<u8>, end_pos: Vec<u8>) -> (result: Vec<u8>)
    requires 
        a.len() == sub.len() && sub.len() == start.len() && start.len() == end_pos.len(),
        forall|i: int| 0 <= i < a.len() ==> {
            start[i] as nat <= end_pos[i] as nat &&
            end_pos[i] as nat <= 1000 &&
            start[i] as nat <= end_pos[i] as nat
        },
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < result.len() ==> {
            start[i] as nat <= result[i] as nat && 
            result[i] as nat <= end_pos[i] as nat
        }","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0637,verus,numpy_triple,strings_rjust,,"Return an array with the elements of a right-justified in a string of length width.

Right-justifies each string in the input array by padding it with the specified
fill character (default is space) to reach the specified width. If the original
string is longer than or equal to the width, it remains unchanged.

Parameters:
- a: Input array of strings
- width: Target width for each string
- fillchar: Character to use for padding (must be exactly one character)

Returns:
- Array where each string is right-justified to the specified width

Mathematical Properties:
1. Length preservation: If original.length >= width, return original unchanged
2. Right-justification: If original.length < width, pad on the left with fillchar
3. Padding placement: Original string appears as suffix in the result
4. Character preservation: Original string appears as contiguous substring
5. Width compliance: Result length equals max(original.length, width)","use vstd::prelude::*;

verus! {

spec fn max_nat(a: nat, b: nat) -> nat {
    if a >= b { a } else { b }
}

spec fn is_suffix_of<T>(suffix: Seq<T>, full: Seq<T>) -> bool {
    suffix.len() <= full.len() && 
    full.subrange(full.len() - suffix.len(), full.len() as int) == suffix
}",,"fn rjust(orig: Vec<char>, width: u8, fillchar: char) -> (res: Vec<char>)
    ensures
        res.len() == max_nat(orig.len() as nat, width as nat),
        (orig.len() >= width as usize ==> res@ == orig@) &&
        (orig.len() < width as usize ==> res.len() == width as usize && is_suffix_of(orig@, res@)) &&
        (orig.len() >= width as usize ==> res.len() == orig.len()) &&
        (orig.len() < width as usize ==> res.len() == width as usize) &&
        (orig.len() == 0 ==> res.len() == width as usize)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0638,verus,numpy_triple,strings_rpartition,,"numpy.strings.rpartition: Partition each element in a around the right-most separator.

Partitions each string in the input vector at the last occurrence of the separator.
Returns a 3-tuple of vectors: (before_separator, separator, after_separator).

For each element in the input array, splits the element at the last occurrence
of the separator, and returns three vectors containing the part before the separator,
the separator itself, and the part after the separator. If the separator is not found,
the third vector contains the whole string, and the first and second vectors contain
empty strings.

From NumPy documentation:
- Parameters: a (array_like with StringDType), sep (array_like with StringDType)
- Returns: 3-tuple of ndarrays with StringDType

Mathematical Properties:
1. Right partition semantics: For each string s, if sep occurs at position i (rightmost), then:
   - before = s[0:i]
   - separator = sep (if found) or """" (if not found)
   - after = s[i+len(sep):] (if found) or """" (if not found)
2. Completeness: before ++ separator ++ after = original string (when sep is found)
3. Last occurrence: Only splits at the last occurrence of sep
4. Not found case: If sep not in string, returns ("""", """", original_string)
5. Preserves vector length: All three result vectors have the same length as input","use vstd::prelude::*;

verus! {",,"fn rpartition(a: Vec<String>, sep: String) -> (result: (Vec<String>, Vec<String>, Vec<String>))
    requires true,
    ensures 
        result.0.len() == a.len(),
        result.1.len() == a.len(),
        result.2.len() == a.len()","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0639,verus,numpy_triple,strings_rsplit,,"For each element in a vector, return a list of the words in the string, using sep as the delimiter string.
Splits from the right, meaning that splits are made from the right side of the string.

Specification: rsplit splits each string in the vector from the right using the given separator.
The resulting vector contains lists of strings where each list represents the split parts
of the corresponding input string.","use vstd::prelude::*;

verus! {",,"fn rsplit(a: Vec<String>, sep: String, maxsplit: u8) -> (result: Vec<Vec<String>>)
    requires 
        sep@.len() > 0,
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i].len() > 0,
        maxsplit as int == 0 ==> forall|i: int| 0 <= i < result.len() ==> 
            result[i].len() == 1 && result[i][0]@ == a[i]@,
        forall|i: int| 0 <= i < result.len() ==> result[i].len() <= maxsplit as int + 1,
        forall|i: int| 0 <= i < result.len() ==> 
            (a[i]@.len() == 0 ==> result[i].len() == 1 && result[i][0]@.len() == 0),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,DupVT02,0.85
VT0640,verus,numpy_triple,strings_rstrip,,"For each element in a vector, return a copy with the trailing characters removed.

Specification: numpy.strings.rstrip removes trailing characters from each string in the vector.

rstrip removes trailing characters from the end of each string. If chars is None, 
whitespace characters are removed. If chars is provided, any combination of those 
characters is removed from the end.

Mathematical Properties:
1. Element-wise transformation: Each string is processed independently
2. Trailing character removal: Only characters at the end are removed
3. Maximal stripping: Remove as many trailing characters as possible
4. Character set filtering: Only characters in the specified set are removed
5. Whitespace default: When chars is None, whitespace characters are removed

From NumPy documentation:
- Parameters: a (array_like) - Input array with string dtype
              chars (optional) - Characters to remove, whitespace if None
- Returns: out (ndarray) - Output array with trailing characters removed","use vstd::prelude::*;

verus! {",,"fn rstrip(a: Vec<String>, chars: Option<String>) -> (result: Vec<String>)
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < a.len() ==> #[trigger] result[i]@.len() <= a[i]@.len()","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0641,verus,numpy_triple,strings_split,,"For each element in a vector of strings, return a list of the words in the string, using sep as the delimiter string.
Specification: split returns a vector where each string is split into a list of substrings based on the separator, with proper handling of maxsplit constraints and reconstruction properties.","use vstd::prelude::*;

verus! {",,"fn split(a: Vec<String>, sep: String, maxsplit: Option<usize>) -> (result: Vec<Vec<String>>)
    requires
        sep@ != Seq::<char>::empty(),
        a.len() > 0,
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < result.len() as int ==> {
            let parts = #[trigger] result[i]@;
            let original = #[trigger] a[i]@;
            (forall|j: int| 0 <= j < parts.len() as int ==> parts[j]@ != sep@) &&
            (match maxsplit {
                None => true,
                Some(limit) => parts.len() <= limit + 1,
            }) &&
            parts.len() >= 1 &&
            (original.len() == 0 ==> parts.len() == 1 && parts[0]@.len() == 0) &&
            (original == sep@ ==> parts.len() == 2 && parts[0]@.len() == 0 && parts[1]@.len() == 0)
        },","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,DupVT02,0.85
VT0642,verus,numpy_triple,strings_splitlines,,"For each element in a, return a list of the lines in the element, breaking at line boundaries

For each element in a vector of strings, return a list of the lines in the element, breaking at line boundaries 

Specification: splitlines returns a vector where each string is split into a list of lines
based on line boundaries, with proper handling of keepends and line break characters","use vstd::prelude::*;

verus! {",,"fn splitlines(a: Vec<String>, keepends: bool) -> (result: Vec<Vec<String>>)
    requires a@.len() > 0,
    ensures 
        result@.len() == a@.len(),
        forall|i: int| 0 <= i < result@.len() ==> #[trigger] result@[i]@.len() >= 1","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0643,verus,numpy_triple,strings_startswith,,"Check if strings in array start with given prefixes

Specification: startswith returns boolean array indicating which strings start with corresponding prefixes","use vstd::prelude::*;
use vstd::string::*;

verus! {
spec fn string_starts_with(s: Seq<char>, prefix: Seq<char>) -> bool {
    prefix.len() <= s.len() && s.subrange(0, prefix.len() as int) == prefix
}",,"fn startswith(a: Vec<String>, prefixes: Vec<String>) -> (result: Vec<bool>)
    requires a.len() == prefixes.len(),
    ensures 
        result.len() == a.len(),
        forall|i: int| 0 <= i < a.len() ==> {
            &&& (result[i] == string_starts_with(a[i]@, prefixes[i]@))
            &&& (result[i] ==> prefixes[i]@.len() <= a[i]@.len())
            &&& (result[i] ==> a[i]@.subrange(0, prefixes[i]@.len() as int) == prefixes[i]@)
            &&& (!result[i] ==> (prefixes[i]@.len() > a[i]@.len() || a[i]@.subrange(0, prefixes[i]@.len() as int) != prefixes[i]@))
        }","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0644,verus,numpy_triple,strings_str_len,,"Returns the length of each string element in the vector.
For Unicode strings, this counts the number of Unicode code points.

Specification: str_len returns the length (number of Unicode code points) of each string element.

Preconditions: None (str_len is defined for all strings)

Postconditions:
- The result vector has the same size as the input vector
- Each element in the result corresponds to the length of the corresponding input string
- Length is always non-negative (natural number)
- Empty strings have length 0
- Length is measured in Unicode code points for Unicode strings","use vstd::prelude::*;

verus! {",,"fn str_len(a: Vec<String>) -> (result: Vec<u8>)
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < a.len() ==> {
            &&& result[i] as nat == a[i]@.len()
            &&& result[i] as nat >= 0
            &&& (a[i]@.len() == 0 <==> a[i]@ == Seq::<char>::empty())
        }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0645,verus,numpy_triple,strings_strip,,"numpy.strings.strip: For each element in a vector, return a copy with the leading and trailing characters removed.

Removes both leading and trailing characters from each string element in the input vector.
This is a combination of lstrip and rstrip operations. The behavior depends on the chars parameter:
- If chars is None, whitespace characters are removed from both ends
- If chars is provided, any combination of those characters is removed from both ends

The function preserves the shape of the input array and handles empty strings
appropriately by returning them unchanged.

From NumPy documentation:
- Parameters: a (array_like) - Input array with string dtype
              chars (optional) - Characters to remove from both ends
- Returns: out (ndarray) - Output array with leading and trailing characters removed

Mathematical Properties:
1. Element-wise transformation: result[i] = strip(a[i], chars) for all i
2. Length preservation or reduction: result[i].length ≤ a[i].length for all i
3. Substring property: result[i] is a substring of a[i] for all i
4. Character set removal: only characters in chars are removed from both ends
5. Preserves vector length: result.size = a.size
6. Combination of lstrip and rstrip: strip(s) = rstrip(lstrip(s))","use vstd::prelude::*;

verus! {",,"fn strip(a: Vec<String>, chars: Option<String>) -> (result: Vec<String>)
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < a.len() as int ==> {
            #[trigger] result[i]@.len() <= a[i]@.len() &&
            (a[i]@.len() == 0 ==> result[i]@.len() == 0)
        }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0646,verus,numpy_triple,strings_swapcase,,"Return element-wise a copy of the string with uppercase characters converted to lowercase and vice versa

Return element-wise a copy of the string with uppercase characters converted to lowercase and vice versa

Specification: numpy.strings.swapcase returns a vector where each string element
has its case swapped (uppercase becomes lowercase and vice versa).

Mathematical Properties:
1. Element-wise correctness: Each element has its alphabetic characters case-swapped
2. Length preservation: Each transformed string has the same length as the original
3. Case transformation: Uppercase→lowercase, lowercase→uppercase, non-alpha unchanged
4. Involutive property: swapcase(swapcase(x)) = x
5. Empty string handling: Empty strings remain empty
6. Character-level correctness: Each character is correctly transformed

Precondition: True (no special preconditions for case swapping)
Postcondition: For all indices i, result[i] is the case-swapped version of a[i]","use vstd::prelude::*;

verus! {",,"spec fn char_swapcase(c: char) -> char;

spec fn string_swapcase(s: Seq<char>) -> Seq<char>
    decreases s.len()
{
    if s.len() == 0 {
        Seq::<char>::empty()
    } else {
        seq![char_swapcase(s[0])] + string_swapcase(s.skip(1))
    }
}

fn swapcase(a: Vec<String>) -> (result: Vec<String>)
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < a.len() ==> result[i]@.len() == a[i]@.len(),
        forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a[i]@.len() ==> 
            #[trigger] result[i]@[j] == char_swapcase(a[i]@[j])","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0648,verus,numpy_triple,strings_translate,,"numpy.strings.translate: For each element in a, return a copy of the string where 
all characters occurring in deletechars are removed, and the remaining characters 
have been mapped through the given translation table.

This function performs character-level transformation on byte strings by first
removing characters specified in deletechars, then translating each remaining
character using a 256-byte translation table.

Specification for numpy.strings.translate: Returns a vector where each element is 
the result of character deletion followed by character translation.

Mathematical Properties:
1. Element-wise transformation: Each result element is derived from the corresponding input
2. Two-stage process: First deletion, then translation
3. Deletion completeness: All occurrences of characters in deletechars are removed
4. Translation mapping: Each remaining byte is mapped through the translation table
5. Order preservation: Relative order of non-deleted characters is maintained
6. Empty string handling: Empty strings remain empty after transformation

// Length property: result length <= original length (due to deletion)

// Deletion property: no character from deletechars appears in result

// Translation property: each byte in result comes from table translation

// The original character existed in input and wasn't deleted

// Completeness property: all non-deleted characters are translated and included  

// Identity on empty deletechars

// Empty string preservation","use vstd::prelude::*;

verus! {",,"fn translate(a: Vec<Vec<u8>>, table: Vec<u8>, deletechars: Vec<u8>) -> (result: Vec<Vec<u8>>)
    requires
        table.len() == 256,
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < a.len() ==> {

            result[i].len() <= a[i].len() &&

            (forall|c: u8| #[trigger] result[i]@.contains(c) ==> {
                forall|j: int| 0 <= j < deletechars.len() ==> c != deletechars[j]
            }) &&

            (forall|k: int| 0 <= k < result[i].len() ==> {
                exists|orig_char: u8, table_idx: int|
                    0 <= table_idx < 256 &&
                    orig_char == table_idx as u8 &&
                    #[trigger] result[i][k] == table[table_idx as int] &&

                    a[i]@.contains(orig_char) &&
                    (forall|j: int| 0 <= j < deletechars.len() ==> orig_char != deletechars[j])
            }) &&

            (forall|orig_char: u8| #[trigger] a[i]@.contains(orig_char) ==> {
                (forall|j: int| 0 <= j < deletechars.len() ==> orig_char != deletechars[j]) ==> {
                    exists|translated_char: u8| result[i]@.contains(translated_char) &&
                        exists|table_idx: int|
                            0 <= table_idx < 256 &&
                            orig_char as int == table_idx &&
                            translated_char == table[table_idx as int]
                }
            }) &&

            (deletechars.len() == 0 ==> {
                result[i].len() == a[i].len() &&
                (forall|k: int| 0 <= k < a[i].len() ==> {
                    exists|table_idx: int|
                        0 <= table_idx < 256 &&
                        a[i][k] as int == table_idx &&
                        #[trigger] result[i][k] == table[table_idx as int]
                })
            }) &&

            (a[i].len() == 0 ==> result[i].len() == 0)
        }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0649,verus,numpy_triple,strings_upper,,"numpy.strings.upper: Return an array with the elements converted to uppercase.

Converts each string element in the input vector to uppercase. This transformation
applies to all alphabetic characters while preserving non-alphabetic characters
(digits, punctuation, whitespace) unchanged.

The function preserves the shape of the input array and handles empty strings
appropriately by returning them unchanged.

From NumPy documentation:
- Parameters: a (array_like) - Input array with string dtype
- Returns: out (ndarray) - Output array with elements converted to uppercase

Mathematical Properties:
1. Element-wise transformation: result[i] = upper(a[i]) for all i
2. Length preservation: result[i].length = a[i].length for all i
3. Case transformation: lowercase letters become uppercase, others unchanged
4. Idempotent: upper(upper(x)) = upper(x)
5. Preserves vector length: result.size = a.size

Specification: numpy.strings.upper returns a vector where each string element
is converted to uppercase.

Mathematical Properties:
1. Element-wise correctness: Each element is correctly converted to uppercase
2. Length preservation: Each transformed string has the same length as the original
3. Case transformation: Lowercase letters become uppercase, others unchanged
4. Idempotent property: Applying upper twice gives the same result as applying it once
5. Empty string handling: Empty strings remain empty
6. Character-level correctness: Each character is correctly transformed

Precondition: True (no special preconditions for uppercase conversion)
Postcondition: For all indices i, result[i] is the uppercase version of a[i]","use vstd::prelude::*;

verus! {
spec fn string_to_upper(s: Seq<char>) -> Seq<char> {
    s
}",,"fn upper(a: Vec<String>) -> (result: Vec<String>)
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < a.len() as int ==>
            result@[i]@ == string_to_upper(a@[i]@) &&
            result@[i]@.len() == a@[i]@.len()","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0650,verus,numpy_triple,strings_zfill,,"numpy.strings.zfill: Return the numeric string left-filled with zeros.

Zero-fills each string in the input array by padding it with leading zeros
to reach the specified width. If the original string is longer than or equal
to the width, it remains unchanged. This function is specifically designed
for numeric strings and handles sign prefixes appropriately.

The function behaves like Python's str.zfill() method:
- Pads strings with leading zeros to reach the target width
- Preserves sign characters ('+' or '-') at the beginning
- Returns original string if it's already >= target width

From NumPy documentation:
- Parameters: a (array_like) - Input array with string dtype
              width (int) - Target width for zero-filling
- Returns: out (ndarray) - Output array with zero-filled strings

Mathematical Properties:
1. Length invariant: result length is max(original_length, width)
2. Identity: strings already >= width remain unchanged
3. Zero-padding: shorter strings get leading zeros
4. Sign preservation: leading '+' or '-' characters are preserved
5. Minimality: no over-padding beyond required width","use vstd::prelude::*;

verus! {",,"spec fn is_sign_char(c: char) -> bool {
    c == '+' || c == '-'
}

spec fn all_zeros(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> s[i] == '0'
}

spec fn max_usize(a: usize, b: usize) -> usize {
    if a >= b { a } else { b }
}

fn zfill(a: Vec<Vec<char>>, width: usize) -> (result: Vec<Vec<char>>)
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < result.len() ==> 
            #[trigger] result[i].len() == max_usize(a[i].len(), width),
        forall|i: int| 0 <= i < result.len() && a[i].len() >= width ==> 
            #[trigger] result[i]@ == a[i]@,
        forall|i: int| 0 <= i < result.len() && a[i].len() < width && a[i].len() > 0 && 
            !is_sign_char(a[i]@[0]) ==> 
            #[trigger] all_zeros(result[i]@.take((width - a[i].len()) as int)) &&
            result[i]@.skip((width - a[i].len()) as int) == a[i]@,
        forall|i: int| 0 <= i < result.len() && a[i].len() < width && a[i].len() > 0 && 
            is_sign_char(a[i]@[0]) ==> 
            #[trigger] result[i]@[0] == a[i]@[0] &&
            result[i]@.skip(width as int) == a[i]@.skip(1),
        forall|i: int| 0 <= i < result.len() && a[i].len() == 0 ==> 
            #[trigger] result[i].len() == width && 
            all_zeros(result[i]@),
        forall|i: int| 0 <= i < result.len() && a[i].len() < width ==> 
            #[trigger] result[i].len() == width,
        forall|i: int| 0 <= i < result.len() && a[i].len() < width ==> 
            #[trigger] all_zeros(result[i]@.take((width - a[i].len()) as int))","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0651,verus,numpy_triple,ufunc___call__,,"Apply a binary universal function elementwise to two vectors.
This represents the core __call__ behavior for binary ufuncs like add, multiply, etc.

Specification: ufunc.__call__ applies the operation elementwise to input vectors.
The result has the same shape as the inputs (broadcasting to common shape) and
each element is computed by applying the operation to corresponding elements.","use vstd::prelude::*;

verus! {",,"fn ufunc_call(op: spec_fn(f32, f32) -> f32, a: &Vec<f32>, b: &Vec<f32>) -> (result: Vec<f32>)
    requires a@.len() == b@.len(),
    ensures 
        result@.len() == a@.len(),
        forall|i: int| 0 <= i < result@.len() ==> result@[i] == op(a@[i], b@[i])","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0652,verus,numpy_triple,ufunc_accumulate,,"Universal function accumulate method: Accumulate the result of applying a binary operator
to all elements in a vector.

For a binary operation `op` and input vector [a₁, a₂, a₃, ..., aₙ], returns:
[a₁, op(a₁, a₂), op(op(a₁, a₂), a₃), ..., op(op(...op(a₁, a₂), a₃), ..., aₙ)]

This generalizes cumulative operations:
- When op = (+), this becomes cumsum: [a₁, a₁+a₂, a₁+a₂+a₃, ...]
- When op = (*), this becomes cumprod: [a₁, a₁*a₂, a₁*a₂*a₃, ...]

The result has the same shape as the input array.","use vstd::prelude::*;

verus! {",,"fn accumulate(a: Vec<i8>) -> (result: Vec<i8>)
    ensures
        result.len() == a.len(),
        a.len() > 0 ==> result[0] == a[0],","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0654,verus,numpy_triple,ufunc_outer,,"Universal function outer method: Apply a binary operator to all pairs (a, b) 
with a in A and b in B.

For two 1-D vectors A = [a₁, a₂, ..., aₘ] and B = [b₁, b₂, ..., bₙ], 
the outer product produces an m×n matrix where result[i,j] = op(A[i], B[j]).

This generalizes the concept of outer product beyond just multiplication:
- When op = (*), this becomes the traditional outer product
- When op = (+), this becomes the sum of all pairs
- When op = (^), this becomes the power of all pairs

The result has shape (m, n) where m is the length of A and n is the length of B.

Specification: outer applies a binary operator to all pairs of elements
from two input vectors, producing a matrix result.

Precondition: True (works for any two vectors and binary operation)
Postcondition:
- Result has dimensions m × n (outer dimensions of input vectors)
- Each element result[i][j] equals op(a[i], b[j])
- The result preserves the structure of the Cartesian product of the inputs
- All pairs (i,j) with i ∈ [0..m-1] and j ∈ [0..n-1] are covered exactly once

Mathematical Properties:
- result[i][j] = op(a[i], b[j]) for all valid i, j
- The result matrix has the same number of rows as the first input vector
- The result matrix has the same number of columns as the second input vector
- For commutative operations: outer(op, a, b)[i][j] = outer(op, b, a)[j][i]
- For associative operations: outer preserves the algebraic structure","use vstd::prelude::*;

verus! {",,"fn outer(op: spec_fn(f64, f64) -> f64, a: Vec<f64>, b: Vec<f64>) -> (result: Vec<Vec<f64>>)
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i].len() == b.len(),
        forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < b.len() ==> 
            result[i][j] == op(a[i], b[j])","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0655,verus,numpy_triple,ufunc_reduce,,"Reduces an array by applying a binary operation repeatedly along an axis.
For 1D arrays, this applies the operation successively to pairs of elements.

Specification: reduce applies a binary operation repeatedly to reduce an array to a single value.
The operation is applied left-associatively: ((a[0] op a[1]) op a[2]) op ... op a[n-1]

/* Represents left-associative folding result at position index */

/* Placeholder - actual implementation would apply operation */","use vstd::prelude::*;

verus! {",,"spec fn fold_left(arr: Seq<f64>, index: nat) -> f64
    decreases index
{
    if index == 0 {
        arr[0 as int]
    } else {

        arr[index as int]
    }
}

fn reduce(arr: Vec<f64>) -> (result: f64)
    requires arr.len() > 0,
    ensures 
        arr.len() == 1 ==> result == arr[0],
        arr.len() > 1 ==> result == fold_left(arr@, (arr.len() - 1) as nat)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0656,verus,numpy_triple,ufunc_reduceat,,"Universal function reduceat method: Performs reductions on specified slices of an array.

For each index pair (indices[i], indices[i+1]), applies the reduction operation 
to the slice array[indices[i]:indices[i+1]].

Special behavior:
- For the last index, reduces from indices[i] to the end of the array
- If indices[i] >= indices[i+1], uses only the element at indices[i]
- Output length equals the number of indices provided

Example: np.add.reduceat([1,2,3,4,5,6,7,8], [0,4,1,5]) applies addition to slices:
- [1,2,3,4] -> 10
- [2,3,4,5] -> 14  
- [5,6,7,8] -> 26
Result: [10, 14, 26]","use vstd::prelude::*;

verus! {",,"spec fn slice_sum(arr: Seq<i32>, start: int, end: int) -> int
    decreases (end - start)
{
    if start >= end || start < 0 || end > arr.len() {
        0
    } else if start + 1 == end {
        arr[start] as int
    } else {
        (arr[start] as int) + slice_sum(arr, start + 1, end)
    }
}

fn reduceat_add(arr: Vec<i32>, indices: Vec<usize>) -> (result: Vec<i32>)
    requires 
        arr.len() > 0,
        indices.len() > 0,
        forall|i: int| 0 <= i < indices.len() ==> #[trigger] (indices[i] as int) < arr.len() as int,
    ensures
        result.len() == indices.len(),
        forall|i: int| 0 <= i < indices.len() ==> {
            let start_idx = indices[i] as int;
            if i < indices.len() - 1 {
                let end_idx = indices[(i + 1) as int] as int;
                if start_idx < end_idx {
                    /* Normal forward slice case */
                    #[trigger] (result[i] as int) == slice_sum(arr@, start_idx, end_idx)
                } else {
                    /* Single element case when indices are non-increasing */
                    #[trigger] result[i] == arr[start_idx]
                }
            } else {
                /* Last index case - reduce to end of array */
                #[trigger] (result[i] as int) == slice_sum(arr@, start_idx, arr.len() as int)
            }
        },","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0657,verus,numpy_triple,ufuncs_frompyfunc,,"numpy.frompyfunc: Takes a function and returns a universal function that applies it element-wise.

Creates a universal function (ufunc) from a Python function. The resulting ufunc
applies the original function element-wise to input arrays. For simplicity, we
model this for the common case of a unary function (nin=1, nout=1).

In our Vector-based model, this takes a function α → β and returns a function
that applies it element-wise to Vector α n, producing Vector β n.

This function enables the creation of vectorized operations from arbitrary functions,
which is a core capability of NumPy's universal function system.

Specification: numpy.frompyfunc creates a vectorized version of a function
that applies the original function element-wise.

Precondition: True (any function can be vectorized)
Postcondition: For all indices i, the result at index i equals func applied
to the input at index i.

This captures the essential property that frompyfunc creates an element-wise
mapping from the original function, preserving the functional behavior
while extending it to work with vectors.","use vstd::prelude::*;

verus! {",,"fn numpy_frompyfunc(func: spec_fn(i8) -> i8, input: Vec<i8>) -> (result: Vec<i8>)
    ensures
        result.len() == input.len(),
        forall|i: int| 0 <= i < input.len() ==> result[i] == func(input[i])","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0658,verus,numpy_triple,ufuncs_identity,,"{
  ""name"": ""identity"",
  ""description"": ""The identity value for the ufunc"",
  ""details"": ""Value such that func(x, identity) == x for all x"",
  ""examples"": {
    ""add.identity"": ""0"",
    ""multiply.identity"": ""1"",
    ""logical_and.identity"": ""True"",
    ""logical_or.identity"": ""False""
  }
}

ufunc.identity: Get the identity element for a ufunc operation.

Returns the identity element for a given binary operation, which is the value
that when combined with any other value using that operation, leaves the other
value unchanged. For example:
- Addition: identity is 0 (x + 0 = x)
- Multiplication: identity is 1 (x * 1 = x)
- Logical AND: identity is True (x ∧ True = x)
- Logical OR: identity is False (x ∨ False = x)

Some operations may have no identity element, in which case None is returned.

Specification: ufunc_identity returns the identity element if it exists.

Precondition: The operation is a valid binary function
Postcondition: If an identity element exists, applying the operation with
               that element leaves any other element unchanged","use vstd::prelude::*;

verus! {
enum OpType {
    Add,
    Multiply,
    LogicalAnd,
    LogicalOr,
}

spec fn apply_op(op: OpType, x: int, y: int) -> int {
    match op {
        OpType::Add => x + y,
        OpType::Multiply => x * y,
        OpType::LogicalAnd => if x != 0 && y != 0 { 1 } else { 0 },
        OpType::LogicalOr => if x != 0 || y != 0 { 1 } else { 0 },
    }
}

spec fn has_identity(op: OpType, id: int) -> bool {
    forall|x: int| apply_op(op, x, id) == x && apply_op(op, id, x) == x
}",,"fn ufunc_identity(op: OpType) -> (result: Option<i8>)
    ensures
        match result {
            Some(id) => has_identity(op, id as int),
            None => forall|id: int| !has_identity(op, id)
        }","{
    // impl-start
    assume(false);
    None
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0659,verus,numpy_triple,ufuncs_nargs,,"The number of arguments the ufunc accepts. Equal to nin + nout.

numpy.ufunc.nargs: Returns the total number of arguments the ufunc accepts.

This attribute represents the sum of input and output arguments for a ufunc.
For example, np.add has nin=2, nout=1, so nargs=3.

This is a read-only attribute that provides metadata about the ufunc's signature.

Specification: numpy.ufunc.nargs returns nin + nout

Precondition: True (no special preconditions for reading metadata)
Postcondition: The result equals the sum of input and output arguments","use vstd::prelude::*;

verus! {

/* Structure representing a NumPy universal function (ufunc) with its metadata */
struct Ufunc {
    /* Number of input arguments the ufunc accepts */
    nin: nat,
    /* Number of output arguments the ufunc produces */
    nout: nat,
}",,"fn numpy_nargs(ufunc: Ufunc) -> (result: u8)
    ensures result as nat == ufunc.nin + ufunc.nout","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0661,verus,numpy_triple,ufuncs_nout,,"The number of output arguments

Returns the number of output arguments for a given ufunc.
This corresponds to the nout attribute of NumPy ufuncs.

Specification: nout returns the number of output arguments of the ufunc.

This specification captures the essential mathematical properties of the nout attribute:

1. **Correctness**: The function returns exactly the nout_val field from the ufunc structure
2. **Lower bound**: The result is always ≥ 1, since all ufuncs can produce at least one output
3. **Type safety**: The result is a natural number representing a count
4. **Determinism**: Given the same ufunc, nout always returns the same value

Mathematical properties:
- ∀ ufunc : UFunc, nout(ufunc) = ufunc.nout_val  
- ∀ ufunc : UFunc, nout(ufunc) ≥ 1
- nout is a pure function (no side effects)

Examples from NumPy documentation:
- add.nout = 1 (binary operation with single output)
- modf.nout = 2 (returns fractional and integral parts)
- divmod.nout = 2 (returns quotient and remainder)","use vstd::prelude::*;

verus! {

/* Represents a universal function (ufunc) type that captures basic metadata about 
   the number of inputs and outputs. In NumPy, this would be the ufunc object itself. */
struct UFunc {
    /* Number of input arguments the ufunc accepts */
    nin: nat,
    /* Number of output arguments the ufunc produces */
    nout_val: nat,
}",,"fn nout(ufunc: UFunc) -> (result: u8)
    requires ufunc.nout_val >= 1,
    ensures 
        result as nat == ufunc.nout_val,
        result as nat >= 1","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0662,verus,numpy_triple,ufuncs_ntypes,,"The number of supported input/output type combinations

numpy.ufunc.ntypes: Returns the number of supported input/output type combinations
for a universal function.

The ntypes attribute represents the number of numerical NumPy types on which
the ufunc can operate. This is a key characteristic that determines the
type flexibility of different NumPy universal functions.

For example:
- np.add.ntypes returns around 22 (supports most numerical types)
- np.exp.ntypes returns around 10 (fewer supported types)
- np.remainder.ntypes returns around 16 (intermediate support)

Specification: ntypes returns the count of supported type combinations
for a ufunc, which must be a positive number for any valid ufunc.

Precondition: The input represents valid type combinations for a ufunc
Postcondition: The result is the exact count of type combinations,
              which is non-zero for any functional ufunc and equals
              the length of the type combinations vector.","use vstd::prelude::*;

verus! {",,"fn ntypes(ufunc_type_combinations: Vec<String>) -> (result: usize)
    requires ufunc_type_combinations@.len() > 0,
    ensures 
        result == ufunc_type_combinations@.len(),
        result > 0","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VT0663,verus,numpy_triple,ufuncs_signature,,Core signature for generalized ufuncs. Defines core dimensionality of inputs and outputs. Parse a ufunc signature string into a structured representation. Specification: parseSignature correctly parses ufunc signature strings.,"use vstd::prelude::*;

verus! {

/* A signature represents the core dimensionality pattern for a generalized ufunc */
pub struct UfuncSignature {
    /* Input dimension patterns as list of dimension lists */
    pub inputs: Vec<Vec<String>>,
    /* Output dimension patterns as list of dimension lists */
    pub outputs: Vec<Vec<String>>,
    /* All unique dimension names used in the signature */
    pub dimension_names: Vec<String>,
}",,"fn parse_signature(sig: Vec<String>) -> (result: UfuncSignature)
    requires sig@.len() > 0,
    ensures
        result.inputs@.len() > 0 || result.outputs@.len() > 0,
        result.inputs@.len() + result.outputs@.len() > 0","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0664,verus,numpy_triple,ufuncs_types,,"List of supported data type signatures
Shows input->output type mappings for universal functions
Returns formatted type signatures as strings","use vstd::prelude::*;

verus! {
/* Data type character codes used in NumPy ufunc type signatures */
#[derive(PartialEq, Eq)]
enum TypeCode {
    Bool,       // '?'
    Byte,       // 'b' 
    UByte,      // 'B'
    Short,      // 'h'
    UShort,     // 'H'
    Int,        // 'i'
    UInt,       // 'I'
    Long,       // 'l'
    ULong,      // 'L'
    LongLong,   // 'q'
    ULongLong,  // 'Q'
    Float32,    // 'f'
    Float64,    // 'd'
    LongDouble, // 'g'
    Complex64,  // 'F'
    Complex128, // 'D'
    CLongDouble,// 'G'
    Object,     // 'O'
}

/* Type signature representing input->output mapping for ufuncs */
struct TypeSignature {
    input_types: Vec<TypeCode>,
    output_type: TypeCode,
}

/* Convert TypeCode to character representation */
spec fn type_code_to_char(tc: TypeCode) -> char {
    match tc {
        TypeCode::Bool => '?',
        TypeCode::Byte => 'b',
        TypeCode::UByte => 'B',
        TypeCode::Short => 'h',
        TypeCode::UShort => 'H',
        TypeCode::Int => 'i',
        TypeCode::UInt => 'I',
        TypeCode::Long => 'l',
        TypeCode::ULong => 'L',
        TypeCode::LongLong => 'q',
        TypeCode::ULongLong => 'Q',
        TypeCode::Float32 => 'f',
        TypeCode::Float64 => 'd',
        TypeCode::LongDouble => 'g',
        TypeCode::Complex64 => 'F',
        TypeCode::Complex128 => 'D',
        TypeCode::CLongDouble => 'G',
        TypeCode::Object => 'O',
    }
}

/* Format a type signature as a string (input1input2...->output) */
spec fn format_type_signature(sig: TypeSignature) -> Seq<char> {
    let input_chars = sig.input_types@.map(|i: int, tc: TypeCode| type_code_to_char(tc));
    let arrow_chars = seq!['-', '>'];
    let output_char = seq![type_code_to_char(sig.output_type)];
    input_chars + arrow_chars + output_char
}",,"fn types(ufunc_signatures: Vec<TypeSignature>) -> (result: Vec<String>)
    ensures
        result.len() == ufunc_signatures.len(),
        forall|i: int| 0 <= i < result.len() ==>
            result[i]@ == format_type_signature(ufunc_signatures[i]) &&
            ufunc_signatures[i].input_types.len() > 0","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,1.0
VT0665,verus,numpy_triple,ufuncs_vectorize,,"Generalized function class that converts a Python function into a vectorized function

Vectorizes a scalar function to operate element-wise on vectors.
Takes a function f and applies it element-wise to input vectors,
producing a new vector with the same size.

Specification: vectorize applies the given function element-wise to the input vector.
The result vector has the same size and each element is the function applied to 
the corresponding element of the input vector.

Properties verified:
1. Element-wise application: each output element equals f applied to corresponding input
2. Size preservation: output vector has same size as input vector
3. Order preservation: relative positions of elements are maintained
4. Functional purity: result depends only on function f and input vector","use vstd::prelude::*;

verus! {",,"fn vectorize<A, B>(f: spec_fn(A) -> B, arr: Vec<A>) -> (result: Vec<B>)
    ensures
        result.len() == arr.len(),
        forall|i: int| 0 <= i < arr.len() ==> result[i] == f(arr[i])","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0000,verus,verina,verina_advanced_1_task,,"This task requires writing a Verus function that finds the single number in a non-empty list of integers, where every element appears exactly twice except for one element that appears only once. The function should return the integer that appears only once.

Input: The input is a non-empty list of integers where each integer appears exactly twice except for one element that appears only once.

Output: The output is a single integer - the unique integer that appears exactly once in the list.

// Helper function to count occurrences of an element in a sequence

// Helper function to filter elements equal to x","use vstd::prelude::*;

verus! {

spec fn count_occurrences(nums: Seq<i32>, x: i32) -> nat {
    nums.filter(|elem: i32| elem == x).len()
}

spec fn filter_equal(nums: Seq<i32>, x: i32) -> Seq<i32> {
    nums.filter(|elem: i32| elem == x)
}",,"fn find_single_number(nums: &Vec<i32>) -> (result: i32)
    requires 
        nums.len() > 0,
        exists|unique_elem: i32| count_occurrences(nums@, unique_elem) == 1,
        forall|elem: i32| nums@.contains(elem) ==> (count_occurrences(nums@, elem) == 1 || count_occurrences(nums@, elem) == 2),
    ensures
        count_occurrences(nums@, result) == 1,
        forall|x: i32| nums@.contains(x) ==> (x == result || count_occurrences(nums@, x) == 2),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0003,verus,verina,verina_advanced_4_task,,"This task requires writing a Verus method that finds the length of the longest increasing sequence in a given array. The method should return the length of the longest increasing subsequence, in which every element is strictly less than the latter element.

-----Input-----
The input consists of an array:
a: The input array.

-----Output-----
The output is an integer:
Returns the length of the longest increasing subsequence, assuring that it is a subsequence of the input sequence and that every element in it is strictly less than the latter one.

/*
    // -- Invalid Inputs
    // []
    // -- Tests
    // [
    //     {
    //         ""input"": {
    //             ""a"": ""#[5, 2, 8, 6, 3, 6, 9, 7]""
    //         },
    //         ""expected"": 4,
    //         ""unexpected"": [
    //             2,
    //             3
    //         ]
    //     },
    //     {
    //         ""input"": {
    //             ""a"": ""#[3, 1, 2, 1, 0]""
    //         },
    //         ""expected"": 2,
    //         ""unexpected"": [
    //             1,
    //             3
    //         ]
    //     },
    //     {
    //         ""input"": {
    //             ""a"": ""#[2, 3, -2, -1, 7, 19, 3, 6, -4, 6, -7, 0, 9, 12, 10]""
    //         },
    //         ""expected"": 6,
    //         ""unexpected"": [
    //             5,
    //             3,
    //             10
    //         ]
    //     },
    //     {
    //         ""input"": {
    //             ""a"": ""#[5, -5, -3, 2, 4, 1, 0, -1, 3, 2, 0]""
    //         },
    //         ""expected"": 4,
    //         ""unexpected"": [
    //             2,
    //             5
    //         ]
    //     },
    //     {
    //         ""input"": {
    //             ""a"": ""#[1, 7, 23, 14, -4, 21, 8, 2, -1, 9, 12, 2]""
    //         },
    //         ""expected"": 5,
    //         ""unexpected"": [
    //             2,
    //             4
    //         ]
    //     },
    //     {
    //         ""input"": {
    //             ""a"": ""#[]""
    //         },
    //         ""expected"": 0,
    //         ""unexpected"": [
    //             1,
    //             2
    //         ]
    //     }
    // ]
    // */

//","use vstd::prelude::*;

verus! {",,"fn longest_increasing_subsequence(a: &Vec<i32>) -> (result: i32)
    ensures
        result >= 0,
        result <= a.len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0004,verus,verina,verina_advanced_5_task,,"This task requires writing a Verus method that adds two non-empty linked lists representing non-negative integers.
The digits are stored in reverse order (i.e., the first element is the least significant digit).
Each node (list element) holds a single digit (ranging from 0 to 9). The function should add the two numbers and return the sum
as a linked list, also in reverse order.

-----Input-----
The input consists of:
- l1: A list of natural numbers representing the digits of the first number in reverse order.
- l2: A list of natural numbers representing the digits of the second number in reverse order.

-----Output-----
The output is a list of natural numbers:
Returns a list of digits (in reverse order) representing the sum of the two input numbers.

/*
    -- Invalid Inputs
    [
        {
            ""input"": {
                ""l1"": ""[]"",
                ""l2"": ""[]""
            }
        },
        {
            ""input"": {
                ""l1"": ""[0, 0]"",
                ""l2"": ""[0, 0]""
            }
        }
    ]
    -- Tests
    [
        {
            ""input"": {
                ""l1"": ""[2,4,3]"",
                ""l2"": ""[5,6,4]""
            },
            ""expected"": ""[7,0,8]"",
            ""unexpected"": [
                ""[2,4,3]"",
                ""[0]""
            ]
        },
        {
            ""input"": {
                ""l1"": ""[0]"",
                ""l2"": ""[0]""
            },
            ""expected"": ""[0]"",
            ""unexpected"": [
                ""[0,0]""
            ]
        },
        {
            ""input"": {
                ""l1"": ""[9,9,9,9,9,9,9]"",
                ""l2"": ""[9,9,9,9]""
            },
            ""expected"": ""[8,9,9,9,0,0,0,1]"",
            ""unexpected"": [
                ""[9,9,9,9,9,9,9,9]""
            ]
        },
        {
            ""input"": {
                ""l1"": ""[1,2,3]"",
                ""l2"": ""[4,5]""
            },
            ""expected"": ""[5,7,3]"",
            ""unexpected"": [
                ""[5,7]"",
                ""[5,7,4]""
            ]
        }
    ]
    */","use vstd::prelude::*;

verus! {

spec fn list_to_nat(l: Seq<u32>) -> nat
    decreases l.len(),
{
    if l.len() == 0 {
        0nat
    } else {
        l[0] as nat + 10nat * list_to_nat(l.subrange(1, l.len() as int))
    }
}",,"fn add_two_numbers(l1: &Vec<u32>, l2: &Vec<u32>) -> (result: Vec<u32>)
    requires 
        l1.len() > 0,
        l2.len() > 0,
        forall|i: int| 0 <= i < l1.len() ==> l1[i] < 10,
        forall|i: int| 0 <= i < l2.len() ==> l2[i] < 10,
        (l1[l1.len() - 1] != 0 || l1@ == seq![0u32]) &&
        (l2[l2.len() - 1] != 0 || l2@ == seq![0u32]),
    ensures
        list_to_nat(result@) == list_to_nat(l1@) + list_to_nat(l2@),
        forall|i: int| 0 <= i < result.len() ==> result[i] < 10,
        result[result.len() - 1] != 0 || (l1@ == seq![0u32] && l2@ == seq![0u32] && result@ == seq![0u32]),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0005,verus,verina,verina_advanced_6_task,,"This task requires writing a Verus method that determines whether a given string contains all 5 English vowels: a, e, i, o, u.

The check is case-insensitive, meaning that both uppercase and lowercase vowels count.

-----Input-----
The input consists of a string:
s: A string of alphabetic characters (may include uppercase and lowercase)

-----Output-----
The output is true or false:
Returns true if the input string contains all 5 vowels (a, e, i, o, u), false otherwise.","use vstd::prelude::*;

verus! {

spec fn to_lower(c: char) -> char {
    if 'A' <= c && c <= 'Z' {
        ((c as int + 32) as char)
    } else {
        c
    }
}

spec fn normalize_str(s: &str) -> Seq<char> {
    s.view().map_values(|c| to_lower(c))
}",,"fn all_vowels(s: &str) -> (result: bool)
    ensures
        result <==> (
            normalize_str(s).contains('a') &&
            normalize_str(s).contains('e') &&
            normalize_str(s).contains('i') &&
            normalize_str(s).contains('o') &&
            normalize_str(s).contains('u')
        ),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0007,verus,verina,verina_advanced_8_task,,"This task requires writing a Verus method that determines whether it is possible to complete a circular journey around a set of gas stations. Each gas station provides a certain amount of gas, and traveling from one station to the next consumes a certain amount of gas.

You start the journey at one of the gas stations with an empty tank. The goal is to find the starting station's index that allows completing the entire circuit once in the clockwise direction without running out of gas. If such a station exists, return its index. Otherwise, return -1.

If multiple solutions exist, return the one with the smallest starting gas station index.

Input:
The input consists of two arrays:

gas: An array of integers where gas[i] represents the amount of gas available at the ith station.

cost: An array of integers where cost[i] is the amount of gas required to travel from station i to station i + 1.

Output:
The output is an integer:
Returns the index of the starting gas station that allows a complete trip around the circuit. If it is not possible to complete the circuit, return -1.","use vstd::prelude::*;

verus! {

spec fn valid_starting_point(gas: &Vec<i32>, cost: &Vec<i32>, start: int) -> bool 
{
    0 <= start < gas.len() && 
    forall|i: int| 0 <= i < gas.len() ==> {
        #[trigger] calculate_acc(gas, cost, start, i + 1) >= 0
    }
}

spec fn calculate_acc(gas: &Vec<i32>, cost: &Vec<i32>, start: int, steps: int) -> int
    decreases steps
{
    if steps <= 0 {
        0
    } else {
        let prev_acc = calculate_acc(gas, cost, start, steps - 1);
        let jdx = ((start + (steps - 1)) % (gas.len() as int)) as nat % (gas.len() as nat);
        prev_acc + gas[jdx as int] - cost[jdx as int]
    }
}",,"fn can_complete_circuit(gas: &Vec<i32>, cost: &Vec<i32>) -> (result: i32)
    requires 
        gas.len() == cost.len(),
        gas.len() > 0,
    ensures
        (result == -1) ==> (forall|start: int| 0 <= start < gas.len() ==> !valid_starting_point(gas, cost, start)),
        (result >= 0) ==> (
            0 <= result < gas.len() &&
            valid_starting_point(gas, cost, result as int) &&
            (forall|start: int| 0 <= start < result ==> !valid_starting_point(gas, cost, start))
        ),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0008,verus,verina,verina_advanced_9_task,,"This task requires writing a Verus method of which given a number n and divisor d, it counts all the number that is smaller than
n whose sum of digits is divisible by d.
-----Input-----
The input consists of two usize:
n: usize
d: usize where d > 0

-----Output-----
The output is a natural number:
Ensure this match the count that satisfy the property.","use vstd::prelude::*;

verus! {",,"fn count_sum_divisible_by(n: usize, d: usize) -> (result: usize)
    requires d > 0,
    ensures 
        result <= n,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0009,verus,verina,verina_advanced_10_task,,"This task requires writing a Verus method that decomposes a natural number `n` into its prime factorization components based on a user-provided list of primes. Specifically, it calculates the exponents for each prime in the factorization such that:
\[ n = \prod p^e \]
In other words, it determines the exponent e for each prime p.

-----Input-----
The input consists of a natural number n, and a list of prime numbers. The input n is obtained by multiplying together any powers of the prime numbers from the provided list.
n: The natural number to be factorized.
primes: A list of primes to decompose n into.

-----Output-----
The output is `Vec<(nat, nat)>`:
Return a list of pair/Cartesian product of two natural numbers (p, e), where p is the prime and e is the exponent of p in the factorization. Each prime in the output must be from the input list, and every prime in the input list must appear in the output.","use vstd::prelude::*;
use vstd::arithmetic::power::pow;

verus! {

spec fn is_prime(n: nat) -> bool {
    arbitrary()
}

spec fn spec_fold(pairs: Seq<(nat, nat)>, acc: int) -> int
    decreases pairs.len()
{
    if pairs.len() == 0 {
        acc
    } else {
        let (p, e) = pairs[0];
        spec_fold(pairs.subrange(1, pairs.len() as int), acc * pow(p as int, e as nat))
    }
}",,"fn find_exponents(n: nat, primes: Vec<nat>) -> (result: Vec<(nat, nat)>)
    requires
        forall|i: int| 0 <= i < primes.len() ==> is_prime(primes[i]),
    ensures
        n as int == spec_fold(result@, 1int),
        forall|i: int| 0 <= i < result.len() ==> (#[trigger] primes@.contains(result[i].0)),
        forall|p: nat| (#[trigger] primes@.contains(p)) ==> 
            exists|j: int| 0 <= j < result.len() && result[j].0 == p,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0010,verus,verina,verina_advanced_11_task,,"This task requires writing a Verus method that finds the **majority element** in a list of integers. A majority element is defined as an element that appears **strictly more than half** the number of times in the list.

If such an element exists, the method should return that element. Otherwise, it should return `-1`. The implementation must ensure that the result is either the majority element (if one exists) or `-1` (when no such element appears more than ⌊n/2⌋ times).

**Input**
The input consists of a list of integers:
- lst: A list of integers, which may include duplicates and negative numbers. The list may also be empty.

**Output**
The output is a single integer:
- If a majority element exists in the input list, return that element.
- If no majority element exists, return `-1`.","use vstd::prelude::*;

verus! {

spec fn count_occurrences(x: i32, lst: Seq<i32>) -> nat {
    lst.filter(|y: i32| y == x).len()
}",,"fn find_majority_element(lst: &Vec<i32>) -> (result: i32)
    ensures ({
        let lst_seq = lst@;
        let n = lst_seq.len();
        let majority = count_occurrences(result, lst_seq) > n / 2 && 
                      forall|x: i32| count_occurrences(x, lst_seq) <= n / 2 || x == result;
        (result == -1 ==> forall|x: i32| count_occurrences(x, lst_seq) <= n / 2) &&
        (result != -1 ==> majority)
    })","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0011,verus,verina,verina_advanced_12_task,,"Write a Verus function that returns the first duplicate integer found in a list. The function should return the value of the first duplicate it encounters, scanning from left to right. If no duplicates exist, return -1.

Input: lst: A sequence of integers.
Output: An integer representing the first duplicated value if any exists, otherwise -1.

/* if result = -1, then lst does not contain any duplicates */

/* if result is not -1, then it is the first duplicate in lst */","use vstd::prelude::*;

verus! {",,"fn first_duplicate(lst: &Seq<i32>) -> (result: i32)
    ensures

        (result == -1 ==> forall|i: int, j: int| 0 <= i < j < lst.len() ==> lst[i] != lst[j]) &&

        (result != -1 ==> 
            exists|i: int, j: int| 0 <= i < j < lst.len() && lst[i] == lst[j] && lst[i] == result &&
            forall|k: int, l: int| 0 <= k < l < lst.len() && lst[k] == lst[l] && l <= i ==> k >= i
        ),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0012,verus,verina,verina_advanced_13_task,,"This task requires writing a Verus method that determines whether there are any intersections between chords on a circle. The method should return true if at least one pair of chords intersects, and false otherwise.

A chord is defined as a line segment connecting two distinct points on a circle. Two chords intersect if they cross each other inside the circle. The points are numbered from 1 to 2N in a clockwise direction, where N is the number of chords.

Constraints

- 2 ≤ N ≤ 2×10^5
- 1 ≤ A_i,B_i ≤ 2N
- A_1,…,A_N,B_1,…,B_N are all distinct
- All input values are integers

Input:
The input consists of two parameters:
N: A natural number representing the number of chords (2 ≤ N ≤ 2×10^5).
chords: A list of N pairs of natural numbers, where each pair represents the endpoints of a chord. All endpoint values are distinct and range from 1 to 2N.

Output:
The output is a boolean value:
- Returns true if there exists at least one pair of intersecting chords.
- Returns false if no chords intersect.

/* All endpoints are distinct */","use vstd::prelude::*;

verus! {

spec fn chord_intersects(chord1: &Vec<usize>, chord2: &Vec<usize>) -> bool {
    let a1 = if chord1[0] < chord1[1] { chord1[0] } else { chord1[1] };
    let b1 = if chord1[0] > chord1[1] { chord1[0] } else { chord1[1] };
    let a2 = if chord2[0] < chord2[1] { chord2[0] } else { chord2[1] };
    let b2 = if chord2[0] > chord2[1] { chord2[0] } else { chord2[1] };
    (a1 < a2 && a2 < b1 && b1 < b2) || (a2 < a1 && a1 < b2 && b2 < b1)
}",,"fn has_chord_intersection(n: usize, chords: &Vec<Vec<usize>>) -> (result: bool)
    requires
        n >= 2,
        chords.len() == n,
        forall|i: int| 0 <= i < chords.len() ==> (
            chords[i].len() == 2 &&
            chords[i][0] >= 1 && chords[i][0] <= 2 * n &&
            chords[i][1] >= 1 && chords[i][1] <= 2 * n
        ),

        forall|i: int, j: int, k: int, l: int| 
            0 <= i < chords.len() && 0 <= j < chords.len() && 
            0 <= k < 2 && 0 <= l < 2 && 
            (i != j || k != l) ==> chords[i][k] != chords[j][l],
    ensures
        result == exists|i: int, j: int| 
            0 <= i < chords.len() && 0 <= j < chords.len() && i != j &&
            #[trigger] chord_intersects(&chords[i], &chords[j]),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0013,verus,verina,verina_advanced_14_task,,"This task requires writing a Verus method that determines whether a natural number is a power of four. The method should return a boolean value that indicates whether the given natural number is a power of four. An integer n is a power of four, if there exists a natural number x such that n = 4^x.

-----Input-----
The input consists of one natural number:
n: A natural number.

-----Output-----
The output is a boolean value:
Return a boolean value that indicates whether the given natural number is a power of four. Return ""true"" if it is a power of four. Otherwise, return ""false"".","use vstd::prelude::*;
use vstd::arithmetic::power::pow;

verus! {",,"fn if_power_of_four(n: nat) -> (result: bool)
    ensures result <==> (exists|m: nat| n == pow(4, m)),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0014,verus,verina,verina_advanced_15_task,,"Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k]. If no such indices exist, return false.

-----Input-----
The input consists of a single list:
nums: A list of integers.

-----Output-----
The output is a boolean:
Returns true if there exists a triplet (i, j, k) where i < j < k and nums[i] < nums[j] < nums[k]; otherwise, returns false.

/*
    -- Invalid Inputs
    []
    -- Tests
    [
        {
            ""input"": {
                ""nums"": ""[1, 2, 3]""
            },
            ""expected"": true,
            ""unexpected"": [
                false
            ]
        },
        {
            ""input"": {
                ""nums"": ""[5, 4, 3, 2, 1]""
            },
            ""expected"": false,
            ""unexpected"": [
                true
            ]
        },
        {
            ""input"": {
                ""nums"": ""[2, 1, 5, 0, 4, 6]""
            },
            ""expected"": true,
            ""unexpected"": [
                false
            ]
        },
        {
            ""input"": {
                ""nums"": ""[1, 5, 0, 4, 1, 3]""
            },
            ""expected"": true,
            ""unexpected"": [
                false
            ]
        },
        {
            ""input"": {
                ""nums"": ""[5, 4, 3]""
            },
            ""expected"": false,
            ""unexpected"": [
                true
            ]
        },
        {
            ""input"": {
                ""nums"": ""[]""
            },
            ""expected"": false,
            ""unexpected"": [
                true
            ]
        }
    ]
    */","use vstd::prelude::*;

verus! {",,"fn increasing_triplet(nums: &Vec<i32>) -> (result: bool)
    ensures
        result ==> exists|i: int, j: int, k: int| 
            0 <= i < j && j < k < nums.len() && 
            nums[i] < nums[j] && nums[j] < nums[k],
        !result ==> forall|i: int, j: int, k: int| 
            0 <= i < j && j < k < nums.len() ==> 
            !(nums[i] < nums[j] && nums[j] < nums[k]),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0016,verus,verina,verina_advanced_17_task,,"This task requires implementing the insertion sort algorithm to sort a list of integers in ascending order. The function should take a list of integers as input and return a new list containing the same elements sorted in non-decreasing order.

-----Input-----
The input is:

l: A list of integers to be sorted.

-----Output-----
The output is:

A list of integers that is sorted in non-decreasing order and is a permutation of the input list.

/* The result is sorted in non-decreasing order */

/* The result is a permutation of the input */","use vstd::prelude::*;

verus! {",,"fn insertion_sort(l: Vec<i32>) -> (result: Vec<i32>)
    ensures

        forall|i: int, j: int| 0 <= i < j < result.len() ==> result[i] <= result[j],

        result@.to_multiset() == l@.to_multiset(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0017,verus,verina,verina_advanced_18_task,,"This task requires writing a Verus method that determines whether a given number `n` is an Armstrong number (also known as a Narcissistic number). An Armstrong number is a number that is equal to the sum of its own digits raised to the power of the number of digits.

Input: The input consists of one natural number:
- `n: u32`: The number to check if it satisfies the Armstrong property.

Output: The output is a boolean value:
- `bool`: Return `true` if `n` is an Armstrong number, otherwise return `false`.

// let n = 153;

// println!(""Is {} an Armstrong number? {}"", n, is_armstrong(n));

// 

// let n = 9474;

// println!(""Is {} an Armstrong number? {}"", n, is_armstrong(n));

// 

// let n = 9475;

// println!(""Is {} an Armstrong number? {}"", n, is_armstrong(n));","use vstd::prelude::*;

verus! {

spec fn count_digits(n: nat) -> nat
    decreases n
{
    if n == 0 { 1 } else if n < 10 { 1 } else { 1 + count_digits(n / 10) }
}

spec fn pow_nat(base: nat, exp: nat) -> nat
    decreases exp
{
    if exp == 0 { 
        1 
    } else { 
        base * pow_nat(base, (exp - 1) as nat) 
    }
}

spec fn sum_powers(n: nat, k: nat) -> nat
    decreases n
{
    if n == 0 { 0 } else { pow_nat(n % 10, k) + sum_powers(n / 10, k) }
}",,"fn is_armstrong(n: u32) -> (result: bool)
    ensures 
        result == (n as nat == sum_powers(n as nat, count_digits(n as nat))),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0018,verus,verina,verina_advanced_19_task,,"This task requires writing a Verus method that checks whether a given string is a palindrome. A palindrome is a string that reads the same forwards and backwards. The function should ignore whitespace, punctuation, and capitalization when checking for palindromes.

-----Input-----
The input consists of:
s: A string to be checked.

-----Output-----
The output is a boolean:
Returns true if the input string is a palindrome when non-alphabetic characters are removed and letters are treated case-insensitively, and false otherwise.

// Check if a character is an uppercase alphabet letter

// Check if a character is a lowercase alphabet letter  

// Determine if a character is alphabetic

// Convert a single character to lowercase (simplified for Verus)

// Simplified: assume conversion works for spec purposes

// This would be the lowercase version in practice

// Normalize a character: keep only lowercase letters

// Normalize a string into a sequence of lowercase alphabetic characters","use vstd::prelude::*;

verus! {

spec fn is_upper_alpha(c: char) -> bool {
    'A' <= c && c <= 'Z'
}

spec fn is_lower_alpha(c: char) -> bool {
    'a' <= c && c <= 'z'
}

spec fn is_alpha(c: char) -> bool {
    is_upper_alpha(c) || is_lower_alpha(c)
}

spec fn to_lower(c: char) -> char {
    if is_upper_alpha(c) {

        c
    } else {
        c
    }
}

spec fn normalize_char(c: char) -> Option<char> {
    if is_alpha(c) {
        Some(to_lower(c))
    } else {
        None
    }
}

spec fn normalize_string(s: &str) -> Seq<char> {
    s@.fold_left(Seq::empty(), |acc: Seq<char>, c: char|
        match normalize_char(c) {
            Some(c_norm) => acc.push(c_norm),
            None => acc,
        }
    )
}",,"fn is_clean_palindrome(s: &str) -> (result: bool)
    ensures 
        result == (normalize_string(s) == normalize_string(s).reverse()),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0029,verus,verina,verina_advanced_30_task,,"This task requires writing a Verus function that computes the length of the longest strictly increasing contiguous subarray in a list of integers. A subarray is a sequence of consecutive elements, and it is strictly increasing if each element is greater than the previous one.

The function should correctly handle empty lists, lists with all equal elements, and long stretches of increasing numbers.

Input:
The input consists of a single list:
nums: A list of integers.

Output:
The output is a natural number:
Returns the length of the longest strictly increasing contiguous subarray. If the list is empty, the function should return 0.","use vstd::prelude::*;

verus! {",,"fn longest_increasing_streak(nums: &Vec<i32>) -> (result: usize)
    ensures
        (nums.len() == 0 ==> result == 0),
        result <= nums.len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0030,verus,verina,verina_advanced_31_task,,"This task requires writing a Lean 4 function that finds the length of the longest strictly increasing subsequence in a list of integers. A subsequence is any sequence that can be derived from the list by deleting zero or more elements without changing the order of the remaining elements. The function must return the length of the longest possible such sequence.

-----Input-----
The input consists of a single value:
xs: A list of integers of type `List Int`.

-----Output-----
The output is a natural number:
Returns the length of the longest strictly increasing subsequence found in the list.

/* Helper functions for generating subsequences and checking increasing property */

/* The result is the length of some strictly increasing subsequence */

/* No strictly increasing subsequence is longer than result */","use vstd::prelude::*;

verus! {

spec fn is_subsequence_of(subseq: Seq<i32>, seq: Seq<i32>) -> bool {
    exists|indices: Seq<int>| 
        indices.len() == subseq.len() &&
        #[trigger] indices.len() >= 0 &&
        (forall|i: int| 0 <= i < indices.len() ==> #[trigger] indices[i] >= 0 && indices[i] < seq.len()) &&
        (forall|i: int| 0 <= i < indices.len() - 1 ==> #[trigger] indices[i] < indices[i + 1]) &&
        (forall|i: int| 0 <= i < subseq.len() ==> #[trigger] subseq[i] == seq[indices[i]])
}

spec fn is_strictly_increasing(seq: Seq<i32>) -> bool {
    forall|i: int| 0 <= i < seq.len() - 1 ==> #[trigger] seq[i] < seq[i + 1]
}",,"fn longest_increasing_subseq_length(xs: &Vec<i32>) -> (result: usize)
    ensures

        exists|subseq: Seq<i32>| 
            is_subsequence_of(subseq, xs@) && 
            is_strictly_increasing(subseq) && 
            subseq.len() == result,

        forall|subseq: Seq<i32>| 
            (is_subsequence_of(subseq, xs@) && is_strictly_increasing(subseq)) 
            ==> subseq.len() <= result,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0031,verus,verina,verina_advanced_32_task,,"This test implements a function in Verus that finds the length of the longest increasing subsequence in a list of integers. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. An increasing subsequence is one in which the elements are in strictly increasing order.

Input: numbers: A list of integers.

Output: A natural number representing the length of the longest increasing subsequence in the input list. If the list is empty, the function returns 0.","use vstd::prelude::*;

verus! {",,"fn longest_increasing_subsequence(numbers: Vec<i32>) -> (result: usize)
    ensures
        result <= numbers.len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVV03,0.85
VV0032,verus,verina,verina_advanced_33_task,,"This task requires implementing the ""Longest Increasing Subsequence"" problem in Verus.
Given a list of integers, the function should compute the length of the longest strictly increasing
subsequence. A subsequence is formed by deleting zero or more elements without changing the order.
If the list is empty, the function should return 0.

-----Input-----
- nums: A list of integers.

-----Output-----
- A natural number representing the length of the longest strictly increasing subsequence.
- If there is no increasing subsequence, return 0.

/* 
    -- Invalid Inputs
    []
    -- Tests
    [
        {
            ""input"": {
                ""nums"": ""[10, 9, 2, 5, 3, 7, 101, 18]""
            },
            ""expected"": 4,
            ""unexpected"": [
                3,
                5
            ]
        },
        {
            ""input"": {
                ""nums"": ""[0, 1, 0, 3, 2, 3]""
            },
            ""expected"": 4,
            ""unexpected"": [
                3
            ]
        },
        {
            ""input"": {
                ""nums"": ""[7, 7, 7, 7, 7]""
            },
            ""expected"": 1,
            ""unexpected"": [
                0,
                2
            ]
        },
        {
            ""input"": {
                ""nums"": ""[]""
            },
            ""expected"": 0,
            ""unexpected"": [
                1
            ]
        },
        {
            ""input"": {
                ""nums"": ""[4, 10, 4, 3, 8, 9]""
            },
            ""expected"": 3,
            ""unexpected"": [
                2,
                4
            ]
        }
    ]
    */","use vstd::prelude::*;

verus! {",,"fn longest_increasing_subsequence(nums: Vec<i32>) -> (result: usize)
    ensures
        result >= 0,
        nums.len() == 0 ==> result == 0,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0033,verus,verina,verina_advanced_34_task,,"This task requires writing a Verus method that finds the length of the longest strictly increasing subsequence from a given list of integers.

-----Input-----
The input consists of a list of integers called nums

-----Output-----
The output is an integer:
Returns a number representing the length of the longest strictly increasing subsequence found in the input list.","use vstd::prelude::*;

verus! {",,"fn longest_increasing_subsequence(nums: &Vec<i32>) -> (result: i32)
    ensures
        result >= 0,
        result <= nums.len() as i32,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVV03,0.85
VV0034,verus,verina,verina_advanced_35_task,,"This task requires writing a Verus function that finds the majority element in a sequence of integers. The majority element is the element that appears more than ⌊n/2⌋ times, where n is the sequence's length. You may assume that a majority element always exists in the input.

-----Input-----
- nums: A sequence of integers of length ≥ 1, containing a majority element.

-----Output-----
- An integer: the element that appears more than ⌊n/2⌋ times.","use vstd::prelude::*;

verus! {

spec fn count_occurrences(nums: Seq<i32>, x: i32) -> nat 
    decreases nums.len()
{
    if nums.len() == 0 {
        0
    } else {
        let first = nums[0];
        let rest_count = count_occurrences(nums.subrange(1, nums.len() as int), x);
        if first == x {
            rest_count + 1
        } else {
            rest_count
        }
    }
}",,"fn majority_element(nums: Seq<i32>) -> (result: i32)
    requires 
        nums.len() > 0,
        exists|x: i32| count_occurrences(nums, x) > nums.len() / 2,
    ensures 
        count_occurrences(nums, result) > nums.len() / 2,
        forall|x: i32| x != result ==> count_occurrences(nums, x) <= nums.len() / 2,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVV01,0.85
VV0035,verus,verina,verina_advanced_36_task,,"This task requires writing a Verus method that finds the majority element in a list of natural numbers. The majority element is defined as the element that appears more than ⌊n / 2⌋ times in the list, where n is the total number of elements.

You may assume that the input list always contains a majority element.

Input: The input consists of one list:
xs: A list of natural numbers (Vec<u64>), where a majority element is guaranteed to exist.

Output: The output is a natural number:
Returns the element that appears more than half the time in the input list.","use vstd::prelude::*;

verus! {

spec fn count_matches(xs: Seq<u64>, x: u64) -> nat
    decreases xs.len()
{
    if xs.len() == 0 {
        0
    } else {
        let first_match: nat = if xs[0] == x { 1 } else { 0 };
        first_match + count_matches(xs.skip(1), x)
    }
}",,"fn majority_element(xs: &Vec<u64>) -> (result: u64)
    requires 
        xs.len() > 0,
        exists|x: u64| count_matches(xs@, x) > xs.len() / 2,
    ensures
        count_matches(xs@, result) > xs.len() / 2,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVV01,0.85
VV0036,verus,verina,verina_advanced_37_task,,"This task requires writing a Verus method that returns the majority element from a list of integers.

The majority element is the one that appears more than ⌊n / 2⌋ times in the list, where n is the list's length. You may assume that a majority element always exists in the input.

Input: nums: A list of integers (with at least one majority element).

Output: Returns the majority element — the value that appears more than ⌊n / 2⌋ times.

/*
    // Invalid Inputs
    []
    // Tests
    [
        {
            ""input"": {
                ""nums"": ""[3, 2, 3]""
            },
            ""expected"": 3,
            ""unexpected"": [
                2
            ]
        },
        {
            ""input"": {
                ""nums"": ""[2, 2, 1, 1, 1, 2, 2]""
            },
            ""expected"": 2,
            ""unexpected"": [
                1
            ]
        },
        {
            ""input"": {
                ""nums"": ""[1]""
            },
            ""expected"": 1,
            ""unexpected"": [
                0
            ]
        },
        {
            ""input"": {
                ""nums"": ""[4, 4, 4, 4, 4, 2, 2, 3, 3]""
            },
            ""expected"": 4,
            ""unexpected"": [
                2,
                3
            ]
        },
        {
            ""input"": {
                ""nums"": ""[9, 8, 9, 9, 7, 9, 6, 9, 9]""
            },
            ""expected"": 9,
            ""unexpected"": [
                6,
                7,
                8
            ]
        },
        {
            ""input"": {
                ""nums"": ""[0, 0, 0, 0, 1]""
            },
            ""expected"": 0,
            ""unexpected"": [
                1
            ]
        },
        {
            ""input"": {
                ""nums"": ""[100000, 100000, 100000, 100000, -100000]""
            },
            ""expected"": 100000,
            ""unexpected"": [
                -100000
            ]
        },
        {
            ""input"": {
                ""nums"": ""[-1, -1, -1, -1, 0, 1, 2]""
            },
            ""expected"": -1,
            ""unexpected"": [
                0,
                1,
                2
            ]
        },
        {
            ""input"": {
                ""nums"": ""[5, 5, 5, 5, 5, 5, 5]""
            },
            ""expected"": 5,
            ""unexpected"": [
                0
            ]
        },
        {
            ""input"": {
                ""nums"": ""[1, 2, 3, 3, 3, 3, 3]""
            },
            ""expected"": 3,
            ""unexpected"": [
                1,
                2
            ]
        }
    ]
    */","use vstd::prelude::*;

verus! {

spec fn count_occurrences(nums: Seq<i32>, value: i32) -> nat {
    nums.filter(|x: i32| x == value).len()
}",,"fn majority_element(nums: &Vec<i32>) -> (result: i32)
    requires nums.len() > 0,
    ensures ({
        let nums_seq = nums@;
        let n = nums_seq.len();
        count_occurrences(nums_seq, result) > n / 2 &&
        forall|x: i32| x == result || count_occurrences(nums_seq, x) <= n / 2
    }),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0037,verus,verina,verina_advanced_38_task,,"This task requires implementing a Verus method that, given a list of intervals, returns the maximum amount that can be spanned after we removed one of the intervals
You may assume you'll receive at least one interval

Input: The input consists of a list of ordered pairs of intervals.
Output: The output is an integer: Return the largest span that is possible after removing one of the intervals.","use vstd::prelude::*;

verus! {",,"fn max_coverage_after_removing_one(intervals: &Vec<(usize, usize)>) -> (result: usize)
    requires intervals.len() > 0,
    ensures 
        result <= intervals.len() * 1000,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0038,verus,verina,verina_advanced_39_task,,"This task requires writing a Verus function that returns the maximum element from a non-empty list of natural numbers.

Input: The input consists of lst: a non-empty list of natural numbers.

Output: The output is a natural number representing the largest element in the list.

/* 
    -- Invalid Inputs
    [
        {
            ""input"": {
                ""lst"": ""[]""
            }
        }
    ]
    -- Tests
    [
        {
            ""input"": {
                ""lst"": ""[1, 2, 3]""
            },
            ""expected"": 3,
            ""unexpected"": [
                2,
                1,
                0
            ]
        },
        {
            ""input"": {
                ""lst"": ""[5, 5, 5]""
            },
            ""expected"": 5,
            ""unexpected"": [
                4,
                0
            ]
        },
        {
            ""input"": {
                ""lst"": ""[10, 1, 9]""
            },
            ""expected"": 10,
            ""unexpected"": [
                1,
                9
            ]
        },
        {
            ""input"": {
                ""lst"": ""[7]""
            },
            ""expected"": 7,
            ""unexpected"": [
                0,
                6
            ]
        },
        {
            ""input"": {
                ""lst"": ""[0, 0, 0, 0]""
            },
            ""expected"": 0,
            ""unexpected"": [
                1
            ]
        }
    ]
    */","use vstd::prelude::*;

verus! {",,"fn max_of_list(lst: &Vec<usize>) -> (result: usize)
    requires lst.len() > 0,
    ensures
        exists|i: int| 0 <= i < lst.len() && lst[i] == result,
        forall|i: int| 0 <= i < lst.len() ==> lst[i] <= result,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0039,verus,verina,verina_advanced_40_task,,"This task requires writing a Verus function that returns the maximum element from a non-empty list of natural numbers.

-----Input-----
The input consists of:
lst: a non-empty list of natural numbers.

-----Output-----
The output is:
A natural number representing the largest element in the list.

/*
    // -- Invalid Inputs
    // [
    //     {
    //         ""input"": {
    //             ""lst"": ""[]""
    //         }
    //     }
    // ]
    // -- Tests
    // [
    //     {
    //         ""input"": {
    //             ""lst"": ""[1, 2, 3]""
    //         },
    //         ""expected"": 3,
    //         ""unexpected"": [
    //             2,
    //             1,
    //             0
    //         ]
    //     },
    //     {
    //         ""input"": {
    //             ""lst"": ""[5, 5, 5]""
    //         },
    //         ""expected"": 5,
    //         ""unexpected"": [
    //             4,
    //             0
    //         ]
    //     },
    //     {
    //         ""input"": {
    //             ""lst"": ""[10, 1, 9]""
    //         },
    //         ""expected"": 10,
    //         ""unexpected"": [
    //             1,
    //             9
    //         ]
    //     },
    //     {
    //         ""input"": {
    //             ""lst"": ""[7]""
    //         },
    //         ""expected"": 7,
    //         ""unexpected"": [
    //             0,
    //             6
    //         ]
    //     },
    //     {
    //         ""input"": {
    //             ""lst"": ""[0, 0, 0, 0]""
    //         },
    //         ""expected"": 0,
    //         ""unexpected"": [
    //             1
    //         ]
    //     }
    // ]
    // */

//","use vstd::prelude::*;

verus! {",,"fn max_of_list(lst: Vec<i32>) -> (result: i32)
    requires lst.len() > 0,
    ensures
        exists|i: int| 0 <= i < lst.len() && lst[i] == result,
        forall|i: int| 0 <= i < lst.len() ==> lst[i] <= result,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0040,verus,verina,verina_advanced_41_task,,"This task requires writing a Verus method that finds the maximum among three given integers. The method should return the largest value, ensuring that the result is greater than or equal to each of the input numbers and that it is one of the provided integers.

-----Input-----
The input consists of three integers:
a: The first integer.
b: The second integer.
c: The third integer.

-----Output-----
The output is an integer:
Returns the maximum of the three input numbers, assuring that the returned value is greater than or equal to a, b, and c, and that it matches one of these values.

/*
    -- Invalid Inputs
    []
    -- Tests
    [
        {
            ""input"": {
                ""a"": 3,
                ""b"": 2,
                ""c"": 1
            },
            ""expected"": 3,
            ""unexpected"": [
                2,
                1,
                -1
            ]
        },
        {
            ""input"": {
                ""a"": 5,
                ""b"": 5,
                ""c"": 5
            },
            ""expected"": 5,
            ""unexpected"": [
                6,
                4
            ]
        },
        {
            ""input"": {
                ""a"": 10,
                ""b"": 20,
                ""c"": 15
            },
            ""expected"": 20,
            ""unexpected"": [
                10,
                15
            ]
        },
        {
            ""input"": {
                ""a"": -1,
                ""b"": -2,
                ""c"": -3
            },
            ""expected"": -1,
            ""unexpected"": [
                -2,
                -3
            ]
        },
        {
            ""input"": {
                ""a"": 0,
                ""b"": -10,
                ""c"": -5
            },
            ""expected"": 0,
            ""unexpected"": [
                -5,
                -10
            ]
        }
    ]
    */","use vstd::prelude::*;

verus! {",,"fn max_of_three(a: i32, b: i32, c: i32) -> (result: i32)
    ensures
        result >= a && result >= b && result >= c,
        result == a || result == b || result == c,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0041,verus,verina,verina_advanced_42_task,,"This task requires writing a Verus function that takes a sequence of stock prices and returns the maximum profit achievable by buying on one day and selling on a later day.

If no profit is possible, the function should return 0.

-----Input-----
The input consists of:
prices: A sequence of natural numbers representing stock prices on each day.

-----Output-----
The output is a natural number:
Returns the maximum profit achievable with one transaction (buy once, sell once), or 0 if no profitable transaction is possible.","use vstd::prelude::*;

verus! {",,"fn max_profit(prices: Seq<usize>) -> (result: usize)
    ensures
        (result == 0 && prices.len() == 0) ||
        (exists|i: int, j: int| 0 <= i < j < prices.len() && prices[j] >= prices[i] && prices[j] - prices[i] == result) ||
        (forall|i: int, j: int| 0 <= i < j < prices.len() ==> prices[j] < prices[i]),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0042,verus,verina,verina_advanced_43_task,,"This task requires writing a Verus method that given a 0-indexed integer array `nums` representing the scores of students in an exam. A teacher wants to select a non empty group of students such that the strength of group is maximized.

The strength of a group is defined as the product of the selected student scores.

You can choose any non-empty subset of students. The goal is to compute the maximum product of any such subset.

----Input---
nums: An non-empty list of integers.

-----Output-----

An integer representing the maximum strength.

/* The result represents the maximum product of any non-empty subset of nums.
           For simplicity, we ensure that the result is at least as large as one of the elements. */

/* 
    // Invalid Inputs
    [
        {
            ""input"": {
                ""nums"": ""[]""
            }
        }
    ]
    // Tests
    [
        {
            ""input"": {
                ""nums"": ""[-2]""
            },
            ""expected"": -2,
            ""unexpected"": [
                2,
                0
            ]
        },
        {
            ""input"": {
                ""nums"": ""[3, -1, -5, 2, 5, -9]""
            },
            ""expected"": 1350,
            ""unexpected"": [
                270,
                0,
                -1
            ]
        },
        {
            ""input"": {
                ""nums"": ""[-4, -5, -4]""
            },
            ""expected"": 20,
            ""unexpected"": [
                80,
                -80,
                -5
            ]
        },
        {
            ""input"": {
                ""nums"": ""[0, -3, 4]""
            },
            ""expected"": 4,
            ""unexpected"": [
                0,
                -12
            ]
        },
        {
            ""input"": {
                ""nums"": ""[1, -1, -1]""
            },
            ""expected"": 1,
            ""unexpected"": [
                -1,
                -2
            ]
        }
    ]
    */","use vstd::prelude::*;

verus! {",,"fn max_strength(nums: &Vec<i32>) -> (result: i32)
    requires nums.len() > 0,
    ensures

        exists|i: int| 0 <= i < nums.len() && result >= nums[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0043,verus,verina,verina_advanced_44_task,,"Given an integer array arr and a positive integer k, this task requires writing a Verus method that finds the
maximum sum of a subarray of arr, such that the length of the subarray is divisible by k.
If the array is empty, or generally if there exists no subarray with length divisible by k,
the default return value should be 0.

Input:
The input consists of:
arr: The array of integers.
k: An integer larger than 1.

Output:
The output is an integer:
Returns the maximum positive integer x such that there exists a subarray where the sum equals x, and the length
of the subarray is divisible by k.

/* TODO: Add postcondition based on subarrays with length divisible by k */","use vstd::prelude::*;

verus! {",,"fn max_subarray_sum_divisible_by_k(arr: &Vec<i32>, k: i32) -> (result: i32)
    requires k > 0,
    ensures true,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0044,verus,verina,verina_advanced_45_task,,"This task requires writing a Verus function that finds the maximum subarray sum from a given list of integers.
A subarray is a contiguous sequence of elements within the list.
The function should return the maximum sum that can be obtained from any subarray.

Input:
The input is a vector of integers:
xs: A vector of integers (can include negative numbers).

Output:
The output is an integer:
Returns the maximum sum among all contiguous subarrays of xs.
If the vector is empty, the result should be 0.","use vstd::prelude::*;

verus! {

spec fn spec_sum(xs: &Vec<i32>, start: int, len: int) -> int 
    decreases len
{
    if len <= 0 {
        0
    } else {
        xs[start] + spec_sum(xs, start + 1, len - 1)
    }
}",,"fn max_subarray_sum(xs: &Vec<i32>) -> (result: i32)
    ensures
        xs.len() == 0 ==> result == 0,
        xs.len() > 0 ==> (
            exists|start: int, len: int| 
                0 <= start < xs.len() && 
                1 <= len <= xs.len() - start &&
                result == spec_sum(xs, start, len) as i32
        ) &&
        (forall|start: int, len: int|
            0 <= start < xs.len() && 
            1 <= len <= xs.len() - start
            ==> spec_sum(xs, start, len) <= result as int
        ),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0045,verus,verina,verina_advanced_46_task,,"This test implements a function in Verus that finds the maximum sum of any contiguous subarray within a vector of integers. A subarray is a continuous section of the original array. If all integers in the vector are negative, the function should return 0 (representing the empty subarray).

Input: numbers - A vector of integers that may contain positive, negative, or zero values.

Output: An integer representing the maximum sum of any contiguous subarray. If the vector is empty or contains only negative numbers, the function returns 0.","use vstd::prelude::*;

verus! {",,"fn max_subarray_sum(numbers: &Vec<i32>) -> (result: i32)
    ensures
        result >= 0,
        forall|start: usize, end: usize| {
            start <= end && end <= numbers.len()
        } ==> {
            let mut subarray_sum: i32 = 0;
            subarray_sum <= result
        },","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0047,verus,verina,verina_advanced_48_task,,"This task requires implementing the merge sort algorithm in Verus to sort a list of integers in ascending order. Merge sort is a divide-and-conquer algorithm that recursively splits the input list into two halves, sorts them separately, and then merges the sorted halves to produce the final sorted result.

The merge sort algorithm works as follows:
1. If the list has one element or is empty, it is already sorted.
2. Otherwise, divide the list into two roughly equal parts.
3. Recursively sort both halves.
4. Merge the two sorted halves to produce a single sorted list.

The key operation in merge sort is the merging step, which takes two sorted lists and combines them into a single sorted list by repeatedly taking the smaller of the two elements at the front of the lists.

Input:
The input consists of one parameter:
list: A list of integers that needs to be sorted.

Output:
The output is a list of integers:
Returns a new list containing all elements from the input list, sorted in ascending order.","use vstd::prelude::*;

verus! {",,"fn merge_sort(list: Vec<i32>) -> (result: Vec<i32>)
    ensures
        result.len() == list.len(),
        forall|i: int, j: int| 0 <= i < j < result.len() ==> result[i] <= result[j],
        result@ =~= list@,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0048,verus,verina,verina_advanced_49_task,,"Implement a Verus function that merges two ascendingly sorted lists of integers into one single sorted list (ascending). The resulting list must contain all elements from both input lists, preserving their ascending order.

Input:
The input consists of two lists of integers:
arr1: A sorted list of integers (ascending)
arr2: Another sorted list of integers (ascending)

Output:
The output is a list of integers:
Returns a new list containing all elements from arr1 and arr2, sorted in ascending order.

/* 
    -- Invalid Inputs
    [
        {
            ""input"": {
                ""arr1"": ""[3, 2, 1]"",
                ""arr2"": ""[6, 5, 4]""
            }
        }
    ]
    -- Tests
    [
        {
            ""input"": {
                ""arr1"": ""[1, 3, 5]"",
                ""arr2"": ""[2, 4, 6]""
            },
            ""expected"": ""[1, 2, 3, 4, 5, 6]"",
            ""unexpected"": [
                ""[1, 3, 5]"",
                ""[2, 4, 6]"",
                ""[1, 3, 2, 4, 5, 6]""
            ]
        },
        {
            ""input"": {
                ""arr1"": ""[]"",
                ""arr2"": ""[]""
            },
            ""expected"": ""[]"",
            ""unexpected"": [
                ""[0]"",
                ""[999]""
            ]
        },
        {
            ""input"": {
                ""arr1"": ""[-2, 0, 1]"",
                ""arr2"": ""[-3, -1]""
            },
            ""expected"": ""[-3, -2, -1, 0, 1]"",
            ""unexpected"": [
                ""[-3, -1]"",
                ""[0, 1]"",
                ""[-2, 0, 1]""
            ]
        },
        {
            ""input"": {
                ""arr1"": ""[10, 20, 30]"",
                ""arr2"": ""[5, 25, 35]""
            },
            ""expected"": ""[5, 10, 20, 25, 30, 35]"",
            ""unexpected"": [
                ""[10, 20, 30]"",
                ""[5, 25, 35]"",
                ""[10, 20, 25, 30, 35]""
            ]
        },
        {
            ""input"": {
                ""arr1"": ""[1, 2, 2]"",
                ""arr2"": ""[2, 3, 3]""
            },
            ""expected"": ""[1, 2, 2, 2, 3, 3]"",
            ""unexpected"": [
                ""[1, 2, 3]"",
                ""[2, 2, 2, 3, 3]""
            ]
        }
    ]
    */","use vstd::prelude::*;

verus! {",,"fn merge_sorted_lists(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)
    requires 
        forall|i: int, j: int| 0 <= i < j < arr1.len() ==> arr1[i] <= arr1[j],
        forall|i: int, j: int| 0 <= i < j < arr2.len() ==> arr2[i] <= arr2[j],
    ensures
        forall|i: int, j: int| 0 <= i < j < result.len() ==> result[i] <= result[j],
        result.len() == arr1.len() + arr2.len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVV04,0.85
VV0049,verus,verina,verina_advanced_50_task,,"This task involves merging two sorted arrays of natural numbers (it is ill defined if inputs aren't sorted.)
The input consists of two arrays:
a1: A sorted array of natural numbers
a2: A sorted array of natural numbers
The output is an array:
Returns a new array with all elements from both input arrays (included once and only once)
The resulting array is sorted itself

/*
    -- Invalid Inputs
    [
        {
            ""input"": {
                ""a1"": ""#[3, 2, 1]"",
                ""a2"": ""#[6, 5, 4]""
            }
        }
    ]
    -- Tests
    [
        {
            ""input"": {
                ""a1"": ""#[1, 3, 5]"",
                ""a2"": ""#[2, 4, 6]""
            },
            ""expected"": ""#[1, 2, 3, 4, 5, 6]"",
            ""unexpected"": [
                ""#[1, 3, 5, 2, 4, 6]"",
                ""#[2, 1, 3, 4, 5, 6]""
            ]
        },
        {
            ""input"": {
                ""a1"": ""#[]"",
                ""a2"": ""#[1, 2, 3]""
            },
            ""expected"": ""#[1, 2, 3]"",
            ""unexpected"": [
                ""#[]"",
                ""#[3, 2, 1]""
            ]
        },
        {
            ""input"": {
                ""a1"": ""#[1, 2, 3]"",
                ""a2"": ""#[]""
            },
            ""expected"": ""#[1, 2, 3]"",
            ""unexpected"": [
                ""#[]"",
                ""#[3, 2, 1]""
            ]
        },
        {
            ""input"": {
                ""a1"": ""#[]"",
                ""a2"": ""#[]""
            },
            ""expected"": ""#[]"",
            ""unexpected"": [
                ""#[1]""
            ]
        },
        {
            ""input"": {
                ""a1"": ""#[1, 1, 2]"",
                ""a2"": ""#[1, 2, 2]""
            },
            ""expected"": ""#[1, 1, 1, 2, 2, 2]"",
            ""unexpected"": [
                ""#[1, 1, 2, 1, 2, 2]"",
                ""#[1, 2]""
            ]
        },
        {
            ""input"": {
                ""a1"": ""#[10, 20, 30]"",
                ""a2"": ""#[5, 15, 25]""
            },
            ""expected"": ""#[5, 10, 15, 20, 25, 30]"",
            ""unexpected"": [
                ""#[10, 20, 30, 5, 15, 25]""
            ]
        },
        {
            ""input"": {
                ""a1"": ""#[1, 3, 5, 7, 9]"",
                ""a2"": ""#[2, 4, 6, 8, 10]""
            },
            ""expected"": ""#[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]"",
            ""unexpected"": [
                ""#[1, 3, 5, 7, 9, 2, 4, 6, 8, 10]""
            ]
        },
        {
            ""input"": {
                ""a1"": ""#[5, 5, 5]"",
                ""a2"": ""#[5, 5, 5]""
            },
            ""expected"": ""#[5, 5, 5, 5, 5, 5]"",
            ""unexpected"": [
                ""#[5, 5, 5]""
            ]
        }
    ]
    */","use vstd::prelude::*;

verus! {

spec fn is_sorted(v: Seq<nat>) -> bool {
    forall|i: int, j: int| 0 <= i < j < v.len() ==> #[trigger] v[i] <= #[trigger] v[j]
}",,"fn merge_sorted(a1: &Vec<nat>, a2: &Vec<nat>) -> (result: Vec<nat>)
    requires 
        is_sorted(a1@),
        is_sorted(a2@),
    ensures
        is_sorted(result@),
        result@.to_multiset() == a1@.to_multiset().add(a2@.to_multiset()),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0050,verus,verina,verina_advanced_51_task,,"This task requires writing a Verus method that takes two sorted (non-decreasing) integer lists and merges them into a single sorted list. The output must preserve order and include all elements from both input lists.

Input:
The input consists of:
a: A list of integers sorted in non-decreasing order.
b: Another list of integers sorted in non-decreasing order.

Output:
The output is a list of integers:
Returns a merged list that contains all elements from both input lists, sorted in non-decreasing order.

/* 
    -- Invalid Inputs
    [
        {
            ""input"": {
                ""a"": ""[1, 2, 3]"",
                ""b"": ""[6, 5, 4]""
            }
        },
        {
            ""input"": {
                ""a"": ""[3, 2, 1]"",
                ""b"": ""[6, 5, 4]""
            }
        }
    ]
    -- Tests
    [
        {
            ""input"": {
                ""a"": ""[1, 3, 5]"",
                ""b"": ""[2, 4, 6]""
            },
            ""expected"": ""[1, 2, 3, 4, 5, 6]"",
            ""unexpected"": [
                ""[1, 3, 5]"",
                ""[2, 4, 6]"",
                ""[6, 5, 4]""
            ]
        },
        {
            ""input"": {
                ""a"": ""[1, 2]"",
                ""b"": ""[1, 2, 3]""
            },
            ""expected"": ""[1, 1, 2, 2, 3]"",
            ""unexpected"": [
                ""[1, 2, 3]""
            ]
        },
        {
            ""input"": {
                ""a"": ""[]"",
                ""b"": ""[4, 5]""
            },
            ""expected"": ""[4, 5]"",
            ""unexpected"": [
                ""[]""
            ]
        },
        {
            ""input"": {
                ""a"": ""[0, 3, 4]"",
                ""b"": ""[]""
            },
            ""expected"": ""[0, 3, 4]"",
            ""unexpected"": [
                ""[4, 3, 0]""
            ]
        },
        {
            ""input"": {
                ""a"": ""[1, 4, 6]"",
                ""b"": ""[2, 3, 5]""
            },
            ""expected"": ""[1, 2, 3, 4, 5, 6]"",
            ""unexpected"": [
                ""[1, 4, 6, 2, 3, 5]""
            ]
        }
    ]
    */","use vstd::prelude::*;

verus! {

spec fn is_sorted(s: Seq<i32>) -> bool {
    forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] <= s[j]
}

spec fn multiset_equiv(s1: Seq<i32>, s2: Seq<i32>) -> bool {
    s1.to_multiset() == s2.to_multiset()
}",,"fn merge_sorted(a: Vec<i32>, b: Vec<i32>) -> (result: Vec<i32>)
    requires 
        is_sorted(a@),
        is_sorted(b@),
    ensures 
        is_sorted(result@),
        multiset_equiv(result@, a@ + b@),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVV04,0.85
VV0052,verus,verina,verina_advanced_53_task,,"This task requires writing a Verus function that calculates the minimum number of right shifts required to sort a given list of distinct positive integers.

A right shift operation on a list nums of length n moves the element at index i to index (i + 1) % n for all indices i. Effectively, the last element moves to the first position, and all other elements shift one position to the right.

The function should return the minimum number of right shifts needed to make the list sorted in ascending order. If the list is already sorted, the function should return 0. If it's impossible to sort the list using only right shifts, the function should return -1.

Input:
The input consists of a single list of integers:
nums: A vector (Vec<i32>) containing distinct positive integers.

Output:
The output is a single integer (i32):
- If the list can be sorted using right shifts, return the minimum number of shifts required (an integer >= 0).
- If the list cannot be sorted using right shifts, return -1.","use vstd::prelude::*;

verus! {",,"fn minimum_right_shifts(nums: Vec<i32>) -> (result: i32)
    requires
        nums.len() <= i32::MAX,
        forall|i: int, j: int| 0 <= i < nums.len() && 0 <= j < nums.len() && i != j ==> nums[i] != nums[j],
    ensures
        ({
            let n = nums.len() as i32;
            if n <= 1 {
                result == 0
            } else {
                (result >= 0 && result < n) || result == -1
            }
        }),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0054,verus,verina,verina_advanced_55_task,,"This task requires writing a Verus method that returns the integer that appears most frequently in the input list. If multiple integers have the same maximum frequency, return the one that appears first in the original list. You should implement a frequency counter using a fold over the list, extract the maximum frequency, and return the first element in the list that matches it.

Input: The input consists of xs: A list of integers (possibly with duplicates). The list is guaranteed to be non-empty.

Output: The output is an integer that appears the most frequently in the list. If there is a tie, the element that occurs first in the original list should be returned.

/* Helper function to count occurrences of a target value in a sequence */","use vstd::prelude::*;

verus! {

spec fn count_occurrences(xs: Seq<i32>, target: i32) -> nat {
    xs.filter(|x: i32| x == target).len()
}",,"fn most_frequent(xs: Vec<i32>) -> (result: i32)
    requires xs.len() > 0,
    ensures
        xs@.contains(result),
        forall|x: i32| xs@.contains(x) ==> count_occurrences(xs@, x) <= count_occurrences(xs@, result),
        exists|first_idx: int| 
            0 <= first_idx < xs.len() && 
            xs[first_idx] == result && 
            count_occurrences(xs@, result) == count_occurrences(xs@, xs[first_idx]) &&
            forall|i: int| 0 <= i < first_idx ==> count_occurrences(xs@, xs[i]) < count_occurrences(xs@, result),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0055,verus,verina,verina_advanced_56_task,,"This task requires writing a Verus method that moves all zeroes in a given integer vector to the end, while preserving the relative order of the non-zero elements.

The method `move_zeroes` processes the input vector by separating the non-zero and zero elements. It then returns a new vector formed by appending all non-zero elements followed by all the zero elements.

-----Input-----
The input is a single vector of integers:
xs: A vector of integers (type: Vec<i32>), possibly containing zero and non-zero values.

-----Output-----
The output is a vector of integers:
Returns a vector (type: Vec<i32>) with the same elements as the input, where all zeroes appear at the end, and the non-zero elements maintain their original relative order.

/* Count how many times a specific value appears in the sequence */

/* Check whether one sequence is a subsequence of another (preserving relative order) */

/* All non-zero elements must maintain their relative order */

/* All zeroes must be located at the end of the output vector */

/* The output must contain the same number of elements */

/* The number of zeroes must remain unchanged */","use vstd::prelude::*;

verus! {

spec fn count_val(val: i32, xs: Seq<i32>) -> nat 
    decreases xs.len()
{
    if xs.len() == 0 {
        0
    } else {
        let rest = count_val(val, xs.drop_first());
        if xs[0] == val { rest + 1 } else { rest }
    }
}

spec fn is_subsequence(xs: Seq<i32>, ys: Seq<i32>) -> bool 
    decreases xs.len() + ys.len()
{
    if xs.len() == 0 {
        true
    } else if ys.len() == 0 {
        false
    } else {
        if xs[0] == ys[0] {
            is_subsequence(xs.drop_first(), ys.drop_first())
        } else {
            is_subsequence(xs, ys.drop_first())
        }
    }
}",,"fn move_zeroes(xs: Vec<i32>) -> (result: Vec<i32>)
    ensures

        is_subsequence(xs@.filter(|x: i32| x != 0), result@),

        forall|i: int| 0 <= i < result.len() && result[i] != 0 ==> 
            forall|j: int| i < j < result.len() ==> result[j] != 0,

        xs.len() == result.len(),

        count_val(0, xs@) == count_val(0, result@),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0056,verus,verina,verina_advanced_57_task,,"This task requires writing a Verus function that finds the next greater element for a given array of numbers. The next greater element for an element x is defined as the first element greater than x that appears to the right of x in the array.

Given two distinct 0-indexed integer arrays `nums1` and `nums2`, where `nums1` is a subset of `nums2`, the function should determine the next greater element for each value in `nums1` as it appears in `nums2`.
All integers in both arrays are unique, and the length constraints are.

Input:
The input consists of two lists of integers:
nums1: A list of integers, which is a subset of nums2.
nums2: A list of integers containing all elements from nums1 and possibly additional elements.

Output:
The output is a list of integers:
- An array of the same length as nums1.
- For each element nums1[i], the corresponding output element is:
  - The next greater element of nums1[i] in nums2 if one exists
  - -1 if there is no next greater element","use vstd::prelude::*;

verus! {",,"fn next_greater_element(nums1: &Vec<i32>, nums2: &Vec<i32>) -> (result: Vec<i32>)
    requires
        forall|i: int, j: int| 0 <= i < nums1.len() && 0 <= j < nums1.len() && i != j ==> nums1[i] != nums1[j],
        forall|i: int, j: int| 0 <= i < nums2.len() && 0 <= j < nums2.len() && i != j ==> nums2[i] != nums2[j],
    ensures
        result.len() == nums1.len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0057,verus,verina,verina_advanced_58_task,,"This task requires writing a Verus function that returns the nth ""ugly number"". Ugly numbers are positive integers whose only prime factors are 2, 3, or 5.

The function should generate ugly numbers in ascending order and return the nth one. The first ugly number is 1.

Input:
The input is a natural number:

n: The index (1-based) of the ugly number to return.

Output:
The output is a natural number:
The nth smallest ugly number.","use vstd::prelude::*;

verus! {

spec fn nth_ugly_number_precond(n: nat) -> bool {
    n > 0
}",,"fn nth_ugly_number(n: u32) -> (result: u32)
    requires n > 0,
    ensures result > 0,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0058,verus,verina,verina_advanced_59_task,,"This task requires writing a Verus method that determines if a given string is a palindrome, ignoring all
non-alphanumeric characters and case differences. For example, the string ""A man, a plan, a canal: Panama"" should return
true.

-----Input-----
A single string:
s: The string to check for palindrome property.

-----Output-----
A boolean (Bool):
true if s is a palindrome when ignoring non-alphanumeric characters and case. false otherwise.

/* Tests
    [
        {
            ""input"": {
                ""s"": """"
            },
            ""expected"": true,
            ""unexpected"": [
                false
            ]
        },
        {
            ""input"": {
                ""s"": ""A man, a plan, a canal: Panama""
            },
            ""expected"": true,
            ""unexpected"": [
                false
            ]
        },
        {
            ""input"": {
                ""s"": ""race a car""
            },
            ""expected"": false,
            ""unexpected"": [
                true
            ]
        },
        {
            ""input"": {
                ""s"": ""No 'x' in Nixon""
            },
            ""expected"": true,
            ""unexpected"": [
                false
            ]
        },
        {
            ""input"": {
                ""s"": ""abc!!cba?""
            },
            ""expected"": true,
            ""unexpected"": [
                false
            ]
        },
        {
            ""input"": {
                ""s"": ""Hello, world!""
            },
            ""expected"": false,
            ""unexpected"": [
                true
            ]
        }
    ] */","use vstd::prelude::*;

verus! {

spec fn is_alphanumeric(c: char) -> bool {
    ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || ('0' <= c && c <= '9')
}

spec fn to_lowercase(c: char) -> char {
    if 'A' <= c && c <= 'Z' {
        ((c as u32) + 32) as char
    } else {
        c
    }
}",,"fn palindrome_ignore_non_alnum(s: &str) -> (result: bool)
    ensures 
        result <==> ({
            let chars_seq = s@;
            let cleaned = chars_seq.filter(|c: char| is_alphanumeric(c)).map(|i, c: char| to_lowercase(c));
            let forward = cleaned;
            let backward = cleaned.reverse();
            forward == backward
        })","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0059,verus,verina,verina_advanced_60_task,,"This task requires writing a Verus method that takes a list of natural numbers and partitions it into two separate lists: one containing all the even numbers and the other containing all the odd numbers. The order of elements in each sublist should match their appearance in the original list. Assume there are no duplicates in the input.

Input:
The input consists of a single list with no duplicate natural numbers:
- nums: A list of natural numbers (nat)

Output:
The output is a tuple of two lists:
- The first list contains all even numbers from the input list, in order.
- The second list contains all odd numbers from the input list, in order.","use vstd::prelude::*;

verus! {",,"fn partition_evens_odds(nums: &Vec<nat>) -> (result: (Vec<nat>, Vec<nat>))
    requires true,
    ensures ({
        let evens = result.0;
        let odds = result.1;
        &&& evens@ + odds@ == nums@.filter(|n: nat| n % 2 == 0) + nums@.filter(|n: nat| n % 2 == 1)
        &&& forall|i: int| 0 <= i < evens.len() ==> evens[i] % 2 == 0
        &&& forall|i: int| 0 <= i < odds.len() ==> odds[i] % 2 == 1
    }),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0060,verus,verina,verina_advanced_61_task,,"This task requires writing a Verus function that takes a list of integers and returns a new list. For each index i in the input list, the output at i is equal to the product of all numbers in the list except the number at index i. The solution must run in O(n) time without using the division operation.

The input is a list of integers. For example, [1,2,3,4].

The output is a list of integers where each element at index i is the product of every input element except the one at that index. For example, for the input [1,2,3,4], the output should be [24,12,8,6]. Each intermediate product is guaranteed to fit in a 32-bit integer.

/* Helper: Product of a sequence of integers */","use vstd::prelude::*;

verus! {

spec fn list_product(nums: Seq<i32>) -> int
    decreases nums.len()
{
    if nums.len() == 0 { 1int } else { nums[0] as int * list_product(nums.subrange(1, nums.len() as int)) }
}",,"fn product_except_self(nums: &Vec<i32>) -> (result: Vec<i32>)
    ensures
        result.len() == nums.len(),
        forall|i: int| 0 <= i < nums.len() ==> 
            result[i] as int == list_product(nums@.subrange(0, i)) * list_product(nums@.subrange(i + 1, nums.len() as int)),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0061,verus,verina,verina_advanced_62_task,,"This task requires writing a Verus method that calculates how much rainwater would be trapped by a terrain represented as an array of heights. Imagine rainwater falls onto a terrain with varying elevation levels. The water can only be trapped between higher elevation points.

Given an array of non-negative integers representing the elevation map where the width of each bar is 1 unit, calculate how much water can be trapped after it rains.

Input:
The input consists of one array:
heights: An array of non-negative integers representing elevation levels.

Output:
The output is an integer:
Returns the total amount of rainwater that can be trapped.","use vstd::prelude::*;

verus! {",,"fn rain(heights: &Vec<i32>) -> (result: i32)
    requires forall|i: int| 0 <= i < heights.len() ==> heights[i] >= 0,
    ensures 
        result >= 0,
        heights.len() < 3 ==> result == 0,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0062,verus,verina,verina_advanced_63_task,,"This task requires writing a Verus method that counts the unique elements from a sorted array.

-----Input-----
The input is a single list of integers:
nums: An array of integers sorted in non-decreasing order.

-----Output-----
The output is a single integer:
Returns the number of unique elements (k).

/* 
    -- Invalid Inputs
    [
        {
            ""input"": {
                ""nums"": ""[3, 2, 1]""
            }
        }
    ]
    -- Tests
    [
        {
            ""input"": {
                ""nums"": ""[1, 1, 2]""
            },
            ""expected"": 2,
            ""unexpected"": [
                1,
                3
            ]
        },
        {
            ""input"": {
                ""nums"": ""[0, 0, 1, 1, 1, 2, 2, 3, 3, 4]""
            },
            ""expected"": 5,
            ""unexpected"": [
                4,
                10
            ]
        },
        {
            ""input"": {
                ""nums"": ""[-1, -1, 0, 1, 2, 2, 3]""
            },
            ""expected"": 5,
            ""unexpected"": [
                3
            ]
        },
        {
            ""input"": {
                ""nums"": ""[1, 2, 3, 4, 5]""
            },
            ""expected"": 5,
            ""unexpected"": [
                4
            ]
        },
        {
            ""input"": {
                ""nums"": ""[1, 1, 1, 1]""
            },
            ""expected"": 1,
            ""unexpected"": [
                2,
                4
            ]
        },
        {
            ""input"": {
                ""nums"": ""[]""
            },
            ""expected"": 0,
            ""unexpected"": [
                1
            ]
        },
        {
            ""input"": {
                ""nums"": ""[1]""
            },
            ""expected"": 1,
            ""unexpected"": [
                0,
                2
            ]
        },
        {
            ""input"": {
                ""nums"": ""[-100, -100, -100]""
            },
            ""expected"": 1,
            ""unexpected"": [
                2,
                3
            ]
        },
        {
            ""input"": {
                ""nums"": ""[-100, -99, -99, -50, 0, 0, 100, 100]""
            },
            ""expected"": 5,
            ""unexpected"": [
                6,
                7
            ]
        },
        {
            ""input"": {
                ""nums"": ""[-1, 0, 0, 0, 1, 2, 2, 3, 4, 4, 5]""
            },
            ""expected"": 7,
            ""unexpected"": [
                6,
                10
            ]
        },
        {
            ""input"": {
                ""nums"": ""[100, 100, 100, 101, 102, 102, 103, 104, 105, 105]""
            },
            ""expected"": 6,
            ""unexpected"": [
                5,
                7
            ]
        }
    ]
    */","use vstd::prelude::*;

verus! {",,"fn remove_duplicates(nums: &Vec<i32>) -> (result: usize)
    requires forall|i: int, j: int| 0 <= i < j < nums.len() ==> nums[i] <= nums[j],
    ensures result <= nums.len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0063,verus,verina,verina_advanced_64_task,,"This task requires writing a Verus method that removes all occurrences of a given element from a list of natural numbers. The method should return a new list that contains all the elements of the original list except those equal to the target number. The order of the remaining elements must be preserved.

-----Input-----
The input consists of two elements:
lst: A list of natural numbers (Vec<nat>).
target: A natural number to be removed from the list.

-----Output-----
The output is a list of natural numbers:
Returns a new list with all occurrences of the target number removed. The relative order of the remaining elements must be the same as in the input list.","use vstd::prelude::*;

verus! {",,"fn remove_element(lst: &Vec<nat>, target: nat) -> (result: Vec<nat>)
    ensures
        forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i] != target,
        forall|i: int| 0 <= i < result.len() ==> 
            exists|j: int| 0 <= j < lst.len() && #[trigger] lst[j] == #[trigger] result[i] && lst[j] != target,
        forall|i: int, j: int| 0 <= i < j < lst.len() && lst[i] != target && lst[j] != target ==> 
            exists|k1: int, k2: int| 0 <= k1 < k2 < result.len() && 
            result[k1] == lst[i] && result[k2] == lst[j],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0064,verus,verina,verina_advanced_65_task,,"This task requires writing a Verus method that reverses a given string. The method should return a new string which consists of the characters of the input string in reverse order.

-----Input-----
The input consists of:
s: A string (which may be empty).

-----Output-----
The output is a string:
Returns a string where the characters are in reverse order from the original input.","use vstd::prelude::*;

verus! {",,"fn reverse_string(s: &Vec<char>) -> (result: Vec<char>)
    ensures
        result@.len() == s@.len(),
        forall|i: int| 0 <= i < s@.len() ==> result@[i] == s@[s@.len() - 1 - i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0065,verus,verina,verina_advanced_66_task,,"Given an input string ""words_str"", this task requires writing a Verus function that reverses the order of its words. A word is defined as a contiguous sequence of non-space characters. The function must remove any extra spaces so that the output string contains words separated by a single space and has no leading or trailing spaces. The characters within each word must stay the same as the original input.

-----Input-----
words_str: A string that may contain leading, trailing, or multiple spaces between words.

-----Output-----
A string with the words from the input reversed, where words are separated by a single space, with no extra spaces at the beginning or end.","use vstd::prelude::*;

verus! {",,fn reverse_words(words_str: &str) -> (result: String),"{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0066,verus,verina,verina_advanced_67_task,,"This task requires writing a Verus method that performs run-length encoding on a given string. The method should scan the string from left to right and group consecutive identical characters into pairs. Each pair consists of the character itself and the number of times it appears consecutively. For example, ""aaabbc"" becomes [('a', 3), ('b', 2), ('c', 1)].

The resulting encoded list must satisfy the following properties:
1. No pair has a zero or negative run-length.
2. Consecutive pairs in the encoding list must not have the same character.
3. Decoding the output should return the original string.

-----Input-----
The input is a single string, `s`.

-----Output-----
The output is a list of pairs `(Char, Nat)`, which represents the run-length-encoded form of the input string.","use vstd::prelude::*;

verus! {

spec fn decode_rle(lst: Vec<(char, usize)>) -> Seq<char> {
    Seq::empty()
}",,"fn run_length_encode(s: &Vec<char>) -> (result: Vec<(char, usize)>)
    ensures
        forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i].1 > 0,
        forall|i: int| 0 <= i < result.len() ==> i + 1 < result.len() ==> #[trigger] result[i].0 != result[i + 1].0,
        decode_rle(result) == s@,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0067,verus,verina,verina_advanced_68_task,,"This task requires implementing a Run-Length Encoding (RLE) algorithm in Verus. The method should take a string as input and return a compressed string where consecutive duplicate characters are replaced by the character followed by its count. The output must strictly alternate between characters and digits, reconstruct to the original input when decoded, and return a non-empty string if and only if the input is non-empty.

Input: The input is a string consisting of any characters (including special characters and digits).

Output: The output is a string where each sequence of identical characters is replaced by the character followed by its count. The output must:
1. Alternate between characters and digits (e.g., ""a3b2"").
2. Reconstruct to the original input when decoded.
3. Be non-empty if and only if the input is non-empty.

// Non-empty check: input is empty iff result is empty

// Format validation: result alternates between characters and digits","use vstd::prelude::*;

verus! {",,"spec fn is_digit(c: char) -> bool {
    '0' <= c && c <= '9'  
}

proof fn run_length_encoder_property(input: String, result: String)
    requires

        input@ == Seq::<char>::empty() <==> result@ == Seq::<char>::empty(),

        (result@.len() > 0 ==> (
            forall|i: int| 0 <= i < result@.len() ==> 
                (i % 2 == 0 ==> !is_digit(result@[i])) &&
                (i % 2 == 1 ==> is_digit(result@[i]))
        )),","{
    assume(false);      
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0068,verus,verina,verina_advanced_69_task,,"Given a sorted list of distinct integers and a target value, return the index if the target is found. If it is not found, return the index where it would be inserted to maintain the sorted order.

This function must preserve the sorted property of the list. The list is assumed to be strictly increasing and contain no duplicates.

-----Input-----
xs : List Int — a sorted list of distinct integers in increasing order
target : Int — the integer to search for

-----Output-----
A natural number (Nat) representing the index at which the target is found, or the index at which it should be inserted to maintain sorted order.

/* Invalid Inputs
    [
        {
            ""input"": {
                ""xs"": ""[2, 1]"",
                ""target"": 5
            }
        },
        {
            ""input"": {
                ""xs"": ""[1, 1]"",
                ""target"": 2
            }
        }
    ]
    -- Tests
    [
        {
            ""input"": {
                ""xs"": ""[1, 3, 5, 6]"",
                ""target"": 5
            },
            ""expected"": 2,
            ""unexpected"": [
                0,
                1,
                3,
                4
            ]
        },
        {
            ""input"": {
                ""xs"": ""[1, 3, 5, 6]"",
                ""target"": 2
            },
            ""expected"": 1,
            ""unexpected"": [
                0,
                2,
                3
            ]
        },
        {
            ""input"": {
                ""xs"": ""[1, 3, 5, 6]"",
                ""target"": 7
            },
            ""expected"": 4,
            ""unexpected"": [
                2,
                3
            ]
        },
        {
            ""input"": {
                ""xs"": ""[1, 3, 5, 6]"",
                ""target"": 0
            },
            ""expected"": 0,
            ""unexpected"": [
                1,
                2
            ]
        },
        {
            ""input"": {
                ""xs"": ""[]"",
                ""target"": 3
            },
            ""expected"": 0,
            ""unexpected"": [
                1
            ]
        },
        {
            ""input"": {
                ""xs"": ""[10]"",
                ""target"": 5
            },
            ""expected"": 0,
            ""unexpected"": [
                1
            ]
        },
        {
            ""input"": {
                ""xs"": ""[10]"",
                ""target"": 15
            },
            ""expected"": 1,
            ""unexpected"": [
                0
            ]
        }
    ]
    */","use vstd::prelude::*;

verus! {",,"fn search_insert(xs: &Vec<i32>, target: i32) -> (result: usize)
    requires forall|i: int, j: int| 0 <= i < j < xs.len() ==> xs[i] < xs[j],
    ensures
        result <= xs.len(),
        forall|i: int| 0 <= i < result ==> xs[i] < target,
        result < xs.len() ==> target <= xs[result as int],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0069,verus,verina,verina_advanced_70_task,,"This task requires writing a Verus method that's goal is to determine the minimum number of adjacent swaps needed to make the array semi-ordered. You may repeatedly swap 2 adjacent elements in the array. A permutation is called semi-ordered if the first number equals 1 and the last number equals n.

Input:

The input consists of:
- nums: A vector of integers.

Output:

The output is an integer.","use vstd::prelude::*;

verus! {",,"fn semi_ordered_permutation(nums: &Vec<i32>) -> (result: i32)
    ensures 
        result >= 0","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0072,verus,verina,verina_advanced_73_task,,"This task requires writing a Verus method that finds the first missing natural number in an increasingly sorted list. The method should return the smallest natural number that is not in the list, ensuring that all natural numbers that are smaller is inside the list.

-----Input-----
The input consists of a list of natural numbers sorted in increasing order:
l: The sorted list

-----Output-----
The output is a natural number:
Returns the smallest natural number that is not in the list, which means all natural numbers that are smaller than the returned value should be inside the input list.","use vstd::prelude::*;

verus! {",,"fn smallest_missing(l: Seq<nat>) -> (result: nat)
    requires forall|i: int, j: int| 0 <= i < j < l.len() ==> l[i] < l[j],
    ensures
        !l.contains(result),
        forall|candidate: nat| candidate < result ==> l.contains(candidate)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0073,verus,verina,verina_advanced_74_task,,"This task requires writing a Verus function called `solution` that takes a vector of natural numbers `nums`. The function should calculate and return the sum of values obtained for each subarray, where the value for a subarray is the square of the count of distinct elements within that subarray.

Input:
The input is a vector of natural numbers:
`nums`: A vector where each element is a natural number.
Constraints:
- The length of the vector `nums` (n) is between 1 and 100 (inclusive).
- Each element in `nums` is between 1 and 100 (inclusive).

Output:
The output is a natural number:
Returns the total sum of squared distinct counts for all subarrays.","use vstd::prelude::*;

verus! {",,"fn solution(nums: Vec<u32>) -> (result: u32)
    requires
        1 <= nums.len() <= 100,
        forall|i: int| 0 <= i < nums.len() ==> #[trigger] nums[i] >= 1 && #[trigger] nums[i] <= 100,
    ensures
        result >= 0,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0074,verus,verina,verina_advanced_75_task,,"Given a sequence of n integers, your task is to find the largest sum obtainable by choosing a contiguous subarray of the sequence. At least one number must be selected.

The algorithm uses dynamic programming (Kadane's Algorithm) to solve the problem:
1. Initialize the current maximum (cur) and the overall maximum (maxSoFar) with the first element.
2. For each subsequent element, update:
     cur = max(element, cur + element)
     maxSoFar = max(maxSoFar, cur)
3. Return maxSoFar as the answer.

Input:
The input is provided as a list of integers:
  sequence: A list of n integers.

Output:
The output is a single integer representing the maximum subarray sum.

/* 
    -- Invalid Inputs
    []
    -- Tests
    [
        {
            ""input"": {
                ""sequence"": ""[10, -4, 3, 1, 5, 6, -35, 12, 21, -1]""
            },
            ""expected"": 33,
            ""unexpected"": [
                32,
                34,
                0
            ]
        },
        {
            ""input"": {
                ""sequence"": ""[2, 1, -4, 3, 4, -4, 6, 5, -5, 1]""
            },
            ""expected"": 14,
            ""unexpected"": [
                13,
                15,
                0
            ]
        },
        {
            ""input"": {
                ""sequence"": ""[-1, -2, -3, -4, -5]""
            },
            ""expected"": -1,
            ""unexpected"": [
                -2,
                0,
                1
            ]
        },
        {
            ""input"": {
                ""sequence"": ""[7]""
            },
            ""expected"": 7,
            ""unexpected"": [
                0,
                1,
                -7
            ]
        },
        {
            ""input"": {
                ""sequence"": ""[1, 2, 3, 4, 5]""
            },
            ""expected"": 15,
            ""unexpected"": [
                14,
                16,
                0
            ]
        }
    ]
    */","use vstd::prelude::*;

verus! {

spec fn spec_subarray_sum(sequence: Seq<i32>, start: int, end: int) -> int
    decreases end - start
{
    if start >= end || start < 0 || end > sequence.len() {
        0
    } else if start + 1 == end {
        sequence[start] as int
    } else {
        sequence[start] as int + spec_subarray_sum(sequence, start + 1, end)
    }
}",,"fn task_code(sequence: Vec<i32>) -> (result: i32)
    requires sequence.len() > 0,
    ensures 
        exists|start: int, end: int| 
            0 <= start < end <= sequence.len() && 
            result as int == spec_subarray_sum(sequence@, start, end) &&
            forall|s: int, e: int| (0 <= s < e <= sequence.len()) ==> 
                spec_subarray_sum(sequence@, s, e) <= result as int,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0075,verus,verina,verina_advanced_76_task,,"This task requires writing a Verus method that returns the k most frequent elements from a list of integers. The method should count the frequency of each distinct element in the list and return the k elements with the highest frequency.

-----Input-----
The input consists of two values:
nums: A list of integers, possibly with duplicates.
k: A natural number indicating how many of the most frequent elements to return. Assuming k <= # of distinct elements in nums.

-----Output-----
The output is a list of integers:
Returns exactly k integers representing the elements that appear most frequently in the input list in the order from the higher frequency to lower frequency.
If two numbers have the same frequency, use the order of the first occurrence in nums.

/*
    -- Invalid Inputs
    [
        {
            ""input"": {
                ""nums"": ""[1, 2, 3]"",
                ""k"": 4
            }
        }
    ]
    -- Tests
    [
        {
            ""input"": {
                ""nums"": ""[1, 1, 1, 2, 2, 3]"",
                ""k"": 2
            },
            ""expected"": ""[1, 2]"",
            ""unexpected"": [
                ""[1, 3]"",
                ""[2, 3]""
            ]
        },
        {
            ""input"": {
                ""nums"": ""[4, 1, -1, 2, -1, 2, 3]"",
                ""k"": 2
            },
            ""expected"": ""[-1, 2]"",
            ""unexpected"": [
                ""[-1, 4]"",
                ""[4, 3]""
            ]
        },
        {
            ""input"": {
                ""nums"": ""[5]"",
                ""k"": 1
            },
            ""expected"": ""[5]"",
            ""unexpected"": [
                ""[]""
            ]
        },
        {
            ""input"": {
                ""nums"": ""[7, 7, 7, 8, 8, 9]"",
                ""k"": 1
            },
            ""expected"": ""[7]"",
            ""unexpected"": [
                ""[8]""
            ]
        },
        {
            ""input"": {
                ""nums"": ""[]"",
                ""k"": 0
            },
            ""expected"": ""[]"",
            ""unexpected"": [
                ""[0]""
            ]
        }
    ]
    */","use vstd::prelude::*;
use vstd::seq_lib::*;

verus! {",,"fn top_k_frequent(nums: &Vec<i32>, k: usize) -> (result: Vec<i32>)
    requires 
        k <= nums@.to_set().len(),
    ensures
        result.len() == k,
        forall|x: i32| result@.contains(x) ==> nums@.contains(x),
        result@.no_duplicates(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0076,verus,verina,verina_advanced_77_task,,"This task requires writing a Verus function that calculates how much water can be trapped between elevations after it rains. The input is a vector of non-negative integers representing an elevation map. Each index traps water depending on the min of max heights to its left and right.

Input:
- height: A vector of natural numbers representing elevations.

Output:
- A natural number: total units of water that can be trapped.","use vstd::prelude::*;

verus! {",,"fn trap_rain_water(height: &Vec<usize>) -> (result: usize)
    requires height.len() >= 0,
    ensures result >= 0,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0077,verus,verina,verina_advanced_78_task,,"This task requires writing a Verus method that solves the Two Sum problem. Given a list of integers and a target integer, the method must return a pair of indices such that the sum of the numbers at those indices equals the target. You may assume that each input has exactly one solution and that you may not use the same element twice. The answer should be returned with first index is smaller than the second.

-----Input-----
The input consists of:
- nums: A list of integers.
- target: An integer representing the target sum.

-----Output-----
The output is a pair (tuple) of integers representing the indices of the two numbers in the input list that add up to the target.","use vstd::prelude::*;

verus! {",,"fn two_sum(nums: &Vec<i32>, target: i32) -> (result: (usize, usize))
    requires
        nums.len() > 1,
        exists|i: int, j: int| 0 <= i < j < nums.len() && nums[i] + nums[j] == target,
    ensures
        result.0 < result.1,
        result.0 < nums.len(),
        result.1 < nums.len(),
        nums[result.0 as int] + nums[result.1 as int] == target,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0078,verus,verina,verina_advanced_79_task,,"This task requires writing a Verus method that implementing the ""Two Sum"" problem. Given a list of integers
and a target integer, the function should return the indices of the two numbers that add up to
the target. If no valid pair exists, the function should return none. And the indices returned must
be within the bounds of the list. If multiple pair exists, return the first pair.

-----Input-----
- nums: A list of integers.
- target: An integer representing the target sum.

-----Output-----
- An option type containing a pair of natural numbers (indices) such that
  nums[i] + nums[j] = target, if such a pair exists. Otherwise, it returns none.

/*
    -- Tests
    [
        {
            ""input"": {
                ""nums"": ""[2, 7, 11, 15]"",
                ""target"": 9
            },
            ""expected"": ""some (0, 1)"",
            ""unexpected"": [
                ""some (1, 2)"",
                ""none""
            ]
        },
        {
            ""input"": {
                ""nums"": ""[3, 2, 4]"",
                ""target"": 6
            },
            ""expected"": ""some (1, 2)"",
            ""unexpected"": [
                ""some (0, 2)"",
                ""none""
            ]
        },
        {
            ""input"": {
                ""nums"": ""[3, 3]"",
                ""target"": 6
            },
            ""expected"": ""some (0, 1)"",
            ""unexpected"": [
                ""some (1, 1)"",
                ""none""
            ]
        },
        {
            ""input"": {
                ""nums"": ""[1, 2, 3]"",
                ""target"": 7
            },
            ""expected"": ""none"",
            ""unexpected"": [
                ""some (0, 2)""
            ]
        },
        {
            ""input"": {
                ""nums"": ""[0, 4, 3, 0]"",
                ""target"": 0
            },
            ""expected"": ""some (0, 3)"",
            ""unexpected"": [
                ""some (1, 2)"",
                ""none""
            ]
        }
    ]
    */","use vstd::prelude::*;

verus! {",,"fn two_sum(nums: Vec<i32>, target: i32) -> (result: Option<(usize, usize)>)
    ensures
        match result {
            None => {
                forall|i: int, j: int| 0 <= i < nums.len() && 0 <= j < nums.len() && i != j ==> nums[i] + nums[j] != target
            },
            Some((i, j)) => {
                i < j &&
                j < nums.len() &&
                nums[i as int] + nums[j as int] == target &&
                forall|k1: int, k2: int| 0 <= k1 < nums.len() && 0 <= k2 < nums.len() && k1 < k2 && (k1 < i || (k1 == i && k2 < j)) ==> nums[k1] + nums[k2] != target
            }
        },","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0079,verus,verina,verina_advanced_80_task,,"This task requires writing a Verus method that finds the indices of two numbers in an array that add up to a target value. Given an array of integers and a target integer, the function should return the indices of the two numbers such that they add up to the target.

You may assume that each input has exactly one solution, and you may not use the same element twice.

-----Input-----
The input consists of:
nums: An array of integers.
target: An integer representing the target sum.

-----Output-----
The output is an array of two integers:
Returns the indices of the two numbers in the array that add up to the target. The indices should be sorted.","use vstd::prelude::*;

verus! {",,"fn two_sum(nums: &Vec<i32>, target: i32) -> (result: Vec<usize>)
    requires 
        nums.len() >= 2,
        exists|i: int, j: int| 0 <= j < i < nums.len() && nums[i] + nums[j] == target,
        forall|i1: int, j1: int, i2: int, j2: int| 
            (0 <= j1 < i1 < nums.len() && nums[i1] + nums[j1] == target &&
             0 <= j2 < i2 < nums.len() && nums[i2] + nums[j2] == target) ==> 
            (i1 == i2 && j1 == j2),
    ensures
        result.len() == 2,
        result[0] < nums.len(),
        result[1] < nums.len(),
        result[0] < result[1],
        nums[result[0] as int] + nums[result[1] as int] == target,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0080,verus,verina,verina_advanced_81_task,,"Implement a Verus function that, given a list of integers, removes all duplicates and returns the resulting list in ascending order.

Input:
The input consists of a single list of integers:
arr: A list of integers.

Output:
The output is a list of integers:
Returns a list containing the unique elements of the input, sorted in ascending order. The returned list must not contain any duplicates, and every element in the output must appear in the original input list.","use vstd::prelude::*;

verus! {",,"fn unique_sorted(arr: &Vec<i32>) -> (result: Vec<i32>)
    ensures
        result.len() <= arr.len(),
        forall|i: int| 0 <= i < result.len() - 1 ==> #[trigger] result[i] <= result[i + 1],
        forall|x: i32| arr@.contains(x) <==> result@.contains(x),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0082,verus,verina,verina_basic_2_task,,"This task requires writing a Verus method that finds the smallest number in an array of integers.

-----Input-----
The input consists of:
s: An array of integers.

-----Output-----
The output is an option integer:
Returns the smallest number found in the input array or none if the array is empty.","use vstd::prelude::*;

verus! {",,"fn find_smallest(s: &Vec<nat>) -> (result: Option<nat>)
    ensures
        match result {
            None => s.len() == 0,
            Some(r) => s.len() > 0 && 
                      (exists|i: int| 0 <= i < s.len() && s[i] == r) &&
                      (forall|i: int| 0 <= i < s.len() ==> r <= s[i])
        },","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVV00,0.85
VV0083,verus,verina,verina_basic_3_task,,"This task requires writing a Verus method that determines whether a given integer is divisible by 11. The method should return true if the number is divisible by 11 and false otherwise.

-----Input-----
The input consists of:
n: An integer to check for divisibility by 11.

-----Output-----
The output is a Boolean value:
Returns true if the input number is divisible by 11.
Returns false if the input number is not divisible by 11.

/* 
    // -- Invalid Inputs
    // []
    // -- Tests
    // [
    //     {
    //         ""input"": {
    //             ""n"": 0
    //         },
    //         ""expected"": true,
    //         ""unexpected"": [
    //             false
    //         ]
    //     },
    //     {
    //         ""input"": {
    //             ""n"": 11
    //         },
    //         ""expected"": true,
    //         ""unexpected"": [
    //             false
    //         ]
    //     },
    //     {
    //         ""input"": {
    //             ""n"": 22
    //         },
    //         ""expected"": true,
    //         ""unexpected"": [
    //             false
    //         ]
    //     },
    //     {
    //         ""input"": {
    //             ""n"": 23
    //         },
    //         ""expected"": false,
    //         ""unexpected"": [
    //             true
    //         ]
    //     },
    //     {
    //         ""input"": {
    //             ""n"": 33
    //         },
    //         ""expected"": true,
    //         ""unexpected"": [
    //             false
    //         ]
    //     },
    //     {
    //         ""input"": {
    //             ""n"": 44
    //         },
    //         ""expected"": true,
    //         ""unexpected"": [
    //             false
    //         ]
    //     },
    //     {
    //         ""input"": {
    //             ""n"": -11
    //         },
    //         ""expected"": true,
    //         ""unexpected"": [
    //             false
    //         ]
    //     },
    //     {
    //         ""input"": {
    //             ""n"": -22
    //         },
    //         ""expected"": true,
    //         ""unexpected"": [
    //             false
    //         ]
    //     },
    //     {
    //         ""input"": {
    //             ""n"": 1
    //         },
    //         ""expected"": false,
    //         ""unexpected"": [
    //             true
    //         ]
    //     },
    //     {
    //         ""input"": {
    //             ""n"": -1
    //         },
    //         ""expected"": false,
    //         ""unexpected"": [
    //             true
    //         ]
    //     },
    //     {
    //         ""input"": {
    //             ""n"": 121
    //         },
    //         ""expected"": true,
    //         ""unexpected"": [
    //             false
    //         ]
    //     },
    //     {
    //         ""input"": {
    //             ""n"": 123
    //         },
    //         ""expected"": false,
    //         ""unexpected"": [
    //             true
    //         ]
    //     }
    // ]
    // */

//","use vstd::prelude::*;

verus! {",,"fn is_divisible_by_11(n: i32) -> (result: bool)
    ensures
        result <==> (exists|k: int| #[trigger] (k * 11) == n),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0084,verus,verina,verina_basic_4_task,,"This task requires writing a Verus method that finds the kth element in a given array using 1-based indexing. The method should return the element at the specified position, where the first element is at position 1.

-----Input-----
The input consists of:
arr: An array of integers.
k: An integer representing the position (1-based index) of the element to find.

-----Output-----
The output is an integer:
Returns the element at the kth position in the array.

-----Note-----
The input k is assumed to be valid (between 1 and array length inclusive).
The array is assumed to be non-empty.","use vstd::prelude::*;

verus! {",,"fn kth_element_impl(arr: &Vec<i32>, k: usize) -> (result: i32)
    requires k >= 1 && k <= arr.len(),
    ensures result == arr[k as int - 1]","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0085,verus,verina,verina_basic_5_task,,"This task requires writing a Verus method that multiplies two integers. The method should return the product of the two input numbers.

-----Input-----
The input consists of:
a: The first integer.
b: The second integer.

-----Output-----
The output is an integer:
Returns the product of the two input integers (a * b).

/*
    -- Invalid Inputs
    []
    -- Tests
    [
        {
            ""input"": {
                ""a"": 3,
                ""b"": 4
            },
            ""expected"": 12,
            ""unexpected"": [
                0,
                11,
                15
            ]
        },
        {
            ""input"": {
                ""a"": 3,
                ""b"": -4
            },
            ""expected"": -12,
            ""unexpected"": [
                0,
                -11,
                12
            ]
        },
        {
            ""input"": {
                ""a"": -3,
                ""b"": 4
            },
            ""expected"": -12,
            ""unexpected"": [
                0,
                -11,
                12
            ]
        },
        {
            ""input"": {
                ""a"": -3,
                ""b"": -4
            },
            ""expected"": 12,
            ""unexpected"": [
                0,
                11,
                -12
            ]
        },
        {
            ""input"": {
                ""a"": 0,
                ""b"": 5
            },
            ""expected"": 0,
            ""unexpected"": [
                1,
                -1,
                5
            ]
        },
        {
            ""input"": {
                ""a"": 5,
                ""b"": 0
            },
            ""expected"": 0,
            ""unexpected"": [
                1,
                -1,
                5
            ]
        },
        {
            ""input"": {
                ""a"": 0,
                ""b"": 0
            },
            ""expected"": 0,
            ""unexpected"": [
                1,
                -1,
                5
            ]
        }
    ]
    */","use vstd::prelude::*;

verus! {",,"fn multiply(a: i32, b: i32) -> (result: i32)
    ensures result == a * b,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0086,verus,verina,verina_basic_6_task,,"This task requires writing a Verus method that finds the minimum among three given integers. The method should return the smallest value, ensuring that the result is less than or equal to each of the input numbers and that it is one of the provided integers.

Input:
The input consists of three integers:
a: The first integer.
b: The second integer.
c: The third integer.

Output:
The output is an integer:
Returns the minimum of the three input numbers, assuring that the returned value is less than or equal to a, b, and c, and that it matches one of these values.","use vstd::prelude::*;

verus! {",,"fn min_of_three(a: i32, b: i32, c: i32) -> (result: i32)
    ensures
        result <= a && result <= b && result <= c,
        result == a || result == b || result == c,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0087,verus,verina,verina_basic_7_task,,"This task requires writing a Verus method that computes the sum of the squares of the first n odd natural numbers. The result should match the formula: (n * (2 * n - 1) * (2 * n + 1)) / 3.

-----Input-----
The input consists of:
n: A natural number representing the count of odd natural numbers to consider (n should be non-negative).

-----Output-----
The output is a natural number:
Returns the sum of the squares of the first n odd natural numbers, as defined by the formula: (n * (2 * n - 1) * (2 * n + 1)) / 3.","use vstd::prelude::*;

verus! {",,"fn sum_of_squares_of_first_n_odd_numbers(n: u32) -> (result: u32)
    requires n >= 0,
    ensures
        result as int == (n as int * (2 * n as int - 1) * (2 * n as int + 1)) / 3,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0088,verus,verina,verina_basic_8_task,,"This task requires writing a Verus method that determines the minimum of two integers. The method should return the smaller of the two numbers. When both numbers are equal, either one may be returned.

-----Input-----
The input consists of two integers:
a: The first integer.
b: The second integer.

-----Output-----
The output is an integer:
Returns the smaller value between the input integers, ensuring that the result is less than or equal to both inputs.","use vstd::prelude::*;

verus! {",,"fn my_min(a: i32, b: i32) -> (result: i32)
    ensures
        result <= a && result <= b,
        result == a || result == b,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0089,verus,verina,verina_basic_9_task,,"This task requires writing a Verus method that checks whether two arrays of integers have any elements in common. In other words, the method should return true if there is at least one element that appears in both arrays, and false if no such element exists.

-----Input-----
The input consists of:
a: An array of integers.
b: An array of integers.

-----Output-----
The output is a Boolean value:
Returns true if there is at least one common element between the two arrays.
Returns false if there are no common elements shared by the arrays.

-----Note-----
Both arrays are assumed to be non-null.","use vstd::prelude::*;

verus! {",,"fn has_common_element(a: &Vec<i32>, b: &Vec<i32>) -> (result: bool)
    requires 
        a.len() > 0,
        b.len() > 0,
    ensures
        result == (exists|i: int, j: int| 0 <= i < a.len() && 0 <= j < b.len() && a[i] == b[j]),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0090,verus,verina,verina_basic_10_task,,"This task requires writing a Verus method that determines if a given integer is strictly greater than every element in a provided array. The method should return true only if the integer is larger than each element in the array; otherwise, it should return false.

-----Input-----
The input consists of:
n: An integer.
a: An array of integers.

-----Output-----
The output is a Boolean value:
Returns true if the integer is greater than all elements in the array.
Returns false if there is at least one element in the array that is greater than or equal to the integer.

-----Note-----
The array is assumed to be non-null.","use vstd::prelude::*;

verus! {",,"fn is_greater(n: i32, a: &Vec<i32>) -> (result: bool)
    requires a.len() > 0,
    ensures result == (forall|i: int| 0 <= i < a.len() ==> n > a[i]),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0091,verus,verina,verina_basic_11_task,,"This task requires writing a Verus method that extracts the last digit of a given non-negative integer. The method should return the last digit, which is obtained by computing the remainder when the number is divided by 10. The result must always be between 0 and 9.

-----Input-----
The input consists of a single value:
n: A non-negative integer.

-----Output-----
The output is an integer:
Returns the last digit of the input number, ensuring that the digit lies within the range 0 to 9.

-----Note-----
It is assumed that the input number n is non-negative.","use vstd::prelude::*;

verus! {",,"fn last_digit(n: nat) -> (result: nat)
    ensures
        result < 10,
        result == n % 10,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0093,verus,verina,verina_basic_13_task,,"This task requires writing a Verus method that transforms an array of integers by replacing every element with its cube. In other words, for each element in the input array, the output array should contain the result of multiplying that element by itself three times.

Input:
The input consists of:
a: An array of integers (which may be empty or non-empty).

Output:
The output is an array of integers:
Returns an array with the same length as the input, where each element is the cube of the corresponding element in the input array.

Note:
There are no additional preconditions; the method should work correctly for any array of integers.","use vstd::prelude::*;

verus! {",,"fn cube_elements(a: &Vec<i32>) -> (result: Vec<i32>)
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < a.len() ==> result[i] == a[i] * a[i] * a[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0094,verus,verina,verina_basic_14_task,,"This task requires writing a Verus method that determines whether a given string contains the character 'z' or 'Z'. The method should return true if the string includes either the lowercase or uppercase letter 'z', and false otherwise.

-----Input-----
The input consists of:
s: A string.

-----Output-----
The output is a Boolean value:
Returns true if the input string contains the character 'z' or 'Z'.
Returns false if the input string does not contain the character 'z' or 'Z'.

-----Note-----
There are no preconditions; the method will always work as strings and sequences are considered non-null.","use vstd::prelude::*;

verus! {",,"fn contains_z(s: &str) -> (result: bool)
    ensures
        result <==> exists|i: int| 0 <= i < s@.len() && (s@[i] == 'z' || s@[i] == 'Z'),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0095,verus,verina,verina_basic_15_task,,"This task requires writing a Verus method that determines whether an array of integers contains at least one pair of consecutive numbers. The method should return true if there is any index where an element, when increased by one, equals the next element in the array. If no such consecutive pair exists, the method should return false.

-----Input-----
The input consists of:
a: An array of integers (the array may be empty or non-empty).

-----Output-----
The output is a Boolean value:
Returns true if there is at least one index where an element plus one equals the following element.
Returns false if the array does not contain any consecutive numbers.

-----Note-----
There are no additional preconditions; the method will function correctly regardless of the array's size.

/* 
    -- Invalid Inputs
    []
    -- Tests
    [
        {
            ""input"": {
                ""a"": ""#[1, 2, 3, 5]""
            },
            ""expected"": true,
            ""unexpected"": [
                false
            ]
        },
        {
            ""input"": {
                ""a"": ""#[1, 3, 5, 7]""
            },
            ""expected"": false,
            ""unexpected"": [
                true
            ]
        },
        {
            ""input"": {
                ""a"": ""#[]""
            },
            ""expected"": false,
            ""unexpected"": [
                true
            ]
        },
        {
            ""input"": {
                ""a"": ""#[10]""
            },
            ""expected"": false,
            ""unexpected"": [
                true
            ]
        },
        {
            ""input"": {
                ""a"": ""#[5, 6]""
            },
            ""expected"": true,
            ""unexpected"": [
                false
            ]
        },
        {
            ""input"": {
                ""a"": ""#[5, 7, 8, 10]""
            },
            ""expected"": true,
            ""unexpected"": [
                false
            ]
        },
        {
            ""input"": {
                ""a"": ""#[9, 9, 10]""
            },
            ""expected"": true,
            ""unexpected"": [
                false
            ]
        },
        {
            ""input"": {
                ""a"": ""#[3, 3, 3]""
            },
            ""expected"": false,
            ""unexpected"": [
                true
            ]
        }
    ]
    */","use vstd::prelude::*;

verus! {",,"fn contains_consecutive_numbers(a: &Vec<i32>) -> (result: bool)
    ensures
        result <==> exists|i: int| {
            &&& 0 <= i < a.len() - 1
            &&& #[trigger] a[i] + 1 == a[(i + 1) as int]
        },","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0097,verus,verina,verina_basic_17_task,,"This task requires writing a Verus method that converts all uppercase characters in a given string to their lowercase equivalents while keeping the other characters unchanged. The output string must have the same length as the input string.

-----Input-----
The input consists of:
s: A string that may contain both uppercase and lowercase characters.

-----Output-----
The output is a string:
Returns a new string where every uppercase letter has been converted to lowercase, and every non-uppercase character remains exactly as in the input.

-----Note-----
There are no preconditions; the method is expected to work for any non-null string.

/* Helper function to check if a character is uppercase */

/* Helper function to shift character by 32 positions */","use vstd::prelude::*;

verus! {

spec fn is_uppercase(c: char) -> bool {
    'A' <= c && c <= 'Z'
}

spec fn shift32(c: char) -> char {
    ((c as int) + 32) as char
}",,"fn to_lowercase(s: &Vec<char>) -> (result: Vec<char>)
    ensures
        result.len() == s.len(),
        forall|i: int| 0 <= i < s.len() ==> {
            if is_uppercase(s[i]) {
                result[i] == shift32(s[i])
            } else {
                result[i] == s[i]
            }
        },","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVV02,0.85
VV0098,verus,verina,verina_basic_18_task,,"This task requires writing a Verus method that computes the sum of the digits of a non-negative integer. The method should process each digit of the input number and return the total sum. The output is guaranteed to be a non-negative natural number.

-----Input-----
The input consists of:
n: A non-negative integer.

-----Output-----
The output is a natural number:
Returns the sum of the digits of the input integer.

-----Note-----
The input is assumed to be a valid non-negative integer.","use vstd::prelude::*;

verus! {",,"fn sum_of_digits(n: nat) -> (result: nat)
    ensures result >= 0","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0099,verus,verina,verina_basic_19_task,,"This task requires writing a Verus method that checks whether an array of integers is sorted in non-decreasing order. The method should return true if every element is less than or equal to the element that follows it, and false otherwise.

-----Input-----
The input consists of:
a: An array of integers. The array can be empty or have any length.

-----Output-----
The output is a Boolean value:
Returns true if the array is sorted in non-decreasing order.
Returns false if the array is not sorted in non-decreasing order.

-----Note-----
A true result guarantees that for every valid pair of indices i and j (with i < j), the element at position i is less than or equal to the element at position j. A false result indicates that there exists at least one adjacent pair of elements where the first element is greater than the second.","use vstd::prelude::*;

verus! {",,"fn is_sorted(a: &Vec<i32>) -> (result: bool)
    ensures
        result == (forall|i: int| 0 <= i < a.len() - 1 ==> #[trigger] a[i] <= a[i + 1]),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0100,verus,verina,verina_basic_20_task,,"This task requires writing a Verus method that calculates the product of all distinct integers in an array. The method should consider each unique integer only once when computing the product and return the resulting value. If the array is empty, the method should return 1.

-----Input-----
The input consists of:
arr: An array of integers.

-----Output-----
The output is an integer:
Returns the product of all unique integers from the input array.

-----Note-----
The order in which the unique integers are multiplied does not affect the final product.

/* Product of all unique integers in the array */

/* Placeholder for actual postcondition */","use vstd::prelude::*;

verus! {",,"fn unique_product(arr: &Vec<i32>) -> (result: i32)
    ensures

        true,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0101,verus,verina,verina_basic_21_task,,"This task requires writing a Verus method that determines whether one list is a sublist of another. In other words, the method should check if the first list appears as a contiguous sequence within the second list and return true if it does, and false otherwise.

-----Input-----
The input consists of two lists of integers:
sub: A list of integers representing the potential sublist.
main: A list of integers in which to search for the sublist.

-----Output-----
The output is a Boolean value:
Returns true if the first list appears as a contiguous sequence within the second list.
Returns false if the first list does not appear as a contiguous sequence in the second list.

-----Note-----
There are no preconditions for this method; the sequences are always non-null.","use vstd::prelude::*;

verus! {

spec fn is_subseq_at(sub: Vec<i32>, main: Vec<i32>, i: int) -> bool {
    0 <= i && i + sub.len() <= main.len() && 
    (forall|j: int| 0 <= j < sub.len() ==> sub[j] == main[i + j])
}",,"fn is_sublist(sub: &Vec<i32>, main: &Vec<i32>) -> (result: bool)
    ensures
        result <==> exists|i: int| is_subseq_at(*sub, *main, i),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0104,verus,verina,verina_basic_24_task,,"This task requires writing a Verus method that finds the difference between the first even number and the first odd number in an array of integers. The method should process the array sequentially until it identifies the first even number and the first odd number, and then return the difference calculated as (first even number) minus (first odd number).

-----Input-----
The input consists of:
a: An array of integers.

-----Output-----
The output is an integer:
Returns the difference computed as the first even number minus the first odd number found in the array.

-----Note-----
The input array is assumed to be non-empty and to contain at least one even number and one odd number.

/*
    -- Invalid Inputs
    [
        {
            ""input"": {
                ""a"": ""#[2]""
            }
        }
    ]
    -- Tests
    [
        {
            ""input"": {
                ""a"": ""#[2, 3, 4, 5]""
            },
            ""expected"": -1,
            ""unexpected"": [
                -2,
                1,
                -3
            ]
        },
        {
            ""input"": {
                ""a"": ""#[1, 4, 6, 8]""
            },
            ""expected"": 3,
            ""unexpected"": [
                2,
                4,
                5
            ]
        },
        {
            ""input"": {
                ""a"": ""#[7, 2, 9, 4]""
            },
            ""expected"": -5,
            ""unexpected"": [
                -3,
                -6,
                5
            ]
        },
        {
            ""input"": {
                ""a"": ""#[2, 2, 3, 3]""
            },
            ""expected"": -1,
            ""unexpected"": [
                1,
                0,
                -2
            ]
        },
        {
            ""input"": {
                ""a"": ""#[1, 1, 2, 2]""
            },
            ""expected"": 1,
            ""unexpected"": [
                0,
                2,
                -1
            ]
        }
    ]
    */","use vstd::prelude::*;

verus! {

spec fn is_even(n: i32) -> bool {
    n % 2 == 0
}

spec fn is_odd(n: i32) -> bool {
    n % 2 != 0
}",,"fn first_even_odd_difference(a: &Vec<i32>) -> (result: i32)
    requires 
        a.len() > 1,
        exists|x: int| 0 <= x < a.len() && is_even(a[x as int]),
        exists|x: int| 0 <= x < a.len() && is_odd(a[x as int]),
    ensures 
        exists|i: int, j: int| 
            0 <= i < a.len() && 0 <= j < a.len() &&
            is_even(a[i as int]) && is_odd(a[j as int]) &&
            result == a[i as int] - a[j as int] &&
            (forall|k: int| 0 <= k < i ==> is_odd(a[k as int])) &&
            (forall|k: int| 0 <= k < j ==> is_even(a[k as int]))","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0105,verus,verina,verina_basic_25_task,,"This task requires writing a Verus method that calculates both the sum and the average of the first n natural numbers. The method should compute the sum of numbers from 0 to n (which equals n * (n + 1) / 2) and then determine the average by dividing this sum by n. The specification assumes that the input n is a positive integer.

-----Input-----
The input consists of:
n: A natural number representing the count of the first natural numbers. The value of n is assumed to be positive.

-----Output-----
The output is a pair consisting of:
- An integer representing the sum of the first n natural numbers.
- A floating-point number representing the average of the first n natural numbers.

-----Note-----
The input n must be a positive integer.

/* reasonable bound to prevent overflow */

/*
    -- Invalid Inputs
    []
    -- Tests
    [
        {
            ""input"": {
                ""n"": 5
            },
            ""expected"": ""(15, 3.0)"",
            ""unexpected"": [
                ""(14, 2.8)"",
                ""(16, 3.2)""
            ]
        },
        {
            ""input"": {
                ""n"": 1
            },
            ""expected"": ""(1, 1.0)"",
            ""unexpected"": [
                ""(0, 0.0)"",
                ""(2, 2.0)""
            ]
        },
        {
            ""input"": {
                ""n"": 10
            },
            ""expected"": ""(55, 5.5)"",
            ""unexpected"": [
                ""(50, 5.0)"",
                ""(60, 6.0)""
            ]
        },
        {
            ""input"": {
                ""n"": 0
            },
            ""expected"": ""(0, 0.0)"",
            ""unexpected"": [
                ""(1, 0.1)"",
                ""(-1, -0.1)""
            ]
        },
        {
            ""input"": {
                ""n"": 2
            },
            ""expected"": ""(3, 1.5)"",
            ""unexpected"": [
                ""(2, 1.0)"",
                ""(4, 2.0)""
            ]
        }
    ]
    */","use vstd::prelude::*;

verus! {",,"fn sum_and_average(n: u32) -> (result: (u32, f64))
    requires n < 100000,
    ensures
        n == 0 ==> result.0 == 0,
        n > 0 ==> result.0 == (n * (n + 1)) / 2,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0106,verus,verina,verina_basic_26_task,,"This task requires writing a Verus method that determines whether a given integer is even. In other words, the method should return true if the number is even and false if the number is odd.

-----Input-----
The input consists of:
n: An integer.

-----Output-----
The output is a Boolean value:
Returns true if the input number is even.
Returns false if the input number is odd.

-----Note-----
There are no preconditions; the method will always work for any integer input.","use vstd::prelude::*;

verus! {",,"fn is_even(n: int) -> (result: bool)
    ensures
        result <==> (n % 2 == 0),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0107,verus,verina,verina_basic_27_task,,"This task requires writing a Verus method that identifies the first repeated character in a given string. The method should return an Option containing a character. The Option value indicates whether any character in the string is repeated. If it is Some(c), the accompanying character is the first character that appears more than once. If it is None, it indicates that there are no repeated characters in the string.

Input:
The input consists of:
s: A vector of characters.

Output:
The output is Option<char>:
- Returns Some(c) with the first repeated character in the string if any repeated character is found.
- Returns None if no repeated characters are present.

Note:
There are no preconditions; the method is expected to work for any vector of characters.","use vstd::prelude::*;

verus! {

spec fn count_char(chars: Seq<char>, c: char) -> nat 
    decreases chars.len()
{
    if chars.len() == 0 {
        0
    } else if chars[0] == c {
        1 + count_char(chars.subrange(1, chars.len() as int), c)
    } else {
        count_char(chars.subrange(1, chars.len() as int), c)
    }
}

spec fn has_no_duplicates_up_to(chars: Seq<char>, end_idx: int) -> bool {
    forall|i: int, j: int| 0 <= i < j < end_idx ==> #[trigger] chars[i] != #[trigger] chars[j]
}

spec fn has_no_duplicates(chars: Seq<char>) -> bool {
    forall|i: int, j: int| 0 <= i < j < chars.len() ==> #[trigger] chars[i] != #[trigger] chars[j]
}

spec fn first_occurrence_index(chars: Seq<char>, c: char) -> int {
    choose|i: int| 0 <= i < chars.len() && chars[i] == c
}

spec fn second_occurrence_exists(chars: Seq<char>, c: char) -> bool {
    exists|i: int, j: int| 0 <= i < j < chars.len() && #[trigger] chars[i] == c && #[trigger] chars[j] == c
}",,"fn find_first_repeated_char(s: &Vec<char>) -> (result: Option<char>)
    ensures match result {
        Some(c) => {
            let chars = s@;
            count_char(chars, c) >= 2 &&
            second_occurrence_exists(chars, c) &&
            {
                let first_idx = first_occurrence_index(chars, c);
                let second_idx = choose|j: int| first_idx < j < chars.len() && chars[j] == c;
                has_no_duplicates_up_to(chars, second_idx)
            }
        },
        None => {
            has_no_duplicates(s@)
        }
    }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0108,verus,verina,verina_basic_28_task,,"This task requires writing a Verus method that determines whether a given natural number is prime. A number (with n ≥ 2) is considered prime if it is divisible only by 1 and itself. The method should return true when the input number is prime and false otherwise.

Input:
The input consists of:
n: A natural number (nat) such that n ≥ 2.

Output:
The output is a Boolean value:
Returns true if the input number is prime (i.e., there is no integer k with 1 < k < n that divides n).
Returns false if the input number is not prime (i.e., there exists an integer k with 1 < k < n that divides n).

Note:
The input is expected to satisfy the condition n ≥ 2.

/* 
    Invalid Inputs
    [
        {
            ""input"": {
                ""n"": 0
            }
        }
    ]
    Tests
    [
        {
            ""input"": {
                ""n"": 2
            },
            ""expected"": true,
            ""unexpected"": [
                false
            ]
        },
        {
            ""input"": {
                ""n"": 3
            },
            ""expected"": true,
            ""unexpected"": [
                false
            ]
        },
        {
            ""input"": {
                ""n"": 4
            },
            ""expected"": false,
            ""unexpected"": [
                true
            ]
        },
        {
            ""input"": {
                ""n"": 5
            },
            ""expected"": true,
            ""unexpected"": [
                false
            ]
        },
        {
            ""input"": {
                ""n"": 9
            },
            ""expected"": false,
            ""unexpected"": [
                true
            ]
        },
        {
            ""input"": {
                ""n"": 11
            },
            ""expected"": true,
            ""unexpected"": [
                false
            ]
        },
        {
            ""input"": {
                ""n"": 12
            },
            ""expected"": false,
            ""unexpected"": [
                true
            ]
        },
        {
            ""input"": {
                ""n"": 13
            },
            ""expected"": true,
            ""unexpected"": [
                false
            ]
        }
    ]
    */","use vstd::prelude::*;

verus! {",,"fn is_prime(n: nat) -> (result: bool)
    requires n >= 2,
    ensures
        result ==> forall|k: nat| 2 <= k < n ==> #[trigger] (n % k) != 0,
        !result ==> exists|k: nat| 2 <= k < n && #[trigger] (n % k) == 0,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0110,verus,verina,verina_basic_30_task,,"This task requires writing a Verus method that computes the element-wise modulo between two arrays of integers. The method should produce a new array where each element is the remainder after dividing the corresponding element from the first array by the element from the second array.

Input:
The input consists of:
a: An array of integers.
b: An array of integers.

Output:
The output is an array of integers:
Returns a new array in which each element is the result of taking the modulo of the corresponding elements from the two input arrays.

Note:
Preconditions:
- Both arrays must be non-null.
- Both arrays must have the same length.
- All elements in the second array should be non-zero.

Postconditions:
- The length of the resulting array is the same as the length of the input arrays.
- Each element in the resulting array is the modulo of the corresponding elements in the input arrays.

// Invalid Inputs

// [

//     {

//         ""input"": {

//             ""a"": ""[1]"",

//             ""b"": ""[4, 0]""

//         }

//     }

// ]

// Tests

// [

//     {

//         ""input"": {

//             ""a"": ""[10, 20, 30]"",

//             ""b"": ""[3, 7, 5]""

//         },

//         ""expected"": ""[1, 6, 0]"",

//         ""unexpected"": [

//             ""[1, 0, 0]"",

//             ""[0, 6, 0]""

//         ]

//     },

//     {

//         ""input"": {

//             ""a"": ""[100, 200, 300, 400]"",

//             ""b"": ""[10, 20, 30, 50]""

//         },

//         ""expected"": ""[0, 0, 0, 0]"",

//         ""unexpected"": [

//             ""[0, 0, 0, 1]"",

//             ""[1, 0, 0, 0]""

//         ]

//     },

//     {

//         ""input"": {

//             ""a"": ""[-10, -20, 30]"",

//             ""b"": ""[3, -7, 5]""

//         },

//         ""expected"": ""[2, 1, 0]"",

//         ""unexpected"": [

//             ""[-1, -5, 0]"",

//             ""[-1, -6, 1]"",

//             ""[0, -6, 0]""

//         ]

//     }

// ]","use vstd::prelude::*;

verus! {",,"fn element_wise_modulo(a: &Vec<i32>, b: &Vec<i32>) -> (result: Vec<i32>)
    requires
        a.len() == b.len(),
        a.len() > 0,
        forall|i: int| 0 <= i < b.len() ==> b[i] != 0,
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] % b[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0111,verus,verina,verina_basic_31_task,,"This task requires writing a Verus method that converts a given string to uppercase. The method should replace every lowercase letter in the input string with its corresponding uppercase character while leaving all other characters unchanged. The output string must have the same length as the input string.

Input:
The input consists of:
s: A string.

Output:
The output is a string:
Returns a new string in which every lowercase letter from the input string is converted to uppercase, and all other characters are exactly the same as in the input string, ensuring the output string has the same length as the input.

Note:
There are no preconditions since the method assumes that the input string is always valid (i.e., non-null).","use vstd::prelude::*;

verus! {

spec fn is_lower_case(c: char) -> bool
{
    'a' <= c && c <= 'z'
}

spec fn shift_minus_32(c: char) -> char
{
    arbitrary()
}",,"fn to_uppercase(s: &str) -> (result: String)
    ensures
        result@.len() == s@.len(),
        forall|i: int| 0 <= i < s@.len() ==> {
            let c = #[trigger] s@.index(i);
            let r = result@.index(i);
            if is_lower_case(c) {
                r == shift_minus_32(c)
            } else {
                r == c
            }
        },","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVV02,0.85
VV0112,verus,verina,verina_basic_32_task,,"This task requires writing a Verus method that swaps the first and last elements of an array of integers. The method should produce a new array where the first element of the output is the last element of the input, the last element of the output is the first element of the input, and all other elements remain in their original positions.

Input:
The input consists of:
a: An array of integers (assumed to be non-empty).

Output:
The output is an array of integers:
Returns a new array where:
- The former last element becomes the first element.
- The former first element becomes the last element.
- All other elements remain unchanged.

/* 
    Invalid Inputs
    [
        {
            ""input"": {
                ""a"": ""[]""
            }
        }
    ]
    Tests
    [
        {
            ""input"": {
                ""a"": ""[1, 2, 3, 4, 5]""
            },
            ""expected"": ""[5, 2, 3, 4, 1]"",
            ""unexpected"": [
                ""[1, 2, 3, 4, 5]"",
                ""[5, 4, 3, 2, 1]"",
                ""[2, 3, 4, 5, 1]""
            ]
        },
        {
            ""input"": {
                ""a"": ""[10]""
            },
            ""expected"": ""[10]"",
            ""unexpected"": [
                ""[0]"",
                ""[5]"",
                ""[11]""
            ]
        },
        {
            ""input"": {
                ""a"": ""[1, 2]""
            },
            ""expected"": ""[2, 1]"",
            ""unexpected"": [
                ""[1, 2]"",
                ""[2, 2]"",
                ""[1, 1]""
            ]
        },
        {
            ""input"": {
                ""a"": ""[1, 2, 3]""
            },
            ""expected"": ""[3, 2, 1]"",
            ""unexpected"": [
                ""[1, 2, 3]"",
                ""[3, 1, 2]"",
                ""[2, 1, 3]""
            ]
        }
    ]
    */","use vstd::prelude::*;

verus! {",,"fn swap_first_and_last(a: &Vec<i32>) -> (result: Vec<i32>)
    requires a.len() > 0,
    ensures
        result.len() == a.len(),
        result[0] == a[a.len() - 1],
        result[result.len() - 1] == a[0],
        forall|i: int| 1 <= i < result.len() - 1 ==> result[i] == a[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0114,verus,verina,verina_basic_34_task,,"This task requires writing a Verus method that extracts even numbers from an array of integers. The method should return a new array containing only the even numbers found in the input array, while preserving the order in which they appear.

-----Input-----
The input consists of:
arr: An array of integers.

-----Output-----
The output is an array of integers:
Returns an array containing all the even numbers from the input array. Specifically:
- Every element in the output array is an even integer.
- All even integers present in the input array are included in the output array.
- The relative order of the even integers is preserved as in the input array.

-----Note-----
There are no preconditions for this task; the method will work with any array, including empty arrays (which are not null).","use vstd::prelude::*;

verus! {

spec fn is_even(n: i32) -> bool {
    n % 2 == 0
}",,"fn find_even_numbers(arr: &Vec<i32>) -> (result: Vec<i32>)
    ensures
        forall|x: i32| result@.contains(x) ==> is_even(x) && arr@.contains(x),
        forall|x: i32| arr@.contains(x) && is_even(x) ==> result@.contains(x),
        forall|i: int, j: int| 0 <= i < arr.len() && 0 <= j < arr.len() && i <= j && 
            is_even(arr[i]) && is_even(arr[j]) ==> {
                exists|ri: int, rj: int| 0 <= ri < result.len() && 0 <= rj < result.len() && 
                    ri <= rj && result[ri] == arr[i] && result[rj] == arr[j]
            },","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0116,verus,verina,verina_basic_36_task,,"This task requires writing a Verus method that takes a given string and returns a new string where every occurrence of a space, comma, or dot is replaced with a colon. The transformation must preserve the original string's length and leave all other characters unmodified.

Input:
The input consists of:
s: A string.

Output:
The output is a string:
- The returned string must have the same length as the input string.
- Every space, comma, or dot in the input string is replaced with a colon.
- All other characters remain unchanged.

Note:
There are no preconditions; the input string is assumed to be non-null.","use vstd::prelude::*;

verus! {

spec fn is_space_comma_dot(c: char) -> bool
{
    c == ' ' || c == ',' || c == '.'
}",,"fn replace_with_colon(s: &str) -> (result: String)
    ensures
        result@.len() == s@.len(),
        forall|i: int| 0 <= i < s@.len() ==> 
            #[trigger] result@.index(i) == 
            if is_space_comma_dot(#[trigger] s@.index(i)) { ':' } else { s@.index(i) },","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0117,verus,verina,verina_basic_37_task,,"This task requires writing a Verus method that locates the first occurrence of a specified integer within a sorted array of integers. The method returns the index corresponding to the first time the target value appears in the array; if the target is absent, it returns -1. It is also essential that the original array remains unchanged.

Input:
The input consists of:
• arr: An array of integers sorted in non-decreasing order.
• target: An integer representing the value to search for.

Output:
The output is an integer:
• If the target is found, the method returns the index of its first occurrence.
• If the target is not found, the method returns -1.

Note:
• The input array must be sorted in non-decreasing order.
• The array is guaranteed to remain unmodified after the method executes.","use vstd::prelude::*;

verus! {",,"fn find_first_occurrence(arr: &Vec<i32>, target: i32) -> (result: i32)
    requires
        forall|i: int, j: int| 0 <= i < j < arr.len() ==> arr[i] <= arr[j],
    ensures
        (result >= 0 ==> {
            &&& 0 <= result < arr.len()
            &&& arr[result as int] == target
            &&& forall|i: int| 0 <= i < result ==> arr[i] != target
        }) &&
        (result == -1 ==> {
            &&& forall|i: int| 0 <= i < arr.len() ==> arr[i] != target
        }),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0118,verus,verina,verina_basic_38_task,,"This task requires writing a Lean 4 method that checks whether all characters in an input string are identical. The method should return true if every character in the string is the same, and false if at least one character differs. An empty string or a single-character string is considered to have all characters identical.

-----Input-----
The input consists of:
s: A string.

-----Output-----
The output is a Boolean value:
Returns true if every character in the string is identical.
Returns false if there is at least one differing character.","use vstd::prelude::*;

verus! {",,"fn all_characters_same(s: Seq<char>) -> (result: bool)
    requires true,
    ensures
        result ==> (forall|i: int, j: int| 0 <= i < s.len() && 0 <= j < s.len() ==> s[i] == s[j]),
        !result ==> (s.len() > 0 && exists|i: int| 0 <= i < s.len() && #[trigger] s[i] != s[0]),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0119,verus,verina,verina_basic_39_task,,"This task requires writing a Verus method that rotates a list of integers to the right by a specified number of positions. The method should produce a new list where each element is shifted to the right while preserving the original list's length.

-----Input-----
The input consists of:
• l: A list of integers.
• n: A non-negative natural number that indicates the number of positions by which to rotate the list.

-----Output-----
The output is a list of integers:
• Returns a list with the same length as the input list, where the elements have been rotated to the right by n positions.

-----Note-----
• The precondition requires that n is non-negative.
• If the input list is empty, it should be returned unchanged.","use vstd::prelude::*;

verus! {",,"fn rotate_right(l: &Vec<i32>, n: usize) -> (result: Vec<i32>)
    ensures
        result.len() == l.len(),
        forall|i: int| 0 <= i < l.len() ==> {
            let len = l.len() as int;
            let rotated_index = ((i - n as int + len) % len) as int;
            #[trigger] result[i] == l[rotated_index]
        },","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0120,verus,verina,verina_basic_40_task,,"This task requires writing a Verus method that finds the second-smallest number in an array of integers. The method should determine and return the number that is larger than the smallest element in the array. It is crucial that the input array remains unchanged after the computation.

-----Input-----
The input consists of:
s: An array of integers containing at least two elements.

-----Output-----
The output is an integer:
Returns the second-smallest number in the input array.

-----Note-----
- The input array is guaranteed to contain at least two elements and is non-null.
- It is assumed that there exist at least two distinct values in the array to ensure a unique second-smallest element.
- The original array must remain unmodified.","use vstd::prelude::*;

verus! {

spec fn second_smallest_precond(s: &Vec<i32>) -> bool {
    s.len() > 1
}

spec fn second_smallest_postcond(s: &Vec<i32>, result: i32) -> bool {
    (exists|i: int| 0 <= i < s.len() && s[i] == result) &&
    (exists|j: int| 0 <= j < s.len() && s[j] < result &&
        (forall|k: int| 0 <= k < s.len() && s[k] != s[j] ==> s[k] >= result))
}",,"fn second_smallest(s: &Vec<i32>) -> (result: i32) 
    requires second_smallest_precond(s) 
    ensures second_smallest_postcond(s, result)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,DupVV00,0.85
VV0121,verus,verina,verina_basic_41_task,,"This task requires writing a Verus method that determines whether an array of integers contains only one distinct element. The method should return true if the array is empty or if every element in the array is the same, and false if there are at least two different elements.

-----Input-----
The input consists of:
a: An array of integers.

-----Output-----
The output is a Boolean value:
Returns true if the array is empty or if all elements in the array are identical.
Returns false if the array contains at least two distinct elements.

-----Note-----
The input array is assumed to be non-null.

/*
    -- Invalid Inputs
    [
        {
            ""input"": {
                ""a"": ""#[]""
            }
        }
    ]
    -- Tests
    [
        {
            ""input"": {
                ""a"": ""#[1, 1, 1]""
            },
            ""expected"": true,
            ""unexpected"": [
                false
            ]
        },
        {
            ""input"": {
                ""a"": ""#[1, 2, 1]""
            },
            ""expected"": false,
            ""unexpected"": [
                true
            ]
        },
        {
            ""input"": {
                ""a"": ""#[3, 4, 5, 6]""
            },
            ""expected"": false,
            ""unexpected"": [
                true
            ]
        },
        {
            ""input"": {
                ""a"": ""#[7]""
            },
            ""expected"": true,
            ""unexpected"": [
                false
            ]
        },
        {
            ""input"": {
                ""a"": ""#[0, 0, 0, 0]""
            },
            ""expected"": true,
            ""unexpected"": [
                false
            ]
        },
        {
            ""input"": {
                ""a"": ""#[0, 0, 1, 0]""
            },
            ""expected"": false,
            ""unexpected"": [
                true
            ]
        }
    ]
    */","use vstd::prelude::*;

verus! {",,"fn has_only_one_distinct_element(a: &Vec<i32>) -> (result: bool)
    requires a.len() > 0,
    ensures
        result ==> (forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() ==> a[i] == a[j]),
        !result ==> (exists|i: int| 0 <= i < a.len() && #[trigger] a[i] != a[0]),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0122,verus,verina,verina_basic_42_task,,"This task requires writing a Verus method that counts the number of digit characters within a given string. A digit is any character between '0' and '9'. The method should determine how many such digit characters appear in the input.

Input:
The input consists of:
s: A string.

Output:
The output is a natural number (usize):
Returns a non-negative count representing the number of digit characters found in the input string.

Note:
There are no additional preconditions; the method works for any provided string.

/* 
    -- Invalid Inputs
    []
    -- Tests
    [
        {
            ""input"": {
                ""s"": ""123abc456""
            },
            ""expected"": 6,
            ""unexpected"": [
                5,
                7,
                0
            ]
        },
        {
            ""input"": {
                ""s"": ""no digits here!""
            },
            ""expected"": 0,
            ""unexpected"": [
                1,
                2,
                3
            ]
        },
        {
            ""input"": {
                ""s"": ""1234567890""
            },
            ""expected"": 10,
            ""unexpected"": [
                9,
                11,
                0
            ]
        },
        {
            ""input"": {
                ""s"": """"
            },
            ""expected"": 0,
            ""unexpected"": [
                1,
                2,
                10
            ]
        },
        {
            ""input"": {
                ""s"": ""a1b2c3""
            },
            ""expected"": 3,
            ""unexpected"": [
                2,
                4,
                5
            ]
        },
        {
            ""input"": {
                ""s"": ""0""
            },
            ""expected"": 1,
            ""unexpected"": [
                0,
                2,
                10
            ]
        },
        {
            ""input"": {
                ""s"": ""abc""
            },
            ""expected"": 0,
            ""unexpected"": [
                1,
                8,
                9
            ]
        }
    ]
    */","use vstd::prelude::*;

verus! {",,"fn count_digits(s: &str) -> (result: usize)
    ensures
        result >= 0,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0123,verus,verina,verina_basic_43_task,,"This task requires writing a Verus method that computes the sum of the fourth power of the first n odd natural numbers. In other words, given a non-negative integer n, the method should calculate the sum: 1⁴ + 3⁴ + 5⁴ + ... for the first n odd numbers.

-----Input-----
The input consists of:
n: A non-negative natural number representing the number of odd natural numbers to consider.

-----Output-----
The output is a natural number:
Returns the sum of the fourth power of the first n odd natural numbers.

-----Note-----
The input n is assumed to be a non-negative integer.
The correctness of the result is established by a theorem that relates the computed sum to a specific formula.","use vstd::prelude::*;

verus! {",,"fn sum_of_fourth_power_of_odd_numbers(n: nat) -> (result: nat)
    ensures
        15 * result == n * (2 * n + 1) * (7 + 24 * (n * n * n) - 12 * (n * n) - 14 * n)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0124,verus,verina,verina_basic_44_task,,"This task requires writing a Verus method that verifies if every odd index in an array of integers holds an odd number. In other words, for each index in the array that is odd, the number located at that index must also be odd. The method should return true if this condition is satisfied for every odd index; otherwise, it should return false.

-----Input-----
The input consists of:
a: An array of integers.

-----Output-----
The output is a Boolean value:
Returns true if, for every odd index in the array, the corresponding element is odd.
Returns false if there is at least one odd index where the corresponding element is not odd.

-----Note-----
There are no preconditions; the method will work for any array of integers.","use vstd::prelude::*;

verus! {

spec fn is_odd(n: i32) -> bool {
    n % 2 == 1
}",,"fn is_odd_at_index_odd(a: &Vec<i32>) -> (result: bool)
    ensures
        result <==> (forall|i: int| 0 <= i < a.len() && i % 2 == 1 ==> is_odd(a[i as int])),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0125,verus,verina,verina_basic_45_task,,"This task requires writing a Verus method that computes the product of the first even and the first odd number encountered in a list of integers. The method should search the list for the earliest even number and the earliest odd number, then return the product of these two numbers.

Input:
The input consists of:
lst: A list of integers.

Output:
The output is an integer:
Returns the product resulting from multiplying the first even number and the first odd number found in the list.

Note:
The input list is assumed to contain at least one even number and one odd number.","use vstd::prelude::*;

verus! {

spec fn find_product_precond(lst: Seq<i32>) -> bool {
    lst.len() > 1 &&
    (exists|x: i32| lst.contains(x) && is_even(x)) &&
    (exists|x: i32| lst.contains(x) && is_odd(x))
}

spec fn is_even(n: i32) -> bool {
    n % 2 == 0
}

spec fn is_odd(n: i32) -> bool {
    n % 2 != 0
}

spec fn first_even_odd_indices(lst: Seq<i32>) -> Option<(int, int)> {
    let even_index = (choose|i: int| 0 <= i < lst.len() && is_even(lst[i]));
    let odd_index = (choose|i: int| 0 <= i < lst.len() && is_odd(lst[i]));
    if (exists|i: int| 0 <= i < lst.len() && is_even(lst[i])) &&
       (exists|i: int| 0 <= i < lst.len() && is_odd(lst[i])) {
        Some((even_index, odd_index))
    } else {
        None
    }
}",,"fn find_product(lst: &Vec<i32>) -> (result: i32)
    requires 
        lst.len() > 1,
        exists|x: i32| lst@.contains(x) && is_even(x),
        exists|x: i32| lst@.contains(x) && is_odd(x),
    ensures
        match first_even_odd_indices(lst@) {
            Some((ei, oi)) => result == lst@[ei] * lst@[oi],
            None => true,
        }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0126,verus,verina,verina_basic_46_task,,"This task requires writing a Verus method that finds the last occurrence of a specified element in a sorted array of integers. The method should return the index corresponding to the last occurrence of the element if it is present; if the element is absent, it should return -1. Additionally, the array must remain unchanged after the method is executed.

Input:
The input consists of:
arr: A sorted array of integers in non-decreasing order.
elem: An integer whose last occurrence position is to be determined.

Output:
The output is an integer:
Returns the index of the last occurrence of the specified integer in the array if it exists.
Returns -1 if the integer is not found in the array.

Note:
The input array is assumed to be sorted in non-decreasing order and remains unchanged by the method.","use vstd::prelude::*;

verus! {",,"fn last_position(arr: &Vec<i32>, elem: i32) -> (result: i32)
    requires forall|i: int, j: int| 0 <= i < j < arr.len() ==> arr[i] <= arr[j],
    ensures
        (result >= 0 ==> 
            0 <= result < arr.len() &&
            arr[result as int] == elem &&
            forall|k: int| result < k < arr.len() ==> arr[k] != elem) &&
        (result == -1 ==> forall|k: int| 0 <= k < arr.len() ==> arr[k] != elem),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0127,verus,verina,verina_basic_47_task,,"This task requires writing a Verus method that calculates the sum of all the elements in an array of integers. The method should process the entire array and return the total sum of its elements.

-----Input-----
The input consists of:
a: An array of integers.

-----Output-----
The output is an integer:
Returns the sum of all elements in the input array.

-----Note-----
- The input array is assumed not to be null.

/*
    -- Invalid Inputs
    [
        {
            ""input"": {
                ""a"": ""#[]""
            }
        }
    ]
    -- Tests
    [
        {
            ""input"": {
                ""a"": ""#[1, 2, 3, 4, 5]""
            },
            ""expected"": 15,
            ""unexpected"": [
                14,
                10,
                16
            ]
        },
        {
            ""input"": {
                ""a"": ""#[13, 14, 15, 16, 17]""
            },
            ""expected"": 75,
            ""unexpected"": [
                74,
                76,
                70
            ]
        },
        {
            ""input"": {
                ""a"": ""#[-1, -2, -3]""
            },
            ""expected"": -6,
            ""unexpected"": [
                -5,
                -7,
                0
            ]
        },
        {
            ""input"": {
                ""a"": ""#[10, -10]""
            },
            ""expected"": 0,
            ""unexpected"": [
                5,
                -5,
                10
            ]
        }
    ]
    */","use vstd::prelude::*;

verus! {

spec fn sum_to(a: &Vec<i32>, n: int) -> int
    decreases n
{
    if n <= 0 { 0 } else { sum_to(a, n - 1) + a[n - 1] }
}",,"fn array_sum(a: &Vec<i32>) -> (result: i32)
    requires a.len() > 0,
    ensures
        result == sum_to(a, a.len() as int),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0128,verus,verina,verina_basic_48_task,,"This task requires writing a Verus method that determines whether a given non-negative natural number is a perfect square. In other words, the method should return true if there exists a natural number whose square is equal to the input number, and false if no such number exists.

Input:
The input consists of a single natural number:
n: A non-negative natural number (nat).

Output:
The output is a Boolean value:
Returns true if there exists an integer such that its square equals the input n.
Returns false if no integer squared equals the input n.

/* 
    Invalid Inputs
    []
    Tests
    [
        {
            ""input"": {
                ""n"": 0
            },
            ""expected"": true,
            ""unexpected"": [
                false
            ]
        },
        {
            ""input"": {
                ""n"": 1
            },
            ""expected"": true,
            ""unexpected"": [
                false
            ]
        },
        {
            ""input"": {
                ""n"": 4
            },
            ""expected"": true,
            ""unexpected"": [
                false
            ]
        },
        {
            ""input"": {
                ""n"": 9
            },
            ""expected"": true,
            ""unexpected"": [
                false
            ]
        },
        {
            ""input"": {
                ""n"": 2
            },
            ""expected"": false,
            ""unexpected"": [
                true
            ]
        },
        {
            ""input"": {
                ""n"": 3
            },
            ""expected"": false,
            ""unexpected"": [
                true
            ]
        },
        {
            ""input"": {
                ""n"": 10
            },
            ""expected"": false,
            ""unexpected"": [
                true
            ]
        },
        {
            ""input"": {
                ""n"": 16
            },
            ""expected"": true,
            ""unexpected"": [
                false
            ]
        },
        {
            ""input"": {
                ""n"": 25
            },
            ""expected"": true,
            ""unexpected"": [
                false
            ]
        },
        {
            ""input"": {
                ""n"": 26
            },
            ""expected"": false,
            ""unexpected"": [
                true
            ]
        }
    ]
    */","use vstd::prelude::*;

verus! {

spec fn is_perfect_square(n: nat) -> bool {
    exists|i: nat| #[trigger] (i * i) == n
}",,"fn is_perfect_square_fn(n: u64) -> (result: bool)
    ensures result <==> is_perfect_square(n as nat),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0129,verus,verina,verina_basic_49_task,,"This task requires writing a Verus method that searches an array of integers to locate the first odd number. The method should return a pair where the first element is a Boolean indicating whether an odd number was found, and the second element is the index of that odd number if found, or -1 if no odd number exists. When an odd number is found, the method should return the smallest index at which an odd number occurs.

-----Input-----
The input consists of:
a: An array of integers.

-----Output-----
The output is a pair (Bool, Int):
- If the Boolean is true, then the integer represents the smallest index of an odd number in the array.
- If the Boolean is false, then there are no odd numbers in the array, and the accompanying integer is -1.

-----Note-----
- The input array is assumed to be non-null.
- If multiple odd numbers are present, the index returned should correspond to the first occurrence.","use vstd::prelude::*;

verus! {

spec fn is_odd(x: i32) -> bool {
    x % 2 != 0
}",,"fn find_first_odd(a: &Vec<i32>) -> (result: Option<usize>)
    requires a.len() > 0,
    ensures
        match result {
            Some(idx) => idx < a.len() && is_odd(a[idx as int]) &&
                forall|j: int| 0 <= j < idx ==> !is_odd(a[j]),
            None => forall|i: int| 0 <= i < a.len() ==> !is_odd(a[i]),
        },","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0130,verus,verina,verina_basic_50_task,,"This task is about calculating the absolute value of an integer. The goal is to determine the non-negative value of a given integer: if the integer is non-negative, it remains unchanged; if it is negative, its positive counterpart is returned.

-----Input-----
The input consists of:
• x: An integer.

-----Output-----
The output is an integer that represents the absolute value of the input. Specifically:
• If x is non-negative, the output is x.
• If x is negative, the output is the negation of x (that is, a value y such that x + y = 0).

-----Note-----
This function should correctly handle zero, positive, and negative integers.","use vstd::prelude::*;

verus! {

spec fn abs(x: int) -> int {
    if x >= 0 { x } else { -x }
}",,"fn abs_impl(x: i32) -> (result: i32)
    ensures
        (x >= 0 ==> result == x) && (x < 0 ==> x + result == 0),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0131,verus,verina,verina_basic_51_task,,"This task requires creating a function that determines the correct insertion index for a given integer in a sorted array. The goal is to identify an index where every number before it is less than the specified value, and every number from that index onward is greater than or equal to the value. If the given integer is larger than all elements in the array, the function should return the array's size.

-----Input-----
The input consists of:
• a: An array of integers that is assumed to be sorted in non-decreasing order.
• key: An integer to search for in the array.

-----Output-----
The output is a natural number (Nat) representing the index determined by the binary search. The index satisfies the following postconditions:
• It is between 0 and the size of the array.
• Every element before the returned index is less than the key.
• If the returned index equals the size of the array, then all elements are less than the key.
• Every element from the index onwards is greater than or equal to the key.

-----Note-----
It is assumed that the input array is sorted in non-decreasing order. The function returns the first index where the key could be inserted while maintaining the sorted order.","use vstd::prelude::*;

verus! {

spec fn binary_search_precond(a: &Vec<i32>, key: i32) -> bool {
    forall|i: int, j: int| 0 <= i <= j < a.len() ==> a[i] <= a[j]
}",,"fn binary_search(a: &Vec<i32>, key: i32) -> (result: usize)
    requires binary_search_precond(a, key),
    ensures
        result <= a.len(),
        forall|i: int| 0 <= i < result ==> a[i] < key,
        forall|i: int| result <= i < a.len() ==> a[i] >= key,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0132,verus,verina,verina_basic_52_task,,"This task requires developing a solution that sorts an array of integers in non-decreasing order. The solution must return an array that is a rearrangement of the input, containing exactly the same elements but ordered from smallest to largest.

-----Input-----
The input consists of:
• a: An array of integers. This array can be empty or non-empty.

-----Output-----
The output is an array of integers that:
• Is sorted in non-decreasing order (i.e., for any indices i and j with i < j, a[i]! ≤ a[j]!).
• Has the same size as the input array.
• Contains exactly the same elements as the input array, ensuring that the multiset of elements is preserved.

-----Note-----
The implementation uses helper functions for swapping elements and performing inner and outer loops of the bubble sort algorithm. No additional preconditions are required as the function should correctly handle empty and non-empty arrays.","use vstd::prelude::*;

verus! {",,"fn bubble_sort(a: &Vec<i32>) -> (result: Vec<i32>)
    ensures
        result.len() == a.len(),
        forall|i: int, j: int| 0 <= i < j < result.len() ==> result[i] <= result[j],
        a@.to_multiset() == result@.to_multiset(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0135,verus,verina,verina_basic_55_task,,"This task involves determining whether two integer values are equal. The goal is simply to compare the two provided numbers and indicate with a Boolean result whether they are the same.

-----Input-----
The input consists of two elements:
• a: An element of type Int.
• b: An element of type Int.

-----Output-----
The output is a Boolean:
• Returns true if a equals b.
• Returns false if a does not equal b.","use vstd::prelude::*;

verus! {",,"fn compare(a: i32, b: i32) -> (result: bool)
    ensures
        (a == b ==> result == true) && (a != b ==> result == false),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0136,verus,verina,verina_basic_56_task,,"The problem is to update a destination array by replacing a specific segment with values taken from a source array. Given two arrays, starting positions, and a length, the task is to construct a new array where the segment in the destination from the specified starting index for the given length is replaced by the corresponding segment from the source, while all other elements remain unchanged.

Input:
The input consists of:
• src: An array of integers representing the source array.
• sStart: A natural number indicating the starting index in src from where to begin copying.
• dest: An array of integers representing the destination array.
• dStart: A natural number indicating the starting index in dest where the segment will be replaced.
• len: A natural number specifying the number of elements to copy.

Output:
The output is an array of integers that:
• Has the same size as the destination array (dest).
• Preserves the original elements of dest except for the segment starting at index dStart of length len, which is replaced by the corresponding segment from src.
• Under the preconditions that src.size ≥ sStart + len and dest.size ≥ dStart + len, guarantees that:
  - All elements with indices less than dStart remain as in dest.
  - All elements with indices greater than or equal to dStart + len remain as in dest.
  - For each index i with 0 ≤ i < len, the element at index dStart + i in the output equals the element at index sStart + i in src.

Note:
It is assumed that the input arrays satisfy the preconditions: the source array has enough elements starting from sStart and the destination array has enough space starting from dStart to accommodate the copied segment.","use vstd::prelude::*;

verus! {",,"fn copy(src: &Vec<i32>, s_start: usize, dest: &Vec<i32>, d_start: usize, len: usize) -> (result: Vec<i32>)
    requires 
        src.len() >= s_start + len,
        dest.len() >= d_start + len,
    ensures
        result.len() == dest.len(),
        forall|i: int| 0 <= i < d_start ==> #[trigger] result[i] == dest[i],
        forall|i: int| d_start + len <= i < result.len() ==> #[trigger] result[i] == dest[i],
        forall|i: int| 0 <= i < len ==> #[trigger] result[d_start + i] == #[trigger] src[s_start + i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0137,verus,verina,verina_basic_57_task,,"This task involves determining how many numbers within an array are less than a specified threshold. The problem is focused on identifying and counting such numbers based purely on their value in relation to the threshold.

-----Input-----
The input consists of:
• numbers: An array of integers (which may be empty or non-empty).
• threshold: An integer that serves as the comparison threshold.

-----Output-----
The output is a natural number (Nat) representing the count of elements in the array that are less than the given threshold.

-----Note-----
There are no additional preconditions; the function should work correctly for any array of integers and any integer threshold.

/* Helper function to recursively count elements less than threshold */","use vstd::prelude::*;

verus! {

spec fn count_less_than_spec(numbers: Seq<i32>, threshold: i32) -> nat
    decreases numbers.len()
{
    if numbers.len() == 0 {
        0
    } else {
        let first = numbers[0];
        let rest = numbers.subrange(1, numbers.len() as int);
        if first < threshold {
            1 + count_less_than_spec(rest, threshold)
        } else {
            count_less_than_spec(rest, threshold)
        }
    }
}",,"fn count_less_than(numbers: &Vec<i32>, threshold: i32) -> (result: usize)
    ensures
        result == count_less_than_spec(numbers@, threshold),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0138,verus,verina,verina_basic_58_task,,"This task involves transforming an array of integers by doubling each element.

-----Input-----
The input consists of:
• s: An array of integers.

-----Output-----
The output is an array of integers where for each valid index i, the element at position i is equal to twice the corresponding element in the input array.

-----Note-----
The implementation makes use of a recursive helper function to update the array in place. It is assumed that the input array is valid and that the doubling operation does not lead to any overflow issues.

/*
    -- Invalid Inputs
    []
    -- Tests
    [
        {
            ""input"": {
                ""s"": ""#[]""
            },
            ""expected"": ""#[]"",
            ""unexpected"": [
                ""#[1]"",
                ""#[0]"",
                ""#[-1]""
            ]
        },
        {
            ""input"": {
                ""s"": ""#[1, 2, 3, 4, 5]""
            },
            ""expected"": ""#[2, 4, 6, 8, 10]"",
            ""unexpected"": [
                ""#[1, 2, 3, 4, 5]"",
                ""#[2, 4, 6, 8, 9]"",
                ""#[0, 4, 6, 8, 10]""
            ]
        },
        {
            ""input"": {
                ""s"": ""#[0, -1, 5]""
            },
            ""expected"": ""#[0, -2, 10]"",
            ""unexpected"": [
                ""#[0, -1, 5]"",
                ""#[1, -2, 10]"",
                ""#[0, 0, 10]""
            ]
        },
        {
            ""input"": {
                ""s"": ""#[100]""
            },
            ""expected"": ""#[200]"",
            ""unexpected"": [
                ""#[100]"",
                ""#[0]"",
                ""#[201]""
            ]
        },
        {
            ""input"": {
                ""s"": ""#[-3, -4]""
            },
            ""expected"": ""#[-6, -8]"",
            ""unexpected"": [
                ""#[3, -4]"",
                ""#[-6, -7]"",
                ""#[-6, -9]""
            ]
        }
    ]
    */","use vstd::prelude::*;

verus! {",,"fn double_array_elements(s: &Vec<i32>) -> (result: Vec<i32>)
    ensures
        result.len() == s.len(),
        forall|i: int| 0 <= i < s.len() ==> #[trigger] result[i] == 2 * s[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0139,verus,verina,verina_basic_59_task,,"Given an integer x, determine a pair (a, b) where the first element is twice the value of x and the second element is four times the value of x.

-----Input-----
The input consists of:
• x: An integer.

-----Output-----
The output is a tuple (a, b) where:
• a = 2 * x
• b = 4 * x

-----Note-----
There are no additional preconditions; the method is defined for all integers.","use vstd::prelude::*;

verus! {",,"fn double_quadruple(x: i32) -> (result: (i32, i32))
    ensures
        result.0 == 2 * x,
        result.1 == 2 * result.0,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0140,verus,verina,verina_basic_60_task,,"This task requires writing a function that processes an array of integers and produces a new array containing only the even numbers from the input. The order of these even numbers should remain the same as in the original array, ensuring that every even number from the input appears in the output and that every element in the output is even.

-----Input-----
The input consists of one parameter:
• arr: An array of integers.

-----Output-----
The output is an array of integers that:
• Contains exactly all even numbers from the input array, preserving their original order.
• Meets the specified conditions that ensure no extraneous (odd or non-existing) elements are returned.

-----Note-----
There are no additional preconditions. The function must adhere to the provided specification which enforces evenness and order preservation for the elements in the output array.","use vstd::prelude::*;

verus! {

spec fn is_even(n: i32) -> bool {
    n % 2 == 0
}",,"fn find_even_numbers(arr: &Vec<i32>) -> (result: Vec<i32>)
    ensures
        forall|i: int| 0 <= i < result.len() ==> is_even(#[trigger] result[i]),
        forall|i: int| 0 <= i < result.len() ==> exists|j: int| 0 <= j < arr.len() && #[trigger] result[i] == arr[j],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0142,verus,verina,verina_basic_62_task,,"The problem involves finding the first occurrence of a specified key in an array of integers. Your task is to identify the index at which the key appears for the first time in the array and return that index. If the key is not found, return -1.

-----Input-----
The input consists of:
• a: An array of integers.
• key: An integer representing the value to search for in the array.

-----Output-----
The output is an integer which represents:
• The index in the array where the key is found, provided that the index is in the range [0, a.size).
• -1 if the key is not present in the array.
In addition, if the output is not -1, then a[(Int.toNat result)]! equals key and every element in the array prior to this index is not equal to key.

-----Note-----
The function performs a linear search beginning at index 0 and returns the first occurrence of the key. There are no additional preconditions on the input array; it can be empty or non-empty.","use vstd::prelude::*;

verus! {",,"fn find(a: &Vec<i32>, key: i32) -> (result: i32)
    ensures
        (result == -1 || (result >= 0 && result < a.len())),
        result != -1 ==> (a[result as int] == key && forall|i: int| 0 <= i < result ==> a[i] != key),
        result == -1 ==> forall|i: int| 0 <= i < a.len() ==> a[i] != key,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0143,verus,verina,verina_basic_63_task,,"The task is to determine whether there exists at least one pair of different floating-point numbers in a list such that the absolute difference between them is less than a given threshold. The focus is solely on deciding if such a pair is present in the list.

Input:
The input consists of:
• numbers: A list of floating-point numbers.
• threshold: A floating-point number representing the maximum allowed difference between two numbers for them to be considered ""close.""

Output:
The output is a boolean value:
• true – if there exists at least one pair of distinct elements in the list such that the absolute difference between them is less than the threshold.
• false – if for every possible pair of elements, the absolute difference is greater than or equal to the threshold.

Note:
It is assumed that the list of numbers is provided and that the threshold is non-negative.","use vstd::prelude::*;

verus! {

spec fn abs_diff(a: int, b: int) -> int {
    if a >= b { a - b } else { b - a }
}",,"fn has_close_elements(numbers: &Vec<i32>, threshold: i32) -> (result: bool)
    requires threshold >= 0,
    ensures
        !result <==> (forall|i: int, j: int| 
            0 <= i < numbers.len() && 0 <= j < numbers.len() && i != j ==> 
            abs_diff(numbers[i] as int, numbers[j] as int) >= threshold as int),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0144,verus,verina,verina_basic_64_task,,"This task requires writing a Verus method that inserts a subarray of characters into another array of characters at a specified index. The method takes the original array (oline) and, given the effective length l to consider, inserts another array of characters (nl) of effective length p starting at the index atPos. The resulting array is of length l + p and is constructed as follows:
• All characters before the insertion position (atPos) remain unchanged.
• The new characters from nl are inserted starting at index atPos.
• The remaining characters from the original array (starting at atPos) are shifted right by p positions.

-----Input-----
The input consists of:
• oline: An array of characters representing the original sequence.
• l: A natural number indicating how many characters from oline to consider.
• nl: An array of characters to be inserted into oline.
• p: A natural number indicating how many characters from nl to consider for insertion.
• atPos: A natural number indicating the position in oline where the insertion should occur (0-indexed).

-----Output-----
The output is an array of characters that is the result of inserting nl into oline at the given atPos. Specifically, the output array should:
• Contain the original characters from index 0 up to (but not including) atPos.
• Have the next p characters equal to the characters from nl.
• Contain the remaining characters from oline (starting from atPos) shifted right by p positions.

-----Note-----
It is assumed that:
• atPos is within the range [0, l].
• l does not exceed the size of oline.
• p does not exceed the size of nl.","use vstd::prelude::*;

verus! {",,"fn insert(oline: &Vec<char>, l: usize, nl: &Vec<char>, p: usize, at_pos: usize) -> (result: Vec<char>)
    requires
        l <= oline.len(),
        p <= nl.len(),
        at_pos <= l,
    ensures
        result.len() == l + p,
        forall|i: int| 0 <= i < p ==> #[trigger] result[at_pos + i] == nl[i],
        forall|i: int| 0 <= i < at_pos ==> #[trigger] result[i] == oline[i],
        forall|i: int| 0 <= i < (l - at_pos) ==> #[trigger] result[at_pos + p + i] == oline[at_pos + i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0145,verus,verina,verina_basic_65_task,,"This task involves computing the integer square root of a given natural number. The goal is to determine the largest natural number r that satisfies r * r ≤ N and N < (r + 1) * (r + 1).

-----Input-----
The input consists of:
• N: A natural number.

-----Output-----
The output is a natural number r that meets the following conditions:
• r * r ≤ N
• N < (r + 1) * (r + 1)

-----Note-----
The implementation relies on a recursive strategy to iteratively increment r until (r + 1)*(r + 1) exceeds N. Edge cases, such as N = 0, should be handled correctly.","use vstd::prelude::*;

verus! {",,"fn square_root(n: usize) -> (result: usize)
    ensures
        result * result <= n,
        n < (result + 1) * (result + 1),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0146,verus,verina,verina_basic_66_task,,"This task focuses on determining if a given integer is even. The problem requires checking whether the integer can be represented as twice another integer, meaning it is divisible by 2 without any remainder.

-----Input-----
The input consists of a single integer:
• x: An integer to be evaluated.

-----Output-----
The output is a boolean value:
• true if x is even (x mod 2 equals 0).
• false if x is odd.

-----Note-----
No additional preconditions are required. The method should work correctly for any integer value.","use vstd::prelude::*;

verus! {",,"fn compute_is_even(x: int) -> (result: bool)
    ensures
        result == true <==> #[trigger] (x % 2) == 0,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0147,verus,verina,verina_basic_67_task,,"This task requires determining whether a given list of characters is a palindrome; that is, whether the sequence reads the same forward and backward.

-----Input-----
The input consists of:
• x: A list of characters (List Char). The list can be empty or non-empty.

-----Output-----
The output is a Boolean value (Bool):
• Returns true if the input list is a palindrome.
• Returns false otherwise.

-----Note-----
An empty list is considered a palindrome. The function does not impose any additional preconditions.","use vstd::prelude::*;

verus! {",,"fn is_palindrome(x: Seq<char>) -> (result: bool)
    ensures
        result <==> (forall|i: int| 0 <= i < x.len() ==> #[trigger] x[i] == x[x.len() - 1 - i]),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0148,verus,verina,verina_basic_68_task,,"The task is to determine the position of a target integer in a given array. The goal is to return the index corresponding to the first occurrence of the target value. If the target is not present in the array, the result should indicate that by returning the size of the array. This description focuses entirely on understanding the problem without specifying any particular implementation method.

-----Input-----
The input consists of:
• a: An array of integers.
• e: An integer representing the target to search for in the array.

-----Output-----
The output is a natural number (Nat) which is:
• The index of the first occurrence of the target integer if found.
• The size of the array if the target integer is not present.

-----Note-----
There are no strict preconditions on the input; the method should work correctly for any array of integers. The specification ensures that the returned index is always valid: it is either within the array bounds with a matching element or equals the array's size if the element is absent.

/*
    -- Invalid Inputs
    []
    -- Tests
    [
        {
            ""input"": {
                ""a"": ""#[1, 3, 5, 7, 9]"",
                ""e"": 5
            },
            ""expected"": ""2"",
            ""unexpected"": [
                ""1"",
                ""3"",
                ""4""
            ]
        },
        {
            ""input"": {
                ""a"": ""#[2, 4, 6, 8]"",
                ""e"": 5
            },
            ""expected"": ""4"",
            ""unexpected"": [
                ""1"",
                ""3"",
                ""5""
            ]
        },
        {
            ""input"": {
                ""a"": ""#[5, 5, 5]"",
                ""e"": 5
            },
            ""expected"": ""0"",
            ""unexpected"": [
                ""1"",
                ""2"",
                ""3""
            ]
        },
        {
            ""input"": {
                ""a"": ""#[10, 9, 8, 7]"",
                ""e"": 10
            },
            ""expected"": ""0"",
            ""unexpected"": [
                ""1"",
                ""2"",
                ""3""
            ]
        },
        {
            ""input"": {
                ""a"": ""#[1, 2, 3, 3, 4]"",
                ""e"": 3
            },
            ""expected"": ""2"",
            ""unexpected"": [
                ""1"",
                ""3"",
                ""4""
            ]
        }
    ]
    */","use vstd::prelude::*;

verus! {",,"fn linear_search(a: &Vec<i32>, e: i32) -> (result: usize)
    ensures
        result <= a.len(),
        result == a.len() || a[result as int] == e,
        forall|i: int| 0 <= i < result ==> a[i] != e,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0149,verus,verina,verina_basic_69_task,,"This problem involves determining the index of the first occurrence of a specified element within an array of integers. The objective is to identify the correct position where the target element appears for the first time, ensuring that all elements prior to that index are different from the target.

-----Input-----
The input consists of:
• a: An array of integers.
• e: An integer representing the element to search for.

-----Output-----
The output is a natural number (usize) representing the index of the first occurrence of e in the array.
• If the element e exists in the array, the index n will satisfy the conditions specified above.

-----Note-----
It is assumed that the input satisfies the precondition where at least one index i in a exists such that a[i] = e.
The implementation uses a helper function to iterate through the array recursively.","use vstd::prelude::*;

verus! {",,"fn linear_search(a: &Vec<i32>, e: i32) -> (result: usize)
    requires exists|i: int| 0 <= i < a.len() && a[i] == e,
    ensures
        result < a.len(),
        a[result as int] == e,
        forall|k: int| 0 <= k < result ==> a[k] != e,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0150,verus,verina,verina_basic_70_task,,"This task involves determining the first index in an array where a given condition holds true. The goal is to identify the position of the first element that meets a specified criterion, ensuring that no preceding element does.

-----Input-----
The input consists of:
• a: An array of elements (for testing purposes, you can assume it is an array of integers).
• P: A predicate function on the elements (represented as a string for test cases, e.g., ""fun x => x > 5""). It is assumed that at least one element in the array satisfies P.

-----Output-----
The output is a natural number (Nat) which represents the index of the first element in the array that satisfies the predicate P.
• The index returned is less than the size of the array.
• The element at the returned index satisfies P.
• All elements before the returned index do not satisfy P.

-----Note-----
It is assumed that the array contains at least one element that satisfies P. In cases where this precondition does not hold, the behavior of the function is not guaranteed by the specification.

/*
    -- Invalid Inputs
    [
        {
            ""input"": {
                ""a"": ""#[1, 2, 3, 4, 5]"",
                ""P"": ""fun x => x > 10""
            }
        }
    ]
    -- Tests
    [
        {
            ""input"": {
                ""a"": ""#[4, 7, 2, 9]"",
                ""P"": ""fun x => x > 5""
            },
            ""expected"": 1,
            ""unexpected"": [
                0,
                2,
                3
            ]
        },
        {
            ""input"": {
                ""a"": ""#[10, 8, 6, 4, 2]"",
                ""P"": ""fun x => x < 5""
            },
            ""expected"": 3,
            ""unexpected"": [
                0,
                1,
                4
            ]
        },
        {
            ""input"": {
                ""a"": ""#[5, 3, 1, 2]"",
                ""P"": ""fun x => x == 1""
            },
            ""expected"": 2,
            ""unexpected"": [
                0,
                1,
                3
            ]
        },
        {
            ""input"": {
                ""a"": ""#[0, 1, 2, 3]"",
                ""P"": ""fun x => x == 0""
            },
            ""expected"": 0,
            ""unexpected"": [
                1,
                2,
                3
            ]
        },
        {
            ""input"": {
                ""a"": ""#[9, 9, 9, 9]"",
                ""P"": ""fun x => x == 9""
            },
            ""expected"": 0,
            ""unexpected"": [
                1,
                2,
                3
            ]
        }
    ]
    */","use vstd::prelude::*;

verus! {",,"fn linear_search3(a: &Vec<i32>, p: spec_fn(i32) -> bool) -> (result: usize)
    requires 
        exists|i: int| 0 <= i < a.len() && p(a[i]),
    ensures 
        result < a.len(),
        p(a[result as int]),
        forall|k: int| 0 <= k < result ==> !p(a[k]),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0151,verus,verina,verina_basic_71_task,,"This problem involves determining the longest common prefix shared by two lists of characters. Given two sequences, the goal is to identify and return the maximal contiguous sequence of characters from the beginning of both lists that are identical.

-----Input-----
The input consists of:
• str1: A list of characters.
• str2: A list of characters.

-----Output-----
The output is a list of characters representing the longest common prefix of the two input lists. The output list satisfies the following conditions:
• Its length is less than or equal to the length of each input list.
• It is exactly the prefix of both str1 and str2.
• It is empty if the first characters of the inputs differ or if one of the lists is empty.

-----Note-----
It is assumed that both inputs are provided as valid lists of characters. The function always returns the correct longest common prefix based on the inputs.","use vstd::prelude::*;

verus! {",,"fn longest_common_prefix(str1: &Vec<char>, str2: &Vec<char>) -> (result: Vec<char>)
    ensures
        result.len() <= str1.len(),
        result.len() <= str2.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i] == str1[i] && result[i] == str2[i],
        result.len() == str1.len() || result.len() == str2.len() || 
            (result.len() < str1.len() && result.len() < str2.len() && str1[result.len() as int] != str2[result.len() as int]),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0152,verus,verina,verina_basic_72_task,,"-----Description-----
The problem asks you to construct a new list by adding an extra number to the end of an existing list of numbers. The focus is on understanding what the final list should look like when a given number is included as the last element.

-----Input-----
The input consists of:
• a: An array of integers.
• b: An integer to be appended to the array.

-----Output-----
The output is an array of integers which represents the original array with the element b added at the end. That is, the output array's list representation equals a.toList concatenated with [b].

-----Note-----
There are no special preconditions; the method is expected to work correctly for any array of integers and any integer b.","use vstd::prelude::*;

verus! {",,"fn append(a: &Vec<i32>, b: i32) -> (result: Vec<i32>)
    ensures
        result.len() == a.len() + 1,
        forall|i: int| 0 <= i < a.len() ==> result[i] == a[i],
        result[a.len() as int] == b,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0153,verus,verina,verina_basic_73_task,,"Determine whether two strings match based on a specific pattern: for each position in the strings, either the characters are the same, or the character in p is a wildcard represented by a question mark '?' that may match any character.

-----Input-----
The input consists of:
• s: A string that is to be matched.
• p: A pattern string of equal length, where each character is either a specific character or the wildcard '?'.

-----Output-----
The output is a Boolean value:
• Returns true if the length of s is equal to the length of p and each corresponding character in s and p are either identical or the character in p is a '?'.
• Returns false if any character in s does not match the corresponding character in p and the character in p is not a '?'.

-----Note-----
It is assumed that both strings provided have the same length.","use vstd::prelude::*;

verus! {",,"fn match_strings(s: &str, p: &str) -> (result: bool)
    requires s@.len() == p@.len(),
    ensures
        result == (forall|n: int| 0 <= n < s@.len() ==> 
            (s@.index(n) == p@.index(n) || p@.index(n) == '?' as u8)),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0154,verus,verina,verina_basic_74_task,,"This task involves identifying the maximum value in a non-empty array of integers. The objective is to determine which element in the array is greater than or equal to every other element, ensuring that the selected value is one of the elements in the array.

-----Input-----
The input consists of:
• a: An array of integers. It is assumed that the array is non-empty (i.e., its size is at least 1).

-----Output-----
The output is an integer that represents the maximum element in the array. This value is guaranteed to satisfy the following:
• It is greater than or equal to every element in the array.
• It is exactly equal to one of the elements in the array.

-----Note-----
It is assumed that the provided array is non-empty. In cases where the array is empty, the function's behavior is not defined.

/*
    -- Invalid Inputs
    [
        {
            ""input"": {
                ""a"": ""[]""
            }
        }
    ]
    -- Tests
    [
        {
            ""input"": {
                ""a"": ""[1, 2, 3, 4, 5]""
            },
            ""expected"": 5,
            ""unexpected"": [
                4,
                3
            ]
        },
        {
            ""input"": {
                ""a"": ""[5, 3, 4, 1, 2]""
            },
            ""expected"": 5,
            ""unexpected"": [
                4,
                3,
                2
            ]
        },
        {
            ""input"": {
                ""a"": ""[7]""
            },
            ""expected"": 7,
            ""unexpected"": [
                6,
                8
            ]
        },
        {
            ""input"": {
                ""a"": ""[-1, -5, -3, -4]""
            },
            ""expected"": -1,
            ""unexpected"": [
                -3,
                -4
            ]
        },
        {
            ""input"": {
                ""a"": ""[-10, -20, -30, -5, -15]""
            },
            ""expected"": -5,
            ""unexpected"": [
                -10,
                -15,
                -20
            ]
        }
    ]
    */","use vstd::prelude::*;

verus! {

spec fn max_array_precond(a: &Vec<i32>) -> bool {
    a.len() > 0
}",,"fn max_array(a: &Vec<i32>) -> (result: i32)
    requires max_array_precond(a),
    ensures
        forall|k: int| 0 <= k < a.len() ==> result >= a[k],
        exists|k: int| 0 <= k < a.len() && result == a[k],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0155,verus,verina,verina_basic_75_task,,"This task involves finding the minimum element in a non-empty array of integers. The goal is to identify and return the smallest number present in the array.

-----Input-----
The input consists of:
• a: An array of integers (the array is assumed to be non-empty).

-----Output-----
The output is an integer that:
• Is the smallest element from the input array.
• Satisfies the property that it is less than or equal to every element in the array and is exactly equal to at least one element of the array.

-----Note-----
It is assumed that the input array contains at least one element. The implementation uses a helper function (loop) to recursively compare elements and determine the minimum value.","use vstd::prelude::*;

verus! {",,"fn min_array(a: &Vec<i32>) -> (result: i32)
    requires a.len() > 0,
    ensures
        forall|i: int| 0 <= i < a.len() ==> result <= a[i],
        exists|i: int| 0 <= i < a.len() && result == a[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0156,verus,verina,verina_basic_76_task,,"This task requires determining the smaller of two integers. Given two input numbers, the goal is to compare them and return the one that is less than or equal to the other.

-----Input-----
The input consists of two integers:
• x: The first integer.
• y: The second integer.

-----Output-----
The output is an integer representing the minimum of the two input integers:
• Returns x if x is less than or equal to y.
• Returns y if x is greater than y.","use vstd::prelude::*;

verus! {",,"fn my_min(x: i32, y: i32) -> (result: i32)
    ensures
        (x <= y ==> result == x) && (x > y ==> result == y),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0157,verus,verina,verina_basic_77_task,,"This task involves updating an element within a 2-dimensional array. The goal is to modify only a specific inner array by changing one of its elements to a new value while keeping every other element and all other inner arrays unchanged.

-----Input-----
The input consists of:
• arr: An array of arrays of natural numbers.
• index1: A natural number representing the index in the outer array identifying which inner array to modify (0-indexed).
• index2: A natural number representing the index within the selected inner array that should be updated (0-indexed).
• val: A natural number which is the new value to set at the specified inner index.

-----Output-----
The output is an array of arrays of natural numbers that:
• Has the same overall structure as the input.
• Contains all original inner arrays unchanged except for the inner array at position index1.
• In the modified inner array, only the element at index2 is replaced with val, while all other elements remain the same.

-----Note-----
It is assumed that index1 is a valid index for the outer array and that index2 is a valid index within the corresponding inner array.

/* 
    -- Invalid Inputs
    [
        {
            ""input"": {
                ""arr"": ""#[#[1, 2, 3], #[4, 5, 6]]"",
                ""index1"": 1,
                ""index2"": 3,
                ""val"": 99
            }
        }
    ]
    -- Tests
    [
        {
            ""input"": {
                ""arr"": ""#[#[1, 2, 3], #[4, 5, 6]]"",
                ""index1"": 0,
                ""index2"": 1,
                ""val"": 99
            },
            ""expected"": ""#[#[1, 99, 3], #[4, 5, 6]]"",
            ""unexpected"": [
                ""#[#[1, 2, 3], #[4, 99, 6]]"",
                ""#[#[1, 99, 3], #[4, 5, 7]]"",
                ""#[#[99, 1, 3], #[4, 5, 6]]""
            ]
        },
        {
            ""input"": {
                ""arr"": ""#[#[7, 8], #[9, 10]]"",
                ""index1"": 1,
                ""index2"": 0,
                ""val"": 0
            },
            ""expected"": ""#[#[7, 8], #[0, 10]]"",
            ""unexpected"": [
                ""#[#[7, 0], #[9, 10]]"",
                ""#[#[7, 8], #[9, 0]]"",
                ""#[#[0, 8], #[9, 10]]""
            ]
        },
        {
            ""input"": {
                ""arr"": ""#[#[0, 0, 0]]"",
                ""index1"": 0,
                ""index2"": 2,
                ""val"": 5
            },
            ""expected"": ""#[#[0, 0, 5]]"",
            ""unexpected"": [
                ""#[#[0, 5, 0]]"",
                ""#[#[5, 0, 0]]""
            ]
        },
        {
            ""input"": {
                ""arr"": ""#[#[3, 4, 5], #[6, 7, 8], #[9, 10, 11]]"",
                ""index1"": 2,
                ""index2"": 1,
                ""val"": 100
            },
            ""expected"": ""#[#[3, 4, 5], #[6, 7, 8], #[9, 100, 11]]"",
            ""unexpected"": [
                ""#[#[3, 4, 5], #[6, 7, 8], #[9, 10, 11]]"",
                ""#[#[3, 4, 5], #[6, 7, 8], #[9, 7, 11]]"",
                ""#[#[3, 4, 5], #[6, 7, 8], #[100, 10, 11]]""
            ]
        },
        {
            ""input"": {
                ""arr"": ""#[#[1]]"",
                ""index1"": 0,
                ""index2"": 0,
                ""val"": 42
            },
            ""expected"": ""#[#[42]]"",
            ""unexpected"": [
                ""#[#[1]]"",
                ""#[#[0]]"",
                ""#[#[99]]""
            ]
        }
    ]
    */","use vstd::prelude::*;

verus! {",,"fn modify_array_element(arr: Vec<Vec<nat>>, index1: usize, index2: usize, val: nat) -> (result: Vec<Vec<nat>>)
    requires
        index1 < arr.len(),
        index2 < arr[index1 as int].len(),
    ensures
        result.len() == arr.len(),
        forall|i: int| 0 <= i < arr.len() && i != index1 ==> result[i] == arr[i],
        forall|j: int| 0 <= j < arr[index1 as int].len() && j != index2 ==> result[index1 as int][j] == arr[index1 as int][j],
        result[index1 as int][index2 as int] == val,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0158,verus,verina,verina_basic_78_task,,"Given two integers, the task is to compute two output values: one being the sum of the integers and the other being their difference.

-----Input-----
The input consists of two integers:
• x: An integer.
• y: An integer.

-----Output-----
The output is a tuple of two integers:
• The first element is x + y.
• The second element is x - y.

-----Note-----
It is assumed that x and y are valid integers. There are no additional constraints on the inputs.

/*
    // -- Invalid Inputs
    // []
    // -- Tests
    // [
    //     {
    //         ""input"": {
    //             ""x"": 3,
    //             ""y"": 2
    //         },
    //         ""expected"": ""(5, 1)"",
    //         ""unexpected"": [
    //             ""(6, 2)"",
    //             ""(5, 2)"",
    //             ""(4, 1)""
    //         ]
    //     },
    //     {
    //         ""input"": {
    //             ""x"": -2,
    //             ""y"": 3
    //         },
    //         ""expected"": ""(1, -5)"",
    //         ""unexpected"": [
    //             ""(-1, 5)"",
    //             ""(2, -3)"",
    //             ""(1, 5)""
    //         ]
    //     },
    //     {
    //         ""input"": {
    //             ""x"": 0,
    //             ""y"": 0
    //         },
    //         ""expected"": ""(0, 0)"",
    //         ""unexpected"": [
    //             ""(1, 0)"",
    //             ""(0, 1)"",
    //             ""(-1, 0)""
    //         ]
    //     },
    //     {
    //         ""input"": {
    //             ""x"": 10,
    //             ""y"": 5
    //         },
    //         ""expected"": ""(15, 5)"",
    //         ""unexpected"": [
    //             ""(14, 5)"",
    //             ""(15, 6)"",
    //             ""(10, 5)""
    //         ]
    //     },
    //     {
    //         ""input"": {
    //             ""x"": -5,
    //             ""y"": -10
    //         },
    //         ""expected"": ""(-15, 5)"",
    //         ""unexpected"": [
    //             ""(-15, -5)"",
    //             ""(-5, 15)"",
    //             ""(-10, 0)""
    //         ]
    //     }
    // ]
    // */

//","use vstd::prelude::*;

verus! {",,"fn multiple_returns(x: i32, y: i32) -> (result: (i32, i32))
    ensures
        result.0 == x + y,
        result.1 + y == x,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0159,verus,verina,verina_basic_79_task,,"Given a nonempty array of integers and a valid index x (with 1 ≤ x < array size), the task is to identify two key pieces of information. First, determine the maximum value among the first x elements of the array. Second, select an index p within the range [x, array size) that satisfies the following conditions: if there exists an element in the segment starting from index x that is strictly greater than the previously determined maximum, then p should be the index of the first such occurrence; otherwise, p should be set to the last index of the array. The focus of the problem is solely on correctly identifying the maximum and choosing the appropriate index based on these order conditions.

Input:
The input consists of:
• a: An array of integers (assumed to be nonempty).
• x: A natural number (Nat) such that 1 ≤ x < a.size.

Output:
The output is a pair (m, p) where:
• m is the maximum value among the first x elements of the array.
• p is an index in the array, with x ≤ p < a.size, determined based on the ordering condition where a[p] is the first element (from index x onward) that is strictly greater than m. If no such element exists, then p is set to a.size − 1.

Note:
It is assumed that the array a is nonempty and that the parameter x meets the precondition 1 ≤ x < a.size. The function relies on helper functions to compute the maximum among the first x elements and to select the appropriate index p based on the given conditions.","use vstd::prelude::*;

verus! {",,"fn online_max(a: &Vec<i32>, x: usize) -> (result: (i32, usize))
    requires
        a.len() > 0,
        x < a.len(),
    ensures
        ({
            let (m, p) = result;
            x <= p && p < a.len()
            && (forall|i: int| 0 <= i < x ==> a[i] <= m)
            && (exists|i: int| 0 <= i < x && a[i] == m)
            && ((p < a.len() - 1) ==> (exists|i: int| x <= i <= p && a[i] > m))
            && ((forall|i: int| x <= i < a.len() ==> a[i] <= m) ==> p == a.len() - 1)
        })","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0160,verus,verina,verina_basic_80_task,,"This task involves determining whether a specified key appears exactly once in an array. The goal is to verify the uniqueness of the key's occurrence without prescribing any specific approach or implementation method.

-----Input-----
The input consists of:
• a: An array of integers.
• key: An integer representing the element whose occurrence is to be checked.

-----Output-----
The output is a Boolean value that:
• Is true if the key appears exactly once in the array.
• Is false otherwise.

-----Note-----
The function should correctly handle arrays with no occurrences of the key, multiple occurrences, and exactly one occurrence.","use vstd::prelude::*;

verus! {

spec fn count_occurrences(a: Seq<i32>, key: i32) -> nat {
    a.filter(|x: i32| x == key).len()
}",,"fn only_once(a: &Vec<i32>, key: i32) -> (result: bool)
    ensures
        result <==> count_occurrences(a@, key) == 1,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0162,verus,verina,verina_basic_82_task,,"This task is about processing an array of integers by producing a new array that excludes the first element. The objective is to define a clear behavior: if the array contains at least one element, return a modified array starting from the second element.

-----Input-----
The input consists of:
• a: An array of integers.

-----Output-----
The output is an array of integers that:
• Has a length equal to the original array's length minus one.
• Contains the same elements as the input array except for the first element.
• Satisfies the condition that for every index i in the output array, the element at position i is equal to the element at position i+1 in the input array.

-----Note-----
It is assumed that the input array is non-empty.

/* 
    -- Invalid Inputs
    [
        {
            ""input"": {
                ""a"": ""#[]""
            }
        }
    ]
    -- Tests
    [
        {
            ""input"": {
                ""a"": ""#[1, 2, 3, 4, 5]""
            },
            ""expected"": ""#[2, 3, 4, 5]"",
            ""unexpected"": [
                ""#[1, 2, 3, 4, 5]"",
                ""#[3, 4, 5]"",
                ""#[2, 3, 4]""
            ]
        },
        {
            ""input"": {
                ""a"": ""#[10, 20, 30]""
            },
            ""expected"": ""#[20, 30]"",
            ""unexpected"": [
                ""#[10, 20, 30]"",
                ""#[10, 30]"",
                ""#[10, 20]""
            ]
        },
        {
            ""input"": {
                ""a"": ""#[0, -1, -2, -3]""
            },
            ""expected"": ""#[-1, -2, -3]"",
            ""unexpected"": [
                ""#[0, -1, -2, -3]"",
                ""#[-1, -3]"",
                ""#[-2, -3]""
            ]
        },
        {
            ""input"": {
                ""a"": ""#[7]""
            },
            ""expected"": ""#[]"",
            ""unexpected"": [
                ""#[7]"",
                ""#[0]"",
                ""#[7, 7]""
            ]
        },
        {
            ""input"": {
                ""a"": ""#[100, 0, 50]""
            },
            ""expected"": ""#[0, 50]"",
            ""unexpected"": [
                ""#[100, 0, 50]"",
                ""#[50]"",
                ""#[0]""
            ]
        }
    ]
    */","use vstd::prelude::*;

verus! {",,"fn remove_front(a: &Vec<i32>) -> (result: Vec<i32>)
    requires a.len() > 0,
    ensures
        a.len() > 0,
        result.len() == a.len() - 1,
        forall|i: int| 0 <= i < result.len() ==> result[i] == a[i + 1],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0163,verus,verina,verina_basic_83_task,,"This task involves concatenating two arrays of integers by appending the second array to the end of the first array. The goal is to produce a new array that sequentially contains all elements from the first array followed by all elements from the second array.

-----Input-----
The input consists of two parameters:
• a: An Array of integers representing the first part of the concatenated array.
• b: An Array of integers representing the second part of the concatenated array.

-----Output-----
The output is an Array of integers that satisfies the following:
• The length of the output array is equal to the sum of the lengths of arrays a and b.
• The first part of the output array (indices 0 to a.size - 1) is identical to array a.
• The remaining part of the output array (indices a.size to a.size + b.size - 1) is identical to array b.

-----Note-----
No additional preconditions are required since the function uses the sizes of the input arrays to build the resulting array.","use vstd::prelude::*;

verus! {",,"fn concat(a: &Vec<i32>, b: &Vec<i32>) -> (result: Vec<i32>)
    ensures
        result.len() == a.len() + b.len(),
        forall|k: int| 0 <= k < a.len() ==> result[k] == a[k],
        forall|k: int| 0 <= k < b.len() ==> result[k + a.len()] == b[k],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0164,verus,verina,verina_basic_84_task,,"You are given an array of integers and a threshold value k. The problem is to create a new array where every element greater than k is replaced with -1 while every other element remains unchanged.

-----Input-----
The input consists of:
• arr: An array of integers.
• k: An integer used as the threshold for replacement.

-----Output-----
The output is an array of integers that satisfies the following conditions:
• For every index i, if arr[i] is greater than k, then the returned array at index i is -1.
• For every index i, if arr[i] is less than or equal to k, then the returned array at index i remains unchanged.

-----Note-----
It is assumed that the input array may be empty or non-empty, and that k can be any integer. There are no additional preconditions.","use vstd::prelude::*;

verus! {",,"fn replace(arr: &Vec<i32>, k: i32) -> (result: Vec<i32>)
    ensures
        result.len() == arr.len(),
        forall|i: int| 0 <= i < arr.len() ==> (arr[i] > k ==> result[i] == -1),
        forall|i: int| 0 <= i < arr.len() ==> (arr[i] <= k ==> result[i] == arr[i]),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0165,verus,verina,verina_basic_85_task,,"This problem focuses on reversing an array of integers. The goal is to take an input array and produce a new array with the elements arranged in the reverse order.

-----Input-----
The input consists of:
• a: An array of integers, which may be empty, contain one element, or many elements.

-----Output-----
The output is an array of integers that:
• Has the same length as the input array.
• Contains the same elements as the input array, but in reverse order.
• For every valid index i in the input array, the output at index i is equal to the element at index (a.size - 1 - i) from the input array.

-----Note-----
There are no specific preconditions; the method should correctly handle any array of integers.","use vstd::prelude::*;

verus! {",,"fn reverse(a: &Vec<i32>) -> (result: Vec<i32>)
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < a.len() ==> result[i] == a[a.len() - 1 - i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0166,verus,verina,verina_basic_86_task,,"This task requires writing a Verus method that rotates an array of integers to the left by a specified offset.

-----Input-----
The input consists of:
• a: An array of integers (which may be empty or non-empty).
• offset: An integer representing the number of positions to rotate the array. The offset is assumed to be non-negative.

-----Output-----
The output is an array of integers that:
• Has the same length as the input array.
• For every valid index i, the output element at index i is equal to the input element at index ((i + offset) mod n), where n is the array size.

-----Note-----
If the array is empty, the method should return an empty array.","use vstd::prelude::*;

verus! {",,"fn rotate(a: &Vec<i32>, offset: int) -> (result: Vec<i32>)
    requires offset >= 0,
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < a.len() ==> {
            let src_idx = (i + offset) % (a.len() as int);
            #[trigger] result[i] == a[src_idx]
        },","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0167,verus,verina,verina_basic_87_task,,"This problem requires sorting an array of integers into non-decreasing order, ensuring that the output contains exactly the same elements as the input (i.e., it is a permutation of the original array).

Input: The input consists of an array of integers (Vec<i32>).

Output: The output is an array of integers that is:
• Sorted in non-decreasing order.
• A permutation of the input, meaning it contains exactly the same elements (with the same multiplicities) as the original array.

Note: It is assumed that the input array is valid and that the swap operations, along with the helper functions, correctly implement the selection sort algorithm.

// Invalid Inputs: []

// Tests:

// Test 1: input a = vec![3, 1, 2], expected vec![1, 2, 3]

// Test 2: input a = vec![0], expected vec![0] 

// Test 3: input a = vec![5, 4, 3, 2, 1], expected vec![1, 2, 3, 4, 5]

// Test 4: input a = vec![2, 2, 1, 4], expected vec![1, 2, 2, 4]

// Test 5: input a = vec![10, -5, 0, 3], expected vec![-5, 0, 3, 10]","use vstd::prelude::*;

verus! {",,"fn selection_sort(a: &Vec<i32>) -> (result: Vec<i32>)
    ensures
        result.len() == a.len(),
        forall|i: int, j: int| 0 <= i <= j < result.len() ==> result[i] <= result[j],
        result@ =~= a@,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0168,verus,verina,verina_basic_88_task,,"This task involves converting a list of integers into an array such that the array contains all the elements of the list in the exact same order. The objective is to ensure that the array has the same number of elements as the list and that each element in the array corresponds exactly to the element at the same position in the list.

Input:
The input consists of:
• xs: A list of integer elements.

Output:
The output is an array of elements of type integer that:
• Has a size equal to the length of the input list xs.
• Contains all the elements from xs in the same order, ensuring that for every valid index i, the array element at i is equal to the list element at i.

Note:
There are no additional preconditions; the method should work correctly for any list of elements.
A corresponding specification is provided stating that the array's size equals the list's length and that each element is preserved.","use vstd::prelude::*;

verus! {",,"fn to_array(xs: &Seq<i32>) -> (result: Vec<i32>)
    ensures
        result.len() == xs.len(),
        forall|i: int| 0 <= i < xs.len() ==> result[i] == xs[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0169,verus,verina,verina_basic_89_task,,"This problem asks you to design a solution that transforms a list with possible duplicate entries into a new list where each element appears only once, maintaining the order of its first occurrence.

-----Input-----
The input consists of:
• s: A list of integers (or any type supporting decidable equality) that may contain duplicate elements.

-----Output-----
The output is a list of integers (or the original type) in which every duplicate element is removed. The order of elements is preserved based on their first appearance in the input list, ensuring that the set of elements in the output is identical to the set in the input.

-----Note-----
No additional preconditions are required. The method should correctly handle any list, including an empty list.

// All elements are unique in the result  

// Every element in result is in s

// Every element in s is in result

/*
    -- Invalid Inputs
    []
    -- Tests
    [
        {
            ""input"": {
                ""s"": ""[1, 2, 2, 3, 1]""
            },
            ""expected"": ""[1, 2, 3]"",
            ""unexpected"": [
                ""[1, 3, 2]"",
                ""[1, 2, 2, 3]"",
                ""[2, 1, 3]""
            ]
        },
        {
            ""input"": {
                ""s"": ""[5, 5, 5, 5]""
            },
            ""expected"": ""[5]"",
            ""unexpected"": [
                ""[5, 5]"",
                ""[]"",
                ""[6]""
            ]
        },
        {
            ""input"": {
                ""s"": ""[]""
            },
            ""expected"": ""[]"",
            ""unexpected"": [
                ""[1]"",
                ""[2]"",
                ""[0]""
            ]
        },
        {
            ""input"": {
                ""s"": ""[11, 22, 33]""
            },
            ""expected"": ""[11, 22, 33]"",
            ""unexpected"": [
                ""[33, 22, 11]"",
                ""[11, 11, 22, 33]"",
                ""[11, 33]""
            ]
        },
        {
            ""input"": {
                ""s"": ""[3, 1, 4, 1, 5, 9, 2, 6, 5]""
            },
            ""expected"": ""[3, 1, 4, 5, 9, 2, 6]"",
            ""unexpected"": [
                ""[3, 1, 4, 1, 5, 9, 2, 6, 5]"",
                ""[1, 3, 4, 5, 9, 2, 6]"",
                ""[3, 1, 4, 5, 9, 6]""
            ]
        }
    ]
    */","use vstd::prelude::*;

verus! {",,"fn set_to_seq(s: &Vec<i32>) -> (result: Vec<i32>)
    ensures

        forall|i: int, j: int| 0 <= i < j < result.len() ==> result[i] != result[j],

        forall|i: int| 0 <= i < result.len() ==> 
            exists|j: int| 0 <= j < s.len() && s[j] == #[trigger] result[i],

        forall|i: int| 0 <= i < s.len() ==> 
            exists|j: int| 0 <= j < result.len() && result[j] == #[trigger] s[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0170,verus,verina,verina_basic_90_task,,"The task is to search for a specific integer in a 2D array where the rows and columns are sorted in non-decreasing order. The goal is to locate the key and return its position as row and column indices, or return (-1, -1) if the algorithm fails to find the key.

-----Input-----
The input consists of:
• a: A non-empty 2D array of integers (Vec<Vec<i32>>). The array is guaranteed to contain at least one element.
• key: An integer value (i32) to search for in the array.

-----Output-----
The output is a pair of integers (i32, i32):
• If the key is found, the first element represents the row index and the second element represents the column index such that get2d a row col = key.
• If the key is not found, the function returns (-1, -1).

-----Note-----
It is assumed that the input 2D array is sorted by rows and columns.

/* Invalid Inputs
    [
        {
            ""input"": {
                ""a"": ""vec![vec![1, 3, 2], vec![0, 6, 5], vec![7, 8, 9]]"",
                ""key"": 2
            }
        }
    ]
    Tests
    [
        {
            ""input"": {
                ""a"": ""vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]"",
                ""key"": 5
            },
            ""expected"": ""(1, 1)"",
            ""unexpected"": [
                ""(1, 2)"",
                ""(0, 1)""
            ]
        },
        {
            ""input"": {
                ""a"": ""vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]"",
                ""key"": 3
            },
            ""expected"": ""(0, 2)"",
            ""unexpected"": [
                ""(0, 1)"",
                ""(1, 2)""
            ]
        },
        {
            ""input"": {
                ""a"": ""vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]"",
                ""key"": 10
            },
            ""expected"": ""(-1, -1)"",
            ""unexpected"": [
                ""(1, 1)"",
                ""(2, 2)""
            ]
        },
        {
            ""input"": {
                ""a"": ""vec![vec![1, 2, 3, 4]]"",
                ""key"": 4
            },
            ""expected"": ""(0, 3)"",
            ""unexpected"": [
                ""(0, 2)"",
                ""(1, 3)"",
                ""(0, 4)""
            ]
        },
        {
            ""input"": {
                ""a"": ""vec![vec![1], vec![2], vec![3], vec![4]]"",
                ""key"": 3
            },
            ""expected"": ""(2, 0)"",
            ""unexpected"": [
                ""(1, 0)"",
                ""(2, 1)""
            ]
        }
    ] */","use vstd::prelude::*;

verus! {

spec fn slope_search_precond(a: &Vec<Vec<i32>>, key: i32) -> bool {
    a.len() > 0 &&
    (forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i].len() == a[0].len()) &&
    (forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a[i].len() - 1 ==> #[trigger] a[i][j] <= a[i][j + 1]) &&
    (forall|j: int, i: int| 0 <= j < a[0].len() && 0 <= i < a.len() - 1 ==> #[trigger] a[i][j] <= a[i + 1][j])
}",,"fn slope_search(a: &Vec<Vec<i32>>, key: i32) -> (result: (i32, i32))
    requires slope_search_precond(a, key),
    ensures
        ({
            let (m, n) = result;
            ((m >= 0 && m < a.len() && n >= 0 && n < a[0].len() && a[m as int][n as int] == key) ||
             (m == -1 && n == -1 && forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a[i].len() ==> #[trigger] a[i][j] != key))
        })","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0171,verus,verina,verina_basic_91_task,,"This task involves creating a function that swaps two integer values. Given two integers, the function should return a pair where the first element is the second input value and the second element is the first input value.

-----Input-----
The input consists of two integers:
• X: An integer representing the first value.
• Y: An integer representing the second value.

-----Output-----
The output is a pair (i32, i32) that:
• Contains the original Y as the first element.
• Contains the original X as the second element.

-----Note-----
There are no additional preconditions. The function simply swaps the two input values.","use vstd::prelude::*;

verus! {",,"fn swap(x: i32, y: i32) -> (result: (i32, i32))
    ensures
        result.0 == y,
        result.1 == x,
        x != y ==> result.0 != x && result.1 != y,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0172,verus,verina,verina_basic_92_task,,"This problem involves swapping the values of two integers. Given two integers as inputs, the objective is to return the two numbers in reversed order.

-----Input-----
The input consists of two integers:
• X: The first integer.
• Y: The second integer.

-----Output-----
The output is a tuple of two integers (Int × Int) where:
• The first element is equal to Y.
• The second element is equal to X.

-----Note-----
There are no restrictions on the input values. The function must correctly swap the inputs regardless of whether they are positive, negative, or zero.

/* Invalid Inputs
    // []
    // Tests
    // [
    //     {
    //         ""input"": {
    //             ""X"": 3,
    //             ""Y"": 4
    //         },
    //         ""expected"": ""(4, 3)"",
    //         ""unexpected"": [
    //             ""(3, 4)"",
    //             ""(3, 3)"",
    //             ""(4, 4)""
    //         ]
    //     },
    //     {
    //         ""input"": {
    //             ""X"": -1,
    //             ""Y"": 10
    //         },
    //         ""expected"": ""(10, -1)"",
    //         ""unexpected"": [
    //             ""(-1, 10)"",
    //             ""(10, 1)"",
    //             ""(-10, -1)""
    //         ]
    //     },
    //     {
    //         ""input"": {
    //             ""X"": 0,
    //             ""Y"": 0
    //         },
    //         ""expected"": ""(0, 0)"",
    //         ""unexpected"": [
    //             ""(0, 1)"",
    //             ""(1, 0)"",
    //             ""(-1, 0)""
    //         ]
    //     },
    //     {
    //         ""input"": {
    //             ""X"": 100,
    //             ""Y"": 50
    //         },
    //         ""expected"": ""(50, 100)"",
    //         ""unexpected"": [
    //             ""(100, 50)"",
    //             ""(50, 50)"",
    //             ""(100, 100)""
    //         ]
    //     },
    //     {
    //         ""input"": {
    //             ""X"": -5,
    //             ""Y"": -10
    //         },
    //         ""expected"": ""(-10, -5)"",
    //         ""unexpected"": [
    //             ""(-5, -10)"",
    //             ""(-10, -10)"",
    //             ""(-5, -5)""
    //         ]
    //     }
    // ] */

//","use vstd::prelude::*;

verus! {",,"fn swap_arithmetic(x: i32, y: i32) -> (result: (i32, i32))
    ensures
        result.0 == y,
        result.1 == x,
        x != y ==> (result.0 != x && result.1 != y),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0173,verus,verina,verina_basic_93_task,,"This task requires swapping two 8-bit unsigned integers. Given two unsigned integer inputs, the goal is to produce an output pair where the first element is the original second input and the second element is the original first input. The problem focuses solely on exchanging the values without specifying any particular method to achieve the swap.

Input:
The input consists of:
• X: A u8 value.
• Y: A u8 value.

Output:
The output is a pair of u8 values (newX, newY) where:
• newX is equal to the original Y.
• newY is equal to the original X.

Note:
There are no additional preconditions; the function is meant to work correctly for any pair of u8 values by leveraging bitwise xor operations.

/* 
    -- Invalid Inputs
    []
    -- Tests
    [
        {
            ""input"": {
                ""X"": 0,
                ""Y"": 0
            },
            ""expected"": ""(0, 0)"",
            ""unexpected"": [
                ""(0, 1)"",
                ""(1, 0)""
            ]
        },
        {
            ""input"": {
                ""X"": 5,
                ""Y"": 10
            },
            ""expected"": ""(10, 5)"",
            ""unexpected"": [
                ""(5, 10)"",
                ""(10, 10)"",
                ""(5, 5)""
            ]
        },
        {
            ""input"": {
                ""X"": 255,
                ""Y"": 1
            },
            ""expected"": ""(1, 255)"",
            ""unexpected"": [
                ""(255, 1)"",
                ""(1, 254)"",
                ""(0, 255)""
            ]
        },
        {
            ""input"": {
                ""X"": 128,
                ""Y"": 64
            },
            ""expected"": ""(64, 128)"",
            ""unexpected"": [
                ""(128, 64)"",
                ""(64, 64)"",
                ""(0, 128)""
            ]
        },
        {
            ""input"": {
                ""X"": 15,
                ""Y"": 15
            },
            ""expected"": ""(15, 15)"",
            ""unexpected"": [
                ""(15, 16)"",
                ""(16, 15)"",
                ""(14, 15)""
            ]
        }
    ]
    */","use vstd::prelude::*;

verus! {",,"fn swap_bitvectors(x: u8, y: u8) -> (result: (u8, u8))
    ensures
        result.0 == y && result.1 == x,
        x != y ==> (result.0 != x && result.1 != y),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0174,verus,verina,verina_basic_94_task,,"This task involves taking an array as input and producing a new array that has the same size and identical elements in the same order as the input.

-----Input-----
The input consists of:
• s: An array of elements (for testing purposes, assume an array of integers, i.e., Array Int).

-----Output-----
The output is an array of the same type as the input:
• The output array has the same size as the input array.
• Each element in the output array is identical to the corresponding element in the input array.

-----Note-----
There are no special preconditions for the input array (it can be empty or non-empty); the function simply performs a straightforward copy operation on the array.","use vstd::prelude::*;

verus! {",,"fn iter_copy(s: &Vec<i32>) -> (result: Vec<i32>)
    ensures
        s.len() == result.len(),
        forall|i: int| 0 <= i < s.len() ==> s[i] == result[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0175,verus,verina,verina_basic_95_task,,"This problem involves swapping two elements in an array of integers at specified positions. Given an array and two indices, the task is to exchange these elements so that the element from the first index moves to the second index and vice versa, while all other elements remain unchanged.

-----Input-----
The input consists of:
• arr: An array of integers.
• i: An integer representing the first index (0-indexed) whose element is to be swapped.
• j: An integer representing the second index (0-indexed) whose element is to be swapped.

-----Output-----
The output is an array of integers which:
• Has the same size as the input array.
• Contains the element originally at index i in position j and the element originally at index j in position i.
• Leaves all other elements unchanged.

-----Note-----
It is assumed that both indices i and j are non-negative and within the bounds of the array (i.e., i and j are less than arr.len()).

/*
    // -- Invalid Inputs
    // [
    //     {
    //         ""input"": {
    //             ""arr"": ""[1, 2, 3, 4]"",
    //             ""i"": -1,
    //             ""j"": 2
    //         }
    //     }
    // ]
    // -- Tests
    // [
    //     {
    //         ""input"": {
    //             ""arr"": ""[1, 2, 3, 4, 5]"",
    //             ""i"": 1,
    //             ""j"": 3
    //         },
    //         ""expected"": ""[1, 4, 3, 2, 5]"",
    //         ""unexpected"": [
    //             ""[1, 2, 3, 4, 5]"",
    //             ""[1, 3, 2, 4, 5]""
    //         ]
    //     },
    //     {
    //         ""input"": {
    //             ""arr"": ""[10, 20, 30, 40]"",
    //             ""i"": 0,
    //             ""j"": 3
    //         },
    //         ""expected"": ""[40, 20, 30, 10]"",
    //         ""unexpected"": [
    //             ""[10, 40, 30, 20]"",
    //             ""[10, 20, 40, 30]""
    //         ]
    //     },
    //     {
    //         ""input"": {
    //             ""arr"": ""[7, 8, 9]"",
    //             ""i"": 1,
    //             ""j"": 2
    //         },
    //         ""expected"": ""[7, 9, 8]"",
    //         ""unexpected"": [
    //             ""[8, 7, 9]"",
    //             ""[9, 8, 7]""
    //         ]
    //     },
    //     {
    //         ""input"": {
    //             ""arr"": ""[1, 2, 3, 4]"",
    //             ""i"": 0,
    //             ""j"": 0
    //         },
    //         ""expected"": ""[1, 2, 3, 4]"",
    //         ""unexpected"": [
    //             ""[1, 2, 4, 3]"",
    //             ""[4, 2, 3, 1]""
    //         ]
    //     },
    //     {
    //         ""input"": {
    //             ""arr"": ""[-1, -2, -3]"",
    //             ""i"": 0,
    //             ""j"": 2
    //         },
    //         ""expected"": ""[-3, -2, -1]"",
    //         ""unexpected"": [
    //             ""[-1, -2, -3]"",
    //             ""[-3, -1, -2]""
    //         ]
    //     }
    // ]
    // */

//","use vstd::prelude::*;

verus! {",,"fn swap(arr: &Vec<i32>, i: usize, j: usize) -> (result: Vec<i32>)
    requires
        i < arr.len(),
        j < arr.len(),
    ensures
        result.len() == arr.len(),
        result[i as int] == arr[j as int],
        result[j as int] == arr[i as int],
        forall|k: int| 0 <= k < arr.len() && k != i && k != j ==> result[k] == arr[k],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0176,verus,verina,verina_basic_96_task,,"This task requires swapping two integer values. Given two integers as input, the objective is to produce an output where their order is reversed: the first element of the output corresponds to the second input and the second element corresponds to the first input.

Input:
The input consists of two integers:
• X: An integer value.
• Y: Another integer value.

Output:
The output is a tuple (i32, i32) where:
• The first element is equal to Y.
• The second element is equal to X.

Note:
There are no additional preconditions for this task. The function simply returns a swapped tuple of its two input integers.

// Invalid Inputs

// []

// Tests

// [

//     {

//         ""input"": {

//             ""X"": 3,

//             ""Y"": 4

//         },

//         ""expected"": ""(4, 3)"",

//         ""unexpected"": [

//             ""(3, 4)"",

//             ""(3, 3)""

//         ]

//     },

//     {

//         ""input"": {

//             ""X"": -10,

//             ""Y"": 20

//         },

//         ""expected"": ""(20, -10)"",

//         ""unexpected"": [

//             ""(20, -20)"",

//             ""(-10, 20)""

//         ]

//     },

//     {

//         ""input"": {

//             ""X"": 0,

//             ""Y"": 0

//         },

//         ""expected"": ""(0, 0)"",

//         ""unexpected"": [

//             ""(0, 1)"",

//             ""(1, 0)""

//         ]

//     },

//     {

//         ""input"": {

//             ""X"": 123,

//             ""Y"": -456

//         },

//         ""expected"": ""(-456, 123)"",

//         ""unexpected"": [

//             ""(123, -456)"",

//             ""(-123, 456)""

//         ]

//     },

//     {

//         ""input"": {

//             ""X"": -1,

//             ""Y"": -2

//         },

//         ""expected"": ""(-2, -1)"",

//         ""unexpected"": [

//             ""(-1, -2)"",

//             ""(-2, 2)""

//         ]

//     }

// ]","use vstd::prelude::*;

verus! {",,"fn swap_simultaneous(x: i32, y: i32) -> (result: (i32, i32))
    ensures
        result.0 == y,
        result.1 == x,
        x != y ==> result.0 != x && result.1 != y,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0177,verus,verina,verina_basic_97_task,,"This task involves updating an array of integers such that the element at a specified index is set to 60 while all other elements remain unchanged.

-----Input-----
The input consists of:
• a: An array of integers.
• j: A natural number representing the index (0-indexed) to update. It is assumed that j is a valid index (j < a.size).

-----Output-----
The output is an array of integers where:
• The element at index j is set to 60.
• All other elements remain the same as in the input array.

-----Note-----
It is assumed that j is a valid index (0 ≤ j < a.size).

/*
    -- Invalid Inputs
    [
        {
            ""input"": {
                ""a"": ""#[1, 2, 3, 4]"",
                ""j"": 5
            }
        }
    ]
    -- Tests
    [
        {
            ""input"": {
                ""a"": ""#[1, 2, 3, 4, 5]"",
                ""j"": 2
            },
            ""expected"": ""#[1, 2, 60, 4, 5]"",
            ""unexpected"": [
                ""#[1, 2, 3, 4, 5]"",
                ""#[1, 60, 3, 4, 5]""
            ]
        },
        {
            ""input"": {
                ""a"": ""#[60, 30, 20]"",
                ""j"": 1
            },
            ""expected"": ""#[60, 60, 20]"",
            ""unexpected"": [
                ""#[60, 30, 20]"",
                ""#[60, 30, 60]""
            ]
        },
        {
            ""input"": {
                ""a"": ""#[10, 20, 30]"",
                ""j"": 0
            },
            ""expected"": ""#[60, 20, 30]"",
            ""unexpected"": [
                ""#[10, 20, 30]"",
                ""#[10, 60, 30]""
            ]
        },
        {
            ""input"": {
                ""a"": ""#[5, 10, 15]"",
                ""j"": 2
            },
            ""expected"": ""#[5, 10, 60]"",
            ""unexpected"": [
                ""#[5, 10, 15]"",
                ""#[5, 60, 15]""
            ]
        },
        {
            ""input"": {
                ""a"": ""#[0]"",
                ""j"": 0
            },
            ""expected"": ""#[60]"",
            ""unexpected"": [
                ""#[0]"",
                ""#[70]""
            ]
        }
    ]
    */","use vstd::prelude::*;

verus! {",,"fn test_array_elements(a: &Vec<i32>, j: usize) -> (result: Vec<i32>)
    requires j < a.len(),
    ensures
        result.len() == a.len(),
        result[j as int] == 60,
        forall|k: int| 0 <= k < a.len() && k != j ==> result[k] == a[k],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0178,verus,verina,verina_basic_98_task,,"This task involves computing three times a given integer. Given an integer, the goal is to produce a value that is exactly three times its value.

Input:
The input consists of a single integer:
x: An integer.

Output:
The output is an integer:
Returns the product of the input integer and 3.

Note:
There are no additional preconditions.","use vstd::prelude::*;

verus! {",,"fn triple(x: i32) -> (result: i32)
    ensures
        result / 3 == x,
        result / 3 * 3 == result,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0179,verus,verina,verina_basic_99_task,,"This task requires computing three times the given integer. The goal is to determine the product of the input integer and 3.

The input consists of:
• x: An integer.

The output is an integer that represents three times the input value.

The implementation uses two different branches based on the value of x (i.e., x < 18 or x ≥ 18), but both branches guarantee that the result equals 3*x.","use vstd::prelude::*;

verus! {",,"fn triple(x: i32) -> (result: i32)
    ensures
        result / 3 == x,
        result / 3 * 3 == result,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0180,verus,verina,verina_basic_100_task,,"This task involves determining the triple of a given integer. The goal is to create a function that, for any integer provided as input, returns a value equal to three times that integer, including handling the case when the input is zero.

-----Input-----
The input consists of:
• x: An integer.

-----Output-----
The output is an integer that represents three times the input integer.
• If x = 0, the output will be 0.
• Otherwise, the output will be computed as x + 2 * x, which is equivalent to 3 * x.

-----Note-----
There are no additional preconditions. It is assumed that x is a valid integer.

/*
    -- Invalid Inputs
    []
    -- Tests
    [
        {
            ""input"": {
                ""x"": 0
            },
            ""expected"": 0,
            ""unexpected"": [
                1,
                -1,
                10
            ]
        },
        {
            ""input"": {
                ""x"": 1
            },
            ""expected"": 3,
            ""unexpected"": [
                2,
                4,
                0
            ]
        },
        {
            ""input"": {
                ""x"": -2
            },
            ""expected"": -6,
            ""unexpected"": [
                -4,
                -2,
                6
            ]
        },
        {
            ""input"": {
                ""x"": 10
            },
            ""expected"": 30,
            ""unexpected"": [
                20,
                40,
                0
            ]
        },
        {
            ""input"": {
                ""x"": -5
            },
            ""expected"": -15,
            ""unexpected"": [
                -10,
                -5,
                15
            ]
        }
    ]
    */","use vstd::prelude::*;

verus! {",,"fn triple(x: i32) -> (result: i32)
    ensures
        result / 3 == x,
        result / 3 * 3 == result,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0181,verus,verina,verina_basic_101_task,,"This problem involves computing the triple of a given integer. The goal is to produce an output that is exactly three times the input value.

-----Input-----
The input consists of:
• x: An integer representing the value to be tripled.

-----Output-----
The output is an integer that is three times the input value (i.e., 3 * x).

-----Note-----
The implementation uses a local variable to first compute double the input and then adds the original input to get the final result. The accompanying theorem asserts that the function satisfies the specification of computing 3 * x.","use vstd::prelude::*;

verus! {",,"fn triple(x: i32) -> (result: i32)
    ensures
        result / 3 == x,
        result / 3 * 3 == result,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0182,verus,verina,verina_basic_102_task,,"This task involves identifying the first occurrence of a pair of indices in an array of integers such that the sum of the corresponding elements equals the given target value. The focus is on determining the earliest valid pair (i, j), with 0 ≤ i < j < nums.size, where the sum of the two numbers equals the target, without considering any language-specific or implementation details.

Input:
The input consists of:
• nums: An array of integers.
• target: An integer representing the desired sum.

Output:
The output is a pair of natural numbers (i, j) that satisfy:
• 0 ≤ i < j < nums.size.
• nums[i] + nums[j] = target.
• Any valid pair with indices preceding (i, j) does not yield the target sum, and no index between i and j forms a valid sum with nums[i].

Note:
It is assumed that the array has at least two elements and that there exists at least one valid pair whose sum is equal to the target.","use vstd::prelude::*;

verus! {",,"fn two_sum(nums: &Vec<i32>, target: i32) -> (result: (usize, usize))
    requires 
        nums.len() > 1,
        exists|i: int, j: int| 0 <= i < j < nums.len() && nums[i] + nums[j] == target,
    ensures
        result.0 < result.1,
        result.1 < nums.len(),
        nums[result.0 as int] + nums[result.1 as int] == target,
        forall|i: int, j: int| 0 <= i < j < nums.len() && i < result.0 as int ==> nums[i] + nums[j] != target,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0183,verus,verina,verina_basic_103_task,,"This problem involves updating an array of integers by modifying two specific positions. Specifically, the element at index 4 should be increased by 3, and the element at index 7 should be changed to 516. The goal is to correctly update these positions while leaving the rest of the array unchanged. The description assumes that the array contains at least 8 elements.

-----Input-----
The input consists of:
• a: An array of integers. The array must contain at least 8 elements.

-----Output-----
The output is an array of integers that meets the following criteria:
• The element at index 4 is updated to its original value plus 3.
• The element at index 7 is set to 516.
• All other elements in the array remain the same as in the input array.

-----Note-----
It is assumed that the input array has a size of at least 8 elements. Indices are 0-indexed.","use vstd::prelude::*;

verus! {",,"fn update_elements(a: &Vec<i32>) -> (result: Vec<i32>)
    requires a.len() >= 8,
    ensures
        result[4] == a[4] + 3,
        result[7] == 516,
        forall|i: int| 0 <= i < a.len() && i != 4 && i != 7 ==> result[i] == a[i],
        result.len() == a.len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0185,verus,verina,verina_basic_105_task,,"This task involves computing the element-wise product of two integer arrays. For each position in the arrays, the corresponding numbers are multiplied together. If an element is missing in one of the arrays at a given index, the missing value is treated as 0. When both arrays provide values for every index, the resulting array will contain the product of the two numbers at each corresponding index.

-----Input-----
The input consists of two arrays:
• a: An array of integers.
• b: An array of integers (should be of equal length to a for the specification to hold).

-----Output-----
The output is an array of integers that:
• Has the same length as the input arrays.
• For each index i, the output array contains the product a[i] * b[i].
• In cases where one of the arrays might be shorter, missing elements default to 0 during multiplication.

-----Note-----
It is assumed that the arrays are of equal length for the theorem specification, although the implementation defaults missing indices to 0.

/*
    -- Invalid Inputs
    [
        {
            ""input"": {
                ""a"": ""#[1, 2, 3]"",
                ""b"": ""#[4, 5]""
            }
        }
    ]
    -- Tests
    [
        {
            ""input"": {
                ""a"": ""#[1, 2, 3]"",
                ""b"": ""#[4, 5, 6]""
            },
            ""expected"": ""#[4, 10, 18]"",
            ""unexpected"": [
                ""#[4, 10, 17]"",
                ""#[0, 10, 18]"",
                ""#[4, 10, 20]""
            ]
        },
        {
            ""input"": {
                ""a"": ""#[0, 0, 0]"",
                ""b"": ""#[1, 2, 3]""
            },
            ""expected"": ""#[0, 0, 0]"",
            ""unexpected"": [
                ""#[1, 0, 0]"",
                ""#[0, 1, 0]"",
                ""#[0, 0, 1]""
            ]
        },
        {
            ""input"": {
                ""a"": ""#[-1, 2, -3]"",
                ""b"": ""#[3, -4, 5]""
            },
            ""expected"": ""#[-3, -8, -15]"",
            ""unexpected"": [
                ""#[-3, -8, -14]"",
                ""#[-3, -7, -15]"",
                ""#[-2, -8, -15]""
            ]
        },
        {
            ""input"": {
                ""a"": ""#[2]"",
                ""b"": ""#[10]""
            },
            ""expected"": ""#[20]"",
            ""unexpected"": [
                ""#[10]"",
                ""#[0]"",
                ""#[30]""
            ]
        },
        {
            ""input"": {
                ""a"": ""#[1, 2, 3, 4]"",
                ""b"": ""#[2, 2, 2, 2]""
            },
            ""expected"": ""#[2, 4, 6, 8]"",
            ""unexpected"": [
                ""#[2, 4, 6, 9]"",
                ""#[1, 4, 6, 8]"",
                ""#[2, 5, 6, 8]""
            ]
        }
    ]
    */","use vstd::prelude::*;

verus! {",,"fn array_product(a: &Vec<i32>, b: &Vec<i32>) -> (result: Vec<i32>)
    requires a.len() == b.len(),
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < a.len() ==> result[i] == a[i] * b[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0186,verus,verina,verina_basic_106_task,,"The task is to compute the element-wise sum of two integer arrays. The result should be a new array where each element is the sum of the corresponding elements from the two input arrays. The problem assumes that both arrays have the same length.

Input:
The input consists of two parameters:
• a: An array of integers.
• b: An array of integers.
Note: Both arrays must have the same length.

Output:
The output is an array of integers that:
• Has the same size as the input arrays.
• Contains elements where each element at index i is computed as a[i] + b[i] from the input arrays.

Note:
It is assumed that the two input arrays have equal lengths.

/*
    // -- Invalid Inputs
    // [
    //     {
    //         ""input"": {
    //             ""a"": ""#[1, 2, 3, 4]"",
    //             ""b"": ""#[5, 6, 7]""
    //         }
    //     }
    // ]
    // -- Tests
    // [
    //     {
    //         ""input"": {
    //             ""a"": ""#[1, 2, 3]"",
    //             ""b"": ""#[4, 5, 6]""
    //         },
    //         ""expected"": ""#[5, 7, 9]"",
    //         ""unexpected"": [
    //             ""#[5, 6, 9]"",
    //             ""#[4, 7, 9]""
    //         ]
    //     },
    //     {
    //         ""input"": {
    //             ""a"": ""#[0, 0, 0]"",
    //             ""b"": ""#[0, 0, 0]""
    //         },
    //         ""expected"": ""#[0, 0, 0]"",
    //         ""unexpected"": [
    //             ""#[0, 0, 1]"",
    //             ""#[1, 0, 0]""
    //         ]
    //     },
    //     {
    //         ""input"": {
    //             ""a"": ""#[-1, 2, 3]"",
    //             ""b"": ""#[1, -2, 4]""
    //         },
    //         ""expected"": ""#[0, 0, 7]"",
    //         ""unexpected"": [
    //             ""#[0, 1, 7]"",
    //             ""#[0, 0, 6]""
    //         ]
    //     },
    //     {
    //         ""input"": {
    //             ""a"": ""#[10]"",
    //             ""b"": ""#[-10]""
    //         },
    //         ""expected"": ""#[0]"",
    //         ""unexpected"": [
    //             ""#[1]"",
    //             ""#[-1]""
    //         ]
    //     },
    //     {
    //         ""input"": {
    //             ""a"": ""#[100, 200, 300]"",
    //             ""b"": ""#[100, 200, 300]""
    //         },
    //         ""expected"": ""#[200, 400, 600]"",
    //         ""unexpected"": [
    //             ""#[200, 400, 601]"",
    //             ""#[199, 400, 600]"",
    //             ""#[200, 399, 600]""
    //         ]
    //     }
    // ]
    // */

//","use vstd::prelude::*;

verus! {",,"fn array_sum(a: &Vec<i32>, b: &Vec<i32>) -> (result: Vec<i32>)
    requires a.len() == b.len(),
    ensures
        result.len() == a.len(),
        forall|i: int| 0 <= i < a.len() ==> result[i] == a[i] + b[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
VV0188,verus,verina,verina_basic_108_task,,"The problem is about processing a sequence of integer operations to determine cumulative results and identify potential negative outcomes. Given a list of integers, the task is to generate an array where the first element is 0 and each subsequent element is the cumulative sum of the operations performed sequentially. Additionally, the solution should check whether any of these cumulative values (after the initial 0) is negative, and return a corresponding boolean flag.

Input:
The input consists of:
• operations: A list of integers representing sequential operations.

Output:
The output is a tuple consisting of:
• An array of integers representing the partial sums. The array's size is one more than the number of operations, starting with 0 and where for each index i such that 0 ≤ i < operations.length, the element at index i+1 is equal to the element at index i added to operations[i].
• A boolean value that is true if there exists an index i (with 1 ≤ i ≤ operations.length) such that the i-th partial sum is negative, and false otherwise.

Note:
The function should also correctly handle an empty list of operations.","use vstd::prelude::*;

verus! {",,"fn below_zero(operations: &Vec<i32>) -> (result: (Vec<i32>, bool))
    ensures
        result.0.len() == operations.len() + 1,
        result.0[0] == 0,
        forall|i: int| 0 <= i < operations.len() ==> result.0[i + 1] == result.0[i] + operations[i],
        result.1 == (exists|i: int| 1 <= i < result.0.len() && result.0[i] < 0),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,1.0
