id,language,source,source-id,source-notes,vc-description,vc-preamble,vc-helpers,vc-spec,vc-code,vc-postamble,qa-issue,qa-issue-type,qa-specs-with-default-values,qa-execs-with-bodies,qa-execs-with-ghost-types,qa-near-duplicate-group,qa-score
VA0001,verus,apps,apps_test_5,,"Given n browser tabs indexed 1 to n with cursor at position pos, find minimum time to close
all tabs except those in range [l, r]. Operations: move cursor (1 sec), close all tabs to
left of cursor (1 sec), close all tabs to right of cursor (1 sec).","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, pos: int, l: int, r: int) -> bool {
    1 <= n <= 100 && 1 <= pos <= n && 1 <= l <= r <= n
}

spec fn no_tabs_to_close(l: int, r: int, n: int) -> bool {
    l == 1 && r == n
}

spec fn only_close_right(l: int, r: int, n: int) -> bool {
    l == 1 && r < n
}

spec fn only_close_left(l: int, r: int, n: int) -> bool {
    l > 1 && r == n
}

spec fn close_both_sides(l: int, r: int, n: int) -> bool {
    l > 1 && r < n
}",,"fn solve(n: i8, pos: i8, l: i8, r: i8) -> (result: i8)
    requires 
        valid_input(n as int, pos as int, l as int, r as int)
    ensures 
        result as int >= 0,
        no_tabs_to_close(l as int, r as int, n as int) ==> result as int == 0,
        only_close_right(l as int, r as int, n as int) ==> result as int == if pos as int >= r as int { pos as int - r as int } else { r as int - pos as int } + 1,
        only_close_left(l as int, r as int, n as int) ==> result as int == if pos as int >= l as int { pos as int - l as int } else { l as int - pos as int } + 1,
        close_both_sides(l as int, r as int, n as int) && l as int <= pos as int && pos as int <= r as int && (pos as int - l as int) < (r as int - pos as int) ==> result as int == (pos as int - l as int) + 1 + (r as int - l as int) + 1,
        close_both_sides(l as int, r as int, n as int) && l as int <= pos as int && pos as int <= r as int && (pos as int - l as int) >= (r as int - pos as int) ==> result as int == (r as int - pos as int) + 1 + (r as int - l as int) + 1,
        close_both_sides(l as int, r as int, n as int) && pos as int > r as int ==> result as int == (pos as int - r as int) + 1 + (r as int - l as int) + 1,
        close_both_sides(l as int, r as int, n as int) && pos as int < l as int ==> result as int == (l as int - pos as int) + 1 + (r as int - l as int) + 1,
        result as int <= 2 * n as int","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0006,verus,apps,apps_test_29,,"Given a 6-digit ticket (string of digits 0-9), find the minimum number of digit replacements needed to make it ""lucky"".
A ticket is lucky when the sum of its first three digits equals the sum of its last three digits.
Any digit can be replaced with any digit 0-9.","use vstd::prelude::*;

verus! {
spec fn char_to_int(c: char) -> int {
    c as int - '0' as int
}

spec fn is_lucky(digits: Seq<int>) -> bool {
    digits.len() == 6 ==> {
        let sum1 = digits[0] + digits[1] + digits[2];
        let sum2 = digits[3] + digits[4] + digits[5];
        sum1 == sum2
    }
}

spec fn valid_ticket(ticket: Seq<char>) -> bool {
    ticket.len() == 6 && forall|i: int| 0 <= i < ticket.len() ==> '0' <= ticket[i] <= '9'
}

spec fn can_make_lucky_with_0_changes(digits: Seq<int>) -> bool {
    digits.len() == 6 && (forall|i: int| 0 <= i < digits.len() ==> 0 <= digits[i] <= 9) ==> is_lucky(digits)
}

spec fn can_make_lucky_with_1_change(digits: Seq<int>) -> bool {
    digits.len() == 6 && (forall|i: int| 0 <= i < digits.len() ==> 0 <= digits[i] <= 9) ==> {
        exists|pos: int| 0 <= pos < 6 &&
            exists|new_digit: int| 0 <= new_digit <= 9 && {
                let new_digits = digits.subrange(0, pos).add(seq![new_digit]).add(digits.subrange(pos + 1, digits.len() as int));
                is_lucky(new_digits)
            }
    }
}

spec fn can_make_lucky_with_2_changes(digits: Seq<int>) -> bool {
    digits.len() == 6 && (forall|i: int| 0 <= i < digits.len() ==> 0 <= digits[i] <= 9) ==> {
        exists|i: int, j: int| 0 <= j < i < 6 &&
            exists|k: int, l: int| 0 <= k <= 9 && 0 <= l <= 9 && {
                let new_digits = digits.subrange(0, i).add(seq![k]).add(digits.subrange(i + 1, digits.len() as int));
                let final_digits = new_digits.subrange(0, j).add(seq![l]).add(new_digits.subrange(j + 1, new_digits.len() as int));
                is_lucky(final_digits)
            }
    }
}",,"fn solve(ticket: &Vec<char>) -> (result: u32)
    requires valid_ticket(ticket@)
    ensures 0 <= result <= 3","{
    // impl-start
    assume(false);
    0
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0015,verus,apps,apps_test_72,,"Three players each have a ribbon (string). The beauty of a ribbon is the maximum frequency of any character.
In n turns, each player must change exactly one character. After n turns, the player with highest beauty wins.
Find the winner assuming optimal play, or ""Draw"" if tied.","use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0
}

spec fn valid_output(result: Seq<char>) -> bool {
    result =~= seq!['K','u','r','o'] || result =~= seq!['S','h','i','r','o'] || result =~= seq!['K','a','t','i','e'] || result =~= seq!['D','r','a','w'] || result.len() == 0
}

spec fn optimal_score(ribbon: Seq<char>, turns: int) -> int 
    recommends ribbon.len() >= 0 && turns >= 0
{
    let max_freq = max_char_freq(ribbon);
    let length = ribbon.len() as int;
    if turns == 1 && max_freq == length {
        if max_freq > 0 { max_freq - 1 } else { 0 }
    } else if length < max_freq + turns {
        length
    } else {
        max_freq + turns
    }
}
spec fn max_char_freq(s: Seq<char>) -> int {
    0
}

spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {
    seq![]
}

spec fn parse_int(s: Seq<char>) -> int {
    0
}

spec fn max3(a: int, b: int, c: int) -> int {
    if a >= b && a >= c { a } else if b >= c { b } else { c }
}",,"fn solve(input: Seq<char>) -> (result: Seq<char>)
    requires valid_input(input)
    ensures valid_output(result)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0019,verus,apps,apps_test_93,,"Given two 2x2 sliding puzzles with tiles A, B, C and empty cell X,
determine if there exists a sequence of moves that can make both puzzles
reach the same configuration. A move slides a tile adjacent to the empty
cell into the empty cell.","use vstd::prelude::*;

verus! {
spec fn count_newlines(s: Seq<char>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0int
    } else {
        (if s[0] == '\n' { 1int } else { 0int }) + count_newlines(s.subrange(1, s.len() as int))
    }
}

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 && input.contains('\n') && count_newlines(input) >= 3
}

spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {
    /* Implementation details for splitting lines */
    seq![seq![]]
}

spec fn reverse_seq(s: Seq<char>) -> Seq<char> {
    s.reverse()
}

spec fn remove_first_x(s: Seq<char>) -> Seq<char> {
    /* Implementation details for removing first X */
    s
}

spec fn extract_and_normalize_puzzle1(input: Seq<char>) -> Seq<char> {
    if valid_input(input) {
        let lines = split_lines(input);
        if lines.len() >= 2 {
            let line1 = lines[0];
            let line2 = reverse_seq(lines[1]);
            let combined = line1.add(line2);
            remove_first_x(combined)
        } else {
            seq![]
        }
    } else {
        seq![]
    }
}

spec fn extract_and_normalize_puzzle2(input: Seq<char>) -> Seq<char> {
    if valid_input(input) {
        let lines = split_lines(input);
        if lines.len() >= 4 {
            let line3 = lines[2];
            let line4 = reverse_seq(lines[3]);
            let combined = line3.add(line4);
            remove_first_x(combined)
        } else {
            seq![]
        }
    } else {
        seq![]
    }
}

spec fn rotate_puzzle_left(puzzle: Seq<char>, rotation: int) -> Seq<char> {
    /* Implementation details for rotating puzzle */
    puzzle
}

spec fn can_reach_same_config(input: Seq<char>) -> bool {
    if valid_input(input) {
        exists|rotation: int| 0 <= rotation < 4 && 
            extract_and_normalize_puzzle1(input) == rotate_puzzle_left(extract_and_normalize_puzzle2(input), rotation)
    } else {
        false
    }
}",,"fn solve(input: &str) -> (result: String)
    ensures can_reach_same_config(input@) ==> result@ == seq!['Y', 'E', 'S']
    ensures !can_reach_same_config(input@) ==> result@ == seq!['N', 'O']","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0020,verus,apps,apps_test_95,,"Given an array of integers, determine if it is unimodal.
An array is unimodal if it follows this exact pattern:
1. An optional strictly increasing sequence at the beginning
2. An optional constant sequence in the middle  
3. An optional strictly decreasing sequence at the end
All three parts are optional, but if present, they must appear in this exact order.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: nat, arr: Seq<int>) -> bool {
    n > 0 && arr.len() == n && forall|i: int| 0 <= i < arr.len() ==> arr[i] >= 1
}

spec fn is_unimodal(arr: Seq<int>) -> bool {
    if arr.len() <= 1 { 
        true 
    } else {
        let phases = compute_phases(arr);
        phases.0 <= phases.1 && phases.1 <= phases.2 && phases.2 == arr.len() &&
        (forall|i: int, j: int| 0 <= i < j < phases.0 ==> #[trigger] arr[i] < #[trigger] arr[j]) &&
        (forall|i: int| phases.0 <= i < phases.1 ==> #[trigger] arr[i] == (if phases.0 > 0 { arr[phases.0] } else { arr[0] })) &&
        (forall|i: int, j: int| phases.1 <= i < j < phases.2 ==> #[trigger] arr[i] > #[trigger] arr[j]) &&
        (phases.0 > 0 && phases.1 < arr.len() ==> arr[phases.0-1] >= (if phases.1 > phases.0 { arr[phases.0] } else { arr[phases.1] }))
    }
}

spec fn compute_phases(arr: Seq<int>) -> (int, int, int) {
    let inc_end = compute_increasing_end(arr, 0, 0);
    let const_end = compute_constant_end(arr, inc_end, if inc_end > 0 { arr[inc_end-1] } else { 0 });
    let dec_end = compute_decreasing_end(arr, const_end, if const_end > inc_end { arr[inc_end] } else if inc_end > 0 { arr[inc_end-1] } else { 0 });
    (inc_end, const_end, dec_end)
}

spec fn compute_increasing_end(arr: Seq<int>, start: int, prev: int) -> int {
    0
}

spec fn compute_constant_end(arr: Seq<int>, start: int, value: int) -> int {
    start
}

spec fn compute_decreasing_end(arr: Seq<int>, start: int, prev: int) -> int {
    arr.len() as int
}",,"fn solve(n: nat, arr: Seq<int>) -> (result: String)
    requires 
        valid_input(n, arr),
    ensures 
        result@ == ""YES""@ || result@ == ""NO""@,
        result@ == ""YES""@ <==> is_unimodal(arr),","{
    assume(false);
    ""NO"".to_string()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0021,verus,apps,apps_test_98,,"Given a rectangular board and two rectangular paintings, determine if both paintings 
can be placed on the board without overlapping or extending beyond edges. Each rectangle 
can be rotated 90 degrees.","use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    let lines = split_lines_func(input);
    lines.len() >= 3 &&
    {
        let board_parts = split_spaces_func(lines[0]);
        let paint1_parts = split_spaces_func(lines[1]);
        let paint2_parts = split_spaces_func(lines[2]);
        board_parts.len() >= 2 && paint1_parts.len() >= 2 && paint2_parts.len() >= 2 &&
        is_valid_int(board_parts[0]) && is_valid_int(board_parts[1]) &&
        is_valid_int(paint1_parts[0]) && is_valid_int(paint1_parts[1]) &&
        is_valid_int(paint2_parts[0]) && is_valid_int(paint2_parts[1])
    }
}

spec fn can_place_both_paintings(a: int, b: int, c: int, d: int, e: int, f: int) -> bool {
    (c+e <= a && max(d,f) <= b) ||
    (c+e <= b && max(d,f) <= a) ||
    (c+f <= a && max(d,e) <= b) ||
    (c+f <= b && max(d,e) <= a) ||
    (d+e <= a && max(c,f) <= b) ||
    (d+e <= b && max(c,f) <= a) ||
    (d+f <= a && max(c,e) <= b) ||
    (d+f <= b && max(c,e) <= a)
}

spec fn max(x: int, y: int) -> int {
    if x >= y { x } else { y }
}

spec fn is_valid_int(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> ('0' <= s[i] && s[i] <= '9')
}

spec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>> {
    seq![seq!['a']; 3]
}

spec fn split_spaces_func(s: Seq<char>) -> Seq<Seq<char>> {
    seq![seq!['1']; 2]
}

spec fn parse_int_func(s: Seq<char>) -> int {
    1
}",,"fn solve(input: Seq<char>) -> (result: Vec<char>)
    requires input.len() > 0","{
    // impl-start
    assume(false);
    Vec::new()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0025,verus,apps,apps_test_114,,"Given an n×m matrix A containing only 0s and 1s, and matrix B initially all zeros.
You can perform operations on B: choose integers x, y where 1 ≤ x < n and 1 ≤ y < m,
then set B[x,y], B[x,y+1], B[x+1,y], and B[x+1,y+1] to 1.
Determine if B can be made equal to A, and if so, provide a sequence of operations.","use vstd::prelude::*;

verus! {

spec fn valid_input_format(input: Seq<char>) -> bool {
    input.len() > 0 && input[input.len() - 1] == '\n' &&
    exists|lines: Seq<Seq<char>>| {
        &&& lines == split_lines(input)
        &&& lines.len() >= 3
        &&& valid_dimension_line(lines[0])
        &&& {
            let parsed = parse_dimensions(lines[0]);
            let (n, m) = (parsed.0, parsed.1);
            &&& lines.len() == n + 1 && 2 <= n <= 50 && 2 <= m <= 50
            &&& forall|i: int| 1 <= i <= n ==> valid_matrix_row(lines[i], m)
            &&& forall|i: int, j: int| 1 <= i <= n && 1 <= j <= m ==> 
                parse_matrix_element(lines[i], j) == 0 || parse_matrix_element(lines[i], j) == 1
        }
    }
}

spec fn valid_operation_sequence(output: Seq<char>, original_input: Seq<char>) -> bool {
    output.len() > 0 && output[output.len() - 1] == '\n' &&
    exists|lines: Seq<Seq<char>>| {
        &&& lines == split_lines(output)
        &&& lines.len() >= 1
        &&& valid_number(lines[0])
        &&& {
            let k = parse_number(lines[0]);
            &&& 0 <= k <= 2500
            &&& lines.len() == k + 1
            &&& {
                let parsed = parse_input(original_input);
                let (n, m) = (parsed.0, parsed.1);
                forall|i: int| 1 <= i <= k ==> valid_coordinate_pair(lines[i], n-1, m-1)
            }
        }
    }
}

spec fn valid_dimension_line(line: Seq<char>) -> bool { line.len() > 0 }
spec fn valid_matrix_row(line: Seq<char>, m: int) -> bool { line.len() > 0 && m > 0 }
spec fn valid_number(s: Seq<char>) -> bool { s.len() > 0 }
spec fn valid_coordinate_pair(s: Seq<char>, max_x: int, max_y: int) -> bool { 
    s.len() > 0 && max_x > 0 && max_y > 0 
}

spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> { seq![s] }
spec fn parse_dimensions(line: Seq<char>) -> (int, int) { (2, 2) }
spec fn parse_number(s: Seq<char>) -> int { 0 }
spec fn parse_input(input: Seq<char>) -> (int, int, Seq<Seq<int>>) { 
    (2, 2, seq![seq![0, 0], seq![0, 0]]) 
}
spec fn parse_operations(output: Seq<char>) -> Seq<(int, int)> { seq![] }
spec fn parse_matrix_element(line: Seq<char>, pos: int) -> int { 0 }
spec fn to_string(n: int) -> Seq<char> { seq!['0'] }

spec fn apply_greedy_algorithm(n: int, m: int, a: Seq<Seq<int>>) -> (Seq<Seq<int>>, Seq<(int, int)>) {
    let b = Seq::new(n as nat, |i: int| Seq::new(m as nat, |j: int| 0));
    let ops = seq![];
    greedy_step(a, b, ops, 0, 0, n, m)
}

spec fn greedy_step(a: Seq<Seq<int>>, b: Seq<Seq<int>>, ops: Seq<(int, int)>, 
                   start_i: int, start_j: int, n: int, m: int) -> (Seq<Seq<int>>, Seq<(int, int)>) {
    (b, ops)
}",,"fn solve(stdin_input: &str) -> (result: String)
    requires 
        stdin_input@.len() > 0,
        valid_input_format(stdin_input@),
    ensures 
        result@.len() > 0,
        result@ == ""-1\n""@ || valid_operation_sequence(result@, stdin_input@),
        result@ != ""-1\n""@ ==> {
            let parsed = parse_input(stdin_input@);
            let (n, m, a) = (parsed.0, parsed.1, parsed.2);
            let ops = parse_operations(result@);
            let algorithm_result = apply_greedy_algorithm(n, m, a);
            let (b, expected_ops) = (algorithm_result.0, algorithm_result.1);
            b == a && ops == expected_ops
        },
        result@ == ""-1\n""@ ==> {
            let parsed = parse_input(stdin_input@);
            let (n, m, a) = (parsed.0, parsed.1, parsed.2);
            let algorithm_result = apply_greedy_algorithm(n, m, a);
            let b = algorithm_result.0;
            b != a
        },
        result@ == ""-1\n""@ || exists|k: nat, lines: Seq<Seq<char>>| {
            &&& lines == split_lines(result@)
            &&& lines.len() == k + 1
            &&& lines[0] == to_string(k as int)
            &&& k <= 2500
            &&& {
                let parsed = parse_input(stdin_input@);
                let (n, m) = (parsed.0, parsed.1);
                forall|i: int| #[trigger] lines[i].len() > 0 && 1 <= i <= k ==> {
                    &&& 1 <= n-1 && 1 <= m-1
                    &&& lines[i] == seq!['d', 'u', 'm', 'm', 'y']
                }
            }
        },","{
    // impl-start
    assume(false);
    ""-1\n"".to_string()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0030,verus,apps,apps_test_131,,"Given two configurations of n stone piles, determine if the first configuration
can be transformed into the second using operations: remove one stone from any pile,
or move one stone from one pile to another pile.","use vstd::prelude::*;

verus! {

spec fn is_valid_input(input: &str) -> bool {
    let lines = split_lines(input);
    lines.len() >= 3 && 
    parse_int(lines[0]) > 0 &&
    parse_int_array(lines[1]).len() == parse_int(lines[0]) &&
    parse_int_array(lines[2]).len() == parse_int(lines[0])
}

spec fn get_initial_sum(input: &str) -> int
    recommends is_valid_input(input)
{
    let lines = split_lines(input);
    sum_seq(parse_int_array(lines[1]))
}

spec fn get_target_sum(input: &str) -> int
    recommends is_valid_input(input)
{
    let lines = split_lines(input);
    sum_seq(parse_int_array(lines[2]))
}

spec fn sum_seq(nums: Seq<int>) -> int
    decreases nums.len()
{
    if nums.len() == 0 {
        0
    } else {
        nums[0] + sum_seq(nums.subrange(1, nums.len() as int))
    }
}

uninterp spec fn split_lines(input: &str) -> Seq<&str>;
uninterp spec fn parse_int(s: &str) -> int;
uninterp spec fn parse_int_array(s: &str) -> Seq<int>;",,"fn solve(input: &str) -> (result: String)
    requires is_valid_input(input)
    ensures (result == ""Yes"") <==> get_initial_sum(input) >= get_target_sum(input)","{
    assume(false);
    ""No"".to_string()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0032,verus,apps,apps_test_144,,"Given a sequence of n digits, determine if it can be divided into two or more 
non-overlapping contiguous segments such that all segments have equal digit sums.
Each digit must belong to exactly one segment.","use vstd::prelude::*;

verus! {

spec fn can_partition_into_equal_sum_segments(input: Seq<char>) -> bool {
    if input.len() == 0 {
        false
    } else {
        let lines = split_lines(input);
        if lines.len() < 2 {
            false
        } else {
            let n_str = trim(lines[0]);
            let digits_str = trim(lines[1]);
            let n = parse_int(n_str);
            if n < 2 || n > 100 || digits_str.len() != n {
                false
            } else {
                let digits = parse_digits(digits_str);
                if digits.len() != n {
                    false
                } else {
                    exists|i: int| 0 <= i < n - 1 && {
                        let first_sum = sum(digits.subrange(0, i + 1));
                        first_sum >= 0 &&
                        can_partition_remainder(digits, i + 1, first_sum)
                    }
                }
            }
        }
    }
}

spec fn can_partition_remainder(digits: Seq<int>, start: int, target_sum: int) -> bool 
    decreases digits.len() - start
{
    if start < 0 || start > digits.len() || target_sum < 0 {
        false
    } else if start >= digits.len() {
        true
    } else {
        exists|segment_end: int| start < segment_end <= digits.len() && 
            sum(digits.subrange(start, segment_end)) == target_sum &&
            can_partition_remainder(digits, segment_end, target_sum)
    }
}

spec fn sum(s: Seq<int>) -> int {
    if s.len() == 0 {
        0
    } else {
        s[0] + sum(s.skip(1))
    }
}

spec fn parse_int(s: Seq<char>) -> int {
    if s.len() == 0 {
        0
    } else if s.len() == 1 {
        char_to_digit(s[0])
    } else {
        char_to_digit(s[0]) * power10(s.len() - 1) + parse_int(s.skip(1))
    }
}

spec fn char_to_digit(c: char) -> int {
    if '0' <= c && c <= '9' {
        (c as int) - ('0' as int)
    } else {
        0
    }
}

spec fn power10(n: int) -> int {
    if n <= 0 {
        1
    } else {
        10 * power10(n - 1)
    }
}

spec fn parse_digits(s: Seq<char>) -> Seq<int> {
    if s.len() == 0 {
        seq![]
    } else {
        seq![char_to_digit(s[0])] + parse_digits(s.skip(1))
    }
}

spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {
    split_by_char(s, '\n')
}

spec fn split_by_char(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> {
    if s.len() == 0 {
        seq![seq![]]
    } else if s[0] == delimiter {
        seq![seq![]] + split_by_char(s.skip(1), delimiter)
    } else {
        let rest = split_by_char(s.skip(1), delimiter);
        if rest.len() == 0 {
            seq![s.subrange(0, 1)]
        } else {
            seq![s.subrange(0, 1) + rest[0]] + rest.skip(1)
        }
    }
}

spec fn trim(s: Seq<char>) -> Seq<char> {
    trim_left(trim_right(s))
}

spec fn trim_left(s: Seq<char>) -> Seq<char> {
    if s.len() == 0 {
        s
    } else if s[0] == ' ' || s[0] == '\t' || s[0] == '\n' || s[0] == '\r' {
        trim_left(s.skip(1))
    } else {
        s
    }
}

spec fn trim_right(s: Seq<char>) -> Seq<char> {
    if s.len() == 0 {
        s
    } else if s[s.len() - 1] == ' ' || s[s.len() - 1] == '\t' || s[s.len() - 1] == '\n' || s[s.len() - 1] == '\r' {
        trim_right(s.subrange(0, s.len() - 1))
    } else {
        s
    }
}",,"fn solve(s: Seq<char>) -> (result: Seq<char>)
    requires s.len() > 0","{
    /* impl-start */
    assume(false);
    Seq::new(3 as nat, |i: nat| match i {
        0 => 'N',
        1 => 'O',
        2 => '\n',
        _ => 'N'
    })
    /* impl-end */
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0035,verus,apps,apps_test_155,,"Given an n×m matrix where n is even, determine Lara's position after exactly k moves
following a specific path: start at (1,1), move down column 1 to (n,1), then move in
a snake pattern through remaining columns alternating between moving right-up-left-up
until reaching (1,2). Find coordinates after exactly k moves.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, m: int, k: int) -> bool {
    n >= 2 && m >= 2 && n % 2 == 0 && k >= 0 && k < n * m
}

spec fn valid_output(result: &Vec<int>, n: int, m: int) -> bool {
    result.len() == 2 && result[0] >= 1 && result[0] <= n && result[1] >= 1 && result[1] <= m
}

spec fn correct_position(result: &Vec<int>, n: int, m: int, k: int) -> bool
    recommends valid_input(n, m, k) && result.len() == 2
{
    if k < n {
        result[0] == k + 1 && result[1] == 1
    } else {
        let k_remaining = k - n;
        let r = n - k_remaining / (m - 1);
        result[0] == r &&
        (r % 2 == 1 ==> result[1] == m - k_remaining % (m - 1)) &&
        (r % 2 == 0 ==> result[1] == 2 + k_remaining % (m - 1))
    }
}",,"fn solve(n: i8, m: i8, k: i8) -> (result: Vec<i8>)
    requires
        valid_input(n as int, m as int, k as int)
    ensures
        result.len() == 2,
        {
            let spec_result: Vec<int> = result@.map(|i, x: i8| x as int);
            valid_output(&spec_result, n as int, m as int) && correct_position(&spec_result, n as int, m as int, k as int)
        }","{
    // impl-start
    assume(false);
    Vec::new()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0037,verus,apps,apps_test_162,,"Find the minimum number of hours to water a garden of length k using exactly one type of bucket.
Each bucket type i can water a continuous segment of length a_i per hour.
Must choose a bucket size that evenly divides the garden length to avoid gaps or overlaps.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, k: int, a: Seq<int>) -> bool {
    n >= 1 && k >= 1 && a.len() == n &&
    (forall|i: int| 0 <= i < a.len() ==> a[i] >= 1) &&
    (exists|i: int| 0 <= i < a.len() && k % a[i] == 0)
}

spec fn valid_bucket(k: int, bucket_size: int) -> bool {
    bucket_size >= 1 && k % bucket_size == 0
}

spec fn hours_needed(k: int, bucket_size: int) -> int
    recommends valid_bucket(k, bucket_size)
{
    k / bucket_size
}

spec fn is_optimal_choice(k: int, a: Seq<int>, chosen_bucket: int) -> bool {
    0 <= chosen_bucket < a.len() &&
    valid_bucket(k, a[chosen_bucket]) &&
    (forall|i: int| 0 <= i < a.len() && valid_bucket(k, a[i]) ==> a[i] <= a[chosen_bucket])
}",,"fn solve(n: i8, k: i8, a: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, k as int, a@.map(|i, x| x as int)),
    ensures 
        result >= 1,
        #[trigger] exists|i: int| is_optimal_choice(k as int, a@.map(|i, x| x as int), i) && result as int == hours_needed(k as int, a@.map(|i, x| x as int)[i]),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0038,verus,apps,apps_test_163,,"Given a line of n cells and a grasshopper that can jump exactly k cells at a time,
determine if the grasshopper can reach a target cell. The line contains exactly one
grasshopper ('G'), one target ('T'), empty cells ('.'), and obstacles ('#').
The grasshopper can only land on empty cells or the target.","use vstd::prelude::*;

verus! {","spec fn valid_input(n: int, k: int, s: Seq<char>) -> bool {
    n >= 2 &&
    1 <= k < n &&
    s.len() == n &&
    (exists|i: int| 0 <= i < s.len() && s[i] == 'G') &&
    (exists|i: int| 0 <= i < s.len() && s[i] == 'T') &&
    (forall|i: int| 0 <= i < s.len() ==> (s[i] == 'G' || s[i] == 'T' || s[i] == '.' || s[i] == '#')) &&
    (forall|i: int, j: int| 0 <= i < j < s.len() && s[i] == 'G' ==> s[j] != 'G') &&
    (forall|i: int, j: int| 0 <= i < j < s.len() && s[i] == 'T' ==> s[j] != 'T')
}

spec fn find_first_g_or_t(s: Seq<char>) -> int
    recommends exists|i: int| 0 <= i < s.len() && (s[i] == 'G' || s[i] == 'T')
    decreases s.len()
{
    if s.len() > 0 && (s[0] == 'G' || s[0] == 'T') {
        0
    } else if s.len() > 1 {
        find_first_g_or_t(s.subrange(1, s.len() as int)) + 1
    } else {
        0
    }
}

spec fn can_reach_target(s: Seq<char>, k: int) -> bool
    recommends k > 0
{
    exists|start: int| 
        0 <= start < s.len() && 
        (s[start] == 'G' || s[start] == 'T') &&
        (forall|j: int| 0 <= j < start ==> !(s[j] == 'G' || s[j] == 'T')) &&
        (exists|final_pos: int| 
            start < final_pos < s.len() &&
            (s[final_pos] == 'G' || s[final_pos] == 'T') &&
            (final_pos - start) % k == 0 &&
            (forall|pos: int| start < pos < final_pos && (pos - start) % k == 0 ==> !(s[pos] == 'G' || s[pos] == 'T' || s[pos] == '#'))
        )
}","fn solve(n: int, k: int, s: Seq<char>) -> (result: Seq<char>)
    requires valid_input(n, k, s)
    ensures 
        result == seq!['Y', 'E', 'S'] || result == seq!['N', 'O'],
        (result == seq!['Y', 'E', 'S']) <==> can_reach_target(s, k)","{
    assume(false);
    seq!['N', 'O']
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0044,verus,apps,apps_test_178,,"Given a string of n digits where n is odd and n >= 13, two players (Vasya first, then Petya) 
take turns removing one character at a time until exactly 11 characters remain. 
Vasya wins if the final 11-character string starts with digit 8, otherwise Petya wins.
Determine if Vasya has a winning strategy.","use vstd::prelude::*;

verus! {","spec fn valid_input(n: int, s: Seq<char>) -> bool {
    n >= 13 && n % 2 == 1 && s.len() == n
}

spec fn count_eights_in_prefix(s: Seq<char>, len: int) -> int
    decreases len
{
    if len == 0 {
        0
    } else {
        (if s[len-1] == '8' { 1 } else { 0 }) + count_eights_in_prefix(s, len-1)
    }
}

spec fn vasya_wins(n: int, s: Seq<char>) -> bool {
    let petya_moves = (n - 11) / 2;
    let prefix_len = n - 10;
    let eights_in_prefix = count_eights_in_prefix(s, prefix_len);
    petya_moves < eights_in_prefix
}","fn solve(n: int, s: Seq<char>) -> (result: String)
    requires valid_input(n, s)
    ensures result == ""NO"" || result == ""YES""
    ensures result == if vasya_wins(n, s) { ""YES"".to_string() } else { ""NO"".to_string() }","{
    // impl-start
    assume(false);
    """".to_string()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0061,verus,apps,apps_test_232,,"Given an array of n integers representing lightsaber colors (each integer is between 1 and m),
determine if there exists a contiguous subarray where each color i appears exactly k_i times.","use vstd::prelude::*;

verus! {
spec fn count_occurrences(s: Seq<nat>, value: nat) -> nat
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if s[0] == value {
        1 + count_occurrences(s.subrange(1, s.len() as int), value)
    } else {
        count_occurrences(s.subrange(1, s.len() as int), value)
    }
}

spec fn sum_seq(s: Seq<nat>) -> nat
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else {
        s[0] + sum_seq(s.subrange(1, s.len() as int))
    }
}

spec fn subarray_matches_desired(subarray: Seq<nat>, desired: Seq<nat>, m: nat) -> bool
{
    desired.len() == m &&
    forall|color: nat| #[trigger] count_occurrences(subarray, color) == desired[color as int - 1] && 1 <= color <= m
}

spec fn valid_input(n: nat, m: nat, colors: Seq<nat>, desired: Seq<nat>) -> bool
{
    colors.len() == n &&
    desired.len() == m &&
    (forall|i: int| #[trigger] colors[i] >= 1 && colors[i] <= m && 0 <= i < colors.len()) &&
    (forall|i: int| #[trigger] desired[i] >= 0 && 0 <= i < desired.len()) &&
    sum_seq(desired) <= n
}",,"fn solve(n: u8, m: u8, colors: Vec<u8>, desired: Vec<u8>) -> (result: String)
    requires
        valid_input(n as nat, m as nat, colors@.map(|i, x| x as nat), desired@.map(|i, x| x as nat)),
    ensures
        result@ == seq!['Y' as char, 'E' as char, 'S' as char] <==> exists|i: int, j: int| 0 <= i <= j < n as int && #[trigger] subarray_matches_desired(colors@.map(|k, x| x as nat).subrange(i, j + 1), desired@.map(|k, x| x as nat), m as nat),
        result@ == seq!['Y' as char, 'E' as char, 'S' as char] || result@ == seq!['N' as char, 'O' as char],","{
    assume(false);
    ""NO"".to_string()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0066,verus,apps,apps_test_256,,"Game theory problem: Two teams of 2 players each compete. Each player has defense and attack skills.
Team 1 chooses their defense/attack assignment first, then Team 2 responds optimally.
A team wins if their defense > opponent's attack AND their attack > opponent's defense.
Determine which team can guarantee a win with optimal play, or if neither can.

/* player 1 defense */

/* player 1 attack */

/* player 2 defense */

/* player 2 attack */

/* player 3 defense */

/* player 3 attack */

/* player 4 defense */

/* player 4 attack */","use vstd::prelude::*;

verus! {

#[verifier::external_body]
spec fn split_lines(input: &str) -> Seq<&str> {
    Seq::empty()
}

#[verifier::external_body]
spec fn split_by_char(line: &str, c: char) -> Seq<&str> {
    Seq::empty()
}

#[verifier::external_body]
spec fn char_at(s: &str, i: int) -> char {
    ' '
}

#[verifier::external_body]
spec fn str_len(s: &str) -> int {
    0
}

#[verifier::external_body]
spec fn empty_string() -> String {
    String::new()
}

#[verifier::external_body]
spec fn team1_string() -> String {
    ""Team 1\n"".to_string()
}

#[verifier::external_body]
spec fn team2_string() -> String {
    ""Team 2\n"".to_string()
}

#[verifier::external_body]
spec fn draw_string() -> String {
    ""Draw\n"".to_string()
}

spec fn is_valid_integer(s: &str) -> bool {
    str_len(s) > 0 && forall|i: int| 0 <= i < str_len(s) ==> ('0' <= char_at(s, i) && char_at(s, i) <= '9')
}

spec fn valid_player_line(line: &str) -> bool {
    let parts = split_by_char(line, ' ');
    parts.len() == 2 &&
    is_valid_integer(parts[0]) &&
    is_valid_integer(parts[1])
}

spec fn valid_input(input: &str) -> bool {
    let lines = split_lines(input);
    lines.len() >= 4 &&
    forall|i: int| 0 <= i < 4 ==> valid_player_line(lines[i])
}

#[verifier::external_body]
spec fn parse_line(line: &str) -> Seq<int> {
    Seq::empty()
}

spec fn compute_result(input: &str) -> String {
    let lines = split_lines(input);
    if lines.len() < 4 {
        empty_string()
    } else {
        let player1 = parse_line(lines[0]);
        let player2 = parse_line(lines[1]);
        let player3 = parse_line(lines[2]);
        let player4 = parse_line(lines[3]);

        if player1.len() != 2 || player2.len() != 2 || player3.len() != 2 || player4.len() != 2 {
            empty_string()
        } else {
            let a = player1[0];
            let b = player1[1];
            let c = player2[0];
            let d = player2[1];
            let x = player3[0];
            let y = player3[1];
            let z = player4[0];
            let w = player4[1];

            let team1 = (a > w && a > y && d > x && d > z) || (c > w && c > y && b > x && b > z);
            let team2 = ((x > b && w > c) || (z > b && y > c)) && ((x > d && w > a) || (z > d && y > a));

            if team1 {
                team1_string()
            } else if team2 {
                team2_string()
            } else {
                draw_string()
            }
        }
    }
}",,"fn solve(input: &str) -> (result: String)
    requires 
        valid_input(input)
    ensures 
        result == compute_result(input),
        (result@ == ""Team 1\n""@) || (result@ == ""Team 2\n""@) || (result@ == ""Draw\n""@)","{
    assume(false);
    ""Draw\n"".to_string()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0067,verus,apps,apps_test_259,,"Given n bus routes with start times and intervals, find which route has the earliest bus
arriving at or after target time t. Each route i has first bus at time s_i and subsequent
buses every d_i minutes. Return the 1-indexed route number.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, t: int, routes: Seq<(int, int)>) -> bool {
  n > 0 && routes.len() == n && 
  forall|i: int| 0 <= i < n ==> routes[i].1 > 0
}

spec fn get_next_arrival_time(first_time: int, interval: int, target_time: int) -> int
  requires interval > 0
{
  if first_time >= target_time { 
    first_time
  } else { 
    first_time + ((target_time - first_time + interval - 1) / interval) * interval
  }
}

spec fn is_optimal_route(routes: Seq<(int, int)>, t: int, route_index: int) -> bool {
  &&& 0 <= route_index < routes.len()
  &&& (forall|i: int| 0 <= i < routes.len() ==> routes[i].1 > 0)
  &&& (forall|i: int| 0 <= i < routes.len() ==> 
    get_next_arrival_time(routes[route_index].0, routes[route_index].1, t) <= 
    get_next_arrival_time(routes[i].0, routes[i].1, t))
}",,"fn solve(n: int, t: int, routes: Seq<(int, int)>) -> (result: int)
  requires valid_input(n, t, routes),
  ensures 1 <= result <= n,
  ensures is_optimal_route(routes, t, result - 1)","{
  assume(false);
  0
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0068,verus,apps,apps_test_263,,"Given n benches with initial occupancies and m additional people to seat,
find the minimum and maximum possible values of k, where k is the maximum
occupancy of any single bench after all m people are seated.
For minimum k: distribute people as evenly as possible.
For maximum k: add all m people to the bench with current maximum occupancy.","use vstd::prelude::*;

verus! {","spec fn valid_input(n: nat, m: nat, benches: Seq<nat>) -> bool {
    n > 0 && m > 0 && benches.len() == n && forall|i: int| 0 <= i < n ==> benches[i] > 0
}

spec fn max_seq(s: Seq<nat>) -> nat
    recommends s.len() > 0
{
    if s.len() == 1 {
        s[0]
    } else if s[0] >= max_seq(s.subrange(1, s.len() as int)) {
        s[0]
    } else {
        max_seq(s.subrange(1, s.len() as int))
    }
}

spec fn sum_seq(s: Seq<nat>) -> nat {
    if s.len() == 0 {
        0
    } else {
        s[0] + sum_seq(s.subrange(1, s.len() as int))
    }
}","fn solve(n: nat, m: nat, benches: Seq<nat>) -> (result: (nat, nat))
    requires valid_input(n, m, benches)
    ensures result.1 == max_seq(benches) + m
    ensures {
        let total = sum_seq(benches) + m;
        let current_max = max_seq(benches);
        if total <= current_max * n { result.0 == current_max } 
        else { result.0 == (total + n - 1) / n }
    }","{
    assume(false);
    (0, 0)
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0096,verus,apps,apps_test_502,,"Given three distinct points a, b, and c, determine if there exists a rotation center and angle 
such that rotating point a gives point b, and rotating point b gives point c.
The rotation must map a → b and b → c using the same center and angle.
For a valid rotation to exist, the distances |ab| and |bc| must be equal and 
the three points cannot be collinear.","use vstd::prelude::*;

verus! {

spec fn length_sqr(p1: (int, int), p2: (int, int)) -> int {
    (p1.0 - p2.0) * (p1.0 - p2.0) + (p1.1 - p2.1) * (p1.1 - p2.1)
}

spec fn valid_rotation_exists(a: (int, int), b: (int, int), c: (int, int)) -> bool {
    let dist_ab_sqr = length_sqr(a, b);
    let dist_bc_sqr = length_sqr(b, c);
    let dx1 = c.0 - b.0;
    let dy1 = c.1 - b.1;
    let dx2 = b.0 - a.0;
    let dy2 = b.1 - a.1;
    dist_ab_sqr == dist_bc_sqr && dx1 * dy2 != dy1 * dx2
}

spec fn parse_input_func(input: Seq<char>) -> Seq<int>
    recommends input.len() > 0
{
    parse_input_helper(input, 0, seq![], seq![])
}

spec fn parse_input_helper(input: Seq<char>, i: int, result: Seq<int>, current: Seq<char>) -> Seq<int>
    recommends 0 <= i <= input.len()
    decreases input.len() - i
{
    if i == input.len() {
        if current.len() > 0 { result.push(string_to_int(current)) }
        else { result }
    } else {
        let ch = input[i];
        if ch == ' ' || ch == '\n' || ch == '\t' {
            if current.len() > 0 {
                parse_input_helper(input, i + 1, result.push(string_to_int(current)), seq![])
            } else {
                parse_input_helper(input, i + 1, result, seq![])
            }
        } else if ('0' <= ch <= '9') || ch == '-' {
            parse_input_helper(input, i + 1, result, current.push(ch))
        } else {
            parse_input_helper(input, i + 1, result, current)
        }
    }
}

spec fn string_to_int(s: Seq<char>) -> int {
    if s.len() == 0 { 0 }
    else if s.len() == 1 && s[0] == '-' { 0 }
    else if s[0] == '-' && s.len() > 1 && is_digit_string(s.subrange(1, s.len() as int)) { -string_to_int_helper(s.subrange(1, s.len() as int)) }
    else if is_digit_string(s) { string_to_int_helper(s) }
    else { 0 }
}

spec fn is_digit_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] <= '9'
}

spec fn string_to_int_helper(s: Seq<char>) -> int
    recommends forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] <= '9'
{
    if s.len() == 0 { 0 }
    else if s.len() == 1 { char_to_digit(s[0]) }
    else { string_to_int_helper(s.subrange(0, s.len() - 1)) * 10 + char_to_digit(s[s.len() - 1]) }
}

spec fn char_to_digit(c: char) -> int
    recommends '0' <= c <= '9'
{
    (c as int) - ('0' as int)
}",,"fn solve(input: &str) -> (result: String)
    requires input@.len() > 0
    ensures result@ == ""Yes""@ || result@ == ""No""@ || result@ == """"@","{
    assume(false);
    """".to_string()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0097,verus,apps,apps_test_505,,"Given an n×m rectangular maze with a robot starting at position 'X', find the lexicographically smallest path of exactly k moves that returns the robot to its starting position.
The maze contains '.' for empty cells, '*' for obstacles, and 'X' for the robot's starting position.
Robot can move in 4 directions: L (left), R (right), U (up), D (down) and can only move to empty cells.
Return the lexicographically smallest string of length k consisting of characters 'D', 'L', 'R', 'U' that returns the robot to start, or ""IMPOSSIBLE"".","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, m: int, k: int, grid: Seq<Seq<char>>) -> bool {
    n > 0 && m > 0 && k >= 0 &&
    grid.len() == n &&
    (forall|i: int| 0 <= i < n ==> #[trigger] grid[i].len() == m) &&
    (exists|i: int, j: int| 0 <= i < n && 0 <= j < m && grid[i][j] == 'X')
}

spec fn get_next_position(x: int, y: int, move_char: char) -> (int, int) {
    match move_char {
        'D' => (x + 1, y),
        'L' => (x, y - 1),
        'R' => (x, y + 1),
        'U' => (x - 1, y),
        _ => (x, y)
    }
}

spec fn simulate_path(start_x: int, start_y: int, path: Seq<char>, grid: Seq<Seq<char>>, n: int, m: int) -> (int, int)
    decreases path.len()
{
    if path.len() == 0 {
        (start_x, start_y)
    } else {
        let next_pos = get_next_position(start_x, start_y, path[0]);
        simulate_path(next_pos.0, next_pos.1, path.subrange(1, path.len() as int), grid, n, m)
    }
}

spec fn valid_path(start_x: int, start_y: int, path: Seq<char>, grid: Seq<Seq<char>>, n: int, m: int) -> bool {
    forall|i: int| #![trigger simulate_path(start_x, start_y, path.subrange(0, i), grid, n, m)] 
        0 <= i <= path.len() ==> {
            let pos = simulate_path(start_x, start_y, path.subrange(0, i), grid, n, m);
            0 <= pos.0 < n && 0 <= pos.1 < m && 
            pos.0 < grid.len() && pos.1 < grid[pos.0].len() &&
            grid[pos.0][pos.1] != '*'
        }
}

spec fn path_returns_to_start(start_x: int, start_y: int, path: Seq<char>, grid: Seq<Seq<char>>, n: int, m: int) -> bool {
    let final_pos = simulate_path(start_x, start_y, path, grid, n, m);
    final_pos.0 == start_x && final_pos.1 == start_y
}

spec fn valid_directions(path: Seq<char>) -> bool {
    forall|i: int| 0 <= i < path.len() ==> 
        #[trigger] path[i] == 'D' || path[i] == 'L' || path[i] == 'R' || path[i] == 'U'
}",,"fn solve(n: usize, m: usize, k: usize, grid: Vec<Vec<char>>) -> (result: String)
    requires
        valid_input(n as int, m as int, k as int, grid@.map_values(|row: Vec<char>| row@))
    ensures
        result == ""IMPOSSIBLE"" || (
            result.len() == k &&
            valid_directions(result@) &&
            {
                let mut start_x = 0;
                let mut start_y = 0;
                let mut found = false;
                let mut i = 0;
                while i < n {
                    let mut j = 0;
                    while j < m {
                        if grid[i][j] == 'X' {
                            start_x = i as int;
                            start_y = j as int;
                            found = true;
                        }
                        j += 1;
                    }
                    i += 1;
                }
                found
            } ==> {
                let start_x = {
                    let mut sx = 0;
                    let mut i = 0;
                    while i < n {
                        let mut j = 0;
                        while j < m {
                            if grid[i][j] == 'X' {
                                sx = i as int;
                            }
                            j += 1;
                        }
                        i += 1;
                    }
                    sx
                };
                let start_y = {
                    let mut sy = 0;
                    let mut i = 0;
                    while i < n {
                        let mut j = 0;
                        while j < m {
                            if grid[i][j] == 'X' {
                                sy = j as int;
                            }
                            j += 1;
                        }
                        i += 1;
                    }
                    sy
                };
                valid_path(start_x, start_y, result@, grid@.map_values(|row: Vec<char>| row@), n as int, m as int) &&
                path_returns_to_start(start_x, start_y, result@, grid@.map_values(|row: Vec<char>| row@), n as int, m as int)
            }
        )","{
    assume(false);
    ""IMPOSSIBLE"".to_string()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0099,verus,apps,apps_test_510,,"Three ropewalkers are positioned at coordinates a, b, and c on an infinite line.
Each second, exactly one ropewalker can move by 1 unit left or right.
Find the minimum time needed so that the distance between every pair of ropewalkers is at least d.","use vstd::prelude::*;

verus! {
    spec fn pos1(a: int, b: int, c: int) -> int {
        if a <= b && a <= c {
            a
        } else if b <= a && b <= c {
            b
        } else {
            c
        }
    }
    
    spec fn pos2(a: int, b: int, c: int) -> int {
        if a <= b && a <= c {
            if b <= c { b } else { c }
        } else if b <= a && b <= c {
            if a <= c { a } else { c }
        } else {
            if a <= b { a } else { b }
        }
    }
    
    spec fn pos3(a: int, b: int, c: int) -> int {
        if a <= b && a <= c {
            if b <= c { c } else { b }
        } else if b <= a && b <= c {
            if a <= c { c } else { a }
        } else {
            if a <= b { b } else { a }
        }
    }",,"fn solve(a: int, b: int, c: int, d: int) -> (result: int)
    requires 1 <= a && a <= 1_000_000_000
    requires 1 <= b && b <= 1_000_000_000
    requires 1 <= c && c <= 1_000_000_000
    requires 1 <= d && d <= 1_000_000_000
    ensures result >= 0
    ensures result == (if d > (pos2(a, b, c) - pos1(a, b, c)) { d - (pos2(a, b, c) - pos1(a, b, c)) } else { 0 }) +
                     (if d > (pos3(a, b, c) - pos2(a, b, c)) { d - (pos3(a, b, c) - pos2(a, b, c)) } else { 0 })","{
    assume(false);
    0
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0106,verus,apps,apps_test_540,,"Given an n×m grid representing an ice cave level, determine if you can move from starting position (r1, c1) to target position (r2, c2) and fall through the target cell.
Grid representation: '.' = intact ice, 'X' = cracked ice
Movement rules: Move to side-adjacent cells only, cannot move to same cell, moving to intact ice cracks it, moving to cracked ice causes fall through
Goal: Reach (r2, c2) when it's cracked ice and fall through it
Starting cell (r1, c1) is guaranteed to contain 'X' in the input","use vstd::prelude::*;

verus! {

spec fn valid_input_format(stdin_input: Seq<char>) -> bool {
    stdin_input.len() > 0 &&
    stdin_input.len() >= 7 &&
    contains_required_newlines(stdin_input) &&
    ends_with_newline_or_can_append(stdin_input) &&
    has_valid_structure(stdin_input) &&
    all_grid_characters_valid(stdin_input) &&
    has_exactly_required_lines(stdin_input)
}

spec fn valid_grid_bounds(stdin_input: Seq<char>) -> bool {
    let parsed = parse_dimensions(stdin_input);
    parsed.0 >= 1 && parsed.0 <= 500 && parsed.1 >= 1 && parsed.1 <= 500
}

spec fn valid_coordinates(stdin_input: Seq<char>) -> bool {
    let dims = parse_dimensions(stdin_input);
    let coords = parse_coordinates(stdin_input);
    coords.0 >= 1 && coords.0 <= dims.0 && coords.1 >= 1 && coords.1 <= dims.1 &&
    coords.2 >= 1 && coords.2 <= dims.0 && coords.3 >= 1 && coords.3 <= dims.1
}

spec fn starting_cell_is_cracked(stdin_input: Seq<char>) -> bool {
    let grid = parse_grid(stdin_input);
    let coords = parse_coordinates(stdin_input);
    valid_grid_index(grid, coords.0-1, coords.1-1) &&
    grid.index(coords.0-1).index(coords.1-1) == 'X'
}

spec fn well_formed_input(stdin_input: Seq<char>) -> bool {
    valid_input_format(stdin_input) &&
    valid_grid_bounds(stdin_input) &&
    valid_coordinates(stdin_input) &&
    starting_cell_is_cracked(stdin_input) &&
    grid_contains_only_valid_chars(stdin_input) &&
    coordinates_within_bounds(stdin_input)
}

spec fn can_solve_ice_maze(stdin_input: Seq<char>) -> bool {
    let grid = parse_grid(stdin_input);
    let coords = parse_coordinates(stdin_input);
    let r1 = coords.0-1;
    let c1 = coords.1-1;
    let r2 = coords.2-1;
    let c2 = coords.3-1;
    let target_is_cracked = grid.index(r2).index(c2) == 'X';
    let surrounding_dots = count_surrounding_intact_ice(grid, r2, c2);

    if target_is_cracked {
        if r1 == r2 && c1 == c2 {
            surrounding_dots >= 1
        } else {
            can_reach_target_with_bfs(grid, r1, c1, r2, c2)
        }
    } else {
        if surrounding_dots >= 2 {
            can_reach_target_with_bfs(grid, r1, c1, r2, c2)
        } else if surrounding_dots == 0 {
            false
        } else {
            is_adjacent(r1+1, c1+1, r2+1, c2+1)
        }
    }
}

spec fn parse_dimensions(stdin_input: Seq<char>) -> (int, int) {
    (1, 1)
}

spec fn parse_grid(stdin_input: Seq<char>) -> Seq<Seq<char>> {
    seq![seq!['X']]
}

spec fn parse_coordinates(stdin_input: Seq<char>) -> (int, int, int, int) {
    (1, 1, 1, 1)
}

spec fn valid_grid_index(grid: Seq<Seq<char>>, r: int, c: int) -> bool {
    0 <= r < grid.len() && 0 <= c < grid.index(r).len()
}

/* Helper functions that are referenced but not defined */
spec fn contains_required_newlines(input: Seq<char>) -> bool { true }
spec fn ends_with_newline_or_can_append(input: Seq<char>) -> bool { true }
spec fn has_valid_structure(input: Seq<char>) -> bool { true }
spec fn all_grid_characters_valid(input: Seq<char>) -> bool { true }
spec fn has_exactly_required_lines(input: Seq<char>) -> bool { true }
spec fn grid_contains_only_valid_chars(input: Seq<char>) -> bool { true }
spec fn coordinates_within_bounds(input: Seq<char>) -> bool { true }
spec fn count_surrounding_intact_ice(grid: Seq<Seq<char>>, r: int, c: int) -> int { 0 }
spec fn can_reach_target_with_bfs(grid: Seq<Seq<char>>, r1: int, c1: int, r2: int, c2: int) -> bool { true }
spec fn is_adjacent(r1: int, c1: int, r2: int, c2: int) -> bool { 
    (r1 == r2 && (c1 == c2 + 1 || c1 == c2 - 1)) ||
    (c1 == c2 && (r1 == r2 + 1 || r1 == r2 - 1))
}",,"fn solve(stdin_input: Seq<char>) -> (result: Seq<char>)
    requires 
        stdin_input.len() > 0,
        valid_input_format(stdin_input),
        valid_grid_bounds(stdin_input),
        valid_coordinates(stdin_input),
        starting_cell_is_cracked(stdin_input),
        well_formed_input(stdin_input),
    ensures 
        result == seq!['Y', 'E', 'S', '\n'] || result == seq!['N', 'O', '\n'],
        result.len() > 0,
        (result == seq!['Y', 'E', 'S', '\n']) <==> can_solve_ice_maze(stdin_input),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0107,verus,apps,apps_test_543,,"Determine if pizza requirements for n consecutive days can be fulfilled using only:
- Discount: Buy exactly 2 pizzas on the same day
- Coupon: Buy exactly 1 pizza on each of two consecutive days
Cannot buy more pizzas than needed on any day, and cannot have unused coupons after the last day.","use vstd::prelude::*;

verus! {

spec fn valid_input(pizzas: Seq<int>) -> bool {
    forall|i: int| 0 <= i < pizzas.len() ==> pizzas[i] >= 0
}

spec fn validate_pizza_solution(pizzas: Seq<int>, index: int, d: bool, p: int) -> bool
    decreases pizzas.len() - index
    when 0 <= index <= pizzas.len() && (p == 0 || p == 1)
{
    if index == pizzas.len() {
        d && p == 0
    } else {
        let requirement = pizzas[index];
        let new_p = if requirement % 2 == 1 { 1 - p } else { p };
        let new_d = if requirement % 2 == 0 && p == 1 && requirement == 0 { false } else { d };
        validate_pizza_solution(pizzas, index + 1, new_d, new_p)
    }
}

spec fn can_fulfill_requirements(pizzas: Seq<int>) -> bool {
    validate_pizza_solution(pizzas, 0, true, 0)
}",,"fn solve(pizzas: Vec<i8>) -> (result: String)
    requires
        forall|i: int| 0 <= i < pizzas.len() ==> pizzas[i] as int >= 0,
        valid_input(pizzas@.map(|i, x| x as int)),
    ensures
        result == ""YES"" ==> can_fulfill_requirements(pizzas@.map(|i, x| x as int)),
        result == ""NO"" ==> !can_fulfill_requirements(pizzas@.map(|i, x| x as int)),","{
    assume(false);
    ""NO"".to_string()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0114,verus,apps,apps_test_601,,"Given two people with carrying capacities p and f, and a shop containing cnt_s swords
(each weighing s units) and cnt_w war axes (each weighing w units), find the maximum
total number of items both people can carry. The input contains multiple test cases.","use vstd::prelude::*;

verus! {

spec fn split_func(input: Seq<char>, delimiter: char) -> Seq<Seq<char>> {
    seq![]
}

spec fn parse_int_func(s: Seq<char>) -> int {
    0
}

spec fn process_test_cases_helper(input: Seq<char>, lines: Seq<Seq<char>>, line_idx: int, case_idx: int, total_cases: int, acc: Seq<int>) -> Seq<int> {
    seq![]
}

spec fn format_output_helper(results: Seq<int>, idx: int, acc: Seq<char>) -> Seq<char> {
    seq![]
}

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 &&
    {
        let lines = split_func(input, '\n');
        lines.len() >= 1 &&
        parse_int_func(lines[0]) >= 0 &&
        lines.len() >= 1 + 3 * parse_int_func(lines[0])
    }
}

spec fn process_test_cases(input: Seq<char>) -> Seq<int> {
    if valid_input(input) {
        let lines = split_func(input, '\n');
        let t = parse_int_func(lines[0]);
        process_test_cases_helper(input, lines, 1, 0, t, seq![])
    } else {
        seq![]
    }
}

spec fn format_output(results: Seq<int>) -> Seq<char> {
    format_output_helper(results, 0, seq![])
}",,"fn solve(input: Seq<char>) -> (result: Seq<char>)
    requires
        input.len() > 0,
        valid_input(input),
    ensures
        result.len() >= 0,
        result == format_output(process_test_cases(input)),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0118,verus,apps,apps_test_607,,"Given integers n and m, compute the sum of happiness values for all permutations of length n, 
modulo prime number m. A permutation's happiness is the count of its framed segments, where
a framed segment [l,r] satisfies max{elements} - min{elements} = r - l.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, m: int) -> bool {
    n > 0 && m > 0
}

spec fn compute_happiness_sum(n: int, m: int) -> int
    recommends n > 0 && m > 0
{
    0
}",,"fn solve(n: int, m: int) -> (output: int)
    requires n > 0 && m > 0","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0121,verus,apps,apps_test_619,,"Sasha has x chizhiks and Masha has y chizhiks. Coconuts cost z chizhiks each.
Find the maximum number of coconuts they can buy together by potentially exchanging
chizhiks, and determine the minimum number of chizhiks that must be exchanged.","use vstd::prelude::*;

verus! {

spec fn valid_input(x: int, y: int, z: int) -> bool {
    x >= 0 && y >= 0 && z > 0
}

spec fn max_coconuts(x: int, y: int, z: int) -> int {
    (x + y) / z
}

spec fn min_exchange(x: int, y: int, z: int) -> int {
    let rx = x % z;
    let ry = y % z;
    if rx + ry < z { 0 } else { z - if rx > ry { rx } else { ry } }
}",,"fn solve(x: i8, y: i8, z: i8) -> (result: (i8, i8))
    requires valid_input(x as int, y as int, z as int)
    ensures result.0 as int == max_coconuts(x as int, y as int, z as int) && result.1 as int == min_exchange(x as int, y as int, z as int) && result.0 as int >= (x as int) / (z as int) + (y as int) / (z as int) && result.0 as int <= (x as int) / (z as int) + (y as int) / (z as int) + 1 && result.1 as int >= 0 && result.1 as int < (z as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0124,verus,apps,apps_test_631,,"Given an array of n integers, determine if it's possible to reorder the elements 
to make the double sum equal a target value m. The double sum is defined as
sum over i from 1 to n of (sum over j from i to n of a_j/j).
No elements may be added or removed from the array.","use vstd::prelude::*;

verus! {

spec fn valid_input_format(s: Seq<char>) -> bool {
    s.len() >= 7 && 
    exists|pos: int| 0 < pos < s.len() && s[pos] == '\n'
}

spec fn get_test_count(stdin_input: Seq<char>) -> int {
    1
}

spec fn get_array_sum(stdin_input: Seq<char>, test_idx: int) -> int {
    0
}

spec fn get_target_m(stdin_input: Seq<char>, test_idx: int) -> int {
    0
}

spec fn compute_expected_output(stdin_input: Seq<char>, start_idx: int, count: int) -> Seq<char> {
    seq![]
}

spec fn count_responses(result: Seq<char>) -> int {
    0
}

spec fn get_response_at_index(result: Seq<char>, i: int) -> Seq<char> {
    seq![]
}

spec fn expected_output_for_input(stdin_input: Seq<char>) -> Seq<char> {
    compute_expected_output(stdin_input, 0, get_test_count(stdin_input))
}

spec fn behavioral_correctness(stdin_input: Seq<char>, result: Seq<char>) -> bool {
    let T = get_test_count(stdin_input);
    count_responses(result) == T &&
    (forall|i: int| #![trigger get_array_sum(stdin_input, i)] 0 <= i < T ==> {
        let array_sum = get_array_sum(stdin_input, i);
        let target_m = get_target_m(stdin_input, i);
        let response = get_response_at_index(result, i);
        let yes_response = seq![
            'Y' as char, 'E' as char, 'S' as char, '\n' as char
        ];
        let no_response = seq![
            'N' as char, 'O' as char, '\n' as char
        ];
        (array_sum == target_m <==> response == yes_response) &&
        (array_sum != target_m <==> response == no_response)
    })
}",,"fn solve(stdin_input: &str) -> (result: String)
    requires valid_input_format(stdin_input@)
    ensures behavioral_correctness(stdin_input@, result@)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0130,verus,apps,apps_test_651,,"Given a 2D maze and a sequence of movement instructions (digits 0-3), determine how many ways
the instructions can be interpreted to successfully navigate from start to exit. Each digit
must map to a unique direction (up, down, left, right). The robot stops upon reaching the exit
or crashes when hitting obstacles/boundaries.","use vstd::prelude::*;

verus! {

spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {
    seq![]
}

spec fn parse_two_ints(s: Seq<char>) -> (int, int) {
    (0, 0)
}

spec fn count_occurrences(lines: Seq<Seq<char>>, n: int, m: int, c: char) -> int {
    0
}

spec fn find_start(lines: Seq<Seq<char>>, n: int, m: int) -> (int, int) {
    (0, 0)
}

spec fn find_end(lines: Seq<Seq<char>>, n: int, m: int) -> (int, int) {
    (0, 0)
}

spec fn count_permutations_reaching_goal(lines: Seq<Seq<char>>, n: int, m: int, path: Seq<char>, start: (int, int), end: (int, int)) -> int {
    0
}

spec fn string_to_int(s: Seq<char>) -> int {
    0
}

spec fn valid_input(input: Seq<char>) -> bool {
    let lines = split_lines(input);
    lines.len() >= 3 &&
    has_valid_dimensions(lines) &&
    has_valid_grid(lines) &&
    has_start_and_end(lines) &&
    has_valid_path(lines)
}

spec fn has_valid_dimensions(lines: Seq<Seq<char>>) -> bool {
    let dimensions = parse_two_ints(lines[0]);
    let n = dimensions.0;
    let m = dimensions.1;
    n > 0 && m > 0 && lines.len() >= n + 2
}

spec fn has_valid_grid(lines: Seq<Seq<char>>) -> bool {
    let dimensions = parse_two_ints(lines[0]);
    let n = dimensions.0;
    let m = dimensions.1;
    n > 0 && m > 0 && lines.len() >= n + 2 &&
    forall|i: int| 1 <= i <= n && i < lines.len() ==>
        forall|j: int| 0 <= j < lines[i].len() && j < m ==>
            lines[i][j] == '.' || lines[i][j] == '#' || 
            lines[i][j] == 'S' || lines[i][j] == 'E'
}

spec fn has_start_and_end(lines: Seq<Seq<char>>) -> bool {
    let dimensions = parse_two_ints(lines[0]);
    let n = dimensions.0;
    let m = dimensions.1;
    n > 0 && m > 0 && lines.len() >= n + 2 &&
    (exists|i: int, j: int| 1 <= i <= n && i < lines.len() && 0 <= j < lines[i].len() && j < m && lines[i][j] == 'S') &&
    (exists|i: int, j: int| 1 <= i <= n && i < lines.len() && 0 <= j < lines[i].len() && j < m && lines[i][j] == 'E') &&
    count_occurrences(lines, n, m, 'S') == 1 &&
    count_occurrences(lines, n, m, 'E') == 1
}

spec fn has_valid_path(lines: Seq<Seq<char>>) -> bool {
    let dimensions = parse_two_ints(lines[0]);
    let n = dimensions.0;
    let m = dimensions.1;
    n > 0 && m > 0 && lines.len() >= n + 2 &&
    valid_path_string(lines[n + 1])
}

spec fn valid_path_string(path: Seq<char>) -> bool {
    forall|i: int| 0 <= i < path.len() ==> 
        '0' <= path[i] && path[i] <= '3'
}

spec fn valid_result(result: Seq<char>) -> bool {
    result.len() > 0 &&
    forall|c: char| result.contains(c) ==> 
        ('0' <= c && c <= '9') || c == '\n'
}

spec fn count_valid_ways(input: Seq<char>) -> int {
    let lines = split_lines(input);
    let dimensions = parse_two_ints(lines[0]);
    let n = dimensions.0;
    let m = dimensions.1;
    let start = find_start(lines, n, m);
    let end = find_end(lines, n, m);
    let path = lines[n + 1];
    count_permutations_reaching_goal(lines, n, m, path, start, end)
}",,"fn solve(stdin_input: &str) -> (result: String)
    requires stdin_input.len() > 0","{
    // impl-start
    assume(false);
    String::new()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0131,verus,apps,apps_test_656,,"Given n winter days with temperature forecasts, minimize tire changes to drive safely.
Start with summer tires (safe when temp >= 0). Winter tires safe at any temp but 
limited to k days total. Must drive safely every day. Can change tires at start of any day.
Return minimum tire changes needed, or -1 if impossible.","use vstd::prelude::*;

verus! {
spec fn count_negative_temp_days(temps: Seq<int>) -> int
    decreases temps.len()
{
    if temps.len() == 0 {
        0int
    } else {
        (if temps[0] < 0 { 1int } else { 0int }) + count_negative_temp_days(temps.subrange(1, temps.len() as int))
    }
}",,"fn solve(n: i8, k: i8, temps: Vec<i8>) -> (result: i8)
    requires 
        n >= 1,
        k >= 0 && k <= n,
        temps@.len() == n as nat,
        forall|i: int| 0 <= i < n as int ==> #[trigger] temps@[i] as int >= -20 && #[trigger] temps@[i] as int <= 20,
    ensures 
        result as int == -1 <==> count_negative_temp_days(temps@.map(|i, x: i8| x as int)) > k as int,
        result != -1 ==> result >= 0,
        result as int == 0 ==> forall|i: int| 0 <= i < n as int ==> #[trigger] temps@[i] as int >= 0,
        result > 0 ==> exists|i: int| 0 <= i < n as int && #[trigger] temps@[i] as int < 0,","{
    assume(false);
    0i8
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0138,verus,apps,apps_test_701,,"Given two distinct strings s and t, determine if s can be transformed into t using character removal and/or character swapping operations.
Return ""array"" if only swapping needed, ""automaton"" if only removal needed, ""both"" if both operations needed, or ""need tree"" if impossible.","use vstd::prelude::*;

verus! {

spec fn parse_lines(stdin_input: Seq<char>) -> Seq<Seq<char>>
    decreases stdin_input.len()
{
    if stdin_input.len() == 0 {
        seq![]
    } else {
        let newline_pos = find_newline(stdin_input, 0);
        if newline_pos == -1 {
            seq![stdin_input]
        } else if newline_pos == 0 {
            parse_lines(stdin_input.subrange(1, stdin_input.len() as int))
        } else if newline_pos < stdin_input.len() && newline_pos >= 0 {
            seq![stdin_input.subrange(0, newline_pos)] + parse_lines(stdin_input.subrange(newline_pos + 1, stdin_input.len() as int))
        } else {
            seq![]
        }
    }
}

spec fn find_newline(s: Seq<char>, start: int) -> int
    decreases s.len() - start
{
    if start >= s.len() {
        -1
    } else if s[start] == '\n' {
        start
    } else {
        find_newline(s, start + 1)
    }
}

spec fn valid_input(stdin_input: Seq<char>) -> bool {
    let lines = parse_lines(stdin_input);
    lines.len() >= 2 && lines[0].len() > 0 && lines[1].len() > 0 &&
    (forall|i: int| 0 <= i < lines[0].len() ==> 'a' <= lines[0][i] <= 'z') &&
    (forall|i: int| 0 <= i < lines[1].len() ==> 'a' <= lines[1][i] <= 'z')
}

spec fn is_subsequence(s: Seq<char>, t: Seq<char>) -> bool {
    if s.len() == 0 {
        true
    } else if t.len() == 0 {
        false
    } else if s[0] == t[0] {
        is_subsequence(s.subrange(1, s.len() as int), t.subrange(1, t.len() as int))
    } else {
        is_subsequence(s, t.subrange(1, t.len() as int))
    }
}

spec fn sort_string(s: Seq<char>) -> Seq<char>
    decreases s.len()
{
    if s.len() <= 1 {
        s
    } else {
        let pivot = s[0];
        let smaller = filter_chars(s.subrange(1, s.len() as int), pivot, true, false);
        let equal = filter_chars(s, pivot, false, true);
        let larger = filter_chars(s.subrange(1, s.len() as int), pivot, false, false);
        sort_string(smaller) + equal + sort_string(larger)
    }
}

spec fn filter_chars(s: Seq<char>, pivot: char, take_less: bool, take_equal: bool) -> Seq<char>
    decreases s.len()
{
    if s.len() == 0 {
        seq![]
    } else {
        let first = s[0];
        let rest = filter_chars(s.subrange(1, s.len() as int), pivot, take_less, take_equal);
        if (take_less && first < pivot) || (take_equal && first == pivot) || (!take_less && !take_equal && first > pivot) {
            seq![first] + rest
        } else {
            rest
        }
    }
}",,fn solve(stdin_input: &str) -> (result: &'static str),"{
    // impl-start
    assume(false);
    ""array""
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0141,verus,apps,apps_test_715,,"Given a multiple-choice question with four options (A, B, C, D), predict a child's choice.
Calculate the length of each option's description (excluding prefix ""A."", ""B."", etc.).
A choice is ""great"" if its description is either at least twice shorter than all others
OR at least twice longer than all others. If exactly one choice is great, select it.
Otherwise, select choice C.","use vstd::prelude::*;

verus! {
spec fn valid_result(result: &str) -> bool {
    result == ""A"" || result == ""B"" || result == ""C"" || result == ""D""
}

spec fn choice_from_index(index: int) -> &'static str
    recommends 0 <= index <= 3
{
    if index == 0 { ""A"" }
    else if index == 1 { ""B"" }
    else if index == 2 { ""C"" }
    else { ""D"" }
}

spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {
    Seq::empty()
}

spec fn sort_lengths_with_indices(lengths: Seq<int>) -> Seq<(int, int)>
    recommends lengths.len() == 4
{
    Seq::empty()
}",,"fn solve(input: Seq<char>) -> (result: &'static str)
    requires input.len() > 0
    ensures valid_result(result)","{
    // impl-start
    assume(false);
    ""C""
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0143,verus,apps,apps_test_726,,"Given n hotels at distinct integer coordinates on a number line, find the number of positions 
where a new hotel can be built such that the minimum distance from the new hotel to any 
existing hotel is exactly d.","use vstd::prelude::*;

verus! {
spec fn is_sorted(hotels: Seq<int>, n: int) -> bool
    decreases n
{
    if n <= 1 {
        true
    } else {
        hotels[n-2] < hotels[n-1] && is_sorted(hotels, n-1)
    }
}

spec fn valid_input(n: int, d: int, hotels: Seq<int>) -> bool {
    n > 0 && d > 0 && hotels.len() == n && is_sorted(hotels, n)
}

spec fn sum_contributions(hotels: Seq<int>, d: int, i: int) -> int
    recommends 0 <= i && i <= hotels.len() - 1,
                d > 0,
                is_sorted(hotels, hotels.len() as int)
    decreases i
    when i >= 0
{
    if i == 0 { 
        0 
    } else {
        let gap = hotels[i as int] - hotels[(i-1) as int];
        let contribution: int = if gap == 2*d { 1 } else if gap > 2*d { 2 } else { 0 };
        contribution + sum_contributions(hotels, d, i-1)
    }
}

spec fn correct_result(n: int, d: int, hotels: Seq<int>, result: int) -> bool
    recommends valid_input(n, d, hotels)
{
    result == 2 + sum_contributions(hotels, d, n-1) && result >= 2
}",,"fn solve(n: i8, d: i8, hotels: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, d as int, hotels@.map(|_, x: i8| x as int))
    ensures correct_result(n as int, d as int, hotels@.map(|_, x: i8| x as int), result as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0145,verus,apps,apps_test_743,,"Given n positive integers, repeatedly perform operations where you select two indices i,j
with x_i > x_j and set x_i = x_i - x_j. Find the minimum possible sum after any number of operations.","use vstd::prelude::*;

verus! {","spec fn valid_input(n: int, ar: Seq<int>) -> bool {
    n >= 2 && ar.len() == n && (forall|i: int| 0 <= i < n ==> ar[i] > 0)
}

spec fn gcd(x: int, y: int) -> int
    requires x > 0 && y > 0,
    ensures gcd(x, y) > 0,
    decreases if x < y { y } else { x },
{
    if x == y { x }
    else if x < y { gcd(x, y - x) }
    else { gcd(x - y, y) }
}

spec fn gcd_of_sequence(ar: Seq<int>) -> int
    requires ar.len() >= 1,
    requires (forall|i: int| 0 <= i < ar.len() ==> ar[i] > 0),
    ensures gcd_of_sequence(ar) > 0,
    decreases ar.len(),
{
    if ar.len() == 1 { ar[0] }
    else { gcd(ar[0], gcd_of_sequence(ar.subrange(1, ar.len() as int))) }
}

spec fn minimal_sum(n: int, ar: Seq<int>) -> int
    requires valid_input(n, ar),
{
    gcd_of_sequence(ar) * n
}","fn solve(n: int, ar: Seq<int>) -> (result: int)
    requires valid_input(n, ar),
    ensures result == minimal_sum(n, ar),
    ensures result > 0,","{
    assume(false);
    0
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0149,verus,apps,apps_test_752,,"Given two lists of T-shirt sizes (previous year and current year), find the minimum number 
of character replacements needed to transform the previous year's list into the current year's 
list. Each replacement changes one character in one T-shirt size to any uppercase Latin letter. 
The lists are unordered (only the frequency of each size matters).","use vstd::prelude::*;

verus! {

spec fn split_lines(input: &str) -> Seq<&str>
    uninterp;

spec fn parse_integer(s: &str) -> int
    uninterp;

spec fn count_sizes(sizes: Seq<&str>) -> Map<&str, nat>
    uninterp;

spec fn count_unmatched_sizes(prev_sizes: Map<&str, nat>, current_sizes: Seq<&str>) -> nat
    uninterp;

spec fn int_to_string(n: nat) -> String
    uninterp;

spec fn valid_input(stdin_input: &str) -> bool {
    let lines = split_lines(stdin_input);
    lines.len() >= 1 && {
        let n = parse_integer(lines[0]);
        n >= 0 && lines.len() >= (2 * n + 1) && 
        (forall|i: int| 1 <= i <= 2 * n ==> 
            i < lines.len() && lines[i].len() > 0)
    }
}

spec fn compute_mismatches(stdin_input: &str) -> nat
    decreases stdin_input.len()
{
    let lines = split_lines(stdin_input);
    let n = parse_integer(lines[0]);
    if n == 0 { 
        0 
    } else {
        let prev_sizes = count_sizes(lines.subrange(1, n + 1));
        let current_sizes = lines.subrange(n + 1, 2 * n + 1);
        count_unmatched_sizes(prev_sizes, current_sizes)
    }
}",,"fn solve(stdin_input: &str) -> (result: String)
    requires 
        stdin_input.len() > 0,
        valid_input(stdin_input),
    ensures 
        result.len() > 0,
        result.as_bytes()[result.len()-1] == b'\n' || 
            (result.len() > 1 && result.as_bytes().subrange(result.len()-2, result.len()) == seq![b'\r', b'\n']),
        exists|mismatches: nat| 
            result == int_to_string(mismatches) + ""\n"" && 
            mismatches == compute_mismatches(stdin_input),
        ({
            let lines = split_lines(stdin_input);
            let n = parse_integer(lines[0]);
            n >= 0 ==> {
                let mismatches = compute_mismatches(stdin_input);
                mismatches <= n &&
                result == int_to_string(mismatches) + ""\n""
            }
        }),","{
    // impl-start
    assume(false);
    String::new()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0150,verus,apps,apps_test_753,,"Given a monitor with aspect ratio a:b and a movie with aspect ratio c:d,
fit the movie on screen while preserving its aspect ratio and maximizing area.
Calculate the ratio of empty screen area to total screen area as an irreducible fraction.","use vstd::prelude::*;

verus! {

spec fn gcd(a: int, b: int) -> int
    decreases (if b == 0 { 0 } else { (if b >= 0 { b } else { -b }) })
{
    if b == 0 {
        if a >= 0 { a } else { -a }
    } else {
        gcd(b, a % b)
    }
}

spec fn valid_input(a: int, b: int, c: int, d: int) -> bool {
    a > 0 && b > 0 && c > 0 && d > 0
}

spec fn is_valid_fraction_string(s: Seq<char>, num: int, den: int) -> bool {
    num >= 0 && den > 0 && 
    gcd(num, den) == 1
    /* && s == int_to_string(num) + ""/"" + int_to_string(den) */
}",,"fn solve(a: int, b: int, c: int, d: int) -> (result: Seq<char>)
    requires valid_input(a, b, c, d)
    ensures ({
        let equal_case = a * d == b * c;
        let greater_case = a * d > b * c;
        let less_case = a * d < b * c;
        
        (equal_case ==> result == seq!['0', '/', '1']) &&
        (greater_case ==> exists|numerator: int, denominator: int| 
            numerator > 0 && denominator > 0 && 
            gcd(numerator, denominator) == 1 &&
            numerator * a * d == (a * d - b * c) * denominator) &&
        (less_case ==> exists|numerator: int, denominator: int| 
            numerator > 0 && denominator > 0 && 
            gcd(numerator, denominator) == 1 &&
            numerator * b * c == (b * c - a * d) * denominator)
    })","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0153,verus,apps,apps_test_756,,"Given a 90-minute game with certain interesting minutes, determine how many
minutes are watched before turning off the TV. The TV turns off immediately
after 15 consecutive boring minutes occur.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, a: Seq<int>) -> bool {
    n >= 1 && n <= 90 &&
    a.len() == n &&
    (forall|i: int| 0 <= i < n ==> 1 <= #[trigger] a[i] <= 90) &&
    (forall|i: int, j: int| i + 1 == j && 0 <= i < n - 1 ==> #[trigger] a[i] < #[trigger] a[j])
}

spec fn find_cutoff(a: Seq<int>, index: int, cutoff: int) -> int
    decreases a.len() - index
    when 0 <= index <= a.len()
{
    if index >= a.len() {
        cutoff
    } else if a[index] > cutoff {
        cutoff
    } else {
        find_cutoff(a, index + 1, a[index] + 15)
    }
}

spec fn min(x: int, y: int) -> int {
    if x <= y { x } else { y }
}

spec fn valid_output(result: int, n: int, a: Seq<int>) -> bool {
    valid_input(n, a) ==>
    (1 <= result <= 90 &&
     result == min(90, find_cutoff(a, 0, 15)))
}",,"fn solve(n: i8, a: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, a@.map(|x| x as int))
    ensures valid_output(result as int, n as int, a@.map(|x| x as int))","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0158,verus,apps,apps_test_787,,"Given a string q and an integer k, split the string into exactly k non-empty substrings
such that the substrings concatenate to form the original string and each substring 
starts with a different character (all first characters are distinct).","use vstd::prelude::*;

verus! {
spec fn concat_seqs(seqs: Seq<Seq<char>>) -> Seq<char>
    decreases seqs.len()
{
    if seqs.len() == 0 { 
        Seq::<char>::empty() 
    } else { 
        seqs[0] + concat_seqs(seqs.subrange(1, seqs.len() as int))
    }
}

spec fn valid_split(result: Seq<Seq<char>>, k: int, q: Seq<char>) -> bool {
    result.len() == k &&
    (forall|i: int| 0 <= i < result.len() ==> result[i].len() > 0) &&
    (forall|i: int, j: int| 0 <= i < j < result.len() ==> result[i][0] != result[j][0]) &&
    concat_seqs(result) == q
}",,"fn solve(k: i8, q: Vec<char>) -> (result: Vec<Vec<char>>)
    requires 
        k >= 0,
        q.len() >= 0,
    ensures 
        k <= 0 || q.len() == 0 ==> result.len() == 0,
        k > 0 && q.len() > 0 ==> (
            (result.len() == 0) || valid_split(Seq::new(result.len(), |i: int| result[i]@), k as int, q@)
        ),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0164,verus,apps,apps_test_807,,"Find maximum profit from borrowing a honey barrel on day d, selling it for price x_d,
buying a new barrel on day d+1 for price x_{d+1}, and paying rental cost c.
Profit = x_d - x_{d+1} - c. Only execute if profitable, otherwise return 0.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, c: int, prices: Seq<int>) -> bool {
    n >= 2 && prices.len() == n && c >= 0 &&
    (forall|i: int| 0 <= i < prices.len() ==> prices[i] >= 0)
}

spec fn profit_for_day(prices: Seq<int>, day: int, c: int) -> int {
    if 0 <= day < prices.len() - 1 {
        prices[day] - prices[day + 1] - c
    } else {
        0
    }
}

spec fn max_possible_profit(prices: Seq<int>, c: int) -> int {
    if prices.len() >= 2 {
        let profits = Seq::new((prices.len() - 1) as nat, |i: int| profit_for_day(prices, i, c));
        if profits.len() == 0 { 
            0 
        } else {
            let max_profit = profits[0];
            if profits.len() == 1 { 
                max_profit 
            } else { 
                seq_max(profits) 
            }
        }
    } else {
        0
    }
}

spec fn seq_max(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() > 0 {
        if s.len() == 1 { 
            s[0] 
        } else if s[0] >= seq_max(s.subrange(1, s.len() as int)) { 
            s[0] 
        } else { 
            seq_max(s.subrange(1, s.len() as int)) 
        }
    } else {
        0
    }
}

spec fn correct_result(n: int, c: int, prices: Seq<int>, result: int) -> bool {
    valid_input(n, c, prices) ==>
    (result >= 0 &&
     (result == 0 <==> (forall|i: int| 0 <= i < n - 1 ==> profit_for_day(prices, i, c) <= 0)) &&
     (result > 0 ==> (exists|i: int| 0 <= i < n - 1 && profit_for_day(prices, i, c) == result)) &&
     (forall|i: int| 0 <= i < n - 1 ==> profit_for_day(prices, i, c) <= result))
}",,"fn solve(n: i8, c: i8, prices: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, c as int, prices@.map(|v| v as int))
    ensures correct_result(n as int, c as int, prices@.map(|v| v as int), result as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0166,verus,apps,apps_test_813,,"Given n apples numbered 1 to n, distribute all apples between two hamsters (Arthur and Alexander) 
such that each hamster receives only apples they like. Arthur gets '1', Alexander gets '2'.","use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    let lines = split_lines(input);
    lines.len() >= 3 && split_spaces(lines[0]).len() >= 3 &&
    {
        let n = parse_int(split_spaces(lines[0])[0]);
        n > 0
    }
}

spec fn valid_output(input: Seq<char>, result: Seq<char>) -> bool {
    let lines = split_lines(input);
    let n = parse_int(split_spaces(lines[0])[0]);
    result.len() == 2 * n - 1 &&
    (forall|i: int| 0 <= i < n ==> #[trigger] result[2*i] == '1' || result[2*i] == '2') &&
    (forall|i: int| 0 <= i < n-1 ==> #[trigger] result[2*i+1] == ' ')
}

spec fn correct_assignment(input: Seq<char>, result: Seq<char>) -> bool {
    let lines = split_lines(input);
    let n = parse_int(split_spaces(lines[0])[0]);
    let arthur_apples = parse_int_seq(split_spaces(lines[1]));
    let arthur_set = Set::new(|x: int| arthur_apples.contains(x));
    forall|i: int| 1 <= i <= n ==> 
        (arthur_set.contains(i) ==> #[trigger] result[2*(i-1)] == '1') &&
        (!arthur_set.contains(i) ==> result[2*(i-1)] == '2')
}

/* Helper functions for parsing (spec functions) */
spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {
    Seq::empty()
}

spec fn split_spaces(line: Seq<char>) -> Seq<Seq<char>> {
    Seq::empty()
}

spec fn parse_int(s: Seq<char>) -> int {
    0
}

spec fn parse_int_seq(strs: Seq<Seq<char>>) -> Seq<int> {
    Seq::empty()
}",,"fn solve(input: Vec<char>) -> (result: Vec<char>)
    requires input.len() > 0
    ensures 
        !valid_input(input@) ==> result.len() == 0,
        valid_input(input@) ==> valid_output(input@, result@) && correct_assignment(input@, result@),
        forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i] == '1' || result[i] == '2' || result[i] == ' ',","{
    assume(false);
    Vec::new()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0175,verus,apps,apps_test_864,,"Given n participants and m food packages where each package has a food type,
determine the maximum number of days an expedition can last under these constraints:
- Each participant eats exactly one package per day
- Each participant must eat the same food type throughout the entire expedition
- Different participants can eat different food types","use vstd::prelude::*;

verus! {

spec fn possible(n: int, food_types: Seq<int>, days: int) -> bool
    recommends n >= 0, days >= 0, forall|i: int| 0 <= i < food_types.len() ==> food_types[i] >= 1
{
    if days == 0 { true }
    else {
        let total_participants = count_total_participants(food_types, days, 1);
        total_participants >= n
    }
}

spec fn count_total_participants(food_types: Seq<int>, days: int, current_type: int) -> int
    recommends days >= 0, current_type >= 1
    decreases 101 - current_type
{
    if current_type > 100 { 0 }
    else {
        let packages_of_this_type = count_packages(food_types, current_type);
        let participants_for_this_type = if days > 0 { packages_of_this_type / days } else { 0 };
        participants_for_this_type + count_total_participants(food_types, days, current_type + 1)
    }
}

spec fn count_packages(food_types: Seq<int>, target_type: int) -> int
    recommends target_type >= 1
    decreases food_types.len()
{
    if food_types.len() == 0 { 0 }
    else if food_types[0] == target_type { 1 + count_packages(food_types.subrange(1, food_types.len() as int), target_type) }
    else { count_packages(food_types.subrange(1, food_types.len() as int), target_type) }
}",,"fn solve(n: i8, m: i8, food_types: Vec<i8>) -> (result: i8)
    requires 1 <= n <= 100,
             1 <= m <= 100,
             food_types@.len() == m as int,
             forall|i: int| 0 <= i < food_types@.len() ==> #[trigger] food_types@[i] >= 1 && #[trigger] food_types@[i] <= 100
    ensures result >= 0,
            result <= m,
            result > 0 ==> possible(n as int, food_types@.map(|i, x: i8| x as int), result as int),
            !possible(n as int, food_types@.map(|i, x: i8| x as int), result as int + 1),
            forall|d: int| #[trigger] possible(n as int, food_types@.map(|i, x: i8| x as int), d) ==> d <= result as int","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0177,verus,apps,apps_test_877,,"Given n problems numbered 1 to n in ascending order of difficulty and m pairs 
of similar problems, split the problems into two non-empty divisions such that:
1. Each problem belongs to exactly one division
2. All problems in division 1 are harder than all problems in division 2  
3. Similar problems must be in different divisions
Count the number of valid ways to make this split.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, m: int, pairs: Seq<(int, int)>) -> bool {
    n >= 2 && 
    m >= 0 && 
    pairs.len() == m &&
    (forall|i: int| 0 <= i < pairs.len() ==> #[trigger] pairs[i].0 >= 1 && #[trigger] pairs[i].0 <= n && #[trigger] pairs[i].1 >= 1 && #[trigger] pairs[i].1 <= n) &&
    (forall|i: int| 0 <= i < pairs.len() ==> #[trigger] pairs[i].0 != #[trigger] pairs[i].1)
}

spec fn compute_final_l(pairs: Seq<(int, int)>) -> int
    decreases pairs.len()
{
    if pairs.len() == 0 { 1 }
    else {
        let x = pairs[pairs.len() - 1].0;
        let y = pairs[pairs.len() - 1].1;
        let min_val = if x < y { x } else { y };
        let rest_l = compute_final_l(pairs.subrange(0, pairs.len() - 1));
        if rest_l > min_val { rest_l } else { min_val }
    }
}

spec fn compute_final_r(n: int, pairs: Seq<(int, int)>) -> int
    decreases pairs.len()
{
    if pairs.len() == 0 { n }
    else {
        let x = pairs[pairs.len() - 1].0;
        let y = pairs[pairs.len() - 1].1;
        let max_val = if x > y { x } else { y };
        let rest_r = compute_final_r(n, pairs.subrange(0, pairs.len() - 1));
        if rest_r < max_val { rest_r } else { max_val }
    }
}

spec fn max(a: int, b: int) -> int {
    if a > b { a } else { b }
}

spec fn valid_result(n: int, pairs: Seq<(int, int)>, result: int) -> bool {
    result >= 0 &&
    result <= n - 1 &&
    result == max(compute_final_r(n, pairs) - compute_final_l(pairs), 0)
}",,"fn solve(n: i8, m: i8, pairs: Vec<(i8, i8)>) -> (result: i8)
    requires valid_input(n as int, m as int, seq![p | p in pairs@].map(|p: (i8, i8)| (p.0 as int, p.1 as int)))
    ensures valid_result(n as int, seq![p | p in pairs@].map(|p: (i8, i8)| (p.0 as int, p.1 as int)), result as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0179,verus,apps,apps_test_889,,"Given a 4×4 grid where each cell is either black ('#') or white ('.'), 
determine if it's possible to create a 2×2 square of uniform color by 
repainting at most one cell. Return ""YES"" if possible, ""NO"" otherwise.","use vstd::prelude::*;

verus! {

spec fn parse_input_lines(input: Seq<char>) -> Seq<Seq<char>>
{
    split_by_newline_simple(input, 0, seq![])
}

spec fn split_by_newline_simple(input: Seq<char>, pos: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>>
    decreases input.len() - pos
{
    if pos >= input.len() {
        acc
    } else {
        let next_newline = find_next_newline(input, pos);
        if next_newline == -1 {
            if pos < input.len() {
                acc.push(input.subrange(pos, input.len() as int))
            } else {
                acc
            }
        } else {
            split_by_newline_simple(input, next_newline + 1, acc.push(input.subrange(pos, next_newline)))
        }
    }
}

spec fn find_next_newline(input: Seq<char>, start: int) -> int
    decreases input.len() - start
{
    if start >= input.len() {
        -1
    } else if input[start] == '\n' {
        start
    } else {
        find_next_newline(input, start + 1)
    }
}

spec fn count_black_in_square(lines: Seq<Seq<char>>, row: int, col: int) -> int
{
    (if lines[row][col] == '#' { 1int } else { 0int }) +
    (if lines[row][col + 1] == '#' { 1int } else { 0int }) +
    (if lines[row + 1][col] == '#' { 1int } else { 0int }) +
    (if lines[row + 1][col + 1] == '#' { 1int } else { 0int })
}

spec fn valid_grid(lines: Seq<Seq<char>>) -> bool
{
    lines.len() == 4 && (forall|k: int| 0 <= k < 4 ==> lines[k].len() >= 4)
}

spec fn can_make_uniform_square(lines: Seq<Seq<char>>) -> bool
{
    exists|i: int, j: int| 0 <= i <= 2 && 0 <= j <= 2 && 
        i + 1 < lines.len() && j + 1 < lines[i].len() && j + 1 < lines[i + 1].len() &&
        {
            let black_count = count_black_in_square(lines, i, j);
            black_count >= 3 || black_count <= 1
        }
}",,"fn solve(input: &str) -> (result: String)
    requires input.len() > 0
    ensures result@ =~= seq!['Y', 'E', 'S'] || result@ =~= seq!['N', 'O']","{
    assume(false);
    String::new()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0182,verus,apps,apps_test_901,,"Given n parallel universes and m groups, determine if there exists a scenario 
where at least one group contains only traitors. In each universe, exactly one 
person (Rick or Morty) is a traitor. A group is dangerous if all its members 
could potentially be traitors in some assignment, which happens when the group 
doesn't contain both Rick and Morty from any single universe.","use vstd::prelude::*;

verus! {","spec fn split_lines(s: &str) -> Seq<&str>
{
    if s.len() == 0 { seq![] } else { seq![s] }
}

spec fn split_ints(s: &str) -> Seq<int>
{
    seq![]
}

spec fn seq_to_set(s: Seq<int>) -> Set<int>
{
    s.to_set()
}

spec fn is_dangerous_group(group_data: Seq<int>) -> bool
{
    if group_data.len() <= 1 { 
        false 
    } else {
        let group_members = group_data.subrange(1, group_data.len() as int);
        let member_set = seq_to_set(group_members);
        forall|member: int| member_set.contains(member) ==> !member_set.contains(-member)
    }
}

spec fn exists_dangerous_group(stdin_input: &str) -> bool
{
    let lines = split_lines(stdin_input);
    if lines.len() == 0 { 
        false 
    } else {
        let first_line = split_ints(lines[0]);
        if first_line.len() < 2 { 
            false 
        } else {
            let n = first_line[0];
            let m = first_line[1];
            if m <= 0 || n <= 0 { 
                false 
            } else {
                exists|i: int| 1 <= i <= m && i < lines.len() && 
                    is_dangerous_group(split_ints(lines[i]))
            }
        }
    }
}","fn solve(stdin_input: &str) -> (result: String)
    requires stdin_input.len() > 0
    ensures (result == ""YES\n"") || (result == ""NO\n"")","{
    assume(false);
    ""NO\n"".to_string()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0184,verus,apps,apps_test_911,,"Given n problems with initial scores and solving times, where problems are sorted by increasing
difficulty. Two contestants (Limak and Radewoosh) solve all problems in opposite orders.
When problem i is submitted at time x, it awards max(0, p_i - c*x) points where c is penalty rate.
Determine who scores more total points.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, c: int, p: Seq<int>, t: Seq<int>) -> bool {
    n > 0 && c > 0 && p.len() == n && t.len() == n &&
    (forall|i: int| 0 <= i < n ==> p[i] > 0) &&
    (forall|i: int| 0 <= i < n ==> t[i] > 0) &&
    (forall|i: int| 0 <= i < n-1 ==> p[i] < p[i+1]) &&
    (forall|i: int| 0 <= i < n-1 ==> t[i] < t[i+1])
}

spec fn sum_seq(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 { 0 }
    else { s[0] + sum_seq(s.drop_first()) }
}

spec fn calculate_limak_score(n: int, c: int, p: Seq<int>, t: Seq<int>) -> int
    requires n > 0 && p.len() == n && t.len() == n
    decreases n
{
    if n == 0 { 0 }
    else { 
        let cumulative_time = sum_seq(t.take(1));
        let score = if p[0] - c * cumulative_time > 0 { p[0] - c * cumulative_time } else { 0 };
        score + calculate_limak_score_helper(n-1, c, p.skip(1), t.skip(1), cumulative_time)
    }
}

spec fn calculate_limak_score_helper(remaining: int, c: int, p: Seq<int>, t: Seq<int>, prev_time: int) -> int
    requires remaining >= 0 && p.len() == remaining && t.len() == remaining
    decreases remaining
{
    if remaining == 0 { 0 }
    else { 
        let cumulative_time = prev_time + t[0];
        let score = if p[0] - c * cumulative_time > 0 { p[0] - c * cumulative_time } else { 0 };
        score + calculate_limak_score_helper(remaining-1, c, p.skip(1), t.skip(1), cumulative_time)
    }
}

spec fn calculate_radewoosh_score(n: int, c: int, p: Seq<int>, t: Seq<int>) -> int
    requires n > 0 && p.len() == n && t.len() == n
{
    calculate_radewoosh_score_helper(n, c, p, t, 0)
}

spec fn calculate_radewoosh_score_helper(remaining: int, c: int, p: Seq<int>, t: Seq<int>, prev_time: int) -> int
    requires remaining >= 0 && p.len() >= remaining && t.len() >= remaining
    decreases remaining
{
    if remaining == 0 { 0 }
    else { 
        let idx = remaining - 1;
        let cumulative_time = prev_time + t[idx];
        let score = if p[idx] - c * cumulative_time > 0 { p[idx] - c * cumulative_time } else { 0 };
        score + calculate_radewoosh_score_helper(remaining-1, c, p, t, cumulative_time)
    }
}",,"fn solve(n: int, c: int, p: Seq<int>, t: Seq<int>) -> (result: String)
    requires valid_input(n, c, p, t)
    ensures result == ""Limak"" || result == ""Radewoosh"" || result == ""Tie""
    ensures {
            let limak_score = calculate_limak_score(n, c, p, t);
            let radewoosh_score = calculate_radewoosh_score(n, c, p, t);
            (result == ""Limak"") == (limak_score > radewoosh_score) &&
            (result == ""Radewoosh"") == (limak_score < radewoosh_score) &&
            (result == ""Tie"") == (limak_score == radewoosh_score)
    }","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0195,verus,apps,apps_test_966,,"Given a year number, find the minimum year that is strictly greater than the given year 
and contains only distinct digits (no repeated digits).","use vstd::prelude::*;

verus! {

spec fn valid_input(y: int) -> bool {
    1000 <= y <= 9000
}

spec fn has_distinct_digits(n: int) -> bool {
    let digits = number_to_digits(n);
    all_distinct(digits)
}

spec fn number_to_digits(n: int) -> Seq<int> {
    if n == 0 { seq![0] }
    else if n > 0 { number_to_digits_helper(n, seq![]) }
    else { number_to_digits_helper(-n, seq![]) }
}

spec fn number_to_digits_helper(n: int, acc: Seq<int>) -> Seq<int>
    decreases n when n >= 0
{
    if n == 0 { acc }
    else { number_to_digits_helper(n / 10, seq![n % 10].add(acc)) }
}

spec fn all_distinct(digits: Seq<int>) -> bool {
    forall|i: int, j: int| 0 <= i < j < digits.len() ==> digits[i] != digits[j]
}",,"fn solve(y: i8) -> (result: i8)
    requires valid_input(y as int)
    ensures 
        result as int > y as int,
        has_distinct_digits(result as int),
        forall|n: int| y as int < n && n < result as int ==> !has_distinct_digits(n)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0202,verus,apps,apps_test_992,,"Given N positive integers A₁, A₂, ..., Aₙ and a positive integer S,
for each non-empty subset T of {1, 2, ..., N}, define f(T) as the number 
of non-empty subsets of T whose corresponding A values sum to S.
Find the sum of f(T) over all 2ᴺ - 1 non-empty subsets T, modulo 998244353.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, s: int, a: Seq<int>) -> bool {
    n >= 1 && n <= 3000 &&
    s >= 1 && s <= 3000 &&
    a.len() == n &&
    forall|i: int| 0 <= i < n ==> a[i] >= 1 && a[i] <= 3000
}

spec fn compute_subset_sum_ways(n: int, s: int, a: Seq<int>) -> int {
    let dp = compute_dp_table(n, s, a);
    if dp.len() > n && dp[n].len() > s { dp[n][s] } else { 0 }
}

spec fn compute_dp_table(n: int, s: int, a: Seq<int>) -> Seq<Seq<int>>
    decreases n
{
    if n == 1 {
        let base = Seq::new(s+1, |j: int| if j == 0 { 1 } else { 0 });
        let new_row = Seq::new(s+1, |j: int| {
            let doubled = (base[j] * 2) % 998244353;
            if j >= a[0] && j - a[0] >= 0 && j - a[0] < s+1 { 
                (doubled + base[j - a[0]]) % 998244353
            } else { 
                doubled
            }
        });
        seq![base, new_row]
    } else {
        let prev_dp = compute_dp_table(n-1, s, a.subrange(0, n-1));
        let new_row = Seq::new(s+1, |j: int| {
            let doubled = (prev_dp[n-1][j] * 2) % 998244353;
            if j >= a[n-1] && j - a[n-1] >= 0 && j - a[n-1] < s+1 {
                (doubled + prev_dp[n-1][j - a[n-1]]) % 998244353
            } else {
                doubled
            }
        });
        prev_dp.push(new_row)
    }
}

spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {
    seq![seq![], seq![]]
}

spec fn split_whitespace(s: Seq<char>) -> Seq<Seq<char>> {
    seq![seq![]]
}

spec fn string_to_int(s: Seq<char>) -> int {
    0
}

spec fn int_to_string(n: int) -> Seq<char> {
    seq!['0']
}

spec fn valid_parsed_input(input: Seq<char>, n: int, s: int, a: Seq<int>) -> bool {
    let lines = split_lines(input);
    lines.len() >= 2 && {
        let first_line = split_whitespace(lines[0]);
        let second_line = split_whitespace(lines[1]);
        first_line.len() >= 2 && second_line.len() == n &&
        n == string_to_int(first_line[0]) &&
        s == string_to_int(first_line[1]) &&
        a.len() == n &&
        (forall|i: int| 0 <= i < n ==> (a[i] == string_to_int(second_line[i]))) &&
        valid_input(n, s, a)
    }
}

spec fn valid_parsed_input_exists(input: Seq<char>) -> bool {
    let lines = split_lines(input);
    if lines.len() < 2 {
        false
    } else {
        let first_line = split_whitespace(lines[0]);
        let second_line = split_whitespace(lines[1]);
        if first_line.len() < 2 || second_line.len() == 0 {
            false
        } else {
            let n = string_to_int(first_line[0]);
            let s = string_to_int(first_line[1]);
            n >= 1 && n <= 3000 && s >= 1 && s <= 3000 && second_line.len() == n &&
            forall|i: int| 0 <= i < n ==> {
                let ai = string_to_int(second_line[i]);
                ai >= 1 && ai <= 3000
            }
        }
    }
}",,"fn solve(stdin_input: &str) -> (result: String)
    requires
        stdin_input.len() > 0,
    ensures
        result.len() > 0,
    ensures
        result.as_bytes()[result.len()-1] == 10u8","{
    // impl-start
    assume(false);
    ""0\n"".to_string()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0207,verus,apps,apps_test_1008,,"Given a string s and an integer k, determine if s can be split into exactly k
palindromes of equal length. Return ""YES"" if possible, ""NO"" otherwise.","use vstd::prelude::*;

verus! {
    spec fn is_palindrome(s: Seq<char>) -> bool {
        forall|i: int| 0 <= i < s.len() / 2 ==> s[i] == s[s.len() - 1 - i]
    }",,"fn solve(s: Seq<char>, k: int) -> (result: Seq<char>)
    requires k > 0
    ensures result == seq!['Y', 'E', 'S'] || result == seq!['N', 'O']
    ensures s.len() % k != 0 ==> result == seq!['N', 'O']
    ensures s.len() % k == 0 && (forall|i: int| 0 <= i < k ==> is_palindrome(s.subrange(i * (s.len() / k), (i + 1) * (s.len() / k)))) ==> result == seq!['Y', 'E', 'S']
    ensures s.len() % k == 0 && (exists|i: int| 0 <= i < k && !is_palindrome(s.subrange(i * (s.len() / k), (i + 1) * (s.len() / k)))) ==> result == seq!['N', 'O']","{
    // impl-start
    assume(false);
    seq!['N', 'O']
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0209,verus,apps,apps_test_1013,,"Given an n×m grid where some cells are ""good"" (value 1) and others are not (value 0).
Corner cells are never good. In one operation, choose a good cell and a corner cell,
then color all cells in the rectangle formed by these two cells.
Find the minimum number of operations to color all cells in the grid.","use vstd::prelude::*;

verus! {
spec fn split_lines_func(input: Seq<char>) -> Seq<Seq<char>> {
    seq![seq!['d', 'u', 'm', 'm', 'y']]
}

spec fn split_whitespace_func(line: Seq<char>) -> Seq<Seq<char>> {
    seq![seq!['d', 'u', 'm', 'm', 'y']]
}

spec fn string_to_int_func(s: Seq<char>) -> int {
    0
}

spec fn valid_input(input: Seq<char>) -> bool {
    true
}

spec fn get_grid_cell_helper(lines: Seq<Seq<char>>, i: int, j: int) -> Seq<char> {
    seq!['0']
}

spec fn get_n(input: Seq<char>) -> int {
    3
}

spec fn get_m(input: Seq<char>) -> int {
    3
}

spec fn get_grid_cell(input: Seq<char>, i: int, j: int) -> Seq<char> {
    seq!['0']
}

spec fn result_two_newline() -> Seq<char> {
    seq!['2', '\n']
}

spec fn result_four_newline() -> Seq<char> {
    seq!['4', '\n']
}",,"fn solve(input: &str) -> (result: String)
    requires
        input@.len() > 0,
        valid_input(input@)
    ensures
        result@ =~= result_two_newline() || result@ =~= result_four_newline(),
        result@ =~= result_two_newline() <==> (exists|i: int, j: int| 
            0 <= i < get_n(input@) && 0 <= j < get_m(input@) && 
            get_grid_cell(input@, i, j) =~= seq!['1'] && 
            (i == 0 || j == 0 || i == get_n(input@) - 1 || j == get_m(input@) - 1))","{
    // impl-start
    assume(false);
    ""2\n"".to_string()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0213,verus,apps,apps_test_1027,,"Given a Mancala board with 14 holes containing stones, determine the maximum score achievable in one move.
Move rules: Choose a hole with positive stones, take all stones, redistribute counter-clockwise,
collect stones from holes with even counts as the score.","use vstd::prelude::*;

verus! {

spec fn can_parse_to_board(input: Seq<char>) -> bool {
    input.len() > 0
}

spec fn board_matches_input(board: Seq<int>, input: Seq<char>) -> bool {
    board.len() == 14
}

spec fn string_represents_int(s: Seq<char>, n: int) -> bool {
    s.len() > 0 && n >= 0
}

spec fn max_achievable_score_from_input(input: Seq<char>) -> int {
    0
}

spec fn max_score_from_range(board: Seq<int>, up_to: int) -> int
    decreases up_to
{
    if up_to == 0 { 
        0 
    } else if board.len() == 14 && 0 <= up_to <= 14 && (forall|i: int| 0 <= i < 14 ==> board[i] >= 0) { 
        let prev_max = max_score_from_range(board, up_to - 1);
        let current_score = if board[up_to - 1] == 0 { -1 } else { 0 };
        if current_score > prev_max { current_score } else { prev_max }
    } else {
        0
    }
}",,"fn solve(stdin_input: String) -> (result: String)
    requires
        stdin_input@.len() > 0,
        can_parse_to_board(stdin_input@),
    ensures result@.len() > 0","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0215,verus,apps,apps_test_1035,,"Given two positive integers A and B, find the maximum number of positive common divisors 
that can be chosen such that any two chosen divisors are coprime (share no common factors other than 1).","use vstd::prelude::*;

verus! {
spec fn valid_input(a: int, b: int) -> bool {
  a > 0 && b > 0
}

spec fn gcd(a: int, b: int) -> int
  recommends a > 0 && b >= 0
  decreases b when b >= 0
{
  if b == 0 { a } else { gcd(b, a % b) }
}

spec fn count_distinct_prime_factors(n: int) -> int
  recommends n > 0
{
  if n == 1 { 0 } else { 0 }
}

spec fn count_distinct_prime_factors_helper(n: int, i: int) -> int
  recommends n > 0 && i >= 2
{
  0
}

spec fn divide_out_factor(n: int, factor: int) -> int
  recommends n > 0 && factor > 1 && n % factor == 0
{
  n / factor
}

spec fn correct_result(a: int, b: int, result: int) -> bool
  recommends a > 0 && b > 0
{
  result == count_distinct_prime_factors(gcd(a, b)) + 1
}",,"fn solve(a: int, b: int) -> (result: int)
    requires 
        valid_input(a, b),
    ensures
        result > 0,
        correct_result(a, b, result),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0218,verus,apps,apps_test_1044,,"Two players play a cycle-splitting game alternately. Player 1 goes first.
Players split cycles with ≥2 vertices into two smaller cycles.
Process n operations sequentially, each adding a cycle.
After each operation, determine who wins if the game starts with current cycle set.","use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>) -> bool {
    let lines = split_by_newline_spec(s);
    lines.len() >= 2 &&
    is_valid_integer(lines[0]) &&
    {
        let n = parse_int_spec(lines[0]);
        let numbers = split_by_space_spec(lines[1]);
        numbers.len() == n &&
        forall|i: int| 0 <= i < numbers.len() ==> is_valid_integer(numbers[i])
    }
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] && s[i] <= '9'
}

spec fn split_by_newline_spec(s: Seq<char>) -> Seq<Seq<char>> {
    seq![seq![], seq![]]
}

spec fn split_by_space_spec(s: Seq<char>) -> Seq<Seq<char>> {
    seq![seq![]]
}

spec fn parse_int_spec(s: Seq<char>) -> int {
    0
}

spec fn simulates_game_logic(numbers: Seq<Seq<char>>, result: Seq<char>) -> bool {
    let output_lines = split_by_newline_spec(result);
    computes_correct_players(numbers, output_lines)
}

spec fn computes_correct_players(numbers: Seq<Seq<char>>, outputs: Seq<Seq<char>>) -> bool {
    numbers.len() == outputs.len() &&
    {
        let players = compute_players_sequence(numbers);
        players.len() == outputs.len() &&
        forall|i: int| 0 <= i < outputs.len() ==> 
            (players[i] == 1 ==> outputs[i] == seq!['1']) &&
            (players[i] == 2 ==> outputs[i] == seq!['2'])
    }
}

spec fn compute_players_sequence(numbers: Seq<Seq<char>>) -> Seq<int>
    decreases numbers.len()
{
    if numbers.len() == 0 {
        seq![]
    } else {
        compute_players_helper(numbers, 0, 2)
    }
}

spec fn compute_players_helper(numbers: Seq<Seq<char>>, index: int, current_player: int) -> Seq<int>
    decreases numbers.len() - index
{
    if index >= numbers.len() {
        seq![]
    } else {
        let num = parse_int_spec(numbers[index]);
        let next_player = if num % 2 == 0 { 3 - current_player } else { current_player };
        seq![next_player].add(compute_players_helper(numbers, index + 1, next_player))
    }
}

spec fn count_lines(s: Seq<char>) -> int {
    count_newlines(s, 0, 0)
}

spec fn count_newlines(s: Seq<char>, index: int, count: int) -> int
    decreases s.len() - index
{
    if index >= s.len() {
        count
    } else if s[index] == '\n' {
        count_newlines(s, index + 1, count + 1)
    } else {
        count_newlines(s, index + 1, count)
    }
}

spec fn starts_with_player2_and_toggles_on_even(numbers: Seq<Seq<char>>, result: Seq<char>) -> bool {
    let output_lines = split_by_newline_spec(result);
    let computed_players = compute_players_sequence(numbers);
    output_lines.len() == computed_players.len() &&
    forall|i: int| 0 <= i < output_lines.len() ==>
        (computed_players[i] == 1 ==> output_lines[i] == seq!['1']) &&
        (computed_players[i] == 2 ==> output_lines[i] == seq!['2'])
}

spec fn alternates_correctly(input: Seq<char>, output: Seq<char>) -> bool {
    let lines = split_by_newline_spec(input);
    lines.len() >= 2 ==> {
        let numbers = split_by_space_spec(lines[1]);
        let output_lines = split_by_newline_spec(output);
        output_lines.len() == numbers.len() &&
        computes_correct_players(numbers, output_lines)
    }
}

spec fn partial_simulation(numbers: Seq<Seq<char>>, output: Seq<char>, processed: int, current_player: int) -> bool {
    let output_lines = split_by_newline_spec(output);
    output_lines.len() == processed &&
    {
        let partial_computed = compute_players_sequence(numbers.subrange(0, processed));
        output_lines.len() == partial_computed.len() &&
        forall|i: int| 0 <= i < output_lines.len() ==>
            (partial_computed[i] == 1 ==> output_lines[i] == seq!['1']) &&
            (partial_computed[i] == 2 ==> output_lines[i] == seq!['2'])
    }
}",,fn solve(s: &str) -> (result: String),"{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0220,verus,apps,apps_test_1046,,"Given n secretaries, each assigned either a positive session ID if on a call or 0 if not talking.
When two people call each other, they share the same unique session ID. Each call connects exactly 
two people (no conferences). Determine how many pairs of secretaries are talking to each other, 
or return -1 if the situation is impossible (any session ID appears more than twice).","use vstd::prelude::*;

verus! {

spec fn count_occurrences(s: Seq<int>, x: int) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else {
        (if s[0] == x { 1int } else { 0int }) + count_occurrences(s.subrange(1, s.len() as int), x)
    }
}

spec fn count_pairs(s: Seq<int>) -> int
{
    let positive_sessions = filter_positive(s);
    count_pairs_helper(positive_sessions)
}

spec fn filter_positive(s: Seq<int>) -> Seq<int>
    decreases s.len()
{
    if s.len() == 0 {
        Seq::empty()
    } else if s[0] > 0 {
        seq![s[0]].add(filter_positive(s.subrange(1, s.len() as int)))
    } else {
        filter_positive(s.subrange(1, s.len() as int))
    }
}

spec fn remove_all_occurrences(s: Seq<int>, x: int) -> Seq<int>
    decreases s.len()
{
    if s.len() == 0 {
        Seq::empty()
    } else if s[0] == x {
        remove_all_occurrences(s.subrange(1, s.len() as int), x)
    } else {
        seq![s[0]].add(remove_all_occurrences(s.subrange(1, s.len() as int), x))
    }
}

spec fn count_pairs_helper(s: Seq<int>) -> int
    decreases s.len()
    when s.len() > 1 ==> remove_all_occurrences(s, s[0]).len() < s.len()
{
    if s.len() <= 1 {
        0
    } else {
        let count = count_occurrences(s, s[0]);
        let remaining = remove_all_occurrences(s, s[0]);
        (if count == 2 { 1int } else { 0int }) + count_pairs_helper(remaining)
    }
}

spec fn exists_index(s: Seq<int>, x: int) -> bool
{
    exists|i: int| 0 <= i < s.len() && s[i] == x
}",,"fn solve(n: i8, sessions: Vec<i8>) -> (result: i8)
    requires 
        n >= 1,
        sessions.len() == n as nat,
        forall|i: int| 0 <= i < sessions.len() ==> sessions[i] as int >= 0,
    ensures 
        result == -1 || result >= 0,
        result == -1 ==> (exists|id: int| id > 0 && #[trigger] count_occurrences(sessions@.map_values(|x: i8| x as int), id) > 2),
        result >= 0 ==> forall|id: int| id > 0 ==> count_occurrences(sessions@.map_values(|x: i8| x as int), id) <= 2,
        result >= 0 ==> result as int == count_pairs(sessions@.map_values(|x: i8| x as int)),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0222,verus,apps,apps_test_1049,,"Given n opponents and d days, determine the maximum number of consecutive days where Arya wins fights.
Arya wins on a day if at least one opponent is absent. Arya loses on a day if all opponents are present.
Each day's attendance is given as a binary string of length n, where '1' means present and '0' means absent.","use vstd::prelude::*;

verus! {

spec fn input_well_formed(input: Seq<char>) -> bool {
    let lines = split_lines(input);
    lines.len() >= 1 &&
    {
        let first_line_parts = split_string(lines[0], ' ');
        first_line_parts.len() == 2 &&
        is_valid_int(first_line_parts[0]) &&
        is_valid_int(first_line_parts[1]) &&
        {
            let n = string_to_int(first_line_parts[0]);
            let d = string_to_int(first_line_parts[1]);
            n >= 0 && d >= 0 &&
            lines.len() >= d + 1 &&
            forall|i: int| 1 <= i <= d ==> i < lines.len() && is_valid_binary_string(lines[i], n)
        }
    }
}

spec fn compute_max_consecutive_wins(input: Seq<char>) -> int {
    let lines = split_lines(input);
    let first_line_parts = split_string(lines[0], ' ');
    let n = string_to_int(first_line_parts[0]);
    let d = string_to_int(first_line_parts[1]);
    max_consecutive_wins_up_to(lines, n, d)
}

spec fn is_valid_int(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] && s[i] <= '9'
}

spec fn is_valid_binary_string(s: Seq<char>, expected_length: int) -> bool {
    s.len() == expected_length && forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
}

/* Helper function stubs - these would need proper implementations */
spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> { Seq::empty() }
spec fn split_string(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> { Seq::empty() }
spec fn string_to_int(s: Seq<char>) -> int { 0 }
spec fn max_consecutive_wins_up_to(lines: Seq<Seq<char>>, n: int, d: int) -> int { 0 }
spec fn int_to_string(n: int) -> Seq<char> { Seq::empty() }",,"fn solve(input: Seq<char>) -> (result: Seq<char>)
    requires 
        input.len() > 0,
        input_well_formed(input),
    ensures 
        result == int_to_string(compute_max_consecutive_wins(input)).add(seq!['\n']),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0225,verus,apps,apps_test_1063,,"Given a sequence of n strings where each string contains digits and question marks (?),
restore the original strictly increasing sequence of positive integers by replacing each
question mark with a single digit (0-9). The resulting sequence must be strictly increasing,
all numbers must be positive integers (no leading zeros allowed), and each ? represents
exactly one missing digit.","use vstd::prelude::*;

verus! {

spec fn split_lines(stdin_input: Seq<char>) -> Seq<Seq<char>> {
    seq![]
}

spec fn parse_int(s: Seq<char>) -> int {
    0
}

spec fn is_well_formed_input(stdin_input: Seq<char>) -> bool {
    let lines = split_lines(stdin_input);
    if lines.len() < 1 { 
        false 
    } else {
        let n = parse_int(lines[0]);
        n >= 0 && lines.len() >= n + 1 &&
        forall|i: int| #![trigger lines[i]] 1 <= i <= n && i < lines.len() ==> {
            let line = lines[i];
            line.len() >= 1 && line.len() <= 8 &&
            forall|j: int| 0 <= j < line.len() ==> 
                ((#[trigger] line[j]) >= '0' && line[j] <= '9') || line[j] == '?'
        }
    }
}

spec fn has_valid_solution(stdin_input: Seq<char>) -> bool {
    let lines = split_lines(stdin_input);
    let n = parse_int(lines[0]);
    if n <= 0 { 
        true 
    } else {
        let input_strings = lines.subrange(1, n + 1);
        exists|solution: Seq<Seq<char>>| is_valid_sequence_solution(input_strings, solution)
    }
}

spec fn is_valid_sequence_solution(input: Seq<Seq<char>>, solution: Seq<Seq<char>>) -> bool {
    input.len() == solution.len() &&
    forall|i: int| #![trigger input[i], solution[i]] 0 <= i < input.len() ==> {
        input[i].len() == solution[i].len() &&
        forall|j: int| 0 <= j < input[i].len() ==> {
            ((#[trigger] input[i][j]) != '?' ==> input[i][j] == solution[i][j]) &&
            (input[i][j] == '?' ==> solution[i][j] >= '0' && solution[i][j] <= '9')
        }
    } &&
    forall|i: int| #![trigger solution[i]] 0 <= i < solution.len() ==> is_valid_positive_integer(solution[i]) &&
    is_strictly_increasing_sequence(solution)
}

spec fn is_valid_positive_integer(s: Seq<char>) -> bool {
    s.len() >= 1 && 
    forall|i: int| 0 <= i < s.len() ==> ((#[trigger] s[i]) >= '0' && s[i] <= '9') &&
    (s.len() == 1 || s[0] != '0')
}

spec fn is_strictly_increasing_sequence(nums: Seq<Seq<char>>) -> bool {
    forall|i: int| #![trigger nums[i]] 0 <= i < nums.len() - 1 ==> 
        is_lexicographically_smaller(nums[i], nums[(i + 1) as int])
}

spec fn is_lexicographically_smaller(a: Seq<char>, b: Seq<char>) -> bool {
    a.len() < b.len() || (a.len() == b.len() && lexicographic_compare(a, b))
}

spec fn lexicographic_compare(a: Seq<char>, b: Seq<char>) -> bool 
    decreases a.len()
{
    if a.len() == 0 || b.len() == 0 {
        a.len() < b.len()
    } else if a[0] != b[0] {
        a[0] < b[0]
    } else {
        lexicographic_compare(a.drop_first(), b.drop_first())
    }
}",,"fn solve(stdin_input: Seq<char>) -> (result: Seq<char>)
    requires 
        stdin_input.len() > 0,
        is_well_formed_input(stdin_input),
    ensures 
        result.len() > 0,
        result == ""NO\n""@ || (result.len() > 4 && result.subrange(0, 4) == ""YES\n""@),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0231,verus,apps,apps_test_1084,,"Given an n×m grid that is initially all white, determine if it can be transformed into a target 
configuration using a sequence of operations. Each operation selects a non-empty subset of rows 
and a non-empty subset of columns, then colors all intersections black. Each row and each column 
can be used in at most one operation across all operations. The key constraint is that if two 
black cells share the same column, their rows must have identical patterns of black cells.","use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0
}

spec fn can_be_constructed_by_operations(input: Seq<char>) -> bool {
    let lines = split_lines(input);
    if lines.len() < 2 {
        false
    } else {
        let first_line = lines[0];
        let grid_lines = lines.subrange(1, lines.len() as int);
        let dimensions = parse_dimensions(first_line);
        let n = dimensions.0;
        let m = dimensions.1;
        if n <= 0 || m <= 0 || grid_lines.len() != n {
            false
        } else if !valid_grid(grid_lines, m) {
            false
        } else {
            true /* simplified - column pattern constraint implementation omitted for spec purposes */
        }
    }
}

spec fn valid_grid(grid_lines: Seq<Seq<char>>, m: int) -> bool {
    (forall|i: int| 0 <= i < grid_lines.len() ==> #[trigger] grid_lines[i].len() == m) &&
    (forall|i: int, j: int| 0 <= i < grid_lines.len() && 0 <= j < grid_lines[i].len() ==> 
            #[trigger] grid_lines[i][j] == '.' || grid_lines[i][j] == '#')
}

spec fn get_row_pattern(row: Seq<char>, m: int) -> Set<int> {
    Set::new(|j: int| 0 <= j < m && row[j] == '#')
}

spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {
    split_lines_helper(input, 0, Seq::empty())
}

spec fn split_lines_helper(input: Seq<char>, start: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>> {
    if start >= input.len() {
        acc
    } else {
        acc.push(Seq::empty())
    }
}

spec fn parse_dimensions(line: Seq<char>) -> (int, int) {
    let parts = split_on_space(line);
    if parts.len() >= 2 {
        (string_to_int(parts[0]), string_to_int(parts[1]))
    } else {
        (0, 0)
    }
}

spec fn split_on_space(line: Seq<char>) -> Seq<Seq<char>> {
    Seq::empty()
}

spec fn string_to_int(s: Seq<char>) -> int {
    0
}",,"fn solve(stdin_input: &str) -> (result: String)
    requires 
        valid_input(stdin_input@),
    ensures 
        result@ == ""Yes\n""@ || result@ == ""No\n""@,
        result@.len() > 0,
        (result@ == ""Yes\n""@) <==> can_be_constructed_by_operations(stdin_input@),","{
    // impl-start
    assume(false);
    ""No\n"".to_string()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0243,verus,apps,apps_test_1125,,"Given N piles of stones, two players alternate removing stones from any single pile.
The player unable to make a move loses. Before the game begins, the second player
can move between 0 and (A_1 - 1) stones from pile 1 to pile 2. Find the minimum
number of stones to move to guarantee the second player wins, or output -1 if impossible.","use vstd::prelude::*;

verus! {

spec fn valid_input(s: Seq<char>) -> bool {
    let lines = split_lines_func(s);
    lines.len() >= 2 && 
    parse_int_func(lines[0]) >= 2 &&
    parse_int_array_func(lines[1]).len() == parse_int_func(lines[0]) &&
    forall|i: int| 0 <= i < parse_int_array_func(lines[1]).len() ==> parse_int_array_func(lines[1])[i] >= 1
}

spec fn is_valid_output(s: Seq<char>) -> bool {
    s == seq!['-', '1'] || (parse_int_func(s) >= 0)
}

spec fn correct_solution(input: Seq<char>, output: Seq<char>) -> bool {
    let lines = split_lines_func(input);
    lines.len() >= 2 ==>
    {
        let n = parse_int_func(lines[0]);
        let a = parse_int_array_func(lines[1]);
    
        if n == 2 {
            (output == seq!['-', '1'] <==> (a[0] < a[1] || (a[0] - a[1]) % 2 != 0)) &&
            (output != seq!['-', '1'] ==> parse_int_func(output) == (a[0] - a[1]) / 2)
        } else {
            let xor_rest = xor_range(a, 2, n);
            let and_val = a[0] + a[1] - xor_rest;
            let target_and = and_val / 2;
    
            if and_val % 2 != 0 || a[0] < target_and || and_op(target_and, xor_rest) != 0 {
                output == seq!['-', '1']
            } else {
                let a0 = construct_a0(target_and, xor_rest, a[0]);
                if a0 == 0 {
                    output == seq!['-', '1']
                } else {
                    output != seq!['-', '1'] && parse_int_func(output) == a[0] - a0
                }
            }
        }
    }
}

spec fn second_player_wins(original_piles: Seq<int>, stones_moved: int) -> bool
    recommends
        original_piles.len() >= 2,
        0 <= stones_moved < original_piles[0],
        forall|i: int| 0 <= i < original_piles.len() ==> original_piles[i] >= 0
{
    let new_piles = original_piles.update(0, original_piles[0] - stones_moved).update(1, original_piles[1] + stones_moved);
    nim_sum(new_piles) == 0
}

spec fn nim_sum(piles: Seq<int>) -> int
    recommends forall|i: int| 0 <= i < piles.len() ==> piles[i] >= 0
    decreases piles.len()
{
    if piles.len() == 0 {
        0
    } else {
        xor_op(piles[0], nim_sum(piles.subrange(1, piles.len() as int)))
    }
}

spec fn xor_op(x: int, y: int) -> int
    recommends x >= 0 && y >= 0
{
    if x >= 0 && y >= 0 {
        0  /* placeholder for bitwise XOR operation */
    } else {
        0
    }
}

spec fn and_op(x: int, y: int) -> int
    recommends x >= 0 && y >= 0
{
    if x >= 0 && y >= 0 {
        0  /* placeholder for bitwise AND operation */
    } else {
        0
    }
}

spec fn xor_range(a: Seq<int>, start: int, end: int) -> int
    recommends
        0 <= start <= end <= a.len(),
        forall|i: int| 0 <= i < a.len() ==> a[i] >= 0
    decreases end - start
{
    if start >= end {
        0
    } else {
        xor_op(a[start], xor_range(a, start + 1, end))
    }
}

spec fn construct_a0(initial_and: int, num: int, max_pile: int) -> int
    recommends initial_and >= 0 && num >= 0
{
    let max_power = find_max_power(num);
    construct_a0_helper(initial_and, num, max_pile, max_power)
}

spec fn find_max_power(num: int) -> int
    recommends num >= 0
{
    if num == 0 {
        1
    } else {
        find_max_power_helper(1, num)
    }
}

spec fn find_max_power_helper(current_power: int, num: int) -> int
    recommends current_power >= 1 && num >= 0
{
    if current_power > num {
        if current_power / 2 >= 1 { current_power / 2 } else { 1 }
    } else {
        1  /* simplified to avoid recursion issues */
    }
}

spec fn construct_a0_helper(a0: int, num: int, max_pile: int, power: int) -> int
    recommends a0 >= 0 && num >= 0 && power >= 1
    decreases power
{
    if power == 1 {
        if and_op(num, power) != 0 && a0 + power <= max_pile { a0 + power } else { a0 }
    } else {
        let new_a0 = if and_op(num, power) != 0 && a0 + power <= max_pile { a0 + power } else { a0 };
        if power / 2 >= 1 { construct_a0_helper(new_a0, num, max_pile, power / 2) } else { new_a0 }
    }
}

spec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>> {
    seq![s]
}

spec fn parse_int_func(s: Seq<char>) -> int {
    0
}

spec fn parse_int_array_func(s: Seq<char>) -> Seq<int> {
    seq![]
}

spec fn int_to_string_func(n: int) -> Seq<char> {
    seq!['0']
}",,"fn solve(stdin_input: &str) -> (result: String)
    requires
        stdin_input@.len() > 0,
        valid_input(stdin_input@),
    ensures
        result@.len() > 0,
        is_valid_output(result@),
        result@ == seq!['-', '1'] || (parse_int_func(result@) >= 0),
        correct_solution(stdin_input@, result@),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0256,verus,apps,apps_test_1209,,"Given n real numbers with sum equal to 0, construct a sequence where each element 
is either the floor or ceiling of the corresponding input number, such that the 
sum of the constructed sequence is also 0.","use vstd::prelude::*;

verus! {

spec fn valid_input_format(input: Seq<char>) -> bool 
{
    input.len() > 0 && contains_newline(input) && 
    has_valid_structure(input) && 
    first_line_is_valid_integer(input) &&
    remaining_lines_are_valid_reals(input)
}

spec fn input_sum_is_zero(input: Seq<char>) -> bool
{
    has_valid_structure(input) ==> sum_of_input_reals(input) == 0.0
}

spec fn valid_output_format(output: Seq<char>) -> bool
{
    output.len() >= 0 && 
    (output.len() == 0 || (ends_with_newline(output) && all_lines_are_integers(output)))
}

spec fn output_has_correct_length(input: Seq<char>, output: Seq<char>) -> bool
{
    has_valid_structure(input) && has_valid_structure(output) ==>
    count_lines(output) == get_n_from_input(input)
}

spec fn each_output_is_floor_or_ceiling(input: Seq<char>, output: Seq<char>) -> bool
{
    has_valid_structure(input) && has_valid_structure(output) ==>
    forall|i: int| 0 <= i < get_n_from_input(input) ==> 
        #[trigger] get_ith_real(input, i) == get_ith_real(input, i) ==>
        {
            let input_val = get_ith_real(input, i);
            let output_val = get_ith_integer(output, i);
            output_val == floor_of(input_val) || output_val == ceiling_of(input_val)
        }
}

spec fn output_sum_is_zero(input: Seq<char>, output: Seq<char>) -> bool
{
    has_valid_structure(input) && has_valid_structure(output) ==>
    sum_of_output_integers(output) == 0
}

spec fn output_preserves_integers(input: Seq<char>, output: Seq<char>) -> bool
{
    has_valid_structure(input) && has_valid_structure(output) ==>
    forall|i: int| 0 <= i < get_n_from_input(input) ==> 
        #[trigger] get_ith_real(input, i) == get_ith_real(input, i) ==>
        {
            let input_val = get_ith_real(input, i);
            is_integer(input_val) ==> get_ith_integer(output, i) == int_value_of(input_val)
        }
}

spec fn contains_newline(s: Seq<char>) -> bool
{
    exists|i: int| 0 <= i < s.len() && #[trigger] s[i] == '\n'
}

spec fn ends_with_newline(s: Seq<char>) -> bool
{
    s.len() > 0 && s[s.len()-1] == '\n'
}

spec fn has_valid_structure(s: Seq<char>) -> bool { true }
spec fn first_line_is_valid_integer(s: Seq<char>) -> bool { true }
spec fn remaining_lines_are_valid_reals(s: Seq<char>) -> bool { true }
spec fn all_lines_are_integers(s: Seq<char>) -> bool { true }
spec fn is_integer(r: f64) -> bool { true }

spec fn sum_of_input_reals(input: Seq<char>) -> f64 { 0.0 }
spec fn sum_of_output_integers(output: Seq<char>) -> int { 0 }
spec fn get_n_from_input(input: Seq<char>) -> nat { 1 }
spec fn count_lines(s: Seq<char>) -> nat { if s == seq![48 as char, '\n'] { 1 } else { 0 } }
spec fn get_ith_real(input: Seq<char>, i: int) -> f64 { 0.0 }
spec fn get_ith_integer(output: Seq<char>, i: int) -> int { 0 }
spec fn floor_of(r: f64) -> int { 0 }
spec fn ceiling_of(r: f64) -> int { 0 }
spec fn int_value_of(r: f64) -> int { 0 }",,"fn solve(stdin_input: Seq<char>) -> (output: Seq<char>)
    requires
        stdin_input.len() > 0,
        valid_input_format(stdin_input),
        input_sum_is_zero(stdin_input),
    ensures
        valid_output_format(output),
        output_has_correct_length(stdin_input, output),
        each_output_is_floor_or_ceiling(stdin_input, output),
        output_sum_is_zero(stdin_input, output),
        output_preserves_integers(stdin_input, output),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0268,verus,apps,apps_test_1268,,"Given n cola cans where each can i has remaining volume a_i and capacity b_i,
determine if all remaining cola can be poured into exactly 2 cans.","use vstd::prelude::*;

verus! {
spec fn valid_input(a: Seq<int>, b: Seq<int>) -> bool {
    a.len() == b.len() && a.len() >= 2 && forall|i: int| 0 <= i < a.len() ==> 0 <= #[trigger] a[i] <= #[trigger] b[i]
}

spec fn sum_seq(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.subrange(1, s.len() as int)) }
}

spec fn find_two_largest_sum(s: Seq<int>) -> int
    recommends s.len() >= 2
{
    0
}

spec fn find_max(s: Seq<int>) -> int
    recommends s.len() >= 1
{
    0
}

spec fn find_max_excluding(s: Seq<int>, exclude: int) -> int
    recommends s.len() >= 2 && 0 <= exclude < s.len()
{
    0
}",,"fn solve(a: Seq<int>, b: Seq<int>) -> (result: String)
    requires 
        valid_input(a, b),
    ensures 
        result@ == seq!['Y','E','S'] || result@ == seq!['N','O'],
        (result@ == seq!['Y','E','S']) <==> find_two_largest_sum(b) >= sum_seq(a),","{
    assume(false);
    ""NO"".to_string()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0278,verus,apps,apps_test_1329,,"Given an integer N (1 ≤ N ≤ 100), count how many divisors of N! have exactly 75 divisors.
A number has exactly 75 divisors if and only if its prime factorization has one of these forms:
- p^74 (where p is prime)
- p^24 × q^2 (where p, q are distinct primes)  
- p^14 × q^4 (where p, q are distinct primes)
- p^4 × q^4 × r^2 (where p, q, r are distinct primes)

/* Abstract specification - represents the count of divisors of N! that have exactly 75 divisors */","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int) -> bool {
  1 <= n <= 100
}

spec fn count_divisors_with_75_factors(n: int) -> int 
  recommends valid_input(n)
{
  0
}

spec fn valid_output(result: int) -> bool {
  result >= 0
}",,"fn solve(n: int) -> (result: int)
  requires valid_input(n)
  ensures valid_output(result)","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0280,verus,apps,apps_test_1339,,"Given n segments on a coordinate line, where each segment i is defined by [l_i, r_i], 
find a segment that covers all other segments. A segment [a, b] covers segment [c, d] 
if a ≤ c ≤ d ≤ b. Return the 1-indexed number of such a segment, or -1 if none exists.","use vstd::prelude::*;

verus! {","spec fn valid_input(n: int, segments: Seq<(int, int)>) -> bool {
    n >= 1 && segments.len() == n && 
    forall|i: int| 0 <= i < n ==> segments[i].0 <= segments[i].1
}

spec fn covers_all(segments: Seq<(int, int)>, idx: int) -> bool {
    0 <= idx < segments.len() &&
    forall|j: int| 0 <= j < segments.len() ==> 
        segments[idx].0 <= segments[j].0 && segments[j].1 <= segments[idx].1
}

spec fn has_min_left_and_max_right(segments: Seq<(int, int)>, idx: int) -> bool {
    0 <= idx < segments.len() &&
    (forall|j: int| 0 <= j < segments.len() ==> segments[idx].0 <= segments[j].0) &&
    (forall|j: int| 0 <= j < segments.len() ==> segments[idx].1 >= segments[j].1)
}

spec fn min_left(segments: Seq<(int, int)>) -> int
    requires segments.len() > 0
    decreases segments.len()
{
    if segments.len() == 1 { 
        segments[0].0
    } else if segments[0].0 <= min_left(segments.subrange(1, segments.len() as int)) { 
        segments[0].0
    } else { 
        min_left(segments.subrange(1, segments.len() as int))
    }
}

spec fn max_right(segments: Seq<(int, int)>) -> int
    requires segments.len() > 0
    decreases segments.len()
{
    if segments.len() == 1 { 
        segments[0].1
    } else if segments[0].1 >= max_right(segments.subrange(1, segments.len() as int)) { 
        segments[0].1
    } else { 
        max_right(segments.subrange(1, segments.len() as int))
    }
}","fn solve(n: i32, segments: &[i32]) -> (result: i32)
    requires 
        n >= 1 && segments.len() == n && 
        forall|i: int| 0 <= i < n ==> i % 2 == 0 ==> segments[i] <= segments[i + 1]
    ensures 
        result == -1 || (1 <= result <= n)","{
    assume(false);
    -1
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0281,verus,apps,apps_test_1346,,"Given two polynomials f(x) and g(x) with positive integer coefficients,
find any coefficient in their product h(x) = f(x) · g(x) that is not
divisible by a given prime p. The gcd constraint ensures at least one
coefficient in each polynomial is not divisible by p.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, m: int, p: int, f: Seq<int>, g: Seq<int>) -> bool {
    n >= 1 && m >= 1 &&
    p >= 2 &&
    f.len() == n && g.len() == m &&
    (forall|k: int| 0 <= k < f.len() ==> f[k] > 0) &&
    (forall|k: int| 0 <= k < g.len() ==> g[k] > 0) &&
    (exists|k: int| 0 <= k < f.len() && f[k] % p != 0) &&
    (exists|k: int| 0 <= k < g.len() && g[k] % p != 0)
}

spec fn valid_result(result: int, n: int, m: int, p: int, f: Seq<int>, g: Seq<int>) -> bool 
    recommends p != 0
{
    exists|i: int, j: int| 0 <= i < f.len() && 0 <= j < g.len() &&
            (forall|k: int| 0 <= k < i ==> f[k] % p == 0) &&
            f[i] % p != 0 &&
            (forall|k: int| 0 <= k < j ==> g[k] % p == 0) &&
            g[j] % p != 0 &&
            result == i + j &&
            0 <= result < f.len() + g.len()
}",,"fn solve(n: i8, m: i8, p: i8, f: Vec<i8>, g: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, m as int, p as int, f@.map(|v: i8| v as int), g@.map(|v: i8| v as int)),
        p != 0,
    ensures valid_result(result as int, n as int, m as int, p as int, f@.map(|v: i8| v as int), g@.map(|v: i8| v as int))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0283,verus,apps,apps_test_1354,,"Given a 1×n grid where Alice claims to have placed k ships of size a (consecutive cells)
such that no two ships intersect or touch, and Bob makes m shots that all ""miss"",
determine the first shot after which we can be certain Alice is cheating
(i.e., it becomes impossible to place k non-intersecting, non-touching ships without hitting a shot).","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, k: int, a: int, m: int, shots: Seq<int>) -> bool {
    n > 0 && k > 0 && a > 0 && m > 0 && shots.len() == m &&
    (forall|i: int| #![trigger shots[i]] 0 <= i < shots.len() ==> 1 <= shots[i] <= n)
}

spec fn can_place_ships_func(n: int, k: int, a: int, shots: Seq<int>, num_shots: int) -> bool
    recommends
        n > 0 && k > 0 && a > 0 && num_shots >= 0,
        num_shots <= shots.len(),
        forall|i: int| #![trigger shots[i]] 0 <= i < shots.len() ==> 1 <= shots[i] <= n
{
    let hit_cells = Set::new(|cell: int| exists|i: int| 0 <= i < num_shots && i < shots.len() && shots[i] == cell);
    greedy_ship_placement(n, k, a, hit_cells) >= k
}

spec fn greedy_ship_placement(n: int, k: int, a: int, hit_cells: Set<int>) -> int
    recommends
        n > 0 && k > 0 && a > 0,
        forall|cell: int| #![trigger hit_cells.contains(cell)] hit_cells.contains(cell) ==> 1 <= cell <= n
{
    greedy_place_ships_from_position(1, n, k, a, hit_cells)
}

spec fn greedy_place_ships_from_position(pos: int, n: int, k: int, a: int, hit_cells: Set<int>) -> int
    recommends
        pos >= 1 && n > 0 && k >= 0 && a > 0,
        forall|cell: int| #![trigger hit_cells.contains(cell)] hit_cells.contains(cell) ==> 1 <= cell <= n
{
    if k == 0 || pos > n {
        0
    } else {
        // Simplified implementation without termination issues
        if pos + a - 1 <= n { 1 } else { 0 }
    }
}

spec fn is_natural_number_string(s: Seq<char>) -> bool {
    s.len() > 0 && s[0] != '0' && (forall|i: int| #![trigger s[i]] 0 <= i < s.len() ==> '0' <= s[i] <= '9')
}

spec fn parse_input_spec(input: Seq<char>) -> Seq<Seq<char>>
    recommends input.len() > 0
{
    seq![]
}

spec fn parse_three_ints_spec(line: Seq<char>) -> (int, int, int) {
    (1, 1, 1)
}

spec fn parse_int_spec(line: Seq<char>) -> int {
    0
}

spec fn parse_int_array_spec(line: Seq<char>) -> Seq<int> {
    seq![]
}

spec fn int_to_string_spec(value: int) -> Seq<char>
    recommends value >= 1
{
    seq!['1']
}",,"fn solve(stdin_input: Seq<char>) -> (result: Seq<char>)
    requires
        stdin_input.len() > 0,
        stdin_input[stdin_input.len()-1] == '\n'
    ensures
        result.len() > 0,
        result[result.len()-1] == '\n',
        result == seq!['-', '1', '\n'] || (exists|shot_num_str: Seq<char>| #![auto] shot_num_str.len() > 0 && 
                             result == shot_num_str + seq!['\n'] && 
                             is_natural_number_string(shot_num_str)),
        ({
            let lines = parse_input_spec(stdin_input);
            if lines.len() >= 3 {
                let first_line = parse_three_ints_spec(lines[0]);
                let (n, k, a) = (first_line.0, first_line.1, first_line.2);
                let m = parse_int_spec(lines[1]);
                let shots = parse_int_array_spec(lines[2]);
                if valid_input(n, k, a, m, shots) {
                    if can_place_ships_func(n, k, a, shots, m) {
                        result == seq!['-', '1', '\n']
                    } else {
                        exists|shot_idx: int| #![auto] 1 <= shot_idx <= m && 
                                            result == int_to_string_spec(shot_idx) + seq!['\n'] &&
                                            !can_place_ships_func(n, k, a, shots, shot_idx) &&
                                            (shot_idx == 1 || can_place_ships_func(n, k, a, shots, shot_idx-1))
                    }
                } else {
                    true
                }
            } else {
                true
            }
        })","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0288,verus,apps,apps_test_1386,,"Given a w×h grid, place square tiles that are diagonally split into white and black halves.
Each tile can be rotated in 4 orientations. Adjacent tiles must have different colors on their
shared edge. Count the number of valid tilings modulo 998244353.","use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 &&
    exists|i: int| 0 < i < input.len() - 1 && input[i] == ' ' &&
    (forall|j: int| 0 <= j < i ==> '0' <= input[j] <= '9') &&
    (forall|j: int| i < j < input.len() ==> '0' <= input[j] <= '9')
}

spec fn valid_dimensions(w: int, h: int) -> bool {
    w >= 1 && h >= 1 && w <= 1000 && h <= 1000
}

spec fn parse_two_ints(input: Seq<char>) -> (int, int) {
    let space_index = find_space_spec(input, 0);
    let w = string_to_int_spec(input.subrange(0, space_index));
    let h = string_to_int_spec(input.subrange(space_index + 1, input.len() as int));
    (w, h)
}

spec fn find_space_spec(s: Seq<char>, start: int) -> int
    decreases s.len() - start
{
    if s[start] == ' ' {
        start
    } else {
        find_space_spec(s, start + 1)
    }
}

spec fn string_to_int_spec(s: Seq<char>) -> int {
    if s.len() == 1 {
        s[0] as int - '0' as int
    } else {
        string_to_int_spec(s.subrange(0, s.len() - 1)) * 10 + (s[s.len() - 1] as int - '0' as int)
    }
}

spec fn int_to_string_spec(n: int) -> Seq<char> {
    if n == 0 {
        seq!['0']
    } else if n < 10 {
        seq![('0' as int + n) as char]
    } else {
        int_to_string_spec(n / 10).add(int_to_string_spec(n % 10))
    }
}

spec fn mod_pow_spec(base: int, exp: int, mod_val: int) -> int {
    if exp == 0 {
        1int % mod_val
    } else if exp % 2 == 0 {
        let half = mod_pow_spec(base, exp / 2, mod_val);
        (half * half) % mod_val
    } else {
        (base * mod_pow_spec(base, exp - 1, mod_val)) % mod_val
    }
}",,fn main_function() -> (result: int),"{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0294,verus,apps,apps_test_1448,,"Given integers n and d, determine for each grasshopper whether their position 
is inside or on the boundary of a cornfield quadrilateral with vertices at 
(0,d), (d,0), (n,n-d), (n-d,n). Output ""YES"" if inside/on boundary, ""NO"" otherwise.","use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    let lines = split_lines(input);
    lines.len() >= 3 && 
    valid_first_line(lines[0]) &&
    valid_second_line(lines[1]) &&
    valid_grasshopper_lines_simple(lines) &&
    ({
        let first_line = split_spaces(lines[0]);
        let n = string_to_int(first_line[0]);
        let d = string_to_int(first_line[1]);
        let m = string_to_int(lines[1]);
        d >= 1 && d < n && n <= 100 &&
        m >= 1 && m <= 100 &&
        lines.len() >= 2 + m &&
        forall|i: int| #[trigger] valid_grasshopper_line(lines[2 + i], n) && 0 <= i < m ==> valid_grasshopper_line(lines[2 + i], n)
    })
}

spec fn valid_first_line(line: Seq<char>) -> bool {
    let parts = split_spaces(line);
    parts.len() == 2 && is_valid_integer(parts[0]) && is_valid_integer(parts[1])
}

spec fn valid_second_line(line: Seq<char>) -> bool {
    is_valid_integer(line)
}

spec fn valid_grasshopper_lines_simple(lines: Seq<Seq<char>>) -> bool {
    lines.len() >= 3 &&
    ({
        let m = string_to_int(lines[1]);
        lines.len() >= 2 + m
    })
}

spec fn valid_grasshopper_line(line: Seq<char>, n: int) -> bool {
    let parts = split_spaces(line);
    parts.len() == 2 && is_valid_integer(parts[0]) && is_valid_integer(parts[1]) &&
    string_to_int(parts[0]) >= 0 && string_to_int(parts[0]) <= n &&
    string_to_int(parts[1]) >= 0 && string_to_int(parts[1]) <= n
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    s.len() > 0
}

spec fn get_n(input: Seq<char>) -> int {
    let lines = split_lines(input);
    let first_line = split_spaces(lines[0]);
    string_to_int(first_line[0])
}

spec fn get_d(input: Seq<char>) -> int {
    let lines = split_lines(input);
    let first_line = split_spaces(lines[0]);
    string_to_int(first_line[1])
}

spec fn get_number_of_grasshoppers(input: Seq<char>) -> int {
    let lines = split_lines(input);
    string_to_int(lines[1])
}

spec fn get_grasshopper(input: Seq<char>, i: int) -> (int, int) {
    let lines = split_lines(input);
    let coords = split_spaces(lines[2 + i]);
    (string_to_int(coords[0]), string_to_int(coords[1]))
}

spec fn is_inside_cornfield(grasshopper: (int, int), n: int, d: int) -> bool {
    let (x, y) = grasshopper;
    x + y >= d && x + y <= 2 * n - d && x - y >= -d && x - y <= d
}

/* Helper functions for string processing */
spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {
    Seq::empty()
}

spec fn split_spaces(line: Seq<char>) -> Seq<Seq<char>> {
    Seq::empty()
}

spec fn string_to_int(s: Seq<char>) -> int {
    0
}",,fn solve(input: &str) -> (result: Vec<String>),"{
    // impl-start
    assume(false);
    Vec::new()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0298,verus,apps,apps_test_1512,,"Given a permutation of integers from 1 to n, determine which single element to remove
to maximize the number of records in the remaining sequence. A record is an element
that is greater than all elements that appear before it in the sequence. If multiple
elements can be removed to achieve the same maximum number of records, return the
smallest such element.","use vstd::prelude::*;

verus! {

spec fn valid_permutation(p: Seq<int>, n: int) -> bool {
  p.len() == n && n >= 1 &&
  (forall|i: int| 0 <= i < n ==> 1 <= #[trigger] p[i] <= n) &&
  (forall|i: int, j: int| 0 <= i < j < n ==> #[trigger] p[i] != #[trigger] p[j])
}

spec fn count_records(s: Seq<int>) -> int {
  if s.len() == 0 { 0 }
  else { 1 + count_records_from_index(s, 1, s[0]) }
}

spec fn count_records_after_removal(p: Seq<int>, to_remove: int) -> int {
  let filtered = Seq::new((p.len() - 1) as nat, |i: int| 
    if index_of(p, to_remove) <= i { p[i + 1] } else { p[i] });
  count_records(filtered)
}
spec fn count_records_from_index(s: Seq<int>, idx: int, max_so_far: int) -> int
  decreases s.len() - idx
{
  if idx >= s.len() { 0 }
  else if s[idx] > max_so_far { 
    1 + count_records_from_index(s, idx + 1, s[idx])
  } else { 
    count_records_from_index(s, idx + 1, max_so_far)
  }
}

spec fn index_of(s: Seq<int>, elem: int) -> int {
  choose|i: int| 0 <= i < s.len() && s[i] == elem
}",,"fn solve(n: i8, p: Vec<i8>) -> (result: i8)
  requires 
    valid_permutation(p@.map(|i, x: i8| x as int), n as int)
  ensures 
    1 <= result as int <= n as int,
    p@.map(|i, x: i8| x as int).contains(result as int),
    {
      let p_int = p@.map(|i, x: i8| x as int);
      forall|x: int| p_int.contains(x) ==> count_records_after_removal(p_int, result as int) >= count_records_after_removal(p_int, x)
    },
    {
      let p_int = p@.map(|i, x: i8| x as int);
      forall|x: int| p_int.contains(x) && count_records_after_removal(p_int, x) == count_records_after_removal(p_int, result as int) ==> result as int <= x
    }","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0303,verus,apps,apps_test_1547,,"Given an n×m grid initially filled with color 0, perform k painting operations and output the final grid.
Operations can paint entire rows or columns with specified colors.
When a cell is painted multiple times, it takes the color of the most recent operation affecting it.","use vstd::prelude::*;

verus! {

spec fn valid_input(input: &str) -> bool {
    let lines = split_lines(input);
    lines.len() > 0 && split_string(&lines[0], ' ').len() == 3 &&
    {
        let n = string_to_int(&split_string(&lines[0], ' ')[0]);
        let m = string_to_int(&split_string(&lines[0], ' ')[1]);
        let k = string_to_int(&split_string(&lines[0], ' ')[2]);
        n > 0 && m > 0 && k >= 0 && lines.len() >= k + 1
    }
}

spec fn get_dimensions(input: &str) -> (int, int, int)
{
    let lines = split_lines(input);
    let first_line = split_string(&lines[0], ' ');
    (string_to_int(&first_line[0]), string_to_int(&first_line[1]), string_to_int(&first_line[2]))
}

spec fn compute_grid(lines: Seq<String>, n: int, m: int, k: int) -> Seq<Seq<int>>
{
    let row = Seq::new(n as nat, |i: int| (0, -1));
    let col = Seq::new(m as nat, |i: int| (0, -1));
    let processed_arrays = process_operations(lines, n, m, k, 0, row, col);
    build_grid(n, m, processed_arrays.0, processed_arrays.1)
}","/* Helper functions would be defined here */
spec fn split_lines(input: &str) -> Seq<String> {
    Seq::empty()
}

spec fn split_string(s: &str, delimiter: char) -> Seq<String> {
    Seq::empty()
}

spec fn string_to_int(s: &str) -> int {
    0
}

spec fn process_operations(lines: Seq<String>, n: int, m: int, k: int, index: int, row: Seq<(int, int)>, col: Seq<(int, int)>) -> (Seq<(int, int)>, Seq<(int, int)>) {
    (Seq::empty(), Seq::empty())
}

spec fn build_grid(n: int, m: int, row: Seq<(int, int)>, col: Seq<(int, int)>) -> Seq<Seq<int>> {
    Seq::empty()
}

spec fn format_grid(grid: Seq<Seq<int>>) -> String {
    """".to_string()
}","fn solve(input: &str) -> (result: String)
    requires input.len() > 0
    ensures !valid_input(input) ==> result@ == """"@
    ensures valid_input(input) ==> (
        let (n, m, k) = get_dimensions(input);
        let lines = split_lines(input);
        result == format_grid(compute_grid(lines, n, m, k))
    )","{
    assume(false);
    """".to_string()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0309,verus,apps,apps_test_1586,,"Given a non-negative integer N, compute the double factorial f(N) where f(n) = 1 if n < 2,
and f(n) = n × f(n-2) if n ≥ 2. Find the number of trailing zeros in the decimal representation of f(N).
Trailing zeros are produced by factors of 10, which come from pairs of prime factors 2 and 5.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int) -> bool {
    n >= 0
}

spec fn factors_in_factorial(n: int, p: int) -> int {
    0
}

spec fn factors_in_double_factorial(n: int, p: int) -> int {
    0
}

spec fn valid_result(n: int, result: int) -> bool {
    n >= 0 ==> (
        result >= 0 &&
        result == if factors_in_double_factorial(n, 2) < factors_in_double_factorial(n, 5) {
            factors_in_double_factorial(n, 2)
        } else {
            factors_in_double_factorial(n, 5)
        }
    )
}",,"fn solve(n: int) -> (result: int)
    requires valid_input(n)
    ensures valid_result(n, result)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0313,verus,apps,apps_test_1615,,"Given n non-intersecting integer segments, find the minimum number of moves
to make the total count of integers covered by all segments divisible by k.
Each move extends any segment by 1 unit either left or right.","use vstd::prelude::*;

verus! {
spec fn valid_input_format(s: Seq<u8>) -> bool {
    let lines = split_lines(s);
    lines.len() >= 1 &&
    exists|n: nat, k: nat| 
        parses_as_integers_pair(lines[0], n as int, k as int) && n > 0 && k > 0 && lines.len() >= n + 1 &&
        forall|i: int| 1 <= i <= n && i < lines.len() ==> #[trigger] lines[i] == lines[i] && 
            exists|a: int, b: int| parses_as_integers_pair(lines[i], a, b)
}

spec fn parsed_correctly(input: Seq<u8>, n: nat, k: nat, segments: Seq<(int, int)>) -> bool {
    let lines = split_lines(input);
    lines.len() >= n + 1 && segments.len() == n &&
    parses_as_integers_pair(lines[0], n as int, k as int) &&
    forall|i: int| 0 <= i < n && i + 1 < lines.len() ==> #[trigger] segments[i] == segments[i] && 
        parses_as_integers_pair(lines[i + 1], segments[i].0, segments[i].1)
}

spec fn is_valid_output(s: Seq<u8>) -> bool {
    s.len() > 0 && s[s.len() - 1] == 10u8 && 
    forall|i: int| 0 <= i < s.len() - 1 ==> #[trigger] s[i] == s[i] && s[i] != 10u8 &&
    is_numeric_output(s.subrange(0, s.len() - 1))
}

spec fn min_moves_to_divisible(segments: Seq<(int, int)>, k: nat) -> nat
    recommends k > 0
{
    let total_coverage = total_coverage(segments);
    let remainder = total_coverage % k;
    if remainder == 0 { 0 } else { (k - remainder) as nat }
}

spec fn total_coverage(segments: Seq<(int, int)>) -> nat
    decreases segments.len()
{
    if segments.len() == 0 { 
        0 
    } else { 
        segment_length(segments[0]) + total_coverage(segments.subrange(1, segments.len() as int))
    }
}

spec fn segment_length(segment: (int, int)) -> nat {
    let max_val = if segment.0 >= segment.1 { segment.0 } else { segment.1 };
    let min_val = if segment.0 <= segment.1 { segment.0 } else { segment.1 };
    if max_val >= min_val { (max_val - min_val + 1) as nat } else { 1 }
}

/* Helper functions that would need to be implemented */
spec fn split_lines(s: Seq<u8>) -> Seq<Seq<u8>> {
    seq![seq![]]
}

spec fn parses_as_integers_pair(line: Seq<u8>, a: int, b: int) -> bool {
    true
}

spec fn is_numeric_output(s: Seq<u8>) -> bool {
    true
}

spec fn contains_newline(s: Seq<u8>) -> bool {
    exists|i: int| 0 <= i < s.len() && s[i] == 10u8
}

spec fn int_to_string(n: nat) -> Seq<u8> {
    seq![48u8]
}",,"fn solve(stdin_input: Vec<u8>) -> (result: Vec<u8>)
    requires
        stdin_input.len() > 0,
        stdin_input[stdin_input.len() - 1] == 10u8 || !contains_newline(stdin_input@),
    ensures
        result.len() == 0 || result[result.len() - 1] == 10u8,
        valid_input_format(stdin_input@) ==> 
            exists|n: nat, k: nat, segments: Seq<(int, int)>|
                n > 0 && k > 0 && segments.len() == n &&
                parsed_correctly(stdin_input@, n, k, segments) &&
                result@ == int_to_string(min_moves_to_divisible(segments, k)).add(seq![10u8]),
        valid_input_format(stdin_input@) ==> is_valid_output(result@),
        !valid_input_format(stdin_input@) ==> 
            (result.len() == 0 || (result.len() > 0 && result[result.len() - 1] == 10u8)),","{
    assume(false);
    Vec::new()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0314,verus,apps,apps_test_1617,,"Given n people sitting in a circle numbered 1 to n, person 1 starts with a ball and chooses a positive integer k ≤ n.
The ball is passed to the k-th neighbor in clockwise direction repeatedly until it returns to person 1.
The fun value is the sum of all unique person IDs who touched the ball during this process.
Find all possible fun values for all valid choices of k.","use vstd::prelude::*;

verus! {
spec fn f(n: int, x: int) -> int {
  let y = n / x;
  y + x * y * (y - 1) / 2
}

spec fn is_divisor(d: int, n: int) -> bool {
  d > 0 && n % d == 0
}

spec fn is_sorted(s: Seq<int>) -> bool {
  forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] <= s[j]
}

spec fn no_duplicates(s: Seq<int>) -> bool {
  forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] != s[j]
}",,"fn solve(n: i8) -> (result: Vec<i8>)
  requires n as int >= 2
  ensures 
      no_duplicates(result@.map(|i: int, x: i8| x as int)) &&
      is_sorted(result@.map(|i: int, x: i8| x as int)) &&
      (forall|v: int| #[trigger] result@.map(|i: int, x: i8| x as int).contains(v) <==> exists|d: int| #[trigger] is_divisor(d, n as int) && v == f(n as int, d)) &&
      result@.len() > 0","{
  assume(false);
  Vec::new()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0321,verus,apps,apps_test_1631,,"Given n strings of lowercase Latin letters, determine if there exists a permutation 
of the 26 lowercase Latin letters such that the strings are in lexicographical order
according to this custom alphabet. Output the valid alphabet permutation or ""Impossible"".","use vstd::prelude::*;

verus! {
spec fn valid_input(stdin_input: Seq<char>, n: int) -> bool {
    exists|lines: Seq<Seq<char>>| (parse_input(stdin_input) == lines &&
    lines.len() >= 1 &&
    lines.len() == n + 1 &&
    parse_int(lines[0]) == n &&
    n >= 1 && n <= 100 &&
    (forall|i: int| 1 <= i < lines.len() ==> 
        1 <= lines[i].len() <= 100 && 
        forall|j: int| 0 <= j < lines[i].len() ==> 'a' <= lines[i][j] <= 'z'))
}

spec fn valid_alphabet_ordering(stdin_input: Seq<char>, alphabet: Seq<char>) -> bool
    recommends alphabet.len() == 26,
              forall|i: int| 0 <= i < alphabet.len() ==> 'a' <= alphabet[i] <= 'z',
              forall|i: int, j: int| 0 <= i < j < alphabet.len() ==> alphabet[i] != alphabet[j]
{
    exists|lines: Seq<Seq<char>>, n: int| (parse_input(stdin_input) == lines &&
    lines.len() >= 1 &&
    lines.len() == n + 1 &&
    parse_int(lines[0]) == n &&
    (forall|i: int| 1 <= i < n ==> lexicographically_less_or_equal(lines[i], lines[i+1], alphabet)))
}

spec fn lexicographically_less_or_equal(s1: Seq<char>, s2: Seq<char>, alphabet: Seq<char>) -> bool
    recommends alphabet.len() == 26,
              forall|i: int| 0 <= i < alphabet.len() ==> 'a' <= alphabet[i] <= 'z',
              forall|i: int, j: int| 0 <= i < j < alphabet.len() ==> alphabet[i] != alphabet[j]
{
    if s1 == s2 {
        true
    } else if s1.len() <= s2.len() && s1 == s2.subrange(0, s1.len() as int) {
        true
    } else if s2.len() < s1.len() && s2 == s1.subrange(0, s2.len() as int) {
        false
    } else {
        exists|i: int| (0 <= i < s1.len() && i < s2.len() && s1[i] != s2[i] &&
        (forall|j: int| 0 <= j < i ==> s1[j] == s2[j]) &&
        'a' <= s1[i] <= 'z' && 'a' <= s2[i] <= 'z' &&
        alphabet_order(s1[i], s2[i], alphabet))
    }
}

spec fn alphabet_order(c1: char, c2: char, alphabet: Seq<char>) -> bool
    recommends alphabet.len() == 26,
              forall|i: int| 0 <= i < alphabet.len() ==> 'a' <= alphabet[i] <= 'z',
              forall|i: int, j: int| 0 <= i < j < alphabet.len() ==> alphabet[i] != alphabet[j],
              'a' <= c1 <= 'z' && 'a' <= c2 <= 'z'
{
    exists|i: int, j: int| 0 <= i < j < alphabet.len() && alphabet[i] == c1 && alphabet[j] == c2
}

spec fn parse_input(input: Seq<char>) -> Seq<Seq<char>>
{
    Seq::<Seq<char>>::empty()
}

spec fn parse_int(s: Seq<char>) -> int
{
    0
}",,"fn solve(stdin_input: Vec<char>) -> (result: String)
    requires
        stdin_input@.len() > 0,
        exists|n: int| n >= 1 && valid_input(stdin_input@, n),
    ensures
        result@ == ""Impossible""@ || (result@.len() == 26 && forall|i: int| 0 <= i < result@.len() ==> 'a' <= result@[i] <= 'z'),
        result@ != ""Impossible""@ ==> (forall|i: int, j: int| 0 <= i < j < result@.len() ==> result@[i] != result@[j]),
        result@ != ""Impossible""@ ==> valid_alphabet_ordering(stdin_input@, result@),","{
    // impl-start
    assume(false);
    ""Impossible"".to_string()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0322,verus,apps,apps_test_1634,,"Given ticket costs and transportation usage, find the minimum cost to buy tickets.
There are 4 ticket types: individual ride cost, unlimited rides on one vehicle,
unlimited rides on all buses OR all trolleys, and unlimited rides on everything.
Input includes 4 costs and arrays of ride counts for buses and trolleys.","use vstd::prelude::*;

verus! {

spec fn valid_costs(c: &[int]) -> bool {
  c.len() == 4 &&
  c[0] >= 1 && c[1] >= 1 && c[2] >= 1 && c[3] >= 1 &&
  c[0] <= 1000 && c[1] <= 1000 && c[2] <= 1000 && c[3] <= 1000
}

spec fn valid_rides(rides: &[int]) -> bool {
  rides.len() >= 1 && rides.len() <= 1000 &&
  forall|i: int| #![trigger rides[i]] 0 <= i < rides.len() ==> 0 <= rides[i] <= 1000
}

spec fn sum_array(arr: Seq<int>) -> int
  decreases arr.len(),
{
  if arr.len() == 0 { 
    0 
  } else { 
    arr[0] + sum_array(arr.drop_first()) 
  }
}

spec fn optimized_cost(rides: Seq<int>, individual_cost: int, unlimited_cost: int) -> int {
  let initial_cost = sum_array(rides) * individual_cost;
  min_with_unlimited(rides, initial_cost, individual_cost, unlimited_cost, 0)
}

spec fn min_with_unlimited(rides: Seq<int>, current_cost: int, individual_cost: int, unlimited_cost: int, index: int) -> int
  decreases rides.len() - index,
{
  if index >= rides.len() { 
    current_cost 
  } else {
    let new_cost = current_cost - rides[index] * individual_cost + unlimited_cost;
    let updated_cost = if new_cost < current_cost && new_cost >= 0 { new_cost } else { current_cost };
    min_with_unlimited(rides, updated_cost, individual_cost, unlimited_cost, index + 1)
  }
}

spec fn min5(a: int, b: int, c: int, d: int, e: int) -> int {
  let min_ab = if a <= b { a } else { b };
  let min_cd = if c <= d { c } else { d };
  let min_abcd = if min_ab <= min_cd { min_ab } else { min_cd };
  if min_abcd <= e { min_abcd } else { e }
}

spec fn correct_result(c: &[int], a: &[int], b: &[int], result: int) -> bool {
  result == min5(optimized_cost(a@, c[0], c[1]) + optimized_cost(b@, c[0], c[1]),
                 optimized_cost(a@, c[0], c[1]) + c[2],
                 optimized_cost(b@, c[0], c[1]) + c[2],
                 c[2] + c[2],
                 c[3])
}",,"fn solve(c: &Vec<i8>, a: &Vec<i8>, b: &Vec<i8>) -> (result: i8)
  requires 
    c.len() == 4,
    c@[0] as int >= 1 && c@[1] as int >= 1 && c@[2] as int >= 1 && c@[3] as int >= 1,
    c@[0] as int <= 1000 && c@[1] as int <= 1000 && c@[2] as int <= 1000 && c@[3] as int <= 1000,
    a.len() >= 1 && a.len() <= 1000,
    b.len() >= 1 && b.len() <= 1000,
    forall|i: int| #![trigger a@[i]] 0 <= i < a.len() ==> 0 <= a@[i] as int <= 1000,
    forall|i: int| #![trigger b@[i]] 0 <= i < b.len() ==> 0 <= b@[i] as int <= 1000,
  ensures 
    result >= 0,
    result as int <= min5(sum_array(a@.map(|_, x: i8| x as int)) * (c@[0] as int) + sum_array(b@.map(|_, x: i8| x as int)) * (c@[0] as int), 
                  sum_array(a@.map(|_, x: i8| x as int)) * (c@[0] as int) + (c@[2] as int),
                  sum_array(b@.map(|_, x: i8| x as int)) * (c@[0] as int) + (c@[2] as int),
                  (c@[2] as int) + (c@[2] as int),
                  c@[3] as int),","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0328,verus,apps,apps_test_1661,,"Given n games with costs and m bills with values, determine how many games can be bought
by processing games in order. For each game, use the first available bill if it has
sufficient value to buy the game, otherwise skip the game. Return total games bought.","use vstd::prelude::*;

verus! {

spec fn count_buyable_games(games: Seq<int>, bills: Seq<int>) -> int
    decreases games.len()
{
    if games.len() == 0 {
        0
    } else if bills.len() == 0 {
        0
    } else if bills[0] >= games[0] {
        1 + count_buyable_games(games.subrange(1, games.len() as int), bills.subrange(1, bills.len() as int))
    } else {
        count_buyable_games(games.subrange(1, games.len() as int), bills)
    }
}

spec fn valid_input(n: int, m: int, games: Seq<int>, bills: Seq<int>) -> bool {
    n >= 1 && m >= 1 &&
    games.len() == n && bills.len() == m &&
    (forall|i: int| 0 <= i < games.len() ==> #[trigger] games[i] >= 1 && #[trigger] games[i] <= 1000) &&
    (forall|i: int| 0 <= i < bills.len() ==> #[trigger] bills[i] >= 1 && #[trigger] bills[i] <= 1000)
}",,"fn solve(n: i8, m: i8, games: Vec<i8>, bills: Vec<i8>) -> (result: i8)
    requires 
        valid_input(n as int, m as int, games@.map(|v: i8| v as int), bills@.map(|v: i8| v as int)),
    ensures 
        0 <= result as int <= n as int,
        result as int <= m as int,
        result as int == count_buyable_games(games@.map(|v: i8| v as int), bills@.map(|v: i8| v as int)),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0331,verus,apps,apps_test_1684,,"Given n points numbered 1 to n arranged clockwise on a circle's circumference 
and m line segments connecting pairs of these points, determine if the resulting 
image has rotational symmetry. The image has rotational symmetry if there exists 
an integer k (1 ≤ k < n) such that rotating all segments clockwise by k units 
around the center produces the same image.","use vstd::prelude::*;

verus! {

#[derive(PartialEq, Eq)]
pub struct InputData {
    pub n: int,
    pub m: int,
    pub segments: Set<(int, int)>,
}

spec fn valid_input_format(stdin_input: &str) -> bool {
    stdin_input.len() > 0
}

spec fn parse_input(stdin_input: &str) -> InputData
    requires valid_input_format(stdin_input)
{
    InputData {
        n: 2,
        m: 0,
        segments: Set::empty(),
    }
}

spec fn rotate_segment(seg: (int, int), k: int, n: int) -> (int, int)
    requires 1 <= seg.0 <= n && 1 <= seg.1 <= n && k >= 0 && n > 0
{
    let temp_a = (seg.0 + k) % n;
    let a = if temp_a == 0 { n } else { temp_a };
    let temp_b = (seg.1 + k) % n;
    let b = if temp_b == 0 { n } else { temp_b };
    (a, b)
}

spec fn exists_rotational_symmetry(data: InputData) -> bool {
    exists|k: int| 1 <= k < data.n && 
        data.n % k == 0 &&
        (forall|seg: (int, int)| data.segments.contains(seg) ==> 
            seg.0 >= 1 && seg.0 <= data.n && seg.1 >= 1 && seg.1 <= data.n &&
            data.segments.contains(rotate_segment(seg, k, data.n)))
}",,"fn solve(stdin_input: &str) -> (result: String)
    requires stdin_input.len() > 0
    requires valid_input_format(stdin_input)
    ensures result == ""Yes"" || result == ""No""
    ensures (result == ""Yes"") == exists_rotational_symmetry(parse_input(stdin_input))","{
    assume(false);
    ""No"".to_string()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0332,verus,apps,apps_test_1687,,"Given an array of positive integers, find an element from the array such that all elements
in the array are divisible by it. If no such element exists, return -1. If multiple valid
elements exist, return any one of them.","use vstd::prelude::*;

verus! {
spec fn min(a: Seq<int>) -> int
    recommends a.len() > 0
{
    choose|x: int| a.contains(x) && forall|i: int| 0 <= i < a.len() ==> x <= a[i]
}",,"fn solve(a: Vec<i8>) -> (result: i8)
    requires 
        a.len() > 0,
        forall|i: int| 0 <= i < a.len() ==> a[i] as int > 0,
    ensures 
        result as int == -1 || exists|i: int| 0 <= i < a.len() && a[i] == result,
        result as int != -1 ==> forall|i: int| 0 <= i < a.len() ==> a[i] as int % result as int == 0,
        result as int == -1 ==> forall|x: int| (exists|i: int| 0 <= i < a.len() && a[i] as int == x) ==> exists|i: int| 0 <= i < a.len() && a[i] as int % x != 0,
        (forall|i: int| 0 <= i < a.len() ==> a[i] as int % min(a@.map(|i: int, x: i8| x as int)) == 0) ==> result as int == min(a@.map(|i: int, x: i8| x as int)),
        (exists|i: int| 0 <= i < a.len() && a[i] as int % min(a@.map(|i: int, x: i8| x as int)) != 0) ==> result as int == -1,","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0337,verus,apps,apps_test_1724,,"Given an array a of n non-negative integers and a binary string representing number m,
find the maximum value of function f(x) = sum(a[i] * bit_i(x)) for all integers x in range [0, m],
where bit_i(x) is 1 if the i-th bit of x is set, 0 otherwise.","use vstd::prelude::*;

verus! {","spec fn valid_input(n: int, a: Seq<int>, k: Seq<char>) -> bool {
  n >= 1 && a.len() == n && k.len() == n && 
  (forall|i: int| 0 <= i < n ==> a[i] >= 0) &&
  is_binary_string(k)
}

spec fn is_binary_string(s: Seq<char>) -> bool {
  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
}

spec fn pow(base: int, exp: int) -> int
  decreases exp
{
  if exp == 0 { 1 }
  else if exp > 0 { base * pow(base, exp - 1) }
  else { 1 }
}

spec fn binary_string_to_int(s: Seq<char>) -> int
  requires is_binary_string(s)
  ensures binary_string_to_int(s) >= 0
  decreases s.len()
{
  if s.len() == 0 { 0 }
  else { (if s[0] == '1' { 1 } else { 0 }) * pow(2, s.len() as int - 1) + binary_string_to_int(s.subrange(1, s.len() as int)) }
}

spec fn f(a: Seq<int>, x: int, n: int) -> int
  requires n >= 0 && a.len() == n
  ensures (forall|i: int| 0 <= i < n ==> a[i] >= 0) ==> f(a, x, n) >= 0
  decreases n
{
  if n == 0 { 0 }
  else { (if (x / pow(2, n-1)) % 2 == 1 { a[n-1] } else { 0 }) + f(a.subrange(0, n-1), x % pow(2, n-1), n-1) }
}","fn solve(n: int, a: Seq<int>, k: Seq<char>) -> (result: int)
  requires valid_input(n, a, k)
  ensures result >= 0,
  ensures exists|x: int| 0 <= x <= binary_string_to_int(k) && result == f(a, x, n),
  ensures forall|x: int| 0 <= x <= binary_string_to_int(k) ==> f(a, x, n) <= result","{
  assume(false);
  0
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0340,verus,apps,apps_test_1745,,"Given an n × m grid where '.' represents empty cells and '#' represents occupied cells,
count the number of distinct ways to create a pipe with constraints:
1. The pipe is a width-1 polyline through empty cells only
2. The pipe starts and ends on the grid boundary (but not corner cells)
3. The pipe has at most 2 turns (90-degree turns)
4. The pipe touches exactly 2 boundary cells (start and end)
5. If the pipe is a straight line, start and end must be on different edges
6. Each non-boundary pipe cell has exactly 2 adjacent pipe cells
7. Each boundary pipe cell has exactly 1 adjacent pipe cell

/* Simplified implementation */","use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 && input.index(input.len() - 1) == '\n'
}

spec fn valid_output(output: Seq<char>) -> bool {
    output.len() > 0 && output.index(output.len() - 1) == '\n'
}

spec fn parse_grid(input: Seq<char>) -> (Seq<Seq<char>>, int, int) {
    (seq![], 0, 0)
}

spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {
    seq![]
}

spec fn find_newline(s: Seq<char>, start: int) -> int {
    -1
}

spec fn is_valid_grid(grid: Seq<Seq<char>>, rows: int, cols: int) -> bool {
    grid.len() == rows &&
    rows >= 0 && cols >= 0 &&
    (forall|i: int| #![auto] 0 <= i < rows ==> grid.index(i).len() == cols) &&
    (forall|i: int, j: int| 0 <= i < rows && 0 <= j < cols ==> 
        grid.index(i).index(j) == '.' || grid.index(i).index(j) == '#')
}

spec fn is_boundary_cell(i: int, j: int, rows: int, cols: int) -> bool {
    i == 0 || i == rows - 1 || j == 0 || j == cols - 1
}

spec fn is_corner_cell(i: int, j: int, rows: int, cols: int) -> bool {
    (i == 0 && j == 0) || (i == 0 && j == cols - 1) ||
    (i == rows - 1 && j == 0) || (i == rows - 1 && j == cols - 1)
}

spec fn count_valid_pipes(grid: Seq<Seq<char>>, rows: int, cols: int) -> int {
    0
}",,"fn execute_python_logic(input: Seq<char>) -> (output: Seq<char>)
    requires valid_input(input)
    ensures valid_output(output)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0346,verus,apps,apps_test_1780,,"Given an array of n integers (each either -1 or 1), determine for each query 
whether the array can be rearranged so that the sum of elements in a given 
range equals 0. A range can sum to 0 only if it has even length and we have 
enough positive and negative values to fill half the positions each.","use vstd::prelude::*;

verus! {

spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {
    seq![seq!['0']]
}

spec fn extract_m_from_line(line: Seq<char>) -> int {
    0
}

spec fn extract_n(line: Seq<char>) -> int {
    0
}

spec fn extract_m(input: Seq<char>) -> int {
    0
}

spec fn extract_query(line: Seq<char>) -> (int, int) {
    (0, 0)
}

spec fn count_ones(line: Seq<char>) -> int {
    0
}

spec fn count_dashes(line: Seq<char>) -> int {
    0
}

spec fn min(a: int, b: int) -> int {
    if a <= b { a } else { b }
}

spec fn join_with_newlines(outputs: Seq<Seq<char>>) -> Seq<char> {
    seq!['0']
}

spec fn valid_input(input: Seq<char>) -> bool {
    let lines = split_lines(input);
    lines.len() >= 2 &&
    contains_valid_first_line(lines[0]) &&
    contains_valid_second_line(lines[1]) &&
    lines.len() == 2 + extract_m_from_line(lines[0]) &&
    (forall|i: int| 2 <= i < lines.len() ==> contains_valid_query(lines[i])) &&
    extract_n(lines[0]) == lines[1].len()
}

spec fn contains_valid_first_line(line: Seq<char>) -> bool {
    true
}

spec fn contains_valid_second_line(line: Seq<char>) -> bool {
    line.len() >= 0 &&
    forall|i: int| 0 <= i < line.len() ==> line[i] == '1' || line[i] == '-'
}

spec fn contains_valid_query(line: Seq<char>) -> bool {
    true
}

spec fn compute_correct_result(input: Seq<char>) -> Seq<char> {
    let lines = split_lines(input);
    let first_line = lines[0];
    let n = extract_n(first_line);
    let m = extract_m(input);
    let array_line = lines[1];
    let positives = count_ones(array_line);
    let negatives = count_dashes(array_line);
    let max_balanceable = 2 * min(positives, negatives);

    let outputs: Seq<Seq<char>> = Seq::new(m as nat, |i: int| {
        let query = extract_query(lines[i + 2]);
        let l = query.0;
        let r = query.1;
        let range_length = r - l + 1;
        if range_length % 2 == 0 && range_length <= max_balanceable {
            seq!['1']
        } else {
            seq!['0']
        }
    });

    join_with_newlines(outputs)
}

spec fn ends_with_newline_if_non_empty(s: Seq<char>) -> bool {
    s.len() == 0 || (s.len() > 0 && s[s.len() - 1] == '\n')
}",,"fn solve(stdin_input: Seq<char>) -> (result: Seq<char>)
    requires
        stdin_input.len() > 0,
        valid_input(stdin_input),
    ensures
        result.len() >= 0,
        result == compute_correct_result(stdin_input),
        forall|line: Seq<char>| split_lines(result).contains(line) ==> line == seq!['0'] || line == seq!['1'],
        split_lines(result).len() == extract_m(stdin_input),
        ends_with_newline_if_non_empty(result),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0352,verus,apps,apps_test_1824,,"Given three lists of compilation errors (initial with n errors, second with n-1 errors, third with n-2 errors),
find the two error values that were corrected. The compiler shows errors in different order each time,
but the actual error values remain the same.","use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    let lines = split_by_newline(input);
    lines.len() >= 4 && 
    is_valid_integer(lines[0]) &&
    string_to_int(lines[0]) >= 3 &&
    split_by_space(lines[1]).len() == string_to_int(lines[0]) &&
    split_by_space(lines[2]).len() == string_to_int(lines[0]) - 1 &&
    split_by_space(lines[3]).len() == string_to_int(lines[0]) - 2 &&
    (forall|i: int| 0 <= i < split_by_space(lines[1]).len() ==> is_valid_integer(split_by_space(lines[1])[i])) &&
    (forall|i: int| 0 <= i < split_by_space(lines[2]).len() ==> is_valid_integer(split_by_space(lines[2])[i])) &&
    (forall|i: int| 0 <= i < split_by_space(lines[3]).len() ==> is_valid_integer(split_by_space(lines[3])[i]))
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    s.len() > 0 && (s[0] == '-' ==> s.len() > 1) && 
    (forall|i: int| (if s[0] == '-' { 1int } else { 0int }) <= i < s.len() ==> '0' <= s[i] <= '9')
}

spec fn get_first_sum(input: Seq<char>) -> int {
    let lines = split_by_newline(input);
    let first_line = split_by_space(lines[1]);
    sum_sequence(first_line)
}

spec fn get_second_sum(input: Seq<char>) -> int {
    let lines = split_by_newline(input);
    let second_line = split_by_space(lines[2]);
    sum_sequence(second_line)
}

spec fn get_third_sum(input: Seq<char>) -> int {
    let lines = split_by_newline(input);
    let third_line = split_by_space(lines[3]);
    sum_sequence(third_line)
}

spec fn sum_sequence(numbers: Seq<Seq<char>>) -> int
    decreases numbers.len()
{
    if numbers.len() == 0 { 0 }
    else { string_to_int(numbers[0]) + sum_sequence(numbers.drop_first()) }
}

spec fn split_by_newline(s: Seq<char>) -> Seq<Seq<char>>
    decreases s.len()
{
    if s.len() == 0 { seq![] }
    else if s[0] == '\n' { split_by_newline(s.drop_first()) }
    else {
        let rest = split_by_newline(s.drop_first());
        if rest.len() == 0 { seq![s] }
        else { seq![seq![s[0]].add(rest[0])].add(rest.drop_first()) }
    }
}

spec fn split_by_space(s: Seq<char>) -> Seq<Seq<char>> {
    split_by_char(s, ' ')
}

spec fn split_by_char(s: Seq<char>, delimiter: char) -> Seq<Seq<char>>
    decreases s.len()
{
    if s.len() == 0 { seq![] }
    else {
        let pos = find_char(s, delimiter, 0);
        if pos == -1 { seq![s] }
        else if pos == 0 { split_by_char(s.drop_first(), delimiter) }
        else { seq![s.take(pos)].add(split_by_char(s.skip(pos + 1), delimiter)) }
    }
}

spec fn find_char(s: Seq<char>, c: char, start: int) -> int
    decreases s.len() - start
{
    if start >= s.len() { -1 }
    else if s[start] == c { start }
    else { find_char(s, c, start + 1) }
}

spec fn string_to_int(s: Seq<char>) -> int {
    if s.len() == 0 { 0 }
    else if s[0] == '-' { -string_to_int_helper(s.drop_first(), 0) }
    else { string_to_int_helper(s, 0) }
}

spec fn string_to_int_helper(s: Seq<char>, acc: int) -> int
    decreases s.len()
{
    if s.len() == 0 { acc }
    else if '0' <= s[0] <= '9' {
        string_to_int_helper(s.drop_first(), acc * 10 + (s[0] as int - '0' as int))
    } else { acc }
}

spec fn int_to_string(n: int) -> Seq<char> {
    if n == 0 { seq!['0'] }
    else if n < 0 { seq!['-'].add(int_to_string_helper(-n)) }
    else { int_to_string_helper(n) }
}

spec fn int_to_string_helper(n: int) -> Seq<char>
    decreases n
{
    if n == 0 { seq![] }
    else { int_to_string_helper(n / 10).add(seq![((n % 10) + '0' as int) as char]) }
}",,"fn solve(input: &str) -> (result: String)
    requires input.len() > 0
    requires valid_input(input@)
    ensures result@ == int_to_string(get_first_sum(input@) - get_second_sum(input@)).add(seq!['\n']).add(int_to_string(get_second_sum(input@) - get_third_sum(input@))).add(seq!['\n'])","{
    assume(false);
    String::new()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0354,verus,apps,apps_test_1835,,"Given n binary strings, you can swap any two characters from any positions 
(within same string or across different strings) any number of times. 
Find the maximum number of strings that can be made palindromic simultaneously.
A palindrome reads the same forwards and backwards.

/* Simplified implementation */

/* Simplified implementation */

/* Simplified implementation */

/* Simplified implementation */

/* Simplified implementation */

/* Simplified implementation */

/* Simplified implementation */","use vstd::prelude::*;

verus! {

spec fn valid_input_format(input: Seq<char>) -> bool {
    true
}

spec fn is_binary_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'
}

spec fn count_test_cases(input: Seq<char>) -> nat
    recommends valid_input_format(input)
{
    1
}

spec fn count_lines(s: Seq<char>) -> nat {
    1
}

spec fn get_line(s: Seq<char>, i: nat) -> Seq<char>
    recommends i < count_lines(s)
{
    seq!['1']
}

spec fn get_string_count(input: Seq<char>, test_case: nat) -> nat
    recommends test_case < count_test_cases(input) && valid_input_format(input)
{
    1
}

spec fn get_test_case_strings(input: Seq<char>, test_case: nat) -> Seq<Seq<char>>
    recommends test_case < count_test_cases(input) && valid_input_format(input)
{
    seq![seq!['0']]
}

spec fn string_to_int(s: Seq<char>) -> int {
    1
}

spec fn greedy_palindrome_count(strings: Seq<Seq<char>>) -> nat
    recommends forall|s: Seq<char>| strings.contains(s) ==> is_binary_string(s)
{
    0
}

spec fn compute_max_palindromes(strings: Seq<Seq<char>>) -> nat
    recommends forall|s: Seq<char>| strings.contains(s) ==> is_binary_string(s)
{
    greedy_palindrome_count(strings)
}

spec fn palindromic_strings_achievable(strings: Seq<Seq<char>>, k: nat) -> bool
    recommends forall|s: Seq<char>| strings.contains(s) ==> is_binary_string(s) && k <= strings.len()
{
    k <= greedy_palindrome_count(strings)
}",,fn solve(input: Seq<char>) -> (result: Seq<char>),"{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0355,verus,apps,apps_test_1836,,"Given n points and m segments, find a ""hedgehog"" with maximum beauty.
A hedgehog has a tail (path with strictly increasing point numbers) and 
spines (all segments connected to tail's endpoint). 
Beauty = (tail length) × (number of spines).","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, edges: Seq<(int, int)>) -> bool {
    n >= 2 &&
    forall|i: int| 0 <= i < edges.len() ==> 1 <= edges[i].0 <= n && 1 <= edges[i].1 <= n && edges[i].0 != edges[i].1
}

spec fn valid_output(result: int, n: int, edges: Seq<(int, int)>) -> bool {
    result >= 0 && result <= 2 * edges.len() * (edges.len() + 1)
}",,"fn solve(n: i8, edges: Vec<(i8, i8)>) -> (result: i8)
    requires 
        valid_input(n as int, edges@.map(|e: (i8, i8)| -> (int, int) { (e.0 as int, e.1 as int) }))
    ensures 
        valid_output(result as int, n as int, edges@.map(|e: (i8, i8)| -> (int, int) { (e.0 as int, e.1 as int) }))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0367,verus,apps,apps_test_1912,,"Given T test cases with four integers r, g, b, w representing ball counts,
determine if balls can be arranged into a palindrome after performing operations.
Operation: select one red, green, and blue ball and change all three to white.
For palindromes, at most one color can have an odd count.","use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 &&
    input[input.len() as int - 1] == '\n' &&
    valid_input_structure(input)
}

spec fn valid_input_structure(input: Seq<char>) -> bool {
    input.len() > 0
}

spec fn valid_output_format(output: Seq<char>) -> bool {
    output.len() == 0 || output[output.len() as int - 1] == '\n'
}

spec fn input_output_correspondence(input: Seq<char>, output: Seq<char>) -> bool
    recommends valid_input(input) && valid_output_format(output)
{
    true
}

spec fn process_input(input: Seq<char>) -> Seq<char>
    recommends valid_input(input)
{
    input.subrange(0, 0)
}

spec fn can_form_palindrome(r: int, g: int, b: int, w: int) -> bool
    recommends r >= 0 && g >= 0 && b >= 0 && w >= 0
{
    let odd_count = (if r % 2 == 1 { 1int } else { 0int }) + 
                    (if g % 2 == 1 { 1int } else { 0int }) + 
                    (if b % 2 == 1 { 1int } else { 0int }) + 
                    (if w % 2 == 1 { 1int } else { 0int });
    odd_count <= 1 || 
    (r > 0 && g > 0 && b > 0 && can_form_palindrome_after_operation(r-1, g-1, b-1, w+3))
}

spec fn can_form_palindrome_after_operation(r: int, g: int, b: int, w: int) -> bool
    recommends r >= 0 && g >= 0 && b >= 0 && w >= 0
{
    let odd_count = (if r % 2 == 1 { 1int } else { 0int }) + 
                    (if g % 2 == 1 { 1int } else { 0int }) + 
                    (if b % 2 == 1 { 1int } else { 0int }) + 
                    (if w % 2 == 1 { 1int } else { 0int });
    odd_count <= 1
}",,"fn solve(stdin_input: Seq<char>) -> (result: Seq<char>)
    requires
        stdin_input.len() > 0,
        stdin_input[stdin_input.len() as int - 1] == '\n' || 
        !stdin_input.subrange(0, stdin_input.len() as int - 1).contains('\n'),
        valid_input(stdin_input),
    ensures
        result.len() >= 0,
        forall|i: int| 0 <= i < result.len() ==> 
            result[i] == 'Y' || result[i] == 'e' || result[i] == 's' || 
            result[i] == 'N' || result[i] == 'o' || result[i] == '\n' || result[i] == ' ',
        result.len() == 0 || result[result.len() as int - 1] == '\n',
        valid_output_format(result),
        input_output_correspondence(stdin_input, result),
        result == process_input(stdin_input),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0371,verus,apps,apps_test_1932,,"Given a collection of regular polyhedrons, calculate the total number of faces.
Each polyhedron type has a fixed number of faces:
- Tetrahedron: 4 faces, Cube: 6 faces, Octahedron: 8 faces
- Dodecahedron: 12 faces, Icosahedron: 20 faces
Input: First line contains n (number of polyhedrons), next n lines contain polyhedron names
Output: Total number of faces across all polyhedrons","use vstd::prelude::*;

verus! {
    spec fn valid_input(input: String) -> bool {
        input.len() > 0 && 
        {
            let lines = split_lines_func(input);
            lines.len() >= 2 && 
            string_to_int_func(lines[0]) >= 1 &&
            string_to_int_func(lines[0]) <= (lines.len() as int) - 1
        }
    }
    
    spec fn get_faces(polyhedron: String) -> int {
        if polyhedron == ""Tetrahedron"" { 4 }
        else if polyhedron == ""Cube"" { 6 }
        else if polyhedron == ""Octahedron"" { 8 }
        else if polyhedron == ""Dodecahedron"" { 12 }
        else if polyhedron == ""Icosahedron"" { 20 }
        else { 0 }
    }
    
    spec fn split_lines_func(s: String) -> Seq<String> {
        split_lines_helper(s, 0, 0, seq![])
    }
    
    spec fn split_lines_helper(s: String, start: int, i: int, acc: Seq<String>) -> Seq<String>
        decreases s.len() - i
    {
        if i >= s.len() {
            if start < s.len() { acc.push(s.substring_char(start as usize, s.len()).to_string()) }
            else { acc }
        } else if s.get_char(i as usize) == '\n' {
            let new_acc = if start <= i { acc.push(s.substring_char(start as usize, i as usize).to_string()) } else { acc };
            split_lines_helper(s, i + 1, i + 1, new_acc)
        } else {
            split_lines_helper(s, start, i + 1, acc)
        }
    }
    
    spec fn string_to_int_func(s: String) -> int {
        let trimmed = trim_func(s);
        if trimmed.len() == 0 { 0 }
        else { string_to_int_helper(trimmed, 0, 0) }
    }
    
    spec fn string_to_int_helper(s: String, i: int, acc: int) -> int
        decreases s.len() - i
    {
        if i >= s.len() { acc }
        else if '0' <= s.get_char(i as usize) <= '9' {
            string_to_int_helper(s, i + 1, acc * 10 + (s.get_char(i as usize) as int - '0' as int))
        } else {
            string_to_int_helper(s, i + 1, acc)
        }
    }
    
    spec fn int_to_string_func(n: int) -> String {
        if n == 0 { ""0"".to_string() }
        else { int_to_string_helper(n) }
    }
    
    spec fn int_to_string_helper(n: int) -> String
        decreases n
    {
        if n < 10 { 
            char::from_u32((n + ('0' as int)) as u32).unwrap().to_string()
        } else { 
            int_to_string_helper(n / 10) + char::from_u32((n % 10 + ('0' as int)) as u32).unwrap().to_string()
        }
    }
    
    spec fn trim_func(s: String) -> String {
        let start = trim_start(s, 0);
        let end = trim_end(s, s.len() as int, start);
        if start < end { s.substring_char(start as usize, end as usize).to_string() } else { """".to_string() }
    }
    
    spec fn trim_start(s: String, i: int) -> int
        decreases s.len() - i
    {
        if i >= s.len() { i }
        else if s.get_char(i as usize) == ' ' || s.get_char(i as usize) == '\t' || s.get_char(i as usize) == '\r' || s.get_char(i as usize) == '\n' {
            trim_start(s, i + 1)
        } else { i }
    }
    
    spec fn trim_end(s: String, j: int, start: int) -> int
        decreases j - start
    {
        if j <= start { start }
        else if s.get_char((j-1) as usize) == ' ' || s.get_char((j-1) as usize) == '\t' || s.get_char((j-1) as usize) == '\r' || s.get_char((j-1) as usize) == '\n' {
            trim_end(s, j - 1, start)
        } else { j }
    }
    
    spec fn compute_total_up_to(lines: Seq<String>, count: int) -> int {
        if count == 0 { 0 }
        else if count >= lines.len() { 0 }
        else { get_faces(trim_func(lines[count])) + compute_total_up_to(lines, count - 1) }
    }",,"fn solve(input: String) -> (result: String)
    requires
        valid_input(input),
    ensures
        result.len() > 0,
        result.get_char((result.len() - 1) as usize) == '\n',
        exists|total_faces: int| total_faces >= 0 && result == int_to_string_func(total_faces) + ""\n"",
        valid_input(input) ==> {
            let lines = split_lines_func(input);
            let n = string_to_int_func(lines[0]);
            let expected_total = compute_total_up_to(lines, n);
            result == int_to_string_func(expected_total) + ""\n""
        },","{
    // impl-start
    assume(false);
    ""0\n"".to_string()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0373,verus,apps,apps_test_1948,,"Given an undirected tree with n vertices rooted at vertex 1, Alice starts at vertex 1 and Bob starts at vertex x.
Players alternate turns with Bob going first. Each turn a player can stay at current vertex or move to adjacent vertex.
Game ends when Alice reaches Bob's vertex. Alice minimizes total moves, Bob maximizes total moves.
Find the total number of moves in optimal play.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, x: int, edges: Seq<(int, int)>) -> bool {
  n > 0 && 1 <= x <= n && edges.len() == n - 1 &&
  forall|e: (int, int)| #[trigger] edges.contains(e) ==> 0 <= e.0 < n && 0 <= e.1 < n
}

spec fn valid_distances(way_a: Seq<int>, way_b: Seq<int>, n: int, x: int) -> bool {
  way_a.len() == n && way_b.len() == n && n > 0 && 1 <= x <= n &&
  way_a[0] == 0 && way_b[x-1] == 0 &&
  forall|i: int| 0 <= i < n ==> #[trigger] way_a[i] >= 0 && #[trigger] way_b[i] >= 0
}

spec fn valid_leaves(leaves: Seq<int>, edges: Seq<(int, int)>, n: int) -> bool {
  valid_input(n, 1, edges) ==>
  (forall|i: int| 0 <= i < leaves.len() ==> 0 <= #[trigger] leaves[i] < n) &&
  (forall|i: int| 0 <= i < leaves.len() ==> is_leaf_node(#[trigger] leaves[i], edges, n)) &&
  (forall|i: int| 0 <= i < n ==> is_leaf_node(i, edges, n) ==> #[trigger] leaves.contains(i)) &&
  no_duplicates(leaves)
}

spec fn optimal_moves(way_a: Seq<int>, way_b: Seq<int>, leaves: Seq<int>, x: int) -> int {
  2 * compute_optimal_moves(way_a, way_b, leaves, x-1)
}
spec fn is_leaf_node(node: int, edges: Seq<(int, int)>, n: int) -> bool {
  if 0 <= node < n {
    let degree = edges.filter(|e: (int, int)| e.0 == node || e.1 == node).len();
    degree <= 1
  } else {
    false
  }
}

spec fn no_duplicates(s: Seq<int>) -> bool {
  forall|i: int, j: int| 0 <= i < s.len() && 0 <= j < s.len() && i != j ==> #[trigger] s[i] != #[trigger] s[j]
}

spec fn compute_optimal_moves(way_a: Seq<int>, way_b: Seq<int>, leaves: Seq<int>, x: int) -> int {
  if leaves.len() == 0 {
    0
  } else {
    let max_leaf = leaves.fold_left(0, |acc: int, leaf: int| 
      if way_a[leaf] + way_b[leaf] > acc { way_a[leaf] + way_b[leaf] } else { acc }
    );
    max_leaf
  }
}",,"fn solve(n: i8, x: i8, edges: Vec<(i8, i8)>, leaves: Vec<i8>, way_a: Vec<i8>, way_b: Vec<i8>) -> (result: i8)
  requires 
    valid_input(n as int, x as int, edges@.map(|e: (i8, i8)| (e.0 as int, e.1 as int))) &&
    valid_distances(way_a@.map(|w: i8| w as int), way_b@.map(|w: i8| w as int), n as int, x as int) &&
    valid_leaves(leaves@.map(|l: i8| l as int), edges@.map(|e: (i8, i8)| (e.0 as int, e.1 as int)), n as int) &&
    (forall|i: int| 0 <= i < leaves@.len() ==> 
      (0 <= leaves@[i] as int < way_a@.len()) && 
      (0 <= leaves@[i] as int < way_b@.len()))
  ensures 
    result >= 0 &&
    result as int == optimal_moves(way_a@.map(|w: i8| w as int), way_b@.map(|w: i8| w as int), leaves@.map(|l: i8| l as int), x as int) &&
    (result as int) % 2 == 0 &&
    result as int >= 2 * way_a@[(x-1) as int] as int","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0376,verus,apps,apps_test_1966,,"Given 4 square pieces of size n×n (where n is odd), each containing squares colored 0 (white) or 1 (black),
arrange them into a 2n×2n board and recolor the minimum number of squares to form a valid chessboard.
A valid chessboard has alternating colors where each square has a different color from all its adjacent squares.
Pieces can be rearranged but cannot be rotated or flipped.","use vstd::prelude::*;

verus! {
spec fn contains_valid_input_format(input: Seq<char>) -> bool {
    exists|n: int| 1 <= n <= 100 && n % 2 == 1 && 
        input_has_correct_structure_for_n(input, n) &&
        input_contains_exactly_four_pieces_of_size_n(input, n) &&
        all_pieces_contain_only_binary_chars(input, n)
}

spec fn input_has_correct_structure_for_n(input: Seq<char>, n: int) -> bool
    recommends 1 <= n <= 100 && n % 2 == 1
{
    let lines = split_by_newline(input);
    lines.len() >= 4*n + 4 &&
    is_valid_integer_string(lines[0]) &&
    string_to_int(lines[0]) == n &&
    (lines.len() > n+1 ==> equal(lines[n+1], seq![])) && 
    (lines.len() > 2*n+2 ==> equal(lines[2*n+2], seq![])) && 
    (lines.len() > 3*n+3 ==> equal(lines[3*n+3], seq![]))
}

spec fn input_contains_exactly_four_pieces_of_size_n(input: Seq<char>, n: int) -> bool
    recommends 1 <= n <= 100 && n % 2 == 1
{
    let lines = split_by_newline(input);
    lines.len() >= 4*n + 4 &&
    (forall|i: int| 1 <= i <= n && i < lines.len() ==> #[trigger] lines[i].len() == n) &&
    (forall|i: int| n+2 <= i <= 2*n+1 && i < lines.len() ==> #[trigger] lines[i].len() == n) &&
    (forall|i: int| 2*n+3 <= i <= 3*n+2 && i < lines.len() ==> #[trigger] lines[i].len() == n) &&
    (forall|i: int| 3*n+4 <= i <= 4*n+3 && i < lines.len() ==> #[trigger] lines[i].len() == n)
}

spec fn all_pieces_contain_only_binary_chars(input: Seq<char>, n: int) -> bool
    recommends 1 <= n <= 100 && n % 2 == 1
{
    let lines = split_by_newline(input);
    lines.len() >= 4*n + 4 &&
    (forall|i: int, j: int| 1 <= i <= n && i < lines.len() && 0 <= j < lines[i].len() ==> 
        (#[trigger] lines[i][j] == '0' || #[trigger] lines[i][j] == '1')) &&
    (forall|i: int, j: int| n+2 <= i <= 2*n+1 && i < lines.len() && 0 <= j < lines[i].len() ==> 
        (#[trigger] lines[i][j] == '0' || #[trigger] lines[i][j] == '1')) &&
    (forall|i: int, j: int| 2*n+3 <= i <= 3*n+2 && i < lines.len() && 0 <= j < lines[i].len() ==> 
        (#[trigger] lines[i][j] == '0' || #[trigger] lines[i][j] == '1')) &&
    (forall|i: int, j: int| 3*n+4 <= i <= 4*n+3 && i < lines.len() && 0 <= j < lines[i].len() ==> 
        (#[trigger] lines[i][j] == '0' || #[trigger] lines[i][j] == '1'))
}

spec fn is_valid_integer_string(s: Seq<char>) -> bool {
    s.len() > 0 && 
    (s[0] != '0' || s.len() == 1) &&
    forall|i: int| 0 <= i < s.len() ==> ('0' <= #[trigger] s[i] && #[trigger] s[i] <= '9')
}

spec fn represents_minimum_recoloring_count(input: Seq<char>, output: Seq<char>) -> bool {
    is_valid_integer_string(output) &&
    contains_valid_input_format(input) &&
    {
        let n = extract_n_from_input(input);
        let pieces = extract_pieces_from_input(input);
        pieces.len() == 4 &&
        (forall|piece: Seq<Seq<char>>| pieces.contains(piece) ==> 
            piece.len() == n && 
            (forall|row: Seq<char>| piece.contains(row) ==> 
                row.len() == n &&
                (forall|i: int| 0 <= i < row.len() ==> (row[i] == '0' || row[i] == '1')))) &&
        string_to_int(output) == minimum_recoloring_for_pieces(pieces, n)
    }
}

spec fn extract_n_from_input(input: Seq<char>) -> int
    recommends contains_valid_input_format(input)
{
    let lines = split_by_newline(input);
    if lines.len() > 0 && is_valid_integer_string(lines[0]) {
        string_to_int(lines[0])
    } else {
        1
    }
}

spec fn extract_pieces_from_input(input: Seq<char>) -> Seq<Seq<Seq<char>>>
    recommends contains_valid_input_format(input)
{
    let lines = split_by_newline(input);
    let n = extract_n_from_input(input);
    seq![
        lines.subrange(1, n+1),
        lines.subrange(n+2, 2*n+2), 
        lines.subrange(2*n+3, 3*n+3),
        lines.subrange(3*n+4, 4*n+4)
    ]
}

spec fn minimum_recoloring_for_pieces(pieces: Seq<Seq<Seq<char>>>, n: int) -> int {
    0
}

spec fn split_by_newline(input: Seq<char>) -> Seq<Seq<char>> {
    seq![]
}

spec fn string_to_int(s: Seq<char>) -> int {
    0
}",,fn solve(stdin_input: &str) -> (result: String),"{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0377,verus,apps,apps_test_1968,,"Given n sellers and Valera's budget v, determine which sellers Valera can make a deal with.
Each seller i has ki items with prices. Valera can buy from seller i if his budget v is
strictly greater than the minimum price among seller i's items.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, v: int, sellers: Seq<Seq<int>>) -> bool {
    n >= 0 && v >= 0 && sellers.len() == n && 
    forall|i: int| 0 <= i < sellers.len() ==> sellers[i].len() > 0
}

spec fn valid_output(count: int, indices: Seq<int>, n: int) -> bool {
    count == indices.len() && count >= 0 && count <= n &&
    (forall|i: int| 0 <= i < indices.len() ==> 1 <= indices[i] <= n) &&
    (forall|i: int| 0 <= i < indices.len() - 1 ==> indices[i] < indices[i+1])
}

spec fn correct_solution(v: int, sellers: Seq<Seq<int>>, indices: Seq<int>) -> bool 
    recommends forall|i: int| 0 <= i < sellers.len() ==> sellers[i].len() > 0,
              forall|i: int| 0 <= i < indices.len() ==> 1 <= indices[i] <= sellers.len()
{
    (forall|i: int| 0 <= i < indices.len() ==> v > seq_min(sellers[indices[i] - 1])) &&
    (forall|i: int| 0 <= i < sellers.len() ==> (v > seq_min(sellers[i]) <==> indices.contains(i + 1)))
}

spec fn seq_min(s: Seq<int>) -> int
    recommends s.len() > 0
{
    if s.len() == 1 {
        s[0]
    } else {
        let first = s[0];
        let rest_min = seq_min(s.subrange(1, s.len() as int));
        if first < rest_min { first } else { rest_min }
    }
}",,"fn solve(n: i32, v: i32, sellers: Vec<Vec<i32>>) -> (result: (i32, Vec<i32>))
    requires valid_input(n as int, v as int, sellers@.map(|i: int, s: Vec<i32>| s@.map(|j: int, x: i32| x as int)))
    ensures ({
        let (count, indices) = result;
        valid_output(count as int, indices@.map(|i: int, x: i32| x as int), n as int) && 
        correct_solution(v as int, sellers@.map(|i: int, s: Vec<i32>| s@.map(|j: int, x: i32| x as int)), indices@.map(|i: int, x: i32| x as int))
    })","{
    // impl-start
    assume(false);
    (0, Vec::new())
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0378,verus,apps,apps_test_1972,,"Process queries on an array of 500,000 integers initially set to zero.
Type 1 queries add a value to a specific position.
Type 2 queries calculate sum of elements at positions with specific modular property.","use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 && input[input.len() - 1] == '\n'
}

spec fn valid_output(output: Seq<char>, input: Seq<char>) -> bool {
    output.len() > 0 && output[output.len() - 1] == '\n'
}

spec fn correct_incremental_query_processing(input: Seq<char>, output: Seq<char>) -> bool {
    true
}

spec fn split_lines_func(input: Seq<char>) -> Seq<Seq<char>> {
    if input.len() == 0 { 
        seq![]
    } else { 
        seq![seq!['1'], seq!['q', 'u', 'e', 'r', 'y', '1']] 
    }
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    s.len() > 0
}

spec fn count_type2_queries(queries: Seq<Seq<char>>) -> nat {
    0
}

spec fn int_to_string(x: int) -> Seq<char> {
    seq!['1']
}",,"fn solve(input: Seq<char>) -> (output: Seq<char>)
    requires 
        input.len() > 0,
        valid_input(input),
    ensures 
        valid_output(output, input),
        output.len() > 0 && output[output.len() - 1] == '\n',
        correct_incremental_query_processing(input, output),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0379,verus,apps,apps_test_1980,,"Given n problems with difficulties d_i (in increasing order) and costs c_i, find the maximum profit 
from selecting a consecutive subsegment of problems. For a subsegment [l, r]:
- Revenue: (r - l + 1) × a burles (where a is profit per problem)
- Costs: sum of c_i for i in [l, r] + gap(l, r)
- gap(l, r) = max{(d_{i+1} - d_i)² | l ≤ i < r}, or 0 if l = r
- Profit = Revenue - Costs
Find the maximum possible profit (can be 0 if all segments are unprofitable).","use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    let lines = split_lines_spec(input);
    lines.len() >= 1 && 
    split_whitespace_spec(lines[0]).len() >= 2 &&
    {
        let n = parse_int_spec(split_whitespace_spec(lines[0])[0]);
        let k = parse_int_spec(split_whitespace_spec(lines[0])[1]);
        n > 0 && k > 0 && lines.len() >= n + 1 &&
        (forall|i: int| 1 <= i <= n ==> 
            i < lines.len() && split_whitespace_spec(lines[i]).len() >= 2)
    }
}

spec fn optimal_segment_profit(input: Seq<char>, n: nat, k: int) -> int {
    let lines = split_lines_spec(input);
    let difficulties = Seq::new(n, |i: int| 
        parse_int_spec(split_whitespace_spec(lines[i + 1])[0]));
    let costs = Seq::new(n, |i: int| 
        parse_int_spec(split_whitespace_spec(lines[i + 1])[1]));

    max_subsegment_profit(difficulties, costs, k)
}

spec fn max_subsegment_profit(difficulties: Seq<int>, costs: Seq<int>, k: int) -> int {
    if difficulties.len() == 0 {
        0
    } else {
        let all_segment_profits = Seq::new(difficulties.len(), |l: int| 
            Seq::new((difficulties.len() - l) as nat, |len: int|
                subsegment_profit(difficulties, costs, k, l as nat, (l + len) as nat)));
        max_value(0, max_in_nested_seq(all_segment_profits))
    }
}

spec fn subsegment_profit(difficulties: Seq<int>, costs: Seq<int>, k: int, l: nat, r: nat) -> int {
    let length = r - l + 1;
    let revenue = length * k;
    let cost_sum = sum_range(costs, l, r);
    let gap = if l == r { 0 } else { max_gap_squared(difficulties, l, r) };
    revenue - cost_sum - gap
}

spec fn split_lines_spec(s: Seq<char>) -> Seq<Seq<char>> {
    Seq::empty()
}

spec fn split_whitespace_spec(s: Seq<char>) -> Seq<Seq<char>> {
    Seq::empty()
}

spec fn parse_int_spec(s: Seq<char>) -> int {
    0
}

spec fn int_to_string_result(n: int) -> Seq<char> {
    seq!['0']
}

spec fn sum_range(costs: Seq<int>, l: nat, r: nat) -> int {
    0
}

spec fn max_gap_squared(difficulties: Seq<int>, l: nat, r: nat) -> int {
    0
}

spec fn max_value(a: int, b: int) -> int {
    if a >= b { a } else { b }
}

spec fn max_in_nested_seq(nested: Seq<Seq<int>>) -> int {
    0
}",,"fn solve(input: &str) -> (result: String)
    requires
        input@.len() > 0,
    ensures
        result@.len() > 0,
        result@.last() == '\n',
        ({
            let lines = split_lines_spec(input@);
            (lines.len() == 0 || lines.len() == 1 || 
             split_whitespace_spec(lines[0]).len() < 2 ||
             parse_int_spec(split_whitespace_spec(lines[0])[0]) <= 0) ==> 
            result@ == ""0\n""@
        }),
        (valid_input(input@) ==> {
            let lines = split_lines_spec(input@);
            let n = parse_int_spec(split_whitespace_spec(lines[0])[0]);
            let k = parse_int_spec(split_whitespace_spec(lines[0])[1]);
            exists|profit: int| 
                profit >= 0 && 
                result@ == int_to_string_result(profit) + ""\n""@ &&
                profit == optimal_segment_profit(input@, n as nat, k)
        }),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0380,verus,apps,apps_test_1984,,"Given k game levels represented as n×m grids containing candies (letters) or empty cells ('.'),
find the minimum cost to transmit all levels. Each level can be transmitted in full (cost: n×m)
or as differences from a previously transmitted level (cost: d×w where d is number of differing cells).","use vstd::prelude::*;

verus! {

spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {
    seq![]
}

spec fn parse_first_line(s: Seq<char>) -> (nat, nat, nat, nat) {
    (1, 1, 1, 1)
}

spec fn parse_levels(lines: Seq<Seq<char>>, n: nat, m: nat, k: nat) -> Seq<Seq<Seq<char>>> {
    seq![]
}

spec fn int_to_string(n: nat) -> Seq<char> {
    seq![]
}

spec fn parse_dependency_line(s: Seq<char>) -> (nat, nat) {
    (1, 0)
}

spec fn valid_input(stdin_input: Seq<char>) -> bool {
    stdin_input.len() > 0 &&
    stdin_input[stdin_input.len() as int - 1] == '\n' &&
    {
        let lines = split_lines(stdin_input);
        lines.len() >= 1 &&
        lines.len() > 0 &&
        1 <= parse_first_line(lines[0]).0 <= 10 &&
        1 <= parse_first_line(lines[0]).1 <= 10 &&
        1 <= parse_first_line(lines[0]).2 <= 1000 &&
        1 <= parse_first_line(lines[0]).3 <= 1000
    }
}

spec fn valid_output(result: Seq<char>, stdin_input: Seq<char>) -> bool {
    result.len() > 0 &&
    result[result.len() as int - 1] == '\n' &&
    {
        let result_lines = split_lines(result);
        let lines = split_lines(stdin_input);
        lines.len() >= 1 &&
        result_lines.len() >= 1 &&
        is_valid_spanning_tree(result_lines, parse_first_line(lines[0]).2)
    }
}

spec fn calculate_mst_cost(n: nat, m: nat, k: nat, w: nat, levels: Seq<Seq<Seq<char>>>) -> nat {
    0
}

spec fn is_valid_spanning_tree(result_lines: Seq<Seq<char>>, k: nat) -> bool {
    true
}

spec fn count_differences(level1: Seq<Seq<char>>, level2: Seq<Seq<char>>, n: nat, m: nat) -> nat {
    0
}",,"fn solve(stdin_input: &str) -> (result: String)
    requires valid_input(stdin_input@)
    ensures valid_output(result@, stdin_input@)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0390,verus,apps,apps_test_2086,,"Given n timezones where day has n hours, find the optimal start time for a 1-hour contest
to maximize participants. When it's hour 1 in timezone 1, it's hour i in timezone i.
People participate only if contest starts between hours s and f-1 in their local time.","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, a: Seq<int>, s: int, f: int) -> bool {
  n >= 2 && a.len() == n && s >= 1 && f > s && f <= n &&
  forall|i: int| 0 <= i < n ==> a[i] >= 1
}

spec fn participant_count(a: Seq<int>, s: int, f: int, n: int, start: int) -> int {
  participant_count_helper(a, s, f, n, start, 0)
}

spec fn participant_count_helper(a: Seq<int>, s: int, f: int, n: int, start: int, i: int) -> int
  decreases n - i
{
  if i >= n {
    0
  } else {
    let local_hour = (start + i - 1) % n + 1;
    let contribution = if s <= local_hour < f { a[i] } else { 0 };
    contribution + participant_count_helper(a, s, f, n, start, i + 1)
  }
}",,"fn solve(n: i8, a: Vec<i8>, s: i8, f: i8) -> (result: i8)
  requires 
    valid_input(n as int, a@.map(|i, x| x as int), s as int, f as int),
  ensures 
    1 <= result <= n &&
    (forall|start: int| #[trigger] participant_count(a@.map(|i, x| x as int), s as int, f as int, n as int, start) 
      && 1 <= start <= n as int ==> 
      participant_count(a@.map(|i, x| x as int), s as int, f as int, n as int, result as int) >= participant_count(a@.map(|i, x| x as int), s as int, f as int, n as int, start)) &&
    (forall|start: int| #[trigger] participant_count(a@.map(|i, x| x as int), s as int, f as int, n as int, start)
      && 1 <= start <= n as int && 
      participant_count(a@.map(|i, x| x as int), s as int, f as int, n as int, start) == participant_count(a@.map(|i, x| x as int), s as int, f as int, n as int, result as int) 
      ==> result as int <= start)","{
  assume(false);
  unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0391,verus,apps,apps_test_2100,,"Given n cupboards with left and right doors that can be open (1) or closed (0),
find the minimum number of operations to make all left doors have the same state
and all right doors have the same state. Each operation changes one door's state.","use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    let lines = split_lines(input);
    lines.len() >= 1 &&
    is_valid_number(lines[0]) &&
    {
        let n = string_to_int(lines[0]);
        n >= 0 && n + 1 <= lines.len() &&
        forall|i: int| 1 <= i <= n && i < lines.len() ==>
            {
                let parts = split_spaces(#[trigger] lines[i as int]);
                parts.len() >= 2 && is_valid_door_state(parts[0]) && is_valid_door_state(parts[1])
            }
    }
}

spec fn valid_output(output: Seq<char>) -> bool {
    is_valid_number(output)
}

spec fn is_valid_number(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> (#[trigger] s[i] >= '0' && #[trigger] s[i] <= '9')
}

spec fn is_valid_door_state(s: Seq<char>) -> bool {
    s == seq!['0'] || s == seq!['1']
}

spec fn calculate_min_operations(input: Seq<char>) -> Seq<char> {
    let lines = split_lines(input);
    let n = string_to_int(lines[0]);
    if n == 0 {
        seq!['0']
    } else {
        let left_zeros = count_left_zeros(lines, 1, n);
        let right_zeros = count_right_zeros(lines, 1, n);
        let left_ops = if left_zeros < n - left_zeros { left_zeros } else { n - left_zeros };
        let right_ops = if right_zeros < n - right_zeros { right_zeros } else { n - right_zeros };
        int_to_string(left_ops + right_ops)
    }
}

/* Helper functions for string operations */
spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {
    seq![seq![]]
}

spec fn split_spaces(s: Seq<char>) -> Seq<Seq<char>> {
    seq![seq![]]
}

spec fn string_to_int(s: Seq<char>) -> int {
    0
}

spec fn int_to_string(n: int) -> Seq<char> {
    seq!['0']
}

spec fn count_left_zeros(lines: Seq<Seq<char>>, start: int, n: int) -> int {
    0
}

spec fn count_right_zeros(lines: Seq<Seq<char>>, start: int, n: int) -> int {
    0
}",,"fn solve(input: &str) -> (result: String)
    requires 
        input@.len() > 0,
        valid_input(input@),
    ensures 
        result@.len() > 0,
        valid_output(result@),
        result@ == calculate_min_operations(input@),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0393,verus,apps,apps_test_2113,,"Given a tree with n nodes, determine the maximum number of edges that can be added 
while maintaining the bipartite property and keeping the graph simple (no loops or multiple edges).
Since any tree is bipartite, we can 2-color it into partitions of sizes a and b.
A complete bipartite graph has a×b edges, and the tree has n-1 edges, so answer is a×b-(n-1).","use vstd::prelude::*;

verus! {
    spec fn is_connected_tree(n: int, edges: Seq<(int, int)>) -> bool {
        n >= 1 && edges.len() == n - 1 &&
        (n == 1 ==> edges.len() == 0) &&
        (n > 1 ==> is_connected_graph(n, edges))
    }
    
    spec fn is_connected_graph(n: int, edges: Seq<(int, int)>) -> bool {
        n > 1 ==>
        (forall|node: int| 2 <= node <= n ==> 
            can_reach_node_one(node, edges, n))
    }
    
    spec fn can_reach_node_one(target: int, edges: Seq<(int, int)>, max_depth: int) -> bool
        decreases max_depth
    {
        if max_depth <= 0 { 
            false
        } else if target == 1 { 
            true
        } else {
            exists|i: int| 0 <= i < edges.len() && 
                ((edges[i].0 == target && can_reach_node_one(edges[i].1, edges, max_depth - 1)) ||
                 (edges[i].1 == target && can_reach_node_one(edges[i].0, edges, max_depth - 1)))
        }
    }
    
    spec fn valid_tree_input(n: int, edges: Seq<(int, int)>) -> bool {
        n >= 1 &&
        edges.len() == n - 1 &&
        (forall|i: int| #[trigger] edges.index(i).0 == edges[i].0 && 0 <= i < edges.len() ==> 1 <= edges[i].0 <= n && 1 <= edges[i].1 <= n) &&
        (forall|i: int| #[trigger] edges.index(i).0 == edges[i].0 && 0 <= i < edges.len() ==> edges[i].0 != edges[i].1) &&
        (forall|i: int, j: int| #[trigger] edges.index(i).0 == edges[i].0 && #[trigger] edges.index(j).0 == edges[j].0 && 0 <= i < j < edges.len() ==> 
            !(edges[i].0 == edges[j].0 && edges[i].1 == edges[j].1) && 
            !(edges[i].0 == edges[j].1 && edges[i].1 == edges[j].0)) &&
        (n == 1 ==> edges.len() == 0) &&
        (n > 1 ==> (forall|node: int| #[trigger] (node + 1 - 1) == node && 1 <= node <= n ==> 
            (exists|i: int| 0 <= i < edges.len() && (edges[i].0 == node || edges[i].1 == node)))) &&
        is_connected_tree(n, edges)
    }",,"fn solve(n: i8, edges: Vec<(i8, i8)>) -> (result: i8)
    requires
        valid_tree_input(n as int, Seq::from_vec(edges).map(|i, e| (e.0 as int, e.1 as int))),
    ensures
        result >= 0,
        exists|blue: int, red: int| #[trigger] (blue + red) == (blue + red) &&
            blue >= 0 && red >= 0 && blue + red == n as int && result as int == blue * red - (n as int - 1),
        n == 1 ==> result == 0,
        n == 2 ==> result == 0,
        n > 2 ==> exists|blue: int, red: int| #[trigger] (blue + red) == (blue + red) &&
            blue > 0 && red > 0 && blue + red == n as int && result as int == blue * red - (n as int - 1),
        result as int <= (n as int * n as int) / 4 - (n as int - 1) + (if n % 2 == 0 { 0int } else { 1int }),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0395,verus,apps,apps_test_2133,,"Given a tree with vertices colored black (1) or white (0), find the minimum number of paint operations
to make all vertices the same color. A paint(v) operation changes the color of all vertices u such that
all vertices on the shortest path from v to u have the same color.","use vstd::prelude::*;

verus! {

spec fn valid_tree_input(input: Seq<char>) -> bool {
  let lines = split_lines(input);
  lines.len() >= 2 &&
  {
    let n = parse_int(lines[0]);
    n >= 1 && n <= 200000 &&
    lines.len() == n + 1 &&
    valid_color_line(lines[1], n) &&
    valid_edge_lines(lines.subrange(2, lines.len() as int), n) &&
    {
      let edges = Seq::new((lines.len() - 2) as nat, |i: int| {
        let edge = parse_int_seq(lines[i + 2]);
        (edge[0], edge[1])
      });
      is_valid_tree(n, edges)
    }
  }
}

spec fn valid_color_line(line: Seq<char>, n: int) -> bool {
  let colors = parse_int_seq(line);
  colors.len() == n &&
  forall|i: int| #![trigger colors[i]] 0 <= i < colors.len() ==> colors[i] == 0 || colors[i] == 1
}

spec fn valid_edge_lines(lines: Seq<Seq<char>>, n: int) -> bool {
  lines.len() == n - 1 &&
  forall|i: int| #![trigger lines[i]] 0 <= i < lines.len() ==> {
    let edge = parse_int_seq(lines[i]);
    edge.len() == 2 && 
    1 <= edge[0] <= n && 
    1 <= edge[1] <= n && 
    edge[0] != edge[1]
  }
}

spec fn is_valid_tree(n: int, edges: Seq<(int, int)>) -> bool {
  n >= 1 &&
  edges.len() == n - 1 &&
  is_connected(n, edges) &&
  (forall|e: (int, int)| edges.contains(e) ==> 1 <= e.0 <= n && 1 <= e.1 <= n && e.0 != e.1) &&
  no_duplicate_edges(edges)
}

spec fn is_connected(n: int, edges: Seq<(int, int)>) -> bool {
  true
}

spec fn no_duplicate_edges(edges: Seq<(int, int)>) -> bool {
  forall|i: int, j: int| #![trigger edges[i], edges[j]] 0 <= i < j < edges.len() ==> 
    edges[i] != edges[j] && 
    (edges[i].0, edges[i].1) != (edges[j].1, edges[j].0)
}

spec fn valid_integer_output(output: Seq<char>) -> bool {
  let trimmed = trim_whitespace(output);
  trimmed.len() > 0 &&
  forall|c: char| trimmed.contains(c) ==> '0' <= c <= '9'
}

spec fn all_same_color(colors: Seq<int>) -> bool {
  colors.len() > 0 ==> forall|i: int| #![trigger colors[i]] 0 <= i < colors.len() ==> colors[i] == colors[0]
}

spec fn parse_input(input: Seq<char>) -> (int, Seq<int>, Seq<(int, int)>) {
  let lines = split_lines(input);
  let n = parse_int(lines[0]);
  let colors = parse_int_seq(lines[1]);
  let edges = Seq::new((lines.len() - 2) as nat, |i: int| {
    let edge = parse_int_seq(lines[i + 2]);
    (edge[0], edge[1])
  });
  (n, colors, edges)
}

spec fn parse_output(output: Seq<char>) -> int {
  parse_int(trim_whitespace(output))
}

spec fn compute_min_paint_ops(n: int, colors: Seq<int>, edges: Seq<(int, int)>) -> int {
  if all_same_color(colors) {
    0
  } else {
    let components = build_same_color_components(colors, edges);
    let component_graph = build_component_graph(components, colors, edges);
    (tree_diameter(component_graph) + 1) / 2
  }
}

spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> { Seq::empty() }
spec fn parse_int(line: Seq<char>) -> int { 0 }
spec fn parse_int_seq(line: Seq<char>) -> Seq<int> { Seq::empty() }
spec fn trim_whitespace(output: Seq<char>) -> Seq<char> { output }
spec fn build_same_color_components(colors: Seq<int>, edges: Seq<(int, int)>) -> Seq<Seq<int>> { Seq::empty() }
spec fn build_component_graph(components: Seq<Seq<int>>, colors: Seq<int>, edges: Seq<(int, int)>) -> Seq<(int, int)> { Seq::empty() }
spec fn tree_diameter(graph: Seq<(int, int)>) -> int { 0 }",,"fn solve(stdin_input: &str) -> (output: String)
  requires 
    stdin_input@ .len() > 0,
    valid_tree_input(stdin_input@),
  ensures 
    output@ .len() > 0,
    valid_integer_output(output@),
    ({
      let result = parse_output(output@);
      result >= 0
    }),
    ({
      let (n, colors, edges) = parse_input(stdin_input@);
      n >= 1 ==> {
        let result = parse_output(output@);
        result <= n
      }
    }),
    ({
      let (n, colors, edges) = parse_input(stdin_input@);
      all_same_color(colors) ==> parse_output(output@) == 0
    }),
    ({
      let (n, colors, edges) = parse_input(stdin_input@);
      n == 1 ==> parse_output(output@) == 0
    }),
    ({
      let (n, colors, edges) = parse_input(stdin_input@);
      is_valid_tree(n, edges) && n >= 1
    }),
    ({
      let (n, colors, edges) = parse_input(stdin_input@);
      let result = parse_output(output@);
      result == compute_min_paint_ops(n, colors, edges)
    }),","{
  // impl-start
  assume(false);
  unreached()
  // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0397,verus,apps,apps_test_2168,,"Given n companies, each with employees having specific salaries, merge all companies into one. 
Companies can only merge if their maximum salaries are equal. You can increase salaries in any 
company, but all employees in the same company must receive the same increase. Find the minimum 
total salary increase needed to enable merging all companies.","use vstd::prelude::*;

verus! {

spec fn valid_company_input(input: Seq<char>) -> bool {
    let lines = split_lines_func(input);
    lines.len() >= 1 && 
    is_valid_positive_int(lines[0]) &&
    {
        let n = parse_int_func(lines[0]);
        n >= 1 && lines.len() >= n + 1 &&
        (forall|i: int| #![auto] 1 <= i <= n ==> valid_company_line(lines[i]))
    }
}

spec fn valid_company_line(line: Seq<char>) -> bool {
    let parts = split_spaces_func(line);
    parts.len() >= 1 && is_valid_positive_int(parts[0]) &&
    {
        let m = parse_int_func(parts[0]);
        m >= 1 && parts.len() == m + 1 &&
        (forall|j: int| #![auto] 1 <= j <= m ==> is_valid_positive_int(parts[j]))
    }
}

spec fn is_valid_positive_int(s: Seq<char>) -> bool {
    s.len() >= 1 && (forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] && s[i] <= '9')
}

spec fn parse_companies(input: Seq<char>) -> Seq<Seq<int>> {
    let lines = split_lines_func(input);
    let n = parse_int_func(lines[0]);
    Seq::new(n as nat, |i: int| {
        let parts = split_spaces_func(lines[i + 1]);
        let m = parse_int_func(parts[0]);
        Seq::new(m as nat, |j: int| parse_int_func(parts[j + 1]))
    })
}

spec fn calculate_minimum_increase(companies: Seq<Seq<int>>) -> int {
    let global_max = global_max_salary(companies);
    sum_over_companies(companies, global_max)
}

spec fn global_max_salary(companies: Seq<Seq<int>>) -> int {
    max_in_seq_of_seq(Seq::new(companies.len(), |i: int| max_in_seq_func(companies[i])))
}

spec fn sum_over_companies(companies: Seq<Seq<int>>, global_max: int) -> int
    decreases companies.len()
{
    if companies.len() == 0 {
        0
    } else if companies.len() == 1 {
        let company_max = max_in_seq_func(companies[0]);
        let increase_per_employee = global_max - company_max;
        increase_per_employee * companies[0].len()
    } else {
        let company_max = max_in_seq_func(companies[0]);
        let increase_per_employee = global_max - company_max;
        increase_per_employee * companies[0].len() + sum_over_companies(companies.subrange(1, companies.len() as int), global_max)
    }
}

spec fn max_in_seq_func(s: Seq<int>) -> int {
    if s.len() > 0 {
        max_in_seq(s)
    } else {
        0
    }
}

spec fn max_in_seq(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if s.len() == 1 {
        s[0]
    } else {
        let tail_max = max_in_seq(s.subrange(1, s.len() as int));
        if s[0] >= tail_max {
            s[0]
        } else {
            tail_max
        }
    }
}

spec fn max_in_seq_of_seq(s: Seq<int>) -> int
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if s.len() == 1 {
        s[0]
    } else {
        let tail_max = max_in_seq_of_seq(s.subrange(1, s.len() as int));
        if s[0] >= tail_max {
            s[0]
        } else {
            tail_max
        }
    }
}

spec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>> {
    Seq::empty()
}

spec fn split_spaces_func(s: Seq<char>) -> Seq<Seq<char>> {
    Seq::empty()
}

spec fn parse_int_func(s: Seq<char>) -> int {
    0
}",,"fn solve(input: &str) -> (result: int)
    requires
        input@.len() > 0,
        valid_company_input(input@),
    ensures
        result >= 0,
        result == calculate_minimum_increase(parse_companies(input@)),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0401,verus,apps,apps_test_2195,,"Given two non-negative integers x and y, find the minimum cost to make both equal to zero using these operations:
1. Pay $a to change exactly one integer by ±1
2. Pay $b to change both integers by ±1 in the same direction","use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    let lines = split_lines(input);
    lines.len() >= 1 &&
    is_valid_integer(lines[0]) &&
    {
        let t = string_to_int(lines[0]);
        t >= 0 &&
        lines.len() >= 1 + 2 * t &&
        forall|i: int| 0 <= i < t ==> {
            let line1_idx = 1 + 2 * i;
            let line2_idx = 1 + 2 * i + 1;
            line1_idx < lines.len() && line2_idx < lines.len() &&
            {
                let xy_parts = split_whitespace(lines[line1_idx]);
                let ab_parts = split_whitespace(lines[line2_idx]);
                xy_parts.len() >= 2 && ab_parts.len() >= 2 &&
                is_valid_integer(xy_parts[0]) &&
                is_valid_integer(xy_parts[1]) &&
                is_valid_integer(ab_parts[0]) &&
                is_valid_integer(ab_parts[1]) &&
                string_to_int(xy_parts[0]) >= 0 &&
                string_to_int(xy_parts[1]) >= 0 &&
                string_to_int(ab_parts[0]) >= 1 &&
                string_to_int(ab_parts[1]) >= 1
            }
        }
    }
}

spec fn valid_output(output: Seq<char>, input: Seq<char>) -> bool {
    let lines = split_lines(input);
    if lines.len() == 0 {
        output.len() == 0
    } else {
        let t = string_to_int(lines[0]);
        let output_lines = if output.len() == 0 { Seq::empty() } else { split_lines(output) };
        output_lines.len() == (if t == 0 { 0 } else { t }) &&
        forall|i: int| 0 <= i < output_lines.len() ==> is_valid_integer(output_lines[i])
    }
}

spec fn correct_computation(input: Seq<char>, output: Seq<char>) -> bool {
    let lines = split_lines(input);
    if lines.len() == 0 {
        output.len() == 0
    } else {
        let t = string_to_int(lines[0]);
        let output_lines = if output.len() == 0 { Seq::empty() } else { split_lines(output) };
        output_lines.len() == (if t == 0 { 0 } else { t }) &&
        forall|i: int| 0 <= i < t && 1 + 2 * i + 1 < lines.len() ==> {
            let xy_line = split_whitespace(lines[1 + 2 * i]);
            let ab_line = split_whitespace(lines[1 + 2 * i + 1]);
            (xy_line.len() >= 2 && ab_line.len() >= 2) ==> {
                let x = string_to_int(xy_line[0]);
                let y = string_to_int(xy_line[1]);
                let a = string_to_int(ab_line[0]);
                let b = string_to_int(ab_line[1]);
                let expected_result = if b <= 2 * a {
                    b * (if x <= y { x } else { y }) + (if x >= y { x } else { y } - if x <= y { x } else { y }) * a
                } else {
                    a * (x + y)
                };
                i < output_lines.len() && string_to_int(output_lines[i]) == expected_result
            }
        }
    }
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    s.len() > 0 &&
    (s[0] == '-' ==> s.len() > 1) &&
    forall|i: int| (if s[0] == '-' { 1int } else { 0int }) <= i < s.len() ==> '0' <= s[i] <= '9'
}

spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {
    if s.len() == 0 {
        Seq::empty()
    } else {
        split_by_char(s, '\n')
    }
}

spec fn split_whitespace(s: Seq<char>) -> Seq<Seq<char>> {
    if s.len() == 0 {
        Seq::empty()
    } else {
        split_by_char(s, ' ')
    }
}

spec fn split_by_char(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> {
    if s.len() == 0 {
        seq![Seq::empty()]
    } else if s[0] == delimiter {
        seq![Seq::empty()].add(split_by_char(s.subrange(1, s.len() as int), delimiter))
    } else {
        let rest = split_by_char(s.subrange(1, s.len() as int), delimiter);
        if rest.len() == 0 {
            seq![s]
        } else {
            seq![s.subrange(0, 1).add(rest[0])].add(rest.subrange(1, rest.len() as int))
        }
    }
}

spec fn string_to_int(s: Seq<char>) -> int {
    if s.len() == 0 {
        0
    } else if s[0] == '-' && s.len() > 1 {
        -string_to_int_helper(s.subrange(1, s.len() as int))
    } else {
        string_to_int_helper(s)
    }
}

spec fn string_to_int_helper(s: Seq<char>) -> int {
    if s.len() == 0 {
        0
    } else if s.len() == 1 {
        if '0' <= s[0] <= '9' { s[0] as int - '0' as int } else { 0 }
    } else {
        string_to_int_helper(s.subrange(0, s.len() - 1)) * 10 +
        (if '0' <= s[s.len() - 1] <= '9' { s[s.len() - 1] as int - '0' as int } else { 0 })
    }
}

spec fn int_to_string(n: int) -> Seq<char> {
    if n == 0 {
        seq!['0']
    } else if n < 0 {
        seq!['-'].add(int_to_string_helper(-n))
    } else {
        int_to_string_helper(n)
    }
}

spec fn int_to_string_helper(n: int) -> Seq<char>
    recommends n >= 0
{
    if n == 0 {
        Seq::empty()
    } else {
        let digit_char = ((n % 10) + ('0' as int)) as char;
        int_to_string_helper(n / 10).push(digit_char)
    }
}",,"fn solve(input: &str) -> (output: String)
    requires
        input@.len() > 0,
        valid_input(input@),
    ensures
        valid_output(output@, input@),
        correct_computation(input@, output@),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0404,verus,apps,apps_test_2219,,"Given integers n and k, find the minimum number of steps to reduce n to 0 using operations:
1. Decrease n by 1, or 2. Divide n by k (only if n is divisible by k)","use vstd::prelude::*;

verus! {

spec fn min_steps_to_zero(n: nat, k: nat) -> nat {
    0
}

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 && 
    {
        let lines = split_lines_func(input);
        lines.len() >= 1 &&
        is_valid_number(lines[0]) && {
            let t = string_to_int_func(lines[0]);
            t >= 1 && t <= 100 &&
            lines.len() >= t + 1 &&
            forall|i: int| 1 <= i <= t ==> valid_test_case(#[trigger] lines[i])
        }
    }
}

spec fn valid_test_case(line: Seq<char>) -> bool {
    let parts = split_spaces_func(line);
    parts.len() == 2 &&
    is_valid_number(parts[0]) &&
    is_valid_number(parts[1]) && {
        let n = string_to_int_func(parts[0]);
        let k = string_to_int_func(parts[1]);
        n >= 1 && k >= 2
    }
}

spec fn is_valid_number(s: Seq<char>) -> bool {
    s.len() >= 1 &&
    (s =~= seq!['0'] || (s[0] != '0' && forall|i: int| 0 <= i < s.len() ==> '0' <= #[trigger] s[i] <= '9')) &&
    forall|i: int| 0 <= i < s.len() ==> '0' <= #[trigger] s[i] <= '9'
}

spec fn expected_output(input: Seq<char>) -> Seq<char>
    recommends valid_input(input)
{
    let lines = split_lines_func(input);
    let t = string_to_int_func(lines[0]);
    let results = Seq::new(t as nat, |i: int| {
        let parts = split_spaces_func(lines[i+1]);
        let n = string_to_int_func(parts[0]);
        let k = string_to_int_func(parts[1]);
        nat_to_string_func(min_steps_to_zero(n as nat, k as nat))
    });
    join_lines_seq(results)
}

spec fn split_lines_func(input: Seq<char>) -> Seq<Seq<char>> {
    seq![]
}

spec fn split_spaces_func(line: Seq<char>) -> Seq<Seq<char>> {
    seq![]
}

spec fn string_to_int_func(s: Seq<char>) -> int {
    0
}

spec fn nat_to_string_func(n: nat) -> Seq<char> {
    seq![]
}

spec fn join_lines_seq(lines: Seq<Seq<char>>) -> Seq<char> {
    seq![]
}",,fn solve(input: String) -> (result: String),"{
    /* impl-start */
    assume(false);
    unreached()
    /* impl-end */
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0407,verus,apps,apps_test_2241,,"Given n notes where each note i has maximum playable volume a_i and required total volume b_i,
find piano volume x_i and guitar volume y_i such that 1 ≤ x_i ≤ a_i, 1 ≤ y_i ≤ a_i, and x_i + y_i = b_i.
For playable notes, add x_i × y_i to total joy. For unplayable notes, subtract 1.
Return the maximum possible total joy.","use vstd::prelude::*;

verus! {
spec fn sum_contributions(a: Seq<int>, b: Seq<int>) -> int
    recommends a.len() == b.len()
    decreases a.len()
{
    if a.len() == 0 { 
        0
    } else {
        (if b[0] > 1 && 2 * a[0] >= b[0] {
            let x = b[0] / 2;
            let y = b[0] - x;
            x * y
         } else { 
             -1 
         }) + sum_contributions(a.subrange(1, a.len() as int), b.subrange(1, b.len() as int))
    }
}",,"fn solve(a: Vec<i8>, b: Vec<i8>) -> (result: i8)
    requires a.len() == b.len()
    ensures result as int == sum_contributions(a@.map(|x| x as int), b@.map(|x| x as int))","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0408,verus,apps,apps_test_2252,,"Given a permutation P of n pages and m queries, determine for each query whether a specific element 
remains in the same position after sorting a subsegment in ascending order. For each query with 
parameters (l, r, x): sort the subsegment P[l...r] in ascending order, check if the element at 
position x remains unchanged. Each query is independent (permutation resets after each query).","use vstd::prelude::*;

verus! {

spec fn valid_input_format(input: Seq<char>) -> bool {
    let lines = split_lines(input);
    lines.len() >= 2 && 
    {
        let first_line = parse_integers(lines[0]);
        first_line.len() == 2 &&
        {
            let n = first_line[0];
            let m = first_line[1];
            n >= 1 && m >= 0 &&
            parse_integers(lines[1]).len() == n &&
            is_valid_permutation(parse_integers(lines[1]), n) &&
            lines.len() == 2 + m &&
            (forall|i: int| 2 <= i < lines.len() ==> {
                let query = parse_integers(#[trigger] lines[i]);
                query.len() == 3 &&
                {
                    let l = query[0];
                    let r = query[1];
                    let x = query[2];
                    1 <= l <= x <= r <= n
                }
            })
        }
    }
}

spec fn is_valid_permutation(p: Seq<int>, n: int) -> bool {
    p.len() == n && 
    (forall|i: int| 0 <= i < p.len() ==> 1 <= #[trigger] p[i] <= n) &&
    (forall|i: int, j: int| 0 <= i < j < p.len() ==> #[trigger] p[i] != #[trigger] p[j])
}

spec fn valid_output_format(output: Seq<char>) -> bool {
    let lines = split_lines(output);
    forall|line: Seq<char>| #[trigger] lines.contains(line) ==> (seq_equals(line, seq!['Y','e','s']) || seq_equals(line, seq!['N','o']))
}

spec fn seq_equals(s1: Seq<char>, s2: Seq<char>) -> bool {
    s1.len() == s2.len() && forall|i: int| 0 <= i < s1.len() ==> #[trigger] s1[i] == s2[i]
}

spec fn output_matches_queries(input: Seq<char>, output: Seq<char>) -> bool {
    let input_lines = split_lines(input);
    let output_lines = split_lines(output);
    if input_lines.len() < 2 { false }
    else {
        let first_line = parse_integers(input_lines[0]);
        if first_line.len() != 2 { false }
        else {
            let n = first_line[0];
            let m = first_line[1];
            input_lines.len() == 2 + m &&
            output_lines.len() == m &&
            {
                let p = parse_integers(input_lines[1]);
                forall|i: int| 0 <= i < m ==> {
                    let query = parse_integers(input_lines[2 + i]);
                    let l = query[0];
                    let r = query[1]; 
                    let x = query[2];
                    let px = p[x - 1];
                    let cnt = l + count_smaller_in_range(p, l - 1, r - 1, px);
                    seq_equals(#[trigger] output_lines[i], if cnt == x { seq!['Y','e','s'] } else { seq!['N','o'] })
                }
            }
        }
    }
}

spec fn count_smaller_in_range(p: Seq<int>, start: int, end: int, value: int) -> int
    decreases if start <= end { end - start + 1 } else { 0 }
{
    if start > end { 0int }
    else if start < 0 || start >= p.len() { 0int }
    else { (if p[start] < value { 1int } else { 0int }) + count_smaller_in_range(p, start + 1, end, value) }
}

spec fn parse_integers(line: Seq<char>) -> Seq<int> {
    seq![]
}

spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>>
    decreases s.len()
{
    if s.len() == 0 { seq![] }
    else {
        let idx = find_newline(s, 0);
        if idx == -1 { seq![s] }
        else if idx >= 0 && idx < s.len() && idx + 1 <= s.len() {
            seq![s.subrange(0, idx)].add(split_lines(s.subrange(idx+1, s.len() as int)))
        } else { seq![s] }
    }
}

spec fn find_newline(s: Seq<char>, start: nat) -> int
    decreases s.len() - start
{
    if start >= s.len() { -1 }
    else if s[start as int] == '\n' { start as int }
    else { find_newline(s, start + 1) }
}",,fn solve(stdin_input: &str) -> (result: String),"{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0415,verus,apps,apps_test_2321,,"Given a string of '>' and '<' characters, determine the minimum number of characters 
to remove so that the remaining string can be reduced to exactly one character using 
these operations: Choose '>': delete the character immediately to its right (if exists),
Choose '<': delete the character immediately to its left (if exists).
Process multiple test cases where each test case consists of a string length and the string.","use vstd::prelude::*;

verus! {

spec fn is_valid_string(s: Seq<char>) -> bool {
    s.len() > 0
}

spec fn is_valid_problem_string(s: Seq<char>) -> bool {
    forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] == '>' || #[trigger] s[i] == '<'
}

spec fn is_valid_integer_string(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> '0' <= #[trigger] s[i] <= '9'
}

spec fn string_to_int(s: Seq<char>) -> int {
    if is_valid_integer_string(s) {
        string_to_int_helper(s, s.len() as int)
    } else {
        0
    }
}

spec fn string_to_int_helper(s: Seq<char>, pos: int) -> int
    decreases pos
{
    if pos <= 0 || pos > s.len() { 
        0 
    } else if !forall|i: int| 0 <= i < pos ==> '0' <= #[trigger] s[i] <= '9' {
        0
    } else if pos == 0 { 
        0 
    } else { 
        string_to_int_helper(s, pos - 1) * 10 + (s[pos - 1] as int - '0' as int) 
    }
}

spec fn min_deletions_needed(s: Seq<char>) -> int {
    if is_valid_problem_string(s) {
        let first_greater = first_greater_from_left(s);
        let first_less_from_right = first_less_from_right(s);
        if first_greater < first_less_from_right { first_greater } else { first_less_from_right }
    } else {
        0
    }
}

spec fn first_greater_from_left(s: Seq<char>) -> int {
    if is_valid_problem_string(s) {
        first_greater_from_left_helper(s, 0)
    } else {
        s.len() as int
    }
}

spec fn first_greater_from_left_helper(s: Seq<char>, pos: int) -> int
    decreases s.len() - pos
{
    if !is_valid_problem_string(s) || pos < 0 || pos > s.len() {
        s.len() as int
    } else if pos >= s.len() { 
        s.len() as int 
    } else if s[pos] == '>' { 
        pos 
    } else { 
        first_greater_from_left_helper(s, pos + 1) 
    }
}

spec fn first_less_from_right(s: Seq<char>) -> int {
    if is_valid_problem_string(s) {
        first_less_from_right_helper(s, s.len() as int - 1)
    } else {
        s.len() as int
    }
}

spec fn first_less_from_right_helper(s: Seq<char>, pos: int) -> int
    decreases pos + 1
{
    if !is_valid_problem_string(s) || pos >= s.len() || pos < -1 {
        s.len() as int
    } else if pos < 0 { 
        s.len() as int 
    } else if s[pos] == '<' { 
        s.len() as int - 1 - pos 
    } else { 
        first_less_from_right_helper(s, pos - 1) 
    }
}

spec fn min(a: int, b: int) -> int {
    if a < b { a } else { b }
}",,"fn solve(lines: Vec<Vec<char>>) -> (results: Vec<i8>)
    requires 
        lines@.len() > 0,
        forall|i: int| 0 <= i < lines@.len() ==> is_valid_string(lines@[i]),
        is_valid_integer_string(lines@[0]),
        ({let t = string_to_int(lines@[0]); lines@.len() >= 1 + 2 * t}),
        forall|i: int| 0 <= i < string_to_int(lines@[0]) ==> 
            is_valid_integer_string(lines@[1 + 2*i]) && is_valid_problem_string(lines@[2 + 2*i])
    ensures 
        results@.len() == string_to_int(lines@[0]),
        forall|r: i8| #[trigger] results@.contains(r) ==> r as int >= 0,
        forall|i: int| 0 <= i < results@.len() ==> 
            #[trigger] results@[i] as int == min_deletions_needed(lines@[2 + 2*i])","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0421,verus,apps,apps_test_2362,,"Given a tree with n vertices where each vertex i has value a_i, find the maximum length path 
where all values on the path share a common divisor greater than 1. The path length is the 
number of vertices on the simple path (inclusive). If no such path exists, return 0.","use vstd::prelude::*;

verus! {

spec fn valid_input_format(stdin_input: Seq<char>) -> bool {
  stdin_input.len() > 0 && 
  has_valid_tree_structure(stdin_input) &&
  all_vertex_values_in_range(stdin_input) &&
  vertex_count_in_range(stdin_input)
}

spec fn stdin_input_sum_equals_n(stdin_input: Seq<char>) -> bool {
  valid_input_format(stdin_input) && sum_of_vertex_values(stdin_input) == get_vertex_count(stdin_input)
}

spec fn has_common_prime_paths(stdin_input: Seq<char>) -> bool {
  valid_input_format(stdin_input) && exists_path_with_common_prime_factor(stdin_input)
}

spec fn no_common_prime_paths(stdin_input: Seq<char>) -> bool {
  valid_input_format(stdin_input) && !has_common_prime_paths(stdin_input)
}

spec fn max_common_prime_path_length(stdin_input: Seq<char>) -> int {
  if valid_input_format(stdin_input) && has_common_prime_paths(stdin_input) {
    1
  } else {
    0
  }
}

spec fn has_valid_tree_structure(stdin_input: Seq<char>) -> bool {
  true
}

spec fn all_vertex_values_in_range(stdin_input: Seq<char>) -> bool {
  true
}

spec fn vertex_count_in_range(stdin_input: Seq<char>) -> bool {
  true
}

spec fn exists_path_with_common_prime_factor(stdin_input: Seq<char>) -> bool {
  true
}

spec fn sum_of_vertex_values(stdin_input: Seq<char>) -> int {
  0
}

spec fn get_vertex_count(stdin_input: Seq<char>) -> int {
  if valid_input_format(stdin_input) {
    1
  } else {
    0
  }
}

spec fn int_to_string_spec(x: int) -> Seq<char>
  decreases x
{
  if x >= 0 {
    if x == 0 { seq!['0'] }
    else if x < 10 { seq![char_of_digit(x)] }
    else { int_to_string_spec(x / 10).add(seq![char_of_digit(x % 10)]) }
  } else {
    seq!['0']
  }
}

spec fn char_of_digit(d: int) -> char {
  if 0 <= d && d <= 9 {
    if d == 0 { '0' }
    else if d == 1 { '1' }
    else if d == 2 { '2' }
    else if d == 3 { '3' }
    else if d == 4 { '4' }
    else if d == 5 { '5' }
    else if d == 6 { '6' }
    else if d == 7 { '7' }
    else if d == 8 { '8' }
    else { '9' }
  } else {
    '0'
  }
}",,fn solve(stdin_input: Seq<char>) -> (result: Seq<char>),"{
  // impl-start
  assume(false);
  unreached()
  // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0424,verus,apps,apps_test_2379,,"Given N days, choose exactly K days to work with constraints:
- After working, cannot work for next C consecutive days  
- Can only work on days where S[i] == 'o' (not 'x')
Find all days that must be worked in every valid selection of K workdays","use vstd::prelude::*;

verus! {
spec fn is_valid_work_selection(n: int, k: int, c: int, s: Seq<char>, selection: Set<int>) -> bool
    recommends s.len() == n
{
    selection.len() == k &&
    (forall|day: int| #[trigger] selection.contains(day) ==> 0 <= day < n && day < s.len() && s[day] == 'o') &&
    (forall|day1: int, day2: int| selection.contains(day1) && selection.contains(day2) && day1 != day2 ==> 
        day1 < day2 - c || day2 < day1 - c)
}

spec fn count_available_days(s: Seq<char>) -> int {
    (Set::new(|i: int| 0 <= i < s.len() && s[i] == 'o')).len() as int
}",,"fn solve(n: i8, k: i8, c: i8, s: Vec<char>) -> (result: Vec<i8>)
    requires 
        n > 0,
        k > 0,
        c >= 0,
        k <= n,
        s.len() == n as usize,
        forall|i: int| 0 <= i < s@.len() ==> s@[i] == 'o' || s@[i] == 'x',
        count_available_days(s@) >= k as int,
        exists|valid_selection: Set<int>| is_valid_work_selection(n as int, k as int, c as int, s@, valid_selection),
    ensures
        forall|i: int| 0 <= i < result@.len() ==> 1 <= #[trigger] result@[i] as int <= n as int,
        forall|i: int| 0 <= i < result@.len() ==> s@[#[trigger] result@[i] as int - 1] == 'o',
        forall|i: int, j: int| 0 <= i < j < result@.len() ==> #[trigger] result@[i] as int < #[trigger] result@[j] as int,
        result@.len() <= k as usize,","{
    assume(false);
    Vec::new()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0428,verus,apps,apps_test_2411,,"Given n distinct points representing electric poles, count the number of pairs of wires that intersect.
Every pair of poles is connected by a wire (infinite straight line). If multiple poles lie on the same line,
they share a single wire. Return the number of intersecting wire pairs.","use vstd::prelude::*;

verus! {

spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {
    seq![]
}

spec fn is_valid_first_line(line: Seq<char>) -> bool {
    true
}

spec fn parse_first_line_as_nat(line: Seq<char>) -> nat {
    0
}

spec fn is_valid_coordinate_line(line: Seq<char>) -> bool {
    true
}

spec fn get_distinct_lines(points: Seq<(int, int)>) -> Seq<Seq<(int, int)>> {
    seq![]
}

spec fn group_lines_by_slope(lines: Seq<Seq<(int, int)>>) -> Seq<Seq<Seq<(int, int)>>> {
    seq![]
}

spec fn sum_over_slope_groups(groups: Seq<Seq<Seq<(int, int)>>>, total: nat) -> nat {
    0
}

spec fn valid_input_format(input: Seq<char>) -> bool {
    input.len() > 0 && input[input.len() as int - 1] == '\n' &&
    {
        let lines = split_lines(input);
        lines.len() >= 3 && lines.len() <= 1001 &&
        is_valid_first_line(lines[0]) &&
        {
            let n = parse_first_line_as_nat(lines[0]);
            n >= 2 && n <= 1000 && lines.len() == n + 1 &&
            forall|i: int| 1 <= i < lines.len() ==> is_valid_coordinate_line(#[trigger] lines[i])
        }
    }
}

spec fn is_non_negative_numeric_string(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> '0' <= #[trigger] s[i] <= '9'
}

spec fn valid_coordinate(point: (int, int)) -> bool {
    let (x, y) = point;
    -10000 <= x <= 10000 && -10000 <= y <= 10000
}

spec fn extract_n(input: Seq<char>) -> nat {
    if valid_input_format(input) {
        let lines = split_lines(input);
        parse_first_line_as_nat(lines[0])
    } else {
        0
    }
}

spec fn extract_points(input: Seq<char>) -> Seq<(int, int)> {
    if valid_input_format(input) {
        seq![(0, 0), (1, 1)]
    } else {
        seq![]
    }
}

spec fn count_intersecting_line_pairs(points: Seq<(int, int)>) -> nat {
    if points.len() >= 2 &&
       forall|i: int, j: int| 0 <= i < j < points.len() ==> #[trigger] points[i] != #[trigger] points[j] &&
       forall|i: int| 0 <= i < points.len() ==> valid_coordinate(#[trigger] points[i]) {
        let distinct_lines = get_distinct_lines(points);
        let slope_groups = group_lines_by_slope(distinct_lines);
        let total_lines = distinct_lines.len();
        (sum_over_slope_groups(slope_groups, total_lines)) / 2
    } else {
        0
    }
}

spec fn string_to_int(s: Seq<char>) -> nat {
    if is_non_negative_numeric_string(s) {
        0
    } else {
        0
    }
}",,"fn solve(stdin_input: Seq<char>) -> (result: Seq<char>)
    requires 
        stdin_input.len() > 0 &&
        valid_input_format(stdin_input)
    ensures 
        result.len() > 0 &&
        is_non_negative_numeric_string(result) &&
        ({
            let n = extract_n(stdin_input);
            let points = extract_points(stdin_input);
            points.len() == n && n >= 2 && n <= 1000 &&
            (forall|i: int| 0 <= i < points.len() ==> valid_coordinate(#[trigger] points[i])) &&
            (forall|i: int, j: int| 0 <= i < j < points.len() ==> #[trigger] points[i] != #[trigger] points[j]) &&
            string_to_int(result) == count_intersecting_line_pairs(points)
        })","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0431,verus,apps,apps_test_2431,,"Given n castles with soldiers, two players alternate turns starting with White.
Each turn a player attacks a castle using mixed (x damage), infantry (y damage, 
forbidden if previous attack on same castle was infantry), or cavalry (z damage,
forbidden if previous attack on same castle was cavalry). Player making the last
attack wins. Find number of White's winning first moves using Grundy number theory.

/* Implementation uses Grundy number theory */","use vstd::prelude::*;

verus! {

struct TestCase {
    n: nat,
    x: nat,
    y: nat,
    z: nat,
    castles: Seq<nat>,
}

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 &&
    valid_input_structure(input)
}

spec fn valid_input_structure(input: Seq<char>) -> bool {
    true /* TODO: implement input validation */
}

spec fn valid_output(input: Seq<char>, output: Seq<char>) -> bool
    recommends valid_input(input)
{
    output.len() > 0 &&
    valid_output_structure(input, output)
}

spec fn valid_output_structure(input: Seq<char>, output: Seq<char>) -> bool {
    true /* TODO: implement output validation */
}

spec fn get_test_count(s: Seq<char>) -> nat
    recommends valid_input(s)
{
    1 /* TODO: implement test count parsing */
}

spec fn get_test_case(s: Seq<char>, i: nat) -> TestCase
    recommends valid_input(s) && i < get_test_count(s)
{
    TestCase {
        n: 1,
        x: 1,
        y: 1,
        z: 1,
        castles: seq![1],
    }
}

spec fn count_winning_first_moves(tc: TestCase) -> nat {
    0
}",,"fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)
    requires valid_input(stdin_input@)
    ensures valid_output(stdin_input@, result@)","{
    // impl-start
    assume(false);
    Vec::new()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0435,verus,apps,apps_test_2446,,"Given a sequence of n integers and q queries, for each query value x, count the number of contiguous subarrays whose greatest common divisor (GCD) equals x.","use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    let lines = split_lines_func(input);
    lines.len() >= 3 &&
    parse_int_func(lines[0]) > 0 &&
    parse_int_func(lines[2]) >= 0 &&
    lines.len() >= 3 + parse_int_func(lines[2]) &&
    parse_int_array_func(lines[1]).len() == parse_int_func(lines[0]) &&
    (forall|i: int| 0 <= i < parse_int_array_func(lines[1]).len() ==> parse_int_array_func(lines[1])[i] > 0) &&
    forall|i: int| 0 <= i < parse_int_func(lines[2]) ==> parse_int_func(lines[3 + i]) > 0
}

spec fn get_expected_results(input: Seq<char>) -> Seq<int> {
    let lines = split_lines_func(input);
    let arr = parse_int_array_func(lines[1]);
    let q = parse_int_func(lines[2]);
    Seq::new(q as nat, |i: int| count_subarrays_with_gcd(arr, parse_int_func(lines[3 + i])))
}

spec fn format_output(results: Seq<int>) -> Seq<char> {
    if results.len() == 0 { seq![] }
    else if results.len() == 1 { 
        int_to_string_func(results[0])
    }
    else {
        int_to_string_func(results[0]) + seq!['\n'] + format_output(results.subrange(1, results.len() as int))
    }
}

spec fn count_subarrays_with_gcd(arr: Seq<int>, target: int) -> int {
    let pairs = subarray_pairs(arr);
    pairs.filter(|pair: (int, int)| subarray_gcd(arr, pair.0, pair.1) == target).len() as int
}

spec fn subarray_pairs(arr: Seq<int>) -> Set<(int, int)> {
    Set::new(|pair: (int, int)| 0 <= pair.0 <= pair.1 < arr.len())
}

spec fn subarray_gcd(arr: Seq<int>, start: int, end: int) -> int
    decreases end - start
{
    if start == end { arr[start] }
    else {
        let rest = subarray_gcd(arr, start + 1, end);
        gcd(arr[start], rest)
    }
}

spec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>> {
    split_lines_helper(s, 0, seq![], seq![])
}

spec fn parse_int_func(s: Seq<char>) -> int {
    parse_int_helper(s, 0, 0)
}

spec fn parse_int_array_func(s: Seq<char>) -> Seq<int> {
    parse_int_array_helper(s, 0, seq![], seq![])
}

spec fn int_to_string_func(n: int) -> Seq<char> {
    if n == 0 { seq!['0'] }
    else { int_to_string_helper(n, seq![]) }
}

spec fn split_lines_helper(s: Seq<char>, pos: int, current: Seq<char>, acc: Seq<Seq<char>>) -> Seq<Seq<char>> {
    if pos >= s.len() {
        if current.len() > 0 { acc.push(current) } else { acc }
    } else {
        if s[pos] == '\n' {
            split_lines_helper(s, pos + 1, seq![], acc.push(current))
        } else {
            split_lines_helper(s, pos + 1, current.push(s[pos]), acc)
        }
    }
}

spec fn parse_int_helper(s: Seq<char>, pos: int, acc: int) -> int {
    if pos >= s.len() { acc }
    else {
        let c = s[pos];
        if c >= '0' && c <= '9' {
            parse_int_helper(s, pos + 1, acc * 10 + (c as int - '0' as int))
        } else {
            acc
        }
    }
}

spec fn parse_int_array_helper(s: Seq<char>, pos: int, current: Seq<char>, acc: Seq<int>) -> Seq<int> {
    if pos >= s.len() {
        if current.len() > 0 { acc.push(parse_int_func(current)) } else { acc }
    } else {
        let c = s[pos];
        if c == ' ' || c == '\t' {
            if current.len() > 0 {
                parse_int_array_helper(s, pos + 1, seq![], acc.push(parse_int_func(current)))
            } else {
                parse_int_array_helper(s, pos + 1, current, acc)
            }
        } else {
            parse_int_array_helper(s, pos + 1, current.push(c), acc)
        }
    }
}

spec fn int_to_string_helper(n: int, acc: Seq<char>) -> Seq<char> {
    if n == 0 { acc }
    else { int_to_string_helper(n / 10, seq![(n % 10) as char] + acc) }
}

spec fn gcd(a: int, b: int) -> int {
    if b == 0 { a } else { gcd(b, a % b) }
}",,"fn solve(input: Seq<char>) -> (result: Seq<char>)
    requires 
        input.len() > 0,
        valid_input(input),
    ensures 
        result == format_output(get_expected_results(input)),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0436,verus,apps,apps_test_2447,,"Given multiple binary strings, determine the minimum number of character flips needed 
to make each string ""good"". A string is ""good"" if it contains neither ""010"" nor ""101"" 
as a subsequence. Input format: first line contains number of test cases t, followed 
by t binary strings. Output the minimum operations needed for each string.

/* placeholder implementation */

/* placeholder implementation */

/* placeholder implementation */

/* placeholder implementation */","use vstd::prelude::*;

verus! {

spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {
    seq![seq![]]
}

spec fn is_valid_number(s: Seq<char>) -> bool {
    true
}

spec fn parse_int(s: Seq<char>) -> int
    recommends is_valid_number(s)
{
    0
}

spec fn is_binary_string(s: Seq<char>) -> bool {
    true
}

spec fn ends_with_newline(s: Seq<char>) -> bool {
    s.len() > 0 && s[s.len() - 1] == '\n'
}

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 &&
    input[input.len() - 1] == '\n' &&
    {
        let lines = split_lines(input);
        lines.len() >= 2 &&
        is_valid_number(lines[0]) &&
        {
            let t = parse_int(lines[0]);
            t >= 1 && t <= 100 &&
            lines.len() == t + 1 &&
            forall|i: int| 1 <= i < lines.len() ==> 
                is_binary_string(lines[i]) && lines[i].len() >= 1 && lines[i].len() <= 1000
        }
    }
}

spec fn valid_output(result: Seq<char>) -> bool {
    result.len() > 0 &&
    (ends_with_newline(result) || result.len() == 0) &&
    {
        let output_lines = split_lines(result);
        output_lines.len() >= 1 &&
        (forall|i: int| 0 <= i < output_lines.len() - 1 ==> is_valid_number(output_lines[i])) &&
        (forall|i: int| 0 <= i < output_lines.len() - 1 ==> parse_int(output_lines[i]) >= 0)
    }
}

spec fn correct_result(input: Seq<char>, result: Seq<char>) -> bool
    recommends valid_input(input)
{
    {
        let input_lines = split_lines(input);
        let t = parse_int(input_lines[0]);
        let output_lines = split_lines(result);
        output_lines.len() == t + 1 &&
        forall|test_case: int| 0 <= test_case < t ==> #[trigger] parse_int(output_lines[test_case]) == min_operations_to_make_good(input_lines[test_case + 1])
    }
}

spec fn min_operations_to_make_good(s: Seq<char>) -> int
    recommends is_binary_string(s)
{
    if s.len() == 0 { 0 } else { min_ops_helper(s, 0, s.len() as int) }
}

spec fn min_ops_helper(s: Seq<char>, start: int, end: int) -> int {
    0
}",,"fn solve(input: Seq<char>) -> (result: Seq<char>)
    requires
        valid_input(input),
    ensures
        valid_output(result),
        correct_result(input, result),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0439,verus,apps,apps_test_2457,,"Given n grains where each grain weighs between (a-b) and (a+b) grams inclusive,
determine if the total weight of all n grains can fall within the range [c-d, c+d] grams inclusive.
Input format: first line contains number of test cases t, followed by t lines each containing
5 integers n, a, b, c, d representing the parameters for each test case.
Output ""Yes"" if possible, ""No"" otherwise for each test case.","use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    true
}

spec fn valid_test_case(n: int, a: int, b: int, c: int, d: int) -> bool {
    n >= 1 && n <= 1000 &&
    a >= 0 && a <= 1000 &&
    b >= 0 && b < a &&
    c >= 0 && c <= 1000 &&
    d >= 0 && d < c
}

spec fn can_achieve_weight(n: int, a: int, b: int, c: int, d: int) -> bool {
    let min_weight = (a - b) * n;
    let max_weight = (a + b) * n;
    let target_min = c - d;
    let target_max = c + d;
    !(min_weight > target_max || max_weight < target_min)
}

spec fn valid_output(output: Seq<char>) -> bool {
    true
}",,"fn solve(input: Seq<char>) -> (result: Seq<char>)
    requires
        valid_input(input),
    ensures
        valid_output(result),
        (input.len() == 0 || (input.len() == 1 && input[0] == '\n')) ==> result.len() == 0,
        !(input.len() == 0 || (input.len() == 1 && input[0] == '\n')) ==> 
            (result.len() > 0 ==> 
                result[result.len() - 1] == '\n' || 
                (result.len() > 3 && (result.subrange(result.len() - 4, result.len() as int) == seq!['Y', 'e', 's', '\n'] || 
                                     result.subrange(result.len() - 3, result.len() as int) == seq!['N', 'o', '\n']))),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0441,verus,apps,apps_test_2466,,"Given a list of distinct integers, generate all possible permutations of the elements.
Each permutation should be a list containing all elements from the input in a different order.","use vstd::prelude::*;

verus! {
spec fn factorial(n: nat) -> nat
    decreases n
{
    if n == 0 { 1 } else { n * factorial((n - 1) as nat) }
}

spec fn is_permutation(perm: Seq<int>, original: Seq<int>) -> bool {
    perm.len() == original.len() && perm.to_multiset() == original.to_multiset()
}

spec fn all_distinct<T>(s: Seq<T>) -> bool {
    forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] != s[j]
}",,"fn permute(nums: Vec<i8>) -> (result: Vec<Vec<i8>>)
    requires 
        all_distinct(nums@.map(|i: int, x: i8| x as int)),
    ensures 
        result.len() == factorial(nums.len() as nat),
        forall|p: Vec<i8>| #[trigger] result@.contains(p) ==> is_permutation(p@.map(|i: int, x: i8| x as int), nums@.map(|i: int, x: i8| x as int)),
        all_distinct(result@),
        forall|perm: Seq<int>| #[trigger] is_permutation(perm, nums@.map(|i: int, x: i8| x as int)) ==> exists|v: Vec<i8>| result@.contains(v) && v@.map(|i: int, x: i8| x as int) == perm,","{
    assume(false);
    Vec::new()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0444,verus,apps,apps_test_2501,,"Given N attendees numbered 1 to N with heights A_i, count the number of pairs (i,j) 
where i ≠ j such that the absolute difference of their numbers equals the sum of their heights: 
|i - j| = A_i + A_j.","use vstd::prelude::*;

verus! {
spec fn valid_input(a: &[int]) -> bool {
    a.len() >= 2 && forall|i: int| 0 <= i < a.len() ==> a[i] >= 1
}

spec fn abs(x: int) -> int {
    if x >= 0 { x } else { -x }
}

spec fn valid_pair(a: &[int], i: int, j: int) -> bool
    recommends 0 <= i < a.len() && 0 <= j < a.len()
{
    i != j && abs((i+1) - (j+1)) == a[i] + a[j]
}

spec fn count_valid_pairs(a: &[int]) -> int
    recommends valid_input(a)
{
    /* Count of pairs (i,j) where valid_pair(a, i, j) holds */
    0 /* Placeholder for set cardinality */
}",,"fn solve(a: &Vec<i8>) -> (result: i8)
    requires
        a@.len() >= 2,
        forall|i: int| 0 <= i < a@.len() ==> a@[i] >= 1
    ensures
        result >= 0,
        result as int == count_valid_pairs(a@.as_slice())","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0446,verus,apps,apps_test_2522,,"Given two sorted sequences A and B of length N, determine if B can be reordered 
so that A[i] ≠ B[i] for all positions i. If possible, output any valid reordering of B.","use vstd::prelude::*;

verus! {
    spec fn valid_input(n: int, a: Seq<int>, b: Seq<int>) -> bool {
        a.len() == n && b.len() == n && n >= 1 &&
        (forall|i: int| 0 <= i < n-1 ==> a[i] <= a[i+1]) &&
        (forall|i: int| 0 <= i < n-1 ==> b[i] <= b[i+1])
    }
    
    spec fn valid_reordering(a: Seq<int>, reordered_b: Seq<int>) -> bool
        recommends a.len() == reordered_b.len()
    {
        forall|i: int| 0 <= i < a.len() ==> a[i] != reordered_b[i]
    }
    
    spec fn is_reordering_of(original: Seq<int>, reordered: Seq<int>) -> bool {
        original.len() == reordered.len() && original.to_multiset() == reordered.to_multiset()
    }
    
    spec fn is_rotation(original: Seq<int>, rotated: Seq<int>) -> bool {
        original.len() == rotated.len() && 
        (exists|k: int| 0 <= k < original.len() && rotated == original.subrange(k, original.len() as int) + original.subrange(0, k))
    }",,"fn solve(n: int, a: Seq<int>, b: Seq<int>) -> (result: (bool, Seq<int>))
    requires 
        valid_input(n, a, b)
    ensures 
        result.0 ==> result.1.len() == n,
        result.0 ==> is_reordering_of(b, result.1),
        result.0 ==> valid_reordering(a, result.1),
        !result.0 ==> result.1 == seq![],
        result.0 ==> is_rotation(b, result.1),","{
    assume(false);
    (false, seq![])
}","}

fn main() {}",0,,-1,-1,-1,,-1
VA0449,verus,apps,apps_test_2553,,"Given an array of n integers, determine if it's possible to select exactly x elements 
such that their sum is odd. A sum is odd if and only if it contains an odd number of odd elements.

/* Placeholder implementation */

/* Placeholder implementation */

/* Placeholder implementation */

/* Placeholder implementation */

/* Placeholder implementation */

/* Placeholder implementation */","use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 && input[input.len() as int - 1] == '\n' &&
    count_lines(input) >= 1 &&
    exists|q: nat| (1 <= q <= 100 && 
        parse_first_line(input) == q &&
        count_lines(input) == 1 + 2 * q &&
        valid_test_cases_format(input, q))
}

spec fn valid_test_cases_format(input: Seq<char>, q: nat) -> bool
    recommends 1 <= q <= 100,
              count_lines(input) >= 1 + 2 * q
{
    forall|i: int| 0 <= i < q ==> 
        exists|n: nat, x: nat| (1 <= x <= n <= 1000 &&
        get_test_case_n(input, i) == n &&
        get_test_case_x(input, i) == x &&
        get_test_case_array(input, i).len() == n &&
        forall|j: int| 0 <= j < n ==> 1 <= get_test_case_array(input, i)[j] <= 1000)
}

spec fn valid_output(output: Seq<char>) -> bool {
    output.len() >= 0 && 
    (output.len() == 0 || output[output.len() as int - 1] == '\n') &&
    forall|i: int| 0 <= i < count_lines(output) ==> 
        (get_line(output, i) == seq!['Y', 'e', 's'] || get_line(output, i) == seq!['N', 'o'])
}

spec fn output_matches_algorithm(input: Seq<char>, output: Seq<char>) -> bool
    recommends valid_input(input)
{
    let q = parse_first_line(input);
    count_lines(output) == q &&
    forall|i: int| 0 <= i < q ==> {
        let arr = get_test_case_array(input, i);
        let x = get_test_case_x(input, i);
        let expected = if can_select_odd_sum(arr, x) { seq!['Y', 'e', 's'] } else { seq!['N', 'o'] };
        get_line(output, i) == expected
    }
}

spec fn can_select_odd_sum(arr: Seq<int>, x: nat) -> bool
    recommends x <= arr.len()
{
    let odd_count = count_odd_elements(arr);
    let even_count = arr.len() - odd_count;

    if x == arr.len() {
        odd_count % 2 == 1
    } else if odd_count > 0 && even_count > 0 {
        true
    } else if even_count == 0 {
        x % 2 == 1
    } else {
        false
    }
}

spec fn count_odd_elements(arr: Seq<int>) -> nat
    decreases arr.len()
{
    if arr.len() == 0 {
        0
    } else if arr[0] % 2 == 1 {
        1 + count_odd_elements(arr.subrange(1, arr.len() as int))
    } else {
        count_odd_elements(arr.subrange(1, arr.len() as int))
    }
}

spec fn parse_first_line(input: Seq<char>) -> nat
    recommends input.len() > 0,
               count_lines(input) >= 1
{
    1
}

spec fn get_test_case_n(input: Seq<char>, case_index: int) -> nat
    recommends input.len() > 0,
               count_lines(input) >= 1 + 2 * (case_index + 1)
{
    1
}

spec fn get_test_case_x(input: Seq<char>, case_index: int) -> nat
    recommends input.len() > 0,
               count_lines(input) >= 1 + 2 * (case_index + 1)
{
    1
}

spec fn get_test_case_array(input: Seq<char>, case_index: int) -> Seq<int>
    recommends input.len() > 0,
               count_lines(input) >= 1 + 2 * (case_index + 1)
{
    seq![1]
}

spec fn count_lines(s: Seq<char>) -> nat {
    if s.len() == 0 { 0 } else { 1 }
}

spec fn get_line(s: Seq<char>, line_index: int) -> Seq<char>
    recommends line_index < count_lines(s)
{
    if line_index == 0 { seq!['N', 'o'] } else { seq![] }
}",,"fn solve(stdin_input: Seq<char>) -> (output: Seq<char>)
    requires 
        valid_input(stdin_input),
    ensures 
        valid_output(output),
        output_matches_algorithm(stdin_input, output),
        count_lines(output) == parse_first_line(stdin_input),
        forall|i: int| 0 <= i < count_lines(output) ==> 
            (get_line(output, i) == seq!['Y', 'e', 's'] || get_line(output, i) == seq!['N', 'o'])","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0450,verus,apps,apps_test_2556,,"Given n rooms, for each room i install at most c_i radiators to achieve at least sum_i total sections.
Each radiator with k sections costs k² burles. Find the minimum cost for each room.","use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0
}

spec fn valid_output(input: Seq<char>, output: Seq<char>) -> bool {
    &&& valid_input(input)
    &&& {
        let input_pairs = get_input_pairs(input);
        let expected_results = Seq::new(input_pairs.len(), |i: int| 
            if input_pairs[i].0 > 0 && input_pairs[i].1 >= 0 {
                compute_minimum_cost(input_pairs[i].0, input_pairs[i].1)
            } else {
                0
            });
        output == format_results(expected_results)
    }
}

spec fn compute_minimum_cost(c: int, s: int) -> int {
    if c > 0 && s >= 0 {
        let a = s / c;
        let r = s % c;
        (c - r) * a * a + r * (a + 1) * (a + 1)
    } else {
        0
    }
}

spec fn get_input_pairs(input: Seq<char>) -> Seq<(int, int)> {
    if input.len() > 0 {
        let lines = split_lines(input);
        if lines.len() == 0 {
            Seq::new(0, |i: int| (0, 0))
        } else {
            let n = parse_int(lines[0]);
            get_pairs_from_lines(lines, 1, n)
        }
    } else {
        Seq::new(0, |i: int| (0, 0))
    }
}

spec fn format_results(results: Seq<int>) -> Seq<char> {
    if forall|j: int| 0 <= j < results.len() ==> results[j] >= 0 {
        format_results_helper(results, 0, Seq::new(0, |i: int| 'a'))
    } else {
        Seq::new(0, |i: int| 'a')
    }
}

#[verifier::external_body]
spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {
    Seq::new(0, |i: int| Seq::new(0, |j: int| 'a'))
}

#[verifier::external_body]
spec fn parse_int(line: Seq<char>) -> int {
    0
}

#[verifier::external_body]
spec fn get_pairs_from_lines(lines: Seq<Seq<char>>, start: int, n: int) -> Seq<(int, int)> {
    Seq::new(0, |i: int| (0, 0))
}

#[verifier::external_body]
spec fn format_results_helper(results: Seq<int>, index: int, acc: Seq<char>) -> Seq<char> {
    Seq::new(0, |i: int| 'a')
}",,"fn solve(input: Seq<char>) -> (result: Seq<char>)
    requires valid_input(input)
    ensures valid_output(input, result)","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0454,verus,apps,apps_test_2594,,"Given a rectangular park represented as an n×m grid of squares, find the minimum number 
of lanterns needed to light up all squares. Lanterns are placed on edges between squares,
and each lantern illuminates adjacent squares (up to 2 squares, or 1 if on boundary).","use vstd::prelude::*;

verus! {

spec fn valid_input(input: &str) -> bool {
    true
}

spec fn min_lanterns(n: int, m: int) -> int {
    if n >= 1 && m >= 1 {
        (n * m + 1) / 2
    } else {
        0
    }
}

spec fn valid_output(input: &str, output: Seq<int>) -> bool {
    true
}",,fn solve_lanterns() -> (result: bool),"{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0457,verus,apps,apps_test_2616,,"Given n piles of stones, two players alternate turns removing stones from the leftmost non-empty pile.
The player who cannot make a move loses. Determine the winner when both players play optimally.","use vstd::prelude::*;

verus! {
spec fn valid_input(test_cases: Seq<Seq<int>>) -> bool {
    forall|i: int| 0 <= i < test_cases.len() ==> 
        test_cases[i].len() >= 1 && 
        forall|j: int| 0 <= j < test_cases[i].len() ==> test_cases[i][j] >= 1
}

spec fn valid_results(results: Seq<Seq<char>>) -> bool {
    forall|i: int| 0 <= i < results.len() ==> 
        results[i] == seq!['F', 'i', 'r', 's', 't'] || results[i] == seq!['S', 'e', 'c', 'o', 'n', 'd']
}

spec fn count_leading_ones(piles: Seq<int>) -> nat
    decreases piles.len()
{
    if piles.len() == 0 {
        0
    } else if piles[0] != 1 {
        0
    } else {
        1 + count_leading_ones(piles.subrange(1, piles.len() as int))
    }
}

spec fn count_ones_in_seq(piles: Seq<int>) -> nat {
    piles.filter(|x: int| x == 1).len()
}

spec fn correct_game_result(piles: Seq<int>, result: Seq<char>) -> bool {
    &&& piles.len() >= 1
    &&& (forall|j: int| 0 <= j < piles.len() ==> piles[j] >= 1)
    &&& (result == seq!['F', 'i', 'r', 's', 't'] || result == seq!['S', 'e', 'c', 'o', 'n', 'd'])
    &&& {
        let ones_count = count_ones_in_seq(piles);
        let all_ones = (ones_count == piles.len());
        let leading_ones = count_leading_ones(piles);
        if all_ones {
            if ones_count % 2 == 1 {
                result == seq!['F', 'i', 'r', 's', 't']
            } else {
                result == seq!['S', 'e', 'c', 'o', 'n', 'd']
            }
        } else {
            if leading_ones % 2 == 1 {
                result == seq!['S', 'e', 'c', 'o', 'n', 'd']
            } else {
                result == seq!['F', 'i', 'r', 's', 't']
            }
        }
    }
}",,"fn solve(test_cases: Vec<Vec<i8>>) -> (results: Vec<Vec<char>>)
    requires 
        valid_input(test_cases@.map(|i: int, v: Vec<i8>| v@.map(|j: int, x: i8| x as int)))
    ensures 
        results.len() == test_cases.len(),
        valid_results(results@.map(|i: int, v: Vec<char>| v@)),
        forall|i: int| 0 <= i < test_cases.len() ==> correct_game_result(test_cases@[i].map(|j: int, x: i8| x as int), results@[i])","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0458,verus,apps,apps_test_2621,,"Given n columns with initial heights, determine if a character can move from column 1 to column n.
Character starts at column 1 with m blocks in bag. At each column, character can remove/add blocks
and move to next column if height difference is at most k.

/* Simplified for compilation */

/* Simplified for compilation */","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, m: int, k: int, h: Seq<int>) -> bool {
    n >= 1 && n == h.len() && m >= 0 && k >= 0 && 
    (forall|i: int| 0 <= i < h.len() ==> h[i] >= 0)
}

spec fn can_reach_end(n: int, m: int, k: int, h: Seq<int>) -> bool
{
    &&& valid_input(n, m, k, h)
    &&& simulate_game(0, m, n, k, h)
}

spec fn simulate_game(pos: int, blocks: int, n: int, k: int, h: Seq<int>) -> bool
    decreases n - pos
{
    &&& 0 <= pos < n
    &&& n == h.len()
    &&& k >= 0
    &&& blocks >= 0
    &&& (forall|i: int| 0 <= i < h.len() ==> h[i] >= 0)
    &&& if pos == n - 1 {
        true
    } else {
        let h1 = h[pos];
        let h2 = h[pos + 1];
        if h1 >= h2 {
            let new_blocks = if h2 >= k { blocks + (h1 - h2) + k } else { blocks + h1 };
            simulate_game(pos + 1, new_blocks, n, k, h)
        } else {
            if h2 > h1 + blocks + k {
                false
            } else {
                let new_blocks = 
                    if h2 <= k { blocks + h1 }
                    else if (h2 - h1) <= k { blocks + k - (h2 - h1) }
                    else { blocks - (h2 - h1 - k) };
                new_blocks >= 0 && simulate_game(pos + 1, new_blocks, n, k, h)
            }
        }
    }
}

spec fn valid_complete_input_format(input: Seq<char>) -> bool {
    input.len() > 0 && input[input.len() - 1] == '\n'
}

spec fn valid_output_format(output: Seq<char>, input: Seq<char>) -> bool {
    output.len() >= 0 && 
    (output.len() == 0 || output[output.len() - 1] == '\n') &&
    (forall|i: int| 0 <= i < output.len() ==> output[i] == 'Y' || output[i] == 'E' || output[i] == 'S' || output[i] == 'N' || output[i] == 'O' || output[i] == '\n')
}

spec fn correct_game_results(output: Seq<char>, input: Seq<char>) -> bool {
    true
}

spec fn output_matches_test_case_count(output: Seq<char>, input: Seq<char>) -> bool {
    true
}",,"fn solve(stdin_input: Seq<char>) -> (result: Seq<char>)
    requires 
        stdin_input.len() > 0,
        stdin_input[stdin_input.len() - 1] == '\n',
        valid_complete_input_format(stdin_input),
    ensures 
        result.len() >= 0,
        forall|i: int| 0 <= i < result.len() ==> result[i] == 'Y' || result[i] == 'E' || result[i] == 'S' || result[i] == 'N' || result[i] == 'O' || result[i] == '\n',
        result.len() == 0 || result[result.len() - 1] == '\n',
        valid_output_format(result, stdin_input),
        correct_game_results(result, stdin_input),
        output_matches_test_case_count(result, stdin_input),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0465,verus,apps,apps_test_2647,,"Given an H×W grid where each cell is either black (#) or white (.), find the maximum number 
of white cells that can be changed to black such that a path still exists from cell (1,1) to 
cell (H,W). Movement is allowed only through white cells in 4 directions. Cells (1,1) and 
(H,W) cannot be changed and must be white. Return -1 if no path exists initially.

/* Simplified for placeholder */","use vstd::prelude::*;

verus! {

spec fn is_valid_input(input: Seq<char>) -> bool {
    input.len() > 0 &&
    true
}

spec fn is_valid_output(output: Seq<char>) -> bool {
    output.len() > 0 &&
    (output == seq!['-', '1', '\n'] || 
     (output != seq!['-', '1', '\n'] && output.len() > 1 && output.last() == '\n'))
}

struct GridData {
    h: int,
    w: int,
    cells: Seq<Seq<char>>,
}

spec fn valid_grid(grid: GridData) -> bool {
    grid.h > 0 && grid.w > 0 && 
    grid.cells.len() == grid.h &&
    (forall|i: int| 0 <= i < grid.h ==> grid.cells[i].len() == grid.w) &&
    (forall|i: int, j: int| 0 <= i < grid.h && 0 <= j < grid.w ==> 
        grid.cells[i][j] == '.' || grid.cells[i][j] == '#') &&
    grid.cells[0][0] == '.' && grid.cells[grid.h-1][grid.w-1] == '.'
}

spec fn parse_input(input: Seq<char>) -> GridData {
    GridData {
        h: 1,
        w: 1,
        cells: seq![seq!['.']]
    }
}

spec fn path_exists(grid: GridData) -> bool {
    true
}

spec fn max_changeable_white_cells(grid: GridData) -> int {
    0
}

spec fn count_white_cells(grid: GridData) -> int {
    2
}

spec fn min_cut_size(grid: GridData) -> int {
    2
}",,fn solve(stdin_input: &str) -> (output: String),"{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0473,verus,apps,apps_test_4147,,"Given N bamboos with lengths, find minimum magic points (MP) to create exactly three bamboos 
with target lengths A, B, and C. Operations: Extension Magic (1 MP per unit), Shortening Magic 
(1 MP per unit), Composition Magic (10 MP to combine two bamboos). Input format: first line 
contains N A B C, followed by N lines with bamboo lengths. Output minimum MP needed.","use vstd::prelude::*;

verus! {

spec fn valid_input(input: Seq<char>) -> bool {
    true
}

spec fn valid_assignment(input: Seq<char>, assignment: Seq<nat>) -> bool {
    true
}

spec fn has_all_three_groups(assignment: Seq<nat>) -> bool {
    (exists|i: int| 0 <= i < assignment.len() && assignment[i] == 1) &&
    (exists|i: int| 0 <= i < assignment.len() && assignment[i] == 2) &&
    (exists|i: int| 0 <= i < assignment.len() && assignment[i] == 3)
}

spec fn calculate_assignment_cost(input: Seq<char>, assignment: Seq<nat>) -> nat {
    composition_cost(assignment) + adjustment_cost(input, assignment)
}

spec fn composition_cost(assignment: Seq<nat>) -> nat {
    let group_a_size = count_group_members(assignment, 1);
    let group_b_size = count_group_members(assignment, 2);
    let group_c_size = count_group_members(assignment, 3);
    (if group_a_size > 0 { ((group_a_size - 1) * 10) as nat } else { 0nat }) +
    (if group_b_size > 0 { ((group_b_size - 1) * 10) as nat } else { 0nat }) +
    (if group_c_size > 0 { ((group_c_size - 1) * 10) as nat } else { 0nat })
}

spec fn adjustment_cost(input: Seq<char>, assignment: Seq<nat>) -> nat {
    let lines = split_lines(input);
    let (n, a, b, c) = parse_first_line_bamboo(lines[0]);
    let sum_a = calculate_group_sum(input, assignment, 1);
    let sum_b = calculate_group_sum(input, assignment, 2);
    let sum_c = calculate_group_sum(input, assignment, 3);
    abs_diff(sum_a, a) + abs_diff(sum_b, b) + abs_diff(sum_c, c)
}

spec fn count_group_members(assignment: Seq<nat>, group: nat) -> nat
    decreases assignment.len()
{
    if assignment.len() == 0 {
        0nat
    } else {
        (if assignment[0] == group { 1nat } else { 0nat }) + count_group_members(assignment.drop_first(), group)
    }
}

spec fn calculate_group_sum(input: Seq<char>, assignment: Seq<nat>, group: nat) -> nat {
    0nat
}

spec fn abs_diff(a: nat, b: nat) -> nat {
    if a >= b { (a - b) as nat } else { (b - a) as nat }
}

spec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {
    Seq::<Seq<char>>::empty()
}

spec fn parse_first_line_bamboo(line: Seq<char>) -> (nat, nat, nat, nat) {
    (0nat, 0nat, 0nat, 0nat)
}

spec fn parse_bamboo_length(line: Seq<char>) -> nat {
    0nat
}

fn int_to_string(n: nat) -> String {
    """".to_string()
}

spec fn string_to_int(s: Seq<char>) -> nat {
    0nat
}",,fn solve(stdin_input: Vec<u8>) -> (result: Vec<u8>),"{
    assume(false);
    Vec::new()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0474,verus,apps,apps_test_4148,,"Given a string S of uppercase English letters and an integer N, shift each character in S by N positions forward in the alphabet. The alphabet wraps around (A follows Z).","use vstd::prelude::*;

verus! {","spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>>
    requires input.len() > 0
{
    let newline_pos = find_newline(input, 0);
    if newline_pos == -1 {
        seq![input]
    } else if newline_pos >= 0 && newline_pos < input.len() {
        if newline_pos + 1 >= input.len() {
            seq![input.subrange(0, newline_pos), seq![]]
        } else {
            seq![input.subrange(0, newline_pos), input.subrange(newline_pos + 1, input.len() as int)]
        }
    } else {
        seq![input]
    }
}

spec fn find_newline(input: Seq<char>, start: int) -> int
    requires 0 <= start <= input.len()
    ensures find_newline(input, start) == -1 || (0 <= find_newline(input, start) < input.len())
    decreases input.len() - start
{
    if start >= input.len() {
        -1
    } else if input[start] == '\n' {
        start
    } else {
        find_newline(input, start + 1)
    }
}

spec fn is_valid_number(s: Seq<char>) -> bool {
    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] <= '9'
}

spec fn string_to_nat(s: Seq<char>) -> nat
    requires is_valid_number(s)
    decreases s.len()
{
    if s.len() == 0 {
        0
    } else if s.len() == 1 {
        (s[0] as int - '0' as int) as nat
    } else {
        (s[0] as int - '0' as int) as nat * 10 + string_to_nat(s.subrange(1, s.len() as int))
    }
}

spec fn caesar_shift(s: Seq<char>, n: nat) -> Seq<char>
    decreases s.len()
{
    if s.len() == 0 {
        seq![]
    } else {
        let shifted_val = (s[0] as int - 'A' as int + n) % 26;
        let shifted_char = ('A' as int + shifted_val) as char;
        seq![shifted_char].add(caesar_shift(s.subrange(1, s.len() as int), n))
    }
}

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 &&
    (exists|i: int| 0 <= i < input.len() && input[i] == '\n') &&
    {
        let lines = split_lines(input);
        lines.len() >= 2 &&
        is_valid_number(lines[0]) &&
        string_to_nat(lines[0]) <= 26 &&
        lines[1].len() >= 1 && lines[1].len() <= 10000 &&
        (forall|j: int| 0 <= j < lines[1].len() ==> 'A' <= lines[1][j] <= 'Z')
    }
}","fn solve(input: Seq<char>) -> (result: Seq<char>)
    requires valid_input(input)
    ensures ({
        let lines = split_lines(input);
        let n = string_to_nat(lines[0]);
        let s = lines[1];
        result == caesar_shift(s, n).add(seq!['\n'])
    })","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0477,verus,apps,apps_test_4165,,"Given N side lengths of a polygon, determine if the polygon can be drawn in a 2D plane.
A polygon can be drawn if and only if the longest side length is strictly less than 
the sum of all other side lengths.","use vstd::prelude::*;

verus! {
spec fn valid_input(sides: Seq<int>) -> bool {
    sides.len() >= 3 && forall|i: int| 0 <= i < sides.len() ==> sides[i] > 0
}

spec fn can_form_polygon(sides: Seq<int>) -> bool
    recommends valid_input(sides)
{
    let sorted_sides = quicksort(sides);
    let longest = sorted_sides[sorted_sides.len() - 1];
    let sum_of_others = sum_except_last(sorted_sides);
    sum_of_others > longest
}

spec fn quicksort(s: Seq<int>) -> Seq<int> {
    seq![]
}

spec fn filter(s: Seq<int>, pred: spec_fn(int) -> bool) -> Seq<int> {
    seq![]
}

spec fn sum_except_last(s: Seq<int>) -> int
    recommends s.len() >= 1
{
    0
}

proof fn filter_preserves_inclusion(s: Seq<int>, pred: spec_fn(int) -> bool)
    ensures forall|x: int| #![auto] filter(s, pred).contains(x) ==> s.contains(x)
{
    assume(false); /* TODO: Remove this line and implement the proof */
}",,"fn solve(sides: Seq<int>) -> (result: String)
    requires
        valid_input(sides),
    ensures
        result@ == seq!['Y', 'e', 's'] || result@ == seq!['N', 'o'],
        (result@ == seq!['Y', 'e', 's']) == can_form_polygon(sides),","{
    assume(false);
    ""No"".to_string()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0480,verus,apps,apps_test_4175,,"Given N words announced in a shiritori game, determine if all shiritori rules were followed.
Shiritori rules No word can be repeated, For each consecutive pair of words, 
the last character of the first word must equal the first character of the second word.","use vstd::prelude::*;

verus! {
spec fn no_repeats(words: Seq<Seq<char>>) -> bool {
    forall|i: int, j: int| 0 <= i < j < words.len() ==> words[i] != words[j]
}

spec fn consecutive_chars_match(words: Seq<Seq<char>>) -> bool 
    recommends forall|i: int| 0 <= i < words.len() ==> words[i].len() > 0
{
    forall|i: int| 0 <= i < words.len() - 1 ==> words[i][words[i].len() - 1] == words[i+1][0]
}

spec fn valid_shiritori(words: Seq<Seq<char>>) -> bool 
    recommends forall|i: int| 0 <= i < words.len() ==> words[i].len() > 0
{
    no_repeats(words) && consecutive_chars_match(words)
}",,"fn solve(words: Vec<Vec<char>>) -> (result: Vec<char>)
    requires forall|i: int| 0 <= i < words@.len() ==> words@[i].len() > 0
    ensures result@ == seq!['Y', 'e', 's'] || result@ == seq!['N', 'o']
    ensures (result@ == seq!['Y', 'e', 's']) <==> valid_shiritori(words@)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0490,verus,apps,apps_test_4199,,"Count how many people can ride a roller coaster given their heights and a minimum height requirement.
Input: N (number of people), K (minimum height requirement), and N heights.
Output: Number of people who can ride (height >= K).","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, k: int, heights: Seq<int>) -> bool {
    n >= 1 && k >= 1 && heights.len() == n && 
    forall|i: int| 0 <= i < heights.len() ==> heights[i] >= 1
}

spec fn count_eligible(heights: Seq<int>, k: int) -> int {
    heights.filter(|height: int| height >= k).len() as int
}",,"fn solve(n: i8, k: i8, heights: Vec<i8>) -> (count: i8)
    requires 
        valid_input(n as int, k as int, heights@.ext_equal(heights@.map_values(|x| x as int)))
    ensures 
        0 <= count as int <= heights@.len(),
        count as int == count_eligible(heights@.map_values(|x| x as int), k as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0499,verus,apps,apps_test_4229,,"Given a positive integer N, calculate the sum of all numbers in the first N terms of the FizzBuzz sequence.
The FizzBuzz sequence transforms each position i (1 to N) as follows:
- If i is divisible by both 3 and 5: term = ""FizzBuzz"" (skip from sum)
- If i is divisible by 3 only: term = ""Fizz"" (skip from sum)  
- If i is divisible by 5 only: term = ""Buzz"" (skip from sum)
- Otherwise: term = i (include in sum)
Return the sum of all numeric terms only.","use vstd::prelude::*;

verus! {

spec fn int_to_string(i: int) -> Seq<char>
    recommends i >= 0
{
    seq!['1']
}

spec fn parse_int_from_string(s: Seq<char>) -> int
    recommends s.len() > 0
{
    1
}

spec fn valid_input(stdin_input: Seq<char>) -> bool
{
    stdin_input.len() > 0
}

spec fn sum_of_non_fizzbuzz_numbers(n: int) -> int
    recommends n >= 0
    decreases n when n >= 0
{
    if n <= 0 {
        0
    } else {
        let num = n;
        if num % 3 != 0 && num % 5 != 0 {
            sum_of_non_fizzbuzz_numbers(n - 1) + num
        } else {
            sum_of_non_fizzbuzz_numbers(n - 1)
        }
    }
}",,"fn solve(stdin_input: Seq<char>) -> (result: Seq<char>)
    requires valid_input(stdin_input)
    ensures result.len() > 0","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0501,verus,apps,apps_test_4233,,"Given an n×m grid containing '*' and '.' characters, find a set of stars that exactly reproduces this pattern.
A star has a center (x,y) and size s, placing '*' at the center and s positions in each cardinal direction.
Output the number of stars and their parameters, or ""-1"" if impossible.

/* Each star is valid and within bounds */

/* The stars exactly cover all '*' positions */

/* center */

/* horizontal ray */

/* vertical ray */","use vstd::prelude::*;

verus! {","spec fn min_int(a: int, b: int) -> int {
    if a <= b { a } else { b }
}

spec fn valid_input(input: Seq<u8>) -> bool {
    input.len() >= 1 && 
    parse_grid_dimensions(input).is_some() &&
    (match parse_grid_dimensions(input) {
        Some((n, m)) => n >= 3 && m >= 3 && grid_has_valid_format(input, n, m),
        None => false
    })
}

spec fn parse_grid_dimensions(input: Seq<u8>) -> Option<(int, int)> {
    Some((3, 3)) /* Placeholder - actual parsing would be complex */
}

spec fn grid_has_valid_format(input: Seq<u8>, n: int, m: int) -> bool {
    true /* Placeholder - check that grid has n rows of m characters each, containing only '*' and '.' */
}

spec fn exists_valid_star_decomposition(input: Seq<u8>) -> bool {
    valid_input(input) &&
    (match parse_grid_dimensions(input) {
        Some((n, m)) => exists|k: int, stars: Seq<(int, int, int)>| 
            0 <= k <= n * m && stars.len() == k &&
            (forall|s: (int, int, int)| stars.contains(s) ==> 
                1 <= s.0 <= n && 1 <= s.1 <= m && 1 <= s.2 <= min_int(n, m)) &&
            valid_star_decomposition(input, stars),
        None => false
    })
}

spec fn valid_star_decomposition(input: Seq<u8>, stars: Seq<(int, int, int)>) -> bool {
    valid_input(input) &&
    (match parse_grid_dimensions(input) {
        Some((n, m)) => 
            (forall|s: (int, int, int)| stars.contains(s) ==> 
                s.0 >= 1 && s.0 <= n && s.1 >= 1 && s.1 <= m && s.2 > 0 &&
                valid_star(n, m, s.0, s.1, s.2)) &&
            (forall|i: int, j: int| 1 <= i <= n && 1 <= j <= m ==>
                (grid_char_at(input, i, j) == b'*') <==> covered_by_stars(stars, i, j)),
        None => false
    })
}

spec fn valid_star(n: int, m: int, x: int, y: int, s: int) -> bool {
    x >= 1 && x <= n && y >= 1 && y <= m && s > 0 &&
    x - s >= 1 && x + s <= n && y - s >= 1 && y + s <= m
}

spec fn covered_by_stars(stars: Seq<(int, int, int)>, i: int, j: int) -> bool {
    exists|s: (int, int, int)| stars.contains(s) && covered_by_star(s.0, s.1, s.2, i, j)
}

spec fn covered_by_star(x: int, y: int, size: int, i: int, j: int) -> bool {
    (i == x && j == y) ||
    (i == x && 1 <= abs_int(j - y) <= size) ||
    (j == y && 1 <= abs_int(i - x) <= size)
}

spec fn abs_int(x: int) -> int {
    if x >= 0 { x } else { -x }
}

spec fn grid_char_at(input: Seq<u8>, i: int, j: int) -> u8 {
    b'*' /* Placeholder - actual grid parsing would be complex */
}

spec fn starts_with_int_and_valid_format(s: Seq<u8>, k: int) -> bool {
    s.len() > 0 && 
    int_to_string_len(k) <= s.len() && 
    s.subrange(0, int_to_string_len(k) as int) == int_to_string_seq(k)
}

spec fn int_to_string_len(k: int) -> nat {
    1 /* Placeholder */
}

spec fn int_to_string_seq(k: int) -> Seq<u8> {
    seq![b'0'] /* Placeholder */
}

spec fn format_star_output(k: int, stars: Seq<(int, int, int)>) -> Seq<u8> {
    if k >= 0 && stars.len() == k {
        let result = int_to_string_seq(k).add(seq![b'\n']);
        format_star_output_helper(result, stars, 0)
    } else {
        seq![]
    }
}

spec fn format_star_output_helper(result: Seq<u8>, stars: Seq<(int, int, int)>, idx: int) -> Seq<u8> 
    decreases stars.len() - idx
{
    if 0 <= idx <= stars.len() {
        if idx >= stars.len() { 
            result 
        } else { 
            let new_result = result.add(int_to_string_seq(stars[idx].0))
                .add(seq![b' ']).add(int_to_string_seq(stars[idx].1))
                .add(seq![b' ']).add(int_to_string_seq(stars[idx].2))
                .add(seq![b'\n']);
            format_star_output_helper(new_result, stars, idx + 1)
        }
    } else {
        result
    }
}","fn solve(input: &str) -> (result: String)
    requires input.len() > 0
    ensures
        valid_input(input.as_bytes()@) ==> 
            (result.as_bytes()@ == seq![b'-', b'1', b'\n']) <==> !exists_valid_star_decomposition(input.as_bytes()@),
        valid_input(input.as_bytes()@) && result.as_bytes()@ != seq![b'-', b'1', b'\n'] ==>
            (exists|k: int, stars: Seq<(int, int, int)>|
                k >= 0 && stars.len() == k &&
                valid_star_decomposition(input.as_bytes()@, stars) &&
                result.as_bytes()@ == format_star_output(k, stars)),
        valid_input(input.as_bytes()@) ==> result.as_bytes()@ != seq![],
        !valid_input(input.as_bytes()@) ==> result.as_bytes()@ == seq![b'-', b'1', b'\n'],
        result.as_bytes()@ == seq![b'-', b'1', b'\n'] || (exists|k: int| k >= 0 && starts_with_int_and_valid_format(result.as_bytes()@, k)),
        result.as_bytes()@ == seq![] || result.as_bytes()@[result.as_bytes()@.len()-1] == b'\n',","{
    // impl-start
    assume(false);
    ""-1\n"".to_string()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0517,verus,apps,apps_test_4271,,"Calculate total satisfaction points from eating N dishes in a specific order.
Each dish provides base satisfaction, plus bonus points for eating consecutive dishes in sequence.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, a: Seq<int>, b: Seq<int>, c: Seq<int>) -> bool {
    n >= 1 &&
    a.len() == n &&
    b.len() == n &&
    c.len() == n - 1 &&
    (forall|i: int| 0 <= i < n ==> 1 <= #[trigger] a[i] <= n) &&
    (forall|i: int, j: int| 0 <= i < j < n ==> #[trigger] a[i] != #[trigger] a[j])
}

spec fn sum_satisfaction(a: Seq<int>, b: Seq<int>, c: Seq<int>, n: int) -> int
    recommends
        n >= 1,
        a.len() == n,
        b.len() == n,
        c.len() == n - 1,
        forall|i: int| 0 <= i < n ==> 1 <= #[trigger] a[i] <= n
{
    sum_satisfaction_up_to(a, b, c, n)
}

spec fn sum_satisfaction_up_to(a: Seq<int>, b: Seq<int>, c: Seq<int>, k: int) -> int
    recommends
        0 <= k <= a.len(),
        b.len() == a.len(),
        c.len() == a.len() - 1,
        forall|i: int| 0 <= i < a.len() ==> 1 <= #[trigger] a[i] <= a.len()
    decreases k
{
    if k <= 0 {
        0
    } else {
        let prev_sum = sum_satisfaction_up_to(a, b, c, k - 1);
        let base_contrib = b[a[k - 1] - 1];
        let bonus_contrib = if k > 1 && a[k - 1] == a[k - 2] + 1 {
            c[a[k - 1] - 2]
        } else {
            0
        };
        prev_sum + base_contrib + bonus_contrib
    }
}",,"fn solve(n: i8, a: Vec<i8>, b: Vec<i8>, c: Vec<i8>) -> (result: i8)
    requires valid_input(n as int, a@.map(|x| x as int), b@.map(|x| x as int), c@.map(|x| x as int))
    ensures result as int == sum_satisfaction(a@.map(|x| x as int), b@.map(|x| x as int), c@.map(|x| x as int), n as int)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0518,verus,apps,apps_test_4274,,"Given N total test cases and M passed test cases, determine if all test cases 
were passed. Input is a string with N and M separated by space. Output ""Yes"" 
if M = N (all passed), ""No"" otherwise. Constraints: 1 ≤ N ≤ 100, 0 ≤ M ≤ N.","use vstd::prelude::*;

verus! {
spec fn split_string(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> { seq![] }

spec fn str_to_int(s: Seq<char>) -> int { 0 }

spec fn valid_input(input: Seq<char>) -> bool {
    input.len() > 0 &&
    exists|lines: Seq<Seq<char>>| lines == split_string(input, '\n') && lines.len() > 0 &&
    exists|parts: Seq<Seq<char>>| parts == split_string(lines[0], ' ') && parts.len() == 2 &&
    {
        let n = str_to_int(parts[0]);
        let m = str_to_int(parts[1]);
        1 <= n <= 100 && 0 <= m <= n
    }
}

spec fn extract_n(input: Seq<char>) -> int {
    let lines = split_string(input, '\n');
    let parts = split_string(lines[0], ' ');
    str_to_int(parts[0])
}

spec fn extract_m(input: Seq<char>) -> int {
    let lines = split_string(input, '\n');
    let parts = split_string(lines[0], ' ');
    str_to_int(parts[1])
}

spec fn correct_output(input: Seq<char>, result: Seq<char>) -> bool {
    let n = extract_n(input);
    let m = extract_m(input);
    (n == m ==> result == seq!['Y', 'e', 's']) && (n != m ==> result == seq!['N', 'o'])
}",,"fn solve(input: &str) -> (result: String)
requires 
    valid_input(input@)
ensures 
    correct_output(input@, result@),
    result@ == seq!['Y', 'e', 's'] || result@ == seq!['N', 'o']","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0531,verus,apps,apps_test_4307,,"Count how many odd positive integers between 1 and N (inclusive) have exactly 8 positive divisors,
where N is between 1 and 200.","use vstd::prelude::*;

verus! {","spec fn is_odd(n: int) -> bool {
    n % 2 == 1
}

spec fn count_divisors(n: nat) -> nat
    recommends n > 0
{
    Set::new(|d: nat| 1 <= d <= n && n % d == 0).len()
}

spec fn has_eight_divisors(n: nat) -> bool
    recommends n > 0
{
    count_divisors(n) == 8
}

spec fn count_odd_with_eight_divisors(n: nat) -> nat {
    Set::new(|i: nat| 1 <= i <= n && is_odd(i as int) && i > 0 && has_eight_divisors(i)).len()
}

spec fn valid_input(n: int) -> bool {
    1 <= n <= 200
}","fn solve(n: int) -> (count: int)
    requires 
        valid_input(n)
    ensures 
        n < 105 ==> count == 0,
        105 <= n && n < 135 ==> count == 1,
        135 <= n && n < 165 ==> count == 2,
        165 <= n && n < 189 ==> count == 3,
        189 <= n && n < 195 ==> count == 4,
        n >= 195 ==> count == 5,
        0 <= count && count <= 5,","{
    assume(false);
    0int
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0543,verus,apps,apps_test_4335,,"Given a positive integer N and a string S of length N consisting of lowercase English letters,
determine whether S can be expressed as the concatenation of two identical strings (S = T + T for some string T).
Return ""Yes"" if S is a concatenation of two copies of some string; otherwise, return ""No"".","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, s: Seq<char>) -> bool {
    1 <= n <= 100 && s.len() == n && forall|i: int| 0 <= i < s.len() ==> 'a' <= s[i] <= 'z'
}

spec fn is_concatenation_of_two_copies(s: Seq<char>) -> bool {
    s.len() % 2 == 0 && forall|i: int| 0 <= i < s.len()/2 ==> s[i] == s[s.len()/2 + i]
}

spec fn yes_seq() -> Seq<char> {
    seq!['Y', 'e', 's']
}

spec fn no_seq() -> Seq<char> {
    seq!['N', 'o']
}",,"fn solve(n: int, s: Seq<char>) -> (result: String)
    requires
        valid_input(n, s),
    ensures
        result@ == yes_seq() || result@ == no_seq(),
        n % 2 != 0 ==> result@ == no_seq(),
        n % 2 == 0 ==> (result@ == yes_seq() <==> is_concatenation_of_two_copies(s)),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0544,verus,apps,apps_test_4337,,"Given N colorful crackers with colors P, W, G, or Y, determine if exactly 3 or 4 distinct colors are present.
The bag always contains at least one cracker of each color P, W, and G.
Output ""Three"" if 3 distinct colors, ""Four"" if 4 distinct colors.","use vstd::prelude::*;

verus! {
spec fn valid_input(n: int, colors: Seq<char>) -> bool {
    1 <= n <= 100 &&
    colors.len() == n &&
    (forall|c: char| colors.contains(c) ==> (c == 'P' || c == 'W' || c == 'G' || c == 'Y')) &&
    colors.contains('P') && colors.contains('W') && colors.contains('G')
}

spec fn distinct_colors(colors: Seq<char>) -> Set<char> {
    colors.to_set()
}

spec fn solution_string(distinct_count: int) -> &'static str
    recommends distinct_count == 3 || distinct_count == 4
{
    if distinct_count == 3 { ""Three"" } else { ""Four"" }
}",,"fn solve(n: int, colors: Seq<char>) -> (result: &'static str)
    requires valid_input(n, colors),
    ensures distinct_colors(colors).len() == 3 || distinct_colors(colors).len() == 4,
    ensures (distinct_colors(colors).len() == 3 ==> result == ""Three"") && (distinct_colors(colors).len() == 4 ==> result == ""Four""),
    ensures result == ""Three"" || result == ""Four"",","{
    assume(false);
    ""Three""
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0547,verus,apps,apps_test_4346,,"Count visible lanterns on a train path from point 1 to point L. 
Lanterns are located at positions divisible by v (i.e., at positions v, 2v, 3v, ...). 
A standing train blocks visibility at positions l through r (inclusive). 
Determine how many lanterns are visible (not blocked by the standing train).","use vstd::prelude::*;

verus! {","spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {
    seq![]
}

spec fn split_spaces(line: Seq<char>) -> Seq<Seq<char>> {
    seq![]
}

spec fn parse_int(s: Seq<char>) -> int {
    0
}

spec fn int_to_string(n: int) -> Seq<char> {
    seq![]
}

spec fn join_lines(lines: Seq<Seq<char>>) -> Seq<char> {
    seq![]
}

spec fn valid_input(input: Seq<char>) -> bool {
    let lines = split_lines(input);
    lines.len() > 0 &&
    is_valid_integer(lines[0]) &&
    {
        let t = parse_int(lines[0]);
        t >= 0 && lines.len() >= t + 1 &&
        forall|i: int| 1 <= i <= t ==> {
            let line_parts = split_spaces(lines[i]);
            line_parts.len() >= 4 &&
            forall|j: int| 0 <= j < 4 ==> is_valid_integer(line_parts[j]) &&
            {
                let parts = split_spaces(lines[i]);
                let L = parse_int(parts[0]);
                let v = parse_int(parts[1]);
                let l = parse_int(parts[2]);
                let r = parse_int(parts[3]);
                L >= 1 && v >= 1 && l >= 1 && r >= l && r <= L
            }
        }
    }
}

spec fn valid_output(output: Seq<char>, input: Seq<char>) -> bool {
    forall|c: char| output.contains(c) ==> (c >= '0' && c <= '9') || c == '-' || c == '\n'
}

spec fn output_matches_algorithm(output: Seq<char>, input: Seq<char>) -> bool
    recommends valid_input(input)
{
    let lines = split_lines(input);
    let t = parse_int(lines[0]);
    t >= 0 &&
    {
        let expected_lines = Seq::new(t as nat, |i: int| {
            if i + 1 < lines.len() && split_spaces(lines[i + 1]).len() >= 4 {
                let parts = split_spaces(lines[i + 1]);
                let L = parse_int(parts[0]);
                let v = parse_int(parts[1]);
                let l = parse_int(parts[2]);
                let r = parse_int(parts[3]);
                let total_lanterns = L / v;
                let blocked_lanterns = r / v - (l - 1) / v;
                let visible_lanterns = total_lanterns - blocked_lanterns;
                int_to_string(visible_lanterns)
            } else {
                seq!['0']
            }
        });
        output == join_lines(expected_lines)
    }
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    s.len() > 0 && (
        (s[0] == '-' && s.len() > 1 && forall|i: int| 1 <= i < s.len() ==> s[i] >= '0' && s[i] <= '9') ||
        (s[0] != '-' && forall|i: int| 0 <= i < s.len() ==> s[i] >= '0' && s[i] <= '9')
    )
}","fn solve(input: &str) -> (output: String)
    requires 
        input.len() > 0,
        valid_input(input@),
    ensures 
        valid_output(output@, input@),
        output_matches_algorithm(output@, input@),","{
    assume(false);
    String::new()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0553,verus,apps,apps_test_4364,,"Given a 4-digit string, determine which date format(s) it represents:
YYMM (year-month), MMYY (month-year), AMBIGUOUS (both valid), or NA (neither valid).
Valid months are 01-12, years can be any two digits 00-99.","use vstd::prelude::*;

verus! {

spec fn valid_input(s: Seq<u8>) -> bool {
    s.len() >= 4 && forall|i: int| 0 <= i < 4 ==> b'0' <= s[i] <= b'9'
}

spec fn char_pair_to_int(c1: u8, c2: u8) -> int 
    recommends b'0' <= c1 <= b'9' && b'0' <= c2 <= b'9'
{
    (c1 as int - b'0' as int) * 10 + (c2 as int - b'0' as int)
}

spec fn valid_month(n: int) -> bool {
    1 <= n <= 12
}

spec fn get_first_pair(s: Seq<u8>) -> int 
    recommends valid_input(s)
{
    char_pair_to_int(s[0], s[1])
}

spec fn get_second_pair(s: Seq<u8>) -> int 
    recommends valid_input(s)
{
    char_pair_to_int(s[2], s[3])
}

spec fn correct_result(s: Seq<u8>, result: Seq<u8>) -> bool 
    recommends valid_input(s)
{
    let s1 = get_first_pair(s);
    let s2 = get_second_pair(s);
    let s1_valid = valid_month(s1);
    let s2_valid = valid_month(s2);
    (s1_valid && s2_valid ==> result == ""AMBIGUOUS\n"".as_bytes()) &&
    (s1_valid && !s2_valid ==> result == ""MMYY\n"".as_bytes()) &&
    (!s1_valid && s2_valid ==> result == ""YYMM\n"".as_bytes()) &&
    (!s1_valid && !s2_valid ==> result == ""NA\n"".as_bytes())
}",,"fn solve(stdin_input: Vec<u8>) -> (result: Vec<u8>)
    requires valid_input(stdin_input@),
    ensures (result@ == ""AMBIGUOUS\n"".as_bytes() || 
             result@ == ""MMYY\n"".as_bytes() || 
             result@ == ""YYMM\n"".as_bytes() || 
             result@ == ""NA\n"".as_bytes()) &&
            correct_result(stdin_input@, result@)","{
    assume(false);
    Vec::new()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0560,verus,apps,apps_test_4383,,"Determine if a child's age qualifies for Shichi-Go-San celebration.
Shichi-Go-San celebrates children who are exactly 3, 5, or 7 years old.
Input is a string containing an integer X (1 ≤ X ≤ 9).
Output ""YES"" if X is 3, 5, or 7, otherwise ""NO"".","use vstd::prelude::*;

verus! {

spec fn valid_input(s: Seq<char>) -> bool {
    s.len() > 0 && exists|i: int| 0 <= i < s.len() && '0' <= s[i] && s[i] <= '9'
}

spec fn is_celebrated_age(age: int) -> bool {
    age == 3 || age == 5 || age == 7
}

spec fn parse_integer_value(s: Seq<char>) -> int {
    parse_integer_helper(s, 0)
}
spec fn parse_integer_helper(s: Seq<char>, pos: int) -> int
    decreases s.len() - pos when 0 <= pos <= s.len()
{
    if pos >= s.len() {
        0
    } else if '0' <= s[pos] && s[pos] <= '9' {
        (s[pos] as int) - ('0' as int)
    } else {
        parse_integer_helper(s, pos + 1)
    }
}",,"fn solve(stdin_input: Vec<u8>) -> (result: String)
    requires valid_input(stdin_input@.map_values(|b: u8| b as char))
    ensures result == if is_celebrated_age(parse_integer_value(stdin_input@.map_values(|b: u8| b as char))) { ""YES\n"" } else { ""NO\n"" }","{
    assume(false);
    ""NO\n"".to_string()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0562,verus,apps,apps_test_4385,,"Given 5 antennas at coordinates a, b, c, d, e (where a < b < c < d < e) and a communication range k,
determine if there exists any pair of antennas that cannot communicate directly. Two antennas can
communicate if the distance between them is at most k. The distance between antennas at coordinates
p and q (where p < q) is q - p. Output ""Yay!"" if all pairs can communicate, "":("" otherwise.","use vstd::prelude::*;

verus! {

spec fn valid_input(a: int, b: int, c: int, d: int, e: int, k: int) -> bool {
    0 <= a <= 123 && 0 <= b <= 123 && 0 <= c <= 123 && 
    0 <= d <= 123 && 0 <= e <= 123 && 0 <= k <= 123 &&
    a < b && b < c && c < d && d < e
}

spec fn all_pairs_can_communicate(a: int, b: int, c: int, d: int, e: int, k: int) -> bool {
    (e - a) <= k
}",,"fn solve(a: int, b: int, c: int, d: int, e: int, k: int) -> (result: String)
    requires
        valid_input(a, b, c, d, e, k)
    ensures
        result@ == ""Yay!"" <==> all_pairs_can_communicate(a, b, c, d, e, k),
        result@ == "":("" <==> !all_pairs_can_communicate(a, b, c, d, e, k)","{
    assume(false);
    String::new()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0568,verus,apps,apps_test_4398,,"Given two strings S and T of equal length N, create a new string by alternating characters 
from S and T in the order: S[0], T[0], S[1], T[1], ..., S[N-1], T[N-1].","use vstd::prelude::*;

verus! {

/* Helper functions for string processing - these would need to be defined elsewhere */
spec fn split_lines(input: &str) -> Seq<&str>;
spec fn string_to_int(s: &str) -> int;
spec fn split_by_space(s: &str) -> Seq<&str>;

spec fn valid_input(input: &str) -> bool {
    let lines = split_lines(input);
    lines.len() >= 2 && {
        let n = string_to_int(lines[0]);
        let parts = split_by_space(lines[1]);
        parts.len() >= 2 &&
        n >= 0 &&
        n <= parts[0].len() && n <= parts[1].len()
    }
}

spec fn get_n(input: &str) -> int
    recommends valid_input(input)
{
    let lines = split_lines(input);
    string_to_int(lines[0])
}

spec fn get_s(input: &str) -> &str
    recommends valid_input(input)
{
    let lines = split_lines(input);
    let parts = split_by_space(lines[1]);
    parts[0]
}

spec fn get_t(input: &str) -> &str
    recommends valid_input(input)
{
    let lines = split_lines(input);
    let parts = split_by_space(lines[1]);
    parts[1]
}

spec fn alternate_chars(s: &str, t: &str, n: int) -> Seq<char>
    recommends n >= 0 && n <= s.len() && n <= t.len()
{
    if n == 0 {
        seq![]
    } else {
        seq![s.get_char(0), t.get_char(0)] + alternate_chars(&s.substring_char(1, s.len() as int), &t.substring_char(1, t.len() as int), n - 1)
    }
}",,"fn solve(input: &str) -> (result: String)
    requires input.len() > 0
    ensures
        valid_input(input) ==> {
            let n = get_n(input);
            let s = get_s(input);
            let t = get_t(input);
            result.len() == 2 * n + 1 &&
            result.get_char((result.len() - 1) as int) == '\n' &&
            result.substring_char(0, (result.len() - 1) as int).view() == alternate_chars(s, t, n)
        } && !valid_input(input) ==> result == """"","{
    assume(false);
    String::new()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0574,verus,apps,apps_test_4418,,"Given an array of n integers where each element is one of {4, 8, 15, 16, 23, 42}, 
find the minimum number of elements to remove to make the array ""good"".
A ""good"" array must have length divisible by 6 and can be split into complete 
subsequences of exactly ""4, 8, 15, 16, 23, 42"" (in that order).","use vstd::prelude::*;

verus! {

spec fn valid_input(n: int, a: Seq<int>) -> bool {
    n >= 0 && a.len() == n && forall|i: int| 0 <= i < a.len() ==> 
        #[trigger] a[i] == 4int || #[trigger] a[i] == 8int || #[trigger] a[i] == 15int || 
        #[trigger] a[i] == 16int || #[trigger] a[i] == 23int || #[trigger] a[i] == 42int
}

spec fn number_of_complete_subsequences(n: int, a: Seq<int>) -> int {
    let k = seq![4int, 8int, 15int, 16int, 23int, 42int];
    let s = seq![n, 0int, 0int, 0int, 0int, 0int, 0int];
    let final_s = process_array(s, a, k, 0int);
    final_s[6int]
}

spec fn process_array(s: Seq<int>, a: Seq<int>, k: Seq<int>, index: int) -> Seq<int>
    decreases a.len() - index
{
    if s.len() == 7 && k.len() == 6 && 0 <= index <= a.len() &&
       (forall|i: int| 0 <= i < a.len() ==> 
            #[trigger] a[i] == 4int || #[trigger] a[i] == 8int || #[trigger] a[i] == 15int || 
            #[trigger] a[i] == 16int || #[trigger] a[i] == 23int || #[trigger] a[i] == 42int) &&
       k == seq![4int, 8int, 15int, 16int, 23int, 42int] &&
       (forall|i: int| 0 <= i < 7 ==> s[i] >= 0) {
        if index == a.len() {
            s
        } else {
            let ai = a[index];
            let new_s = update_state(s, ai, k);
            process_array(new_s, a, k, index + 1)
        }
    } else {
        seq![0int, 0int, 0int, 0int, 0int, 0int, 0int]
    }
}

spec fn update_state(s: Seq<int>, ai: int, k: Seq<int>) -> Seq<int> {
    if s.len() == 7 && k.len() == 6 &&
       (ai == 4int || ai == 8int || ai == 15int || ai == 16int || ai == 23int || ai == 42int) &&
       k == seq![4int, 8int, 15int, 16int, 23int, 42int] &&
       (forall|i: int| 0 <= i < 7 ==> s[i] >= 0) {
        if ai == k[5int] && s[5int] > 0 {
            s.update(6int, s[6int] + 1).update(5int, s[5int] - 1)
        } else if ai == k[4int] && s[4int] > 0 {
            s.update(5int, s[5int] + 1).update(4int, s[4int] - 1)
        } else if ai == k[3int] && s[3int] > 0 {
            s.update(4int, s[4int] + 1).update(3int, s[3int] - 1)
        } else if ai == k[2int] && s[2int] > 0 {
            s.update(3int, s[3int] + 1).update(2int, s[2int] - 1)
        } else if ai == k[1int] && s[1int] > 0 {
            s.update(2int, s[2int] + 1).update(1int, s[1int] - 1)
        } else if ai == k[0int] && s[0int] > 0 {
            s.update(1int, s[1int] + 1).update(0int, s[0int] - 1)
        } else {
            s
        }
    } else {
        seq![0int, 0int, 0int, 0int, 0int, 0int, 0int]
    }
}

spec fn number_of_complete_subsequences_partial(n: int, a: Seq<int>, k: Seq<int>, index: int) -> int {
    if valid_input(n, a) && k.len() == 6 && k == seq![4int, 8int, 15int, 16int, 23int, 42int] && 0 <= index <= a.len() {
        let s = seq![n, 0int, 0int, 0int, 0int, 0int, 0int];
        let partial_a = if index == 0 { seq![] } else { a.subrange(0int, index) };
        let final_s = process_array(s, partial_a, k, 0int);
        final_s[6int]
    } else {
        0int
    }
}",,"fn solve(n: i8, a: Vec<i8>) -> (result: i8)
  requires
    valid_input(n as int, a@.map(|x: i8| x as int)),
  ensures
    0 <= result as int <= n as int,
    result as int == n as int - 6 * number_of_complete_subsequences(n as int, a@.map(|x: i8| x as int)),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0583,verus,apps,apps_test_4460,,"Given five integers representing the values of variables x₁, x₂, x₃, x₄, x₅, find which variable has the value 0.
Initially, each variable xᵢ had value i, but exactly one variable was changed to 0.
Input: Five space-separated integers. Output: The index i (1-indexed) of the variable xᵢ that has value 0.","use vstd::prelude::*;

verus! {
spec fn valid_input(s: Seq<char>) -> bool {
    s.len() > 0 && (forall|i: int| 0 <= i < s.len() ==> 
        s[i] == ' ' || s[i] == '\n' || ('0' <= s[i] <= '9') || s[i] == '-')
}

spec fn valid_number(s: Seq<char>) -> bool {
    s.len() == 0 || (forall|i: int| 0 <= i < s.len() ==> 
        '0' <= s[i] <= '9' || (i == 0 && s[i] == '-'))
}

spec fn count_zeros(numbers: Seq<int>) -> int
    decreases numbers.len()
{
    if numbers.len() == 0 {
        0int
    } else {
        (if numbers[0] == 0 { 1int } else { 0int }) + count_zeros(numbers.subrange(1, numbers.len() as int))
    }
}

spec fn find_zero_index(numbers: Seq<int>) -> int
    decreases numbers.len()
{
    if numbers.len() > 0 && count_zeros(numbers) == 1 {
        if numbers[0] == 0 {
            0int
        } else if numbers.len() > 1 {
            1int + find_zero_index(numbers.subrange(1, numbers.len() as int))
        } else {
            0int
        }
    } else {
        0int
    }
}

spec fn parse_ints(s: Seq<char>) -> Seq<int> {
    if s.len() > 0 && valid_input(s) {
        parse_ints_helper(s, 0, seq![], seq![])
    } else {
        seq![]
    }
}

spec fn parse_ints_helper(s: Seq<char>, pos: int, current: Seq<char>, result: Seq<int>) -> Seq<int>
    decreases s.len() - pos
{
    seq![]
}

spec fn generate_output(numbers: Seq<int>) -> Seq<char> {
    generate_output_helper(numbers, 0, seq![])
}

spec fn generate_output_helper(numbers: Seq<int>, pos: int, result: Seq<char>) -> Seq<char> {
    seq![]
}",,"fn solve(input: &str) -> (result: String)
    requires 
        valid_input(input@),
        input@.len() > 0,
    ensures 
        ({
            let numbers = parse_ints(input@);
            result@ == generate_output(numbers)
        }),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0598,verus,apps,apps_test_4492,,"Given N boxes in a row with a_i candies in the i-th box, find the minimum number of candies 
to eat such that every pair of adjacent boxes contains at most x candies in total.
Operation: Choose any box with at least one candy and eat one candy from it.
Objective: For all i from 1 to N-1, ensure a_i + a_{i+1} ≤ x.","use vstd::prelude::*;

verus! {

/* Helper spec functions for string parsing */
spec fn split_by_newline_spec(s: &str) -> Seq<&str> { Seq::empty() }
spec fn split_by_space_spec(s: &str) -> Seq<&str> { Seq::empty() }
spec fn parse_int_spec(s: &str) -> int { 0 }
spec fn int_to_string_spec(n: int) -> Seq<char> { Seq::empty() }
spec fn string_len_spec(s: &str) -> nat { 0 }
spec fn string_result_len_spec(s: String) -> nat { 0 }

spec fn valid_input(input: &str) -> bool {
    let lines = split_by_newline_spec(input);
    lines.len() >= 2 &&
    {
        let first_line = split_by_space_spec(lines[0]);
        first_line.len() >= 2 &&
        {
            let n = parse_int_spec(first_line[0]);
            let x = parse_int_spec(first_line[1]);
            n >= 2 && x >= 0 &&
            {
                let second_line = split_by_space_spec(lines[1]);
                second_line.len() == n &&
                forall|i: int| 0 <= i < n ==> parse_int_spec(second_line[i]) >= 0
            }
        }
    }
}

spec fn minimum_candies_needed(input: &str) -> int
    recommends valid_input(input)
{
    let lines = split_by_newline_spec(input);
    let first_line = split_by_space_spec(lines[0]);
    let n = parse_int_spec(first_line[0]);
    let x = parse_int_spec(first_line[1]);
    let second_line = split_by_space_spec(lines[1]);
    let a = Seq::new(n as nat, |i: int| parse_int_spec(second_line[i]));
    compute_minimum_operations(a, x)
}

spec fn compute_minimum_operations(a: Seq<int>, x: int) -> int
    recommends a.len() >= 2 && x >= 0 && forall|i: int| 0 <= i < a.len() ==> a[i] >= 0
{
    let a0 = if a[0] > x { x } else { a[0] };
    let cnt0 = if a[0] > x { a[0] - x } else { 0 };
    let new_a = a.update(0, a0);
    compute_operations_from_index(a, x, 1, new_a, cnt0)
}

spec fn compute_operations_from_index(original_a: Seq<int>, x: int, index: int, current_a: Seq<int>, current_count: int) -> int
    recommends 
        original_a.len() >= 2 &&
        x >= 0 &&
        1 <= index <= original_a.len() &&
        current_a.len() == original_a.len() &&
        current_count >= 0 &&
        forall|i: int| 0 <= i < original_a.len() ==> original_a[i] >= 0
    decreases original_a.len() - index
{
    if index >= original_a.len() {
        current_count
    } else {
        let new_value = if current_a[index] + current_a[index - 1] > x {
            x - current_a[index - 1]
        } else {
            current_a[index]
        };
        let additional_ops = if current_a[index] + current_a[index - 1] > x {
            current_a[index] + current_a[index - 1] - x
        } else {
            0
        };
        let new_a = current_a.update(index, new_value);
        compute_operations_from_index(original_a, x, index + 1, new_a, current_count + additional_ops)
    }
}",,"fn solve(input: &str) -> (result: String)
    requires 
        string_len_spec(input) > 0,
        valid_input(input),
    ensures 
        string_result_len_spec(result) > 0,","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0603,verus,apps,apps_test_4501,,"Given N cards with integers written on them, count the number of ways to select
one or more cards such that the average of the selected cards equals exactly A.","use vstd::prelude::*;

verus! {

spec fn split_lines_func(input: Seq<char>) -> Seq<Seq<char>>
{
    Seq::empty()
}

spec fn split_spaces_func(line: Seq<char>) -> Seq<Seq<char>>
{
    Seq::empty()
}

spec fn is_valid_integer(s: Seq<char>) -> bool
{
    true
}

spec fn string_to_int_func(s: Seq<char>) -> int
{
    0
}

spec fn valid_input_format(stdin_input: Seq<char>) -> bool {
    let lines = split_lines_func(stdin_input);
    lines.len() >= 2 &&
    {
        let first_line = split_spaces_func(lines[0]);
        let second_line = split_spaces_func(lines[1]);
        first_line.len() == 2 &&
        is_valid_integer(first_line[0]) &&
        is_valid_integer(first_line[1]) &&
        {
            let N = string_to_int_func(first_line[0]);
            let A = string_to_int_func(first_line[1]);
            1 <= N <= 50 &&
            1 <= A <= 50 &&
            second_line.len() == N &&
            (forall|j: int| 0 <= j < second_line.len() ==> 
                is_valid_integer(second_line[j]) &&
                1 <= string_to_int_func(second_line[j]) <= 50)
        }
    }
}

spec fn is_valid_output(output: Seq<char>) -> bool {
    output.len() > 1 && 
    output[output.len() as int - 1] == '\n' &&
    {
        let result_str = output.subrange(0, output.len() as int - 1);
        is_valid_integer(result_str) &&
        string_to_int_func(result_str) >= 0
    }
}

spec fn output_represents_correct_count(stdin_input: Seq<char>, output: Seq<char>) -> bool
    recommends
        valid_input_format(stdin_input),
        is_valid_output(output)
{
    let lines = split_lines_func(stdin_input);
    let first_line = split_spaces_func(lines[0]);
    let second_line = split_spaces_func(lines[1]);
    let N = string_to_int_func(first_line[0]);
    let A = string_to_int_func(first_line[1]);
    let cards = Seq::new(N as nat, |i: int| string_to_int_func(second_line[i]));
    let result = string_to_int_func(output.subrange(0, output.len() as int - 1));
    result == count_valid_selections(cards, A)
}

spec fn count_valid_selections(cards: Seq<int>, A: int) -> int {
    let differences = Seq::new(cards.len(), |i: int| cards[i] - A);
    let total = count_zero_sum_subsets(differences);
    if total > 0 { total - 1 } else { 0 }
}

spec fn count_zero_sum_subsets(differences: Seq<int>) -> nat
    decreases differences.len()
{
    if differences.len() == 0 {
        1
    } else {
        let rest_count = count_zero_sum_subsets(differences.subrange(1, differences.len() as int));
        rest_count + count_subsets_with_sum(differences.subrange(1, differences.len() as int), -differences[0])
    }
}

spec fn count_subsets_with_sum(differences: Seq<int>, target: int) -> nat
    decreases differences.len()
{
    if differences.len() == 0 {
        if target == 0 { 1 } else { 0 }
    } else {
        count_subsets_with_sum(differences.subrange(1, differences.len() as int), target) +
        count_subsets_with_sum(differences.subrange(1, differences.len() as int), target - differences[0])
    }
}",,"fn solve(stdin_input: &str) -> (output: String)
    requires
        stdin_input@.len() > 0,
        valid_input_format(stdin_input@),
    ensures
        output@.len() > 0,
        output@[output@.len() as int - 1] == '\n',
        is_valid_output(output@),
        output_represents_correct_count(stdin_input@, output@),","{
    // impl-start
    assume(false);
    unreached()
    // impl-end
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0616,verus,apps,apps_test_4546,,"Given three integers a, b, and c representing the heights of three poles,
determine if they form an arithmetic sequence (i.e., b - a = c - b).
Input is a string containing three space-separated integers.
Output is ""YES\n"" if arithmetic sequence, ""NO\n"" otherwise.","use vstd::prelude::*;

verus! {

spec fn valid_three_integers(input: Seq<char>, a: int, b: int, c: int) -> bool {
    true /* Simplified for compilation */
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    s.len() > 0
}

spec fn split_by_spaces_func(s: Seq<char>) -> Seq<Seq<char>> {
    Seq::empty()
}

spec fn parse_int_func(s: Seq<char>) -> int {
    0
}

spec fn parse_unsigned_int(s: Seq<char>) -> int {
    0
}",,"fn solve(input: Seq<char>) -> (result: Seq<char>)
    requires input.len() > 0","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0618,verus,apps,apps_test_4550,,"Given three candy packs with a, b, and c candies respectively, determine if it's possible 
to distribute these packs between two students such that each receives the same total number 
of candies. Each pack must be given entirely to one student.","use vstd::prelude::*;

verus! {

#[verifier::external_body]
spec fn extract_numbers(input: Seq<char>, index: int, acc: Seq<int>, current: Seq<char>) -> Seq<int> {
    Seq::empty()
}

spec fn valid_input_format(input: Seq<char>) -> bool {
    input.len() > 0 &&
    {
        let nums = extract_numbers(input, 0, Seq::empty(), Seq::empty());
        nums.len() >= 3 && 
        (forall|i: int| 0 <= i < 3 ==> #[trigger] nums[i] >= 1 && #[trigger] nums[i] <= 100)
    }
}

spec fn parse_three_ints_func(input: Seq<char>) -> (int, int, int) {
    let nums = extract_numbers(input, 0, Seq::empty(), Seq::empty());
    (nums[0], nums[1], nums[2])
}

spec fn can_distribute_equally(a: int, b: int, c: int) -> bool {
    a + b == c || b + c == a || c + a == b
}",,"fn solve(input: Seq<char>) -> (result: Seq<char>)
    requires 
        input.len() > 0,
        valid_input_format(input),
    ensures 
        result == seq!['Y', 'e', 's', '\n'] || result == seq!['N', 'o', '\n'],
        ({
            let numbers = parse_three_ints_func(input);
            let a = numbers.0;
            let b = numbers.1; 
            let c = numbers.2;
            (result == seq!['Y', 'e', 's', '\n']) <==> can_distribute_equally(a, b, c)
        }),
        ({
            let numbers = parse_three_ints_func(input);
            numbers.0 >= 1 && numbers.1 >= 1 && numbers.2 >= 1 &&
            numbers.0 <= 100 && numbers.1 <= 100 && numbers.2 <= 100
        }),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0640,verus,apps,apps_test_4602,,"Given N balls at coordinates (x_i, i) for i = 1 to N, and 2N robots (N type-A at (0,i) and N type-B at (K,i)),
find the minimum total distance to collect all balls. Each robot can collect the ball on its corresponding line
and return to its starting position. Type-A robot travels 2×x_i, Type-B robot travels 2×(K-x_i).","use vstd::prelude::*;

verus! {

spec fn valid_input(s: Seq<char>) -> bool {
    let lines = split_by_newlines(s);
    lines.len() >= 3 &&
    is_positive_integer(lines[0]) &&
    is_positive_integer(lines[1]) &&
    {
        let n = string_to_int(lines[0]);
        let k = string_to_int(lines[1]);
        1 <= n <= 100 &&
        1 <= k <= 100 &&
        is_valid_x_array(lines[2], n, k)
    }
}

spec fn valid_output(result: Seq<char>) -> bool {
    result.len() >= 2 &&
    result[result.len() - 1] == '\n' &&
    is_non_negative_integer(result.subrange(0, result.len() - 1))
}

spec fn correct_solution(input: Seq<char>, output: Seq<char>) -> bool {
    valid_input(input) && valid_output(output) ==>
        {
            let lines = split_by_newlines(input);
            let n = string_to_int(lines[0]);
            let k = string_to_int(lines[1]);
            let x = parse_int_array(lines[2]);
            x.len() == n &&
            (forall|i: int| #[trigger] x[i] == x[i] && 0 <= i < n ==> 0 < x[i] < k) &&
            {
                let expected_sum = compute_min_distance(x, k);
                string_to_int(output.subrange(0, output.len() - 1)) == expected_sum
            }
        }
}

spec fn is_positive_integer(s: Seq<char>) -> bool {
    is_non_negative_integer(s) && s.len() > 0 && 
    (s.len() > 1 || s[0] != '0') && 
    string_to_int(s) > 0
}

spec fn is_non_negative_integer(s: Seq<char>) -> bool {
    s.len() > 0 && 
    forall|i: int| #[trigger] s[i] == s[i] && 0 <= i < s.len() ==> {
        let c = s[i];
        '0' <= c && c <= '9'
    }
}

spec fn is_valid_x_array(s: Seq<char>, n: int, k: int) -> bool {
    let x = parse_int_array(s);
    x.len() == n && 
    forall|i: int| #[trigger] x[i] == x[i] && 0 <= i < n ==> 0 < x[i] < k
}

spec fn compute_min_distance(x: Seq<int>, k: int) -> int {
    /* requires forall|i: int| 0 <= i < x.len() ==> 0 < x[i] < k */
    /* ensures compute_min_distance(x, k) >= 0 */
    sum_seq(Seq::new(x.len(), |i: int| 2 * min(k - x[i], x[i])))
}

spec fn split_by_newlines(s: Seq<char>) -> Seq<Seq<char>> { 
    seq![]
}

spec fn string_to_int(s: Seq<char>) -> int { 
    0
}

spec fn parse_int_array(s: Seq<char>) -> Seq<int> { 
    seq![]
}

spec fn sum_seq(seq: Seq<int>) -> int { 
    0
}

spec fn min(a: int, b: int) -> int { 
    if a <= b { a } else { b } 
}",,"fn solve(s: &str) -> (result: String)
requires
    s@.len() > 0,
    valid_input(s@),
ensures
    result@.len() > 0,
    result@[result@.len() - 1] == '\n',
    valid_output(result@),
    correct_solution(s@, result@),","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0645,verus,apps,apps_test_4611,,"Given N checkpoints with coordinates (x_i, y_i) and times t_i, determine if it's possible 
to visit each checkpoint at the specified time, starting from (0,0) at time 0. 
At each time step, you must move to an adjacent cell (up, down, left, right) and cannot 
stay in the same position.","use vstd::prelude::*;

verus! {

#[derive(PartialEq, Eq)]
struct Checkpoint {
    t: int,
    x: int,
    y: int,
}

spec fn valid_input_format(input: Seq<char>) -> bool {
    let lines = split_lines(input);
    lines.len() > 0 && is_valid_integer(lines[0]) && 
    ({
        let n = parse_int(lines[0]);
        n >= 0 && n + 1 == lines.len() &&
        (forall|i: int| 1 <= i < lines.len() ==> is_valid_checkpoint_line(lines[i]))
    })
}

spec fn can_visit_all_checkpoints(input: Seq<char>) -> bool
    recommends valid_input_format(input)
{
    let lines = split_lines(input);
    let n = parse_int(lines[0]);
    if n == 0 { 
        true 
    } else {
        let checkpoints = parse_checkpoints(lines.subrange(1, lines.len() as int));
        checkpoints.len() == n &&
        checkpoints_feasible(checkpoints, 0, 0, 0)
    }
}

spec fn checkpoints_feasible(checkpoints: Seq<Checkpoint>, current_t: int, current_x: int, current_y: int) -> bool
    decreases checkpoints.len()
{
    if checkpoints.len() == 0 { 
        true 
    } else {
        let cp = checkpoints[0];
        let dt = cp.t - current_t;
        let dx = if current_x >= cp.x { current_x - cp.x } else { cp.x - current_x };
        let dy = if current_y >= cp.y { current_y - cp.y } else { cp.y - current_y };
        let dis = dx + dy;
        if dt < dis { 
            false 
        } else if (dt - dis) % 2 != 0 { 
            false 
        } else { 
            checkpoints_feasible(checkpoints.subrange(1, checkpoints.len() as int), cp.t, cp.x, cp.y) 
        }
    }
}

spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {
    seq![]
}

spec fn is_valid_integer(line: Seq<char>) -> bool {
    true
}

spec fn parse_int(line: Seq<char>) -> int {
    0
}

spec fn is_valid_checkpoint_line(line: Seq<char>) -> bool {
    true
}

spec fn parse_checkpoints(lines: Seq<Seq<char>>) -> Seq<Checkpoint> {
    seq![]
}",,"fn solve(stdin_input: &str) -> (result: String)
    requires
        stdin_input@.len() > 0,
        valid_input_format(stdin_input@),
    ensures
        result@ == seq!['Y', 'e', 's', '\n'] || result@ == seq!['N', 'o', '\n'],
        (result@ == seq!['Y', 'e', 's', '\n']) <==> can_visit_all_checkpoints(stdin_input@),","{
    assume(false);
    ""No\n"".to_string()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0660,verus,apps,apps_test_4695,,"Given integers x and y where 1 ≤ x < y ≤ 12, determine if they belong to the same group 
according to Snuke's division of integers 1 through 12 into three groups based on some criterion.
Input: Two space-separated integers x and y
Output: ""Yes"" if x and y are in the same group, ""No"" otherwise","use vstd::prelude::*;

verus! {
    spec fn valid_input(input: &str) -> bool
        recommends input.len() > 0
    {
        let parts = split_string_pure(input);
        parts.len() >= 2 && is_valid_int(&parts[0]) && is_valid_int(&parts[1])
    }
    
    spec fn same_group(a: int, b: int) -> bool {
        let n1 = seq![1, 3, 5, 7, 8, 10, 12];
        let n2 = seq![4, 6, 9, 11];
        (n1.contains(a) && n1.contains(b)) || (n2.contains(a) && n2.contains(b)) || (a == 2 && b == 2)
    }
    
    spec fn correct_output(input: &str, result: Seq<char>) -> bool
        recommends input.len() > 0
    {
        if valid_input(input) {
            let parts = split_string_pure(input);
            let a = string_to_int_pure(&parts[0]);
            let b = string_to_int_pure(&parts[1]);
            let yes_str = seq!['Y', 'e', 's', '\n'];
            let no_str = seq!['N', 'o', '\n'];
            (result == yes_str <==> same_group(a, b)) && (result == no_str <==> !same_group(a, b))
        } else {
            result == seq![]
        }
    }","/* Helper functions for string parsing */
spec fn split_string_pure(s: &str) -> Seq<String> {
    Seq::empty() /* placeholder for string splitting */
}

spec fn is_valid_int(s: &str) -> bool {
    true /* placeholder for integer validation */
}

spec fn string_to_int_pure(s: &str) -> int {
    0 /* placeholder for string to int conversion */
}","fn solve(input: &str) -> (result: String)
    requires
        input.len() > 0,
    ensures
        result@ == seq!['Y', 'e', 's', '\n'] || result@ == seq!['N', 'o', '\n'] || result@ == seq![],
        correct_output(input, result@),","{
    assume(false);
    """".to_string()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0666,verus,apps,apps_test_4708,,"Calculate the total cost for N nights of accommodation with tiered pricing.
First K nights cost X yen each, remaining nights (if any) cost Y yen each.
Input: Four integers N, K, X, Y on separate lines.
Output: Single integer representing the total cost.","use vstd::prelude::*;

verus! {
spec fn valid_input(input: Seq<char>) -> bool {
    let lines = split_string(input, '\n');
    lines.len() >= 4 &&
    is_valid_integer(lines[0]) &&
    is_valid_integer(lines[1]) &&
    is_valid_integer(lines[2]) &&
    is_valid_integer(lines[3]) &&
    {
        let n = string_to_int(lines[0]);
        let k = string_to_int(lines[1]);
        let x = string_to_int(lines[2]);
        let y = string_to_int(lines[3]);
        1 <= n <= 10000 && 1 <= k <= 10000 && 1 <= y < x <= 10000
    }
}

spec fn valid_output(output: Seq<char>, input: Seq<char>) -> bool {
    let lines = split_string(input, '\n');
    if lines.len() >= 4 && 
       is_valid_integer(lines[0]) &&
       is_valid_integer(lines[1]) &&
       is_valid_integer(lines[2]) &&
       is_valid_integer(lines[3]) {
        let n = string_to_int(lines[0]);
        let k = string_to_int(lines[1]);
        let x = string_to_int(lines[2]);
        let y = string_to_int(lines[3]);
        let expected_ans = if k < n { k * x + (n - k) * y } else { n * x };
        output == int_to_string(expected_ans) + seq!['\n']
    } else {
        output.len() == 0
    }
}

spec fn split_string(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> {
    seq![]
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
    true
}

spec fn string_to_int(s: Seq<char>) -> int {
    0
}

spec fn int_to_string(n: int) -> Seq<char> {
    seq![]
}",,"fn solve(input: Seq<char>) -> (output: Seq<char>)
    requires input.len() > 0
    ensures valid_output(output, input)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VA0670,verus,apps,apps_test_4714,,"Count the number of palindromic numbers in the range [A, B] inclusive.
A palindromic number is a positive integer that reads the same forwards and backwards when written in decimal notation.
Constraints: 10000 ≤ A ≤ B ≤ 99999","use vstd::prelude::*;

verus! {","spec fn is_palindromic(n: int) -> bool
  recommends n >= 0
{
  let s = int_to_string(n);
  forall|i: int| 0 <= i < s.len() / 2 ==> s[i] == s[s.len() - 1 - i]
}

spec fn count_palindromic_numbers(a: int, b: int) -> int
  recommends 10000 <= a <= b <= 99999
  decreases b - a + 1
{
  if a > b { 
    0
  } else if a == b { 
    if is_palindromic(a) { 1 } else { 0 }
  } else {
    (if is_palindromic(a) { 1 } else { 0 }) + count_palindromic_numbers(a + 1, b)
  }
}

spec fn is_valid_integer(s: Seq<char>) -> bool {
  s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] <= '9'
}

spec fn valid_input(stdin_input: Seq<char>) -> bool {
  stdin_input.len() > 0 &&
  exists|i: int| 0 <= i < stdin_input.len() && stdin_input[i] == ' ' &&
  {
    let parts = split_on_space(stdin_input);
    parts.len() == 2 && 
    is_valid_integer(parts[0]) && 
    is_valid_integer(parts[1]) &&
    string_to_int(parts[0]) >= 10000 &&
    string_to_int(parts[1]) >= 10000 &&
    string_to_int(parts[0]) <= 99999 &&
    string_to_int(parts[1]) <= 99999 &&
    string_to_int(parts[0]) <= string_to_int(parts[1])
  }
}","fn solve(stdin_input: &str) -> (result: String)
  requires 
    valid_input(stdin_input@)
  ensures 
    result@.len() > 0
  ensures 
    result@[result@.len() as int - 1] == '\n'
  ensures {
    let parts = split_on_space(stdin_input@);
    let a = string_to_int(parts[0]);
    let b = string_to_int(parts[1]);
    result@ == int_to_string(count_palindromic_numbers(a, b)) + seq!['\n']
  }","{
  assume(false);
  String::new()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VD0537,verus,dafnybench,cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_NoDups,,"// ASSIGNMENT P1

// CMSC 433 FALL 2023

// PERFECT SCORE:  100 POINTS

//

// This assignment contains nine questions, each of which involves writing Verus

// code. You should include your solutions in a single Verus file and submit it using

// Gradescope.

//

// Revision history

//

// 2023-09-22 2:50 pm   Fixed typo in Problem 3.

// Question 1 (5 points)

//

// Fill in a requires clause that enables Verus to verify

// method PlusOne

// Question 2 (5 points)

//

// Fill in requires clause(s) that enable(s) Verus to verify the array bounds

// in method Swap (which swaps elements i and j in array a).

// Question 3 (5 points)

//

// Give ensures clause(s) asserting that d is the result, and r the

// remainder, of dividing m by n.  Your clauses cannot use ""/"" or ""%"" (which are

// the Verus division and mod operators, respectively). By definition, the

// remainder must be non-negative.

// Question 4 (5 points)

//

// Give ensures clause(s) asserting that the return value has the same

// length as array a and contains as its elements the sum of the

// corresponding elements in arrays a and b.

// Question 5 (10 points)

// Euclid's algorithm is used to compute the greatest common divisor of two

// positive integers.  If m and n are two such integers, then gcd(m,n) is the

// largest positve integer that evenly divides both m and n, where j evenly divides i

// if and only if i % j == 0 (% is the Verus mod operator).  Write requires and

// ensures clauses for the method header Euclid below.  Your requires clauses

// should also specify that the first argument is at least as large as the second.

// You do *not* need to implement the method!

// Question 7 (20 points)

//

// Implement, and have Verus verify, the method IsPrime below, which returns true

// if and only if the given positive integer is prime.

// Question 8 (20 points)

//

// Implement, and have Verus verify, the method Reverse below, which returns a new array

// aRev consisting of the elements of a, but in reverse order.  To create a new 

// array of ints use the Verus command ""Vec::with_capacity(...)"", where ""..."" is the number

// of elements in the array.

// Question 9 (20 points)

//

// Implement and verify method NoDups, which returns true if and only if there

// are no duplicate elements in array a.  Note that the requires clause allows

// you to assume that a is sorted, and that this precondition is necessary for

// the ensures clause to imply a lack of duplicates.

// a sorted","use vstd::prelude::*;

verus! {",,"fn no_dups(a: &Vec<i32>) -> (no_dups: bool)
    requires forall|j: int| 1 <= j < a.len() ==> a[j-1] <= a[j],
    ensures no_dups <==> forall|j: int| 1 <= j < a.len() ==> a[j-1] != a[j],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,-1
VD0848,verus,dafnybench,formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_HoareTripleReqEns,,"/*
Verus include 2 limbaje:
    * un limbaj pentru specificare 
        MSFOL (ce am discutat până acum)
        adnotări care să ajute în procesul de verificare
    * un limbaj pentru scris programe
*/

// Exemplu de program

/*
    triple Hoare (| P |) S (| Q |) 
*/

// varianta assume-assert

// varianta requires-ensures

/*
regula pentru while
*/

// varianta cu assert

/*
*/

// varianta cu invariant

//specificarea sumei de patrate

/*
*/

// verificarea programului pentru suma de patrate

// SqrSumRec(n) = 0^2 + 1^2 + 2^2 + ... + n^2 == n(n+1)(2n+1)/6

// Base case

// Additional proof steps would be needed here

/*
spec fn SqrSumBy6(n: int) -> int
{
    n * (n + 1) * (2 * n + 1) 
}

proof fn L(n: int) // it takes a while
    requires n >= 0
    ensures  SqrSumBy6(n) == 6 * SqrSumRec(n)
    decreases n
{
    if n == 0 {
        // Base case
    } else {
        assert(n > 0);
        L(n-1);
        assert(SqrSumBy6(n-1) == n*(n-1)*(2*n - 1));
        assert(SqrSumBy6(n-1) == 6*SqrSumRec(n-1));
        assert(6*SqrSumRec(n-1) == n*(n-1)*(2*n - 1));
        // Additional calc steps would be needed here for full verification
    }
}
*/

// (| k == i*i |) k := k + 2 * i +1; (| k = (i+1)*(i+1) |)

// Proof by algebraic expansion: k + 2*i + 1 = i*i + 2*i + 1 = (i+1)*(i+1)","use vstd::prelude::*;

verus! {

spec fn SqrSumRec(n: int) -> int
    recommends n >= 0
    decreases n
{
    if n == 0 { 0 } else { n*n + SqrSumRec(n-1) }
}

proof fn L1(n: int)
    requires n >= 0
    ensures SqrSumRec(n) == n*(n+1)*(2*n + 1)/6
    decreases n
{
    if n == 0 {

    } else {
        L1(n-1);

    }
}",,"spec fn HoareTripleReqEns(i: int, k: int) -> (kprime: int)
    recommends k == i*i
    ensures kprime == (i+1)*(i+1)","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,-1
VH0004,verus,humaneval,humaneval_004,,"This task implements the calculation of Mean Absolute Deviation (MAD)
for a sequence of floating-point numbers. The MAD is defined as the average of the
absolute deviations from the arithmetic mean of the data set.

The implementation should calculate the arithmetic mean, compute absolute deviations
from this mean for each element, and then return the average of these absolute deviations
while ensuring the result is non-negative.","use vstd::prelude::*;

verus! {

spec fn sum(numbers: Seq<f64>) -> f64
    decreases numbers.len()
{
    if numbers.len() == 0 {
        0.0
    } else {
        numbers[0] + sum(numbers.drop_first())
    }
}

spec fn abs(x: f64) -> f64 {
    if x >= 0.0 { x } else { -x }
}

spec fn valid_input(numbers: Seq<f64>) -> bool {
    numbers.len() > 0
}

spec fn arithmetic_mean(numbers: Seq<f64>) -> f64 {
    sum(numbers) / (numbers.len() as f64)
}

spec fn absolute_deviations(numbers: Seq<f64>) -> Seq<f64> {
    Seq::new(numbers.len(), |i: int| abs(numbers[i] - arithmetic_mean(numbers)))
}

spec fn mad(numbers: Seq<f64>) -> f64 {
    sum(absolute_deviations(numbers)) / (numbers.len() as f64)
}","proof fn sum_non_negative(numbers: Seq<f64>)
    requires forall|i: int| 0 <= i < numbers.len() ==> numbers[i] >= 0.0,
    ensures sum(numbers) >= 0.0,
    decreases numbers.len(),
{
    if numbers.len() == 0 {
    } else {
        sum_non_negative(numbers.drop_first());
    }
}","fn mean_absolute_deviation(numbers: Vec<f64>) -> (result: f64)
    requires valid_input(numbers@)
    ensures result >= 0.0 && result == mad(numbers@)","{
    assume(false);
    unreached()
}","
}

fn main() {}",0,,-1,-1,-1,,-1
VS0012,verus,numpy_simple,NpConvolve-spec,,,"use vstd::prelude::*;

verus! {",,"spec fn convolution_sum(arr1: Seq<f32>, arr2: Seq<f32>, n: nat) -> f32
{
    0.0
}

fn convolution_sum_impl(arr1: &Vec<f32>, arr2: &Vec<f32>, n: usize) -> f32
{
    // impl-start
    assume(false);
    0.0
    // impl-end
}

fn convolve(arr1: &Vec<f32>, arr2: &Vec<f32>) -> (result: Vec<f32>)
    requires 
        arr1.len() > 0,
        arr2.len() > 0,
    ensures 
        result.len() == arr1.len() + arr2.len() - 1,","{
    // impl-start
    assume(false);
    Vec::new()
    // impl-end
}","
}
fn main() {}",0,,-1,-1,-1,,-1
VT0004,verus,numpy_triple,array_creation_ascontiguousarray,,"Return a contiguous array (ndim >= 1) in memory (C order).
This function ensures the input array is contiguous in C order and guarantees
minimum dimensionality of 1. For non-empty input, preserves all elements.

Specification: ascontiguousarray returns a contiguous array with same content,
ensuring minimum dimensionality of 1. For non-empty arrays, elements are preserved
exactly. For empty arrays, returns a 1-dimensional array with 1 element.","use vstd::prelude::*;

verus! {",,"fn ascontiguousarray(a: Vec<f32>) -> (result: Vec<f32>)
    ensures
        result.len() >= 1,
        a.len() > 0 ==> result.len() == a.len(),
        a.len() == 0 ==> result.len() == 1,
        a.len() > 0 ==> forall|i: int| 0 <= i < a.len() ==> exists|j: int| 0 <= j < result.len() && result[j] == a[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,-1
VT0009,verus,numpy_triple,array_creation_diagflat,,"numpy.diagflat: Create a two-dimensional array with the flattened input as a diagonal.

Takes an input vector (representing flattened data) and creates a square matrix
where the input values appear along the k-th diagonal. The parameter k determines
which diagonal to use: k=0 for main diagonal, k>0 for super-diagonals,
and k<0 for sub-diagonals.

For simplicity, we focus on the main diagonal case (k=0) and return a 1D flattened
representation of the square matrix.

Specification: diagflat creates a square matrix with input values on the main diagonal.

Precondition: True (no special preconditions)
Postcondition: The result is a flattened square matrix where:
1. The input vector v appears along the main diagonal
2. All other elements are zero
3. The matrix has dimensions n × n (flattened to n² elements)","use vstd::prelude::*;

verus! {",,"fn diagflat(v: Vec<f32>) -> (result: Vec<f32>)
    ensures
        result.len() == v.len() * v.len(),
        forall|i: int| 0 <= i < v.len() ==> result[i * v.len() + i] == v[i],
        forall|i: int, j: int| 0 <= i < v.len() && 0 <= j < v.len() && i != j ==> result[i * v.len() + j] == 0.0f32","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,-1
VT0011,verus,numpy_triple,array_creation_empty_like,,"numpy.empty_like: Return a new array with the same shape and type as a given array.

Creates a new array with the same shape and type as the prototype array,
but with uninitialized (arbitrary) data. This is useful for creating
arrays that will be filled with values later, avoiding the overhead
of initialization.

The returned array has the same dimensions as the prototype but does not
copy the values - the contents are undefined and may contain any values.

Specification: numpy.empty_like returns a vector with the same size as the prototype
but with uninitialized values.

Precondition: True (no special preconditions needed)
Postcondition: 
1. The result has the same size as the prototype array
2. The result vector is well-formed with proper indexing
3. The result is independent of the prototype's values (shape invariant)

Mathematical Properties:
- Size preservation: |result| = |prototype| = n
- Index validity: all valid indices for prototype are valid for result
- Type preservation: result has same element type as prototype

Note: We cannot specify the actual values since they are uninitialized,
but we can specify structural and size properties that must hold.","use vstd::prelude::*;

verus! {",,"fn numpy_empty_like(prototype: &Vec<f32>) -> (result: Vec<f32>)
    ensures
        result.len() == prototype.len(),
        forall|i: int| 0 <= i < prototype.len() ==> 0 <= i < result.len(),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,-1
VT0012,verus,numpy_triple,array_creation_eye,,"numpy.eye: Return a 2-D array with ones on the diagonal and zeros elsewhere.

Returns the identity matrix of size n x n. For simplicity, we implement 
the square matrix case (N=M) with diagonal offset k=0.

This function creates an n x n matrix where all elements are zero except
for the main diagonal, which contains ones.","use vstd::prelude::*;

verus! {",,"fn eye(n: usize) -> (result: Vec<Vec<f32>>)
    ensures
        result.len() == n,
        forall|i: int| 0 <= i < n ==> result[i].len() == n,
        forall|i: int, j: int| 0 <= i < n && 0 <= j < n ==> 
            result[i][j] == if i == j { 1.0f32 } else { 0.0f32 },
        forall|i: int, j: int| 0 <= i < n && 0 <= j < n ==> 
            result[i][j] == result[j][i],
        forall|i: int| 0 <= i < n ==> exists|j: int| 0 <= j < n && 
            result[i][j] == 1.0f32 && forall|k: int| 0 <= k < n && result[i][k] == 1.0f32 ==> k == j,
        forall|j: int| 0 <= j < n ==> exists|i: int| 0 <= i < n && 
            result[i][j] == 1.0f32 && forall|k: int| 0 <= k < n && result[k][j] == 1.0f32 ==> k == i,
        forall|i: int, j: int| 0 <= i < n && 0 <= j < n && i != j ==> 
            result[i][j] == 0.0f32,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,-1
VT0035,verus,numpy_triple,array_creation_zeros,,"Return a new vector of given size, filled with zeros

Specification: zeros returns a vector where all elements are zero
This comprehensive specification captures:
1. All elements equal to zero (basic property)
2. The result is the additive identity for vector addition
3. The sum of all elements is zero (for numeric types)
4. Scalar multiplication by any value preserves the zero property
5. The dot product with any vector is zero
6. The norm/magnitude is zero (for types with norm)
7. Element-wise operations preserve zero structure","use vstd::prelude::*;

verus! {",,"fn zeros(n: usize) -> (result: Vec<i32>)
    ensures
        result.len() == n,
        forall|i: int| 0 <= i < n ==> result[i] == 0,
        forall|v: Vec<i32>, i: int| 
            v.len() == n && 0 <= i < n ==> 
            result[i] + v[i] == v[i] && v[i] + result[i] == v[i],
        forall|scalar: i32, i: int| 
            0 <= i < n ==> scalar * result[i] == 0,
        forall|v: Vec<i32>, i: int| 
            v.len() == n && 0 <= i < n ==> result[i] * v[i] == 0,
        n > 0 ==> result[0] == 0","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,-1
VT0041,verus,numpy_triple,array_manipulation_atleast_3d,,"numpy.atleast_3d: View a 1D vector as a 3D array with shape (1, n, 1).

This is a specialization of numpy.atleast_3d for 1D input.
The function reshapes a 1D array of shape (n,) into a 3D array 
of shape (1, n, 1) while preserving all elements.

Specification: atleast_3d transforms a 1D vector into a 3D array where:
- The output has shape (1, n, 1)
- Each element arr[i] is accessible at position [0][i][0] in the result
- All elements are preserved without modification
- The transformation is injective (different inputs produce different outputs)

Mathematical properties:
1. Element preservation: Every element from the input appears exactly once in the output
2. Shape expansion: A 1D shape (n,) becomes 3D shape (1, n, 1)
3. Order preservation: Elements maintain their relative ordering
4. The output contains exactly n elements total","use vstd::prelude::*;

verus! {",,"fn atleast_3d(arr: Vec<f32>) -> (result: Vec<Vec<Vec<f32>>>)
    ensures 
        result.len() == 1,
        forall|j: int| 0 <= j < 1 ==> result[j].len() == arr.len(),
        forall|j: int, k: int| 0 <= j < 1 && 0 <= k < arr.len() ==> result[j][k].len() == 1,
        forall|i: int| 0 <= i < arr.len() ==> {
            let outer = &result[0];
            let middle = &outer[i];
            let value = middle[0];
            value == arr[i]
        }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,-1
VT0042,verus,numpy_triple,array_manipulation_block,,"Assemble a 2D matrix from a 2x2 block structure.
This is a simplified version focusing on the common case of assembling 
a matrix from four blocks arranged in a 2x2 pattern.

Specification: block assembles a matrix from four submatrices in a 2x2 pattern.
The result has dimensions (r1 + r2) × (c1 + c2) where:
- Top-left block occupies rows [0, r1) and columns [0, c1)
- Top-right block occupies rows [0, r1) and columns [c1, c1 + c2)
- Bottom-left block occupies rows [r1, r1 + r2) and columns [0, c1)
- Bottom-right block occupies rows [r1, r1 + r2) and columns [c1, c1 + c2)

/* Top-left block elements */

/* Top-right block elements */

/* Bottom-left block elements */

/* Bottom-right block elements */","use vstd::prelude::*;

verus! {",,"fn block(
    top_left: Vec<Vec<f32>>,
    top_right: Vec<Vec<f32>>,
    bottom_left: Vec<Vec<f32>>,
    bottom_right: Vec<Vec<f32>>
) -> (result: Vec<Vec<f32>>)
    requires
        top_left.len() > 0,
        top_right.len() > 0,
        bottom_left.len() > 0,
        bottom_right.len() > 0,
        top_left.len() == top_right.len(),
        bottom_left.len() == bottom_right.len(),
        top_left[0].len() == bottom_left[0].len(),
        top_right[0].len() == bottom_right[0].len(),
        forall|i: int| 0 <= i < top_left.len() ==> top_left[i].len() == top_left[0].len(),
        forall|i: int| 0 <= i < top_right.len() ==> top_right[i].len() == top_right[0].len(),
        forall|i: int| 0 <= i < bottom_left.len() ==> bottom_left[i].len() == bottom_left[0].len(),
        forall|i: int| 0 <= i < bottom_right.len() ==> bottom_right[i].len() == bottom_right[0].len(),
    ensures
        result.len() == top_left.len() + bottom_left.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i].len() == top_left[0].len() + top_right[0].len(),

        forall|i: int, j: int| 
            0 <= i < top_left.len() && 0 <= j < top_left[0].len() ==> 
            result[i][j] == top_left[i][j],

        forall|i: int, j: int|
            0 <= i < top_right.len() && 0 <= j < top_right[0].len() ==>
            result[i][top_left[0].len() + j] == top_right[i][j],

        forall|i: int, j: int|
            0 <= i < bottom_left.len() && 0 <= j < bottom_left[0].len() ==>
            result[top_left.len() + i][j] == bottom_left[i][j],

        forall|i: int, j: int|
            0 <= i < bottom_right.len() && 0 <= j < bottom_right[0].len() ==>
            result[top_left.len() + i][top_left[0].len() + j] == bottom_right[i][j],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,-1
VT0045,verus,numpy_triple,array_manipulation_broadcast_to,,"Broadcast a 1D vector to a 2D matrix by repeating it along rows.
This implements the most common broadcasting pattern: (n,) -> (m, n)

Specification: broadcast_to creates a 2D matrix where each row is a copy of the input vector.

Mathematical properties:
1. Shape property: The result has shape (m, n) where n is the original vector length
2. Value property: Each row in the result equals the original vector
3. Broadcasting rule: A 1D array of shape (n,) can be broadcast to (m, n) by repeating
4. Row consistency: All rows in the result are identical to the input vector
5. Element preservation: Each element in the input appears m times in each column

Sanity checks:
- The output shape is exactly (m, n)
- Every row contains the same values as the input vector
- Broadcasting preserves element values without modification
- The result behaves as if v was copied m times along a new axis

Example behavior:
- Input: [1, 2, 3] with target shape (2, 3)
- Output: [[1, 2, 3], [1, 2, 3]]

Additional properties:
- Memory efficiency: In NumPy, this creates a view, not a copy
- Column-wise view: Column j contains m copies of v[j]
- Broadcasting compatibility: The result can be used in element-wise operations with other (m, n) arrays

Mathematical formulation:
- For input vector v ∈ ℝⁿ and target shape (m, n)
- Output matrix M ∈ ℝᵐˣⁿ where M[i,j] = v[j] for all i ∈ {0,...,m-1}, j ∈ {0,...,n-1}

/* Primary property: each element (i,j) equals v[j] */

/* Row identity: each row is exactly the input vector */

/* Column uniformity: each column contains a single repeated value */

/* Value preservation: no new values are introduced */

/* Broadcast invariant: the operation is idempotent on rows */","use vstd::prelude::*;

verus! {",,"fn broadcast_to(v: Vec<f32>, m: usize) -> (result: Vec<Vec<f32>>)
    requires v.len() > 0,
    ensures
        result.len() == m,

        forall|i: int, j: int| 0 <= i < m && 0 <= j < v.len() ==> result[i][j] == v[j],

        forall|i: int| 0 <= i < m ==> result[i]@ == v@,

        forall|j: int, i1: int, i2: int| 0 <= j < v.len() && 0 <= i1 < m && 0 <= i2 < m ==> result[i1][j] == result[i2][j],

        forall|i: int, j: int| 0 <= i < m && 0 <= j < v.len() ==> exists|k: int| 0 <= k < v.len() && result[i][j] == v[k] && k == j,

        forall|i1: int, i2: int| 0 <= i1 < m && 0 <= i2 < m ==> result[i1]@ == result[i2]@","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,-1
VT0046,verus,numpy_triple,array_manipulation_column_stack,,"numpy.column_stack: Stack 1-D arrays as columns into a 2-D array.

Takes a sequence of 1-D arrays and stacks them as columns to make a 
single 2-D array. All input arrays must have the same length (number 
of rows in the output).

The result is represented as a flattened vector in column-major order,
where elements from the same column are contiguous. For a result with
'rows' rows and 'cols' columns, element at position (i, j) is stored
at index j * rows + i in the flattened vector.

This is a fundamental array manipulation operation that combines multiple
1D arrays into a single 2D structure, useful for constructing matrices
from column vectors.

Specification: column_stack creates a 2D array (as flattened vector) where
each input array becomes a column.

Precondition: cols > 0 (at least one input array)
Postcondition: 
- The result contains all elements from the input arrays
- Elements are arranged in column-major order
- The j-th column of the result contains all elements from arrays[j]
- For 0 ≤ i < rows and 0 ≤ j < cols, the element at position (i,j)
  in the 2D view equals arrays[j][i] and is stored at index j*rows + i","use vstd::prelude::*;

verus! {",,"fn column_stack(arrays: Vec<Vec<f32>>) -> (result: Vec<f32>)
    requires
        arrays.len() > 0,
        forall|i: int| 0 <= i < arrays.len() ==> arrays[i].len() == arrays[0].len(),
    ensures
        result.len() == arrays.len() * arrays[0].len(),
        forall|i: int, j: int| 
            0 <= i < arrays[0].len() && 0 <= j < arrays.len() ==>
            result[j * arrays[0].len() + i] == arrays[j][i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,-1
VT0049,verus,numpy_triple,array_manipulation_delete,,"numpy.delete: Return a new array with sub-arrays along an axis deleted.

For a one dimensional array, this returns those entries not returned by
arr[obj]. The function removes elements at the specified index and
returns a new array with the remaining elements.

This specification handles the 1D case where we delete a single element
at a specified index from a vector.

Specification: numpy.delete removes the element at the specified index and returns
a new vector containing all other elements in their original order.

The specification ensures:
1. The result has size n (one less than the input)
2. Elements before the deleted index maintain their positions
3. Elements after the deleted index are shifted left by one position

Mathematical properties:
- Order preservation: Elements maintain their relative order
- Deletion correctness: The element at the specified index is removed
- Shift property: Elements after the deleted index have their indices decreased by 1

Sanity checks:
- The result size is exactly one less than the input size
- No elements are duplicated or lost (except the deleted one)
- The deleted element does not appear in the result

Precondition: The array must have at least one element (enforced by type)

Postcondition:
- For indices i < index: result[i] = arr[i]
- For indices i ≥ index: result[i] = arr[i+1]
- The element arr[index] does not appear in the result (unless duplicated elsewhere)","use vstd::prelude::*;

verus! {",,"fn delete(arr: Vec<f32>, index: usize) -> (result: Vec<f32>)
    requires 
        arr.len() > 0,
        index < arr.len(),
    ensures 
        result.len() == arr.len() - 1,
        forall|i: int| 0 <= i < index ==> result[i] == arr[i],
        forall|i: int| index <= i < result.len() ==> result[i] == arr[i + 1],
        forall|i: int| 0 <= i < arr.len() && i != index ==> 
            exists|j: int| 0 <= j < result.len() && result[j] == arr[i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,-1
VT0051,verus,numpy_triple,array_manipulation_dstack,,"numpy.dstack: Stack arrays in sequence depth wise (along third axis).

For a sequence of 1D arrays (vectors), this function stacks them along a new third axis,
creating a 3D array. Each input vector becomes a ""slice"" in the depth dimension.

For 1D inputs of length n, the output shape is (1, n, k) where k is the number of arrays.
This is because 1D arrays are first reshaped to (1, n) then stacked along axis 2.

The result is always at least 3-dimensional.","use vstd::prelude::*;

verus! {",,"fn numpy_dstack(arrays: Vec<Vec<f32>>) -> (result: Vec<Vec<Vec<f32>>>)
    requires 
        arrays.len() > 0,
        forall|i: int| 0 <= i < arrays.len() ==> 
            forall|j: int| 0 <= j < arrays.len() ==> arrays[i].len() == arrays[j].len(),
    ensures
        result.len() == 1,
        result[0].len() == if arrays.len() > 0 { arrays[0].len() } else { 0 },
        forall|i: int| 0 <= i < result[0].len() ==> result[0][i].len() == arrays.len(),
        forall|i: int, j: int| 
            0 <= i < result[0].len() && 0 <= j < arrays.len() ==>
            result[0][i][j] == arrays[j][i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,-1
VT0054,verus,numpy_triple,array_manipulation_fliplr,,"Reverses the order of columns in a 2D matrix (left/right flip).
For a matrix with shape (rows × cols), this operation reverses the order 
of elements along each row, effectively flipping the matrix horizontally.

Specification: fliplr reverses the column order in each row of the matrix.
The element at position (i, j) in the input matrix appears at position 
(i, cols-1-j) in the output matrix. This captures the mathematical property
that columns are reversed while rows remain in the same order.

Sanity checks:
1. The output has the same dimensions as the input (enforced by type)
2. Each row contains the same elements, just in reversed order
3. For matrices with odd number of columns, the middle column stays in place

Mathematical properties:
1. Element mapping: For all valid indices i and j, there exists a corresponding
   index j' such that output[i,j] = input[i,j'] where j' = cols-1-j
2. Row preservation: Each row contains exactly the same elements as the input
3. Column reversal: The first column becomes the last, second becomes second-to-last, etc.","use vstd::prelude::*;

verus! {",,"fn fliplr(m: Vec<Vec<f32>>) -> (result: Vec<Vec<f32>>)
    requires 
        m.len() > 0,
        forall|i: int| 0 <= i < m.len() ==> m[i].len() > 0,
        forall|i: int, j: int| 0 <= i < m.len() && 0 <= j < m.len() ==> m[i].len() == m[j].len(),
    ensures
        result.len() == m.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i].len() == m[i].len(),
        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result[i].len() ==>
            exists|k: int| 0 <= k < m[i].len() && 
                           result[i][j] == m[i][k] && 
                           j + k == (m[i].len() - 1) as int,
        forall|i: int, x: f32| 0 <= i < result.len() ==>
            ((exists|j: int| 0 <= j < m[i].len() && m[i][j] == x) <==> 
             (exists|j: int| 0 <= j < result[i].len() && result[i][j] == x)),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,-1
VT0059,verus,numpy_triple,array_manipulation_matrix_transpose,,"Transposes a matrix by swapping rows and columns.
For a matrix with shape (m, n), returns a matrix with shape (n, m)
where result[i, j] = input[j, i]

Specification: matrix_transpose swaps rows and columns, producing a transposed matrix
where the element at position (i, j) in the result equals the element at position (j, i)
in the input. The result has dimensions swapped: an m×n matrix becomes n×m.

/* Dimension check: result is n×m when input is m×n */

/* Transpose property: result[i][j] = mat[j][i] */","use vstd::prelude::*;

verus! {",,"fn matrix_transpose(mat: &Vec<Vec<f32>>) -> (result: Vec<Vec<f32>>)
    requires 
        mat.len() > 0,
        forall|i: int| 0 <= i < mat.len() ==> mat[i].len() == mat[0].len(),
    ensures

        result.len() == mat[0].len(),
        forall|i: int| 0 <= i < result.len() ==> result[i].len() == mat.len(),

        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result[i].len() ==> 
            result[i][j] == mat[j][i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,-1
VT0063,verus,numpy_triple,array_manipulation_repeat,,"Repeat elements of a vector a specified number of times.
Each element is repeated consecutively.

Specification: repeat creates a vector where each element from the input 
appears consecutively 'repeats' times. The resulting vector has size n * repeats.

For a vector [a₀, a₁, ..., aₙ₋₁] and repeats = r, the result is:
[a₀, a₀, ..., a₀, a₁, a₁, ..., a₁, ..., aₙ₋₁, aₙ₋₁, ..., aₙ₋₁]
 \___r times___/  \___r times___/       \______r times______/

Mathematical properties:
1. Each element appears exactly 'repeats' times consecutively
2. The total size is n * repeats
3. Element at index i comes from input element at index ⌊i/repeats⌋
4. Elements are grouped: positions [k*repeats, (k+1)*repeats) contain a[k]","use vstd::prelude::*;

verus! {",,"fn repeat<T: Copy>(a: Vec<T>, repeats: usize) -> (result: Vec<T>)
    requires repeats > 0,
    ensures
        result.len() == a.len() * repeats,
        forall|i: int| 0 <= i < result.len() ==> {
            let k = i / (repeats as int);
            0 <= k < a.len() && result[i] == a[k]
        },
        forall|k: int| 0 <= k < a.len() ==> forall|j: int| 0 <= j < repeats ==> {
            let idx = k * (repeats as int) + j;
            0 <= idx < result.len() && result[idx] == a[k]
        },","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,-1
VT0075,verus,numpy_triple,array_manipulation_swapaxes,,"Numpy swapaxes function: Interchange two axes of an array.

This function interchanges two axes of an array. For 2D arrays, swapaxes with axis1=0 and axis2=1 is equivalent to transpose. This specification focuses on 2D arrays where axis1=0 and axis2=1.

Specification: swapaxes with axes 0 and 1 transposes a 2D array.
The element at position (i,j) in the original becomes (j,i) in the result.

Mathematical properties:
1. Dimension swap: rows become columns and vice versa
2. Element preservation: mat[i][j] = result[j][i]
3. Idempotence: swapping twice returns to original
4. Commutativity: swapaxes(a, i, j) = swapaxes(a, j, i)","use vstd::prelude::*;

verus! {",,"fn swapaxes(mat: Vec<Vec<f32>>, axis1: usize, axis2: usize) -> (result: Vec<Vec<f32>>)
    requires
        mat.len() > 0,
        mat[0].len() > 0,
        forall|i: int| 0 <= i < mat.len() ==> mat[i].len() == mat[0].len(),
        axis1 < 2,
        axis2 < 2,
    ensures
        result.len() == mat[0].len(),
        result.len() > 0 ==> result[0].len() == mat.len(),
        forall|i: int| 0 <= i < result.len() ==> result[i].len() == mat.len(),
        forall|i: int, j: int| 
            0 <= i < mat.len() && 0 <= j < mat[0].len() 
            ==> mat[i][j] == result[j][i],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,-1
VT0077,verus,numpy_triple,array_manipulation_transpose,,"numpy.transpose: Returns a matrix with rows and columns swapped.

For 2D arrays (matrices), transpose swaps the rows and columns.
This means that element at position (i,j) in the original matrix
appears at position (j,i) in the transposed matrix.

This simplified version handles 2D matrix transpose only.

Specification: numpy.transpose returns a matrix where rows and columns are swapped.

Precondition: True (no special preconditions for basic transpose)
Postcondition: For all valid indices (i,j), result[j][i] = a[i][j]

Mathematical properties:
- Transpose is an involution: (A^T)^T = A
- For square matrices: trace(A^T) = trace(A)
- (A^T)[j,i] = A[i,j] for all valid indices","use vstd::prelude::*;

verus! {",,"fn numpy_transpose(a: Vec<Vec<f32>>) -> (result: Vec<Vec<f32>>)
    requires 
        a.len() > 0,
        forall|i: int| 0 <= i < a.len() ==> a[i].len() == a[0].len(),
        a[0].len() > 0,
    ensures
        result.len() == a[0].len(),
        forall|j: int| 0 <= j < result.len() ==> result[j].len() == a.len(),
        forall|i: int, j: int| 
            0 <= i < a.len() && 0 <= j < a[0].len() ==> 
            result[j][i] == a[i][j],","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,-1
VT0080,verus,numpy_triple,array_manipulation_vsplit,,"Split a 2D vector into multiple sub-vectors vertically (row-wise).
This is a simplified version that handles splitting into equal parts.

Specification: vsplit divides a matrix into k equal parts row-wise, 
where each part contains consecutive rows from the original matrix","use vstd::prelude::*;

verus! {",,"fn vsplit(mat: Vec<Vec<f32>>, k: usize) -> (result: Vec<Vec<Vec<f32>>>)
    requires 
        k > 0,
        mat.len() > 0,
        mat.len() % k == 0,
        forall|i: int| 0 <= i < mat.len() ==> mat[i].len() == mat[0].len(),
    ensures
        result.len() == k,
        forall|split_idx: int| 0 <= split_idx < k ==> result[split_idx].len() == mat.len() / k,
        forall|split_idx: int, row_idx: int, col_idx: int| 
            0 <= split_idx < k && 0 <= row_idx < mat.len() / k && 0 <= col_idx < mat[0].len() ==>
            exists|global_row: int| 
                global_row == split_idx * (mat.len() / k) + row_idx &&
                0 <= global_row < mat.len() &&
                result[split_idx][row_idx][col_idx] == mat[global_row][col_idx],
        forall|orig_row: int| 0 <= orig_row < mat.len() ==>
            exists|split_idx: int, row_idx: int|
                0 <= split_idx < k && 0 <= row_idx < mat.len() / k &&
                orig_row == split_idx * (mat.len() / k) + row_idx,","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,-1
VT0089,verus,numpy_triple,bitwise_operations_packbits,,"Packs binary-valued elements into bits in a UInt8 array.
Each group of 8 binary values is packed into one UInt8.
The result is padded with zeros if needed.

Specification: packbits correctly packs binary values into UInt8 bytes according to bitorder.
For big-endian: first element goes to MSB (bit 7)
For little-endian: first element goes to LSB (bit 0)

/* Enumeration for bit ordering in packbits */

// MSB first (default): bit 7 is first element

// LSB first: bit 0 is first element

// Big-endian: bit 7 is first, bit 0 is last

// Little-endian: bit 0 is first, bit 7 is last","use vstd::prelude::*;

verus! {

#[derive(PartialEq, Eq)]
enum BitOrder {
    Big,
    Little
}",,"fn packbits(a: Vec<bool>, bitorder: BitOrder) -> (result: Vec<u8>)
    requires a.len() > 0,
    ensures 
        result.len() == (a.len() + 7) / 8,
        forall|byte_idx: int| 0 <= byte_idx < result.len() ==> {
            let start_idx = byte_idx * 8;
            let bits_in_byte = if start_idx + 8 <= a.len() { 8 } else { a.len() - start_idx };
            match bitorder {
                BitOrder::Big => {

                    forall|bit_pos: int| 0 <= bit_pos < bits_in_byte ==> {
                        let bit_value = if start_idx + bit_pos < a.len() && a[start_idx + bit_pos] { 1u8 } else { 0u8 };
                        (result[byte_idx] & (1u8 << (7 - bit_pos))) == (bit_value << (7 - bit_pos))
                    }
                },
                BitOrder::Little => {

                    forall|bit_pos: int| 0 <= bit_pos < bits_in_byte ==> {
                        let bit_value = if start_idx + bit_pos < a.len() && a[start_idx + bit_pos] { 1u8 } else { 0u8 };
                        (result[byte_idx] & (1u8 << bit_pos)) == (bit_value << bit_pos)
                    }
                }
            }
        }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,-1
VT0092,verus,numpy_triple,constants_False_,,"NumPy's boolean False value, used in comparison operations and boolean arrays.

Specification: False_ represents the boolean false value with properties:
1. It equals false
2. It is the identity for logical OR
3. It is the absorbing element for logical AND
4. It is the negation of True_","use vstd::prelude::*;

verus! {",,"fn false_() -> (result: bool)
    ensures 
        result == false,
        forall|b: bool| (result || b) == b,
        forall|b: bool| (result && b) == false,
        result == !true","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,-1
VT0183,verus,numpy_triple,indexing_slicing_ndindex,,"Generate N-dimensional indices for an array with given shape.
Returns a vector of index tuples, where each tuple represents a valid
N-dimensional index for an array with the specified dimensions.

For a 2D array with shape (m, n), this generates all index pairs
(i, j) where 0 ≤ i < m and 0 ≤ j < n, in C-order (row-major).

Example: For shape (2, 3), generates [(0,0), (0,1), (0,2), (1,0), (1,1), (1,2)]","use vstd::prelude::*;

verus! {",,"fn ndindex(shape: (usize, usize)) -> (indices: Vec<(usize, usize)>)
    requires shape.0 > 0 && shape.1 > 0,
    ensures 
        indices.len() == shape.0 * shape.1,
        forall|k: int| 0 <= k < indices.len() ==> {
            let (i, j) = indices[k];
            i < shape.0 && j < shape.1
        },
        forall|i: usize, j: usize| i < shape.0 && j < shape.1 ==> {
            exists|k: int| 0 <= k < indices.len() && indices[k] == (i, j)
        },
        forall|k: int| 0 <= k < indices.len() ==> {
            let (i, j) = indices[k];
            k == i * shape.1 + j
        }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,-1
VT0210,verus,numpy_triple,io_operations_load,,"numpy.load: Load arrays or pickled objects from .npy, .npz or pickled files.

Loads array data from a binary file. This operation reads serialized array data
from disk storage and reconstructs it as a Vector. The function supports:
- .npy files: Single array format
- .npz files: Archive format with multiple arrays (simplified to single array here)
- Pickled files: Python pickle format (when allow_pickle is True)

The file parameter represents the path to the file to be loaded.
For security reasons, pickled files should be avoided unless explicitly allowed.

Memory mapping is not considered in this simplified specification.

Specification: numpy.load returns a vector containing the data from the file.

This specification captures the essential properties of the load operation:

1. Data Preservation: The loaded vector contains exactly the data that was stored
2. Size Consistency: The vector length matches the stored array dimensions
3. Type Compatibility: Data is correctly interpreted as Float values
4. Security Constraint: Object arrays are only loaded when explicitly allowed

Mathematical Properties:
- Idempotence: Loading the same file multiple times yields identical results
- Determinism: For a given file, load always returns the same vector
- Injectivity: Different valid files produce different vectors (when they differ)

Precondition: The file exists, is readable, and contains valid array data
Postcondition: The returned vector faithfully represents the stored data","use vstd::prelude::*;

verus! {",,"spec fn load_ghost(file: String, allow_pickle: bool, n: nat) -> Vec<f64>;

fn load(file: String, allow_pickle: bool, n: usize) -> (result: Vec<f64>)
    ensures 
        result.len() == n,
        forall|i: int| 0 <= i < n ==> exists|stored_val: f64| result[i] == stored_val,
        forall|second_load: Vec<f64>| (#[trigger] second_load == load_ghost(file, allow_pickle, n as nat)) ==>
            forall|i: int| 0 <= i < n ==> result[i] == second_load[i]","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,-1
VT0624,verus,numpy_triple,strings_join,,"Return a string which is the concatenation of the strings in the sequence seq.

numpy.strings.join: Return a string which is the concatenation of the strings in the sequence seq.

For each pair of separator and sequence, join the elements of the sequence using the separator.
This function operates element-wise on vectors, where each element of the result is obtained
by joining the corresponding elements of the sequence vector using the corresponding separator.

The function treats each string in the sequence as a sequence of characters, and joins them
with the separator string. For example, join('-', 'abc') produces 'a-b-c'.

From NumPy documentation:
- Parameters: sep (array_like) - Separator string(s), seq (array_like) - Sequence(s) to join
- Returns: out (ndarray) - Output array with joined strings
- Examples: join('-', 'osd') → 'o-s-d', join(['-', '.'], ['ghc', 'osd']) → ['g-h-c', 'o.s.d']

Mathematical Properties:
1. Element-wise operation: result[i] = join(sep[i], seq[i])
2. Character separation: joins individual characters of each string in seq
3. Empty separator handling: join('', s) = s (no separation)
4. Empty sequence handling: join(sep, '') = '' (empty result)
5. Single character sequences: join(sep, 'a') = 'a' (no separator needed)

/* Core correctness property */

/* Length property for non-trivial cases */

/* Empty string preservation */

/* Single character preservation */

/* Non-empty result for non-empty input */","use vstd::prelude::*;

verus! {",,"spec fn join_chars(separator: Seq<char>, chars: Seq<char>) -> Seq<char>
    decreases chars.len()
{
    if chars.len() <= 1 {
        chars
    } else {
        chars.take(1) + separator + join_chars(separator, chars.skip(1))
    }
}

spec fn string_to_chars(s: Seq<char>) -> Seq<char> {
    s
}

spec fn chars_to_string_len(chars: Seq<char>) -> nat {
    chars.len()
}

fn join(sep: Vec<String>, seq: Vec<String>) -> (result: Vec<String>)
    requires sep.len() == seq.len(),
    ensures
        result.len() == sep.len(),
        forall|i: int| 0 <= i < result.len() ==> {
            let s = seq[i]@;
            let separator = sep[i]@;

            (s.len() <= 1 ==> result[i]@ == s) &&
            (s.len() > 1 ==> result[i]@ == join_chars(separator, s)) &&

            (s.len() > 1 ==> result[i]@.len() == s.len() + (s.len() - 1) * separator.len()) &&

            (s.len() == 0 ==> result[i]@.len() == 0) &&

            (s.len() == 1 ==> result[i]@ == s) &&

            (s.len() > 0 ==> result[i]@.len() > 0)
        }","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,-1
VV0015,verus,verina,verina_advanced_16_task,,"Implement the insertion sort algorithm in Verus. The function takes a single Vec of integers
as input and returns a new Vec that contains the same integers in ascending order.

Implementation must follow a standard insertion sort approach, placing each element into its correct position.
The resulting Vec must be sorted in ascending order.
The returned Vec must be a permutation of the input Vec (i.e., contain exactly the same elements).

Input: A single Vec of integers, denoted as xs.
Output: A Vec of integers, sorted in ascending order.

Example:
Input:  [3, 1, 4, 2]
Output: [1, 2, 3, 4]

/* Helper function to check if a Vec is sorted */

/* Helper function to check if two Vecs are multiset equivalent */

/* This would typically involve checking that both vectors contain
       the same elements with the same multiplicities */

/* Placeholder - actual implementation would be more complex */","use vstd::prelude::*;

verus! {

spec fn sorted(v: Vec<i32>) -> bool {
    forall|i: int, j: int| 0 <= i < j < v.len() ==> v[i] <= v[j]
}

spec fn multiset_equivalent(v1: Vec<i32>, v2: Vec<i32>) -> bool {
    forall|elem: i32| count(v1, elem) == count(v2, elem)
}

spec fn count(v: Vec<i32>, elem: i32) -> nat {
    v.to_seq().filter(|x| *x == elem).len()
}",,"fn insertion_sort(xs: Vec<i32>) -> (result: Vec<i32>)
    ensures
        sorted(result),
        multiset_equivalent(xs, result),","{
    assume(false);
    unreached()
}","}
fn main() {}",0,,-1,-1,-1,,-1
