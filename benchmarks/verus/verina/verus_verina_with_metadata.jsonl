{"id":"verina_advanced_10_task","vc-description":"This task requires writing a Verus method that decomposes a natural number `n` into its prime factorization components based on a user-provided list of primes. Specifically, it calculates the exponents for each prime in the factorization such that:\n\\[ n = \\prod p^e \\]\nIn other words, it determines the exponent e for each prime p.\n\n-----Input-----\nThe input consists of a natural number n, and a list of prime numbers. The input n is obtained by multiplying together any powers of the prime numbers from the provided list.\nn: The natural number to be factorized.\nprimes: A list of primes to decompose n into.\n\n-----Output-----\nThe output is `Vec<(nat, nat)>`:\nReturn a list of pair/Cartesian product of two natural numbers (p, e), where p is the prime and e is the exponent of p in the factorization. Each prime in the output must be from the input list, and every prime in the input list must appear in the output.","vc-preamble":"use vstd::prelude::*;\nuse vstd::arithmetic::power::pow;\n\nverus! {\n\nspec fn is_prime(n: nat) -> bool {\n    arbitrary()\n}\n\nspec fn spec_fold(pairs: Seq<(nat, nat)>, acc: int) -> int\n    decreases pairs.len()\n{\n    if pairs.len() == 0 {\n        acc\n    } else {\n        let (p, e) = pairs[0];\n        spec_fold(pairs.subrange(1, pairs.len() as int), acc * pow(p as int, e as nat))\n    }\n}","vc-helpers":"","vc-spec":"fn find_exponents(n: nat, primes: Vec<nat>) -> (result: Vec<(nat, nat)>)\n    requires\n        forall|i: int| 0 <= i < primes.len() ==> is_prime(primes[i]),\n    ensures\n        n as int == spec_fold(result@, 1int),\n        forall|i: int| 0 <= i < result.len() ==> (#[trigger] primes@.contains(result[i].0)),\n        forall|p: nat| (#[trigger] primes@.contains(p)) ==> \n            exists|j: int| 0 <= j < result.len() && result[j].0 == p,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"e3c6a6104e63ae2987558844230bd9abf7059c9233418df7d4abc9bbda8b4f22","vc_description_hash":"e27c85f6cab386741932977887aeba257d1a6fe3141127d688f0c59da106c6f5","vc_spec_hash":"63c4796ebd2b5330964f8b4cd71c3de6c13e216b62ab978f1208564ba60c4c47","vc_preamble_hash":"83c3c49d0337a43f5e9fb28d513c8913a404e95fcdef89a0658ffe9ea4e39236","description_normalized_hash":"58f88172f80aaa891f366346396a8ce52419c205be1d7ba7d858bf3e9d95c066","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn find_exponents(n: nat, primes: Vec<nat>) -> (result: Vec<(nat, nat)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_advanced_11_task","vc-description":"This task requires writing a Verus method that finds the **majority element** in a list of integers. A majority element is defined as an element that appears **strictly more than half** the number of times in the list.\n\nIf such an element exists, the method should return that element. Otherwise, it should return `-1`. The implementation must ensure that the result is either the majority element (if one exists) or `-1` (when no such element appears more than \u230an/2\u230b times).\n\n**Input**\nThe input consists of a list of integers:\n- lst: A list of integers, which may include duplicates and negative numbers. The list may also be empty.\n\n**Output**\nThe output is a single integer:\n- If a majority element exists in the input list, return that element.\n- If no majority element exists, return `-1`.","vc-preamble":"use vstd::prelude::*;\n\nverus! {\n\nspec fn count_occurrences(x: i32, lst: Seq<i32>) -> nat {\n    lst.filter(|y: i32| y == x).len()\n}","vc-helpers":"","vc-spec":"fn find_majority_element(lst: &Vec<i32>) -> (result: i32)\n    ensures ({\n        let lst_seq = lst@;\n        let n = lst_seq.len();\n        let majority = count_occurrences(result, lst_seq) > n / 2 && \n                      forall|x: i32| count_occurrences(x, lst_seq) <= n / 2 || x == result;\n        (result == -1 ==> forall|x: i32| count_occurrences(x, lst_seq) <= n / 2) &&\n        (result != -1 ==> majority)\n    })","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"4fbc96fb85840c01be718952b9ba6a5e57e78132430019cad0fe46a548886086","vc_description_hash":"0a0156f86f48ea42b4aa12a12d3039c04ce0dc699b863c6b91f7840e8ba028f1","vc_spec_hash":"2a09ae0b0e9497df75c65aac0737ec3f9e4b17deff9a459a07cac0b860972a07","vc_preamble_hash":"652fabb24d8d22159737895dc241ac819df554502184b47198c1115c2b17e545","description_normalized_hash":"0ae6041415d1b50a70d4224eeed008671d42977aea08928bab6e85672726e74a","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn find_majority_element(lst: &Vec<i32>) -> (result: i32)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_advanced_12_task","vc-description":"Write a Verus function that returns the first duplicate integer found in a list. The function should return the value of the first duplicate it encounters, scanning from left to right. If no duplicates exist, return -1.\n\nInput: lst: A sequence of integers.\nOutput: An integer representing the first duplicated value if any exists, otherwise -1.\n\n/* if result = -1, then lst does not contain any duplicates */\n\n/* if result is not -1, then it is the first duplicate in lst */","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn first_duplicate(lst: &Seq<i32>) -> (result: i32)\n    ensures\n\n        (result == -1 ==> forall|i: int, j: int| 0 <= i < j < lst.len() ==> lst[i] != lst[j]) &&\n\n        (result != -1 ==> \n            exists|i: int, j: int| 0 <= i < j < lst.len() && lst[i] == lst[j] && lst[i] == result &&\n            forall|k: int, l: int| 0 <= k < l < lst.len() && lst[k] == lst[l] && l <= i ==> k >= i\n        ),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"9436f43395bdbfb310b270c8a7cb4780db0fd10e41b901dcb960f1004d76ed30","vc_description_hash":"3e39c4b25ca255e6efaebe2242f1ce341b28773b1af7b0236d95e07e665fbb87","vc_spec_hash":"47a5aba34ac29a91e33c1066f979b758097dc51894792124a6f8c90db74190b0","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"abe544efb6862f8782d7ef544e298cd1312855af809d360d7e4ecada2995540f","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn first_duplicate(lst: &Seq<i32>) -> (result: i32)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_advanced_13_task","vc-description":"This task requires writing a Verus method that determines whether there are any intersections between chords on a circle. The method should return true if at least one pair of chords intersects, and false otherwise.\n\nA chord is defined as a line segment connecting two distinct points on a circle. Two chords intersect if they cross each other inside the circle. The points are numbered from 1 to 2N in a clockwise direction, where N is the number of chords.\n\nConstraints\n\n- 2 \u2264 N \u2264 2\u00d710^5\n- 1 \u2264 A_i,B_i \u2264 2N\n- A_1,\u2026,A_N,B_1,\u2026,B_N are all distinct\n- All input values are integers\n\nInput:\nThe input consists of two parameters:\nN: A natural number representing the number of chords (2 \u2264 N \u2264 2\u00d710^5).\nchords: A list of N pairs of natural numbers, where each pair represents the endpoints of a chord. All endpoint values are distinct and range from 1 to 2N.\n\nOutput:\nThe output is a boolean value:\n- Returns true if there exists at least one pair of intersecting chords.\n- Returns false if no chords intersect.\n\n/* All endpoints are distinct */","vc-preamble":"use vstd::prelude::*;\n\nverus! {\n\nspec fn chord_intersects(chord1: &Vec<usize>, chord2: &Vec<usize>) -> bool {\n    let a1 = if chord1[0] < chord1[1] { chord1[0] } else { chord1[1] };\n    let b1 = if chord1[0] > chord1[1] { chord1[0] } else { chord1[1] };\n    let a2 = if chord2[0] < chord2[1] { chord2[0] } else { chord2[1] };\n    let b2 = if chord2[0] > chord2[1] { chord2[0] } else { chord2[1] };\n    (a1 < a2 && a2 < b1 && b1 < b2) || (a2 < a1 && a1 < b2 && b2 < b1)\n}","vc-helpers":"","vc-spec":"fn has_chord_intersection(n: usize, chords: &Vec<Vec<usize>>) -> (result: bool)\n    requires\n        n >= 2,\n        chords.len() == n,\n        forall|i: int| 0 <= i < chords.len() ==> (\n            chords[i].len() == 2 &&\n            chords[i][0] >= 1 && chords[i][0] <= 2 * n &&\n            chords[i][1] >= 1 && chords[i][1] <= 2 * n\n        ),\n\n        forall|i: int, j: int, k: int, l: int| \n            0 <= i < chords.len() && 0 <= j < chords.len() && \n            0 <= k < 2 && 0 <= l < 2 && \n            (i != j || k != l) ==> chords[i][k] != chords[j][l],\n    ensures\n        result == exists|i: int, j: int| \n            0 <= i < chords.len() && 0 <= j < chords.len() && i != j &&\n            #[trigger] chord_intersects(&chords[i], &chords[j]),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"d0fd35d089d7fc708d51377f0c77effed11beb3f009e6286673e6c2729643376","vc_description_hash":"b987c3d10f53dde412da518e92d272c5aa3609215fba0450ba9bf29ef6c04c7e","vc_spec_hash":"5effc2772ec990ad273af38b838e8e372b30f8b38131d3ffe6176de4d035a09f","vc_preamble_hash":"37303e740ba44a17e6b4615d84736c26bd3f5954307d73b570019cc1011146ea","description_normalized_hash":"e6e00b04026e5bfa66db14d19a2adc197c056e6e7ba8eaae23d2da353a491ff8","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn has_chord_intersection(n: usize, chords: &Vec<Vec<usize>>) -> (result: bool)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_advanced_14_task","vc-description":"This task requires writing a Verus method that determines whether a natural number is a power of four. The method should return a boolean value that indicates whether the given natural number is a power of four. An integer n is a power of four, if there exists a natural number x such that n = 4^x.\n\n-----Input-----\nThe input consists of one natural number:\nn: A natural number.\n\n-----Output-----\nThe output is a boolean value:\nReturn a boolean value that indicates whether the given natural number is a power of four. Return \"true\" if it is a power of four. Otherwise, return \"false\".","vc-preamble":"use vstd::prelude::*;\nuse vstd::arithmetic::power::pow;\n\nverus! {","vc-helpers":"","vc-spec":"fn if_power_of_four(n: nat) -> (result: bool)\n    ensures result <==> (exists|m: nat| n == pow(4, m)),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"a842ba93c3f0a3250b0d26cc792261f92363a52993853266daba7c40a06bce8e","vc_description_hash":"ead3de8acd9048b01720e05f12cb6515cc82a90bde8e503896d7da3366f1fecf","vc_spec_hash":"b3d40c934c2e9c384cc066bb773fae3ce1742286275aa85825eb19cdfb545ce7","vc_preamble_hash":"6fbc8ec5cfc064bd8d1ae92a43ae12dc71980e9b37a26b5c47873b0dbe50a3dc","description_normalized_hash":"0bc7921523b446b339ae9e4c857b678c3264bba2b3fd2ad425c01ecbfc61ad52","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn if_power_of_four(n: nat) -> (result: bool)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_advanced_15_task","vc-description":"Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k]. If no such indices exist, return false.\n\n-----Input-----\nThe input consists of a single list:\nnums: A list of integers.\n\n-----Output-----\nThe output is a boolean:\nReturns true if there exists a triplet (i, j, k) where i < j < k and nums[i] < nums[j] < nums[k]; otherwise, returns false.\n\n/*\n    -- Invalid Inputs\n    []\n    -- Tests\n    [\n        {\n            \"input\": {\n                \"nums\": \"[1, 2, 3]\"\n            },\n            \"expected\": true,\n            \"unexpected\": [\n                false\n            ]\n        },\n        {\n            \"input\": {\n                \"nums\": \"[5, 4, 3, 2, 1]\"\n            },\n            \"expected\": false,\n            \"unexpected\": [\n                true\n            ]\n        },\n        {\n            \"input\": {\n                \"nums\": \"[2, 1, 5, 0, 4, 6]\"\n            },\n            \"expected\": true,\n            \"unexpected\": [\n                false\n            ]\n        },\n        {\n            \"input\": {\n                \"nums\": \"[1, 5, 0, 4, 1, 3]\"\n            },\n            \"expected\": true,\n            \"unexpected\": [\n                false\n            ]\n        },\n        {\n            \"input\": {\n                \"nums\": \"[5, 4, 3]\"\n            },\n            \"expected\": false,\n            \"unexpected\": [\n                true\n            ]\n        },\n        {\n            \"input\": {\n                \"nums\": \"[]\"\n            },\n            \"expected\": false,\n            \"unexpected\": [\n                true\n            ]\n        }\n    ]\n    */","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn increasing_triplet(nums: &Vec<i32>) -> (result: bool)\n    ensures\n        result ==> exists|i: int, j: int, k: int| \n            0 <= i < j && j < k < nums.len() && \n            nums[i] < nums[j] && nums[j] < nums[k],\n        !result ==> forall|i: int, j: int, k: int| \n            0 <= i < j && j < k < nums.len() ==> \n            !(nums[i] < nums[j] && nums[j] < nums[k]),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"50d8112952f2006d901701045652c8ce7c68f8fe59986ba14657f234163a9675","vc_description_hash":"1cdd93cbea03df4cfa61aa979a3cbc6569a8bc3bf29717dc262cee0321fb07e5","vc_spec_hash":"6fce88fa61d1888fe241d5222ec9f739b9dcb8f324673b92dcf0320ad7272fca","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"7df0e744473a9a58fea21aac30e7aa9c91774ea27d376e20ab3e978ed26013d9","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn increasing_triplet(nums: &Vec<i32>) -> (result: bool)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_advanced_16_task","vc-description":"Implement the insertion sort algorithm in Verus. The function takes a single Vec of integers\nas input and returns a new Vec that contains the same integers in ascending order.\n\nImplementation must follow a standard insertion sort approach, placing each element into its correct position.\nThe resulting Vec must be sorted in ascending order.\nThe returned Vec must be a permutation of the input Vec (i.e., contain exactly the same elements).\n\nInput: A single Vec of integers, denoted as xs.\nOutput: A Vec of integers, sorted in ascending order.\n\nExample:\nInput:  [3, 1, 4, 2]\nOutput: [1, 2, 3, 4]\n\n/* Helper function to check if a Vec is sorted */\n\n/* Helper function to check if two Vecs are multiset equivalent */\n\n/* This would typically involve checking that both vectors contain\n       the same elements with the same multiplicities */\n\n/* Placeholder - actual implementation would be more complex */","vc-preamble":"use vstd::prelude::*;\n\nverus! {\n\nspec fn sorted(v: Vec<i32>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < v.len() ==> v[i] <= v[j]\n}\n\nspec fn multiset_equivalent(v1: Vec<i32>, v2: Vec<i32>) -> bool {\n    forall|elem: i32| count(v1, elem) == count(v2, elem)\n}\n\nspec fn count(v: Vec<i32>, elem: i32) -> nat {\n    v.to_seq().filter(|x| *x == elem).len()\n}","vc-helpers":"","vc-spec":"fn insertion_sort(xs: Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        sorted(result),\n        multiset_equivalent(xs, result),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"21042132270f4a10a411bdfac6d7c801319ffb9cb68e146ad41bace0a692e2e8","vc_description_hash":"7e1836521345ee4c758492bfa0c0ced8357b46aa3aacbc780c32930b7391027e","vc_spec_hash":"a195e9f2bd9ff4190df35770604ea81169372fc917fb90337e84b2591801063f","vc_preamble_hash":"4d7c3366b41a8b377ca15f6657f61ccae775dc93533bf7d2a5907f83bf5101bb","description_normalized_hash":"5d8dc2ec239eb705c422d4bf0221026d82a62ddeaa3d0b447024ca9f06d1ef53","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn insertion_sort(xs: Vec<i32>) -> (result: Vec<i32>)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_advanced_17_task","vc-description":"This task requires implementing the insertion sort algorithm to sort a list of integers in ascending order. The function should take a list of integers as input and return a new list containing the same elements sorted in non-decreasing order.\n\n-----Input-----\nThe input is:\n\nl: A list of integers to be sorted.\n\n-----Output-----\nThe output is:\n\nA list of integers that is sorted in non-decreasing order and is a permutation of the input list.\n\n/* The result is sorted in non-decreasing order */\n\n/* The result is a permutation of the input */","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn insertion_sort(l: Vec<i32>) -> (result: Vec<i32>)\n    ensures\n\n        forall|i: int, j: int| 0 <= i < j < result.len() ==> result[i] <= result[j],\n\n        result@.to_multiset() == l@.to_multiset(),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"69d75f265378303f28e4d8dfd564a8175ad0a79f217c2a731049cad6fdd1a58c","vc_description_hash":"d3121f1db42067d4a4d2e76f2adf21e0d65b9bc3695db3f8d44a242af69f715e","vc_spec_hash":"f67b6e5b2a2089318c3c79f772fe806df24f0a7b528ce84c9177e817befcffbd","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"7dd3e647070f522b4ce084116985f50b0f36c5f21fc45950fc6110ea5d402819","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn insertion_sort(l: Vec<i32>) -> (result: Vec<i32>)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_advanced_18_task","vc-description":"This task requires writing a Verus method that determines whether a given number `n` is an Armstrong number (also known as a Narcissistic number). An Armstrong number is a number that is equal to the sum of its own digits raised to the power of the number of digits.\n\nInput: The input consists of one natural number:\n- `n: u32`: The number to check if it satisfies the Armstrong property.\n\nOutput: The output is a boolean value:\n- `bool`: Return `true` if `n` is an Armstrong number, otherwise return `false`.\n\n// let n = 153;\n\n// println!(\"Is {} an Armstrong number? {}\", n, is_armstrong(n));\n\n// \n\n// let n = 9474;\n\n// println!(\"Is {} an Armstrong number? {}\", n, is_armstrong(n));\n\n// \n\n// let n = 9475;\n\n// println!(\"Is {} an Armstrong number? {}\", n, is_armstrong(n));","vc-preamble":"use vstd::prelude::*;\n\nverus! {\n\nspec fn count_digits(n: nat) -> nat\n    decreases n\n{\n    if n == 0 { 1 } else if n < 10 { 1 } else { 1 + count_digits(n / 10) }\n}\n\nspec fn pow_nat(base: nat, exp: nat) -> nat\n    decreases exp\n{\n    if exp == 0 { \n        1 \n    } else { \n        base * pow_nat(base, (exp - 1) as nat) \n    }\n}\n\nspec fn sum_powers(n: nat, k: nat) -> nat\n    decreases n\n{\n    if n == 0 { 0 } else { pow_nat(n % 10, k) + sum_powers(n / 10, k) }\n}","vc-helpers":"","vc-spec":"fn is_armstrong(n: u32) -> (result: bool)\n    ensures \n        result == (n as nat == sum_powers(n as nat, count_digits(n as nat))),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"88b749cb218e3926f19619dd165e55b864846a0c4a6e23d2e10ec25a66295a63","vc_description_hash":"28afe08a28a6adfa9ff3927ffbe65810fd855850149e4bee45b1ec28e0499dd3","vc_spec_hash":"1bd080b9d0961ff420cff362d3205776de70894e6d319930b513c2c33c6b6694","vc_preamble_hash":"8d11b6e606d4d20ec2eab3ea5b5962d4bbcf9433051f8bead054a44b7ae80b9a","description_normalized_hash":"bf63f98d9161ece22bd4c0a2e6dec3c311b24d22dad7e422c651c9af5436bceb","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn is_armstrong(n: u32) -> (result: bool)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_advanced_19_task","vc-description":"This task requires writing a Verus method that checks whether a given string is a palindrome. A palindrome is a string that reads the same forwards and backwards. The function should ignore whitespace, punctuation, and capitalization when checking for palindromes.\n\n-----Input-----\nThe input consists of:\ns: A string to be checked.\n\n-----Output-----\nThe output is a boolean:\nReturns true if the input string is a palindrome when non-alphabetic characters are removed and letters are treated case-insensitively, and false otherwise.\n\n// Check if a character is an uppercase alphabet letter\n\n// Check if a character is a lowercase alphabet letter  \n\n// Determine if a character is alphabetic\n\n// Convert a single character to lowercase (simplified for Verus)\n\n// Simplified: assume conversion works for spec purposes\n\n// This would be the lowercase version in practice\n\n// Normalize a character: keep only lowercase letters\n\n// Normalize a string into a sequence of lowercase alphabetic characters","vc-preamble":"use vstd::prelude::*;\n\nverus! {\n\nspec fn is_upper_alpha(c: char) -> bool {\n    'A' <= c && c <= 'Z'\n}\n\nspec fn is_lower_alpha(c: char) -> bool {\n    'a' <= c && c <= 'z'\n}\n\nspec fn is_alpha(c: char) -> bool {\n    is_upper_alpha(c) || is_lower_alpha(c)\n}\n\nspec fn to_lower(c: char) -> char {\n    if is_upper_alpha(c) {\n\n        c\n    } else {\n        c\n    }\n}\n\nspec fn normalize_char(c: char) -> Option<char> {\n    if is_alpha(c) {\n        Some(to_lower(c))\n    } else {\n        None\n    }\n}\n\nspec fn normalize_string(s: &str) -> Seq<char> {\n    s@.fold_left(Seq::empty(), |acc: Seq<char>, c: char|\n        match normalize_char(c) {\n            Some(c_norm) => acc.push(c_norm),\n            None => acc,\n        }\n    )\n}","vc-helpers":"","vc-spec":"fn is_clean_palindrome(s: &str) -> (result: bool)\n    ensures \n        result == (normalize_string(s) == normalize_string(s).reverse()),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"e6f16b96a2d58470e57f729c735f1b9356c06932089cf1f1bb6e325de5d63e1c","vc_description_hash":"9b0fa8929b0a1abda0c927a8bae4e631c20db3af9a9cc36bb74e49c743f7ff5b","vc_spec_hash":"202a65b5f4bd3ee1f6229709eb756c88bb6d208aa90f09cceda15f64f10a9c3f","vc_preamble_hash":"04abe17fb85dce170db8287afe3a619ec2a87d18f286834c66b0bc8cbba8447d","description_normalized_hash":"d9cdf6d84f4765dbc023a7b4aff73cf5f1d30112204e88b1f9cf4ad228076c66","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn is_clean_palindrome(s: &str) -> (result: bool)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_advanced_1_task","vc-description":"This task requires writing a Verus function that finds the single number in a non-empty list of integers, where every element appears exactly twice except for one element that appears only once. The function should return the integer that appears only once.\n\nInput: The input is a non-empty list of integers where each integer appears exactly twice except for one element that appears only once.\n\nOutput: The output is a single integer - the unique integer that appears exactly once in the list.\n\n// Helper function to count occurrences of an element in a sequence\n\n// Helper function to filter elements equal to x","vc-preamble":"use vstd::prelude::*;\n\nverus! {\n\nspec fn count_occurrences(nums: Seq<i32>, x: i32) -> nat {\n    nums.filter(|elem: i32| elem == x).len()\n}\n\nspec fn filter_equal(nums: Seq<i32>, x: i32) -> Seq<i32> {\n    nums.filter(|elem: i32| elem == x)\n}","vc-helpers":"","vc-spec":"fn find_single_number(nums: &Vec<i32>) -> (result: i32)\n    requires \n        nums.len() > 0,\n        exists|unique_elem: i32| count_occurrences(nums@, unique_elem) == 1,\n        forall|elem: i32| nums@.contains(elem) ==> (count_occurrences(nums@, elem) == 1 || count_occurrences(nums@, elem) == 2),\n    ensures\n        count_occurrences(nums@, result) == 1,\n        forall|x: i32| nums@.contains(x) ==> (x == result || count_occurrences(nums@, x) == 2),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"6d65c289fe84da1a08bdd511726a0d169fd9097ad528a7a1966be78e33ba93fa","vc_description_hash":"e6d153cbefd13de9e8dd05783b86e47fad54b7d15cfacb8d5aaed7b10cf07dfa","vc_spec_hash":"af9398b4451845eaeda962718d11b85bdb6d718beed30bcfa88177ea544fd760","vc_preamble_hash":"ae7dac726dcb1671e13900ca56fe7651444e63127d0d610e3255e30471a0109e","description_normalized_hash":"fd1e741b71ac519bd9430ba719511d5b4ac63adcce008e36d5eabfc29974a539","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn find_single_number(nums: &Vec<i32>) -> (result: i32)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_advanced_30_task","vc-description":"This task requires writing a Verus function that computes the length of the longest strictly increasing contiguous subarray in a list of integers. A subarray is a sequence of consecutive elements, and it is strictly increasing if each element is greater than the previous one.\n\nThe function should correctly handle empty lists, lists with all equal elements, and long stretches of increasing numbers.\n\nInput:\nThe input consists of a single list:\nnums: A list of integers.\n\nOutput:\nThe output is a natural number:\nReturns the length of the longest strictly increasing contiguous subarray. If the list is empty, the function should return 0.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn longest_increasing_streak(nums: &Vec<i32>) -> (result: usize)\n    ensures\n        (nums.len() == 0 ==> result == 0),\n        result <= nums.len(),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"6a29573df1d911f9d49e88d17a6ed21ce5f1d210eb4f57adba58d50933f37409","vc_description_hash":"8d89cfba84580c71048ccb770041d3e5ed770af5fe12f938433d59511c9538ed","vc_spec_hash":"d676b798709b2ab301e09c4041de06a04ee8c24f925d0b3bb97863cc74eefb58","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"2fa00898f132c1afdaa3f2a083727774f66ddc325e74423f6ffe4db3ed41a4a7","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn longest_increasing_streak(nums: &Vec<i32>) -> (result: usize)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_advanced_31_task","vc-description":"This task requires writing a Lean 4 function that finds the length of the longest strictly increasing subsequence in a list of integers. A subsequence is any sequence that can be derived from the list by deleting zero or more elements without changing the order of the remaining elements. The function must return the length of the longest possible such sequence.\n\n-----Input-----\nThe input consists of a single value:\nxs: A list of integers of type `List Int`.\n\n-----Output-----\nThe output is a natural number:\nReturns the length of the longest strictly increasing subsequence found in the list.\n\n/* Helper functions for generating subsequences and checking increasing property */\n\n/* The result is the length of some strictly increasing subsequence */\n\n/* No strictly increasing subsequence is longer than result */","vc-preamble":"use vstd::prelude::*;\n\nverus! {\n\nspec fn is_subsequence_of(subseq: Seq<i32>, seq: Seq<i32>) -> bool {\n    exists|indices: Seq<int>| \n        indices.len() == subseq.len() &&\n        #[trigger] indices.len() >= 0 &&\n        (forall|i: int| 0 <= i < indices.len() ==> #[trigger] indices[i] >= 0 && indices[i] < seq.len()) &&\n        (forall|i: int| 0 <= i < indices.len() - 1 ==> #[trigger] indices[i] < indices[i + 1]) &&\n        (forall|i: int| 0 <= i < subseq.len() ==> #[trigger] subseq[i] == seq[indices[i]])\n}\n\nspec fn is_strictly_increasing(seq: Seq<i32>) -> bool {\n    forall|i: int| 0 <= i < seq.len() - 1 ==> #[trigger] seq[i] < seq[i + 1]\n}","vc-helpers":"","vc-spec":"fn longest_increasing_subseq_length(xs: &Vec<i32>) -> (result: usize)\n    ensures\n\n        exists|subseq: Seq<i32>| \n            is_subsequence_of(subseq, xs@) && \n            is_strictly_increasing(subseq) && \n            subseq.len() == result,\n\n        forall|subseq: Seq<i32>| \n            (is_subsequence_of(subseq, xs@) && is_strictly_increasing(subseq)) \n            ==> subseq.len() <= result,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"461d23baa4317e9b17f8bc8e6581cd6e2164625c9e0aac21fdda5e9b39d211f6","vc_description_hash":"668fff6464674925d91e84ec762ccc2f8a4271b27ab26566579adddf94027a54","vc_spec_hash":"6a4cefe880055b977169936bad3504c690eb54a4f7768008a730c104b85d3cd0","vc_preamble_hash":"f4065b1790a17aba21f4812798c039eb6f3554081e075c0cbc78034aec05a04c","description_normalized_hash":"4e77df18655b74ee9e7100b33ce719316a7c901e34f260010ade4a6c01d5ca44","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn longest_increasing_subseq_length(xs: &Vec<i32>) -> (result: usize)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_advanced_32_task","vc-description":"This test implements a function in Verus that finds the length of the longest increasing subsequence in a list of integers. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. An increasing subsequence is one in which the elements are in strictly increasing order.\n\nInput: numbers: A list of integers.\n\nOutput: A natural number representing the length of the longest increasing subsequence in the input list. If the list is empty, the function returns 0.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn longest_increasing_subsequence(numbers: Vec<i32>) -> (result: usize)\n    ensures\n        result <= numbers.len(),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"bb0aa0176a41aff0a022876c6b72514878ed677ff90830e0524b62d9202b0c86","vc_description_hash":"386fae01ab98eaa509c4b485a4b427683d88e1764862ceb877b97b40d39b60b7","vc_spec_hash":"f559d4dc8c79e0eb3a775fbd12addfd8e7b31ab9231820affe176245802e8842","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"e4c3fef0c19c3e38c513cdb724d8a6d10b59a20a634ed1740fda0448c62af55c","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn longest_increasing_subsequence(numbers: Vec<i32>) -> (result: usize)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_advanced_33_task","vc-description":"This task requires implementing the \"Longest Increasing Subsequence\" problem in Verus.\nGiven a list of integers, the function should compute the length of the longest strictly increasing\nsubsequence. A subsequence is formed by deleting zero or more elements without changing the order.\nIf the list is empty, the function should return 0.\n\n-----Input-----\n- nums: A list of integers.\n\n-----Output-----\n- A natural number representing the length of the longest strictly increasing subsequence.\n- If there is no increasing subsequence, return 0.\n\n/* \n    -- Invalid Inputs\n    []\n    -- Tests\n    [\n        {\n            \"input\": {\n                \"nums\": \"[10, 9, 2, 5, 3, 7, 101, 18]\"\n            },\n            \"expected\": 4,\n            \"unexpected\": [\n                3,\n                5\n            ]\n        },\n        {\n            \"input\": {\n                \"nums\": \"[0, 1, 0, 3, 2, 3]\"\n            },\n            \"expected\": 4,\n            \"unexpected\": [\n                3\n            ]\n        },\n        {\n            \"input\": {\n                \"nums\": \"[7, 7, 7, 7, 7]\"\n            },\n            \"expected\": 1,\n            \"unexpected\": [\n                0,\n                2\n            ]\n        },\n        {\n            \"input\": {\n                \"nums\": \"[]\"\n            },\n            \"expected\": 0,\n            \"unexpected\": [\n                1\n            ]\n        },\n        {\n            \"input\": {\n                \"nums\": \"[4, 10, 4, 3, 8, 9]\"\n            },\n            \"expected\": 3,\n            \"unexpected\": [\n                2,\n                4\n            ]\n        }\n    ]\n    */","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn longest_increasing_subsequence(nums: Vec<i32>) -> (result: usize)\n    ensures\n        result >= 0,\n        nums.len() == 0 ==> result == 0,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"589bb99b6afc794f6c00f980c43c80539b70506ae24b2053ce0f7b9677e2dfa4","vc_description_hash":"af9849530af603c957eb6c006ba9ca2fa1d1887a922ba2721baa669888ba8c61","vc_spec_hash":"bfe84404a44d7c1469bb02f1274b815a5ba5ae947ec825b607e342bc0d0addfa","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"c39c084b0b16a7c16af89764b109e7e97bf6164f21fd60b3c8eecd2447e5bb7e","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn longest_increasing_subsequence(nums: Vec<i32>) -> (result: usize)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_advanced_34_task","vc-description":"This task requires writing a Verus method that finds the length of the longest strictly increasing subsequence from a given list of integers.\n\n-----Input-----\nThe input consists of a list of integers called nums\n\n-----Output-----\nThe output is an integer:\nReturns a number representing the length of the longest strictly increasing subsequence found in the input list.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn longest_increasing_subsequence(nums: &Vec<i32>) -> (result: i32)\n    ensures\n        result >= 0,\n        result <= nums.len() as i32,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"128c9ad8d192963879173288fdafce426ee16e7a561362ce229d3d461c416d94","vc_description_hash":"36dd36cb73b8b88dc2db4cc9e229507ed0c92b1a7bc887f45501985f910e522e","vc_spec_hash":"4c57c984db1f726f5a55e5df95122e0f47e0705553ffc3a03d139bd4e5085277","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"d9e2e855ac0236c4060853a0e7c3bd94c6e9c8330ca943ceac84ec1859a0495f","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn longest_increasing_subsequence(nums: &Vec<i32>) -> (result: i32)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_advanced_35_task","vc-description":"This task requires writing a Verus function that finds the majority element in a sequence of integers. The majority element is the element that appears more than \u230an/2\u230b times, where n is the sequence's length. You may assume that a majority element always exists in the input.\n\n-----Input-----\n- nums: A sequence of integers of length \u2265 1, containing a majority element.\n\n-----Output-----\n- An integer: the element that appears more than \u230an/2\u230b times.","vc-preamble":"use vstd::prelude::*;\n\nverus! {\n\nspec fn count_occurrences(nums: Seq<i32>, x: i32) -> nat \n    decreases nums.len()\n{\n    if nums.len() == 0 {\n        0\n    } else {\n        let first = nums[0];\n        let rest_count = count_occurrences(nums.subrange(1, nums.len() as int), x);\n        if first == x {\n            rest_count + 1\n        } else {\n            rest_count\n        }\n    }\n}","vc-helpers":"","vc-spec":"fn majority_element(nums: Seq<i32>) -> (result: i32)\n    requires \n        nums.len() > 0,\n        exists|x: i32| count_occurrences(nums, x) > nums.len() / 2,\n    ensures \n        count_occurrences(nums, result) > nums.len() / 2,\n        forall|x: i32| x != result ==> count_occurrences(nums, x) <= nums.len() / 2,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"fa5b754c649b7e2b75247e4129bf3ca95217f1146f10fddbb884645156e7e54d","vc_description_hash":"2bb4bf70d813179e39d6ae4d4fe2b91d7568daafd53b6f82fffe6b670dd76a44","vc_spec_hash":"536d85259cc02bc287b4b1eb8bba1296ab3511123537148b8db91f3e6ef46f8d","vc_preamble_hash":"5ecdd80da445d3a332f97f5c03e1a5ac705d5181aa856f0adaa855cd6d9544a3","description_normalized_hash":"a6e488d508fd64f94363a6cc5b2ea4d2008af046492a578b734b5236310a396d","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn majority_element(nums: Seq<i32>) -> (result: i32)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_advanced_36_task","vc-description":"This task requires writing a Verus method that finds the majority element in a list of natural numbers. The majority element is defined as the element that appears more than \u230an / 2\u230b times in the list, where n is the total number of elements.\n\nYou may assume that the input list always contains a majority element.\n\nInput: The input consists of one list:\nxs: A list of natural numbers (Vec<u64>), where a majority element is guaranteed to exist.\n\nOutput: The output is a natural number:\nReturns the element that appears more than half the time in the input list.","vc-preamble":"use vstd::prelude::*;\n\nverus! {\n\nspec fn count_matches(xs: Seq<u64>, x: u64) -> nat\n    decreases xs.len()\n{\n    if xs.len() == 0 {\n        0\n    } else {\n        let first_match: nat = if xs[0] == x { 1 } else { 0 };\n        first_match + count_matches(xs.skip(1), x)\n    }\n}","vc-helpers":"","vc-spec":"fn majority_element(xs: &Vec<u64>) -> (result: u64)\n    requires \n        xs.len() > 0,\n        exists|x: u64| count_matches(xs@, x) > xs.len() / 2,\n    ensures\n        count_matches(xs@, result) > xs.len() / 2,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"35cbae2005245388b38d6b804b14b556d3acbbe56951e4c70171cdb686564180","vc_description_hash":"ed7675bbc3be10972f1208cdc028923534f47eb4be6c653d8897324d84ff2aeb","vc_spec_hash":"acec35ed1936ff7d1c19afb612829ba8148010386fa62681dc6cc8554e4aea26","vc_preamble_hash":"0be539956af70d55dec8f7a90a30dc003b11e30c372f2113092bf74c3c1f0a80","description_normalized_hash":"10ea69853b161efb4e5b34d68f7ea26a4e74ed5ca92bf4a6a4fae7cba88421d2","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn majority_element(xs: &Vec<u64>) -> (result: u64)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_advanced_37_task","vc-description":"This task requires writing a Verus method that returns the majority element from a list of integers.\n\nThe majority element is the one that appears more than \u230an / 2\u230b times in the list, where n is the list's length. You may assume that a majority element always exists in the input.\n\nInput: nums: A list of integers (with at least one majority element).\n\nOutput: Returns the majority element \u2014 the value that appears more than \u230an / 2\u230b times.\n\n/*\n    // Invalid Inputs\n    []\n    // Tests\n    [\n        {\n            \"input\": {\n                \"nums\": \"[3, 2, 3]\"\n            },\n            \"expected\": 3,\n            \"unexpected\": [\n                2\n            ]\n        },\n        {\n            \"input\": {\n                \"nums\": \"[2, 2, 1, 1, 1, 2, 2]\"\n            },\n            \"expected\": 2,\n            \"unexpected\": [\n                1\n            ]\n        },\n        {\n            \"input\": {\n                \"nums\": \"[1]\"\n            },\n            \"expected\": 1,\n            \"unexpected\": [\n                0\n            ]\n        },\n        {\n            \"input\": {\n                \"nums\": \"[4, 4, 4, 4, 4, 2, 2, 3, 3]\"\n            },\n            \"expected\": 4,\n            \"unexpected\": [\n                2,\n                3\n            ]\n        },\n        {\n            \"input\": {\n                \"nums\": \"[9, 8, 9, 9, 7, 9, 6, 9, 9]\"\n            },\n            \"expected\": 9,\n            \"unexpected\": [\n                6,\n                7,\n                8\n            ]\n        },\n        {\n            \"input\": {\n                \"nums\": \"[0, 0, 0, 0, 1]\"\n            },\n            \"expected\": 0,\n            \"unexpected\": [\n                1\n            ]\n        },\n        {\n            \"input\": {\n                \"nums\": \"[100000, 100000, 100000, 100000, -100000]\"\n            },\n            \"expected\": 100000,\n            \"unexpected\": [\n                -100000\n            ]\n        },\n        {\n            \"input\": {\n                \"nums\": \"[-1, -1, -1, -1, 0, 1, 2]\"\n            },\n            \"expected\": -1,\n            \"unexpected\": [\n                0,\n                1,\n                2\n            ]\n        },\n        {\n            \"input\": {\n                \"nums\": \"[5, 5, 5, 5, 5, 5, 5]\"\n            },\n            \"expected\": 5,\n            \"unexpected\": [\n                0\n            ]\n        },\n        {\n            \"input\": {\n                \"nums\": \"[1, 2, 3, 3, 3, 3, 3]\"\n            },\n            \"expected\": 3,\n            \"unexpected\": [\n                1,\n                2\n            ]\n        }\n    ]\n    */","vc-preamble":"use vstd::prelude::*;\n\nverus! {\n\nspec fn count_occurrences(nums: Seq<i32>, value: i32) -> nat {\n    nums.filter(|x: i32| x == value).len()\n}","vc-helpers":"","vc-spec":"fn majority_element(nums: &Vec<i32>) -> (result: i32)\n    requires nums.len() > 0,\n    ensures ({\n        let nums_seq = nums@;\n        let n = nums_seq.len();\n        count_occurrences(nums_seq, result) > n / 2 &&\n        forall|x: i32| x == result || count_occurrences(nums_seq, x) <= n / 2\n    }),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"9b49ebbcac39a74f01bd7773b5935c1b64c080713e84acc93033e9247ea65de2","vc_description_hash":"65840c84251e63d3124bbff2f4350b5b749589975999d6687f55770c4bfaa5a5","vc_spec_hash":"8a876f368ab3dceedc7832737dc209ce0931ecaae2420e89610c5cfc06ebb322","vc_preamble_hash":"78e5995dd3dd76c47bd0869dc63be7f00af245efa0966510f25ef551de061506","description_normalized_hash":"4d617aa18107fd4f02fc3f126c1cd2b27851c637d75696060d1d736d4898f991","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn majority_element(nums: &Vec<i32>) -> (result: i32)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_advanced_38_task","vc-description":"This task requires implementing a Verus method that, given a list of intervals, returns the maximum amount that can be spanned after we removed one of the intervals\nYou may assume you'll receive at least one interval\n\nInput: The input consists of a list of ordered pairs of intervals.\nOutput: The output is an integer: Return the largest span that is possible after removing one of the intervals.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn max_coverage_after_removing_one(intervals: &Vec<(usize, usize)>) -> (result: usize)\n    requires intervals.len() > 0,\n    ensures \n        result <= intervals.len() * 1000,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"4ed45cba2581c79a84275f4bf406611205f93cb8f988f4783912c5ba1fd18bf4","vc_description_hash":"325b71c83cf8fe884b0adbf9df2ee385e298bdcdfba72b0d2a7b90f5c439f39f","vc_spec_hash":"edadaf8d52cda7813080395085cde303a910b9403d076c64caafe21bc15c8356","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"819de12aaaddc96065a29acb391c94ba2918d638e5122d26568bbcc07196c3c6","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_advanced_39_task","vc-description":"This task requires writing a Verus function that returns the maximum element from a non-empty list of natural numbers.\n\nInput: The input consists of lst: a non-empty list of natural numbers.\n\nOutput: The output is a natural number representing the largest element in the list.\n\n/* \n    -- Invalid Inputs\n    [\n        {\n            \"input\": {\n                \"lst\": \"[]\"\n            }\n        }\n    ]\n    -- Tests\n    [\n        {\n            \"input\": {\n                \"lst\": \"[1, 2, 3]\"\n            },\n            \"expected\": 3,\n            \"unexpected\": [\n                2,\n                1,\n                0\n            ]\n        },\n        {\n            \"input\": {\n                \"lst\": \"[5, 5, 5]\"\n            },\n            \"expected\": 5,\n            \"unexpected\": [\n                4,\n                0\n            ]\n        },\n        {\n            \"input\": {\n                \"lst\": \"[10, 1, 9]\"\n            },\n            \"expected\": 10,\n            \"unexpected\": [\n                1,\n                9\n            ]\n        },\n        {\n            \"input\": {\n                \"lst\": \"[7]\"\n            },\n            \"expected\": 7,\n            \"unexpected\": [\n                0,\n                6\n            ]\n        },\n        {\n            \"input\": {\n                \"lst\": \"[0, 0, 0, 0]\"\n            },\n            \"expected\": 0,\n            \"unexpected\": [\n                1\n            ]\n        }\n    ]\n    */","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn max_of_list(lst: &Vec<usize>) -> (result: usize)\n    requires lst.len() > 0,\n    ensures\n        exists|i: int| 0 <= i < lst.len() && lst[i] == result,\n        forall|i: int| 0 <= i < lst.len() ==> lst[i] <= result,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"051a6076cbb0fe0d2dc2a0f667d050fda9e20f27da5f81f59a28524a7c9c7dd6","vc_description_hash":"abd8f7cb5efae4ab4f5a071e65bcfd86384816080f48cfe93435473b72a557a7","vc_spec_hash":"c8cd47e698dcb956729c2bdce0306a4541a7ae1bfe64886df1f5006f7dcd6634","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"60444db8284d4c4871e08b6e47cb4e160ca204ea3b3f250762fdb3be6bdf1497","duplicate_status":"unique","similar_problems":[{"id":"verina_advanced_40_task","similarity":0.709,"type":"high_similarity"}],"structural_info":{"function_signature":"fn max_of_list(lst: &Vec<usize>) -> (result: usize)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_advanced_40_task","vc-description":"This task requires writing a Verus function that returns the maximum element from a non-empty list of natural numbers.\n\n-----Input-----\nThe input consists of:\nlst: a non-empty list of natural numbers.\n\n-----Output-----\nThe output is:\nA natural number representing the largest element in the list.\n\n/*\n    // -- Invalid Inputs\n    // [\n    //     {\n    //         \"input\": {\n    //             \"lst\": \"[]\"\n    //         }\n    //     }\n    // ]\n    // -- Tests\n    // [\n    //     {\n    //         \"input\": {\n    //             \"lst\": \"[1, 2, 3]\"\n    //         },\n    //         \"expected\": 3,\n    //         \"unexpected\": [\n    //             2,\n    //             1,\n    //             0\n    //         ]\n    //     },\n    //     {\n    //         \"input\": {\n    //             \"lst\": \"[5, 5, 5]\"\n    //         },\n    //         \"expected\": 5,\n    //         \"unexpected\": [\n    //             4,\n    //             0\n    //         ]\n    //     },\n    //     {\n    //         \"input\": {\n    //             \"lst\": \"[10, 1, 9]\"\n    //         },\n    //         \"expected\": 10,\n    //         \"unexpected\": [\n    //             1,\n    //             9\n    //         ]\n    //     },\n    //     {\n    //         \"input\": {\n    //             \"lst\": \"[7]\"\n    //         },\n    //         \"expected\": 7,\n    //         \"unexpected\": [\n    //             0,\n    //             6\n    //         ]\n    //     },\n    //     {\n    //         \"input\": {\n    //             \"lst\": \"[0, 0, 0, 0]\"\n    //         },\n    //         \"expected\": 0,\n    //         \"unexpected\": [\n    //             1\n    //         ]\n    //     }\n    // ]\n    // */\n\n//","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn max_of_list(lst: Vec<i32>) -> (result: i32)\n    requires lst.len() > 0,\n    ensures\n        exists|i: int| 0 <= i < lst.len() && lst[i] == result,\n        forall|i: int| 0 <= i < lst.len() ==> lst[i] <= result,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"16d63c022b0ffbd31438d0c6f1bcad1bb92d4e7a0d7f927ca66c748de9374cd4","vc_description_hash":"be0762d35397e2d1fd94e7202c7f5ee5f240590c7e48662677aafe29edb7c0c2","vc_spec_hash":"135723d3a001e252e9a676e19d5e13b1537226781656fcb06e64a814fb076fe3","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"d0fe6a5551339fa607be88bcccedf71d0192f8784ce0d9e2030a379a87fae24d","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn max_of_list(lst: Vec<i32>) -> (result: i32)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_advanced_41_task","vc-description":"This task requires writing a Verus method that finds the maximum among three given integers. The method should return the largest value, ensuring that the result is greater than or equal to each of the input numbers and that it is one of the provided integers.\n\n-----Input-----\nThe input consists of three integers:\na: The first integer.\nb: The second integer.\nc: The third integer.\n\n-----Output-----\nThe output is an integer:\nReturns the maximum of the three input numbers, assuring that the returned value is greater than or equal to a, b, and c, and that it matches one of these values.\n\n/*\n    -- Invalid Inputs\n    []\n    -- Tests\n    [\n        {\n            \"input\": {\n                \"a\": 3,\n                \"b\": 2,\n                \"c\": 1\n            },\n            \"expected\": 3,\n            \"unexpected\": [\n                2,\n                1,\n                -1\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": 5,\n                \"b\": 5,\n                \"c\": 5\n            },\n            \"expected\": 5,\n            \"unexpected\": [\n                6,\n                4\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": 10,\n                \"b\": 20,\n                \"c\": 15\n            },\n            \"expected\": 20,\n            \"unexpected\": [\n                10,\n                15\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": -1,\n                \"b\": -2,\n                \"c\": -3\n            },\n            \"expected\": -1,\n            \"unexpected\": [\n                -2,\n                -3\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": 0,\n                \"b\": -10,\n                \"c\": -5\n            },\n            \"expected\": 0,\n            \"unexpected\": [\n                -5,\n                -10\n            ]\n        }\n    ]\n    */","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn max_of_three(a: i32, b: i32, c: i32) -> (result: i32)\n    ensures\n        result >= a && result >= b && result >= c,\n        result == a || result == b || result == c,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"27cb1d76b631596f623c837c2333cefe425e1872f1b5b1c8de2b3cf03954c886","vc_description_hash":"12bd6c2651c112f513251284d6720430ffefa9005eb73226afe40e82ec774393","vc_spec_hash":"6cb03134f3c184190ee922f7bccf421ce8ffc12c4882a36414cca41e513e95e2","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"b649677eace5714353ea6fa26b1f3eb8b66df7f7fb83d0db556220c392cbcabf","duplicate_status":"unique","similar_problems":[{"id":"verina_basic_6_task","similarity":0.764,"type":"high_similarity"}],"structural_info":{"function_signature":"fn max_of_three(a: i32, b: i32, c: i32) -> (result: i32)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_advanced_42_task","vc-description":"This task requires writing a Verus function that takes a sequence of stock prices and returns the maximum profit achievable by buying on one day and selling on a later day.\n\nIf no profit is possible, the function should return 0.\n\n-----Input-----\nThe input consists of:\nprices: A sequence of natural numbers representing stock prices on each day.\n\n-----Output-----\nThe output is a natural number:\nReturns the maximum profit achievable with one transaction (buy once, sell once), or 0 if no profitable transaction is possible.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn max_profit(prices: Seq<usize>) -> (result: usize)\n    ensures\n        (result == 0 && prices.len() == 0) ||\n        (exists|i: int, j: int| 0 <= i < j < prices.len() && prices[j] >= prices[i] && prices[j] - prices[i] == result) ||\n        (forall|i: int, j: int| 0 <= i < j < prices.len() ==> prices[j] < prices[i]),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"aaf6f0de25c165af9cac41d4b91e2495ac0be14a8d26422000987ab0f0494bc5","vc_description_hash":"5e8c621e89d622fc78d9350a1eb868b85d23614cb64f8213da24d198786ef978","vc_spec_hash":"399164187dfd7e0eb2ce03d47f3c55f3488f6d1c7529683e156bbfab08d23ff5","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"bab9a1b9500ac147258cb224826f4df7120618f3f866823c3bfe7e57ad55f34f","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn max_profit(prices: Seq<usize>) -> (result: usize)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_advanced_43_task","vc-description":"This task requires writing a Verus method that given a 0-indexed integer array `nums` representing the scores of students in an exam. A teacher wants to select a non empty group of students such that the strength of group is maximized.\n\nThe strength of a group is defined as the product of the selected student scores.\n\nYou can choose any non-empty subset of students. The goal is to compute the maximum product of any such subset.\n\n----Input---\nnums: An non-empty list of integers.\n\n-----Output-----\n\nAn integer representing the maximum strength.\n\n/* The result represents the maximum product of any non-empty subset of nums.\n           For simplicity, we ensure that the result is at least as large as one of the elements. */\n\n/* \n    // Invalid Inputs\n    [\n        {\n            \"input\": {\n                \"nums\": \"[]\"\n            }\n        }\n    ]\n    // Tests\n    [\n        {\n            \"input\": {\n                \"nums\": \"[-2]\"\n            },\n            \"expected\": -2,\n            \"unexpected\": [\n                2,\n                0\n            ]\n        },\n        {\n            \"input\": {\n                \"nums\": \"[3, -1, -5, 2, 5, -9]\"\n            },\n            \"expected\": 1350,\n            \"unexpected\": [\n                270,\n                0,\n                -1\n            ]\n        },\n        {\n            \"input\": {\n                \"nums\": \"[-4, -5, -4]\"\n            },\n            \"expected\": 20,\n            \"unexpected\": [\n                80,\n                -80,\n                -5\n            ]\n        },\n        {\n            \"input\": {\n                \"nums\": \"[0, -3, 4]\"\n            },\n            \"expected\": 4,\n            \"unexpected\": [\n                0,\n                -12\n            ]\n        },\n        {\n            \"input\": {\n                \"nums\": \"[1, -1, -1]\"\n            },\n            \"expected\": 1,\n            \"unexpected\": [\n                -1,\n                -2\n            ]\n        }\n    ]\n    */","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn max_strength(nums: &Vec<i32>) -> (result: i32)\n    requires nums.len() > 0,\n    ensures\n\n        exists|i: int| 0 <= i < nums.len() && result >= nums[i],","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"2c44f2a23efb2c77817f81506f4599374a57aaa345be3e4f3f8c904cbf721c61","vc_description_hash":"cf83924846fd8b99f8928c0d86e970811537396959d02475099d3bb1d4a3e6a2","vc_spec_hash":"676bb6c7065c4dab77ccbd53676fa9c42b5bf6982512cf7fe45e6b1cba0bc203","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"e4d763be54b1d698ab5033947f082d59622b7ad91fef61545cc9ac8ff346e21a","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn max_strength(nums: &Vec<i32>) -> (result: i32)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_advanced_44_task","vc-description":"Given an integer array arr and a positive integer k, this task requires writing a Verus method that finds the\nmaximum sum of a subarray of arr, such that the length of the subarray is divisible by k.\nIf the array is empty, or generally if there exists no subarray with length divisible by k,\nthe default return value should be 0.\n\nInput:\nThe input consists of:\narr: The array of integers.\nk: An integer larger than 1.\n\nOutput:\nThe output is an integer:\nReturns the maximum positive integer x such that there exists a subarray where the sum equals x, and the length\nof the subarray is divisible by k.\n\n/* TODO: Add postcondition based on subarrays with length divisible by k */","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn max_subarray_sum_divisible_by_k(arr: &Vec<i32>, k: i32) -> (result: i32)\n    requires k > 0,\n    ensures true,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"4f0ab423184247c481461140bf55a5afc998605ce3ffa727f1481e55201303d8","vc_description_hash":"d383989d090b6ebc812b56dac943a2b433a2a9040a50091ce3b8678905df3f04","vc_spec_hash":"0fe39cfa4a901edc53510bad2761daddf18f1beecc923360ce2e045b81b62141","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"f7ef430ecabf1f2f8c72cc4fc53a6f693d1abb0fcb90a1b985847117d1071685","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn max_subarray_sum_divisible_by_k(arr: &Vec<i32>, k: i32) -> (result: i32)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_advanced_45_task","vc-description":"This task requires writing a Verus function that finds the maximum subarray sum from a given list of integers.\nA subarray is a contiguous sequence of elements within the list.\nThe function should return the maximum sum that can be obtained from any subarray.\n\nInput:\nThe input is a vector of integers:\nxs: A vector of integers (can include negative numbers).\n\nOutput:\nThe output is an integer:\nReturns the maximum sum among all contiguous subarrays of xs.\nIf the vector is empty, the result should be 0.","vc-preamble":"use vstd::prelude::*;\n\nverus! {\n\nspec fn spec_sum(xs: &Vec<i32>, start: int, len: int) -> int \n    decreases len\n{\n    if len <= 0 {\n        0\n    } else {\n        xs[start] + spec_sum(xs, start + 1, len - 1)\n    }\n}","vc-helpers":"","vc-spec":"fn max_subarray_sum(xs: &Vec<i32>) -> (result: i32)\n    ensures\n        xs.len() == 0 ==> result == 0,\n        xs.len() > 0 ==> (\n            exists|start: int, len: int| \n                0 <= start < xs.len() && \n                1 <= len <= xs.len() - start &&\n                result == spec_sum(xs, start, len) as i32\n        ) &&\n        (forall|start: int, len: int|\n            0 <= start < xs.len() && \n            1 <= len <= xs.len() - start\n            ==> spec_sum(xs, start, len) <= result as int\n        ),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"e8b72748e935f460b41675337d2c8115d2e7764ce1eceb3cdd2f1e128c077a8b","vc_description_hash":"d06d0580ec34992f77ff2ccaac1341c2ab5d9be6ab9b0ddd781f44c2fa9f2482","vc_spec_hash":"dffc4bc6f1ef57b326df83520caa1f5f7022becfca59b5a82c5e920d00eff2f7","vc_preamble_hash":"10aff44ce82b2403296990bff79fad597f0509fe200896b890ab01dce512a4e8","description_normalized_hash":"a07e18b62b9db1ba3b2e0963fe82d13beb3027053864b17e3cdf9f8c78a6d242","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn max_subarray_sum(xs: &Vec<i32>) -> (result: i32)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_advanced_46_task","vc-description":"This test implements a function in Verus that finds the maximum sum of any contiguous subarray within a vector of integers. A subarray is a continuous section of the original array. If all integers in the vector are negative, the function should return 0 (representing the empty subarray).\n\nInput: numbers - A vector of integers that may contain positive, negative, or zero values.\n\nOutput: An integer representing the maximum sum of any contiguous subarray. If the vector is empty or contains only negative numbers, the function returns 0.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn max_subarray_sum(numbers: &Vec<i32>) -> (result: i32)\n    ensures\n        result >= 0,\n        forall|start: usize, end: usize| {\n            start <= end && end <= numbers.len()\n        } ==> {\n            let mut subarray_sum: i32 = 0;\n            subarray_sum <= result\n        },","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"afe44d19efd2a6c3cd8c2418d1a0f2b532a6f0054af1916ccec568227d36abcd","vc_description_hash":"4b17ad01eba80fb09c8f096a5c1b6f53423537a2632f3981772adfc2fd60a71b","vc_spec_hash":"e6828cadb37346f97e65af013047d6c9416785d6c308447eeddb881b1190b60c","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"53ac5ae4a3e2dc4faa2abe0de39848fa495a0f9a5764c783a14aee05c2de5089","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn max_subarray_sum(numbers: &Vec<i32>) -> (result: i32)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_advanced_48_task","vc-description":"This task requires implementing the merge sort algorithm in Verus to sort a list of integers in ascending order. Merge sort is a divide-and-conquer algorithm that recursively splits the input list into two halves, sorts them separately, and then merges the sorted halves to produce the final sorted result.\n\nThe merge sort algorithm works as follows:\n1. If the list has one element or is empty, it is already sorted.\n2. Otherwise, divide the list into two roughly equal parts.\n3. Recursively sort both halves.\n4. Merge the two sorted halves to produce a single sorted list.\n\nThe key operation in merge sort is the merging step, which takes two sorted lists and combines them into a single sorted list by repeatedly taking the smaller of the two elements at the front of the lists.\n\nInput:\nThe input consists of one parameter:\nlist: A list of integers that needs to be sorted.\n\nOutput:\nThe output is a list of integers:\nReturns a new list containing all elements from the input list, sorted in ascending order.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn merge_sort(list: Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        result.len() == list.len(),\n        forall|i: int, j: int| 0 <= i < j < result.len() ==> result[i] <= result[j],\n        result@ =~= list@,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"ef8274e79827d29a11133ed7889a5fe36e9d3d7da52e406939a4e9945b3da10e","vc_description_hash":"59d0268f7747a9e5c1b3fc0769b570b200c52e89435bd87e48ee5f0b5d907e02","vc_spec_hash":"bb303bf3b7412dc1dbeeddecf7e91192dd62f459e11a07a7abd9f3edc73eaab4","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"70c0001f573a5f6c50e47b1cea0f61dbeba050e7daf4726fbf9c77235bd3bc3c","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn merge_sort(list: Vec<i32>) -> (result: Vec<i32>)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_advanced_49_task","vc-description":"Implement a Verus function that merges two ascendingly sorted lists of integers into one single sorted list (ascending). The resulting list must contain all elements from both input lists, preserving their ascending order.\n\nInput:\nThe input consists of two lists of integers:\narr1: A sorted list of integers (ascending)\narr2: Another sorted list of integers (ascending)\n\nOutput:\nThe output is a list of integers:\nReturns a new list containing all elements from arr1 and arr2, sorted in ascending order.\n\n/* \n    -- Invalid Inputs\n    [\n        {\n            \"input\": {\n                \"arr1\": \"[3, 2, 1]\",\n                \"arr2\": \"[6, 5, 4]\"\n            }\n        }\n    ]\n    -- Tests\n    [\n        {\n            \"input\": {\n                \"arr1\": \"[1, 3, 5]\",\n                \"arr2\": \"[2, 4, 6]\"\n            },\n            \"expected\": \"[1, 2, 3, 4, 5, 6]\",\n            \"unexpected\": [\n                \"[1, 3, 5]\",\n                \"[2, 4, 6]\",\n                \"[1, 3, 2, 4, 5, 6]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"arr1\": \"[]\",\n                \"arr2\": \"[]\"\n            },\n            \"expected\": \"[]\",\n            \"unexpected\": [\n                \"[0]\",\n                \"[999]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"arr1\": \"[-2, 0, 1]\",\n                \"arr2\": \"[-3, -1]\"\n            },\n            \"expected\": \"[-3, -2, -1, 0, 1]\",\n            \"unexpected\": [\n                \"[-3, -1]\",\n                \"[0, 1]\",\n                \"[-2, 0, 1]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"arr1\": \"[10, 20, 30]\",\n                \"arr2\": \"[5, 25, 35]\"\n            },\n            \"expected\": \"[5, 10, 20, 25, 30, 35]\",\n            \"unexpected\": [\n                \"[10, 20, 30]\",\n                \"[5, 25, 35]\",\n                \"[10, 20, 25, 30, 35]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"arr1\": \"[1, 2, 2]\",\n                \"arr2\": \"[2, 3, 3]\"\n            },\n            \"expected\": \"[1, 2, 2, 2, 3, 3]\",\n            \"unexpected\": [\n                \"[1, 2, 3]\",\n                \"[2, 2, 2, 3, 3]\"\n            ]\n        }\n    ]\n    */","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn merge_sorted_lists(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)\n    requires \n        forall|i: int, j: int| 0 <= i < j < arr1.len() ==> arr1[i] <= arr1[j],\n        forall|i: int, j: int| 0 <= i < j < arr2.len() ==> arr2[i] <= arr2[j],\n    ensures\n        forall|i: int, j: int| 0 <= i < j < result.len() ==> result[i] <= result[j],\n        result.len() == arr1.len() + arr2.len(),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"7a0b0a1fb8c7d35a64ae4c89c4c971616466ccc43d4c9126741ffbf440c1515b","vc_description_hash":"ab2c5d85fbd901490b966b2816d629fbf51c7dbddec4984c51b469ab24ff3e89","vc_spec_hash":"d7934b9e284f17eff578d1884b8d7d5a2d9024eaf2fcfa916d272f1e736d7d35","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"bceaad1437faacea8a26780a2238ba99573b192d23030ebe122fb6d35e8f4bde","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn merge_sorted_lists(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_advanced_4_task","vc-description":"This task requires writing a Verus method that finds the length of the longest increasing sequence in a given array. The method should return the length of the longest increasing subsequence, in which every element is strictly less than the latter element.\n\n-----Input-----\nThe input consists of an array:\na: The input array.\n\n-----Output-----\nThe output is an integer:\nReturns the length of the longest increasing subsequence, assuring that it is a subsequence of the input sequence and that every element in it is strictly less than the latter one.\n\n/*\n    // -- Invalid Inputs\n    // []\n    // -- Tests\n    // [\n    //     {\n    //         \"input\": {\n    //             \"a\": \"#[5, 2, 8, 6, 3, 6, 9, 7]\"\n    //         },\n    //         \"expected\": 4,\n    //         \"unexpected\": [\n    //             2,\n    //             3\n    //         ]\n    //     },\n    //     {\n    //         \"input\": {\n    //             \"a\": \"#[3, 1, 2, 1, 0]\"\n    //         },\n    //         \"expected\": 2,\n    //         \"unexpected\": [\n    //             1,\n    //             3\n    //         ]\n    //     },\n    //     {\n    //         \"input\": {\n    //             \"a\": \"#[2, 3, -2, -1, 7, 19, 3, 6, -4, 6, -7, 0, 9, 12, 10]\"\n    //         },\n    //         \"expected\": 6,\n    //         \"unexpected\": [\n    //             5,\n    //             3,\n    //             10\n    //         ]\n    //     },\n    //     {\n    //         \"input\": {\n    //             \"a\": \"#[5, -5, -3, 2, 4, 1, 0, -1, 3, 2, 0]\"\n    //         },\n    //         \"expected\": 4,\n    //         \"unexpected\": [\n    //             2,\n    //             5\n    //         ]\n    //     },\n    //     {\n    //         \"input\": {\n    //             \"a\": \"#[1, 7, 23, 14, -4, 21, 8, 2, -1, 9, 12, 2]\"\n    //         },\n    //         \"expected\": 5,\n    //         \"unexpected\": [\n    //             2,\n    //             4\n    //         ]\n    //     },\n    //     {\n    //         \"input\": {\n    //             \"a\": \"#[]\"\n    //         },\n    //         \"expected\": 0,\n    //         \"unexpected\": [\n    //             1,\n    //             2\n    //         ]\n    //     }\n    // ]\n    // */\n\n//","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn longest_increasing_subsequence(a: &Vec<i32>) -> (result: i32)\n    ensures\n        result >= 0,\n        result <= a.len(),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"bfe5c553d3d1b2a0c458ed1602741614128084ee3a8fcddf00ac63d5a458ec32","vc_description_hash":"0cb0785228d59f8fede5d85b03d3ab4192cd4b14e6d8288afadde84c98a94a3f","vc_spec_hash":"d6c17193ca80cadc3c9a72bd7074560605b47ee8c6717f0c278d1d9b636a362a","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"c8cd72adf0b7f15755dc8681bfda314d24bdcd8d617599614eba7b4326cb0c43","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn longest_increasing_subsequence(a: &Vec<i32>) -> (result: i32)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_advanced_50_task","vc-description":"This task involves merging two sorted arrays of natural numbers (it is ill defined if inputs aren't sorted.)\nThe input consists of two arrays:\na1: A sorted array of natural numbers\na2: A sorted array of natural numbers\nThe output is an array:\nReturns a new array with all elements from both input arrays (included once and only once)\nThe resulting array is sorted itself\n\n/*\n    -- Invalid Inputs\n    [\n        {\n            \"input\": {\n                \"a1\": \"#[3, 2, 1]\",\n                \"a2\": \"#[6, 5, 4]\"\n            }\n        }\n    ]\n    -- Tests\n    [\n        {\n            \"input\": {\n                \"a1\": \"#[1, 3, 5]\",\n                \"a2\": \"#[2, 4, 6]\"\n            },\n            \"expected\": \"#[1, 2, 3, 4, 5, 6]\",\n            \"unexpected\": [\n                \"#[1, 3, 5, 2, 4, 6]\",\n                \"#[2, 1, 3, 4, 5, 6]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"a1\": \"#[]\",\n                \"a2\": \"#[1, 2, 3]\"\n            },\n            \"expected\": \"#[1, 2, 3]\",\n            \"unexpected\": [\n                \"#[]\",\n                \"#[3, 2, 1]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"a1\": \"#[1, 2, 3]\",\n                \"a2\": \"#[]\"\n            },\n            \"expected\": \"#[1, 2, 3]\",\n            \"unexpected\": [\n                \"#[]\",\n                \"#[3, 2, 1]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"a1\": \"#[]\",\n                \"a2\": \"#[]\"\n            },\n            \"expected\": \"#[]\",\n            \"unexpected\": [\n                \"#[1]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"a1\": \"#[1, 1, 2]\",\n                \"a2\": \"#[1, 2, 2]\"\n            },\n            \"expected\": \"#[1, 1, 1, 2, 2, 2]\",\n            \"unexpected\": [\n                \"#[1, 1, 2, 1, 2, 2]\",\n                \"#[1, 2]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"a1\": \"#[10, 20, 30]\",\n                \"a2\": \"#[5, 15, 25]\"\n            },\n            \"expected\": \"#[5, 10, 15, 20, 25, 30]\",\n            \"unexpected\": [\n                \"#[10, 20, 30, 5, 15, 25]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"a1\": \"#[1, 3, 5, 7, 9]\",\n                \"a2\": \"#[2, 4, 6, 8, 10]\"\n            },\n            \"expected\": \"#[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\",\n            \"unexpected\": [\n                \"#[1, 3, 5, 7, 9, 2, 4, 6, 8, 10]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"a1\": \"#[5, 5, 5]\",\n                \"a2\": \"#[5, 5, 5]\"\n            },\n            \"expected\": \"#[5, 5, 5, 5, 5, 5]\",\n            \"unexpected\": [\n                \"#[5, 5, 5]\"\n            ]\n        }\n    ]\n    */","vc-preamble":"use vstd::prelude::*;\n\nverus! {\n\nspec fn is_sorted(v: Seq<nat>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < v.len() ==> #[trigger] v[i] <= #[trigger] v[j]\n}","vc-helpers":"","vc-spec":"fn merge_sorted(a1: &Vec<nat>, a2: &Vec<nat>) -> (result: Vec<nat>)\n    requires \n        is_sorted(a1@),\n        is_sorted(a2@),\n    ensures\n        is_sorted(result@),\n        result@.to_multiset() == a1@.to_multiset().add(a2@.to_multiset()),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"43857890942b3f90a42f4e823baa596e47be0a73ffaf1364200c116f71e7073e","vc_description_hash":"9e86e15b81ff67ae635b95fb0489b92d685492aa9cb6b286cfb8759cf33f9fb5","vc_spec_hash":"bacad990063a2d75b1eb218606c28e8062ddf4937913bf775ca396e8732963cb","vc_preamble_hash":"669d5438682f0a3b737d4bfcad698f71da3795785d7b6901bc1ba848bc4a0504","description_normalized_hash":"fdb9c68a9675e0acfb45a953f52dfce5774d86f5da73a05287c6d2bd4e479344","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn merge_sorted(a1: &Vec<nat>, a2: &Vec<nat>) -> (result: Vec<nat>)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_advanced_51_task","vc-description":"This task requires writing a Verus method that takes two sorted (non-decreasing) integer lists and merges them into a single sorted list. The output must preserve order and include all elements from both input lists.\n\nInput:\nThe input consists of:\na: A list of integers sorted in non-decreasing order.\nb: Another list of integers sorted in non-decreasing order.\n\nOutput:\nThe output is a list of integers:\nReturns a merged list that contains all elements from both input lists, sorted in non-decreasing order.\n\n/* \n    -- Invalid Inputs\n    [\n        {\n            \"input\": {\n                \"a\": \"[1, 2, 3]\",\n                \"b\": \"[6, 5, 4]\"\n            }\n        },\n        {\n            \"input\": {\n                \"a\": \"[3, 2, 1]\",\n                \"b\": \"[6, 5, 4]\"\n            }\n        }\n    ]\n    -- Tests\n    [\n        {\n            \"input\": {\n                \"a\": \"[1, 3, 5]\",\n                \"b\": \"[2, 4, 6]\"\n            },\n            \"expected\": \"[1, 2, 3, 4, 5, 6]\",\n            \"unexpected\": [\n                \"[1, 3, 5]\",\n                \"[2, 4, 6]\",\n                \"[6, 5, 4]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"[1, 2]\",\n                \"b\": \"[1, 2, 3]\"\n            },\n            \"expected\": \"[1, 1, 2, 2, 3]\",\n            \"unexpected\": [\n                \"[1, 2, 3]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"[]\",\n                \"b\": \"[4, 5]\"\n            },\n            \"expected\": \"[4, 5]\",\n            \"unexpected\": [\n                \"[]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"[0, 3, 4]\",\n                \"b\": \"[]\"\n            },\n            \"expected\": \"[0, 3, 4]\",\n            \"unexpected\": [\n                \"[4, 3, 0]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"[1, 4, 6]\",\n                \"b\": \"[2, 3, 5]\"\n            },\n            \"expected\": \"[1, 2, 3, 4, 5, 6]\",\n            \"unexpected\": [\n                \"[1, 4, 6, 2, 3, 5]\"\n            ]\n        }\n    ]\n    */","vc-preamble":"use vstd::prelude::*;\n\nverus! {\n\nspec fn is_sorted(s: Seq<i32>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] <= s[j]\n}\n\nspec fn multiset_equiv(s1: Seq<i32>, s2: Seq<i32>) -> bool {\n    s1.to_multiset() == s2.to_multiset()\n}","vc-helpers":"","vc-spec":"fn merge_sorted(a: Vec<i32>, b: Vec<i32>) -> (result: Vec<i32>)\n    requires \n        is_sorted(a@),\n        is_sorted(b@),\n    ensures \n        is_sorted(result@),\n        multiset_equiv(result@, a@ + b@),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"9c8dbcb2c14e05fe16063247eb7879690207ae18acdcc867b02ab60d744e1880","vc_description_hash":"c3c014f39b16f8d77194f69100b3f4aa2b659ab08dc5793d06bbf40a920d838d","vc_spec_hash":"d8c6d00b9e909569a2d0a8a4f73899280b7ef38e16be71bad6f6d282eeb5b34c","vc_preamble_hash":"f2b569c56946bf6bffd650cafc8f22b591d43145daf0fc59926df4792f0c8deb","description_normalized_hash":"722778c1ec30b56b6df7ceeb47155461ff5e6fe4ce3f08e419bd7548072879e2","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn merge_sorted(a: Vec<i32>, b: Vec<i32>) -> (result: Vec<i32>)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_advanced_53_task","vc-description":"This task requires writing a Verus function that calculates the minimum number of right shifts required to sort a given list of distinct positive integers.\n\nA right shift operation on a list nums of length n moves the element at index i to index (i + 1) % n for all indices i. Effectively, the last element moves to the first position, and all other elements shift one position to the right.\n\nThe function should return the minimum number of right shifts needed to make the list sorted in ascending order. If the list is already sorted, the function should return 0. If it's impossible to sort the list using only right shifts, the function should return -1.\n\nInput:\nThe input consists of a single list of integers:\nnums: A vector (Vec<i32>) containing distinct positive integers.\n\nOutput:\nThe output is a single integer (i32):\n- If the list can be sorted using right shifts, return the minimum number of shifts required (an integer >= 0).\n- If the list cannot be sorted using right shifts, return -1.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn minimum_right_shifts(nums: Vec<i32>) -> (result: i32)\n    requires\n        nums.len() <= i32::MAX,\n        forall|i: int, j: int| 0 <= i < nums.len() && 0 <= j < nums.len() && i != j ==> nums[i] != nums[j],\n    ensures\n        ({\n            let n = nums.len() as i32;\n            if n <= 1 {\n                result == 0\n            } else {\n                (result >= 0 && result < n) || result == -1\n            }\n        }),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"191afbce53677e18985bbfc664dfe3d2de6002622182b4420757f37b966cbfe5","vc_description_hash":"f4b345f233d081fed41b03cec50df1802fb38c5c7c112953754b752cc1535bee","vc_spec_hash":"cb106267e919cc608c887f4bfb7512e90c5a59167c26acf54d6d758ab2de4f5e","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"01e6a9b912ebf970ba08122e681fe5515149c2d4af0f39240d947f192634e534","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn minimum_right_shifts(nums: Vec<i32>) -> (result: i32)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_advanced_55_task","vc-description":"This task requires writing a Verus method that returns the integer that appears most frequently in the input list. If multiple integers have the same maximum frequency, return the one that appears first in the original list. You should implement a frequency counter using a fold over the list, extract the maximum frequency, and return the first element in the list that matches it.\n\nInput: The input consists of xs: A list of integers (possibly with duplicates). The list is guaranteed to be non-empty.\n\nOutput: The output is an integer that appears the most frequently in the list. If there is a tie, the element that occurs first in the original list should be returned.\n\n/* Helper function to count occurrences of a target value in a sequence */","vc-preamble":"use vstd::prelude::*;\n\nverus! {\n\nspec fn count_occurrences(xs: Seq<i32>, target: i32) -> nat {\n    xs.filter(|x: i32| x == target).len()\n}","vc-helpers":"","vc-spec":"fn most_frequent(xs: Vec<i32>) -> (result: i32)\n    requires xs.len() > 0,\n    ensures\n        xs@.contains(result),\n        forall|x: i32| xs@.contains(x) ==> count_occurrences(xs@, x) <= count_occurrences(xs@, result),\n        exists|first_idx: int| \n            0 <= first_idx < xs.len() && \n            xs[first_idx] == result && \n            count_occurrences(xs@, result) == count_occurrences(xs@, xs[first_idx]) &&\n            forall|i: int| 0 <= i < first_idx ==> count_occurrences(xs@, xs[i]) < count_occurrences(xs@, result),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"998941247c2c10ec818f06fbd03a476d1510b1b3fe156dda84c23b8356a3c1d6","vc_description_hash":"be5cd74b47f7d2e5eec46a8f9366b30c21f8792ea510e1956b22ecdb2a8d5b6c","vc_spec_hash":"ecfaf9785bb9e674b538b325d996f67bf795b07523a874871530f7ad8359e521","vc_preamble_hash":"ca29955f88b0e088b3d58d321c27b134e2b07f81d3ce44da80a23d522f3ccf66","description_normalized_hash":"29f1124e1e634036c8d30940a562897f9ec082f1c45369d634ee2794393b0619","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn most_frequent(xs: Vec<i32>) -> (result: i32)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_advanced_56_task","vc-description":"This task requires writing a Verus method that moves all zeroes in a given integer vector to the end, while preserving the relative order of the non-zero elements.\n\nThe method `move_zeroes` processes the input vector by separating the non-zero and zero elements. It then returns a new vector formed by appending all non-zero elements followed by all the zero elements.\n\n-----Input-----\nThe input is a single vector of integers:\nxs: A vector of integers (type: Vec<i32>), possibly containing zero and non-zero values.\n\n-----Output-----\nThe output is a vector of integers:\nReturns a vector (type: Vec<i32>) with the same elements as the input, where all zeroes appear at the end, and the non-zero elements maintain their original relative order.\n\n/* Count how many times a specific value appears in the sequence */\n\n/* Check whether one sequence is a subsequence of another (preserving relative order) */\n\n/* All non-zero elements must maintain their relative order */\n\n/* All zeroes must be located at the end of the output vector */\n\n/* The output must contain the same number of elements */\n\n/* The number of zeroes must remain unchanged */","vc-preamble":"use vstd::prelude::*;\n\nverus! {\n\nspec fn count_val(val: i32, xs: Seq<i32>) -> nat \n    decreases xs.len()\n{\n    if xs.len() == 0 {\n        0\n    } else {\n        let rest = count_val(val, xs.drop_first());\n        if xs[0] == val { rest + 1 } else { rest }\n    }\n}\n\nspec fn is_subsequence(xs: Seq<i32>, ys: Seq<i32>) -> bool \n    decreases xs.len() + ys.len()\n{\n    if xs.len() == 0 {\n        true\n    } else if ys.len() == 0 {\n        false\n    } else {\n        if xs[0] == ys[0] {\n            is_subsequence(xs.drop_first(), ys.drop_first())\n        } else {\n            is_subsequence(xs, ys.drop_first())\n        }\n    }\n}","vc-helpers":"","vc-spec":"fn move_zeroes(xs: Vec<i32>) -> (result: Vec<i32>)\n    ensures\n\n        is_subsequence(xs@.filter(|x: i32| x != 0), result@),\n\n        forall|i: int| 0 <= i < result.len() && result[i] != 0 ==> \n            forall|j: int| i < j < result.len() ==> result[j] != 0,\n\n        xs.len() == result.len(),\n\n        count_val(0, xs@) == count_val(0, result@),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"a0dec319d20a798bdefcc3706513e80cde5a2f8adfbcea24cf42b19b7f764da7","vc_description_hash":"cf38f886ac40b44061cea3a8c3ccd6c19b9185d6bd0fba8a19e0048fa185dfce","vc_spec_hash":"b55532ef40172d85eb2056b69473614675fed0e462d487083606e6a79945ca73","vc_preamble_hash":"ce4921c493b6b174628a8e28a4a0c2214e5b04905075836981c35ec5488ec54b","description_normalized_hash":"17d8a4cce139bfdb115d9bb1357b9bb508185ab5b948e397dc7f8a3b0246cbcd","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn move_zeroes(xs: Vec<i32>) -> (result: Vec<i32>)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_advanced_57_task","vc-description":"This task requires writing a Verus function that finds the next greater element for a given array of numbers. The next greater element for an element x is defined as the first element greater than x that appears to the right of x in the array.\n\nGiven two distinct 0-indexed integer arrays `nums1` and `nums2`, where `nums1` is a subset of `nums2`, the function should determine the next greater element for each value in `nums1` as it appears in `nums2`.\nAll integers in both arrays are unique, and the length constraints are.\n\nInput:\nThe input consists of two lists of integers:\nnums1: A list of integers, which is a subset of nums2.\nnums2: A list of integers containing all elements from nums1 and possibly additional elements.\n\nOutput:\nThe output is a list of integers:\n- An array of the same length as nums1.\n- For each element nums1[i], the corresponding output element is:\n  - The next greater element of nums1[i] in nums2 if one exists\n  - -1 if there is no next greater element","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn next_greater_element(nums1: &Vec<i32>, nums2: &Vec<i32>) -> (result: Vec<i32>)\n    requires\n        forall|i: int, j: int| 0 <= i < nums1.len() && 0 <= j < nums1.len() && i != j ==> nums1[i] != nums1[j],\n        forall|i: int, j: int| 0 <= i < nums2.len() && 0 <= j < nums2.len() && i != j ==> nums2[i] != nums2[j],\n    ensures\n        result.len() == nums1.len(),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"2074c96e2ef8f7c6ca05b8dc00342f8e560cd9687de01bba5cd145c2f9c102b4","vc_description_hash":"18c09c4989d606cc9ade7c17a8f0db273f0e6de508cda6cacfd16619b4e888c4","vc_spec_hash":"c4b749140c8c744781fdd6c237fc88786e52b8caacef4db09a43676dfa2934a6","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"24ca0f42b05bb33600425276a1077ca79596c487504c703d6a013f348a5372b4","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn next_greater_element(nums1: &Vec<i32>, nums2: &Vec<i32>) -> (result: Vec<i32>)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_advanced_58_task","vc-description":"This task requires writing a Verus function that returns the nth \"ugly number\". Ugly numbers are positive integers whose only prime factors are 2, 3, or 5.\n\nThe function should generate ugly numbers in ascending order and return the nth one. The first ugly number is 1.\n\nInput:\nThe input is a natural number:\n\nn: The index (1-based) of the ugly number to return.\n\nOutput:\nThe output is a natural number:\nThe nth smallest ugly number.","vc-preamble":"use vstd::prelude::*;\n\nverus! {\n\nspec fn nth_ugly_number_precond(n: nat) -> bool {\n    n > 0\n}","vc-helpers":"","vc-spec":"fn nth_ugly_number(n: u32) -> (result: u32)\n    requires n > 0,\n    ensures result > 0,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"702305e6d4b1c10841a7489c8efe931a4888784b3afe8b51713ee8aac87cce1b","vc_description_hash":"5094955c30e8bafb231fdf76890671097838d10db6b194461735448ab89620f1","vc_spec_hash":"67e21106bd979c4ff281023c3e401ca1d499232b835a2cab0a41b8d5216767f8","vc_preamble_hash":"4e2e5b9fe68c17795bd4ec329043ccc23f9255c8df5794e93faca7693e695e19","description_normalized_hash":"ae81a8301c61dc440eda47539f329f964d72b3e32f8bdf807da501cc45d126cf","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn nth_ugly_number(n: u32) -> (result: u32)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_advanced_59_task","vc-description":"This task requires writing a Verus method that determines if a given string is a palindrome, ignoring all\nnon-alphanumeric characters and case differences. For example, the string \"A man, a plan, a canal: Panama\" should return\ntrue.\n\n-----Input-----\nA single string:\ns: The string to check for palindrome property.\n\n-----Output-----\nA boolean (Bool):\ntrue if s is a palindrome when ignoring non-alphanumeric characters and case. false otherwise.\n\n/* Tests\n    [\n        {\n            \"input\": {\n                \"s\": \"\"\n            },\n            \"expected\": true,\n            \"unexpected\": [\n                false\n            ]\n        },\n        {\n            \"input\": {\n                \"s\": \"A man, a plan, a canal: Panama\"\n            },\n            \"expected\": true,\n            \"unexpected\": [\n                false\n            ]\n        },\n        {\n            \"input\": {\n                \"s\": \"race a car\"\n            },\n            \"expected\": false,\n            \"unexpected\": [\n                true\n            ]\n        },\n        {\n            \"input\": {\n                \"s\": \"No 'x' in Nixon\"\n            },\n            \"expected\": true,\n            \"unexpected\": [\n                false\n            ]\n        },\n        {\n            \"input\": {\n                \"s\": \"abc!!cba?\"\n            },\n            \"expected\": true,\n            \"unexpected\": [\n                false\n            ]\n        },\n        {\n            \"input\": {\n                \"s\": \"Hello, world!\"\n            },\n            \"expected\": false,\n            \"unexpected\": [\n                true\n            ]\n        }\n    ] */","vc-preamble":"use vstd::prelude::*;\n\nverus! {\n\nspec fn is_alphanumeric(c: char) -> bool {\n    ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || ('0' <= c && c <= '9')\n}\n\nspec fn to_lowercase(c: char) -> char {\n    if 'A' <= c && c <= 'Z' {\n        ((c as u32) + 32) as char\n    } else {\n        c\n    }\n}","vc-helpers":"","vc-spec":"fn palindrome_ignore_non_alnum(s: &str) -> (result: bool)\n    ensures \n        result <==> ({\n            let chars_seq = s@;\n            let cleaned = chars_seq.filter(|c: char| is_alphanumeric(c)).map(|i, c: char| to_lowercase(c));\n            let forward = cleaned;\n            let backward = cleaned.reverse();\n            forward == backward\n        })","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"57efc9977c7391d8850844c78d2d26800c4d5f5fa51fa6a130601ec74ee6b053","vc_description_hash":"cafe431b1c76953313ec2b6cae11c0d54570ef72f7883f1dbfbe9c5f17d02808","vc_spec_hash":"ce4f3ee97db222cab98d2e2c5a0b0fbcaf0d0002fa8f6d5d858b7c90a2a20eb4","vc_preamble_hash":"5d543b61421f3b726a075e0a82a3ff3601b532fac9dc0fd371c591e0269328c6","description_normalized_hash":"5acf2d20cc175eed31ea66ae44120bb68fc1e55d20caec58bbbbe25750694edb","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn palindrome_ignore_non_alnum(s: &str) -> (result: bool)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_advanced_5_task","vc-description":"This task requires writing a Verus method that adds two non-empty linked lists representing non-negative integers.\nThe digits are stored in reverse order (i.e., the first element is the least significant digit).\nEach node (list element) holds a single digit (ranging from 0 to 9). The function should add the two numbers and return the sum\nas a linked list, also in reverse order.\n\n-----Input-----\nThe input consists of:\n- l1: A list of natural numbers representing the digits of the first number in reverse order.\n- l2: A list of natural numbers representing the digits of the second number in reverse order.\n\n-----Output-----\nThe output is a list of natural numbers:\nReturns a list of digits (in reverse order) representing the sum of the two input numbers.\n\n/*\n    -- Invalid Inputs\n    [\n        {\n            \"input\": {\n                \"l1\": \"[]\",\n                \"l2\": \"[]\"\n            }\n        },\n        {\n            \"input\": {\n                \"l1\": \"[0, 0]\",\n                \"l2\": \"[0, 0]\"\n            }\n        }\n    ]\n    -- Tests\n    [\n        {\n            \"input\": {\n                \"l1\": \"[2,4,3]\",\n                \"l2\": \"[5,6,4]\"\n            },\n            \"expected\": \"[7,0,8]\",\n            \"unexpected\": [\n                \"[2,4,3]\",\n                \"[0]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"l1\": \"[0]\",\n                \"l2\": \"[0]\"\n            },\n            \"expected\": \"[0]\",\n            \"unexpected\": [\n                \"[0,0]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"l1\": \"[9,9,9,9,9,9,9]\",\n                \"l2\": \"[9,9,9,9]\"\n            },\n            \"expected\": \"[8,9,9,9,0,0,0,1]\",\n            \"unexpected\": [\n                \"[9,9,9,9,9,9,9,9]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"l1\": \"[1,2,3]\",\n                \"l2\": \"[4,5]\"\n            },\n            \"expected\": \"[5,7,3]\",\n            \"unexpected\": [\n                \"[5,7]\",\n                \"[5,7,4]\"\n            ]\n        }\n    ]\n    */","vc-preamble":"use vstd::prelude::*;\n\nverus! {\n\nspec fn list_to_nat(l: Seq<u32>) -> nat\n    decreases l.len(),\n{\n    if l.len() == 0 {\n        0nat\n    } else {\n        l[0] as nat + 10nat * list_to_nat(l.subrange(1, l.len() as int))\n    }\n}","vc-helpers":"","vc-spec":"fn add_two_numbers(l1: &Vec<u32>, l2: &Vec<u32>) -> (result: Vec<u32>)\n    requires \n        l1.len() > 0,\n        l2.len() > 0,\n        forall|i: int| 0 <= i < l1.len() ==> l1[i] < 10,\n        forall|i: int| 0 <= i < l2.len() ==> l2[i] < 10,\n        (l1[l1.len() - 1] != 0 || l1@ == seq![0u32]) &&\n        (l2[l2.len() - 1] != 0 || l2@ == seq![0u32]),\n    ensures\n        list_to_nat(result@) == list_to_nat(l1@) + list_to_nat(l2@),\n        forall|i: int| 0 <= i < result.len() ==> result[i] < 10,\n        result[result.len() - 1] != 0 || (l1@ == seq![0u32] && l2@ == seq![0u32] && result@ == seq![0u32]),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"73180d0f1ae1ed36b40cbe20e598ba151aaeba88a8e2c500abb8672b05892f00","vc_description_hash":"afa2454ce1d5036d3aa3c8126325f990963d2a10a9eb0a213e07eee41acbc8e6","vc_spec_hash":"b8dcb530d5dcf23d42acee6a3e6d1a93815191e93ee6f14bbc74a1ff2a812837","vc_preamble_hash":"f8a8bb23f1bbc4c4cf6a6d42dbbd75a3002f86a2ef5988d53a7350104e34dc6c","description_normalized_hash":"80d18f40a2606e437fad1d6c700c1e104f3ba659ef212891ce811e54265a0355","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn add_two_numbers(l1: &Vec<u32>, l2: &Vec<u32>) -> (result: Vec<u32>)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_advanced_60_task","vc-description":"This task requires writing a Verus method that takes a list of natural numbers and partitions it into two separate lists: one containing all the even numbers and the other containing all the odd numbers. The order of elements in each sublist should match their appearance in the original list. Assume there are no duplicates in the input.\n\nInput:\nThe input consists of a single list with no duplicate natural numbers:\n- nums: A list of natural numbers (nat)\n\nOutput:\nThe output is a tuple of two lists:\n- The first list contains all even numbers from the input list, in order.\n- The second list contains all odd numbers from the input list, in order.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn partition_evens_odds(nums: &Vec<nat>) -> (result: (Vec<nat>, Vec<nat>))\n    requires true,\n    ensures ({\n        let evens = result.0;\n        let odds = result.1;\n        &&& evens@ + odds@ == nums@.filter(|n: nat| n % 2 == 0) + nums@.filter(|n: nat| n % 2 == 1)\n        &&& forall|i: int| 0 <= i < evens.len() ==> evens[i] % 2 == 0\n        &&& forall|i: int| 0 <= i < odds.len() ==> odds[i] % 2 == 1\n    }),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"84489aeed48f0601bbd0e0674ccd08717109db115808222c94e8a6a45b315943","vc_description_hash":"a18ec47fea6ba77263b386e1f25a15d502e8a7088c808400a2b6dd3dac933d76","vc_spec_hash":"964f51b498ba5f4db6c060e7c9f6f6cbe9206065d469149c77fe32001501f418","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"c1909a8b20c46ce63e01f8cde6fd0aef3412aa796c38f86654032bdcdc8d301f","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn partition_evens_odds(nums: &Vec<nat>) -> (result: (Vec<nat>, Vec<nat>)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_advanced_61_task","vc-description":"This task requires writing a Verus function that takes a list of integers and returns a new list. For each index i in the input list, the output at i is equal to the product of all numbers in the list except the number at index i. The solution must run in O(n) time without using the division operation.\n\nThe input is a list of integers. For example, [1,2,3,4].\n\nThe output is a list of integers where each element at index i is the product of every input element except the one at that index. For example, for the input [1,2,3,4], the output should be [24,12,8,6]. Each intermediate product is guaranteed to fit in a 32-bit integer.\n\n/* Helper: Product of a sequence of integers */","vc-preamble":"use vstd::prelude::*;\n\nverus! {\n\nspec fn list_product(nums: Seq<i32>) -> int\n    decreases nums.len()\n{\n    if nums.len() == 0 { 1int } else { nums[0] as int * list_product(nums.subrange(1, nums.len() as int)) }\n}","vc-helpers":"","vc-spec":"fn product_except_self(nums: &Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        result.len() == nums.len(),\n        forall|i: int| 0 <= i < nums.len() ==> \n            result[i] as int == list_product(nums@.subrange(0, i)) * list_product(nums@.subrange(i + 1, nums.len() as int)),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"38902e9e82e808428c45709d21b30d112ab083137e66cab8b1a86fddcd599a4a","vc_description_hash":"a71cc19d73873dba1ad620f1e27bb1046ce72509929d950b178b6d1afc4344e3","vc_spec_hash":"62bba3e05e9021ce2b5bd6d62373bf419d80a198d5422c7b4491969e11696be4","vc_preamble_hash":"c791f9f719fbd3f4285593351e14f53b2e44bd1be88dda6e5ab00413e6a6b5ba","description_normalized_hash":"bcaafc5c36cf11f04422aabde9339ea6584ad0b06d3b0b1d03d424529cd290ad","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn product_except_self(nums: &Vec<i32>) -> (result: Vec<i32>)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_advanced_62_task","vc-description":"This task requires writing a Verus method that calculates how much rainwater would be trapped by a terrain represented as an array of heights. Imagine rainwater falls onto a terrain with varying elevation levels. The water can only be trapped between higher elevation points.\n\nGiven an array of non-negative integers representing the elevation map where the width of each bar is 1 unit, calculate how much water can be trapped after it rains.\n\nInput:\nThe input consists of one array:\nheights: An array of non-negative integers representing elevation levels.\n\nOutput:\nThe output is an integer:\nReturns the total amount of rainwater that can be trapped.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn rain(heights: &Vec<i32>) -> (result: i32)\n    requires forall|i: int| 0 <= i < heights.len() ==> heights[i] >= 0,\n    ensures \n        result >= 0,\n        heights.len() < 3 ==> result == 0,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"b090881d841c3b211ac6e570c2408a10723bd4caf3ceb6a059169ce29c182c51","vc_description_hash":"e8a060de7d2d27548a376b40439ce1e0eecd6f3c443c7c6af2d4992eb1ea6c13","vc_spec_hash":"d6904d473cb0095302d4dd673c00d8ef9b789317393fc4d802e0c88e729e2aea","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"c95762811db4deb8e8a0cdc06186fab8ae310892470c116d8cbb10b0fe229e53","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn rain(heights: &Vec<i32>) -> (result: i32)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_advanced_63_task","vc-description":"This task requires writing a Verus method that counts the unique elements from a sorted array.\n\n-----Input-----\nThe input is a single list of integers:\nnums: An array of integers sorted in non-decreasing order.\n\n-----Output-----\nThe output is a single integer:\nReturns the number of unique elements (k).\n\n/* \n    -- Invalid Inputs\n    [\n        {\n            \"input\": {\n                \"nums\": \"[3, 2, 1]\"\n            }\n        }\n    ]\n    -- Tests\n    [\n        {\n            \"input\": {\n                \"nums\": \"[1, 1, 2]\"\n            },\n            \"expected\": 2,\n            \"unexpected\": [\n                1,\n                3\n            ]\n        },\n        {\n            \"input\": {\n                \"nums\": \"[0, 0, 1, 1, 1, 2, 2, 3, 3, 4]\"\n            },\n            \"expected\": 5,\n            \"unexpected\": [\n                4,\n                10\n            ]\n        },\n        {\n            \"input\": {\n                \"nums\": \"[-1, -1, 0, 1, 2, 2, 3]\"\n            },\n            \"expected\": 5,\n            \"unexpected\": [\n                3\n            ]\n        },\n        {\n            \"input\": {\n                \"nums\": \"[1, 2, 3, 4, 5]\"\n            },\n            \"expected\": 5,\n            \"unexpected\": [\n                4\n            ]\n        },\n        {\n            \"input\": {\n                \"nums\": \"[1, 1, 1, 1]\"\n            },\n            \"expected\": 1,\n            \"unexpected\": [\n                2,\n                4\n            ]\n        },\n        {\n            \"input\": {\n                \"nums\": \"[]\"\n            },\n            \"expected\": 0,\n            \"unexpected\": [\n                1\n            ]\n        },\n        {\n            \"input\": {\n                \"nums\": \"[1]\"\n            },\n            \"expected\": 1,\n            \"unexpected\": [\n                0,\n                2\n            ]\n        },\n        {\n            \"input\": {\n                \"nums\": \"[-100, -100, -100]\"\n            },\n            \"expected\": 1,\n            \"unexpected\": [\n                2,\n                3\n            ]\n        },\n        {\n            \"input\": {\n                \"nums\": \"[-100, -99, -99, -50, 0, 0, 100, 100]\"\n            },\n            \"expected\": 5,\n            \"unexpected\": [\n                6,\n                7\n            ]\n        },\n        {\n            \"input\": {\n                \"nums\": \"[-1, 0, 0, 0, 1, 2, 2, 3, 4, 4, 5]\"\n            },\n            \"expected\": 7,\n            \"unexpected\": [\n                6,\n                10\n            ]\n        },\n        {\n            \"input\": {\n                \"nums\": \"[100, 100, 100, 101, 102, 102, 103, 104, 105, 105]\"\n            },\n            \"expected\": 6,\n            \"unexpected\": [\n                5,\n                7\n            ]\n        }\n    ]\n    */","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn remove_duplicates(nums: &Vec<i32>) -> (result: usize)\n    requires forall|i: int, j: int| 0 <= i < j < nums.len() ==> nums[i] <= nums[j],\n    ensures result <= nums.len(),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"84a3b636ed8cc994b39907c8e97f54ac0f9828a62e669889163e3ff8280271a4","vc_description_hash":"9b4809a855708e8c4031303b4a9975be8f389bb3b81699edeb0e0d790cdae235","vc_spec_hash":"bbeb3afc62a70f3291892e2718bb272187db6a21927f51aa00dd36e0150cdbcc","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"6fe68c7ca399880c3076cf104cb4b37499f4b8cf49607b3323c8c970773f71e2","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn remove_duplicates(nums: &Vec<i32>) -> (result: usize)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_advanced_64_task","vc-description":"This task requires writing a Verus method that removes all occurrences of a given element from a list of natural numbers. The method should return a new list that contains all the elements of the original list except those equal to the target number. The order of the remaining elements must be preserved.\n\n-----Input-----\nThe input consists of two elements:\nlst: A list of natural numbers (Vec<nat>).\ntarget: A natural number to be removed from the list.\n\n-----Output-----\nThe output is a list of natural numbers:\nReturns a new list with all occurrences of the target number removed. The relative order of the remaining elements must be the same as in the input list.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn remove_element(lst: &Vec<nat>, target: nat) -> (result: Vec<nat>)\n    ensures\n        forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i] != target,\n        forall|i: int| 0 <= i < result.len() ==> \n            exists|j: int| 0 <= j < lst.len() && #[trigger] lst[j] == #[trigger] result[i] && lst[j] != target,\n        forall|i: int, j: int| 0 <= i < j < lst.len() && lst[i] != target && lst[j] != target ==> \n            exists|k1: int, k2: int| 0 <= k1 < k2 < result.len() && \n            result[k1] == lst[i] && result[k2] == lst[j],","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"27046c72ab45bb8321f0cc19d3f55254fe0921e17d20ecd0aa081eaa337234c4","vc_description_hash":"eb76995908d04bc28da5897b9764209156bfe30d4d89eb5824e3c411b9a1b211","vc_spec_hash":"b6c5628696c430b2747a912f8a4797cb5cc312bde18bfb4f9241ce7b93a14c1d","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"20c32fb061e86a9bf85a15b8715cd630ddfa1e30d9d43eeebf3fd5fa4b8fce70","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn remove_element(lst: &Vec<nat>, target: nat) -> (result: Vec<nat>)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_advanced_65_task","vc-description":"This task requires writing a Verus method that reverses a given string. The method should return a new string which consists of the characters of the input string in reverse order.\n\n-----Input-----\nThe input consists of:\ns: A string (which may be empty).\n\n-----Output-----\nThe output is a string:\nReturns a string where the characters are in reverse order from the original input.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn reverse_string(s: &Vec<char>) -> (result: Vec<char>)\n    ensures\n        result@.len() == s@.len(),\n        forall|i: int| 0 <= i < s@.len() ==> result@[i] == s@[s@.len() - 1 - i],","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"f8a53a007644c8d82b664ca72c89a1dd3189772450f222126feea1cb81ebf3bc","vc_description_hash":"e791e2cdd4efb9387962e69228fa14e6589a8a6c624f31388a24e06fce83bec8","vc_spec_hash":"ec0175027e1ab95acd6bc143540a7dc257f3f46e46989d9d50bd80effb628d30","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"b6f754fd2db0fee2eafb4c5b4c63b455298a3d26e68586d5547209278c9fde9a","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn reverse_string(s: &Vec<char>) -> (result: Vec<char>)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_advanced_66_task","vc-description":"Given an input string \"words_str\", this task requires writing a Verus function that reverses the order of its words. A word is defined as a contiguous sequence of non-space characters. The function must remove any extra spaces so that the output string contains words separated by a single space and has no leading or trailing spaces. The characters within each word must stay the same as the original input.\n\n-----Input-----\nwords_str: A string that may contain leading, trailing, or multiple spaces between words.\n\n-----Output-----\nA string with the words from the input reversed, where words are separated by a single space, with no extra spaces at the beginning or end.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn reverse_words(words_str: &str) -> (result: String)","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"1904ca84b12024a2961103067ce1f733e7400adc28b2f29fa0e2098a702681e8","vc_description_hash":"57ef0837fcdbd625d79ddf9e92b94f59708eb3e1f2f07aa9a729f34ffbbeab18","vc_spec_hash":"744ac229d3379753401023fbe3203ad5c0a6b5139408b3badbe173259bd5aa6b","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"78241dabf7eb267aaafa1d339fe6f8fbbde5ae66013c2873af6cd5123cf73168","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn reverse_words(words_str: &str) -> (result: String)","has_requires":false,"has_ensures":false,"precondition_count":0,"postcondition_count":0}}}
{"id":"verina_advanced_67_task","vc-description":"This task requires writing a Verus method that performs run-length encoding on a given string. The method should scan the string from left to right and group consecutive identical characters into pairs. Each pair consists of the character itself and the number of times it appears consecutively. For example, \"aaabbc\" becomes [('a', 3), ('b', 2), ('c', 1)].\n\nThe resulting encoded list must satisfy the following properties:\n1. No pair has a zero or negative run-length.\n2. Consecutive pairs in the encoding list must not have the same character.\n3. Decoding the output should return the original string.\n\n-----Input-----\nThe input is a single string, `s`.\n\n-----Output-----\nThe output is a list of pairs `(Char, Nat)`, which represents the run-length-encoded form of the input string.","vc-preamble":"use vstd::prelude::*;\n\nverus! {\n\nspec fn decode_rle(lst: Vec<(char, usize)>) -> Seq<char> {\n    Seq::empty()\n}","vc-helpers":"","vc-spec":"fn run_length_encode(s: &Vec<char>) -> (result: Vec<(char, usize)>)\n    ensures\n        forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i].1 > 0,\n        forall|i: int| 0 <= i < result.len() ==> i + 1 < result.len() ==> #[trigger] result[i].0 != result[i + 1].0,\n        decode_rle(result) == s@,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"09bbd8dbe43be84890d86bc4fe358b9afc0cb5345368a96a7fdbcaf5d35ac1b2","vc_description_hash":"af158f25b155ecf1d5ea8ff4784dc4655b9920d9b5624955f077354e5306e872","vc_spec_hash":"e0930337e2c7ffa7c5dc62520cd7f2d2fc938dc73091b45c15c2717ba4fbef5d","vc_preamble_hash":"3cc43b1f878baffb7eb8c599128102488f2fb255b67e5397708f19694c0f2903","description_normalized_hash":"515723302fab3fa95c205757aebf5af258ed4b061c9e7c50c9a8979cc177e098","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn run_length_encode(s: &Vec<char>) -> (result: Vec<(char, usize)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_advanced_68_task","vc-description":"This task requires implementing a Run-Length Encoding (RLE) algorithm in Verus. The method should take a string as input and return a compressed string where consecutive duplicate characters are replaced by the character followed by its count. The output must strictly alternate between characters and digits, reconstruct to the original input when decoded, and return a non-empty string if and only if the input is non-empty.\n\nInput: The input is a string consisting of any characters (including special characters and digits).\n\nOutput: The output is a string where each sequence of identical characters is replaced by the character followed by its count. The output must:\n1. Alternate between characters and digits (e.g., \"a3b2\").\n2. Reconstruct to the original input when decoded.\n3. Be non-empty if and only if the input is non-empty.\n\n// Non-empty check: input is empty iff result is empty\n\n// Format validation: result alternates between characters and digits","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"spec fn is_digit(c: char) -> bool {\n    '0' <= c && c <= '9'  \n}\n\nproof fn run_length_encoder_property(input: String, result: String)\n    requires\n\n        input@ == Seq::<char>::empty() <==> result@ == Seq::<char>::empty(),\n\n        (result@.len() > 0 ==> (\n            forall|i: int| 0 <= i < result@.len() ==> \n                (i % 2 == 0 ==> !is_digit(result@[i])) &&\n                (i % 2 == 1 ==> is_digit(result@[i]))\n        )),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"192c23b4cecf49abd60f3518ffdd63683a6a97bd4894503620615e7af243fa2c","vc_description_hash":"2128cab213a0f3bf052e5b86002c1b6cf7c4e29cdd2414dea91481df923c6bdf","vc_spec_hash":"a907617e36b6402277f296d71126ca3c3bbfbddc9bef3cb2628d556e8e90118d","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"867c34ef55274f4c2d329e79dd7d31ba11539267d8e0c72e7301f4e24f94008f","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"","has_requires":true,"has_ensures":false,"precondition_count":1,"postcondition_count":0}}}
{"id":"verina_advanced_69_task","vc-description":"Given a sorted list of distinct integers and a target value, return the index if the target is found. If it is not found, return the index where it would be inserted to maintain the sorted order.\n\nThis function must preserve the sorted property of the list. The list is assumed to be strictly increasing and contain no duplicates.\n\n-----Input-----\nxs : List Int \u2014 a sorted list of distinct integers in increasing order\ntarget : Int \u2014 the integer to search for\n\n-----Output-----\nA natural number (Nat) representing the index at which the target is found, or the index at which it should be inserted to maintain sorted order.\n\n/* Invalid Inputs\n    [\n        {\n            \"input\": {\n                \"xs\": \"[2, 1]\",\n                \"target\": 5\n            }\n        },\n        {\n            \"input\": {\n                \"xs\": \"[1, 1]\",\n                \"target\": 2\n            }\n        }\n    ]\n    -- Tests\n    [\n        {\n            \"input\": {\n                \"xs\": \"[1, 3, 5, 6]\",\n                \"target\": 5\n            },\n            \"expected\": 2,\n            \"unexpected\": [\n                0,\n                1,\n                3,\n                4\n            ]\n        },\n        {\n            \"input\": {\n                \"xs\": \"[1, 3, 5, 6]\",\n                \"target\": 2\n            },\n            \"expected\": 1,\n            \"unexpected\": [\n                0,\n                2,\n                3\n            ]\n        },\n        {\n            \"input\": {\n                \"xs\": \"[1, 3, 5, 6]\",\n                \"target\": 7\n            },\n            \"expected\": 4,\n            \"unexpected\": [\n                2,\n                3\n            ]\n        },\n        {\n            \"input\": {\n                \"xs\": \"[1, 3, 5, 6]\",\n                \"target\": 0\n            },\n            \"expected\": 0,\n            \"unexpected\": [\n                1,\n                2\n            ]\n        },\n        {\n            \"input\": {\n                \"xs\": \"[]\",\n                \"target\": 3\n            },\n            \"expected\": 0,\n            \"unexpected\": [\n                1\n            ]\n        },\n        {\n            \"input\": {\n                \"xs\": \"[10]\",\n                \"target\": 5\n            },\n            \"expected\": 0,\n            \"unexpected\": [\n                1\n            ]\n        },\n        {\n            \"input\": {\n                \"xs\": \"[10]\",\n                \"target\": 15\n            },\n            \"expected\": 1,\n            \"unexpected\": [\n                0\n            ]\n        }\n    ]\n    */","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn search_insert(xs: &Vec<i32>, target: i32) -> (result: usize)\n    requires forall|i: int, j: int| 0 <= i < j < xs.len() ==> xs[i] < xs[j],\n    ensures\n        result <= xs.len(),\n        forall|i: int| 0 <= i < result ==> xs[i] < target,\n        result < xs.len() ==> target <= xs[result as int],","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"f81ecbe443e0aca6b8b893952faf59a8108df45f66db73e406c4cbee8dbab11d","vc_description_hash":"a5f0bc337351e0729e1a9107e5311dd618aae33872d8e351529c3a1a466ab205","vc_spec_hash":"cbfef76866771975e6468fe5122ab17493102a93205f9c2d9729982771749571","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"76293c8578f0f6523084b15379e6f720f78e18591054c08065b6bfff7dbb0016","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn search_insert(xs: &Vec<i32>, target: i32) -> (result: usize)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_advanced_6_task","vc-description":"This task requires writing a Verus method that determines whether a given string contains all 5 English vowels: a, e, i, o, u.\n\nThe check is case-insensitive, meaning that both uppercase and lowercase vowels count.\n\n-----Input-----\nThe input consists of a string:\ns: A string of alphabetic characters (may include uppercase and lowercase)\n\n-----Output-----\nThe output is true or false:\nReturns true if the input string contains all 5 vowels (a, e, i, o, u), false otherwise.","vc-preamble":"use vstd::prelude::*;\n\nverus! {\n\nspec fn to_lower(c: char) -> char {\n    if 'A' <= c && c <= 'Z' {\n        ((c as int + 32) as char)\n    } else {\n        c\n    }\n}\n\nspec fn normalize_str(s: &str) -> Seq<char> {\n    s.view().map_values(|c| to_lower(c))\n}","vc-helpers":"","vc-spec":"fn all_vowels(s: &str) -> (result: bool)\n    ensures\n        result <==> (\n            normalize_str(s).contains('a') &&\n            normalize_str(s).contains('e') &&\n            normalize_str(s).contains('i') &&\n            normalize_str(s).contains('o') &&\n            normalize_str(s).contains('u')\n        ),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"432b5f2b6a7e5e06de3643a1d01a6bd22701a976d307577be4a88dc0205df6da","vc_description_hash":"9afdf8e6316c5593fd734814e445d2c5c05be2d24c2a8d8b178bf70b388b0aba","vc_spec_hash":"f35dcc325e7d2e5e027f71147accf08f308f759b83b2a73c02ac7f0b2df574c2","vc_preamble_hash":"c357dfd3f16cf5eb33f3778485769ac5c6638af6e0169cf4c9a1bfc414c1de4f","description_normalized_hash":"0c56198944cdb4720863c8e319739d7b1ee9ac88c2ffbbae96b51e61e7d8022b","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn all_vowels(s: &str) -> (result: bool)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_advanced_70_task","vc-description":"This task requires writing a Verus method that's goal is to determine the minimum number of adjacent swaps needed to make the array semi-ordered. You may repeatedly swap 2 adjacent elements in the array. A permutation is called semi-ordered if the first number equals 1 and the last number equals n.\n\nInput:\n\nThe input consists of:\n- nums: A vector of integers.\n\nOutput:\n\nThe output is an integer.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn semi_ordered_permutation(nums: &Vec<i32>) -> (result: i32)\n    ensures \n        result >= 0","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"af6c9ec31206acd9de6a60cf2aad981d346a3d7608325c85ef0cfbb82887a5c3","vc_description_hash":"a33adb9486a96da7e7f40ab5eeadc135e1a6ef765cb255274898b41f7912b083","vc_spec_hash":"a27f899344890fef4bc436740a8a8cef7673843bb8111837dcf0e2c3e36773dc","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"dc1b16eb105098b985580eb19fc5f984e7fdb5dd59c511f88641898867e07011","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn semi_ordered_permutation(nums: &Vec<i32>) -> (result: i32)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_advanced_73_task","vc-description":"This task requires writing a Verus method that finds the first missing natural number in an increasingly sorted list. The method should return the smallest natural number that is not in the list, ensuring that all natural numbers that are smaller is inside the list.\n\n-----Input-----\nThe input consists of a list of natural numbers sorted in increasing order:\nl: The sorted list\n\n-----Output-----\nThe output is a natural number:\nReturns the smallest natural number that is not in the list, which means all natural numbers that are smaller than the returned value should be inside the input list.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn smallest_missing(l: Seq<nat>) -> result: nat;\n    requires forall|i: int, j: int| 0 <= i < j < l.len() ==> l[i] < l[j],\n    ensures\n        !l.contains(result),\n        forall|candidate: nat| candidate < result ==> l.contains(candidate),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"d9705b239dbe7024eab99d3e0bfa831f9d8f0abdfff5c95801af84c07716463b","vc_description_hash":"ee77272e454f5a0e86da2f4bba2dd407206e3080230c096d0eee77fdf5f3171c","vc_spec_hash":"fd71f07106042a94d8168200a123c0b8b8d3e23b9fd7fc8e040ff2daff19a5f2","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"f2d65048bd8ef554cedafd5811bccec3301a7767a75f874bf27c450cbd8a1555","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_advanced_74_task","vc-description":"This task requires writing a Verus function called `solution` that takes a vector of natural numbers `nums`. The function should calculate and return the sum of values obtained for each subarray, where the value for a subarray is the square of the count of distinct elements within that subarray.\n\nInput:\nThe input is a vector of natural numbers:\n`nums`: A vector where each element is a natural number.\nConstraints:\n- The length of the vector `nums` (n) is between 1 and 100 (inclusive).\n- Each element in `nums` is between 1 and 100 (inclusive).\n\nOutput:\nThe output is a natural number:\nReturns the total sum of squared distinct counts for all subarrays.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn solution(nums: Vec<u32>) -> (result: u32)\n    requires\n        1 <= nums.len() <= 100,\n        forall|i: int| 0 <= i < nums.len() ==> #[trigger] nums[i] >= 1 && #[trigger] nums[i] <= 100,\n    ensures\n        result >= 0,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"6aca75d4a259277aedefa8dac11312ab965bf716e9fd1f92edfc46c7e1e93b98","vc_description_hash":"4204d5bea35193a53597539b6e47d0721544010f166ff90881227c6c43acea25","vc_spec_hash":"d000ab4a0189ab481153033f6857248a8350997a761d07579327ddb7d49d0498","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"c3c346b652cb630812a81f66d68d79d7a09d511814243dc20b10afefeb9d10fb","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn solution(nums: Vec<u32>) -> (result: u32)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_advanced_75_task","vc-description":"Given a sequence of n integers, your task is to find the largest sum obtainable by choosing a contiguous subarray of the sequence. At least one number must be selected.\n\nThe algorithm uses dynamic programming (Kadane's Algorithm) to solve the problem:\n1. Initialize the current maximum (cur) and the overall maximum (maxSoFar) with the first element.\n2. For each subsequent element, update:\n     cur = max(element, cur + element)\n     maxSoFar = max(maxSoFar, cur)\n3. Return maxSoFar as the answer.\n\nInput:\nThe input is provided as a list of integers:\n  sequence: A list of n integers.\n\nOutput:\nThe output is a single integer representing the maximum subarray sum.\n\n/* \n    -- Invalid Inputs\n    []\n    -- Tests\n    [\n        {\n            \"input\": {\n                \"sequence\": \"[10, -4, 3, 1, 5, 6, -35, 12, 21, -1]\"\n            },\n            \"expected\": 33,\n            \"unexpected\": [\n                32,\n                34,\n                0\n            ]\n        },\n        {\n            \"input\": {\n                \"sequence\": \"[2, 1, -4, 3, 4, -4, 6, 5, -5, 1]\"\n            },\n            \"expected\": 14,\n            \"unexpected\": [\n                13,\n                15,\n                0\n            ]\n        },\n        {\n            \"input\": {\n                \"sequence\": \"[-1, -2, -3, -4, -5]\"\n            },\n            \"expected\": -1,\n            \"unexpected\": [\n                -2,\n                0,\n                1\n            ]\n        },\n        {\n            \"input\": {\n                \"sequence\": \"[7]\"\n            },\n            \"expected\": 7,\n            \"unexpected\": [\n                0,\n                1,\n                -7\n            ]\n        },\n        {\n            \"input\": {\n                \"sequence\": \"[1, 2, 3, 4, 5]\"\n            },\n            \"expected\": 15,\n            \"unexpected\": [\n                14,\n                16,\n                0\n            ]\n        }\n    ]\n    */","vc-preamble":"use vstd::prelude::*;\n\nverus! {\n\nspec fn spec_subarray_sum(sequence: Seq<i32>, start: int, end: int) -> int\n    decreases end - start\n{\n    if start >= end || start < 0 || end > sequence.len() {\n        0\n    } else if start + 1 == end {\n        sequence[start] as int\n    } else {\n        sequence[start] as int + spec_subarray_sum(sequence, start + 1, end)\n    }\n}","vc-helpers":"","vc-spec":"fn task_code(sequence: Vec<i32>) -> (result: i32)\n    requires sequence.len() > 0,\n    ensures \n        exists|start: int, end: int| \n            0 <= start < end <= sequence.len() && \n            result as int == spec_subarray_sum(sequence@, start, end) &&\n            forall|s: int, e: int| (0 <= s < e <= sequence.len()) ==> \n                spec_subarray_sum(sequence@, s, e) <= result as int,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"f18a5a200c5332cf3ae8f51423233d4cfa11940e691155dccf67417b9f700acf","vc_description_hash":"ebacb2a0812752fcb9c5ba7c2da054ae781ea1738f5e77437d74c2e95e03a054","vc_spec_hash":"942e66f61897476d80622a8a8b3a8173cbafe21c9a739a40b2e93bdcf63e02ea","vc_preamble_hash":"12e6c17e1714547bbf6acbf42aecd2345132797c0e7ec8c28b5d2b138fb80455","description_normalized_hash":"26b866dff27d940e67f54fea623bab210de97270fa406de2a2dcc260a049fd34","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn task_code(sequence: Vec<i32>) -> (result: i32)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_advanced_76_task","vc-description":"This task requires writing a Verus method that returns the k most frequent elements from a list of integers. The method should count the frequency of each distinct element in the list and return the k elements with the highest frequency.\n\n-----Input-----\nThe input consists of two values:\nnums: A list of integers, possibly with duplicates.\nk: A natural number indicating how many of the most frequent elements to return. Assuming k <= # of distinct elements in nums.\n\n-----Output-----\nThe output is a list of integers:\nReturns exactly k integers representing the elements that appear most frequently in the input list in the order from the higher frequency to lower frequency.\nIf two numbers have the same frequency, use the order of the first occurrence in nums.\n\n/*\n    -- Invalid Inputs\n    [\n        {\n            \"input\": {\n                \"nums\": \"[1, 2, 3]\",\n                \"k\": 4\n            }\n        }\n    ]\n    -- Tests\n    [\n        {\n            \"input\": {\n                \"nums\": \"[1, 1, 1, 2, 2, 3]\",\n                \"k\": 2\n            },\n            \"expected\": \"[1, 2]\",\n            \"unexpected\": [\n                \"[1, 3]\",\n                \"[2, 3]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"nums\": \"[4, 1, -1, 2, -1, 2, 3]\",\n                \"k\": 2\n            },\n            \"expected\": \"[-1, 2]\",\n            \"unexpected\": [\n                \"[-1, 4]\",\n                \"[4, 3]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"nums\": \"[5]\",\n                \"k\": 1\n            },\n            \"expected\": \"[5]\",\n            \"unexpected\": [\n                \"[]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"nums\": \"[7, 7, 7, 8, 8, 9]\",\n                \"k\": 1\n            },\n            \"expected\": \"[7]\",\n            \"unexpected\": [\n                \"[8]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"nums\": \"[]\",\n                \"k\": 0\n            },\n            \"expected\": \"[]\",\n            \"unexpected\": [\n                \"[0]\"\n            ]\n        }\n    ]\n    */","vc-preamble":"use vstd::prelude::*;\nuse vstd::seq_lib::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn top_k_frequent(nums: &Vec<i32>, k: usize) -> (result: Vec<i32>)\n    requires \n        k <= nums@.to_set().len(),\n    ensures\n        result.len() == k,\n        forall|x: i32| result@.contains(x) ==> nums@.contains(x),\n        result@.no_duplicates(),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"6922698987a80bddaaa5918bdf07439d3d66f768b2d7b0a98bea198f30158733","vc_description_hash":"87419776de2c1bc080a120f4dd789a1ce8a8d17fd62e669f7e4dced143919350","vc_spec_hash":"25a7838f607ca21b7cd841b2faa0bb58813fb286292d813e49f04da011e148d1","vc_preamble_hash":"3c13a8ac2e202d229ded977abb67e4fee79c1cf736fbcd53a6c7b6fbe0471f07","description_normalized_hash":"c647e0ceff3793be0de66730872ef98e4fe4092cd9fb51fd1b15d682989373ec","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn top_k_frequent(nums: &Vec<i32>, k: usize) -> (result: Vec<i32>)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_advanced_77_task","vc-description":"This task requires writing a Verus function that calculates how much water can be trapped between elevations after it rains. The input is a vector of non-negative integers representing an elevation map. Each index traps water depending on the min of max heights to its left and right.\n\nInput:\n- height: A vector of natural numbers representing elevations.\n\nOutput:\n- A natural number: total units of water that can be trapped.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn trap_rain_water(height: &Vec<usize>) -> (result: usize)\n    requires height.len() >= 0,\n    ensures result >= 0,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"b1924c2a63911d9506f656b62b458123c420aad40c780fca53835a07738b9650","vc_description_hash":"03757b556d11f08178c1f2808889e838e1211a037cf6b9650ea333a83e157169","vc_spec_hash":"2101eb72fccd03d8e811f10535577a0ddb9cc3a7bd97e1015e81846c1fdce776","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"9c9a26ba1f62e18eadac27f3c1e588f2225e81b2d0d7eae6fc5c40e50a36ce0d","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn trap_rain_water(height: &Vec<usize>) -> (result: usize)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_advanced_78_task","vc-description":"This task requires writing a Verus method that solves the Two Sum problem. Given a list of integers and a target integer, the method must return a pair of indices such that the sum of the numbers at those indices equals the target. You may assume that each input has exactly one solution and that you may not use the same element twice. The answer should be returned with first index is smaller than the second.\n\n-----Input-----\nThe input consists of:\n- nums: A list of integers.\n- target: An integer representing the target sum.\n\n-----Output-----\nThe output is a pair (tuple) of integers representing the indices of the two numbers in the input list that add up to the target.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn two_sum(nums: &Vec<i32>, target: i32) -> (result: (usize, usize))\n    requires\n        nums.len() > 1,\n        exists|i: int, j: int| 0 <= i < j < nums.len() && nums[i] + nums[j] == target,\n    ensures\n        result.0 < result.1,\n        result.0 < nums.len(),\n        result.1 < nums.len(),\n        nums[result.0 as int] + nums[result.1 as int] == target,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"edcaab8a6b132fe375f73c2cf1996623c2ccc3df4cfeaed0176b22f9073d2546","vc_description_hash":"e2cd65cea9057fba7034dbf9325b00fbdd4feadbb02dcede278dbf1d1aee34a9","vc_spec_hash":"799a9ad7723cdf94ecc448092f04971c5627dcfbdfa7dfbd3add874ca89af9d3","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"d076ebb41d28aa8de89dbec0092f2c22b43634c248ea276e48cc4709d786f175","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn two_sum(nums: &Vec<i32>, target: i32) -> (result: (usize, usize)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_advanced_79_task","vc-description":"This task requires writing a Verus method that implementing the \"Two Sum\" problem. Given a list of integers\nand a target integer, the function should return the indices of the two numbers that add up to\nthe target. If no valid pair exists, the function should return none. And the indices returned must\nbe within the bounds of the list. If multiple pair exists, return the first pair.\n\n-----Input-----\n- nums: A list of integers.\n- target: An integer representing the target sum.\n\n-----Output-----\n- An option type containing a pair of natural numbers (indices) such that\n  nums[i] + nums[j] = target, if such a pair exists. Otherwise, it returns none.\n\n/*\n    -- Tests\n    [\n        {\n            \"input\": {\n                \"nums\": \"[2, 7, 11, 15]\",\n                \"target\": 9\n            },\n            \"expected\": \"some (0, 1)\",\n            \"unexpected\": [\n                \"some (1, 2)\",\n                \"none\"\n            ]\n        },\n        {\n            \"input\": {\n                \"nums\": \"[3, 2, 4]\",\n                \"target\": 6\n            },\n            \"expected\": \"some (1, 2)\",\n            \"unexpected\": [\n                \"some (0, 2)\",\n                \"none\"\n            ]\n        },\n        {\n            \"input\": {\n                \"nums\": \"[3, 3]\",\n                \"target\": 6\n            },\n            \"expected\": \"some (0, 1)\",\n            \"unexpected\": [\n                \"some (1, 1)\",\n                \"none\"\n            ]\n        },\n        {\n            \"input\": {\n                \"nums\": \"[1, 2, 3]\",\n                \"target\": 7\n            },\n            \"expected\": \"none\",\n            \"unexpected\": [\n                \"some (0, 2)\"\n            ]\n        },\n        {\n            \"input\": {\n                \"nums\": \"[0, 4, 3, 0]\",\n                \"target\": 0\n            },\n            \"expected\": \"some (0, 3)\",\n            \"unexpected\": [\n                \"some (1, 2)\",\n                \"none\"\n            ]\n        }\n    ]\n    */","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn two_sum(nums: Vec<i32>, target: i32) -> (result: Option<(usize, usize)>)\n    ensures\n        match result {\n            None => {\n                forall|i: int, j: int| 0 <= i < nums.len() && 0 <= j < nums.len() && i != j ==> nums[i] + nums[j] != target\n            },\n            Some((i, j)) => {\n                i < j &&\n                j < nums.len() &&\n                nums[i as int] + nums[j as int] == target &&\n                forall|k1: int, k2: int| 0 <= k1 < nums.len() && 0 <= k2 < nums.len() && k1 < k2 && (k1 < i || (k1 == i && k2 < j)) ==> nums[k1] + nums[k2] != target\n            }\n        },","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"7794ff8fe31a04387d218100ff5731969d61dcc909621ba0f9ba9adda4628b4e","vc_description_hash":"2c584da7e733dc042891015693f62f3922096d9d4d3b28341cce5f0c5f8b2d24","vc_spec_hash":"b91f4b83191520df1319746ce4afcb1bc01ece81851070b961bbb26335f94a1e","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"b617b94a35e59e23f7c4fc10b47fb6a61b687c5be5667a4ae29f5b47e7c88ca3","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn two_sum(nums: Vec<i32>, target: i32) -> (result: Option<(usize, usize)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_advanced_80_task","vc-description":"This task requires writing a Verus method that finds the indices of two numbers in an array that add up to a target value. Given an array of integers and a target integer, the function should return the indices of the two numbers such that they add up to the target.\n\nYou may assume that each input has exactly one solution, and you may not use the same element twice.\n\n-----Input-----\nThe input consists of:\nnums: An array of integers.\ntarget: An integer representing the target sum.\n\n-----Output-----\nThe output is an array of two integers:\nReturns the indices of the two numbers in the array that add up to the target. The indices should be sorted.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn two_sum(nums: &Vec<i32>, target: i32) -> (result: Vec<usize>)\n    requires \n        nums.len() >= 2,\n        exists|i: int, j: int| 0 <= j < i < nums.len() && nums[i] + nums[j] == target,\n        forall|i1: int, j1: int, i2: int, j2: int| \n            (0 <= j1 < i1 < nums.len() && nums[i1] + nums[j1] == target &&\n             0 <= j2 < i2 < nums.len() && nums[i2] + nums[j2] == target) ==> \n            (i1 == i2 && j1 == j2),\n    ensures\n        result.len() == 2,\n        result[0] < nums.len(),\n        result[1] < nums.len(),\n        result[0] < result[1],\n        nums[result[0] as int] + nums[result[1] as int] == target,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"a40c4ffe66de12f22c5e35eaed121cd114f4f136c358d9e405ddd6fb60e1cb2a","vc_description_hash":"93742e5ffa3b1828e1b6a8df5360e4858dd2f562e6c61093f69516a2e31e62d3","vc_spec_hash":"785bdfe658e081d4715713b26660813a88cbb7e7530d2b7c3139c79bc3a0e91d","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"6761eda0f722a0ec9a5fbb9d0804c47968042769b90d662ce80c46bb17f0e359","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn two_sum(nums: &Vec<i32>, target: i32) -> (result: Vec<usize>)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_advanced_81_task","vc-description":"Implement a Verus function that, given a list of integers, removes all duplicates and returns the resulting list in ascending order.\n\nInput:\nThe input consists of a single list of integers:\narr: A list of integers.\n\nOutput:\nThe output is a list of integers:\nReturns a list containing the unique elements of the input, sorted in ascending order. The returned list must not contain any duplicates, and every element in the output must appear in the original input list.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn unique_sorted(arr: &Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        result.len() <= arr.len(),\n        forall|i: int| 0 <= i < result.len() - 1 ==> #[trigger] result[i] <= result[i + 1],\n        forall|x: i32| arr@.contains(x) <==> result@.contains(x),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"f3e16bc2e9026d472b55e126cb32b90e780384cc000913cbc78ba234cb408842","vc_description_hash":"91f4c5469f4b7691dd107d0d7e3c219e61cb3f2454df2fa5faddcb67c6671a73","vc_spec_hash":"d876b28b2a5b7f21157c891c3395a5d6bea8504948042d25983a8a2c6d7264af","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"a3563bdbc02f648305145e7d0e7febfb1f66cecc5dfba56289ce51a864c7b3bf","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn unique_sorted(arr: &Vec<i32>) -> (result: Vec<i32>)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_advanced_8_task","vc-description":"This task requires writing a Verus method that determines whether it is possible to complete a circular journey around a set of gas stations. Each gas station provides a certain amount of gas, and traveling from one station to the next consumes a certain amount of gas.\n\nYou start the journey at one of the gas stations with an empty tank. The goal is to find the starting station's index that allows completing the entire circuit once in the clockwise direction without running out of gas. If such a station exists, return its index. Otherwise, return -1.\n\nIf multiple solutions exist, return the one with the smallest starting gas station index.\n\nInput:\nThe input consists of two arrays:\n\ngas: An array of integers where gas[i] represents the amount of gas available at the ith station.\n\ncost: An array of integers where cost[i] is the amount of gas required to travel from station i to station i + 1.\n\nOutput:\nThe output is an integer:\nReturns the index of the starting gas station that allows a complete trip around the circuit. If it is not possible to complete the circuit, return -1.","vc-preamble":"use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_starting_point(gas: &Vec<i32>, cost: &Vec<i32>, start: int) -> bool \n{\n    0 <= start < gas.len() && \n    forall|i: int| 0 <= i < gas.len() ==> {\n        #[trigger] calculate_acc(gas, cost, start, i + 1) >= 0\n    }\n}\n\nspec fn calculate_acc(gas: &Vec<i32>, cost: &Vec<i32>, start: int, steps: int) -> int\n    decreases steps\n{\n    if steps <= 0 {\n        0\n    } else {\n        let prev_acc = calculate_acc(gas, cost, start, steps - 1);\n        let jdx = ((start + (steps - 1)) % (gas.len() as int)) as nat % (gas.len() as nat);\n        prev_acc + gas[jdx as int] - cost[jdx as int]\n    }\n}","vc-helpers":"","vc-spec":"fn can_complete_circuit(gas: &Vec<i32>, cost: &Vec<i32>) -> (result: i32)\n    requires \n        gas.len() == cost.len(),\n        gas.len() > 0,\n    ensures\n        (result == -1) ==> (forall|start: int| 0 <= start < gas.len() ==> !valid_starting_point(gas, cost, start)),\n        (result >= 0) ==> (\n            0 <= result < gas.len() &&\n            valid_starting_point(gas, cost, result as int) &&\n            (forall|start: int| 0 <= start < result ==> !valid_starting_point(gas, cost, start))\n        ),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"76cbc2ce54a882007d42e9e1f711ba2b89a7abb534407538dd2ee9997c289c5c","vc_description_hash":"8a07c9c445a6639adbbed278635e2a8834dc255d78d6fce655007824784e1daf","vc_spec_hash":"906d05d2d85dfaf22462dbbf92a7c28769c32c8a498ba2c34cf20db47f2337c9","vc_preamble_hash":"ce2769d599821391d42e5bd1ef2d42de6dd74cf1efad3044fd9ca863883b1492","description_normalized_hash":"0c0bec009c285445ffc08f05f6c2433ce3940b449be2251198dbe9dc07851834","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn can_complete_circuit(gas: &Vec<i32>, cost: &Vec<i32>) -> (result: i32)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_advanced_9_task","vc-description":"This task requires writing a Verus method of which given a number n and divisor d, it counts all the number that is smaller than\nn whose sum of digits is divisible by d.\n-----Input-----\nThe input consists of two usize:\nn: usize\nd: usize where d > 0\n\n-----Output-----\nThe output is a natural number:\nEnsure this match the count that satisfy the property.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn count_sum_divisible_by(n: usize, d: usize) -> (result: usize)\n    requires d > 0,\n    ensures \n        result <= n,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"51d5292d3c995775806705e669cfaa5d539b5df8f6be1b648f235acae47b268f","vc_description_hash":"9f4c0d77d7e5ff316f3b728067d82c1f8d6f4d0b6806f26f0eb2617186c94c3b","vc_spec_hash":"e6d7dc31a589a9a0963d0bde7b88cd786ef039f1dc576505377403d49fc9d940","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"ce4a523b7a9581adaf698f92021f6b311cbbfe4c4f6c9c09fe0aa8f2e3fdba1b","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn count_sum_divisible_by(n: usize, d: usize) -> (result: usize)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_basic_100_task","vc-description":"This task involves determining the triple of a given integer. The goal is to create a function that, for any integer provided as input, returns a value equal to three times that integer, including handling the case when the input is zero.\n\n-----Input-----\nThe input consists of:\n\u2022 x: An integer.\n\n-----Output-----\nThe output is an integer that represents three times the input integer.\n\u2022 If x = 0, the output will be 0.\n\u2022 Otherwise, the output will be computed as x + 2 * x, which is equivalent to 3 * x.\n\n-----Note-----\nThere are no additional preconditions. It is assumed that x is a valid integer.\n\n/*\n    -- Invalid Inputs\n    []\n    -- Tests\n    [\n        {\n            \"input\": {\n                \"x\": 0\n            },\n            \"expected\": 0,\n            \"unexpected\": [\n                1,\n                -1,\n                10\n            ]\n        },\n        {\n            \"input\": {\n                \"x\": 1\n            },\n            \"expected\": 3,\n            \"unexpected\": [\n                2,\n                4,\n                0\n            ]\n        },\n        {\n            \"input\": {\n                \"x\": -2\n            },\n            \"expected\": -6,\n            \"unexpected\": [\n                -4,\n                -2,\n                6\n            ]\n        },\n        {\n            \"input\": {\n                \"x\": 10\n            },\n            \"expected\": 30,\n            \"unexpected\": [\n                20,\n                40,\n                0\n            ]\n        },\n        {\n            \"input\": {\n                \"x\": -5\n            },\n            \"expected\": -15,\n            \"unexpected\": [\n                -10,\n                -5,\n                15\n            ]\n        }\n    ]\n    */","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn triple(x: i32) -> (result: i32)\n    ensures\n        result / 3 == x,\n        result / 3 * 3 == result,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"7c99db1fc33c7ee37879b065e04792ac38da952d9158edb41c24b8fb0d18a817","vc_description_hash":"fea0ff0e07caa5d42838ebdecf922e843c981db8ca6b51bdfb7a718275624fdb","vc_spec_hash":"7becd9c2db9ad90f05f585c51d2095592a60a1475f0e02b7d59d9b0392f55d20","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"71d8dd412343279feef3d37b3c53f6cbb7416b1b43ef9bc04942f93c5bb63ddf","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn triple(x: i32) -> (result: i32)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_101_task","vc-description":"This problem involves computing the triple of a given integer. The goal is to produce an output that is exactly three times the input value.\n\n-----Input-----\nThe input consists of:\n\u2022 x: An integer representing the value to be tripled.\n\n-----Output-----\nThe output is an integer that is three times the input value (i.e., 3 * x).\n\n-----Note-----\nThe implementation uses a local variable to first compute double the input and then adds the original input to get the final result. The accompanying theorem asserts that the function satisfies the specification of computing 3 * x.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn triple(x: i32) -> (result: i32)\n    ensures\n        result / 3 == x,\n        result / 3 * 3 == result,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"541577f8aacc406e5323532e8fdd71ea68e7a1b65151a6c26d60bdeab6a52ff2","vc_description_hash":"9ebb782d7524110cf8efdc25cd839ab35a8004379b6b2936131b70c97ce44ad9","vc_spec_hash":"7becd9c2db9ad90f05f585c51d2095592a60a1475f0e02b7d59d9b0392f55d20","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"fbfc9536ec8e6349046fded2685a9c63a5e8cf0c519335d4f4a7b05e2a3cf0c8","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn triple(x: i32) -> (result: i32)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_102_task","vc-description":"This task involves identifying the first occurrence of a pair of indices in an array of integers such that the sum of the corresponding elements equals the given target value. The focus is on determining the earliest valid pair (i, j), with 0 \u2264 i < j < nums.size, where the sum of the two numbers equals the target, without considering any language-specific or implementation details.\n\nInput:\nThe input consists of:\n\u2022 nums: An array of integers.\n\u2022 target: An integer representing the desired sum.\n\nOutput:\nThe output is a pair of natural numbers (i, j) that satisfy:\n\u2022 0 \u2264 i < j < nums.size.\n\u2022 nums[i] + nums[j] = target.\n\u2022 Any valid pair with indices preceding (i, j) does not yield the target sum, and no index between i and j forms a valid sum with nums[i].\n\nNote:\nIt is assumed that the array has at least two elements and that there exists at least one valid pair whose sum is equal to the target.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn two_sum(nums: &Vec<i32>, target: i32) -> (result: (usize, usize))\n    requires \n        nums.len() > 1,\n        exists|i: int, j: int| 0 <= i < j < nums.len() && nums[i] + nums[j] == target,\n    ensures\n        result.0 < result.1,\n        result.1 < nums.len(),\n        nums[result.0 as int] + nums[result.1 as int] == target,\n        forall|i: int, j: int| 0 <= i < j < nums.len() && i < result.0 as int ==> nums[i] + nums[j] != target,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"e0ce20fd3078b096e6e1131340b401b2560b826d51e2a2bcc019d0290a6b1ad0","vc_description_hash":"2bcdc5b471e868a78be918950bd19503a14f15aa887f7443bacd79609426f344","vc_spec_hash":"db9d8da8df0e782d366c43bbb2215d0e7ab67a5d9f2eea43bec4bc2dd12ba32a","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"17a5ef21bf8b4c4888fd5497b46f5d9395526614e768e9b28d0614e32e1d4937","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn two_sum(nums: &Vec<i32>, target: i32) -> (result: (usize, usize)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_basic_103_task","vc-description":"This problem involves updating an array of integers by modifying two specific positions. Specifically, the element at index 4 should be increased by 3, and the element at index 7 should be changed to 516. The goal is to correctly update these positions while leaving the rest of the array unchanged. The description assumes that the array contains at least 8 elements.\n\n-----Input-----\nThe input consists of:\n\u2022 a: An array of integers. The array must contain at least 8 elements.\n\n-----Output-----\nThe output is an array of integers that meets the following criteria:\n\u2022 The element at index 4 is updated to its original value plus 3.\n\u2022 The element at index 7 is set to 516.\n\u2022 All other elements in the array remain the same as in the input array.\n\n-----Note-----\nIt is assumed that the input array has a size of at least 8 elements. Indices are 0-indexed.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn update_elements(a: &Vec<i32>) -> (result: Vec<i32>)\n    requires a.len() >= 8,\n    ensures\n        result[4] == a[4] + 3,\n        result[7] == 516,\n        forall|i: int| 0 <= i < a.len() && i != 4 && i != 7 ==> result[i] == a[i],\n        result.len() == a.len(),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"4e5e091e343d124bd9dfef7d21a56d2e4b988659e8045f7f33cba19a275a73b9","vc_description_hash":"922b4909839ae85a76443aa452728463bd3b45ef66d6f2b9405ff71fb11ade48","vc_spec_hash":"9e4268f6d021a8de132def88f1d5dcb72985d12cda91de60e38dddd005a78193","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"516ba5cdba3825e222caea7c0633cc3301f7dc6ddb14e475ecc2a8d9ead2167c","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn update_elements(a: &Vec<i32>) -> (result: Vec<i32>)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_basic_105_task","vc-description":"This task involves computing the element-wise product of two integer arrays. For each position in the arrays, the corresponding numbers are multiplied together. If an element is missing in one of the arrays at a given index, the missing value is treated as 0. When both arrays provide values for every index, the resulting array will contain the product of the two numbers at each corresponding index.\n\n-----Input-----\nThe input consists of two arrays:\n\u2022 a: An array of integers.\n\u2022 b: An array of integers (should be of equal length to a for the specification to hold).\n\n-----Output-----\nThe output is an array of integers that:\n\u2022 Has the same length as the input arrays.\n\u2022 For each index i, the output array contains the product a[i] * b[i].\n\u2022 In cases where one of the arrays might be shorter, missing elements default to 0 during multiplication.\n\n-----Note-----\nIt is assumed that the arrays are of equal length for the theorem specification, although the implementation defaults missing indices to 0.\n\n/*\n    -- Invalid Inputs\n    [\n        {\n            \"input\": {\n                \"a\": \"#[1, 2, 3]\",\n                \"b\": \"#[4, 5]\"\n            }\n        }\n    ]\n    -- Tests\n    [\n        {\n            \"input\": {\n                \"a\": \"#[1, 2, 3]\",\n                \"b\": \"#[4, 5, 6]\"\n            },\n            \"expected\": \"#[4, 10, 18]\",\n            \"unexpected\": [\n                \"#[4, 10, 17]\",\n                \"#[0, 10, 18]\",\n                \"#[4, 10, 20]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"#[0, 0, 0]\",\n                \"b\": \"#[1, 2, 3]\"\n            },\n            \"expected\": \"#[0, 0, 0]\",\n            \"unexpected\": [\n                \"#[1, 0, 0]\",\n                \"#[0, 1, 0]\",\n                \"#[0, 0, 1]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"#[-1, 2, -3]\",\n                \"b\": \"#[3, -4, 5]\"\n            },\n            \"expected\": \"#[-3, -8, -15]\",\n            \"unexpected\": [\n                \"#[-3, -8, -14]\",\n                \"#[-3, -7, -15]\",\n                \"#[-2, -8, -15]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"#[2]\",\n                \"b\": \"#[10]\"\n            },\n            \"expected\": \"#[20]\",\n            \"unexpected\": [\n                \"#[10]\",\n                \"#[0]\",\n                \"#[30]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"#[1, 2, 3, 4]\",\n                \"b\": \"#[2, 2, 2, 2]\"\n            },\n            \"expected\": \"#[2, 4, 6, 8]\",\n            \"unexpected\": [\n                \"#[2, 4, 6, 9]\",\n                \"#[1, 4, 6, 8]\",\n                \"#[2, 5, 6, 8]\"\n            ]\n        }\n    ]\n    */","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn array_product(a: &Vec<i32>, b: &Vec<i32>) -> (result: Vec<i32>)\n    requires a.len() == b.len(),\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> result[i] == a[i] * b[i],","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"941d24625925abe94c6a65012e868bb61f1a04eb22df843ca1ad45c13da25037","vc_description_hash":"32658721ecb7d24abcafc1c69e0de17369076d2a34f4b1befa9bd9d1596f435c","vc_spec_hash":"e78cc6483731237e892c228f9b64bf4cb382580a738bf869876e2b3178692969","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"b32e898d9fd7be215aad8481869bcfa06e919f5a99a26b1ddac0dfb5eeac8222","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn array_product(a: &Vec<i32>, b: &Vec<i32>) -> (result: Vec<i32>)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_basic_106_task","vc-description":"The task is to compute the element-wise sum of two integer arrays. The result should be a new array where each element is the sum of the corresponding elements from the two input arrays. The problem assumes that both arrays have the same length.\n\nInput:\nThe input consists of two parameters:\n\u2022 a: An array of integers.\n\u2022 b: An array of integers.\nNote: Both arrays must have the same length.\n\nOutput:\nThe output is an array of integers that:\n\u2022 Has the same size as the input arrays.\n\u2022 Contains elements where each element at index i is computed as a[i] + b[i] from the input arrays.\n\nNote:\nIt is assumed that the two input arrays have equal lengths.\n\n/*\n    // -- Invalid Inputs\n    // [\n    //     {\n    //         \"input\": {\n    //             \"a\": \"#[1, 2, 3, 4]\",\n    //             \"b\": \"#[5, 6, 7]\"\n    //         }\n    //     }\n    // ]\n    // -- Tests\n    // [\n    //     {\n    //         \"input\": {\n    //             \"a\": \"#[1, 2, 3]\",\n    //             \"b\": \"#[4, 5, 6]\"\n    //         },\n    //         \"expected\": \"#[5, 7, 9]\",\n    //         \"unexpected\": [\n    //             \"#[5, 6, 9]\",\n    //             \"#[4, 7, 9]\"\n    //         ]\n    //     },\n    //     {\n    //         \"input\": {\n    //             \"a\": \"#[0, 0, 0]\",\n    //             \"b\": \"#[0, 0, 0]\"\n    //         },\n    //         \"expected\": \"#[0, 0, 0]\",\n    //         \"unexpected\": [\n    //             \"#[0, 0, 1]\",\n    //             \"#[1, 0, 0]\"\n    //         ]\n    //     },\n    //     {\n    //         \"input\": {\n    //             \"a\": \"#[-1, 2, 3]\",\n    //             \"b\": \"#[1, -2, 4]\"\n    //         },\n    //         \"expected\": \"#[0, 0, 7]\",\n    //         \"unexpected\": [\n    //             \"#[0, 1, 7]\",\n    //             \"#[0, 0, 6]\"\n    //         ]\n    //     },\n    //     {\n    //         \"input\": {\n    //             \"a\": \"#[10]\",\n    //             \"b\": \"#[-10]\"\n    //         },\n    //         \"expected\": \"#[0]\",\n    //         \"unexpected\": [\n    //             \"#[1]\",\n    //             \"#[-1]\"\n    //         ]\n    //     },\n    //     {\n    //         \"input\": {\n    //             \"a\": \"#[100, 200, 300]\",\n    //             \"b\": \"#[100, 200, 300]\"\n    //         },\n    //         \"expected\": \"#[200, 400, 600]\",\n    //         \"unexpected\": [\n    //             \"#[200, 400, 601]\",\n    //             \"#[199, 400, 600]\",\n    //             \"#[200, 399, 600]\"\n    //         ]\n    //     }\n    // ]\n    // */\n\n//","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn array_sum(a: &Vec<i32>, b: &Vec<i32>) -> (result: Vec<i32>)\n    requires a.len() == b.len(),\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> result[i] == a[i] + b[i],","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"42aeae5b95970fcb22e78340806f347165bbca3b31405c06be2fea316cd39d95","vc_description_hash":"aae7f52f5e232f20a9a0aba14d055404b39357b95adf9cd69856c0a31aa7ae15","vc_spec_hash":"6119891261b4817968d822742feb725aa27152d4ef23f4187efd5fcd4a1a2f79","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"01c71bb00ad7beda3474e44614533ad04eddec3d3912775e22f784b614122e06","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn array_sum(a: &Vec<i32>, b: &Vec<i32>) -> (result: Vec<i32>)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_basic_108_task","vc-description":"The problem is about processing a sequence of integer operations to determine cumulative results and identify potential negative outcomes. Given a list of integers, the task is to generate an array where the first element is 0 and each subsequent element is the cumulative sum of the operations performed sequentially. Additionally, the solution should check whether any of these cumulative values (after the initial 0) is negative, and return a corresponding boolean flag.\n\nInput:\nThe input consists of:\n\u2022 operations: A list of integers representing sequential operations.\n\nOutput:\nThe output is a tuple consisting of:\n\u2022 An array of integers representing the partial sums. The array's size is one more than the number of operations, starting with 0 and where for each index i such that 0 \u2264 i < operations.length, the element at index i+1 is equal to the element at index i added to operations[i].\n\u2022 A boolean value that is true if there exists an index i (with 1 \u2264 i \u2264 operations.length) such that the i-th partial sum is negative, and false otherwise.\n\nNote:\nThe function should also correctly handle an empty list of operations.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn below_zero(operations: &Vec<i32>) -> (result: (Vec<i32>, bool))\n    ensures\n        result.0.len() == operations.len() + 1,\n        result.0[0] == 0,\n        forall|i: int| 0 <= i < operations.len() ==> result.0[i + 1] == result.0[i] + operations[i],\n        result.1 == (exists|i: int| 1 <= i < result.0.len() && result.0[i] < 0),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"625e00861f1e051e5e57ed1969871c39f816d81ed2352b84e82fbb6109b7cfe1","vc_description_hash":"a0fa43fec5d7730f6d5d595eb1916efe2f387538bf19c799aa45ec6bd0524dde","vc_spec_hash":"e97865ec334ab4cab14b53941e69c3fd4d2e7ae9d667d1521ed4096eb75cddf0","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"75a80c7b64cb96cb0c853a129ac425cc92b7862d805321fa71636b06b3e181ed","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn below_zero(operations: &Vec<i32>) -> (result: (Vec<i32>, bool)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_10_task","vc-description":"This task requires writing a Verus method that determines if a given integer is strictly greater than every element in a provided array. The method should return true only if the integer is larger than each element in the array; otherwise, it should return false.\n\n-----Input-----\nThe input consists of:\nn: An integer.\na: An array of integers.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if the integer is greater than all elements in the array.\nReturns false if there is at least one element in the array that is greater than or equal to the integer.\n\n-----Note-----\nThe array is assumed to be non-null.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn is_greater(n: i32, a: &Vec<i32>) -> (result: bool)\n    requires a.len() > 0,\n    ensures result == (forall|i: int| 0 <= i < a.len() ==> n > a[i]),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"129f83e996e0bb179515c6a0b689e6b413236a9c50ceb61664c787b326206251","vc_description_hash":"290657c22f0b6a19a640b6d875112b2b6a0689b4f2548d0c08a86f068374f62d","vc_spec_hash":"8bda0d6d5f4fd2d99274a3debdb4b81e8826db8bfdf1041b5873e97b9c1790f8","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"3e54da157d3714607d8a6cfd6978100caf0f2d0f2bc58ce39b968dbc9707b941","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn is_greater(n: i32, a: &Vec<i32>) -> (result: bool)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_basic_11_task","vc-description":"This task requires writing a Verus method that extracts the last digit of a given non-negative integer. The method should return the last digit, which is obtained by computing the remainder when the number is divided by 10. The result must always be between 0 and 9.\n\n-----Input-----\nThe input consists of a single value:\nn: A non-negative integer.\n\n-----Output-----\nThe output is an integer:\nReturns the last digit of the input number, ensuring that the digit lies within the range 0 to 9.\n\n-----Note-----\nIt is assumed that the input number n is non-negative.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn last_digit(n: nat) -> result: nat\n    ensures\n        result < 10,\n        result == n % 10,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"0538f8b649cc65009781c5b4f6fcefca40afd832a15999b9c407817fd20a14c7","vc_description_hash":"75dc237e62cd41e68e2d0616c87f9416c8eac15f6878a96fc9fc585b8a4d1144","vc_spec_hash":"c0ec1db94e0da977070dc9bc16763d8273a7c53e819cb247d742726a8f9a9653","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"7adb262f366d08ebd83bcd28634141809c963d546fd0a5d259e41d98a00f4791","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_13_task","vc-description":"This task requires writing a Verus method that transforms an array of integers by replacing every element with its cube. In other words, for each element in the input array, the output array should contain the result of multiplying that element by itself three times.\n\nInput:\nThe input consists of:\na: An array of integers (which may be empty or non-empty).\n\nOutput:\nThe output is an array of integers:\nReturns an array with the same length as the input, where each element is the cube of the corresponding element in the input array.\n\nNote:\nThere are no additional preconditions; the method should work correctly for any array of integers.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn cube_elements(a: &Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> result[i] == a[i] * a[i] * a[i],","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"45a5b1c92cf3789b2e6ab06f44e04857adf6622fbdb0b00e43a67099e90b7a2b","vc_description_hash":"fc227cd960154ae3219806de7a1819c1fb6c918c38b1694c917decab6ade67fa","vc_spec_hash":"b1390760ec52306dd6c8f38be6f8ca63bb8acea36f3ea923a5dfb67a2625aa88","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"a47d427022d710647f70e82504dbd209a567095ae3f3934b768579b5ad85a7fe","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn cube_elements(a: &Vec<i32>) -> (result: Vec<i32>)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_14_task","vc-description":"This task requires writing a Verus method that determines whether a given string contains the character 'z' or 'Z'. The method should return true if the string includes either the lowercase or uppercase letter 'z', and false otherwise.\n\n-----Input-----\nThe input consists of:\ns: A string.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if the input string contains the character 'z' or 'Z'.\nReturns false if the input string does not contain the character 'z' or 'Z'.\n\n-----Note-----\nThere are no preconditions; the method will always work as strings and sequences are considered non-null.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn contains_z(s: &str) -> (result: bool)\n    ensures\n        result <==> exists|i: int| 0 <= i < s@.len() && (s@[i] == 'z' || s@[i] == 'Z'),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"b3c40420869731ea9973740323638da84d6d00acc974550a2219a254daccf034","vc_description_hash":"f39fa810ec86c032ea785b2faf2be5bc93dff79a4b8725b4d6a59012d4ed7299","vc_spec_hash":"eb2ee0968e5e8a85fd388fd61fa1284f304c8078b2a82df9cc59cbb5c62555d9","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"f4616a3f769e871cdf0e2bcbfb7f7e5de46e76ed9fef8b0c9a0703b65aab3af3","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn contains_z(s: &str) -> (result: bool)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_15_task","vc-description":"This task requires writing a Verus method that determines whether an array of integers contains at least one pair of consecutive numbers. The method should return true if there is any index where an element, when increased by one, equals the next element in the array. If no such consecutive pair exists, the method should return false.\n\n-----Input-----\nThe input consists of:\na: An array of integers (the array may be empty or non-empty).\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if there is at least one index where an element plus one equals the following element.\nReturns false if the array does not contain any consecutive numbers.\n\n-----Note-----\nThere are no additional preconditions; the method will function correctly regardless of the array's size.\n\n/* \n    -- Invalid Inputs\n    []\n    -- Tests\n    [\n        {\n            \"input\": {\n                \"a\": \"#[1, 2, 3, 5]\"\n            },\n            \"expected\": true,\n            \"unexpected\": [\n                false\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"#[1, 3, 5, 7]\"\n            },\n            \"expected\": false,\n            \"unexpected\": [\n                true\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"#[]\"\n            },\n            \"expected\": false,\n            \"unexpected\": [\n                true\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"#[10]\"\n            },\n            \"expected\": false,\n            \"unexpected\": [\n                true\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"#[5, 6]\"\n            },\n            \"expected\": true,\n            \"unexpected\": [\n                false\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"#[5, 7, 8, 10]\"\n            },\n            \"expected\": true,\n            \"unexpected\": [\n                false\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"#[9, 9, 10]\"\n            },\n            \"expected\": true,\n            \"unexpected\": [\n                false\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"#[3, 3, 3]\"\n            },\n            \"expected\": false,\n            \"unexpected\": [\n                true\n            ]\n        }\n    ]\n    */","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn contains_consecutive_numbers(a: &Vec<i32>) -> (result: bool)\n    ensures\n        result <==> exists|i: int| {\n            &&& 0 <= i < a.len() - 1\n            &&& #[trigger] a[i] + 1 == a[(i + 1) as int]\n        },","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"2117fc0bfce25522eb08490453cc8a93220891587111580e35ee7b13af99cd5d","vc_description_hash":"0ce433b8a854c930ea877db7f6652e20b9e132b8317eb8b17c1b62464f53eb2e","vc_spec_hash":"c32b4f38f66b9dbea4bbe8760009f1a0a1d55426184e115a225f87ae4c6edbf8","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"3e505bd744ab54450dc41cbc2a82ab190e64c6b91920aa6cfd333eb9e2c21581","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn contains_consecutive_numbers(a: &Vec<i32>) -> (result: bool)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_17_task","vc-description":"This task requires writing a Verus method that converts all uppercase characters in a given string to their lowercase equivalents while keeping the other characters unchanged. The output string must have the same length as the input string.\n\n-----Input-----\nThe input consists of:\ns: A string that may contain both uppercase and lowercase characters.\n\n-----Output-----\nThe output is a string:\nReturns a new string where every uppercase letter has been converted to lowercase, and every non-uppercase character remains exactly as in the input.\n\n-----Note-----\nThere are no preconditions; the method is expected to work for any non-null string.\n\n/* Helper function to check if a character is uppercase */\n\n/* Helper function to shift character by 32 positions */","vc-preamble":"use vstd::prelude::*;\n\nverus! {\n\nspec fn is_uppercase(c: char) -> bool {\n    'A' <= c && c <= 'Z'\n}\n\nspec fn shift32(c: char) -> char {\n    ((c as int) + 32) as char\n}","vc-helpers":"","vc-spec":"fn to_lowercase(s: &Vec<char>) -> (result: Vec<char>)\n    ensures\n        result.len() == s.len(),\n        forall|i: int| 0 <= i < s.len() ==> {\n            if is_uppercase(s[i]) {\n                result[i] == shift32(s[i])\n            } else {\n                result[i] == s[i]\n            }\n        },","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"27e7a65c95630b9f2f2ce9b26d92355689d39050e97e2399f2431d3bcab690a9","vc_description_hash":"7fb9291b91e2bd60b6de15e0f53b84f96d29ba635a6a493e23bf759ff6a074d2","vc_spec_hash":"c53e1df023f0960f541fb6b2d34234face60c3c57d821123fad538620520fed6","vc_preamble_hash":"5fa7ddc4ccc0ee230d2826c9eca36b20f15efd6f8a9a85813d639d79eee41c64","description_normalized_hash":"7f5d0a68db10256a7fe1dedfb3393cd9f0041a26bf33460d551fbe987a59ebc5","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn to_lowercase(s: &Vec<char>) -> (result: Vec<char>)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_18_task","vc-description":"This task requires writing a Verus method that computes the sum of the digits of a non-negative integer. The method should process each digit of the input number and return the total sum. The output is guaranteed to be a non-negative natural number.\n\n-----Input-----\nThe input consists of:\nn: A non-negative integer.\n\n-----Output-----\nThe output is a natural number:\nReturns the sum of the digits of the input integer.\n\n-----Note-----\nThe input is assumed to be a valid non-negative integer.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn sum_of_digits(n: nat) -> result: nat;\n    ensures result >= 0,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"2db49f9705c0d9c90ccb429c2bd5340ffd6f90737ef99dd4a42043acfba49f0f","vc_description_hash":"578b74e1150532f51f4ce88e19b4969f426dfc17ddc783482d0914989d10bbb1","vc_spec_hash":"3220abbdbf00d74262be621401679782e5c4662f015fd52e7e3096d616f17514","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"3c1ecefaf12b04118198eacb0d0b860d7e1b0cf1cf595bf183a9c8771e7f9377","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_19_task","vc-description":"This task requires writing a Verus method that checks whether an array of integers is sorted in non-decreasing order. The method should return true if every element is less than or equal to the element that follows it, and false otherwise.\n\n-----Input-----\nThe input consists of:\na: An array of integers. The array can be empty or have any length.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if the array is sorted in non-decreasing order.\nReturns false if the array is not sorted in non-decreasing order.\n\n-----Note-----\nA true result guarantees that for every valid pair of indices i and j (with i < j), the element at position i is less than or equal to the element at position j. A false result indicates that there exists at least one adjacent pair of elements where the first element is greater than the second.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn is_sorted(a: &Vec<i32>) -> (result: bool)\n    ensures\n        result == (forall|i: int| 0 <= i < a.len() - 1 ==> #[trigger] a[i] <= a[i + 1]),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"00b2817d3b8f05e4b6fd3875ca55c073a65568bebb0d57554b516a3848164f88","vc_description_hash":"5bb4ef1f06d45dec03d842b7a054809e21520462ae986417905fb13094436b18","vc_spec_hash":"281830e984008c7189d00e26907d171a4cc4452c8e0894c2d3cd945604523a3e","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"4f4dd759285520a8a38d8e0e8e3065f21e31f2b5921bb84385d3a5a9d2fb8f05","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn is_sorted(a: &Vec<i32>) -> (result: bool)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_20_task","vc-description":"This task requires writing a Verus method that calculates the product of all distinct integers in an array. The method should consider each unique integer only once when computing the product and return the resulting value. If the array is empty, the method should return 1.\n\n-----Input-----\nThe input consists of:\narr: An array of integers.\n\n-----Output-----\nThe output is an integer:\nReturns the product of all unique integers from the input array.\n\n-----Note-----\nThe order in which the unique integers are multiplied does not affect the final product.\n\n/* Product of all unique integers in the array */\n\n/* Placeholder for actual postcondition */","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn unique_product(arr: &Vec<i32>) -> (result: i32)\n    ensures\n\n        true,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"cade0e332a9ca6ca1e83a4f569b5509ddb92867cf7555d70ae517fe6479cf985","vc_description_hash":"89d8cbdd6b4b7c14979c63fad6fa30ae0cd239e512a12f6ab95993259c97d763","vc_spec_hash":"6cbd3ed1f804747851a6546d3d53a5f6fad28d072a882b2c3c43cfc216fe0b33","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"c0e94a83e2db76e5064596fd340715c162e7ded01b2615300e59d99a37dd6dba","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn unique_product(arr: &Vec<i32>) -> (result: i32)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_21_task","vc-description":"This task requires writing a Verus method that determines whether one list is a sublist of another. In other words, the method should check if the first list appears as a contiguous sequence within the second list and return true if it does, and false otherwise.\n\n-----Input-----\nThe input consists of two lists of integers:\nsub: A list of integers representing the potential sublist.\nmain: A list of integers in which to search for the sublist.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if the first list appears as a contiguous sequence within the second list.\nReturns false if the first list does not appear as a contiguous sequence in the second list.\n\n-----Note-----\nThere are no preconditions for this method; the sequences are always non-null.","vc-preamble":"use vstd::prelude::*;\n\nverus! {\n\nspec fn is_subseq_at(sub: Vec<i32>, main: Vec<i32>, i: int) -> bool {\n    0 <= i && i + sub.len() <= main.len() && \n    (forall|j: int| 0 <= j < sub.len() ==> sub[j] == main[i + j])\n}","vc-helpers":"","vc-spec":"fn is_sublist(sub: &Vec<i32>, main: &Vec<i32>) -> (result: bool)\n    ensures\n        result <==> exists|i: int| is_subseq_at(*sub, *main, i),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"5360e9107deb137f4be8e8edfbc312704f9ddd303d086973a5a969df7f6331e0","vc_description_hash":"824d0d12d0116f45438eb414b7f31291759fde921496423e393cfa9b26f855fe","vc_spec_hash":"d7153160fe5d1283a03cba0034ffe1f13533d7bc746277cbd77c9f02f103c09c","vc_preamble_hash":"ec107d3b560b738a276b012ab0905ec2ed176ef1ab08966b0185ac86eebe9d5e","description_normalized_hash":"7925545597a5400d15f207b0c45ee2ce175cd391c32e6fbf71b33e1887e1e433","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn is_sublist(sub: &Vec<i32>, main: &Vec<i32>) -> (result: bool)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_24_task","vc-description":"This task requires writing a Verus method that finds the difference between the first even number and the first odd number in an array of integers. The method should process the array sequentially until it identifies the first even number and the first odd number, and then return the difference calculated as (first even number) minus (first odd number).\n\n-----Input-----\nThe input consists of:\na: An array of integers.\n\n-----Output-----\nThe output is an integer:\nReturns the difference computed as the first even number minus the first odd number found in the array.\n\n-----Note-----\nThe input array is assumed to be non-empty and to contain at least one even number and one odd number.\n\n/*\n    -- Invalid Inputs\n    [\n        {\n            \"input\": {\n                \"a\": \"#[2]\"\n            }\n        }\n    ]\n    -- Tests\n    [\n        {\n            \"input\": {\n                \"a\": \"#[2, 3, 4, 5]\"\n            },\n            \"expected\": -1,\n            \"unexpected\": [\n                -2,\n                1,\n                -3\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"#[1, 4, 6, 8]\"\n            },\n            \"expected\": 3,\n            \"unexpected\": [\n                2,\n                4,\n                5\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"#[7, 2, 9, 4]\"\n            },\n            \"expected\": -5,\n            \"unexpected\": [\n                -3,\n                -6,\n                5\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"#[2, 2, 3, 3]\"\n            },\n            \"expected\": -1,\n            \"unexpected\": [\n                1,\n                0,\n                -2\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"#[1, 1, 2, 2]\"\n            },\n            \"expected\": 1,\n            \"unexpected\": [\n                0,\n                2,\n                -1\n            ]\n        }\n    ]\n    */","vc-preamble":"use vstd::prelude::*;\n\nverus! {\n\nspec fn is_even(n: i32) -> bool {\n    n % 2 == 0\n}\n\nspec fn is_odd(n: i32) -> bool {\n    n % 2 != 0\n}","vc-helpers":"","vc-spec":"fn first_even_odd_difference(a: &Vec<i32>) -> (result: i32)\n    requires \n        a.len() > 1,\n        exists|x: int| 0 <= x < a.len() && is_even(a[x as int]),\n        exists|x: int| 0 <= x < a.len() && is_odd(a[x as int]),\n    ensures \n        exists|i: int, j: int| \n            0 <= i < a.len() && 0 <= j < a.len() &&\n            is_even(a[i as int]) && is_odd(a[j as int]) &&\n            result == a[i as int] - a[j as int] &&\n            (forall|k: int| 0 <= k < i ==> is_odd(a[k as int])) &&\n            (forall|k: int| 0 <= k < j ==> is_even(a[k as int]))","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"8ae4b78e12b758cb4005898af83a7cd2338b70df775c445dc8962373a18c64a7","vc_description_hash":"6dca92f7b1bb637dbf45cd1e23e266ae945a8a7804e297d185610aa8e9c88e8f","vc_spec_hash":"a701abddfe5b3dbabf25b239c104e37ab941c56d1b118bd7701fb44c616dfb3b","vc_preamble_hash":"9c1b4f3c062563eb279e429c1ffb4b902ba6210ea4beb177892257e88b574107","description_normalized_hash":"2c71844120e08582ac0b7d40c07f6506f23abdc11e910aca83074b189e01055c","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn first_even_odd_difference(a: &Vec<i32>) -> (result: i32)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_basic_25_task","vc-description":"This task requires writing a Verus method that calculates both the sum and the average of the first n natural numbers. The method should compute the sum of numbers from 0 to n (which equals n * (n + 1) / 2) and then determine the average by dividing this sum by n. The specification assumes that the input n is a positive integer.\n\n-----Input-----\nThe input consists of:\nn: A natural number representing the count of the first natural numbers. The value of n is assumed to be positive.\n\n-----Output-----\nThe output is a pair consisting of:\n- An integer representing the sum of the first n natural numbers.\n- A floating-point number representing the average of the first n natural numbers.\n\n-----Note-----\nThe input n must be a positive integer.\n\n/* reasonable bound to prevent overflow */\n\n/*\n    -- Invalid Inputs\n    []\n    -- Tests\n    [\n        {\n            \"input\": {\n                \"n\": 5\n            },\n            \"expected\": \"(15, 3.0)\",\n            \"unexpected\": [\n                \"(14, 2.8)\",\n                \"(16, 3.2)\"\n            ]\n        },\n        {\n            \"input\": {\n                \"n\": 1\n            },\n            \"expected\": \"(1, 1.0)\",\n            \"unexpected\": [\n                \"(0, 0.0)\",\n                \"(2, 2.0)\"\n            ]\n        },\n        {\n            \"input\": {\n                \"n\": 10\n            },\n            \"expected\": \"(55, 5.5)\",\n            \"unexpected\": [\n                \"(50, 5.0)\",\n                \"(60, 6.0)\"\n            ]\n        },\n        {\n            \"input\": {\n                \"n\": 0\n            },\n            \"expected\": \"(0, 0.0)\",\n            \"unexpected\": [\n                \"(1, 0.1)\",\n                \"(-1, -0.1)\"\n            ]\n        },\n        {\n            \"input\": {\n                \"n\": 2\n            },\n            \"expected\": \"(3, 1.5)\",\n            \"unexpected\": [\n                \"(2, 1.0)\",\n                \"(4, 2.0)\"\n            ]\n        }\n    ]\n    */","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn sum_and_average(n: u32) -> (result: (u32, f64))\n    requires n < 100000,\n    ensures\n        n == 0 ==> result.0 == 0,\n        n > 0 ==> result.0 == (n * (n + 1)) / 2,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"5440af8678589fa1a045c2bf4cbbcfb8210e8d1deb7450f62db8b9cfcece15e1","vc_description_hash":"6083f3e81f73e182bd908a16e70c533c8010b28c7f8c43af27365363045d11e6","vc_spec_hash":"3d200747899191b146f1f46352a3e4574da74bb37cfb7a062e289b3b22bb5ff7","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"6b294c8692cd9cb8c6cc346404c9c219a01566244f0b9991a6d0ecebafc6e9b1","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn sum_and_average(n: u32) -> (result: (u32, f64)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_basic_26_task","vc-description":"This task requires writing a Verus method that determines whether a given integer is even. In other words, the method should return true if the number is even and false if the number is odd.\n\n-----Input-----\nThe input consists of:\nn: An integer.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if the input number is even.\nReturns false if the input number is odd.\n\n-----Note-----\nThere are no preconditions; the method will always work for any integer input.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn is_even(n: int) -> (result: bool)\n    ensures\n        result <==> (n % 2 == 0),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"1b98daf8263bc87177afd35041b5e1a09f0db7e261421c5f77f274f6fa4b663d","vc_description_hash":"0bbbccd5648e34e01f53442dc854668e27650d2c8b9b77b9860153fee93bb662","vc_spec_hash":"67fa9f841c77abc79a68a6ae9a450ae76b3358c36e221417fde529c4e151cdfd","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"3eb8b88e81e7742d24623aa2f027c2055ffc1fcd3bfc8a06f232b5b2c10fe4b5","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn is_even(n: int) -> (result: bool)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_27_task","vc-description":"This task requires writing a Verus method that identifies the first repeated character in a given string. The method should return an Option containing a character. The Option value indicates whether any character in the string is repeated. If it is Some(c), the accompanying character is the first character that appears more than once. If it is None, it indicates that there are no repeated characters in the string.\n\nInput:\nThe input consists of:\ns: A vector of characters.\n\nOutput:\nThe output is Option<char>:\n- Returns Some(c) with the first repeated character in the string if any repeated character is found.\n- Returns None if no repeated characters are present.\n\nNote:\nThere are no preconditions; the method is expected to work for any vector of characters.","vc-preamble":"use vstd::prelude::*;\n\nverus! {\n\nspec fn count_char(chars: Seq<char>, c: char) -> nat \n    decreases chars.len()\n{\n    if chars.len() == 0 {\n        0\n    } else if chars[0] == c {\n        1 + count_char(chars.subrange(1, chars.len() as int), c)\n    } else {\n        count_char(chars.subrange(1, chars.len() as int), c)\n    }\n}\n\nspec fn has_no_duplicates_up_to(chars: Seq<char>, end_idx: int) -> bool {\n    forall|i: int, j: int| 0 <= i < j < end_idx ==> #[trigger] chars[i] != #[trigger] chars[j]\n}\n\nspec fn has_no_duplicates(chars: Seq<char>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < chars.len() ==> #[trigger] chars[i] != #[trigger] chars[j]\n}\n\nspec fn first_occurrence_index(chars: Seq<char>, c: char) -> int {\n    choose|i: int| 0 <= i < chars.len() && chars[i] == c\n}\n\nspec fn second_occurrence_exists(chars: Seq<char>, c: char) -> bool {\n    exists|i: int, j: int| 0 <= i < j < chars.len() && #[trigger] chars[i] == c && #[trigger] chars[j] == c\n}","vc-helpers":"","vc-spec":"fn find_first_repeated_char(s: &Vec<char>) -> (result: Option<char>)\n    ensures match result {\n        Some(c) => {\n            let chars = s@;\n            count_char(chars, c) >= 2 &&\n            second_occurrence_exists(chars, c) &&\n            {\n                let first_idx = first_occurrence_index(chars, c);\n                let second_idx = choose|j: int| first_idx < j < chars.len() && chars[j] == c;\n                has_no_duplicates_up_to(chars, second_idx)\n            }\n        },\n        None => {\n            has_no_duplicates(s@)\n        }\n    }","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"6fb74ba2b2f194ec4c85ac1c7d72e5e37515a322f5121f0f21c617faa3d53a6b","vc_description_hash":"ff9fcf3affa305b19eb18b2cf3f4d5176d5877be9a25f661f59bed8e8b28c0a7","vc_spec_hash":"86aa2416c26340dfeb990b751533b82c8ed9a5cb5b9abb381cace5411bb9d6ca","vc_preamble_hash":"7764e35efffc2404f648ff42fa22358b00dcd8986fe70c44174f695cd1237839","description_normalized_hash":"8285e239c852d6c48a18a7e2ae6e85bcd3de124f7ddc2bf8f6059eadd4e23a81","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn find_first_repeated_char(s: &Vec<char>) -> (result: Option<char>)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_28_task","vc-description":"This task requires writing a Verus method that determines whether a given natural number is prime. A number (with n \u2265 2) is considered prime if it is divisible only by 1 and itself. The method should return true when the input number is prime and false otherwise.\n\nInput:\nThe input consists of:\nn: A natural number (nat) such that n \u2265 2.\n\nOutput:\nThe output is a Boolean value:\nReturns true if the input number is prime (i.e., there is no integer k with 1 < k < n that divides n).\nReturns false if the input number is not prime (i.e., there exists an integer k with 1 < k < n that divides n).\n\nNote:\nThe input is expected to satisfy the condition n \u2265 2.\n\n/* \n    Invalid Inputs\n    [\n        {\n            \"input\": {\n                \"n\": 0\n            }\n        }\n    ]\n    Tests\n    [\n        {\n            \"input\": {\n                \"n\": 2\n            },\n            \"expected\": true,\n            \"unexpected\": [\n                false\n            ]\n        },\n        {\n            \"input\": {\n                \"n\": 3\n            },\n            \"expected\": true,\n            \"unexpected\": [\n                false\n            ]\n        },\n        {\n            \"input\": {\n                \"n\": 4\n            },\n            \"expected\": false,\n            \"unexpected\": [\n                true\n            ]\n        },\n        {\n            \"input\": {\n                \"n\": 5\n            },\n            \"expected\": true,\n            \"unexpected\": [\n                false\n            ]\n        },\n        {\n            \"input\": {\n                \"n\": 9\n            },\n            \"expected\": false,\n            \"unexpected\": [\n                true\n            ]\n        },\n        {\n            \"input\": {\n                \"n\": 11\n            },\n            \"expected\": true,\n            \"unexpected\": [\n                false\n            ]\n        },\n        {\n            \"input\": {\n                \"n\": 12\n            },\n            \"expected\": false,\n            \"unexpected\": [\n                true\n            ]\n        },\n        {\n            \"input\": {\n                \"n\": 13\n            },\n            \"expected\": true,\n            \"unexpected\": [\n                false\n            ]\n        }\n    ]\n    */","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn is_prime(n: nat) -> (result: bool)\n    requires n >= 2,\n    ensures\n        result ==> forall|k: nat| 2 <= k < n ==> #[trigger] (n % k) != 0,\n        !result ==> exists|k: nat| 2 <= k < n && #[trigger] (n % k) == 0,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"aed1dfdba07981838360f0487f750e5e37120826e1b9c44dd55ca6e444fea087","vc_description_hash":"85556876027e5db56506b1d6edc806be30f352a804805e6dddcc80a4de5476de","vc_spec_hash":"12798017066f7b6eedd07bc6fcd5681518764062da1fad7bc0d6e14ab8b8fb1c","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"8ae30bdb3a22b185256f0017dceb99baf72024e76e19791a74d9cbc3912ce0bc","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn is_prime(n: nat) -> (result: bool)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_basic_2_task","vc-description":"This task requires writing a Verus method that finds the smallest number in an array of integers.\n\n-----Input-----\nThe input consists of:\ns: An array of integers.\n\n-----Output-----\nThe output is an option integer:\nReturns the smallest number found in the input array or none if the array is empty.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn find_smallest(s: &Vec<nat>) -> (result: Option<nat>)\n    ensures\n        match result {\n            None => s.len() == 0,\n            Some(r) => s.len() > 0 && \n                      (exists|i: int| 0 <= i < s.len() && s[i] == r) &&\n                      (forall|i: int| 0 <= i < s.len() ==> r <= s[i])\n        },","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"670471a53863c695cfe3d8feb86074fed9093097d54b9b345e6641a31c0c8f3d","vc_description_hash":"6c1a69265945404d3719fb2793dfba4f71be87068598dec1fe481b61f387483d","vc_spec_hash":"e5505ad31464884ca18cae7cc723e410021d40919fa57e4d3bd7ea8b16a31357","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"1d2cfe6ef988c6e8cd8cea76453b25206e4822f1e19aee717cc8b0d3c5247ede","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn find_smallest(s: &Vec<nat>) -> (result: Option<nat>)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_30_task","vc-description":"This task requires writing a Verus method that computes the element-wise modulo between two arrays of integers. The method should produce a new array where each element is the remainder after dividing the corresponding element from the first array by the element from the second array.\n\nInput:\nThe input consists of:\na: An array of integers.\nb: An array of integers.\n\nOutput:\nThe output is an array of integers:\nReturns a new array in which each element is the result of taking the modulo of the corresponding elements from the two input arrays.\n\nNote:\nPreconditions:\n- Both arrays must be non-null.\n- Both arrays must have the same length.\n- All elements in the second array should be non-zero.\n\nPostconditions:\n- The length of the resulting array is the same as the length of the input arrays.\n- Each element in the resulting array is the modulo of the corresponding elements in the input arrays.\n\n// Invalid Inputs\n\n// [\n\n//     {\n\n//         \"input\": {\n\n//             \"a\": \"[1]\",\n\n//             \"b\": \"[4, 0]\"\n\n//         }\n\n//     }\n\n// ]\n\n// Tests\n\n// [\n\n//     {\n\n//         \"input\": {\n\n//             \"a\": \"[10, 20, 30]\",\n\n//             \"b\": \"[3, 7, 5]\"\n\n//         },\n\n//         \"expected\": \"[1, 6, 0]\",\n\n//         \"unexpected\": [\n\n//             \"[1, 0, 0]\",\n\n//             \"[0, 6, 0]\"\n\n//         ]\n\n//     },\n\n//     {\n\n//         \"input\": {\n\n//             \"a\": \"[100, 200, 300, 400]\",\n\n//             \"b\": \"[10, 20, 30, 50]\"\n\n//         },\n\n//         \"expected\": \"[0, 0, 0, 0]\",\n\n//         \"unexpected\": [\n\n//             \"[0, 0, 0, 1]\",\n\n//             \"[1, 0, 0, 0]\"\n\n//         ]\n\n//     },\n\n//     {\n\n//         \"input\": {\n\n//             \"a\": \"[-10, -20, 30]\",\n\n//             \"b\": \"[3, -7, 5]\"\n\n//         },\n\n//         \"expected\": \"[2, 1, 0]\",\n\n//         \"unexpected\": [\n\n//             \"[-1, -5, 0]\",\n\n//             \"[-1, -6, 1]\",\n\n//             \"[0, -6, 0]\"\n\n//         ]\n\n//     }\n\n// ]","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn element_wise_modulo(a: &Vec<i32>, b: &Vec<i32>) -> (result: Vec<i32>)\n    requires\n        a.len() == b.len(),\n        a.len() > 0,\n        forall|i: int| 0 <= i < b.len() ==> b[i] != 0,\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] % b[i],","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"28d99dcd758805ea2c5509e77e0a569e1ed285e1324a7e5c5b37df022974fa4a","vc_description_hash":"ee19de68770a45b783f20bb1876e2967fc95a3814e966946e9f08edc212ac280","vc_spec_hash":"f2a3a4ac1d10c396e9f92fed4953817862163980f3022cc18fd4ba4d3dda15c4","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"4b7c13bf98630f495278c73c69d0e25023980425b739a0e61cd71c6136304f6e","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn element_wise_modulo(a: &Vec<i32>, b: &Vec<i32>) -> (result: Vec<i32>)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_basic_31_task","vc-description":"This task requires writing a Verus method that converts a given string to uppercase. The method should replace every lowercase letter in the input string with its corresponding uppercase character while leaving all other characters unchanged. The output string must have the same length as the input string.\n\nInput:\nThe input consists of:\ns: A string.\n\nOutput:\nThe output is a string:\nReturns a new string in which every lowercase letter from the input string is converted to uppercase, and all other characters are exactly the same as in the input string, ensuring the output string has the same length as the input.\n\nNote:\nThere are no preconditions since the method assumes that the input string is always valid (i.e., non-null).","vc-preamble":"use vstd::prelude::*;\n\nverus! {\n\nspec fn is_lower_case(c: char) -> bool\n{\n    'a' <= c && c <= 'z'\n}\n\nspec fn shift_minus_32(c: char) -> char\n{\n    arbitrary()\n}","vc-helpers":"","vc-spec":"fn to_uppercase(s: &str) -> (result: String)\n    ensures\n        result@.len() == s@.len(),\n        forall|i: int| 0 <= i < s@.len() ==> {\n            let c = #[trigger] s@.index(i);\n            let r = result@.index(i);\n            if is_lower_case(c) {\n                r == shift_minus_32(c)\n            } else {\n                r == c\n            }\n        },","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"bec14e98e47b23ae413bf9440582530219c64b2bb07373be3edefed007e94744","vc_description_hash":"474e4eebb057b8367cfd534e68d049082c6c80610f163be2bfaca5f2618f4158","vc_spec_hash":"4064b9a1037c32c94923533cfadff0976d56466170cf28f96d0468e58233e302","vc_preamble_hash":"c638b7a7355f1ccf3ba486c6e9caeba25423e34cff8ecec3562c440e8b99e369","description_normalized_hash":"38b0685f385b637a03424e606821a3a2f112d6ec57fb0c2531f4c783788d4711","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn to_uppercase(s: &str) -> (result: String)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_32_task","vc-description":"This task requires writing a Verus method that swaps the first and last elements of an array of integers. The method should produce a new array where the first element of the output is the last element of the input, the last element of the output is the first element of the input, and all other elements remain in their original positions.\n\nInput:\nThe input consists of:\na: An array of integers (assumed to be non-empty).\n\nOutput:\nThe output is an array of integers:\nReturns a new array where:\n- The former last element becomes the first element.\n- The former first element becomes the last element.\n- All other elements remain unchanged.\n\n/* \n    Invalid Inputs\n    [\n        {\n            \"input\": {\n                \"a\": \"[]\"\n            }\n        }\n    ]\n    Tests\n    [\n        {\n            \"input\": {\n                \"a\": \"[1, 2, 3, 4, 5]\"\n            },\n            \"expected\": \"[5, 2, 3, 4, 1]\",\n            \"unexpected\": [\n                \"[1, 2, 3, 4, 5]\",\n                \"[5, 4, 3, 2, 1]\",\n                \"[2, 3, 4, 5, 1]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"[10]\"\n            },\n            \"expected\": \"[10]\",\n            \"unexpected\": [\n                \"[0]\",\n                \"[5]\",\n                \"[11]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"[1, 2]\"\n            },\n            \"expected\": \"[2, 1]\",\n            \"unexpected\": [\n                \"[1, 2]\",\n                \"[2, 2]\",\n                \"[1, 1]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"[1, 2, 3]\"\n            },\n            \"expected\": \"[3, 2, 1]\",\n            \"unexpected\": [\n                \"[1, 2, 3]\",\n                \"[3, 1, 2]\",\n                \"[2, 1, 3]\"\n            ]\n        }\n    ]\n    */","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn swap_first_and_last(a: &Vec<i32>) -> (result: Vec<i32>)\n    requires a.len() > 0,\n    ensures\n        result.len() == a.len(),\n        result[0] == a[a.len() - 1],\n        result[result.len() - 1] == a[0],\n        forall|i: int| 1 <= i < result.len() - 1 ==> result[i] == a[i],","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"d1b2cce7a780a360085532307248d079f9a21b237771dd73ecf216e512b2d15c","vc_description_hash":"f12b760227e66b9bb656633eec20f079cca9dfccac45b74e3759f220947e74d3","vc_spec_hash":"5298217c47e0a53be25ad193289d06c393b3930323006e6373b8998c22dd7f3b","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"b1cef9de575aa42d42cca6c8a33f96c738a17ca77b623b853d92be54b19ce535","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn swap_first_and_last(a: &Vec<i32>) -> (result: Vec<i32>)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_basic_34_task","vc-description":"This task requires writing a Verus method that extracts even numbers from an array of integers. The method should return a new array containing only the even numbers found in the input array, while preserving the order in which they appear.\n\n-----Input-----\nThe input consists of:\narr: An array of integers.\n\n-----Output-----\nThe output is an array of integers:\nReturns an array containing all the even numbers from the input array. Specifically:\n- Every element in the output array is an even integer.\n- All even integers present in the input array are included in the output array.\n- The relative order of the even integers is preserved as in the input array.\n\n-----Note-----\nThere are no preconditions for this task; the method will work with any array, including empty arrays (which are not null).","vc-preamble":"use vstd::prelude::*;\n\nverus! {\n\nspec fn is_even(n: i32) -> bool {\n    n % 2 == 0\n}","vc-helpers":"","vc-spec":"fn find_even_numbers(arr: &Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        forall|x: i32| result@.contains(x) ==> is_even(x) && arr@.contains(x),\n        forall|x: i32| arr@.contains(x) && is_even(x) ==> result@.contains(x),\n        forall|i: int, j: int| 0 <= i < arr.len() && 0 <= j < arr.len() && i <= j && \n            is_even(arr[i]) && is_even(arr[j]) ==> {\n                exists|ri: int, rj: int| 0 <= ri < result.len() && 0 <= rj < result.len() && \n                    ri <= rj && result[ri] == arr[i] && result[rj] == arr[j]\n            },","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"28b57808bec135741ebfe585a5b7639d2d4127b7255cf591b79623196711cbfd","vc_description_hash":"0a75df6ecf18e3172fef0055e109f42cc88368c53c28a92c4e1beb605f8a2a1c","vc_spec_hash":"8acba8dbe8078cb82650dd71577b4e225135e634b2d0faf5744f58bae57cd8f7","vc_preamble_hash":"9f1e5f2ca099ae14c4e16e00b534ccb5d56bb6f615cda8034f18f49f7c0d8513","description_normalized_hash":"d6c8eb742fbd02ef969cac5dcef5176d0fdf5638a87e15375a90189e0759c18b","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn find_even_numbers(arr: &Vec<i32>) -> (result: Vec<i32>)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_36_task","vc-description":"This task requires writing a Verus method that takes a given string and returns a new string where every occurrence of a space, comma, or dot is replaced with a colon. The transformation must preserve the original string's length and leave all other characters unmodified.\n\nInput:\nThe input consists of:\ns: A string.\n\nOutput:\nThe output is a string:\n- The returned string must have the same length as the input string.\n- Every space, comma, or dot in the input string is replaced with a colon.\n- All other characters remain unchanged.\n\nNote:\nThere are no preconditions; the input string is assumed to be non-null.","vc-preamble":"use vstd::prelude::*;\n\nverus! {\n\nspec fn is_space_comma_dot(c: char) -> bool\n{\n    c == ' ' || c == ',' || c == '.'\n}","vc-helpers":"","vc-spec":"fn replace_with_colon(s: &str) -> (result: String)\n    ensures\n        result@.len() == s@.len(),\n        forall|i: int| 0 <= i < s@.len() ==> \n            #[trigger] result@.index(i) == \n            if is_space_comma_dot(#[trigger] s@.index(i)) { ':' } else { s@.index(i) },","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"7a6ca8813d1401dd2348b563278c15fda5fe264202638ca6d6c9c30e89f382f8","vc_description_hash":"da1ec7fd7aad9e417638086e3dd4c928a59887d2a6932e4c945cb9767051c930","vc_spec_hash":"4329314fbc08d66f84f928f3fb334671b88537d402498249a43406cc14f3f825","vc_preamble_hash":"9b7fd3e0e062dc4265edfdd849edbad0c9b99e4f5ffe34ff6e29a18320e30cf9","description_normalized_hash":"3705345ed7e4f26661cf32d887f38793ee0af4cccc9455b0c49bb2225da6a33c","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn replace_with_colon(s: &str) -> (result: String)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_37_task","vc-description":"This task requires writing a Verus method that locates the first occurrence of a specified integer within a sorted array of integers. The method returns the index corresponding to the first time the target value appears in the array; if the target is absent, it returns -1. It is also essential that the original array remains unchanged.\n\nInput:\nThe input consists of:\n\u2022 arr: An array of integers sorted in non-decreasing order.\n\u2022 target: An integer representing the value to search for.\n\nOutput:\nThe output is an integer:\n\u2022 If the target is found, the method returns the index of its first occurrence.\n\u2022 If the target is not found, the method returns -1.\n\nNote:\n\u2022 The input array must be sorted in non-decreasing order.\n\u2022 The array is guaranteed to remain unmodified after the method executes.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn find_first_occurrence(arr: &Vec<i32>, target: i32) -> (result: i32)\n    requires\n        forall|i: int, j: int| 0 <= i < j < arr.len() ==> arr[i] <= arr[j],\n    ensures\n        (result >= 0 ==> {\n            &&& 0 <= result < arr.len()\n            &&& arr[result as int] == target\n            &&& forall|i: int| 0 <= i < result ==> arr[i] != target\n        }) &&\n        (result == -1 ==> {\n            &&& forall|i: int| 0 <= i < arr.len() ==> arr[i] != target\n        }),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"d705fc3f2ed227ffeeb1d2275783f8d0a8006d8218535fb9ff3d0cdc5520f4f4","vc_description_hash":"add1486df424c4eb656b9fae3c88c3e9c3d8b50a9e268d4b297527440a8dd68b","vc_spec_hash":"6f2f471b18f44a310e88508a4e0b7c3b3614bd999218dafb7fd71787bb45938d","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"b093aff4a4f11690e30629c87df70edeef824ca9d41973d1e90edb41f57b3aff","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn find_first_occurrence(arr: &Vec<i32>, target: i32) -> (result: i32)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_basic_38_task","vc-description":"This task requires writing a Lean 4 method that checks whether all characters in an input string are identical. The method should return true if every character in the string is the same, and false if at least one character differs. An empty string or a single-character string is considered to have all characters identical.\n\n-----Input-----\nThe input consists of:\ns: A string.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if every character in the string is identical.\nReturns false if there is at least one differing character.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn all_characters_same(s: Seq<char>) -> (result: bool)\n    requires true,\n    ensures\n        result ==> (forall|i: int, j: int| 0 <= i < s.len() && 0 <= j < s.len() ==> s[i] == s[j]),\n        !result ==> (s.len() > 0 && exists|i: int| 0 <= i < s.len() && #[trigger] s[i] != s[0]),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"abeb849a5416fee992d7ac2426d117129032aadf8428e73eaa40fa1195089bfa","vc_description_hash":"0770f82843d344a3d516f81e40ed02f56681dee11c264d4e38a486afd5d5487b","vc_spec_hash":"35cafd8ac0640c5690c526a6acf38ae88649fa878d95c5f58d4a48340c739369","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"8639e9ab371fb3fd89d7d09443568b412c9a885263f62aaf0ea0330e252a17c2","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn all_characters_same(s: Seq<char>) -> (result: bool)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_basic_39_task","vc-description":"This task requires writing a Verus method that rotates a list of integers to the right by a specified number of positions. The method should produce a new list where each element is shifted to the right while preserving the original list's length.\n\n-----Input-----\nThe input consists of:\n\u2022 l: A list of integers.\n\u2022 n: A non-negative natural number that indicates the number of positions by which to rotate the list.\n\n-----Output-----\nThe output is a list of integers:\n\u2022 Returns a list with the same length as the input list, where the elements have been rotated to the right by n positions.\n\n-----Note-----\n\u2022 The precondition requires that n is non-negative.\n\u2022 If the input list is empty, it should be returned unchanged.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn rotate_right(l: &Vec<i32>, n: usize) -> (result: Vec<i32>)\n    ensures\n        result.len() == l.len(),\n        forall|i: int| 0 <= i < l.len() ==> {\n            let len = l.len() as int;\n            let rotated_index = ((i - n as int + len) % len) as int;\n            #[trigger] result[i] == l[rotated_index]\n        },","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"72ea11988a3f3cf60e145be0848ca600be13ff12535626acc9a7b174617ce773","vc_description_hash":"9ac1c42f3672bae37880118a618e5a9d8c4c07b3e05c08f93a7f74cd9f1dc234","vc_spec_hash":"3512db6c54290eb68b003a6a31530a2c5c3554aa8f3510a52a6b55451cad9c1c","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"2ff8d06dec923316dc5b000036edd0355a4eed2a6b8ff9792f746da156000da6","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn rotate_right(l: &Vec<i32>, n: usize) -> (result: Vec<i32>)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_3_task","vc-description":"This task requires writing a Verus method that determines whether a given integer is divisible by 11. The method should return true if the number is divisible by 11 and false otherwise.\n\n-----Input-----\nThe input consists of:\nn: An integer to check for divisibility by 11.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if the input number is divisible by 11.\nReturns false if the input number is not divisible by 11.\n\n/* \n    // -- Invalid Inputs\n    // []\n    // -- Tests\n    // [\n    //     {\n    //         \"input\": {\n    //             \"n\": 0\n    //         },\n    //         \"expected\": true,\n    //         \"unexpected\": [\n    //             false\n    //         ]\n    //     },\n    //     {\n    //         \"input\": {\n    //             \"n\": 11\n    //         },\n    //         \"expected\": true,\n    //         \"unexpected\": [\n    //             false\n    //         ]\n    //     },\n    //     {\n    //         \"input\": {\n    //             \"n\": 22\n    //         },\n    //         \"expected\": true,\n    //         \"unexpected\": [\n    //             false\n    //         ]\n    //     },\n    //     {\n    //         \"input\": {\n    //             \"n\": 23\n    //         },\n    //         \"expected\": false,\n    //         \"unexpected\": [\n    //             true\n    //         ]\n    //     },\n    //     {\n    //         \"input\": {\n    //             \"n\": 33\n    //         },\n    //         \"expected\": true,\n    //         \"unexpected\": [\n    //             false\n    //         ]\n    //     },\n    //     {\n    //         \"input\": {\n    //             \"n\": 44\n    //         },\n    //         \"expected\": true,\n    //         \"unexpected\": [\n    //             false\n    //         ]\n    //     },\n    //     {\n    //         \"input\": {\n    //             \"n\": -11\n    //         },\n    //         \"expected\": true,\n    //         \"unexpected\": [\n    //             false\n    //         ]\n    //     },\n    //     {\n    //         \"input\": {\n    //             \"n\": -22\n    //         },\n    //         \"expected\": true,\n    //         \"unexpected\": [\n    //             false\n    //         ]\n    //     },\n    //     {\n    //         \"input\": {\n    //             \"n\": 1\n    //         },\n    //         \"expected\": false,\n    //         \"unexpected\": [\n    //             true\n    //         ]\n    //     },\n    //     {\n    //         \"input\": {\n    //             \"n\": -1\n    //         },\n    //         \"expected\": false,\n    //         \"unexpected\": [\n    //             true\n    //         ]\n    //     },\n    //     {\n    //         \"input\": {\n    //             \"n\": 121\n    //         },\n    //         \"expected\": true,\n    //         \"unexpected\": [\n    //             false\n    //         ]\n    //     },\n    //     {\n    //         \"input\": {\n    //             \"n\": 123\n    //         },\n    //         \"expected\": false,\n    //         \"unexpected\": [\n    //             true\n    //         ]\n    //     }\n    // ]\n    // */\n\n//","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn is_divisible_by_11(n: i32) -> (result: bool)\n    ensures\n        result <==> (exists|k: int| #[trigger] (k * 11) == n),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"ee9e55e1b5aca7f9508580b721e71ca13abb28f20fafc0c3be9ca0b95d60130d","vc_description_hash":"925cdb49ba88c4c014dbdaf93e1fa2165e89654ea2872f77b769bb08d7a9d0d7","vc_spec_hash":"7d7abaf3c46c4bbde13af6d0e772622eacded9b540ce59ff1b619ac6a76d60b3","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"d4c8626d480943260c426b8223efd1d651a5b5123f5c317c9d6a713140a3d0e1","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn is_divisible_by_11(n: i32) -> (result: bool)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_40_task","vc-description":"This task requires writing a Verus method that finds the second-smallest number in an array of integers. The method should determine and return the number that is larger than the smallest element in the array. It is crucial that the input array remains unchanged after the computation.\n\n-----Input-----\nThe input consists of:\ns: An array of integers containing at least two elements.\n\n-----Output-----\nThe output is an integer:\nReturns the second-smallest number in the input array.\n\n-----Note-----\n- The input array is guaranteed to contain at least two elements and is non-null.\n- It is assumed that there exist at least two distinct values in the array to ensure a unique second-smallest element.\n- The original array must remain unmodified.","vc-preamble":"use vstd::prelude::*;\n\nverus! {\n\nspec fn second_smallest_precond(s: &Vec<i32>) -> bool {\n    s.len() > 1\n}\n\nspec fn second_smallest_postcond(s: &Vec<i32>, result: i32) -> bool {\n    (exists|i: int| 0 <= i < s.len() && s[i] == result) &&\n    (exists|j: int| 0 <= j < s.len() && s[j] < result &&\n        (forall|k: int| 0 <= k < s.len() && s[k] != s[j] ==> s[k] >= result))\n}","vc-helpers":"","vc-spec":"fn second_smallest(s: &Vec<i32>) -> result: i32\n    requires second_smallest_precond(s) \n    ensures second_smallest_postcond(s, result)","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"57fbdad93b16a4f9a7a69eb69fcc896b9f4534445807db1e6d1b5f2fd54a552e","vc_description_hash":"41d29494adbf63919aa8f2fa055fd2264c676c81b609eebc137e5783270c9e30","vc_spec_hash":"199170fa32bd4713a668006a1fd3c2c86cc0f3e917cd61b9fc73bded4ee94eb6","vc_preamble_hash":"ade96946b0c609c6a938a6b32f00c43dfa6cf98d29536ae21f7f774a8a856eaa","description_normalized_hash":"96d0bdfcb835cbc04c61fd93b996629421ab0c4d71a4a24cd26454b422cabf63","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_basic_41_task","vc-description":"This task requires writing a Verus method that determines whether an array of integers contains only one distinct element. The method should return true if the array is empty or if every element in the array is the same, and false if there are at least two different elements.\n\n-----Input-----\nThe input consists of:\na: An array of integers.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if the array is empty or if all elements in the array are identical.\nReturns false if the array contains at least two distinct elements.\n\n-----Note-----\nThe input array is assumed to be non-null.\n\n/*\n    -- Invalid Inputs\n    [\n        {\n            \"input\": {\n                \"a\": \"#[]\"\n            }\n        }\n    ]\n    -- Tests\n    [\n        {\n            \"input\": {\n                \"a\": \"#[1, 1, 1]\"\n            },\n            \"expected\": true,\n            \"unexpected\": [\n                false\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"#[1, 2, 1]\"\n            },\n            \"expected\": false,\n            \"unexpected\": [\n                true\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"#[3, 4, 5, 6]\"\n            },\n            \"expected\": false,\n            \"unexpected\": [\n                true\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"#[7]\"\n            },\n            \"expected\": true,\n            \"unexpected\": [\n                false\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"#[0, 0, 0, 0]\"\n            },\n            \"expected\": true,\n            \"unexpected\": [\n                false\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"#[0, 0, 1, 0]\"\n            },\n            \"expected\": false,\n            \"unexpected\": [\n                true\n            ]\n        }\n    ]\n    */","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn has_only_one_distinct_element(a: &Vec<i32>) -> (result: bool)\n    requires a.len() > 0,\n    ensures\n        result ==> (forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() ==> a[i] == a[j]),\n        !result ==> (exists|i: int| 0 <= i < a.len() && #[trigger] a[i] != a[0]),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"78d14f9af64d72697dd3ae321ecd506de2363eb18a4041d37acd325586511ae7","vc_description_hash":"f1ef96877cec2c160fb1f82428fa54c552247c2fb235babd1ab65fcde0fd8f75","vc_spec_hash":"da8669501aa923f605bfb3901dddbc91c53a8a1e5e6a237459a52fd74c467daa","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"aed914ed7350bea5367d91c365f2bf8bc538a285aee0a0210f770a5222adb3d6","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn has_only_one_distinct_element(a: &Vec<i32>) -> (result: bool)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_basic_42_task","vc-description":"This task requires writing a Verus method that counts the number of digit characters within a given string. A digit is any character between '0' and '9'. The method should determine how many such digit characters appear in the input.\n\nInput:\nThe input consists of:\ns: A string.\n\nOutput:\nThe output is a natural number (usize):\nReturns a non-negative count representing the number of digit characters found in the input string.\n\nNote:\nThere are no additional preconditions; the method works for any provided string.\n\n/* \n    -- Invalid Inputs\n    []\n    -- Tests\n    [\n        {\n            \"input\": {\n                \"s\": \"123abc456\"\n            },\n            \"expected\": 6,\n            \"unexpected\": [\n                5,\n                7,\n                0\n            ]\n        },\n        {\n            \"input\": {\n                \"s\": \"no digits here!\"\n            },\n            \"expected\": 0,\n            \"unexpected\": [\n                1,\n                2,\n                3\n            ]\n        },\n        {\n            \"input\": {\n                \"s\": \"1234567890\"\n            },\n            \"expected\": 10,\n            \"unexpected\": [\n                9,\n                11,\n                0\n            ]\n        },\n        {\n            \"input\": {\n                \"s\": \"\"\n            },\n            \"expected\": 0,\n            \"unexpected\": [\n                1,\n                2,\n                10\n            ]\n        },\n        {\n            \"input\": {\n                \"s\": \"a1b2c3\"\n            },\n            \"expected\": 3,\n            \"unexpected\": [\n                2,\n                4,\n                5\n            ]\n        },\n        {\n            \"input\": {\n                \"s\": \"0\"\n            },\n            \"expected\": 1,\n            \"unexpected\": [\n                0,\n                2,\n                10\n            ]\n        },\n        {\n            \"input\": {\n                \"s\": \"abc\"\n            },\n            \"expected\": 0,\n            \"unexpected\": [\n                1,\n                8,\n                9\n            ]\n        }\n    ]\n    */","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn count_digits(s: &str) -> (result: usize)\n    ensures\n        result >= 0,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"0f7082f1a4d1285fca48f4bd6b1a8ce8d2318ffadda281e4e55b251b928283a8","vc_description_hash":"afb0566fa81b3df62ae3da88c490efe173beec8082e0eea937885aafb1ca5225","vc_spec_hash":"9dc2352968ecf166e5f3b088cd5ee8374da92c79494240eb440a4d41c28f5dc6","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"926f600367497332ba873432d1579b61882a49326d7b5a0d40428cc3f2c65581","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn count_digits(s: &str) -> (result: usize)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_43_task","vc-description":"This task requires writing a Verus method that computes the sum of the fourth power of the first n odd natural numbers. In other words, given a non-negative integer n, the method should calculate the sum: 1\u2074 + 3\u2074 + 5\u2074 + ... for the first n odd numbers.\n\n-----Input-----\nThe input consists of:\nn: A non-negative natural number representing the number of odd natural numbers to consider.\n\n-----Output-----\nThe output is a natural number:\nReturns the sum of the fourth power of the first n odd natural numbers.\n\n-----Note-----\nThe input n is assumed to be a non-negative integer.\nThe correctness of the result is established by a theorem that relates the computed sum to a specific formula.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn sum_of_fourth_power_of_odd_numbers(n: nat) -> result: nat\n    ensures\n        15 * result == n * (2 * n + 1) * (7 + 24 * (n * n * n) - 12 * (n * n) - 14 * n),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"edce97d26fad0d08b59ff582be054e7a6bbec1f7cf31660dc2b5b9295c9922af","vc_description_hash":"b9c29ee6eadba8b17d48889548dd9950a077bc396c52f51b8f9ca0d1f8a5fa6e","vc_spec_hash":"893c48f58eea0c2308615c307e450599e88492dfd0768d7999fe4a16ec51772e","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"0e254c67830071575afd5268d809af48efce222659c8958eea4768dad558657d","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_44_task","vc-description":"This task requires writing a Verus method that verifies if every odd index in an array of integers holds an odd number. In other words, for each index in the array that is odd, the number located at that index must also be odd. The method should return true if this condition is satisfied for every odd index; otherwise, it should return false.\n\n-----Input-----\nThe input consists of:\na: An array of integers.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if, for every odd index in the array, the corresponding element is odd.\nReturns false if there is at least one odd index where the corresponding element is not odd.\n\n-----Note-----\nThere are no preconditions; the method will work for any array of integers.","vc-preamble":"use vstd::prelude::*;\n\nverus! {\n\nspec fn is_odd(n: i32) -> bool {\n    n % 2 == 1\n}","vc-helpers":"","vc-spec":"fn is_odd_at_index_odd(a: &Vec<i32>) -> (result: bool)\n    ensures\n        result <==> (forall|i: int| 0 <= i < a.len() && i % 2 == 1 ==> is_odd(a[i as int])),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"5b1ae13642ee7d64e4feedcedc839151e6b890c7eeebd43096f221a72fa8707f","vc_description_hash":"2a0e0a28a6f3076038ca27bd233ada0d627dadee150c8fc51b310251d2a82972","vc_spec_hash":"c9d550e3004205d1bbff0bcde33a8f009f82d0eaeca936217d16d38f95fbb0bb","vc_preamble_hash":"f72ad886ab06b32459bb169644153897e097125ee414449c29593d57c6214cad","description_normalized_hash":"c87098568ae034fdc7f04064236b990690ab234fe40960412757bc023ff5d64e","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn is_odd_at_index_odd(a: &Vec<i32>) -> (result: bool)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_45_task","vc-description":"This task requires writing a Verus method that computes the product of the first even and the first odd number encountered in a list of integers. The method should search the list for the earliest even number and the earliest odd number, then return the product of these two numbers.\n\nInput:\nThe input consists of:\nlst: A list of integers.\n\nOutput:\nThe output is an integer:\nReturns the product resulting from multiplying the first even number and the first odd number found in the list.\n\nNote:\nThe input list is assumed to contain at least one even number and one odd number.","vc-preamble":"use vstd::prelude::*;\n\nverus! {\n\nspec fn find_product_precond(lst: Seq<i32>) -> bool {\n    lst.len() > 1 &&\n    (exists|x: i32| lst.contains(x) && is_even(x)) &&\n    (exists|x: i32| lst.contains(x) && is_odd(x))\n}\n\nspec fn is_even(n: i32) -> bool {\n    n % 2 == 0\n}\n\nspec fn is_odd(n: i32) -> bool {\n    n % 2 != 0\n}\n\nspec fn first_even_odd_indices(lst: Seq<i32>) -> Option<(int, int)> {\n    let even_index = (choose|i: int| 0 <= i < lst.len() && is_even(lst[i]));\n    let odd_index = (choose|i: int| 0 <= i < lst.len() && is_odd(lst[i]));\n    if (exists|i: int| 0 <= i < lst.len() && is_even(lst[i])) &&\n       (exists|i: int| 0 <= i < lst.len() && is_odd(lst[i])) {\n        Some((even_index, odd_index))\n    } else {\n        None\n    }\n}","vc-helpers":"","vc-spec":"fn find_product(lst: &Vec<i32>) -> (result: i32)\n    requires \n        lst.len() > 1,\n        exists|x: i32| lst@.contains(x) && is_even(x),\n        exists|x: i32| lst@.contains(x) && is_odd(x),\n    ensures\n        match first_even_odd_indices(lst@) {\n            Some((ei, oi)) => result == lst@[ei] * lst@[oi],\n            None => true,\n        }","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"bfdace3f941a62c32c7884aca2b0b7cc4c69c51b5cd67b6ac3869e545eba8d8a","vc_description_hash":"1d3d6f7fc5706f64c9c78bd27a95ee61c907362f7fb55141fc5e1b9661d3e11a","vc_spec_hash":"56894f01145d8a666ca4274a90d44042655c846dc85d65863604c2f1d1e27a08","vc_preamble_hash":"0e2ed2500b9f4936a21376d5272cb28b64ac9f5478beb2b909a4e16d585ae5ee","description_normalized_hash":"53f2800b8eaae1d0d3a1e0433ca38ad7a91754432624f2ecd2d2fe46d5865ff3","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn find_product(lst: &Vec<i32>) -> (result: i32)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_basic_46_task","vc-description":"This task requires writing a Verus method that finds the last occurrence of a specified element in a sorted array of integers. The method should return the index corresponding to the last occurrence of the element if it is present; if the element is absent, it should return -1. Additionally, the array must remain unchanged after the method is executed.\n\nInput:\nThe input consists of:\narr: A sorted array of integers in non-decreasing order.\nelem: An integer whose last occurrence position is to be determined.\n\nOutput:\nThe output is an integer:\nReturns the index of the last occurrence of the specified integer in the array if it exists.\nReturns -1 if the integer is not found in the array.\n\nNote:\nThe input array is assumed to be sorted in non-decreasing order and remains unchanged by the method.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn last_position(arr: &Vec<i32>, elem: i32) -> (result: i32)\n    requires forall|i: int, j: int| 0 <= i < j < arr.len() ==> arr[i] <= arr[j],\n    ensures\n        (result >= 0 ==> \n            0 <= result < arr.len() &&\n            arr[result as int] == elem &&\n            forall|k: int| result < k < arr.len() ==> arr[k] != elem) &&\n        (result == -1 ==> forall|k: int| 0 <= k < arr.len() ==> arr[k] != elem),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"7fb7d94bc4b5b038a035c91bda7ce67435613bde7c6ed0adb4a18bee554acaee","vc_description_hash":"e61a3bb712d3085e05044485533377f0ba6e2e03a6263549b6783e1281195407","vc_spec_hash":"4576f1aba092d44d727e626741077695944dcdbd35b7cdd2543f37908c8ff024","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"881204ef2769b8ab5ac87721ab87f9a16fa6815ef45bc22a1008c8fed25e6cc4","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn last_position(arr: &Vec<i32>, elem: i32) -> (result: i32)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_basic_47_task","vc-description":"This task requires writing a Verus method that calculates the sum of all the elements in an array of integers. The method should process the entire array and return the total sum of its elements.\n\n-----Input-----\nThe input consists of:\na: An array of integers.\n\n-----Output-----\nThe output is an integer:\nReturns the sum of all elements in the input array.\n\n-----Note-----\n- The input array is assumed not to be null.\n\n/*\n    -- Invalid Inputs\n    [\n        {\n            \"input\": {\n                \"a\": \"#[]\"\n            }\n        }\n    ]\n    -- Tests\n    [\n        {\n            \"input\": {\n                \"a\": \"#[1, 2, 3, 4, 5]\"\n            },\n            \"expected\": 15,\n            \"unexpected\": [\n                14,\n                10,\n                16\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"#[13, 14, 15, 16, 17]\"\n            },\n            \"expected\": 75,\n            \"unexpected\": [\n                74,\n                76,\n                70\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"#[-1, -2, -3]\"\n            },\n            \"expected\": -6,\n            \"unexpected\": [\n                -5,\n                -7,\n                0\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"#[10, -10]\"\n            },\n            \"expected\": 0,\n            \"unexpected\": [\n                5,\n                -5,\n                10\n            ]\n        }\n    ]\n    */","vc-preamble":"use vstd::prelude::*;\n\nverus! {\n\nspec fn sum_to(a: &Vec<i32>, n: int) -> int\n    decreases n\n{\n    if n <= 0 { 0 } else { sum_to(a, n - 1) + a[n - 1] }\n}","vc-helpers":"","vc-spec":"fn array_sum(a: &Vec<i32>) -> (result: i32)\n    requires a.len() > 0,\n    ensures\n        result == sum_to(a, a.len() as int),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"56a4b91d6000ba640e0729481b84f4595251b1011a65e9a9e8717dcbad3495c3","vc_description_hash":"9e2124bb4197570d88edba040143a3d6ae1e135e28862cec31713f4a5a2eb895","vc_spec_hash":"194ec07725f5c8b04430090764157d0398e64895f2bd0a39fa40a23336341046","vc_preamble_hash":"36ea2f75e48f0464fe5ec5c8e21e35b61ccf8f0c61c776565f68d4d9f2523688","description_normalized_hash":"3af98c1316292c70ec739c8226b9ab16bc5603760a850c0cc7ba99b5fd9fed10","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn array_sum(a: &Vec<i32>) -> (result: i32)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_basic_48_task","vc-description":"This task requires writing a Verus method that determines whether a given non-negative natural number is a perfect square. In other words, the method should return true if there exists a natural number whose square is equal to the input number, and false if no such number exists.\n\nInput:\nThe input consists of a single natural number:\nn: A non-negative natural number (nat).\n\nOutput:\nThe output is a Boolean value:\nReturns true if there exists an integer such that its square equals the input n.\nReturns false if no integer squared equals the input n.\n\n/* \n    Invalid Inputs\n    []\n    Tests\n    [\n        {\n            \"input\": {\n                \"n\": 0\n            },\n            \"expected\": true,\n            \"unexpected\": [\n                false\n            ]\n        },\n        {\n            \"input\": {\n                \"n\": 1\n            },\n            \"expected\": true,\n            \"unexpected\": [\n                false\n            ]\n        },\n        {\n            \"input\": {\n                \"n\": 4\n            },\n            \"expected\": true,\n            \"unexpected\": [\n                false\n            ]\n        },\n        {\n            \"input\": {\n                \"n\": 9\n            },\n            \"expected\": true,\n            \"unexpected\": [\n                false\n            ]\n        },\n        {\n            \"input\": {\n                \"n\": 2\n            },\n            \"expected\": false,\n            \"unexpected\": [\n                true\n            ]\n        },\n        {\n            \"input\": {\n                \"n\": 3\n            },\n            \"expected\": false,\n            \"unexpected\": [\n                true\n            ]\n        },\n        {\n            \"input\": {\n                \"n\": 10\n            },\n            \"expected\": false,\n            \"unexpected\": [\n                true\n            ]\n        },\n        {\n            \"input\": {\n                \"n\": 16\n            },\n            \"expected\": true,\n            \"unexpected\": [\n                false\n            ]\n        },\n        {\n            \"input\": {\n                \"n\": 25\n            },\n            \"expected\": true,\n            \"unexpected\": [\n                false\n            ]\n        },\n        {\n            \"input\": {\n                \"n\": 26\n            },\n            \"expected\": false,\n            \"unexpected\": [\n                true\n            ]\n        }\n    ]\n    */","vc-preamble":"use vstd::prelude::*;\n\nverus! {\n\nspec fn is_perfect_square(n: nat) -> bool {\n    exists|i: nat| #[trigger] (i * i) == n\n}","vc-helpers":"","vc-spec":"fn is_perfect_square_fn(n: u64) -> (result: bool)\n    ensures result <==> is_perfect_square(n as nat),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"2c3109bc98feb993b46d9a751ee326122239ae773dfaf9ab48df0f6aae444907","vc_description_hash":"01dbd4a56f2d58975ee92df14f0b25726d8615912d813dff8703bb8e083641cd","vc_spec_hash":"3601539d11ebf172243fc5fa71e0cd404878da7c22ead5b5e450cedf22d7127e","vc_preamble_hash":"27b907a7ff96c590dd9684a832270ac5ca04bfc2cdb0bb40438aeaa437af311a","description_normalized_hash":"9f31688bb9b771c3655a067fc832745bfa5e5beda5c04bedbd5cf2ff495a0f66","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn is_perfect_square_fn(n: u64) -> (result: bool)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_49_task","vc-description":"This task requires writing a Verus method that searches an array of integers to locate the first odd number. The method should return a pair where the first element is a Boolean indicating whether an odd number was found, and the second element is the index of that odd number if found, or -1 if no odd number exists. When an odd number is found, the method should return the smallest index at which an odd number occurs.\n\n-----Input-----\nThe input consists of:\na: An array of integers.\n\n-----Output-----\nThe output is a pair (Bool, Int):\n- If the Boolean is true, then the integer represents the smallest index of an odd number in the array.\n- If the Boolean is false, then there are no odd numbers in the array, and the accompanying integer is -1.\n\n-----Note-----\n- The input array is assumed to be non-null.\n- If multiple odd numbers are present, the index returned should correspond to the first occurrence.","vc-preamble":"use vstd::prelude::*;\n\nverus! {\n\nspec fn is_odd(x: i32) -> bool {\n    x % 2 != 0\n}","vc-helpers":"","vc-spec":"fn find_first_odd(a: &Vec<i32>) -> (result: Option<usize>)\n    requires a.len() > 0,\n    ensures\n        match result {\n            Some(idx) => idx < a.len() && is_odd(a[idx as int]) &&\n                forall|j: int| 0 <= j < idx ==> !is_odd(a[j]),\n            None => forall|i: int| 0 <= i < a.len() ==> !is_odd(a[i]),\n        },","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"e66552f8ccf973a27983b19401bd7810e4a80e6d27254813e32e72536f616dbb","vc_description_hash":"b3b2530fc4907492a5efd312e7bf1ad114b17f203f19bc405d7e4ae847c7ac05","vc_spec_hash":"0147bdc7270c1452ed216e13bfcba706dd915d0cd01838b8513e7a838228716f","vc_preamble_hash":"d0f4549b0fde63b26e825379960f7e41240a80701152412663b0706dc19821e4","description_normalized_hash":"a1b8bf4e6a8992fad7e0efb099fbb4cf6eed85588c5493a676cb650d7daeaf1c","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn find_first_odd(a: &Vec<i32>) -> (result: Option<usize>)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_basic_4_task","vc-description":"This task requires writing a Verus method that finds the kth element in a given array using 1-based indexing. The method should return the element at the specified position, where the first element is at position 1.\n\n-----Input-----\nThe input consists of:\narr: An array of integers.\nk: An integer representing the position (1-based index) of the element to find.\n\n-----Output-----\nThe output is an integer:\nReturns the element at the kth position in the array.\n\n-----Note-----\nThe input k is assumed to be valid (between 1 and array length inclusive).\nThe array is assumed to be non-empty.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn kth_element_impl(arr: &Vec<i32>, k: usize) -> (result: i32)\n    requires k >= 1 && k <= arr.len(),\n    ensures result == arr[k as int - 1]","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"23205507baeb8620175040763a13a45f371bf3f230739fe71e38d7b83880acd0","vc_description_hash":"90ec954b39115a3a83824034ee280fe70ec7f51921c15414b44885854609df05","vc_spec_hash":"b759c9032047a562b79c8c915e92f0f3b597cfa6c5c2e081c3dec9796711d21d","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"6215222e02abe0a7335c4d052df5efa66c7364861216ac1a1e57fddf7e54bb19","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn kth_element_impl(arr: &Vec<i32>, k: usize) -> (result: i32)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_basic_50_task","vc-description":"This task is about calculating the absolute value of an integer. The goal is to determine the non-negative value of a given integer: if the integer is non-negative, it remains unchanged; if it is negative, its positive counterpart is returned.\n\n-----Input-----\nThe input consists of:\n\u2022 x: An integer.\n\n-----Output-----\nThe output is an integer that represents the absolute value of the input. Specifically:\n\u2022 If x is non-negative, the output is x.\n\u2022 If x is negative, the output is the negation of x (that is, a value y such that x + y = 0).\n\n-----Note-----\nThis function should correctly handle zero, positive, and negative integers.","vc-preamble":"use vstd::prelude::*;\n\nverus! {\n\nspec fn abs(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}","vc-helpers":"","vc-spec":"fn abs_impl(x: i32) -> (result: i32)\n    ensures\n        (x >= 0 ==> result == x) && (x < 0 ==> x + result == 0),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"adb7a33be03772b740f3f73c1df53702ecfea1ceecdab3148b57778290466d00","vc_description_hash":"6bd0d53f8833ac9d41fcb347ec3b61f6f0a92a6fdb75fef2ed9ada70c08d8615","vc_spec_hash":"7f495646dbcc32d97ee2c0550c05b4ceab6a8123bfa312711251345bfe9d0417","vc_preamble_hash":"c938364d9f6c6a0392a839a6671f9bf4584069a22542b3043c3d53f402bc813e","description_normalized_hash":"ef2c192011c728e84127278f49dfca08e177414740472064a6a6af3b67c1da55","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn abs_impl(x: i32) -> (result: i32)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_51_task","vc-description":"This task requires creating a function that determines the correct insertion index for a given integer in a sorted array. The goal is to identify an index where every number before it is less than the specified value, and every number from that index onward is greater than or equal to the value. If the given integer is larger than all elements in the array, the function should return the array's size.\n\n-----Input-----\nThe input consists of:\n\u2022 a: An array of integers that is assumed to be sorted in non-decreasing order.\n\u2022 key: An integer to search for in the array.\n\n-----Output-----\nThe output is a natural number (Nat) representing the index determined by the binary search. The index satisfies the following postconditions:\n\u2022 It is between 0 and the size of the array.\n\u2022 Every element before the returned index is less than the key.\n\u2022 If the returned index equals the size of the array, then all elements are less than the key.\n\u2022 Every element from the index onwards is greater than or equal to the key.\n\n-----Note-----\nIt is assumed that the input array is sorted in non-decreasing order. The function returns the first index where the key could be inserted while maintaining the sorted order.","vc-preamble":"use vstd::prelude::*;\n\nverus! {\n\nspec fn binary_search_precond(a: &Vec<i32>, key: i32) -> bool {\n    forall|i: int, j: int| 0 <= i <= j < a.len() ==> a[i] <= a[j]\n}","vc-helpers":"","vc-spec":"fn binary_search(a: &Vec<i32>, key: i32) -> (result: usize)\n    requires binary_search_precond(a, key),\n    ensures\n        result <= a.len(),\n        forall|i: int| 0 <= i < result ==> a[i] < key,\n        forall|i: int| result <= i < a.len() ==> a[i] >= key,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"ba62e96108696607b9f8d3e884f2fe8f8f28183907417962437b0e8d34297c95","vc_description_hash":"902c4467e9954535890855dbabebe41b14d774092ffbd95320f6298a958d38a5","vc_spec_hash":"ff3d30cb2c101307bc5ef0f8c3b39836a6374a339f0e84f7fc25624371558c75","vc_preamble_hash":"a439d764fff1c27fe2cbb655f56c9d98638c2b276afac54d6909da405c6e6af1","description_normalized_hash":"26125a20c2a3311be3c66597e8c7fd8df9a9389cdef1580d26e0d465a0bb8545","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn binary_search(a: &Vec<i32>, key: i32) -> (result: usize)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_basic_52_task","vc-description":"This task requires developing a solution that sorts an array of integers in non-decreasing order. The solution must return an array that is a rearrangement of the input, containing exactly the same elements but ordered from smallest to largest.\n\n-----Input-----\nThe input consists of:\n\u2022 a: An array of integers. This array can be empty or non-empty.\n\n-----Output-----\nThe output is an array of integers that:\n\u2022 Is sorted in non-decreasing order (i.e., for any indices i and j with i < j, a[i]! \u2264 a[j]!).\n\u2022 Has the same size as the input array.\n\u2022 Contains exactly the same elements as the input array, ensuring that the multiset of elements is preserved.\n\n-----Note-----\nThe implementation uses helper functions for swapping elements and performing inner and outer loops of the bubble sort algorithm. No additional preconditions are required as the function should correctly handle empty and non-empty arrays.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn bubble_sort(a: &Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int, j: int| 0 <= i < j < result.len() ==> result[i] <= result[j],\n        a@.to_multiset() == result@.to_multiset(),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"13366f24f3434d3220fe1c0cf78cefac3f3e058b9424257d97a9249d1d9bd7a6","vc_description_hash":"f8c8b4a407a4780d56c7204502c27065119a0c99cc6690cc4c65cdaaf5859343","vc_spec_hash":"1bd091147c79929c28ab5e98e967aef8248501118a9ecc2e2ea99ab84262f983","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"b5885064497dc0118ad412aafa44269a48ae43c65aa3cc88ec32da363f56d7ba","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn bubble_sort(a: &Vec<i32>) -> (result: Vec<i32>)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_55_task","vc-description":"This task involves determining whether two integer values are equal. The goal is simply to compare the two provided numbers and indicate with a Boolean result whether they are the same.\n\n-----Input-----\nThe input consists of two elements:\n\u2022 a: An element of type Int.\n\u2022 b: An element of type Int.\n\n-----Output-----\nThe output is a Boolean:\n\u2022 Returns true if a equals b.\n\u2022 Returns false if a does not equal b.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn compare(a: i32, b: i32) -> (result: bool)\n    ensures\n        (a == b ==> result == true) && (a != b ==> result == false),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"7abe16853cccfa3a0a6f52501d87501fc31da29031dffd7855d44dab4ecd61fc","vc_description_hash":"7c1b71dbc068c31e30d792a72553f49f77112b05b092cbdeda829ed096f752a0","vc_spec_hash":"261636ca44fcb0e60331db6f97d0f816476b20f3fa99ad48569a6345e6ac6736","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"ab779e115fd55bdabdb05286ae414b7f13940683b3fb6d58b8be7efd46a312a1","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn compare(a: i32, b: i32) -> (result: bool)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_56_task","vc-description":"The problem is to update a destination array by replacing a specific segment with values taken from a source array. Given two arrays, starting positions, and a length, the task is to construct a new array where the segment in the destination from the specified starting index for the given length is replaced by the corresponding segment from the source, while all other elements remain unchanged.\n\nInput:\nThe input consists of:\n\u2022 src: An array of integers representing the source array.\n\u2022 sStart: A natural number indicating the starting index in src from where to begin copying.\n\u2022 dest: An array of integers representing the destination array.\n\u2022 dStart: A natural number indicating the starting index in dest where the segment will be replaced.\n\u2022 len: A natural number specifying the number of elements to copy.\n\nOutput:\nThe output is an array of integers that:\n\u2022 Has the same size as the destination array (dest).\n\u2022 Preserves the original elements of dest except for the segment starting at index dStart of length len, which is replaced by the corresponding segment from src.\n\u2022 Under the preconditions that src.size \u2265 sStart + len and dest.size \u2265 dStart + len, guarantees that:\n  - All elements with indices less than dStart remain as in dest.\n  - All elements with indices greater than or equal to dStart + len remain as in dest.\n  - For each index i with 0 \u2264 i < len, the element at index dStart + i in the output equals the element at index sStart + i in src.\n\nNote:\nIt is assumed that the input arrays satisfy the preconditions: the source array has enough elements starting from sStart and the destination array has enough space starting from dStart to accommodate the copied segment.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn copy(src: &Vec<i32>, s_start: usize, dest: &Vec<i32>, d_start: usize, len: usize) -> (result: Vec<i32>)\n    requires \n        src.len() >= s_start + len,\n        dest.len() >= d_start + len,\n    ensures\n        result.len() == dest.len(),\n        forall|i: int| 0 <= i < d_start ==> #[trigger] result[i] == dest[i],\n        forall|i: int| d_start + len <= i < result.len() ==> #[trigger] result[i] == dest[i],\n        forall|i: int| 0 <= i < len ==> #[trigger] result[d_start + i] == #[trigger] src[s_start + i],","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"5a04af072f947f18ef2fe41da16b400d8cf420d6ecbcbc01555616bb172d9b3d","vc_description_hash":"dfcf0b8e6c7dea213b9032af582049484597732518bef74378d53cb29c5bcf2e","vc_spec_hash":"77099663e8ae19f77b9a9b360ea2c849af74a411e81c344ee4f82f8061f99b54","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"5eb7fb7cd390bd7cfd9f6d82a3536474f75ab0d9dbb6d9e881da41de066573c3","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn copy(src: &Vec<i32>, s_start: usize, dest: &Vec<i32>, d_start: usize, len: usize) -> (result: Vec<i32>)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_basic_57_task","vc-description":"This task involves determining how many numbers within an array are less than a specified threshold. The problem is focused on identifying and counting such numbers based purely on their value in relation to the threshold.\n\n-----Input-----\nThe input consists of:\n\u2022 numbers: An array of integers (which may be empty or non-empty).\n\u2022 threshold: An integer that serves as the comparison threshold.\n\n-----Output-----\nThe output is a natural number (Nat) representing the count of elements in the array that are less than the given threshold.\n\n-----Note-----\nThere are no additional preconditions; the function should work correctly for any array of integers and any integer threshold.\n\n/* Helper function to recursively count elements less than threshold */","vc-preamble":"use vstd::prelude::*;\n\nverus! {\n\nspec fn count_less_than_spec(numbers: Seq<i32>, threshold: i32) -> nat\n    decreases numbers.len()\n{\n    if numbers.len() == 0 {\n        0\n    } else {\n        let first = numbers[0];\n        let rest = numbers.subrange(1, numbers.len() as int);\n        if first < threshold {\n            1 + count_less_than_spec(rest, threshold)\n        } else {\n            count_less_than_spec(rest, threshold)\n        }\n    }\n}","vc-helpers":"","vc-spec":"fn count_less_than(numbers: &Vec<i32>, threshold: i32) -> (result: usize)\n    ensures\n        result == count_less_than_spec(numbers@, threshold),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"99660e5ef0116d886447a11e0f17438313bdcfb380f71bc110c8837c838d33d5","vc_description_hash":"40110aceb88e3af62f3e1965ba983ef9c73271ee6b1b580e788e049e979c7105","vc_spec_hash":"b6cf67f9b8b0af240dc4a53dbc01821af7d8c97a10295a975d5f3d4d5f7c0117","vc_preamble_hash":"918ccc8308bb3db60f58c229700883c2d570e2909be05d3d666806720764eb04","description_normalized_hash":"6da9cae8884b2754a2ccc5b829650601c4b13340b6da663a4bcebb3c47f83108","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn count_less_than(numbers: &Vec<i32>, threshold: i32) -> (result: usize)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_58_task","vc-description":"This task involves transforming an array of integers by doubling each element.\n\n-----Input-----\nThe input consists of:\n\u2022 s: An array of integers.\n\n-----Output-----\nThe output is an array of integers where for each valid index i, the element at position i is equal to twice the corresponding element in the input array.\n\n-----Note-----\nThe implementation makes use of a recursive helper function to update the array in place. It is assumed that the input array is valid and that the doubling operation does not lead to any overflow issues.\n\n/*\n    -- Invalid Inputs\n    []\n    -- Tests\n    [\n        {\n            \"input\": {\n                \"s\": \"#[]\"\n            },\n            \"expected\": \"#[]\",\n            \"unexpected\": [\n                \"#[1]\",\n                \"#[0]\",\n                \"#[-1]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"s\": \"#[1, 2, 3, 4, 5]\"\n            },\n            \"expected\": \"#[2, 4, 6, 8, 10]\",\n            \"unexpected\": [\n                \"#[1, 2, 3, 4, 5]\",\n                \"#[2, 4, 6, 8, 9]\",\n                \"#[0, 4, 6, 8, 10]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"s\": \"#[0, -1, 5]\"\n            },\n            \"expected\": \"#[0, -2, 10]\",\n            \"unexpected\": [\n                \"#[0, -1, 5]\",\n                \"#[1, -2, 10]\",\n                \"#[0, 0, 10]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"s\": \"#[100]\"\n            },\n            \"expected\": \"#[200]\",\n            \"unexpected\": [\n                \"#[100]\",\n                \"#[0]\",\n                \"#[201]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"s\": \"#[-3, -4]\"\n            },\n            \"expected\": \"#[-6, -8]\",\n            \"unexpected\": [\n                \"#[3, -4]\",\n                \"#[-6, -7]\",\n                \"#[-6, -9]\"\n            ]\n        }\n    ]\n    */","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn double_array_elements(s: &Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        result.len() == s.len(),\n        forall|i: int| 0 <= i < s.len() ==> #[trigger] result[i] == 2 * s[i],","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"e768c56f5579f76af9f4879c06f719432cc17926019588d9b840e68f5cfedf37","vc_description_hash":"26142edceaca8479635ac975349a1c420daf007ff66aef88581726cc1c5ca60f","vc_spec_hash":"ae9eccda05076632493267d17a872f549f15ac02eb4c003f979318a48e821f42","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"587ba01c57475b81e104e79fed2b0b2fb061cfcfac2110ae45596a8329a43bcb","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn double_array_elements(s: &Vec<i32>) -> (result: Vec<i32>)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_59_task","vc-description":"Given an integer x, determine a pair (a, b) where the first element is twice the value of x and the second element is four times the value of x.\n\n-----Input-----\nThe input consists of:\n\u2022 x: An integer.\n\n-----Output-----\nThe output is a tuple (a, b) where:\n\u2022 a = 2 * x\n\u2022 b = 4 * x\n\n-----Note-----\nThere are no additional preconditions; the method is defined for all integers.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn double_quadruple(x: i32) -> (result: (i32, i32))\n    ensures\n        result.0 == 2 * x,\n        result.1 == 2 * result.0,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"3d3928bcfa7b9cf277f0ecc4db6de61dbe3c8813ef444ed75f5d669b6c731e65","vc_description_hash":"14cc41860845e14f0ccf31851847e9f5ff33c818adc9110f8c0886b16ba212e9","vc_spec_hash":"dff238d2e346d7e33ca1e41701dbbf7e13aa58dc3f005ea655f665530d26476f","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"92671af96e831484ca01e032e26e2863361222a6355f3b48456fa670c10f3ab5","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn double_quadruple(x: i32) -> (result: (i32, i32)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_5_task","vc-description":"This task requires writing a Verus method that multiplies two integers. The method should return the product of the two input numbers.\n\n-----Input-----\nThe input consists of:\na: The first integer.\nb: The second integer.\n\n-----Output-----\nThe output is an integer:\nReturns the product of the two input integers (a * b).\n\n/*\n    -- Invalid Inputs\n    []\n    -- Tests\n    [\n        {\n            \"input\": {\n                \"a\": 3,\n                \"b\": 4\n            },\n            \"expected\": 12,\n            \"unexpected\": [\n                0,\n                11,\n                15\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": 3,\n                \"b\": -4\n            },\n            \"expected\": -12,\n            \"unexpected\": [\n                0,\n                -11,\n                12\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": -3,\n                \"b\": 4\n            },\n            \"expected\": -12,\n            \"unexpected\": [\n                0,\n                -11,\n                12\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": -3,\n                \"b\": -4\n            },\n            \"expected\": 12,\n            \"unexpected\": [\n                0,\n                11,\n                -12\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": 0,\n                \"b\": 5\n            },\n            \"expected\": 0,\n            \"unexpected\": [\n                1,\n                -1,\n                5\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": 5,\n                \"b\": 0\n            },\n            \"expected\": 0,\n            \"unexpected\": [\n                1,\n                -1,\n                5\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": 0,\n                \"b\": 0\n            },\n            \"expected\": 0,\n            \"unexpected\": [\n                1,\n                -1,\n                5\n            ]\n        }\n    ]\n    */","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn multiply(a: i32, b: i32) -> (result: i32)\n    ensures result == a * b,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"1a7d3d6817ddcacad83d811f352b91cf0c41bfb6250561dda2cedbe25a773bb3","vc_description_hash":"ef186cc2bb54002eef204e74e60ca80cb12c07e04ec593fc626b68cc1f5a112d","vc_spec_hash":"85583270e81d3c07ffc6385414a119bd368e43d342041f82757d5b785d5e0cdd","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"bb99ceb207c517aff4bdc9702c2c33f27917f46d50c82a14f225faf1eae135a4","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn multiply(a: i32, b: i32) -> (result: i32)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_60_task","vc-description":"This task requires writing a function that processes an array of integers and produces a new array containing only the even numbers from the input. The order of these even numbers should remain the same as in the original array, ensuring that every even number from the input appears in the output and that every element in the output is even.\n\n-----Input-----\nThe input consists of one parameter:\n\u2022 arr: An array of integers.\n\n-----Output-----\nThe output is an array of integers that:\n\u2022 Contains exactly all even numbers from the input array, preserving their original order.\n\u2022 Meets the specified conditions that ensure no extraneous (odd or non-existing) elements are returned.\n\n-----Note-----\nThere are no additional preconditions. The function must adhere to the provided specification which enforces evenness and order preservation for the elements in the output array.","vc-preamble":"use vstd::prelude::*;\n\nverus! {\n\nspec fn is_even(n: i32) -> bool {\n    n % 2 == 0\n}","vc-helpers":"","vc-spec":"fn find_even_numbers(arr: &Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        forall|i: int| 0 <= i < result.len() ==> is_even(#[trigger] result[i]),\n        forall|i: int| 0 <= i < result.len() ==> exists|j: int| 0 <= j < arr.len() && #[trigger] result[i] == arr[j],","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"5140cb332caeaa2327b2ef3e75bbd71dc012f985c5de923d8baeb0b905cf6226","vc_description_hash":"7d5a2dee39e637112cb40aa4665b75d5f7512756f2d5c1cf3138b4ae450d63b1","vc_spec_hash":"ccdd1319cb7cff522bbaa0bbde3600567ef84a11c58155b2b2a54f91e2b5f9d7","vc_preamble_hash":"9f1e5f2ca099ae14c4e16e00b534ccb5d56bb6f615cda8034f18f49f7c0d8513","description_normalized_hash":"1128cff4d37aef1d9d2144b34e87fdc630246a1b355e45852c12771ac77e2e84","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn find_even_numbers(arr: &Vec<i32>) -> (result: Vec<i32>)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_62_task","vc-description":"The problem involves finding the first occurrence of a specified key in an array of integers. Your task is to identify the index at which the key appears for the first time in the array and return that index. If the key is not found, return -1.\n\n-----Input-----\nThe input consists of:\n\u2022 a: An array of integers.\n\u2022 key: An integer representing the value to search for in the array.\n\n-----Output-----\nThe output is an integer which represents:\n\u2022 The index in the array where the key is found, provided that the index is in the range [0, a.size).\n\u2022 -1 if the key is not present in the array.\nIn addition, if the output is not -1, then a[(Int.toNat result)]! equals key and every element in the array prior to this index is not equal to key.\n\n-----Note-----\nThe function performs a linear search beginning at index 0 and returns the first occurrence of the key. There are no additional preconditions on the input array; it can be empty or non-empty.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn find(a: &Vec<i32>, key: i32) -> (result: i32)\n    ensures\n        (result == -1 || (result >= 0 && result < a.len())),\n        result != -1 ==> (a[result as int] == key && forall|i: int| 0 <= i < result ==> a[i] != key),\n        result == -1 ==> forall|i: int| 0 <= i < a.len() ==> a[i] != key,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"45e2a11f586b87422ffc752ea6f8bf0534d0f8469cca41c5c13791278d607007","vc_description_hash":"0fd1faa2ed1c4f309a2ea75a79e5a46a16dd0da8689df777d1050ef4cdf89e66","vc_spec_hash":"8cde419894ac89e42c4e892427a9be3d3e5ed472812e0943848d27e49175ed17","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"faaf75a3efc97809901536185b3b3d3994c7617058bc13c3de132c8d0c30ebb4","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn find(a: &Vec<i32>, key: i32) -> (result: i32)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_63_task","vc-description":"The task is to determine whether there exists at least one pair of different floating-point numbers in a list such that the absolute difference between them is less than a given threshold. The focus is solely on deciding if such a pair is present in the list.\n\nInput:\nThe input consists of:\n\u2022 numbers: A list of floating-point numbers.\n\u2022 threshold: A floating-point number representing the maximum allowed difference between two numbers for them to be considered \"close.\"\n\nOutput:\nThe output is a boolean value:\n\u2022 true \u2013 if there exists at least one pair of distinct elements in the list such that the absolute difference between them is less than the threshold.\n\u2022 false \u2013 if for every possible pair of elements, the absolute difference is greater than or equal to the threshold.\n\nNote:\nIt is assumed that the list of numbers is provided and that the threshold is non-negative.","vc-preamble":"use vstd::prelude::*;\n\nverus! {\n\nspec fn abs_diff(a: int, b: int) -> int {\n    if a >= b { a - b } else { b - a }\n}","vc-helpers":"","vc-spec":"fn has_close_elements(numbers: &Vec<i32>, threshold: i32) -> (result: bool)\n    requires threshold >= 0,\n    ensures\n        !result <==> (forall|i: int, j: int| \n            0 <= i < numbers.len() && 0 <= j < numbers.len() && i != j ==> \n            abs_diff(numbers[i] as int, numbers[j] as int) >= threshold as int),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"04e60216fb756f1a0cbeedc9da7b26d78783c2918840ed4c776f32813c414491","vc_description_hash":"efb6140b0a75af12416cb1a34aaa6ba166d0407a956d27bfa7d4848b2d248f76","vc_spec_hash":"75ff929b1d495f6c1516dee8f209c88c94b269a1829d254ca284afab0b5d1866","vc_preamble_hash":"de76cf40cf0bd1710cf761ede19cc9f75c3a8871a17dbc55b8c2a9a914b7cfc2","description_normalized_hash":"c23b4979b947d2b34d95068c7653f1e9c7b58fc253b5889f5842445bc44d6082","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn has_close_elements(numbers: &Vec<i32>, threshold: i32) -> (result: bool)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_basic_64_task","vc-description":"This task requires writing a Verus method that inserts a subarray of characters into another array of characters at a specified index. The method takes the original array (oline) and, given the effective length l to consider, inserts another array of characters (nl) of effective length p starting at the index atPos. The resulting array is of length l + p and is constructed as follows:\n\u2022 All characters before the insertion position (atPos) remain unchanged.\n\u2022 The new characters from nl are inserted starting at index atPos.\n\u2022 The remaining characters from the original array (starting at atPos) are shifted right by p positions.\n\n-----Input-----\nThe input consists of:\n\u2022 oline: An array of characters representing the original sequence.\n\u2022 l: A natural number indicating how many characters from oline to consider.\n\u2022 nl: An array of characters to be inserted into oline.\n\u2022 p: A natural number indicating how many characters from nl to consider for insertion.\n\u2022 atPos: A natural number indicating the position in oline where the insertion should occur (0-indexed).\n\n-----Output-----\nThe output is an array of characters that is the result of inserting nl into oline at the given atPos. Specifically, the output array should:\n\u2022 Contain the original characters from index 0 up to (but not including) atPos.\n\u2022 Have the next p characters equal to the characters from nl.\n\u2022 Contain the remaining characters from oline (starting from atPos) shifted right by p positions.\n\n-----Note-----\nIt is assumed that:\n\u2022 atPos is within the range [0, l].\n\u2022 l does not exceed the size of oline.\n\u2022 p does not exceed the size of nl.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn insert(oline: &Vec<char>, l: usize, nl: &Vec<char>, p: usize, at_pos: usize) -> (result: Vec<char>)\n    requires\n        l <= oline.len(),\n        p <= nl.len(),\n        at_pos <= l,\n    ensures\n        result.len() == l + p,\n        forall|i: int| 0 <= i < p ==> #[trigger] result[at_pos + i] == nl[i],\n        forall|i: int| 0 <= i < at_pos ==> #[trigger] result[i] == oline[i],\n        forall|i: int| 0 <= i < (l - at_pos) ==> #[trigger] result[at_pos + p + i] == oline[at_pos + i],","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"3f3b6fc25321cff911a935dc2d1289380a3a79baffc05097c1a8f322674be84a","vc_description_hash":"18315f5aedd7b64be3054cb64a49de2ce53b524d1bbf3fbc1fadc57ed11bb00e","vc_spec_hash":"c1023c4d2a95070f17897ea2acc17da2b30cccbb025bc95082fcfaa32ab8811f","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"654d69be341e5d78ba2d7752d5d84c0255586d75c1084442b57291c9ab8b31c2","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn insert(oline: &Vec<char>, l: usize, nl: &Vec<char>, p: usize, at_pos: usize) -> (result: Vec<char>)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_basic_65_task","vc-description":"This task involves computing the integer square root of a given natural number. The goal is to determine the largest natural number r that satisfies r * r \u2264 N and N < (r + 1) * (r + 1).\n\n-----Input-----\nThe input consists of:\n\u2022 N: A natural number.\n\n-----Output-----\nThe output is a natural number r that meets the following conditions:\n\u2022 r * r \u2264 N\n\u2022 N < (r + 1) * (r + 1)\n\n-----Note-----\nThe implementation relies on a recursive strategy to iteratively increment r until (r + 1)*(r + 1) exceeds N. Edge cases, such as N = 0, should be handled correctly.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn square_root(n: usize) -> (result: usize)\n    ensures\n        result * result <= n,\n        n < (result + 1) * (result + 1),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"d40d3ccc78c804ea12bb6bce192ae4c52c3af28d0b4e2f00f75c68549d0dc944","vc_description_hash":"508a93887885e19b5a413f4327a9f6c4d1c4dcedf0de42487056f7f2c2b0b992","vc_spec_hash":"37be1a000fbdff051dbfbd1e83fa4e38eaf8a4be66ec8125c1b034e90942441c","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"f8136052abcacc580ae7cd454b9b378d68d47b455bca75d0270ec7fbc126d8e1","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn square_root(n: usize) -> (result: usize)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_66_task","vc-description":"This task focuses on determining if a given integer is even. The problem requires checking whether the integer can be represented as twice another integer, meaning it is divisible by 2 without any remainder.\n\n-----Input-----\nThe input consists of a single integer:\n\u2022 x: An integer to be evaluated.\n\n-----Output-----\nThe output is a boolean value:\n\u2022 true if x is even (x mod 2 equals 0).\n\u2022 false if x is odd.\n\n-----Note-----\nNo additional preconditions are required. The method should work correctly for any integer value.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn compute_is_even(x: int) -> (result: bool)\n    ensures\n        result == true <==> #[trigger] (x % 2) == 0,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"a3ae4f2cd50d93a69a73103a7102e7030a6e791d9b61f26e9034a600a3248640","vc_description_hash":"88037063ec0fd62a65d0ac2229bb5115e9a81fb8ffbc2a1d84c9bc6caf144e97","vc_spec_hash":"18ab3967454ed97bfc1ef83c5f7ade6812f3e143844ab525de1063d6489c24ad","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"8416eeb521b864fc0bb4491b44e86d115b3ae896841ac2134c2524e5bd5b3486","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn compute_is_even(x: int) -> (result: bool)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_67_task","vc-description":"This task requires determining whether a given list of characters is a palindrome; that is, whether the sequence reads the same forward and backward.\n\n-----Input-----\nThe input consists of:\n\u2022 x: A list of characters (List Char). The list can be empty or non-empty.\n\n-----Output-----\nThe output is a Boolean value (Bool):\n\u2022 Returns true if the input list is a palindrome.\n\u2022 Returns false otherwise.\n\n-----Note-----\nAn empty list is considered a palindrome. The function does not impose any additional preconditions.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn is_palindrome(x: Seq<char>) -> (result: bool)\n    ensures\n        result <==> (forall|i: int| 0 <= i < x.len() ==> #[trigger] x[i] == x[x.len() - 1 - i]),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"648afc7ec5e8178a071ae1c4e076ce19ab8db745ac9dd89c8f7d9e6d058b880b","vc_description_hash":"7b4139399b7e79dd2c74a857021e5525554ef38aed9b9e41e69c6ddfa4968800","vc_spec_hash":"cb156aad97fc4c96c0ad3276cc9ec50b5324a76c30af269d52f34102a7e2b914","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"163cd82958e3671d96bc7539180a1c0c5ccd188573dee55506e4028118961f88","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn is_palindrome(x: Seq<char>) -> (result: bool)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_68_task","vc-description":"The task is to determine the position of a target integer in a given array. The goal is to return the index corresponding to the first occurrence of the target value. If the target is not present in the array, the result should indicate that by returning the size of the array. This description focuses entirely on understanding the problem without specifying any particular implementation method.\n\n-----Input-----\nThe input consists of:\n\u2022 a: An array of integers.\n\u2022 e: An integer representing the target to search for in the array.\n\n-----Output-----\nThe output is a natural number (Nat) which is:\n\u2022 The index of the first occurrence of the target integer if found.\n\u2022 The size of the array if the target integer is not present.\n\n-----Note-----\nThere are no strict preconditions on the input; the method should work correctly for any array of integers. The specification ensures that the returned index is always valid: it is either within the array bounds with a matching element or equals the array's size if the element is absent.\n\n/*\n    -- Invalid Inputs\n    []\n    -- Tests\n    [\n        {\n            \"input\": {\n                \"a\": \"#[1, 3, 5, 7, 9]\",\n                \"e\": 5\n            },\n            \"expected\": \"2\",\n            \"unexpected\": [\n                \"1\",\n                \"3\",\n                \"4\"\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"#[2, 4, 6, 8]\",\n                \"e\": 5\n            },\n            \"expected\": \"4\",\n            \"unexpected\": [\n                \"1\",\n                \"3\",\n                \"5\"\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"#[5, 5, 5]\",\n                \"e\": 5\n            },\n            \"expected\": \"0\",\n            \"unexpected\": [\n                \"1\",\n                \"2\",\n                \"3\"\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"#[10, 9, 8, 7]\",\n                \"e\": 10\n            },\n            \"expected\": \"0\",\n            \"unexpected\": [\n                \"1\",\n                \"2\",\n                \"3\"\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"#[1, 2, 3, 3, 4]\",\n                \"e\": 3\n            },\n            \"expected\": \"2\",\n            \"unexpected\": [\n                \"1\",\n                \"3\",\n                \"4\"\n            ]\n        }\n    ]\n    */","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn linear_search(a: &Vec<i32>, e: i32) -> (result: usize)\n    ensures\n        result <= a.len(),\n        result == a.len() || a[result as int] == e,\n        forall|i: int| 0 <= i < result ==> a[i] != e,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"a9d801eea4c7c4937da30b36a99e31223d4053b3e908ff366e1357810586e4ef","vc_description_hash":"27601c11ffb48f65c1a39b96346b945cfa76c9c8ea88627ef7baddd8be154078","vc_spec_hash":"b3604fefb3bce7f749bce7f183e8e42b9a92b493ab665eab8c321ffe536fec29","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"ebff4b096ce0ccf18a2311cae6491f63faea6f4b464e9ffb63bafe47dd7429cd","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn linear_search(a: &Vec<i32>, e: i32) -> (result: usize)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_69_task","vc-description":"This problem involves determining the index of the first occurrence of a specified element within an array of integers. The objective is to identify the correct position where the target element appears for the first time, ensuring that all elements prior to that index are different from the target.\n\n-----Input-----\nThe input consists of:\n\u2022 a: An array of integers.\n\u2022 e: An integer representing the element to search for.\n\n-----Output-----\nThe output is a natural number (usize) representing the index of the first occurrence of e in the array.\n\u2022 If the element e exists in the array, the index n will satisfy the conditions specified above.\n\n-----Note-----\nIt is assumed that the input satisfies the precondition where at least one index i in a exists such that a[i] = e.\nThe implementation uses a helper function to iterate through the array recursively.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn linear_search(a: &Vec<i32>, e: i32) -> (result: usize)\n    requires exists|i: int| 0 <= i < a.len() && a[i] == e,\n    ensures\n        result < a.len(),\n        a[result as int] == e,\n        forall|k: int| 0 <= k < result ==> a[k] != e,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"8a4dcd7536e04cd8416aef3e57e5d4125860d0ca242d5357d256a15130a96750","vc_description_hash":"b2e70e55f6ba662a765bab34c2530ed100f6ffa409fff70d9006605834eaf77e","vc_spec_hash":"23b402a6055699f448ad44cc92b127cc0e4cd5ef73e2495c1029e25f81cd1f09","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"792b342583aa0ec2105a11826158f2fdfeab7839ed416a71345e5049c5be7183","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn linear_search(a: &Vec<i32>, e: i32) -> (result: usize)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_basic_6_task","vc-description":"This task requires writing a Verus method that finds the minimum among three given integers. The method should return the smallest value, ensuring that the result is less than or equal to each of the input numbers and that it is one of the provided integers.\n\nInput:\nThe input consists of three integers:\na: The first integer.\nb: The second integer.\nc: The third integer.\n\nOutput:\nThe output is an integer:\nReturns the minimum of the three input numbers, assuring that the returned value is less than or equal to a, b, and c, and that it matches one of these values.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn min_of_three(a: i32, b: i32, c: i32) -> (result: i32)\n    ensures\n        result <= a && result <= b && result <= c,\n        result == a || result == b || result == c,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"70f3b7710a65fa67621cda81471969669006326c8e28036c833e5063510de63c","vc_description_hash":"8d7fd953506b41dedbee3f705faddca1ad3dcf440a7ed319de86234db819e6a6","vc_spec_hash":"e744ec12eef70eaba5b86cacc123fa0eb6188f5d38036b2b71381b081b323119","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"d8ed246dd7a7b12b15ab8c81a2a32b2bb4c695ffb3e39250627d40f20761c0f2","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn min_of_three(a: i32, b: i32, c: i32) -> (result: i32)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_70_task","vc-description":"This task involves determining the first index in an array where a given condition holds true. The goal is to identify the position of the first element that meets a specified criterion, ensuring that no preceding element does.\n\n-----Input-----\nThe input consists of:\n\u2022 a: An array of elements (for testing purposes, you can assume it is an array of integers).\n\u2022 P: A predicate function on the elements (represented as a string for test cases, e.g., \"fun x => x > 5\"). It is assumed that at least one element in the array satisfies P.\n\n-----Output-----\nThe output is a natural number (Nat) which represents the index of the first element in the array that satisfies the predicate P.\n\u2022 The index returned is less than the size of the array.\n\u2022 The element at the returned index satisfies P.\n\u2022 All elements before the returned index do not satisfy P.\n\n-----Note-----\nIt is assumed that the array contains at least one element that satisfies P. In cases where this precondition does not hold, the behavior of the function is not guaranteed by the specification.\n\n/*\n    -- Invalid Inputs\n    [\n        {\n            \"input\": {\n                \"a\": \"#[1, 2, 3, 4, 5]\",\n                \"P\": \"fun x => x > 10\"\n            }\n        }\n    ]\n    -- Tests\n    [\n        {\n            \"input\": {\n                \"a\": \"#[4, 7, 2, 9]\",\n                \"P\": \"fun x => x > 5\"\n            },\n            \"expected\": 1,\n            \"unexpected\": [\n                0,\n                2,\n                3\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"#[10, 8, 6, 4, 2]\",\n                \"P\": \"fun x => x < 5\"\n            },\n            \"expected\": 3,\n            \"unexpected\": [\n                0,\n                1,\n                4\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"#[5, 3, 1, 2]\",\n                \"P\": \"fun x => x == 1\"\n            },\n            \"expected\": 2,\n            \"unexpected\": [\n                0,\n                1,\n                3\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"#[0, 1, 2, 3]\",\n                \"P\": \"fun x => x == 0\"\n            },\n            \"expected\": 0,\n            \"unexpected\": [\n                1,\n                2,\n                3\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"#[9, 9, 9, 9]\",\n                \"P\": \"fun x => x == 9\"\n            },\n            \"expected\": 0,\n            \"unexpected\": [\n                1,\n                2,\n                3\n            ]\n        }\n    ]\n    */","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn linear_search3(a: &Vec<i32>, p: spec_fn(i32) -> bool) -> (result: usize)\n    requires \n        exists|i: int| 0 <= i < a.len() && p(a[i]),\n    ensures \n        result < a.len(),\n        p(a[result as int]),\n        forall|k: int| 0 <= k < result ==> !p(a[k]),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"82da9bd232de951848832fccc3474a974b17a0001ed9c0b5c1348f4615814154","vc_description_hash":"9654e16e884b7eb0aee3a229e6b413c84033a4f3272da5251373e2f704fc51bc","vc_spec_hash":"1ff5472c2c9800131ba68f6ab0d4e75a1159e3db7c0d821242c6f5219efe628e","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"08aa6e325f48b42ac63bb97049cfec1a519acb530ecf81160700dc372364002d","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_basic_71_task","vc-description":"This problem involves determining the longest common prefix shared by two lists of characters. Given two sequences, the goal is to identify and return the maximal contiguous sequence of characters from the beginning of both lists that are identical.\n\n-----Input-----\nThe input consists of:\n\u2022 str1: A list of characters.\n\u2022 str2: A list of characters.\n\n-----Output-----\nThe output is a list of characters representing the longest common prefix of the two input lists. The output list satisfies the following conditions:\n\u2022 Its length is less than or equal to the length of each input list.\n\u2022 It is exactly the prefix of both str1 and str2.\n\u2022 It is empty if the first characters of the inputs differ or if one of the lists is empty.\n\n-----Note-----\nIt is assumed that both inputs are provided as valid lists of characters. The function always returns the correct longest common prefix based on the inputs.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn longest_common_prefix(str1: &Vec<char>, str2: &Vec<char>) -> (result: Vec<char>)\n    ensures\n        result.len() <= str1.len(),\n        result.len() <= str2.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == str1[i] && result[i] == str2[i],\n        result.len() == str1.len() || result.len() == str2.len() || \n            (result.len() < str1.len() && result.len() < str2.len() && str1[result.len() as int] != str2[result.len() as int]),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"38281f6b2f2f94f1bb9a9912f0fcb7d28813d900d8023b9591e7e10eff96e47a","vc_description_hash":"d8cb3aad6bead23343c6020ef29f558d061af0d057e7c991b851a3e629a1f82e","vc_spec_hash":"0274ef08968020bd004fdb26630254c1cd17ef5b08f87893eaf253fc95ff1b05","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"d64bb07a6b110a2feae1e577bf10901c6c8af641659bc5361491096963f3b03f","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn longest_common_prefix(str1: &Vec<char>, str2: &Vec<char>) -> (result: Vec<char>)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_72_task","vc-description":"-----Description-----\nThe problem asks you to construct a new list by adding an extra number to the end of an existing list of numbers. The focus is on understanding what the final list should look like when a given number is included as the last element.\n\n-----Input-----\nThe input consists of:\n\u2022 a: An array of integers.\n\u2022 b: An integer to be appended to the array.\n\n-----Output-----\nThe output is an array of integers which represents the original array with the element b added at the end. That is, the output array's list representation equals a.toList concatenated with [b].\n\n-----Note-----\nThere are no special preconditions; the method is expected to work correctly for any array of integers and any integer b.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn append(a: &Vec<i32>, b: i32) -> (result: Vec<i32>)\n    ensures\n        result.len() == a.len() + 1,\n        forall|i: int| 0 <= i < a.len() ==> result[i] == a[i],\n        result[a.len() as int] == b,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"fc63f6ebd1b97d4d397510fd3a569ed3673052a52effe6d65ff99bfafb437ed4","vc_description_hash":"b4b514e7e048a9e588ab244a5d6b4633019ad9ee63f810fbd9498e02435daf9e","vc_spec_hash":"a8940b9320d6b27953136ae100164c38b8e526ed1c8073cb18bbfaf7e02f01d2","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"818db5e694e2c0ad19994c6f9ac1bf01ba87e2fe99f57f72aa1095c15da4225d","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn append(a: &Vec<i32>, b: i32) -> (result: Vec<i32>)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_73_task","vc-description":"Determine whether two strings match based on a specific pattern: for each position in the strings, either the characters are the same, or the character in p is a wildcard represented by a question mark '?' that may match any character.\n\n-----Input-----\nThe input consists of:\n\u2022 s: A string that is to be matched.\n\u2022 p: A pattern string of equal length, where each character is either a specific character or the wildcard '?'.\n\n-----Output-----\nThe output is a Boolean value:\n\u2022 Returns true if the length of s is equal to the length of p and each corresponding character in s and p are either identical or the character in p is a '?'.\n\u2022 Returns false if any character in s does not match the corresponding character in p and the character in p is not a '?'.\n\n-----Note-----\nIt is assumed that both strings provided have the same length.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn match_strings(s: &str, p: &str) -> (result: bool)\n    requires s@.len() == p@.len(),\n    ensures\n        result == (forall|n: int| 0 <= n < s@.len() ==> \n            (s@.index(n) == p@.index(n) || p@.index(n) == '?' as u8)),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"058e268f87dac5b8fad93a08bbd898a5e4debd40bd2e7c2a9740182f6b0672b9","vc_description_hash":"d9a210c2703788acb86615a9ce9c4088df252f6c8dc57f7c7d7778c9e2f53b02","vc_spec_hash":"eed9d3a53fb9f6ba978c13fd06782e2126fe8cdb2b812b3c92db1a54e22bf849","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"84a991394b7626153a03f04ea5470f37aa8362bd9c4001f004ff9ea30f08b8fa","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn match_strings(s: &str, p: &str) -> (result: bool)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_basic_74_task","vc-description":"This task involves identifying the maximum value in a non-empty array of integers. The objective is to determine which element in the array is greater than or equal to every other element, ensuring that the selected value is one of the elements in the array.\n\n-----Input-----\nThe input consists of:\n\u2022 a: An array of integers. It is assumed that the array is non-empty (i.e., its size is at least 1).\n\n-----Output-----\nThe output is an integer that represents the maximum element in the array. This value is guaranteed to satisfy the following:\n\u2022 It is greater than or equal to every element in the array.\n\u2022 It is exactly equal to one of the elements in the array.\n\n-----Note-----\nIt is assumed that the provided array is non-empty. In cases where the array is empty, the function's behavior is not defined.\n\n/*\n    -- Invalid Inputs\n    [\n        {\n            \"input\": {\n                \"a\": \"[]\"\n            }\n        }\n    ]\n    -- Tests\n    [\n        {\n            \"input\": {\n                \"a\": \"[1, 2, 3, 4, 5]\"\n            },\n            \"expected\": 5,\n            \"unexpected\": [\n                4,\n                3\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"[5, 3, 4, 1, 2]\"\n            },\n            \"expected\": 5,\n            \"unexpected\": [\n                4,\n                3,\n                2\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"[7]\"\n            },\n            \"expected\": 7,\n            \"unexpected\": [\n                6,\n                8\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"[-1, -5, -3, -4]\"\n            },\n            \"expected\": -1,\n            \"unexpected\": [\n                -3,\n                -4\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"[-10, -20, -30, -5, -15]\"\n            },\n            \"expected\": -5,\n            \"unexpected\": [\n                -10,\n                -15,\n                -20\n            ]\n        }\n    ]\n    */","vc-preamble":"use vstd::prelude::*;\n\nverus! {\n\nspec fn max_array_precond(a: &Vec<i32>) -> bool {\n    a.len() > 0\n}","vc-helpers":"","vc-spec":"fn max_array(a: &Vec<i32>) -> (result: i32)\n    requires max_array_precond(a),\n    ensures\n        forall|k: int| 0 <= k < a.len() ==> result >= a[k],\n        exists|k: int| 0 <= k < a.len() && result == a[k],","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"b619fa9093dc930c3c0deff5a0081eb93d8a29c4ef48931024c2ab2fe832d4af","vc_description_hash":"77600a638338ef334901025e45e122de4b7130a7ac8ce02fab7f8890e0f7b466","vc_spec_hash":"4433c0d6e3a2ac96f9c6abf2ce8aac278f934807369e9b1df218c330afc9c90c","vc_preamble_hash":"e16bdb408c3f0b6f6d445dae04fa7e3bca74b4efff9b09e680c2d286e33cadb4","description_normalized_hash":"f59e86e31c7ffcbe6436cb8076e3b5851ba6455aa6b387465e49fe269f0ac753","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn max_array(a: &Vec<i32>) -> (result: i32)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_basic_75_task","vc-description":"This task involves finding the minimum element in a non-empty array of integers. The goal is to identify and return the smallest number present in the array.\n\n-----Input-----\nThe input consists of:\n\u2022 a: An array of integers (the array is assumed to be non-empty).\n\n-----Output-----\nThe output is an integer that:\n\u2022 Is the smallest element from the input array.\n\u2022 Satisfies the property that it is less than or equal to every element in the array and is exactly equal to at least one element of the array.\n\n-----Note-----\nIt is assumed that the input array contains at least one element. The implementation uses a helper function (loop) to recursively compare elements and determine the minimum value.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn min_array(a: &Vec<i32>) -> (result: i32)\n    requires a.len() > 0,\n    ensures\n        forall|i: int| 0 <= i < a.len() ==> result <= a[i],\n        exists|i: int| 0 <= i < a.len() && result == a[i],","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"5e44e9d62ad239e73f0c93dbbed4b6cab42d56ef430b0010a8db1b20db10235c","vc_description_hash":"b16fb0eb80b69b562da5c88141be0ee98e831e55a5d97db6b9aaa6ebd09db317","vc_spec_hash":"0894e2b0c3259494cd7855e8f4fdf0cddc8d91326932329e4853d02bdee99ec1","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"705d01160f88de527447b97318e0efb10a298838288e9af4513443ea576d3b94","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn min_array(a: &Vec<i32>) -> (result: i32)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_basic_76_task","vc-description":"This task requires determining the smaller of two integers. Given two input numbers, the goal is to compare them and return the one that is less than or equal to the other.\n\n-----Input-----\nThe input consists of two integers:\n\u2022 x: The first integer.\n\u2022 y: The second integer.\n\n-----Output-----\nThe output is an integer representing the minimum of the two input integers:\n\u2022 Returns x if x is less than or equal to y.\n\u2022 Returns y if x is greater than y.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn my_min(x: i32, y: i32) -> (result: i32)\n    ensures\n        (x <= y ==> result == x) && (x > y ==> result == y),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"f133715d7df76beff1f666b56db01303ed72e31c2b851188d64bee9b3b04cd63","vc_description_hash":"5dedb8bf100aecdf252814174b0c2d9525a2cd9abe6ef35ebb57e7289d4ba449","vc_spec_hash":"f0ae863ca28d3d8a0cd2546efbdf6a48884bfb18a0130b4a6fdd8ca022b0ca2f","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"f4d16903ebb903ec1b24c87804aed3bd1319accab99f44d89bf6ce6c1ee39fd3","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn my_min(x: i32, y: i32) -> (result: i32)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_77_task","vc-description":"This task involves updating an element within a 2-dimensional array. The goal is to modify only a specific inner array by changing one of its elements to a new value while keeping every other element and all other inner arrays unchanged.\n\n-----Input-----\nThe input consists of:\n\u2022 arr: An array of arrays of natural numbers.\n\u2022 index1: A natural number representing the index in the outer array identifying which inner array to modify (0-indexed).\n\u2022 index2: A natural number representing the index within the selected inner array that should be updated (0-indexed).\n\u2022 val: A natural number which is the new value to set at the specified inner index.\n\n-----Output-----\nThe output is an array of arrays of natural numbers that:\n\u2022 Has the same overall structure as the input.\n\u2022 Contains all original inner arrays unchanged except for the inner array at position index1.\n\u2022 In the modified inner array, only the element at index2 is replaced with val, while all other elements remain the same.\n\n-----Note-----\nIt is assumed that index1 is a valid index for the outer array and that index2 is a valid index within the corresponding inner array.\n\n/* \n    -- Invalid Inputs\n    [\n        {\n            \"input\": {\n                \"arr\": \"#[#[1, 2, 3], #[4, 5, 6]]\",\n                \"index1\": 1,\n                \"index2\": 3,\n                \"val\": 99\n            }\n        }\n    ]\n    -- Tests\n    [\n        {\n            \"input\": {\n                \"arr\": \"#[#[1, 2, 3], #[4, 5, 6]]\",\n                \"index1\": 0,\n                \"index2\": 1,\n                \"val\": 99\n            },\n            \"expected\": \"#[#[1, 99, 3], #[4, 5, 6]]\",\n            \"unexpected\": [\n                \"#[#[1, 2, 3], #[4, 99, 6]]\",\n                \"#[#[1, 99, 3], #[4, 5, 7]]\",\n                \"#[#[99, 1, 3], #[4, 5, 6]]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"arr\": \"#[#[7, 8], #[9, 10]]\",\n                \"index1\": 1,\n                \"index2\": 0,\n                \"val\": 0\n            },\n            \"expected\": \"#[#[7, 8], #[0, 10]]\",\n            \"unexpected\": [\n                \"#[#[7, 0], #[9, 10]]\",\n                \"#[#[7, 8], #[9, 0]]\",\n                \"#[#[0, 8], #[9, 10]]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"arr\": \"#[#[0, 0, 0]]\",\n                \"index1\": 0,\n                \"index2\": 2,\n                \"val\": 5\n            },\n            \"expected\": \"#[#[0, 0, 5]]\",\n            \"unexpected\": [\n                \"#[#[0, 5, 0]]\",\n                \"#[#[5, 0, 0]]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"arr\": \"#[#[3, 4, 5], #[6, 7, 8], #[9, 10, 11]]\",\n                \"index1\": 2,\n                \"index2\": 1,\n                \"val\": 100\n            },\n            \"expected\": \"#[#[3, 4, 5], #[6, 7, 8], #[9, 100, 11]]\",\n            \"unexpected\": [\n                \"#[#[3, 4, 5], #[6, 7, 8], #[9, 10, 11]]\",\n                \"#[#[3, 4, 5], #[6, 7, 8], #[9, 7, 11]]\",\n                \"#[#[3, 4, 5], #[6, 7, 8], #[100, 10, 11]]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"arr\": \"#[#[1]]\",\n                \"index1\": 0,\n                \"index2\": 0,\n                \"val\": 42\n            },\n            \"expected\": \"#[#[42]]\",\n            \"unexpected\": [\n                \"#[#[1]]\",\n                \"#[#[0]]\",\n                \"#[#[99]]\"\n            ]\n        }\n    ]\n    */","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn modify_array_element(arr: Vec<Vec<nat>>, index1: usize, index2: usize, val: nat) -> (result: Vec<Vec<nat>>)\n    requires\n        index1 < arr.len(),\n        index2 < arr[index1 as int].len(),\n    ensures\n        result.len() == arr.len(),\n        forall|i: int| 0 <= i < arr.len() && i != index1 ==> result[i] == arr[i],\n        forall|j: int| 0 <= j < arr[index1 as int].len() && j != index2 ==> result[index1 as int][j] == arr[index1 as int][j],\n        result[index1 as int][index2 as int] == val,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"d6e90bab51e3a17fa629afc5593f0ecb669f369e9b7b11fafb9ffd7d09c473b8","vc_description_hash":"677b8756204112e39a9b6c805c3289c3c2218844ec482d353012d2251b3e2b37","vc_spec_hash":"adc70d1aebcdefb9f66ab9aaa6251e576187a846efb57fa636821241757000d5","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"b44be9662506df1c8be2697407ab0cb5f5f2f5deecb1752e02e52bbf5285ae8f","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn modify_array_element(arr: Vec<Vec<nat>>, index1: usize, index2: usize, val: nat) -> (result: Vec<Vec<nat>>)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_basic_78_task","vc-description":"Given two integers, the task is to compute two output values: one being the sum of the integers and the other being their difference.\n\n-----Input-----\nThe input consists of two integers:\n\u2022 x: An integer.\n\u2022 y: An integer.\n\n-----Output-----\nThe output is a tuple of two integers:\n\u2022 The first element is x + y.\n\u2022 The second element is x - y.\n\n-----Note-----\nIt is assumed that x and y are valid integers. There are no additional constraints on the inputs.\n\n/*\n    // -- Invalid Inputs\n    // []\n    // -- Tests\n    // [\n    //     {\n    //         \"input\": {\n    //             \"x\": 3,\n    //             \"y\": 2\n    //         },\n    //         \"expected\": \"(5, 1)\",\n    //         \"unexpected\": [\n    //             \"(6, 2)\",\n    //             \"(5, 2)\",\n    //             \"(4, 1)\"\n    //         ]\n    //     },\n    //     {\n    //         \"input\": {\n    //             \"x\": -2,\n    //             \"y\": 3\n    //         },\n    //         \"expected\": \"(1, -5)\",\n    //         \"unexpected\": [\n    //             \"(-1, 5)\",\n    //             \"(2, -3)\",\n    //             \"(1, 5)\"\n    //         ]\n    //     },\n    //     {\n    //         \"input\": {\n    //             \"x\": 0,\n    //             \"y\": 0\n    //         },\n    //         \"expected\": \"(0, 0)\",\n    //         \"unexpected\": [\n    //             \"(1, 0)\",\n    //             \"(0, 1)\",\n    //             \"(-1, 0)\"\n    //         ]\n    //     },\n    //     {\n    //         \"input\": {\n    //             \"x\": 10,\n    //             \"y\": 5\n    //         },\n    //         \"expected\": \"(15, 5)\",\n    //         \"unexpected\": [\n    //             \"(14, 5)\",\n    //             \"(15, 6)\",\n    //             \"(10, 5)\"\n    //         ]\n    //     },\n    //     {\n    //         \"input\": {\n    //             \"x\": -5,\n    //             \"y\": -10\n    //         },\n    //         \"expected\": \"(-15, 5)\",\n    //         \"unexpected\": [\n    //             \"(-15, -5)\",\n    //             \"(-5, 15)\",\n    //             \"(-10, 0)\"\n    //         ]\n    //     }\n    // ]\n    // */\n\n//","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn multiple_returns(x: i32, y: i32) -> (result: (i32, i32))\n    ensures\n        result.0 == x + y,\n        result.1 + y == x,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"6a0336af7e8895355b24357b9b90a26721a1f357a487c668b95f1fe2a14e80de","vc_description_hash":"cbf620d64607026d26a4381652b37dd1a9b4a847561b1d2e62ff8eb098515c72","vc_spec_hash":"a4e6afeb039fe2c9b7995ead25727a55a31ab56dabdc0a74775f7feb1e4a403b","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"df66b8a7423788ebba4e68285c9cce41ff81f0b0bf567354ad3fd15e9f78e6f5","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn multiple_returns(x: i32, y: i32) -> (result: (i32, i32)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_79_task","vc-description":"Given a nonempty array of integers and a valid index x (with 1 \u2264 x < array size), the task is to identify two key pieces of information. First, determine the maximum value among the first x elements of the array. Second, select an index p within the range [x, array size) that satisfies the following conditions: if there exists an element in the segment starting from index x that is strictly greater than the previously determined maximum, then p should be the index of the first such occurrence; otherwise, p should be set to the last index of the array. The focus of the problem is solely on correctly identifying the maximum and choosing the appropriate index based on these order conditions.\n\nInput:\nThe input consists of:\n\u2022 a: An array of integers (assumed to be nonempty).\n\u2022 x: A natural number (Nat) such that 1 \u2264 x < a.size.\n\nOutput:\nThe output is a pair (m, p) where:\n\u2022 m is the maximum value among the first x elements of the array.\n\u2022 p is an index in the array, with x \u2264 p < a.size, determined based on the ordering condition where a[p] is the first element (from index x onward) that is strictly greater than m. If no such element exists, then p is set to a.size \u2212 1.\n\nNote:\nIt is assumed that the array a is nonempty and that the parameter x meets the precondition 1 \u2264 x < a.size. The function relies on helper functions to compute the maximum among the first x elements and to select the appropriate index p based on the given conditions.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn online_max(a: &Vec<i32>, x: usize) -> (result: (i32, usize))\n    requires\n        a.len() > 0,\n        x < a.len(),\n    ensures\n        ({\n            let (m, p) = result;\n            x <= p && p < a.len()\n            && (forall|i: int| 0 <= i < x ==> a[i] <= m)\n            && (exists|i: int| 0 <= i < x && a[i] == m)\n            && ((p < a.len() - 1) ==> (exists|i: int| x <= i <= p && a[i] > m))\n            && ((forall|i: int| x <= i < a.len() ==> a[i] <= m) ==> p == a.len() - 1)\n        })","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"53e52b2ed061cc5cd52dae77de09ad64e9b4ad6b8d56262d521c945a6d5796b1","vc_description_hash":"7ce017cfd8106af909f4d193b2feec67f1a40d529b3f9397d23b1f29df1ecfc9","vc_spec_hash":"2b1915ef9c57d662efa9d9b36eee41e1bf1769128085f62b5f4e6967c3abb632","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"18bec204af061b127843147a33ec729b8fd446ec63ac5b357a5e7822d25303f1","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn online_max(a: &Vec<i32>, x: usize) -> (result: (i32, usize)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_basic_7_task","vc-description":"This task requires writing a Verus method that computes the sum of the squares of the first n odd natural numbers. The result should match the formula: (n * (2 * n - 1) * (2 * n + 1)) / 3.\n\n-----Input-----\nThe input consists of:\nn: A natural number representing the count of odd natural numbers to consider (n should be non-negative).\n\n-----Output-----\nThe output is a natural number:\nReturns the sum of the squares of the first n odd natural numbers, as defined by the formula: (n * (2 * n - 1) * (2 * n + 1)) / 3.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn sum_of_squares_of_first_n_odd_numbers(n: u32) -> (result: u32)\n    requires n >= 0,\n    ensures\n        result as int == (n as int * (2 * n as int - 1) * (2 * n as int + 1)) / 3,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"734a0577292173cb3ee1ce90f7101971a8395c6b97cf8fc6837b2e939a086930","vc_description_hash":"40ddf32cff44e83ca62d3932c2f48a4c65f4dfd2dad2133492ade8aa8064a057","vc_spec_hash":"effb28e861a5818f645d3eeb8ffbb82a7bc182c059510c0923ba4fb1c618a8a8","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"d7bf2b8c735b2e40656b4955a64ced25ba9fff1f5f952a26ca90a286fa7e03cd","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn sum_of_squares_of_first_n_odd_numbers(n: u32) -> (result: u32)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_basic_80_task","vc-description":"This task involves determining whether a specified key appears exactly once in an array. The goal is to verify the uniqueness of the key's occurrence without prescribing any specific approach or implementation method.\n\n-----Input-----\nThe input consists of:\n\u2022 a: An array of integers.\n\u2022 key: An integer representing the element whose occurrence is to be checked.\n\n-----Output-----\nThe output is a Boolean value that:\n\u2022 Is true if the key appears exactly once in the array.\n\u2022 Is false otherwise.\n\n-----Note-----\nThe function should correctly handle arrays with no occurrences of the key, multiple occurrences, and exactly one occurrence.","vc-preamble":"use vstd::prelude::*;\n\nverus! {\n\nspec fn count_occurrences(a: Seq<i32>, key: i32) -> nat {\n    a.filter(|x: i32| x == key).len()\n}","vc-helpers":"","vc-spec":"fn only_once(a: &Vec<i32>, key: i32) -> (result: bool)\n    ensures\n        result <==> count_occurrences(a@, key) == 1,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"c1012fe7aba77a9a3a02a0922e2ef8ce88c8695b264e7b2b9f3a24f81d5a5142","vc_description_hash":"5a9924d05a6c26867f8978a42197a0ef2f50c7261376604aeca58322b08a4abc","vc_spec_hash":"6a6a6fb29a1e434057f67ecd2340dc26ed2addc9de42722963d9ca96050ff6ad","vc_preamble_hash":"1ba218d37cb8bbc630752f344809de449e3edc931a935c6dd8a893a14bddda91","description_normalized_hash":"28ea09738e838a894760695ee0813c001bed98ac3165cad7cf7c3888dae4fd63","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn only_once(a: &Vec<i32>, key: i32) -> (result: bool)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_82_task","vc-description":"This task is about processing an array of integers by producing a new array that excludes the first element. The objective is to define a clear behavior: if the array contains at least one element, return a modified array starting from the second element.\n\n-----Input-----\nThe input consists of:\n\u2022 a: An array of integers.\n\n-----Output-----\nThe output is an array of integers that:\n\u2022 Has a length equal to the original array's length minus one.\n\u2022 Contains the same elements as the input array except for the first element.\n\u2022 Satisfies the condition that for every index i in the output array, the element at position i is equal to the element at position i+1 in the input array.\n\n-----Note-----\nIt is assumed that the input array is non-empty.\n\n/* \n    -- Invalid Inputs\n    [\n        {\n            \"input\": {\n                \"a\": \"#[]\"\n            }\n        }\n    ]\n    -- Tests\n    [\n        {\n            \"input\": {\n                \"a\": \"#[1, 2, 3, 4, 5]\"\n            },\n            \"expected\": \"#[2, 3, 4, 5]\",\n            \"unexpected\": [\n                \"#[1, 2, 3, 4, 5]\",\n                \"#[3, 4, 5]\",\n                \"#[2, 3, 4]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"#[10, 20, 30]\"\n            },\n            \"expected\": \"#[20, 30]\",\n            \"unexpected\": [\n                \"#[10, 20, 30]\",\n                \"#[10, 30]\",\n                \"#[10, 20]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"#[0, -1, -2, -3]\"\n            },\n            \"expected\": \"#[-1, -2, -3]\",\n            \"unexpected\": [\n                \"#[0, -1, -2, -3]\",\n                \"#[-1, -3]\",\n                \"#[-2, -3]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"#[7]\"\n            },\n            \"expected\": \"#[]\",\n            \"unexpected\": [\n                \"#[7]\",\n                \"#[0]\",\n                \"#[7, 7]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"#[100, 0, 50]\"\n            },\n            \"expected\": \"#[0, 50]\",\n            \"unexpected\": [\n                \"#[100, 0, 50]\",\n                \"#[50]\",\n                \"#[0]\"\n            ]\n        }\n    ]\n    */","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn remove_front(a: &Vec<i32>) -> (result: Vec<i32>)\n    requires a.len() > 0,\n    ensures\n        a.len() > 0,\n        result.len() == a.len() - 1,\n        forall|i: int| 0 <= i < result.len() ==> result[i] == a[i + 1],","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"20c4b78813c10a796dec99fe5914f80d5965a2f4d73e773104ec58365bd4e763","vc_description_hash":"afef4109980fd199fe2361010109eda26897ca526ac1c1730d151ff7aa66961c","vc_spec_hash":"1d78cfe91b5393ef10f1c192fdc34eedb3a25461faca3e82ff333a59d0917ea4","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"6a7957f56fe3fb25df021b01c2dee22234fe930ff92ec78a20000cea39e18bfa","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn remove_front(a: &Vec<i32>) -> (result: Vec<i32>)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_basic_83_task","vc-description":"This task involves concatenating two arrays of integers by appending the second array to the end of the first array. The goal is to produce a new array that sequentially contains all elements from the first array followed by all elements from the second array.\n\n-----Input-----\nThe input consists of two parameters:\n\u2022 a: An Array of integers representing the first part of the concatenated array.\n\u2022 b: An Array of integers representing the second part of the concatenated array.\n\n-----Output-----\nThe output is an Array of integers that satisfies the following:\n\u2022 The length of the output array is equal to the sum of the lengths of arrays a and b.\n\u2022 The first part of the output array (indices 0 to a.size - 1) is identical to array a.\n\u2022 The remaining part of the output array (indices a.size to a.size + b.size - 1) is identical to array b.\n\n-----Note-----\nNo additional preconditions are required since the function uses the sizes of the input arrays to build the resulting array.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn concat(a: &Vec<i32>, b: &Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        result.len() == a.len() + b.len(),\n        forall|k: int| 0 <= k < a.len() ==> result[k] == a[k],\n        forall|k: int| 0 <= k < b.len() ==> result[k + a.len()] == b[k],","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"c5061a93c915a0c4a7d67bf085934383e4f7ea9a2207069d6bcef50a0edcab07","vc_description_hash":"d8e36edf3cfea8801be28e0bb984227be5293b6bc463dbeca218fc97752aa783","vc_spec_hash":"5aca8ca47f5ad5b235639c44aba54ecfcd3018feb1a56db035a2121f779aa880","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"27fda65f7540408f8c0417147ac793204ca418e0f149d57a957cbef2ed8ade61","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn concat(a: &Vec<i32>, b: &Vec<i32>) -> (result: Vec<i32>)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_84_task","vc-description":"You are given an array of integers and a threshold value k. The problem is to create a new array where every element greater than k is replaced with -1 while every other element remains unchanged.\n\n-----Input-----\nThe input consists of:\n\u2022 arr: An array of integers.\n\u2022 k: An integer used as the threshold for replacement.\n\n-----Output-----\nThe output is an array of integers that satisfies the following conditions:\n\u2022 For every index i, if arr[i] is greater than k, then the returned array at index i is -1.\n\u2022 For every index i, if arr[i] is less than or equal to k, then the returned array at index i remains unchanged.\n\n-----Note-----\nIt is assumed that the input array may be empty or non-empty, and that k can be any integer. There are no additional preconditions.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn replace(arr: &Vec<i32>, k: i32) -> (result: Vec<i32>)\n    ensures\n        result.len() == arr.len(),\n        forall|i: int| 0 <= i < arr.len() ==> (arr[i] > k ==> result[i] == -1),\n        forall|i: int| 0 <= i < arr.len() ==> (arr[i] <= k ==> result[i] == arr[i]),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"ad05c03b140d405845a2a0dfa1280f2f53d64454680b444e3f2e4b06996e3822","vc_description_hash":"7ece0c656db16ca3f3482b317567e2eda75351de6e8fc7ee539bcc5de7169ea2","vc_spec_hash":"a1a7367c375905176cdbe3d7c949d588604a5c1b5f02db1e0ef2b68ef85fe742","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"4d53dbf164654e074916432d3ad9c0d8b5f3b0d28c2d8a678b7fad16e6586984","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn replace(arr: &Vec<i32>, k: i32) -> (result: Vec<i32>)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_85_task","vc-description":"This problem focuses on reversing an array of integers. The goal is to take an input array and produce a new array with the elements arranged in the reverse order.\n\n-----Input-----\nThe input consists of:\n\u2022 a: An array of integers, which may be empty, contain one element, or many elements.\n\n-----Output-----\nThe output is an array of integers that:\n\u2022 Has the same length as the input array.\n\u2022 Contains the same elements as the input array, but in reverse order.\n\u2022 For every valid index i in the input array, the output at index i is equal to the element at index (a.size - 1 - i) from the input array.\n\n-----Note-----\nThere are no specific preconditions; the method should correctly handle any array of integers.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn reverse(a: &Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> result[i] == a[a.len() - 1 - i],","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"68443d4c4f390fd6e9418fecc0becc5f14fab786ca1fb49883ef7425c768da44","vc_description_hash":"5e32b2cbd984447fe5995a1c38be3eb78724169e55b567a462a675ba824b50f6","vc_spec_hash":"d63a225878d939ee675c62f1f874168e5e925f22425d9e38cb190d205d81e9b8","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"43b8c54963f38db114636a614804d0ab93a6a61b7dee2ace290f016560884423","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn reverse(a: &Vec<i32>) -> (result: Vec<i32>)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_86_task","vc-description":"This task requires writing a Verus method that rotates an array of integers to the left by a specified offset.\n\n-----Input-----\nThe input consists of:\n\u2022 a: An array of integers (which may be empty or non-empty).\n\u2022 offset: An integer representing the number of positions to rotate the array. The offset is assumed to be non-negative.\n\n-----Output-----\nThe output is an array of integers that:\n\u2022 Has the same length as the input array.\n\u2022 For every valid index i, the output element at index i is equal to the input element at index ((i + offset) mod n), where n is the array size.\n\n-----Note-----\nIf the array is empty, the method should return an empty array.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn rotate(a: &Vec<i32>, offset: int) -> (result: Vec<i32>)\n    requires offset >= 0,\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> {\n            let src_idx = (i + offset) % (a.len() as int);\n            #[trigger] result[i] == a[src_idx]\n        },","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"281a86a05bec403d3d59503bfce331e6505782239d43619032a1eea26b9e5bf1","vc_description_hash":"291c6052ae2c67756626bebdb860071d03eb39c5ea68b00e2fd833afbd93dfb4","vc_spec_hash":"3eb391e5b42dee87ca84ea6fad7f951e4e2ef06cbbbe1b87553cdb01ec07ba6c","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"2b6fd26d6c70c1b01e570f13e2cdeb246f604bef9797d77a723cb977d25bf9fb","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn rotate(a: &Vec<i32>, offset: int) -> (result: Vec<i32>)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_basic_87_task","vc-description":"This problem requires sorting an array of integers into non-decreasing order, ensuring that the output contains exactly the same elements as the input (i.e., it is a permutation of the original array).\n\nInput: The input consists of an array of integers (Vec<i32>).\n\nOutput: The output is an array of integers that is:\n\u2022 Sorted in non-decreasing order.\n\u2022 A permutation of the input, meaning it contains exactly the same elements (with the same multiplicities) as the original array.\n\nNote: It is assumed that the input array is valid and that the swap operations, along with the helper functions, correctly implement the selection sort algorithm.\n\n// Invalid Inputs: []\n\n// Tests:\n\n// Test 1: input a = vec![3, 1, 2], expected vec![1, 2, 3]\n\n// Test 2: input a = vec![0], expected vec![0] \n\n// Test 3: input a = vec![5, 4, 3, 2, 1], expected vec![1, 2, 3, 4, 5]\n\n// Test 4: input a = vec![2, 2, 1, 4], expected vec![1, 2, 2, 4]\n\n// Test 5: input a = vec![10, -5, 0, 3], expected vec![-5, 0, 3, 10]","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn selection_sort(a: &Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int, j: int| 0 <= i <= j < result.len() ==> result[i] <= result[j],\n        result@ =~= a@,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"e430bd52bf2ee61f5f4e24eae4291b148dd89a2c6c18e03578270a789a6c5e19","vc_description_hash":"1bcdd0e19218617566729ce10a575f84837538f0b767f34c2ccb723090b9bffa","vc_spec_hash":"e742b2ea03b10fcac7c5c8461f83ea274d2e073c013eb00cab7d47f395d73b21","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"2fec4beacf86ae14714ecb1776cd6a3c60eeca0c253b95d46db1ce8c94ac985c","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn selection_sort(a: &Vec<i32>) -> (result: Vec<i32>)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_88_task","vc-description":"This task involves converting a list of integers into an array such that the array contains all the elements of the list in the exact same order. The objective is to ensure that the array has the same number of elements as the list and that each element in the array corresponds exactly to the element at the same position in the list.\n\nInput:\nThe input consists of:\n\u2022 xs: A list of integer elements.\n\nOutput:\nThe output is an array of elements of type integer that:\n\u2022 Has a size equal to the length of the input list xs.\n\u2022 Contains all the elements from xs in the same order, ensuring that for every valid index i, the array element at i is equal to the list element at i.\n\nNote:\nThere are no additional preconditions; the method should work correctly for any list of elements.\nA corresponding specification is provided stating that the array's size equals the list's length and that each element is preserved.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn to_array(xs: &Seq<i32>) -> (result: Vec<i32>)\n    ensures\n        result.len() == xs.len(),\n        forall|i: int| 0 <= i < xs.len() ==> result[i] == xs[i],","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"0bf5ee6cf79cbd57a009e9965ef2488fee35502dd44022a90084ec5480f47152","vc_description_hash":"6f4f241fdac42f42c3fd842e514ba3c3618308e13f8c5799b2f0b1b4c0619276","vc_spec_hash":"c2d1dbc62cf0ca58fe505e187454c805273f378b34dc93173d0604dcf73c209e","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"26556c58bcc10a22b71219e5e44248cb254479cc40b959fa06902f28fb873f36","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn to_array(xs: &Seq<i32>) -> (result: Vec<i32>)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_89_task","vc-description":"This problem asks you to design a solution that transforms a list with possible duplicate entries into a new list where each element appears only once, maintaining the order of its first occurrence.\n\n-----Input-----\nThe input consists of:\n\u2022 s: A list of integers (or any type supporting decidable equality) that may contain duplicate elements.\n\n-----Output-----\nThe output is a list of integers (or the original type) in which every duplicate element is removed. The order of elements is preserved based on their first appearance in the input list, ensuring that the set of elements in the output is identical to the set in the input.\n\n-----Note-----\nNo additional preconditions are required. The method should correctly handle any list, including an empty list.\n\n// All elements are unique in the result  \n\n// Every element in result is in s\n\n// Every element in s is in result\n\n/*\n    -- Invalid Inputs\n    []\n    -- Tests\n    [\n        {\n            \"input\": {\n                \"s\": \"[1, 2, 2, 3, 1]\"\n            },\n            \"expected\": \"[1, 2, 3]\",\n            \"unexpected\": [\n                \"[1, 3, 2]\",\n                \"[1, 2, 2, 3]\",\n                \"[2, 1, 3]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"s\": \"[5, 5, 5, 5]\"\n            },\n            \"expected\": \"[5]\",\n            \"unexpected\": [\n                \"[5, 5]\",\n                \"[]\",\n                \"[6]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"s\": \"[]\"\n            },\n            \"expected\": \"[]\",\n            \"unexpected\": [\n                \"[1]\",\n                \"[2]\",\n                \"[0]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"s\": \"[11, 22, 33]\"\n            },\n            \"expected\": \"[11, 22, 33]\",\n            \"unexpected\": [\n                \"[33, 22, 11]\",\n                \"[11, 11, 22, 33]\",\n                \"[11, 33]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"s\": \"[3, 1, 4, 1, 5, 9, 2, 6, 5]\"\n            },\n            \"expected\": \"[3, 1, 4, 5, 9, 2, 6]\",\n            \"unexpected\": [\n                \"[3, 1, 4, 1, 5, 9, 2, 6, 5]\",\n                \"[1, 3, 4, 5, 9, 2, 6]\",\n                \"[3, 1, 4, 5, 9, 6]\"\n            ]\n        }\n    ]\n    */","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn set_to_seq(s: &Vec<i32>) -> (result: Vec<i32>)\n    ensures\n\n        forall|i: int, j: int| 0 <= i < j < result.len() ==> result[i] != result[j],\n\n        forall|i: int| 0 <= i < result.len() ==> \n            exists|j: int| 0 <= j < s.len() && s[j] == #[trigger] result[i],\n\n        forall|i: int| 0 <= i < s.len() ==> \n            exists|j: int| 0 <= j < result.len() && result[j] == #[trigger] s[i],","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"d57f9a4b79e440ffb835217581d979251eaf458ec4aa0a6567a202729583cd2d","vc_description_hash":"45e1e184c967895cc7bfbe3d8de3836bfde44d830bbfa21314142d7225d49fe2","vc_spec_hash":"95739a7cb96bf75d73c8ef179d7a4a8102ce025252256917fb10d5bbfc2ce4f7","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"af0d64f4a3e7f2c918052e13304aacd2991e7eeb3f7039f3a4903b69fa5bd067","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn set_to_seq(s: &Vec<i32>) -> (result: Vec<i32>)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_8_task","vc-description":"This task requires writing a Verus method that determines the minimum of two integers. The method should return the smaller of the two numbers. When both numbers are equal, either one may be returned.\n\n-----Input-----\nThe input consists of two integers:\na: The first integer.\nb: The second integer.\n\n-----Output-----\nThe output is an integer:\nReturns the smaller value between the input integers, ensuring that the result is less than or equal to both inputs.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn my_min(a: i32, b: i32) -> (result: i32)\n    ensures\n        result <= a && result <= b,\n        result == a || result == b,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"5e8e4e5dd766e5f38dc03f6994e7d35ea55839520748bc7b95c2fe1ac99a12ba","vc_description_hash":"362ddd15a1cb7e2b3e508f777dc588f2418520437096c0f025496a6e5aa42aa4","vc_spec_hash":"de3cca40133a68fb2a9235996b9ae88e1b28137ad9ad156b4841ffbe794ea305","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"1c5c1ffe65e86fc9cdfd7a2f5e30be8d699836a7e6a50a7cccd7315b16071f13","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn my_min(a: i32, b: i32) -> (result: i32)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_90_task","vc-description":"The task is to search for a specific integer in a 2D array where the rows and columns are sorted in non-decreasing order. The goal is to locate the key and return its position as row and column indices, or return (-1, -1) if the algorithm fails to find the key.\n\n-----Input-----\nThe input consists of:\n\u2022 a: A non-empty 2D array of integers (Vec<Vec<i32>>). The array is guaranteed to contain at least one element.\n\u2022 key: An integer value (i32) to search for in the array.\n\n-----Output-----\nThe output is a pair of integers (i32, i32):\n\u2022 If the key is found, the first element represents the row index and the second element represents the column index such that get2d a row col = key.\n\u2022 If the key is not found, the function returns (-1, -1).\n\n-----Note-----\nIt is assumed that the input 2D array is sorted by rows and columns.\n\n/* Invalid Inputs\n    [\n        {\n            \"input\": {\n                \"a\": \"vec![vec![1, 3, 2], vec![0, 6, 5], vec![7, 8, 9]]\",\n                \"key\": 2\n            }\n        }\n    ]\n    Tests\n    [\n        {\n            \"input\": {\n                \"a\": \"vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]\",\n                \"key\": 5\n            },\n            \"expected\": \"(1, 1)\",\n            \"unexpected\": [\n                \"(1, 2)\",\n                \"(0, 1)\"\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]\",\n                \"key\": 3\n            },\n            \"expected\": \"(0, 2)\",\n            \"unexpected\": [\n                \"(0, 1)\",\n                \"(1, 2)\"\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]\",\n                \"key\": 10\n            },\n            \"expected\": \"(-1, -1)\",\n            \"unexpected\": [\n                \"(1, 1)\",\n                \"(2, 2)\"\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"vec![vec![1, 2, 3, 4]]\",\n                \"key\": 4\n            },\n            \"expected\": \"(0, 3)\",\n            \"unexpected\": [\n                \"(0, 2)\",\n                \"(1, 3)\",\n                \"(0, 4)\"\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"vec![vec![1], vec![2], vec![3], vec![4]]\",\n                \"key\": 3\n            },\n            \"expected\": \"(2, 0)\",\n            \"unexpected\": [\n                \"(1, 0)\",\n                \"(2, 1)\"\n            ]\n        }\n    ] */","vc-preamble":"use vstd::prelude::*;\n\nverus! {\n\nspec fn slope_search_precond(a: &Vec<Vec<i32>>, key: i32) -> bool {\n    a.len() > 0 &&\n    (forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i].len() == a[0].len()) &&\n    (forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a[i].len() - 1 ==> #[trigger] a[i][j] <= a[i][j + 1]) &&\n    (forall|j: int, i: int| 0 <= j < a[0].len() && 0 <= i < a.len() - 1 ==> #[trigger] a[i][j] <= a[i + 1][j])\n}","vc-helpers":"","vc-spec":"fn slope_search(a: &Vec<Vec<i32>>, key: i32) -> (result: (i32, i32))\n    requires slope_search_precond(a, key),\n    ensures\n        ({\n            let (m, n) = result;\n            ((m >= 0 && m < a.len() && n >= 0 && n < a[0].len() && a[m as int][n as int] == key) ||\n             (m == -1 && n == -1 && forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a[i].len() ==> #[trigger] a[i][j] != key))\n        })","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"cc5ac8380f05d10bf5dfbc73be22aad394b1e2c901f410f6057c6b003297a005","vc_description_hash":"f88c75ddb4527967495b65d36d83de69c052e4c513c308dbd4037e5e03fe4d57","vc_spec_hash":"4012a33a64ae0b0a1275e9ef77ea864fe6227aa12b461c23591176320cc9eb74","vc_preamble_hash":"8c4a322214b56c7dc30b5ffb875c085b83f815677cdbd1391c29cb3a38d8f734","description_normalized_hash":"ca25429b5d579ff9c9d2130f9affd9c66c8c358d3bec3ecea4a3474914051ff1","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn slope_search(a: &Vec<Vec<i32>>, key: i32) -> (result: (i32, i32)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_basic_91_task","vc-description":"This task involves creating a function that swaps two integer values. Given two integers, the function should return a pair where the first element is the second input value and the second element is the first input value.\n\n-----Input-----\nThe input consists of two integers:\n\u2022 X: An integer representing the first value.\n\u2022 Y: An integer representing the second value.\n\n-----Output-----\nThe output is a pair (i32, i32) that:\n\u2022 Contains the original Y as the first element.\n\u2022 Contains the original X as the second element.\n\n-----Note-----\nThere are no additional preconditions. The function simply swaps the two input values.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn swap(x: i32, y: i32) -> (result: (i32, i32))\n    ensures\n        result.0 == y,\n        result.1 == x,\n        x != y ==> result.0 != x && result.1 != y,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"ba51293ef67316d88829268ef9459f6fb04b9dc0187ce711100d9edb3bc2f895","vc_description_hash":"da2fb3eee32afda6703593f41597457d09b42666262ed7c287cafdbdfe9685c9","vc_spec_hash":"958d4c80e862bc477ce32a24ca600a3b788f3db7dadb1a0dd1a01be2dd201b1a","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"0d8ddb7ec6b8c6b109497687a835f648275c0a70649075309a183b48d89daadc","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn swap(x: i32, y: i32) -> (result: (i32, i32)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_92_task","vc-description":"This problem involves swapping the values of two integers. Given two integers as inputs, the objective is to return the two numbers in reversed order.\n\n-----Input-----\nThe input consists of two integers:\n\u2022 X: The first integer.\n\u2022 Y: The second integer.\n\n-----Output-----\nThe output is a tuple of two integers (Int \u00d7 Int) where:\n\u2022 The first element is equal to Y.\n\u2022 The second element is equal to X.\n\n-----Note-----\nThere are no restrictions on the input values. The function must correctly swap the inputs regardless of whether they are positive, negative, or zero.\n\n/* Invalid Inputs\n    // []\n    // Tests\n    // [\n    //     {\n    //         \"input\": {\n    //             \"X\": 3,\n    //             \"Y\": 4\n    //         },\n    //         \"expected\": \"(4, 3)\",\n    //         \"unexpected\": [\n    //             \"(3, 4)\",\n    //             \"(3, 3)\",\n    //             \"(4, 4)\"\n    //         ]\n    //     },\n    //     {\n    //         \"input\": {\n    //             \"X\": -1,\n    //             \"Y\": 10\n    //         },\n    //         \"expected\": \"(10, -1)\",\n    //         \"unexpected\": [\n    //             \"(-1, 10)\",\n    //             \"(10, 1)\",\n    //             \"(-10, -1)\"\n    //         ]\n    //     },\n    //     {\n    //         \"input\": {\n    //             \"X\": 0,\n    //             \"Y\": 0\n    //         },\n    //         \"expected\": \"(0, 0)\",\n    //         \"unexpected\": [\n    //             \"(0, 1)\",\n    //             \"(1, 0)\",\n    //             \"(-1, 0)\"\n    //         ]\n    //     },\n    //     {\n    //         \"input\": {\n    //             \"X\": 100,\n    //             \"Y\": 50\n    //         },\n    //         \"expected\": \"(50, 100)\",\n    //         \"unexpected\": [\n    //             \"(100, 50)\",\n    //             \"(50, 50)\",\n    //             \"(100, 100)\"\n    //         ]\n    //     },\n    //     {\n    //         \"input\": {\n    //             \"X\": -5,\n    //             \"Y\": -10\n    //         },\n    //         \"expected\": \"(-10, -5)\",\n    //         \"unexpected\": [\n    //             \"(-5, -10)\",\n    //             \"(-10, -10)\",\n    //             \"(-5, -5)\"\n    //         ]\n    //     }\n    // ] */\n\n//","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn swap_arithmetic(x: i32, y: i32) -> (result: (i32, i32))\n    ensures\n        result.0 == y,\n        result.1 == x,\n        x != y ==> (result.0 != x && result.1 != y),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"1c7c10712081183b397611bd6002ed92f15a06d1b1113ba12c98f77357709c56","vc_description_hash":"1678bbd75b299ed72aa4281e70f02b0991c82ac6843c3e6ac678c5343da7f29d","vc_spec_hash":"64d5ee9415ac8a53da9341137cf43f3c6c5afd17f47ede8eff8d4b430a4c2305","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"1305831ae057997ff051074fd738655dd1ab9b3ee347e4c3fc526106e118537f","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn swap_arithmetic(x: i32, y: i32) -> (result: (i32, i32)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_93_task","vc-description":"This task requires swapping two 8-bit unsigned integers. Given two unsigned integer inputs, the goal is to produce an output pair where the first element is the original second input and the second element is the original first input. The problem focuses solely on exchanging the values without specifying any particular method to achieve the swap.\n\nInput:\nThe input consists of:\n\u2022 X: A u8 value.\n\u2022 Y: A u8 value.\n\nOutput:\nThe output is a pair of u8 values (newX, newY) where:\n\u2022 newX is equal to the original Y.\n\u2022 newY is equal to the original X.\n\nNote:\nThere are no additional preconditions; the function is meant to work correctly for any pair of u8 values by leveraging bitwise xor operations.\n\n/* \n    -- Invalid Inputs\n    []\n    -- Tests\n    [\n        {\n            \"input\": {\n                \"X\": 0,\n                \"Y\": 0\n            },\n            \"expected\": \"(0, 0)\",\n            \"unexpected\": [\n                \"(0, 1)\",\n                \"(1, 0)\"\n            ]\n        },\n        {\n            \"input\": {\n                \"X\": 5,\n                \"Y\": 10\n            },\n            \"expected\": \"(10, 5)\",\n            \"unexpected\": [\n                \"(5, 10)\",\n                \"(10, 10)\",\n                \"(5, 5)\"\n            ]\n        },\n        {\n            \"input\": {\n                \"X\": 255,\n                \"Y\": 1\n            },\n            \"expected\": \"(1, 255)\",\n            \"unexpected\": [\n                \"(255, 1)\",\n                \"(1, 254)\",\n                \"(0, 255)\"\n            ]\n        },\n        {\n            \"input\": {\n                \"X\": 128,\n                \"Y\": 64\n            },\n            \"expected\": \"(64, 128)\",\n            \"unexpected\": [\n                \"(128, 64)\",\n                \"(64, 64)\",\n                \"(0, 128)\"\n            ]\n        },\n        {\n            \"input\": {\n                \"X\": 15,\n                \"Y\": 15\n            },\n            \"expected\": \"(15, 15)\",\n            \"unexpected\": [\n                \"(15, 16)\",\n                \"(16, 15)\",\n                \"(14, 15)\"\n            ]\n        }\n    ]\n    */","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn swap_bitvectors(x: u8, y: u8) -> (result: (u8, u8))\n    ensures\n        result.0 == y && result.1 == x,\n        x != y ==> (result.0 != x && result.1 != y),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"3fc0cb3c9f347305c1d7bcba1d0516a7b8d265a951da6fe8458a2ea619eb142b","vc_description_hash":"9da080e212c93b5bf2566810d15fec208a4900623fc5f277d4691e36c85c789c","vc_spec_hash":"c502ad968c40509acccc7d11a4bb24e87836ce0f4f05df392e48c8172e2ac776","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"644bbacac45eb856bbfefca76ec62ca486917c9e0ded15472651743fd108a198","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn swap_bitvectors(x: u8, y: u8) -> (result: (u8, u8)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_94_task","vc-description":"This task involves taking an array as input and producing a new array that has the same size and identical elements in the same order as the input.\n\n-----Input-----\nThe input consists of:\n\u2022 s: An array of elements (for testing purposes, assume an array of integers, i.e., Array Int).\n\n-----Output-----\nThe output is an array of the same type as the input:\n\u2022 The output array has the same size as the input array.\n\u2022 Each element in the output array is identical to the corresponding element in the input array.\n\n-----Note-----\nThere are no special preconditions for the input array (it can be empty or non-empty); the function simply performs a straightforward copy operation on the array.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn iter_copy(s: &Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        s.len() == result.len(),\n        forall|i: int| 0 <= i < s.len() ==> s[i] == result[i],","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"bb251d3ff3cfb96d32715dfcc03c75c675254fd3f01a12ae656eaecb3bb9b5e7","vc_description_hash":"659254d711eee15aed570a3a8b47474cd221e0b2ed1b22d349e3123cd13ef730","vc_spec_hash":"c9f6e29025453e8f361de63f419bdc8cf54297013e259c08c87226dca8ac4bdf","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"7b3ab4846e4fada67055a2a6f3f2dac0c801358648c1331061f2c1f0e86f35b6","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn iter_copy(s: &Vec<i32>) -> (result: Vec<i32>)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_95_task","vc-description":"This problem involves swapping two elements in an array of integers at specified positions. Given an array and two indices, the task is to exchange these elements so that the element from the first index moves to the second index and vice versa, while all other elements remain unchanged.\n\n-----Input-----\nThe input consists of:\n\u2022 arr: An array of integers.\n\u2022 i: An integer representing the first index (0-indexed) whose element is to be swapped.\n\u2022 j: An integer representing the second index (0-indexed) whose element is to be swapped.\n\n-----Output-----\nThe output is an array of integers which:\n\u2022 Has the same size as the input array.\n\u2022 Contains the element originally at index i in position j and the element originally at index j in position i.\n\u2022 Leaves all other elements unchanged.\n\n-----Note-----\nIt is assumed that both indices i and j are non-negative and within the bounds of the array (i.e., i and j are less than arr.len()).\n\n/*\n    // -- Invalid Inputs\n    // [\n    //     {\n    //         \"input\": {\n    //             \"arr\": \"[1, 2, 3, 4]\",\n    //             \"i\": -1,\n    //             \"j\": 2\n    //         }\n    //     }\n    // ]\n    // -- Tests\n    // [\n    //     {\n    //         \"input\": {\n    //             \"arr\": \"[1, 2, 3, 4, 5]\",\n    //             \"i\": 1,\n    //             \"j\": 3\n    //         },\n    //         \"expected\": \"[1, 4, 3, 2, 5]\",\n    //         \"unexpected\": [\n    //             \"[1, 2, 3, 4, 5]\",\n    //             \"[1, 3, 2, 4, 5]\"\n    //         ]\n    //     },\n    //     {\n    //         \"input\": {\n    //             \"arr\": \"[10, 20, 30, 40]\",\n    //             \"i\": 0,\n    //             \"j\": 3\n    //         },\n    //         \"expected\": \"[40, 20, 30, 10]\",\n    //         \"unexpected\": [\n    //             \"[10, 40, 30, 20]\",\n    //             \"[10, 20, 40, 30]\"\n    //         ]\n    //     },\n    //     {\n    //         \"input\": {\n    //             \"arr\": \"[7, 8, 9]\",\n    //             \"i\": 1,\n    //             \"j\": 2\n    //         },\n    //         \"expected\": \"[7, 9, 8]\",\n    //         \"unexpected\": [\n    //             \"[8, 7, 9]\",\n    //             \"[9, 8, 7]\"\n    //         ]\n    //     },\n    //     {\n    //         \"input\": {\n    //             \"arr\": \"[1, 2, 3, 4]\",\n    //             \"i\": 0,\n    //             \"j\": 0\n    //         },\n    //         \"expected\": \"[1, 2, 3, 4]\",\n    //         \"unexpected\": [\n    //             \"[1, 2, 4, 3]\",\n    //             \"[4, 2, 3, 1]\"\n    //         ]\n    //     },\n    //     {\n    //         \"input\": {\n    //             \"arr\": \"[-1, -2, -3]\",\n    //             \"i\": 0,\n    //             \"j\": 2\n    //         },\n    //         \"expected\": \"[-3, -2, -1]\",\n    //         \"unexpected\": [\n    //             \"[-1, -2, -3]\",\n    //             \"[-3, -1, -2]\"\n    //         ]\n    //     }\n    // ]\n    // */\n\n//","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn swap(arr: &Vec<i32>, i: usize, j: usize) -> (result: Vec<i32>)\n    requires\n        i < arr.len(),\n        j < arr.len(),\n    ensures\n        result.len() == arr.len(),\n        result[i as int] == arr[j as int],\n        result[j as int] == arr[i as int],\n        forall|k: int| 0 <= k < arr.len() && k != i && k != j ==> result[k] == arr[k],","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"41fe3d000d916d239fa675fa3e4a87aa46f2283a6264db2eca26fca1f7b42dd2","vc_description_hash":"91b308c50b72503f200a565187a7196f0fd815596a21a26f4f6acb9354933e6c","vc_spec_hash":"57a8b55cb9cf34658594885b698d8b6b92e24c491dda8941b4787fc57cf3f745","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"c073a4da362e277f2efcaefd3fb34a8b0fceb71367e1410db1d8118309dcf478","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn swap(arr: &Vec<i32>, i: usize, j: usize) -> (result: Vec<i32>)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_basic_96_task","vc-description":"This task requires swapping two integer values. Given two integers as input, the objective is to produce an output where their order is reversed: the first element of the output corresponds to the second input and the second element corresponds to the first input.\n\nInput:\nThe input consists of two integers:\n\u2022 X: An integer value.\n\u2022 Y: Another integer value.\n\nOutput:\nThe output is a tuple (i32, i32) where:\n\u2022 The first element is equal to Y.\n\u2022 The second element is equal to X.\n\nNote:\nThere are no additional preconditions for this task. The function simply returns a swapped tuple of its two input integers.\n\n// Invalid Inputs\n\n// []\n\n// Tests\n\n// [\n\n//     {\n\n//         \"input\": {\n\n//             \"X\": 3,\n\n//             \"Y\": 4\n\n//         },\n\n//         \"expected\": \"(4, 3)\",\n\n//         \"unexpected\": [\n\n//             \"(3, 4)\",\n\n//             \"(3, 3)\"\n\n//         ]\n\n//     },\n\n//     {\n\n//         \"input\": {\n\n//             \"X\": -10,\n\n//             \"Y\": 20\n\n//         },\n\n//         \"expected\": \"(20, -10)\",\n\n//         \"unexpected\": [\n\n//             \"(20, -20)\",\n\n//             \"(-10, 20)\"\n\n//         ]\n\n//     },\n\n//     {\n\n//         \"input\": {\n\n//             \"X\": 0,\n\n//             \"Y\": 0\n\n//         },\n\n//         \"expected\": \"(0, 0)\",\n\n//         \"unexpected\": [\n\n//             \"(0, 1)\",\n\n//             \"(1, 0)\"\n\n//         ]\n\n//     },\n\n//     {\n\n//         \"input\": {\n\n//             \"X\": 123,\n\n//             \"Y\": -456\n\n//         },\n\n//         \"expected\": \"(-456, 123)\",\n\n//         \"unexpected\": [\n\n//             \"(123, -456)\",\n\n//             \"(-123, 456)\"\n\n//         ]\n\n//     },\n\n//     {\n\n//         \"input\": {\n\n//             \"X\": -1,\n\n//             \"Y\": -2\n\n//         },\n\n//         \"expected\": \"(-2, -1)\",\n\n//         \"unexpected\": [\n\n//             \"(-1, -2)\",\n\n//             \"(-2, 2)\"\n\n//         ]\n\n//     }\n\n// ]","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn swap_simultaneous(x: i32, y: i32) -> (result: (i32, i32))\n    ensures\n        result.0 == y,\n        result.1 == x,\n        x != y ==> result.0 != x && result.1 != y,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"1b4d91e33fce9563e175cae8570645f092f90bf5ff591eee6f57364626e5a6a5","vc_description_hash":"1fb7d7e9529db7f7f7478193c8a811086c5a01a866ea8e252347305bceb59bf2","vc_spec_hash":"29eae37be376e761339fe86b8543489a3bab0e742f1c317cf5f9a8d3e18977b7","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"46758782f994dcecc48e034bcc7067811035e206253c30164fa6f4973a33a2be","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn swap_simultaneous(x: i32, y: i32) -> (result: (i32, i32)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_97_task","vc-description":"This task involves updating an array of integers such that the element at a specified index is set to 60 while all other elements remain unchanged.\n\n-----Input-----\nThe input consists of:\n\u2022 a: An array of integers.\n\u2022 j: A natural number representing the index (0-indexed) to update. It is assumed that j is a valid index (j < a.size).\n\n-----Output-----\nThe output is an array of integers where:\n\u2022 The element at index j is set to 60.\n\u2022 All other elements remain the same as in the input array.\n\n-----Note-----\nIt is assumed that j is a valid index (0 \u2264 j < a.size).\n\n/*\n    -- Invalid Inputs\n    [\n        {\n            \"input\": {\n                \"a\": \"#[1, 2, 3, 4]\",\n                \"j\": 5\n            }\n        }\n    ]\n    -- Tests\n    [\n        {\n            \"input\": {\n                \"a\": \"#[1, 2, 3, 4, 5]\",\n                \"j\": 2\n            },\n            \"expected\": \"#[1, 2, 60, 4, 5]\",\n            \"unexpected\": [\n                \"#[1, 2, 3, 4, 5]\",\n                \"#[1, 60, 3, 4, 5]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"#[60, 30, 20]\",\n                \"j\": 1\n            },\n            \"expected\": \"#[60, 60, 20]\",\n            \"unexpected\": [\n                \"#[60, 30, 20]\",\n                \"#[60, 30, 60]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"#[10, 20, 30]\",\n                \"j\": 0\n            },\n            \"expected\": \"#[60, 20, 30]\",\n            \"unexpected\": [\n                \"#[10, 20, 30]\",\n                \"#[10, 60, 30]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"#[5, 10, 15]\",\n                \"j\": 2\n            },\n            \"expected\": \"#[5, 10, 60]\",\n            \"unexpected\": [\n                \"#[5, 10, 15]\",\n                \"#[5, 60, 15]\"\n            ]\n        },\n        {\n            \"input\": {\n                \"a\": \"#[0]\",\n                \"j\": 0\n            },\n            \"expected\": \"#[60]\",\n            \"unexpected\": [\n                \"#[0]\",\n                \"#[70]\"\n            ]\n        }\n    ]\n    */","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn test_array_elements(a: &Vec<i32>, j: usize) -> (result: Vec<i32>)\n    requires j < a.len(),\n    ensures\n        result.len() == a.len(),\n        result[j as int] == 60,\n        forall|k: int| 0 <= k < a.len() && k != j ==> result[k] == a[k],","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"7fbcba99b0d629bb60f1400d201fb441e157e4cc13bb9020983cd42354cb0356","vc_description_hash":"07e0a62847f4677fa21d41bb9acc1696817692697d0dda2ea1be7384529d3adf","vc_spec_hash":"5e77afb550c61b0e71975927001bba5dac9584d8af02e169b3959b4b382aff5c","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"e93391b4b48cb2480b27a10d91f74849a3acdad6f72a4086f7aaf9eae6378343","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn test_array_elements(a: &Vec<i32>, j: usize) -> (result: Vec<i32>)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
{"id":"verina_basic_98_task","vc-description":"This task involves computing three times a given integer. Given an integer, the goal is to produce a value that is exactly three times its value.\n\nInput:\nThe input consists of a single integer:\nx: An integer.\n\nOutput:\nThe output is an integer:\nReturns the product of the input integer and 3.\n\nNote:\nThere are no additional preconditions.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn triple(x: i32) -> (result: i32)\n    ensures\n        result / 3 == x,\n        result / 3 * 3 == result,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"5e6e5fe34ec6c239f38b006c4e125652ec8a4775e3dd319e9892e12a46882953","vc_description_hash":"606a23c3a11b31f6bb759c96e43e9385b64c0246759480368b4e9b4b282c1572","vc_spec_hash":"7becd9c2db9ad90f05f585c51d2095592a60a1475f0e02b7d59d9b0392f55d20","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"b3d736586b04899e14fb025bac590c1393e4910d41de64d3f28286812da0456b","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn triple(x: i32) -> (result: i32)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_99_task","vc-description":"This task requires computing three times the given integer. The goal is to determine the product of the input integer and 3.\n\nThe input consists of:\n\u2022 x: An integer.\n\nThe output is an integer that represents three times the input value.\n\nThe implementation uses two different branches based on the value of x (i.e., x < 18 or x \u2265 18), but both branches guarantee that the result equals 3*x.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn triple(x: i32) -> (result: i32)\n    ensures\n        result / 3 == x,\n        result / 3 * 3 == result,","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"73dcb98e424c5f54f6240fb346a3b26a49f8f5100d2a3d533194de01853e32ef","vc_description_hash":"1a11ba38dbfdf1d05bb165231234e9b651909d1b52a27608c5ba78e0e757fe80","vc_spec_hash":"7becd9c2db9ad90f05f585c51d2095592a60a1475f0e02b7d59d9b0392f55d20","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"dafbf169fb3775d5b55f267ce3892918b38e914709145ca22dd4306bf92abd2e","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn triple(x: i32) -> (result: i32)","has_requires":false,"has_ensures":true,"precondition_count":0,"postcondition_count":1}}}
{"id":"verina_basic_9_task","vc-description":"This task requires writing a Verus method that checks whether two arrays of integers have any elements in common. In other words, the method should return true if there is at least one element that appears in both arrays, and false if no such element exists.\n\n-----Input-----\nThe input consists of:\na: An array of integers.\nb: An array of integers.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if there is at least one common element between the two arrays.\nReturns false if there are no common elements shared by the arrays.\n\n-----Note-----\nBoth arrays are assumed to be non-null.","vc-preamble":"use vstd::prelude::*;\n\nverus! {","vc-helpers":"","vc-spec":"fn has_common_element(a: &Vec<i32>, b: &Vec<i32>) -> (result: bool)\n    requires \n        a.len() > 0,\n        b.len() > 0,\n    ensures\n        result == (exists|i: int, j: int| 0 <= i < a.len() && 0 <= j < b.len() && a[i] == b[j]),","vc-code":"{\n    assume(false);\n    unreached()\n}","vc-postamble":"}\nfn main() {}","_metadata":{"content_hash":"01ea119c38538567d6ba341b74e6abe8c6bcea500f922988dd1498e6563989d3","vc_description_hash":"032b86253c405c111164773e0e19541c4fc32d38fb90058a9ba46f9e3f236e7f","vc_spec_hash":"1bca83a50b837d0852a2b35d02cc6e290842e8290a396192c6616aa23c0ee1bd","vc_preamble_hash":"bd03035bdf0cbb234b98ba8e05594448810f488dc84a70d39b913103ddfa90af","description_normalized_hash":"8a5926b92a68916198f8c3986224f936e74b600b85e778be22ea26fe2d6bce41","duplicate_status":"unique","similar_problems":[],"structural_info":{"function_signature":"fn has_common_element(a: &Vec<i32>, b: &Vec<i32>) -> (result: bool)","has_requires":true,"has_ensures":true,"precondition_count":1,"postcondition_count":1}}}
