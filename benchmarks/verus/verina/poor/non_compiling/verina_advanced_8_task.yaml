vc-description: |-
  This task requires writing a Verus method that determines whether it is possible to complete a circular journey around a set of gas stations. Each gas station provides a certain amount of gas, and traveling from one station to the next consumes a certain amount of gas.
  
  You start the journey at one of the gas stations with an empty tank. The goal is to find the starting station's index that allows completing the entire circuit once in the clockwise direction without running out of gas. If such a station exists, return its index. Otherwise, return -1.
  
  If multiple solutions exist, return the one with the smallest starting gas station index.
  
  Input:
  The input consists of two arrays:
  
  gas: An array of integers where gas[i] represents the amount of gas available at the ith station.
  
  cost: An array of integers where cost[i] is the amount of gas required to travel from station i to station i + 1.
  
  Output:
  The output is an integer:
  Returns the index of the starting gas station that allows a complete trip around the circuit. If it is not possible to complete the circuit, return -1.

vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn valid_starting_point(gas: &Vec<i32>, cost: &Vec<i32>, start: int) -> bool 
  {
      0 <= start < gas.len() && 
      forall|i: int| 0 <= i < gas.len() ==> {
          #[trigger] calculate_acc(gas, cost, start, i + 1) >= 0
      }
  }
  
  spec fn calculate_acc(gas: &Vec<i32>, cost: &Vec<i32>, start: int, steps: int) -> int
      decreases steps
  {
      if steps <= 0 {
          0
      } else {
          let prev_acc = calculate_acc(gas, cost, start, steps - 1);
          let jdx = ((start + (steps - 1)) % (gas.len() as int)) as nat % (gas.len() as nat);
          prev_acc + gas[jdx as int] - cost[jdx as int]
      }
  }

vc-helpers: |-

vc-spec: |-
  fn can_complete_circuit(gas: &Vec<i8>, cost: &Vec<i8>) -> (result: i8)
      requires 
          gas@.len() == cost@.len(),
          gas@.len() > 0,
      ensures
          (result == -1) ==> (forall|start: int| 0 <= start < gas@.len() ==> !valid_starting_point(&gas@.map(|i: int, x: i8| x as i32), &cost@.map(|i: int, x: i8| x as i32), start)),
          (result >= 0) ==> (
              0 <= result as int && result as int < (gas@.len() as int) &&
              valid_starting_point(&gas@.map(|i: int, x: i8| x as i32), &cost@.map(|i: int, x: i8| x as i32), result as int) &&
              (forall|start: int| 0 <= start < result as int ==> !valid_starting_point(&gas@.map(|i: int, x: i8| x as i32), &cost@.map(|i: int, x: i8| x as i32), start))
          ),

vc-code: |-
  {
      assume(false);
      unreached()
  }

vc-postamble: |-
  }
  fn main() {}