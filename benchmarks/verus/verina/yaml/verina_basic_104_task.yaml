vc-description: |-
  This problem involves combining two maps by creating a new map that includes every key from both inputs. When a key is found in both maps, the value from the second map is used in the result.
  
  Input:
  The input consists of:
  • m1: A Map (represented as a list of key-value pairs) where each key is of type Int and each value is of type Int.
  • m2: A Map (similarly represented) where keys may overlap with m1.
  
  Output:
  The output is a Map that meets the following conditions:
  • Every key present in m2 is present in the result.
  • Every key present in m1 is also present in the result.
  • For keys that appear in both maps, the resulting value is the one from m2.
  • For keys that appear only in m1, the resulting value remains unchanged.
  • No keys outside those present in m1 or m2 are included in the result.
  • The entries in the map should be sorted
  
  Note:
  It is assumed that the Map structure ensures key uniqueness in the final result using BEq for key comparison.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-

vc-spec: |-
  spec fn find_key(entries: Seq<(i32, i32)>, k: i32) -> Option<i32> {
      entries.filter(|p: (i32, i32)| p.0 == k).map(|p: (i32, i32)| p.1).first()
  }

  fn update_map(m1: &Vec<(i32, i32)>, m2: &Vec<(i32, i32)>) -> (result: Vec<(i32, i32)>)
      ensures
          forall|k: i32, v: i32| m2.contains((k, v)) ==> result.contains((k, v)),
          forall|k: i32, v: i32| m1.contains((k, v)) && !exists|v2: i32| m2.contains((k, v2)) ==> result.contains((k, v)),
          forall|k: i32, v: i32| result.contains((k, v)) ==> 
              (m2.contains((k, v)) || (m1.contains((k, v)) && !exists|v2: i32| m2.contains((k, v2)))),
          forall|i: int, j: int| 0 <= i < j < result.len() ==> result[i].0 <= result[j].0,

vc-code: |-
  {
      // impl-start
      assume(false);
      Vec::new()
      // impl-end
  }

vc-postamble: |-

  }
  fn main() {}