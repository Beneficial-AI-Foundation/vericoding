{"id": "VV0015", "language": "verus", "source": "verina", "source_id": "verina_advanced_16_task", "vc-description": "Implement the insertion sort algorithm in Verus. The function takes a single Vec of integers\nas input and returns a new Vec that contains the same integers in ascending order.\n\nImplementation must follow a standard insertion sort approach, placing each element into its correct position.\nThe resulting Vec must be sorted in ascending order.\nThe returned Vec must be a permutation of the input Vec (i.e., contain exactly the same elements).\n\nInput: A single Vec of integers, denoted as xs.\nOutput: A Vec of integers, sorted in ascending order.\n\nExample:\nInput:  [3, 1, 4, 2]\nOutput: [1, 2, 3, 4]\n\n/* Helper function to check if a Vec is sorted */\n\n/* Helper function to check if two Vecs are multiset equivalent */\n\n/* This would typically involve checking that both vectors contain\n       the same elements with the same multiplicities */\n\n/* Placeholder - actual implementation would be more complex */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sorted(v: Vec<i32>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < v.len() ==> v[i] <= v[j]\n}\n\nspec fn multiset_equivalent(v1: Vec<i32>, v2: Vec<i32>) -> bool {\n    forall|elem: i32| count(v1, elem) == count(v2, elem)\n}\n\nspec fn count(v: Vec<i32>, elem: i32) -> nat {\n    v.to_seq().filter(|x| *x == elem).len()\n}", "vc-helpers": "", "vc-spec": "fn insertion_sort(xs: Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        sorted(result),\n        multiset_equivalent(xs, result),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling"}
