=== Raw LLM Generate Response ===
Length: 1773 characters
--------------------------------------------------------------------------------
["proof fn lemma_exp_zero(x: nat) ensures Exp_int(x, 0) == 1 { }\nproof fn lemma_exp_rec(x: nat, y: nat) requires y > 0 ensures Exp_int(x, y) == x * Exp_int(x, (y - 1) as nat) { }\nproof fn lemma_str2int_empty() ensures Str2Int(Seq::<char>::empty()) == 0 { }\nproof fn lemma_str2int_rec(s: Seq<char>, c: char) requires ValidBitString(s.push(c)), s.len() > 0 ensures Str2Int(s.push(c)) == 2 * Str2Int(s) + (if c == '1' { 1 } else { 0 }) { }\nproof fn lemma_mod_exp_property(x: nat, y: nat, z: nat) requires z > 1 ensures Exp_int(x, y) % z == Exp_int(x % z, y) % z { }\nproof fn lemma_mod_exp_pow2_base(x: nat, n: nat, z: nat) requires z > 1 ensures Exp_int(x, Exp_int(2, n)) % z == Exp_int(Exp_int(x, Exp_int(2, n - 1)) % z, 2) % z { }", "{\n    let n = sy@.len() as int - 1;\n    let (mut result, mut base, mut exponent) = (Vec::new(), sx.to_vec(), sy.to_vec());\n    \n    while exponent.len() > 0\n        invariant\n            ValidBitString(result@),\n            ValidBitString(base@),\n            ValidBitString(exponent@),\n            Str2Int(result@) == Exp_int(Str2Int(sx@), Str2Int(sy@) - Str2Int(exponent@)) % Str2Int(sz@),\n            exponent@.len() <= sy@.len()\n        decreases exponent@.len()\n    {\n        let last_char = *exponent.last().unwrap();\n        exponent.pop();\n        \n        if last_char == '1' {\n            let temp = ModExpPow2(base.as_slice(), exponent.as_slice(), n, sz.as_slice());\n            result = Add(result.as_slice(), temp.as_slice());\n            result = DivMod(result.as_slice(), sz.as_slice()).1;\n        }\n        \n        base = ModExpPow2(base.as_slice(), exponent.as_slice(), n, sz.as_slice());\n        base = DivMod(base.as_slice(), sz.as_slice()).1;\n        n = n - 1;\n    }\n    \n    result\n}"]
--------------------------------------------------------------------------------
