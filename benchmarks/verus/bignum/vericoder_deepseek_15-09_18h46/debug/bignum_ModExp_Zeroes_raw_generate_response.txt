=== Raw LLM Generate Response ===
Length: 3058 characters
--------------------------------------------------------------------------------
["\nproof fn helper_lemma_exp_mod(x: nat, y: nat, m: nat)\n    requires m > 1\n    ensures Exp_int(x, y) % m == Exp_int(x % m, y) % m\n{\n    if y == 0 {\n        assert(Exp_int(x, 0) % m == 1 % m) by {\n            assert(1 % m == 1) by { assert(m > 1); }\n        };\n        assert(Exp_int(x % m, 0) % m == 1 % m) by {\n            assert(1 % m == 1) by { assert(m > 1); }\n        };\n    } else {\n        helper_lemma_exp_mod(x, y - 1, m);\n        assert(Exp_int(x, y) == x * Exp_int(x, y - 1)) by { };\n        assert(Exp_int(x % m, y) == (x % m) * Exp_int(x % m, y - 1)) by { };\n        assert((x * Exp_int(x, y - 1)) % m == (x % m) * (Exp_int(x, y - 1) % m) % m) by { };\n        assert(Exp_int(x, y - 1) % m == Exp_int(x % m, y - 1) % m);\n    }\n}\n\nproof fn helper_lemma_str2int_mod(s: Seq<char>, m: nat)\n    requires ValidBitString(s), m > 1\n    ensures Str2Int(s) % m == Str2Int(Seq::new()) % m || (Str2Int(s.subrange(0, s.len() as int - 1)) * 2 + (if s[s.len() as int - 1] == '1' { 1 } else { 0 })) % m == (Str2Int(s.subrange(0, s.len() as int - 1)) % m * 2 + (if s[s.len() as int - 1] == '1' { 1 } else { 0 })) % m\n{\n    if s.len() == 0 {\n        assert(Str2Int(s) == 0) by { };\n        assert(0 % m == 0) by { };\n    } else {\n        let last_char_bit = if s[s.len() as int - 1] == '1' { 1 } else { 0 };\n        assert(Str2Int(s) == 2 * Str2Int(s.subrange(0, s.len() as int - 1)) + last_char_bit) by { };\n        assert((2 * Str2Int(s.subrange(0, s.len() as int - 1)) + last_char_bit) % m == (2 % m * (Str2Int(s.subrange(0, s.len() as int - 1)) % m) + last_char_bit % m) % m) by { };\n        helper_lemma_str2int_mod(s.subrange(0, s.len() as int - 1), m);\n    }\n}\n","{\n    let m = Str2Int(sz@);\n    let x_mod_m = Str2Int(sx@) % m;\n    let y_val = Str2Int(sy@);\n    \n    proof {\n        helper_lemma_exp_mod(Str2Int(sx@), y_val, m);\n        helper_lemma_str2int_mod(sx@, m);\n    }\n    \n    // Start with base case: x^0 mod m = 1 mod m\n    let mut result = 1;\n    let mut current_base = x_mod_m;\n    let mut remaining_exp = y_val;\n    \n    while remaining_exp > 0\n        invariant\n            remaining_exp <= y_val,\n            result * Exp_int(current_base, remaining_exp) % m == Exp_int(Str2Int(sx@), y_val) % m,\n            current_base == Exp_int(x_mod_m, Exp_int(2, y_val - remaining_exp)) % m\n    {\n        if remaining_exp % 2 == 1 {\n            result = (result * current_base) % m;\n        }\n        current_base = (current_base * current_base) % m;\n        remaining_exp = remaining_exp / 2;\n    }\n    \n    // Convert result to binary representation\n    let mut res_vec = Vec::new();\n    let mut num = result;\n    \n    while num > 0\n        invariant\n            num >= 0,\n            Str2Int(res_vec@) == result - num * Exp_int(2, res_vec@.len() as nat)\n    {\n        let bit = if num % 2 == 1 { '1' } else { '0' };\n        res_vec.push(bit);\n        num = num / 2;\n    }\n    \n    // Reverse to get correct order (LSB last)\n    res_vec.reverse();\n    \n    res_vec\n}"]
--------------------------------------------------------------------------------
