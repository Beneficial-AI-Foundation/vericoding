=== Raw LLM Generate Response ===
Length: 1532 characters
--------------------------------------------------------------------------------
[
"exec fn str_to_int(s: &[char]) -> int\n    requires\n        ValidBitString(s@),\n    ensures\n        result == Str2Int(s@) as int,\n    decreases s.len()\n{\n    if s.len() == 0 { 0 } else {\n        let hi = str_to_int(&s[0..s.len()-1]);\n        let lo = if s[s.len() - 1] == '1' { 1 } else { 0 };\n        hi * 2 + lo\n    }\n}\n\nexec fn pow_mod(base: int, exp: int, mod_: int) -> int\n    requires\n        mod_ > 1,\n        exp >= 0,\n    decreases exp\n{\n    let mut result = 1;\n    let mut b = base % mod_;\n    let mut e = exp;\n    while e > 0\n        invariant\n            b >= 0,\n            b < mod_,\n            result >= 0,\n            result < mod_,\n            e >= 0,\n        decreases e\n    {\n        if e % 2 == 1 {\n            result = (result * b) % mod_;\n        }\n        b = (b * b) % mod_;\n        e = e / 2;\n    }\n    result\n}\n\nexec fn int_to_binary(mut x: int) -> Vec<char>\n    requires\n        x >= 0,\n    ensures\n        ValidBitString(result@),\n        Str2Int(result@) == x as nat,\n{\n    if x == 0 { vec!['0'] } else {\n        let mut v = Vec::new();\n        while x > 0\n        {\n            let rem = x % 2;\n            v.push(if rem == 1 { '1' } else { '0' });\n            x = x / 2;\n        }\n        v.reverse();\n        v\n    }\n}",
"{\n    let base_int = str_to_int(sx);\n    let exp_int = str_to_int(sy);\n    let mod_int = str_to_int(sz);\n    let res_int = pow_mod(base_int, exp_int, mod_int);\n    let res = int_to_binary(res_int);\n    res\n}"
]
--------------------------------------------------------------------------------
