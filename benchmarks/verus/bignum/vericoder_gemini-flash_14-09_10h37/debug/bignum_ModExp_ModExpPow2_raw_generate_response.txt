=== Raw LLM Generate Response ===
Length: 1532 characters
--------------------------------------------------------------------------------
["proof fn lemma_mult_rec(a: nat, b: nat, c:nat)
    requires a % c == 0
    ensures (a * b) % c == 0
{
    reveal_div_by();
    assert(exists |k: nat| a == k * c);
    assert(a * b == (k * c) * b);
    assert(a * b == (k * b) * c);
}", "{
    let x = Str2Int(sx@);
    let y = Str2Int(sy@);
    let z = Str2Int(sz@);

    if sy@.len() == 1 {
        let one_char: Seq<char> = Seq::new().push(sy@[0]);
        if Str2Int(one_char) == 0 {
            // sy is "0"
            return s_int_to_str<char>(1);
        }
    }

    let mid: Vec<char> = ModExp_ModExpPow2(sx, &sy[0..sy.len()-1], sz);
    let mid_int = Str2Int(mid@);

    if sy@[sy.len()-1] == '0' {
        lemma_mult_rec(mid_int, x, z);
        return s_int_to_str((mid_int * x) % z);
    } else { // sy@[sy.len()-1] == '1'
        let two_pow_y_minus_1 = Exp_int(2, (sy.len() - 1) as nat);
        let sy_prefix = sy.subrange(0, (sy.len() - 1) as int);
        let y_prefix_int = Str2Int(sy_prefix);
        let y_current_int = Str2Int(sy@);

        proof {
            assert(y_current_int == 2 * y_prefix_int + 1);
            assert(Exp_int(x, y_current_int) == Exp_int(x, 2 * y_prefix_int + 1));
            assert(Exp_int(x, y_current_int) == Exp_int(x, 2 * y_prefix_int) * x);
            assert(Exp_int(x, y_current_int) == Exp_int(Exp_int(x, y_prefix_int), 2) * x);
        }

        lemma_mult_rec(mid_int, mid_int, z);
        let term1 = (mid_int * mid_int) % z;

        lemma_mult_rec(term1, x, z);
        return s_int_to_str((term1 * x) % z);
    }
}"]
--------------------------------------------------------------------------------
