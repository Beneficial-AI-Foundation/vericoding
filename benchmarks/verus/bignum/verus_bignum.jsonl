{"id": "bignum_Add", "vc-description": "Bignum task: bignum_Add.\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}", "vc-helpers": "", "vc-spec": "fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == str2int(s1) + str2int(s2)", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_Add_NormalizeBitString", "vc-description": "Bignum task: bignum_Add[NormalizeBitString].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */\n\n/* Remove leading zeros, except keep at least one digit */\n\n/* I added and proved some extra post-conditions: */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 {\n    0nat\n  } else {\n    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn normalize_bit_string(s: Seq<char>) -> (t: Seq<char>)\n  ensures \n    valid_bit_string(t),\n    t.len() > 0,\n    t.len() > 1 ==> t[0] != '0',\n    valid_bit_string(s) ==> str2int(s) == str2int(t),\n{\n  assume(false);\n  unreached()\n}", "vc-helpers": "", "vc-spec": "fn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) + str2int(s2),", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_Compare", "vc-description": "Bignum task: bignum_Compare.\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { \n    0nat \n  } else { \n    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}", "vc-helpers": "", "vc-spec": "fn compare(s1: Seq<char>, s2: Seq<char>) -> (res: i32)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    (str2int(s1) < str2int(s2)) ==> (res == -1) &&\n    (str2int(s1) == str2int(s2)) ==> (res == 0) &&\n    (str2int(s1) > str2int(s2)) ==> (res == 1)\n  decreases str2int(s1) + str2int(s2)", "vc-code": "{\n  // impl-start\n  assume(false);\n  0\n  // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_CompareUnequal", "vc-description": "Bignum task: bignum_CompareUnequal.\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 { \n    0nat \n  } else { \n    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}", "vc-helpers": "", "vc-spec": "fn compare_unequal(s1: Seq<char>, s2: Seq<char>) -> (res: i32)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n    s1.len() > 0,\n    s1.len() > 1 ==> s1[0] != '0',\n    s2.len() > 0,\n    s2.len() > 1 ==> s2[0] != '0',\n    s1.len() > s2.len()\n  ensures \n    str2int(s1) < str2int(s2) ==> res == -1,\n    str2int(s1) == str2int(s2) ==> res == 0,\n    str2int(s1) > str2int(s2) ==> res == 1", "vc-code": "{\n  assume(false);\n  0\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_Compare_CompareUnequal", "vc-description": "Bignum task: bignum_Compare[CompareUnequal].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 {\n    0nat\n  } else {\n    2nat * str2int(s.subrange(0, s.len() - 1)) + \n    (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn compare_unequal(s1: Seq<char>, s2: Seq<char>) -> (res: i32)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n    s1.len() > 0,\n    s1.len() > 1 ==> s1[0] != '0',\n    s2.len() > 0,\n    s2.len() > 1 ==> s2[0] != '0',\n    s1.len() > s2.len()\n  ensures \n    str2int(s1) < str2int(s2) ==> res == -1,\n    str2int(s1) == str2int(s2) ==> res == 0,\n    str2int(s1) > str2int(s2) ==> res == 1\n{\n  assume(false);\n  unreached()\n}", "vc-helpers": "", "vc-spec": "fn compare(s1: Seq<char>, s2: Seq<char>) -> (res: i32)\n  requires valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    str2int(s1) < str2int(s2) ==> res == -1,\n    str2int(s1) == str2int(s2) ==> res == 0,\n    str2int(s1) > str2int(s2) ==> res == 1\n  decreases str2int(s1) + str2int(s2)", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_Compare_CompareUnequal_NormalizeBitString", "vc-description": "Bignum task: bignum_Compare[CompareUnequal,NormalizeBitString].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */\n\n/* Remove leading zeros, except keep at least one digit */\n\n/* I added and proved some extra post-conditions: */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1 as int)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn normalize_bit_string(s: Seq<char>) -> (t: Seq<char>)\n  ensures\n    valid_bit_string(t),\n    t.len() > 0,\n    t.len() > 1 ==> t[0] != '0',\n    valid_bit_string(s) ==> str2int(s) == str2int(t),\n{\n  assume(false);\n  unreached()\n}\n\nfn compare_unequal(s1: Seq<char>, s2: Seq<char>) -> (res: i32)\n  requires\n    valid_bit_string(s1) && valid_bit_string(s2),\n    s1.len() > 0,\n    s1.len() > 1 ==> s1[0] != '0',\n    s2.len() > 0,\n    s2.len() > 1 ==> s2[0] != '0',\n    s1.len() > s2.len(),\n  ensures\n    str2int(s1) < str2int(s2) ==> res == -1,\n    str2int(s1) == str2int(s2) ==> res == 0,\n    str2int(s1) > str2int(s2) ==> res == 1,\n{\n  assume(false);\n  unreached()\n}", "vc-helpers": "", "vc-spec": "fn compare(s1: Seq<char>, s2: Seq<char>) -> (res: i32)\n  requires valid_bit_string(s1) && valid_bit_string(s2)\n  ensures\n    str2int(s1) < str2int(s2) ==> res == -1,\n    str2int(s1) == str2int(s2) ==> res == 0,\n    str2int(s1) > str2int(s2) ==> res == 1,\n  decreases str2int(s1) + str2int(s2)", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_Compare_NormalizeBitString", "vc-description": "Bignum task: bignum_Compare[NormalizeBitString].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */\n\n/* Remove leading zeros, except keep at least one digit */\n\n/* I added and proved some extra post-conditions: */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 {\n      0nat\n  } else {\n      2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn normalize_bit_string(s: Seq<char>) -> (t: Seq<char>)\n  ensures \n      valid_bit_string(t) &&\n      t.len() > 0 &&\n      (t.len() > 1 ==> t[0] != '0') &&\n      (valid_bit_string(s) ==> str2int(s) == str2int(t))\n{\n  assume(false);\n  unreached()\n}", "vc-helpers": "", "vc-spec": "fn compare(s1: Seq<char>, s2: Seq<char>) -> (res: int)\n  requires valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n      (str2int(s1) < str2int(s2) ==> res == -1) &&\n      (str2int(s1) == str2int(s2) ==> res == 0) &&\n      (str2int(s1) > str2int(s2) ==> res == 1)\n  decreases str2int(s1) + str2int(s2)", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_DivMod", "vc-description": "Bignum task: bignum_DivMod.\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 { \n    0nat \n  } else { \n    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}", "vc-helpers": "", "vc-spec": "fn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (result: (Seq<char>, Seq<char>))\n  requires \n    valid_bit_string(dividend) && valid_bit_string(divisor),\n    str2int(divisor) > 0,\n  ensures \n    valid_bit_string(result.0) && valid_bit_string(result.1),\n    str2int(result.0) == str2int(dividend) / str2int(divisor),\n    str2int(result.1) == str2int(dividend) % str2int(divisor),", "vc-code": "{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_DivMod_Compare", "vc-description": "Bignum task: bignum_DivMod[Compare].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nfn compare(s1: Seq<char>, s2: Seq<char>) -> (res: i32)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    str2int(s1) < str2int(s2) ==> res == -1,\n    str2int(s1) == str2int(s2) ==> res == 0,\n    str2int(s1) > str2int(s2) ==> res == 1\n  decreases str2int(s1) + str2int(s2)\n{\n  assume(false);\n  unreached()\n}", "vc-helpers": "", "vc-spec": "fn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n  requires \n    valid_bit_string(dividend) && valid_bit_string(divisor),\n    str2int(divisor) > 0\n  ensures \n    valid_bit_string(res.0) && valid_bit_string(res.1),\n    str2int(res.0) == str2int(dividend) / str2int(divisor),\n    str2int(res.1) == str2int(dividend) % str2int(divisor)", "vc-code": "{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_DivMod_Compare_Sub", "vc-description": "Bignum task: bignum_DivMod[Compare,Sub].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n    recommends valid_bit_string(s)\n    decreases s.len()\n{\n    if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn sub(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2),\n        str2int(s1) >= str2int(s2),\n    ensures \n        valid_bit_string(res),\n        str2int(res) == str2int(s1) - str2int(s2),\n{\n    assume(false);\n    unreached()\n}\n\nfn compare(s1: Seq<char>, s2: Seq<char>) -> (res: i32)\n    requires valid_bit_string(s1) && valid_bit_string(s2),\n    ensures \n        str2int(s1) < str2int(s2) ==> res == -1,\n        str2int(s1) == str2int(s2) ==> res == 0,\n        str2int(s1) > str2int(s2) ==> res == 1,\n    decreases str2int(s1) + str2int(s2),\n{\n    assume(false);\n    unreached()\n}", "vc-helpers": "", "vc-spec": "fn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n    requires \n        valid_bit_string(dividend) && valid_bit_string(divisor),\n        str2int(divisor) > 0,\n    ensures \n        valid_bit_string(res.0) && valid_bit_string(res.1),\n        str2int(res.0) == str2int(dividend) / str2int(divisor),\n        str2int(res.1) == str2int(dividend) % str2int(divisor),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_DivMod_Sub", "vc-description": "Bignum task: bignum_DivMod[Sub].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn sub(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n    str2int(s1) >= str2int(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) - str2int(s2)\n{\n  assume(false);\n  unreached()\n}", "vc-helpers": "", "vc-spec": "fn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (result: (Seq<char>, Seq<char>))\n  requires \n    valid_bit_string(dividend) && valid_bit_string(divisor),\n    str2int(divisor) > 0\n  ensures \n    valid_bit_string(result.0) && valid_bit_string(result.1),\n    str2int(result.0) == str2int(dividend) / str2int(divisor),\n    str2int(result.1) == str2int(dividend) % str2int(divisor)", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_ModExp", "vc-description": "Bignum task: bignum_ModExp.\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */\n\n/* requires y < Exp_int(2,n+1) */\n\n/* && n > 0 */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0nat \n    } else { \n        2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}", "vc-helpers": "", "vc-spec": "fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n        sy.len() > 0 && str2int(sz) > 1\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n    decreases sy.len()", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_ModExpPow2", "vc-description": "Bignum task: bignum_ModExpPow2.\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */\n\n/* sy is power of 2 or zero */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0nat \n    } else { \n        2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    }\n}", "vc-helpers": "", "vc-spec": "fn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n        str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0,\n        sy.len() == n + 1,\n        str2int(sz) > 1,\n    ensures \n        valid_bit_string(res),\n        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz),\n    decreases n", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_ModExpPow2_Add", "vc-description": "Bignum task: bignum_ModExpPow2[Add].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */\n\n/* sy is power of 2 or zero */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0nat \n    } else { \n        2nat * str2int(s.subrange(0, s.len() - 1)) + \n        (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    }\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2)\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) + str2int(s2)\n{\n    assume(false);\n    unreached()\n}", "vc-helpers": "", "vc-spec": "fn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n        (str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0) &&\n        sy.len() == n + 1 &&\n        str2int(sz) > 1\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n    decreases n", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_ModExpPow2_Add_DivMod", "vc-description": "Bignum task: bignum_ModExpPow2[Add,DivMod].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */\n\n/* sy is power of 2 or zero */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { \n    0nat \n  } else { \n    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res) && str2int(res) == str2int(s1) + str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n  requires \n    valid_bit_string(dividend) && valid_bit_string(divisor) && str2int(divisor) > 0\n  ensures \n    valid_bit_string(res.0) && valid_bit_string(res.1) &&\n    str2int(res.0) == str2int(dividend) / str2int(divisor) &&\n    str2int(res.1) == str2int(dividend) % str2int(divisor)\n{\n  assume(false);\n  unreached()\n}", "vc-helpers": "", "vc-spec": "fn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n    (str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0) &&\n    sy.len() == n + 1 &&\n    str2int(sz) > 1\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases n", "vc-code": "{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_ModExpPow2_Add_DivMod_Mul", "vc-description": "Bignum task: bignum_ModExpPow2[Add,DivMod,Mul].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */\n\n/* sy is power of 2 or zero */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn str2int(s: Seq<char>) -> nat\n    recommends valid_bit_string(s)\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0nat \n    } else { \n        2nat * str2int(s.subrange(0, s.len() - 1)) + \n        (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    }\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2),\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) + str2int(s2),\n{\n    assume(false);\n    unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n    requires \n        valid_bit_string(dividend) && valid_bit_string(divisor) &&\n        str2int(divisor) > 0,\n    ensures \n        valid_bit_string(res.0) && valid_bit_string(res.1) &&\n        str2int(res.0) == str2int(dividend) / str2int(divisor) &&\n        str2int(res.1) == str2int(dividend) % str2int(divisor),\n{\n    assume(false);\n    unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2),\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) * str2int(s2),\n{\n    assume(false);\n    unreached()\n}", "vc-helpers": "", "vc-spec": "fn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n        (str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0) &&\n        sy.len() == n + 1 &&\n        str2int(sz) > 1,\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz),\n    decreases n,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_ModExpPow2_Add_Mul", "vc-description": "Bignum task: bignum_ModExpPow2[Add,Mul].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */\n\n/* sy is power of 2 or zero */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1nat) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0nat \n    } else { \n        2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    }\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires\n        valid_bit_string(s1) && valid_bit_string(s2)\n    ensures\n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) + str2int(s2)\n{\n    assume(false);\n    unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires\n        valid_bit_string(s1) && valid_bit_string(s2)\n    ensures\n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) * str2int(s2)\n{\n    assume(false);\n    unreached()\n}", "vc-helpers": "", "vc-spec": "fn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n    requires\n        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n        (str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0) &&\n        sy.len() == n + 1 &&\n        str2int(sz) > 1\n    ensures\n        valid_bit_string(res) &&\n        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n    decreases n", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_ModExpPow2_DivMod", "vc-description": "Bignum task: bignum_ModExpPow2[DivMod].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */\n\n/* sy is power of 2 or zero */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0nat\n    } else {\n        if valid_bit_string(s) {\n            2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n        } else {\n            0nat\n        }\n    }\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (result: (Seq<char>, Seq<char>))\n    requires \n        valid_bit_string(dividend) && valid_bit_string(divisor) && str2int(divisor) > 0\n    ensures \n        valid_bit_string(result.0) && valid_bit_string(result.1),\n        str2int(result.0) == str2int(dividend) / str2int(divisor),\n        str2int(result.1) == str2int(dividend) % str2int(divisor)\n{\n    assume(false);\n    unreached()\n}", "vc-helpers": "", "vc-spec": "fn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n        str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0,\n        sy.len() == n + 1,\n        str2int(sz) > 1\n    ensures \n        valid_bit_string(res),\n        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n    decreases n", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_ModExpPow2_DivMod_Mul", "vc-description": "Bignum task: bignum_ModExpPow2[DivMod,Mul].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */\n\n/* sy is power of 2 or zero */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if !valid_bit_string(s) {\n        0nat\n    } else if s.len() == 0 { \n        0nat \n    } else { \n        2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    }\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n    requires \n        valid_bit_string(dividend) && valid_bit_string(divisor),\n        str2int(divisor) > 0,\n    ensures \n        valid_bit_string(res.0) && valid_bit_string(res.1),\n        str2int(res.0) == str2int(dividend) / str2int(divisor),\n        str2int(res.1) == str2int(dividend) % str2int(divisor),\n{\n    assume(false);\n    unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2),\n    ensures \n        valid_bit_string(res),\n        str2int(res) == str2int(s1) * str2int(s2),\n{\n    assume(false);\n    unreached()\n}", "vc-helpers": "", "vc-spec": "fn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n        str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0,\n        sy.len() == n + 1,\n        str2int(sz) > 1,\n    ensures \n        valid_bit_string(res),\n        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz),\n    decreases n", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_ModExpPow2_Mul", "vc-description": "Bignum task: bignum_ModExpPow2[Mul].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */\n\n/* sy is power of 2 or zero */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0nat \n    } else { \n        2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    }\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2)\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) * str2int(s2)\n{\n    assume(false);\n    unreached()\n}", "vc-helpers": "", "vc-spec": "fn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n        (str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0) &&\n        sy.len() == n + 1 &&\n        str2int(sz) > 1\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n    decreases n", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_ModExpPow2_int", "vc-description": "Bignum task: bignum_ModExpPow2_int.\nImplement the method according to the Dafny specification.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1 } else { x * exp_int(x, (y - 1) as nat) }\n}", "vc-helpers": "", "vc-spec": "fn mod_exp_pow2_int(x: nat, y: nat, n: nat, z: nat) -> (res: nat)\n    requires \n        y == exp_int(2, n),\n        z > 0,\n    ensures res == exp_int(x, y) % z\n    decreases n", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_ModExp_Add", "vc-description": "Bignum task: bignum_ModExp[Add].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */\n\n/*requires y < Exp_int(2,n+1)*/\n\n/*&& n > 0*/", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s.index(s.len() - 1) == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> s.index(i) == '0' || s.index(i) == '1'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == str2int(s1) + str2int(s2),\n{\n  assume(false);\n  unreached()\n}", "vc-helpers": "", "vc-spec": "fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n    sy.len() > 0 && str2int(sz) > 1,\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz),\n  decreases sy.len(),", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_ModExp_Add_DivMod", "vc-description": "Bignum task: bignum_ModExp[Add,DivMod].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */\n\n/* requires y < Exp_int(2,n+1) */\n\n/* && n > 0 */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn str2_int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2_int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1nat) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res) &&\n    str2_int(res) == str2_int(s1) + str2_int(s2),\n{\n  assume(false);\n  unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n  requires \n    valid_bit_string(dividend) && valid_bit_string(divisor) &&\n    str2_int(divisor) > 0,\n  ensures \n    valid_bit_string(res.0) && valid_bit_string(res.1) &&\n    str2_int(res.0) == str2_int(dividend) / str2_int(divisor) &&\n    str2_int(res.1) == str2_int(dividend) % str2_int(divisor),\n{\n  assume(false);\n  unreached()\n}", "vc-helpers": "", "vc-spec": "fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n    sy.len() > 0 && str2_int(sz) > 1,\n  ensures \n    valid_bit_string(res) &&\n    str2_int(res) == exp_int(str2_int(sx), str2_int(sy)) % str2_int(sz),\n  decreases sy.len()", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_ModExp_Add_DivMod_ModExpPow2", "vc-description": "Bignum task: bignum_ModExp[Add,DivMod,ModExpPow2].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */\n\n/* sy is power of 2 or zero */\n\n/* requires y < Exp_int(2,n+1) */\n\n/* && n > 0 */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires\n      valid_bit_string(s1) && valid_bit_string(s2)\n  ensures\n      valid_bit_string(res) &&\n      str2int(res) == str2int(s1) + str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (result: (Seq<char>, Seq<char>))\n  requires\n      valid_bit_string(dividend) && valid_bit_string(divisor) &&\n      str2int(divisor) > 0\n  ensures\n      valid_bit_string(result.0) && valid_bit_string(result.1) &&\n      str2int(result.0) == str2int(dividend) / str2int(divisor) &&\n      str2int(result.1) == str2int(dividend) % str2int(divisor)\n{\n  assume(false);\n  unreached()\n}\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n  requires\n      valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n      (str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0) &&\n      sy.len() == n + 1 &&\n      str2int(sz) > 1\n  ensures\n      valid_bit_string(res) &&\n      str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases n\n{\n  assume(false);\n  unreached()\n}", "vc-helpers": "", "vc-spec": "fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires\n      valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n      sy.len() > 0 && str2int(sz) > 1\n  ensures\n      valid_bit_string(res) &&\n      str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases sy.len()", "vc-code": "{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_ModExp_Add_DivMod_ModExpPow2_Mul", "vc-description": "Bignum task: bignum_ModExp[Add,DivMod,ModExpPow2,Mul].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */\n\n/* sy is power of 2 or zero */\n\n/* requires y < Exp_int(2,n+1) */\n\n/* && n > 0 */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 {\n    0nat\n  } else {\n    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) + str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n  requires \n    valid_bit_string(dividend) && valid_bit_string(divisor),\n    str2int(divisor) > 0\n  ensures \n    valid_bit_string(res.0) && valid_bit_string(res.1),\n    str2int(res.0) == str2int(dividend) / str2int(divisor),\n    str2int(res.1) == str2int(dividend) % str2int(divisor)\n{\n  assume(false);\n  unreached()\n}\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0,\n    sy.len() == n + 1,\n    str2int(sz) > 1\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases n\n{\n  assume(false);\n  unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) * str2int(s2)\n{\n  assume(false);\n  unreached()\n}", "vc-helpers": "", "vc-spec": "fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    sy.len() > 0 && str2int(sz) > 1\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases sy.len()", "vc-code": "{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_ModExp_Add_DivMod_ModExpPow2_Zeroes", "vc-description": "Bignum task: bignum_ModExp[Add,DivMod,ModExpPow2,Zeroes].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */\n\n/* sy is power of 2 or zero */\n\n/* requires y < Exp_int(2,n+1) */\n\n/* && n > 0 */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0nat \n    } else { \n        2 * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn all_zero(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2)\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) + str2int(s2)\n{\n    assume(false);\n    unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n    requires \n        valid_bit_string(dividend) && valid_bit_string(divisor) &&\n        str2int(divisor) > 0\n    ensures \n        valid_bit_string(res.0) && valid_bit_string(res.1) &&\n        str2int(res.0) == str2int(dividend) / str2int(divisor) &&\n        str2int(res.1) == str2int(dividend) % str2int(divisor)\n{\n    assume(false);\n    unreached()\n}\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n        (str2int(sy) == exp_int(2, n) || str2int(sy) == 0) &&\n        sy.len() == n + 1 &&\n        str2int(sz) > 1\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n    decreases n\n{\n    assume(false);\n    unreached()\n}\n\nfn zeros(n: nat) -> (s: Seq<char>)\n    ensures \n        s.len() == n &&\n        valid_bit_string(s) &&\n        str2int(s) == 0 &&\n        all_zero(s)\n{\n    assume(false);\n    unreached()\n}", "vc-helpers": "", "vc-spec": "fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n        sy.len() > 0 && str2int(sz) > 1\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n    decreases sy.len()", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_ModExp_Add_DivMod_Mul", "vc-description": "Bignum task: bignum_ModExp[Add,DivMod,Mul].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */\n\n/* requires y < Exp_int(2,n+1) */\n\n/* && n > 0 */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == str2int(s1) + str2int(s2),\n{\n  assume(false);\n  unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (ret: (Seq<char>, Seq<char>))\n  requires \n    valid_bit_string(dividend) && valid_bit_string(divisor) &&\n    str2int(divisor) > 0,\n  ensures \n    valid_bit_string(ret.0) && valid_bit_string(ret.1) &&\n    str2int(ret.0) == str2int(dividend) / str2int(divisor) &&\n    str2int(ret.1) == str2int(dividend) % str2int(divisor),\n{\n  assume(false);\n  unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == str2int(s1) * str2int(s2),\n{\n  assume(false);\n  unreached()\n}", "vc-helpers": "", "vc-spec": "fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n    sy.len() > 0 && str2int(sz) > 1,\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz),\n  decreases sy.len()", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_ModExp_Add_DivMod_Mul_Zeroes", "vc-description": "Bignum task: bignum_ModExp[Add,DivMod,Mul,Zeroes].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */\n\n/* requires y < Exp_int(2,n+1) */\n\n/* && n > 0 */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1nat) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nspec fn all_zero(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) + str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n  requires \n    valid_bit_string(dividend) && valid_bit_string(divisor),\n    str2int(divisor) > 0\n  ensures \n    valid_bit_string(res.0) && valid_bit_string(res.1),\n    str2int(res.0) == str2int(dividend) / str2int(divisor),\n    str2int(res.1) == str2int(dividend) % str2int(divisor)\n{\n  assume(false);\n  unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) * str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn zeros(n: nat) -> (s: Seq<char>)\n  ensures \n    s.len() == n,\n    valid_bit_string(s),\n    str2int(s) == 0,\n    all_zero(s)\n{\n  assume(false);\n  unreached()\n}", "vc-helpers": "", "vc-spec": "fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    sy.len() > 0 && str2int(sz) > 1\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases sy.len()", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_ModExp_Add_DivMod_Zeroes", "vc-description": "Bignum task: bignum_ModExp[Add,DivMod,Zeroes].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */\n\n/* requires y < Exp_int(2,n+1) */\n\n/* && n > 0 */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn str2_int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { \n    0nat \n  } else { \n    if valid_bit_string(s) {\n      2 * str2_int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    } else {\n      0nat\n    }\n  }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn all_zero(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res) &&\n    str2_int(res) == str2_int(s1) + str2_int(s2),\n{\n  assume(false);\n  unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (quotient_remainder: (Seq<char>, Seq<char>))\n  requires \n    valid_bit_string(dividend) && valid_bit_string(divisor) &&\n    str2_int(divisor) > 0,\n  ensures \n    valid_bit_string(quotient_remainder.0) && valid_bit_string(quotient_remainder.1) &&\n    str2_int(quotient_remainder.0) == str2_int(dividend) / str2_int(divisor) &&\n    str2_int(quotient_remainder.1) == str2_int(dividend) % str2_int(divisor),\n{\n  assume(false);\n  unreached()\n}\n\nfn zeros(n: nat) -> (s: Seq<char>)\n  ensures \n    s.len() == n &&\n    valid_bit_string(s) &&\n    str2_int(s) == 0 &&\n    all_zero(s),\n{\n  assume(false);\n  unreached()\n}", "vc-helpers": "", "vc-spec": "fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n    sy.len() > 0 && str2_int(sz) > 1,\n  ensures \n    valid_bit_string(res) &&\n    str2_int(res) == exp_int(str2_int(sx), str2_int(sy)) % str2_int(sz),\n  decreases sy.len(),", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_ModExp_Add_ModExpPow2", "vc-description": "Bignum task: bignum_ModExp[Add,ModExpPow2].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */\n\n/* sy is power of 2 or zero */\n\n/* requires y < Exp_int(2,n+1) */\n\n/* && n > 0 */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<u8>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { \n    0nat \n  } else { \n    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == 49u8 { 1nat } else { 0nat })\n  }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<u8>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == 48u8 || s[i] == 49u8)\n}\n\nfn add(s1: Seq<u8>, s2: Seq<u8>) -> (res: Seq<u8>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == str2int(s1) + str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn mod_exp_pow2(sx: Seq<u8>, sy: Seq<u8>, n: nat, sz: Seq<u8>) -> (res: Seq<u8>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n    (str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0) &&\n    sy.len() == n + 1 &&\n    str2int(sz) > 1\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases n\n{\n  assume(false);\n  unreached()\n}", "vc-helpers": "", "vc-spec": "fn mod_exp(sx: Seq<u8>, sy: Seq<u8>, sz: Seq<u8>) -> (res: Seq<u8>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n    sy.len() > 0 && str2int(sz) > 1\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases sy.len()", "vc-code": "{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_ModExp_Add_ModExpPow2_Mul", "vc-description": "Bignum task: bignum_ModExp[Add,ModExpPow2,Mul].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */\n\n/* sy is power of 2 or zero */\n\n/* requires y < Exp_int(2,n+1) */\n\n/* && n > 0 */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0nat \n    } else { \n        2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2)\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) + str2int(s2)\n{\n    assume(false);\n    unreached()\n}\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n        (str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0) &&\n        sy.len() == n + 1 &&\n        str2int(sz) > 1\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n    decreases n\n{\n    assume(false);\n    unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(s1) && valid_bit_string(s2)\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == str2int(s1) * str2int(s2)\n{\n    assume(false);\n    unreached()\n}", "vc-helpers": "", "vc-spec": "fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n        sy.len() > 0 && str2int(sz) > 1\n    ensures \n        valid_bit_string(res) &&\n        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n    decreases sy.len()", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_ModExp_Add_ModExpPow2_Mul_Zeroes", "vc-description": "Bignum task: bignum_ModExp[Add,ModExpPow2,Mul,Zeroes].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */\n\n/* sy is power of 2 or zero */\n\n/* requires y < Exp_int(2,n+1) */\n\n/* && n > 0 */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 {\n    0nat\n  } else {\n    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0nat { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn all_zero(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) + str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0,\n    sy.len() == n + 1,\n    str2int(sz) > 1\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases n\n{\n  assume(false);\n  unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) * str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn zeros(n: nat) -> (s: Seq<char>)\n  ensures \n    s.len() == n,\n    valid_bit_string(s),\n    str2int(s) == 0,\n    all_zero(s)\n{\n  assume(false);\n  unreached()\n}", "vc-helpers": "", "vc-spec": "fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    sy.len() > 0 && str2int(sz) > 1\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases sy.len()", "vc-code": "{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_ModExp_Add_ModExpPow2_Zeroes", "vc-description": "Bignum task: bignum_ModExp[Add,ModExpPow2,Zeroes].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */\n\n/* sy is power of 2 or zero */\n\n/* requires y < Exp_int(2,n+1) */\n\n/* && n > 0 */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { \n      0nat \n  } else { \n      2nat * str2int(s.subrange(0, s.len() as int - 1)) + (if s[s.len() as int - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1nat) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nspec fn all_zero(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n      valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n      valid_bit_string(res),\n      str2int(res) == str2int(s1) + str2int(s2),\n{\n  assume(false);\n  unreached()\n}\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n      valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n      str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0,\n      sy.len() == n + 1,\n      str2int(sz) > 1,\n  ensures \n      valid_bit_string(res),\n      str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz),\n  decreases n\n{\n  assume(false);\n  unreached()\n}\n\nfn zeros(n: nat) -> (s: Seq<char>)\n  ensures \n      s.len() == n,\n      valid_bit_string(s),\n      str2int(s) == 0,\n      all_zero(s),\n{\n  assume(false);\n  unreached()\n}", "vc-helpers": "", "vc-spec": "fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n      valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n      sy.len() > 0 && str2int(sz) > 1,\n  ensures \n      valid_bit_string(res),\n      str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz),\n  decreases sy.len()", "vc-code": "{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_ModExp_Add_Mul", "vc-description": "Bignum task: bignum_ModExp[Add,Mul].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */\n\n/* requires y < Exp_int(2,n+1) */\n\n/* && n > 0 */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn str2_int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2_int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res) &&\n    str2_int(res) == str2_int(s1) + str2_int(s2),\n{\n  assume(false);\n  unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res) &&\n    str2_int(res) == str2_int(s1) * str2_int(s2),\n{\n  assume(false);\n  unreached()\n}", "vc-helpers": "", "vc-spec": "fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n    sy.len() > 0 && str2_int(sz) > 1,\n  ensures \n    valid_bit_string(res) &&\n    str2_int(res) == exp_int(str2_int(sx), str2_int(sy)) % str2_int(sz),\n  decreases sy.len(),", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_ModExp_Add_Mul_Zeroes", "vc-description": "Bignum task: bignum_ModExp[Add,Mul,Zeroes].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */\n\n/* requires y < Exp_int(2,n+1) */\n\n/* && n > 0 */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn all_zero(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == str2int(s1) + str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == str2int(s1) * str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn zeros(n: nat) -> (s: Seq<char>)\n  ensures \n    s.len() == n &&\n    valid_bit_string(s) &&\n    str2int(s) == 0 &&\n    all_zero(s)\n{\n  assume(false);\n  unreached()\n}", "vc-helpers": "", "vc-spec": "fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n    sy.len() > 0 && str2int(sz) > 1\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases sy.len()", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_ModExp_Add_Zeroes", "vc-description": "Bignum task: bignum_ModExp[Add,Zeroes].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */\n\n/* requires y < Exp_int(2,n+1) */\n\n/* && n > 0 */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nspec fn all_zero(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) + str2int(s2),\n{\n  assume(false);\n  unreached()\n}\n\nfn zeros(n: nat) -> (s: Seq<char>)\n  ensures \n    s.len() == n,\n    valid_bit_string(s),\n    str2int(s) == 0,\n    all_zero(s),\n{\n  assume(false);\n  unreached()\n}", "vc-helpers": "", "vc-spec": "fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    sy.len() > 0 && str2int(sz) > 1,\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz),\n  decreases sy.len()", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_ModExp_DivMod", "vc-description": "Bignum task: bignum_ModExp[DivMod].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */\n\n/* requires y < Exp_int(2,n+1) */\n\n/* && n > 0 */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, (s.len() - 1) as int)) + (if s[(s.len() - 1) as int] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (result: (Seq<char>, Seq<char>))\n  requires \n      valid_bit_string(dividend) && valid_bit_string(divisor) &&\n      str2int(divisor) > 0\n  ensures \n      valid_bit_string(result.0) && valid_bit_string(result.1) &&\n      str2int(result.0) == str2int(dividend) / str2int(divisor) &&\n      str2int(result.1) == str2int(dividend) % str2int(divisor)\n{\n  assume(false);\n  unreached()\n}", "vc-helpers": "", "vc-spec": "fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n      valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n      sy.len() > 0 && str2int(sz) > 1\n  ensures \n      valid_bit_string(res) &&\n      str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases sy.len()", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_ModExp_DivMod_ModExpPow2", "vc-description": "Bignum task: bignum_ModExp[DivMod,ModExpPow2].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */\n\n/* sy is power of 2 or zero */\n\n/* requires y < Exp_int(2,n+1) */\n\n/* && n > 0 */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (result: (Seq<char>, Seq<char>))\n  requires \n    valid_bit_string(dividend) && valid_bit_string(divisor) &&\n    str2int(divisor) > 0\n  ensures \n    ({\n       let (quotient, remainder) = result; \n       valid_bit_string(quotient) && valid_bit_string(remainder) &&\n       str2int(quotient) == str2int(dividend) / str2int(divisor) &&\n       str2int(remainder) == str2int(dividend) % str2int(divisor)\n    })\n{\n  assume(false);\n  unreached()\n}\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n    (str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0) &&\n    sy.len() == n + 1 &&\n    str2int(sz) > 1\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases n\n{\n  assume(false);\n  unreached()\n}", "vc-helpers": "", "vc-spec": "fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n    sy.len() > 0 && str2int(sz) > 1\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases sy.len()", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_ModExp_DivMod_ModExpPow2_Mul", "vc-description": "Bignum task: bignum_ModExp[DivMod,ModExpPow2,Mul].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */\n\n/* sy is power of 2 or zero */\n\n/* requires y < Exp_int(2,n+1) */\n\n/* && n > 0 */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 {\n    0nat\n  } else {\n    2nat * str2int(s.subrange(0, s.len() - 1)) + \n     (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 {\n    1nat\n  } else {\n    x * exp_int(x, (y - 1) as nat)\n  }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n  requires \n    valid_bit_string(dividend) && valid_bit_string(divisor),\n    str2int(divisor) > 0,\n  ensures \n    valid_bit_string(res.0) && valid_bit_string(res.1),\n    str2int(res.0) == str2int(dividend) / str2int(divisor),\n    str2int(res.1) == str2int(dividend) % str2int(divisor),\n{\n  assume(false);\n  unreached()\n}\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    str2int(sy) == exp_int(2, n) || str2int(sy) == 0,\n    sy.len() == n + 1,\n    str2int(sz) > 1,\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz),\n  decreases n\n{\n  assume(false);\n  unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) * str2int(s2),\n{\n  assume(false);\n  unreached()\n}", "vc-helpers": "", "vc-spec": "fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    sy.len() > 0 && str2int(sz) > 1,\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz),\n  decreases sy.len()", "vc-code": "{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_ModExp_DivMod_ModExpPow2_Mul_Zeroes", "vc-description": "Bignum task: bignum_ModExp[DivMod,ModExpPow2,Mul,Zeroes].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */\n\n/* sy is power of 2 or zero */\n\n/* requires y < Exp_int(2,n+1) */\n\n/* && n > 0 */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 { \n    0nat \n  } else { \n    2nat * str2int(s.subrange(0, s.len() - 1)) + \n    (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn all_zero(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (result: (Seq<char>, Seq<char>))\n  requires \n    valid_bit_string(dividend) && valid_bit_string(divisor),\n    str2int(divisor) > 0,\n  ensures \n    valid_bit_string(result.0) && valid_bit_string(result.1),\n    str2int(result.0) == str2int(dividend) / str2int(divisor),\n    str2int(result.1) == str2int(dividend) % str2int(divisor),\n{\n  assume(false);\n  unreached()\n}\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0,\n    sy.len() == n + 1,\n    str2int(sz) > 1,\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz),\n  decreases n\n{\n  assume(false);\n  unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) * str2int(s2),\n{\n  assume(false);\n  unreached()\n}\n\nfn zeros(n: nat) -> (s: Seq<char>)\n  ensures \n    s.len() == n,\n    valid_bit_string(s),\n    str2int(s) == 0,\n    all_zero(s),\n{\n  assume(false);\n  unreached()\n}", "vc-helpers": "", "vc-spec": "fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    sy.len() > 0 && str2int(sz) > 1,\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz),\n  decreases sy.len()", "vc-code": "{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_ModExp_DivMod_ModExpPow2_Zeroes", "vc-description": "Bignum task: bignum_ModExp[DivMod,ModExpPow2,Zeroes].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */\n\n/* sy is power of 2 or zero */\n\n/* requires y < Exp_int(2,n+1) */\n\n/* && n > 0 */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0nat\n    } else {\n        2 * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 {\n        1nat\n    } else {\n        x * exp_int(x, (y - 1) as nat)\n    }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn all_zero(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (ret: (Seq<char>, Seq<char>))\n    requires \n        valid_bit_string(dividend) && valid_bit_string(divisor),\n        str2int(divisor) > 0\n    ensures \n        valid_bit_string(ret.0) && valid_bit_string(ret.1),\n        str2int(ret.0) == str2int(dividend) / str2int(divisor),\n        str2int(ret.1) == str2int(dividend) % str2int(divisor)\n{\n    assume(false);\n    unreached()\n}\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n        str2int(sy) == exp_int(2, n) || str2int(sy) == 0,\n        sy.len() == n + 1,\n        str2int(sz) > 1\n    ensures \n        valid_bit_string(res),\n        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n    decreases n\n{\n    assume(false);\n    unreached()\n}\n\nfn zeros(n: nat) -> (s: Seq<char>)\n    ensures \n        s.len() == n,\n        valid_bit_string(s),\n        str2int(s) == 0,\n        all_zero(s)\n{\n    assume(false);\n    unreached()\n}", "vc-helpers": "", "vc-spec": "fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n        sy.len() > 0 && str2int(sz) > 1\n    ensures \n        valid_bit_string(res),\n        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n    decreases sy.len()", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_ModExp_DivMod_Mul", "vc-description": "Bignum task: bignum_ModExp[DivMod,Mul].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */\n\n/* requires y < Exp_int(2,n+1) */\n\n/* && n > 0 */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1nat) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn div_mod(dividend: Vec<char>, divisor: Vec<char>) -> (res: (Vec<char>, Vec<char>))\n  requires \n    valid_bit_string(dividend@) && valid_bit_string(divisor@) &&\n    str2int(divisor@) > 0\n  ensures \n    valid_bit_string(res.0@) && valid_bit_string(res.1@) &&\n    str2int(res.0@) == str2int(dividend@) / str2int(divisor@) &&\n    str2int(res.1@) == str2int(dividend@) % str2int(divisor@)\n{\n  assume(false);\n  (Vec::new(), Vec::new())\n}\n\nfn mul(s1: Vec<char>, s2: Vec<char>) -> (res: Vec<char>)\n  requires valid_bit_string(s1@) && valid_bit_string(s2@)\n  ensures \n    valid_bit_string(res@) &&\n    str2int(res@) == str2int(s1@) * str2int(s2@)\n{\n  assume(false);\n  Vec::new()\n}", "vc-helpers": "", "vc-spec": "fn mod_exp(sx: Vec<char>, sy: Vec<char>, sz: Vec<char>) -> (res: Vec<char>)\n  requires \n    valid_bit_string(sx@) && valid_bit_string(sy@) && valid_bit_string(sz@) &&\n    sy@.len() > 0 && str2int(sz@) > 1\n  ensures \n    valid_bit_string(res@) &&\n    str2int(res@) == exp_int(str2int(sx@), str2int(sy@)) % str2int(sz@)\n  decreases sy@.len()", "vc-code": "{\n  assume(false);\n  Vec::new()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_ModExp_DivMod_Mul_Zeroes", "vc-description": "Bignum task: bignum_ModExp[DivMod,Mul,Zeroes].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */\n\n/* requires y < Exp_int(2,n+1) */\n\n/* && n > 0 */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 {\n      0nat\n  } else {\n      2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn all_zero(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (result: (Seq<char>, Seq<char>))\n  requires\n      valid_bit_string(dividend) && valid_bit_string(divisor) &&\n      str2int(divisor) > 0\n  ensures\n      valid_bit_string(result.0) && valid_bit_string(result.1) &&\n      str2int(result.0) == str2int(dividend) / str2int(divisor) &&\n      str2int(result.1) == str2int(dividend) % str2int(divisor)\n{\n  assume(false);\n  unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires valid_bit_string(s1) && valid_bit_string(s2)\n  ensures\n      valid_bit_string(res) &&\n      str2int(res) == str2int(s1) * str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn zeros(n: nat) -> (s: Seq<char>)\n  ensures\n      s.len() == n &&\n      valid_bit_string(s) &&\n      str2int(s) == 0 &&\n      all_zero(s)\n{\n  assume(false);\n  unreached()\n}", "vc-helpers": "", "vc-spec": "fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires\n      valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n      sy.len() > 0 && str2int(sz) > 1\n  ensures\n      valid_bit_string(res) &&\n      str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases sy.len()", "vc-code": "{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_ModExp_DivMod_Zeroes", "vc-description": "Bignum task: bignum_ModExp[DivMod,Zeroes].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */\n\n/* requires y < Exp_int(2,n+1) */\n\n/* && n > 0 */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { \n      0nat \n  } else { \n      2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn all_zero(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (res: (Seq<char>, Seq<char>))\n  requires \n      valid_bit_string(dividend) && valid_bit_string(divisor),\n      str2int(divisor) > 0,\n  ensures \n      valid_bit_string(res.0) && valid_bit_string(res.1),\n      str2int(res.0) == str2int(dividend) / str2int(divisor),\n      str2int(res.1) == str2int(dividend) % str2int(divisor),\n{\n  assume(false);\n  unreached()\n}\n\nfn zeros(n: nat) -> (s: Seq<char>)\n  ensures \n      s.len() == n,\n      valid_bit_string(s),\n      str2int(s) == 0,\n      all_zero(s),\n{\n  assume(false);\n  unreached()\n}", "vc-helpers": "", "vc-spec": "fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n      valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n      sy.len() > 0 && str2int(sz) > 1,\n  ensures \n      valid_bit_string(res),\n      str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz),\n  decreases sy.len()", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_ModExp_ModExpPow2", "vc-description": "Bignum task: bignum_ModExp[ModExpPow2].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */\n\n/* sy is power of 2 or zero */\n\n/* requires y < Exp_int(2,n+1) */\n\n/* && n > 0 */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0,\n    sy.len() == n + 1,\n    str2int(sz) > 1\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases n\n{\n  assume(false);\n  unreached()\n}", "vc-helpers": "", "vc-spec": "fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    sy.len() > 0 && str2int(sz) > 1\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases sy.len()", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_ModExp_ModExpPow2_Add_Zeroes_DivMod_Mul", "vc-description": "Bignum task: bignum_ModExp[ModExpPow2,Add,Zeroes,DivMod,Mul].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */\n\n/* sy is power of 2 or zero */\n\n/* requires y < Exp_int(2,n+1) */\n\n/* && n > 0 */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 {\n    0nat\n  } else {\n    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn all_zero(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0,\n    sy.len() == n + 1,\n    str2int(sz) > 1\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases n\n{\n  assume(false);\n  unreached()\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) + str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn zeros(n: nat) -> (s: Seq<char>)\n  ensures \n    s.len() == n,\n    valid_bit_string(s),\n    str2int(s) == 0,\n    all_zero(s)\n{\n  assume(false);\n  unreached()\n}\n\nfn div_mod(dividend: Seq<char>, divisor: Seq<char>) -> (ret: (Seq<char>, Seq<char>))\n  requires \n    valid_bit_string(dividend) && valid_bit_string(divisor),\n    str2int(divisor) > 0\n  ensures \n    valid_bit_string(ret.0) && valid_bit_string(ret.1),\n    str2int(ret.0) == str2int(dividend) / str2int(divisor),\n    str2int(ret.1) == str2int(dividend) % str2int(divisor)\n{\n  assume(false);\n  unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) * str2int(s2)\n{\n  assume(false);\n  unreached()\n}", "vc-helpers": "", "vc-spec": "fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    sy.len() > 0 && str2int(sz) > 1\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases sy.len()", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_ModExp_ModExpPow2_Mul", "vc-description": "Bignum task: bignum_ModExp[ModExpPow2,Mul].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */\n\n/* sy is power of 2 or zero */\n\n/* requires y < Exp_int(2,n+1) */\n\n/* && n > 0 */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0,\n    sy.len() == n + 1,\n    str2int(sz) > 1\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases n\n{\n  assume(false);\n  unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) * str2int(s2)\n{\n  assume(false);\n  unreached()\n}", "vc-helpers": "", "vc-spec": "fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    sy.len() > 0 && str2int(sz) > 1\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases sy.len()", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_ModExp_ModExpPow2_Mul_Zeroes", "vc-description": "Bignum task: bignum_ModExp[ModExpPow2,Mul,Zeroes].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */\n\n/* sy is power of 2 or zero */\n\n/* requires y < Exp_int(2,n+1) */\n\n/* && n > 0 */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n    recommends valid_bit_string(s)\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0nat \n    } else { \n        2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn all_zero(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n        str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0,\n        sy.len() == n + 1,\n        str2int(sz) > 1\n    ensures \n        valid_bit_string(res),\n        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n    decreases n\n{\n    assume(false);\n    unreached()\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n    requires valid_bit_string(s1) && valid_bit_string(s2)\n    ensures \n        valid_bit_string(res),\n        str2int(res) == str2int(s1) * str2int(s2)\n{\n    assume(false);\n    unreached()\n}\n\nfn zeros(n: nat) -> (s: Seq<char>)\n    ensures \n        s.len() == n,\n        valid_bit_string(s),\n        str2int(s) == 0,\n        all_zero(s)\n{\n    assume(false);\n    unreached()\n}", "vc-helpers": "", "vc-spec": "fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n    requires \n        valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n        sy.len() > 0 && str2int(sz) > 1\n    ensures \n        valid_bit_string(res),\n        str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n    decreases sy.len()", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_ModExp_ModExpPow2_Zeroes", "vc-description": "Bignum task: bignum_ModExp[ModExpPow2,Zeroes].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */\n\n/* sy is power of 2 or zero */\n\n/*requires y < Exp_int(2,n+1)*/\n\n/*&& n > 0*/", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 {\n    0nat\n  } else {\n    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 {\n    1nat\n  } else {\n    x * exp_int(x, (y - 1) as nat)\n  }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nspec fn all_zero(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nfn mod_exp_pow2(sx: Seq<char>, sy: Seq<char>, n: nat, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    str2int(sy) == exp_int(2nat, n) || str2int(sy) == 0,\n    sy.len() == n + 1,\n    str2int(sz) > 1\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases n\n{\n  assume(false);\n  unreached()\n}\n\nfn zeros(n: nat) -> (s: Seq<char>)\n  ensures \n    s.len() == n,\n    valid_bit_string(s),\n    str2int(s) == 0,\n    all_zero(s)\n{\n  assume(false);\n  unreached()\n}", "vc-helpers": "", "vc-spec": "fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    sy.len() > 0 && str2int(sz) > 1\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases sy.len()", "vc-code": "{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_ModExp_Mul", "vc-description": "Bignum task: bignum_ModExp[Mul].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */\n\n/* requires y < Exp_int(2,n+1) */\n\n/* && n > 0 */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 {\n    0nat\n  } else {\n    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 {\n    1nat\n  } else {\n    x * exp_int(x, (y - 1) as nat)\n  }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == str2int(s1) * str2int(s2)\n{\n  assume(false);\n  unreached()\n}", "vc-helpers": "", "vc-spec": "fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz) &&\n    sy.len() > 0 && str2int(sz) > 1\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases sy.len()", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_ModExp_Mul_Zeroes", "vc-description": "Bignum task: bignum_ModExp[Mul,Zeroes].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */\n\n/* requires y < Exp_int(2,n+1) */\n\n/* && n > 0 */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { \n    0nat \n  } else { \n    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn all_zero(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nfn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) * str2int(s2)\n{\n  assume(false);\n  unreached()\n}\n\nfn zeros(n: nat) -> (s: Seq<char>)\n  ensures \n    s.len() == n,\n    valid_bit_string(s),\n    str2int(s) == 0,\n    all_zero(s)\n{\n  assume(false);\n  unreached()\n}", "vc-helpers": "", "vc-spec": "fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    sy.len() > 0 && str2int(sz) > 1\n  ensures \n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz)\n  decreases sy.len()", "vc-code": "{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_ModExp_Zeroes", "vc-description": "Bignum task: bignum_ModExp[Zeroes].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */\n\n/* requires y < Exp_int(2,n+1) */\n\n/* && n > 0 */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn exp_int(x: nat, y: nat) -> nat\n  decreases y\n{\n  if y == 0 { 1nat } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nspec fn all_zero(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nfn zeros(n: nat) -> (s: Seq<char>)\n  ensures\n    s.len() == n,\n    valid_bit_string(s),\n    str2int(s) == 0,\n    all_zero(s),\n{\n  assume(false);\n  unreached()\n}", "vc-helpers": "", "vc-spec": "fn mod_exp(sx: Seq<char>, sy: Seq<char>, sz: Seq<char>) -> (res: Seq<char>)\n  requires\n    valid_bit_string(sx) && valid_bit_string(sy) && valid_bit_string(sz),\n    sy.len() > 0 && str2int(sz) > 1,\n  ensures\n    valid_bit_string(res),\n    str2int(res) == exp_int(str2int(sx), str2int(sy)) % str2int(sz),\n  decreases sy.len()", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_ModExp_int", "vc-description": "Bignum task: bignum_ModExp_int.\nImplement the method according to the Verus specification.\n\n/* && n > 0 */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1 } else { x * exp_int(x, (y - 1) as nat) }\n}", "vc-helpers": "", "vc-spec": "fn mod_exp_int(x: u64, y: u64, n: u64, z: u64) -> (res: u64)\n    requires \n        y < exp_int(x as nat, y as nat),\n        z > 1,\n    ensures res as nat == exp_int(x as nat, y as nat) % (z as nat)\n    decreases n", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_ModExp_int_ModExpPow2_int", "vc-description": "Bignum task: bignum_ModExp_int[ModExpPow2_int].\nImplement the method according to the Verus specification.\n\n/* && n > 0 */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn exp_int(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1 } else { x * exp_int(x, (y - 1) as nat) }\n}\n\nfn mod_exp_pow2_int(x: nat, y: nat, n: nat, z: nat) -> (res: nat)\n    requires \n        y == exp_int(2, n),\n        z > 0,\n    ensures res == exp_int(x, y) % z\n    decreases n\n{\n    assume(false);\n    unreached()\n}", "vc-helpers": "", "vc-spec": "fn mod_exp_int(x: nat, y: nat, n: nat, z: nat) -> (res: nat)\n    requires \n        y < exp_int(2, n + 1),\n        z > 1,\n    ensures res == exp_int(x, y) % z\n    decreases n", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_Mul", "vc-description": "Bignum task: bignum_Mul.\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 {\n    0nat \n  } else {\n    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}", "vc-helpers": "", "vc-spec": "fn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == str2int(s1) * str2int(s2)", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_Mul_Add", "vc-description": "Bignum task: bignum_Mul[Add].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == str2int(s1) + str2int(s2),\n{\n  assume(false);\n  unreached()\n}", "vc-helpers": "", "vc-spec": "fn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == str2int(s1) * str2int(s2),", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_Mul_Add_NormalizeBitString", "vc-description": "Bignum task: bignum_Mul[Add,NormalizeBitString].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nfn add(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == str2int(s1) + str2int(s2),\n{\n  assume(false);\n  unreached()\n}\n\nfn normalize_bit_string(s: Seq<char>) -> (t: Seq<char>)\n  ensures \n    valid_bit_string(t) &&\n    t.len() > 0 &&\n    (t.len() > 1 ==> t[0] != '0') &&\n    (valid_bit_string(s) ==> str2int(s) == str2int(t)),\n{\n  assume(false);\n  unreached()\n}", "vc-helpers": "", "vc-spec": "fn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == str2int(s1) * str2int(s2),", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_Mul_NormalizeBitString", "vc-description": "Bignum task: bignum_Mul[NormalizeBitString].\nImplement the method according to the Verus specification.\n\n/* All characters must be '0' or '1'. */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 { \n    0nat \n  } else { \n    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn normalize_bit_string(s: Seq<char>) -> (t: Seq<char>)\n  ensures \n    valid_bit_string(t),\n    t.len() > 0,\n    t.len() > 1 ==> t[0] != '0',\n    valid_bit_string(s) ==> str2int(s) == str2int(t)\n{\n  assume(false);\n  unreached()\n}", "vc-helpers": "", "vc-spec": "fn mul(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2)\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) * str2int(s2)", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_NormalizeBitString", "vc-description": "Bignum task: bignum_NormalizeBitString.\nImplement the method according to the Dafny specification.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn str2int(s: Seq<char>) -> nat\n  recommends valid_bit_string(s)\n  decreases s.len()\n{\n  if s.len() == 0 {\n    0nat\n  } else {\n    2nat * str2int(s.subrange(0, s.len() as int - 1)) + \n    (if s[s.len() as int - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}", "vc-helpers": "", "vc-spec": "fn normalize_bit_string(s: Seq<char>) -> (t: Seq<char>)\n  ensures \n    valid_bit_string(t) &&\n    t.len() > 0 &&\n    (t.len() > 1 ==> t[0] != '0') &&\n    (valid_bit_string(s) ==> str2int(s) == str2int(t))", "vc-code": "{\n  /* impl-start */\n  assume(false);\n  unreached()\n  /* impl-end */\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_Sub", "vc-description": "Bignum task: bignums_Sub.\nImplement the method according to the Verus specification.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { 0nat } else { 2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat }) }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool\n{\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}", "vc-helpers": "", "vc-spec": "fn sub(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2),\n    str2int(s1) >= str2int(s2),\n  ensures \n    valid_bit_string(res),\n    str2int(res) == str2int(s1) - str2int(s2),", "vc-code": "{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_Sub_NormalizeBitstring", "vc-description": "Bignum task: bignums_Sub[NormalizeBitstring].\nImplement the method according to the Verus specification.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn str2int(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() == 0 { \n    0nat \n  } else { \n    2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n  }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nfn normalize_bit_string(s: Seq<char>) -> (t: Seq<char>)\n  ensures \n    valid_bit_string(t) &&\n    t.len() > 0 &&\n    (t.len() > 1 ==> t[0] != '0') &&\n    (valid_bit_string(s) ==> str2int(s) == str2int(t))\n{\n  assume(false);\n  unreached()\n}", "vc-helpers": "", "vc-spec": "fn sub(s1: Seq<char>, s2: Seq<char>) -> (res: Seq<char>)\n  requires \n    valid_bit_string(s1) && valid_bit_string(s2) &&\n    str2int(s1) >= str2int(s2)\n  ensures \n    valid_bit_string(res) &&\n    str2int(res) == str2int(s1) - str2int(s2)", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "bignum_Zeros", "vc-description": "Bignum task: bignums_Zeros.\nImplement the method according to the Verus specification.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn all_zero(s: Seq<char>) -> bool {\n    s.len() == 0 || forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nspec fn str2int(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0nat \n    } else { \n        2nat * str2int(s.subrange(0, s.len() - 1)) + (if s[s.len() - 1] == '1' { 1nat } else { 0nat })\n    }\n}\n\nspec fn valid_bit_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}", "vc-helpers": "", "vc-spec": "fn zeros(n: usize) -> (s: Seq<char>)\n    ensures \n        s.len() == n,\n        valid_bit_string(s),\n        str2int(s) == 0,\n        all_zero(s)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
