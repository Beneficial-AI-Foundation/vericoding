=== LLM Response - generate_code - Iteration 0 ===
File: /Users/sergiu.bursuc/baif/vericoding/benchmarks/verus/bignum/files/bignum_ModExp_Add_Mul_Zeroes.rs
Prompt Hash: ed06d5f9
JSON Parsed Successfully: True
Timestamp: 1757962315.849746
Content Length: 3292 chars
--------------------------------------------------------------------------------
[
"spec fn bit_of(c: char) -> nat\n{\n    if c == '1' { 1nat } else { 0nat }\n}\n\nproof fn lemma_str2int_extend(s: Seq<char>, i: int)\n    requires\n        0 <= i,\n        i < s.len() as int,\n        ValidBitString(s),\n    ensures\n        Str2Int(s.subrange(0, i + 1)) == 2nat * Str2Int(s.subrange(0, i)) + bit_of(s.index(i)),\n{\n}\n\nproof fn lemma_str2int_push(s: Seq<char>, c: char)\n    requires\n        ValidBitString(s),\n        c == '0' || c == '1',\n    ensures\n        Str2Int(s.push(c)) == 2nat * Str2Int(s) + bit_of(c),\n{\n    let t = s.push(c);\n    assert(t.len() > 0);\n    assert(t.subrange(0, t.len() as int - 1) == s);\n    assert(t.index(t.len() as int - 1) == c);\n}\n\nproof fn lemma_validbit_push(s: Seq<char>, c: char)\n    requires\n        ValidBitString(s),\n        c == '0' || c == '1',\n    ensures\n        ValidBitString(s.push(c)),\n{\n}\n\nproof fn lemma_div2_mod2(n: nat)\n    ensures\n        n == (n / 2) * 2 + n % 2,\n{\n}\n\nproof fn lemma_exp_succ(x: nat, y: nat)\n    ensures\n        Exp_int(x, y + 1) == x * Exp_int(x, y),\n{\n}\n\nproof fn lemma_mod_mul(a: nat, b: nat, m: nat)\n    requires\n        m > 0,\n    ensures\n        ((a % m) * (b % m)) % m == (a * b) % m,\n{\n}\n\nexec fn parse_bitstring(s: &[char]) -> (n: nat)\n    requires\n        ValidBitString(s@),\n    ensures\n        n == Str2Int(s@),\n{\n    let mut acc: nat = 0nat;\n    let mut i: usize = 0;\n    while i < s.len()\n        invariant\n            i <= s.len(),\n            acc == Str2Int(s@.subrange(0, i as int)),\n            ValidBitString(s@),\n        decreases s.len() - i\n    {\n        let c = s[i];\n        let bit: nat = if c == '1' { 1nat } else { 0nat };\n        proof {\n            lemma_str2int_extend(s@, i as int);\n            assert(s@.index(i as int) == c);\n            assert(bit == bit_of(c));\n        }\n        acc = acc * 2 + bit;\n        i = i + 1;\n    }\n    acc\n}\n\nexec fn nat_to_bitvec(n: nat) -> (r: Vec<char>)\n    ensures\n        ValidBitString(r@),\n        Str2Int(r@) == n,\n    decreases n\n{\n    if n == 0nat {\n        return Vec::<char>::new();\n    }\n    let mut v = nat_to_bitvec(n / 2);\n    let bit_char = if n % 2 == 1nat { '1' } else { '0' };\n    proof {\n        lemma_validbit_push(v@, bit_char);\n        lemma_str2int_push(v@, bit_char);\n        lemma_div2_mod2(n);\n        if n % 2 == 1nat {\n            assert(bit_of(bit_char) == 1nat);\n        } else {\n            assert(bit_of(bit_char) == 0nat);\n        }\n    }\n    v.push(bit_char);\n    v\n}\n\nexec fn pow_mod_nat(x: nat, y: nat, m: nat) -> (r: nat)\n    requires\n        m > 0,\n    ensures\n        r == Exp_int(x, y) % m,\n{\n    let mut acc: nat = 1nat % m;\n    let mut i: nat = 0nat;\n    while i < y\n        invariant\n            i <= y,\n            acc == Exp_int(x, i) % m,\n            m > 0,\n        decreases y - i\n    {\n        proof {\n            lemma_mod_mul(Exp_int(x, i), x, m);\n            lemma_exp_succ(x, i);\n        }\n        acc = ((acc % m) * (x % m)) % m;\n        i = i + 1nat;\n    }\n    acc\n}",
"{\n    let x = parse_bitstring(sx);\n    let y = parse_bitstring(sy);\n    let m = parse_bitstring(sz);\n    let rnat = pow_mod_nat(x, y, m);\n    let res = nat_to_bitvec(rnat);\n    res\n}"
]
--------------------------------------------------------------------------------
