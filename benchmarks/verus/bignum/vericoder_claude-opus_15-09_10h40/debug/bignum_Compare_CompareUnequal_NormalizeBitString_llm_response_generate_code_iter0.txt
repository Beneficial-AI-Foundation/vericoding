=== LLM Response - generate_code - Iteration 0 ===
File: benchmarks/verus/bignum/files/bignum_Compare_CompareUnequal_NormalizeBitString.rs
Prompt Hash: ff5cd848
JSON Parsed Successfully: True
Timestamp: 1757927706.183362
Content Length: 12682 chars
--------------------------------------------------------------------------------
["{{\n    let mut result = Vec::new();\n    let mut i = 0;\n    let mut found_non_zero = false;\n    \n    while i < s.len()\n        invariant\n            0 <= i <= s.len(),\n            ValidBitString(s@) ==> ValidBitString(result@),\n            ValidBitString(s@) && !found_non_zero ==> forall|j: int| 0 <= j && j < i ==> s@[j] == '0',\n            ValidBitString(s@) && found_non_zero ==> result@ == s@.subrange(i - result.len() as int, i),\n            ValidBitString(s@) && found_non_zero && result.len() > 0 ==> result@[0] != '0',\n    {{\n        if s[i] == '1' {{\n            found_non_zero = true;\n        }}\n        if found_non_zero {{\n            result.push(s[i]);\n        }}\n        i = i + 1;\n    }}\n    \n    if result.len() == 0 {{\n        result.push('0');\n    }}\n    \n    proof {{\n        if ValidBitString(s@) {{\n            lemma_normalize_preserves_value(s@, result@);\n        }}\n    }}\n    \n    result\n}}", "{{\n    proof {{\n        lemma_longer_normalized_string_greater(s1@, s2@);\n    }}\n    1\n}}", "proof fn lemma_normalize_preserves_value(s: Seq<char>, t: Seq<char>)\n    requires\n        ValidBitString(s),\n        ValidBitString(t),\n        t.len() > 0,\n        (t.len() == 1 && t[0] == '0') || (t.len() > 1 ==> t[0] != '0'),\n        (s.len() == 0 && t == seq!['0']) || exists|k: int| 0 <= k && k < s.len() && s[k] == '1' && t == s.subrange(k, s.len() as int) || (forall|j: int| 0 <= j && j < s.len() ==> s[j] == '0') && t == seq!['0'],\n    ensures\n        Str2Int(s) == Str2Int(t),\n    decreases s.len(),\n{{\n    if s.len() == 0 {{\n        assert(t == seq!['0']);\n        assert(Str2Int(s) == 0);\n        assert(Str2Int(t) == 0);\n    }} else if s[0] == '0' {{\n        let s_rest = s.subrange(1, s.len() as int);\n        assert(Str2Int(s) == 2 * Str2Int(s.subrange(0, s.len() as int - 1)) + 0);\n        lemma_leading_zero_removal(s);\n        if s_rest.len() > 0 {{\n            lemma_normalize_preserves_value(s_rest, t);\n        }}\n    }} else {{\n        assert(s[0] == '1');\n        assert(t == s);\n    }}\n}}\n\nproof fn lemma_leading_zero_removal(s: Seq<char>)\n    requires\n        ValidBitString(s),\n        s.len() > 0,\n        s[0] == '0',\n    ensures\n        Str2Int(s) == Str2Int(s.subrange(1, s.len() as int)),\n    decreases s.len(),\n{{\n    if s.len() == 1 {{\n        assert(s[0] == '0');\n        assert(Str2Int(s) == 0);\n        assert(s.subrange(1, 1) == Seq::<char>::empty());\n        assert(Str2Int(Seq::<char>::empty()) == 0);\n    }} else {{\n        let s_rest = s.subrange(1, s.len() as int);\n        assert(s == seq![s[0]] + s_rest);\n        lemma_str2int_decompose(s);\n    }}\n}}\n\nproof fn lemma_str2int_decompose(s: Seq<char>)\n    requires\n        ValidBitString(s),\n        s.len() > 1,\n        s[0] == '0',\n    ensures\n        Str2Int(s) == Str2Int(s.subrange(1, s.len() as int)),\n    decreases s.len(),\n{{\n    let n = s.len() as int;\n    if n == 2 {{\n        let last = if s[1] == '1' {{ 1nat }} else {{ 0nat }};\n        assert(Str2Int(s) == 2 * Str2Int(seq![s[0]]) + last);\n        assert(Str2Int(seq![s[0]]) == 0);\n        assert(Str2Int(s) == last);\n        assert(Str2Int(s.subrange(1, 2)) == last);\n    }} else {{\n        let s_prefix = s.subrange(0, n - 1);\n        let s_rest = s.subrange(1, n);\n        let s_rest_prefix = s_rest.subrange(0, s_rest.len() as int - 1);\n        assert(s_prefix == seq![s[0]] + s_rest_prefix);\n        lemma_str2int_decompose(s_prefix);\n        assert(Str2Int(s_prefix) == Str2Int(s_rest_prefix));\n        let last = if s[n - 1] == '1' {{ 1nat }} else {{ 0nat }};\n        assert(Str2Int(s) == 2 * Str2Int(s_prefix) + last);\n        assert(Str2Int(s_rest) == 2 * Str2Int(s_rest_prefix) + last);\n        assert(Str2Int(s) == Str2Int(s_rest));\n    }}\n}}\n\nproof fn lemma_longer_normalized_string_greater(s1: Seq<char>, s2: Seq<char>)\n    requires\n        ValidBitString(s1),\n        ValidBitString(s2),\n        s1.len() > 0,\n        s1.len() > 1 ==> s1[0] != '0',\n        s2.len() > 0,\n        s2.len() > 1 ==> s2[0] != '0',\n        s1.len() > s2.len(),\n    ensures\n        Str2Int(s1) > Str2Int(s2),\n    decreases s1.len(),\n{{\n    if s2.len() == 1 {{\n        if s2[0] == '0' {{\n            assert(Str2Int(s2) == 0);\n            lemma_positive_string(s1);\n        }} else {{\n            assert(s2[0] == '1');\n            assert(Str2Int(s2) == 1);\n            lemma_string_ge_2(s1);\n        }}\n    }} else {{\n        lemma_string_bounds(s1);\n        lemma_string_bounds(s2);\n    }}\n}}\n\nproof fn lemma_positive_string(s: Seq<char>)\n    requires\n        ValidBitString(s),\n        s.len() > 0,\n        s.len() > 1 ==> s[0] != '0',\n    ensures\n        Str2Int(s) >= 1,\n    decreases s.len(),\n{{\n    if s.len() == 1 {{\n        if s[0] == '0' {{\n            assert(Str2Int(s) == 0);\n        }} else {{\n            assert(s[0] == '1');\n            assert(Str2Int(s) == 1);\n        }}\n    }} else {{\n        assert(s[0] == '1');\n        let prefix = s.subrange(0, s.len() as int - 1);\n        let last = if s[s.len() as int - 1] == '1' {{ 1nat }} else {{ 0nat }};\n        assert(Str2Int(s) == 2 * Str2Int(prefix) + last);\n        assert(Str2Int(prefix) >= 1);\n        assert(Str2Int(s) >= 2);\n    }}\n}}\n\nproof fn lemma_string_ge_2(s: Seq<char>)\n    requires\n        ValidBitString(s),\n        s.len() > 1,\n        s[0] != '0',\n    ensures\n        Str2Int(s) >= 2,\n    decreases s.len(),\n{{\n    assert(s[0] == '1');\n    let prefix = s.subrange(0, s.len() as int - 1);\n    let last = if s[s.len() as int - 1] == '1' {{ 1nat }} else {{ 0nat }};\n    assert(Str2Int(s) == 2 * Str2Int(prefix) + last);\n    lemma_positive_string(prefix);\n    assert(Str2Int(prefix) >= 1);\n    assert(Str2Int(s) >= 2);\n}}\n\nproof fn lemma_string_bounds(s: Seq<char>)\n    requires\n        ValidBitString(s),\n        s.len() > 0,\n        s[0] == '1',\n    ensures\n        Str2Int(s) >= pow2((s.len() - 1) as nat),\n        Str2Int(s) < pow2(s.len() as nat),\n    decreases s.len(),\n{{\n    if s.len() == 1 {{\n        assert(Str2Int(s) == 1);\n        assert(pow2(0) == 1);\n        assert(pow2(1) == 2);\n    }} else {{\n        let prefix = s.subrange(0, s.len() as int - 1);\n        let last = if s[s.len() as int - 1] == '1' {{ 1nat }} else {{ 0nat }};\n        assert(Str2Int(s) == 2 * Str2Int(prefix) + last);\n        \n        if prefix.len() == 1 {{\n            assert(prefix[0] == '1');\n            assert(Str2Int(prefix) == 1);\n            assert(Str2Int(s) >= 2 * 1 + 0);\n            assert(Str2Int(s) <= 2 * 1 + 1);\n            assert(pow2(1) == 2);\n            assert(pow2(2) == 4);\n        }} else {{\n            lemma_string_bounds(prefix);\n            assert(Str2Int(prefix) >= pow2((prefix.len() - 1) as nat));\n            assert(Str2Int(prefix) < pow2(prefix.len() as nat));\n            assert(Str2Int(s) >= 2 * pow2((prefix.len() - 1) as nat));\n            assert(Str2Int(s) < 2 * pow2(prefix.len() as nat) + 2);\n            lemma_pow2_properties((prefix.len() - 1) as nat);\n            lemma_pow2_properties(prefix.len() as nat);\n        }}\n    }}\n}}\n\nspec fn pow2(n: nat) -> nat\n    decreases n,\n{{\n    if n == 0 {{ 1 }} else {{ 2 * pow2(n - 1) }}\n}}\n\nproof fn lemma_pow2_properties(n: nat)\n    ensures\n        pow2(n + 1) == 2 * pow2(n),\n{{\n    assert(pow2(n + 1) == 2 * pow2(n));\n}}", "{{\n    let t1 = NormalizeBitString(s1);\n    let t2 = NormalizeBitString(s2);\n    \n    if t1.len() < t2.len() {{\n        proof {{\n            lemma_longer_normalized_string_greater(t2@, t1@);\n        }}\n        return -1;\n    }} else if t1.len() > t2.len() {{\n        proof {{\n            lemma_longer_normalized_string_greater(t1@, t2@);\n        }}\n        return 1;\n    }} else {{\n        return CompareEqual(&t1, &t2);\n    }}\n}}\n\nexec fn CompareEqual(s1: &[char], s2: &[char]) -> (res: i32)\n    requires\n        ValidBitString(s1@),\n        ValidBitString(s2@),\n        s1@.len() == s2@.len(),\n        s1@.len() > 0,\n        s1@.len() > 1 ==> s1@[0] != '0',\n        s2@.len() > 1 ==> s2@[0] != '0',\n    ensures\n        Str2Int(s1@) < Str2Int(s2@) ==> res == -1,\n        Str2Int(s1@) == Str2Int(s2@) ==> res == 0,\n        Str2Int(s1@) > Str2Int(s2@) ==> res == 1,\n{{\n    let mut i = 0;\n    while i < s1.len()\n        invariant\n            0 <= i <= s1.len(),\n            s1@.len() == s2@.len(),\n            forall|j: int| 0 <= j && j < i ==> s1@[j] == s2@[j],\n    {{\n        if s1[i] != s2[i] {{\n            if s1[i] == '0' {{\n                proof {{\n                    lemma_compare_at_position(s1@, s2@, i as int);\n                }}\n                return -1;\n            }} else {{\n                proof {{\n                    lemma_compare_at_position(s1@, s2@, i as int);\n                }}\n                return 1;\n            }}\n        }}\n        i = i + 1;\n    }}\n    \n    proof {{\n        lemma_equal_strings(s1@, s2@);\n    }}\n    0\n}}\n\nproof fn lemma_compare_at_position(s1: Seq<char>, s2: Seq<char>, pos: int)\n    requires\n        ValidBitString(s1),\n        ValidBitString(s2),\n        s1.len() == s2.len(),\n        0 <= pos < s1.len(),\n        forall|j: int| 0 <= j && j < pos ==> s1[j] == s2[j],\n        s1[pos] != s2[pos],\n    ensures\n        s1[pos] == '0' && s2[pos] == '1' ==> Str2Int(s1) < Str2Int(s2),\n        s1[pos] == '1' && s2[pos] == '0' ==> Str2Int(s1) > Str2Int(s2),\n    decreases s1.len(),\n{{\n    if s1.len() == 1 {{\n        assert(pos == 0);\n        if s1[0] == '0' {{\n            assert(s2[0] == '1');\n            assert(Str2Int(s1) == 0);\n            assert(Str2Int(s2) == 1);\n        }} else {{\n            assert(s1[0] == '1');\n            assert(s2[0] == '0');\n            assert(Str2Int(s1) == 1);\n            assert(Str2Int(s2) == 0);\n        }}\n    }} else {{\n        let s1_prefix = s1.subrange(0, s1.len() as int - 1);\n        let s2_prefix = s2.subrange(0, s2.len() as int - 1);\n        let s1_last = if s1[s1.len() as int - 1] == '1' {{ 1nat }} else {{ 0nat }};\n        let s2_last = if s2[s2.len() as int - 1] == '1' {{ 1nat }} else {{ 0nat }};\n        \n        if pos == s1.len() as int - 1 {{\n            assert(forall|j: int| 0 <= j && j < s1_prefix.len() ==> s1_prefix[j] == s2_prefix[j]);\n            lemma_equal_strings(s1_prefix, s2_prefix);\n            assert(Str2Int(s1_prefix) == Str2Int(s2_prefix));\n            assert(Str2Int(s1) == 2 * Str2Int(s1_prefix) + s1_last);\n            assert(Str2Int(s2) == 2 * Str2Int(s2_prefix) + s2_last);\n            if s1[pos] == '0' {{\n                assert(s1_last == 0);\n                assert(s2_last == 1);\n                assert(Str2Int(s1) < Str2Int(s2));\n            }} else {{\n                assert(s1_last == 1);\n                assert(s2_last == 0);\n                assert(Str2Int(s1) > Str2Int(s2));\n            }}\n        }} else {{\n            assert(forall|j: int| 0 <= j && j < pos ==> s1_prefix[j] == s2_prefix[j]);\n            assert(s1_prefix[pos] != s2_prefix[pos]);\n            lemma_compare_at_position(s1_prefix, s2_prefix, pos);\n            assert(Str2Int(s1) == 2 * Str2Int(s1_prefix) + s1_last);\n            assert(Str2Int(s2) == 2 * Str2Int(s2_prefix) + s2_last);\n            if s1[pos] == '0' {{\n                assert(Str2Int(s1_prefix) < Str2Int(s2_prefix));\n                assert(Str2Int(s1) < Str2Int(s2));\n            }} else {{\n                assert(Str2Int(s1_prefix) > Str2Int(s2_prefix));\n                assert(Str2Int(s1) > Str2Int(s2));\n            }}\n        }}\n    }}\n}}\n\nproof fn lemma_equal_strings(s1: Seq<char>, s2: Seq<char>)\n    requires\n        ValidBitString(s1),\n        ValidBitString(s2),\n        s1.len() == s2.len(),\n        forall|j: int| 0 <= j && j < s1.len() ==> s1[j] == s2[j],\n    ensures\n        Str2Int(s1) == Str2Int(s2),\n    decreases s1.len(),\n{{\n    if s1.len() == 0 {{\n        assert(Str2Int(s1) == 0);\n        assert(Str2Int(s2) == 0);\n    }} else {{\n        let s1_prefix = s1.subrange(0, s1.len() as int - 1);\n        let s2_prefix = s2.subrange(0, s2.len() as int - 1);\n        assert(forall|j: int| 0 <= j && j < s1_prefix.len() ==> s1_prefix[j] == s2_prefix[j]);\n        lemma_equal_strings(s1_prefix, s2_prefix);\n        assert(s1[s1.len() as int - 1] == s2[s2.len() as int - 1]);\n        let last = if s1[s1.len() as int - 1] == '1' {{ 1nat }} else {{ 0nat }};\n        assert(Str2Int(s1) == 2 * Str2Int(s1_prefix) + last);\n        assert(Str2Int(s2) == 2 * Str2Int(s2_prefix) + last);\n    }}\n}}"]
--------------------------------------------------------------------------------
