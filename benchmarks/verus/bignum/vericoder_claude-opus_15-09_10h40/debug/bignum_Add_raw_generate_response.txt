=== Raw LLM Generate Response ===
Length: 2918 characters
--------------------------------------------------------------------------------
["spec fn power2(n: nat) -> nat\n    decreases n\n{\n    if n == 0 { 1 } else { 2 * power2(n - 1) }\n}\n\nproof fn lemma_str2int_bounds(s: Seq<char>)\n    requires ValidBitString(s)\n    ensures Str2Int(s) < power2(s.len())\n    decreases s.len()\n{\n    if s.len() > 0 {\n        lemma_str2int_bounds(s.subrange(0, s.len() as int - 1));\n    }\n}\n\nproof fn lemma_str2int_append(s: Seq<char>, c: char)\n    requires\n        ValidBitString(s),\n        c == '0' || c == '1',\n    ensures\n        ValidBitString(s.push(c)),\n        Str2Int(s.push(c)) == 2 * Str2Int(s) + if c == '1' { 1 } else { 0 },\n    decreases s.len()\n{\n    let s_new = s.push(c);\n    assert(s_new.subrange(0, s_new.len() as int - 1) =~= s);\n}", "{\n    let mut result = Vec::<char>::new();\n    let mut carry: u8 = 0;\n    let mut i: usize = 0;\n    let n1 = s1.len();\n    let n2 = s2.len();\n    let max_len = if n1 > n2 { n1 } else { n2 };\n    \n    while i < max_len || carry > 0\n        invariant\n            i <= max_len,\n            carry <= 1,\n            ValidBitString(result@),\n            Str2Int(result@) == (Str2Int(s1@.subrange(n1 as int - i as int, n1 as int)) + Str2Int(s2@.subrange(n2 as int - i as int, n2 as int)) + carry as nat) % power2(i),\n    {\n        let mut bit_sum = carry;\n        \n        if i < n1 {\n            let idx1 = n1 - 1 - i;\n            if s1[idx1] == '1' {\n                bit_sum = bit_sum + 1;\n            }\n        }\n        \n        if i < n2 {\n            let idx2 = n2 - 1 - i;\n            if s2[idx2] == '1' {\n                bit_sum = bit_sum + 1;\n            }\n        }\n        \n        let res_bit = if bit_sum % 2 == 1 { '1' } else { '0' };\n        carry = bit_sum / 2;\n        \n        proof {\n            let old_result = result@;\n            let new_result = old_result.push(res_bit);\n            lemma_str2int_append(old_result, res_bit);\n            \n            if i < n1 && i < n2 {\n                assert(s1@.subrange(n1 as int - (i + 1) as int, n1 as int).len() == (i + 1) as int);\n                assert(s2@.subrange(n2 as int - (i + 1) as int, n2 as int).len() == (i + 1) as int);\n            }\n        }\n        \n        result.push(res_bit);\n        i = i + 1;\n    }\n    \n    let mut reversed = Vec::<char>::new();\n    let mut j: usize = result.len();\n    \n    while j > 0\n        invariant\n            j <= result.len(),\n            ValidBitString(reversed@),\n            reversed@.len() == result.len() - j,\n            forall |k: int| 0 <= k && k < reversed@.len() as int ==> reversed@[k] == result@[result.len() as int - 1 - k],\n    {\n        j = j - 1;\n        reversed.push(result[j]);\n    }\n    \n    proof {\n        assert(Str2Int(s1@.subrange(0, n1 as int)) == Str2Int(s1@));\n        assert(Str2Int(s2@.subrange(0, n2 as int)) == Str2Int(s2@));\n        assert(carry == 0);\n    }\n    \n    reversed\n}"]
--------------------------------------------------------------------------------
