=== Raw LLM Generate Response ===
Length: 2503 characters
--------------------------------------------------------------------------------
[
"proof fn lemma_exp_properties(x: nat, y: nat, z: nat)\n    requires z > 1\n    ensures\n        y > 0 ==> Exp_int(x, y) == x * Exp_int(x, (y - 1) as nat),\n        Exp_int(x, 0) == 1,\n{\n}\n\nproof fn lemma_mod_properties(a: nat, b: nat, c: nat, m: nat)\n    requires m > 1\n    ensures\n        (a * b) % m == ((a % m) * (b % m)) % m,\n        (a + b) % m == ((a % m) + (b % m)) % m,\n{\n}\n\nexec fn int_to_bit_string(n: nat) -> (res: Vec<char>)\n    ensures\n        ValidBitString(res@),\n        Str2Int(res@) == n,\n    decreases n\n{\n    if n == 0 {\n        vec!['0']\n    } else if n == 1 {\n        vec!['1']\n    } else {\n        let mut res = int_to_bit_string(n / 2);\n        if n % 2 == 0 {\n            res.push('0');\n        } else {\n            res.push('1');\n        }\n        res\n    }\n}\n\nexec fn mod_mul(sx: &[char], sy: &[char], sz: &[char]) -> (res: Vec<char>)\n    requires\n        ValidBitString(sx@),\n        ValidBitString(sy@),\n        ValidBitString(sz@),\n        Str2Int(sz@) > 1,\n    ensures\n        ValidBitString(res@),\n        Str2Int(res@) == (Str2Int(sx@) * Str2Int(sy@)) % Str2Int(sz@),\n{\n    proof {\n        lemma_mod_properties(Str2Int(sx@), Str2Int(sy@), 0, Str2Int(sz@));\n    }\n    let prod = (Str2Int(sx@) * Str2Int(sy@)) % Str2Int(sz@);\n    int_to_bit_string(prod)\n}",
"{\n    if sy@.len() == 1 {\n        if sy@[0] == '0' {\n            proof {\n                lemma_exp_properties(Str2Int(sx@), 0, Str2Int(sz@));\n            }\n            return int_to_bit_string(1);\n        } else {\n            proof {\n                lemma_exp_properties(Str2Int(sx@), 1, Str2Int(sz@));\n            }\n            return int_to_bit_string(Str2Int(sx@) % Str2Int(sz@));\n        }\n    }\n    \n    let sy_prefix = &sy[0..sy.len() - 1];\n    let last_bit = sy[sy.len() - 1];\n    \n    let half_exp = ModExp_Mul_Zeroes(sx, sy_prefix, sz);\n    let squared = mod_mul(&half_exp, &half_exp, sz);\n    \n    if last_bit == '1' {\n        let sx_mod = int_to_bit_string(Str2Int(sx@) % Str2Int(sz@));\n        proof {\n            lemma_exp_properties(Str2Int(sx@), Str2Int(sy@), Str2Int(sz@));\n            lemma_mod_properties(Exp_int(Str2Int(sx@), Str2Int(sy@) / 2) * Exp_int(Str2Int(sx@), Str2Int(sy@) / 2), Str2Int(sx@), 0, Str2Int(sz@));\n        }\n        mod_mul(&squared, &sx_mod, sz)\n    } else {\n        proof {\n            lemma_exp_properties(Str2Int(sx@), Str2Int(sy@), Str2Int(sz@));\n        }\n        squared\n    }\n}"
]
--------------------------------------------------------------------------------
