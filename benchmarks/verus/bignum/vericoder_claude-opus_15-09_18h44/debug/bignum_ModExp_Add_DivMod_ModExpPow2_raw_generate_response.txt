=== Raw LLM Generate Response ===
Length: 1255 characters
--------------------------------------------------------------------------------
["proof fn lemma_exp_split(x: nat, y: nat, z: nat)\n    requires z > 1\n    ensures Exp_int(x, y) % z == (if y == 0 { 1 % z } else if y % 2 == 0 { (Exp_int(x, y/2) * Exp_int(x, y/2)) % z } else { (x * Exp_int(x, y-1)) % z })\n    decreases y\n{\n    if y == 0 {\n    } else if y % 2 == 0 {\n        lemma_exp_split(x, y/2, z);\n        assert(Exp_int(x, y) == Exp_int(x, y/2) * Exp_int(x, y/2));\n    } else {\n        lemma_exp_split(x, y-1, z);\n    }\n}", "{\n    if sy@.len() == 1 && sy@[0] == '0' {\n        let mut result = Vec::<char>::new();\n        result.push('1');\n        return result;\n    }\n    \n    let n = (sy@.len() - 1) as int;\n    let mut sy_pow2 = Vec::<char>::new();\n    for i in 0..n {\n        sy_pow2.push('0');\n    }\n    sy_pow2.push('1');\n    \n    let (sy_div, sy_mod) = DivMod(sy, &sy_pow2);\n    \n    if sy_mod@.len() == 1 && sy_mod@[0] == '0' {\n        let half_res = ModExpPow2(sx, &sy_div, n - 1, sz);\n        let squared = DivMod(&Add(&half_res, &half_res), sz).1;\n        return squared;\n    } else {\n        let pow_res = ModExpPow2(sx, &sy_pow2, n, sz);\n        let rec_res = ModExp(sx, &sy_div, sz);\n        let combined = DivMod(&Add(&pow_res, &rec_res), sz).1;\n        return combined;\n    }\n}"]
--------------------------------------------------------------------------------
