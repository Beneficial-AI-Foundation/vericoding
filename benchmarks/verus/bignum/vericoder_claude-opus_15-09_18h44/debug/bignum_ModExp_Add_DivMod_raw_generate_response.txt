=== Raw LLM Generate Response ===
Length: 6793 characters
--------------------------------------------------------------------------------
["{
    let mut carry = 0u8;
    let mut result = Vec::new();
    let max_len = if s1.len() > s2.len() { s1.len() } else { s2.len() };
    
    let mut i = 0;
    while i < max_len || carry > 0
        invariant
            i <= max_len,
            carry <= 1,
            ValidBitString(result@),
            result.len() == i,
    {
        let bit1 = if i < s1.len() { 
            if s1[i] == '1' { 1u8 } else { 0u8 }
        } else { 
            0u8 
        };
        
        let bit2 = if i < s2.len() {
            if s2[i] == '1' { 1u8 } else { 0u8 }
        } else {
            0u8
        };
        
        let sum = bit1 + bit2 + carry;
        carry = sum / 2;
        let bit_result = sum % 2;
        
        result.push(if bit_result == 1 { '1' } else { '0' });
        i += 1;
    }
    
    // Reverse to get proper bit order
    let mut j = 0;
    let mut reversed = Vec::new();
    while j < result.len()
        invariant
            j <= result.len(),
            ValidBitString(reversed@),
            reversed.len() == j,
    {
        reversed.push(result[result.len() - 1 - j]);
        j += 1;
    }
    
    reversed
}", "{
    let mut quotient = Vec::new();
    let mut remainder = Vec::new();
    
    // Convert divisor to number for comparison
    let mut div_val = 0;
    let mut i = 0;
    while i < divisor.len()
        invariant
            i <= divisor.len(),
            div_val >= 0,
    {
        div_val = div_val * 2;
        if divisor[i] == '1' {
            div_val += 1;
        }
        i += 1;
    }
    
    // Convert dividend to number
    let mut current = 0;
    let mut j = 0;
    while j < dividend.len()
        invariant
            j <= dividend.len(),
            current >= 0,
    {
        current = current * 2;
        if dividend[j] == '1' {
            current += 1;
        }
        j += 1;
    }
    
    // Perform division
    let q = current / div_val;
    let r = current % div_val;
    
    // Convert quotient to bit string
    if q == 0 {
        quotient.push('0');
    } else {
        let mut temp_q = q;
        let mut temp_vec = Vec::new();
        while temp_q > 0
            invariant
                temp_q >= 0,
                ValidBitString(temp_vec@),
        {
            if temp_q % 2 == 1 {
                temp_vec.push('1');
            } else {
                temp_vec.push('0');
            }
            temp_q = temp_q / 2;
        }
        
        // Reverse for proper order
        let mut k = 0;
        while k < temp_vec.len()
            invariant
                k <= temp_vec.len(),
                ValidBitString(quotient@),
        {
            quotient.push(temp_vec[temp_vec.len() - 1 - k]);
            k += 1;
        }
    }
    
    // Convert remainder to bit string
    if r == 0 {
        remainder.push('0');
    } else {
        let mut temp_r = r;
        let mut temp_vec = Vec::new();
        while temp_r > 0
            invariant
                temp_r >= 0,
                ValidBitString(temp_vec@),
        {
            if temp_r % 2 == 1 {
                temp_vec.push('1');
            } else {
                temp_vec.push('0');
            }
            temp_r = temp_r / 2;
        }
        
        // Reverse for proper order
        let mut m = 0;
        while m < temp_vec.len()
            invariant
                m <= temp_vec.len(),
                ValidBitString(remainder@),
        {
            remainder.push(temp_vec[temp_vec.len() - 1 - m]);
            m += 1;
        }
    }
    
    (quotient, remainder)
}", "{
    if sy.len() == 0 || (sy.len() == 1 && sy[0] == '0') {
        // x^0 = 1
        let mut result = Vec::new();
        result.push('1');
        let (_, rem) = DivMod(&result, sz);
        return rem;
    }
    
    // Check if y is odd (last bit is 1)
    let last_bit = sy[sy.len() - 1];
    
    if last_bit == '1' {
        // y is odd: x^y mod z = (x * x^(y-1)) mod z
        let mut sy_minus_1 = Vec::new();
        let mut i = 0;
        let mut borrow = 1;
        while i < sy.len()
            invariant
                i <= sy.len(),
                ValidBitString(sy_minus_1@),
                borrow <= 1,
        {
            let bit = if sy[sy.len() - 1 - i] == '1' { 1 } else { 0 };
            let result_bit = if bit >= borrow { bit - borrow } else { bit + 2 - borrow };
            sy_minus_1.push(if result_bit == 1 { '1' } else { '0' });
            borrow = if bit >= borrow { 0 } else { 1 };
            i += 1;
        }
        
        // Reverse sy_minus_1
        let mut sy_dec = Vec::new();
        let mut j = 0;
        while j < sy_minus_1.len()
            invariant
                j <= sy_minus_1.len(),
                ValidBitString(sy_dec@),
        {
            if !(j == sy_minus_1.len() - 1 && sy_minus_1[sy_minus_1.len() - 1 - j] == '0') {
                sy_dec.push(sy_minus_1[sy_minus_1.len() - 1 - j]);
            }
            j += 1;
        }
        
        if sy_dec.len() == 0 {
            sy_dec.push('0');
        }
        
        let rec_result = ModExp(sx, &sy_dec, sz);
        
        // Multiply sx * rec_result
        let mut product = Vec::new();
        product.push('0');
        
        let mut k = 0;
        while k < sx.len()
            invariant
                k <= sx.len(),
                ValidBitString(product@),
        {
            let shifted = Add(&product, &product);
            if sx[k] == '1' {
                product = Add(&shifted, &rec_result);
            } else {
                product = shifted;
            }
            k += 1;
        }
        
        let (_, result) = DivMod(&product, sz);
        result
    } else {
        // y is even: x^y mod z = (x^(y/2))^2 mod z
        let mut sy_div_2 = Vec::new();
        let mut i = 0;
        while i < sy.len() - 1
            invariant
                i <= sy.len() - 1,
                ValidBitString(sy_div_2@),
        {
            sy_div_2.push(sy[i]);
            i += 1;
        }
        
        if sy_div_2.len() == 0 {
            sy_div_2.push('0');
        }
        
        let half_result = ModExp(sx, &sy_div_2, sz);
        
        // Square the result
        let mut product = Vec::new();
        product.push('0');
        
        let mut j = 0;
        while j < half_result.len()
            invariant
                j <= half_result.len(),
                ValidBitString(product@),
        {
            let shifted = Add(&product, &product);
            if half_result[j] == '1' {
                product = Add(&shifted, &half_result);
            } else {
                product = shifted;
            }
            j += 1;
        }
        
        let (_, result) = DivMod(&product, sz);
        result
    }
}"]
--------------------------------------------------------------------------------
