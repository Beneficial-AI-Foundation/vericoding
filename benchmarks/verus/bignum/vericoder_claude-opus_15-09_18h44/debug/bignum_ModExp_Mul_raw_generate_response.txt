=== Raw LLM Generate Response ===
Length: 5431 characters
--------------------------------------------------------------------------------
["{
    let mut result = Vec::<char>::new();
    let n1 = s1.len();
    let n2 = s2.len();
    
    if n1 == 0 || n2 == 0 {
        result.push('0');
        return result;
    }
    
    // Check for zero operands
    let mut is_zero1 = true;
    let mut is_zero2 = true;
    for i in 0..n1 {
        if s1[i] == '1' {
            is_zero1 = false;
            break;
        }
    }
    for i in 0..n2 {
        if s2[i] == '1' {
            is_zero2 = false;
            break;
        }
    }
    
    if is_zero1 || is_zero2 {
        result.push('0');
        return result;
    }
    
    // Initialize result with zeros
    let result_len = n1 + n2;
    for _ in 0..result_len {
        result.push('0');
    }
    
    // Perform binary multiplication
    for i in (0..n2).rev() {
        if s2[i] == '1' {
            let mut carry = 0u8;
            for j in (0..n1).rev() {
                let pos = i + j + 1;
                let mut sum = carry;
                if s1[j] == '1' {
                    sum += 1;
                }
                if result[pos] == '1' {
                    sum += 1;
                }
                
                result.set(pos, if sum % 2 == 1 { '1' } else { '0' });
                carry = sum / 2;
            }
            
            if carry > 0 {
                let pos = i;
                if result[pos] == '0' {
                    result.set(pos, '1');
                } else {
                    // Handle carry propagation
                    let mut k = pos;
                    while k > 0 && result[k] == '1' {
                        result.set(k, '0');
                        k -= 1;
                    }
                    if k == 0 && result[0] == '1' {
                        result.set(0, '0');
                    } else {
                        result.set(k, '1');
                    }
                }
            }
        }
    }
    
    // Remove leading zeros
    while result.len() > 1 && result[0] == '0' {
        result.remove(0);
    }
    
    result
}", "{
    let y_len = sy.len();
    
    // Base case: y == 0
    if y_len == 1 && sy[0] == '0' {
        let mut res = Vec::<char>::new();
        res.push('1');
        return res;
    }
    
    // Check if y is odd (last bit is 1)
    let y_is_odd = sy[y_len - 1] == '1';
    
    // Compute y' = y / 2 (right shift)
    let mut sy_half = Vec::<char>::new();
    for i in 0..(y_len - 1) {
        sy_half.push(sy[i]);
    }
    
    if sy_half.len() == 0 || (sy_half.len() == 1 && sy_half[0] == '0') {
        // y' == 0, so result is x^1 % z = x % z
        if y_is_odd {
            // Need to compute x % z
            let mut result = Vec::<char>::new();
            let x_val = Str2Int(sx@);
            let z_val = Str2Int(sz@);
            let res_val = x_val % z_val;
            
            // Convert res_val back to binary string
            if res_val == 0 {
                result.push('0');
            } else {
                let mut temp = res_val;
                let mut digits = Vec::<char>::new();
                while temp > 0 {
                    if temp % 2 == 1 {
                        digits.push('1');
                    } else {
                        digits.push('0');
                    }
                    temp = temp / 2;
                }
                // Reverse to get correct order
                for i in (0..digits.len()).rev() {
                    result.push(digits[i]);
                }
            }
            return result;
        } else {
            // y == 0 case already handled above
            let mut res = Vec::<char>::new();
            res.push('1');
            return res;
        }
    }
    
    // Recursive call: compute (x^(y/2)) % z
    let half_result = ModExp(sx, &sy_half, sz);
    
    // Square the half result: (half_result * half_result) % z
    let squared = Mul(&half_result, &half_result);
    
    // Compute squared % z
    let mut squared_mod = Vec::<char>::new();
    let sq_val = Str2Int(squared@);
    let z_val = Str2Int(sz@);
    let sq_mod_val = sq_val % z_val;
    
    if sq_mod_val == 0 {
        squared_mod.push('0');
    } else {
        let mut temp = sq_mod_val;
        let mut digits = Vec::<char>::new();
        while temp > 0 {
            if temp % 2 == 1 {
                digits.push('1');
            } else {
                digits.push('0');
            }
            temp = temp / 2;
        }
        for i in (0..digits.len()).rev() {
            squared_mod.push(digits[i]);
        }
    }
    
    if y_is_odd {
        // Multiply by x once more: (squared_mod * x) % z
        let temp_mul = Mul(&squared_mod, sx);
        let mut final_result = Vec::<char>::new();
        let temp_val = Str2Int(temp_mul@);
        let final_val = temp_val % z_val;
        
        if final_val == 0 {
            final_result.push('0');
        } else {
            let mut temp = final_val;
            let mut digits = Vec::<char>::new();
            while temp > 0 {
                if temp % 2 == 1 {
                    digits.push('1');
                } else {
                    digits.push('0');
                }
                temp = temp / 2;
            }
            for i in (0..digits.len()).rev() {
                final_result.push(digits[i]);
            }
        }
        return final_result;
    } else {
        return squared_mod;
    }
}"]
--------------------------------------------------------------------------------
