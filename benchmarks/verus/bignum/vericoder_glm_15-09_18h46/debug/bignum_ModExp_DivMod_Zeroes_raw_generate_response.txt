=== Raw LLM Generate Response ===
Length: 1622 characters
--------------------------------------------------------------------------------
["exec fn str_to_int_exec(s: Seq<char>) -> (result: nat)\n    requires ValidBitString(s)\n    ensures result == Str2Int(s)\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        let last_char = s.index(s.len() - 1);\n        let last_bit = if last_char == '1' { 1 } else { 0 };\n        let rest = s.subrange(0, s.len() - 1);\n        2 * str_to_int_exec(rest) + last_bit\n    }\n}\n\nexec fn int_to_str_exec(n: nat) -> (result: Vec<char>)\n    ensures ValidBitString(result@) && Str2Int(result@) == n\n    decreases n\n{\n    if n == 0 {\n        vec!['0']\n    } else if n == 1 {\n        vec!['1']\n    } else {\n        let mut res = int_to_str_exec(n / 2);\n        let last_digit = if n % 2 == 0 { '0' } else { '1' };\n        res.push(last_digit);\n        res\n    }\n}\n\nexec fn mod_exp_recursive(exponent: Seq<char>, base: nat, modulus: nat) -> (result: nat)\n    requires ValidBitString(exponent), modulus > 1\n    ensures result == Exp_int(base, Str2Int(exponent)) % modulus\n    decreases exponent.len()\n{\n    if exponent.len() == 0 {\n        1\n    } else {\n        let rest = exponent.subrange(0, exponent.len() - 1);\n        let last_char = exponent.index(exponent.len() - 1);\n        let t = mod_exp_recursive(rest, base, modulus);\n        let t2 = (t * t) % modulus;\n        if last_char == '1' {\n            (t2 * base) % modulus\n        } else {\n            t2\n        }\n    }\n}", "{\n    let x_int = str_to_int_exec(sx@);\n    let z_int = str_to_int_exec(sz@);\n    let result_int = mod_exp_recursive(sy@, x_int, z_int);\n    int_to_str_exec(result_int)\n}"]
--------------------------------------------------------------------------------
