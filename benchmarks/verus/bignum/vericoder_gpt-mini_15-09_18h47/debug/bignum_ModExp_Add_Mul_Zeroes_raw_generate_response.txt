=== Raw LLM Generate Response ===
Length: 2621 characters
--------------------------------------------------------------------------------
[
"fn char_to_nat(c: char) -> nat { if c == '1' { 1 } else { 0 } }\nfn nat_to_char(b: nat) -> char { if b == 1 { '1' } else { '0' } }",
"{\n    // compute x_nat\n    let mut x_nat: nat = 0;\n    let mut i: int = 0;\n    while i < sx.len() as int\n        invariant\n            0 <= i,\n            i <= sx.len() as int,\n            x_nat == Str2Int(sx@.subrange(0, i)),\n        decreases sx.len() as int - i\n    {\n        let b = if sx[i as usize] == '1' { 1 } else { 0 };\n        x_nat = 2 * x_nat + b;\n        i += 1;\n    }\n\n    // compute y_nat\n    let mut y_nat: nat = 0;\n    let mut j: int = 0;\n    while j < sy.len() as int\n        invariant\n            0 <= j,\n            j <= sy.len() as int,\n            y_nat == Str2Int(sy@.subrange(0, j)),\n        decreases sy.len() as int - j\n    {\n        let b = if sy[j as usize] == '1' { 1 } else { 0 };\n        y_nat = 2 * y_nat + b;\n        j += 1;\n    }\n\n    // compute m_nat\n    let mut m_nat: nat = 0;\n    let mut k: int = 0;\n    while k < sz.len() as int\n        invariant\n            0 <= k,\n            k <= sz.len() as int,\n            m_nat == Str2Int(sz@.subrange(0, k)),\n        decreases sz.len() as int - k\n    {\n        let b = if sz[k as usize] == '1' { 1 } else { 0 };\n        m_nat = 2 * m_nat + b;\n        k += 1;\n    }\n\n    let orig_x = x_nat;\n    let orig_y = y_nat;\n\n    // modular exponentiation (square-and-multiply)\n    let mut base: nat = orig_x % m_nat;\n    let mut exp: int = orig_y as int;\n    let mut result: nat = 1;\n    while exp > 0\n        invariant\n            exp >= 0,\n            result < m_nat,\n            base < m_nat,\n            (result * Exp_int(base, exp as nat)) % m_nat == Exp_int(orig_x, orig_y) % m_nat,\n        decreases exp\n    {\n        if exp % 2 == 1 {\n            result = (result * base) % m_nat;\n        }\n        base = (base * base) % m_nat;\n        exp = exp / 2;\n    }\n\n    // construct result bitstring (MSB...LSB where last char is LSB)\n    let mut resv = Vec::<char>::new();\n    if result == 0 {\n        return resv;\n    }\n\n    let mut rev = Vec::<char>::new();\n    let mut r = result;\n    while r > 0\n        invariant\n            r >= 0,\n        decreases r\n    {\n        let c = if r % 2 == 1 { '1' } else { '0' };\n        rev.push(c);\n        r = r / 2;\n    }\n\n    let mut idx: int = rev.len() as int - 1;\n    while idx >= 0\n        invariant\n            idx >= -1,\n            idx < rev.len() as int,\n        decreases idx + 1\n    {\n        resv.push(rev[idx as usize]);\n        idx -= 1;\n    }\n\n    resv\n}"
]
--------------------------------------------------------------------------------
