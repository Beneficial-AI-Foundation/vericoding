=== LLM Response - generate_code - Iteration 0 ===
File: /Users/sergiu.bursuc/baif/vericoding/benchmarks/verus/bignum/files/bignum_ModExp_int_ModExpPow2_int.rs
Prompt Hash: beaefb67
JSON Parsed Successfully: True
Timestamp: 1757962087.386038
Content Length: 2558 chars
--------------------------------------------------------------------------------
[
  "spec fn CharBit(c: char) -> nat { if c == '1' { 1 } else { 0 } }",
  "{\n    // compute modulus m = Str2Int(sz@)\n    let mut m: nat = 0;\n    let mut i: int = 0;\n    while i < sz.len() as int\n        invariant\n            m == Str2Int(sz@.subrange(0, i)),\n        decreases (sz.len() as int - i)\n    {\n        let b = if sz[i as usize] == '1' { 1 } else { 0 };\n        m = m * 2 + b;\n        i += 1;\n    }\n\n    // compute base = Str2Int(sx@)\n    let mut base: nat = 0;\n    i = 0;\n    while i < sx.len() as int\n        invariant\n            base == Str2Int(sx@.subrange(0, i)),\n        decreases (sx.len() as int - i)\n    {\n        let b = if sx[i as usize] == '1' { 1 } else { 0 };\n        base = base * 2 + b;\n        i += 1;\n    }\n\n    // compute exponent value = Str2Int(sy@)\n    let mut _exp_val: nat = 0;\n    i = 0;\n    while i < sy.len() as int\n        invariant\n            _exp_val == Str2Int(sy@.subrange(0, i)),\n        decreases (sy.len() as int - i)\n    {\n        let b = if sy[i as usize] == '1' { 1 } else { 0 };\n        _exp_val = _exp_val * 2 + b;\n        i += 1;\n    }\n\n    // modular exponentiation using left-to-right binary method\n    let mut res_val: nat = 1;\n    let base_mod: nat = base % m;\n    i = 0;\n    while i < sy.len() as int\n        invariant\n            res_val == Exp_int(Str2Int(sx@), Str2Int(sy@.subrange(0, i))) % Str2Int(sz@),\n        decreases (sy.len() as int - i)\n    {\n        // square\n        res_val = (res_val * res_val) % m;\n        if sy[i as usize] == '1' {\n            res_val = (res_val * base_mod) % m;\n        }\n        i += 1;\n    }\n\n    // convert numeric result to bit vector (MSB-first)\n    if res_val == 0 {\n        return Vec::<char>::new();\n    }\n\n    let orig: nat = res_val;\n    // find highest power of two <= res_val\n    let mut pow: nat = 1;\n    while pow <= res_val\n        invariant\n            pow >= 1,\n        decreases (res_val + 1 - pow)\n    {\n        pow = pow * 2;\n    }\n    pow = pow / 2;\n\n    let mut acc: nat = 0;\n    let mut value: nat = res_val;\n    let mut out: Vec<char> = Vec::new();\n    while pow > 0\n        invariant\n            acc == Str2Int(out@),\n            orig == acc * (pow * 2) + value,\n        decreases pow\n    {\n        if value >= pow {\n            acc = acc * 2 + 1;\n            value = value - pow;\n            out.push('1');\n        } else {\n            acc = acc * 2 + 0;\n            out.push('0');\n        }\n        pow = pow / 2;\n    }\n\n    return out;\n}"
]
--------------------------------------------------------------------------------
