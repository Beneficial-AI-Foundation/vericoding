=== Raw LLM Generate Response ===
Length: 2504 characters
--------------------------------------------------------------------------------
[
"spec fn BitVal(c: char) -> nat { if c == '1' { 1 } else { 0 } }\nspec fn SeqToNat(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    Str2Int(s)\n}\nproof fn MulMod_Compat(a: nat, b: nat, m: nat)\n    requires\n        m > 0,\n    ensures\n        (a * b) % m == ((a % m) * (b % m)) % m,\n{\n    // Standard modular arithmetic lemma; proof by properties of division\n}\n",
"{\n    // parse modulus sz -> m\n    let mut m: nat = 0;\n    let mut i: usize = 0;\n    let slen = sz.len();\n    while i < slen\n        invariant\n            i <= slen,\n        decreases\n            slen - i\n    {\n        let bit = if sz[i] == '1' { 1 } else { 0 };\n        m = 2 * m + bit;\n        i += 1;\n    }\n\n    // parse base sx -> base and reduce modulo m\n    let mut base: nat = 0;\n    let mut j: usize = 0;\n    let bxlen = sx.len();\n    while j < bxlen\n        invariant\n            j <= bxlen,\n        decreases\n            bxlen - j\n    {\n        let bit = if sx[j] == '1' { 1 } else { 0 };\n        base = 2 * base + bit;\n        j += 1;\n    }\n    base = base % m;\n\n    // modular exponentiation: process bits of sy from LSB to MSB\n    let mut res: nat = 1 % m;\n    let mut k: usize = 0;\n    let ylen = sy.len();\n    while k < ylen\n        invariant\n            k <= ylen,\n        decreases\n            ylen - k\n    {\n        // bit from LSB: sy[ylen-1-k]\n        let bch = sy[ylen - 1 - k];\n        if bch == '1' {\n            res = (res * base) % m;\n        }\n        base = (base * base) % m;\n        k += 1;\n    }\n\n    // convert result res to bit vector (MSB .. LSB, so last char is LSB)\n    let mut bits = Vec::<char>::new();\n    if res == 0 {\n        bits.push('0');\n    } else {\n        let mut r: nat = res;\n        while r > 0\n            invariant\n                r >= 0,\n            decreases\n                r\n        {\n            if r % 2 == 1 {\n                bits.push('1');\n            } else {\n                bits.push('0');\n            }\n            r = r / 2;\n        }\n        // bits currently LSB-first, reverse to make MSB-first (last = LSB)\n        let mut p: usize = 0;\n        let n = bits.len();\n        while p < n / 2\n            invariant\n                p <= n,\n            decreases\n                n - p\n        {\n            let q = n - 1 - p;\n            let tmp = bits[p];\n            bits[p] = bits[q];\n            bits[q] = tmp;\n            p += 1;\n        }\n    }\n\n    return bits;\n}\n"
]
--------------------------------------------------------------------------------
