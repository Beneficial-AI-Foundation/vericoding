=== Raw LLM Generate Response ===
Length: 1813 characters
--------------------------------------------------------------------------------
["{\n    let len1 = s1.len();\n    let len2 = s2.len();\n    let max_len = if len1 > len2 { len1 } else { len2 };\n    let mut result_vec: Vec<char> = Vec::new();\n    let mut carry = 0_i128;\n\n    let mut i = 0;\n    while i < max_len || carry > 0\n        invariant\n            0 <= i,\n            result_vec.len() == i,\n            carry == 0 || carry == 1,\n            (forall |j: int| 0 <= j && j < i ==> (result_vec.index(j) == '0' || result_vec.index(j) == '1')),\n        decreases max_len - i\n    {\n        let digit1 = if i < len1 && (s1[len1 - 1 - i] == '1') { 1 } else { 0 };\n        let digit2 = if i < len2 && (s2[len2 - 1 - i] == '1') { 1 } else { 0 };\n\n        let sum = digit1 + digit2 + carry;\n        carry = if sum >= 2 { 1 } else { 0 };\n        let current_digit = if sum % 2 == 1 { '1' } else { '0' };\n        result_vec.insert(0, current_digit);\n        i = i + 1;\n    }\n\n    if result_vec.is_empty() {\n        result_vec.push('0');\n    }\n    result_vec\n}", "{\n    let x = Str2Int(sx@);\n    let y = Str2Int(sy@);\n    let z = Str2Int(sz@);\n\n    let mut res: nat = 1;\n    let mut base: nat = x;\n    let mut exponent: nat = y;\n\n    proof {\n        if z > 1 {\n            assert((x as int % z as int) >= 0) by(nonlinear_arith);\n        }\n    }\n\n    while exponent > 0\n        invariant\n            z > 1,\n            res > 0,\n            base > 0,\n            exponent >= 0,\n            // loop invariant for modular exponentiation\n            Exp_int(x, y) % z == (res * Exp_int(base, exponent)) % z,\n        decreases exponent\n    {\n        if exponent % 2 == 1 {\n            res = (res * base) % z;\n        }\n        base = (base * base) % z;\n        exponent = exponent / 2;\n    }\n\n    crate::bit_helper::int_to_vec_char(res as int)\n}"]
--------------------------------------------------------------------------------
