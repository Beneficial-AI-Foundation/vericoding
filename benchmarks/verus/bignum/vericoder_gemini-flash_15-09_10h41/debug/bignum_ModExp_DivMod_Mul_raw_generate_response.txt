=== Raw LLM Generate Response ===
Length: 5129 characters
--------------------------------------------------------------------------------
["spec fn ModExp_Lemma(x: nat, y: nat, z: nat) -> nat
    requires z > 1
    decreases y
{
    if y == 0 {
        1 % z
    } else {
        (x * ModExp_Lemma(x, (y - 1) as nat, z)) % z
    }
}", "{\n    let x_val = Str2Int(sx@);\n    let y_val = Str2Int(sy@);\n    let z_val = Str2Int(sz@);\n\n    if sy@.len() == 1 && sy@[0] == '0' {\n        // y == 0\n        let result: nat = 1 % z_val;\n        let mut encoded_result = Vec::<char>::new();\n        if result == 0 {\n            encoded_result.push('0');\n        } else {\n            let mut temp_result = result;\n            while temp_result > 0\n                invariant\n                    temp_result >= 0,\n                    ValidBitString(encoded_result@),\n                decreases temp_result\n            {\n                if temp_result % 2 == 1 {\n                    encoded_result.insert(0, '1');\n                } else {\n                    encoded_result.insert(0, '0');\n                }\n                temp_result = temp_result / 2;\n            }\n        }\n        return encoded_result;\n    } else if sy@.len() == 1 && sy@[0] == '1' {\n        // y == 1\n        let result: nat = x_val % z_val;\n        let mut encoded_result = Vec::<char>::new();\n        if result == 0 {\n            encoded_result.push('0');\n        } else {\n            let mut temp_result = result;\n            while temp_result > 0\n                invariant\n                    temp_result >= 0,\n                    ValidBitString(encoded_result@),\n                decreases temp_result\n            {\n                if temp_result % 2 == 1 {\n                    encoded_result.insert(0, '1');\n                } else {\n                    encoded_result.insert(0, '0');\n                }\n                temp_result = temp_result / 2;\n            }\n        }\n        return encoded_result;\n    } else {\n        let (sx_vec, sy_minus_1_vec, sz_vec) = (sx.to_vec(), sy.to_vec(), sz.to_vec());\n        let mut sy_char_seq = sy@;\n        let last_char = sy_char_seq.last().unwrap();\n\n        let sy_minus_1_seq = if sy_char_seq.len() > 0 {\n            let mut new_seq = sy_char_seq.subrange(0, sy_char_seq.len() - 1);\n            if last_char == '1' {\n                // Sy_minus_1 is straight forward if last_char is '1'\n                new_seq\n            } else {\n                // Need to find the first '1' from the right to propagate borrow for '0'\n                let mut found_one = false;\n                let mut i = new_seq.len() - 1;\n                while i >= 0 && !found_one\n                    invariant\n                        i >= -1,\n                        ValidBitString(new_seq) // Invariant for new_seq in this while loop\n                    decreases i\n                {\n                    if new_seq.index(i) == '1' {\n                        new_seq = new_seq.update(i, '0');\n                        found_one = true;\n                    } else {\n                        new_seq = new_seq.update(i, '1');\n                    }\n                    i = i - 1;\n                }\n                if i < 0 && !found_one {\n                    // This case means original sy was of form '100...0' and sy-1 would be '11...1'\n                    // and we essentially have all '0's after the borrow\n                    Seq::<char>::empty()\n                } else {\n                    // Remove leading zeros created by borrow\n                    let mut first_one_idx: int = -1;\n                    for k in 0..new_seq.len() {\n                        if new_seq.index(k) == '1' {\n                            first_one_idx = k;\n                            break;\n                        }\n                    }\n                    if first_one_idx == -1 { Seq::<char>::empty() } else { new_seq.subrange(first_one_idx, new_seq.len() as int) }\n                }\n            }\n        } else {\n            // Should not happen given sy@.len() > 0\n            Seq::<char>::empty()\n        };\n        \n        let mut sy_minus_1_vec_new = Vec::<char>::new();\n        for i in 0..sy_minus_1_seq.len() {\n            sy_minus_1_vec_new.push(sy_minus_1_seq.index(i));\n        }\n\n        let recursive_result_vec = ModExp_DivMod_Mul(&sx_vec, &sy_minus_1_vec_new, &sz_vec);\n        let recursive_result_nat = Str2Int(recursive_result_vec@);\n\n        let final_result_nat = (x_val * recursive_result_nat) % z_val;\n\n        let mut res = Vec::<char>::new();\n        if final_result_nat == 0 {\n            res.push('0');\n        } else {\n            let mut temp_val = final_result_nat;\n            while temp_val > 0\n                invariant\n                    temp_val >= 0,\n                    ValidBitString(res@),\n                decreases temp_val\n            {\n                let remainder = temp_val % 2;\n                if remainder == 1 {\n                    res.insert(0, '1');\n                } else {\n                    res.insert(0, '0');\n                }\n                temp_val = temp_val / 2;\n            }\n        }\n        res\n    }\n}"]
--------------------------------------------------------------------------------
