=== Raw LLM Generate Response ===
Length: 5695 characters
--------------------------------------------------------------------------------
["spec fn subrange_to_seq(s: &[char], start: int, end: int) -> Seq<char>\n  requires 0 <= start <= end <= s.len()\n{\n  s@.subrange(start, end)\n}\n\nproof fn bit_string_preserves_validity(s: Seq<char>, start: int, end: int)\n  requires ValidBitString(s),\n    0 <= start <= end <= s.len()\n  ensures ValidBitString(s.subrange(start, end))\n{\n  // The validity of a subrange relies on the validity of the original sequence,\n  // which is directly implied by the definition of ValidBitString.\n  // No explicit proof steps are needed beyond what's handled by Verus's SMT solver.\n}\n\nproof fn prefix_mod_exp_lemma(\n  sx_seq: Seq<char>,\n  sy_seq: Seq<char>,\n  sz_seq: Seq<char>,\n  first_bit: char,\n  rem_sy_seq: Seq<char>,\n  res_rem: Seq<char>,\n  res_final: Seq<char>,\n  k: nat\n)\n  requires\n    ValidBitString(sx_seq),\n    ValidBitString(sy_seq),\n    ValidBitString(sz_seq),\n    sy_seq == rem_sy_seq.push(first_bit),\n    Str2Int(sz_seq) > 1,\n    res_rem == ModExp(sx_seq.view(), rem_sy_seq.view(), sz_seq.view())@,\n    (first_bit == '0' || first_bit == '1'),\n    res_final == if (first_bit == '0') then\n      MulMod(res_rem.view(), res_rem.view(), sz_seq.view())@\n    else\n      MulMod(sx_seq.view(), MulMod(res_rem.view(), res_rem.view(), sz_seq.view()).view(), sz_seq.view())@,\n    Str2Int(rem_sy_seq) == k\n  ensures\n    Str2Int(res_final) == Exp_int(Str2Int(sx_seq), Str2Int(sy_seq)) % Str2Int(sz_seq)\n{\n  let base = Str2Int(sx_seq);\n  let modulus = Str2Int(sz_seq);\n  let rem_exp = Str2Int(res_rem);\n  let current_exp = Str2Int(sy_seq);\n\n  let rem_sy_val = Str2Int(rem_sy_seq);\n  assert(rem_sy_val == k);\n  assert(Str2Int(sy_seq) == 2 * rem_sy_val + (if first_bit == '1' { 1nat } else { 0nat }));\n\n  // Need to prove this from the recursive call's ensures clause\n  assert(rem_exp == Exp_int(base, rem_sy_val) % modulus);\n\n  let term1 = (rem_exp * rem_exp) % modulus;\n  let term2 = if first_bit == '0' {\n    term1\n  } else {\n    (base * term1) % modulus\n  };\n\n  // proof for Exp_int(base, 2 * k)\n  let exp_2k = Exp_int(base, 2 * k);\n  assert(exp_2k == Exp_int(base, k) * Exp_int(base, k));\n\n  // proof for Exp_int(base, 2 * k + 1)\n  let exp_2k_plus_1 = Exp_int(base, 2 * k + 1);\n  assert(exp_2k_plus_1 == base * Exp_int(base, 2*k));\n\n  if first_bit == '0' {\n    assert(current_exp == 2 * k);\n    assert(Exp_int(base, current_exp) % modulus == (Exp_int(base, k) * Exp_int(base, k)) % modulus);\n    assert(rem_exp == Exp_int(base, k) % modulus);\n    assert((rem_exp * rem_exp) % modulus == (Exp_int(base, k) % modulus * Exp_int(base, k) % modulus) % modulus);\n    assert((Exp_int(base, k) % modulus * Exp_int(base, k) % modulus) % modulus == (Exp_int(base, k) * Exp_int(base, k)) % modulus) by (nonlinear_arith);\n    assert(term1 == Exp_int(base, current_exp) % modulus);\n    assert(term2 == Exp_int(base, current_exp) % modulus);\n  } else {\n    assert(current_exp == 2 * k + 1);\n    assert(Exp_int(base, current_exp) % modulus == (base * Exp_int(base, 2*k)) % modulus);\n    assert(Exp_int(base, 2 * k) % modulus == (Exp_int(base, k) % modulus * Exp_int(base, k) % modulus) % modulus);\n    assert(term1 == Exp_int(base, 2 * k) % modulus);\n    assert((base * term1) % modulus == (base * Exp_int(base, 2 * k) % modulus) % modulus);\n    assert(( base * Exp_int(base, 2 * k) % modulus) % modulus == (base * Exp_int(base, 2 * k)) % modulus) by (nonlinear_arith);\n    assert(term2 == Exp_int(base, current_exp) % modulus);\n  }\n\n  assert(Str2Int(res_final) == Exp_int(base, current_exp) % modulus);\n}\n\nexec fn MulMod(s1: &[char], s2: &[char], sm: &[char]) -> (res: Vec<char>)\n  requires ValidBitString(s1@), ValidBitString(s2@), ValidBitString(sm@), Str2Int(sm@) > 0\n  ensures ValidBitString(res@), Str2Int(res@) == (Str2Int(s1@) * Str2Int(s2@)) % Str2Int(sm@)\n{\n  let n1 = Str2Int(s1@);\n  let n2 = Str2Int(s2@);\n  let m = Str2Int(sm@);\n  let product = n1 * n2;\n  let remainder = product % m;\n  let mut res_vec: Vec<char> = Vec::new();\n  if remainder == 0 {\n    res_vec.push('0');\n  } else {\n    let mut temp = remainder;\n    while temp > 0\n      invariant\n        temp >= 0,\n        ValidBitString(res_vec@)\n      decreases temp\n    {\n      let bit = temp % 2;\n      if bit == 0 {\n        res_vec.insert(0, '0');\n      } else {\n        res_vec.insert(0, '1');\n      }\n      temp = temp / 2;\n    }\n  }\n  res_vec\n}", "{\n  let base_val = Str2Int(sx@);\n  let exp_val = Str2Int(sy@);\n  let mod_val = Str2Int(sz@);\n\n  if exp_val == 0 {\n    let mut res_vec = Vec::new();\n    res_vec.push('1');\n    return res_vec;\n  }\n\n  let last_bit = sy@[sy@.len() as int - 1];\n  let rem_sy_seq = sy@.subrange(0, sy@.len() as int - 1);\n\n  let rem_sy_vec: Vec<char> = rem_sy_seq.to_vec();\n  let rem_sy_slice = rem_sy_vec.as_slice();\n\n  let res_rem_call = ModExp(sx, rem_sy_slice, sz);\n  let res_rem_seq = res_rem_call@;\n\n  let res_final_seq: Seq<char>;\n  if last_bit == '0' {\n    let temp_mul = MulMod(res_rem_call.as_slice(), res_rem_call.as_slice(), sz);\n    res_final_seq = temp_mul@;\n  } else {\n    let temp_mul1 = MulMod(res_rem_call.as_slice(), res_rem_call.as_slice(), sz);\n    let temp_mul2 = MulMod(sx, temp_mul1.as_slice(), sz);\n    res_final_seq = temp_mul2@;\n  }\n\n  proof {\n    bit_string_preserves_validity(sy@, 0, sy@.len() as int - 1);\n    prefix_mod_exp_lemma(\n      sx@,\n      sy@,\n      sz@,\n      last_bit,\n      rem_sy_seq,\n      res_rem_call@,\n      res_final_seq,\n      Str2Int(rem_sy_seq)\n    );\n  }\n\n  let mut res_final_vec = Vec::new();\n  for i in 0..res_final_seq.len() {\n    res_final_vec.push(res_final_seq.index(i));\n  }\n  res_final_vec\n}"]
--------------------------------------------------------------------------------
