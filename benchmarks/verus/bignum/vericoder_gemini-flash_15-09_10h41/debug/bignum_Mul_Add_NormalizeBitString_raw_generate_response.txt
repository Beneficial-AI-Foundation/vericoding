=== Raw LLM Generate Response ===
Length: 3003 characters
--------------------------------------------------------------------------------
["proof fn lemma_Str2Int_non_negative(s: Seq<char>)
    requires ValidBitString(s)
    ensures Str2Int(s) >= 0
    decreases s.len()
{
    if s.len() > 0 {
        lemma_Str2Int_non_negative(s.subrange(0, s.len() as int - 1));
    }
}", "{
    let mut sum: Vec<char> = Vec::new();
    let s1_seq = s1@;
    let s2_seq = s2@;
    let n1 = s1_seq.len() as int;
    let n2 = s2_seq.len() as int;

    // Pad sum with zeros for initial sizing
    for _i in 0..n1 + n2 {
        sum.push('0');
    }

    let mut i = 0;
    while i < n1
        invariant
            0 <= i && i <= n1,
            sum.len() == n1 + n2,
            ValidBitString(sum@),
            sum@.subrange(0, n1 + n2) == (Seq::new() + sum@.subrange(0, i + n2))
        decreases n1 - i
    {
        let bit1 = if s1_seq.index(n1 - 1 - i) == '1' { 1 } else { 0 };
        if bit1 == 1 {
            let mut j = 0;
            let mut carry = 0;
            while j < n2 + 1
                invariant
                    0 <= j && j <= n2 + 1,
                    sum.len() == n1 + n2,
                    ValidBitString(sum@),
                    carry == 0 || carry == 1,
                    (forall |k: int| 0 <= k && k < i + j ==> ValidBitString(sum.get(k..i + j))
                ` ` )
                decreases n2 + 1 - j
            {
                let s2_idx = n2 - 1 - j;
                let sum_idx = n1 + n2 - 1 - (i + j);

                if sum_idx >= 0 && sum_idx < sum.len() {
                    let bit2 = if j < n2 { if s2_seq.index(s2_idx) == '1' { 1 } else { 0 } } else { 0 };
                    let current_sum_val = if sum.get(sum_idx) == '1' { 1 } else { 0 };

                    let total = bit2 + current_sum_val + carry;
                    carry = total / 2;
                    sum.set(sum_idx, if total % 2 == 1 { '1' } else { '0' });
                }
                j = j + 1;
            }
        }
        i = i + 1;
    }

    // Remove leading zeros if necessary
    let mut first_one = 0;
    let mut found_one = false;
    while first_one < sum.len() && !found_one
        invariant
            0 <= first_one && first_one <= sum.len(),
            sum.len() == n1 + n2,
            ValidBitString(sum@),
            !found_one == (forall |k: int| 0 <= k && k < first_one ==> sum.get(k) == '0')
        decreases sum.len() - first_one
    {
        if sum.get(first_one) == '1' {
            found_one = true;
        } else {
            first_one = first_one + 1;
        }
    }

    if found_one {
        let mut final_res: Vec<char> = Vec::new();
        let mut k = first_one;
        while k < sum.len()
            invariant
                first_one <= k && k <= sum.len(),
                final_res.len() == k - first_one,
                ValidBitString(final_res@),
                ValidBitString(sum@)
            decreases sum.len() - k
        {
            final_res.push(sum.get(k));
            k = k + 1;
        }
        final_res
    } else {
        vec!['0']
    }
}"]
--------------------------------------------------------------------------------
