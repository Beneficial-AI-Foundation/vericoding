=== Raw LLM Generate Response ===
Length: 2144 characters
--------------------------------------------------------------------------------
["spec fn ModExp_DivMod_spec_internal(x_val: nat, y_val: nat, z_val: nat) -> nat\ndecreases y_val\n{\n    if y_val == 0 { 1 % z_val }\n    else if y_val % 2 == 0 {\n        let half_pow = ModExp_DivMod_spec_internal(x_val, y_val / 2, z_val);\n        (half_pow * half_pow) % z_val\n    }\n    else {\n        let half_pow = ModExp_DivMod_spec_internal(x_val, (y_val - 1) / 2, z_val);\n        (x_val * half_pow * half_pow) % z_val\n    }\n}", "{\n    let x_val = Str2Int(sx@);\n    let y_val = Str2Int(sy@);\n    let z_val = Str2Int(sz@);\n\n    // Base case: y_val is 0, result is 1 % z\n    if y_val == 0 {\n        let res_val = 1 % z_val;\n        return int_to_bit_vec(res_val);\n    }\n\n    // Recursive step: Divide and Conquer\n    if y_val % 2 == 0 { // y is even\n        let mut vec_y_div_2: Vec<char> = Vec::new();\n        let y_div_2: nat = y_val / 2;\n        vec_y_div_2 = int_to_bit_vec(y_div_2);\n\n        let half_pow_vec = ModExp_DivMod(sx, &*vec_y_div_2, sz);\n\n        let half_pow_val = Str2Int(half_pow_vec@);\n        let res_val = (half_pow_val * half_pow_val) % z_val;\n        assert(res_val == ModExp_DivMod_spec_internal(x_val, y_val, z_val));\n        return int_to_bit_vec(res_val);\n    } else { // y is odd\n        let mut vec_y_minus_1_div_2: Vec<char> = Vec::new();\n        let y_minus_1_div_2: nat = (y_val - 1) / 2;\n        vec_y_minus_1_div_2 = int_to_bit_vec(y_minus_1_div_2);\n\n        let half_pow_vec = ModExp_DivMod(sx, &*vec_y_minus_1_div_2, sz);\n        let half_pow_val = Str2Int(half_pow_vec@);\n        let res_val = (x_val * half_pow_val * half_pow_val) % z_val;\n        assert(res_val == ModExp_DivMod_spec_internal(x_val, y_val, z_val));\n        return int_to_bit_vec(res_val);\n    }\n\n    #[verifier::external_body]\n    fn int_to_bit_vec(n: nat) -> Vec<char> {\n        if n == 0 { return vec!['0']; }\n        let mut bits = Vec::new();\n        let mut num = n;\n        while num > 0 {\n            let remainder = num % 2;\n            bits.push(if remainder == 1 { '1' } else { '0' });\n            num /= 2;\n        }\n        bits.into_iter().rev().collect()\n    }\n}"]
--------------------------------------------------------------------------------
