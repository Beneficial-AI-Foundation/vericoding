=== Raw LLM Generate Response ===
Length: 1663 characters
--------------------------------------------------------------------------------
["proof fn lemma_mod_property(a: nat, b: nat, m: nat)
  requires m > 1
  ensures (a * b) % m == ((a % m) * (b % m)) % m
{\n  let ap = a % m;\n  let bp = b % m;\n  let q_a = a / m;\n  let q_b = b / m;\n\n  assert(a == q_a * m + ap);\n  assert(b == q_b * m + bp);\n  assert(a * b == (q_a * m + ap) * (q_b * m + bp));\n  assert(a * b == q_a * q_b * m * m + q_a * m * bp + ap * q_b * m + ap * bp);\n  assert(a * b % m == (ap * bp) % m) by (nonlinear_arith);\n}", "{\n  let x = Str2Int(sx@);\n  let y = Str2Int(sy@);\n  let z = Str2Int(sz@);\n\n  if y == 0 {\n    let one_str = ['1'].to_vec();\n    return one_str;\n  } else if sy.len() == 1 {\n    let r_int = x % z;\n    return Verus_int::nat_to_string_binary(r_int);\n  }\n\n  let sy_prime_seq = sy@.subrange(0, sy.len() as int - 1);\n  let sy_prime_vec = sy_prime_seq.to_vec();\n  let sy_last_bit = sy@[sy.len() as int - 1];\n\n  let y_prime = Str2Int(sy_prime_seq);\n\n  // y = 2 * y' + last_bit\n  // x^y = x^(2*y' + last_bit) = x^(2*y') * x^last_bit = (x^y')^2 * x^last_bit\n\n  // Recursive call for x^y' mod z\n  let pow_half_vec = ModExp(sx, &sy_prime_vec, sz);\n  let pow_half = Str2Int(pow_half_vec@);\n\n  // Calculate (x^y')^2 mod z\n  let sq_pow_half = (pow_half * pow_half) % z;\n  lemma_mod_property(pow_half, pow_half, z);\n\n  let res_val: nat;\n  if sy_last_bit == '1' {\n    // res_val = (sq_pow_half * (x % z)) % z\n    // x^last_bit is x (since last_bit is 1)\n    res_val = (sq_pow_half * (x % z)) % z;\n    lemma_mod_property(sq_pow_half, x % z, z);\n  } else {\n    // x^last_bit is 1 (since last_bit is 0)\n    res_val = sq_pow_half;\n  }\n  \n  Verus_int::nat_to_string_binary(res_val)\n}"]
--------------------------------------------------------------------------------
