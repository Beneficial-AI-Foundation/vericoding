=== Raw LLM Generate Response ===
Length: 1625 characters
--------------------------------------------------------------------------------
```json
["proof fn lemma_Str2Int_prefix(s: Seq<char>, i: int)\n    requires\n        0 <= i && i < s.len(),\n        ValidBitString(s),\n    ensures Str2Int(s.subrange(0, i + 1)) == 2 * Str2Int(s.subrange(0, i)) + (if s[i] == '1' { 1 } else { 0 }),\n{\n    reveal(Str2Int);\n}\n\nexec fn Str2IntExec(s: &[char]) -> (res: nat)\n    requires ValidBitString(s@)\n    ensures res == Str2Int(s@)\n{\n    let mut res: nat = 0;\n    let mut i: nat = 0;\n    while i < s.len()\n        invariant\n            ValidBitString(s@),\n            i <= s.len(),\n            res == Str2Int(s@.subrange(0, i as int)),\n        decreases s.len() - i\n    {\n        proof {\n            if i < s.len() {\n                lemma_Str2Int_prefix(s@, i as int);\n            }\n        }\n        let bit = if s[i as usize] == '1' { 1 } else { 0 };\n        res = res * 2 + bit;\n        i = i + 1;\n    }\n    res\n}\n\nproof fn lemma_Str2Int_append(s: Seq<char>, c: char)\n    requires\n        ValidBitString(s),\n        c == '0' || c == '1',\n    ensures Str2Int(s.push(c)) == 2 * Str2Int(s) + (if c == '1' { 1 } else { 0 }),\n{\n    reveal(Str2Int);\n}\n\nexec fn Int2StrExec(n: nat) -> (s: Vec<char>)\n    ensures\n        ValidBitString(s@),\n        Str2Int(s@) == n,\n        (n > 0 ==> s@.len() > 0 && s@[0] == '1'),\n        (n == 0 ==> s@.len() == 1 && s@[0] == '0'),\n    decreases n\n{\n    if n == 0 {\n        return vec!['0'];\n    }\n    if n == 1 {\n        vstd::arithmetic::div_mod::lemma_div_is_lesser(1, 2);\n        return vec!['1'];\n    }\n    vstd::arithmetic::div_mod::lemma_div_is_lesser(n, 2);\n    let mut prefix =
--------------------------------------------------------------------------------
