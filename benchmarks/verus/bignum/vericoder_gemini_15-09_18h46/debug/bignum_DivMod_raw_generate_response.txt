=== Raw LLM Generate Response ===
Length: 1588 characters
--------------------------------------------------------------------------------
```json
["spec fn power(b: nat, e: nat) -> nat decreases e { if e == 0 { 1 } else { b * power(b, e - 1) } }\n\nproof fn lemma_div_by_2(x: nat)\n    ensures\n        x % 2 == x - (x / 2) * 2,\n        x > 0 ==> x / 2 < x,\n{\n    if x > 0 {\n        vstd::arithmetic::div_mod::lemma_div_by_2_is_bit_shift(x);\n    }\n    vstd::arithmetic::div_mod::lemma_div_mod_is_div_mul_plus_mod(x, 2);\n}\n\nproof fn lemma_str2int_plus_one(s: Seq<char>)\n    requires ValidBitString(s),\n    ensures Str2Int(s.push('1')) == 2 * Str2Int(s) + 1,\n{\n    reveal(Str2Int);\n}\n\nproof fn lemma_str2int_plus_zero(s: Seq<char>)\n    requires ValidBitString(s),\n    ensures Str2Int(s.push('0')) == 2 * Str2Int(s),\n{\n    reveal(Str2Int);\n}\n\nexec fn nat_to_vec_char(n: u64) -> (res: Vec<char>)\n    ensures\n        ValidBitString(res@),\n        Str2Int(res@) == n as nat,\ndecreases n\n{\n    if n == 0 {\n        return vec!['0'];\n    }\n    if n == 1 {\n        return vec!['1'];\n    }\n\n    proof { lemma_div_by_2(n as nat); }\n    let mut head = nat_to_vec_char(n / 2);\n    \n    if n % 2 == 1 {\n        proof { lemma_str2int_plus_one(head@); }\n        head.push('1');\n    } else {\n        proof { lemma_str2int_plus_zero(head@); }\n        head.push('0');\n    }\n    head\n}\n\nexec fn BitstringToNat(s: &[char]) -> (r: u64)\n    requires ValidBitString(s@), Str2Int(s@) <= 0xffffffffffffffff\n    ensures r as nat == Str2Int(s@)\n{\n    let mut res: u64 = 0;\n    let mut i: usize = 0;\n    while i < s.len()\n        invariant \n            ValidBitString(s@),\n            res as nat ==
--------------------------------------------------------------------------------
