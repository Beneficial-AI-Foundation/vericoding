=== LLM Response - generate_code - Iteration 0 ===
File: /Users/sergiu.bursuc/baif/vericoding/benchmarks/verus/bignum/files/bignum_ModExpPow2_int.rs
Prompt Hash: c060a569
JSON Parsed Successfully: True
Timestamp: 1757961301.507769
Content Length: 2333 chars
--------------------------------------------------------------------------------
```json
["proof fn power_of_2_div_lemma(n: nat)\n    requires\n        n > 0\n    ensures\n        Exp_int(2, n) / 2 == Exp_int(2, (n - 1) as nat)\n{\n    unfold(Exp_int(2, n));\n}\n\nproof fn lemma_exp_plus(x: nat, y1: nat, y2: nat)\n    ensures\n        Exp_int(x, y1 + y2) == Exp_int(x, y1) * Exp_int(x, y2)\n    decreases y1\n{\n    if y1 > 0 {\n        lemma_exp_plus(x, (y1 - 1) as nat, y2);\n        vstd::math::lemma_mul_is_associative(x, Exp_int(x, (y1 - 1) as nat), Exp_int(x, y2));\n        assert(Exp_int(x, y1) == x * Exp_int(x, (y1-1) as nat)) by { unfold(Exp_int(x,y1)); };\n        assert(Exp_int(x, y1+y2) == x * Exp_int(x, y1+y2-1)) by { unfold(Exp_int(x,y1+y2)); };\n    }\n}\n\nproof fn lemma_exp_square(x: nat, y: nat)\n    ensures\n        Exp_int(x, 2*y) == Exp_int(x, y) * Exp_int(x, y)\n{\n    lemma_exp_plus(x, y, y);\n    assert(y+y == 2*y);\n}", "{\n    if n == 0 {\n        return x % z;\n    } else {\n        let y_rec = y / 2;\n        let n_rec = n - 1;\n        \n        proof {\n            power_of_2_div_lemma(n as nat);\n            assert((y_rec as nat) == Exp_int(2, n_rec as nat));\n        }\n\n        let t = ModExpPow2_int(x, y_rec, n_rec, z);\n\n        let t_128 = t as u128;\n        let z_128 = z as u128;\n        let res_128 = (t_128 * t_128) % z_128;\n        let res = res_128 as u64;\n\n        proof {\n            let x_nat = x as nat;\n            let z_nat = z as nat;\n            let y_nat = y as nat;\n            let n_nat = n as nat;\n            let n_rec_nat = n_rec as nat;\n\n            let exp_rec_nat = Exp_int(2, n_rec_nat);\n            lemma_exp_square(x_nat, exp_rec_nat);\n            \n            assert(y_nat == 2 * exp_rec_nat) by {\n                power_of_2_div_lemma(n_nat);\n                assert(Exp_int(2, n_nat) == y_nat);\n                vstd::math::lemma_mul_division_auto(y_nat, 2);\n            };\n\n            vstd::math::lemma_mod_properties_auto();\n\n            let A = Exp_int(x_nat, exp_rec_nat);\n            assert(Exp_int(x_nat, y_nat) % z_nat == (A * A) % z_nat);\n            assert((A * A) % z_nat == ((A % z_nat) * (A % z_nat)) % z_nat);\n            \n            assert((t as nat) == A % z_nat);\n            \n            assert((res as nat) == ((t as nat) * (t as nat)) % z_nat);\n        }\n        res\n    }\n}"]
```
--------------------------------------------------------------------------------
