=== Raw LLM Generate Response ===
Length: 1477 characters
--------------------------------------------------------------------------------
```json
["proof fn lemma_mod_mul(a: nat, b: nat, m: nat)
    requires m > 0
    ensures (a * b) % m == ((a % m) * (b % m)) % m
{
    vstd::arithmetic::div_mod::lemma_mul_mod_breakdown(a, b, m);
}

proof fn lemma_exp_unfold(b: nat, e: nat)
    requires e > 0
    ensures Exp_int(b, e) == b * Exp_int(b, (e-1) as nat)
{}

proof fn lemma_mod_exp_squared(b: nat, m: nat)
    requires m > 0
    ensures (b * b) % m == (Exp_int(b % m, 2)) % m
{
    lemma_mod_mul(b, b, m);
    assert((b * b) % m == ((b % m) * (b % m)) % m);
    lemma_exp_unfold(b % m, 2);
    lemma_exp_unfold(b % m, 1);
}

proof fn lemma_mod_exp_pwr2(b: nat, n: nat, m: nat)
    requires
        m > 0,
        n > 0,
    ensures
        Exp_int(b, Exp_int(2, n)) % m == Exp_int(Exp_int(b, Exp_int(2, (n-1) as nat)) % m, 2) % m
{
    let inner_exp = Exp_int(2, (n-1) as nat);
    let p = Exp_int(b, inner_exp);
    assert(Exp_int(2, n) == inner_exp * 2) by {
      lemma_exp_unfold(2, n as nat);
      assert(Exp_int(2, n) == 2 * Exp_int(2, (n-1) as nat));
    };
    assert(Exp_int(b, Exp_int(2, n)) == Exp_int(p, 2));
    lemma_mod_exp_squared(p, m);
}

proof fn lemma_Str2Int_pow2_prefix(s: Seq<char>, n: nat)
    requires
        n > 0,
        s.len() == (n + 1) as int,
        ValidBitString(s),
        Str2Int(s) == Exp_int(2, n),
    ensures
        let prefix = s.subrange(0, n as int);
        prefix.len() == n as int,
        ValidBitString(prefix),
        Str2Int(prefix) == Exp_int(2, (n-1) as nat
--------------------------------------------------------------------------------
