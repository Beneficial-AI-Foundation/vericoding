=== Raw LLM Generate Response ===
Length: 1625 characters
--------------------------------------------------------------------------------
```json
["spec fn Nat2Str(n: nat) -> Seq<char>\n    decreases n\n{\n    if n == 0 { seq!['0'] }\n    else if n == 1 { seq!['1'] }\n    else { Nat2Str(n/2).push(if n % 2 == 1 { '1' } else { '0' }) }\n}\n\nproof fn lemma_Str2Int_Nat2Str(n: nat)\n    ensures Str2Int(Nat2Str(n)) == n\n    decreases n\n{\n    if n > 1 {\n        vstd::arithmetic::div_mod_lemma(n as int, 2);\n        lemma_Str2Int_Nat2Str(n/2);\n    }\n}\n\nproof fn lemma_ValidBitString_Nat2Str(n: nat)\n    ensures ValidBitString(Nat2Str(n))\n    decreases n\n{\n    if n > 1 {\n        lemma_ValidBitString_Nat2Str(n/2);\n    }\n}\n\nexec fn Str2Int_exec(s: &[char]) -> (res: nat)\n    requires ValidBitString(s@)\n    ensures res == Str2Int(s@)\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        let prefix = s.subslice(0, s.len() - 1);\n        let prefix_val = Str2Int_exec(&prefix);\n        let last_val = if s[s.len() - 1] == '1' { 1 } else { 0 };\n        assert(Str2Int(s@) == 2 * Str2Int(prefix@) + last_val) by {\n            assert(s@.subrange(0, s@.len() as int - 1) == prefix@);\n        }\n        2 * prefix_val + last_val\n    }\n}\n\nexec fn Nat2Str_exec(n: nat) -> (res: Vec<char>)\n    ensures\n        res@ == Nat2Str(n),\n        ValidBitString(res@),\n        Str2Int(res@) == n,\n    decreases n\n{\n    proof {\n        lemma_ValidBitString_Nat2Str(n);\n        lemma_Str2Int_Nat2Str(n);\n    }\n    if n == 0 {\n        let mut v = Vec::new();\n        v.push('0');\n        v\n    } else if n == 1 {\n        let mut v = Vec::new();\n        v.push('1');\n        v\n    } else {\n        vstd::arith
--------------------------------------------------------------------------------
