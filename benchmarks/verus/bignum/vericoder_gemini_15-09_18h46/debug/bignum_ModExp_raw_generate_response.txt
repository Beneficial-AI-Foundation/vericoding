=== Raw LLM Generate Response ===
Length: 1488 characters
--------------------------------------------------------------------------------
```json
["proof fn lemma_exp_add(x: nat, a: nat, b: nat)\n    ensures Exp_int(x, a + b) == Exp_int(x, a) * Exp_int(x, b),\n    decreases a,\n{\n    if a > 0 {\n        lemma_exp_add(x, (a - 1) as nat, b);\n    }\n}\n\nexec fn str_to_int(s: &[char]) -> (n: nat)\n    requires ValidBitString(s@),\n    ensures n == Str2Int(s@),\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        return 0;\n    }\n    let prefix_val = str_to_int(&s[..s.len() - 1]);\n    let last_val = if s[s.len() - 1] == '1' { 1 } else { 0 };\n    proof {\n        assert(Str2Int(s@) == Str2Int(s@.subrange(0, s@.len() as int - 1)) * 2 + if s[s.len() - 1] == '1' { 1 } else { 0 });\n    }\n    prefix_val * 2 + last_val\n}\n\nproof fn lemma_str2int_push(s: Seq<char>, c: char)\n    requires ValidBitString(s), c == '0' || c == '1',\n    ensures ValidBitString(s.push(c)),\n        Str2Int(s.push(c)) == Str2Int(s) * 2 + if c == '1' { 1 } else { 0 },\n{\n}\n\nexec fn int_to_str(n: nat) -> (res: Vec<char>)\n    ensures ValidBitString(res@), Str2Int(res@) == n,\n    decreases n,\n{\n    if n == 0 {\n        return vec!['0'];\n    }\n    if n == 1 {\n        return vec!['1'];\n    }\n    let mut high_bits = int_to_str(n / 2);\n    let low_bit = if n % 2 == 1 { '1' } else { '0' };\n    proof {\n        lemma_str2int_push(high_bits@, low_bit);\n        assert(n == (n / 2) * 2 + n % 2) by(compute_only);\n    }\n    high_bits.push(low_bit);\n    high_bits\n}", "{\n    if sy.len() == 1 {\n        if sy[0] == '0
--------------------------------------------------------------------------------
