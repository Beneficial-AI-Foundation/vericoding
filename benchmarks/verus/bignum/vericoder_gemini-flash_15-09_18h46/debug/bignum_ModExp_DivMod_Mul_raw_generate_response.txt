=== Raw LLM Generate Response ===
Length: 1420 characters
--------------------------------------------------------------------------------
["spec fn modulo(a: nat, b: nat) -> nat { a % b }

spec fn mult(x: nat, y: nat) -> nat { x * y }

proof fn Exp_int_zero_is_one()
  ensures Exp_int(10, 0) == 1
{}

proof fn Exp_int_property(x: nat, y: nat)
  ensures Exp_int(x, y as nat) == x * Exp_int(x, (y - 1) as nat)
  requires y > 0
{}
", "{\n    let x_int = Str2Int(sx@);\n    let y_int = Str2Int(sy@);\n    let z_int = Str2Int(sz@);\n\n    if sy@.len() == 1 && sy@[0] == '0' {\n        // x^0 mod z = 1 mod z\n        S_to_v(nat_to_seq(1 % z_int))\n    } else if sy@.len() == 1 && sy@[0] == '1' {\n        // x^1 mod z = x mod z\n        S_to_v(nat_to_seq(x_int % z_int))\n    } else {\n        let half_y_char = DivideByTwo(sy@);\n        let half_y_int = Str2Int(half_y_char@);\n\n        let mut recurse_result = ModExp_DivMod_Mul(sx, &half_y_char, sz);\n        let recurse_result_int = Str2Int(recurse_result@);\n\n        let is_odd = sy@[sy@.len() - 1] == '1';\n\n        let final_result: nat;\n        if is_odd {\n            // x^y = x * (x^(y/2))^2\n            let term1 = mult(recurse_result_int, recurse_result_int);\n            let term2 = mult(x_int, term1);\n            final_result = modulo(term2, z_int);\n        } else {\n            // x^y = (x^(y/2))^2\n            let term1 = mult(recurse_result_int, recurse_result_int);\n            final_result = modulo(term1, z_int);\n        }\n        S_to_v(nat_to_seq(final_result))\n    }\n}"]
--------------------------------------------------------------------------------
