=== Raw LLM Generate Response ===
Length: 2708 characters
--------------------------------------------------------------------------------
["proof fn lemma_mult_mod_distrib(a: nat, b: nat, m: nat)
    ensures (a % m * b % m) % m == (a * b) % m
{
    let a_mod_m = a % m;
    let b_mod_m = b % m;
    let a_div_m = a / m;
    let b_div_m = b / m;

    assert(a == a_div_m * m + a_mod_m);
    assert(b == b_div_m * m + b_mod_m);

    let product = a * b;
    let product_mod_m = (a_mod_m * b_mod_m) % m;

    assert( (a_div_m * m + a_mod_m) * (b_div_m * m + b_mod_m) == a * b ) by {
        assert( (a_div_m * m + a_mod_m) * (b_div_m * m + b_mod_m) ==
            a_div_m * m * b_div_m * m +
            a_div_m * m * b_mod_m +
            a_mod_m * b_div_m * m +
            a_mod_m * b_mod_m
        );
    }

    assert( (a * b) % m == ( (a_div_m * m * b_div_m * m + a_div_m * m * b_mod_m + a_mod_m * b_div_m * m) + a_mod_m * b_mod_m ) % m ) by {
        assert( (a_div_m * m * b_div_m * m) % m == 0nat );
        assert( (a_div_m * m * b_mod_m) % m == 0nat );
        assert( (a_mod_m * b_div_m * m) % m == 0nat );
    }

    assert( (a * b) % m == ( a_mod_m * b_mod_m ) % m );
}", "{\n    let x_val = Str2Int(sx@);\n    let y_val = Str2Int(sy@);\n    let z_val = Str2Int(sz@);\n\n    if sy@.len() == 1 && sy@[0] == '0' {\n        // x^0 mod z = 1 mod z\n        if z_val == 1 {\n            return vec!['0']; // 1 % 1 is 0\n        } else {\n            return vec!['1'];\n        }\n    }\n\n    let mut result_val = 1_nat;\n    let mut base = x_val % z_val;\n    let mut exponent = y_val;\n\n    while exponent > 0\n        invariant\n            result_val * Exp_int(base, exponent) % z_val == x_val.pow(y_val as u32) % z_val,\n            exponent >= 0,\n            base >= 0,\n            z_val > 1\n        decreases exponent\n    {\n        if exponent % 2 == 1 {\n            // result_val = (result_val * base) % z_val;\n            lemma_mult_mod_distrib(result_val, base, z_val);\n            result_val = (result_val * base) % z_val;\n        }\n\n        // base = (base * base) % z_val;\n        lemma_mult_mod_distrib(base, base, z_val);\n        base = (base * base) % z_val;\n        exponent = exponent / 2;\n    }\n\n    let hex_chars = \"0123456789ABCDEF\".chars().collect::<Vec<char>>();\n    if result_val == 0 {\n        return vec!['0'];\n    }\n\n    let mut bits = Vec::<char>::new();\n    let mut temp = result_val;\n    while temp > 0\n        invariant\n            temp >= 0,\n            forall |i: int| #![trigger bits@.index(i)] 0 <= i && i < bits@.len() ==> (bits@[i] == '0' || bits@[i] == '1')\n        decreases temp\n    {\n        if temp % 2 == 1 {\n            bits.push('1');\n        } else {\n            bits.push('0');\n        }\n        temp = temp / 2;\n    }\n    bits.reverse();\n    bits\n}"]
--------------------------------------------------------------------------------
