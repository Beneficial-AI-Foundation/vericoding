=== Raw LLM Generate Response ===
Length: 3910 characters
--------------------------------------------------------------------------------
["proof fn Str2Int_plus_bound(orig_sy: Seq<char>, sy: Seq<char>, i: int, sum: nat)\n    requires\n        ValidBitString(orig_sy),\n        sy.len() == orig_sy.len() - i,\n        sum == Str2Int(orig_sy.subrange(i as int, orig_sy.len() as int)),\n        0 <= i,\n        i <= orig_sy.len()\n    ensures\n        sum < Exp_int(2, (orig_sy.len() - i) as nat) + 1,\n        sum >= 0\n    decreases sy.len()\n{\n    if sy.len() == 0 {\n        assert(sum == 0);\n    } else {\n        let first_bit_val = if sy.index(0) == '1' { 1nat } else { 0nat };\n        let new_sy = sy.subrange(1, sy.len() as int);\n        let new_sum = Str2Int(new_sy);\n        Str2Int_plus_bound(orig_sy, new_sy, i + 1, new_sum);\n        assert(sum == Exp_int(2, (sy.len() - 1) as nat) * first_bit_val + new_sum);\n    }\n}\n\nproof fn pow_properties_generic<F: crate::verus_code_gen_test_ModExp::ModExp_ModExpPow2_Mul::S, V: crate::verus_code_gen_test_ModExp::ModExp_ModExpPow2_Mul::S>(x: F, y: V, modVal: F) \n    requires \n        modVal > 1\n\n    ensures \n        (x * y) % modVal == ((x % modVal) * (y % modVal)) % modVal,\n        (x + y) % modVal == ((x % modVal) + (y % modVal)) % modVal\n{\n}\n\nspec fn convert_nat_to_char_vec(n: nat) -> Seq<char>\n    decreases n\n{\n    if n == 0 { Seq::new().push('0') }\n    else\n    {\n        let mut result = Seq::new();\n        let mut num = n;\n        while num > 0\n            invariant\n                num >= 0\n        {\n            if num % 2 == 0 {\n                result = result.push('0');\n            } else {\n                result = result.push('1');\n            }\n            num = num / 2;\n        }\n        result\n    }\n}\n\nproof fn convert_nat_to_char_vec_properties(n: nat)\n    ensures (n > 0 ==> Str2Int(convert_nat_to_char_vec(n).reverse()) == n),\n            (n == 0 ==> Str2Int(convert_nat_to_char_vec(n).reverse()) == 0),\n            (n > 0 ==> forall |i: int| 0 <= i && i < convert_nat_to_char_vec(n).len() ==> (convert_nat_to_char_vec(n)@.index(i) == '0' || convert_nat_to_char_vec(n)@.index(i) == '1')),\n            (convert_nat_to_char_vec(0)@.len() == 1)\n{\n    if n > 0 {\n        let mut result = Seq::new();\n        let mut num = n;\n        let mut i = 0;\n        let mut s_val = 0;\n\n        while num > 0\n            invariant\n                num >= 0,\n                forall |j: int| 0 <= j && j < result.len() ==> (result.index(j) == '0' || result.index(j) == '1'),\n                s_val == Str2Int(result),\n                (num * Exp_int(2, i as nat) + s_val) == n,\n                i == result.len()\n        {\n            if num % 2 == 0 {\n                result = result.push('0');\n            } else {\n                result = result.push('1');\n            }\n            num = num / 2;\n            i = i + 1;\n            s_val = Str2Int(result);\n        }\n        assert(Str2Int(result.reverse()) == n);\n        assert(ValidBitString(convert_nat_to_char_vec(n)@));\n    }\n}\n", "{\n    let x = Str2Int(sx@);\n    let y = Str2Int(sy@);\n    let z = Str2Int(sz@);\n\n    let mut result: nat = 1;\n    let mut base: nat = x;\n    let mut exponent: nat = y;\n\n    while exponent > 0\n        invariant\n            result > 0,\n            exponent >= 0,\n            Exp_int(x, y) % z == (result * Exp_int(base, exponent)) % z,\n            base > 0,\n            z > 1,\n            (ValidBitString(sx@) && ValidBitString(sy@) && ValidBitString(sz@))\n        decreases exponent\n    {\n        if exponent % 2 == 1 {\n            result = (result * base) % z;\n        }\n        base = (base * base) % z;\n        exponent = exponent / 2;\n    }\n\n    convert_nat_to_char_vec_properties(result);\n    let final_res_seq = convert_nat_to_char_vec(result).reverse();\n    \n    vassert(ValidBitString(final_res_seq));\n    vassert(Str2Int(final_res_seq) == result);\n\n    final_res_seq.to_vec()\n}"]
--------------------------------------------------------------------------------
