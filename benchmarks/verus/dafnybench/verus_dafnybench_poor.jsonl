{"id": "VD0537", "language": "verus", "source": "dafnybench", "source_id": "cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_NoDups", "vc-description": "// ASSIGNMENT P1\n\n// CMSC 433 FALL 2023\n\n// PERFECT SCORE:  100 POINTS\n\n//\n\n// This assignment contains nine questions, each of which involves writing Verus\n\n// code. You should include your solutions in a single Verus file and submit it using\n\n// Gradescope.\n\n//\n\n// Revision history\n\n//\n\n// 2023-09-22 2:50 pm   Fixed typo in Problem 3.\n\n// Question 1 (5 points)\n\n//\n\n// Fill in a requires clause that enables Verus to verify\n\n// method PlusOne\n\n// Question 2 (5 points)\n\n//\n\n// Fill in requires clause(s) that enable(s) Verus to verify the array bounds\n\n// in method Swap (which swaps elements i and j in array a).\n\n// Question 3 (5 points)\n\n//\n\n// Give ensures clause(s) asserting that d is the result, and r the\n\n// remainder, of dividing m by n.  Your clauses cannot use \"/\" or \"%\" (which are\n\n// the Verus division and mod operators, respectively). By definition, the\n\n// remainder must be non-negative.\n\n// Question 4 (5 points)\n\n//\n\n// Give ensures clause(s) asserting that the return value has the same\n\n// length as array a and contains as its elements the sum of the\n\n// corresponding elements in arrays a and b.\n\n// Question 5 (10 points)\n\n// Euclid's algorithm is used to compute the greatest common divisor of two\n\n// positive integers.  If m and n are two such integers, then gcd(m,n) is the\n\n// largest positve integer that evenly divides both m and n, where j evenly divides i\n\n// if and only if i % j == 0 (% is the Verus mod operator).  Write requires and\n\n// ensures clauses for the method header Euclid below.  Your requires clauses\n\n// should also specify that the first argument is at least as large as the second.\n\n// You do *not* need to implement the method!\n\n// Question 7 (20 points)\n\n//\n\n// Implement, and have Verus verify, the method IsPrime below, which returns true\n\n// if and only if the given positive integer is prime.\n\n// Question 8 (20 points)\n\n//\n\n// Implement, and have Verus verify, the method Reverse below, which returns a new array\n\n// aRev consisting of the elements of a, but in reverse order.  To create a new \n\n// array of ints use the Verus command \"Vec::with_capacity(...)\", where \"...\" is the number\n\n// of elements in the array.\n\n// Question 9 (20 points)\n\n//\n\n// Implement and verify method NoDups, which returns true if and only if there\n\n// are no duplicate elements in array a.  Note that the requires clause allows\n\n// you to assume that a is sorted, and that this precondition is necessary for\n\n// the ensures clause to imply a lack of duplicates.\n\n// a sorted", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn no_dups(a: &Vec<i32>) -> (no_dups: bool)\n    requires forall|j: int| 1 <= j < a.len() ==> a[j-1] <= a[j],\n    ensures no_dups <==> forall|j: int| 1 <= j < a.len() ==> a[j-1] != a[j],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling"}
{"id": "VD0848", "language": "verus", "source": "dafnybench", "source_id": "formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_HoareTripleReqEns", "vc-description": "/*\nVerus include 2 limbaje:\n    * un limbaj pentru specificare \n        MSFOL (ce am discutat până acum)\n        adnotări care să ajute în procesul de verificare\n    * un limbaj pentru scris programe\n*/\n\n// Exemplu de program\n\n/*\n    triple Hoare (| P |) S (| Q |) \n*/\n\n// varianta assume-assert\n\n// varianta requires-ensures\n\n/*\nregula pentru while\n*/\n\n// varianta cu assert\n\n/*\n*/\n\n// varianta cu invariant\n\n//specificarea sumei de patrate\n\n/*\n*/\n\n// verificarea programului pentru suma de patrate\n\n// SqrSumRec(n) = 0^2 + 1^2 + 2^2 + ... + n^2 == n(n+1)(2n+1)/6\n\n// Base case\n\n// Additional proof steps would be needed here\n\n/*\nspec fn SqrSumBy6(n: int) -> int\n{\n    n * (n + 1) * (2 * n + 1) \n}\n\nproof fn L(n: int) // it takes a while\n    requires n >= 0\n    ensures  SqrSumBy6(n) == 6 * SqrSumRec(n)\n    decreases n\n{\n    if n == 0 {\n        // Base case\n    } else {\n        assert(n > 0);\n        L(n-1);\n        assert(SqrSumBy6(n-1) == n*(n-1)*(2*n - 1));\n        assert(SqrSumBy6(n-1) == 6*SqrSumRec(n-1));\n        assert(6*SqrSumRec(n-1) == n*(n-1)*(2*n - 1));\n        // Additional calc steps would be needed here for full verification\n    }\n}\n*/\n\n// (| k == i*i |) k := k + 2 * i +1; (| k = (i+1)*(i+1) |)\n\n// Proof by algebraic expansion: k + 2*i + 1 = i*i + 2*i + 1 = (i+1)*(i+1)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn SqrSumRec(n: int) -> int\n    recommends n >= 0\n    decreases n\n{\n    if n == 0 { 0 } else { n*n + SqrSumRec(n-1) }\n}\n\nproof fn L1(n: int)\n    requires n >= 0\n    ensures SqrSumRec(n) == n*(n+1)*(2*n + 1)/6\n    decreases n\n{\n    if n == 0 {\n\n    } else {\n        L1(n-1);\n\n    }\n}", "vc-helpers": "", "vc-spec": "spec fn HoareTripleReqEns(i: int, k: int) -> (kprime: int)\n    recommends k == i*i\n    ensures kprime == (i+1)*(i+1)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling"}
