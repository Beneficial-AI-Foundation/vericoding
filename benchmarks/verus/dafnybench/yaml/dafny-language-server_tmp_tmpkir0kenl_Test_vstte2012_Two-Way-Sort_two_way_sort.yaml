vc-description: |-

vc-preamble: |-
  use vstd::prelude::*;
  use vstd::multiset::Multiset;
  
  verus! {
  
  // This method is a slight generalization of the
  // code provided in the problem statement since it
  // is generic in the type of the array elements.
  
  spec fn multisets<T>(s: Seq<T>) -> Multiset<T>
      decreases s.len(),
  {
      if s.len() == 0 { 
          Multiset::empty() 
      } else { 
          Multiset::singleton(s[0]).add(multisets(s.subrange(1, s.len() as int)))
      }
  }
  
  fn swap<T>(a: &mut Vec<T>, i: usize, j: usize)
      requires 
          i < j < old(a).len(),
      ensures 
          a[i as int] == old(a)[j as int],
          a[j as int] == old(a)[i as int],
          forall|m: int| 0 <= m < a.len() && m != i && m != j ==> a[m] == old(a)[m],
          multisets(a@) == multisets(old(a)@),
  {
      assume(false);
  }
  
  // This method is a direct translation of the pseudo
  // code given in the problem statement.
  // The first postcondition expresses that the resulting
  // array is sorted, that is, all occurrences of "false"
  // come before all occurrences of "true".
  // The second postcondition expresses that the post-state
  // array is a permutation of the pre-state array. To express
  // this, we use Verus's built-in multisets. The built-in
  // function "multisets" takes a sequence and yields the
  // multiset of the sequence elements.
  // Note that Verus guesses a suitable ranking function
  // for the termination proof of the while loop.
  // We use the loop guard from the given pseudo-code.  However,
  // the program also verifies with the stronger guard "i < j"
  // (without changing any of the other specifications or
  // annotations).

vc-helpers: |-

vc-spec: |-
  fn two_way_sort(a: &mut Vec<bool>)
      ensures 
          forall|m: int, n: int| 0 <= m < n < a.len() ==> (!a[m] || a[n]),
          multisets(a@) == multisets(old(a)@),

vc-code: |-
  {
      assume(false);
  }

vc-postamble: |-
  fn main() {}
  
  }

