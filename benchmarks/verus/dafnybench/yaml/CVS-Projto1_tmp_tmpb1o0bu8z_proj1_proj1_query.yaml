vc-description: |-

vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  //Exercicio 1.a)
  spec fn sum(a: Seq<int>, i: int, j: int) -> int
      recommends 0 <= i <= j <= a.len()
      decreases j when 0 <= i <= j <= a.len()
  {
      if i == j {
          0
      } else {
          a[j - 1] + sum(a, i, j - 1)
      }
  }
  
  //Exercicio 1.b)
  
  //Exercicio 1.c)
  
  
  spec fn is_prefix_sum_for(a: Seq<int>, c: Seq<int>) -> bool {
      a.len() + 1 == c.len()
      && c[0] == 0
      && forall|j: int| 1 <= j <= a.len() ==> c[j] == sum(a, 0, j)
  }
  
  ///Exercicio 2.
  #[derive(PartialEq, Eq)]
  enum List<T> {
      Nil,
      Cons { head: T, tail: Box<List<T>> }
  }
  
  fn from_array<T: Copy>(a: &[T]) -> (l: List<T>)
      requires a.len() > 0
      ensures forall|j: int| 0 <= j < a.len() ==> mem(a@[j], l)
  {
      assume(false);
      List::Nil
  }
  
  spec fn mem<T>(x: T, l: List<T>) -> bool
      decreases l
  {
      match l {
          List::Nil => false,
          List::Cons { head: y, tail: r } => if x == y { true } else { mem(x, *r) }
      }
  }

vc-helpers: |-
  // <vc-helpers>
  // </vc-helpers>

vc-spec: |-
  // <vc-spec>
  exec fn query(a: &[i32], i: usize, j: usize) -> (s: i32)
      requires 0 <= i <= j <= a.len()
      ensures s == sum(a@.map(|k, x| x as int), i as int, j as int)
  // </vc-spec>

vc-code: |-
  // <vc-code>
  {
      assume(false);
      0
  }
  // </vc-code>

vc-postamble: |-
  fn main() {}
  
  }

