vc-description: |-

vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  // see pdf 'ex6 & 7 documentation' for excercise question
  
  #[derive(PartialEq, Eq, Debug, Clone, Copy)]
  enum Bases {
      A,
      C,
      G,
      T,
  }
  
  //swaps two sequence indexes
  fn exchanger(s: Seq<Bases>, x: nat, y: nat) -> (t: Seq<Bases>)
      requires 
          0 < s.len() && x < s.len() && y < s.len()
      ensures 
          t.len() == s.len(),
          forall|b: int| 0 <= b < s.len() && b != x && b != y ==> t[b] == s[b],
          t[x as int] == s[y as int] && s[x as int] == t[y as int],
          s.to_multiset() == t.to_multiset()
  {
      assume(false);
      s
  }
  
  //idea from Rustan Leino video "Basics of specification and verification: Lecture 3, the Dutch National Flag algorithm"
  //modified for 4 elements
  spec fn below(first: Bases, second: Bases) -> bool {
      first == second ||
      first == Bases::A || 
      (first == Bases::C && (second == Bases::G || second == Bases::T)) || 
      (first == Bases::G && second == Bases::T) ||
      second == Bases::T
  }
  
  //checks if a sequence is in base order
  spec fn bordered(s: Seq<Bases>) -> bool {
      forall|j: int, k: int| 0 <= j < k < s.len() ==> below(s[j], s[k])
  }

vc-helpers: |-

vc-spec: |-
  fn sorter(bases: Seq<Bases>) -> (sobases: Seq<Bases>)
      requires 
          0 < bases.len()
      ensures 
          sobases.len() == bases.len(),
          bordered(sobases),
          bases.to_multiset() == sobases.to_multiset()

vc-code: |-
  {
      assume(false);
      unreached();
  }

vc-postamble: |-
  fn main() {}
  
  }

