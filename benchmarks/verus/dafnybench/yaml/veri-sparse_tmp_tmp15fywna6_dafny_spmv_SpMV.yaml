vc-description: |-
  // 0 0 0 0 0 0 1 0
  
  // 0 0 0 0 0 0 0 0
  
  // 0 0 0 0 1 0 0 0
  
  // 0 0 0 0 0 0 0 0
  
  // 0 0 1 0 0 0 0 0
  
  // 0 0 0 0 0 0 0 0
  
  // 1 0 0 0 0 0 0 0
  
  // 0 0 0 0 0 0 0 0

vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn sum(X_val: Seq<int>, X_crd: Seq<nat>, v: Seq<int>, b: int, k: int) -> int
      decreases k - b
  {
      if k <= b {
          0
      } else {
          sum(X_val, X_crd, v, b + 1, k) + X_val[b] * v[X_crd[b] as int]
      }
  }

vc-helpers: |-

vc-spec: |-
  fn SpMV(X_val: &[i8], X_crd: &[u8], X_pos: &[u8], v: &[i8]) -> (y: Vec<i8>)
      requires 
          X_crd.len() >= 1,
          X_crd.len() == X_val.len(),
          forall|i: int, j: int| 0 <= i < j < X_pos.len() ==> X_pos[i] as nat <= X_pos[j] as nat,
          forall|i: int| 0 <= i < X_crd.len() ==> (X_crd[i] as nat) < v.len(),
          forall|i: int| 0 <= i < X_pos.len() ==> (X_pos[i] as nat) <= X_val.len(),
          X_pos.len() >= 1,
      ensures
          y.len() + 1 == X_pos.len(),
          forall|i: int| 0 <= i < y.len() ==> y[i] as int == sum(X_val@.map(|i: int, x: i8| x as int), X_crd@.map(|i: int, x: u8| x as nat), v@.map(|i: int, x: i8| x as int), X_pos[i] as int, X_pos[i + 1] as int),

vc-code: |-
  {
      assume(false);
      unreached()
  }

vc-postamble: |-
  }
  fn main() {}