vc-description: |-
  // predicate for primeness
  
  // the class containing a prime database, if a number is prime it returns Yes, if it is not No and if the number
  
  // is not in the database it returns Unknown
  
  // the valid invariant of the class
  
  // the constructor
  
  // lookup n in the database and reply with Yes or No if it's in the database and it is or it is not prime,
  
  // or with Unknown when it's not in the databse
  
  // method to test whether a number is prime, returns bool

vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn prime(n: nat) -> bool {
      n > 1 && (forall|nr: nat| 1 < nr < n ==> #[trigger] (n % nr) != 0)
  }
  
  #[derive(PartialEq, Eq)]
  enum Answer {
      Yes,
      No,
      Unknown,
  }
  
  struct PrimeMap {
      database: Ghost<Map<nat, bool>>,
  }
  
  impl PrimeMap {
  
      spec fn valid(&self) -> bool {
          forall|i: nat| self.database@.dom().contains(i) ==> (self.database@[i] == prime(i))
      }
  
      fn new() -> (result: PrimeMap)
          ensures 
              result.database@ === Map::empty(),
              result.valid(),
      {
          PrimeMap {
              database: Ghost(Map::empty())
          }
      }
  
      fn is_prime(&self, n: nat) -> (answer: Answer)
          requires self.valid(),
          ensures 
              self.database@.dom().contains(n) && prime(n) <==> answer == Answer::Yes,
              self.database@.dom().contains(n) && !prime(n) <==> answer == Answer::No,
              !self.database@.dom().contains(n) <==> answer == Answer::Unknown,
      {
          assume(false);
          Answer::Unknown
      }
  
  }

vc-helpers: |-

vc-spec: |-
  fn test_primeness(n: nat) -> (result: bool) 
        requires n >= 0,
        ensures result <==> prime(n),

vc-code: |-
  {
      assume(false);
      unreached()
  }

vc-postamble: |-
  }
  fn main() {}

