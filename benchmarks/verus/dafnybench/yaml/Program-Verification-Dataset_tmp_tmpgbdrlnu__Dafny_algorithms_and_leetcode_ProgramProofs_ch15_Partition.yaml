vc-description: |-

vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn split_point(a: Seq<int>, n: int) -> bool {
      0 <= n <= a.len() &&
      forall|i: int, j: int| 0 <= i < n <= j < a.len() ==> a[i] <= a[j]
  }
  
  spec fn swap_frame(a_old: Seq<int>, a_new: Seq<int>, lo: int, hi: int) -> bool {
      0 <= lo <= hi <= a_old.len() &&
      a_old.len() == a_new.len() &&
      (forall|i: int| (0 <= i < lo || hi <= i < a_old.len()) ==> a_new[i] == a_old[i]) &&
      a_new.to_multiset() == a_old.to_multiset()
  }

vc-helpers: |-

vc-spec: |-
  fn partition(a: &mut Vec<i8>, lo: usize, hi: usize) -> (p: usize)
      requires
          0 <= lo < hi <= old(a).len(),
          split_point(old(a)@.map(|i: int, x: i8| x as int), lo as int),
          split_point(old(a)@.map(|i: int, x: i8| x as int), hi as int),
      ensures
          lo <= p < hi,
          forall|i: int| lo <= i < p ==> (a[i] as int) < (a[p as int] as int),
          forall|i: int| p <= i < hi ==> (a[p as int] as int) <= (a[i] as int),
          split_point(a@.map(|i: int, x: i8| x as int), lo as int),
          split_point(a@.map(|i: int, x: i8| x as int), hi as int),
          swap_frame(old(a)@.map(|i: int, x: i8| x as int), a@.map(|i: int, x: i8| x as int), lo as int, hi as int),

vc-code: |-
  {
      assume(false);
      unreached()
  }

vc-postamble: |-
  }
  fn main() {}