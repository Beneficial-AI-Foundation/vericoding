vc-description: |-
  //Bubblesort CS 494 submission
  
  //References: https://stackoverflow.com/questions/69364687/how-to-prove-time-complexity-of-bubble-sort-using-dafny/69365785#69365785
  
  // predicate checks if elements of a are in ascending order, two additional conditions are added to allow us to sort in specific range within array
  
  //helps ensure swapping is valid, it is used inside the nested while loop to make sure linear order is being kept 
  
  // all values within the array should be in ascending order
  
  // Here having the algorithm for the bubblesort
  
  // makes sure a is not empty and length is greater than 0
  
  // makes sure elements of array a are sorted from 0 - a.len()
  
  // Since a is being modified, we compare the previous elements to current elements.

vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn sorted(a: &Vec<i32>, from: usize, to: usize) -> bool
      recommends 
          from <= to,
          to <= a.len(),
  {
      forall|x: usize, y: usize| from <= x < y < to ==> a[x as int] <= a[y as int]
  }
  
  spec fn pivot(a: &Vec<i32>, to: usize, pvt: usize) -> bool
      recommends
          pvt < to,
          to <= a.len(),
  {
      forall|x: usize, y: usize| 0 <= x < pvt < y < to ==> a[x as int] <= a[y as int]
  }

vc-helpers: |-
  spec fn sorted_i8(a: &Vec<i8>, from: usize, to: usize) -> bool
      recommends 
          from <= to,
          to <= a.len(),
  {
      forall|x: usize, y: usize| from <= x < y < to ==> a[x as int] <= a[y as int]
  }

vc-spec: |-
  fn BubbleSort(a: &mut Vec<i8>)
      requires 
          old(a).len() > 0,
      ensures 
          sorted_i8(a, 0, a.len()),
          a@.to_multiset() == old(a)@.to_multiset(),

vc-code: |-
  {
      assume(false);
      unreached()
  }

vc-postamble: |-
  }
  fn main() {}