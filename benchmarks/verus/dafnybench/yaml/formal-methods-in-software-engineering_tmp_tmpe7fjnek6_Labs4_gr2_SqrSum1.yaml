vc-description: |-
  /*
  Verus includes 2 languages:
      * a language for specification 
          MSFOL (what we've discussed so far)
          annotations to help in the verification process
      * a language for writing programs
  */
  
  // Example program
  
  /*
      triple Hoare (| P |) S (| Q |) 
  */
  
  // assume-assert variant
  
  // requires-ensures variant
  
  /*
  rule for while
  */
  
  // assert variant
  
  /*
  */
  
  // invariant variant
  
  //specification of sum of squares
  
  /*
  
  */
  
  // verification of the program for sum of squares
  
  // SqrSumRec(n) = 0^2 + 1^2 + 2^2 + ... + n^2 == n(n+1)(2n+1)/6
  
  //OK
  
  /*
  spec fn sqr_sum_by_6(n: int) -> int
  {
      n * (n + 1) * (2 * n + 1) 
  }
  
  proof fn l(n: int) // it takes a while
      requires n >= 0
      ensures sqr_sum_by_6(n) == 6 * sqr_sum_rec(n)
      decreases n
  {
      if n == 0 {}
      else {
          assert(n > 0);
          l(n-1);
          assert(sqr_sum_by_6(n-1) == n*(n-1)*(2*n - 1));
          assert(sqr_sum_by_6(n-1) == 6*sqr_sum_rec(n-1));
          assert(6*sqr_sum_rec(n-1) == n*(n-1)*(2*n - 1));
          calc! (==)
          n*((n-1)*(2*n - 1)); {
              n*(2*n*(n-1) - n + 1); {
                  n*(2*n*n - 3*n + 1); {
                      n*(2*n*n - 3*n + 1);
                  }
              }
          }
          calc! (==)
          2*n*n + n; {
              (2*n + 1)*n;
          }
          calc! (==)
          (2*n + 1)*n + (2*n + 1); {
              (2*n + 1)*(n+1);
          }
          calc! (==)
          n*((n-1)*(2*n - 1)) + 6*n*n; {
              n*(2*n*(n-1) - n + 1) + 6*n*n; {
                  n*(2*n*(n-1) - n + 1) + 6*n*n; {
                      n*(2*n*n - 3*n + 1) + 6*n*n; {
                          n*(2*n*n - 3*n + 1 + 6*n); {
                              n*(2*n*n + 6*n - 3*n + 1); {
                                  n*(2*n*n + 3*n + 1); {
                                      n*(2*n*n + n + (2*n + 1)); {
                                          n*((2*n + 1)*n + (2*n + 1)); {
                                              n*((2*n + 1)*(n+1));
                                          }
                                      }
                                  }
                              }
                          }
                      }
                  }
              }
          }
      }
  }
  
  */
  
  // s = 0^2 + 1^2 + 2^2 + ... + n^2 == n(n+1)(2n+1)/6

vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn sqr_sum_rec(n: int) -> int
      decreases n when n >= 0
  {
      if n <= 0 { 0 } else { n*n + sqr_sum_rec(n-1) }
  }
  
  proof fn l1(n: int)
      requires n >= 0
      ensures sqr_sum_rec(n) == n*(n+1)*(2*n + 1)/6
      decreases n
  {
      if n == 0 {
          assert(sqr_sum_rec(0) == 0);
          assert(0*(0+1)*(2*0 + 1)/6 == 0);
      } else {
          l1(n-1);
          assert(sqr_sum_rec(n-1) == (n-1)*n*(2*(n-1) + 1)/6);
          assert(sqr_sum_rec(n) == n*n + sqr_sum_rec(n-1));
          // Need to prove: n*n + (n-1)*n*(2*n-1)/6 == n*(n+1)*(2*n+1)/6
          // This requires algebraic manipulation that Verus can handle
          assert(n*n + (n-1)*n*(2*n-1)/6 == n*(n+1)*(2*n+1)/6) by {
              // Mathematical proof would go here
              assume(false);
          }
      }
  }

vc-helpers: |-

vc-spec: |-
  fn sqr_sum1(n: i8) -> (s: i8)
      requires n as int >= 0
      ensures s as int == sqr_sum_rec(n as int)

vc-code: |-
  {
      assume(false);
      unreached()
  }

vc-postamble: |-
  }
  fn main() {}