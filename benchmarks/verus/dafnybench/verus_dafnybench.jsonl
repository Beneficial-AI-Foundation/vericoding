{"id": "Software-Verification_tmp_tmpv4ueky2d_Non-overlapping Intervals_non_overlapping_intervals_non_overlapping_intervals", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// Bubble Sort\nfn bubble_sort(a: &mut Vec<Vec<i32>>)\n    requires\n        old(a).len() >= 1,\n        forall|i: int| 0 <= i < old(a).len() ==> #[trigger] old(a)[i].len() == 2,\n    ensures\n        a.len() == old(a).len(),\n        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i].len() == 2,\n        sorted(a, 0, (a.len() - 1) as int),\n{\n    assume(false);\n}\n\n\n// Predicates for Bubble Sort\nspec fn sorted(a: &Vec<Vec<i32>>, l: int, u: int) -> bool\n    recommends\n        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i].len() == 2,\n{\n    forall|i: int, j: int| 0 <= l <= i <= j <= u < a.len() ==> #[trigger] a[i][1] <= #[trigger] a[j][1]\n}\n\nspec fn partitioned(a: &Vec<Vec<i32>>, i: int) -> bool\n    recommends\n        forall|k: int| 0 <= k < a.len() ==> #[trigger] a[k].len() == 2,\n{\n    forall|k: int, k_prime: int| 0 <= k <= i < k_prime < a.len() ==> #[trigger] a[k][1] <= #[trigger] a[k_prime][1]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn non_overlapping_intervals(intervals: &mut Vec<Vec<i32>>) -> (count: i32)\n    requires\n        1 <= old(intervals).len() <= 100000,\n        forall|i: int| 0 <= i < old(intervals).len() ==> #[trigger] old(intervals)[i].len() == 2,\n        forall|i: int| 0 <= i < old(intervals).len() ==> -50000 <= #[trigger] old(intervals)[i][0] <= 50000,\n        forall|i: int| 0 <= i < old(intervals).len() ==> -50000 <= #[trigger] old(intervals)[i][1] <= 50000,\n    // TODO: modify the ensures clause so that count is indeed equal to the minimum number of intervals we need to remove to make the rest of the intervals non-overlapping.\n    ensures\n        count >= 0,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_733_FindFirstOccurrence", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn find_first_occurrence(arr: &[i32], target: i32) -> (result: i32)\n    requires\n        forall|i: int, j: int| 0 <= i < j < arr.len() ==> arr[i] <= arr[j]\n    ensures\n        (0 <= result < arr.len() ==> arr[result as int] == target) &&\n        (result == -1 ==> forall|i: int| 0 <= i < arr.len() ==> arr[i] != target)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    -1\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "Clover_double_array_elements_double_array_elements", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn double_array_elements(s: &mut Vec<i32>)\n    ensures forall|i: int| 0 <= i < old(s).len() ==> s[i] == 2 * old(s)[i]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafny-duck_tmp_tmplawbgxjo_p6_FilterVowelsArray", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// Given an array of characters, it filters all the vowels. ['d','e','l','i','g','h','t']-> ['e','i']\nspec fn vowels() -> Set<char> {\n    set!['a', 'e', 'i', 'o', 'u']\n}\n\nspec fn filter_vowels(xs: Seq<char>) -> Seq<char>\n    decreases xs.len()\n{\n    if xs.len() == 0 {\n        seq![]\n    } else if vowels().contains(xs[xs.len() - 1]) {\n        filter_vowels(xs.subrange(0, xs.len() - 1)).add(seq![xs[xs.len() - 1]])\n    } else {\n        filter_vowels(xs.subrange(0, xs.len() - 1))\n    }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn filter_vowels_array(xs: &[char]) -> (ys: Vec<char>)\n    ensures filter_vowels(xs@) == ys@\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Clover_binary_search_BinarySearch", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn binary_search(a: &[i32], key: i32) -> (n: usize)\n    requires \n        forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j]\n    ensures \n        0 <= n <= a.len(),\n        forall|i: int| 0 <= i < n ==> a[i] < key,\n        n == a.len() ==> forall|i: int| 0 <= i < a.len() ==> a[i] < key,\n        forall|i: int| n <= i < a.len() ==> a[i] >= key\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Clover_avg_ComputeAvg", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn compute_avg(a: int, b: int) -> (avg: int)\n    ensures avg == (a + b) / 2\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session6Exercises_ExerciseCountMin_mCountMin", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn min(v: Seq<int>, i: int) -> int\n    decreases i\n{\n    if 1 <= i <= v.len() {\n        if i == 1 {\n            v[0]\n        } else if v[i-1] <= min(v, i-1) {\n            v[i-1]\n        } else {\n            min(v, i-1)\n        }\n    } else {\n        0  // dummy value for invalid inputs\n    }\n}\n\nproof fn min_property(v: Seq<int>, i: int)\n    requires 1 <= i <= v.len()\n    ensures forall|k: int| 0 <= k < i ==> v[k] >= min(v, i)\n    decreases i\n{\n    if i > 1 {\n        min_property(v, i-1);\n    }\n}\n\nspec fn count_min(v: Seq<int>, x: int, i: int) -> int\n    decreases i\n{\n    if 0 <= i <= v.len() {\n        if i == 0 {\n            0\n        } else if v[i-1] == x {\n            1 + count_min(v, x, i-1)\n        } else {\n            count_min(v, x, i-1)\n        }\n    } else {\n        0  // dummy value for invalid inputs\n    }\n}\n\nproof fn count_min_property(v: Seq<int>, x: int, i: int)\n    requires 0 <= i <= v.len()\n    ensures !(exists|k: int| 0 <= k < i && v[k] == x) ==> count_min(v, x, i) == 0\n    decreases i\n{\n    if i > 0 {\n        count_min_property(v, x, i-1);\n    }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn m_count_min(v: &Vec<i32>) -> (c: i32)\n    requires v.len() > 0\n    ensures c == count_min(v@.map_values(|x: i32| x as int), \n                          min(v@.map_values(|x: i32| x as int), v.len() as int), \n                          v.len() as int)\n    //Implement and verify an O(v.len()) algorithm\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_750_AddTupleToList", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nproof fn add_tuple_to_list(l: Seq<(int, int)>, t: (int, int)) -> (r: Seq<(int, int)>)\n    ensures\n        r.len() == l.len() + 1,\n        r[r.len() - 1] == t,\n        forall|i: int| 0 <= i < l.len() ==> r[i] == l[i]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    arbitrary()\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n} // verus!"}
{"id": "Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_A2_Q1_trimmed copy - 副本_FooCount", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn count(hi: nat, s: Seq<int>) -> int\n    recommends 0 <= hi <= s.len()\n    decreases hi\n{\n    if hi == 0 {\n        0\n    } else if s[hi - 1] % 2 == 0 {\n        1 + count((hi - 1) as nat, s)\n    } else {\n        count((hi - 1) as nat, s)\n    }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn foo_count(count_index: usize, a: &Vec<int>, b: &mut Vec<int>) -> (p: usize)\n    requires \n        count_index == 0 || (a.len() == old(b).len() && 1 <= count_index <= a.len()),\n    ensures \n        p == count(count_index as nat, a@),\n    decreases count_index\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_755_SecondSmallest", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn min_pair(s: Seq<i32>) -> i32 {\n    if s[0] <= s[1] { s[0] } else { s[1] }\n}\n\nspec fn min(s: Seq<i32>) -> i32;", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn second_smallest(s: &[i32]) -> (second_smallest: i32)\n    requires \n        s.len() >= 2,\n        exists|i: int, j: int| 0 <= i < s.len() && 0 <= j < s.len() && i != j && \n            s[i] == min(s@) && s[j] != s[i]\n    ensures \n        exists|i: int, j: int| 0 <= i < s.len() && 0 <= j < s.len() && i != j && \n            s[i] == min(s@) && s[j] == second_smallest,\n        forall|k: int| 0 <= k < s.len() && s[k] != min(s@) ==> s[k] >= second_smallest\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_week5_ComputePower_ComputePower", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn power(n: nat) -> nat \n    decreases n\n{\n    if n == 0 { 1 } else { 2 * power((n - 1) as nat) }\n}\n\nfn calc_power(n: u32) -> (p: u32)\n    ensures p == 2 * n\n{\n  assume(false);\n  0\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn compute_power(n: u32) -> (p: u32)\n    ensures p == power(n as nat)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  0\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "dafny-exercise_tmp_tmpouftptir_reverse_Reverse", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn reverse(a: &Vec<char>) -> (b: Vec<char>)\n    requires \n        a.len() > 0,\n    ensures \n        b.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> b[i] == a[a.len() - i - 1],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_557_ToggleCase", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_lower_case(c: char) -> bool {\n    97 <= c as int <= 122\n}\n\nspec fn is_upper_case(c: char) -> bool {\n    65 <= c as int <= 90\n}\n\nspec fn is_lower_upper_pair(c: char, C: char) -> bool {\n    (c as int) == (C as int) + 32\n}\n\nspec fn is_upper_lower_pair(C: char, c: char) -> bool {\n    (C as int) == (c as int) - 32\n}\n\nspec fn shift_minus_32(c: char) -> char {\n    ((c as int - 32) % 128) as char\n}\n\nspec fn shift_32(c: char) -> char {\n    ((c as int + 32) % 128) as char\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn toggle_case(s: Vec<char>) -> (v: Vec<char>)\n    ensures\n        v.len() == s.len(),\n        forall|i: int| 0 <= i < s.len() ==> {\n            let s_char = #[trigger] s[i];\n            let v_char = v[i];\n            if is_lower_case(s_char) {\n                is_lower_upper_pair(s_char, v_char)\n            } else if is_upper_case(s_char) {\n                is_upper_lower_pair(s_char, v_char)\n            } else {\n                v_char == s_char\n            }\n        }\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex7_Sorter", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// see pdf 'ex6 & 7 documentation' for excercise question\n\n\n#[derive(PartialEq, Eq, Debug, Clone, Copy)]\nenum Bases {\n    A,\n    C,\n    G,\n    T,\n}\n\n//swaps two sequence indexes\nfn exchanger(s: Seq<Bases>, x: nat, y: nat) -> (t: Seq<Bases>)\n    requires \n        0 < s.len() && x < s.len() && y < s.len()\n    ensures \n        t.len() == s.len(),\n        forall|b: int| 0 <= b < s.len() && b != x && b != y ==> t[b] == s[b],\n        t[x as int] == s[y as int] && s[x as int] == t[y as int],\n        s.to_multiset() == t.to_multiset()\n{\n    assume(false);\n    s\n}\n\n//idea from Rustan Leino video \"Basics of specification and verification: Lecture 3, the Dutch National Flag algorithm\"\n//modified for 4 elements\nspec fn below(first: Bases, second: Bases) -> bool {\n    first == second ||\n    first == Bases::A || \n    (first == Bases::C && (second == Bases::G || second == Bases::T)) || \n    (first == Bases::G && second == Bases::T) ||\n    second == Bases::T\n}\n\n//checks if a sequence is in base order\nspec fn bordered(s: Seq<Bases>) -> bool {\n    forall|j: int, k: int| 0 <= j < k < s.len() ==> below(s[j], s[k])\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn sorter(bases: Seq<Bases>) -> (sobases: Seq<Bases>)\n    requires \n        0 < bases.len()\n    ensures \n        sobases.len() == bases.len(),\n        bordered(sobases),\n        bases.to_multiset() == sobases.to_multiset()\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    bases\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_476_SumMinMax", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// The order of the recursion in these two functions\n// must match the order of the iteration in the algorithm above\nspec fn min_seq(a: Seq<int>) -> int\n    recommends a.len() > 0\n    decreases a.len() when a.len() > 0\n{\n    if a.len() == 1 {\n        a[0]\n    } else {\n        let prefix = a.subrange(0, a.len() - 1);\n        assume(prefix.len() < a.len());\n        let min_prefix = min_seq(prefix);\n        if a[a.len() - 1] <= min_prefix {\n            a[a.len() - 1]\n        } else {\n            min_prefix\n        }\n    }\n}\n\nspec fn max_seq(a: Seq<int>) -> int\n    recommends a.len() > 0\n    decreases a.len() when a.len() > 0\n{\n    if a.len() == 1 {\n        a[0]\n    } else {\n        let prefix = a.subrange(0, a.len() - 1);\n        assume(prefix.len() < a.len());\n        let max_prefix = max_seq(prefix);\n        if a[a.len() - 1] >= max_prefix {\n            a[a.len() - 1]\n        } else {\n            max_prefix\n        }\n    }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn sum_min_max(a: &[i32]) -> (sum: i32)\n    requires a.len() > 0\n    ensures sum == max_seq(a@.map(|i: int, x: i32| x as int)) + min_seq(a@.map(|i: int, x: i32| x as int))\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "BPTree-verif_tmp_tmpq1z6xm1d_Utils_InsertIntoSorted", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// Function SetLessThan equivalent\nspec fn set_less_than(numbers: Set<int>, threshold: int) -> Set<int> {\n    numbers.filter(|i: int| i < threshold)\n}\n\n// Function seqSet equivalent\nspec fn seq_set(nums: Seq<int>, index: nat) -> Set<int> {\n    if index < nums.len() {\n        Set::new(|x: int| exists|i: int| 0 <= i < index && i < nums.len() && nums[i] == x)\n    } else {\n        Set::empty()\n    }\n}\n\n// Predicate SortedSeq equivalent\nspec fn sorted_seq(a: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] < a[j]\n}\n\n// Method GetInsertIndex equivalent\nfn get_insert_index(a: &[int], limit: usize, x: int) -> (idx: usize)\n    requires \n        !a@.contains(x),\n        limit <= a.len(),\n        sorted_seq(a@.take(limit as int)),\n    ensures\n        idx <= limit,\n        sorted_seq(a@.take(limit as int)),\n        idx > 0 ==> a[(idx - 1) as int] < x,\n        idx < limit ==> x < a[idx as int],\n{\n    assume(false);\n    0\n}\n\n// Predicate sorted equivalent\nspec fn sorted(a: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] < a[j]\n}\n\n// Predicate distinct equivalent\nspec fn distinct(a: Seq<int>) -> bool {\n    forall|i: int, j: int| (0 <= i < a.len() && 0 <= j < a.len() && i != j) ==> a[i] != a[j]\n}\n\n// Predicate sorted_eq equivalent\nspec fn sorted_eq(a: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j]\n}\n\n// Predicate lessThan equivalent\nspec fn less_than(a: Seq<int>, key: int) -> bool {\n    forall|i: int| 0 <= i < a.len() ==> a[i] < key\n}\n\n// Predicate greaterThan equivalent\nspec fn greater_than(a: Seq<int>, key: int) -> bool {\n    forall|i: int| 0 <= i < a.len() ==> a[i] > key\n}\n\n// Predicate greaterEqualThan equivalent\nspec fn greater_equal_than(a: Seq<int>, key: int) -> bool {\n    forall|i: int| 0 <= i < a.len() ==> a[i] >= key\n}\n\n// Function count equivalent\nspec fn count(a: Seq<bool>) -> nat\n    decreases a.len()\n{\n    if a.len() == 0 { \n        0nat \n    } else { \n        (if a[0] { 1nat } else { 0nat }) + count(a.drop_first())\n    }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn insert_into_sorted(a: &[int], limit: usize, key: int) -> (b: Vec<int>)\n    requires \n        key > 0,\n        !a@.contains(key),\n        limit < a.len(),\n        forall|i: int| 0 <= i < limit ==> a[i] > 0,\n        forall|i: int| limit <= i < a.len() ==> a[i] == 0,\n        sorted(a@.take(limit as int)),\n    ensures\n        b.len() == a.len(),\n        sorted(b@.take((limit + 1) as int)),\n        forall|i: int| limit + 1 <= i < b.len() ==> b[i] == 0,\n        forall|i: int| 0 <= i < limit ==> a@.contains(b[i]),\n        forall|i: int| 0 <= i < limit + 1 ==> b[i] > 0,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Dafny_tmp_tmpmvs2dmry_pancakesort_flip_flip", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// flips (i.e., reverses) array elements in the range [0..num]", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn flip(a: &mut Vec<i32>, num: usize)\n    requires \n        old(a).len() > 0,\n        num < old(a).len(),\n    ensures\n        forall|k: int| 0 <= k <= num as int ==> #[trigger] a[k] == old(a)[num as int - k],\n        // forall k :: num < k < a.Length ==> a[k] == old(a[k])\n        a.len() == old(a).len(),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 3_InsertionSortMultiset_Search", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// Höfundur spurningar:  Snorri Agnarsson, snorri@hi.is\n// Permalink spurningar: https://rise4fun.com/Dafny/G4sc3\n\n// Höfundur lausnar:     Alexander Guðmundsson\n// Permalink lausnar:    https://rise4fun.com/Dafny/nujsu\n\n// Insertion sort með hjálp helmingunarleitar.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn search(s: Seq<int>, x: int) -> (k: usize)\n    // Ekki má breyta forskilyrðum eða eftirskilyrðum fallsins\n    requires \n        forall|p: int, q: int| 0 <= p < q < s.len() ==> s[p] <= s[q],\n    ensures \n        0 <= k <= s.len(),\n        forall|i: int| 0 <= i < k ==> s[i] <= x,\n        forall|i: int| k <= i < s.len() ==> s[i] >= x,\n        forall|z: int| s.subrange(0, k as int).contains(z) ==> z <= x,\n        forall|z: int| s.subrange(k as int, s.len() as int).contains(z) ==> z >= x,\n        s == s.subrange(0, k as int).add(s.subrange(k as int, s.len() as int)),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "Correctness_tmp_tmpwqvg5q_4_Sorting_Tangent_Tangent", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/**\n  Ather, Mohammad Faiz (s4648481/3)\n  CSSE3100\n  Assignemnt 3\n  The University of Queensland\n */\n\n// Question 1\n\n// Author: Leino, Title: Program Proofs\nfn binary_search(a: &[int], circle: int) -> (n: usize)\n    requires\n        forall|i: int| 1 <= i < a.len() ==> a[i-1] < #[trigger] a[i],\n        forall|i: int, j: int| 0 <= i < j < a.len() ==> #[trigger] a[i] < #[trigger] a[j],\n    ensures\n        n <= a.len(),\n        forall|i: int| 0 <= i < n ==> #[trigger] a[i] < circle,\n        forall|i: int| n <= i < a.len() ==> circle <= #[trigger] a[i],\n{\n    assume(false);\n    0\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn tangent(r: &[int], x: &[int]) -> (found: bool)\n    requires\n        forall|i: int| 1 <= i < x.len() ==> x[i-1] < #[trigger] x[i],\n        forall|i: int, j: int| 0 <= i < j < x.len() ==> #[trigger] x[i] < #[trigger] x[j],\n    ensures\n        !found ==> forall|i: int, j: int| \n            0 <= i < r.len() && 0 <= j < x.len() ==> #[trigger] r[i] != #[trigger] x[j],\n        found ==> exists|i: int, j: int|\n            0 <= i < r.len() && 0 <= j < x.len() && #[trigger] r[i] == #[trigger] x[j],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    false\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "Dafny_Verify_tmp_tmphq7j0row_Generated_Code_ComputePower_ComputePower", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn power(n: nat) -> nat\n    decreases n\n{\n    if n == 0 { 1 } else { 2 * power((n - 1) as nat) }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn compute_power(n: u32) -> (p: u32)\n    requires n < 32, // practical bound to prevent overflow\n    ensures p == power(n as nat),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0 // unreachable due to assume(false)\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_249_Intersection", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// Predicate to check if an element exists in an array\nspec fn in_array(a: &[i32], x: i32) -> bool {\n    exists|i: int| 0 <= i < a.len() && a[i as int] == x\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn intersection(a: &[i32], b: &[i32]) -> (result: Vec<i32>)\n    ensures\n        // All elements in the output are in both a and b\n        forall|x: i32| result@.contains(x) ==> (in_array(a, x) && in_array(b, x)),\n        // The elements in the output are all different\n        forall|i: int, j: int| 0 <= i < j < result.len() ==> result[i] != result[j]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_770_SumOfFourthPowerOfOddNumbers", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn sum_of_fourth_power_of_odd_numbers(n: i32) -> (sum: i32)\n    requires n > 0,\n    ensures sum == n * (2 * n + 1) * (24 * n * n * n - 12 * n * n - 14 * n + 7) / 15,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0 // unreachable but needed for return type\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "DafnyPrograms_tmp_tmp74_f9k_c_automaton_ExecuteAutomaton", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/**\nConsider cellular automata: a row of cells is repeatedly updated according to a rule. In this exercise I dabbled with,\neach cell has the value either false or true. Each cell's next state depends only on the immediate neighbours, in the \ncase where the cell is at the edges of the row, the inexistent neighbours are replaced by \"false\". The automaton table \nwill contain the initial row, plus a row for each number of steps.\n */\nstruct Automaton {}\n\n/**\nThis method computes the automaton.\nProvide the initial row: init, the rule and the desired number of steps\n */", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\n#[verifier::exec_allows_no_decreases_clause]\nfn execute_automaton(init: Seq<bool>, rule: spec_fn(bool, bool, bool) -> bool, steps: nat) \n    -> (table: Seq<Seq<bool>>)\n    requires \n        // we need the initial row to have the length bigger or equal to two\n        init.len() >= 2\n    ensures \n        // after computation the automaton is made of the initial row plus a row for each of the steps\n        table.len() == 1 + steps,\n        // the automaton must have the initial row at the top\n        table[0] == init,\n        // all rows in the automaton must be the same length\n        forall|i: int| 0 <= i < table.len() ==> #[trigger] table[i].len() == init.len()\n        // TODO: Additional ensures clauses for middle and corner elements would require complex triggers\n        // Original Dafny clauses commented due to trigger complexity in Verus:\n        // all the middle row elements (with existing neighbours) after a step, will be equal to the rule applied on the element in the previous state\n        // and its neigbours\n        // ensures forall i | 0 <= i < |table| - 1 ::\n        //           forall j | 1 <= j <= |table[i]| - 2 :: table[i + 1][j] == rule(table[i][j - 1], table[i][j], table[i][j + 1])\n        // the corner row elements (with non-existing neighbours) after a step, will be equal to the rule applied on the element in the previous state,\n        // its neighbour and false\n        // ensures forall i | 0 <= i < |table| - 1 ::\n        //           table[i + 1][0] == rule(false, table[i][0], table[i][1]) && table[i + 1][|table[i]| - 1] == rule(table[i][|table[i]| - 2], table[i][|table[i]| - 1], false)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    loop {}\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_625_SwapFirstAndLast", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn swap_first_and_last(a: &mut Vec<i32>)\n    requires \n        old(a).len() > 0,\n    ensures\n        a.len() == old(a).len(),\n        a[0] == old(a)[old(a).len() - 1],\n        a[a.len() - 1] == old(a)[0],\n        forall|k: int| 1 <= k < old(a).len() - 1 ==> a[k] == old(a)[k],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_170_SumInRange", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sum_to(a: Seq<int>, start: int, end: int) -> int\n    recommends \n        0 <= start <= end <= a.len(),\n    decreases end\n    when 0 <= start <= end <= a.len()\n{\n    if start == end {\n        0\n    } else {\n        sum_to(a, start, end - 1) + a[end - 1]\n    }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn sum_in_range(a: &[i32], start: usize, end: usize) -> (sum: i32)\n    requires \n        start <= end <= a.len(),\n    ensures\n        sum == sum_to(a@.map(|i, v| v as int), start as int, end as int),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "Dafny_tmp_tmpmvs2dmry_pancakesort_findmax_findMax", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// returns an index of the largest element of array 'a' in the range [0..n)", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn findMax(a: &[i32], n: usize) -> (r: usize)\n    requires\n        a.len() > 0,\n        0 < n <= a.len(),\n    ensures\n        0 <= r < n <= a.len(),\n        forall|k: usize| 0 <= k < n <= a.len() ==> a[r as int] >= a[k as int],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_mmaximum1", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n//Algorithm 1: From left to right return the first", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn mmaximum1(v: &[i32]) -> (i: usize)\n    requires v.len() > 0,\n    ensures \n        0 <= i < v.len(),\n        forall|k: int| 0 <= k < v.len() ==> v[i as int] >= v[k],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "//Algorithm 2: From right to left return the last\n\n\n\n\n//Algorithm : from left to right\n//Algorithm : from right to left\n\nfn main() {\n}\n\n}"}
{"id": "Software-Verification_tmp_tmpv4ueky2d_Non-overlapping Intervals_non_overlapping_intervals_bubble_sort", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// Bubble Sort\n\n// Predicates for Bubble Sort\nspec fn sorted(a: &Vec<(i32, i32)>, l: int, u: int) -> bool {\n    forall|i: int, j: int| 0 <= l <= i <= j <= u < a.len() ==> a[i].1 <= a[j].1\n}\n\nspec fn partitioned(a: &Vec<(i32, i32)>, i: int) -> bool {\n    forall|k: int, k_prime: int| 0 <= k <= i < k_prime < a.len() ==> a[k].1 <= a[k_prime].1\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn bubble_sort(a: &mut Vec<(i32, i32)>)\n    ensures sorted(a, 0, a.len() as int - 1)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_2_SharedElements", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn in_array(a: &[i32], x: i32) -> bool {\n    exists|i: int| 0 <= i < a.len() && a[i] == x\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn shared_elements(a: &[i32], b: &[i32]) -> (result: Vec<i32>)\n    ensures\n        // All elements in the output are in both a and b\n        forall|x: i32| result@.contains(x) ==> (in_array(a, x) && in_array(b, x)),\n        // The elements in the output are all different\n        forall|i: int, j: int| 0 <= i < j < result.len() ==> result[i] != result[j]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_106_AppendArrayToSeq", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn append_array_to_seq(s: Seq<i32>, a: &Vec<i32>) -> (r: Seq<i32>)\n    ensures\n        r.len() == s.len() + a.len(),\n        forall|i: int| 0 <= i < s.len() ==> r[i] == s[i],\n        forall|i: int| 0 <= i < a.len() ==> r[s.len() + i] == a[i],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    s\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "BelowZero_BelowZero", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* \nHumanEvalX 3\nYou're given a list of deposit and withdrawal operations on a bank account that starts with zero balance. \nYour task is to detect if at any point the balance of account falls below zero, and at that point function \nshould return True. Otherwise it should return False.\n*/\n\nspec fn sum(s: Seq<int>, n: nat) -> int\n    recommends n <= s.len()\n    decreases n\n{\n    if s.len() == 0 || n == 0 {\n        0\n    } else {\n        s[0] + sum(s.subrange(1, s.len() as int), (n - 1) as nat)\n    }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn below_zero(ops: Seq<int>) -> (result: bool)\n    ensures result <==> exists|n: nat| n <= ops.len() && sum(ops, n) < 0\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  false\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_555_DifferenceSumCubesAndSumNumbers", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn difference_sum_cubes_and_sum_numbers(n: u32) -> (diff: u32)\n    requires n >= 0\n    ensures diff == (n * n * (n + 1) * (n + 1)) / 4 - (n * (n + 1)) / 2\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  0\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "llm-verified-eval_tmp_tmpd2deqn_i_dafny_9_rolling_max", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn isMax(m: int, numbers: Seq<int>) -> bool {\n    numbers.contains(m) &&\n    forall|i: int| 0 <= i < numbers.len() ==> numbers[i] <= m\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn rolling_max(numbers: Vec<int>) -> (result: Vec<int>)\n    requires\n        numbers.len() > 0,\n    ensures\n        result.len() == numbers.len(),\n        forall|i: int| 0 < i < result.len() ==> isMax(result[i], numbers@.subrange(0, i + 1)),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "Software-Verification_tmp_tmpv4ueky2d_Best Time to Buy and Sell Stock_best_time_to_buy_and_sell_stock_best_time_to_buy_and_sell_stock", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn best_time_to_buy_and_sell_stock(prices: &[i32]) -> (max_profit: i32)\n    requires \n        1 <= prices.len() <= 100000,\n        forall|i: int| 0 <= i < prices.len() ==> #[trigger] prices[i] >= 0 && #[trigger] prices[i] <= 10000,\n    ensures \n        forall|i: int, j: int| 0 <= i < j < prices.len() ==> max_profit >= #[trigger] prices[j] - #[trigger] prices[i],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "SENG2011_tmp_tmpgk5jq85q_exam_ex2_Getmini", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn get_mini(a: &[i32]) -> (mini: usize)\n    requires a.len() > 0,\n    ensures \n        0 <= mini < a.len(), // mini is an index of a\n        forall|x: usize| 0 <= x < a.len() ==> a[mini as int] <= a[x as int], // a[mini] is the minimum value\n        forall|x: usize| 0 <= x < mini ==> a[mini as int] < a[x as int], // a[mini] is the first min\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0 // unreachable but needed for type checking\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_234_CubeVolume", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn cube_volume(size: i32) -> (volume: i32)\n    requires size > 0\n    ensures volume == size * size * size\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0 // unreachable but needed for return type\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_leetcode_lc-remove-element_removeElement", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n//https://leetcode.com/problems/remove-element/", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn removeElement(nums: &mut Vec<i32>, val: i32) -> (i: usize)\n    ensures forall|k: int| 0 < k < i && k < nums.len() ==> nums[k] != val,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Clover_integer_square_root_SquareRoot", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn square_root(n: u32) -> (r: u32)\n  ensures r * r <= n < (r + 1) * (r + 1)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  0\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_262_SplitArray", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn split_array(arr: &[i32], l: usize) -> (Vec<i32>, Vec<i32>)\n    requires 0 <= l <= arr.len()\n{\n// </vc-spec>", "vc-code": "// <vc-code>\n    assume(false);\n    (Vec::new(), Vec::new())\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafny_examples_tmp_tmp8qotd4ez_leetcode_0027-remove-element_RemoveElement", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn remove_element(nums: &mut Vec<i32>, val: i32) -> (newLength: usize)\n    ensures \n        0 <= newLength <= nums.len(),\n        forall|i: int| 0 <= i < newLength ==> nums[i] != val,\n        nums@.subrange(0, newLength as int).to_multiset() == \n            old(nums)@.to_multiset().remove(val),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "dafny-language-server_tmp_tmpkir0kenl_Test_dafny2_SegmentSum_MaxSegSum", "vc-description": "", "vc-preamble": "// RUN: %verus \"%s\"\n\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn sum(a: Seq<int>, s: int, t: int) -> int\n    recommends 0 <= s <= t <= a.len()\n    decreases t - s when 0 <= s <= t <= a.len()\n{\n    if s == t { 0 } else { sum(a, s, t-1) + a[t-1] }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn max_seg_sum(a: &Vec<int>) -> (result: (usize, usize))\n    ensures ({\n        let (k, m) = result;\n        &&& k <= m <= a.len()\n        &&& forall |p: int, q: int| 0 <= p <= q <= a.len() ==> \n            sum(a@, p, q) <= sum(a@, k as int, m as int)\n    })\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    (0, 0)\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_133_SumOfNegatives", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sum_negatives_to(a: &[i32], n: int) -> int\n    recommends 0 <= n <= a.len()\n    decreases n\n{\n    if n == 0 { \n        0 \n    } else if n > 0 && a[n - 1] < 0 { \n        sum_negatives_to(a, n - 1) + a[n - 1] \n    } else if n > 0 { \n        sum_negatives_to(a, n - 1) \n    } else {\n        0\n    }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn sum_of_negatives(a: &[i32]) -> (result: i32)\n    ensures result == sum_negatives_to(a, a.len() as int)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_mlastMaximum", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// Algorithm 1: From left to right return the first\n// Algorithm 2: From right to left return the last", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn mlast_maximum(v: &[i32]) -> (i: usize)\n    requires v.len() > 0\n    ensures \n        i < v.len(),\n        forall|k: int| 0 <= k < v.len() ==> v[i as int] >= v[k],\n        forall|l: int| i < l < v.len() ==> v[i as int] > v[l],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}\n\n// Algorithm : from left to right\n// Algorithm : from right to left"}
{"id": "Clover_longest_prefix_LongestCommonPrefix", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn longest_common_prefix(str1: Seq<char>, str2: Seq<char>) -> (prefix: Seq<char>)\n    ensures \n        prefix.len() <= str1.len() && prefix == str1.subrange(0, prefix.len() as int) &&\n        prefix.len() <= str2.len() && prefix == str2.subrange(0, prefix.len() as int),\n        prefix.len() == str1.len() || prefix.len() == str2.len() || \n        (str1[prefix.len() as int] != str2[prefix.len() as int])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 2_BinarySearchDec_SearchRecursive", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// Author of question: Snorri Agnarsson\n// Permalink of question: https://rise4fun.com/Dafny/CGB1z\n\n// Authors of solution:   Alexander Guðmundsson\n// Permalink of solution: https://rise4fun.com/Dafny/VnB5\n\n// Use the command\n//   verus H2-skeleton.rs\n// to compile the file.\n\n// When you have solved the problem put\n// the solution on the Verus web page,\n// generate a permalink and put it in\n// this file.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn search_recursive(a: Seq<int>, i: int, j: int, x: int) -> (k: int)\n    requires \n        0 <= i <= j <= a.len(),\n        forall|p: int, q: int| i <= p < q < j ==> a[p] >= a[q],\n    ensures \n        i <= k <= j,\n        forall|r: int| i <= r < k ==> a[r] >= x,\n        forall|r: int| k <= r < j ==> a[r] < x,\n    decreases j - i\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    i\n}\n// </vc-code>", "vc-postamble": "fn main() {\n    // Ef eftirfarandi fall er ekki samþykkt þá eru\n    // föllin ekki að haga sér rétt að mati Verus.\n}\n\n}"}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBinarySearch_search", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sorted(s: Seq<int>) -> bool {\n    forall|u: int, w: int| 0 <= u < w < s.len() ==> s[u] <= s[w]\n}\n\nfn binary_search(v: &[int], elem: int) -> (p: i32)\n    requires sorted(v@)\n    ensures \n        -1 <= p < v@.len() &&\n        (forall|u: int| 0 <= u <= p ==> v@[u] <= elem) &&\n        (forall|w: int| p < w < v@.len() ==> v@[w] > elem)\n{\n    assume(false);\n    -1\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn search(v: &[int], elem: int) -> (b: bool)\n    requires sorted(v@)\n    ensures b == v@.contains(elem)\n    //Implement by calling binary search function\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    false\n}\n// </vc-code>", "vc-postamble": "fn main() {\n    //Recursive binary search\n}\n\n}"}
{"id": "Clover_all_digits_allDigits", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn all_digits(s: &str) -> (result: bool)\n    ensures result <==> (forall|i: int| 0 <= i < s@.len() ==> {\n        let c = #[trigger] s@.index(i);\n        c == '0' || c == '1' || c == '2' || c == '3' || c == '4' || \n        c == '5' || c == '6' || c == '7' || c == '8' || c == '9'\n    })\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    false\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "Clover_abs_Abs", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nproof fn abs(x: int) -> (y: int)\n    ensures \n        x >= 0 ==> x == y,\n        x < 0 ==> x + y == 0,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_790_IsEvenAtIndexEven", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_even(n: int) -> bool {\n    n % 2 == 0\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn is_even_at_index_even(lst: &Vec<i32>) -> (result: bool)\n    ensures result <==> (forall|i: int| 0 <= i < lst.len() ==> (is_even(i) ==> is_even(lst[i] as int)))\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    true\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_807_FindFirstOdd", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_odd(x: int) -> bool {\n    x % 2 != 0\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn find_first_odd(a: &[i32]) -> (result: (bool, usize))\n    ensures \n        (!result.0 ==> (forall|i: int| 0 <= i < a.len() ==> !is_odd(a[i] as int))) &&\n        (result.0 ==> (0 <= result.1 < a.len() && \n                      is_odd(a[result.1 as int] as int) && \n                      (forall|i: int| 0 <= i < result.1 ==> !is_odd(a[i] as int))))\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  (false, 0)\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "formal-verification_tmp_tmpoepcssay_strings3_haveCommonKSubstring", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nfn isPrefix(pre: Seq<char>, str: Seq<char>) -> (res: bool)\n    ensures\n        !res <==> isNotPrefixPred(pre, str),\n        res <==> isPrefixPred(pre, str),\n{\n    assume(false);\n    true\n}\n\n\n\nspec fn isPrefixPred(pre: Seq<char>, str: Seq<char>) -> bool {\n    (pre.len() <= str.len()) && \n    pre == str.subrange(0, pre.len() as int)\n}\n\nspec fn isNotPrefixPred(pre: Seq<char>, str: Seq<char>) -> bool {\n    (pre.len() > str.len()) || \n    pre != str.subrange(0, pre.len() as int)\n}\n\nspec fn isSubstringPred(sub: Seq<char>, str: Seq<char>) -> bool {\n    exists|i: int| 0 <= i <= str.len() && isPrefixPred(sub, str.subrange(i, str.len() as int))\n}\n\nspec fn isNotSubstringPred(sub: Seq<char>, str: Seq<char>) -> bool {\n    forall|i: int| 0 <= i <= str.len() ==> isNotPrefixPred(sub, str.subrange(i, str.len() as int))\n}\n\nfn isSubstring(sub: Seq<char>, str: Seq<char>) -> (res: bool)\n    ensures\n        res <==> isSubstringPred(sub, str),\n        res ==> isSubstringPred(sub, str),\n        // ensures  !res ==> !isSubstringPred(sub, str)\n        isSubstringPred(sub, str) ==> res,\n        isSubstringPred(sub, str) ==> res,\n        !res <==> isNotSubstringPred(sub, str), // This postcondition follows from the above lemma.\n{\n    assume(false);\n    true\n}\n\n\n\nspec fn haveCommonKSubstringPred(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool {\n    exists|i1: int, j1: int| 0 <= i1 <= str1.len() - k && j1 == i1 + k && isSubstringPred(str1.subrange(i1, j1), str2)\n}\n\nspec fn haveNotCommonKSubstringPred(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool {\n    forall|i1: int, j1: int| 0 <= i1 <= str1.len() - k && j1 == i1 + k ==> isNotSubstringPred(str1.subrange(i1, j1), str2)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn haveCommonKSubstring(k: nat, str1: Seq<char>, str2: Seq<char>) -> (found: bool)\n    ensures\n        found <==> haveCommonKSubstringPred(k, str1, str2),\n        !found <==> haveNotCommonKSubstringPred(k, str1, str2), // This postcondition follows from the above lemma.\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    true\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "MIEIC_mfes_tmp_tmpq3ho7nve_exams_mt2_19_p5_partition", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\ntype T = int; // example\n\n // Partitions a nonempty array 'a', by reordering the elements in the array,\n// so that elements smaller than a chosen pivot are placed to the left of the\n// pivot, and values greater or equal than the pivot are placed to the right of \n// the pivot. Returns the pivot position.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn partition(a: &mut Vec<T>) -> (pivotPos: usize)\n    requires \n        old(a).len() > 0,\n    ensures \n        pivotPos < a.len(),\n        forall|i: int| 0 <= i < pivotPos ==> a[i] < a[pivotPos as int],\n        forall|i: int| pivotPos < i < a.len() ==> a[i] >= a[pivotPos as int],\n        a@.to_multiset() == old(a)@.to_multiset(),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Clover_linear_search1_LinearSearch", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn linear_search(a: &[i32], e: i32) -> (n: usize)\n    ensures \n        n <= a.len(),\n        n == a.len() || a[n as int] == e,\n        forall|i: int| 0 <= i < n ==> e != a[i],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "veri-sparse_tmp_tmp15fywna6_dafny_spmv_SpMV", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sum(X_val: Seq<int>, X_crd: Seq<nat>, v: Seq<int>, b: int, k: int) -> int\n    decreases k - b\n{\n    if k <= b {\n        0\n    } else {\n        sum(X_val, X_crd, v, b + 1, k) + X_val[b] * v[X_crd[b] as int]\n    }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn SpMV(X_val: &[int], X_crd: &[nat], X_pos: &[nat], v: &[int]) -> (y: Vec<int>)\n    requires \n        X_crd.len() >= 1,\n        X_crd.len() == X_val.len(),\n        forall|i: int, j: int| 0 <= i < j < X_pos.len() ==> X_pos[i] <= X_pos[j],\n        forall|i: int| 0 <= i < X_crd.len() ==> X_crd[i] < v.len(),\n        forall|i: int| 0 <= i < X_pos.len() ==> X_pos[i] <= X_val.len(),\n        X_pos.len() >= 1,\n    ensures\n        y.len() + 1 == X_pos.len(),\n        forall|i: int| 0 <= i < y.len() ==> y[i] == sum(X_val@, X_crd@, v@, X_pos[i] as int, X_pos[i + 1] as int),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>", "vc-postamble": "// 0 0 0 0 0 0 1 0\n// 0 0 0 0 0 0 0 0\n// 0 0 0 0 1 0 0 0\n// 0 0 0 0 0 0 0 0\n// 0 0 1 0 0 0 0 0\n// 0 0 0 0 0 0 0 0\n// 1 0 0 0 0 0 0 0\n// 0 0 0 0 0 0 0 0\n\nfn main() {\n}\n\n}"}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBubbleSort_bubbleSort", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sorted_seg(a: Seq<int>, i: int, j: int) -> bool\n    recommends 0 <= i <= j <= a.len()\n{\n    forall|l: int, k: int| i <= l <= k < j ==> a[l] <= a[k]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn bubble_sort(a: &mut Vec<int>, c: usize, f: usize)\n    requires \n        0 <= c <= f <= old(a).len(),\n    ensures \n        sorted_seg(a@, c as int, f as int),\n        a@.subrange(c as int, f as int).to_multiset() == old(a)@.subrange(c as int, f as int).to_multiset(),\n        a@.subrange(0, c as int) == old(a)@.subrange(0, c as int),\n        a@.subrange(f as int, a@.len() as int) == old(a)@.subrange(f as int, old(a)@.len() as int),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session9Exercises_ExerciseSeqMaxSum_segMaxSum", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sum(v: Seq<int>, i: int, j: int) -> int\n    recommends 0 <= i <= j <= v.len()\n    decreases j when 0 <= i <= j <= v.len()\n{\n    if i == j {\n        0 as int\n    } else {\n        sum(v, i, (j-1) as int) + v[(j-1) as int]\n    }\n}\n\nspec fn sum_max_to_right(v: Seq<int>, i: int, s: int) -> bool\n    recommends 0 <= i < v.len()\n{\n    forall|l: int, ss: int| 0 <= l <= i && ss == i + 1 ==> sum(v, l, ss) <= s\n}\n\nspec fn sum2(v: Seq<int>, i: int, j: int) -> int\n    recommends 0 <= i <= j <= v.len()\n    decreases j - i when 0 <= i <= j <= v.len()\n{\n    if i == j {\n        0 as int\n    } else {\n        v[i as int] + sum2(v, (i+1) as int, j)\n    }\n}\n\nspec fn sum_max_to_right2(v: Seq<int>, j: int, i: int, s: int) -> bool\n    recommends 0 <= j <= i < v.len()\n{\n    forall|l: int, ss: int| j <= l <= i && ss == i + 1 ==> sum2(v, l, ss) <= s\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn seg_max_sum(v: &[i32], i: usize) -> (i32, usize)\n    requires v.len() > 0 && i < v.len()\n    ensures |result: (i32, usize)|\n        result.1 <= i && \n        result.0 == sum(v@.map_values(|x: i32| x as int), result.1 as int, (i+1) as int) &&\n        sum_max_to_right(v@.map_values(|x: i32| x as int), i as int, result.0 as int)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    (0i32, 0)\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_07_Hoangkim_ex07_Hoangkim_FindMin", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n//Problem01\n//a)\n\n//b)\n//Problem04\n\n//Problem02\nspec fn sorted(a: Seq<int>) -> bool {\n    forall|i: int| 1 <= i < a.len() ==> #[trigger] a[i] >= a[i-1]\n}\n\n\n\n//Problem03", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn find_min(a: &[int], lo: usize) -> (minIdx: usize)\n    requires \n        a.len() > 0,\n        lo < a.len(),\n    ensures \n        lo <= minIdx < a.len(),\n        forall|x: int| lo <= x < a.len() ==> a[minIdx as int] <= a[x],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    lo // unreachable but needed for type checking\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "formal-verification_tmp_tmpoepcssay_strings3_isSubstring", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_prefix_pred(pre: Seq<char>, str: Seq<char>) -> bool {\n    pre.len() <= str.len() && \n    pre == str.subrange(0, pre.len() as int)\n}\n\nspec fn is_not_prefix_pred(pre: Seq<char>, str: Seq<char>) -> bool {\n    pre.len() > str.len() || \n    pre != str.subrange(0, pre.len() as int)\n}\n\nfn is_prefix(pre: Seq<char>, str: Seq<char>) -> (res: bool)\n    ensures\n        !res <==> is_not_prefix_pred(pre, str),\n        res <==> is_prefix_pred(pre, str),\n{\n    assume(false);\n    true\n}\n\nspec fn is_substring_pred(sub: Seq<char>, str: Seq<char>) -> bool {\n    exists|i: int| 0 <= i <= str.len() && is_prefix_pred(sub, str.subrange(i, str.len() as int))\n}\n\nspec fn is_not_substring_pred(sub: Seq<char>, str: Seq<char>) -> bool {\n    forall|i: int| 0 <= i <= str.len() ==> is_not_prefix_pred(sub, str.subrange(i, str.len() as int))\n}\n\nspec fn have_common_k_substring_pred(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool {\n    exists|i1: int, j1: int| 0 <= i1 <= str1.len() as int - k as int && j1 == i1 + k as int && is_substring_pred(str1.subrange(i1, j1), str2)\n}\n\nspec fn have_not_common_k_substring_pred(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool {\n    forall|i1: int, j1: int| 0 <= i1 <= str1.len() as int - k as int && j1 == i1 + k as int ==> is_not_substring_pred(str1.subrange(i1, j1), str2)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn is_substring(sub: Seq<char>, str: Seq<char>) -> (res: bool)\n    ensures\n        res <==> is_substring_pred(sub, str),\n        res ==> is_substring_pred(sub, str),\n        // ensures  !res ==> !is_substring_pred(sub, str)\n        is_substring_pred(sub, str) ==> res,\n        is_substring_pred(sub, str) ==> res,\n        !res <==> is_not_substring_pred(sub, str), // This postcondition follows from the above lemma.\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    true\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "CVS-Projto1_tmp_tmpb1o0bu8z_proj1_proj1_queryFast", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// Exercise 1.a)\nspec fn sum(a: Seq<int>, i: int, j: int) -> int\n    decreases j - i\n{\n    if i == j {\n        0\n    } else if i < j && j-1 < a.len() {\n        a[j-1] + sum(a, i, j-1)\n    } else {\n        0  // default case\n    }\n}\n\n// Exercise 1.b)\n\n// Exercise 1.c)\n\nspec fn is_prefix_sum_for(a: Seq<int>, c: Seq<int>) -> bool {\n    a.len() + 1 == c.len()\n    && c[0] == 0\n    && forall |j: int| #![auto] 1 <= j <= a.len() ==> c[j] == sum(a, 0, j)\n}\n\n// Exercise 2.\npub enum List<T> {\n    Nil,\n    Cons { head: T, tail: Box<List<T>> }\n}\n\nfn from_array<T: Copy + PartialEq>(a: &Vec<T>) -> (l: List<T>)\n    requires a.len() > 0\n    ensures forall |j: int| #![auto] 0 <= j < a.len() ==> mem(a@[j], &l)\n{\n    assume(false);\n    List::Nil\n}\n\nspec fn mem<T: PartialEq>(x: T, l: &List<T>) -> bool\n    decreases l\n{\n    match l {\n        List::Nil => false,\n        List::Cons { head: y, tail: r } => if x == *y { true } else { mem(x, r) }\n    }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nproof fn query_fast(a: Seq<int>, c: Seq<int>, i: int, j: int) -> (r: int)\n    requires \n        is_prefix_sum_for(a, c) && 0 <= i <= j <= a.len() < c.len()\n    ensures r == sum(a, i, j)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "Clover_array_product_arrayProduct", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn array_product(a: &[i32], b: &[i32]) -> (c: Vec<i32>)\n    requires \n        a.len() == b.len(),\n    ensures \n        c.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> a[i] * b[i] == c[i],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "dafny_misc_tmp_tmpg4vzlnm1_rosetta_code_fibonacci_sequence_FibonacciIterative", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// definition of Fibonacci numbers\nspec fn fibonacci(n: nat) -> nat\n    decreases n\n{\n    if n == 0 {\n        0\n    } else if n == 1 {\n        1\n    } else {\n        fibonacci((n - 1) as nat) + fibonacci((n - 2) as nat)\n    }\n}\n\n// iterative calculation of Fibonacci numbers", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn fibonacci_iterative(n: u64) -> (f: u64)\n    requires n < 100  // practical bound to prevent overflow\n    ensures f == fibonacci(n as nat)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session8Exercises_ExerciseInsertionSort_InsertionSort", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sorted_seg(a: &Vec<i32>, i: int, j: int) -> bool\n    recommends 0 <= i <= j + 1 <= a.len()\n{\n    forall|l: int, k: int| i <= l <= k <= j ==> a[l] <= a[k]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn insertion_sort(a: &mut Vec<i32>)\n    ensures \n        sorted_seg(a, 0, (a.len() - 1) as int),\n        a@.to_multiset() == old(a)@.to_multiset(), //Add and prove this\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session5Exercises_ExerciseSumElems_sumElems", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sum_r(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        sum_r(s.subrange(0, s.len() - 1)) + s[s.len() - 1]\n    }\n}\n\nspec fn sum_l(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s[0] + sum_l(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn sum_v(v: Seq<int>, c: int, f: int) -> int {\n    if 0 <= c <= f <= v.len() {\n        sum_r(v.subrange(c, f))\n    } else {\n        0\n    }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn sum_elems(v: &[i32]) -> (sum: i32)\n//ensures sum as int == sum_l(v@.map(|i, x| x as int))\nensures sum as int == sum_r(v@.map(|i, x| x as int))\n//ensures sum as int == sum_v(v@.map(|i, x| x as int), 0, v@.len())\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  0\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_242_CountCharacters", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn count_characters(s: Seq<char>) -> (count: usize)\n    ensures \n        count >= 0,\n        count == s.len(),\n{\n// </vc-spec>", "vc-code": "// <vc-code>\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "Formal-Verification-Project_tmp_tmp9gmwsmyp_strings3_haveCommonKSubstring", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nfn is_prefix(pre: Seq<char>, str: Seq<char>) -> (res: bool)\n    ensures\n        !res <==> is_not_prefix_pred(pre, str),\n        res <==> is_prefix_pred(pre, str),\n{\n    assume(false);\n    false\n}\n\n\n\nspec fn is_prefix_pred(pre: Seq<char>, str: Seq<char>) -> bool {\n    pre.len() <= str.len() && \n    pre == str.subrange(0, pre.len() as int)\n}\n\nspec fn is_not_prefix_pred(pre: Seq<char>, str: Seq<char>) -> bool {\n    pre.len() > str.len() || \n    pre != str.subrange(0, pre.len() as int)\n}\n\nspec fn is_substring_pred(sub: Seq<char>, str: Seq<char>) -> bool {\n    exists|i: int| 0 <= i <= str.len() && is_prefix_pred(sub, str.subrange(i, str.len() as int))\n}\n\nspec fn is_not_substring_pred(sub: Seq<char>, str: Seq<char>) -> bool {\n    forall|i: int| 0 <= i <= str.len() ==> is_not_prefix_pred(sub, str.subrange(i, str.len() as int))\n}\n\nfn is_substring(sub: Seq<char>, str: Seq<char>) -> (res: bool)\n    ensures\n        res <==> is_substring_pred(sub, str),\n        //!res <==> is_not_substring_pred(sub, str), // This postcondition follows from the above lemma.\n{\n    assume(false);\n    false\n}\n\n\nspec fn have_common_k_substring_pred(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool {\n    exists|i1: int, j1: int| \n        0 <= i1 <= str1.len() - k && \n        j1 == i1 + k && \n        is_substring_pred(str1.subrange(i1, j1), str2)\n}\n\nspec fn have_not_common_k_substring_pred(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool {\n    forall|i1: int, j1: int| \n        0 <= i1 <= str1.len() - k && \n        j1 == i1 + k ==> \n        is_not_substring_pred(str1.subrange(i1, j1), str2)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn have_common_k_substring(k: nat, str1: Seq<char>, str2: Seq<char>) -> (found: bool)\n    ensures\n        found <==> have_common_k_substring_pred(k, str1, str2),\n        //!found <==> have_not_common_k_substring_pred(k, str1, str2), // This postcondition follows from the above lemma.\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    false\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 3_InsertionSortMultiset_Sort", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\nuse vstd::multiset::*;\n\nverus! {\n\n// Höfundur spurningar:  Snorri Agnarsson, snorri@hi.is\n// Permalink spurningar: https://rise4fun.com/Dafny/G4sc3\n\n// Höfundur lausnar:     Alexander Guðmundsson\n// Permalink lausnar:    https://rise4fun.com/Dafny/nujsu\n\n// Insertion sort með hjálp helmingunarleitar.\n\n\nproof fn search(s: Seq<i32>, x: i32) -> (k: usize)\n    // Ekki má breyta forskilyrðum eða eftirskilyrðum fallsins\n    requires \n        forall|p: int, q: int| 0 <= p < q < s.len() ==> s[p] <= s[q],\n    ensures \n        0 <= k <= s.len()\n        && forall|i: int| 0 <= i < k ==> s[i] <= x\n        && forall|i: int| k <= i < s.len() ==> s[i] >= x\n        && forall|z: i32| s.subrange(0, k as int).contains(z) ==> z <= x\n        && forall|z: i32| s.subrange(k as int, s.len() as int).contains(z) ==> z >= x\n        && s == s.subrange(0, k as int) + s.subrange(k as int, s.len() as int),\n{\n  assume(false);\n  0\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nproof fn sort(m: Multiset<i32>) -> (r: Seq<i32>)\n    ensures \n        r.to_multiset() == m\n        && forall|p: int, q: int| 0 <= p < q < r.len() ==> r[p] <= r[q],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  seq![]\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_227_MinOfThree", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn min_of_three(a: i32, b: i32, c: i32) -> (min: i32)\n    ensures\n        min <= a && min <= b && min <= c,\n        (min == a) || (min == b) || (min == c),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  0\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_ProgramProofs_ch15_QuickSortAux", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn split_point(a: Seq<int>, n: int) -> bool {\n    forall|i: int, j: int| 0 <= i < n <= j < a.len() ==> a[i] <= a[j]\n}\n\nspec fn swap_frame(a_old: Seq<int>, a_new: Seq<int>, lo: int, hi: int) -> bool\n    recommends 0 <= lo <= hi <= a_old.len() && a_old.len() == a_new.len()\n{\n    (forall|i: int| (0 <= i < lo || hi <= i < a_new.len()) ==> a_new[i] == a_old[i]) \n    && a_new.to_multiset() =~= a_old.to_multiset()\n}\n\nfn partition(a: &mut Vec<int>, lo: usize, hi: usize) -> (p: usize)\n    requires \n        0 <= lo < hi <= old(a).len(),\n        split_point(old(a)@, lo as int) && split_point(old(a)@, hi as int),\n    ensures\n        lo <= p < hi,\n        forall|i: int| lo <= i < p ==> a@[i] < a@[p as int],\n        forall|i: int| p <= i < hi ==> a@[p as int] <= a@[i],\n        split_point(a@, lo as int) && split_point(a@, hi as int),\n        swap_frame(old(a)@, a@, lo as int, hi as int),\n{\n    assume(false);\n    lo // dummy return\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn quick_sort_aux(a: &mut Vec<int>, lo: usize, hi: usize)\n    requires \n        0 <= lo <= hi <= old(a).len(),\n        split_point(old(a)@, lo as int) && split_point(old(a)@, hi as int),\n    ensures\n        forall|i: int, j: int| lo <= i < j < hi ==> a@[i] <= a@[j],\n        swap_frame(old(a)@, a@, lo as int, hi as int),\n        split_point(a@, lo as int) && split_point(a@, hi as int),\n    decreases hi - lo\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "dafny-duck_tmp_tmplawbgxjo_ex3_BadSort", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// program verifies\n\nspec fn sortedbad(s: Seq<char>) -> bool {\n    // no b's after non-b's\n    (forall|i: int, j: int| 0 <= i <= j < s.len() && s[i] == 'b' && s[j] != 'b' ==> i < j) &&\n    // only non-d's before d's\n    (forall|i: int, j: int| 0 <= i <= j < s.len() && s[i] != 'd' && s[j] == 'd' ==> i < j)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn bad_sort(a: Seq<char>) -> (b: Seq<char>)\n    requires \n        forall|i: int| 0 <= i < a.len() ==> a[i] == 'b' || a[i] == 'a' || a[i] == 'd',\n    ensures \n        sortedbad(b) && b.to_multiset() == a.to_multiset(),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    a\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "BinarySearchTree_tmp_tmp_bn2twp5_bst4copy_insertRecursion", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\npub enum Tree {\n    Empty,\n    Node { left: Box<Tree>, value: int, right: Box<Tree> },\n}\n\npub open spec fn binary_search_tree(tree: Tree) -> bool\n    decreases tree\n{\n    match tree {\n        Tree::Empty => true,\n        Tree::Node { left, value, right } => {\n            (left.is_Empty() || left.get_Node_value() < value)\n            && (right.is_Empty() || right.get_Node_value() > value)\n            && binary_search_tree(*left) && binary_search_tree(*right)\n            && min_value(*right, value) && max_value(*left, value)\n        }\n    }\n}\n\npub open spec fn max_value(tree: Tree, max: int) -> bool\n    decreases tree\n{\n    match tree {\n        Tree::Empty => true,\n        Tree::Node { left, value: v, right } => {\n            (max > v) && max_value(*left, max) && max_value(*right, max)\n        }\n    }\n}\n\npub open spec fn min_value(tree: Tree, min: int) -> bool\n    decreases tree\n{\n    match tree {\n        Tree::Empty => true,\n        Tree::Node { left, value: v, right } => {\n            (min < v) && min_value(*left, min) && min_value(*right, min)\n        }\n    }\n}\n\nimpl Tree {\n    pub open spec fn is_Empty(&self) -> bool {\n        matches!(*self, Tree::Empty)\n    }\n\n    pub open spec fn get_Node_value(&self) -> int {\n        match self {\n            Tree::Node { value, .. } => *value,\n            _ => arbitrary(),\n        }\n    }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn insert_recursion(tree: Tree, value: int) -> (res: Tree)\n    requires binary_search_tree(tree),\n    decreases tree,\n    ensures res != Tree::Empty ==> binary_search_tree(res),\n    ensures forall|x: int| min_value(tree, x) && x < value ==> min_value(res, x),\n    ensures forall|x: int| max_value(tree, x) && x > value ==> max_value(res, x),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    Tree::Empty\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session6Exercises_ExerciseCountEven_mcountEven", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn positive(s: Seq<int>) -> bool {\n    forall|u: int| 0 <= u < s.len() ==> s[u] >= 0\n}\n\nspec fn is_even(i: int) -> bool\n    recommends i >= 0\n{\n    i % 2 == 0\n}\n\nspec fn count_even(s: Seq<int>) -> int\n    recommends positive(s)\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0 as int\n    } else {\n        (if s[s.len() - 1] % 2 == 0 { 1 as int } else { 0 as int }) + count_even(s.subrange(0, s.len() - 1))\n    }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn mcount_even(v: &Vec<i32>) -> (n: i32)\n    requires positive(v@.map(|i: int, x: i32| x as int))\n    ensures n as int == count_even(v@.map(|i: int, x: i32| x as int))\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "AssertivePrograming_tmp_tmpwf43uz0e_DivMode_Unary_IterativeDivMod", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// Noa Leron 207131871  \n// Tsuri Farhana 315016907\n\n\n// definitions borrowed from Rustan Leino's Program Proofs Chapter 7\n// (https://program-proofs.com/code.html example code in Dafny; source file 7-Unary.dfy)\npub enum Unary {\n    Zero,\n    Suc(Box<Unary>),\n}\n\npub open spec fn unary_to_nat(x: Unary) -> nat \n    decreases x\n{\n    match x {\n        Unary::Zero => 0nat,\n        Unary::Suc(x_prime) => 1nat + unary_to_nat(*x_prime),\n    }\n}\n\npub open spec fn nat_to_unary(n: nat) -> Unary \n    decreases n\n{\n    if n == 0 {\n        Unary::Zero\n    } else {\n        Unary::Suc(Box::new(nat_to_unary((n - 1) as nat)))\n    }\n}\n\npub open spec fn less(x: Unary, y: Unary) -> bool \n    decreases x, y\n{\n    match y {\n        Unary::Zero => false,\n        Unary::Suc(y_pred) => match x {\n            Unary::Zero => true,\n            Unary::Suc(x_pred) => less(*x_pred, *y_pred),\n        }\n    }\n}\n\npub open spec fn less_alt(x: Unary, y: Unary) -> bool \n    decreases x, y\n{\n    match y {\n        Unary::Zero => false,\n        Unary::Suc(y_pred) => match x {\n            Unary::Zero => true,\n            Unary::Suc(x_pred) => less(*x_pred, *y_pred),\n        }\n    }\n}\n\npub open spec fn add(x: Unary, y: Unary) -> Unary \n    decreases y\n{\n    match y {\n        Unary::Zero => x,\n        Unary::Suc(y_prime) => Unary::Suc(Box::new(add(x, *y_prime))),\n    }\n}\n\npub open spec fn sub(x: Unary, y: Unary) -> Unary \n    decreases y\n{\n    if less(x, y) {\n        arbitrary()\n    } else {\n        match y {\n            Unary::Zero => x,\n            Unary::Suc(y_prime) => match x {\n                Unary::Zero => arbitrary(),\n                Unary::Suc(x_pred) => sub(*x_pred, *y_prime),\n            }\n        }\n    }\n}\n\npub open spec fn mul(x: Unary, y: Unary) -> Unary \n    decreases x\n{\n    match x {\n        Unary::Zero => Unary::Zero,\n        Unary::Suc(x_prime) => add(mul(*x_prime, y), y),\n    }\n}\n\n/*\nGoal: implement correcly and clearly, using iterative code (no recursion), documenting the proof obligations\n    as we've learned, with assertions and a lemma for each proof goal\n\n- DO NOT modify the specification or any of the definitions given in this file\n- Not all definitions above are relevant, some are simply included as examples\n- Feel free to use existing non-ghost functions/predicates in your code, and existing lemmas (for the proof) in your annotations\n- New functions/predicates may be added ONLY as ghost\n- If it helps you in any way, a recursive implementation + proof can be found in the book and the downloadable source file\n  [https://program-proofs.com/code.html example code in Dafny, source file 7-Unary.dfy]\n*/\n\nfn iterative_div_mod_prime(x: Unary, y: Unary) -> (res: (Unary, Unary))\n    requires y != Unary::Zero\n    ensures add(mul(res.0, y), res.1) == x && less(res.1, y)\n{\n    assume(false);\n    (Unary::Zero, Unary::Zero)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn iterative_div_mod(x: Unary, y: Unary) -> (res: (Unary, Unary))\n    requires y != Unary::Zero\n    ensures add(mul(res.0, y), res.1) == x && less(res.1, y)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    (Unary::Zero, Unary::Zero)\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "SENG2011_tmp_tmpgk5jq85q_ass2_ex3_BadSort", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// verifies\n// all bs are before all as which are before all ds\n\nspec fn sortedbad(s: Seq<char>) -> bool {\n    // all b's are before all a's and d's\n    (forall|i: int, j: int| 0 <= i < s.len() && 0 <= j < s.len() && s[i] == 'b' && (s[j] == 'a' || s[j] == 'd') ==> i < j) &&\n    // all a's are after all b's\n    (forall|i: int, j: int| 0 <= i < s.len() && 0 <= j < s.len() && s[i] == 'a' && s[j] == 'b' ==> i > j) &&\n    // all a's are before all d's\n    (forall|i: int, j: int| 0 <= i < s.len() && 0 <= j < s.len() && s[i] == 'a' && s[j] == 'd' ==> i < j) &&\n    // all d's are after all b's and a's\n    (forall|i: int, j: int| 0 <= i < s.len() && 0 <= j < s.len() && s[i] == 'd' && (s[j] == 'a' || s[j] == 'b') ==> i > j)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn bad_sort(a: Vec<char>) -> (b: Vec<char>)\n    requires\n        forall|k: int| 0 <= k < a.len() ==> a[k] == 'b' || a[k] == 'a' || a[k] == 'd',\n    ensures\n        sortedbad(b@),\n        a@.to_multiset() =~= b@.to_multiset(),\n        a.len() == b.len(),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_637_IsBreakEven", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nexec fn is_break_even(cost_price: int, selling_price: int) -> (result: bool)\n    requires cost_price >= 0 && selling_price >= 0,\n    ensures result <==> (cost_price == selling_price),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings1_haveCommonKSubstring", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_not_prefix_pred(pre: Seq<char>, str: Seq<char>) -> bool {\n    (pre.len() > str.len()) || \n    pre != str.subrange(0, pre.len() as int)\n}\n\n\nfn is_prefix(pre: Seq<char>, str: Seq<char>) -> (res: bool)\n    ensures\n        !res <==> is_not_prefix_pred(pre, str),\n        res <==> is_prefix_predicate(pre, str),\n{\n  assume(false);\n  false\n}\n\n\n\nspec fn is_prefix_predicate(pre: Seq<char>, str: Seq<char>) -> bool {\n  str.len() >= pre.len() && pre == str.subrange(0, pre.len() as int)\n}\n\n\nspec fn is_substring_predicate(sub: Seq<char>, str: Seq<char>) -> bool {\n  str.len() >= sub.len() && \n  exists|i: int| 0 <= i <= str.len() && #[trigger] is_prefix_predicate(sub, str.subrange(i, str.len() as int))\n}\n\nfn is_substring(sub: Seq<char>, str: Seq<char>) -> (res: bool)\n    ensures res == is_substring_predicate(sub, str)\n{\n  assume(false);\n  false\n}\n\nspec fn have_common_k_substring_predicate(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool {\n  str1.len() >= k && str2.len() >= k && \n  exists|i: int| 0 <= i <= str1.len() - k && \n      #[trigger] is_substring_predicate(\n          str1.subrange(i, str1.len() as int).subrange(0, k as int), \n          str2\n      )\n}\n\nspec fn max_common_substring_predicate(str1: Seq<char>, str2: Seq<char>, len: nat) -> bool {\n   forall|k: int| len < k <= str1.len() ==> !#[trigger] have_common_k_substring_predicate(k as nat, str1, str2)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn have_common_k_substring(k: nat, str1: Seq<char>, str2: Seq<char>) -> (found: bool)\n    ensures \n        (str1.len() < k || str2.len() < k) ==> !found,\n        have_common_k_substring_predicate(k, str1, str2) == found,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  false\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_574_CylinderSurfaceArea", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn cylinder_surface_area(radius: u64, height: u64) -> (area: u64)\n    requires radius > 0 && height > 0\n    ensures area == 2 * radius * (radius + height)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "CVS-handout1_tmp_tmptm52no3k_1_queryFast", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/*                                      Cumulative Sums over Arrays                                        */\n\n/*\n    Daniel Cavalheiro   57869\n    Pedro Nunes         57854\n*/\n\n\n\n//(a)\n\nspec fn sum(a: Seq<int>, i: int, j: int) -> int\n    decreases j - i\n{\n    if i >= j { \n        0 \n    } else { \n        a[i] + sum(a, i + 1, j) \n    }\n}\n\n\n\n//(b)\n\n\n\n\n//(c)\n\nspec fn is_prefix_sum_for(a: Seq<int>, c: Seq<int>) -> bool\n{\n    &&& a.len() + 1 == c.len() \n    &&& c.len() > 0 \n    &&& c[0] == 0\n    &&& forall|i: int| 0 <= i < a.len() ==> c[i + 1] == c[i] + a[i]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn queryFast(a: &[i32], c: &[i32], i: i32, j: i32) -> (r: i32)\n    requires a.len() + 1 == c.len() && c.len() > 0 && c@[0] == 0,\n        0 <= i <= j <= a.len(),\n        is_prefix_sum_for(a@.map(|_i, x| x as int), c@.map(|_i, x| x as int))\n    ensures r as int == sum(a@.map(|_i, x| x as int), i as int, j as int)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_792_CountLists", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn count_lists(lists: &Vec<Vec<int>>) -> (count: usize)\n    ensures \n        count >= 0,\n        count == lists.len(),\n{\n// </vc-spec>", "vc-code": "// <vc-code>\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_95_SmallestListLength", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn smallest_list_length(s: Seq<Seq<int>>) -> (v: int)\n    requires\n        s.len() > 0,\n    ensures\n        forall|i: int| 0 <= i < s.len() ==> v <= s[i].len(),\n        exists|i: int| 0 <= i < s.len() && v == #[trigger] s[i].len(),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    proof { assume(false); }\n    unreached()\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "AssertivePrograming_tmp_tmpwf43uz0e_MergeSort_MergeSort", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// Noa Leron 207131871\n// Tsuri Farhana 315016907\n\n\n\nspec fn sorted(q: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i <= j < q.len() ==> q[i] <= q[j]\n}\n\n/*\nGoal: Implement the well known merge sort algorithm in O(a.Length X log_2(a.Length)) time, recursively.\n\n- Divide the contents of the original array into two local arrays\n- After sorting the local arrays (recursively), merge the contents of the two returned arrays using the Merge method (see below)\n- DO NOT modify the specification or any other part of the method's signature\n- DO NOT introduce any further methods\n*/\n\nspec fn inv(a: Seq<int>, a1: Seq<int>, a2: Seq<int>, i: nat, mid: nat) -> bool {\n    (i <= a1.len()) && (i <= a2.len()) && (i + mid <= a.len()) &&\n    (a1.subrange(0, i as int) =~= a.subrange(0, i as int)) && \n    (a2.subrange(0, i as int) =~= a.subrange(mid as int, (i + mid) as int))\n}\n\n/*\nGoal: Implement iteratively, correctly, efficiently, clearly\n\nDO NOT modify the specification or any other part of the method's signature\n*/\nfn merge(b: &mut Vec<int>, c: &Vec<int>, d: &Vec<int>)\n    requires\n        old(b).len() == c.len() + d.len(),\n        sorted(c@),\n        sorted(d@),\n    ensures\n        sorted(b@),\n        b@.to_multiset() == c@.to_multiset().add(d@.to_multiset()),\n{\n  assume(false);\n}\n\n\n//This is a method that replace the loop body\n\n\n//Loop invariant - b is sorted so far and the next two potential values that will go into b are bigger then the biggest value in b.\nspec fn inv_sorted(b: Seq<int>, c: Seq<int>, d: Seq<int>, i: nat, j: nat) -> bool {\n    i <= c.len() && j <= d.len() && i + j <= b.len() &&\n    ((i + j > 0 && i < c.len()) ==> (b[(j + i - 1) as int] <= c[i as int])) &&\n    ((i + j > 0 && j < d.len()) ==> (b[(j + i - 1) as int] <= d[j as int])) &&\n    sorted(b.subrange(0, (i + j) as int))\n    }\n\n\n//Loop invariant - the multiset of the prefix of b so far is the same multiset as the prefixes of c and d so far.\nspec fn inv_sub_set(b: Seq<int>, c: Seq<int>, d: Seq<int>, i: nat, j: nat) -> bool {\n    i <= c.len() && j <= d.len() && i + j <= b.len() &&\n    b.subrange(0, (i + j) as int).to_multiset() == \n        c.subrange(0, i as int).to_multiset().add(d.subrange(0, j as int).to_multiset())\n}\n\n//This lemma helps verus see that if the prefixes of arrays are the same multiset until the end of the arrays,\n//all the arrays are the same multiset.\n\n\n//This lemma helps verus see that after adding the next value from c to b the prefixes are still the same subsets.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn merge_sort(a: Vec<int>) -> (b: Vec<int>)\n    ensures\n        b.len() == a.len(),\n        sorted(b@),\n        a@.to_multiset() == b@.to_multiset(),\n    decreases a.len()\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  a\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_94_MinSecondValueFirst", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn min_second_value_first(s: &Vec<Vec<i32>>) -> (first_of_min_second: i32)\n    requires \n        s.len() > 0,\n        forall|i: int| 0 <= i < s.len() ==> s@[i].len() >= 2,\n    ensures \n        exists|i: int| 0 <= i < s.len() && first_of_min_second == s@[i]@[0] && \n            (forall|j: int| 0 <= j < s.len() ==> s@[i]@[1] <= s@[j]@[1]),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "Clover_min_array_minArray", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn min_array(a: &[i32]) -> (r: i32)\n    requires a.len() > 0,\n    ensures forall|i: int| 0 <= i < a.len() ==> r <= a[i],\n    // Note: Verus currently has syntax limitations with exists quantifiers in postconditions\n    // The second ensures clause from Dafny cannot be directly translated\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0 // unreachable due to assume(false)\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_579_DissimilarElements", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn in_array(a: &Vec<int>, x: int) -> bool {\n    exists|i: int| 0 <= i < a.len() && a[i] == x\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn dissimilar_elements(a: &Vec<int>, b: &Vec<int>) -> (result: Vec<int>)\n    ensures\n        // All elements in the output are either in a or b, but not in both or neither\n        forall|x: int| result@.contains(x) ==> (in_array(a, x) != in_array(b, x)),\n        // The elements in the output are all different\n        forall|i: int, j: int| 0 <= i < j < result.len() ==> result[i] != result[j],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "cs245-verification_tmp_tmp0h_nxhqp_quicksort-partition_QuicksortPartition", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// Quicksort Partition -- Stephanie McIntyre\n// Based on examples in class \n// Parts have been modified cause you know, arrays are different...\n\n/* The annotations and implied proofs are left for you.\n   I might do them later on next week. */", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn quicksort_partition(x: &mut Vec<i32>, n: usize, p: i32) -> (result: (usize, usize))\n/*Pre-Condition*/   requires old(x).len() >= 1, n == old(x).len();\n/*Post-Condition*/  ensures result.1 >= n;\n                    ensures forall|i: int| 0 <= i < (result.0 as int) && (result.0 as int) < (n as int) ==> x[i] <= p;\n                    ensures result.0 == n || (forall|i: int| (result.0 as int) <= i && i < (n as int) ==> x[i] > p);\n                    ensures x@.to_multiset() == old(x)@.to_multiset()           //This says the new X is a permutation of our old version of X.\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  (0, n)\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Exercise3_Increment_Array_incrementArray", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn increment_array(a: &mut Vec<i32>)\n  requires old(a).len() > 0,\n  ensures \n      a.len() == old(a).len(),\n      forall|i: int| 0 <= i < a.len() ==> a[i] == old(a)[i] + 1,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_10_Hoangkim_ex10_hoangkim_strange", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n//Problem01\n\n/*\n3 Verification conditions\n\n1. VC1: Precondiotion implies the loop variant\nn ∈ ℕ => sqn = 0*0 ∧ i = 0 ∧ x=? ∧ i≤n \nn >= 0 => 0 = 0*0 ∧ i = 0 ∧ i≤n \nn >= 0 => 0 = 0*0 ∧ 0 ≤ n \n2. VC2: Loop invariant and loop guard preserve the loop invariant.\nVC2: i < n ∧ i+1 ≤ n ∧ sqn = i * i ⇒ sqn = sqn + x ∧ i = i + 1 ∧ x = 2 * i + 1\n3.VC3: Loop terminates, and the loop invariant implies the postcondition.\nVC3: ¬(i < n) ∧ i ≤ n ∧ sqn = i * i ⇒ sqn = n * n\n\nSimplified VC for square0\n1. true, since 0 = 0 and n >= 0 => 0 ≤ n\n2. true, i < n => i + 1 <= n\n3. true, ¬(i < n) ∧ i ≤ n ∧ sqn = i * i ⇒ sqn = n * n since ¬(i < n) ∧ i ≤ n imply i = n\n\n*/\n\n\n//Problem02\n//As you can see below, Verus claims that after executing the following method\n//strange() we will have that 1=2;\nfn q(x: u32, y: u32) -> (z: u32)\n    requires y > x + 2\n    ensures x < z*z && z*z < y\n{\n    assume(false);\n    0\n}\n\n/*(a). Do you have an explanation for this behaviour?\n    Answer: \n    the method strange() doesn't have any input or output. This method initializes\n    variable x with value 4. Then it calculates variable c as a result of calling\n    method 'q' with x as first var and 2*x as second var.the strange method does not \n    specify any postcondition. Therefore, we cannot make any assumptions about the \n    behavior or the value of c after calling q.\n    We can change ensures in strange() to false and it's still verified\n*/\n\n/*(b)\n{\n  assume{:axiom} false;\n}var x:nat := 4; var c := q(x,2*x); {1 = 2 }\n    precond in strange(): difference between 'y' and 'x' muss be greater than 2,\n    square from 'z' will be a value  between 'x' and 'y'\n\n    apply the Hoare rules step by step:\n    1. {true} as a precondition\n    2. we assign 4 to 'x' and having {4=4}\n    3. assign value q(x, 2 * x) to c, substitute the postcondition of 'q' in place of 'c'\n        post cond of q will be x < z*z < 2*x. Replacing c we having {x < z * z < 2 * x}\n    4. we having the statement {x < z*z < 2*x} => {1 = 2} as postcondtion\n\n    as we know the statment {1 = 2} is always false. true => false is always false     \n\n\n\n*/\n\n//Problem 3\n//Use what you know about the weakest preconditions/strongest postconditions to ex-\n//plain why the following code verifies:\n\n/*\nWP: is a condition that, if satisfied before the execution of a program, guarantees the \nsatisfaction of a specified postcondition\nSP: is a condition that must hold after the execution of a program, assuming a specified \nprecondition\n\nThe strongest postcondition for assert is x<=9\nAnalyze the code: \nThe strongest postcondition for the assert statement assert x <= 9; is x <= 9. This \npostcondition asserts that the value of x should be less than or equal to 9 after the \nexecution of the program. To ensure this postcondition, we need to find a weakest precondition \n(WP) that guarantees x <= 9 after executing the code.\n\nThe \"assume\" statement introduces a precondition.\nIt assumes that the square of x is less than 100. In other words, it assumes that x is \nwithin the range (0, 10) since the largest possible square less than 100 is 9 * 9 = 81.\n\n\n*/", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn strange()\n    ensures 1==2\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "DafnyProjects_tmp_tmp2acw_s4s_CombNK_Comb", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* \n * Formal specification and verification of a dynamic programming algorithm for calculating C(n, k).\n * FEUP, MIEIC, MFES, 2020/21.\n */\n\n// Initial recursive definition of C(n, k), based on the Pascal equality.\nspec fn comb(n: nat, k: nat) -> nat\n    recommends 0 <= k <= n\n    decreases n\n    when n >= 1 && k >= 1\n{\n    if k == 0 || k == n { \n        1 \n    } else { \n        comb((n - 1) as nat, k) + comb((n - 1) as nat, (k - 1) as nat)\n    }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn Comb(n: u64, k: u64) -> (res: u64)\n    requires 0 <= k <= n\n    ensures res == comb(n as nat, k as nat)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "assertive-programming-assignment-1_tmp_tmp3h_cj44u_FindRange_FindRange", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sorted(q: Seq<int>) -> bool {\n    forall |i: int, j: int| 0 <= i <= j < q.len() ==> q[i] <= q[j]\n}\n\n// all the values in the range satisfy `comparer` (comparer(q[i], key) == true)\nspec fn range_satisfies_comparer(q: Seq<int>, key: int, lower_bound: int, upper_bound: int, comparer: spec_fn(int, int) -> bool) -> bool\n    recommends 0 <= lower_bound <= upper_bound <= q.len()\n{\n    forall |i: int| lower_bound <= i < upper_bound ==> comparer(q[i], key)\n}\n\n// all the values in the range satisfy `!comparer` (comparer(q[i], key) == false)\nspec fn range_satisfies_comparer_negation(q: Seq<int>, key: int, lower_bound: int, upper_bound: int, comparer: spec_fn(int, int) -> bool) -> bool\n    recommends 0 <= lower_bound <= upper_bound <= q.len()\n{\n    range_satisfies_comparer(q, key, lower_bound, upper_bound, |n1: int, n2: int| !comparer(n1, n2))\n}\n\nfn binary_search(q: Seq<int>, key: int, lower_bound: usize, upper_bound: usize, comparer: spec_fn(int, int) -> bool) -> (index: usize)\n    requires\n        sorted(q),\n        0 <= lower_bound <= upper_bound <= q.len(),\n        range_satisfies_comparer_negation(q, key, 0int, lower_bound as int, comparer),\n        range_satisfies_comparer(q, key, upper_bound as int, q.len() as int, comparer),\n        // comparer is '>' or '>='\n        (forall |n1: int, n2: int| #[trigger] comparer(n1, n2) == (n1 > n2)) ||\n        (forall |n1: int, n2: int| #[trigger] comparer(n1, n2) == (n1 >= n2))\n    ensures\n        lower_bound <= index <= upper_bound,\n        range_satisfies_comparer_negation(q, key, 0int, index as int, comparer),\n        range_satisfies_comparer(q, key, index as int, q.len() as int, comparer)\n{\n    assume(false);\n    0\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn find_range(q: Seq<int>, key: int) -> (res: (usize, usize))\n    requires sorted(q)\n    ensures\n        res.0 <= res.1 <= q.len(),\n        forall |i: int| 0 <= i < res.0 ==> q[i] < key,\n        forall |i: int| res.0 <= i < res.1 ==> q[i] == key,\n        forall |i: int| res.1 <= i < q.len() ==> q[i] > key\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    (0, 0)\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_784_ProductEvenOdd", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_even(n: int) -> bool {\n    n % 2 == 0\n}\n\nspec fn is_odd(n: int) -> bool {\n    n % 2 != 0\n}\n\nspec fn is_first_even(even_index: int, lst: Seq<int>) -> bool\n    recommends 0 <= even_index < lst.len() && is_even(lst[even_index])\n{\n    forall|i: int| 0 <= i < even_index ==> is_odd(lst[i])\n}\n\nspec fn is_first_odd(odd_index: int, lst: Seq<int>) -> bool\n    recommends 0 <= odd_index < lst.len() && is_odd(lst[odd_index])\n{\n    forall|i: int| 0 <= i < odd_index ==> is_even(lst[i])\n}\n\n\nfn first_even_odd_indices(lst: Seq<int>) -> (r: (usize, usize))\n    requires lst.len() >= 2,\n    requires exists|i: int| 0 <= i < lst.len() && is_even(lst[i]),\n    requires exists|i: int| 0 <= i < lst.len() && is_odd(lst[i]),\n    ensures ({\n        let (even_index, odd_index) = r;\n        &&& 0 <= even_index < lst.len()\n        &&& 0 <= odd_index < lst.len()\n        &&& is_even(lst[even_index as int]) && is_first_even(even_index as int, lst)\n        &&& is_odd(lst[odd_index as int]) && is_first_odd(odd_index as int, lst)\n    }),\n{\n  assume(false);\n  (0, 0)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn product_even_odd(lst: Seq<int>) -> (product: i32)\n    requires lst.len() >= 2,\n    requires exists|i: int| 0 <= i < lst.len() && is_even(lst[i]),\n    requires exists|i: int| 0 <= i < lst.len() && is_odd(lst[i]),\n    ensures exists|i: int, j: int| 0 <= i < lst.len() && is_even(lst[i]) && is_first_even(i, lst) && \n                                   0 <= j < lst.len() && is_odd(lst[j])  && is_first_odd(j, lst) && product as int == lst[i] * lst[j],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  0\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_457_MinLengthSublist", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn min_length_sublist(s: Seq<Seq<int>>) -> (min_sublist: Seq<int>)\n    requires \n        s.len() > 0,\n    ensures \n        s.contains(min_sublist),\n        forall |sublist: Seq<int>| s.contains(sublist) ==> min_sublist.len() <= sublist.len(),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "BPTree-verif_tmp_tmpq1z6xm1d_Utils_GetInsertIndex", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// method CountLessThan(numbers: set<int>, threshold: int) returns (count: int)\n// //   ensures count == |set i | i in numbers && i < threshold|\n//     ensures count == |SetLessThan(numbers, threshold)|\n// {\n//   count := 0;\n//   var ss := numbers;\n//   while ss != {}\n//     decreases |ss|\n//   {\n//     var i: int :| i in ss;\n//     ss := ss - {i};\n//     if i < threshold {\n//       count := count + 1;\n//     }\n\n//   }\n//   assert count == |SetLessThan(numbers, threshold)|;\n// //   assert count == |set i | i in numbers && i < threshold|;\n// }\n\n// function SetLessThan(numbers: set<int>, threshold: int): set<int>\n// {\n//   set i | i in numbers && i < threshold\n// }\n\nspec fn set_less_than(numbers: Set<int>, threshold: int) -> Set<int> {\n    numbers.filter(|i: int| i < threshold)\n}\n\n\n/*\n*/\n\n// function seqSet(nums: seq<int>, index: nat): set<int> {\n//     set x | 0 <= x < index < |nums| :: nums[x]\n// }\n\nspec fn seq_set(nums: Seq<int>, index: nat) -> Set<int> \n    recommends index <= nums.len()\n{\n    Set::new(|x: int| exists |i: int| 0 <= i < index && i < nums.len() && nums[i] == x)\n}\n\n\n// lemma numElemsOfSet(a: seq<int>)\n//   requires sorted(a)\n// {\n//   assert distinct(a);\n//   var s := set x | x in a;\n//   assert forall x :: x in s ==> x in a[..];\n//   assert forall x :: x in a ==> x in s;\n//   assert |s| == |a|;\n// }\n\n// lemma CardinalitySetEqualsArray(a: seq<int>, s: set<int>)\n//   requires s == set x | x in a\n//   requires distinct(a)\n//   ensures |s| == |a|\n// {\n//     assert forall x :: x in s ==> exists i :: 0 <= i < |a| && a[i] == x;\n//     assert forall i, j :: 0 <= i < |a| && 0 <= j < |a| && i != j ==> a[i] != a[j];\n//     // Assert that each element in the array is in the set\n//     assert forall i :: 0 <= i < |a| ==> a[i] in s;\n//     // Assert that the set contains exactly the elements in the array\n//     assert s == set x | x in a;\n//     // Assert that the set is a subset of the array\n//     assert forall x :: x in s <==> x in a;\n\n//     // Conclude the equivalence\n//     assert |s| == |a|;\n// }\n\n\n/*\n\n\n*/\n\n// TODO play with this for keys==Contents\n\n\n// ghost predicate SortedSeq(a: seq<int>)\n//   //sequence is sorted from left to right\n// {\n//   (forall i,j :: 0<= i< j < |a| ==> ( a[i] < a[j] ))\n// }\n\nspec fn sorted_seq(a: Seq<int>) -> bool {\n    forall |i: int, j: int| 0 <= i < j < a.len() ==> a[i] < a[j]\n}\n\n// predicate sorted(a: seq<int>)\n// {\n//   forall i,j :: 0 <= i < j < |a| ==> a[i] < a[j]\n// }\n\nspec fn sorted(a: Seq<int>) -> bool {\n    forall |i: int, j: int| 0 <= i < j < a.len() ==> a[i] < a[j]\n}\n\n// predicate distinct(a: seq<int>)\n// {\n//   forall i,j :: (0 <= i < |a| && 0 <= j < |a| && i != j) ==> a[i] != a[j]\n// }\n\nspec fn distinct(a: Seq<int>) -> bool {\n    forall |i: int, j: int| (0 <= i < a.len() && 0 <= j < a.len() && i != j) ==> a[i] != a[j]\n}\n\n// predicate sorted_eq(a: seq<int>)\n// {\n//   forall i,j :: 0 <= i < j < |a| ==> a[i] <= a[j]\n// }\n\nspec fn sorted_eq(a: Seq<int>) -> bool {\n    forall |i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j]\n}\n\n// predicate lessThan(a:seq<int>, key:int) {\n//   forall i :: 0 <= i < |a| ==> a[i] < key\n// }\n\nspec fn less_than(a: Seq<int>, key: int) -> bool {\n    forall |i: int| 0 <= i < a.len() ==> a[i] < key\n}\n\n// predicate greaterThan(a:seq<int>, key:int) {\n//   forall i :: 0 <= i < |a| ==> a[i] > key\n// }\n\nspec fn greater_than(a: Seq<int>, key: int) -> bool {\n    forall |i: int| 0 <= i < a.len() ==> a[i] > key\n}\n\n// predicate greaterEqualThan(a:seq<int>, key:int) {\n//   forall i :: 0 <= i < |a| ==> a[i] >= key\n// }\n\nspec fn greater_equal_than(a: Seq<int>, key: int) -> bool {\n    forall |i: int| 0 <= i < a.len() ==> a[i] >= key\n}\n/*\nmethod InsertSorted(a: array<int>, key: int ) returns (b: array<int>)\n  requires sorted_eq(a[..])\n  ensures sorted_eq(b[..])\n{\n  assume{:axiom} false;\n}\n*/\n\n// function count(a: seq<bool>): nat\n// {\n//   if |a| == 0 then 0 else\n//     (if a[0] then 1 else 0) + count(a[1..])\n// }\n\nspec fn count(a: Seq<bool>) -> nat \n    decreases a.len()\n{\n    if a.len() == 0 {\n        0nat\n    } else {\n        (if a[0] { 1nat } else { 0nat }) + count(a.subrange(1, a.len() as int))\n    }\n}\n\n// verifies in more than 45 seconds, but less than 100 seconds\n// method InsertIntoSorted(a: array<int>, limit:int, key:int) returns (b: array<int>)\n//     requires key > 0\n//     requires key !in a[..]\n//     requires 0 <= limit < a.Length\n//     requires forall i :: 0 <= i < limit ==> a[i] > 0\n//     requires forall i :: limit <= i < a.Length ==> a[i] == 0\n//     requires sorted(a[..limit]) \n//     ensures b.Length == a.Length\n//     ensures sorted(b[..(limit+ 1)])\n//     ensures forall i :: limit + 1 <= i < b.Length ==> b[i] == 0  \n//     ensures forall i :: 0 <= i < limit ==> a[i] in b[..]\n//     ensures forall i :: 0 <= i < limit + 1 ==> b[i] > 0\n// {\n//   assume{:axiom} false;\n// }\n\nfn insert_into_sorted(a: Vec<int>, limit: usize, key: int) -> (b: Vec<int>)\n    requires\n        key > 0,\n        !a@.contains(key),\n        limit < a.len(),\n        forall |i: int| 0 <= i < limit ==> a@[i] > 0,\n        forall |i: int| limit <= i < a.len() ==> a@[i] == 0,\n        sorted(a@.subrange(0, limit as int)),\n    ensures\n        b.len() == a.len(),\n        sorted(b@.subrange(0, limit as int + 1)),\n        forall |i: int| limit + 1 <= i < b.len() ==> b@[i] == 0,\n        forall |i: int| 0 <= i < limit ==> a@.contains(b@[i]),\n        forall |i: int| 0 <= i < limit + 1 ==> b@[i] > 0,\n{\n    assume(false);\n    Vec::new()\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\n// method GetInsertIndex(a: array<int>, limit: int, x:int) returns (idx:int)\n//   // get index so that array stays sorted\n//   requires x !in a[..]\n//   requires 0 <= limit <= a.Length\n//   requires SortedSeq(a[..limit])\n//   ensures 0<= idx <= limit\n//   ensures SortedSeq(a[..limit])\n//   ensures idx > 0 ==> a[idx-1]< x\n//   ensures idx < limit ==> x < a[idx]\nfn get_insert_index(a: &Vec<int>, limit: usize, x: int) -> (idx: usize)\n    // get index so that array stays sorted\n    requires\n        !a@.contains(x),\n        limit <= a.len(),\n        sorted_seq(a@.subrange(0, limit as int)),\n    ensures\n        idx <= limit,\n        sorted_seq(a@.subrange(0, limit as int)),\n        idx > 0 ==> a@[idx as int - 1] < x,\n        idx < limit ==> x < a@[idx as int],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_70_AllSequencesEqualLength", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn all_sequences_equal_length(sequences: Seq<Seq<int>>) -> (result: bool)\n    ensures result <==> (forall |i: int, j: int| 0 <= i < sequences.len() && 0 <= j < sequences.len() ==> sequences[i].len() == sequences[j].len())\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    true\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_624_ToUppercase", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_lower_case(c: char) -> bool {\n    97 <= c as int <= 122\n}\n\nspec fn is_lower_upper_pair(c: char, C: char) -> bool {\n    (c as int) == (C as int) + 32\n}\n\nspec fn shift_minus_32(c: char) -> char {\n    ((c as int - 32) % 128) as char\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn to_uppercase(s: Seq<char>) -> (v: Seq<char>)\n    ensures\n        v.len() == s.len(),\n        forall|i: int| 0 <= i < s.len() ==> \n            if is_lower_case(s[i]) {\n                is_lower_upper_pair(s[i], v[i])\n            } else {\n                v[i] == s[i]\n            }\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    s\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula3_maxArrayReverse", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn fib(n: nat) -> nat\n    decreases n\n{\n    if n == 0 { 1 }\n    else if n == 1 { 1 }\n    else { fib((n - 1) as nat) + fib((n - 2) as nat) }\n}\n\n\n// 2.\npub enum List<T> {\n    Nil,\n    Cons(T, Box<List<T>>),\n}\n\nspec fn add(l: List<int>) -> int\n    decreases l\n{\n    match l {\n        List::Nil => 0,\n        List::Cons(x, xs) => x + add(*xs),\n    }\n}\n\n\n// 3.\n\n// 5.\n\n// 6\nspec fn sum(n: nat) -> nat\n    decreases n\n{\n    if n == 0 { 0 } else { n + sum((n - 1) as nat) }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn maxArrayReverse(arr: &[i32]) -> (max: i32)\n    requires arr.len() > 0\n    ensures forall|i: int| 0 <= i < arr.len() ==> arr[i] <= max\n    ensures exists|x: int| 0 <= x < arr.len() && arr[x] == max\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_HoareTripleReqEns", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/*\nVerus include 2 limbaje:\n    * un limbaj pentru specificare \n        MSFOL (ce am discutat până acum)\n        adnotări care să ajute în procesul de verificare\n    * un limbaj pentru scris programe\n*/\n\n// Exemplu de program\n\n/*\n    triple Hoare (| P |) S (| Q |) \n*/\n\n// varianta assume-assert\n\n// varianta requires-ensures\n\n/*\nregula pentru while\n*/\n\n// varianta cu assert\n/*\n*/\n\n// varianta cu invariant\n\n//specificarea sumei de patrate\nspec fn SqrSumRec(n: int) -> int\n    recommends n >= 0\n    decreases n\n{\n    if n == 0 { 0 } else { n*n + SqrSumRec(n-1) }\n}\n/*\n*/\n\n// verificarea programului pentru suma de patrate\n\n// SqrSumRec(n) = 0^2 + 1^2 + 2^2 + ... + n^2 == n(n+1)(2n+1)/6\nproof fn L1(n: int)\n    requires n >= 0\n    ensures SqrSumRec(n) == n*(n+1)*(2*n + 1)/6\n    decreases n\n{\n    if n == 0 {\n        // Base case\n    } else {\n        L1(n-1);\n        // Additional proof steps would be needed here\n    }\n}\n\n/*\nspec fn SqrSumBy6(n: int) -> int\n{\n    n * (n + 1) * (2 * n + 1) \n}\n\nproof fn L(n: int) // it takes a while\n    requires n >= 0\n    ensures  SqrSumBy6(n) == 6 * SqrSumRec(n)\n    decreases n\n{\n    if n == 0 {\n        // Base case\n    } else {\n        assert(n > 0);\n        L(n-1);\n        assert(SqrSumBy6(n-1) == n*(n-1)*(2*n - 1));\n        assert(SqrSumBy6(n-1) == 6*SqrSumRec(n-1));\n        assert(6*SqrSumRec(n-1) == n*(n-1)*(2*n - 1));\n        // Additional calc steps would be needed here for full verification\n    }\n}\n*/", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nspec fn HoareTripleReqEns(i: int, k: int) -> int\n    // (| k == i*i |) k := k + 2 * i +1; (| k = (i+1)*(i+1) |)\n    recommends k == i*i\n{\n    k + 2 * i + 1\n}\n\nproof fn HoareTripleReqEns_correctness(i: int, k: int)\n    requires k == i*i\n    ensures HoareTripleReqEns(i, k) == (i+1)*(i+1)\n{\n    // Proof by algebraic expansion: k + 2*i + 1 = i*i + 2*i + 1 = (i+1)*(i+1)\n    assert(k + 2 * i + 1 == i*i + 2*i + 1);\n    assert(i*i + 2*i + 1 == (i+1)*(i+1));\n}\n// </vc-spec>", "vc-code": "// <vc-code>\n// Implementation would go here if this were an exec function\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_627_SmallestMissingNumber", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nspec fn smallest_missing_number(s: Seq<int>) -> int\n    recommends\n        forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] <= s[j],\n        forall|i: int| 0 <= i < s.len() ==> s[i] >= 0,\n{\n// </vc-spec>", "vc-code": "// <vc-code>\n    choose|v: int| 0 <= v && !s.contains(v) && (forall|k: int| 0 <= k < v ==> s.contains(k))\n// </vc-code>", "vc-postamble": "}\n\nfn main() {}\n\n}"}
{"id": "Dafny-Practice_tmp_tmphnmt4ovh_Pattern Matching_FindAllOccurrences", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn find_all_occurrences(text: &str, pattern: &str) -> (offsets: Ghost<Set<nat>>)\n    ensures \n        forall|i: nat| offsets@.contains(i) ==> i + pattern@.len() <= text@.len(),\n        forall|i: nat| 0 <= i && i + pattern@.len() <= text@.len() \n                      ==> (text@.subrange(i as int, (i + pattern@.len()) as int) == pattern@) == offsets@.contains(i)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    proof {\n        assume(false);\n    }\n    Ghost(Set::empty())\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Dafny_tmp_tmpj88zq5zt_2-Kontrakte_reverse3_swap3", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn swap3(a: &mut Vec<i32>, h: usize, i: usize, j: usize)\n    requires \n        h < old(a).len(),\n        i < old(a).len(),\n        j < old(a).len(),\n        i != j && j != h && h != i,\n    ensures\n        a[h as int] == old(a)[i as int],\n        a[j as int] == old(a)[h as int],\n        a[i as int] == old(a)[j as int],\n        forall|k: int| 0 <= k < old(a).len() && k != h as int && k != i as int && k != j as int ==> a[k] == old(a)[k],\n        a.len() == old(a).len(),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Dafny_Programs_tmp_tmp99966ew4_lemma_FindZero", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn find_zero(a: &[i32]) -> (index: i32)\n    requires\n        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i] >= 0,\n        forall|i: int| 0 < i < a.len() ==> #[trigger] a[i-1] - 1 <= a[i],\n    ensures\n        (index < 0 ==> forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i] != 0),\n        (0 <= index ==> index < a.len() && a[index as int] == 0),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    -1\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session9Exercises_ExerciseSeqMaxSum_segSumaMaxima2", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sum(v: Seq<i32>, i: int, j: int) -> int\n    recommends 0 <= i <= j <= v.len()\n    decreases j - i when i < j\n{\n    if i == j {\n        0\n    } else {\n        sum(v, i, (j - 1) as int) + v[(j - 1) as int] as int\n    }\n}\n\nspec fn sum_max_to_right(v: Seq<i32>, i: int, s: int) -> bool\n    recommends 0 <= i < v.len()\n{\n    forall|l: int, ss: int| 0 <= l <= i && ss == i + 1 ==> sum(v, l, ss) <= s\n}\n\n\n\nspec fn sum2(v: Seq<i32>, i: int, j: int) -> int\n    recommends 0 <= i <= j <= v.len()\n    decreases j - i when i < j\n{\n    if i == j {\n        0\n    } else {\n        v[i] as int + sum2(v, i + 1, j)\n    }\n}\n\n//Now do the same but with a loop from right to left\nspec fn sum_max_to_right2(v: Seq<i32>, j: int, i: int, s: int) -> bool //maximum sum stuck to the right\n    recommends 0 <= j <= i < v.len()\n{\n    forall|l: int, ss: int| j <= l <= i && ss == i + 1 ==> sum2(v, l, ss) <= s\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn seg_suma_maxima2(v: &[i32], i: usize) -> (result: (i32, usize))\n    requires v.len() > 0 && i < v.len()\n    ensures \n        0 <= result.1 <= i && \n        result.0 as int == sum2(v@, result.1 as int, (i + 1) as int) && \n        sum_max_to_right2(v@, 0, i as int, result.0 as int)\n//Implement and verify\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    (0, 0)\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "VerifiedMergeSortDafny_tmp_tmpva7qms1b_MergeSort_mergeSimple", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn merged(a1: Seq<i32>, a2: Seq<i32>, b: &Vec<i32>, start: int, end: int) -> bool {\n    &&& end - start == a2.len() + a1.len()\n    &&& 0 <= start <= end <= b.len()\n    &&& a1.to_multiset().add(a2.to_multiset()) == b@.subrange(start, end).to_multiset()\n}\n\nspec fn sorted_slice(a: &Vec<i32>, start: int, end: int) -> bool {\n    &&& 0 <= start <= end <= a.len()\n    &&& forall|i: int, j: int| start <= i <= j < end ==> a@[i] <= a@[j]\n}\n\nspec fn sorted_seq(a: Seq<i32>) -> bool {\n    forall|i: int, j: int| 0 <= i <= j < a.len() ==> a[i] <= a[j]\n}\n\nspec fn sorted(a: &Vec<i32>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < a.len() ==> a@[i] <= a@[j]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn mergeSimple(a1: Seq<i32>, a2: Seq<i32>, start: usize, end: usize, b: &mut Vec<i32>)\n    requires\n        sorted_seq(a1),\n        sorted_seq(a2),\n        0 <= start <= end <= old(b).len(),\n        a1.len() + a2.len() == end - start + 1,\n    ensures\n        sorted_slice(b, start as int, end as int),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced examples_demo_Partition", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn partition(a: &mut Vec<i32>) -> (usize, usize)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  let lo: usize = 0;\n  let hi: usize = 0;\n  \n  // This is a post-condition that must be proven\n  assert(0 <= lo && lo <= hi && hi <= a.len());\n  assert(forall|x: int| 0 <= x < lo ==> a[x as int] < 0);\n  assert(forall|x: int| lo <= x < hi ==> a[x as int] == 0);\n  assert(forall|x: int| hi <= x < a.len() ==> a[x as int] > 0);\n  \n  (lo, hi)\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_NoDups", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// ASSIGNMENT P1\n// CMSC 433 FALL 2023\n// PERFECT SCORE:  100 POINTS\n//\n// This assignment contains nine questions, each of which involves writing Verus\n// code. You should include your solutions in a single Verus file and submit it using\n// Gradescope.\n//\n// Revision history\n//\n// 2023-09-22 2:50 pm   Fixed typo in Problem 3.\n\n\n// Question 1 (5 points)\n//\n// Fill in a requires clause that enables Verus to verify\n// method PlusOne\n\n\n\n// Question 2 (5 points)\n//\n// Fill in requires clause(s) that enable(s) Verus to verify the array bounds\n// in method Swap (which swaps elements i and j in array a).\n\n\n// Question 3 (5 points)\n//\n// Give ensures clause(s) asserting that d is the result, and r the\n// remainder, of dividing m by n.  Your clauses cannot use \"/\" or \"%\" (which are\n// the Verus division and mod operators, respectively). By definition, the\n// remainder must be non-negative.\n\n\n// Question 4 (5 points)\n//\n// Give ensures clause(s) asserting that the return value has the same\n// length as array a and contains as its elements the sum of the\n// corresponding elements in arrays a and b.\n\n\n// Question 5 (10 points)\n\n// Euclid's algorithm is used to compute the greatest common divisor of two\n// positive integers.  If m and n are two such integers, then gcd(m,n) is the\n// largest positve integer that evenly divides both m and n, where j evenly divides i\n// if and only if i % j == 0 (% is the Verus mod operator).  Write requires and\n// ensures clauses for the method header Euclid below.  Your requires clauses\n// should also specify that the first argument is at least as large as the second.\n// You do *not* need to implement the method!\n\n\n// Question 7 (20 points)\n//\n// Implement, and have Verus verify, the method IsPrime below, which returns true\n// if and only if the given positive integer is prime.\n\n\n// Question 8 (20 points)\n//\n// Implement, and have Verus verify, the method Reverse below, which returns a new array\n// aRev consisting of the elements of a, but in reverse order.  To create a new \n// array of ints use the Verus command \"Vec::with_capacity(...)\", where \"...\" is the number\n// of elements in the array.\n\n\n// Question 9 (20 points)\n//\n// Implement and verify method NoDups, which returns true if and only if there\n// are no duplicate elements in array a.  Note that the requires clause allows\n// you to assume that a is sorted, and that this precondition is necessary for\n// the ensures clause to imply a lack of duplicates.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn no_dups(a: &Vec<i32>) -> (no_dups: bool)\n    requires forall|j: int| 1 <= j < a.len() ==> a[j-1] <= a[j], // a sorted\n    ensures no_dups <==> forall|j: int| 1 <= j < a.len() ==> a[j-1] != a[j],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  false\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExercisefirstZero_mfirstCero", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn mfirst_cero(v: &[i32]) -> (i: usize)\n    ensures\n        i <= v.len(),\n        forall|j: int| 0 <= j < i as int ==> v@[j] != 0,\n        i != v.len() ==> v@[i as int] == 0,\n{\n    assume(false);\n    0\n}\n// </vc-spec>", "vc-code": "// <vc-code>\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_616_ElementWiseModulo", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn element_wise_modulo(a: &[i32], b: &[i32]) -> (result: Vec<i32>)\n    requires \n        a.len() == b.len(),\n        forall|i: int| 0 <= i < b.len() ==> b[i] != 0,\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] % b[i],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseSelSort_selSort", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sorted_seg(a: Seq<int>, i: int, j: int) -> bool\n{\n    &&& 0 <= i <= j <= a.len()\n    &&& forall|l: int, k: int| i <= l <= k < j ==> a[l] <= a[k]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn sel_sort(a: &mut Vec<int>, c: usize, f: usize)\n    requires \n        c <= f <= old(a).len(),\n    ensures \n        sorted_seg(a@, c as int, f as int),\n        a.len() == old(a).len(),\n        a@.subrange(c as int, f as int).to_multiset() == old(a)@.subrange(c as int, f as int).to_multiset(),\n        a@.subrange(0, c as int) == old(a)@.subrange(0, c as int),\n        a@.subrange(f as int, a.len() as int) == old(a)@.subrange(f as int, old(a).len() as int),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "BinaryAddition_ArrayToSequence", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* \nMIPS 0\nWe implement the following with bitvectors in Verus.\nhere s' and t' are converted to decimal scalars\ns = [1,1,1], t = [1,0,1], ys = [1, 0, 0], s' = 7, t' = 5, ys' = 4\nys' % 2 ^ (len(s)) = (s' + t') % 2 ^ (len(s))\n4 % 8 = 12 % 8\n\ndef f(s,t):\n    a = 0;b = 0;\n    ys = []\n    for i in range(10):\n        c = s[i]; d = t[i];\n        next_a = b ^ c ^ d\n        next_b = b+c+d>1\n        a = next_a;b = next_b;\n        y = a\n        ys.append(y)\n    return ys\n*/\n\nspec fn array_to_bv10(arr: Seq<bool>) -> int\n    recommends arr.len() == 10\n{\n    array_to_bv10_helper(arr, 9)\n}\n\nspec fn array_to_bv10_helper(arr: Seq<bool>, index: int) -> int\n    recommends 0 <= index < arr.len()\n    decreases index\n{\n    if index <= 0 {\n        if arr[0] { 1 } else { 0 }\n    } else {\n        let bit: int = if arr[index] { 1 } else { 0 };\n        bit * pow2(index) + array_to_bv10_helper(arr, index - 1)\n    }\n}\n\nspec fn pow2(n: int) -> int\n    recommends n >= 0\n    decreases n\n{\n    if n <= 0 { 1 } else { 2 * pow2(n - 1) }\n}\n\nspec fn is_bit_set(x: int, bit_index: int) -> bool\n    recommends 0 <= bit_index < 10 && x >= 0\n{\n    (x / pow2(bit_index)) % 2 == 1\n}\n\nspec fn bv10_to_seq(x: int) -> Seq<bool> {\n    seq![is_bit_set(x, 0), is_bit_set(x, 1), is_bit_set(x, 2), is_bit_set(x, 3),\n         is_bit_set(x, 4), is_bit_set(x, 5), is_bit_set(x, 6), is_bit_set(x, 7),\n         is_bit_set(x, 8), is_bit_set(x, 9)]\n}\n\nspec fn bool_to_int(a: bool) -> int {\n    if a { 1 } else { 0 }\n}\n\nspec fn xor_bool(a: bool, b: bool) -> bool {\n    (a || b) && !(a && b)\n}\n\nspec fn bit_addition(s: Seq<bool>, t: Seq<bool>) -> Seq<bool> \n    recommends s.len() == 10 && t.len() == 10\n{\n    let a: int = array_to_bv10(s);\n    let b: int = array_to_bv10(t);\n    let c: int = (a + b) % pow2(10);\n    bv10_to_seq(c)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn array_to_sequence(arr: &[bool; 10]) -> (res: Vec<bool>)\n    ensures \n        res.len() == 10,\n        forall|k: int| 0 <= k < 10 ==> res[k] == arr[k]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  vec![]\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "Clover_copy_part_copy", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn copy(src: &[i32], s_start: usize, dest: &[i32], d_start: usize, len: usize) -> (r: Vec<i32>)\n    requires \n        src.len() >= s_start + len,\n        dest.len() >= d_start + len,\n    ensures \n        r.len() == dest.len(),\n        r@.subrange(0, d_start as int) =~= dest@.subrange(0, d_start as int),\n        r@.subrange((d_start + len) as int, dest.len() as int) =~= dest@.subrange((d_start + len) as int, dest.len() as int),\n        r@.subrange(d_start as int, (len + d_start) as int) =~= src@.subrange(s_start as int, (len + s_start) as int),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "Clover_modify_2d_array_modify_array_element", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn modify_array_element(arr: &mut Vec<Vec<nat>>, index1: usize, index2: usize, val: nat)\n  requires\n      index1 < old(arr).len(),\n      index2 < old(arr)[index1 as int].len(),\n      forall|i: int, j: int| \n          0 <= i < old(arr).len() && 0 <= j < old(arr).len() && i != j ==> \n          !equal(old(arr)[i], old(arr)[j]),\n  ensures\n      arr.len() == old(arr).len(),\n      forall|i: int| 0 <= i < arr.len() ==> equal(arr[i], old(arr)[i]),\n      forall|i: int, j: int| \n          0 <= i < arr.len() && 0 <= j < arr[i].len() && \n          (i != index1 || j != index2) ==> \n          arr[i][j] == old(arr)[i][j],\n      arr[index1 as int][index2 as int] == val,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Dafny-demo_tmp_tmpkgr_dvdi_Dafny_BinarySearch_BinarySearch", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// Predicate to check if array slice is sorted\nspec fn sorted(a: &[int], l: int, u: int) -> bool {\n    forall|i: int, j: int| 0 <= l <= i <= j <= u < a.len() ==> a[i] <= a[j]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn binary_search(a: &[int], key: int) -> (index: i32)\n    requires \n        a.len() > 0,\n        sorted(a, 0, (a.len() - 1) as int),\n    ensures \n        index >= 0 ==> index < a.len() && a[index as int] == key,\n        index < 0 ==> forall|k: int| 0 <= k < a.len() ==> a[k] != key,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    -1\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_605_IsPrime", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn is_prime(n: int) -> (result: bool)\n    requires n >= 2\n    ensures result <==> (forall|k: int| 2 <= k < n ==> #[trigger] (n % k) != 0)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    true\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "SENG2011_tmp_tmpgk5jq85q_ass2_ex1_StringSwap", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn string_swap(s: Seq<char>, i: nat, j: nat) -> (t: Seq<char>)\n    requires \n        i >= 0 && j >= 0 && s.len() >= 0,\n        s.len() > 0 ==> i < s.len() && j < s.len(),\n    ensures \n        s.to_multiset() == t.to_multiset(),\n        s.len() == t.len(),\n        s.len() > 0 ==> forall|k: nat| k != i && k != j && k < s.len() ==> t[k as int] == s[k as int],\n        s.len() > 0 ==> t[i as int] == s[j as int] && t[j as int] == s[i as int],\n        s.len() == 0 ==> t == s,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    s\n}\n// </vc-code>", "vc-postamble": "// string == Seq<char>\n//give se2011 ass2 ex1.dfy\n\nfn main() {}\n\n}"}
{"id": "dafny-exercise_tmp_tmpouftptir_appendArray_appendArray", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn append_array(a: &[i32], b: &[i32]) -> (c: Vec<i32>)\n    ensures \n        c.len() == a.len() + b.len(),\n        forall|i: int| 0 <= i < a.len() ==> a[i] == c[i],\n        forall|i: int| 0 <= i < b.len() ==> b[i] == c[a.len() + i],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced examples_InsertionSort_InsertionSort", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sorted(a: &Vec<i32>, start: int, end: int) -> bool {\n    &&& 0 <= start <= end <= a.len()\n    &&& forall|j: int, k: int| start <= j < k < end ==> a[j] <= a[k]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn insertion_sort(a: &mut Vec<i32>)\n    requires \n        old(a).len() > 1,\n    ensures \n        sorted(a, 0, a.len() as int),\n        a.len() == old(a).len(),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_284_AllElementsEqual", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn all_elements_equal(a: &[i32], n: i32) -> (result: bool)\n    ensures\n        result ==> forall|i: int| 0 <= i < a.len() ==> a[i] == n,\n        !result ==> exists|i: int| 0 <= i < a.len() && a[i] != n,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  true\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_examples_relativeOrder_FindEvenNumbers", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_even(n: int) -> bool {\n    n % 2 == 0\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn find_even_numbers(arr: &[int]) -> (even_numbers: Vec<int>)\n    ensures\n        // All even numbers from arr are in the result\n        forall|i: int| 0 <= i < arr.len() && is_even(arr[i]) ==> \n            #[trigger] even_numbers@.contains(arr[i]),\n        // All numbers in result come from arr  \n        forall|x: int| #[trigger] even_numbers@.contains(x) ==> \n            exists|i: int| 0 <= i < arr.len() && arr[i] == x,\n        // Order preservation property\n        forall|k: int, l: int| 0 <= k < l < even_numbers.len() ==>\n            exists|n: int, m: int| 0 <= n < m < arr.len() && \n                #[trigger] even_numbers[k] == arr[n] && \n                #[trigger] even_numbers[l] == arr[m]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_06_Hoangkim_ex_06_hoangkim_gcdI", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n//Problem01\n//a)\nspec fn gcd(x: int, y: int) -> int\n    recommends x > 0 && y > 0\n    decreases x + y when x > 0 && y > 0\n{\n    if x == y { x }\n    else if x > y { gcd(x - y, y) }\n    else { gcd(x, y - x) }\n}\n\n//b)\nspec fn gcd_prime(x: int, y: int) -> int\n    recommends x > 0 && y > 0\n    decreases if x > y { x } else { y }, x + y when x > 0 && y > 0\n{\n    if x == y { x }\n    else if x > y { gcd_prime(x - y, y) }\n    else { gcd(y, x) }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn gcd_i(m: int, n: int) -> (d: int)\n    requires m > 0 && n > 0\n    ensures d == gcd(m, n)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    m\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_verified algorithms_lol_sort_lol_sort", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// By `lol sort` here, I refer to a seemingly-broken sorting algorithm,\n// which actually somehow manages to work perfectly:\n//\n// for i in 0..n\n//   for j in 0..n\n//     if i < j\n//       swap a[i], a[j]\n//\n// It is perhaps the simpliest sorting algorithm to \"memorize\",\n// even \"symmetrically beautiful\" as if `i` and `j` just played highly\n// similar roles. And technically it's still O(n^2) time lol...\n//\n// Proving its correctness is tricky (interesting) though.\n\n// Successfully verified with [Dafny 3.3.0.31104] in about 5 seconds.\n\n\n\n// We define \"valid permutation\" using multiset:\n\nspec fn valid_permut(a: Seq<int>, b: Seq<int>) -> bool\n    recommends a.len() == b.len()\n{\n    a.to_multiset() == b.to_multiset()\n}\n\n// This is a swap-based sorting algorithm, so permutedness is trivial:\n// note that: if i == j, the spec just says a[..] remains the same.\nfn swap(a: &mut Vec<int>, i: usize, j: usize)\n    requires \n        i < old(a).len(),\n        j < old(a).len(),\n    ensures\n        a.len() == old(a).len(),\n        a@ == old(a)@.update(i as int, old(a)[j as int]).update(j as int, old(a)[i as int]),\n        valid_permut(a@, old(a)@),\n{\n    assume(false);\n}\n\n// We then define \"sorted\" (by increasing order):\nspec fn sorted(a: Seq<int>) -> bool\n{\n    forall|i: int, j: int| 0 <= i <= j < a.len() ==> a[i] <= a[j]\n}\n\n\n// Now, the lol sort algorithm:\n// (Some invariants were tricky to find, but Verus was smart enough otherwise)", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn lol_sort(a: &mut Vec<int>)\n    ensures \n        valid_permut(a@, old(a)@),\n        sorted(a@),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseAllEqual_mallEqual1", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn all_equal(s: Seq<i32>) -> bool {\n    forall|i: int, j: int| 0 <= i < s.len() && 0 <= j < s.len() ==> s[i] == s[j]\n}\n//forall|i: int, j: int| 0 <= i <= j < s.len() ==> s[i] == s[j]\n//forall|i: int| 0 < i < s.len() ==> s[i-1] == s[i]\n//forall|i: int| 0 <= i < s.len() - 1 ==> s[i] == s[i+1]\n\n\n//Ordered indexes\n\n//All equal to first", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn mall_equal1(v: &[i32]) -> (b: bool)\n    ensures b == all_equal(v@)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    false\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "Clover_swap_arith_SwapArithmetic", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn swap_arithmetic(x: i32, y: i32) -> (res: (i32, i32))\n    ensures \n        res.0 == y && res.1 == x,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    (0, 0)\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n} // verus!"}
{"id": "dafny-synthesis_task_id_240_ReplaceLastElement", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn replace_last_element(first: &Vec<i32>, second: &Vec<i32>) -> (result: Vec<i32>)\n    requires \n        first.len() > 0,\n    ensures \n        result.len() == first.len() - 1 + second.len(),\n        forall|i: int| 0 <= i < first.len() - 1 ==> result[i] == first[i],\n        forall|i: int| first.len() - 1 <= i < result.len() ==> result[i] == second[i - first.len() + 1],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    let mut result = Vec::new();\n    result\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_586_SplitAndAppend", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn split_and_append(l: Seq<int>, n: int) -> (r: Seq<int>)\n    requires \n        n >= 0 && n < l.len(),\n    ensures \n        r.len() == l.len(),\n        forall|i: int| 0 <= i < l.len() ==> r[i] == l[((i + n) as nat % l.len()) as int],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_BubbleSort_sol_bubbleSort", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sorted_between(a: &Vec<i32>, from: usize, to: usize) -> bool\n    recommends\n        from <= to,\n        to <= a.len(),\n{\n    forall|i: int, j: int| from <= i < j < to && 0 <= i < a.len() && 0 <= j < a.len() ==> a@[i] <= a@[j]\n}\n\nspec fn sorted(a: &Vec<i32>) -> bool {\n    sorted_between(a, 0, a.len())\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn bubbleSort(a: &mut Vec<i32>)\n    requires\n        old(a).len() > 0,\n    ensures\n        sorted(a),\n        old(a)@ == a@,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_641_NthNonagonalNumber", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn nth_nonagonal_number(n: int) -> (number: int)\n    requires n >= 0\n    ensures number == n * (7 * n - 5) / 2\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_477_ToLowercase", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_upper_case(c: char) -> bool {\n    65 <= c as int <= 90\n}\n\nspec fn is_upper_lower_pair(C: char, c: char) -> bool {\n    (C as int) == (c as int) - 32\n}\n\nspec fn shift_32(c: char) -> char {\n    (((c as int + 32) % 128) as u8) as char\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\n#[verifier::exec_allows_no_decreases_clause]\nfn to_lowercase(s: &str) -> (v: String)\n    ensures\n        v@.len() == s@.len(),\n        forall|i: int| #![trigger s@[i]] 0 <= i < s@.len() ==> \n        {\n            if is_upper_case(s@[i]) {\n                is_upper_lower_pair(s@[i], v@[i])\n            } else {\n                v@[i] == s@[i]\n            }\n        }\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    loop {}\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_424_ExtractRearChars", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn extract_rear_chars(l: &Vec<Vec<char>>) -> (r: Vec<char>)\n    requires forall|i: int| 0 <= i < l.len() ==> l[i].len() > 0\n    ensures \n        r.len() == l.len()\n        && forall|i: int| 0 <= i < l.len() ==> r[i] == l[i][l[i].len() - 1]\n{\n// </vc-spec>", "vc-code": "// <vc-code>\n    assume(false);\n    Vec::new()\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_632_swap", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn count(arr: Seq<int>, value: int) -> nat\n    decreases arr.len()\n{\n    if arr.len() == 0 { 0nat } else { (if arr[0] == value { 1nat } else { 0nat }) + count(arr.skip(1), value) }\n}\n\nproof fn count_bound(arr: Seq<int>, value: int)\n    ensures count(arr, value) <= arr.len()\n    decreases arr.len()\n{\n    if arr.len() > 0 {\n        count_bound(arr.skip(1), value);\n    }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn swap(arr: &mut Vec<int>, i: usize, j: usize)\n    requires \n        old(arr).len() > 0,\n        i < old(arr).len(),\n        j < old(arr).len(),\n    ensures \n        arr[i as int] == old(arr)[j as int],\n        arr[j as int] == old(arr)[i as int],\n        forall|k: int| 0 <= k < arr.len() && k != i && k != j ==> arr[k] == old(arr)[k],\n        arr@.to_multiset() == old(arr)@.to_multiset(),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Clover_update_array_UpdateElements", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn update_elements(a: &mut Vec<i32>)\n    requires \n        old(a).len() >= 8,\n    ensures \n        old(a)[4] + 3 == a[4],\n        a[7] == 516,\n        forall|i: int| 0 <= i < a.len() ==> i != 7 && i != 4 ==> a[i] == old(a)[i],\n        a.len() == old(a).len(),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "assertive-programming-assignment-1_tmp_tmp3h_cj44u_ProdAndCount_ProdAndCount", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn recursive_positive_product(q: Seq<int>) -> int\n    decreases q.len()\n{\n    if q.len() == 0 {\n        1\n    } else if q[0] <= 0 {\n        recursive_positive_product(q.subrange(1, q.len() as int))\n    } else {\n        q[0] * recursive_positive_product(q.subrange(1, q.len() as int))\n    }\n}\n\nspec fn recursive_count(key: int, q: Seq<int>) -> int\n    decreases q.len()\n{\n    if q.len() == 0 {\n        0\n    } else if q[q.len() - 1] == key {\n        1 + recursive_count(key, q.subrange(0, q.len() as int - 1))\n    } else {\n        recursive_count(key, q.subrange(0, q.len() as int - 1))\n    }\n}\n\nspec fn county(elem: int, key: int) -> int {\n    if elem == key { 1 } else { 0 }\n}\n\nspec fn prody(elem: int) -> int {\n    if elem <= 0 { 1 } else { elem }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn prod_and_count(q: &[i32], key: i32) -> (i32, u32)\n    ensures |result: (i32, u32)| \n        result.0 == recursive_positive_product(q@.map(|_, x: i32| x as int)) &&\n        result.1 == recursive_count(key as int, q@.map(|_, x: i32| x as int)) as u32\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    (0, 0)\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "Clover_below_zero_below_zero", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn below_zero(operations: Vec<i32>) -> (result: (Vec<i32>, bool))\n    ensures\n        result.0.len() == operations.len() + 1,\n        result.0[0] == 0,\n        forall|i: int| 0 <= i < (result.0.len() - 1) as int ==> result.0[i + 1] == result.0[i] + operations[i],\n        result.1 == true ==> exists|i: int| 1 <= i <= operations.len() as int && result.0[i] < 0,\n        result.1 == false ==> forall|i: int| 0 <= i < result.0.len() as int ==> result.0[i] >= 0,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    (vec![], false)\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Insertion_Sort_Normal_lookForMin", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sorted(a: &[int]) -> bool {\n    sorted_a(a, a.len() as int)\n}\n\nspec fn sorted_a(a: &[int], i: int) -> bool {\n    0 <= i <= a.len() && \n    forall|k: int| #![trigger a[k]] 0 < k < i ==> a[(k-1) as int] <= a[k]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn look_for_min(a: &[int], i: usize) -> (m: usize)\n    requires \n        0 <= i < a.len(),\n    ensures\n        i <= m < a.len(),\n        forall|k: int| #![trigger a[k]] i <= k < a.len() ==> a[k] >= a[m as int],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  i\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_normal_data_completion_MaxPerdV2_max", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn contains(v: i32, a: Seq<i32>, n: int) -> bool {\n    exists|j: int| 0 <= j < n && a[j] == v\n}\n\nspec fn upper_bound(v: i32, a: Seq<i32>, n: int) -> bool {\n    forall|j: int| 0 <= j < n ==> a[j] <= v\n}\n\nspec fn is_max(m: i32, a: Seq<i32>, n: int) -> bool {\n    contains(m, a, n) && upper_bound(m, a, n)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn max(a: &[i32], n: usize) -> (max: i32)\n    requires 0 < n <= a.len(),\n    ensures is_max(max, a@, n as int),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "CVS-Projto1_tmp_tmpb1o0bu8z_proj1_proj1_query", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n//Exercicio 1.a)\nspec fn sum(a: Seq<int>, i: int, j: int) -> int\n    recommends 0 <= i <= j <= a.len()\n    decreases j when 0 <= i <= j <= a.len()\n{\n    if i == j {\n        0\n    } else {\n        a[j - 1] + sum(a, i, j - 1)\n    }\n}\n\n//Exercicio 1.b)\n\n//Exercicio 1.c)\n\n\nspec fn is_prefix_sum_for(a: Seq<int>, c: Seq<int>) -> bool {\n    a.len() + 1 == c.len()\n    && c[0] == 0\n    && forall|j: int| 1 <= j <= a.len() ==> c[j] == sum(a, 0, j)\n}\n\n///Exercicio 2.\n#[derive(PartialEq, Eq)]\nenum List<T> {\n    Nil,\n    Cons { head: T, tail: Box<List<T>> }\n}\n\nfn from_array<T: Copy>(a: &[T]) -> (l: List<T>)\n    requires a.len() > 0\n    ensures forall|j: int| 0 <= j < a.len() ==> mem(a@[j], l)\n{\n    assume(false);\n    List::Nil\n}\n\nspec fn mem<T>(x: T, l: List<T>) -> bool\n    decreases l\n{\n    match l {\n        List::Nil => false,\n        List::Cons { head: y, tail: r } => if x == y { true } else { mem(x, *r) }\n    }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nexec fn query(a: &[i32], i: usize, j: usize) -> (s: i32)\n    requires 0 <= i <= j <= a.len()\n    ensures s == sum(a@.map(|k, x| x as int), i as int, j as int)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "dafny-exercise_tmp_tmpouftptir_firstE_firstE", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn firstE(a: &[char]) -> (x: i32)\n    ensures\n        if a@.contains('e') {\n            0 <= x < a@.len() && a@[x as int] == 'e' && \n            forall|i: int| 0 <= i < x ==> a@[i] != 'e'\n        } else {\n            x == -1\n        }\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    -1\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "Prog-Fun-Solutions_tmp_tmp7_gmnz5f_extra_mod_mod", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn f(n: nat) -> nat\n    decreases n\n{\n    if n == 0 { 1 }\n    else if n % 2 == 0 { 1 + 2 * f(n / 2) }\n    else { 2 * f(n / 2) }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn mod_fn(n: u64) -> (a: u64)\n    requires n >= 0,\n    ensures a as nat == f(n as nat),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    1\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Clover_count_lessthan_CountLessThan", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn count_less_than(numbers: Set<int>, threshold: int) -> (count: usize)\n    ensures count == numbers.filter(|i: int| i < threshold).len()\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_801_CountEqualNumbers", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn count_equal_numbers(a: i32, b: i32, c: i32) -> (count: i32)\n    ensures \n        count >= 0 && count <= 3,\n        (count == 3) <==> (a == b && b == c),\n        (count == 2) <==> ((a == b && b != c) || (a != b && b == c) || (a == c && b != c)),\n        (count == 1) <==> (a != b && b != c && a != c),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0  // unreachable\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBinarySearch_binarySearchRec", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sorted(s: Seq<i32>) -> bool {\n    forall|u: int, w: int| 0 <= u < w < s.len() ==> s[u] <= s[w]\n}\n\n\n\n\n\n\n\n//Recursive binary search", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn binary_search_rec(v: &Vec<i32>, elem: i32, c: usize, f: usize) -> (p: i32)\n    requires\n        sorted(v@),\n        0 <= c <= f + 1 <= v.len(),//0<=c<=v.Length && -1<=f<v.Length && c<=f+1\n        forall|k: int| 0 <= k < c ==> v[k] <= elem,\n        forall|k: int| f < k < v.len() ==> v[k] > elem,\n    ensures\n        -1 <= p < v.len(),\n        (forall|u: int| 0 <= u <= p ==> v[u] <= elem) && (forall|w: int| p < w < v.len() ==> v[w] > elem),\n    decreases f - c\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    -1\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_762_IsMonthWith30Days", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn is_month_with_30_days(month: i32) -> (result: bool)\n    requires 1 <= month <= 12\n    ensures result <==> (month == 4 || month == 6 || month == 9 || month == 11)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    true // unreachable due to assume(false)\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "Dafny_tmp_tmp0wu8wmfr_tests_Search1000_Search1000", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// Author: Snorri Agnarsson, snorri@hi.is\n\n// Search1000 is a Verus version of a function shown\n// by Jon Bentley in his old Programming Pearls\n// column in CACM.  Surprisingly Verus needs no help\n// to verify the function.\n\n// Is2Pow(n) is true iff n==2^k for some k>=0.\nspec fn is_2_pow(n: int) -> bool\n    decreases n\n{\n    if n < 1 {\n        false\n    } else if n == 1 {\n        true\n    } else {\n        n % 2 == 0 && is_2_pow(n / 2)\n    }\n}\n\n// This method is a binary search that only works for array\n// segments of size n == 2^k-1 for some k>=0.\n\n// This method is a binary search that only works for array\n// segments of size n == 2^k-1 for some k>=0.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn search_1000(a: &[i32], x: i32) -> (k: usize)\n    requires \n        a.len() >= 1000,\n        forall|p: int, q: int| 0 <= p < q < 1000 ==> a[p] <= a[q],\n    ensures \n        0 <= k <= 1000,\n        forall|r: int| 0 <= r < k ==> a[r] < x,\n        forall|r: int| k <= r < 1000 ==> a[r] >= x,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafl_tmp_tmp_r3_8w3y_dafny_examples_uiowa_find_Find", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/*\n   CS:5810 Formal Methods in Software Engineering\n   Fall 2017\n   The University of Iowa\n\n   Instructor: Cesare Tinelli\n\n   Credits: Example adapted from Dafny tutorial\n*/", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn find(a: &[i32], key: i32) -> (i: i32)\n    ensures\n        // if i is non-negative then \n        0 <= i ==> (// (1) i is smaller than the length of a\n                    i < a.len() && \n                    // (2) key is at position i in a\n                    a[i as int] == key && \n                    // (3) i is the smallest position where key appears\n                    forall|k: int| 0 <= k < i ==> a[k] != key\n                   ),\n        // if index is negative then\n        i < 0 ==> \n                // a does not contain key\n                forall|k: int| 0 <= k < a.len() ==> a[k] != key,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    -1\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_587_ArrayToSeq", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn array_to_seq(a: &[i32]) -> (s: Vec<i32>)\n    ensures\n        s.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> s[i] == a[i],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "dafl_tmp_tmp_r3_8w3y_dafny_examples_uiowa_binary-search_binSearch", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n///////////////////\n// Binary search\n///////////////////\n\n\nspec fn is_sorted(a: &[int]) -> bool {\n    forall|i: int, j: int| 0 <= i <= j < a.len() ==> a[i] <= a[j]\n}\n\n\n// a[lo] <= a[lo+1] <= ... <= a[hi-2] <= a[hi-1]\n\n/* Note: the following definition of is_sorted:\n\n\nalthough equivalent to the one above is not enough for Verus to be able \nto prove the invariants for the loop in bin_search.\n\nThe given one works because it *explicitly* states that every element \nof the input array is smaller than or equal to all later elements. \nThis fact is implied by the alternative definition of is_sorted given \nhere (which only talks about array elements and their successors). \nHowever, it needs to be derived as an auxiliary lemma first, something \nthat Verus is not currently able to do automatically. \n*/", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn bin_search(a: &[int], k: int) -> (b: bool)\n    requires is_sorted(a)\n    ensures b == exists|i: int| 0 <= i < a.len() && a[i] == k\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    false\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafny_tmp_tmp59p638nn_examples_SelectionSort_SelectionnSort", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// Two-state predicate for checking if multiset is preserved\nspec fn preserved(a_old: Seq<i32>, a_new: Seq<i32>, left: nat, right: nat) -> bool\n    recommends left <= right <= a_old.len() && a_old.len() == a_new.len()\n{\n    a_old.subrange(left as int, right as int).to_multiset() == a_new.subrange(left as int, right as int).to_multiset()\n}\n\n// Predicate for checking if array slice is ordered\nspec fn ordered(a: Seq<i32>, left: nat, right: nat) -> bool\n    recommends left <= right <= a.len()\n{\n    forall|i: int| #![trigger a[i]] left < i < right ==> a[i-1] <= a[i]\n}\n\n// Two-state predicate for sorted array\nspec fn sorted(a_old: Seq<i32>, a_new: Seq<i32>) -> bool\n    recommends a_old.len() == a_new.len()\n{\n    ordered(a_new, 0, a_new.len() as nat) && preserved(a_old, a_new, 0, a_old.len() as nat)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn selection_sort(a: &mut Vec<i32>)\n    ensures sorted(old(a)@, a@)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "Dafny-Grind75_tmp_tmpsxfz3i4r_problems_twoSum_twoSum", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn summing_pair(i: nat, j: nat, nums: Seq<int>, target: int) -> bool\n    recommends \n        i < nums.len(),\n        j < nums.len(),\n{\n    i != j && nums[i as int] + nums[j as int] == target\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn two_sum(nums: Seq<int>, target: int) -> (pair: (usize, usize))\n    requires exists|i: nat, j: nat| i < j < nums.len() && summing_pair(i, j, nums, target) && forall|l: nat, m: nat| l < m < nums.len() && l != i && m != j ==> !summing_pair(l, m, nums, target)\n    ensures \n        0 <= pair.0 < nums.len() && \n        0 <= pair.1 < nums.len() && \n        summing_pair(pair.0 as nat, pair.1 as nat, nums, target)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    (0, 0)\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "verified-using-dafny_tmp_tmp7jatpjyn_longestZero_longestZero", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn get_size(i: int, j: int) -> int {\n    j - i + 1\n}\n\n// For a given integer array, let's find the longest subsequence of 0s.\n// sz: size, pos: position. a[pos..(pos+sz)] will be all zeros", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn longest_zero(a: &[i32]) -> (result: (usize, usize))\n    requires \n        1 <= a.len()\n    ensures \n        result.0 <= a.len(),\n        result.1 < a.len(),\n        result.1 + result.0 <= a.len(),\n        forall |i: int| result.1 <= i < (result.1 + result.0) ==> a[i as int] == 0,\n        forall |i: int, j: int| {\n            0 <= i < j < a.len() && get_size(i, j) > (result.0 as int)\n            ==> exists |k: int| i <= k <= j && a[k] != 0\n        }\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  (0, 0)\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "veri-sparse_tmp_tmp15fywna6_dafny_dspmspv_DSpMSpV", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sum(X_val: Seq<int>, X_crd: Seq<nat>, \n           v_val: Seq<int>, v_crd: Seq<nat>, \n           kX: nat, kV: nat, pX_end: nat, pV_end: nat) -> int\n    decreases pX_end + pV_end - (kX + kV)\n{\n    if pV_end <= kV || pX_end <= kX {\n        0\n    } else if kX < X_crd.len() && kV < v_crd.len() && X_crd[kX as int] == v_crd[kV as int] {\n        sum(X_val, X_crd, v_val, v_crd, kX + 1, kV + 1, pX_end, pV_end) + \n        (if kV < v_val.len() && kX < X_val.len() { v_val[kV as int] * X_val[kX as int] } else { 0 })\n    } else if kX < X_crd.len() && kV < v_crd.len() && X_crd[kX as int] < v_crd[kV as int] {\n        sum(X_val, X_crd, v_val, v_crd, kX + 1, kV, pX_end, pV_end)\n    } else {\n        sum(X_val, X_crd, v_val, v_crd, kX, kV + 1, pX_end, pV_end)\n    }\n}\n\nspec fn min(x: nat, y: nat) -> nat {\n    if x <= y { x } else { y }\n}\n\nspec fn notin(y: nat, x: Seq<nat>) -> bool {\n    forall|i: int| 0 <= i < x.len() ==> y != #[trigger] x[i]\n}\n\nspec fn index_seq(x: nat, y: Seq<nat>) -> nat\n    decreases y.len()\n{\n    if y.len() == 0 {\n        0\n    } else if y[0] == x {\n        0\n    } else {\n        1 + index_seq(x, y.subrange(1, y.len() as int))\n    }\n}\n\nspec fn index(x: nat, y: Seq<nat>) -> nat {\n    index_seq(x, y)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn DSpMSpV(X_val: &[int], X_crd: &[nat], X_pos: &[nat], X_crd1: &[nat], X_len: nat,\n           v_val: &[int], v_crd: &[nat]) -> (result: Vec<int>)\n    // X requirements \n    requires X_pos.len() >= 1,\n    requires X_val.len() == X_crd.len(),\n    requires forall|i: int, j: int| 0 <= i < j < X_pos.len() ==> #[trigger] X_pos[i] <= #[trigger] X_pos[j],\n    requires forall|i: int| 0 <= i < X_pos.len() ==> 0 <= #[trigger] X_pos[i] <= X_val.len(),\n\n    requires X_len >= X_crd1.len(),\n    requires forall|i: int| 0 <= i < X_crd1.len() ==> #[trigger] X_crd1[i] < X_len,\n\n    requires X_crd1.len() < X_pos.len(),\n    requires forall|i: int, j: int| 0 <= i < j < X_crd1.len() ==> #[trigger] X_crd1[i] < #[trigger] X_crd1[j],\n\n    // v requirements \n    requires v_val.len() == v_crd.len(),\n\n    ensures result.len() == X_len,\n    ensures forall|i: int| 0 <= i < result.len() ==> {\n        let idx = index(i as nat, X_crd1@);\n        #[trigger] result[i] == if idx < X_crd1.len() {\n            sum(X_val@, X_crd@, v_val@, v_crd@, X_pos[idx as int], 0, \n                X_pos[idx as int + 1], v_val.len() as nat)\n        } else {\n            0\n        }\n    }\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "se2011_tmp_tmp71eb82zt_ass2_ex2_SecondLargest", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// ex2\n\n// this was me playing around to try and get an ensures for the method \n/*predicate method check(a: array<int>, seclar:int)\nrequires a.Length > 0\nreads a\n{ ensures exists i :: 0 <= i < a.Length && forall j :: (0 <= j < a.Length && j != i) ==> (a[i] >= a[j]) && (seclar <= a[i]) && ( if a[j] != a[i] then seclar >= a[j] else seclar <= a[j]) } */", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn second_largest(a: &[i32]) -> (seclar: i32)\n    requires a.len() > 0\n    //ensures exists i :: 0 <= i < a.len() && forall j :: (0 <= j < a.len() && j != i) ==> (a[i] >= a[j]) && (seclar <= a[i]) && ( if a[j] != a[i] then seclar >= a[j] else seclar <= a[j])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_626_AreaOfLargestTriangleInSemicircle", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn area_of_largest_triangle_in_semicircle(radius: i32) -> (area: i32)\n    requires radius > 0\n    ensures area == radius * radius\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  radius * radius\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "Clover_selectionsort_SelectionSort", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn selection_sort(a: &mut Vec<i32>)\n    ensures\n        forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j],\n        a@.to_multiset() == old(a)@.to_multiset(),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_470_PairwiseAddition", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn pairwise_addition(a: &[i32]) -> (result: Vec<i32>)\n    requires\n        a.len() % 2 == 0,\n    ensures\n        result.len() == a.len() / 2,\n        forall|i: int| 0 <= i < result.len() ==> result[i as int] == a[2*i] + a[2*i + 1],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  Vec::new()\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "Clover_multi_return_MultipleReturns", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn multiple_returns(x: int, y: int) -> (result: (int, int))\n    ensures \n        result.0 == x + y,\n        result.1 == x - y,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    (x + y, x - y)\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_799_RotateLeftBits", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn rotate_left_bits(n: u32, d: int) -> (result: u32)\n    requires 0 <= d < 32\n    ensures result == ((n << d) | (n >> (32 - d)))\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  n\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "Dafny_Programs_tmp_tmp99966ew4_binary_search_BinarySearch", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sorted(a: &[int]) -> bool {\n    forall|j: int, k: int| 0 <= j < k < a.len() ==> a[j] <= a[k]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn binary_search(a: &[int], value: int) -> (index: i32)\n    requires \n        sorted(a),\n    ensures \n        0 <= index ==> index < a.len() && a[index as int] == value,\n        index < 0 ==> forall|k: int| 0 <= k < a.len() ==> a[k] != value,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    -1\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_436_FindNegativeNumbers", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/**\n * Find negative numbers from an array of numbers\n **/\n\nspec fn is_negative(n: int) -> bool {\n    n < 0\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn find_negative_numbers(arr: &[int]) -> (negative_list: Vec<int>)\n    ensures\n        // All numbers in the output are negative and exist in the input\n        forall|i: int| 0 <= i < negative_list.len() ==> \n            is_negative(negative_list[i]) && exists|j: int| 0 <= j < arr.len() && arr[j] == negative_list[i],\n        // All negative numbers in the input are in the output\n        forall|i: int| 0 <= i < arr.len() && is_negative(arr[i]) ==> \n            exists|j: int| 0 <= j < negative_list.len() && negative_list[j] == arr[i],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Software-Verification_tmp_tmpv4ueky2d_Contains Duplicate_contains_duplicate_contains_duplicate", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn distinct(nums: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < nums.len() ==> nums[i] != nums[j]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn contains_duplicate(nums: Seq<int>) -> (result: bool)\n    requires\n        1 <= nums.len() <= 100000,\n        forall|i: int| 0 <= i < nums.len() ==> #[trigger] nums[i] >= -1000000000 && nums[i] <= 1000000000,\n    ensures\n        result <==> distinct(nums),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    true\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "vfag_tmp_tmpc29dxm1j_Verificacion_torneo_torneo", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn torneo(valores: &Vec<int>, i: usize, j: usize, k: usize) -> (res: (usize, usize))\n    requires \n        valores.len() >= 20 && valores.len() < 50,\n        i < valores.len() && j < valores.len() && k < valores.len(),\n        i != j && j != k && k != i,\n    ensures \n        exists|p: usize, q: usize, r: usize| \n            (p == i || p == j || p == k) &&\n            (q == i || q == j || q == k) &&  \n            (r == i || r == j || r == k) &&\n            p != q && q != r && p != r &&\n            valores[p as int] >= valores[q as int] && \n            valores[q as int] >= valores[r as int] &&\n            res.0 == p && \n            res.1 == q, // Q\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    (0, 0)\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "Formal-Verification-Project_tmp_tmp9gmwsmyp_strings3_isSubstring", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_prefix_pred(pre: Seq<char>, str: Seq<char>) -> bool {\n    pre.len() <= str.len() && \n    pre == str.subrange(0, pre.len() as int)\n}\n\nspec fn is_not_prefix_pred(pre: Seq<char>, str: Seq<char>) -> bool {\n    pre.len() > str.len() || \n    pre != str.subrange(0, pre.len() as int)\n}\n\nfn is_prefix(pre: Seq<char>, str: Seq<char>) -> (res: bool)\n    ensures \n        !res <==> is_not_prefix_pred(pre, str),\n        res <==> is_prefix_pred(pre, str),\n{\n    assume(false);\n    false\n}\n\nspec fn is_substring_pred(sub: Seq<char>, str: Seq<char>) -> bool {\n    exists|i: int| 0 <= i <= str.len() && is_prefix_pred(sub, str.subrange(i, str.len() as int))\n}\n\nspec fn is_not_substring_pred(sub: Seq<char>, str: Seq<char>) -> bool {\n    forall|i: int| 0 <= i <= str.len() ==> is_not_prefix_pred(sub, str.subrange(i, str.len() as int))\n}\n\nspec fn have_common_k_substring_pred(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool {\n    exists|i1: int, j1: int| 0 <= i1 <= str1.len() - k && j1 == i1 + k && is_substring_pred(str1.subrange(i1, j1), str2)\n}\n\nspec fn have_not_common_k_substring_pred(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool {\n    forall|i1: int, j1: int| 0 <= i1 <= str1.len() - k && j1 == i1 + k ==> is_not_substring_pred(str1.subrange(i1, j1), str2)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn is_substring(sub: Seq<char>, str: Seq<char>) -> (res: bool)\n    ensures res <==> is_substring_pred(sub, str)\n    //ensures !res <==> is_not_substring_pred(sub, str) // This postcondition follows from the above lemma.\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    false\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "dafleet_tmp_tmpa2e4kb9v_0001-0050_0001-two-sum_twoSum", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* https://leetcode.com/problems/two-sum/\nGiven an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nYou can return the answer in any order.\n\nExample 1:\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n*/\n\n\nspec fn correct_pair(pair: (int, int), nums: Seq<int>, target: int) -> bool {\n    let (i, j) = pair;\n    &&& 0 <= i < nums.len()\n    &&& 0 <= j < nums.len()\n    &&& i != j  // \"you may not use the same element twice\"\n    &&& nums[i] + nums[j] == target\n}\n\n// We actually make a weaker pre-condition: there exists at least one solution.\n// For verification simplicity, we pretend as if:\n// - `Seq` were Python list\n// - `Map` were Python dict\n\n/* Discussions\n1. It may be tempting to append `&& e_to_i[nums[i']] == i'` to the invariant (formula A),\n  but this is wrong, because `nums` may contain redundant elements.\n  Redundant elements will share the same key in `e_to_i`, the newer overwriting the older.\n\n2. Tip: Generally, we often need invariants when copying data from a container to another.\n  To specify a set/map, we often need \"back and forth\" assertions, namely:\n  (a) What elements are in the map/set (like in formula A)\n  (b) What do elements in the set/map satisfy (like in formula B)\n*/", "vc-helpers": "// <vc-helpers>\nspec fn seq_i32_to_int(s: Seq<i32>) -> Seq<int> {\n    s.map(|i, v| v as int)\n}\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn twoSum(nums: Seq<i32>, target: i32) -> (pair: (usize, usize))\n    requires exists|i: int, j: int| correct_pair((i, j), seq_i32_to_int(nums), target as int)\n    ensures correct_pair((pair.0 as int, pair.1 as int), seq_i32_to_int(nums), target as int)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    (0, 0)\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Clover_array_sum_arraySum", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn array_sum(a: &Vec<i32>, b: &Vec<i32>) -> (c: Vec<i32>)\n    requires \n        a.len() == b.len(),\n    ensures \n        c.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> a[i] + b[i] == c[i],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_145_MaxDifference", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn max_difference(a: &[i32]) -> (diff: i32)\n    requires a.len() > 1\n    ensures forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() ==> a[i] - a[j] <= diff\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  0\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_113_IsInteger", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_digit(c: char) -> bool {\n    48 <= c as int <= 57\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn is_integer(s: Seq<char>) -> (result: bool)\n    ensures result <==> (s.len() > 0) && (forall|i: int| 0 <= i < s.len() ==> is_digit(s[i]))\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    false\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafny-language-server_tmp_tmpkir0kenl_Test_dafny2_TuringFactorial_ComputeFactorial", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn factorial(n: nat) -> nat\n    decreases n\n{\n    if n == 0 { 1 } else { n * factorial((n - 1) as nat) }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn compute_factorial(n: i32) -> (u: i32)\n    requires 1 <= n,\n    ensures u == factorial(n as nat),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings3_haveCommonKSubstring", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// We spent 2h each on this assignment\n\nspec fn is_prefix_pred(pre: Seq<char>, s: Seq<char>) -> bool {\n    pre.len() <= s.len() && \n    pre == s.subrange(0, pre.len() as int)\n}\n\nspec fn is_not_prefix_pred(pre: Seq<char>, s: Seq<char>) -> bool {\n    pre.len() > s.len() || \n    pre != s.subrange(0, pre.len() as int)\n}\n\nfn is_prefix(pre: &str, s: &str) -> (res: bool)\n    ensures \n        !res <==> is_not_prefix_pred(pre@, s@),\n        res <==> is_prefix_pred(pre@, s@)\n{\n    assume(false);\n    true\n}\n\nspec fn is_substring_pred(sub: Seq<char>, s: Seq<char>) -> bool {\n    exists|i: int| 0 <= i <= s.len() && is_prefix_pred(sub, s.subrange(i, s.len() as int))\n}\n\nspec fn is_not_substring_pred(sub: Seq<char>, s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i <= s.len() ==> is_not_prefix_pred(sub, s.subrange(i, s.len() as int))\n}\n\nfn is_substring(sub: &str, s: &str) -> (res: bool)\n    ensures res <==> is_substring_pred(sub@, s@)\n    //ensures !res <==> is_not_substring_pred(sub@, s@) // This postcondition follows from the above lemma.\n{\n    assume(false);\n    true\n}\n\nspec fn have_common_k_substring_pred(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool {\n    exists|i1: int, j1: int| \n        0 <= i1 <= str1.len() - k && \n        j1 == i1 + k && \n        is_substring_pred(str1.subrange(i1, j1), str2)\n}\n\nspec fn have_not_common_k_substring_pred(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool {\n    forall|i1: int, j1: int| \n        0 <= i1 <= str1.len() - k && \n        j1 == i1 + k ==> \n        is_not_substring_pred(str1.subrange(i1, j1), str2)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn have_common_k_substring(k: nat, str1: &str, str2: &str) -> (found: bool)\n    ensures found <==> have_common_k_substring_pred(k, str1@, str2@)\n    //ensures !found <==> have_not_common_k_substring_pred(k, str1@, str2@) // This postcondition follows from the above lemma.\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    true\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafny-exercise_tmp_tmpouftptir_filter_Filter", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn filter(a: Seq<char>, b: Set<char>) -> (c: Set<char>)\n    ensures forall|x: char| a.contains(x) && b.contains(x) <==> c.contains(x)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    b  // This won't be reached due to assume(false), but satisfies the type checker\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafny_tmp_tmp59p638nn_examples_SelectionSort_SelectionSort", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn ordered(a: Seq<int>, left: int, right: int) -> bool {\n    &&& 0 <= left <= right <= a.len()\n    &&& forall |i: int| #![trigger a[i]] left < i < right ==> a[i-1] <= a[i]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn selection_sort(a: &mut Vec<int>)\n    ensures \n        ordered(a@, 0, a.len() as int),\n        a.len() == old(a).len(),\n        a@.to_multiset() =~= old(a)@.to_multiset(),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex7_Exchanger", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// see pdf 'ex6 & 7 documentation' for excercise question\n\n#[derive(PartialEq, Eq, Clone, Copy)]\nenum Bases {\n    A,\n    C,\n    G,\n    T,\n}\n\n//swaps two sequence indexes\n\n//idea from Rustan Leino video \"Basics of specification and verification: Lecture 3, the Dutch National Flag algorithm\"\n//modified for 4 elements\nspec fn below(first: Bases, second: Bases) -> bool {\n    first == second ||\n    first == Bases::A || \n    (first == Bases::C && (second == Bases::G || second == Bases::T)) || \n    (first == Bases::G && second == Bases::T) ||\n    second == Bases::T\n}\n\n//checks if a sequence is in base order\nspec fn bordered(s: Seq<Bases>) -> bool {\n    forall|j: int, k: int| 0 <= j < k < s.len() ==> below(s[j], s[k])\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn exchanger(s: Seq<Bases>, x: nat, y: nat) -> (t: Seq<Bases>)\n    requires \n        0 < s.len(),\n        x < s.len(),\n        y < s.len(),\n    ensures \n        t.len() == s.len(),\n        forall|b: nat| 0 <= b < s.len() && b != x && b != y ==> t[b as int] == s[b as int],\n        t[x as int] == s[y as int] && s[x as int] == t[y as int],\n        s.to_multiset() == t.to_multiset(),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    s\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_414_AnyValueExists", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn any_value_exists(seq1: Seq<int>, seq2: Seq<int>) -> (result: bool)\n    ensures result <==> (exists|i: int| 0 <= i < seq1.len() && seq2.contains(seq1[i]))\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    true\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_461_CountUppercase", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_upper_case(c: char) -> bool {\n    65 <= c as int <= 90\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn count_uppercase(s: &str) -> (count: usize)\n    ensures \n        count >= 0,\n        count as int == s@.filter(|c: char| is_upper_case(c)).len(),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Software-Verification_tmp_tmpv4ueky2d_Longest Increasing Subsequence_longest_increasing_subsequence_longest_increasing_subsequence", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// Function\nspec fn find_max(x: int, y: int) -> int {\n    if x > y { x } else { y }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn longest_increasing_subsequence(nums: &Vec<i32>) -> (max: i32)\n    requires \n        1 <= nums.len() <= 2500,\n        forall|i: int| 0 <= i < nums.len() ==> #[trigger] nums[i] >= -10000 && #[trigger] nums[i] <= 10000,\n    // TODO: modify the ensures clause so that max is indeed equal to the longest increasing subsequence\n    ensures \n        max >= 1,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  1 // unreachable but needed for return type\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings3_maxCommonSubstringLength", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_substring(sub: Seq<char>, str: Seq<char>) -> bool \n    decreases str.len()\n{\n    if sub.len() == 0 {\n        true\n    } else if sub.len() > str.len() {\n        false  \n    } else {\n        sub == str.subrange(0, sub.len() as int) || is_substring(sub, str.subrange(1, str.len() as int))\n    }\n}\n\n// We spent 2h each on this assignment\n\nspec fn is_prefix_pred(pre: Seq<char>, str: Seq<char>) -> bool {\n    pre.len() <= str.len() && \n    pre == str.subrange(0, pre.len() as int)\n}\n\nspec fn is_not_prefix_pred(pre: Seq<char>, str: Seq<char>) -> bool {\n    pre.len() > str.len() || \n    pre != str.subrange(0, pre.len() as int)\n}\n\nspec fn is_substring_pred(sub: Seq<char>, str: Seq<char>) -> bool {\n    exists|i: int| #![auto] 0 <= i && i <= str.len() && is_prefix_pred(sub, str.subrange(i, str.len() as int))\n}\n\nspec fn is_not_substring_pred(sub: Seq<char>, str: Seq<char>) -> bool {\n    forall|i: int| #![auto] 0 <= i && i <= str.len() ==> is_not_prefix_pred(sub, str.subrange(i, str.len() as int))\n}\n\n\nspec fn have_common_k_substring_pred(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool {\n    exists|i1: int, j1: int| #![auto] 0 <= i1 && i1 + k <= str1.len() && j1 == i1 + k && is_substring_pred(str1.subrange(i1, j1), str2)\n}\n\nspec fn have_not_common_k_substring_pred(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool {\n    forall|i1: int, j1: int| #![auto] 0 <= i1 && i1 + k <= str1.len() && j1 == i1 + k ==> is_not_substring_pred(str1.subrange(i1, j1), str2)\n}\n\nfn have_common_k_substring(k: usize, str1: Seq<char>, str2: Seq<char>) -> (found: bool)\n    ensures found <==> have_common_k_substring_pred(k as nat, str1, str2)\n    //ensures !found <==> have_not_common_k_substring_pred(k, str1, str2) // This postcondition follows from the above lemma.\n{\n    assume(false);\n    false\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn max_common_substring_length(str1: Seq<char>, str2: Seq<char>) -> (len: usize)\n    requires str1.len() <= str2.len()\n    ensures (forall|k: nat| #![auto] len < k && k <= str1.len() ==> !have_common_k_substring_pred(k, str1, str2))\n        && have_common_k_substring_pred(len as nat, str1, str2)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "Clover_swap_in_array_swap", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn swap(arr: &mut Vec<i32>, i: usize, j: usize)\n    requires \n        i < old(arr).len(),\n        j < old(arr).len(),\n    ensures\n        arr[i as int] == old(arr)[j as int],\n        arr[j as int] == old(arr)[i as int],\n        forall|k: int| 0 <= k < arr.len() && k != i && k != j ==> arr[k] == old(arr)[k],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "SENG2011_tmp_tmpgk5jq85q_flex_ex1_sum", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// sums from index 0 -> i - 1\nspec fn sumcheck(s: &[int], i: int) -> int\n    recommends 0 <= i <= s.len()\n    decreases i when 0 <= i <= s.len()\n{\n    if i == 0 { 0 }\n    else { s[i as nat - 1] + sumcheck(s, i - 1) }\n}\n\n// returns sum of array", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\n#[verifier::exec_allows_no_decreases_clause]\nfn sum(s: &[int]) -> (a: int)\n    requires s.len() > 0\n    ensures sumcheck(s, s.len() as int) == a\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    loop {}\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "Clover_cal_ans_CalDiv", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn cal_div() -> (result: (i32, i32))\n  ensures result.0 == 191i32 / 7i32 && result.1 == 191i32 % 7i32,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  (0i32, 0i32)\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_18_RemoveChars", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn remove_chars(s1: Seq<char>, s2: Seq<char>) -> (v: Seq<char>)\n    ensures \n        v.len() <= s1.len(),\n        forall|i: int| 0 <= i < v.len() ==> s1.contains(v[i]) && !s2.contains(v[i]),\n        forall|i: int| 0 <= i < s1.len() ==> s2.contains(s1[i]) || v.contains(s1[i])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_127_Multiply", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn multiply(a: int, b: int) -> (result: int)\n    ensures result == a * b\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    a * b  // This won't be reached due to assume(false)\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Dafny_tmp_tmpmvs2dmry_examples2_gcdCalc", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn gcd(m: nat, n: nat) -> nat\n    recommends m > 0 && n > 0\n    decreases m + n\n    when m > 0 && n > 0\n{\n    if m == n {\n        n\n    } else if m > n {\n        gcd(sub(m, n), n)\n    } else {\n        gcd(m, sub(n, m))\n    }\n}\n\nspec fn exp_nat(base: nat, n: nat) -> nat\n    decreases n\n{\n    if n == 0 {\n        1nat\n    } else if base == 0 {\n        0nat\n    } else {\n        base * exp_nat(base, sub(n, 1))\n    }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn gcd_calc(m: u32, n: u32) -> (res: u32)\n    requires m > 0 && n > 0\n    ensures res == gcd(m as nat, n as nat)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "SENG2011_tmp_tmpgk5jq85q_exam_ex3_Symmetric", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn symmetric(a: &[i32]) -> (flag: bool)\n    ensures \n        flag == true ==> forall|x: int| 0 <= x < a.len() ==> #[trigger] a[x] == a[a.len() - x - 1],\n        flag == false ==> exists|x: int| #[trigger] a[x] != a[a.len() - x - 1] && 0 <= x < a.len(),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    true\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_623_PowerOfListElements", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn power(base: int, exponent: int) -> int\n    recommends exponent >= 0\n    decreases exponent\n{\n    if exponent <= 0 { 1 } else { base * power(base, exponent - 1) }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn power_of_list_elements(l: Vec<i32>, n: u32) -> (result: Vec<i32>)\n    ensures \n        result.len() == l.len(),\n        forall|i: int| #![auto] 0 <= i < l.len() ==> result[i] == power(l[i] as int, n as int),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Clover_double_quadruple_DoubleQuadruple", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn double_quadruple(x: i32) -> (ret: (i32, i32))\n  ensures ret.0 == 2 * x && ret.1 == 4 * x\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  (0, 0)\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Clover_convert_map_key_convert_map_key", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn convert_map_key(inputs: Map<nat, bool>, f: spec_fn(nat) -> nat) -> (r: Map<nat, bool>)\n    requires\n        forall|n1: nat, n2: nat| \n            #[trigger] f(n1) != #[trigger] f(n2) ==> n1 != n2,\n    ensures\n        forall|k: nat| inputs.contains_key(k) <==> r.contains_key(f(k)),\n        forall|k: nat| inputs.contains_key(k) ==> r[f(k)] == inputs[k],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "bbfny_tmp_tmpw4m0jvl0_enjoying_FindMax", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// shenanigans going through the dafny tutorial\n\n\n\n\nspec fn max(a: int, b: int) -> int\n{\n  if a > b { a } else { b }\n}\nfn testing()\n{\n  assume(false);\n}\n\nspec fn abs(x: int) -> int\n{\n  if x < 0 { -x } else { x }\n}\n\n\nspec fn fib(n: nat) -> nat\n    decreases n\n{\n  if n == 0 { 0 }\n  else if n == 1 { 1 }\n  else { fib((n - 1) as nat) + fib((n - 2) as nat) }\n}\n\nspec fn sorted(a: &[int]) -> bool\n{\n  forall|j: int, k: int| 0 <= j < k < a.len() ==> a[j] < a[k]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn find_max(a: &[int]) -> (i: usize)\n    requires \n        a.len() >= 1\n    ensures \n        0 <= i < a.len(),\n        forall|k: int| 0 <= k < a.len() ==> a[k] <= a[i as int]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  0\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafny_projects_tmp_tmpjutqwjv4_tutorial_tutorial_FindZero", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// Working through https://dafny.org/dafny/OnlineTutorial/guide\n\nspec fn fib(n: nat) -> nat \n    decreases n\n{\n    if n == 0 { 0nat }\n    else if n == 1 { 1nat }\n    else { fib((n - 1) as nat) + fib((n - 2) as nat) }\n}\n\n\nspec fn sorted(a: Seq<int>) -> bool {\n    forall|n: int, m: int| 0 <= n < m < a.len() ==> a[n] <= a[m]\n}\n\n\n\n// https://dafny.org/dafny/OnlineTutorial/ValueTypes\n\nspec fn update(s: Seq<int>, i: int, v: int) -> Seq<int>\n{\n    s.subrange(0, i).add(seq![v]).add(s.subrange(i + 1, s.len() as int))\n}\n\n\n// https://dafny.org/dafny/OnlineTutorial/Lemmas\n\nspec fn count(a: Seq<bool>) -> nat\n    decreases a.len()\n{\n    if a.len() == 0 { \n        0nat\n    } else {\n        (if a[0] { 1nat } else { 0nat }) + count(a.subrange(1, a.len() as int))\n    }\n}\n\n\nstruct Node {\n    next: Seq<int>, // Using int IDs instead of references for simplicity\n}\n\nspec fn closed(graph: Set<int>) -> bool {\n    true // Simplified for translation\n}\n\nspec fn path(p: Seq<int>, graph: Set<int>) -> bool \n    decreases p.len()\n{\n    closed(graph) && 0 < p.len() &&\n    graph.contains(p[0]) &&\n    (p.len() > 1 ==> \n        path(p.subrange(1, p.len() as int), graph))\n}\n\nspec fn path_specific(p: Seq<int>, start: int, end: int, graph: Set<int>) -> bool {\n    closed(graph) &&\n    0 < p.len() && // path is nonempty\n    start == p[0] && end == p[p.len() - 1] && // it starts and ends correctly\n    path(p, graph) // and it is a valid path\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn find_zero(a: &[int]) -> (index: i32)\n    requires \n        forall|i: int| #![trigger a[i]] 0 <= i < a.len() ==> 0 <= a[i],\n        forall|i: int| #![trigger a[i]] 0 < i < a.len() ==> a[i-1] - 1 <= a[i],\n    ensures \n        index < 0 ==> forall|i: int| #![trigger a[i]] 0 <= i < a.len() ==> a[i] != 0,\n        0 <= index ==> index < a.len() && a[index as int] == 0,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    -1\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "Formal-methods-of-software-development_tmp_tmppryvbyty_Bloque 2_Lab6_vector_Sum", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/*predicate palindrome<T(==)> (s:seq<T>)\n{\n    forall i:: 0<=i<|s| ==> s[i] == s[|s|-i-1]\n}\n*/\n// SUM OF A SEQUENCE OF INTEGERS\nspec fn sum(v: Seq<int>) -> int \n    decreases v.len()\n{\n    if v.len() == 0 { \n        0 \n    } else if v.len() == 1 { \n        v[0] \n    } else { \n        v[0] + sum(v.subrange(1, v.len() as int))\n    }\n}\n\n// Structural Induction on Sequences\n\n// MAXIMUM OF A SEQUENCE\n\n// TODO: Hacer\n// Derivar formalmente un calculo incremental de j*j*j\n\n\n// REVERSE OF A SEQUENCE\nspec fn reverse<T>(s: Seq<T>) -> Seq<T> \n    decreases s.len()\n{\n    if s.len() == 0 { \n        seq![] \n    } else { \n        reverse(s.subrange(1, s.len() as int)).push(s[0])\n    }\n}\n\nspec fn seq2set<T>(s: Seq<T>) -> Set<T> \n    decreases s.len()\n{\n    if s.len() == 0 { \n        set!{} \n    } else { \n        set!{s[0]}.union(seq2set(s.subrange(1, s.len() as int)))\n    }\n}\n\n\n// REVERSE IS ITS OWN INVERSE\n\n// SCALAR PRODUCT OF TWO VECTORS OF INTEGER\nspec fn scalar_product(v1: Seq<int>, v2: Seq<int>) -> int\n    decreases v1.len()\n{\n    if v1.len() == 0 || v2.len() == 0 { \n        0 \n    } else { \n        v1[0] * v2[0] + scalar_product(v1.subrange(1, v1.len() as int), v2.subrange(1, v2.len() as int))\n    }\n}\n\n// MULTISETS\n\nfn multiplicity_examples<T>()\n{\n  assume(false);\n}\n\n// REVERSE HAS THE SAME MULTISET", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn vector_Sum(v: Seq<int>) -> (x: i32)\n    ensures x == sum(v)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  0\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "DafnyPrograms_tmp_tmp74_f9k_c_invertarray_InvertArray", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/**\n  Inverts an array of ints.\n */", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn invert_array(a: &mut Vec<i32>)\n    ensures\n        a.len() == old(a).len(),\n        forall|i: int| 0 <= i < a.len() ==> a[i] == old(a)[a.len() - 1 - i],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_3_IsNonPrime", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn is_non_prime(n: int) -> (result: bool)\n    requires n >= 2\n    ensures result <==> (exists|k: int| 2 <= k < n && #[trigger] (n % k) == 0)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  true // dummy return value\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "Clover_test_array_TestArrayElements", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn test_array_elements(a: &mut Vec<i32>, j: usize)\n    requires \n        j < old(a).len(),\n    ensures \n        a.len() == old(a).len(),\n        a[j as int] == 60,\n        forall|k: int| 0 <= k < a.len() && k != j ==> a[k] == old(a)[k],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_05_Hoangkim_ex_05_Hoangkim_gcdI", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n//Problem01\nspec fn fib(n: nat) -> nat\n    decreases n\n{\n    if n < 2 { n } else { fib((n-2) as nat) + fib((n-1) as nat) }\n}\n\n//# 2 pts\n\n//Problem02\nspec fn fact(n: nat) -> nat\n    decreases n\n{\n    if n == 0 { 1 } else { n * fact((n-1) as nat) }\n}\n\n//# 3 pts\n//Problem03\nspec fn gcd(m: nat, n: nat) -> nat\n    decreases (m + n)\n{\n    if m == 0 || n == 0 { 0 }\n    else if m == n { m }\n    else if m > n { gcd((m - n) as nat, n) }\n    else { gcd(m, (n - m) as nat) }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn gcd_iterative(m: u32, n: u32) -> (g: u32)\n    requires m > 0 && n > 0\n    ensures g == gcd(m as nat, n as nat);\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "//# 3 pts\n\n\n// # sum: 9 pts\n\nfn main() {\n}\n\n}"}
{"id": "formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_DivMod1", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/*\nVerus include 2 limbaje:\n    * un limbaj pentru specificare \n        MSFOL (ce am discutat până acum)\n        adnotări care să ajute în procesul de verificare\n    * un limbaj pentru scris programe\n*/\n\n// Exemplu de program\n\n\n\n/*\n    triple Hoare (| P |) S (| Q |) \n*/\n\n// varianta assume-assert\n\n// varianta requires-ensures\n\n\n/*\nregula pentru while\n*/\n\n// varianta cu assert\n/*\n*/\n\n// varianta cu invariant\n\n//specificarea sumei de patrate\nspec fn SqrSumRec(n: int) -> int\n    decreases n when n >= 0\n{\n    if n <= 0 { 0 } else { n*n + SqrSumRec(n-1) }\n}\n/*\n*/\n\n// verificarea programului pentru suma de patrate\n\n\n// SqrSumRec(n) = 0^2 + 1^2 + 2^2 + ... + n^2 == n(n+1)(2n+1)/6\nproof fn L1(n: int)\n    requires n >= 0\n    ensures SqrSumRec(n) == n*(n+1)*(2*n + 1)/6\n    decreases n\n{\n    if n == 0 {\n        // Base case holds automatically\n    } else {\n        L1(n-1);\n        // Inductive step would require additional arithmetic reasoning\n    }\n}\n\n/*\nspec fn SqrSumBy6(n: int) -> int\n{\n    n * (n + 1) * (2 * n + 1) \n}\n\nproof fn L(n: int) // it takes a while\n    decreases n\n    requires n >= 0\n    ensures  SqrSumBy6(n) == 6 * SqrSumRec(n)\n{\n    if n == 0 {\n    } else {\n        assert(n > 0);\n        L(n-1);\n        assert(SqrSumBy6(n-1) == n*(n-1)*(2*n - 1));\n        assert(SqrSumBy6(n-1) == 6*SqrSumRec(n-1));\n        assert(6*SqrSumRec(n-1) == n*(n-1)*(2*n - 1));\n        // Sequential assertions replacing calc chains\n        assert(n*((n-1)*(2*n - 1)) == n*(2*n*(n-1) - n + 1));\n        assert(n*(2*n*(n-1) - n + 1) == n*(2*n*n - 3*n + 1));\n        \n        assert(2*n*n + n == (2*n + 1)*n);\n        \n        assert((2*n + 1)*n + (2*n + 1) == (2*n + 1)*(n+1));\n        \n        // Additional algebraic steps would be needed here\n    }\n}\n\n*/", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn DivMod1(a: u32, b: u32) -> (result: (u32, u32))\n    requires b > 0 && a >= 0\n    ensures a == b * result.0 + result.1 && 0 <= result.1 < b\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    (0, 0)\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "DafnyProjects_tmp_tmp2acw_s4s_Power_powerDC", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* \n* Formal verification of an O(log n) algorithm to calculate the natural power of an integer (x^n), \n* illustrating the usage of lemmas and automatic induction in Verus.\n* Translated from Dafny to Verus.\n*/\n\n// Recursive definition of x^n in functional style, with time and space complexity O(n).\nspec fn power(x: int, n: nat) -> int\n    decreases n\n{\n    if n == 0 { 1 } else { x * power(x, (n - 1) as nat) }\n}\n\n// Computation of x^n in time and space O(log n).", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn power_dc(x: i64, n: u64) -> (p: i64)\n    ensures p == power(x as int, n as nat)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    1\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n    // A few test cases would go here\n}\n\n}"}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_ProgramProofs_ch15_QuickSort", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nfn partition(a: &mut Vec<int>, lo: usize, hi: usize) -> (p: usize)\n    requires 0 <= lo < hi <= old(a).len(),\n    ensures lo <= p < hi,\n{\n    assume(false);\n    0\n}\n\nspec fn split_point(a: &Vec<int>, n: usize) -> bool\n    recommends 0 <= n <= a.len(),\n{\n    forall|i: int, j: int| 0 <= i < n && n <= j < a.len() ==> a[i] <= a[j]\n}\n\nspec fn swap_frame(a: &Vec<int>, old_a: &Vec<int>, lo: usize, hi: usize) -> bool\n    recommends 0 <= lo <= hi <= a.len(),\n{\n    (forall|i: int| (0 <= i < lo || hi <= i < a.len()) ==> a[i] == old_a[i]) &&\n    a@.to_multiset() =~= old_a@.to_multiset()\n}\n\nfn quick_sort_aux(a: &mut Vec<int>, lo: usize, hi: usize)\n    requires \n        0 <= lo <= hi <= old(a).len(),\n        split_point(old(a), lo),\n        split_point(old(a), hi),\n    ensures \n        forall|i: int, j: int| lo <= i < j < hi ==> a[i] <= a[j],\n        swap_frame(a, old(a), lo, hi),\n        split_point(a, lo),\n        split_point(a, hi),\n    decreases hi - lo,\n{\n    assume(false);\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn quick_sort(a: &mut Vec<int>)\n    ensures \n        forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j],\n        a@.to_multiset() =~= old(a)@.to_multiset(),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "Clover_bubble_sort_BubbleSort", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn bubble_sort(a: &mut Vec<i32>)\n    ensures \n        forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j],\n        a@.to_multiset() == old(a)@.to_multiset(),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_BubbleSort_bubbleSort", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sorted(a: Seq<i32>, from: int, to: int) -> bool\n    recommends 0 <= from <= to <= a.len()\n{\n    forall|u: int, v: int| from <= u < v < to ==> a[u] <= a[v]\n}\n\nspec fn pivot(a: Seq<i32>, to: int, pvt: int) -> bool\n    recommends 0 <= pvt < to <= a.len()\n{\n    forall|u: int, v: int| 0 <= u < pvt < v < to ==> a[u] <= a[v]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn bubbleSort(a: &mut Vec<i32>)\n    requires \n        old(a).len() > 0,\n    ensures \n        sorted(a@, 0, a.len() as int),\n        a@.to_multiset() == old(a)@.to_multiset(),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBinarySearch_otherbSearch", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sorted(s: Seq<i32>) -> bool {\n    forall|u: int, w: int| 0 <= u < w < s.len() ==> s[u] <= s[w]\n}\n\nfn binary_search(v: &Vec<i32>, elem: i32) -> (p: i32)\n    requires sorted(v@)\n    ensures -1 <= p < v.len()\n    ensures forall|u: int| 0 <= u <= p ==> v[u] <= elem\n    ensures forall|w: int| p < w < v.len() ==> v[w] > elem\n{\n    assume(false);\n    -1\n}\n\n\n\n\n\n\n// Recursive binary search", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn other_b_search(v: &Vec<i32>, elem: i32) -> (res: (bool, usize))\n    requires sorted(v@)\n    ensures 0 <= res.1 <= v.len()\n    ensures res.0 == v@.contains(elem)\n    ensures res.0 ==> res.1 < v.len() && v[res.1 as int] == elem\n    ensures !res.0 ==> forall|u: int| 0 <= u < res.1 ==> v[u] < elem\n    ensures !res.0 ==> forall|w: int| res.1 <= w < v.len() ==> v[w] > elem\n// Implement and verify\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    (false, 0)\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_431_HasCommonElement", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn has_common_element(a: &[i32], b: &[i32]) -> (result: bool)\n    ensures \n        result ==> (exists|i: int, j: int| 0 <= i < a.len() && 0 <= j < b.len() && a[i] == b[j]) &&\n        (!result ==> (forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < b.len() ==> a[i] != b[j]))\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    true\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_430_ParabolaDirectrix", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn parabola_directrix(a: int, h: int, k: int) -> (directrix: int)\n    requires a != 0\n    // Note: In Verus, complex floating-point arithmetic in specifications is limited\n    // This represents the mathematical relationship: directrix == k - 1/(4*a)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    k // Placeholder - would be k - 1/(4*a) in mathematical terms  \n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "Clover_has_close_elements_has_close_elements", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\nspec fn abs_diff(a: int, b: int) -> int {\n    if a - b < 0 { b - a } else { a - b }\n}\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn has_close_elements(numbers: Seq<int>, threshold: int) -> (res: bool)\n    requires threshold >= 0,\n    ensures ({\n        &&& (res ==> exists|i: int, j: int| 0 <= i < numbers.len() && 0 <= j < numbers.len() && i != j && \n            abs_diff(numbers[i], numbers[j]) < threshold)\n        &&& (!res ==> forall|i: int, j: int| 1 <= i < numbers.len() && 0 <= j < i ==> \n            abs_diff(numbers[i], numbers[j]) >= threshold)\n    }),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    false\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session10Exercises_ExerciseBarrier_barrier", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n//Method barrier below receives an array and an integer p\n//and returns a boolean b which is true if and only if \n//all the positions to the left of p and including also position p contain elements \n//that are strictly smaller than all the elements contained in the positions to the right of p \n\n//Examples:\n// If v=[7,2,5,8] and p=0 or p=1 then the method must return false, \n// but for p=2 the method should return true\n//1.Specify the method\n//2.Implement an O(v.size()) method\n//3.Verify the method", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn barrier(v: &[i32], p: usize) -> (b: bool)\n//Give the precondition\n//Give the postcondition\n//{Implement and verify}\n    requires \n        v.len() > 0,\n        p < v.len(),\n    ensures \n        b == forall|k: usize, l: usize| \n            k <= p && p < l && l < v.len() ==> v[k as int] < v[l as int]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    true\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_105_CountTrue", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn count_to(a: &[bool], n: int) -> int\n    decreases n when 0 <= n <= a.len()\n{\n    if n <= 0 { \n        0int \n    } else { \n        count_to(a, n - 1) + if a[n - 1] { 1int } else { 0int } \n    }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn count_true(a: &[bool]) -> (result: usize)\n    ensures result == count_to(a, a.len() as int)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafny-programs_tmp_tmpcwodh6qh_src_factorial_factorial", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn fact(n: nat) -> nat \n    decreases n\n{\n    if n == 0 { 1 } else { n * fact((n - 1) as nat) }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn factorial(n: u32) -> (res: u32)\n    requires n <= 12  // to prevent overflow\n    ensures res == fact(n as nat)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  0  // dummy return to satisfy type checker\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "FlexWeek_tmp_tmpc_tfdj_3_reverse_Reverse", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// Write an *iterative* Verus method reverse with signature:", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "//          fn reverse(a: &Vec<char>) -> Vec<char>\n\n// which takes an input vector of characters 'a' and outputs vector 'b' consisting of\n// the elements of the input vector in reverse order. The following conditions apply:\n//  - the input vector cannot be empty\n//  - the input vector is not modified\n//  - you must use iteration\n//  - not permitted is an *executable* (parallel) forall statement\n//  - not permitted are any other predicates, functions or methods\n\n// For the purposes of this practice exercise, I'll include a test method.\n\n// <vc-spec>\nfn reverse(a: &Vec<char>) -> (b: Vec<char>)\n    requires a.len() > 0\n    ensures \n        a.len() == b.len(),\n        forall|k: int| 0 <= k < a.len() ==> b[k] == a[(a.len() - 1) - k]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>", "vc-postamble": "// Notice it compiles and the executable generates output (just to see the vectors printed in reverse).\n\nfn main() {\n    \n}\n\n}"}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_ProgramProofs_ch15_Partition", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn split_point(a: Seq<int>, n: int) -> bool {\n    0 <= n <= a.len() &&\n    forall|i: int, j: int| 0 <= i < n <= j < a.len() ==> a[i] <= a[j]\n}\n\n\n\nspec fn swap_frame(a_old: Seq<int>, a_new: Seq<int>, lo: int, hi: int) -> bool {\n    0 <= lo <= hi <= a_old.len() &&\n    a_old.len() == a_new.len() &&\n    (forall|i: int| (0 <= i < lo || hi <= i < a_old.len()) ==> a_new[i] == a_old[i]) &&\n    a_new.to_multiset() == a_old.to_multiset()\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn partition(a: &mut Vec<int>, lo: usize, hi: usize) -> (p: usize)\n    requires\n        0 <= lo < hi <= old(a).len(),\n        split_point(old(a)@, lo as int),\n        split_point(old(a)@, hi as int),\n    ensures\n        lo <= p < hi,\n        forall|i: int| lo <= i < p ==> a[i] < a[p as int],\n        forall|i: int| p <= i < hi ==> a[p as int] <= a[i],\n        split_point(a@, lo as int),\n        split_point(a@, hi as int),\n        swap_frame(old(a)@, a@, lo as int, hi as int),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  lo\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "Clover_quotient_Quotient", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nproof fn quotient(x: nat, y: nat) -> (result: (int, int))\n    requires y != 0\n    ensures ({\n        let (r, q) = result;\n        q * y + r == x && 0 <= r < y && 0 <= q\n    })\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    (0, 0) // unreachable due to assume(false)\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "CVS-handout1_tmp_tmptm52no3k_1_query", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/*                                      Cumulative Sums over Arrays                                        */\n\n/*\n    Daniel Cavalheiro   57869\n    Pedro Nunes         57854\n*/\n\n\n\n//(a)\n\nspec fn sum(a: &[int], i: int, j: int) -> int\n    recommends 0 <= i <= j <= a.len()\n    decreases j - i when 0 <= i <= j <= a.len()\n{\n    if i == j { 0 }\n    else { a[i] + sum(a, i + 1, j) }\n}\n\n\n\n//(b)\n\n//(c)\n\nspec fn is_prefix_sum_for(a: &[int], c: &[int]) -> bool\n{\n    &&& a.len() + 1 == c.len()\n    &&& c[0] == 0\n    &&& forall|i: int| 0 <= i < a.len() ==> c[i + 1] == c[i] + a[i]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn query(a: &[int], i: usize, j: usize) -> (res: i64)\n    requires 0 <= i <= j <= a.len()\n    ensures res == sum(a, i as int, j as int)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  0i64\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_142_CountIdenticalPositions", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn count_identical_positions(a: Seq<int>, b: Seq<int>, c: Seq<int>) -> (count: usize)\n    requires\n        a.len() == b.len() && b.len() == c.len(),\n    ensures\n        count >= 0,\n        count == Set::<int>::new(|i: int| 0 <= i < a.len() && a[i] == b[i] && b[i] == c[i]).len(),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_Reverse", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// ASSIGNMENT P1\n// CMSC 433 FALL 2023\n// PERFECT SCORE:  100 POINTS\n//\n// This assignment contains nine questions, each of which involves writing Verus\n// code. You should include your solutions in a single Verus file and submit it using\n// Gradescope.\n//\n// Revision history\n//\n// 2023-09-22 2:50 pm   Fixed typo in Problem 3.\n\n\n// Question 1 (5 points)\n//\n// Fill in a requires clause that enables Verus to verify\n// method PlusOne\n\n\n\n// Question 2 (5 points)\n//\n// Fill in requires clause(s) that enable(s) Verus to verify the array bounds\n// in method Swap (which swaps elements i and j in array a).\n\n\n// Question 3 (5 points)\n//\n// Give ensures clause(s) asserting that d is the result, and r the\n// remainder, of dividing m by n.  Your clauses cannot use \"/\" or \"%\" (which are\n// the Verus division and mod operators, respectively). By definition, the\n// remainder must be non-negative.\n\n\n// Question 4 (5 points)\n//\n// Give ensures clause(s) asserting that the return value has the same\n// length as array a and contains as its elements the sum of the\n// corresponding elements in arrays a and b.\n\n\n// Question 5 (10 points)\n\n// Euclid's algorithm is used to compute the greatest common divisor of two\n// positive integers.  If m and n are two such integers, then gcd(m,n) is the\n// largest positve integer that evenly divides both m and n, where j evenly divides i\n// if and only if i % j == 0 (% is the Verus mod operator).  Write requires and\n// ensures clauses for the method header Euclid below.  Your requires clauses\n// should also specify that the first argument is at least as large as the second.\n// You do *not* need to implement the method!\n\n\n// Question 7 (20 points)\n//\n// Implement, and have Verus verify, the method IsPrime below, which returns true\n// if and only if the given positive integer is prime.\n\n\n// Question 8 (20 points)\n//\n// Implement, and have Verus verify, the method Reverse below, which returns a new array\n// aRev consisting of the elements of a, but in reverse order.  To create a new \n// array of ints use the Verus command \"Vec::with_capacity(...)\", where \"...\" is the number\n// of elements in the array.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn reverse(a: &Vec<i32>) -> (a_rev: Vec<i32>)\n    ensures\n        a_rev.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> a[i] == a_rev[a_rev.len() - i - 1]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>", "vc-postamble": "// Question 9 (20 points)\n//\n// Implement and verify method NoDups, which returns true if and only if there\n// are no duplicate elements in array a.  Note that the requires clause allows\n// you to assume that a is sorted, and that this precondition is necessary for\n// the ensures clause to imply a lack of duplicates.\n\nfn main() {}\n\n}"}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session6Exercises_ExercisePeekSum_mPeekSum", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_peek(v: &Vec<i32>, i: int) -> bool\n    recommends 0 <= i < v.len()\n{\n    forall|k: int| 0 <= k < i ==> v[i] >= v[k]\n}\n\nspec fn peek_sum(v: &Vec<i32>, i: int) -> int\n    recommends 0 <= i <= v.len()\n    decreases i when 0 <= i <= v.len()\n{\n    if i == 0 {\n        0\n    } else {\n        if is_peek(v, i - 1) {\n            v[i - 1] + peek_sum(v, i - 1)\n        } else {\n            peek_sum(v, i - 1)\n        }\n    }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn m_peek_sum(v: &Vec<i32>) -> (sum: i32)\n    requires v.len() > 0\n    ensures sum == peek_sum(v, v.len() as int)\n    //Implement and verify an O(v.len()) algorithm to solve this problem\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_leetcode_FindPivotIndex_FindPivotIndex", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/*\nhttps://leetcode.com/problems/find-pivot-index/description/\nGiven an array of integers nums, calculate the pivot index of this array.\n\nThe pivot index is the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the right.\n\nIf the index is on the left edge of the array, then the left sum is 0 because there are no elements to the left. This also applies to the right edge of the array.\n\nReturn the leftmost pivot index. If no such index exists, return -1.\n\n\n\nExample 1:\n\nInput: nums = [1,7,3,6,5,6]\nOutput: 3\nExplanation:\nThe pivot index is 3.\nLeft sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11\nRight sum = nums[4] + nums[5] = 5 + 6 = 11\nExample 2:\n\nInput: nums = [1,2,3]\nOutput: -1\nExplanation:\nThere is no index that satisfies the conditions in the problem statement.\nExample 3:\n\nInput: nums = [2,1,-1]\nOutput: 0\nExplanation:\nThe pivot index is 0.\nLeft sum = 0 (no elements to the left of index 0)\nRight sum = nums[1] + nums[2] = 1 + -1 = 0\n\n```TypeScript\nfunction pivotIndex(nums: number[]): number {\n    const n = nums.length;\n    let leftsums = [0], rightsums = [0];\n    for(let i=1; i < n+1; i++) {\n        leftsums.push(nums[i-1]+leftsums[i-1]);\n        rightsums.push(nums[n-i]+rightsums[i-1]);\n    }\n    for(let i=0; i <= n; i++) {\n        if(leftsums[i] == rightsums[n-(i+1)]) return i;\n    }\n    return -1;\n};\n```\n*/\n\nspec fn sum(nums: Seq<int>) -> int\n    decreases nums.len()\n{\n    if nums.len() == 0 { \n        0 \n    } else { \n        sum(nums.subrange(0, nums.len() as int - 1)) + nums[nums.len() - 1]\n    }\n}\n\n\nspec fn sum_up(nums: Seq<int>) -> int\n    decreases nums.len()\n{\n    if nums.len() == 0 { \n        0 \n    } else { \n        nums[0] + sum_up(nums.subrange(1, nums.len() as int))\n    }\n}\n\n// By Divyanshu Ranjan\n\n// By Divyanshu Ranjan", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn find_pivot_index(nums: &Vec<i32>) -> (index: i32)\n    requires nums.len() > 0\n    ensures index == -1 ==> forall |k: nat| #[trigger] sum(nums@.map_values(|v: i32| v as int).subrange(0, k as int)) != #[trigger] sum(nums@.map_values(|v: i32| v as int).subrange((k + 1) as int, nums@.len() as int))\n    ensures 0 <= index < nums.len() ==> sum(nums@.map_values(|v: i32| v as int).subrange(0, index as int)) == sum(nums@.map_values(|v: i32| v as int).subrange((index + 1) as int, nums@.len() as int))\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    -1\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafny-programs_tmp_tmpcwodh6qh_src_expt_expt", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn expt(b: int, n: nat) -> int\n    decreases n\n{\n    if n == 0 { 1 } else { b * expt(b, (n - 1) as nat) }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn expt_method(b: i32, n: u32) -> (res: i32)\n    ensures res == expt(b as int, n as nat)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafny-language-server_tmp_tmpkir0kenl_Test_VSComp2010_Problem1-SumMax_M", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// VSComp 2010, problem 1, compute the sum and max of the elements of an array and prove\n// that 'sum <= N * max'.\n// Rustan Leino, 18 August 2010.\n//\n// The problem statement gave the pseudo-code for the method, but did not ask to prove\n// that 'sum' or 'max' return as the sum and max, respectively, of the array.  The\n// given assumption that the array's elements are non-negative is not needed to establish\n// the requested postcondition.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn M(N: int, a: &[int]) -> (result: (int, int))\n    requires \n        0 <= N,\n        a.len() == N,\n        forall|k: int| 0 <= k && k < N ==> 0 <= a[k],\n    ensures \n        result.0 <= N * result.1;\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "MIEIC_mfes_tmp_tmpq3ho7nve_exams_mt2_19_p4_calcR", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn R(n: nat) -> nat\n    decreases n\n{\n    if n == 0 { \n        0nat \n    } else if R((n-1) as nat) > n { \n        (R((n-1) as nat) - n) as nat\n    } else { \n        (R((n-1) as nat) + n) as nat\n    }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn calcR(n: u64) -> (r: u64)\n    ensures r == R(n as nat)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Correctness_tmp_tmpwqvg5q_4_Sorting_Tangent_BinarySearch", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/**\n  Ather, Mohammad Faiz (s4648481/3)\n  CSSE3100\n  Assignemnt 3\n  The University of Queensland\n */\n\n// Question 1\n\n// Author: Leino, Title: Program Proofs", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn binary_search(a: &[i32], circle: i32) -> (n: usize)\n    requires \n        forall|i: int| #![trigger a[i]] 1 <= i < a.len() ==> a[i-1] < a[i],\n        forall|i: int, j: int| #![trigger a[i], a[j]] 0 <= i < j < a.len() ==> a[i] < a[j],\n    ensures \n        n <= a.len(),\n        forall|i: int| #![trigger a[i]] 0 <= i < n ==> a[i] < circle,\n        forall|i: int| #![trigger a[i]] n <= i < a.len() ==> circle <= a[i],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_804_IsProductEven", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_even(n: int) -> bool {\n    n % 2 == 0\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn is_product_even(a: &[int]) -> (result: bool)\n    ensures result <==> exists|i: int| 0 <= i < a.len() && is_even(a@[i])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  false\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "Dafny-experiences_tmp_tmp150sm9qy_dafny_started_tutorial_dafny_tutorial_array_FindMax", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn find_max(a: &[i32]) -> (i: usize)\n    // Annotate this method with pre- and postconditions\n    // that ensure it behaves as described.\n    requires \n        a.len() > 0,\n    ensures\n        i < a.len(),\n        forall|k: int| 0 <= k < a.len() ==> a[k] <= a[i as int],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_290_MaxLengthList", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn max_length_list(lists: &Vec<Vec<int>>) -> (max_list: Vec<int>)\n    requires lists.len() > 0\n    ensures forall|i: int| 0 <= i < lists.len() ==> lists[i].len() <= max_list.len(),\n            exists|i: int| 0 <= i < lists.len() && max_list@ == lists[i]@\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    proof {\n        assume(false);\n    }\n    Vec::new()\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_A2_Q1_trimmed copy - 副本_PreCompute", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn count(hi: nat, s: Seq<i32>) -> int\n    decreases hi\n{\n    if hi == 0 {\n        0\n    } else if s[hi - 1] % 2 == 0 {\n        1 + count((hi - 1) as nat, s)\n    } else {\n        count((hi - 1) as nat, s)\n    }\n}\n\n\n\n\nfn compute_count(count_index: usize, a: &Vec<i32>, b: &mut Vec<i32>) -> (p: usize)\n    requires \n        count_index == 0 || (a.len() == old(b).len() && 1 <= count_index <= a.len()),\n    ensures \n        p == count(count_index as nat, a@),\n{\n  assume(false);\n  0\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn pre_compute(a: &Vec<i32>, b: &mut Vec<i32>) -> (p: usize)\n    requires \n        a.len() == old(b).len(),\n    ensures \n        (b.len() == 0 || (a.len() == b.len() && 1 <= b.len() <= a.len())) &&\n        p == count(b.len() as nat, a@),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  0\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "Clover_triple3_Triple", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nproof fn triple(x: int) -> (r: int)\n  ensures r == 3 * x\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  0 as int  // unreachable due to assume(false)\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "formal-verification_tmp_tmpoepcssay_strings3_isPrefix", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_prefix_pred(pre: Seq<char>, str: Seq<char>) -> bool {\n    pre.len() <= str.len() && \n    pre == str.subrange(0, pre.len() as int)\n}\n\nspec fn is_not_prefix_pred(pre: Seq<char>, str: Seq<char>) -> bool {\n    pre.len() > str.len() || \n    pre != str.subrange(0, pre.len() as int)\n}\n\nspec fn is_substring_pred(sub: Seq<char>, str: Seq<char>) -> bool {\n    exists|i: int| 0 <= i <= str.len() && is_prefix_pred(sub, str.subrange(i, str.len() as int))\n}\n\nspec fn is_not_substring_pred(sub: Seq<char>, str: Seq<char>) -> bool {\n    forall|i: int| 0 <= i <= str.len() ==> is_not_prefix_pred(sub, str.subrange(i, str.len() as int))\n}\n\n\n\n\nspec fn have_common_k_substring_pred(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool {\n    exists|i1: int, j1: int| 0 <= i1 <= str1.len() - k && j1 == i1 + k && is_substring_pred(str1.subrange(i1, j1), str2)\n}\n\nspec fn have_not_common_k_substring_pred(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool {\n    forall|i1: int, j1: int| 0 <= i1 <= str1.len() - k && j1 == i1 + k ==> is_not_substring_pred(str1.subrange(i1, j1), str2)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn is_prefix(pre: Seq<char>, str: Seq<char>) -> (res: bool)\n    ensures\n        !res <==> is_not_prefix_pred(pre, str),\n        res <==> is_prefix_pred(pre, str),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    true\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafny-language-server_tmp_tmpkir0kenl_Test_vstte2012_Two-Way-Sort_two_way_sort", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\nuse vstd::multiset::Multiset;\n\nverus! {\n\n// This method is a slight generalization of the\n// code provided in the problem statement since it\n// is generic in the type of the array elements.\n\nspec fn multisets<T>(s: Seq<T>) -> Multiset<T>\n    decreases s.len(),\n{\n    if s.len() == 0 { \n        Multiset::empty() \n    } else { \n        Multiset::singleton(s[0]).add(multisets(s.subrange(1, s.len() as int)))\n    }\n}\n\nfn swap<T>(a: &mut Vec<T>, i: usize, j: usize)\n    requires \n        i < j < old(a).len(),\n    ensures \n        a[i as int] == old(a)[j as int],\n        a[j as int] == old(a)[i as int],\n        forall|m: int| 0 <= m < a.len() && m != i && m != j ==> a[m] == old(a)[m],\n        multisets(a@) == multisets(old(a)@),\n{\n    assume(false);\n}\n\n// This method is a direct translation of the pseudo\n// code given in the problem statement.\n// The first postcondition expresses that the resulting\n// array is sorted, that is, all occurrences of \"false\"\n// come before all occurrences of \"true\".\n// The second postcondition expresses that the post-state\n// array is a permutation of the pre-state array. To express\n// this, we use Verus's built-in multisets. The built-in\n// function \"multisets\" takes a sequence and yields the\n// multiset of the sequence elements.\n// Note that Verus guesses a suitable ranking function\n// for the termination proof of the while loop.\n// We use the loop guard from the given pseudo-code.  However,\n// the program also verifies with the stronger guard \"i < j\"\n// (without changing any of the other specifications or\n// annotations).", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn two_way_sort(a: &mut Vec<bool>)\n    ensures \n        forall|m: int, n: int| 0 <= m < n < a.len() ==> (!a[m] || a[n]),\n        multisets(a@) == multisets(old(a)@),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "dafny_tmp_tmp49a6ihvk_m4_DutchFlag", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n#[derive(PartialEq, Eq, Clone, Copy)]\nenum Color {\n    Red,\n    White,\n    Blue,\n}\n\nspec fn below(c: Color, d: Color) -> bool {\n    c == Color::Red || c == d || d == Color::Blue\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn dutch_flag(a: &mut Vec<Color>)\n    ensures \n        forall|i: int, j: int| 0 <= i < j < a.len() ==> below(a[i], a[j]),\n        a@.to_multiset() == old(a)@.to_multiset(),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Dafny-Projects_tmp_tmph399drhy_p2_arraySplit_ArraySplit", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn array_split(a: Vec<i32>) -> (ret: (Vec<i32>, Vec<i32>))\n    ensures\n        a@ == ret.0@ + ret.1@,\n        a.len() == ret.0.len() + ret.1.len(),\n        a.len() > 1 ==> a.len() > ret.0.len(),\n        a.len() > 1 ==> a.len() > ret.1.len(),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    (Vec::new(), Vec::new())\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_581_SquarePyramidSurfaceArea", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn square_pyramid_surface_area(base_edge: i32, height: i32) -> (area: i32)\n    requires \n        base_edge > 0,\n        height > 0,\n    ensures \n        area == base_edge * base_edge + 2 * base_edge * height,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0 // unreachable but needed for return type\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_IsPrime", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// ASSIGNMENT P1\n// CMSC 433 FALL 2023\n// PERFECT SCORE:  100 POINTS\n//\n// This assignment contains nine questions, each of which involves writing Verus\n// code. You should include your solutions in a single Verus file and submit it using\n// Gradescope.\n//\n// Revision history\n//\n// 2023-09-22 2:50 pm   Fixed typo in Problem 3.\n\n\n// Question 1 (5 points)\n//\n// Fill in a requires clause that enables Verus to verify\n// method PlusOne\n\n\n\n// Question 2 (5 points)\n//\n// Fill in requires clause(s) that enable(s) Verus to verify the array bounds\n// in method Swap (which swaps elements i and j in array a).\n\n\n// Question 3 (5 points)\n//\n// Give ensures clause(s) asserting that d is the result, and r the\n// remainder, of dividing m by n.  Your clauses cannot use \"/\" or \"%\" (which are\n// the Verus division and mod operators, respectively). By definition, the\n// remainder must be non-negative.\n\n\n// Question 4 (5 points)\n//\n// Give ensures clause(s) asserting that the return value has the same\n// length as array a and contains as its elements the sum of the\n// corresponding elements in arrays a and b.\n\n\n// Question 5 (10 points)\n\n// Euclid's algorithm is used to compute the greatest common divisor of two\n// positive integers.  If m and n are two such integers, then gcd(m,n) is the\n// largest positve integer that evenly divides both m and n, where j evenly divides i\n// if and only if i % j == 0 (% is the Verus mod operator).  Write requires and\n// ensures clauses for the method header Euclid below.  Your requires clauses\n// should also specify that the first argument is at least as large as the second.\n// You do *not* need to implement the method!\n\n\n// Question 7 (20 points)\n//\n// Implement, and have Verus verify, the method IsPrime below, which returns true\n// if and only if the given positive integer is prime.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn is_prime(m: int) -> (is_prime: bool)\n    requires m > 0, // m must be greater than 0\n    ensures is_prime <==> (m > 1 && forall|j: int| 2 <= j < m ==> #[trigger] (m % j) != 0),\n    // ensures states that \"is_prime is true iff m > 1 && not divisible by [2, m-1)\"\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  false\n}\n// </vc-code>", "vc-postamble": "// Question 8 (20 points)\n//\n// Implement, and have Verus verify, the method Reverse below, which returns a new array\n// aRev consisting of the elements of a, but in reverse order.  To create a new \n// array of ints use the Verus command \"Vec::new()\", where the vector can be built\n// with the appropriate number of elements.\n\n\n// Question 9 (20 points)\n//\n// Implement and verify method NoDups, which returns true if and only if there\n// are no duplicate elements in array a.  Note that the requires clause allows\n// you to assume that a is sorted, and that this precondition is necessary for\n// the ensures clause to imply a lack of duplicates.\n\nfn main() {}\n\n}"}
{"id": "llm-verified-eval_tmp_tmpd2deqn_i_dafny_161_solve", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_letter(c: char) -> bool {\n    (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')\n}\n\nspec fn no_letters(s: Seq<char>, n: nat) -> bool\n    recommends n <= s.len()\n{\n    forall|i: int| 0 <= i < n ==> !is_letter(s[i])\n}\n\nspec fn toggle_case(c: char) -> char {\n    if c >= 'a' && c <= 'z' {\n        ((c as u8 - 'a' as u8 + 'A' as u8) as char)\n    } else if c >= 'A' && c <= 'Z' {\n        ((c as u8 - 'A' as u8 + 'a' as u8) as char)\n    } else {\n        c\n    }\n}\n\nspec fn is_reverse(s: Seq<char>, s_prime: Seq<char>) -> bool {\n    (s.len() == s_prime.len()) &&\n    (forall|si: int| 0 <= si < s.len()/2 ==> s_prime[s.len() - si - 1] == s[si])\n}\n\nfn reverse(original: Vec<char>) -> (reversed: Vec<char>)\n    ensures \n        reversed@.len() == original@.len(),\n        forall|i: int| 0 <= i < original@.len() ==> reversed@[i] == original@[original@.len() - 1 - i]\n{\n    assume(false);\n    vec![]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn solve(s: Vec<char>) -> (result: Vec<char>)\n    ensures \n        result@.len() == s@.len(),\n        !no_letters(s@, s@.len() as nat) ==> \n            forall|i: int| 0 <= i < s@.len() && is_letter(s@[i]) ==> \n                result@[i] == toggle_case(s@[i]),\n        !no_letters(s@, s@.len() as nat) ==> \n            forall|i: int| 0 <= i < s@.len() && !is_letter(s@[i]) ==> \n                result@[i] == s@[i],\n        no_letters(s@, s@.len() as nat) ==> is_reverse(result@, s@)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    vec![]\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_ArraySum", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// ASSIGNMENT P1\n// CMSC 433 FALL 2023\n// PERFECT SCORE:  100 POINTS\n//\n// This assignment contains nine questions, each of which involves writing Verus\n// code. You should include your solutions in a single Verus file and submit it using\n// Gradescope.\n//\n// Revision history\n//\n// 2023-09-22 2:50 pm   Fixed typo in Problem 3.\n\n\n// Question 1 (5 points)\n//\n// Fill in a requires clause that enables Verus to verify\n// method PlusOne\n\n\n\n// Question 2 (5 points)\n//\n// Fill in requires clause(s) that enable(s) Verus to verify the array bounds\n// in method Swap (which swaps elements i and j in array a).\n\n\n// Question 3 (5 points)\n//\n// Give ensures clause(s) asserting that d is the result, and r the\n// remainder, of dividing m by n.  Your clauses cannot use \"/\" or \"%\" (which are\n// the Verus division and mod operators, respectively). By definition, the\n// remainder must be non-negative.\n\n\n// Question 4 (5 points)\n//\n// Give ensures clause(s) asserting that the return value has the same\n// length as array a and contains as its elements the sum of the\n// corresponding elements in arrays a and b.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn array_sum(a: &[i32], b: &[i32]) -> (c: Vec<i32>)\n    requires a.len() == b.len()\n    ensures \n        c.len() == a.len() && \n        forall |i: int| 0 <= i < c.len() ==> c[i] == a[i] + b[i] // TODO\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  Vec::new()\n}\n// </vc-code>", "vc-postamble": "// Question 5 (10 points)\n\n// Euclid's algorithm is used to compute the greatest common divisor of two\n// positive integers.  If m and n are two such integers, then gcd(m,n) is the\n// largest positve integer that evenly divides both m and n, where j evenly divides i\n// if and only if i % j == 0 (% is the Verus mod operator).  Write requires and\n// ensures clauses for the method header Euclid below.  Your requires clauses\n// should also specify that the first argument is at least as large as the second.\n// You do *not* need to implement the method!\n\n\n// Question 7 (20 points)\n//\n// Implement, and have Verus verify, the method IsPrime below, which returns true\n// if and only if the given positive integer is prime.\n\n\n// Question 8 (20 points)\n//\n// Implement, and have Verus verify, the method Reverse below, which returns a new array\n// aRev consisting of the elements of a, but in reverse order.  To create a new \n// array of ints use the Verus command \"Vec::new()\", then push elements.\n\n\n// Question 9 (20 points)\n//\n// Implement and verify method NoDups, which returns true if and only if there\n// are no duplicate elements in array a.  Note that the requires clause allows\n// you to assume that a is sorted, and that this precondition is necessary for\n// the ensures clause to imply a lack of duplicates.\n\nfn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_591_SwapFirstAndLast", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn swap_first_and_last(a: &mut Vec<i32>)\n    requires\n        old(a).len() > 0,\n    ensures\n        a.len() == old(a).len(),\n        a[0] == old(a)[old(a).len() - 1],\n        a[a.len() - 1] == old(a)[0],\n        forall|k: int| 1 <= k < a.len() - 1 ==> a[k] == old(a)[k],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Dafny-programs_tmp_tmpnso9eu7u_Algorithms + sorting_bubble-sort_BubbleSort", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/*\nBubble Sort is the simplest sorting algorithm that works by \nrepeatedly swapping the adjacent elements if they are in wrong order.\n*/\n\nspec fn sorted_between(a: Seq<int>, from: int, to: int) -> bool {\n    forall|i: int, j: int| 0 <= i <= j < a.len() && from <= i <= j <= to ==> a[i] <= a[j]\n}\n\nspec fn sorted(a: Seq<int>) -> bool {\n    sorted_between(a, 0, (a.len() - 1) as int)\n}\n\n/* Explanation:\n\ninvariant forall n, m :: 0 <= n <= i <m <N ==> A [n] <= A [m]\n     // A is ordered for each pair of elements such that\n     // the first element belongs to the left partition of i\n     // and the second element belongs to the right partition of i\n\ninvariant forall n :: 0 <= n <= j ==> A [n] <= A [j]\n     // There is a variable defined by the value that the array takes at position j\n     // Therefore, each value that the array takes for all elements from 0 to j\n     // They are less than or equal to the value of the variable\n*/", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn bubble_sort(a: &mut Vec<int>)\n    ensures \n        sorted(a@),\n        a@.to_multiset() == old(a)@.to_multiset()\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_554_FindOddNumbers", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/**\n * Find odd numbers from an array of numbers\n **/\n\nspec fn is_odd(n: int) -> bool {\n    n % 2 == 1\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn find_odd_numbers(arr: &[i32]) -> (odd_list: Vec<i32>)\n    // All numbers in the output are odd and exist in the input \n    ensures forall|i: int| 0 <= i < odd_list.len() ==> is_odd(odd_list[i] as int) && arr@.contains(odd_list[i])\n    // All odd numbers in the input are in the output\n    ensures forall|i: int| 0 <= i < arr.len() && is_odd(arr[i] as int) ==> odd_list@.contains(arr[i])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  Vec::new()\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_A2_Q1_trimmed copy - 副本_ComputeCount", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn count(hi: nat, s: Seq<int>) -> int\n    recommends 0 <= hi <= s.len()\n    decreases hi\n{\n    if hi == 0 {\n        0\n    } else if s[hi-1] % 2 == 0 {\n        1 + count((hi-1) as nat, s)\n    } else {\n        count((hi-1) as nat, s)\n    }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn compute_count(count_index: usize, a: Seq<int>, b: &mut Vec<int>) -> (p: usize)\n    requires count_index == 0 || (a.len() == old(b).len() && 1 <= count_index <= a.len())\n    ensures p == count(count_index as nat, a)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "Clover_swap_sim_SwapSimultaneous", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn swap_simultaneous(x_param: i32, y_param: i32) -> (ret: (i32, i32))\n    ensures \n        ret.0 == y_param,\n        ret.1 == x_param,\n{\n// </vc-spec>", "vc-code": "// <vc-code>\n    assume(false);\n    (0, 0) // dummy return to satisfy type system\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_793_LastPosition", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn last_position(arr: &Vec<i32>, elem: i32) -> (pos: i32)\n    requires \n        arr.len() > 0,\n        forall|i: int, j: int| 0 <= i < j < arr.len() ==> arr[i] <= arr[j],\n    ensures\n        pos == -1 || (0 <= pos < arr.len() && arr[pos as int] == elem && \n            (pos >= arr.len() - 1 || arr[(pos + 1) as int] > elem)),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    -1\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "Clover_is_palindrome_IsPalindrome", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn is_palindrome(x: Seq<char>) -> (result: bool)\n  ensures result <==> (forall|i: int| 0 <= i < x.len() ==> #[trigger] x[i] == x[x.len() - i - 1])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  false\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseSeparate_separate", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn strict_negative(v: &Vec<i32>, i: usize, j: usize) -> bool\n    recommends 0 <= i <= j <= v.len()\n{\n    forall|u: usize| i <= u < j ==> v[u as int] < 0\n}\n\nspec fn positive(s: Seq<i32>) -> bool {\n    forall|u: int| 0 <= u < s.len() ==> s[u] >= 0\n}\n\nspec fn is_permutation(s: Seq<i32>, t: Seq<i32>) -> bool {\n    s.to_multiset() == t.to_multiset()\n}\n\n/**\nreturns an index st new array is a permutation of the old array\npositive first and then strictnegative, i is the firs neg or len if not any */", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn separate(v: &mut Vec<i32>) -> (i: usize)\n    ensures\n        0 <= i <= v.len(),\n        positive(v@.subrange(0, i as int)),\n        strict_negative(v, i, v.len()),\n        is_permutation(v@, old(v)@),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_412_RemoveOddNumbers", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/**\n * Remove odd numbers from an array of numbers\n **/\n\nspec fn is_even(n: int) -> bool {\n    n % 2 == 0\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn remove_odd_numbers(arr: &[i32]) -> (even_list: Vec<i32>)\n    ensures\n        // All numbers in the output are even and exist in the input \n        forall|i: int| 0 <= i < even_list.len() ==> is_even(even_list[i] as int) && arr@.contains(even_list[i]),\n        // All even numbers in the input are in the output\n        forall|i: int| 0 <= i < arr.len() && is_even(arr[i] as int) ==> even_list@.contains(arr[i])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_435_LastDigit", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\n#[verifier::exec_allows_no_decreases_clause]\nfn last_digit(n: int) -> (result: int)\n    requires n >= 0,\n    ensures 0 <= result < 10,\n    ensures n % 10 == result,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    loop { }\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "Clover_max_array_maxArray", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn maxArray(a: &[int]) -> (m: int)\n    requires a.len() >= 1,\n    ensures \n        forall|k: int| 0 <= k < a.len() ==> m >= a@[k] &&\n        exists|k: int| 0 <= k < a.len() && m == a@[k],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "formal-verification_tmp_tmpoepcssay_strings3_maxCommonSubstringLength", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_substring(sub: Seq<char>, str: Seq<char>) -> bool \n    decreases str.len()\n{\n    if sub.len() == 0 {\n        true\n    } else if str.len() < sub.len() {\n        false\n    } else {\n        (str.subrange(0, sub.len() as int) == sub) || is_substring(sub, str.subrange(1, str.len() as int))\n    }\n}\n\nspec fn is_prefix_pred(pre: Seq<char>, str: Seq<char>) -> bool {\n    pre.len() <= str.len() && \n    pre == str.subrange(0, pre.len() as int)\n}\n\nspec fn is_not_prefix_pred(pre: Seq<char>, str: Seq<char>) -> bool {\n    pre.len() > str.len() || \n    pre != str.subrange(0, pre.len() as int)\n}\n\nspec fn is_substring_pred(sub: Seq<char>, str: Seq<char>) -> bool {\n    exists|i: int| #![auto] 0 <= i <= str.len() && is_prefix_pred(sub, str.subrange(i, str.len() as int))\n}\n\nspec fn is_not_substring_pred(sub: Seq<char>, str: Seq<char>) -> bool {\n    forall|i: int| #![auto] 0 <= i <= str.len() ==> is_not_prefix_pred(sub, str.subrange(i, str.len() as int))\n}\n\nspec fn have_common_k_substring_pred(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool {\n    exists|i1: int, j1: int| #![auto] 0 <= i1 <= str1.len() - k && j1 == i1 + k && is_substring_pred(str1.subrange(i1, j1), str2)\n}\n\nspec fn have_not_common_k_substring_pred(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool {\n    forall|i1: int, j1: int| #![auto] 0 <= i1 <= str1.len() - k && j1 == i1 + k ==> is_not_substring_pred(str1.subrange(i1, j1), str2)\n}\n\nfn have_common_k_substring(k: usize, str1: Seq<char>, str2: Seq<char>) -> (found: bool)\n    ensures \n        found <==> have_common_k_substring_pred(k as nat, str1, str2),\n        !found <==> have_not_common_k_substring_pred(k as nat, str1, str2),\n{\n    assume(false);\n    false\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn max_common_substring_length(str1: Seq<char>, str2: Seq<char>) -> (len: usize)\n    requires str1.len() <= str2.len(),\n    ensures \n        forall|k: nat| #![auto] len < k <= str1.len() ==> !have_common_k_substring_pred(k, str1, str2),\n        have_common_k_substring_pred(len as nat, str1, str2),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "AssertivePrograming_tmp_tmpwf43uz0e_MergeSort_MergeLoop", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// Noa Leron 207131871\n// Tsuri Farhana 315016907\n\n\n\n\nspec fn sorted(q: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i <= j < q.len() ==> q[i] <= q[j]\n}\n\n/*\nGoal: Implement the well known merge sort algorithm in O(a.Length X log_2(a.Length)) time, recursively.\n\n- Divide the contents of the original array into two local arrays\n- After sorting the local arrays (recursively), merge the contents of the two returned arrays using the Merge method (see below)\n- DO NOT modify the specification or any other part of the method's signature\n- DO NOT introduce any further methods\n*/\n\nspec fn inv(a: Seq<int>, a1: Seq<int>, a2: Seq<int>, i: nat, mid: nat) -> bool {\n    (i <= a1.len()) && (i <= a2.len()) && (i + mid <= a.len()) &&\n    (a1.subrange(0, i as int) =~= a.subrange(0, i as int)) && \n    (a2.subrange(0, i as int) =~= a.subrange(mid as int, (i + mid) as int))\n}\n\n\n/*\nGoal: Implement iteratively, correctly, efficiently, clearly\n\nDO NOT modify the specification or any other part of the method's signature\n*/\n\n\n//This is a method that replace the loop body\n\n//Loop invariant - b is sorted so far and the next two potential values that will go into b are bigger then the biggest value in b.\nspec fn inv_sorted(b: Seq<int>, c: Seq<int>, d: Seq<int>, i: nat, j: nat) -> bool {\n    i <= c.len() && j <= d.len() && i + j <= b.len() &&\n    ((i + j > 0 && i < c.len()) ==> (b[(j + i - 1) as int] <= c[i as int])) &&\n    ((i + j > 0 && j < d.len()) ==> (b[(j + i - 1) as int] <= d[j as int])) &&\n    sorted(b.subrange(0, (i + j) as int))\n    }\n\n\n//Loop invariant - the multiset of the prefix of b so far is the same multiset as the prefixes of c and d so far.\nspec fn inv_sub_set(b: Seq<int>, c: Seq<int>, d: Seq<int>, i: nat, j: nat) -> bool {\n    i <= c.len() && j <= d.len() && i + j <= b.len() &&\n    b.subrange(0, (i + j) as int).to_multiset() =~= \n    c.subrange(0, i as int).to_multiset().add(d.subrange(0, j as int).to_multiset())\n}\n\n//This lemma helps dafny see that if the prefixs of arrays are the same multiset until the end of the arrays,\n//all the arrays are the same multiset.\n\n\n//This lemma helps dafny see that after adding the next value from c to b the prefixes are still the same subsets.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn merge_loop(b: &mut Vec<int>, c: &Vec<int>, d: &Vec<int>, i0: usize, j0: usize) -> (r: (usize, usize))\n        requires\n            old(b).len() == c.len() + d.len(),\n            sorted(c@),\n            sorted(d@),\n            i0 <= c.len(),\n            j0 <= d.len(),\n            i0 + j0 <= old(b).len(),\n            inv_sub_set(old(b)@, c@, d@, i0 as nat, j0 as nat),\n            inv_sorted(old(b)@, c@, d@, i0 as nat, j0 as nat),\n            i0 + j0 < old(b).len(),\n\n        ensures\n            r.0 <= c.len() && r.1 <= d.len() && r.0 + r.1 <= b.len(),\n            inv_sub_set(b@, c@, d@, r.0 as nat, r.1 as nat),\n            inv_sorted(b@, c@, d@, r.0 as nat, r.1 as nat),\n            //decreases ensures\n            0 <= c.len() - r.0 < c.len() - i0 || (c.len() - r.0 == c.len() - i0 && 0 <= d.len() - r.1 < d.len() - j0)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  (0, 0) // dummy return\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_10_Hoangkim_ex10_hoangkim_q", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n//Problem01\n\n/*\n3 Verification conditions\n\n1. VC1: Precondiotion implies the loop variant\nn ∈ ℕ => sqn = 0*0 ∧ i = 0 ∧ x=? ∧ i≤n \nn >= 0 => 0 = 0*0 ∧ i = 0 ∧ i≤n \nn >= 0 => 0 = 0*0 ∧ 0 ≤ n \n2. VC2: Loop invariant and loop guard preserve the loop invariant.\nVC2: i < n ∧ i+1 ≤ n ∧ sqn = i * i ⇒ sqn = sqn + x ∧ i = i + 1 ∧ x = 2 * i + 1\n3.VC3: Loop terminates, and the loop invariant implies the postcondition.\nVC3: ¬(i < n) ∧ i ≤ n ∧ sqn = i * i ⇒ sqn = n * n\n\nSimplified VC for square0\n1. true, since 0 = 0 and n >= 0 => 0 ≤ n\n2. true, i < n => i + 1 <= n\n3. true, ¬(i < n) ∧ i ≤ n ∧ sqn = i * i ⇒ sqn = n * n since ¬(i < n) ∧ i ≤ n imply i = n\n\n*/\n\n\n//Problem02\n//As you can see below, Verus claims that after executing the following function\n//strange() we will have that 1=2;\n\n/*(a). Do you have an explanation for this behaviour?\n    Answer: \n    the function strange() doesn't have any input or output. This function initializes\n    variable x with value 4. Then it calculates variable c as a result of calling\n    function 'q' with x as first var and 2*x as second var.the strange function does not \n    specify any postcondition. Therefore, we cannot make any assumptions about the \n    behavior or the value of c after calling q.\n    We can change ensures in strange() to false and it's still verified\n*/\n\n/*(b)\n{\n  assume{:axiom} false;\n}var x:nat := 4; var c := q(x,2*x); {1 = 2 }\n    precond in strange(): difference between 'y' and 'x' muss be greater than 2,\n    square from 'z' will be a value  between 'x' and 'y'\n\n    apply the Hoare rules step by step:\n    1. {true} as a precondition\n    2. we assign 4 to 'x' and having {4=4}\n    3. assign value q(x, 2 * x) to c, substitute the postcondition of 'q' in place of 'c'\n        post cond of q will be x < z*z < 2*x. Replacing c we having {x < z * z < 2 * x}\n    4. we having the statement {x < z*z < 2*x} => {1 = 2} as postcondtion\n\n    as we know the statment {1 = 2} is always false. true => false is always false     \n\n\n\n*/\n\n//Problem 3\n//Use what you know about the weakest preconditions/strongest postconditions to ex-\n//plain why the following code verifies:\n\n/*\nWP: is a condition that, if satisfied before the execution of a program, guarantees the \nsatisfaction of a specified postcondition\nSP: is a condition that must hold after the execution of a program, assuming a specified \nprecondition\n\nThe strongest postcondition for assert is x<=9\nAnalyze the code: \nThe strongest postcondition for the assert statement assert x <= 9; is x <= 9. This \npostcondition asserts that the value of x should be less than or equal to 9 after the \nexecution of the program. To ensure this postcondition, we need to find a weakest precondition \n(WP) that guarantees x <= 9 after executing the code.\n\nThe \"assume\" statement introduces a precondition.\nIt assumes that the square of x is less than 100. In other words, it assumes that x is \nwithin the range (0, 10) since the largest possible square less than 100 is 9 * 9 = 81.\n\n\n*/", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn q(x: u32, y: u32) -> (z: u32)\n    requires y - x > 2\n    ensures x < z*z < y\n\nfn strange()\n    ensures 1 == 2\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_743_RotateRight", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn rotate_right(l: Seq<int>, n: int) -> (r: Seq<int>)\n    requires n >= 0,\n    ensures \n        r.len() == l.len(),\n        forall|i: int| 0 <= i < l.len() ==> r.index(i) == l.index((i - n + l.len() as int) % l.len() as int),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    l  // This is unreachable but satisfies return type\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Clover_two_sum_twoSum", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn twoSum(nums: &[i32], target: i32) -> (result: (usize, usize))\n    requires \n        nums.len() > 1,\n        exists|i: int, j: int| 0 <= i < j < nums.len() && nums[i] + nums[j] == target,\n    ensures \n        0 <= result.0 < result.1 < nums.len() && nums[result.0 as int] + nums[result.1 as int] == target\n        && forall|ii: int, jj: int| #![trigger nums[ii], nums[jj]] (0 <= ii < result.0 && ii < jj < nums.len()) ==> nums[ii] + nums[jj] != target\n        && forall|jj: int| #![trigger nums[jj]] result.0 < jj < result.1 ==> nums[result.0 as int] + nums[jj] != target,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    (0, 1) // unreachable\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Clover_is_even_ComputeIsEven", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn compute_is_even(x: int) -> (is_even: bool)\n    ensures (x % 2 == 0) == is_even\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    true // placeholder return value\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "FlexWeek_tmp_tmpc_tfdj_3_ex4_join", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn join(a: &[i32], b: &[i32]) -> (c: Vec<i32>)\n    ensures\n        a@ + b@ == c@,\n        (a@ + b@).to_multiset() == c@.to_multiset(),\n        a@.to_multiset().add(b@.to_multiset()) == c@.to_multiset(),\n        a.len() + b.len() == c.len(),\n        // Forall\n        forall|i: int| 0 <= i < a.len() ==> c[i] == a[i],\n        forall|i: int, j: int| \n            a.len() <= i < c.len() && \n            0 <= j < b.len() && \n            i - j == a.len() ==> c[i] == b[j],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Dafny_tmp_tmp0wu8wmfr_tests_InsertionSortSeq_InsertionSort", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// Insertion sort.\n//\n// Author: Snorri Agnarsson, snorri@hi.is\n\n\nspec fn is_sorted(s: Seq<int>) -> bool {\n    forall|p: int, q: int| 0 <= p < q < s.len() ==> s[p] <= s[q]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn insertion_sort(s: Seq<int>) -> (r: Seq<int>)\n    ensures\n        s.to_multiset() == r.to_multiset(),\n        is_sorted(r),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    s\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "feup-mfes_tmp_tmp6_a1y5a5_examples_SelectionSort_selectionSort", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* \n* Formal verification of the selection sort algorithm with Verus.\n* FEUP, MIEIC, MFES, 2020/21.\n*/\n\n// Checks if array 'a' is sorted between positions 'from' (inclusive) and 'to' (exclusive).\nspec fn is_sorted(a: Seq<i32>, from: int, to: int) -> bool\n    recommends 0 <= from <= to <= a.len()\n{\n    forall|i: int, j: int| from <= i < j < to ==> a[i] <= a[j]\n}\n\n// Sorts array 'a' using the selection sort algorithm.\n\n// Finds the position of a minimum value in non-empty subarray 'a' between positions \n// 'from' (inclusive) and 'to' (exclusive)\nfn find_min(a: &Vec<i32>, from: usize, to: usize) -> (index: usize)\n    requires \n        0 <= from < to <= a.len(),\n    ensures \n        from <= index < to,\n        forall|k: int| from as int <= k < to as int ==> a@[k] >= a@[index as int],\n{\n    assume(false);\n    0\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn selection_sort(a: &mut Vec<i32>)\n    ensures \n        is_sorted(a@, 0, a@.len() as int),\n        a@.to_multiset() == old(a)@.to_multiset(),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "Software-Verification_tmp_tmpv4ueky2d_Valid Palindrome_valid_panlindrome_isPalindrome", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn isPalindrome(s: &Vec<char>) -> (result: bool)\n    requires 1 <= s.len() <= 200000,\n    ensures result <==> (forall|i: int| 0 <= i < (s.len() as int) / 2 ==> s[i] == s[(s.len() as int) - 1 - i])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  true\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "Clover_slope_search_SlopeSearch", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn slope_search(a: &Vec<Vec<i32>>, key: i32) -> (result: (usize, usize))\n  requires \n      a.len() > 0,\n      forall|i: int| 0 <= i < a.len() ==> #[trigger] a@[i].len() == a@[0].len(),\n      a@[0].len() > 0,\n      // Each row is sorted (non-decreasing)\n      forall|i: int, j: int, j_prime: int| \n          0 <= i < a.len() && 0 <= j < j_prime < a@[0].len()\n          ==> #[trigger] a@[i]@[j] <= #[trigger] a@[i]@[j_prime],\n      // Each column is sorted (non-decreasing)  \n      forall|i: int, i_prime: int, j: int| \n          0 <= i < i_prime < a.len() && 0 <= j < a@[0].len()\n          ==> #[trigger] a@[i]@[j] <= #[trigger] a@[i_prime]@[j],\n      // Key exists in the matrix\n      exists|i: int, j: int| \n          0 <= i < a.len() && 0 <= j < a@[0].len()\n          && #[trigger] a@[i]@[j] == key\n  ensures\n      result.0 < a.len(),\n      result.1 < a@[0].len(),\n      a@[result.0 as int]@[result.1 as int] == key\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  (0, 0)\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_161_RemoveElements", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// Predicate to check if an element exists in an array\nspec fn in_array(a: &[i32], x: i32) -> bool {\n    exists|i: int| 0 <= i < a.len() && a@.index(i) == x\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn remove_elements(a: &[i32], b: &[i32]) -> (result: Vec<i32>)\n    // All elements in the output are in a and not in b\n    ensures forall|x: i32| result@.contains(x) ==> in_array(a, x) && !in_array(b, x)\n    // The elements in the output are all different\n    ensures forall|i: int, j: int| 0 <= i < j < result.len() ==> result@.index(i) != result@.index(j)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  Vec::new()\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_304_ElementAtIndexAfterRotation", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nproof fn element_at_index_after_rotation(l: Seq<int>, n: int, index: int) -> (element: int)\n    requires \n        n >= 0,\n        0 <= index < l.len(),\n    ensures \n        element == l[((index - n + l.len() as int) % l.len() as int) as int],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0 as int\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_433_IsGreater", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn is_greater(n: i32, a: &[i32]) -> (result: bool)\n    ensures \n        result ==> forall|i: int| 0 <= i < a.len() ==> n > a[i],\n        !result ==> exists|i: int| 0 <= i < a.len() && n <= a[i],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    true // placeholder return\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_238_CountNonEmptySubstrings", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn count_non_empty_substrings(s: Seq<char>) -> (count: usize)\n    ensures \n        count >= 0,\n        count == (s.len() * (s.len() + 1)) / 2, // Formula for the number of non-empty substrings of a string\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "MFS_tmp_tmpmmnu354t_Praticas_TP9_Power_powerIter", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* \n* Formal verification of O(n) and O(log n) algorithms to calculate the natural\n* power of a real number (x^n), illustrating the usage of lemmas.\n* FEUP, M.EIC, MFS, 2021/22.\n*/\n\n// Initial specification/definition of x^n, recursive, functional style, \n// with time and space complexity O(n).\nspec fn power(x: int, n: nat) -> int\n    decreases n\n{\n    if n == 0 { 1 } else { x * power(x, (n-1) as nat) }\n}\n\n// Iterative version, imperative, with time complexity O(n) and space complexity O(1).", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn power_iter(b: i32, n: u32) -> (p: i32)\n    ensures p as int == power(b as int, n as nat)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "// Recursive version, imperative, with time and space complexity O(log n).\n\n// A simple test case to make sure the specification is adequate.\n\nfn main() {}\n\n}"}
{"id": "Dafny_tmp_tmp0wu8wmfr_tests_Search1000_Search2PowRecursive", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// Author: Snorri Agnarsson, snorri@hi.is\n\n// Search1000 is a Dafny version of a function shown\n// by Jon Bentley in his old Programming Pearls\n// column in CACM.  Surprisingly Dafny needs no help\n// to verify the function.\n\n// Is2Pow(n) is true iff n==2^k for some k>=0.\nspec fn is_2_pow(n: int) -> bool\n    decreases n\n{\n    if n < 1 {\n        false\n    } else if n == 1 {\n        true\n    } else {\n        n % 2 == 0 && is_2_pow(n / 2)\n    }\n}\n\n// This method is a binary search that only works for array\n// segments of size n == 2^k-1 for some k>=0.\n\n// This method is a binary search that only works for array\n// segments of size n == 2^k-1 for some k>=0.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn search_2_pow_recursive(a: &[i32], i: usize, n: usize, x: i32) -> (k: usize)\n    decreases n\n    requires\n        i + n <= a.len(),\n        forall|p: int, q: int| \n            0 <= p < q && i as int <= p && q < (i + n) as int ==> \n            a[p] <= a[q],\n        is_2_pow((n + 1) as int),\n    ensures\n        i <= k <= i + n,\n        forall|r: int| \n            0 <= r && i as int <= r < k as int ==> \n            a[r] < x,\n        forall|r: int| \n            0 <= r && k as int <= r < (i + n) as int ==> \n            a[r] >= x,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  0\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_599_SumAndAverage", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn sum_and_average(n: i32) -> (res: (i32, i32))\n    requires n > 0\n    ensures res.0 == n * (n + 1) / 2 && res.1 * n == res.0\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    (0, 0)\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_verified algorithms_lol_sort_swap", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// By `lol sort` here, I refer to a seemingly-broken sorting algorithm,\n// which actually somehow manages to work perfectly:\n//\n// for i in 0..n\n//   for j in 0..n\n//     if i < j\n//       swap a[i], a[j]\n//\n// It is perhaps the simpliest sorting algorithm to \"memorize\",\n// even \"symmetrically beautiful\" as if `i` and `j` just played highly\n// similar roles. And technically it's still O(n^2) time lol...\n//\n// Proving its correctness is tricky (interesting) though.\n\n// Successfully verified with Verus\n\n\n\n// We define \"valid permutation\" using multiset:\n\nspec fn valid_permut(a: Seq<int>, b: Seq<int>) -> bool\n    recommends a.len() == b.len()\n{\n    a.to_multiset() == b.to_multiset()\n}\n\n// This is a swap-based sorting algorithm, so permutedness is trivial:\n// note that: if i == j, the spec just says a[..] remains the same.\n\n// We then define \"sorted\" (by increasing order):\nspec fn sorted(a: Seq<int>) -> bool\n{\n    forall|i: int, j: int| 0 <= i <= j < a.len() ==> a[i] <= a[j]\n}\n\n\n// Now, the lol sort algorithm:\n// (Some invariants were tricky to find, but Verus was smart enough otherwise)", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn swap(a: &mut Vec<int>, i: usize, j: usize)\n    requires \n        i < old(a).len(),\n        j < old(a).len(),\n    ensures \n        a.len() == old(a).len(),\n        a@ == old(a)@.update(i as int, old(a)@[j as int]).update(j as int, old(a)@[i as int]),\n        valid_permut(a@, old(a)@),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "Clover_return_seven_M", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nproof fn M(x: int) -> (seven: int)\n  ensures seven == 7\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  7\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "Dafny-Practice_tmp_tmphnmt4ovh_BST_InsertBST", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\npub enum Tree {\n    Empty,\n    Node(int, Box<Tree>, Box<Tree>),\n}\n\nspec fn numbers_in_tree(t: Tree) -> Set<int> {\n    numbers_in_sequence(inorder(t))\n}\n\nspec fn numbers_in_sequence(q: Seq<int>) -> Set<int> {\n    Set::new(|x: int| q.contains(x))\n}\n\nspec fn bst(t: Tree) -> bool {\n    ascending(inorder(t))\n}\n\nspec fn inorder(t: Tree) -> Seq<int>\n    decreases t\n{\n    match t {\n        Tree::Empty => seq![],\n        Tree::Node(n, left, right) => inorder(*left) + seq![n] + inorder(*right)\n    }\n}\n\nspec fn ascending(q: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < q.len() ==> q[i] < q[j]\n}\n\nspec fn no_duplicates(q: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < q.len() ==> q[i] != q[j]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn insert_bst(t0: Tree, x: int) -> (t: Tree)\n    requires \n        bst(t0) && !numbers_in_tree(t0).contains(x)\n    ensures \n        bst(t) && numbers_in_tree(t) =~= numbers_in_tree(t0).insert(x)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    Tree::Empty\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Clover_reverse_reverse", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn reverse(a: &mut Vec<i32>)\n    ensures forall|i: int| 0 <= i < old(a).len() ==> a[i] == old(a)[old(a).len() - 1 - i]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "MIEIC_mfes_tmp_tmpq3ho7nve_TP3_binary_search_binarySearch", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// Checks if array 'a' is sorted.\nspec fn is_sorted(a: &[i32]) -> bool {\n    forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j]\n}\n\n// Finds a value 'x' in a sorted array 'a', and returns its index,\n// or -1 if not found.\n\n// Simple test cases to check the post-condition.\n\n/*\na) Identify adequate pre and post-conditions for this method, \nand encode them as \"requires\" and \"ensures\" clauses in Verus. \nYou can use the predicate below if needed.\n\nb) Identify an adequate loop variant and loop invariant, and encode them \nas \"decreases\" and \"invariant\" clauses in Verus.\n*/", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn binary_search(a: &[i32], x: i32) -> (index: i32)\n    requires is_sorted(a)\n    ensures -1 <= index < a.len() && \n            (index != -1 ==> a[index as int] == x) &&\n            (index == -1 ==> !a@.contains(x))\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_578_Interleave", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\n#[verifier::exec_allows_no_decreases_clause]\nfn interleave(s1: Seq<int>, s2: Seq<int>, s3: Seq<int>) -> (r: Seq<int>)\n    requires \n        s1.len() == s2.len() && s2.len() == s3.len(),\n    ensures \n        r.len() == 3 * s1.len(),\n        forall|i: int| 0 <= i < s1.len() ==> r[3*i] == s1[i] && r[3*i + 1] == s2[i] && r[3*i + 2] == s3[i],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    loop { }\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced examples_MatrixMultiplication_multiply", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn row_column_product(m1: &Vec<Vec<int>>, m2: &Vec<Vec<int>>, row: int, column: int) -> int\n    recommends\n        m1.len() > 0,\n        m2.len() > 0,\n        m1[0].len() == m2.len(),\n        0 <= row < m1.len(),\n        0 <= column < m2[0].len(),\n        forall|i: int| 0 <= i < m1.len() ==> #[trigger] m1[i].len() == m1[0].len(),\n        forall|i: int| 0 <= i < m2.len() ==> #[trigger] m2[i].len() == m2[0].len(),\n{\n    row_column_product_from(m1, m2, row, column, 0)\n}\n\nspec fn row_column_product_from(m1: &Vec<Vec<int>>, m2: &Vec<Vec<int>>, row: int, column: int, k: int) -> int\n    recommends\n        m1.len() > 0,\n        m2.len() > 0,\n        0 <= k <= m1[0].len(),\n        m1[0].len() == m2.len(),\n        0 <= row < m1.len(),\n        0 <= column < m2[0].len(),\n        forall|i: int| 0 <= i < m1.len() ==> #[trigger] m1[i].len() == m1[0].len(),\n        forall|i: int| 0 <= i < m2.len() ==> #[trigger] m2[i].len() == m2[0].len(),\n        k < m1[0].len() ==> 0 <= k < m1[row].len(),\n        k < m1[0].len() ==> 0 <= k < m2.len(),\n        k < m1[0].len() ==> 0 <= column < m2[k].len(),\n    decreases m1[0].len() - k\n    when 0 <= k <= m1[0].len()\n{\n    if k == m1[0].len() {\n        0\n    } else {\n        m1[row][k] * m2[k][column] + row_column_product_from(m1, m2, row, column, k + 1)\n    }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn multiply(m1: &Vec<Vec<int>>, m2: &Vec<Vec<int>>) -> (m3: Vec<Vec<int>>)\n    requires\n        m1.len() > 0,\n        m2.len() > 0,\n        m1[0].len() == m2.len(),\n        forall|i: int| 0 <= i < m1.len() ==> #[trigger] m1[i].len() == m1[0].len(),\n        forall|i: int| 0 <= i < m2.len() ==> #[trigger] m2[i].len() == m2[0].len(),\n    ensures\n        m3.len() == m1.len(),\n        m3.len() > 0 ==> m3[0].len() == m2[0].len(),\n        forall|i: int| 0 <= i < m3.len() ==> #[trigger] m3[i].len() == m2[0].len(),\n        forall|i: int, j: int| 0 <= i < m3.len() && 0 <= j < m2[0].len() ==>\n            #[trigger] m3[i][j] == row_column_product(m1, m2, i, j),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    let mut result = Vec::new();\n    proof {\n        assume(false);\n    }\n    result\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "dafny_examples_tmp_tmp8qotd4ez_leetcode_0070-climbing-stairs_ClimbStairs", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn stairs(n: nat) -> nat\n    decreases n\n{\n    if n <= 1 { 1 } else { stairs((n - 2) as nat) + stairs((n - 1) as nat) }\n}\n\n// A simple specification", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn climb_stairs(n: u32) -> (r: u32)\n    requires n >= 0\n    ensures r == stairs(n as nat)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_ProgramProofs_ch15_SelectionSort", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn split_point(a: &Vec<int>, n: int) -> bool {\n    0 <= n <= a.len() &&\n    forall|i: int, j: int| 0 <= i < n <= j < a.len() ==> a[i] <= a[j]\n}\n\nspec fn swap_frame(a_old: &Vec<int>, a_new: &Vec<int>, lo: int, hi: int) -> bool {\n    0 <= lo <= hi <= a_old.len() &&\n    a_old.len() == a_new.len() &&\n    (forall|i: int| (0 <= i < lo || hi <= i < a_old.len()) ==> a_new[i] == a_old[i]) &&\n    a_new@.to_multiset() == a_old@.to_multiset()\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn selection_sort(a: &mut Vec<int>)\n    ensures\n        forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j],\n        a@.to_multiset() == old(a)@.to_multiset(),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_732_ReplaceWithColon", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_space_comma_dot(c: char) -> bool {\n    c == ' ' || c == ',' || c == '.'\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn replace_with_colon(s: &str) -> (v: String)\n    ensures \n        v@.len() == s@.len(),\n        forall|i: int| 0 <= i < s@.len() ==> {\n            if is_space_comma_dot(s@[i]) {\n                v@[i] == ':'\n            } else {\n                v@[i] == s@[i]\n            }\n        }\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_600_IsEven", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn is_even(n: int) -> (result: bool)\n    ensures result <==> n % 2 == 0\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    true // placeholder return\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafny-exercise_tmp_tmpouftptir_zapNegatives_ZapNegatives", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn zap_negatives(a: &mut Vec<i32>)\n    ensures \n        a.len() == old(a).len(),\n        forall|i: int| 0 <= i < a.len() ==> \n            if old(a)[i] < 0 { a[i] == 0 } \n            else { a[i] == old(a)[i] }\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "Dafny_tmp_tmp0wu8wmfr_tests_Search1000_Search2PowLoop", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// Author: Snorri Agnarsson, snorri@hi.is\n\n// Search1000 is a Verus version of a function shown\n// by Jon Bentley in his old Programming Pearls\n// column in CACM.  \n\n// Is2Pow(n) is true iff n==2^k for some k>=0.\nspec fn is_2_pow(n: int) -> bool\n    decreases n\n{\n    if n < 1 {\n        false\n    } else if n == 1 {\n        true\n    } else {\n        n % 2 == 0 && is_2_pow(n / 2)\n    }\n}\n\n// This method is a binary search that only works for array\n// segments of size n == 2^k-1 for some k>=0.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn search_2_pow_loop(a: &[i32], i: usize, n: usize, x: i32) -> (k: usize)\n    requires\n        i <= i + n <= a.len(),\n        forall|p: int, q: int| i <= p < q < (i + n) && 0 <= p < a.len() && 0 <= q < a.len() ==> \n            a@[p] <= a@[q],\n        is_2_pow((n + 1) as int),\n    ensures\n        i <= k <= i + n,\n        forall|r: int| i <= r < k && 0 <= r < a.len() ==> a@[r] < x,\n        forall|r: int| k <= r < (i + n) && 0 <= r < a.len() ==> a@[r] >= x,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  0\n}\n// </vc-code>", "vc-postamble": "// This method is a binary search that only works for array\n// segments of size n == 2^k-1 for some k>=0.\n\nfn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_803_IsPerfectSquare", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn is_perfect_square(n: int) -> (result: bool)\n    requires \n        n >= 0,\n    ensures \n        result == true ==> (exists|i: int| 0 <= i <= n && #[trigger] (i * i) == n),\n        result == false ==> (forall|a: int| 0 < a*a < n ==> #[trigger] (a*a) != n),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    true\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_455_MonthHas31Days", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn month_has_31_days(month: i32) -> (result: bool)\n    requires 1 <= month <= 12\n    ensures result <==> (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    true // unreachable but needed for return type\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExerciseFibonacci_fibonacci1", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn fib(n: nat) -> nat\n    decreases n\n{\n    if n == 0 { 0 }\n    else if n == 1 { 1 }\n    else { fib((n - 1) as nat) + fib((n - 2) as nat) }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn fibonacci1(n: u64) -> (f: u64)\n    requires n < 100, // practical bound to prevent overflow\n    ensures f == fib(n as nat)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings1_maxCommonSubstringLength", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_not_prefix_pred(pre: Seq<char>, str: Seq<char>) -> bool {\n    (pre.len() > str.len()) || \n    pre != str.subrange(0, pre.len() as int)\n}\n\nfn is_prefix(pre: Seq<char>, str: Seq<char>) -> (res: bool)\n    ensures \n        !res <==> is_not_prefix_pred(pre, str),\n        res <==> is_prefix_predicate(pre, str),\n{\n    assume(false);\n    true\n}\n\nspec fn is_prefix_predicate(pre: Seq<char>, str: Seq<char>) -> bool {\n    str.len() >= pre.len() && pre == str.subrange(0, pre.len() as int)\n}\n\nspec fn is_substring_predicate(sub: Seq<char>, str: Seq<char>) -> bool {\n    str.len() >= sub.len() && (exists|i: int| 0 <= i <= str.len() && is_prefix_predicate(sub, str.subrange(i, str.len() as int)))\n}\n\nfn is_substring(sub: Seq<char>, str: Seq<char>) -> (res: bool)\n    ensures res == is_substring_predicate(sub, str),\n{\n    assume(false);\n    true\n}\n\nspec fn have_common_k_substring_predicate(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool {\n    str1.len() >= k && str2.len() >= k && (exists|i: int| 0 <= i <= str1.len() - k && is_substring_predicate((str1.subrange(i, str1.len() as int)).subrange(0, k as int), str2))\n}\n\nfn have_common_k_substring(k: usize, str1: Seq<char>, str2: Seq<char>) -> (found: bool)\n    requires k <= usize::MAX,\n    ensures \n        (str1.len() < k || str2.len() < k) ==> !found,\n        have_common_k_substring_predicate(k as nat, str1, str2) == found,\n{\n    assume(false);\n    true\n}\n\nspec fn max_common_substring_predicate(str1: Seq<char>, str2: Seq<char>, len: nat) -> bool {\n    forall|k: int| len < k <= str1.len() ==> !#[trigger] have_common_k_substring_predicate(k as nat, str1, str2)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn max_common_substring_length(str1: Seq<char>, str2: Seq<char>) -> (len: usize)\n    ensures \n        len <= str1.len() && len <= str2.len(),\n        len >= 0,\n        max_common_substring_predicate(str1, str2, len as nat),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Clover_even_list_FindEvenNumbers", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn find_even_numbers(arr: &[i32]) -> (even_numbers: Vec<i32>)\n    ensures \n        (forall|x: i32| arr@.contains(x) && x % 2 == 0 ==> even_numbers@.contains(x)) &&\n        (forall|x: i32| !arr@.contains(x) ==> !even_numbers@.contains(x)) &&\n        (forall|k: int| 0 <= k < even_numbers@.len() ==> even_numbers@[k] % 2 == 0) &&\n        (forall|k: int, l: int| 0 <= k < l < even_numbers@.len() ==> \n            exists|n: int, m: int| 0 <= n < m < arr@.len() && \n            #[trigger] even_numbers@[k] == #[trigger] arr@[n] && \n            #[trigger] even_numbers@[l] == #[trigger] arr@[m])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_441_CubeSurfaceArea", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn cube_surface_area(size: i32) -> (area: i32)\n    requires size > 0\n    ensures area == 6 * size * size\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  0  // unreachable but needed for return type\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_SqrSum1", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/*\nVerus includes 2 languages:\n    * a language for specification \n        MSFOL (what we've discussed so far)\n        annotations to help in the verification process\n    * a language for writing programs\n*/\n\n// Example program\n\n/*\n    triple Hoare (| P |) S (| Q |) \n*/\n\n// assume-assert variant\n\n// requires-ensures variant\n\n/*\nrule for while\n*/\n\n// assert variant\n/*\n*/\n\n// invariant variant\n\n//specification of sum of squares\nspec fn sqr_sum_rec(n: int) -> int\n    recommends n >= 0\n    decreases n\n{\n    if n == 0 { 0 } else { n*n + sqr_sum_rec(n-1) }\n}\n/*\n\n*/\n\n// verification of the program for sum of squares\n\n// SqrSumRec(n) = 0^2 + 1^2 + 2^2 + ... + n^2 == n(n+1)(2n+1)/6\nproof fn l1(n: int)\n    requires n >= 0\n    ensures sqr_sum_rec(n) == n*(n+1)*(2*n + 1)/6\n    decreases n\n{\n    //OK\n}\n\n/*\nspec fn sqr_sum_by_6(n: int) -> int\n{\n    n * (n + 1) * (2 * n + 1) \n}\n\nproof fn l(n: int) // it takes a while\n    requires n >= 0\n    ensures sqr_sum_by_6(n) == 6 * sqr_sum_rec(n)\n    decreases n\n{\n    if n == 0 {}\n    else {\n        assert(n > 0);\n        l(n-1);\n        assert(sqr_sum_by_6(n-1) == n*(n-1)*(2*n - 1));\n        assert(sqr_sum_by_6(n-1) == 6*sqr_sum_rec(n-1));\n        assert(6*sqr_sum_rec(n-1) == n*(n-1)*(2*n - 1));\n        calc! (==)\n        n*((n-1)*(2*n - 1)); {\n            n*(2*n*(n-1) - n + 1); {\n                n*(2*n*n - 3*n + 1); {\n                    n*(2*n*n - 3*n + 1);\n                }\n            }\n        }\n        calc! (==)\n        2*n*n + n; {\n            (2*n + 1)*n;\n        }\n        calc! (==)\n        (2*n + 1)*n + (2*n + 1); {\n            (2*n + 1)*(n+1);\n        }\n        calc! (==)\n        n*((n-1)*(2*n - 1)) + 6*n*n; {\n            n*(2*n*(n-1) - n + 1) + 6*n*n; {\n                n*(2*n*(n-1) - n + 1) + 6*n*n; {\n                    n*(2*n*n - 3*n + 1) + 6*n*n; {\n                        n*(2*n*n - 3*n + 1 + 6*n); {\n                            n*(2*n*n + 6*n - 3*n + 1); {\n                                n*(2*n*n + 3*n + 1); {\n                                    n*(2*n*n + n + (2*n + 1)); {\n                                        n*((2*n + 1)*n + (2*n + 1)); {\n                                            n*((2*n + 1)*(n+1));\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n*/", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn sqr_sum1(n: int) -> (s: int)\n    requires n >= 0\n    ensures s == sqr_sum_rec(n)  // s = 0^2 + 1^2 + 2^2 + ... + n^2 == n(n+1)(2n+1)/6\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    n  // This is unreachable due to assume(false)\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_588_DifferenceMinMax", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// The order of the recursion in these two functions\n// must match the order of the iteration in the algorithm above\nspec fn min(a: Seq<int>) -> int\n    recommends a.len() > 0\n    decreases a.len() when a.len() > 0\n{\n    if a.len() == 1 {\n        a[0]\n    } else {\n        let prefix = a.take(a.len() - 1);\n        let min_prefix = min(prefix);\n        if a[a.len() - 1] <= min_prefix {\n            a[a.len() - 1]\n        } else {\n            min_prefix\n        }\n    }\n}\n\nspec fn max(a: Seq<int>) -> int\n    recommends a.len() > 0  \n    decreases a.len() when a.len() > 0\n{\n    if a.len() == 1 {\n        a[0]\n    } else {\n        let prefix = a.take(a.len() - 1);\n        let max_prefix = max(prefix);\n        if a[a.len() - 1] >= max_prefix {\n            a[a.len() - 1]\n        } else {\n            max_prefix\n        }\n    }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn difference_min_max(a: &[i32]) -> (diff: i32)\n    requires a.len() > 0\n    ensures diff == max(a@.map(|i, x| x as int)) - min(a@.map(|i, x| x as int))\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseFirstNegative_mfirstNegative", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn positive(s: Seq<int>) -> bool {\n    forall|u: int| 0 <= u < s.len() ==> s[u] >= 0\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn mfirstNegative(v: &[int]) -> (result: (bool, usize))\n    ensures \n        (result.0 <==> exists|k: int| 0 <= k < v.len() && v[k] < 0) &&\n        (result.0 ==> (result.1 < v.len() && v[result.1 as int] < 0 && positive(v@.subrange(0, result.1 as int))))\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    (false, 0)\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafny_projects_tmp_tmpjutqwjv4_tutorial_tutorial_Find", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// Working through https://dafny.org/dafny/OnlineTutorial/guide\n\nspec fn fib(n: nat) -> nat\n    decreases n\n{\n    if n == 0 { 0 }\n    else if n == 1 { 1 }\n    else { fib((n - 1) as nat) + fib((n - 2) as nat) }\n}\n\nspec fn sorted(a: &[int]) -> bool {\n    forall|n: int, m: int| 0 <= n < m < a.len() ==> a[n] <= a[m]\n}\n\n\n\n// https://dafny.org/dafny/OnlineTutorial/ValueTypes\n\nspec fn update(s: Seq<int>, i: int, v: int) -> Seq<int> {\n    s.subrange(0, i).add(seq![v]).add(s.subrange(i + 1, s.len() as int))\n}\n\n\n// https://dafny.org/dafny/OnlineTutorial/Lemmas\n\n\n\nspec fn count(a: Seq<bool>) -> nat\n    decreases a.len()\n{\n    if a.len() == 0 { 0nat }\n    else {\n        (if a[0] { 1nat } else { 0nat }) + count(a.subrange(1, a.len() as int))\n    }\n}\n\n\nstruct Node {\n    next: Vec<usize>\n}\n\nspec fn closed(graph: Set<usize>) -> bool {\n    forall|i: usize| graph.contains(i) ==> \n        forall|k: usize| k < 10 ==> // simplified constraint\n            graph.contains(k) && k != i\n}\n\nspec fn path(p: Seq<usize>, graph: Set<usize>) -> bool\n    decreases p.len()\n{\n    closed(graph) && 0 < p.len() &&\n    graph.contains(p[0]) &&\n    (p.len() > 1 ==> \n     path(p.subrange(1, p.len() as int), graph)) // and the rest of the sequence is a valid path\n}\n\nspec fn pathSpecific(p: Seq<usize>, start: usize, end: usize, graph: Set<usize>) -> bool {\n    closed(graph) &&\n    0 < p.len() && // path is nonempty\n    start == p[0] && end == p[p.len() - 1] && // it starts and ends correctly\n    path(p, graph) // and it is a valid path\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn Find(a: &[int], key: int) -> (index: i32)\n    ensures \n        0 <= index ==> index < a.len() && a[index as int] == key,\n        index < 0 ==> (forall|k: int| 0 <= k < a.len() ==> a[k] != key),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    -1\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "cs245-verification_tmp_tmp0h_nxhqp_SortingIssues_FirstAttempt_sort", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// Sorting: \n//        Pre/Post Condition Issues - An investigation \n//                                      -- Stephanie McIntyre\n// Based on examples in class \n\n// First Attempt at specifying requirements for sorting array A in incrementing order\n// We want our Hoare triple of (|Pre-Condition|) Code (|Post-Condition|) to hold iff A is properly sorted.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn sort(A: &mut Vec<i32>, n: usize)\n    requires \n        n == old(A).len(),\n        n >= 0,  // This is always true for usize, but kept for consistency\n    ensures\n        forall|i: int, j: int| 0 <= i <= j < n ==> A[i] <= A[j],  // This states that A is sorted.\n\n//Can we write code that does not sort A that still satisfies the requirements? \n//Consider the following program:\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "dafny_tmp_tmp59p638nn_examples_realExponent_pow", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nuninterp spec fn power(n: int, alpha: int) -> int;\n\nuninterp spec fn log(n: int, alpha: int) -> int;", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn pow(n: u32, alpha: i32) -> (product: i32)\n    requires n > 0 && alpha > 0\n    ensures product == power(n as int, alpha as int)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  0\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n} // verus!"}
{"id": "formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex2_Allow42", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n/*\n    i)  Write a verified method with signature", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn allow_42(x: i32, y: i32) -> (ret: (i32, bool))\n    ensures \n        (y != 42 ==> ret.0 == (x as int / (42int - y as int)) as i32 && ret.1 == false) &&\n        (y == 42 ==> ret.0 == 0 && ret.1 == true)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    (0, false)\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_573_UniqueProduct", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn set_product(s: Set<int>) -> int\n    decreases s.len()\n{\n    if s.is_empty() {\n        1\n    } else {\n        arbitrary()  // This represents the nondeterministic choice like |:| in Dafny\n    }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn unique_product(arr: &[i32]) -> (product: i32)\n    ensures product == set_product(arr@.to_set().map(|x: i32| x as int))\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "Dafny_tmp_tmpv_d3qi10_3_cumsum_cumsum", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sum(a: Seq<i32>, i: int) -> int\n    recommends \n        0 <= i < a.len(),\n    decreases i\n{\n    if 0 <= i < a.len() {\n        a[i] as int + if i == 0 { 0 } else { sum(a, i - 1) }\n    } else {\n        0\n    }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn cumsum(a: &[i32], b: &mut [i32])\n    requires \n        a.len() == old(b).len(),\n        a.len() > 0,\n    ensures \n        forall|i: int| 0 <= i < a.len() ==> b[i] as int == sum(a@, i),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_460_GetFirstElements", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn get_first_elements(lst: Seq<Seq<int>>) -> (result: Seq<int>)\n    requires forall|i: int| 0 <= i < lst.len() ==> lst[i].len() > 0,\n    ensures result.len() == lst.len(),\n    ensures forall|i: int| 0 <= i < result.len() ==> result[i] == lst[i][0],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    Seq::empty()\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "Clover_triple4_Triple", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nproof fn triple(x: int) -> (r: int)\n    ensures r == 3 * x\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0int  // dummy return value\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "bbfny_tmp_tmpw4m0jvl0_enjoying_Find", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// shenanigans going through the dafny tutorial\n\n\n\n\nspec fn max(a: int, b: int) -> int {\n    if a > b { a } else { b }\n}\n\nfn testing() {\n    assume(false);\n}\n\nspec fn abs(x: int) -> int {\n    if x < 0 { -x } else { x }\n}\n\n\nspec fn fib(n: nat) -> nat\n    decreases n\n{\n    if n == 0 { 0 }\n    else if n == 1 { 1 }\n    else { fib((n - 1) as nat) + fib((n - 2) as nat) }\n}\n\nspec fn sorted(a: &[int]) -> bool {\n    forall|j: int, k: int| 0 <= j < k < a.len() ==> a[j] < a[k]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn find(a: &[int], key: int) -> (index: i32)\n    ensures\n        0 <= index ==> index < a.len() && a[index as int] == key,\n        index < 0 ==> forall|k: int| 0 <= k < a.len() ==> a[k] != key,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    -1\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_143_CountArrays", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn count_arrays(arrays: &Vec<Vec<i32>>) -> (count: usize)\n    ensures \n        count >= 0,\n        count == arrays.len(),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "Clover_match_Match", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn match_strings(s: Seq<char>, p: Seq<char>) -> (b: bool)\n  requires s.len() == p.len()\n  ensures b == (forall|n: int| 0 <= n < s.len() ==> s[n] == p[n] || p[n] == '?')\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  true  // placeholder return\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "DafnyProjects_tmp_tmp2acw_s4s_partitionOddEven_partitionOddEven", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// Rearranges the elements in an array 'a' of natural numbers,\n// so that all odd numbers appear before all even numbers.\n\nspec fn odd(n: nat) -> bool { n % 2 == 1 }\nspec fn even(n: nat) -> bool { n % 2 == 0 }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn partitionOddEven(a: &mut Vec<nat>)\n    ensures \n        a@.to_multiset() == old(a)@.to_multiset(),\n        !(exists|i: int, j: int| 0 <= i < j < a@.len() && even(a@[i]) && odd(a@[j])),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "feup-mfes_tmp_tmp6_a1y5a5_examples_SelectionSort_findMin", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* \n * Formal verification of the selection sort algorithm with Verus.\n * FEUP, MIEIC, MFES, 2020/21.\n */\n\n// Checks if array 'a' is sorted between positions 'from' (inclusive) and 'to' (exclusive).\npub open spec fn is_sorted(a: &[i32], from: usize, to: usize) -> bool {\n    &&& from <= to <= a.len()\n    &&& forall|i: int, j: int| from <= i < j < to ==> a[i] <= a[j]\n}\n\n// Sorts array 'a' using the selection sort algorithm.\n\n// Finds the position of a minimum value in non-empty subarray 'a' between positions \n// 'from' (inclusive) and 'to' (exclusive)", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn find_min(a: &mut [i32], from: usize, to: usize) -> (index: usize)\n    requires \n        0 <= from < to <= old(a).len(),\n    ensures\n        from <= index < to,\n        forall|k: int| from <= k < to ==> old(a)[k] >= old(a)[index as int],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    from\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_from dafny main repo_dafny2_COST-verif-comp-2011-3-TwoDuplicates_Search", "vc-description": "", "vc-preamble": "// RUN: %testDafnyForEachResolver \"%s\" -- --warn-deprecation:false\n\nuse vstd::prelude::*;\n\nverus! {\n\n/*\nRustan Leino, 5 Oct 2011\n\nCOST Verification Competition, Challenge 3: Two equal elements\nhttp://foveoos2011.cost-ic0701.org/verification-competition\n\nGiven: An integer array a of length n+2 with n>=2. It is known that at\nleast two values stored in the array appear twice (i.e., there are at\nleast two duplets).\n\nImplement and verify a program finding such two values.\n\nYou may assume that the array contains values between 0 and n-1.\n*/\n\n// Remarks:\n\n// The implementation of method 'Search' takes one pass through the elements of\n// the given array.  To keep track of what it has seen, it allocates an array as\n// temporary storage--I imagine that this is what the competition designers\n// had in mind, since the problem description says one can assume the values\n// of the given array to lie in the range 0..n.\n\n// To keep track of whether it already has found one duplicate, the method\n// sets the output variables p and q as follows:\n//   p != q   - no duplicates found yet\n//   p == q   - one duplicate found so far, namely the value stored in p and q\n// Note, the loop invariant does not need to say anything about the state\n// of two duplicates having been found, because when the second duplicate is\n// found, the method returns.\n\n// What needs to be human-trusted about this program is the specification of\n// 'Search'.  The specification straightforwardly lists the assumptions stated\n// in the problem description, including the given fact that the array contains\n// (at least) two distinct elements that each occurs (at least) twice.  To\n// trust the specification of 'Search', a human also needs to trust the definition\n// of 'IsDuplicate' and its auxiliary function 'IsPrefixDuplicate'.\n\n// About Dafny:\n// As always (when it is successful), Dafny verifies that the program does not\n// cause any run-time errors (like array index bounds errors), that the program\n// terminates, that expressions and functions are well defined, and that all\n// specifications are satisfied.  The language prevents type errors by being type\n// safe, prevents dangling pointers by not having an \"address-of\" or \"deallocate\"\n// operation (which is accommodated at run time by a garbage collector), and\n// prevents arithmetic overflow errors by using mathematical integers (which\n// is accommodated at run time by using BigNum's).  By proving that programs\n// terminate, Dafny proves that a program's time usage is finite, which implies\n// that the program's space usage is finite too.  However, executing the\n// program may fall short of your hopes if you don't have enough time or\n// space; that is, the program may run out of space or may fail to terminate in\n// your lifetime, because Dafny does not prove that the time or space needed by\n// the program matches your execution environment.  The only input fed to\n// the Dafny verifier/compiler is the program text below; Dafny then automatically\n// verifies and compiles the program (for this program in less than 11 seconds)\n// without further human intervention.\n\nspec fn uninterp is_duplicate(a: Seq<int>, p: int) -> bool;\n\nspec fn uninterp is_prefix_duplicate(a: Seq<int>, k: usize, p: int) -> bool;", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn search(a: &[i32]) -> (ret: (i32, i32))\n    requires 4 <= a.len(),\n    requires exists|p: int, q: int| #![auto] p != q && is_duplicate(a@.map(|i, x| x as int), p) && is_duplicate(a@.map(|i, x| x as int), q),  // two distinct duplicates exist\n    requires forall|i: usize| #![auto] 0 <= i < a.len() ==> 0 <= a[i as int] < (a.len() - 2) as int,  // the elements of \"a\" in the range [0.. a.len()-2]\n    ensures ret.0 != ret.1 && is_duplicate(a@.map(|i, x| x as int), ret.0 as int) && is_duplicate(a@.map(|i, x| x as int), ret.1 as int)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    (0, 1)\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "Workshop_tmp_tmp0cu11bdq_Lecture_Answers_max_array_max", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// http://verifythus.cost-ic0701.org/common-example/arraymax-in-dafny", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn max(a: &[i32]) -> (max: i32)\n    requires a.len() > 0,\n    ensures forall|j: int| 0 <= j < a.len() ==> max >= a[j], //max is larger then anything in the array\n    // Note: exists quantifier syntax may vary in different Verus versions\n    // ensures exists|j: int| 0 <= j < a.len() && max == a[j], //max is an element in the array\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Clover_online_max_onlineMax", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn online_max(a: &[i32], x: usize) -> (result: (Ghost<i32>, usize))\n    requires \n        1 <= x < a.len(),\n        a.len() != 0,\n    ensures\n        x <= result.1 < a.len(),\n        forall|i: int| 0 <= i < x ==> #[trigger] a[i] <= result.0@,\n        exists|i: int| 0 <= i < x && #[trigger] a[i] == result.0@,\n        x <= result.1 < a.len() - 1 ==> (forall|i: int| 0 <= i < result.1 ==> #[trigger] a[i] < a[result.1 as int]),\n        (forall|i: int| x <= i < a.len() && #[trigger] a[i] <= result.0@) ==> result.1 == a.len() - 1\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    (Ghost(0), 0)\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "Clover_swap_Swap", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn swap(x: i32, y: i32) -> (result: (i32, i32))\n    ensures \n        result.0 == y,\n        result.1 == x,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    (y, x)\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_566_SumOfDigits", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// spec fn int_values(n: int) -> Seq<int>\n//     recommends n >= 0\n// {\n//     if n == 0 { seq![0] }\n//     else { seq![n] + int_values(n/10) }\n// }\n\nspec fn power10(n: nat) -> nat\n    decreases n\n{\n    if n == 0 { 1 } else { 10 * power10((n - 1) as nat) }\n}\n\n// spec fn number_to_seq(number: int) -> Seq<int>\n//     recommends number >= 0\n// {\n//     if number == 0 { Seq::empty() }\n//     else { seq![number % 10] + number_to_seq(number/10) }\n// }\n\n// spec fn sum_seq(digits: Seq<int>) -> int\n// {\n//     if digits.len() == 0 { 0 }\n//     else { digits[0] + sum_seq(digits.subrange(1, digits.len() as int)) }\n// }\n\nspec fn sum_digits(n: nat) -> nat {\n    let ndigits = number_of_digits(n);\n    let p = power10((ndigits - 1) as nat);\n    sum_digits_recursive(n, p)\n}\n\nspec fn sum_digits_recursive(n: nat, p: nat) -> nat\n    decreases p\n{\n    if n == 0 || p == 0 { 0 }\n    else {\n        let left_most_digit = n/p;\n        let rest = n%p;\n        left_most_digit + sum_digits_recursive(rest, (p/10) as nat)\n    }\n}\n\nspec fn number_of_digits(n: nat) -> nat\n    decreases n\n{\n    if 0 <= n <= 9 { 1 } else { 1 + number_of_digits((n/10) as nat) }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn sum_of_digits(number: u64) -> (sum: u64)\n    requires number >= 0,\n    ensures \n        sum >= 0,\n        sum == sum_digits(number as nat),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_594_FirstEvenOddDifference", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_even(n: int) -> bool {\n    n % 2 == 0\n}\n\nspec fn is_odd(n: int) -> bool {\n    n % 2 != 0\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn first_even_odd_difference(a: &[i32]) -> (diff: i32)\n    requires \n        a.len() >= 2,\n        exists|i: int| 0 <= i < a.len() && is_even(a[i] as int),\n        exists|i: int| 0 <= i < a.len() && is_odd(a[i] as int),\n    ensures \n        exists|i: int, j: int| \n            0 <= i < a.len() && \n            0 <= j < a.len() && \n            is_even(a[i] as int) && \n            is_odd(a[j] as int) && \n            diff == a[i] - a[j] && \n            (forall|k: int| 0 <= k < i ==> is_odd(a[k] as int)) && \n            (forall|k: int| 0 <= k < j ==> is_even(a[k] as int))\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0  // dummy return value\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced examples_Percentile_PercentileNonUniqueAnswer", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// Sum of elements of A from indices 0 to end.\n// end is inclusive! (not James's normal way of thinking!!)\nspec fn sum_upto(a: Seq<int>, end: int) -> int\n    recommends -1 <= end < a.len()\n    decreases end + 1\n    when end >= -1\n{\n    if end == -1 {\n        0\n    } else {\n        a[end] + sum_upto(a, end - 1)\n    }\n}\n\nspec fn sum(a: Seq<int>) -> int {\n    sum_upto(a, a.len() - 1)\n}\n\n\n// example showing that, with the original postcondition, the answer is non-unique!", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\n#[verifier::external_body]\nfn percentile_non_unique_answer() -> (result: (int, Vec<int>, int, int, int))\n    ensures (forall|i: int| 0 <= i < result.1@.len() ==> result.1@[i] > 0)\n    ensures (0 <= result.0 && result.0 <= 100)\n    ensures (result.2 == sum(result.1@))\n    ensures (result.2 > 0)\n\n    ensures (-1 <= result.3 && result.3 < result.1@.len())\n    ensures (sum_upto(result.1@, result.3) <= (result.0/100) * result.2)\n    ensures (result.3+1 < result.1@.len() ==> sum_upto(result.1@, result.3+1) >= (result.0/100) * result.2)\n\n    ensures (-1 <= result.4 && result.4 < result.1@.len())\n    ensures (sum_upto(result.1@, result.4) <= (result.0/100) * result.2)\n    ensures (result.4+1 < result.1@.len() ==> sum_upto(result.1@, result.4+1) >= (result.0/100) * result.2)\n\n    ensures (result.3 != result.4)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    unimplemented!()\n}\n// </vc-code>", "vc-postamble": "// proof that, with the corrected postcondition, the answer is unique\n// lemma for previous proof: when an array has strictly positive elements, the\n// sums strictly increase left to right\n\nfn main() {\n}\n\n}"}
{"id": "VerifiedMergeSortDafny_tmp_tmpva7qms1b_MergeSort_merge", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn merged(a1: Seq<int>, a2: Seq<int>, b: &Vec<int>, start: int, end: int) -> bool {\n    &&& end - start == a2.len() + a1.len()\n    &&& 0 <= start <= end <= b.len()\n    &&& a1.to_multiset().add(a2.to_multiset()) == b@.subrange(start, end).to_multiset()\n}\n\nspec fn sorted_slice(a: &Vec<int>, start: int, end: int) -> bool {\n    &&& 0 <= start <= end <= a.len()\n    &&& forall|i: int, j: int| start <= i <= j < end ==> a@[i] <= a@[j]\n}\n\nspec fn sorted_seq(a: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i <= j < a.len() ==> a[i] <= a[j]\n}\n\nspec fn sorted(a: &Vec<int>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < a.len() ==> a@[i] <= a@[j]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn merge(a1: Seq<int>, a2: Seq<int>, start: int, end: int, b: &mut Vec<int>)\n    requires \n        sorted_seq(a1),\n        sorted_seq(a2),\n        end - start == a1.len() + a2.len(),\n        0 <= start < end < a1.len() && end <= a2.len() < old(b).len(),\n        end < a1.len() && end < a2.len(),\n        old(b).len() == a2.len() + a1.len(),\n    ensures \n        sorted_slice(b, start, end),\n        merged(a1, a2, b, start, end),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "dafleet_tmp_tmpa2e4kb9v_0001-0050_0003-longest-substring-without-repeating-characters_lengthOfLongestSubstring", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* https://leetcode.com/problems/longest-substring-without-repeating-characters/\nGiven a string s, find the length of the longest substring without repeating characters.\n\nExample 1:\nInput: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.\n*/\n\n\n// a left-inclusive right-exclusive interval:\npub struct Interval {\n    pub start: int,\n    pub end: int,\n}\n\nimpl Interval {\n    pub open spec fn valid(self) -> bool {\n        self.start <= self.end\n    }\n}\n\npub open spec fn length(iv: Interval) -> int {\n    iv.end - iv.start\n}\n\npub open spec fn valid_interval(s: Seq<char>, iv: Interval) -> bool {\n    &&& 0 <= iv.start <= iv.end <= s.len()                             // interval is in valid range\n    &&& forall|i: int, j: int| iv.start <= i < j < iv.end ==> s[i] != s[j]   // no repeating characters in interval\n}\n\n// Below shows an efficient solution using standard \"sliding window\" technique. \n// For verification simplicity, we pretend as if:\n// - `set` were Python set (or even better, a fixed-size array -- if the \"alphabet\" is small)\n//\n// `best_iv` is for verification purpose, not returned by the real program, thus `ghost`.\n\n/* Discussions\n1. The \"sliding window\" technique is the most \"fancy\" part of the solution,\n  ensuring an O(n) time despite the O(n^2) search space.\n  The reason why it works lies in the last two invariants: (A) and (B).\n\n  Invariant (A) is simply a \"partial\" guarantee for the longest valid substring in `s[..hi]`,\n  so once the loop finishes, as `hi == |s|`, this \"partial\" guarantee becomes \"full\".\n\n  Invariant (B) is crucial: it encodes why we can monotonically increase `lo` as we increase `hi`.\n  What's the \"intuition\" behind that? Let me share an \"informal proof\" below:\n\n    Let `sub(i)` be the longest valid substring whose last character is `s[i]`.\n    Apparently, the final answer will be \"the longest among the longests\", i.e.\n    `max(|sub(0)|, |sub(1)|, ..., |sub(|s|-1)|)`.\n\n    Now, notice that the \"starting position\" of `sub(i)` is monotonically increasing regarding `i`!\n    Otherwise, imagine `sub(i+1)` started at `j` while `sub(i)` started at `j+1` (or even worse),\n    then `sub(i)` could be made longer (by starting at `j` instead).\n    This is an obvious contradiction.\n\n    Therefore, when we search for the starting position of `sub(i)` (the `lo`) for each `i` (the `hi`),\n    there's no need to \"look back\".\n\n2. The solution above can be made more efficient, using \"jumping window\" instead of \"sliding window\".\n  Namely, we use a dict (instead of set) to look up the \"position of repetition\",\n  and move `lo` right after that position at once.\n\n  You can even \"early terminate\" (based on `lo`) when all remaining intervals are doomed \"no longer\",\n  resulting in even fewer number of loop iterations.\n  (Time complexity will still be O(n), though.)\n\n  The corresponding verification code is shown below:\n*/\n\n\n// For verification simplicity, we pretend as if:\n// - `map` were Python dict (or even better, a fixed-size array -- if the \"alphabet\" is small)\n\n// Bonus Question:\n//   \"Why can we safely use (C) instead of (D) as the loop condition? Won't `hi` go out-of-bound?\"\n// Can you figure it out?", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn lengthOfLongestSubstring(s: Seq<char>) -> (result: (usize, Ghost<Interval>))\n    ensures \n        valid_interval(s, result.1@) && length(result.1@) == result.0 as int,    /** `result.1@` is valid */\n        forall|iv: Interval| valid_interval(s, iv) ==> length(iv) <= result.0 as int,  /** `result.1@` is longest */\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    (0, Ghost(Interval { start: 0, end: 0 }))\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "Clover_array_append_append", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn append(a: &Vec<i32>, b: i32) -> (c: Vec<i32>)\n    ensures c@ == a@ + seq![b]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    Vec::new() // unreachable due to assume(false), but needed for type checking\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex1_PalVerify", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// ex3errors.dfy in Assignment 1\n// verify that an array of characters is a Palindrome\n/*\nA Palindrome is a word that is the same when written forwards and when written backwards. \nFor example, the word \"refer\" is a Palindrome.\nThe method PalVerify is supposed to verify whether a word is a Palindrome, \nwhere the word is represented as an array of characters. \nThe method was written by a novice software engineer, and contains many errors.\n\n   i) Without changing the signature or the code in the while loop, \n      fix the method so that it veriifes the code. Do not add any Dafny predicates or functions: \n      keep the changes to a minimum.\n\n   ii) Write a tester method (you may call it anything you like) that verifies that the \n      testcases refer, z and the empty string are Palindromes, and xy and 123421 are not. \n      The tester should not generate any output.\n*/", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn pal_verify(a: &Vec<char>) -> (yn: bool)\n    ensures yn == true ==> forall|i: int| 0 <= i < a.len()/2 ==> #[trigger] a[i] == #[trigger] a[a.len() - i - 1]\n    ensures yn == false ==> exists|i: int| #![trigger a[i], a[a.len() - i - 1]] 0 <= i < a.len()/2 && a[i] != a[a.len() - i - 1]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    false\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseReplace_replace", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn replace(v: &mut Vec<i32>, x: i32, y: i32)\n    ensures\n        forall|k: int| 0 <= k < old(v).len() && old(v)[k] == x ==> v[k] == y,\n        forall|k: int| 0 <= k < old(v).len() && old(v)[k] != x ==> v[k] == old(v)[k],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "BinarySearchTree_tmp_tmp_bn2twp5_bst4copy_insert", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n#[derive(PartialEq, Eq)]\npub enum Tree {\n    Empty,\n    Node(Box<Tree>, int, Box<Tree>),\n}\n\npub open spec fn binary_search_tree(tree: Tree) -> bool\n    decreases tree\n{\n    match tree {\n        Tree::Empty => true,\n        Tree::Node(left, value, right) => {\n            (matches!(*left, Tree::Empty) || (*left).get_node_value() < value)\n            && (matches!(*right, Tree::Empty) || (*right).get_node_value() > value)\n            && binary_search_tree(*left)\n            && binary_search_tree(*right)\n            && min_value(*right, value)\n            && max_value(*left, value)\n        }\n    }\n}\n\npub open spec fn max_value(tree: Tree, max: int) -> bool\n    decreases tree\n{\n    match tree {\n        Tree::Empty => true,\n        Tree::Node(left, value, right) => {\n            max > value && max_value(*left, max) && max_value(*right, max)\n        }\n    }\n}\n\npub open spec fn min_value(tree: Tree, min: int) -> bool\n    decreases tree\n{\n    match tree {\n        Tree::Empty => true,\n        Tree::Node(left, value, right) => {\n            min < value && min_value(*left, min) && min_value(*right, min)\n        }\n    }\n}\n\nimpl Tree {\n    pub open spec fn get_node_value(self) -> int\n        recommends !matches!(self, Tree::Empty)\n    {\n        match self {\n            Tree::Node(_, value, _) => value,\n            _ => arbitrary()\n        }\n    }\n}\n\nfn insert_recursion(tree: Tree, value: int) -> (res: Tree)\n    requires binary_search_tree(tree),\n    ensures \n        res != Tree::Empty ==> binary_search_tree(res),\n        forall|x: int| min_value(tree, x) && x < value ==> min_value(res, x),\n        forall|x: int| max_value(tree, x) && x > value ==> max_value(res, x),\n    decreases tree,\n{\n    assume(false);\n    Tree::Empty\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn insert(tree: Tree, value: int) -> (res: Tree)\n    requires binary_search_tree(tree),\n    ensures binary_search_tree(res),\n    decreases tree,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    Tree::Empty\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "dafny-exercise_tmp_tmpouftptir_absIt_AbsIt", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn abs_it(s: &mut Vec<i32>)\n    ensures\n        s.len() == old(s).len(),\n        forall|i: int| 0 <= i < s.len() ==> \n            if old(s)[i] < 0 { s[i] == -old(s)[i] } else { s[i] == old(s)[i] }\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_399_BitwiseXOR", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn bitwise_xor(a: Seq<u32>, b: Seq<u32>) -> (result: Seq<u32>)\n    requires\n        a.len() == b.len(),\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] ^ b[i],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  unreached()\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "software_analysis_tmp_tmpmt6bo9sf_ss_find_min_index", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_sorted(ss: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i <= j < ss.len() ==> ss[i] <= ss[j]\n}\n\nspec fn is_permutation(a: Seq<int>, b: Seq<int>) -> bool\n    decreases a.len(), b.len()\n{\n    a.len() == b.len() && \n    ((a.len() == 0 && b.len() == 0) ||  \n    exists|i: int, j: int| 0 <= i < a.len() && 0 <= j < b.len() && \n        a[i] == b[j] && \n        is_permutation(\n            a.subrange(0, i) + (if i < a.len() { a.subrange(i + 1, a.len() as int) } else { seq![] }),\n            b.subrange(0, j) + (if j < b.len() { b.subrange(j + 1, b.len() as int) } else { seq![] })\n        ))\n}\n\n\n// spec fn is_permutation(a: Seq<int>, b: Seq<int>) -> bool\n//     decreases a.len(), b.len()\n// {\n//     a.len() == b.len() && ((a.len() == 0 && b.len() == 0) || exists|i: int, j: int| 0 <= i < a.len() && 0 <= j < b.len() && a[i] == b[j] && is_permutation(a.subrange(0, i) + a.subrange(i + 1, a.len() as int), b.subrange(0, j) + b.subrange(j + 1, b.len() as int)))\n// }\n\nspec fn is_permutation2(a: Seq<int>, b: Seq<int>) -> bool {\n    a.to_multiset() == b.to_multiset()\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn find_min_index(a: &[int], s: usize, e: usize) -> (min_i: usize)\n    requires\n        a.len() > 0,\n        s < a.len(),\n        e <= a.len(),\n        e > s,\n    ensures\n        min_i >= s,\n        min_i < e,\n        forall|k: int| s <= k < e ==> a[min_i as int] <= a[k],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 3_SelectionSortMultiset_Sort", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\nuse vstd::multiset::*;\n\nverus! {\n\n// Höfundur spurningar:  Snorri Agnarsson, snorri@hi.is\n// Permalink spurningar: https://rise4fun.com/Dafny/dtcnY\n\n// Höfundur lausnar:     Alexander Guðmundsson\n// Permalink lausnar:    https://rise4fun.com/Dafny/ybUCz\n\n///////////////////////////////////////////////////////////////\n// Hér byrjar óbreytanlegi hluti skrárinnar.\n// Fyrir aftan þann hluta er sá hluti sem þið eigið að breyta.\n///////////////////////////////////////////////////////////////\n\n// Hjálparfall sem finnur minnsta gildi í poka\n\nproof fn min_of_multiset(m: Multiset<int>) -> (min: int)\n    requires \n        m.len() > 0,\n    ensures \n        m.count(min) > 0,\n        forall|z: int| m.count(z) > 0 ==> min <= z,\n{\n    assume(false);\n    arbitrary()\n}\n\n// Ekki má breyta þessu falli.\n\n\n///////////////////////////////////////////////////////////////\n// Hér lýkur óbreytanlega hluta skrárinnar.\n// Hér fyrir aftan er sá hluti sem þið eigið að breyta til að\n// útfæra afbrigði af selection sort.\n///////////////////////////////////////////////////////////////\n\n// Selection sort sem raðar poka í runu.\n// Klárið að forrita þetta fall.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nexec fn sort(m: Multiset<int>) -> (s: Vec<int>)\n    // Setjið viðeigandi ensures klausur hér\n    ensures \n        s@.to_multiset() == m,\n        forall|p: int, q: int| 0 <= p < q < s.len() ==> s[p] <= s[q],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_565_SplitStringIntoChars", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn split_string_into_chars(s: Vec<char>) -> (v: Vec<char>)\n    ensures\n        v.len() == s.len(),\n        forall|i: int| 0 <= i < s.len() ==> v[i] == s[i],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_567_IsSorted", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn is_sorted(a: &[i32]) -> (sorted: bool)\n    requires\n        a.len() > 0,\n    ensures\n        sorted <==> forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j],\n        !sorted ==> exists|i: int, j: int| 0 <= i < j < a.len() && a[i] > a[j],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    true\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Insertion_Sort_Normal_insertionSort", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sorted(a: &Vec<i32>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j]\n}\n\nspec fn sorted_range(a: &Vec<i32>, end: int) -> bool {\n    forall|i: int, j: int| 0 <= i < j < end ==> a[i] <= a[j]\n}\n\nfn look_for_min(a: &Vec<i32>, i: usize) -> (m: usize)\n    requires \n        0 <= i < a.len()\n    ensures \n        i <= m < a.len(),\n        forall|k: int| i <= k < a.len() ==> a[k as int] >= a[m as int]\n{\n    assume(false);\n    i // placeholder return\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn insertion_sort(a: &mut Vec<i32>)\n    ensures sorted(a)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "Clover_triple_Triple", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn triple(x: i32) -> (r: i32)\n  ensures r == 3 * x\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  0\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "Clover_swap_bitvector_SwapBitvectors", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn swap_bitvectors(x: u8, y: u8) -> (result: (u8, u8))\n    ensures \n        result.0 == y,\n        result.1 == x,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    (0, 0) // This will never be reached due to assume(false)\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "assertive-programming-assignment-1_tmp_tmp3h_cj44u_SearchAddends_FindAddends", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sorted(q: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i <= j < q.len() ==> q[i] <= q[j]\n}\n\nspec fn has_addends(q: Seq<int>, x: int) -> bool {\n    exists|i: int, j: int| 0 <= i < j < q.len() && q[i] + q[j] == x\n}\n\nspec fn is_valid_index<T>(q: Seq<T>, i: nat) -> bool {\n    0 <= i < q.len()\n}\n\nspec fn are_ordered_indices<T>(q: Seq<T>, i: nat, j: nat) -> bool {\n    0 <= i < j < q.len()\n}\n\nspec fn are_addends_indices(q: Seq<int>, x: int, i: nat, j: nat) -> bool\n    recommends is_valid_index(q, i) && is_valid_index(q, j)\n{\n    q[i as int] + q[j as int] == x\n}\n\nspec fn has_addends_in_indices_range(q: Seq<int>, x: int, i: nat, j: nat) -> bool\n    recommends are_ordered_indices(q, i, j)\n{\n    has_addends(q.subrange(i as int, (j + 1) as int), x)\n}\n\nspec fn loop_inv(q: Seq<int>, x: int, i: nat, j: nat, sum: int) -> bool {\n    are_ordered_indices(q, i, j) &&\n    has_addends_in_indices_range(q, x, i, j) &&\n    are_addends_indices(q, sum, i, j)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn find_addends(q: Seq<int>, x: int) -> (result: (usize, usize))\n    requires sorted(q) && has_addends(q, x)\n    ensures ({\n        let (i, j) = result;\n        i < j < q.len() && q[i as int] + q[j as int] == x\n    })\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  (0, 1)\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseContained_mcontained", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn strict_sorted(s: Seq<i32>) -> bool {\n    forall|u: int, w: int| 0 <= u < w < s.len() ==> s[u] < s[w]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn mcontained(v: &[i32], w: &[i32], n: usize, m: usize) -> (b: bool)\n//Specify and implement an O(m+n) algorithm that returns b\n//v and w are strictly increasing ordered arrays\n//b is true iff the first n elements of v are contained in the first m elements of w\n    requires \n        n <= m,\n        n >= 0,\n        strict_sorted(v@),\n        strict_sorted(w@),\n        v@.len() >= n,\n        w@.len() >= m,\n    ensures\n        b == forall|k: int| 0 <= k < n ==> w@.subrange(0, m as int).contains(v@[k])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    false\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 1_LinearSearch_SearchLoop", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// Author of question: Snorri Agnarsson\n// Permalink of question: https://rise4fun.com/Dafny/0HRr\n\n// Author of solution:    Alexander Guðmundsson\n// Permalink of solution: https://rise4fun.com/Dafny/8pxWd\n\n// Use the command\n//   verus LinearSearch-skeleton.rs\n// to verify the file.\n\n// When you have solved the problem put\n// the solution on the Verus web page,\n// generate a permalink and put it in\n// this file.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn search_loop(a: &Vec<i32>, i: usize, j: usize, x: i32) -> (k: i32)\n    requires \n        i <= j <= a.len(),\n    ensures \n        (i <= k < j) || k == -1,\n        k != -1 ==> 0 <= k < a.len() && a[k as int] == x,\n        k != -1 ==> forall|r: int| k < r < j && 0 <= r < a.len() ==> a[r] != x,\n        k == -1 ==> forall|r: int| (i as int) <= r < (j as int) && 0 <= r < a.len() ==> a[r] != x,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    proof {\n        assume(false);\n    }\n    -1\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "dafleet_tmp_tmpa2e4kb9v_0001-0050_0005-longest-palindromic-substring_expand_from_center", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* https://leetcode.com/problems/longest-palindromic-substring/\nGiven a string s, return the longest palindromic substring in s.\n\nExample 1:\nInput: s = \"babad\"\nOutput: \"bab\"\nExplanation: \"aba\" is also a valid answer.\n*/\n\n\n// Specifying the problem: whether `s[i..j]` is palindromic\nspec fn palindromic(s: Seq<char>, i: int, j: int) -> bool\n    recommends 0 <= i <= j <= s.len()\n    decreases j - i\n{\n    j - i < 2 || (s[i] == s[j-1] && palindromic(s, i+1, j-1))\n}\n\n// A \"common sense\" about palindromes:\n\n// A useful \"helper function\" that returns the longest palindrome at a given center (i0, j0).\n\n// The main algorithm.\n// We traverse all centers from left to right, and \"expand\" each of them, to find the longest palindrome.\n\n\n/* Discussions\n1. Dafny is super bad at slicing (esp. nested slicing).\n  Do circumvent it whenever possible. It can save you a lot of assertions & lemmas!\n\n  For example, instead of `palindromic(s[i..j])`, use the pattern `palindromic(s, i, j)` instead.\n  I didn't realize this (ref: https://github.com/Nangos/dafleet/commit/3302ddd7642240ff2b2f6a8c51e8becd5c9b6437),\n  Resulting in a couple of clumsy lemmas.\n\n2. Bonus -- Manacher's algorithm\n  Our above solution needs `O(|s|^2)` time in the worst case. Can we improve it? Yes.\n\n  Manacher's algorithm guarantees an `O(|s|)` time.\n  To get the intuition, ask yourself: when will it really take `O(|s|^2)` time?\n  When there are a lot of \"nesting and overlapping\" palindromes. like in `abcbcbcba` or even `aaaaaa`.\n\n  Imagine each palindrome as a \"mirror\". \"Large mirrors\" reflect \"small mirrors\".\n  Therefore, when we \"expand\" from some \"center\", we can \"reuse\" some information from its \"mirrored center\".\n  For example, we move the \"center\", from left to right, in the string `aiaOaia...`\n  Here, the char `O` is the \"large mirror\".\n  When the current center is the second `i`, it is \"mirrored\" to the first `i` (which we've calculated for),\n  so we know the palindrome centered at the second `i` must have at least a length of 3 (`aia`).\n  So we can expand directly from `aia`, instead of expanding from scratch.\n\n  Manacher's algorithm is verified below.\n  Also, I will verify that \"every loop is entered for only `O(|s|)` times\",\n  which \"indirectly\" proves that the entire algorithm runs in `O(|s|)` time.\n*/\n\n\n// A reference implementation of Manacher's algorithm:\n// (Ref. https://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher's_algorithm) for details...\nfn longest_palindrome_prime(s: Seq<char>) -> (result: (Seq<char>, usize, usize))\n    ensures ({\n        let (ans, lo, hi) = result;\n        &&& 0 <= lo <= hi <= s.len()\n        &&& ans == s.subrange(lo as int, hi as int)\n        &&& palindromic(s, lo as int, hi as int)\n        &&& forall|i: int, j: int| 0 <= i <= j <= s.len() && palindromic(s, i, j) ==> j - i <= hi - lo\n    })\n{\n    assume(false);\n    let ghost empty_seq = Seq::<char>::empty();\n    (empty_seq, 0, 0)\n}\n\n\n// Below are helper functions and lemmas we used:\n\n// Inserts bogus characters to the original string (e.g. from `abc` to `|a|b|c|`).\n// Note that this is neither efficient nor necessary in reality, but just for the ease of understanding.\nspec fn insert_bogus_chars(s: Seq<char>, bogus: char) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        seq![bogus]\n    } else {\n        let s_old = insert_bogus_chars(s.drop_first(), bogus);\n        seq![bogus].add(seq![s[0]]).add(s_old)\n    }\n}\n\n// Returns (max_index, max_value) of array `a` starting from index `start`.\nfn argmax(a: Vec<i32>, start: usize) -> (result: (usize, i32))\n    requires 0 <= start < a.len()\n    ensures ({\n        let (idx, val) = result;\n        &&& start <= idx < a.len()\n        &&& a@[idx as int] == val\n        &&& forall|i: int| start <= i < a.len() ==> a@[i] <= val\n    })\n    decreases a.len() - start\n{\n    if start == a.len() - 1 {\n        (start, a[start])\n    } else {\n        let (i, v) = argmax(a, start + 1);\n        if a[start] >= v { (start, a[start]) } else { (i, v) }\n    }\n}\n\n// Whether an interval at center `c` with a radius `r` is within the boundary of `s'`.\nspec fn inbound_radius(s_prime: Seq<char>, c: int, r: int) -> bool {\n    r >= 0 && 0 <= c-r && c+r < s_prime.len()\n}\n\n// Whether `r` is a valid palindromic radius at center `c`.\nspec fn palindromic_radius(s_prime: Seq<char>, c: int, r: int) -> bool\n    recommends inbound_radius(s_prime, c, r)\n{\n    palindromic(s_prime, c-r, c+r+1)\n}\n\n// Whether `r` is the maximal palindromic radius at center `c`.\nspec fn max_radius(s_prime: Seq<char>, c: int, r: int) -> bool {\n    &&& inbound_radius(s_prime, c, r)\n    &&& palindromic_radius(s_prime, c, r)\n    &&& forall|r_prime: int| r_prime > r && inbound_radius(s_prime, c, r_prime) ==> !palindromic_radius(s_prime, c, r_prime)\n}\n\n// Basically, just \"rephrasing\" the `lemma_palindromic_contains`,\n// talking about center and radius, instead of interval\n\n// When \"expand from center\" ends, we've find the max radius:\n\n// The critical insight behind Manacher's algorithm.\n//\n// Given the longest palindrome centered at `c` has length `r`, consider the interval from `c-r` to `c+r`.\n// Consider a pair of centers in the interval: `c1` (left half) and `c2` (right half), equally away from `c`.\n// Then, the length of longest palindromes at `c1` and `c2` are related as follows:\n//, where:\nspec fn abs(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\n// Transfering our final result on `s'` to that on `s`:\n\n// The following returns whether `s[lo..hi]` is the longest palindrome s.t. `lo + hi == k`:\nspec fn max_interval_for_same_center(s: Seq<char>, k: int, lo: int, hi: int) -> bool {\n    &&& 0 <= lo <= hi <= s.len()\n    &&& lo + hi == k\n    &&& palindromic(s, lo, hi)\n    &&& forall|i: int, j: int| 0 <= i <= j <= s.len() && palindromic(s, i, j) && i + j == k ==> j - i <= hi - lo\n}\n\n// Establishes the \"palindromic isomorphism\" between `s` and `s'`.\n\n// Implies that whenever `c + r` is odd, the corresponding palindrome can be \"lengthened for free\"\n// because its both ends are the bogus char.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn expand_from_center(s: Seq<char>, i0: usize, j0: usize) -> (result: (usize, usize))\n    requires 0 <= i0 <= j0 <= s.len()\n    requires palindromic(s, i0 as int, j0 as int)\n    ensures ({\n        let (lo, hi) = result;\n        &&& 0 <= lo <= hi <= s.len()\n        &&& palindromic(s, lo as int, hi as int)\n        &&& forall|i: int, j: int| 0 <= i <= j <= s.len() && palindromic(s, i, j)  // Among all palindromes\n          && i + j == i0 + j0                                             // sharing the same center,\n          ==> j - i <= hi - lo                                             // `s[lo..hi]` is longest.\n    })\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    (0, 0)\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced examples_ReverseString_yarra", "vc-description": "", "vc-preamble": "// RUN: /compile:0\n\nuse vstd::prelude::*;\n\nverus! {\n\n// Predicate to check if outarr is the reverse of arr\nspec fn reversed(arr: Seq<char>, outarr: Seq<char>) -> bool {\n    arr.len() == outarr.len() &&\n    forall|k: int| 0 <= k < arr.len() ==> outarr[k] == arr[arr.len() - 1 - k]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn yarra(arr: &Vec<char>) -> (outarr: Vec<char>)\n    requires arr.len() > 0\n    ensures outarr.len() == arr.len() && reversed(arr@, outarr@)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "MFES_2021_tmp_tmpuljn8zd9_Exams_Special_Exam_03_2020_4_CatalanNumbers_calcC", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn C(n: nat) -> nat\n    decreases n\n{\n    if n == 0 { \n        1nat \n    } else { \n        ((4 * (n as int) - 2) * (C((n - 1) as nat) as int) / ((n as int) + 1)) as nat\n    }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn calcC(n: u64) -> (res: u64)\n    ensures res == C(n as nat),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0  // Need to return a value\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_14_TriangularPrismVolume", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn triangular_prism_volume(base: u32, height: u32, length: u32) -> (volume: u32)\n    requires \n        base > 0,\n        height > 0,\n        length > 0,\n    ensures volume == (base * height * length) / 2,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_452_CalculateLoss", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn calculate_loss(cost_price: i32, selling_price: i32) -> (loss: i32)\n    requires cost_price >= 0 && selling_price >= 0,\n    ensures (cost_price > selling_price ==> loss == cost_price - selling_price) && (cost_price <= selling_price ==> loss == 0),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  0\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "Clover_min_of_two_Min", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn min(x: int, y: int) -> (z: int)\n    ensures\n        x <= y ==> z == x,\n        x > y ==> z == y,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    x\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Software-Verification_tmp_tmpv4ueky2d_Remove Element_remove_element_remove_element", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn remove_element(nums: &mut Vec<i32>, val: i32) -> (i: usize)\n    requires \n        old(nums).len() <= 100,\n        forall|j: int| 0 <= j < old(nums).len() ==> #[trigger] old(nums)[j] >= 0 && old(nums)[j] <= 50,\n        0 <= val <= 100,\n    ensures\n        forall|j: int| 0 < j < i < nums.len() ==> #[trigger] nums[j] != val,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  0\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_809_IsSmaller", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn is_smaller(a: Seq<int>, b: Seq<int>) -> (result: bool)\n    requires \n        a.len() == b.len(),\n    ensures \n        result <==> forall|i: int| 0 <= i < a.len() ==> a[i] > b[i],\n        !result <==> exists|i: int| 0 <= i < a.len() && a[i] <= b[i],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    true\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Dafny_tmp_tmpj88zq5zt_2-Kontrakte_max_max", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn max(a: &[i32], b: &[i32], i: usize, j: usize) -> (m: i32)\n    requires \n        i < a.len(),\n        j < b.len(),\n    ensures \n        a[i as int] > b[j as int] ==> m == a[i as int],\n        a[i as int] <= b[j as int] ==> m == b[j as int],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0  // unreachable, but needed for type checking\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_602_FindFirstRepeatedChar", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn find_first_repeated_char(s: &str) -> (result: (bool, char))\n    ensures \n        (result.0 ==> exists|i: int, j: int| 0 <= i < j < s@.len() && s@[i] == s@[j] && s@[i] == result.1 && \n            (forall|k: int, l: int| 0 <= k < l < j && s@[k] == s@[l] ==> k >= i)) &&\n        (!result.0 ==> (forall|i: int, j: int| 0 <= i < j < s@.len() ==> s@[i] != s@[j]))\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    (false, 'a')\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "Dafny_tmp_tmpmvs2dmry_examples2_Product", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn gcd(m: nat, n: nat) -> nat\nrecommends m > 0 && n > 0\ndecreases m + n\n{\n    if m == n { \n        n \n    } else if m > n { \n        gcd(sub(m, n), n)\n    } else {\n        gcd(m, sub(n, m))\n    }\n}\n\nspec fn exp(x: real, n: nat) -> real\ndecreases n\n{\n    if n == 0 {\n        1.0\n    } else if x == 0.0 {\n        0.0\n    } else if n == 0 && x == 0.0 {\n        1.0\n    } else {\n        x * exp(x, sub(n, 1))\n    }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn Product(m: u64, n: u64) -> (res: u64)\nensures res == m * n\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  0\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula3_sumBackwards", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn fib(n: nat) -> nat \n    decreases n\n{\n    if n == 0 { \n        1 \n    } else if n == 1 { \n        1 \n    } else { \n        fib((n-1) as nat) + fib((n-2) as nat)\n    }\n}\n\n\n// 2.\nenum List<T> {\n    Nil,\n    Cons(T, Box<List<T>>)\n}\n\nspec fn add(l: List<int>) -> int \n    decreases l\n{\n    match l {\n        List::Nil => 0,\n        List::Cons(x, xs) => x + add(*xs)\n    }\n}\n\n\n// 3.\n\n// 5.\n\n// 6\nspec fn sum(n: nat) -> nat \n    decreases n\n{\n    if n == 0 { \n        0 \n    } else { \n        n + sum((n-1) as nat)\n    }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn sum_backwards(n: u32) -> (r: u32)\n    ensures r == sum(n as nat)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "assertive-programming-assignment-1_tmp_tmp3h_cj44u_FindRange_BinarySearch", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sorted(q: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i <= j < q.len() ==> q[i] <= q[j]\n}\n\n\n// all the values in the range satisfy `comparer` (comparer(q[i], key) == true)\nspec fn range_satisfies_comparer(q: Seq<int>, key: int, lower_bound: nat, upper_bound: nat, comparer: spec_fn(int, int) -> bool) -> bool\n    recommends 0 <= lower_bound <= upper_bound <= q.len()\n{\n    forall|i: int| lower_bound <= i < upper_bound ==> comparer(q[i], key)\n}\n\n// all the values in the range satisfy `!comparer` (comparer(q[i], key) == false)\nspec fn range_satisfies_comparer_negation(q: Seq<int>, key: int, lower_bound: nat, upper_bound: nat, comparer: spec_fn(int, int) -> bool) -> bool\n    recommends 0 <= lower_bound <= upper_bound <= q.len()\n{\n    range_satisfies_comparer(q, key, lower_bound, upper_bound, |n1, n2| !comparer(n1, n2))\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn binary_search(q: Seq<int>, key: int, lower_bound: usize, upper_bound: usize, comparer: spec_fn(int, int) -> bool) -> (index: usize)\n    requires\n        sorted(q),\n        0 <= lower_bound <= upper_bound <= q.len(),\n        range_satisfies_comparer_negation(q, key, lower_bound as nat, upper_bound as nat, comparer),\n        range_satisfies_comparer(q, key, upper_bound as nat, q.len() as nat, comparer),\n        // comparer is '>' or '>='\n        (forall|n1: int, n2: int| #[trigger] comparer(n1, n2) ==> comparer(n1, n2) == (n1 > n2)) ||\n        (forall|n1: int, n2: int| #[trigger] comparer(n1, n2) ==> comparer(n1, n2) == (n1 >= n2)),\n\n    ensures\n        lower_bound <= index <= upper_bound,\n        range_satisfies_comparer_negation(q, key, 0nat, index as nat, comparer),\n        range_satisfies_comparer(q, key, index as nat, q.len() as nat, comparer),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  0\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_handout1_queryFast", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// 1 a)\n\n// [ai, aj[\nspec fn sum(a: Seq<int>, i: int, j: int) -> int\n    recommends 0 <= i <= j <= a.len()\n    decreases j - i\n    when 0 <= i <= j <= a.len()\n{\n    if i == j { 0 }\n    else { a[j-1] + sum(a, i, j-1) }\n}\n\n// 1 b)\n\n// 1 c)\n// a -> [1, 10, 3, −4, 5]\n// c -> [0, 1, 11, 14, 10, 15]\n\nspec fn is_prefix_sum_for(a: Seq<int>, c: Seq<int>) -> bool\n{\n    a.len() + 1 == c.len() && \n    forall|i: int| #![auto] 0 <= i <= a.len() ==> c[i] == sum(a, 0, i)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nproof fn queryFast(a: Seq<int>, c: Seq<int>, i: int, j: int) -> (r: int)\n    requires 0 <= i <= j <= a.len(),\n             is_prefix_sum_for(a, c)\n    ensures r == sum(a, i, j)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "Clover_triple2_Triple", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nproof fn triple(x: int) -> (r: int)\n  ensures r == 3 * x\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  3 * x\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n} // verus!"}
{"id": "llm-verified-eval_tmp_tmpd2deqn_i_dafny_5_intersperse", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nproof fn intersperse(numbers: Seq<int>, delimiter: int) -> (interspersed: Seq<int>)\n    ensures\n        interspersed.len() == if numbers.len() > 0 { 2 * numbers.len() - 1 } else { 0 },\n        forall|i: int| 0 <= i < interspersed.len() && i % 2 == 0 ==> \n            interspersed[i] == numbers[i / 2],\n        forall|i: int| 0 <= i < interspersed.len() && i % 2 == 1 ==>\n            interspersed[i] == delimiter,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    arbitrary()\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Insertion_Sorted_Standard_sorting", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn insertion_sorted(array: Seq<int>, left: int, right: int) -> bool\n    recommends 0 <= left <= right <= array.len()\n{\n    forall|i: int, j: int| left <= i < j < right ==> array[i] <= array[j]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn sorting(array: &mut Vec<int>)\n    requires old(array).len() > 1\n    ensures insertion_sorted(array@, 0, array@.len() as int)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "dafny_examples_tmp_tmp8qotd4ez_leetcode_0069-sqrt_mySqrt", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// Author: Shaobo He\n\nspec fn sqrt(x: int, r: int) -> bool {\n    r * r <= x && (r + 1) * (r + 1) > x\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\n#[verifier::exec_allows_no_decreases_clause]\nfn mySqrt(x: int) -> (res: int)\n    requires 0 <= x,\n    ensures sqrt(x, res),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    loop { }\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "Dafny_Verify_tmp_tmphq7j0row_Generated_Code_Count_count", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn has_count(v: int, a: Seq<int>, n: nat) -> int\n    decreases n\n{\n    if n == 0 {\n        0\n    } else {\n        if a[n-1] == v {\n            has_count(v, a, (n-1) as nat) + 1\n        } else {\n            has_count(v, a, (n-1) as nat)\n        }\n    }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn count(v: i32, a: &[i32], n: usize) -> (r: i32)\n    requires n <= a.len()\n    ensures n <= a.len() ==> has_count(v as int, a@.map_values(|x: i32| x as int), n as nat) == r as int\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "dafl_tmp_tmp_r3_8w3y_dafny_examples_uiowa_fibonacci_ComputeFib", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/*\n   CS:5810 Formal Methods in Software Engineering\n   Fall 2017\n   The University of Iowa\n\n   Instructor: Cesare Tinelli\n\n   Credits: Example adapted from Dafny tutorial\n*/\n\n\n//      n = 0, 1, 2, 3, 4, 5, 6,  7,  8, ...\n// fib(n) = 0, 1, 1, 2, 3, 5, 8, 13, 21, ...\nspec fn fib(n: nat) -> nat\n    decreases n\n{\n    if n == 0 { 0 }\n    else if n == 1 { 1 }\n    else { fib((n - 1) as nat) + fib((n - 2) as nat) }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn ComputeFib(n: usize) -> (f: usize)\n    ensures f == fib(n as nat)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Quick_Sort_quickSort", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn quick_sorted(seq: Seq<int>) -> bool {\n    forall|idx_1: int, idx_2: int| 0 <= idx_1 < idx_2 < seq.len() ==> seq[idx_1] <= seq[idx_2]\n}\n\n#[verifier::exec_allows_no_decreases_clause]\nfn threshold(thres: int, seq: Seq<int>) -> (res: (Seq<int>, Seq<int>))\n    ensures\n        (forall|x: int| res.0.contains(x) ==> x <= thres) && (forall|x: int| res.1.contains(x) ==> x >= thres) &&\n        res.0.len() + res.1.len() == seq.len() &&\n        res.0.to_multiset().add(res.1.to_multiset()) == seq.to_multiset()\n{\n    assume(false);\n    loop {}\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn quick_sort(seq: Seq<int>) -> (res: Seq<int>)\n    ensures seq.to_multiset() == res.to_multiset()\n    decreases seq.len()\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    seq\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Dafny_Learning_Experience_tmp_tmpuxvcet_u_week8_12_a3_search_findPositionOfIndex_FindPositionOfElement", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn find_position_of_element(a: &[i32], element: usize, n1: usize, s1: Seq<i32>) -> (result: (i32, usize))\n    requires\n        n1 == s1.len() && 0 <= n1 <= a.len(),\n        forall|i: int| 0 <= i < s1.len() ==> a[i] == s1[i],\n    ensures\n        result.0 == -1 || result.0 >= 1,\n        s1.len() != 0 && result.0 >= 1 ==> exists|i: int| 0 <= i < s1.len() && s1[i] == element,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    (0, 0)\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "vfag_tmp_tmpc29dxm1j_sumar_componentes_suma_componentes", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn suma_aux(V: &[i32], n: int) -> int\n    decreases V.len() - n\n    when 0 <= n <= V.len()\n{\n    if n == V.len() {\n        0\n    } else {\n        V[n as int] + suma_aux(V, n + 1)\n    }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn suma_componentes(V: &[i32]) -> (suma: i32)\n    ensures suma == suma_aux(V, 0)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "dafny-duck_tmp_tmplawbgxjo_p4_single", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n//Given two arrays of integers, it returns a single array with all integers merged. \n// [1,5,2,3],[4,3,5]->[1,5,2,3,4,3,5]", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn single(x: &[i32], y: &[i32]) -> (b: Vec<i32>)\n    requires \n        x.len() > 0,\n        y.len() > 0,\n    ensures \n        b@.len() == x@.len() + y@.len(),\n        b@ == x@ + y@,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_598_IsArmstrong", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn is_armstrong(n: int) -> (result: bool)\n    requires 100 <= n < 1000\n    ensures result <==> (n == ((n / 100) * (n / 100) * (n / 100) + ((n / 10) % 10) * ((n / 10) % 10) * ((n / 10) % 10) + (n % 10) * (n % 10) * (n % 10)))\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    true\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Selection_Sort_Standard_selectionSorted", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn selection_sorted(array: &mut Vec<i32>) \n    ensures array@.to_multiset() == old(array)@.to_multiset()\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_leetcode_validAnagram_isAnagram", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\nuse vstd::multiset::*;\n\nverus! {\n\nproof fn to_multiset(s: &str) -> (mset: Multiset<char>)\n    ensures mset == s@.to_multiset()\n{\n    assume(false);\n    s@.to_multiset()\n}\n\nproof fn mset_equal(s: Multiset<char>, t: Multiset<char>) -> (equal: bool)\n    ensures s == t <==> equal\n{\n    assume(false);\n    true\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn is_anagram(s: &str, t: &str) -> (equal: bool)\n    ensures (s@.to_multiset() == t@.to_multiset()) == equal\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    true\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Prog-Fun-Solutions_tmp_tmp7_gmnz5f_extra_mod2_mod2", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn f2(n: nat) -> nat \n    decreases n\n{\n    if n == 0 { 0 }\n    else { 5 * f2(n / 3) + n % 4 }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn mod2(n: u32) -> (a: u32)\n    ensures a == f2(n as nat)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Clover_cal_sum_Sum", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn sum(n: u32) -> (s: u32)\n    requires n >= 0\n    ensures s == n * (n + 1) / 2\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "CS494-final-project_tmp_tmp7nof55uq_bubblesort_BubbleSort", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n//Bubblesort CS 494 submission\n//References: https://stackoverflow.com/questions/69364687/how-to-prove-time-complexity-of-bubble-sort-using-dafny/69365785#69365785\n\n\n// predicate checks if elements of a are in ascending order, two additional conditions are added to allow us to sort in specific range within array\n\nspec fn sorted(a: &Vec<i32>, from: usize, to: usize) -> bool\n    recommends \n        from <= to,\n        to <= a.len(),\n{\n    forall|x: usize, y: usize| from <= x < y < to ==> a[x as int] <= a[y as int]\n}\n\n//helps ensure swapping is valid, it is used inside the nested while loop to make sure linear order is being kept \nspec fn pivot(a: &Vec<i32>, to: usize, pvt: usize) -> bool\n    recommends\n        pvt < to,\n        to <= a.len(),\n{\n    forall|x: usize, y: usize| 0 <= x < pvt < y < to ==> a[x as int] <= a[y as int] // all values within the array should be in ascending order\n}\n\n// Here having the algorithm for the bubblesort", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn BubbleSort(a: &mut Vec<i32>)\n    requires \n        old(a).len() > 0, // makes sure a is not empty and length is greater than 0\n    ensures \n        sorted(a, 0, a.len()), // makes sure elements of array a are sorted from 0 - a.len()\n        a@.to_multiset() == old(a)@.to_multiset(), // Since a is being modified, we compare the previous elements to current elements.\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBinarySearch_binarySearch", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sorted(s: Seq<int>) -> bool {\n    forall|u: int, w: int| 0 <= u < w < s.len() ==> s[u] <= s[w]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn binary_search(v: &Vec<i32>, elem: i32) -> (p: i32)\n    requires sorted(v@.map_values(|val: i32| val as int)),\n    ensures ({\n        &&& -1 <= p < v.len()\n        &&& forall|u: int| 0 <= u <= p ==> v@[u] <= elem as int\n        &&& forall|w: int| p < w < v.len() ==> v@[w] > elem as int\n    }),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "//Recursive binary search\n\nfn main() {}\n\n}"}
{"id": "Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 8_H8_Partition", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\nuse vstd::multiset::Multiset;\n\nverus! {\n    // Höfundur spurningar:  Snorri Agnarsson, snorri@hi.is\n    // Permalink spurningar: https://rise4fun.com/Dafny/GW7a\n    \n    // Höfundur lausnar:     Alexander Guðmundsson\n    // Permalink lausnar:    https://www.rise4fun.com/Dafny/JPGct\n    \n    // Klárið að forrita föllin tvö.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn partition(Ghost(m): Ghost<Multiset<int>>) -> (res: (Ghost<Multiset<int>>, Ghost<int>, Ghost<Multiset<int>>))\n    requires m.len() > 0\n    ensures ({\n        let (Ghost(pre), Ghost(p), Ghost(post)) = res;\n        &&& m.contains(p)\n        &&& m == pre.add(Multiset::singleton(p)).add(post)\n        &&& forall|z: int| pre.contains(z) ==> z <= p\n        &&& forall|z: int| post.contains(z) ==> z >= p\n    })\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    (Ghost(Multiset::empty()), Ghost(0), Ghost(Multiset::empty()))\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "dafny-exercises_tmp_tmp5mvrowrx_leetcode_26-remove-duplicates-from-sorted-array_RemoveDuplicates", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn remove_duplicates(nums: &mut Vec<i32>) -> (num_length: usize)\n    requires\n        forall|i: int, j: int| 0 <= i < j < old(nums).len() ==> old(nums)[i] <= old(nums)[j],\n    ensures\n        nums.len() == old(nums).len(),\n        0 <= num_length <= nums.len(),\n        forall|i: int, j: int| 0 <= i < j < num_length ==> nums[i] != nums[j],\n        forall|i: int| 0 <= i < num_length ==> old(nums)@.contains(nums[i]),\n        forall|i: int| 0 <= i < old(nums).len() ==> nums@.subrange(0, num_length as int).contains(old(nums)[i]),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_572_RemoveDuplicates", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn remove_duplicates(a: &[i32]) -> (result: Vec<i32>)\n    ensures\n        forall|x: i32| result@.contains(x) <==> exists|i: int| 0 <= i < a.len() && a[i] == x,\n        forall|i: int, j: int| 0 <= i < j < result.len() ==> result@[i] != result@[j]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "dafny_examples_tmp_tmp8qotd4ez_test_shuffle_getRandomDataEntry", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nfn random(a: int, b: int) -> (r: int)\n    ensures a <= b ==> a <= r <= b\n{\n    assume(false);\n    a\n}\n\nspec fn set_of_seq<T>(s: Seq<T>) -> Set<T> {\n    s.to_set()\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn get_random_data_entry<T: PartialEq + Clone>(m_work_list: &Vec<T>, avoid_set: &Vec<T>) -> (e: T)\n    requires m_work_list.len() > 0\n    ensures \n        set_of_seq(avoid_set@).subset_of(set_of_seq(m_work_list@)) && \n        set_of_seq(avoid_set@) != set_of_seq(m_work_list@) ==> !avoid_set@.contains(e),\n        (forall |x: T| avoid_set@.contains(x) ==> m_work_list@.contains(x)) && \n        avoid_set@ != m_work_list@ ==> m_work_list@.contains(e)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    m_work_list[0].clone()\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafleet_tmp_tmpa2e4kb9v_0001-0050_0005-longest-palindromic-substring_longestPalindrome", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* https://leetcode.com/problems/longest-palindromic-substring/\nGiven a string s, return the longest palindromic substring in s.\n\nExample 1:\nInput: s = \"babad\"\nOutput: \"bab\"\nExplanation: \"aba\" is also a valid answer.\n*/\n\n\n// Specifying the problem: whether `s[i..j]` is palindromic\nspec fn palindromic(s: Seq<char>, i: int, j: int) -> bool\n    recommends 0 <= i <= j <= s.len()\n    decreases j - i\n{\n    j - i < 2 || (s[i] == s[j-1] && palindromic(s, i+1, j-1))\n}\n\n// A \"common sense\" about palindromes:\n\n// A useful \"helper function\" that returns the longest palindrome at a given center (i0, j0).\nfn expand_from_center(s: Seq<char>, i0: usize, j0: usize) -> (res: (usize, usize))\n    requires \n        0 <= i0 <= j0 <= s.len(),\n        palindromic(s, i0 as int, j0 as int),\n    ensures \n        res.0 <= res.1 <= s.len(),\n        palindromic(s, res.0 as int, res.1 as int),\n        forall|i: int, j: int| 0 <= i <= j <= s.len() && palindromic(s, i, j)  \n            && i + j == i0 + j0 ==> j - i <= res.1 - res.0,\n{\n    assume(false);\n    (0, 0)\n}\n\n\n// The main algorithm.\n// We traverse all centers from left to right, and \"expand\" each of them, to find the longest palindrome.\n\n/* Discussions\n1. Dafny is super bad at slicing (esp. nested slicing).\n  Do circumvent it whenever possible. It can save you a lot of assertions & lemmas!\n\n  For example, instead of `palindromic(s[i..j])`, use the pattern `palindromic(s, i, j)` instead.\n  I didn't realize this (ref: https://github.com/Nangos/dafleet/commit/3302ddd7642240ff2b2f6a8c51e8becd5c9b6437),\n  Resulting in a couple of clumsy lemmas.\n\n2. Bonus -- Manacher's algorithm\n  Our above solution needs `O(|s|^2)` time in the worst case. Can we improve it? Yes.\n\n  Manacher's algorithm guarantees an `O(|s|)` time.\n  To get the intuition, ask yourself: when will it really take `O(|s|^2)` time?\n  When there are a lot of \"nesting and overlapping\" palindromes. like in `abcbcbcba` or even `aaaaaa`.\n\n  Imagine each palindrome as a \"mirror\". \"Large mirrors\" reflect \"small mirrors\".\n  Therefore, when we \"expand\" from some \"center\", we can \"reuse\" some information from its \"mirrored center\".\n  For example, we move the \"center\", from left to right, in the string `aiaOaia...`\n  Here, the char `O` is the \"large mirror\".\n  When the current center is the second `i`, it is \"mirrored\" to the first `i` (which we've calculated for),\n  so we know the palindrome centered at the second `i` must have at least a length of 3 (`aia`).\n  So we can expand directly from `aia`, instead of expanding from scratch.\n\n  Manacher's algorithm is verified below.\n  Also, I will verify that \"every loop is entered for only `O(|s|)` times\",\n  which \"indirectly\" proves that the entire algorithm runs in `O(|s|)` time.\n*/\n\n\n// A reference implementation of Manacher's algorithm:\n// (Ref. https://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher's_algorithm) for details...\n\n\n// Below are helper functions and lemmas we used:\n\n// Inserts bogus characters to the original string (e.g. from `abc` to `|a|b|c|`).\n// Note that this is neither efficient nor necessary in reality, but just for the ease of understanding.\nspec fn insert_bogus_chars(s: Seq<char>, bogus: char) -> (s_prime: Seq<char>)\n    decreases s.len()\n{\n    if s.len() == 0 {\n        seq![bogus]\n    } else {\n        let s_prime_old = insert_bogus_chars(s.subrange(1, s.len() as int), bogus);\n        let s_prime_new = seq![bogus].add(seq![s[0]]).add(s_prime_old);\n        s_prime_new\n    }\n}\n\n// Returns (max_index, max_value) of array `a` starting from index `start`.\nfn argmax(a: &Vec<i32>, start: usize) -> (res: (usize, i32))\n    requires 0 <= start < a.len()\n    ensures \n        start <= res.0 < a.len() && a[res.0 as int] == res.1,\n        forall|i: int| start <= i < a.len() ==> a[i] <= res.1,\n    decreases a.len() - start\n{\n    if start == a.len() - 1 {\n        (start, a[start])\n    } else {\n        let (i, v) = argmax(a, start + 1);\n        if a[start] >= v { (start, a[start]) } else { (i, v) }\n    }\n}\n\n// Whether an interval at center `c` with a radius `r` is within the boundary of `s'`.\nspec fn inbound_radius(s_prime: Seq<char>, c: int, r: int) -> bool\n{\n    r >= 0 && 0 <= c-r && c+r < s_prime.len()\n}\n\n// Whether `r` is a valid palindromic radius at center `c`.\nspec fn palindromic_radius(s_prime: Seq<char>, c: int, r: int) -> bool\n    recommends inbound_radius(s_prime, c, r)\n{\n    palindromic(s_prime, c-r, c+r+1)\n}\n\n// Whether `r` is the maximal palindromic radius at center `c`.\nspec fn max_radius(s_prime: Seq<char>, c: int, r: int) -> bool\n{\n    inbound_radius(s_prime, c, r)\n    && palindromic_radius(s_prime, c, r)\n    && (forall|r_prime: int| r_prime > r && inbound_radius(s_prime, c, r_prime) ==> !palindromic_radius(s_prime, c, r_prime))\n}\n\n// Basically, just \"rephrasing\" the `lemma_palindromic_contains`,\n// talking about center and radius, instead of interval\n\n// When \"expand from center\" ends, we've find the max radius:\n\n// The critical insight behind Manacher's algorithm.\n//\n// Given the longest palindrome centered at `c` has length `r`, consider the interval from `c-r` to `c+r`.\n// Consider a pair of centers in the interval: `c1` (left half) and `c2` (right half), equally away from `c`.\n// Then, the length of longest palindromes at `c1` and `c2` are related as follows:\n//, where:\nspec fn abs(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\n// Transfering our final result on `s'` to that on `s`:\n\n// The following returns whether `s[lo..hi]` is the longest palindrome s.t. `lo + hi == k`:\nspec fn max_interval_for_same_center(s: Seq<char>, k: int, lo: int, hi: int) -> bool {\n    0 <= lo <= hi <= s.len()\n    && lo + hi == k\n    && palindromic(s, lo, hi)\n    && (forall|i: int, j: int| 0 <= i <= j <= s.len() && palindromic(s, i, j) && i + j == k ==> j - i <= hi - lo)\n}\n\n// Establishes the \"palindromic isomorphism\" between `s` and `s'`.\n\n// Implies that whenever `c + r` is odd, the corresponding palindrome can be \"lengthened for free\"\n// because its both ends are the bogus char.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn longestPalindrome(s: Vec<char>) -> (ans: (Vec<char>, usize, usize))\n    ensures \n        0 <= ans.1 <= ans.2 <= s.len(),\n        ans.0@ == s@.subrange(ans.1 as int, ans.2 as int),  // `ans` is indeed a substring in `s`\n        palindromic(s@, ans.1 as int, ans.2 as int),  // `ans` is palindromic\n        forall|i: int, j: int| 0 <= i <= j <= s.len() && palindromic(s@, i, j) ==> j - i <= ans.2 - ans.1,  // `ans` is longest\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    let result_vec = Vec::<char>::new();\n    (result_vec, 0, 0)\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "Formal-Verification-Project_tmp_tmp9gmwsmyp_strings3_maxCommonSubstringLength", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_substring(sub: Seq<char>, str: Seq<char>) -> bool\n{\n    exists|i: int| 0 <= i <= str.len() - sub.len() && str.subrange(i, i + sub.len()) == sub\n}\n\nspec fn is_prefix_pred(pre: Seq<char>, str: Seq<char>) -> bool\n{\n    pre.len() <= str.len() && pre == str.subrange(0, pre.len() as int)\n}\n\nspec fn is_not_prefix_pred(pre: Seq<char>, str: Seq<char>) -> bool\n{\n    pre.len() > str.len() || pre != str.subrange(0, pre.len() as int)\n}\n\nspec fn is_substring_pred(sub: Seq<char>, str: Seq<char>) -> bool\n{\n    exists|i: int| 0 <= i <= str.len() && is_prefix_pred(sub, str.subrange(i, str.len() as int))\n}\n\nspec fn is_not_substring_pred(sub: Seq<char>, str: Seq<char>) -> bool\n{\n    forall|i: int| 0 <= i <= str.len() ==> is_not_prefix_pred(sub, str.subrange(i, str.len() as int))\n}\n\nspec fn have_common_k_substring_pred(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool\n{\n    exists|i1: int, j1: int| 0 <= i1 <= str1.len() - k && j1 == i1 + k && is_substring_pred(str1.subrange(i1, j1), str2)\n}\n\nspec fn have_not_common_k_substring_pred(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool\n{\n    forall|i1: int, j1: int| 0 <= i1 <= str1.len() - k && j1 == i1 + k ==> is_not_substring_pred(str1.subrange(i1, j1), str2)\n}\n\nfn have_common_k_substring(k: usize, str1: &Vec<char>, str2: &Vec<char>) -> (found: bool)\n    ensures found <==> have_common_k_substring_pred(k as nat, str1@, str2@)\n{\n    // Check that both strings are larger than k\n    if k > str1.len() || k > str2.len() {\n        return false;\n    }\n    // Initialize variables\n    let mut i: usize = 0;\n    let mut temp = false;\n\n    // Don't want to exceed the bounds of str1 when checking for the element that is k entries away\n    while i <= str1.len() - k\n        invariant \n            // Invariant to stay within bounds\n            0 <= i <= (str1.len() - k) + 1,\n            // Invariant to show that when temp is true, it is a substring\n            temp ==> 0 <= i <= (str1.len() - k) && is_substring_pred(str1@.subrange(i as int, (i + k) as int), str2@),\n            // Invariant to show that when temp is false, it is not a substring\n            !temp ==> (forall|m: int, n: int| (0 <= m < i && n == m + (k as int)) ==> is_not_substring_pred(str1@.subrange(m, n), str2@)),\n        // Telling Verus that i is the value that is increasing\n        decreases str1.len() - k - i\n    {\n        assume(false);\n\n        // Get an index from the array position we are at to the array position that is k away and check the substring\n        proof {\n            let ghost_i = i as int;\n            let ghost_k = k as int;\n            let substr = str1@.subrange(ghost_i, ghost_i + ghost_k);\n            temp = is_substring(substr, str2@);\n        }\n        if temp == true {\n            return true;\n        }\n        i = i + 1;\n    }\n    false\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn max_common_substring_length(str1: &Vec<char>, str2: &Vec<char>) -> (len: usize)\n    requires str1.len() <= str2.len()\n    ensures \n        forall|k: int| len < k <= str1.len() ==> !have_common_k_substring_pred(k as nat, str1@, str2@),\n        have_common_k_substring_pred(len as nat, str1@, str2@)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_IntDiv", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// ASSIGNMENT P1\n// CMSC 433 FALL 2023\n// PERFECT SCORE:  100 POINTS\n//\n// This assignment contains nine questions, each of which involves writing Verus\n// code. You should include your solutions in a single Verus file and submit it using\n// Gradescope.\n//\n// Revision history\n//\n// 2023-09-22 2:50 pm   Fixed typo in Problem 3.\n\n\n// Question 1 (5 points)\n//\n// Fill in a requires clause that enables Verus to verify\n// method PlusOne\n\n\n\n// Question 2 (5 points)\n//\n// Fill in requires clause(s) that enable(s) Verus to verify the array bounds\n// in method Swap (which swaps elements i and j in array a).\n\n\n// Question 3 (5 points)\n//\n// Give ensures clause(s) asserting that d is the result, and r the\n// remainder, of dividing m by n.  Your clauses cannot use \"/\" or \"%\" (which are\n// the Verus division and mod operators, respectively). By definition, the\n// remainder must be non-negative.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn IntDiv(m: int, n: int) -> (ret: (int, int))\n    requires n > 0\n    ensures m == n * ret.0 + ret.1 && 0 <= ret.1 < n // TODO\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  (0, 0)\n}\n// </vc-code>", "vc-postamble": "// Question 4 (5 points)\n//\n// Give ensures clause(s) asserting that the return value has the same\n// length as array a and contains as its elements the sum of the\n// corresponding elements in arrays a and b.\n\n\n// Question 5 (10 points)\n\n// Euclid's algorithm is used to compute the greatest common divisor of two\n// positive integers.  If m and n are two such integers, then gcd(m,n) is the\n// largest positve integer that evenly divides both m and n, where j evenly divides i\n// if and only if i % j == 0 (% is the Verus mod operator).  Write requires and\n// ensures clauses for the method header Euclid below.  Your requires clauses\n// should also specify that the first argument is at least as large as the second.\n// You do *not* need to implement the method!\n\n\n// Question 7 (20 points)\n//\n// Implement, and have Verus verify, the method IsPrime below, which returns true\n// if and only if the given positive integer is prime.\n\n\n// Question 8 (20 points)\n//\n// Implement, and have Verus verify, the method Reverse below, which returns a new array\n// aRev consisting of the elements of a, but in reverse order.  To create a new \n// array of ints use the Verus command \"Vec::new()\", where you can build the vector\n// with the desired elements.\n\n\n// Question 9 (20 points)\n//\n// Implement and verify method NoDups, which returns true if and only if there\n// are no duplicate elements in array a.  Note that the requires clause allows\n// you to assume that a is sorted, and that this precondition is necessary for\n// the ensures clause to imply a lack of duplicates.\n\nfn main() {}\n\n}"}
{"id": "cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_Euclid", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// ASSIGNMENT P1\n// CMSC 433 FALL 2023\n// PERFECT SCORE:  100 POINTS\n//\n// This assignment contains nine questions, each of which involves writing Verus\n// code. You should include your solutions in a single Verus file and submit it using\n// Gradescope.\n//\n// Revision history\n//\n// 2023-09-22 2:50 pm   Fixed typo in Problem 3.\n\n\n// Question 1 (5 points)\n//\n// Fill in a requires clause that enables Verus to verify\n// method PlusOne\n\n\n\n// Question 2 (5 points)\n//\n// Fill in requires clause(s) that enable(s) Verus to verify the array bounds\n// in method Swap (which swaps elements i and j in array a).\n\n\n// Question 3 (5 points)\n//\n// Give ensures clause(s) asserting that d is the result, and r the\n// remainder, of dividing m by n.  Your clauses cannot use \"/\" or \"%\" (which are\n// the Verus division and mod operators, respectively). By definition, the\n// remainder must be non-negative.\n\n\n// Question 4 (5 points)\n//\n// Give ensures clause(s) asserting that the return value has the same\n// length as array a and contains as its elements the sum of the\n// corresponding elements in arrays a and b.\n\n\n// Question 5 (10 points)\n\n// Euclid's algorithm is used to compute the greatest common divisor of two\n// positive integers.  If m and n are two such integers, then gcd(m,n) is the\n// largest positve integer that evenly divides both m and n, where j evenly divides i\n// if and only if i % j == 0 (% is the Verus mod operator).  Write requires and\n// ensures clauses for the method header Euclid below.  Your requires clauses\n// should also specify that the first argument is at least as large as the second.\n// You do *not* need to implement the method!", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn euclid(m: int, n: int) -> (gcd: int)\n    requires m > 1 && n > 1 && m >= n  // TODO\n    ensures gcd > 0 && gcd <= n && gcd <= m && m % gcd == 0 && n % gcd == 0 // TODO\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  n\n}\n// </vc-code>", "vc-postamble": "// Question 7 (20 points)\n//\n// Implement, and have Verus verify, the method IsPrime below, which returns true\n// if and only if the given positive integer is prime.\n\n\n// Question 8 (20 points)\n//\n// Implement, and have Verus verify, the method Reverse below, which returns a new array\n// aRev consisting of the elements of a, but in reverse order.  To create a new \n// array of ints use the Verus command \"Vec::with_capacity(...)\", where \"...\" is the number\n// of elements in the array.\n\n\n// Question 9 (20 points)\n//\n// Implement and verify method NoDups, which returns true if and only if there\n// are no duplicate elements in array a.  Note that the requires clause allows\n// you to assume that a is sorted, and that this precondition is necessary for\n// the ensures clause to imply a lack of duplicates.\n\nfn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_273_SubtractSequences", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn subtract_sequences(a: Seq<int>, b: Seq<int>) -> (result: Seq<int>)\n    requires \n        a.len() == b.len(),\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] - b[i],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    proof {\n        assert(false);\n    }\n    a\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "dafny_examples_tmp_tmp8qotd4ez_test_shuffle_swap", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn set_of_seq<T>(s: Seq<T>) -> Set<T> {\n    Set::new(|x: T| s.contains(x))\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn swap<T>(a: &mut Vec<T>, i: usize, j: usize)\n    requires \n        i < old(a).len(),\n        j < old(a).len(),\n    ensures\n        a[i as int] == old(a)[j as int],\n        a[j as int] == old(a)[i as int],\n        forall|m: int| 0 <= m < a.len() && m != i && m != j ==> a[m] == old(a)[m],\n        a@.to_multiset() == old(a)@.to_multiset(),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_251_InsertBeforeEach", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\n#[verifier::exec_allows_no_decreases_clause]\nfn insert_before_each(s: Seq<String>, x: String) -> (v: Seq<String>)\n    ensures\n        v.len() == 2 * s.len(),\n        forall|i: int| 0 <= i < s.len() ==> v[2*i] == x && v[2*i + 1] == s[i],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    loop {}\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_644_ReverseUptoK", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\nspec fn array_index(v: Seq<i32>, i: int) -> i32 {\n    v[i]\n}\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn reverse_upto_k(s: &mut Vec<i32>, k: usize)\n    requires \n        2 <= k,\n        k <= old(s).len(),\n    ensures \n        s.len() == old(s).len(),\n        forall|i: int| 0 <= i < k ==> array_index(s@, i) == array_index(old(s)@, k - 1 - i),\n        forall|i: int| k <= i < s.len() ==> array_index(s@, i) == array_index(old(s)@, i),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "Dafny_tmp_tmpv_d3qi10_2_min_minArray", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn min(a: int, b: int) -> int \n{\n    if a < b { a } else { b }\n}\n\nspec fn min_function(a: int, b: int) -> int \n{\n    if a < b { a } else { b }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn min_array(a: &Vec<i32>) -> (m: i32)\n    requires a.len() > 0\n    ensures forall|k: int| 0 <= k < a.len() ==> m <= a[k]\n    ensures exists|k: int| 0 <= k < a.len() && m == a[k]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  0\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "llm-verified-eval_tmp_tmpd2deqn_i_dafny_3_below_zero", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sum(s: Seq<int>, n: nat) -> int\n    recommends n <= s.len()\n    decreases n\n{\n    if s.len() == 0 || n == 0 {\n        0\n    } else {\n        s[0] + sum(s.subrange(1, s.len() as int), (n - 1) as nat)\n    }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn below_zero(ops: Seq<int>) -> (result: bool)\n    ensures result <==> exists|n: nat| n <= ops.len() && sum(ops, n) < 0\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  false\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_261_ElementWiseDivision", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn element_wise_division(a: Seq<int>, b: Seq<int>) -> (result: Seq<int>)\n    requires\n        a.len() == b.len(),\n        forall|i: int| 0 <= i < b.len() ==> b[i] != 0,\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] / b[i],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    proof { assume(false); }\n    unreached()\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "AssertivePrograming_tmp_tmpwf43uz0e_Find_Substring_FindFirstOccurrence", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// Noa Leron 207131871\n// Tsuri Farhana 315016907\n\nspec fn is_prefix(prefix: Seq<char>, full: Seq<char>) -> bool {\n    prefix.len() <= full.len() &&\n    forall|k: int| 0 <= k < prefix.len() ==> prefix[k] == full[k]\n}\n\nspec fn exists_substring(str1: Seq<char>, str2: Seq<char>) -> bool {\n    exists|offset: int| 0 <= offset <= str1.len() - str2.len() &&\n        is_prefix(str2, str1.subrange(offset, str1.len() as int))\n}\n\nspec fn post(str1: Seq<char>, str2: Seq<char>, found: bool, i: nat) -> bool {\n    (found <==> exists_substring(str1, str2)) &&\n    (found ==> i + str2.len() <= str1.len() && \n        is_prefix(str2, str1.subrange(i as int, str1.len() as int)))\n}\n\n/*\nGoal: Verify correctness of the following code. Once done, remove the {:verify false} (or turn it into {:verify true}).\n\nFeel free to add GHOST code, including calls to lemmas. But DO NOT modify the specification or the original (executable) code.\n*/\n\n//this is our lemmas, invatiants and presicats\n\nspec fn outter_inv_correctness(str1: Seq<char>, str2: Seq<char>, found: bool, i: nat) -> bool {\n    (found ==> (i + str2.len() <= str1.len() && \n        is_prefix(str2, str1.subrange(i as int, str1.len() as int)))) && // Second part of post condition\n    (!found && 0 < i <= str1.len() && i != str2.len() - 1 ==> \n        !(exists_substring(str1.subrange(0, i as int), str2))) && // First part of post condition\n    (!found ==> i <= str1.len())\n}\n\nspec fn inner_inv_correctness(str1: Seq<char>, str2: Seq<char>, i: nat, j: int, found: bool) -> bool {\n    0 <= j <= i && // index in range\n    j < str2.len() && // index in range\n    i < str1.len() && // index in range\n    (str1[i as int] == str2[j] ==> \n        is_prefix(str2.subrange(j, str2.len() as int), str1.subrange(i as int, str1.len() as int))) &&\n    (found ==> j == 0 && str1[i as int] == str2[j])\n}\n\nspec fn inner_inv_termination(str1: Seq<char>, str2: Seq<char>, i: nat, j: int, old_i: nat, old_j: nat) -> bool {\n    old_j - j == old_i - old_i\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn find_first_occurrence(str1: Seq<char>, str2: Seq<char>) -> (result: (bool, usize))\n    ensures post(str1, str2, result.0, result.1 as nat)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  (false, 0)\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExercisePositive_mpositive", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn positive(s: Seq<int>) -> bool {\n    forall|u: int| 0 <= u < s.len() ==> s[u] >= 0\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn mpositive(v: &[int]) -> (b: bool)\n    ensures b == positive(v@)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    false\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "DafnyProjects_tmp_tmp2acw_s4s_longestPrefix_longestPrefix", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// MFES, Exam 8/Sept/20201, Exercise 5 \n\n// Computes the length (i) of the longest common prefix (initial subarray) \n// of two arrays a and b.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn longest_prefix(a: &[i32], b: &[i32]) -> (i: usize)\n    ensures \n        i <= a.len() && i <= b.len(),\n        a@.subrange(0, i as int) == b@.subrange(0, i as int),\n        i < a.len() && i < b.len() ==> a[i as int] != b[i as int]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {\n    // Test method with an example.\n}\n\n}"}
{"id": "dafny-synthesis_task_id_603_LucidNumbers", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn lucid_numbers(n: i32) -> (lucid: Vec<i32>)\n    requires \n        n >= 0,\n    ensures \n        forall|i: int| 0 <= i < lucid.len() ==> lucid[i] % 3 == 0,\n        forall|i: int| 0 <= i < lucid.len() ==> lucid[i] <= n,\n        forall|i: int, j: int| 0 <= i < j < lucid.len() ==> lucid[i] < lucid[j],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_610_RemoveElement", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn remove_element(s: &Vec<i32>, k: usize) -> (v: Vec<i32>)\n    requires \n        k < s.len(),\n    ensures\n        v.len() == s.len() - 1,\n        forall|i: int| 0 <= i < k ==> v[i] == s[i],\n        forall|i: int| k <= i < v.len() ==> v[i] == s[(i + 1) as int],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  Vec::new()\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n}"}
{"id": "dafny-synthesis_task_id_622_FindMedian", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn find_median(a: &[i32], b: &[i32]) -> (median: i32)\n    requires \n        a.len() == b.len(),\n        a.len() > 0,\n        forall|i: int| #[trigger] a[i] == a[i] ==> (0 <= i < (a.len() - 1) as int ==> a[i] <= a[add(i, 1)]),\n        forall|i: int| #[trigger] b[i] == b[i] ==> (0 <= i < (b.len() - 1) as int ==> b[i] <= b[add(i, 1)]),\n    ensures \n        median as int == if a.len() % 2 == 0 { \n            (a[(a.len() / 2 - 1) as int] + b[0int]) / 2 \n        } else { \n            a[(a.len() / 2) as int] as int\n        }\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0 // unreachable due to assume(false)\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "Simulink-To_dafny_tmp_tmpbcuesj2t_Tank_checkRegulation", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n#[derive(PartialEq, Eq)]\nenum Valve {\n    ON,\n    OFF,\n}\n\nstruct Pipe {\n    v1: Valve, // outlet valve \n    v2: Valve, // inlet Valve\n    v3: Valve, // outlet valve\n    in_flowv1: int, // flow in valve v1\n    in_flowv2: int, // flow in valve v2\n    in_flowv3: int, // flow in valve v3\n}\n\nimpl Pipe {\n    spec fn new() -> Self {\n        Pipe {\n            v1: Valve::OFF,\n            v2: Valve::ON,\n            v3: Valve::OFF,\n            in_flowv1: 0,\n            in_flowv2: 0,\n            in_flowv3: 0,\n        }\n    }\n}\n\nstruct Tank {\n    pipe: Pipe,\n    height: int,\n}\n\nimpl Tank {\n    spec fn new() -> Self {\n        Tank {\n            pipe: Pipe::new(),\n            height: 0,\n        }\n    }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn checkRegulation(tank: &mut Tank)\n    ensures \n        (tank.height > 10 && tank.pipe.v1 == Valve::OFF && tank.pipe.v3 == Valve::ON && tank.pipe.v2 == old(tank).pipe.v2) \n        || (tank.height < 8 && tank.pipe.v1 == Valve::OFF && tank.pipe.v2 == Valve::ON && tank.pipe.v3 == old(tank).pipe.v3)\n        || ((tank.pipe.in_flowv3 > 5 || tank.pipe.in_flowv1 > 5) && tank.pipe.v2 == Valve::OFF && tank.pipe.v3 == old(tank).pipe.v3 && tank.pipe.v1 == old(tank).pipe.v1)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_mathematical objects verification_examples_fast_exp_FastExp", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sum(s: Seq<int>, i: nat) -> int\n    recommends i <= s.len()\n    decreases i\n{\n    if i == 0 { 0 } else { sum(s, (i - 1) as nat) + s[i - 1] }\n}\n\nspec fn exp(b: nat, n: nat) -> nat\n    decreases n\n{\n    if n == 0 { 1nat } else { b * exp(b, (n - 1) as nat) }\n}\n\nspec fn bits(n: nat) -> Seq<bool>\n    decreases n\n{\n    if n == 0 {\n        seq![]\n    } else {\n        seq![n % 2 != 0].add(bits((n / 2) as nat))\n    }\n}\n\nspec fn from_bits(s: Seq<bool>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0nat\n    } else {\n        (if s[0] { 1nat } else { 0nat }) + 2nat * from_bits(s.subrange(1, s.len() as int))\n    }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn fast_exp(b: u32, n: u32) -> (r: u32)\n    ensures r == exp(b as nat, n as nat)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "t1_MF_tmp_tmpi_sqie4j_exemplos_colecoes_sequences_ex3_Delete", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// line contém uma string de tamanho l\n// remover p caracteres a partir da posição at", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn delete(line: &mut Vec<char>, l: usize, at: usize, p: usize)\n    requires\n        l <= old(line).len(),\n        at + p <= l,\n    ensures\n        line@ == old(line)@.subrange(0, at as int) + old(line)@.subrange((at + p) as int, l as int),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafny-duck_tmp_tmplawbgxjo_p1_SumArray", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// Given an array of integers, it returns the sum. [1,3,3,2]->9\n\nspec fn sum(xs: Seq<i32>) -> int\n    decreases xs.len()\n{\n    if xs.len() == 0 {\n        0int\n    } else {\n        sum(xs.subrange(0, xs.len() - 1)) + xs[xs.len() - 1] as int\n    }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn sum_array(xs: &[i32]) -> (s: i32)\n    ensures s as int == sum(xs@)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "Clover_find_Find", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn find(a: &[i32], key: i32) -> (index: i32)\n    ensures\n        -1 <= index < a.len() as i32,\n        index != -1 ==> a[index as int] == key && (forall|i: int| 0 <= i < index ==> a[i] != key),\n        index == -1 ==> (forall|i: int| 0 <= i < a.len() ==> a[i] != key),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    -1\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "dafny-language-server_tmp_tmpkir0kenl_Test_tutorial_maximum_Maximum", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// This file shows how to specify and implement a function to compute the\n// largest element of a list. The function is fully specified by two\n// preconditions, as proved by the MaximumIsUnique lemma below.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn maximum(values: Seq<int>) -> (max: int)\n    requires\n        values.len() > 0,\n    ensures\n        values.contains(max),\n        forall|i: int| 0 <= i < values.len() ==> values[i] <= max,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "dafny-exercise_tmp_tmpouftptir_countNeg_CountNeg", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn verify_neg(a: &[int], idx: int) -> nat\n    decreases idx\n{\n    if idx <= 0 {\n        0nat\n    } else {\n        verify_neg(a, idx - 1) + (if a[idx - 1] < 0 { 1nat } else { 0nat })\n    }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn count_neg(a: &[int]) -> (cnt: usize)\n    ensures cnt == verify_neg(a, a.len() as int)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "AssertivePrograming_tmp_tmpwf43uz0e_MergeSort_Merge", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// Noa Leron 207131871\n// Tsuri Farhana 315016907\n\n\n\n\nspec fn sorted(q: Seq<i32>) -> bool {\n    forall|i: int, j: int| 0 <= i <= j < q.len() ==> q[i] <= q[j]\n}\n\n/*\nGoal: Implement the well known merge sort algorithm in O(a.Length X log_2(a.Length)) time, recursively.\n\n- Divide the contents of the original array into two local arrays\n- After sorting the local arrays (recursively), merge the contents of the two returned arrays using the Merge method (see below)\n- DO NOT modify the specification or any other part of the method's signature\n- DO NOT introduce any further methods\n*/\n\nspec fn inv(a: Seq<i32>, a1: Seq<i32>, a2: Seq<i32>, i: usize, mid: usize) -> bool {\n    (i <= a1.len()) && (i <= a2.len()) && (i + mid <= a.len()) &&\n    (a1.subrange(0, i as int) == a.subrange(0, i as int)) && \n    (a2.subrange(0, i as int) == a.subrange(mid as int, (i + mid) as int))\n}\n\n\n/*\nGoal: Implement iteratively, correctly, efficiently, clearly\n\nDO NOT modify the specification or any other part of the method's signature\n*/\n\n//This is a method that replace the loop body\nfn merge_loop(b: &mut Vec<i32>, c: &Vec<i32>, d: &Vec<i32>, i0: usize, j0: usize) -> (usize, usize)\n        requires\n            old(b).len() == c.len() + d.len(),\n            sorted(c@),\n            sorted(d@),\n            i0 <= c.len(),\n            j0 <= d.len(),\n            i0 + j0 <= old(b).len(),\n            inv_sub_set(old(b)@, c@, d@, i0, j0),\n            inv_sorted(old(b)@, c@, d@, i0, j0),\n            i0 + j0 < old(b).len(),\n{\n    let mut i = i0;\n    let mut j = j0;\n\n    if i == c.len() || (j < d.len() && d[j] < c[i]) {\n        // in this case we take the next value from d\n        b.set(i + j, d[j]);\n        j = j + 1;\n    } else {\n        // in this case we take the next value from c\n        b.set(i + j, c[i]);\n        i = i + 1;\n    }\n\n    (i, j)\n}\n\n\n//Loop invariant - b is sorted so far and the next two potential values that will go into b are bigger than the biggest value in b.\nspec fn inv_sorted(b: Seq<i32>, c: Seq<i32>, d: Seq<i32>, i: usize, j: usize) -> bool {\n    i <= c.len() && j <= d.len() && i + j <= b.len() &&\n    ((i + j > 0 && i < c.len()) ==> (b[j + i - 1] <= c[i as int])) &&\n    ((i + j > 0 && j < d.len()) ==> (b[j + i - 1] <= d[j as int])) &&\n    sorted(b.subrange(0, (i + j) as int))\n}\n\n\n//Loop invariant - the multiset of the prefix of b so far is the same multiset as the prefixes of c and d so far.\nspec fn inv_sub_set(b: Seq<i32>, c: Seq<i32>, d: Seq<i32>, i: usize, j: usize) -> bool {\n    i <= c.len() && j <= d.len() && i + j <= b.len() &&\n    b.subrange(0, (i + j) as int).to_multiset() == \n        c.subrange(0, i as int).to_multiset().add(d.subrange(0, j as int).to_multiset())\n}\n\n//This lemma helps Verus see that if the prefixes of arrays are the same multiset until the end of the arrays,\n//all the arrays are the same multiset.\n\n\n//This lemma helps Verus see that after adding the next value from c to b the prefixes are still the same subsets.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn merge(b: &mut Vec<i32>, c: &Vec<i32>, d: &Vec<i32>)\n    requires\n        old(b).len() == c.len() + d.len(),\n        sorted(c@),\n        sorted(d@),\n    ensures\n        sorted(b@),\n        b@.to_multiset() == c@.to_multiset().add(d@.to_multiset()),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBubbleSort_bubbleSorta", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sorted_seg(a: Seq<i32>, i: int, j: int) -> bool //j excluded\n    recommends 0 <= i <= j <= a.len()\n{\n    forall|l: int, k: int| i <= l <= k < j ==> a[l] <= a[k]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn bubbleSorta(a: &mut Vec<i32>, c: usize, f: usize) //f excluded\n    requires \n        c <= f,\n        f <= old(a).len(), //when c==f empty sequence\n    ensures \n        sorted_seg(a@, c as int, f as int),\n        a@.subrange(c as int, f as int).to_multiset() == old(a)@.subrange(c as int, f as int).to_multiset(),\n        a@.subrange(0, c as int) == old(a)@.subrange(0, c as int),\n        a@.subrange(f as int, a.len() as int) == old(a)@.subrange(f as int, old(a).len() as int),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_606_DegreesToRadians", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nspec fn pi_approx() -> int { 314159265358979323846i128 as int }\nspec fn scale_factor() -> int { 100000000000000000000i128 as int }\n\nfn degrees_to_radians(degrees: i64) -> (radians: i64)\n    ensures radians as int == (degrees as int * pi_approx()) / scale_factor() / 180\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0 // unreachable\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced examples_Percentile_Percentile", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// Sum of elements of A from indices 0 to end.\n// end is inclusive! (not James's normal way of thinking!!)\nspec fn sum_upto(a: Seq<int>, end: int) -> int\n    decreases end + 2\n{\n    if end < 0 {\n        0\n    } else if end >= a.len() {\n        0  // out of bounds\n    } else {\n        a[end] + sum_upto(a, end - 1)\n    }\n}\n\nspec fn sum(a: Seq<int>) -> int {\n    sum_upto(a, a.len() - 1)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn percentile(p: int, a: &[int], total: int) -> (i: i32)\n    requires \n        forall|idx: int| 0 <= idx < a.len() ==> a@[idx] > 0,\n        0 <= p <= 100,\n        total == sum(a@),\n        total > 0,\n    ensures \n        -1 <= i < a.len(),\n        sum_upto(a@, i as int) <= (p * total) / 100,\n        i as int + 1 < a.len() ==> sum_upto(a@, i as int + 1) > (p * total) / 100,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "// example showing that, with the original postcondition, the answer is non-unique!\n\n\n// proof that, with the corrected postcondition, the answer is unique\n// lemma for previous proof: when an array has strictly positive elements, the\n// sums strictly increase left to right\n\nfn main() {\n}\n\n}"}
{"id": "630-dafny_tmp_tmpz2kokaiq_Solution_BinarySearch", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sorted(a: &[int]) -> bool {\n    forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn binary_search(a: &[int], x: int) -> (index: i32)\n    requires \n        sorted(a),\n    ensures \n        0 <= index < a.len() ==> a[index as int] == x,\n        index == -1 ==> forall|i: int| 0 <= i < a.len() ==> a[i] != x,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    -1\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_629_FindEvenNumbers", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_even(n: int) -> bool {\n    n % 2 == 0\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn find_even_numbers(arr: &[i32]) -> (even_list: Vec<i32>)\n    // All numbers in the output are even and exist in the input \n    ensures forall|i: int| 0 <= i < even_list.len() ==> is_even(even_list[i] as int) && exists|j: int| 0 <= j < arr.len() && arr[j] == even_list[i],\n    // All even numbers in the input are in the output\n    ensures forall|i: int| 0 <= i < arr.len() && is_even(arr[i] as int) ==> exists|j: int| 0 <= j < even_list.len() && even_list[j] == arr[i]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_126_SumOfCommonDivisors", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn sum_of_common_divisors(a: u32, b: u32) -> (sum: u32)\n    requires \n        a > 0 && b > 0,\n    ensures \n        sum >= 0,\n        forall|d: u32| #![trigger a % d, b % d] \n            1 <= d <= a && 1 <= d <= b && a % d == 0 && b % d == 0 ==> sum >= d,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_426_FilterOddNumbers", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/**\n * Filter odd numbers from an array of numbers\n **/\n\nspec fn is_odd(n: int) -> bool {\n    n % 2 != 0\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn filter_odd_numbers(arr: &[int]) -> (odd_list: Vec<int>)\n    ensures \n        // All numbers in the output are odd and exist in the input \n        forall|i: int| 0 <= i < odd_list.len() ==> is_odd(odd_list[i]) && arr@.contains(odd_list[i]),\n        // All odd numbers in the input are in the output\n        forall|i: int| 0 <= i < arr.len() && is_odd(arr[i]) ==> odd_list@.contains(arr[i]),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "dafny-exercise_tmp_tmpouftptir_prac4_ex2_GetTriple", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn triple(a: &[int]) -> bool {\n    exists|i: int| 0 <= i < a.len() - 2 && #[trigger] a[i] == a[i + 1] && a[i + 1] == a[i + 2]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn get_triple(a: &[int]) -> (index: usize)\nensures \n    (0 <= index < a.len() - 1) || index == a.len(),\n    index == a.len() <==> !triple(a),\n    (0 <= index < a.len() - 1) <==> triple(a),\n    (0 <= index < a.len() - 1) ==> a[index as int] == a[index as int + 1] && a[index as int + 1] == a[index as int + 2]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    a.len()\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_from dafny main repo_dafny2_Classics_FIND", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// RUN: %testDafnyForEachResolver \"%s\" -- --warn-deprecation:false\n\n\n// A version of Turing's additive factorial program [Dr. A. Turing, \"Checking a large routine\",\n// In \"Report of a Conference of High Speed Automatic Calculating Machines\", pp. 67-69, 1949].\n\nspec fn factorial(n: nat) -> nat\n    decreases n\n{\n    if n == 0 { 1 } else { n * factorial(sub(n, 1)) }\n}\n\n\n// Hoare's FIND program [C.A.R. Hoare, \"Proof of a program: FIND\", CACM 14(1): 39-45, 1971].\n// The proof annotations here are not the same as in Hoare's article.\n\n// In Hoare's words:\n//   This program operates on an array A[1:N], and a value of f (1 <= f <= N).\n//   Its effect is to rearrange the elements of A in such a way that:\n//     forall p,q (1 <= p <= f <= q <= N ==> A[p] <= A[f] <= A[q]).\n//\n// Here, we use 0-based indices, so we would say:\n//   This method operates on an array A[0..N], and a value of f (0 <= f < N).\n//   Its effect is to rearrange the elements of A in such a way that:\n//     forall p,q :: 0 <= p <= f <= q < N ==> A[p] <= A[f] <= A[q]).", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn find(A: &mut Vec<i32>, N: usize, f: usize)\n    requires \n        old(A)@.len() == N,\n        f < N,\n    ensures\n        forall|p: int, q: int| 0 <= p <= f as int <= q < N as int ==> A@[p] <= A@[q],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "cs245-verification_tmp_tmp0h_nxhqp_A8_Q1_A8Q1", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// A8Q1 — Steph Renee McIntyre\n// Following the solutions from Carmen Bruni\n\n// There is no definition for power, so this function will be used for validating that our imperative program is correct. This is just for Verus.\nspec fn power(a: int, n: int) -> int //function for a to the power of n\n    recommends 0 <= n\n    decreases n when 0 <= n\n{\n    if n <= 0 { 1 } else { a * power(a, n - 1) }\n}\n\n/* Proof of implieds can be seen on LEARN.\n    Note: If you are unconvinced, putting asserts for each condition will demonstrate the correctness of the statements. \n*/", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn A8Q1(y0: int, x: int) -> (z: int)\n    requires y0 >= 0\n    ensures z == power(x, y0)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    proof {\n        assume(false);\n    }\n    unreached()\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_760_HasOnlyOneDistinctElement", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn has_only_one_distinct_element(a: &[i32]) -> (result: bool)\n    ensures \n        result ==> forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() ==> a[i] == a[j],\n        !result ==> exists|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() && a[i] != a[j],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    true\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex6_BullsCows", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// see pdf 'ex6 & 7 documentation' for excercise question\n\nspec fn bullspec(s: Seq<nat>, u: Seq<nat>) -> nat {\n    if !(0 <= u.len() == s.len() && nomultiples(u)) {\n        arbitrary()\n    } else {\n        reccbull(s, u, 0)\n    }\n}\n\nspec fn cowspec(s: Seq<nat>, u: Seq<nat>) -> nat {\n    if !(0 <= u.len() == s.len() && nomultiples(u)) {\n        arbitrary()\n    } else {\n        recccow(s, u, 0)\n    }\n}\n\nspec fn reccbull(s: Seq<nat>, u: Seq<nat>, i: int) -> nat\n    decreases s.len() - i\n{\n    if !(0 <= i <= s.len() == u.len()) {\n        arbitrary()\n    } else if i == s.len() {\n        0\n    } else if s[i] == u[i] {\n        reccbull(s, u, i + 1) + 1\n    } else {\n        reccbull(s, u, i + 1)\n    }\n}\n\nspec fn recccow(s: Seq<nat>, u: Seq<nat>, i: int) -> nat\n    decreases s.len() - i\n{\n    if !(0 <= i <= s.len() == u.len()) {\n        arbitrary()\n    } else if i == s.len() {\n        0\n    } else if s[i] != u[i] && s.contains(u[i]) {\n        recccow(s, u, i + 1) + 1\n    } else {\n        recccow(s, u, i + 1)\n    }\n}\n\nspec fn nomultiples(u: Seq<nat>) -> bool {\n    forall|j: int, k: int| 0 <= j < k < u.len() ==> u[j] != u[k]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn BullsCows(s: Vec<u32>, u: Vec<u32>) -> (ret: (u32, u32))\n    requires \n        0 < u.len() == s.len() <= 10,\n        nomultiples(s@.map(|i, x: u32| x as nat)) && nomultiples(u@.map(|i, x: u32| x as nat))\n    ensures \n        ret.0 >= 0 && ret.1 >= 0,\n        ret.0 as nat == bullspec(s@.map(|i, x: u32| x as nat), u@.map(|i, x: u32| x as nat)),\n        ret.1 as nat == cowspec(s@.map(|i, x: u32| x as nat), u@.map(|i, x: u32| x as nat))\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    (0, 0)\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_examples_bubblesort_BubbleSort", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n//https://stackoverflow.com/questions/69364687/how-to-prove-time-complexity-of-bubble-sort-using-dafny\nspec fn n_choose_2(n: int) -> int\n{\n    n * (n - 1) / 2\n}\n\n// sum of all integers in the range [lo, hi)\n// (inclusive of lo, exclusive of hi)\nspec fn sum_range(lo: int, hi: int) -> int\n    decreases hi - lo\n{\n    if lo >= hi { 0 }\n    else { sum_range(lo, hi - 1) + hi - 1 }\n}\n\n// dafny proves this automatically by induction", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn bubble_sort(a: &mut Vec<i32>) -> (n: usize) \n    ensures n <= n_choose_2(a.len() as int) as usize\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "software_analysis_tmp_tmpmt6bo9sf_ss_selection_sort", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nfn find_min_index(a: &Vec<i32>, s: usize, e: usize) -> (min_i: usize)\n    requires \n        a.len() > 0,\n        s < a.len(),\n        e <= a.len(),\n        e > s,\n    ensures \n        min_i >= s,\n        min_i < e,\n        forall|k: int| s <= k < e ==> a[min_i as int] <= a[k],\n{\n    assume(false);\n    s\n}\n\nspec fn is_sorted(ss: Seq<i32>) -> bool {\n    forall|i: int, j: int| 0 <= i <= j < ss.len() ==> ss[i] <= ss[j]\n}\n\nspec fn is_permutation(a: Seq<i32>, b: Seq<i32>) -> bool\n    decreases a.len(), b.len()\n{\n    a.len() == b.len() && \n    ((a.len() == 0 && b.len() == 0) ||  \n     (exists|i: int, j: int| {\n        0 <= i < a.len() && 0 <= j < b.len() && a[i] == b[j] && \n        is_permutation(\n            a.subrange(0, i) + {if i < a.len() { a.subrange(i + 1, a.len() as int) } else { seq![] }},\n            b.subrange(0, j) + {if j < b.len() { b.subrange(j + 1, b.len() as int) } else { seq![] }}\n        )\n     }))\n}\n\nspec fn is_permutation2(a: Seq<i32>, b: Seq<i32>) -> bool {\n    a.to_multiset() == b.to_multiset()\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn selection_sort(ns: &mut Vec<i32>) \n    requires old(ns).len() >= 0\n    ensures \n        is_sorted(ns@),\n        is_permutation2(old(ns)@, ns@),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "BinaryAddition_BinaryAddition", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* \nMIPS 0\nWe implement the following with bitvectors in Verus.\nhere s' and t' are converted to decimal scalars\ns = [1,1,1], t = [1,0,1], ys = [1, 0, 0], s' = 7, t' = 5, ys' = 4\nys' % 2 ^ (len(s)) = (s' + t') % 2 ^ (len(s))\n4 % 8 = 12 % 8\n\ndef f(s,t):\n    a = 0;b = 0;\n    ys = []\n    for i in range(10):\n        c = s[i]; d = t[i];\n        next_a = b ^ c ^ d\n        next_b = b+c+d>1\n        a = next_a;b = next_b;\n        y = a\n        ys.append(y)\n    return ys\n*/\n\n// Helper function to check if a bit is set\nspec fn is_bit_set(x: u16, bit_index: int) -> bool\n    recommends 0 <= bit_index < 10\n{\n    (x & (1u16 << bit_index)) != 0\n}\n\n// Convert u16 to sequence of 10 bools (LSB first)\nspec fn bv10_to_seq(x: u16) -> Seq<bool> {\n    seq![\n        is_bit_set(x, 0), is_bit_set(x, 1), is_bit_set(x, 2), is_bit_set(x, 3),\n        is_bit_set(x, 4), is_bit_set(x, 5), is_bit_set(x, 6), is_bit_set(x, 7),\n        is_bit_set(x, 8), is_bit_set(x, 9)\n    ]\n}\n\n// Convert array of bools to u16 bitvector\nspec fn array_to_bv10(arr: &[bool; 10]) -> u16\n{\n    array_to_bv10_helper(arr, 9)\n}\n\nspec fn array_to_bv10_helper(arr: &[bool; 10], index: nat) -> u16\n    recommends index < 10\n    decreases index\n{\n    if index == 0 {\n        if arr[index as int] { 1u16 } else { 0u16 }\n    } else {\n        let bit: u16 = if arr[index as int] { 1u16 } else { 0u16 };\n        #[verifier::truncate]\n        let shifted: u16 = (bit << (index as int));\n        #[verifier::truncate]\n        let result: u16 = (shifted as int + array_to_bv10_helper(arr, (index - 1) as nat) as int) as u16;\n        result\n    }\n}\n\n// Convert array to sequence\nfn array_to_sequence(arr: &[bool; 10]) -> (res: Vec<bool>)\n    ensures res.len() == 10,\n    ensures forall|k: int| 0 <= k < 10 ==> res[k] == arr[k]\n{\n    assume(false);\n    Vec::new()\n}\n\n// Boolean to integer conversion\nspec fn bool_to_int(a: bool) -> int {\n    if a { 1 } else { 0 }\n}\n\n// XOR operation\nspec fn xor_bool(a: bool, b: bool) -> bool {\n    (a || b) && !(a && b)\n}\n\n// Traditional bit addition using bitvectors\nspec fn bit_addition(s: &[bool; 10], t: &[bool; 10]) -> Seq<bool> {\n    let a: u16 = array_to_bv10(s);\n    let b: u16 = array_to_bv10(t);\n    #[verifier::truncate]\n    let c: u16 = (a as int + b as int) as u16;\n    bv10_to_seq(c)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn binary_addition(s: &[bool; 10], t: &[bool; 10]) -> (sresult: Vec<bool>) // Generated program for bit addition\n    requires s.len() == 10 && t.len() == 10\n    ensures sresult.len() == 10,\n    ensures bit_addition(s, t) == sresult@, // Verification of correctness\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_751_IsMinHeap", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn is_min_heap(a: &Vec<i32>) -> (result: bool)\n    requires a.len() > 0\n    ensures \n        result ==> forall|i: int| 0 <= i < (a.len() as int) / 2 ==> {\n            let left_idx = 2 * i + 1;\n            let right_idx = 2 * i + 2;\n            (left_idx < a.len()) ==> (#[trigger] a[i as int] <= a[left_idx]) &&\n            (right_idx < a.len()) ==> (a[i as int] <= a[right_idx])\n        },\n        !result ==> exists|i: int| 0 <= i < (a.len() as int) / 2 && {\n            let left_idx = 2 * i + 1;\n            let right_idx = 2 * i + 2;\n            (#[trigger] a[i as int] > a[left_idx] && left_idx < a.len()) ||\n            (a[i as int] > a[right_idx] && right_idx < a.len())\n        }\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    false\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_776_CountVowelNeighbors", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_vowel(c: char) -> bool {\n    c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n    c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U'\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn count_vowel_neighbors(s: &str) -> (count: usize)\n    ensures \n        count >= 0 &&\n        count == Set::new(|i: int| 1 <= i < s@.len() - 1 && \n                          is_vowel(s@[i-1]) && \n                          is_vowel(s@[i+1])).len(),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  0\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "dafny-exercise_tmp_tmpouftptir_prac3_ex2_GetEven", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn get_even(s: &mut Vec<nat>)\n    ensures \n        s.len() == old(s).len(),\n        forall|i: int| 0 <= i < s.len() ==> {\n            if old(s)[i] % 2 == 1 {\n                s[i] == old(s)[i] + 1\n            } else {\n                s[i] == old(s)[i]\n            }\n        }\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Quick_Sort_threshold", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn quick_sorted(seq: Seq<int>) -> bool {\n    forall|idx_1: int, idx_2: int| 0 <= idx_1 < idx_2 < seq.len() ==> seq[idx_1] <= seq[idx_2]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn threshold(thres: int, seq: Seq<int>) -> (ret: (Seq<int>, Seq<int>))\n    ensures \n        (forall|x: int| ret.0.contains(x) ==> x <= thres) &&\n        (forall|x: int| ret.1.contains(x) ==> x >= thres) &&\n        ret.0.len() + ret.1.len() == seq.len() &&\n        ret.0.to_multiset().add(ret.1.to_multiset()) == seq.to_multiset()\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    loop { }\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_728_AddLists", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn add_lists(a: Seq<int>, b: Seq<int>) -> (result: Seq<int>)\n    requires \n        a.len() == b.len(),\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] + b[i],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    a\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "cs245-verification_tmp_tmp0h_nxhqp_power_compute_power", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n//power -- Stephanie Renee McIntyre\n//Based on the code used in the course overheads for Fall 2018\n\n//There is no definition for power, so this function will be used for validating that our imperative program is correct.\n\n/* Proof of implied (a): Follows from definition of the power function. */\n\n/* Proof of implied (b): Details left as exercise, but this is relatively simple. */\n\n/* Proof of implied (c): Simple substitution and uses the fact that i=n. */\n\n/* Proof of termination: the loop guard gives us the expression i<n. This is equivalent to n-i>=0.\n   Prior to the loop, n>=0 and i=0.\n   Each iteration of the loop, i increases by 1 and thus n-i decreases by 1. Thus n-i will eventually reach 0.\n   When the n-i=0, n=i and thus the loop guard ends the loop as it is no longer the case that i<n.\n   Thus the program terminates.\n*/", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nspec fn power(a: int, n: nat) -> int //function for a to the power of n\n    recommends 0 <= a\n    decreases n\n{\n    if n == 0 { 1 } else { a * power(a, (n - 1) as nat) }\n}\n\n//Our code from class\nfn compute_power(a: u64, n: u64) -> (s: u64)\n    /*Pre-Condition*/   requires n >= 0 && a >= 0\n    /*Post-Condition*/  ensures s as int == power(a as int, n as nat)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_04_Hoangkim_ex_04_Hoangkim_intDiv", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n//Problem 01\n\n//problem02\n//a)", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nproof fn int_div(n: int, d: int) -> (result: (int, int))\n    requires n >= d && n >= 0 && d > 0,\n    ensures ({\n        let (q, r) = result;\n        (d * q) + r == n && 0 <= q <= n / 2 && 0 <= r < d\n    })\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    (0, 0) // unreachable due to assume(false)\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_mfirstMaximum", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n//Algorithm 1: From left to right return the first\n\n//Algorithm 2: From right to left return the last", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn mfirstMaximum(v: &Vec<i32>) -> (i: usize)\n    requires v.len() > 0,\n    ensures \n        0 <= i < v.len() &&\n        (forall|k: int| 0 <= k < v.len() ==> v[i as int] >= v[k]) &&\n        (forall|l: int| 0 <= l < i ==> v[i as int] > v[l]),\n    //Algorithm: from left to right\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "//Algorithm : from left to right\n//Algorithm : from right to left\n\nfn main() {}\n\n}"}
{"id": "llm-verified-eval_tmp_tmpd2deqn_i_dafny_0_has_close_elements", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn abs(x: int) -> int {\n    if x < 0 { -x } else { x }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn has_close_elements(numbers: Seq<int>, threshold: int) -> (result: bool)\n    ensures\n        result <==> exists|i: int, j: int|\n            0 <= i < numbers.len() &&\n            0 <= j < numbers.len() &&\n            i != j &&\n            abs(numbers[i] - numbers[j]) < threshold,\n        result ==> numbers.len() > 1,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    false\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_759_IsDecimalWithTwoPrecision", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn is_decimal_with_two_precision(s: &str) -> (result: bool)\n    ensures\n        result ==> exists|i: int| 0 <= i < s@.len() && s@[i] == '.' && s@.len() - i - 1 == 2,\n        !result ==> !exists|i: int| 0 <= i < s@.len() && s@[i] == '.' && s@.len() - i - 1 == 2,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    false\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "DafnyPrograms_tmp_tmp74_f9k_c_prime-database_testPrimeness", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// predicate for primeness\nspec fn prime(n: nat) -> bool {\n    n > 1 && (forall|nr: nat| 1 < nr < n ==> #[trigger] (n % nr) != 0)\n}\n\n#[derive(PartialEq, Eq)]\nenum Answer {\n    Yes,\n    No,\n    Unknown,\n}\n\n// the class containing a prime database, if a number is prime it returns Yes, if it is not No and if the number\n// is not in the database it returns Unknown\nstruct PrimeMap {\n    database: Ghost<Map<nat, bool>>,\n}\n\nimpl PrimeMap {\n    // the valid invariant of the class\n    spec fn valid(&self) -> bool {\n        forall|i: nat| self.database@.dom().contains(i) ==> (self.database@[i] == prime(i))\n    }\n\n    // the constructor\n    fn new() -> (result: PrimeMap)\n        ensures \n            result.database@ === Map::empty(),\n            result.valid(),\n    {\n        PrimeMap {\n            database: Ghost(Map::empty())\n        }\n    }\n\n    // lookup n in the database and reply with Yes or No if it's in the database and it is or it is not prime,\n    // or with Unknown when it's not in the databse\n    fn is_prime(&self, n: nat) -> (answer: Answer)\n        requires self.valid(),\n        ensures \n            self.database@.dom().contains(n) && prime(n) <==> answer == Answer::Yes,\n            self.database@.dom().contains(n) && !prime(n) <==> answer == Answer::No,\n            !self.database@.dom().contains(n) <==> answer == Answer::Unknown,\n    {\n        assume(false);\n        Answer::Unknown\n    }\n\n    // method to test whether a number is prime, returns bool\n\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn test_primeness(n: nat) -> (result: bool) \n      requires n >= 0,\n      ensures result <==> prime(n),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    false\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_432_MedianLength", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn median_length(a: int, b: int) -> (median: int)\n    requires a > 0 && b > 0\n    ensures median == (a + b) / 2\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  unreached::<int>()\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Clover_canyon_search_CanyonSearch", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn canyon_search(a: &[i32], b: &[i32]) -> (d: u32)\n  requires \n      a.len() != 0 && b.len() != 0,\n      forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j],\n      forall|i: int, j: int| 0 <= i < j < b.len() ==> b[i] <= b[j],\n  ensures\n      exists|i: int, j: int| 0 <= i < a.len() && 0 <= j < b.len() && \n          d as int == (if a[i] < b[j] { \n              b[j] - a[i]\n          } else { \n              a[i] - b[j]\n          }),\n      forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < b.len() ==> \n          d as int <= (if a[i] < b[j] { \n              b[j] - a[i]\n          } else { \n              a[i] - b[j]\n          }),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  0\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Software-Verification_tmp_tmpv4ueky2d_Counting Bits_counting_bits_counting_bits", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn counting_bits(n: usize) -> (result: Vec<usize>)\n    requires 0 <= n <= 100000\n    ensures result.len() == n + 1 &&\n            (forall|i: int| 1 <= i < (n + 1) as int ==> \n                #[trigger] result[i as int] == result[(i / 2) as int] + (i % 2) as usize)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "MFES_2021_tmp_tmpuljn8zd9_TheoreticalClasses_Power_powerIter", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* \n* Formal verification of O(n) and O(log n) algorithms to calculate the natural\n* power of a real number (x^n), illustrating the usage of lemmas.\n* FEUP, MIEIC, MFES, 2020/21.\n*/\n\n// Initial specification/definition of x^n, recursive, functional style, \n// with time and space complexity O(n).\nspec fn power(x: int, n: nat) -> int\n    decreases n\n{\n    if n == 0 { 1 } else { x * power(x, (n - 1) as nat) }\n}\n\n// Iterative version, imperative, with time complexity O(n) and space complexity O(1).", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn power_iter(x: i64, n: u64) -> (p: i64)\n    ensures p == power(x as int, n as nat)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    1\n}\n// </vc-code>", "vc-postamble": "// Recursive version, imperative, with time and space complexity O(log n).\n\n// States the property x^a * x^b = x^(a+b), that powerOpt takes advantage of. \n// The annotation {:induction a} guides Dafny to prove the property\n// by automatic induction on 'a'.\n\n// A simple test case to make sure the specification is adequate.\n\nfn main() {\n}\n\n}"}
{"id": "dafny_examples_tmp_tmp8qotd4ez_leetcode_0001-two-sum_TwoSum", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// If this invariant is added explicitly to the loop then the verfication never finishes.\n// It could be {:opaque} for a more controlled verification:\n// assert InMap([], m, target) by {\n//   reveal InMap();\n// }\nspec fn in_map(nums: Seq<int>, m: Map<int, int>, t: int) -> bool {\n    forall|j: int| 0 <= j < nums.len() ==> m.contains_key(t - nums[j])\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn two_sum(nums: &[i32], target: i32) -> (r: (i32, i32))\n    ensures \n        0 <= r.0 ==> 0 <= r.0 < r.1 < nums.len() && \n                     nums.view()[r.0 as int] + nums.view()[r.1 as int] == target &&\n                     forall|i: int, j: int| 0 <= i < j < r.1 ==> nums.view()[i] + nums.view()[j] != target,\n        r.0 == -1 <==> forall|i: int, j: int| 0 <= i < j < nums.len() ==> nums.view()[i] + nums.view()[j] != target,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    (-1, -1)\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Dafny_tmp_tmp0wu8wmfr_tests_SumIntsLoop_SumIntsLoop", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sum_ints(n: int) -> int\n    decreases n when n >= 0\n{\n    if n <= 0 {\n        0\n    } else {\n        sum_ints(n - 1) + n\n    }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn sum_ints_loop(n: u32) -> (s: u32)\n    ensures \n        s == sum_ints(n as int),\n        s == n * (n + 1) / 2;\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "Clover_insert_insert", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn insert(line: &mut Vec<char>, l: int, nl: &Vec<char>, p: int, at: int)\n    requires \n        0 <= l + p <= old(line).len(),\n        0 <= p <= nl.len(),\n        0 <= at <= l,\n    ensures \n        forall|i: int| (0 <= i < p) ==> line[at + i] == nl[i],\n        forall|i: int| (0 <= i < at) ==> line[i] == old(line)[i],\n        forall|i: int| (at + p <= i < l + p) ==> line[i] == old(line)[i - p],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_474_ReplaceChars", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn replace_chars(s: Seq<char>, old_char: char, new_char: char) -> (v: Seq<char>)\n    ensures\n        v.len() == s.len(),\n        forall|i: int| 0 <= i < s.len() ==> \n            (s[i] == old_char ==> v[i] == new_char) &&\n            (s[i] != old_char ==> v[i] == s[i]),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    s\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session5Exercises_ExerciseSumElems_sumElemsB", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sum_r(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        sum_r(s.subrange(0, s.len() - 1)) + s[s.len() - 1]\n    }\n}\n\nspec fn sum_l(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s[0] + sum_l(s.subrange(1, s.len() as int))\n    }\n}\n\n\nspec fn sum_v(v: Seq<int>, c: int, f: int) -> int\n{\n    if 0 <= c <= f <= v.len() {\n        sum_r(v.subrange(c, f))\n    } else {\n        0\n    }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn sum_elems_b(v: &[i32]) -> (sum: i32)\n//ensures sum as int == sum_l(v@.map(|i, x| x as int))\nensures sum as int == sum_r(v@.map(|i, x| x as int))\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  0\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_07_Hoangkim_ex07_Hoangkim_selectionSort", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n//Problem01\n//a)\n\n//b)\n//Problem04\n\nfn find_min(a: &[i32], lo: usize) -> (minIdx: usize)\n    requires\n        a.len() > 0,\n        lo < a.len(),\n    ensures\n        lo <= minIdx < a.len(),\n        forall|x: usize| lo <= x < a.len() ==> a[minIdx as int] <= a[x as int],\n{\n    assume(false);\n    lo // dummy return\n}\n\n//Problem02\nspec fn sorted(a: Seq<i32>) -> bool {\n    forall|i: int| 0 < i < a.len() ==> #[trigger] a[i-1] <= a[i]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn selection_sort(a: &mut [i32])\n    //ensures multiset(a) == multiset(old(a))\n    //ensures sorted(a@)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "//Problem03\n\nfn main() {}\n\n}"}
{"id": "dafny-language-server_tmp_tmpkir0kenl_Test_dafny4_Bug165_Select", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// Using generic type parameter with uninterpreted body\nspec fn f<T>(a: T) -> bool {\n    true  // placeholder uninterpreted function\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\n#[verifier::exec_allows_no_decreases_clause]\nfn select<T>(s1: Seq<T>) -> (r: Seq<T>)\n    ensures\n        forall|e: T| f(e) ==> s1.to_multiset().count(e) == r.to_multiset().count(e),\n        forall|e: T| !f(e) ==> r.to_multiset().count(e) == 0,\n\nfn main_impl<T>(s1: Seq<T>)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    loop { }\n}\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_632_MoveZeroesToEnd", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nfn swap(arr: &mut Vec<i32>, i: usize, j: usize)\n    requires \n        old(arr).len() > 0,\n        i < old(arr).len(),\n        j < old(arr).len(),\n    ensures\n        arr[i as int] == old(arr)[j as int],\n        arr[j as int] == old(arr)[i as int],\n        forall|k: int| 0 <= k < arr.len() && k != i && k != j ==> arr[k] == old(arr)[k],\n        arr@.to_multiset() == old(arr)@.to_multiset(),\n{\n    assume(false);\n}\n\nspec fn count(arr: Seq<i32>, value: i32) -> nat\n    decreases arr.len(),\n{\n    if arr.len() == 0 {\n        0nat\n    } else {\n        (if arr[0] == value { 1nat } else { 0nat }) + count(arr.skip(1), value)\n    }\n}\n\nproof fn count_bound(arr: Seq<i32>, value: i32)\n    ensures count(arr, value) <= arr.len(),\n    decreases arr.len(),\n{\n    if arr.len() == 0 {\n    } else {\n        count_bound(arr.skip(1), value);\n    }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn move_zeros_to_end(arr: &mut Vec<i32>)\n    requires old(arr).len() >= 2,\n    ensures\n        // Same size\n        arr.len() == old(arr).len(),\n        // Zeros to the right of the first zero\n        forall|i: int, j: int| 0 <= i < j < arr.len() && arr[i] == 0 ==> arr[j] == 0,\n        // The final array is a permutation of the original one\n        arr@.to_multiset() == old(arr)@.to_multiset(),\n        // Relative order of non-zero elements is preserved\n        forall|n: int, m: int| 0 <= n < m < arr.len() && old(arr)[n] != 0 && old(arr)[m] != 0 ==>\n            exists|k: int, l: int| 0 <= k < l < arr.len() && arr[k] == old(arr)[n] && arr[l] == old(arr)[m],\n        // Number of zeros is preserved\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "dafny_misc_tmp_tmpg4vzlnm1_rosetta_code_factorial_IterativeFactorial", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// recursive definition of factorial\nspec fn factorial(n: nat) -> nat\n    decreases n\n{\n    if n == 0 { 1 } else { n * factorial((n - 1) as nat) }\n}\n\n// iterative implementation of factorial", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn iterative_factorial(n: u32) -> (result: u32)\n    requires n < 13, // prevent overflow\n    ensures result == factorial(n as nat)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Dafny_Verify_tmp_tmphq7j0row_dataset_detailed_examples_SelectionSort_SelectionSort", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// Works by dividing the input list into two parts: sorted and unsorted. At the beginning, \n// the sorted part is empty and the unsorted part contains all the elements.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn selection_sort(a: &mut Vec<i32>)\n    ensures\n        // Ensures the final array is sorted in ascending order\n        forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j],\n        // Ensures that the final array has the same elements as the initial array\n        a@.to_multiset() == old(a)@.to_multiset(),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "Clover_array_concat_concat", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn concat(a: &[i32], b: &[i32]) -> (c: Vec<i32>)\n    ensures \n        c.len() == b.len() + a.len(),\n        forall|k: int| 0 <= k < a.len() ==> c[k] == a[k],\n        forall|k: int| 0 <= k < b.len() ==> c[k + a.len()] == b[k],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_775_IsOddAtIndexOdd", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_odd(n: int) -> bool {\n    n % 2 == 1\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn is_odd_at_index_odd(a: &[int]) -> (result: bool)\n    ensures result <==> forall|i: int| 0 <= i < a.len() ==> (is_odd(i) ==> is_odd(a[i]))\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  false\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_784_FirstEvenOddIndices", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_even(n: int) -> bool {\n    n % 2 == 0\n}\n\nspec fn is_odd(n: int) -> bool {\n    n % 2 != 0\n}\n\nspec fn is_first_even(even_index: int, lst: Seq<i32>) -> bool\n    recommends 0 <= even_index < lst.len(), is_even(lst[even_index] as int)\n{\n    forall|i: int| 0 <= i < even_index ==> is_odd(lst[i] as int)\n}\n\nspec fn is_first_odd(odd_index: int, lst: Seq<i32>) -> bool\n    recommends 0 <= odd_index < lst.len(), is_odd(lst[odd_index] as int)\n{\n    forall|i: int| 0 <= i < odd_index ==> is_even(lst[i] as int)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn first_even_odd_indices(lst: Vec<i32>) -> (result: (usize, usize))\n    requires lst.len() >= 2,\n             exists|i: int| 0 <= i < lst.len() && is_even(lst[i] as int),\n             exists|i: int| 0 <= i < lst.len() && is_odd(lst[i] as int)\n    ensures 0 <= result.0 < lst.len(),\n            0 <= result.1 < lst.len(),\n            // This is the postcondition that ensures that it's the first, not just any\n            is_even(lst[result.0 as int] as int) && is_first_even(result.0 as int, lst@),\n            is_odd(lst[result.1 as int] as int) && is_first_odd(result.1 as int, lst@)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    (0, 0)\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 1_LinearSearch_SearchRecursive", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// Author of question: Snorri Agnarsson\n// Permalink of question: https://rise4fun.com/Dafny/0HRr\n\n// Author of solution:    Alexander Guðmundsson\n// Permalink of solution: https://rise4fun.com/Dafny/8pxWd\n\n// Use the command\n//   verus LinearSearch-skeleton.rs\n// to compile the file.\n\n// When you have solved the problem put\n// the solution on the Verus web page,\n// generate a permalink and put it in\n// this file.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn search_recursive(a: Seq<int>, i: usize, j: usize, x: int) -> (result: isize)\n    requires \n        i <= j,\n        j <= a.len(),\n    ensures\n        (i <= result && result < j as isize) || result == -1,\n        result != -1 ==> a[result as int] == x,\n        result != -1 ==> forall|r: int| result < r && r < j as int ==> a[r] != x,\n        result == -1 ==> forall|r: int| i as int <= r && r < j as int ==> a[r] != x,\n    decreases j - i,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    -1\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_577_FactorialOfLastDigit", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn factorial(n: int) -> int\n    recommends n >= 0\n    decreases n when n >= 0\n{\n    if n == 0 { 1 } else { n * factorial((n - 1) as int) }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn factorial_of_last_digit(n: u64) -> (fact: u64)\n    requires n >= 0\n    ensures fact == factorial((n % 10) as int)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  0\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_401_IndexWiseAddition", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn index_wise_addition(a: Seq<Seq<int>>, b: Seq<Seq<int>>) -> (result: Seq<Seq<int>>)\n    requires \n        a.len() > 0 && b.len() > 0,\n        a.len() == b.len(),\n        forall|i: int| 0 <= i < a.len() ==> a[i].len() == b[i].len(),\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == a[i].len(),\n        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result[i].len() ==> \n            result[i][j] == a[i][j] + b[i][j],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "Dafny_tmp_tmpmvs2dmry_examples2_exp_by_sqr", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn gcd(m: nat, n: nat) -> nat\nrecommends m > 0 && n > 0\ndecreases m + n\n{\n    if m == n { \n        n \n    } else if m > n { \n        // Simplified to avoid termination proof complexity\n        if m > n { gcd(1, n) } else { n }\n    } else { \n        // Simplified to avoid termination proof complexity  \n        if n > m { gcd(m, 1) } else { m }\n    }\n}\n\nspec fn exp(x: int, n: nat) -> int\ndecreases n\n{\n    if n == 0 { \n        1 \n    } else if x == 0 { \n        0 \n    } else if n == 0 && x == 0 { \n        1 \n    } else { \n        x * exp(x, sub(n, 1)) \n    }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn exp_by_sqr(x0: u32, n0: u32) -> (r: u32)\nrequires x0 >= 0;\nensures r == exp(x0 as int, n0 as nat);\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  0\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "Clover_linear_search2_LinearSearch", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn linear_search(a: &[i32], e: i32) -> (n: usize)\n    requires exists|i: int| 0 <= i < a.len() && a[i] == e,\n    ensures ({\n        &&& 0 <= n < a.len() \n        &&& a[n as int] == e\n        &&& forall|k: int| 0 <= k < n as int ==> a[k] != e\n    }),\n{\n// </vc-spec>", "vc-code": "// <vc-code>\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_576_IsSublist", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn is_sublist(sub: Seq<int>, main: Seq<int>) -> (result: bool)\n    ensures\n        result == exists|i: int, j: int| 0 <= i <= main.len() - sub.len() && j == i + sub.len() && sub =~= #[trigger] main.subrange(i, j)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    false\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "Dafny_tmp_tmp0wu8wmfr_tests_F1a_Mid", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn mid(p: int, q: int) -> (m: int)\n    // | ... | ??? | ... |\n    //        p m   q\n    requires \n        p <= q,\n    ensures \n        p <= m <= q,\n        m - p <= q - m,\n        0 <= (q - m) - (m - p) <= 1,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    proof {\n        assert(false);\n    }\n    p // unreachable\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "Dafny_ProgrammingLanguages_tmp_tmp82_e0kji_ExtraCredit_optimizeCorrect", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n#[derive(PartialEq, Eq)]\nenum Exp {\n    Const(int),\n    Var(String),\n    Plus(Box<Exp>, Box<Exp>),\n    Mult(Box<Exp>, Box<Exp>),\n}\n\nspec fn eval(e: Exp, store: Map<String, int>) -> int\n    decreases e\n{\n    match e {\n        Exp::Const(n) => n,\n        Exp::Var(s) => if store.dom().contains(s) { store[s] } else { -1 },\n        Exp::Plus(e1, e2) => eval(*e1, store) + eval(*e2, store),\n        Exp::Mult(e1, e2) => eval(*e1, store) * eval(*e2, store),\n    }\n}\n\n//fill this function in to make optimizeFeatures work\nspec fn optimize(e: Exp) -> Exp\n    decreases e\n{\n    match e {\n        Exp::Mult(e1, e2) => {\n            match (*e1, *e2) {\n                (Exp::Const(n1), _) if n1 == 0 => Exp::Const(0),\n                (_, Exp::Const(n2)) if n2 == 0 => Exp::Const(0),\n                (Exp::Const(n1), e2_inner) if n1 == 1 => e2_inner,\n                (e1_inner, Exp::Const(n2)) if n2 == 1 => e1_inner,\n                (Exp::Const(n1), Exp::Const(n2)) => Exp::Const(n1 * n2),\n                _ => e,\n            }\n        },\n        Exp::Plus(e1, e2) => {\n            match (*e1, *e2) {\n                (Exp::Const(n1), e2_inner) if n1 == 0 => e2_inner,\n                (e1_inner, Exp::Const(n2)) if n2 == 0 => e1_inner,\n                (Exp::Const(n1), Exp::Const(n2)) => Exp::Const(n1 + n2),\n                _ => e,\n            }\n        },\n        _ => e,\n    }\n} \n\n//as you write optimize this will become unproved\n//you must write proof code so that Verus can prove this", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn optimize_correct(e: Exp, s: Map<String, int>)\n    ensures eval(e, s) == eval(optimize(e), s)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Clover_replace_replace", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn replace(arr: &mut Vec<i32>, k: i32)\n    ensures \n        forall|i: int| 0 <= i < old(arr).len() ==> old(arr)[i] > k ==> arr[i] == -1,\n        forall|i: int| 0 <= i < old(arr).len() ==> old(arr)[i] <= k ==> arr[i] == old(arr)[i],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_69_ContainsSequence", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn contains_sequence(list: Seq<Seq<int>>, sub: Seq<int>) -> (result: bool)\n    ensures result <==> exists|i: int| 0 <= i < list.len() && sub == list[i]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    false\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "Clover_rotate_rotate", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn rotate(a: &[i32], offset: usize) -> (result: Vec<i32>)\n    requires \n        offset >= 0,\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> result[i] == a[(i + offset as int) % a.len() as int],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    Vec::new()\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "Software-Verification_tmp_tmpv4ueky2d_Remove Duplicates from Sorted Array_remove_duplicates_from_sorted_array_remove_duplicates_from_sorted_array", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// Helper predicate\nspec fn is_sorted(nums: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < nums.len() ==> nums[i] <= nums[j]\n}\n\nspec fn is_sorted_and_distinct(nums: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < nums.len() ==> nums[i] < nums[j]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn remove_duplicates_from_sorted_array(nums: Seq<int>) -> (result: Seq<int>)\n    requires \n        is_sorted(nums),\n        1 <= nums.len() <= 30000,\n        forall|i: int| #![trigger nums[i]] 0 <= i < nums.len() ==> -100 <= nums[i] <= 100,\n    ensures \n        is_sorted_and_distinct(result),\n        forall|i: int| #![trigger nums.contains(i)] nums.contains(i) <==> result.contains(i),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExerciseSquare_root_mroot1", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn mroot1(n: u32) -> (r: u32) //Cost O(root n)\n    requires n >= 0,\n    ensures r >= 0 && (r as int) * (r as int) <= n < ((r + 1) as int) * ((r + 1) as int),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_233_CylinderLateralSurfaceArea", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn cylinder_lateral_surface_area(radius: u64, height: u64) -> (area: u64)\n    requires \n        radius > 0,\n        height > 0,\n    ensures area == 2 * radius * height * 314 / 100,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_644_Reverse", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn reverse(a: &mut Vec<i32>)\n    ensures forall|k: int| 0 <= k < old(a).len() ==> a[k] == old(a)[old(a).len() as int - 1 - k]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafny-language-server_tmp_tmpkir0kenl_Test_comp_Arrays_LinearSearch", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// RUN: %verus \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nfn print_array<A>(a: Option<&[A]>) {\n    assume(false);\n}\n\ntype Lowercase = char; // In Verus, we'd use refinement types or Ghost wrappers for constraints\n\nfn diag_matrix<A: Copy>(rows: usize, cols: usize, zero: A, one: A) -> (a: Vec<Vec<A>>)\n    requires rows >= 0 && cols >= 0\n{\n    assume(false);\n    Vec::new()\n}\n\nfn print_matrix<A>(m: &Vec<Vec<A>>) {\n    assume(false);\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn linear_search(a: &[int], key: int) -> (n: usize)\n    ensures \n        0 <= n <= a.len(),\n        n == a.len() || a[n as int] == key,\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n    // Main function content would go here\n}\n\n}"}
{"id": "SENG2011_tmp_tmpgk5jq85q_ass2_ex2_String3Sort", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n// verifies\n// check that string between indexes low and high-1 are sorted\nspec fn sorted(a: Seq<char>, low: int, high: int) -> bool\n    recommends 0 <= low <= high <= a.len()\n{ \n    forall|j: int, k: int| low <= j < k < high ==> a[j] <= a[k]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn string3_sort(a: Seq<char>) -> (b: Seq<char>)\n    requires \n        a.len() == 3,\n    ensures \n        sorted(b, 0, b.len() as int),\n        a.len() == b.len(),\n        seq![b[0], b[1], b[2]].to_multiset() == seq![a[0], a[1], a[2]].to_multiset(),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    a\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_171_PentagonPerimeter", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn pentagon_perimeter(side: i32) -> (perimeter: i32)\n    requires side > 0\n    ensures perimeter == 5 * side\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume(false);\n  5 * side\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_741_AllCharactersSame", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn all_characters_same(s: Seq<u8>) -> (result: bool)\n    ensures\n        result ==> (forall|i: int, j: int| 0 <= i < s.len() && 0 <= j < s.len() ==> s[i] == s[j]),\n        !result ==> (s.len() > 1) && (exists|i: int, j: int| 0 <= i < s.len() && 0 <= j < s.len() && i != j && s[i] != s[j])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    true\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_472_ContainsConsecutiveNumbers", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn contains_consecutive_numbers(a: &[i32]) -> (result: bool)\n    requires a.len() > 0\n    ensures result <==> exists|i: int| #![trigger a.spec_index(i)] \n        0 <= i < (a.len() as int) - 1 && a[i] + 1 == a[i + 1]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    true\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_769_Difference", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn difference(a: Seq<int>, b: Seq<int>) -> (diff: Seq<int>)\n    ensures\n        forall|x: int| diff.contains(x) <==> (a.contains(x) && !b.contains(x)),\n        forall|i: int, j: int| 0 <= i < j < diff.len() ==> diff.index(i) != diff.index(j),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    unreached()\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_798_ArraySum", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sum_to(a: &[i32], n: int) -> int\n    recommends 0 <= n <= a.len()\n    decreases n\n{\n    if n <= 0 { 0 } else { sum_to(a, n - 1) + a[n - 1] }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn array_sum(a: &[i32]) -> (result: i32)\n    ensures result == sum_to(a, a.len() as int)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "dafny-synthesis_task_id_230_ReplaceBlanksWithChar", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn replace_blanks_with_char(s: Seq<char>, ch: char) -> (v: Seq<char>)\n    ensures \n        v.len() == s.len(),\n        forall|i: int| 0 <= i < s.len() ==> {\n            (s[i] == ' ' ==> v[i] == ch) &&\n            (s[i] != ' ' ==> v[i] == s[i])\n        }\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    s\n}\n// </vc-code>", "vc-postamble": "fn main() {}\n\n}"}
{"id": "dafny-synthesis_task_id_618_ElementWiseDivide", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn element_wise_divide(a: Seq<int>, b: Seq<int>) -> (result: Seq<int>)\n    requires \n        a.len() == b.len(),\n        forall|i: int| 0 <= i < b.len() ==> b[i] != 0,\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] / b[i],\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    a\n}\n// </vc-code>", "vc-postamble": "\nfn main() {\n}\n\n}"}
{"id": "Dafny_Verify_tmp_tmphq7j0row_dataset_bql_exampls_SmallNum_add_small_numbers", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfn add_small_numbers(a: &[i32], n: usize, max: i32) -> (r: i32)\n    requires \n        n > 0,\n        n <= a.len(),\n        forall|i: int| 0 <= i && i < n ==> a[i] <= max,\n    ensures\n        r <= max * (n as i32),\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n    assume(false);\n    0  // Need to return a value\n}\n// </vc-code>", "vc-postamble": "fn main() {\n}\n\n}"}
