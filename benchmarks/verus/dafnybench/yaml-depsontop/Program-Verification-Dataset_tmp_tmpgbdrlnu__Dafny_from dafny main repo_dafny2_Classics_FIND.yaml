vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  // RUN: %testDafnyForEachResolver "%s" -- --warn-deprecation:false
  
  
  // A version of Turing's additive factorial program [Dr. A. Turing, "Checking a large routine",
  // In "Report of a Conference of High Speed Automatic Calculating Machines", pp. 67-69, 1949].
  
  spec fn factorial(n: nat) -> nat
      decreases n
  {
      if n == 0 { 1 } else { n * factorial(sub(n, 1)) }
  }
  
  
  // Hoare's FIND program [C.A.R. Hoare, "Proof of a program: FIND", CACM 14(1): 39-45, 1971].
  // The proof annotations here are not the same as in Hoare's article.
  
  // In Hoare's words:
  //   This program operates on an array A[1:N], and a value of f (1 <= f <= N).
  //   Its effect is to rearrange the elements of A in such a way that:
  //     forall p,q (1 <= p <= f <= q <= N ==> A[p] <= A[f] <= A[q]).
  //
  // Here, we use 0-based indices, so we would say:
  //   This method operates on an array A[0..N], and a value of f (0 <= f < N).
  //   Its effect is to rearrange the elements of A in such a way that:
  //     forall p,q :: 0 <= p <= f <= q < N ==> A[p] <= A[f] <= A[q]).

vc-helpers: |-
  // <vc-helpers>
  // </vc-helpers>

vc-spec: |-
  // <vc-spec>
  fn find(A: &mut Vec<i32>, N: usize, f: usize)
      requires 
          old(A)@.len() == N,
          f < N,
      ensures
          forall|p: int, q: int| 0 <= p <= f as int <= q < N as int ==> A@[p] <= A@[q],
  // </vc-spec>

vc-code: |-
  // <vc-code>
  {
      assume(false);
  }
  // </vc-code>

vc-postamble: |-
  
  fn main() {}
  
  }