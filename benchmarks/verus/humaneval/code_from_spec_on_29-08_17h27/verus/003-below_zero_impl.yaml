vc-preamble: |-
  
  use vstd::prelude::*;
  
  verus! {
  
  spec fn sum(s: Seq<int>) -> (result:int)
      decreases s.len(),
  {
      if s.len() == 0 {
          0
      } else {
          s[0] + sum(s.skip(1))
      }
  }
  // pure-end
  // pure-end
  
  spec fn sum_other_way(s: Seq<int>) -> (result:int)
      decreases s.len(),
  {
      if s.len() == 0 {
          0
      } else {
          s[s.len() - 1] + sum_other_way(s.take(s.len() - 1))
      }
  }
  // pure-end

vc-helpers: |-


vc-description: |-
  function_signature: "def below_zero(operations: List[int]) -> bool"
  docstring: |
  You're given a list of deposit and withdrawal operations on a bank account that starts with
  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and
  at that point function should return True. Otherwise it should return False.
  test_cases:
  - input:
  - 1
  - 2
  - 3
  expected_output: false
  - input:
  - 1
  - 2
  - -4
  - 5
  expected_output: true

vc-spec: |-
  fn below_zero(operations: Vec<i32>) -> (result: bool)
      // pre-conditions-start
      requires
          forall|i: int|
              0 <= i <= operations@.len() ==> sum(operations@.take(i).map(|_idx, j: i32| j as int))
                  <= i32::MAX,
      // pre-conditions-end
      // post-conditions-start
      ensures
          result <==> exists|i: int|
              0 <= i <= operations@.len() && sum(operations@.take(i).map(|_idx, j: i32| j as int))
                  < 0,
      // post-conditions-end

vc-code: |-
  {
      // impl-start
      assume(false);
      false
      // impl-end
  }

vc-postamble: |-
  
  }
  fn main() {}

