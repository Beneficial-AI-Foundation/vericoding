vc-description: |-
  /--
  function_signature: "fn smallest_missing_number(s: &[i32]) -> (v: i32)"
  docstring: Implement smallest missing number functionality.
  -/

vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {

vc-helpers: |-
  spec fn contains_value(s: &[i32], val: int) -> bool {
      exists|i: int| 0 <= i < s.len() && s[i] == val
  }
  
  proof fn lemma_sorted_property(s: &[i32], target: int)
      requires
          forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] <= s[j],
          forall|i: int| 0 <= i < s.len() ==> s[i] >= 0,
      ensures
          forall|i: int| 0 <= i < s.len() && s[i] > target ==> 
              forall|j: int| i <= j < s.len() ==> s[j] >= s[i]
  {
  }
  
  proof fn lemma_missing_number_exists(s: &[i32])
      requires
          forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] <= s[j],
          forall|i: int| 0 <= i < s.len() ==> s[i] >= 0,
          s.len() <= 100_000,
      ensures
          exists|v: int| v >= 0 && 
              (forall|i: int| 0 <= i < s.len() ==> s[i] != v) &&
              #[trigger] (forall|k: int| 0 <= k < v ==> #[trigger] exists|j: int| 0 <= j < s.len() && s[j] == k)
  {
      if s.len() == 0 {
          assert(forall|k: int| 0 <= k < 0 ==> exists|j: int| 0 <= j < s.len() && s[j] == k);
      } else {
          let candidate = s.len() as int;
          if forall|i: int| 0 <= i < s.len() ==> s[i] != candidate {
              if forall|k: int| 0 <= k < candidate ==> exists|j: int| 0 <= j < s.len() && s[j] == k {
                  assert(candidate >= 0);
              }
          }
      }
  }

vc-spec: |-
  #[verifier::loop_isolation(false)]
  fn smallest_missing_number(s: &[i32]) -> (v: i32)
      // pre-conditions-start
      requires
          forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] <= s[j],
          forall|i: int| 0 <= i < s.len() ==> s[i] >= 0,
          s.len() <= 100_000,
      // pre-conditions-end
      // post-conditions-start
      ensures
          0 <= v,
          forall|i: int| 0 <= i < s.len() ==> s[i] != v,
          forall|k: int| 0 <= k < v && s[k] != v ==> exists|j: int| 0 <= j < s.len() && s[j] == k,
      // post-conditions-end

vc-code: |-
  {
      let mut current = 0i32;
      let mut i = 0;
      
      while i < s.len()
          invariant
              0 <= i <= s.len(),
              current >= 0,
              #[trigger] forall|k: int| 0 <= k < current ==> #[trigger] exists|j: int| 0 <= j < s.len() && s[j] == k,
              i > 0 ==> current <= s[i - 1] + 1,
              forall|j: int| 0 <= j < i ==> s[j] < current || s[j] == current,
          decreases s.len() - i
      {
          if s[i] == current {
              current = current + 1;
          } else if s[i] > current {
              assert(forall|j: int| 0 <= j < s.len() ==> s[j] != current);
              return current;
          }
          i = i + 1;
      }
      
      assert(forall|j: int| 0 <= j < s.len() ==> s[j] != current);
      current
  }

vc-postamble: |-
  
  fn main() {}
  }

