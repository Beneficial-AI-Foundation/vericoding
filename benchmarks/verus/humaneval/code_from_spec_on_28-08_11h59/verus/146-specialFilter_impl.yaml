vc-description: |-
  /--
  function_signature: "def specialFilter(nums: List[int]) -> int"
  docstring: |
      Write a function that takes an array of numbers as input and returns
      the number of elements in the array that are greater than 10 and both
      first and last digits of a number are odd (1, 3, 5, 7, 9).
  test_cases:
    - input: [15, -73, 14, -15]
      expected_output: 1
    - input: [33, -2, -3, 45, 21, 109]
      expected_output: 2
  -/

vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn extract_first_digit_spec(n: int) -> (ret:int)
      decreases n,
  {
      if n < 10 {
          n
      } else {
          extract_first_digit_spec(n / 10)
      }
  }
  // pure-end
  spec fn extract_last_digit_spec(n: int) -> (ret:int) {
      n % 10
  }
  // pure-end
  spec fn is_odd(n: int) -> (ret:bool) {
      (n % 2) != 0
  }
  // pure-end
  // pure-end
  
  
  spec fn is_valid_element_spec(n: int) -> (ret:bool) {
      &&& (n > 10)
      &&& is_odd(extract_first_digit_spec(n))
      &&& is_odd(extract_last_digit_spec(n))
  }
  // pure-end
  spec fn special_filter_spec(seq: Seq<i32>) -> (ret:int)
      decreases seq.len(),
  {
      if seq.len() == 0 {
          0
      } else {
          special_filter_spec(seq.drop_last()) + if (is_valid_element_spec(seq.last() as int)) {
              1 as int
          } else {
              0 as int
          }
      }
  }
  // pure-end

vc-helpers: |-
  fn extract_first_digit(n: u32) -> (res: u32)
      decreases n,
      ensures
          res == extract_first_digit_spec(n as int),
  {
      if n < 10 {
          n
      } else {
          extract_first_digit(n / 10)
      }
  }
  
  fn extract_last_digit(n: u32) -> (res: u32)
      ensures
          res == extract_last_digit_spec(n as int),
  {
      n % 10
  }
  
  fn is_valid_element(n: i32) -> (res: bool)
      ensures
          res == is_valid_element_spec(n as int),
  {
      ((n > 10) && (extract_first_digit(n as u32) % 2 != 0) && (extract_last_digit(n as u32) % 2 != 0))
  }
  
  proof fn special_filter_spec_extensionality(seq1: Seq<i32>, seq2: Seq<i32>)
      requires seq1 =~= seq2,
      ensures special_filter_spec(seq1) == special_filter_spec(seq2),
  {
  }
  
  proof fn special_filter_spec_push_lemma(seq: Seq<i32>, elem: i32)
      ensures special_filter_spec(seq.push(elem)) == special_filter_spec(seq) + if is_valid_element_spec(elem as int) { 1int } else { 0int },
  {
  }

vc-spec: |-
  fn special_filter(numbers: &Vec<i32>) -> (count: usize)
      // post-conditions-start
      ensures
          count == special_filter_spec(numbers@),
      // post-conditions-end

vc-code: |-
  {
      let mut count: usize = 0;
      let mut i: usize = 0;
      
      while i < numbers.len()
          invariant
              i <= numbers.len(),
              count == special_filter_spec(numbers@.subrange(0, i as int)),
      {
          if is_valid_element(numbers[i]) {
              count = count + 1;
          }
          
          proof {
              special_filter_spec_push_lemma(numbers@.subrange(0, i as int), numbers@[i as int]);
          }
          
          i = i + 1;
      }
      
      proof {
          assert(numbers@.subrange(0, i as int) =~= numbers@);
          special_filter_spec_extensionality(numbers@.subrange(0, i as int), numbers@);
      }
      
      count
  }

vc-postamble: |-
  
  } // verus!
  fn main() {}

