vc-description: |-
  /--
  function_signature: "def encode_shift(s: String) -> String"
  docstring: |
      returns encoded string by shifting every character by 5 in the alphabet.
  test_cases:
    - input: abc
      expected_output: fgh
    - input: xyz
      expected_output: cde
    - input: aaa
      expected_output: fff
  -/

vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn encode_char_spec(c: int) -> (result:int)
      recommends
          65 <= c <= 90,
  {
      (c - 65 + 5) % 26 + 65
  }
  // pure-end
  spec fn decode_char_spec(c: int) -> (result:int)
      recommends
          65 <= c <= 90,
  {
      (c - 65 + 26 - 5) % 26 + 65
  }
  // pure-end

vc-helpers: |-
  fn encode_char(c: u8) -> (r: u8)
      // pre-conditions-start
      requires
          65 <= c <= 90,
      // pre-conditions-end
      // post-conditions-start
      ensures
          r == encode_char_spec(c as int),
          65 <= r <= 90,
      // post-conditions-end
  {
      (c - 65 + 5) % 26 + 65
  }
  
  fn decode_char(c: u8) -> (r: u8)
      // pre-conditions-start
      requires
          65 <= c <= 90,
      // pre-conditions-end
      // post-conditions-start
      ensures
          r == decode_char_spec(c as int),
          65 <= r <= 90,
      // post-conditions-end
  {
      // impl-start
      (c - 65 + 26 - 5) % 26 + 65
      // impl-end
  }
  
  #[verifier::loop_isolation(false)]
  fn encode_shift(s: &Vec<u8>) -> (t: Vec<u8>)
      // pre-conditions-start
      requires
          forall|i: int| #![trigger s[i]] 0 <= i < s.len() ==> 65 <= s[i] <= 90,
      // pre-conditions-end
      // post-conditions-start
      ensures
          s.len() == t.len(),
          forall|i: int| #![auto] 0 <= i < t.len() ==> t[i] == encode_char_spec(s[i] as int),
          forall|i: int| #![auto] 0 <= i < t.len() ==> decode_char_spec(t[i] as int) == s[i],
      // post-conditions-end
  {
      // impl-start
      let mut t: Vec<u8> = vec![];
      for i in 0..s.len()
          // invariants-start
          invariant
              t.len() == i,
              forall|j: int| #![auto] 0 <= j < i ==> t[j] == encode_char_spec(s[j] as int),
              forall|j: int| #![auto] 0 <= j < i ==> decode_char_spec(t[j] as int) == s[j],
          // invariants-end
      {
          t.push(encode_char(s[i]));
          // assert-start
          proof {
              opposite_encode_decode(s[i as int] as int);
          }
          // assert-end
      }
      t
      // impl-end
  }
  
  proof fn opposite_encode_decode(c: int)
      // pre-conditions-start
      requires
          65 <= c <= 90,
      // pre-conditions-end
      // post-conditions-start
      ensures
          encode_char_spec(decode_char_spec(c)) == c,
          decode_char_spec(encode_char_spec(c)) == c,
      // post-conditions-end
  {
      use vstd::arithmetic::mul::*;
      
      let encoded = encode_char_spec(c);
      let decoded = decode_char_spec(c);
      
      assert(encoded == (c - 65 + 5) % 26 + 65);
      assert(decoded == (c - 65 + 26 - 5) % 26 + 65);
      
      // For decode_char_spec(encoded)
      assert(decode_char_spec(encoded) == ((c - 65 + 5) % 26 + 65 - 65 + 26 - 5) % 26 + 65);
      assert(decode_char_spec(encoded) == ((c - 65 + 5) % 26 + 21) % 26 + 65);
      
      // Since (c - 65 + 5) % 26 is in range [0, 25], and 21 + 25 < 26*2
      assert(0 <= (c - 65 + 5) % 26 < 26);
      assert(0 <= (c - 65 + 5) % 26 + 21 < 47);
      assert(((c - 65 + 5) % 26 + 21) % 26 == (c - 65 + 5 + 21) % 26);
      
      assert(decode_char_spec(encoded) == (c - 65 + 26) % 26 + 65);
      assert((c - 65 + 26) % 26 == (c - 65) % 26);
      assert(decode_char_spec(encoded) == (c - 65) % 26 + 65);
      
      // Since 65 <= c <= 90, we have 0 <= c - 65 <= 25 < 26
      assert(0 <= c - 65 <= 25);
      assert((c - 65) % 26 == c - 65);
      assert(decode_char_spec(encoded) == c - 65 + 65);
      assert(decode_char_spec(encoded) == c);
      
      // For encode_char_spec(decoded)
      assert(encode_char_spec(decoded) == ((c - 65 + 21) % 26 + 65 - 65 + 5) % 26 + 65);
      assert(encode_char_spec(decoded) == ((c - 65 + 21) % 26 + 5) % 26 + 65);
      
      // Since (c - 65 + 21) % 26 is in range [0, 25], and 5 + 25 < 26*2
      assert(0 <= (c - 65 + 21) % 26 < 26);
      assert(0 <= (c - 65 + 21) % 26 + 5 < 31);
      assert(((c - 65 + 21) % 26 + 5) % 26 == (c - 65 + 21 + 5) % 26);
      
      assert(encode_char_spec(decoded) == (c - 65 + 26) % 26 + 65);
      assert((c - 65 + 26) % 26 == (c - 65) % 26);
      assert(encode_char_spec(decoded) == (c - 65) % 26 + 65);
      
      // Since 0 <= c - 65 <= 25 < 26
      assert((c - 65) % 26 == c - 65);
      assert(encode_char_spec(decoded) == c - 65 + 65);
      assert(encode_char_spec(decoded) == c);
  }

vc-spec: |-
  #[verifier::loop_isolation(false)]
  fn decode_shift(s: &Vec<u8>) -> (t: Vec<u8>)
      // pre-conditions-start
      requires
          forall|i: int| #![trigger s[i]] 0 <= i < s.len() ==> 65 <= s[i] <= 90,
      // pre-conditions-end
      // post-conditions-start
      ensures
          s.len() == t.len(),
          forall|i: int| #![auto] 0 <= i < t.len() ==> t[i] == decode_char_spec(s[i] as int),
          forall|i: int| #![auto] 0 <= i < t.len() ==> encode_char_spec(t[i] as int) == s[i],
      // post-conditions-end

vc-code: |-
  {
      // impl-start
      let mut t: Vec<u8> = vec![];
      for i in 0..s.len()
          // invariants-start
          invariant
              t.len() == i,
              forall|j: int| #![auto] 0 <= j < i ==> t[j] == decode_char_spec(s[j] as int),
              forall|j: int| #![auto] 0 <= j < i ==> encode_char_spec(t[j] as int) == s[j],
          // invariants-end
      {
          t.push(decode_char(s[i]));
          // assert-start
          proof {
              opposite_encode_decode(s[i as int] as int);
          }
          // assert-end
      }
      t
      // impl-end
  }

vc-postamble: |-
  
  }
  fn main() {}

