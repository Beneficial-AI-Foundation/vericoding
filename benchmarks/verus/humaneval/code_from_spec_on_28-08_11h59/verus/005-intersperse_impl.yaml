vc-description: |-
  /--
  function_signature: "def intersperse(numbers: List[int], delimeter: int) -> List[int]"
  docstring: |
      Insert a number 'delimeter' between every two consecutive elements of input list `numbers'
  test_cases:
    - input:
        - []
        - 4
      expected_output: []
    - input:
        - [1, 2, 3]
        - 4
      expected_output: [1, 4, 2, 4, 3]
  -/

vc-preamble: |-
  use vstd::assert_seqs_equal;
  use vstd::prelude::*;
  
  verus! {
  
  spec fn intersperse_spec(numbers: Seq<u64>, delimiter: u64) -> (result:Seq<u64>)
      decreases numbers.len(),
  {
      if numbers.len() <= 1 {
          numbers
      } else {
          intersperse_spec(numbers.drop_last(), delimiter) + seq![delimiter, numbers.last()]
      }
  }
  // pure-end
  // pure-end
  
  spec fn even(i: int) -> (result:int) {
      2 * i
  }
  // pure-end
  // pure-end
  
  spec fn odd(i: int) -> (result:int) {
      2 * i + 1
  }
  // pure-end
  // pure-end
  
  spec fn intersperse_quantified(numbers: Seq<u64>, delimiter: u64, interspersed: Seq<u64>) -> (result:bool) {
      (if numbers.len() == 0 {
          interspersed.len() == 0
      } else {
          interspersed.len() == 2 * numbers.len() - 1
      }) && (forall|i: int| 0 <= i < numbers.len() ==> #[trigger] interspersed[even(i)] == numbers[i])
          && (forall|i: int|
          0 <= i < numbers.len() - 1 ==> #[trigger] interspersed[odd(i)] == delimiter)
  }
  // pure-end

vc-helpers: |-
  proof fn intersperse_spec_len(numbers: Seq<u64>, delimiter: u64)
      ensures
          numbers.len() > 0 ==> intersperse_spec(numbers, delimiter).len() == 2 * numbers.len() - 1,
      decreases numbers.len(),
  {
      if numbers.len() > 0 {
          intersperse_spec_len(numbers.drop_last(), delimiter);
      }
  }
  
  proof fn intersperse_quantified_is_spec(numbers: Seq<u64>, delimiter: u64, interspersed: Seq<u64>)
      requires
          intersperse_quantified(numbers, delimiter, interspersed),
      ensures
          interspersed == intersperse_spec(numbers, delimiter),
      decreases numbers.len(),
  {
      let is = intersperse_spec(numbers, delimiter);
      if numbers.len() == 0 {
      } else if numbers.len() == 1 {
          assert(interspersed.len() == 1);
          assert(interspersed[even(0)] == numbers[0]);
      } else {
          intersperse_quantified_is_spec(
              numbers.drop_last(),
              delimiter,
              interspersed.take(interspersed.len() - 2),
          );
          intersperse_spec_len(numbers, delimiter);
          assert_seqs_equal!(is == interspersed, i => {
              if i < is.len() - 2 {
              } else {
                  if i % 2 == 0 {
                      assert(is[i] == numbers.last());
                      assert(interspersed[even(i/2)] == numbers[i / 2]);
                      assert(i / 2 == numbers.len() - 1);
                  } else {
                      assert(is[i] == delimiter);
                      assert(interspersed[odd((i-1)/2)] == delimiter);
                  }
              }
          });
      }
      assert(interspersed =~= intersperse_spec(numbers, delimiter));
  }
  
  proof fn intersperse_correctness(numbers: Vec<u64>, delimiter: u64, result: Vec<u64>)
      requires
          result.len() == if numbers.len() == 0 { 0 } else { 2 * numbers.len() - 1 },
          forall|i: int| 0 <= i < numbers.len() ==> result@[even(i)] == numbers@[i],
          forall|i: int| 0 <= i < numbers.len() - 1 ==> result@[odd(i)] == delimiter,
      ensures
          result@ == intersperse_spec(numbers@, delimiter),
  {
      assert(intersperse_quantified(numbers@, delimiter, result@));
      intersperse_quantified_is_spec(numbers@, delimiter, result@);
  }

vc-spec: |-
  fn intersperse(numbers: Vec<u64>, delimiter: u64) -> (result: Vec<u64>)
      // post-conditions-start
      ensures
          result@ == intersperse_spec(numbers@, delimiter),
      // post-conditions-end

vc-code: |-
  {
      if numbers.len() == 0 {
          return vec![];
      }
      
      if numbers.len() == 1 {
          return numbers;
      }
      
      let capacity = 2 * numbers.len() - 1;
      let mut result = Vec::with_capacity(capacity);
      
      let mut i = 0;
      while i < numbers.len()
          invariant
              0 <= i <= numbers.len(),
              numbers.len() > 1,
              result.len() == if i == 0 { 0 } else { 2 * i - 1 },
              forall|j: int| 0 <= j < i ==> result@[even(j)] == numbers@[j],
              forall|j: int| 0 <= j < i - 1 ==> result@[odd(j)] == delimiter,
          decreases numbers.len() - i,
      {
          if i > 0 {
              result.push(delimiter);
          }
          result.push(numbers[i]);
          i = i + 1;
      }
      
      proof {
          intersperse_correctness(numbers, delimiter, result);
      }
      
      result
  }

vc-postamble: |-
  
  }
  fn main() {}

