vc-description: |-
  /--
  function_signature: "fn largest_prime_factor(n: u32) -> (result: u32)"
  docstring: Find the largest prime factor of a given number.
  -/

vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn is_prime_pred(n: u32) -> (ret: bool) {
      forall|k: int| 2 <= k < n ==> #[trigger] (n as int % k) != 0
  }

vc-helpers: |-
  #[verifier::loop_isolation(false)]
  fn is_prime(n: u32) -> (result: bool)
      requires
          n >= 2,
      ensures
          result ==> (forall|k: int| 2 <= k < n ==> #[trigger] (n as int % k) != 0),
          !result ==> exists|k: int| 2 <= k < n && #[trigger] (n as int % k) == 0,
  {
      let mut i = 2;
      let mut result = true;
      while i < n
          invariant
              2 <= i <= n,
              result ==> forall|k: int| 2 <= k < i ==> #[trigger] (n as int % k) != 0,
              !result ==> exists|k: int| 2 <= k < i && #[trigger] (n as int % k) == 0,
          decreases n - i
      {
          if n % i == 0 {
              result = false;
          }
          i = i + 1;
      }
      result
  }
  
  spec fn divides(a: int, b: int) -> bool {
      b % a == 0
  }
  
  proof fn prime_factor_is_prime(n: u32, f: u32)
      requires 
          2 <= n,
          2 <= f <= n,
          divides(f as int, n as int),
          forall|k: int| 2 <= k < f ==> !divides(k, f as int),
      ensures
          is_prime_pred(f)
  {
      assert(forall|k: int| 2 <= k < f ==> (f as int % k) != 0) by {
          assert(forall|k: int| 2 <= k < f ==> !divides(k, f as int));
      }
  }
  
  proof fn smallest_factor_is_prime(n: u32, f: u32)
      requires
          2 <= f <= n,
          divides(f as int, n as int),
          forall|k: int| 2 <= k < f ==> !divides(k, n as int),
      ensures
          is_prime_pred(f)
  {
      assert(forall|k: int| 2 <= k < f ==> (f as int % k) != 0) by {
          forall|k: int| 2 <= k < f implies (f as int % k) != 0 by {
              if f as int % k == 0 {
                  assert(divides(k, f as int));
                  assert(divides(k, n as int)) by {
                      let q = f as int / k;
                      let r = n as int / f as int;
                      assert(n as int == f as int * r);
                      assert(f as int == k * q);
                      assert(n as int == k * q * r);
                  }
                  assert(false);
              }
          }
      }
  }
  
  proof fn temp_prime_implies_result(n: u32, temp: u32, i: u32)
      requires
          2 <= n,
          2 <= temp <= n,
          2 <= i,
          (i as u64) * (i as u64) > (temp as u64),
          forall|k: int| 2 <= k < i ==> !divides(k, temp as int),
      ensures
          is_prime_pred(temp)
  {
      assert(forall|k: int| 2 <= k < temp ==> (temp as int % k) != 0) by {
          forall|k: int| 2 <= k < temp implies (temp as int % k) != 0 by {
              if k < i {
                  assert(!divides(k, temp as int));
              } else {
                  assert(k >= i);
                  assert(k * k >= i * i > temp);
                  if temp as int % k == 0 {
                      let q = temp as int / k;
                      assert(temp as int == k * q);
                      if q >= k {
                          assert(temp as int >= k * k > temp as int);
                          assert(false);
                      } else {
                          assert(2 <= q < k < temp);
                          assert(divides(q, temp as int));
                          assert(q < i);
                          assert(!divides(q, temp as int));
                          assert(false);
                      }
                  }
              }
          }
      }
  }

vc-spec: |-
  #[verifier::loop_isolation(false)]
  fn largest_prime_factor(n: u32) -> (result: u32)
      requires
          2 <= n <= u32::MAX - 1,
      ensures
          1 <= result <= n,
          result == 1 || (result > 1 && is_prime_pred(result))

vc-code: |-
  {
      let mut factor = 1;
      let mut temp = n;
      let mut i = 2;
      
      while i <= temp && (i as u64) * (i as u64) <= (temp as u64)
          invariant
              1 <= factor <= n,
              2 <= i,
              2 <= temp <= n,
              factor == 1 || (factor > 1 && divides(factor as int, n as int)),
              forall|k: int| 2 <= k < i ==> !divides(k, temp as int),
          decreases temp
      {
          if temp % i == 0 {
              factor = i;
              while temp % i == 0 && temp > 1
                  invariant
                      2 <= temp,
                      temp == 1 || divides(i as int, temp as int),
                  decreases temp
              {
                  temp = temp / i;
              }
          }
          i = i + 1;
      }
      
      if temp > 1 {
          factor = temp;
          proof {
              temp_prime_implies_result(n, temp, i);
          }
      } else if factor > 1 {
          proof {
              smallest_factor_is_prime(n, factor);
          }
      }
      
      factor
  }

vc-postamble: |-
  
  fn main() {}
  }

