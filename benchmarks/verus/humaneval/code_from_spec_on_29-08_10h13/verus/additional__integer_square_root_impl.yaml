vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {

vc-helpers: |-
  proof fn lemma_sqrt_bounds(n: i32, r: i32)
      requires
          n >= 1,
          0 <= r,
          r * r <= n,
          n < (r + 1) * (r + 1)
      ensures
          r >= 0
  {
  }
  
  proof fn lemma_monotonic_square(a: i32, b: i32)
      requires
          0 <= a <= b
      ensures
          a * a <= b * b
  {
      /* code modified by LLM (iteration 4): added proper proof for monotonicity */
      if a == b {
          assert(a * a == b * b);
      } else {
          assert(a < b);
          assert(a >= 0);
          assert(b > 0);
          assert(a * a <= a * b) by {
              assert(a <= b);
              if a == 0 {
                  assert(a * a == 0);
                  assert(a * b == 0);
              } else {
                  assert(a > 0);
              }
          };
          assert(a * b <= b * b) by {
              assert(a <= b);
              if b == 0 {
                  assert(a == 0);
                  assert(a * b == 0);
                  assert(b * b == 0);
              } else {
                  assert(b > 0);
              }
          };
      }
  }
  
  proof fn lemma_overflow_bounds(r: i32, n: i32)
      requires
          n >= 1,
          0 <= r <= 46340,
          r * r <= n
      ensures
          (r + 1) * (r + 1) >= 0
  {
      /* code modified by LLM (iteration 4): strengthened overflow bounds proof */
      assert(r + 1 <= 46341);
      assert(46341 * 46341 <= 2147395281i32);
  }

vc-description: |-
  function_signature: "fn integer_square_root(n: i32) -> (result: i32)"
  docstring: Implement integer square root functionality.

vc-spec: |-
  fn integer_square_root(n: i32) -> (result: i32)
      // pre-conditions-start
      requires
          n >= 1,
      // pre-conditions-end
      // post-conditions-start
      ensures
          0 <= result * result,
          result * result <= n,
          n < (result + 1) * (result + 1)
      // post-conditions-end

vc-code: |-
  {
      /* code modified by LLM (iteration 5): fixed type annotation for literal */
      let mut result: i32 = 0;
      
      while result <= 46340
          invariant
              result >= 0,
              result * result <= n,
              result <= 46340
          decreases 46340 - result
      {
          let next_result = result + 1;
          if next_result <= 46340 && next_result <= 2147483647i32 / next_result && next_result * next_result <= n {
              result = next_result;
          } else {
              break;
          }
      }
      
      /* code modified by LLM (iteration 5): updated postcondition proof with correct type annotations */
      proof {
          lemma_overflow_bounds(result, n);
          assert(result * result <= n);
          
          if result < 46340 {
              let next = result + 1;
              if next <= 46340 && next <= 2147483647i32 / next {
                  assert(next * next <= 2147483647i32);
                  assert(next * next > n) by {
                      assert(!(next * next <= n));
                  };
              } else {
                  if next > 46340 {
                      assert(next > 46340);
                      assert(next * next > 46340 * 46340);
                      assert(46340 * 46340 > n) by {
                          assert(result <= 46340);
                          assert(result * result <= n);
                          assert(next == result + 1);
                          assert(next > 46340);
                      };
                  } else {
                      assert(next > 2147483647i32 / next);
                      assert(next * next > 2147483647i32);
                      assert(n <= 2147483647i32);
                      assert(next * next > n);
                  }
              }
              assert(n < (result + 1) * (result + 1));
          } else {
              assert(result == 46340);
              let next = result + 1;
              assert(next == 46341);
              assert(next * next > 46340 * 46340);
              assert(result * result <= n);
              assert(n >= 1);
              assert(next * next > n);
              assert(n < (result + 1) * (result + 1));
          }
      }
      
      result
  }

vc-postamble: |-
  
  fn main() {}
  }

