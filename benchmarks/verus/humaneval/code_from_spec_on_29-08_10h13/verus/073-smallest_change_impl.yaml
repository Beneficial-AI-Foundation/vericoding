vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn zip_halves<T>(v: Seq<T>) -> (ret: Seq<(T, T)>) {
      v.take((v.len() / 2) as int).zip_with(v.skip(((v.len() + 1) / 2) as int).reverse())
  }
  // pure-end
  // pure-end
  
  spec fn diff(s: Seq<(i32, i32)>) -> (ret: int) {
      s.fold_left(
          0,
          |acc: int, x: (i32, i32)|
              if (x.0 != x.1) {
                  acc + 1
              } else {
                  acc
              },
      )
  }
  // pure-end

vc-helpers: |-
  proof fn zip_halves_len<T>(v: Seq<T>)
      ensures zip_halves(v).len() == (v.len() / 2) as int
  {
  }
  
  proof fn zip_halves_index<T>(v: Seq<T>, i: int)
      requires 0 <= i < zip_halves(v).len()
      ensures 
          zip_halves(v)[i].0 == v[i],
          zip_halves(v)[i].1 == v[v.len() - 1 - i]
  {
  }
  
  proof fn diff_empty()
      ensures diff(Seq::<(i32, i32)>::empty()) == 0
  {
  }
  
  proof fn diff_push(s: Seq<(i32, i32)>, x: (i32, i32))
      ensures diff(s.push(x)) == diff(s) + if x.0 != x.1 { 1int } else { 0int }
  {
  }
  
  proof fn diff_build_lemma(v: Seq<i32>, i: int, acc: int, result_seq: Seq<(i32, i32)>)
      requires 
          0 <= i <= (v.len() / 2) as int,
          result_seq.len() == i,
          forall |j: int| 0 <= j < i ==> result_seq[j] == (v[j], v[v.len() - 1 - j]),
          acc == diff(result_seq)
      ensures
          if i == (v.len() / 2) as int {
              acc == diff(zip_halves(v))
          } else {
              let new_pair = (v[i], v[v.len() - 1 - i]);
              let new_seq = result_seq.push(new_pair);
              let new_acc = acc + if new_pair.0 != new_pair.1 { 1int } else { 0int };
              new_acc == diff(new_seq)
          }
  {
      if i == (v.len() / 2) as int {
          assert(result_seq =~= zip_halves(v)) by {
              assert(result_seq.len() == zip_halves(v).len()) by {
                  zip_halves_len(v);
              }
              assert(forall |j: int| 0 <= j < result_seq.len() ==> result_seq[j] == zip_halves(v)[j]) by {
                  assert forall |j: int| 0 <= j < result_seq.len() implies result_seq[j] == zip_halves(v)[j] by {
                      zip_halves_index(v, j);
                  }
              }
          }
      } else {
          diff_push(result_seq, (v[i], v[v.len() - 1 - i]));
      }
  }
  
  proof fn zip_with_take_skip_lemma(v: Seq<i32>, i: int)
      requires 0 <= i < v.len() / 2, v.len() > 0
      ensures 
          v.take(i as int).zip_with(v.skip((v.len() - i) as int).reverse()).push((v[i], v[v.len() - 1 - i])) =~=
          v.take((i + 1) as int).zip_with(v.skip((v.len() - i - 1) as int).reverse())
  {
  }

vc-description: |-
  function_signature: "def smallest_change(arr: List[int]) -> int"
  docstring: |
  Given an array arr of integers, find the minimum number of elements that
  need to be changed to make the array palindromic. A palindromic array is an array that
  is read the same backwards and forwards. In one change, you can change one element to any other element.
  test_cases:
  - input: [1,2,3,5,4,7,9,6]
  expected_output: 4
  - input: [1, 2, 3, 4, 3, 2, 2]
  expected_output: 1
  - input: [1, 2, 3, 2, 1]
  expected_output: 0

vc-spec: |-
  fn smallest_change(v: Vec<i32>) -> (change: usize)
      // pre-conditions-start
      requires
          v@.len() < usize::MAX,
      // pre-conditions-end
      // post-conditions-start
      ensures
          change == diff(zip_halves(v@)),
      // post-conditions-end

vc-code: |-
  {
      let len = v.len();
      let half = len / 2;
      let mut change: usize = 0;
      let mut i = 0;
      
      /* code modified by LLM (iteration 5): fixed invariant and overflow check */
      while i < half
          invariant
              0 <= i <= half,
              half == len / 2,
              len == v@.len(),
              change <= half,
              change as int == diff(v@.take(i as int).zip_with(v@.skip((len - i) as int).reverse())),
          decreases half - i
      {
          let left = v[i];
          let right = v[len - 1 - i];
          
          /* code modified by LLM (iteration 5): simplified increment */
          if left != right {
              change = change + 1;
          }
          
          proof {
              let old_seq = v@.take(i as int).zip_with(v@.skip((len - i) as int).reverse());
              let new_seq = v@.take((i + 1) as int).zip_with(v@.skip((len - i - 1) as int).reverse());
              
              diff_push(old_seq, (left, right));
              if i < v@.len() / 2 && v@.len() > 0 {
                  zip_with_take_skip_lemma(v@, i as int);
              }
              
              assert(new_seq =~= old_seq.push((left, right)));
          }
          
          i = i + 1;
      }
      
      proof {
          assert(v@.take(half as int) =~= v@.take((v@.len() / 2) as int));
          assert(v@.skip((len - half) as int) =~= v@.skip(((v@.len() + 1) / 2) as int));
          assert(change as int == diff(zip_halves(v@)));
      }
      
      change
  }

vc-postamble: |-
  
  }
  fn main() {}

