vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn spec_sum(s: Seq<nat>) -> (ret: int) {
      s.fold_left(0, |x: int, y| x + y)
  }
  // pure-end
  // pure-end
  
  spec fn total_str_len(strings: Seq<&str>) -> (ret: int) {
      spec_sum(strings.map_values(|s: &str| s@.len()))
  }
  // pure-end
  spec fn inner_expr_total_match<'a>(lst1: Vec<&'a str>, lst2: Vec<&'a str>, ret: Option<Vec<&'a str>>) -> (ret:bool) {
      ret.is_some() ==> ret.unwrap() == if total_str_len(lst1@) <= total_str_len(lst2@) {
          lst1
      } else {
          lst2
      }
  }
  // pure-end

vc-helpers: |-
  proof fn lemma_fold_left_nonneg(s: Seq<nat>)
      ensures spec_sum(s) >= 0
  {
      let f = |x: int, y: nat| x + y;
      if s.len() == 0 {
      } else {
          lemma_fold_left_nonneg(s.drop_last());
          assert(spec_sum(s) == spec_sum(s.drop_last()) + s.last());
      }
  }
  
  proof fn lemma_total_str_len_nonneg(strings: Seq<&str>)
      ensures total_str_len(strings) >= 0
  {
      lemma_fold_left_nonneg(strings.map_values(|s: &str| s@.len()));
  }
  
  proof fn lemma_spec_sum_bounded(s: Seq<nat>, bound: nat)
      requires forall|i: int| 0 <= i < s.len() ==> s[i] <= bound,
      requires s.len() <= usize::MAX,
      ensures spec_sum(s) <= s.len() * bound
  {
      let f = |x: int, y: nat| x + y;
      if s.len() == 0 {
      } else {
          lemma_spec_sum_bounded(s.drop_last(), bound);
          assert(spec_sum(s) == spec_sum(s.drop_last()) + s.last());
          assert(s.len() == s.drop_last().len() + 1);
      }
  }
  
  fn compute_total_str_len(strings: Vec<&str>) -> (ret: Option<usize>)
      ensures ret.is_some() ==> ret.unwrap() == total_str_len(strings@),
      ensures ret.is_some() <== total_str_len(strings@) <= usize::MAX
  {
      proof {
          lemma_total_str_len_nonneg(strings@);
      }
      
      let mut total: usize = 0;
      let mut i = 0;
      
      while i < strings.len()
          invariant
              0 <= i <= strings.len(),
              total == spec_sum(strings@.take(i as int).map_values(|s: &str| s@.len())),
              total <= usize::MAX,
      {
          /* code modified by LLM (iteration 5): use s@.len() instead of s.len() to work with Verus sequences */
          let str_len = strings[i]@.len();
          if total > usize::MAX - str_len {
              return None;
          }
          total = total + str_len;
          i = i + 1;
          
          proof {
              let prev_seq = strings@.take((i-1) as int).map_values(|s: &str| s@.len());
              let curr_seq = strings@.take(i as int).map_values(|s: &str| s@.len());
              assert(curr_seq == prev_seq.push(strings@[i-1]@.len()));
              assert(spec_sum(curr_seq) == spec_sum(prev_seq) + strings@[i-1]@.len());
          }
      }
      
      proof {
          assert(strings@.take(strings.len() as int) == strings@);
      }
      
      Some(total)
  }

vc-description: |-
  function_signature: "def total_match(lst1: List[str], lst2: List[str]) -> List[str]"
  docstring: |
  Write a function that accepts two lists of strings and returns the list that has
  total number of chars in the all strings of the list less than the other list.
  If the two lists have the same number of chars, return the first list.
  test_cases:
  - input: ([], [])
  expected_output: []
  - input: (['hi', 'admin'], ['hI', 'Hi'])
  expected_output: ['hI', 'Hi']
  - input: (['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])
  expected_output: ['hi', 'admin']
  - input: (['hi', 'admin'], ['hI', 'hi', 'hi'])
  expected_output: ['hI', 'hi', 'hi']
  - input: (['4'], ['1', '2', '3', '4', '5'])
  expected_output: ['4']

vc-spec: |-
  fn total_match<'a>(lst1: Vec<&'a str>, lst2: Vec<&'a str>) -> (ret: Option<Vec<&'a str>>)
      // post-conditions-start
      ensures
          ret.is_some() <== total_str_len(lst1@) <= usize::MAX && total_str_len(lst2@) <= usize::MAX,
          inner_expr_total_match(lst1, lst2, ret),
      // post-conditions-end

vc-code: |-
  fn total_match<'a>(lst1: Vec<&'a str>, lst2: Vec<&'a str>) -> (ret: Option<Vec<&'a str>>)
      ensures
          ret.is_some() <== total_str_len(lst1@) <= usize::MAX && total_str_len(lst2@) <= usize::MAX,
          inner_expr_total_match(lst1, lst2, ret),
  {
      /* code modified by LLM (iteration 5): fixed function to match spec and use compute_total_str_len helper */
      let len1_opt = compute_total_str_len(lst1);
      let len2_opt = compute_total_str_len(lst2);
      
      match (len1_opt, len2_opt) {
          (Some(len1), Some(len2)) => {
              if len1 <= len2 {
                  Some(lst1)
              } else {
                  Some(lst2)
              }
          },
          _ => None
      }
  }

vc-postamble: |-
  
  }
  fn main() {}

