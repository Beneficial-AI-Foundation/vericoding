vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn how_many_times(string: Seq<char>, substring: Seq<char>) -> (result:nat)
      decreases string.len(),
  {
      if (string.len() == 0) {
          0
      } else if substring.is_prefix_of(string) {
          1 + how_many_times(string.skip(1), substring)
      } else {
          how_many_times(string.skip(1), substring)
      }
  }
  // pure-end
  // pure-end
  
  spec fn inner_expr_how_many_times_impl(opt_k: Option<u32>, string: Vec<char>, substring: Vec<char>) -> (result:bool) {
      match opt_k {
          Some(k) => k as nat == how_many_times(string@, substring@),
          None => how_many_times(string@, substring@) > u32::MAX,
      }
  }
  // pure-end

vc-helpers: |-
  proof fn lemma_how_many_times_bound(string: Seq<char>, substring: Seq<char>)
      requires substring.len() >= 1
      ensures how_many_times(string, substring) <= string.len()
      decreases string.len()
  {
      if string.len() == 0 {
      } else if substring.is_prefix_of(string) {
          lemma_how_many_times_bound(string.skip(1), substring);
      } else {
          lemma_how_many_times_bound(string.skip(1), substring);
      }
  }
  
  proof fn lemma_how_many_times_skip_invariant(string: Seq<char>, substring: Seq<char>, i: nat)
      requires 
          substring.len() >= 1,
          i <= string.len()
      ensures 
          how_many_times(string, substring) == 
          how_many_times(string.take(i as int), substring) + how_many_times(string.skip(i as int), substring)
      decreases i
  {
      if i == 0 {
      } else {
          lemma_how_many_times_skip_invariant(string, substring, (i - 1) as nat);
          if substring.is_prefix_of(string.skip((i - 1) as int)) {
          } else {
          }
      }
  }
  
  proof fn lemma_take_skip_append(string: Seq<char>, i: int)
      requires 0 <= i <= string.len()
      ensures string.take(i).add(string.skip(i)) == string
  {
  }
  
  proof fn lemma_how_many_times_step(string: Seq<char>, substring: Seq<char>, i: int)
      requires 
          substring.len() >= 1,
          0 <= i < string.len()
      ensures
          how_many_times(string.take(i + 1), substring) == 
          how_many_times(string.take(i), substring) + (if substring.is_prefix_of(string.skip(i)) { 1nat } else { 0nat })
  {
      let prefix_part = string.take(i);
      let new_char_part = string.skip(i).take(1);
      let combined = prefix_part.add(new_char_part);
      
      assert(combined == string.take(i + 1));
      
      lemma_how_many_times_prefix_extension(prefix_part, new_char_part, string.skip(i + 1), substring);
  }
  
  proof fn lemma_how_many_times_prefix_extension(prefix: Seq<char>, middle: Seq<char>, suffix: Seq<char>, substring: Seq<char>)
      requires 
          substring.len() >= 1,
          middle.len() >= 1
      ensures
          how_many_times(prefix.add(middle), substring) == 
          how_many_times(prefix, substring) + (if substring.is_prefix_of(middle.add(suffix)) { 1nat } else { 0nat })
      decreases prefix.len()
  {
      if prefix.len() == 0 {
      } else if substring.is_prefix_of(prefix) {
          lemma_how_many_times_prefix_extension(prefix.skip(1), middle, suffix, substring);
      } else {
          lemma_how_many_times_prefix_extension(prefix.skip(1), middle, suffix, substring);
      }
  }
  
  proof fn lemma_matches_is_prefix(string: Vec<char>, substring: Vec<char>, i: usize)
      requires 
          i + substring.len() <= string.len(),
          substring.len() >= 1,
          forall|k: int| 0 <= k < substring.len() ==> string@[i + k] == substring@[k]
      ensures 
          substring@.is_prefix_of(string@.skip(i as int))
  {
      let suffix = string@.skip(i as int);
      assert(forall|k: int| 0 <= k < substring.len() ==> suffix[k] == substring@[k]);
  }

vc-description: |-
  function_signature: "def how_many_times(string: str, substring: str) -> int"
  docstring: |
  Find how many times a given substring can be found in the original string. Count overlaping cases.
  test_cases:
  - input:
  - ""
  - "a"
  expected_output: 0
  - input:
  - "aaa"
  - "a"
  expected_output: 3
  - input:
  - "aaaa"
  - "aa"
  expected_output: 3

vc-spec: |-
  fn how_many_times_impl(string: Vec<char>, substring: Vec<char>) -> (opt_k: Option<u32>)
      // pre-conditions-start
      requires
          substring.len() >= 1,
      // pre-conditions-end
      // post-conditions-start
      ensures
          inner_expr_how_many_times_impl(opt_k, string, substring),
      // post-conditions-end

vc-code: |-
  {
      if string.len() == 0 {
          return Some(0);
      }
      
      proof {
          lemma_how_many_times_bound(string@, substring@);
      }
      
      let mut count: u32 = 0;
      let mut i: usize = 0;
      
      /* code modified by LLM (iteration 5): added decreases clause to fix verification error */
      while i < string.len()
          invariant
              substring.len() >= 1,
              i <= string.len(),
              count as nat == how_many_times(string@.take(i as int), substring@),
              count <= i,
          decreases string.len() - i
      {
          /* code modified by LLM (iteration 5): added prefix check logic */
          let increment = if i + substring.len() <= string.len() {
              let mut matches = true;
              let mut j: usize = 0;
              
              while j < substring.len() && matches
                  invariant
                      j <= substring.len(),
                      i + substring.len() <= string.len(),
                      matches == (forall|k: int| 0 <= k < j ==> string@[i + k] == substring@[k]),
                  decreases substring.len() - j
              {
                  if string[i + j] != substring[j] {
                      matches = false;
                  }
                  j += 1;
              }
              
              if matches {
                  proof {
                      lemma_matches_is_prefix(string, substring, i);
                  }
                  1
              } else {
                  0
              }
          } else {
              0
          };
          
          /* code modified by LLM (iteration 5): overflow check and count update */
          if increment == 1 {
              if count == u32::MAX {
                  return None;
              }
              count += 1;
          }
          
          /* code modified by LLM (iteration 5): prove invariant maintenance */
          proof {
              lemma_how_many_times_step(string@, substring@, i as int);
          }
          
          i += 1;
      }
      
      /* code modified by LLM (iteration 5): final proof that result matches spec */
      proof {
          assert(string@.take(i as int) == string@);
      }
      
      Some(count)
  }

vc-postamble: |-
  
  } // verus!
  fn main() {}

