vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {

vc-helpers: |-
  spec fn xor_char(a: char, b: char) -> char {
      ((a as u8) ^ (b as u8)) as char
  }
  
  spec fn string_xor_spec(a: Seq<char>, b: Seq<char>) -> Seq<char> {
      if a.len() != b.len() {
          seq![]
      } else {
          seq![xor_char(a[i], b[i]); i in 0..a.len()]
      }
  }

vc-description: |-
  function_signature: "fn string_xor(a: &[char], b: &[char]) -> (result: Vec<char>)"
  docstring: Implement string xor functionality.

vc-spec: |-
  fn string_xor(a: &[char], b: &[char]) -> (result: Vec<char>)
      ensures result@.len() == if a@.len() == b@.len() { a@.len() } else { 0 },
      ensures result@ == string_xor_spec(a@, b@)

vc-code: |-
  {
      if a.len() != b.len() {
          return vec![];
      }
      
      let mut result = Vec::new();
      let mut i = 0;
      
      while i < a.len()
          invariant
              i <= a.len(),
              result.len() == i,
              a.len() == b.len(),
              forall|j: int| 0 <= j < i ==> result@[j] == xor_char(a@[j], b@[j])
      {
          /* code modified by LLM (iteration 5): fixed XOR calculation to match spec */
          let xor_val = xor_char(a[i], b[i]);
          result.push(xor_val);
          i += 1;
      }
      
      result
  }

vc-postamble: |-
  
  fn main() {}
  }

