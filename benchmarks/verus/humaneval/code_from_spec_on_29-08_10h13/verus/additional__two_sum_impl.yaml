vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {

vc-helpers: |-
  proof fn lemma_exists_implies_found(nums: &[i32], target: i32, i: usize, j: usize)
      requires
          nums.len() >= 2,
          0 <= i < j < nums.len(),
          nums[i as int] + nums[j as int] == target
      ensures
          exists|x: int, y: int| 0 <= x < y < nums.len() && nums[x as int] + nums[y as int] == target
  {
  }

vc-description: |-
  function_signature: "fn two_sum(nums: &[i32], target: i32) -> (result: (usize, usize))"
  docstring: Perform addition or summation operations.

vc-spec: |-
  fn two_sum(nums: &[i32], target: i32) -> (result: (usize, usize))
      requires
          nums.len() >= 2,
          exists|i: int, j: int| 0 <= i < j < nums.len() && nums[i as int] + nums[j as int] == target
      ensures
          result.0 < result.1,
          result.1 < nums.len(),
          nums[result.0 as int] + nums[result.1 as int] == target

vc-code: |-
  {
      let mut i = 0;
      /* code modified by LLM (iteration 5): fixed outer loop invariant and bounds */
      while i < nums.len() - 1
          invariant
              0 <= i <= nums.len() - 1,
              forall|x: int, y: int| 0 <= x < y < nums.len() && x < i ==> nums[x] + nums[y] != target
          decreases nums.len() - 1 - i
      {
          let mut j = i + 1;
          /* code modified by LLM (iteration 5): fixed inner loop invariant and bounds */
          while j < nums.len()
              invariant
                  0 <= i < nums.len() - 1,
                  i + 1 <= j <= nums.len(),
                  forall|y: int| i < y < j ==> nums[i as int] + nums[y] != target
              decreases nums.len() - j
          {
              /* code modified by LLM (iteration 5): added bounds check and return statement */
              if i < nums.len() && j < nums.len() && nums[i as int] + nums[j as int] == target {
                  proof {
                      assert(0 <= i < j < nums.len());
                      assert(nums[i as int] + nums[j as int] == target);
                  }
                  return (i, j);
              }
              j += 1;
          }
          i += 1;
      }
      /* code modified by LLM (iteration 5): added proof that this is unreachable */
      proof {
          assert(false) by {
              let witness_i, witness_j = choose|i: int, j: int| 0 <= i < j < nums.len() && nums[i as int] + nums[j as int] == target;
              assert(witness_i < nums.len() - 1);
              assert(witness_i + 1 <= witness_j);
          }
      }
      unreached()
  }

vc-postamble: |-
  
  fn main() {}
  }

