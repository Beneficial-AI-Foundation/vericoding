vc-preamble: |-
  use vstd::math::abs;
  use vstd::prelude::*;
  use vstd::slice::*;
  
  verus! {

vc-helpers: |-
  proof fn abs_commutative(a: i64, b: i64)
      ensures abs(a as int - b as int) == abs(b as int - a as int)
  {
      let a_int = a as int;
      let b_int = b as int;
      if a_int >= b_int {
          assert(a_int - b_int >= 0);
          assert(b_int - a_int <= 0);
          assert(abs(a_int - b_int) == a_int - b_int);
          assert(abs(b_int - a_int) == -(b_int - a_int));
          assert(-(b_int - a_int) == a_int - b_int);
      } else {
          assert(a_int - b_int < 0);
          assert(b_int - a_int > 0);
          assert(abs(a_int - b_int) == -(a_int - b_int));
          assert(abs(b_int - a_int) == b_int - a_int);
          assert(-(a_int - b_int) == b_int - a_int);
      }
  }
  
  proof fn abs_diff_exec_spec(a: i64, b: i64)
      ensures (if a >= b { a - b } else { b - a }) as int == abs(a as int - b as int)
  {
      if a >= b {
          assert((a - b) as int == a as int - b as int);
          assert(a as int >= b as int);
          assert(abs(a as int - b as int) == a as int - b as int);
      } else {
          assert((b - a) as int == b as int - a as int);
          /* code modified by LLM (iteration 5): fixed syntax error by adding comma */
          assert(a as int < b as int,);
          assert(abs(a as int - b as int) == -(a as int - b as int));
          assert(-(a as int - b as int) == b as int - a as int);
      }
  }

vc-description: |-
  function_signature: "def has_close_elements(numbers: List[float], threshold: float) -> bool"
  docstring: Check if in given list of numbers, are any two numbers closer to each other than given threshold.
  test_cases:
  - input: [[1.0, 2.0, 3.0], 0.5]
  expected_output: False
  - input: [[1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3]
  expected_output: True

vc-spec: |-
  fn has_close_elements(numbers: &[i64], threshold: i64) -> (result: bool)
      // post-conditions-start
      ensures
          result == exists|i: int, j: int|
              0 <= i < j < numbers@.len() && abs(numbers[i] - numbers[j]) < threshold,
      // post-conditions-end

vc-code: |-
  {
      let mut i = 0;
      while i < numbers.len()
          invariant
              0 <= i <= numbers.len(),
              forall|i1: int, j1: int|
                  0 <= i1 < j1 < i ==> abs(numbers@[i1] - numbers@[j1]) >= threshold,
      {
          let mut j = i + 1;
          while j < numbers.len()
              invariant
                  i < numbers.len(),
                  i + 1 <= j <= numbers.len(),
                  0 <= i <= numbers.len(),
                  forall|i1: int, j1: int|
                      0 <= i1 < j1 < i ==> abs(numbers@[i1] - numbers@[j1]) >= threshold,
                  forall|j1: int|
                      i + 1 <= j1 < j ==> abs(numbers@[i as int] - numbers@[j1]) >= threshold,
          {
              /* code modified by LLM (iteration 4): use executable abs computation instead of ghost types */
              let exec_abs = if numbers[i] >= numbers[j] { numbers[i] - numbers[j] } else { numbers[j] - numbers[i] };
              if exec_abs < threshold {
                  proof {
                      abs_diff_exec_spec(numbers[i], numbers[j]);
                      assert(exec_abs as int == abs(numbers@[i as int] - numbers@[j as int]));
                      assert(exec_abs < threshold);
                      assert(abs(numbers@[i as int] - numbers@[j as int]) < threshold);
                  }
                  assert(0 <= i < j < numbers@.len());
                  assert(abs(numbers@[i as int] - numbers@[j as int]) < threshold);
                  return true;
              }
              j += 1;
          }
          i += 1;
      }
      
      assert(forall|i: int, j: int|
          0 <= i < j < numbers@.len() ==> abs(numbers@[i] - numbers@[j]) >= threshold);
      false
  }

vc-postamble: |-
  
  }
  fn main() {}

