vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn in_array(a: Seq<i32>, x: i32) -> (ret: bool) {
      exists|i: int| 0 <= i < a.len() && a[i] == x
  }

vc-helpers: |-
  proof fn lemma_in_array_contains(a: Seq<i32>, x: i32)
      ensures in_array(a, x) <==> a.contains(x)
  {
  }
  
  proof fn lemma_not_in_array_not_contains(a: Seq<i32>, x: i32)
      ensures !in_array(a, x) <==> !a.contains(x)
  {
  }
  
  proof fn lemma_push_preserves_uniqueness(c: Vec<i32>, x: i32)
      requires forall|i: int, j: int| 0 <= i < j < c.len() ==> c@[i] != c@[j],
      requires !(c@).contains(x),
      ensures forall|i: int, j: int| 0 <= i < j < (c.len() + 1) ==> {
          let new_c = c.push(x);
          new_c@[i] != new_c@[j]
      }
  {
  }

vc-description: |-
  function_signature: "fn remove_elements(a: &Vec<i32>, b: &Vec<i32>) -> (c: Vec<i32>)"
  docstring: Implement remove elements functionality.

vc-spec: |-
  #[verifier::loop_isolation(false)]
  fn remove_elements(a: &Vec<i32>, b: &Vec<i32>) -> (c: Vec<i32>)
      // post-conditions-start
      ensures
          forall|k: int| #![auto] 0 <= k < c.len() ==> in_array(a@, c[k]) && !in_array(b@, c[k]),
          forall|i: int, j: int| 0 <= i < j < c.len() ==> c[i] != c[j],
      // post-conditions-end

vc-code: |-
  {
      let mut c = Vec::new();
      let mut i = 0;
      
      while i < a.len()
          invariant
              0 <= i <= a.len(),
              forall|k: int| #![auto] 0 <= k < c.len() ==> in_array(a@, c@[k]) && !in_array(b@, c@[k]),
              forall|p: int, q: int| 0 <= p < q < c.len() ==> c@[p] != c@[q],
      {
          let elem = a[i];
          
          if !b@.contains(elem) && !(c@).contains(elem) {
              /* code modified by LLM (iteration 5): fixed syntax for c@ contains check */
              proof {
                  lemma_in_array_contains(a@, elem);
                  lemma_not_in_array_not_contains(b@, elem);
                  lemma_push_preserves_uniqueness(c, elem);
              }
              c.push(elem);
          }
          i += 1;
      }
      
      proof {
          /* code modified by LLM (iteration 5): final proof block maintains postconditions */
          assert forall|k: int| #![auto] 0 <= k < c.len() ==> in_array(a@, c@[k]) && !in_array(b@, c@[k]);
          assert forall|i: int, j: int| 0 <= i < j < c.len() ==> c@[i] != c@[j];
      }
      
      c
  }

vc-postamble: |-
  
  fn main() {}
  }

