vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn sum(numbers: Seq<u32>) -> (result:int) {
      numbers.fold_left(0, |acc: int, x| acc + x)
  }
  // pure-end
  // pure-end
  
  spec fn product(numbers: Seq<u32>) -> (result:int) {
      numbers.fold_left(1, |acc: int, x| acc * x)
  }
  // pure-end

vc-helpers: |-
  proof fn lemma_sum_empty()
      ensures sum(Seq::<u32>::empty()) == 0
  {
      /* code modified by LLM (iteration 5): added explicit proof using fold_left properties */
      assert(Seq::<u32>::empty().fold_left(0, |acc: int, x| acc + x) == 0);
  }
  
  proof fn lemma_product_empty()
      ensures product(Seq::<u32>::empty()) == 1
  {
      /* code modified by LLM (iteration 5): added explicit proof using fold_left properties */
      assert(Seq::<u32>::empty().fold_left(1, |acc: int, x| acc * x) == 1);
  }
  
  proof fn lemma_sum_push(s: Seq<u32>, x: u32)
      ensures sum(s.push(x)) == sum(s) + x
  {
      /* code modified by LLM (iteration 5): added explicit proof using fold_left properties */
      assert(s.push(x).fold_left(0, |acc: int, y| acc + y) == s.fold_left(0, |acc: int, y| acc + y) + x);
  }
  
  proof fn lemma_product_push(s: Seq<u32>, x: u32)
      ensures product(s.push(x)) == product(s) * x
  {
      /* code modified by LLM (iteration 5): added explicit proof using fold_left properties */
      assert(s.push(x).fold_left(1, |acc: int, y| acc * y) == s.fold_left(1, |acc: int, y| acc * y) * x);
  }
  
  proof fn lemma_sum_nonnegative(s: Seq<u32>)
      ensures sum(s) >= 0
      decreases s.len()
  {
      if s.len() == 0 {
          lemma_sum_empty();
      } else {
          let prefix = s.subrange(0, s.len() - 1);
          lemma_sum_push(prefix, s[s.len() - 1]);
          lemma_sum_nonnegative(prefix);
      }
  }
  
  proof fn lemma_product_positive(s: Seq<u32>)
      ensures product(s) >= 1
      decreases s.len()
  {
      if s.len() == 0 {
          lemma_product_empty();
      } else {
          let prefix = s.subrange(0, s.len() - 1);
          lemma_product_push(prefix, s[s.len() - 1]);
          lemma_product_positive(prefix);
          /* code modified by LLM (iteration 5): added explicit reasoning about positive product */
          assert(s[s.len() - 1] >= 1);
          assert(product(prefix) >= 1);
          assert(product(s) == product(prefix) * s[s.len() - 1]);
          assert(product(s) >= 1 * 1);
      }
  }
  
  proof fn lemma_product_bound(s: Seq<u32>)
      requires s.len() > 0
      ensures product(s) <= u32::MAX ==> product(s) >= 1 && product(s) <= u32::MAX
  {
      lemma_product_positive(s);
  }

vc-description: |-
  function_signature: "def sum_product(numbers: List[int]) -> Tuple[int, int]"
  docstring: |
  For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.
  Empty sum should be equal to 0 and empty product should be equal to 1.
  test_cases:
  - input: []
  expected_output: (0, 1)
  - input: [1, 2, 3, 4]
  expected_output: (10, 24)

vc-spec: |-
  fn sum_product(numbers: Vec<u32>) -> (result: (u64, Option<u32>))
      // pre-conditions-start
      requires
          numbers.len() < u32::MAX,
      // pre-conditions-end
      // post-conditions-start
      ensures
          result.0 == sum(numbers@),
          result.1 matches Some(v) ==> v == product(numbers@),
      // post-conditions-end

vc-code: |-
  {
      let mut sum_val: u64 = 0;
      let mut product_val: u32 = 1;
      let mut product_overflow = false;
      let mut i = 0;
  
      proof {
          lemma_sum_empty();
          lemma_product_empty();
      }
  
      /* code modified by LLM (iteration 5): fixed invariant and overflow handling */
      while i < numbers.len()
          invariant
              i <= numbers.len(),
              sum_val == sum(numbers@.subrange(0, i as int)),
              !product_overflow ==> product_val == product(numbers@.subrange(0, i as int)),
              product_overflow ==> product(numbers@.subrange(0, i as int)) > u32::MAX,
              sum_val <= (i as u64) * (u32::MAX as u64),
          decreases numbers.len() - i
      {
          let old_i = i;
          let element = numbers[i];
          
          /* code modified by LLM (iteration 5): added overflow check for sum */
          assert(sum_val + (element as u64) >= sum_val);
          sum_val = sum_val + element as u64;
          
          if !product_overflow {
              if element > 0 && product_val > u32::MAX / element {
                  product_overflow = true;
              } else {
                  product_val = product_val * element;
              }
          }
          
          i = i + 1;
          
          proof {
              lemma_sum_push(numbers@.subrange(0, old_i as int), element);
              if !product_overflow {
                  lemma_product_push(numbers@.subrange(0, old_i as int), element);
              }
          }
      }
  
      let product_result = if product_overflow {
          None
      } else {
          Some(product_val)
      };
  
      (sum_val, product_result)
  }

vc-postamble: |-
  
  }
  fn main() {}

