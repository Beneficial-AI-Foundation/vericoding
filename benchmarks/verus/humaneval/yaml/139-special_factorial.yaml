vc-description: |-
  /--
  function_signature: "def special_factorial(n: int) -> int"
  docstring: |
      The Brazilian factorial is defined as:
      brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!
      where n > 0. Please write a function that computes the Brazilian factorial.
  test_cases:
    - input: 4
      expected_output: 288
  -/

vc-preamble: |-

  use vstd::arithmetic::mul::*;
  use vstd::prelude::*;

  verus! {

  spec fn factorial(n: nat) -> (ret:nat)
      decreases n,
  {
      if n <= 1 {
          1
      } else {
          n * factorial((n - 1) as nat)
      }
  }
  // pure-end
  // pure-end

  spec fn brazilian_factorial(n: nat) -> (ret:nat)
      decreases n,
  {
      if n <= 1 {
          factorial(1)
      } else {
          factorial(n) * brazilian_factorial((n - 1) as nat)
      }
  }
  // pure-end

vc-helpers: |-
  // pure-end

  proof fn lemma_factorial_positive(n: nat)
      // post-conditions-start
      ensures
          factorial(n) >= 1,
      decreases n,
      // post-conditions-end
  {
      // impl-start
      if (n == 0) {
      } else {
          lemma_factorial_positive((n - 1) as nat);
          assert(factorial(n) >= 1) by {
              broadcast use lemma_mul_strictly_positive;

          };
      }
      // impl-end
  }
  // pure-end

  // pure-end

  proof fn lemma_brazilian_factorial_positive(n: nat)
      // post-conditions-start
      ensures
          brazilian_factorial(n) >= 1,
      decreases n,
      // post-conditions-end
  {
      // impl-start
      if (n == 0) {
      } else {
          lemma_factorial_positive((n) as nat);
          lemma_brazilian_factorial_positive((n - 1) as nat);
          assert(brazilian_factorial(n) >= 1) by {
              lemma_mul_strictly_positive(
                  factorial(n) as int,
                  brazilian_factorial((n - 1) as nat) as int,
              )
          };
      }
      // impl-end
  }
  // pure-end

  // pure-end

  proof fn lemma_brazilian_fib_monotonic(i: nat, j: nat)
      // pre-conditions-start
      requires
          0 <= i <= j,
      // pre-conditions-end
      // post-conditions-start
      ensures
          brazilian_factorial(i) <= brazilian_factorial(j),
      decreases j - i,
      // post-conditions-end
  {
      // impl-start
      if (i == j) {
      } else if (j == i + 1) {
          assert(factorial(j) >= 1) by { lemma_factorial_positive(j) };
          assert(brazilian_factorial(j) >= brazilian_factorial(i)) by {
              broadcast use lemma_mul_increases;

          };
      } else {
          lemma_brazilian_fib_monotonic(i, (j - 1) as nat);
          lemma_brazilian_fib_monotonic((j - 1) as nat, j);
      }
      // impl-end
  }
  // pure-end

vc-spec: |-
  fn brazilian_factorial_impl(n: u64) -> (ret: Option<u64>)
      // post-conditions-start
      ensures
          match ret {
              None => brazilian_factorial(n as nat) > u64::MAX,
              Some(bf) => bf == brazilian_factorial(n as nat),
          },
      // post-conditions-end

vc-code: |-
  {
      // impl-start
      assume(false);
      None
      // impl-end
  }

vc-postamble: |-

  } // verus!
  fn main() {}
