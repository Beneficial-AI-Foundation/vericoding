vc-description: |-
  This task implements a function that calculates the sum of absolute
  values of all elements in an array, multiplied by the product of signs of all elements.
  The sign function returns 1 for positive numbers, -1 for negative numbers, and 0
  for zero. If the array is empty, the function returns None; otherwise, it returns
  Some with the computed result.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

  spec fn abs(x: int) -> int {
      if x >= 0 { x } else { -x }
  }

  spec fn sign(x: int) -> int {
      if x > 0 { 1 } else if x < 0 { -1 } else { 0 }
  }

  spec fn sum_of_magnitudes(arr: Seq<int>) -> int
      decreases arr.len()
  {
      if arr.len() == 0 { 0 } else { abs(arr[0]) + sum_of_magnitudes(arr.subrange(1, arr.len() as int)) }
  }

  spec fn product_of_signs(arr: Seq<int>) -> int
      decreases arr.len()
  {
      if arr.len() == 0 { 1 } else { sign(arr[0]) * product_of_signs(arr.subrange(1, arr.len() as int)) }
  }

vc-helpers: |-
  proof fn sum_of_magnitudes_append(arr: Seq<int>, i: int)
      requires 0 <= i < arr.len()
      ensures sum_of_magnitudes(arr.subrange(0, i + 1)) == sum_of_magnitudes(arr.subrange(0, i)) + abs(arr[i])
  {
      assume(false); // TODO: Remove this line and implement the proof
  }

  proof fn product_of_signs_append(arr: Seq<int>, i: int)
      requires 0 <= i < arr.len()
      ensures product_of_signs(arr.subrange(0, i + 1)) == product_of_signs(arr.subrange(0, i)) * sign(arr[i])
  {
      assume(false); // TODO: Remove this line and implement the proof
  }

vc-spec: |-
  fn prod_signs(arr: Seq<int>) -> (result: Option<int>)
      ensures 
          (arr.len() == 0) ==> (result == Option::<int>::None) &&
          (arr.len() > 0) ==> (result == Option::<int>::Some(sum_of_magnitudes(arr) * product_of_signs(arr)))

vc-code: |-
  {
      // impl-start
      assume(false);
      Option::<int>::None
      // impl-end
  }

vc-postamble: |-

  }

  fn main() {}