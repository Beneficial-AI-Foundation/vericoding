vc-description: |-
  This task implements a function that calculates the sum of absolute
  values of all elements in an array, multiplied by the product of signs of all elements.
  The sign function returns 1 for positive numbers, -1 for negative numbers, and 0
  for zero. If the array is empty, the function returns None; otherwise, it returns
  Some with the computed result.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

  spec fn abs(x: int) -> int {
      if x >= 0 { x } else { -x }
  }

  spec fn sign(x: int) -> int {
      if x > 0 { 1 } else if x < 0 { -1 } else { 0 }
  }

  spec fn sum_of_magnitudes(arr: Seq<int>) -> int
      decreases arr.len()
  {
      if arr.len() == 0 { 0 } else { abs(arr[0]) + sum_of_magnitudes(arr.subrange(1, arr.len() as int)) }
  }

  spec fn product_of_signs(arr: Seq<int>) -> int
      decreases arr.len()
  {
      if arr.len() == 0 { 1 } else { sign(arr[0]) * product_of_signs(arr.subrange(1, arr.len() as int)) }
  }

vc-helpers: |-

vc-spec: |-
  fn prod_signs(arr: Vec<i8>) -> (result: Option<i8>)
      ensures 
          (arr@.len() == 0) ==> (result == Option::<i8>::None) &&
          (arr@.len() > 0) ==> (result == Option::<i8>::Some((sum_of_magnitudes(arr@.map(|i: int, x: i8| x as int)) * product_of_signs(arr@.map(|i: int, x: i8| x as int))) as i8))

vc-code: |-
  {
      // impl-start
      assume(false);
      Option::<i8>::None
      // impl-end
  }

vc-postamble: |-

  }

  fn main() {}