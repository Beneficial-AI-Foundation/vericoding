{"id": "000-has_close_elements", "vc-description": "", "vc-preamble": "use vstd::math::abs;\nuse vstd::prelude::*;\nuse vstd::slice::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn has_close_elements(numbers: &[i64], threshold: i64) -> (result: bool)\n\n    ensures\n        result == exists|i: int, j: int|\n            0 <= i < j < numbers@.len() && abs(numbers[i] - numbers[j]) < threshold,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "003-below_zero", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sum(s: Seq<int>) -> (result:int)\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s[0] + sum(s.skip(1))\n    }\n}\n\nspec fn sum_other_way(s: Seq<int>) -> (result:int)\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s[s.len() - 1] + sum_other_way(s.take(s.len() - 1))\n    }\n}", "vc-helpers": "", "vc-spec": "fn below_zero(operations: Vec<i32>) -> (result: bool)\n\n    requires\n        forall|i: int|\n            0 <= i <= operations@.len() ==> sum(operations@.take(i).map(|_idx, j: i32| j as int))\n                <= i32::MAX,\n\n    ensures\n        result <==> exists|i: int|\n            0 <= i <= operations@.len() && sum(operations@.take(i).map(|_idx, j: i32| j as int))\n                < 0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "004-mean_absolute_derivation", "vc-description": "", "vc-preamble": "use vstd::arithmetic::div_mod::{\n    lemma_div_is_ordered, lemma_div_is_ordered_by_denominator, lemma_div_multiples_vanish,\n    lemma_fundamental_div_mod, lemma_fundamental_div_mod_converse,\n};\nuse vstd::arithmetic::mul::{\n    lemma_mul_inequality, lemma_mul_is_distributive_add, lemma_mul_is_distributive_add_other_way,\n    lemma_mul_unary_negation,\n};\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn sum(numbers: Seq<int>) -> (result:int) {\n    numbers.fold_left(0, |acc: int, x| acc + x)\n}\n\nspec fn mean(values: Seq<int>) -> (result:int)\n    recommends\n        values.len() > 0,\n{\n    sum(values) / (values.len() as int)\n}\n\nspec fn abs(n: int) -> (result:int) {\n    if n >= 0 {\n        n\n    } else {\n        -n\n    }\n}\n\nspec fn spec_mean_absolute_deviation(numbers: Seq<int>) -> (result:int)\n    recommends\n        numbers.len() > 0,\n{\n    let avg = mean(numbers);\n    sum(numbers.map(|_index, n: int| abs(n - avg))) / (numbers.len() as int)\n}\n\nspec fn if_inner_lemma_how_to_add_then_divide(x : int, y : int, d : int) -> (result: bool) {\n    if (x % d) + (y % d) >= d {\n        &&& (x + y) / d == (x / d) + (y / d) + 1\n        &&& (x + y) % d == (x % d) + (y % d) - d\n    } else {\n        &&& (x + y) / d == (x / d) + (y / d)\n        &&& (x + y) % d == (x % d) + (y % d)\n    }\n}\n\nspec fn expr_inner_divide_i32_by_u32(qr : (i32, u32), x: i32, d: u32) -> (result:bool) {\n    let (q, r) = qr;\n    q == x as int / d as int && r == x as int % d as int\n}\nspec fn expr_inner_divide_i32_by_usize(qr : (i32, usize), x: i32, d: usize) -> (result:bool) {\n    let (q, r) = qr;\n    q == x as int / d as int && r == x as int % d as int\n}", "vc-helpers": "", "vc-spec": "fn mean_absolute_deviation(numbers: &[i32]) -> (result: u32)\n\n    requires\n        numbers.len() > 0,\n\n    ensures\n        result == spec_mean_absolute_deviation(numbers@.map(|_index, n: i32| n as int)),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "005-intersperse", "vc-description": "", "vc-preamble": "use vstd::assert_seqs_equal;\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn intersperse_spec(numbers: Seq<u64>, delimiter: u64) -> (result:Seq<u64>)\n    decreases numbers.len(),\n{\n    if numbers.len() <= 1 {\n        numbers\n    } else {\n        intersperse_spec(numbers.drop_last(), delimiter) + seq![delimiter, numbers.last()]\n    }\n}\n\nspec fn even(i: int) -> (result:int) {\n    2 * i\n}\n\nspec fn odd(i: int) -> (result:int) {\n    2 * i + 1\n}\n\nspec fn intersperse_quantified(numbers: Seq<u64>, delimiter: u64, interspersed: Seq<u64>) -> (result:bool) {\n    (if numbers.len() == 0 {\n        interspersed.len() == 0\n    } else {\n        interspersed.len() == 2 * numbers.len() - 1\n    }) && (forall|i: int| 0 <= i < numbers.len() ==> #[trigger] interspersed[even(i)] == numbers[i])\n        && (forall|i: int|\n        0 <= i < numbers.len() - 1 ==> #[trigger] interspersed[odd(i)] == delimiter)\n}", "vc-helpers": "", "vc-spec": "fn intersperse(numbers: Vec<u64>, delimiter: u64) -> (result: Vec<u64>)\n\n    ensures\n        result@ == intersperse_spec(numbers@, delimiter),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "007-filter_by_substring", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn filter_by_substring<'a>(strings: &Vec<&'a str>, substring: &str) -> (res: Vec<&'a str>)\n\n    ensures\n        forall|i: int|\n            0 <= i < strings@.len() && (exists|j: int|\n                0 <= j <= strings@[i]@.len() - substring@.len() && strings[i]@.subrange(\n                    j,\n                    #[trigger] (j + substring@.len()),\n                ) == substring@) ==> res@.contains(#[trigger] (strings[i])),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "008-sum_product", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sum(numbers: Seq<u32>) -> (result:int) {\n    numbers.fold_left(0, |acc: int, x| acc + x)\n}\n\nspec fn product(numbers: Seq<u32>) -> (result:int) {\n    numbers.fold_left(1, |acc: int, x| acc * x)\n}", "vc-helpers": "", "vc-spec": "fn sum_product(numbers: Vec<u32>) -> (result: (u64, Option<u32>))\n\n    requires\n        numbers.len() < u32::MAX,\n\n    ensures\n        result.0 == sum(numbers@),\n        result.1 matches Some(v) ==> v == product(numbers@),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "009-rolling_max", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn seq_max(a: Seq<i32>) -> (ret: i32)\n    decreases a.len(),\n{\n    if a.len() == 0 {\n        i32::MIN\n    } else if a.last() > seq_max(a.drop_last()) {\n        a.last()\n    } else {\n        seq_max(a.drop_last())\n    }\n}", "vc-helpers": "", "vc-spec": "fn rolling_max(numbers: Vec<i32>) -> (result: Vec<i32>)\n\n    ensures\n        result.len() == numbers.len(),\n        forall|i: int| 0 <= i < numbers.len() ==> result[i] == seq_max(numbers@.take(i + 1)),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "011-string_xor", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\nuse vstd::slice::*;\n\nverus! {\n\nspec fn is_binary_digit(c: char) -> (ret: bool) {\n    c == '0' || c == '1'\n}\n\nspec fn xor_char(a: char, b: char) -> (result: char)\n    recommends\n        is_binary_digit(a),\n        is_binary_digit(b),\n{\n    if a == b {\n        '0'\n    } else {\n        '1'\n    }\n}", "vc-helpers": "", "vc-spec": "fn string_xor(a: &[char], b: &[char]) -> (result: Vec<char>)\n\n    requires\n        a@.len() == b@.len(),\n        forall|i: int| 0 <= i < a@.len() as int ==> is_binary_digit(#[trigger] a[i]),\n        forall|i: int| 0 <= i < b@.len() as int ==> is_binary_digit(#[trigger] b[i]),\n\n    ensures\n        result.len() == a@.len(),\n        forall|i: int|\n            0 <= i < result.len() as int ==> #[trigger] result[i] == xor_char(a[i], b[i]),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "012-longest", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn expr_inner_longest(strings: &Vec<Vec<u8>>, result: Option<&Vec<u8>>) -> (result: bool) {\n    match result {\n        None => strings.len() == 0,\n        Some(s) => {\n            (forall|i: int| #![auto] 0 <= i < strings.len() ==> s.len() >= strings[i].len())\n                && (exists|i: int|\n                #![auto]\n                (0 <= i < strings.len() && s == strings[i] && (forall|j: int|\n                    #![auto]\n                    0 <= j < i ==> strings[j].len() < s.len())))\n        },\n    }\n}", "vc-helpers": "", "vc-spec": "fn longest(strings: &Vec<Vec<u8>>) -> (result: Option<&Vec<u8>>)\n\n    ensures\n        expr_inner_longest(strings, result),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "014-all_prefixes", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn all_prefixes(s: &Vec<u8>) -> (prefixes: Vec<Vec<u8>>)\n\n    ensures\n        prefixes.len() == s.len(),\n        forall|i: int| #![auto] 0 <= i < s.len() ==> prefixes[i]@ == s@.subrange(0, i + 1),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "015-string_sequence", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn single_digit_number_to_char(n: nat) -> (result:char) {\n    if n == 0 {\n        '0'\n    } else if n == 1 {\n        '1'\n    } else if n == 2 {\n        '2'\n    } else if n == 3 {\n        '3'\n    } else if n == 4 {\n        '4'\n    } else if n == 5 {\n        '5'\n    } else if n == 6 {\n        '6'\n    } else if n == 7 {\n        '7'\n    } else if n == 8 {\n        '8'\n    } else {\n        '9'\n    }\n}\n\nspec fn number_to_char(n: nat) -> (result:Seq<char>)\n    decreases n,\n{\n    if (n == 0) {\n        seq![]\n    } else {\n        number_to_char(n / 10).add(seq![single_digit_number_to_char(n % 10)])\n    }\n}\n\nspec fn string_sequence(n: nat) -> (result:Seq<char>)\n    decreases n,\n{\n    if n == 0 {\n        seq!['0']\n    } else {\n        string_sequence((n - 1) as nat).add(seq![' '].add(number_to_char(n)))\n    }\n}", "vc-helpers": "", "vc-spec": "fn string_sequence_impl(n: u8) -> (string_seq: Vec<char>)\n\n    ensures\n        string_seq@ == string_sequence(n as nat),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "018-how_many_times", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn how_many_times(string: Seq<char>, substring: Seq<char>) -> (result:nat)\n    decreases string.len(),\n{\n    if (string.len() == 0) {\n        0\n    } else if substring.is_prefix_of(string) {\n        1 + how_many_times(string.skip(1), substring)\n    } else {\n        how_many_times(string.skip(1), substring)\n    }\n}\n\nspec fn inner_expr_how_many_times_impl(opt_k: Option<u32>, string: Vec<char>, substring: Vec<char>) -> (result:bool) {\n    match opt_k {\n        Some(k) => k as nat == how_many_times(string@, substring@),\n        None => how_many_times(string@, substring@) > u32::MAX,\n    }\n}", "vc-helpers": "", "vc-spec": "fn how_many_times_impl(string: Vec<char>, substring: Vec<char>) -> (opt_k: Option<u32>)\n\n    requires\n        substring.len() >= 1,\n\n    ensures\n        inner_expr_how_many_times_impl(opt_k, string, substring),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "023-strlen", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn strlen(string: &Vec<char>) -> (length: usize)\n\n    ensures\n        length == string.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "025-factorize", "vc-description": "", "vc-preamble": "use vstd::arithmetic::div_mod::*;\nuse vstd::arithmetic::mul::*;\nuse vstd::assert_by_contradiction;\nuse vstd::calc;\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn is_prime(n: nat) -> (result:bool) {\n    forall|i: nat| 1 < i < n ==> #[trigger] (n % i) != 0\n}\n\nspec fn is_prime_factorization(n: nat, factorization: Seq<nat>) -> (result:bool) {\n\n    &&& forall|i: int|\n        0 <= i < factorization.len() ==> #[trigger] is_prime(\n            factorization[i] as nat,\n        )\n\n    &&& factorization.fold_right(|x: nat, acc: nat| (acc * x as nat), 1nat)\n        == n\n\n    &&& forall|i: nat, j: nat|\n        (1 < i <= j < factorization.len()) ==> (#[trigger] factorization[i as int]\n            <= #[trigger] factorization[j as int])\n}", "vc-helpers": "", "vc-spec": "fn factorize(n: u8) -> (factorization: Vec<u8>)\n\n    requires\n        1 <= n <= u8::MAX,\n\n    ensures\n        is_prime_factorization(n as nat, factorization@.map(|_idx, j: u8| j as nat)),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "026-remove_duplicates", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn count_frequency_spec(seq: Seq<i64>, key: i64) -> (result:int)\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n        0\n    } else {\n        count_frequency_spec(seq.drop_last(), key) + if (seq.last() == key) {\n            1 as int\n        } else {\n            0 as int\n        }\n    }\n}", "vc-helpers": "", "vc-spec": "fn remove_duplicates(numbers: &Vec<i64>) -> (unique_numbers: Vec<i64>)\n\n    ensures\n        unique_numbers@ == numbers@.filter(|x: i64| count_frequency_spec(numbers@, x) == 1),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "027-flip_case", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_upper_case(c: char) -> (result:bool) {\n    c >= 'A' && c <= 'Z'\n}\n\nspec fn is_lower_case(c: char) -> (result:bool) {\n    c >= 'a' && c <= 'z'\n}\n\nspec fn shift_plus_32_spec(c: char) -> (result:char) {\n    ((c as u8) + 32) as char\n}\n\nspec fn shift_minus_32_spec(c: char) -> (result:char) {\n    ((c as u8) - 32) as char\n}\n\nspec fn flip_case_spec(c: char) -> (result:char) {\n    if is_lower_case(c) {\n        shift_minus_32_spec(c)\n    } else if is_upper_case(c) {\n        shift_plus_32_spec(c)\n    } else {\n        c\n    }\n}", "vc-helpers": "", "vc-spec": "fn flip_case(str: &[char]) -> (flipped_case: Vec<char>)\n\n    ensures\n        str@.len() == flipped_case@.len(),\n        forall|i: int| 0 <= i < str.len() ==> flipped_case[i] == flip_case_spec(#[trigger] str[i]),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "030-get-positive", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn get_positive(input: Vec<i32>) -> (positive_list: Vec<i32>)\n\n    ensures\n        positive_list@ == input@.filter(|x: i32| x > 0),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "034-unique", "vc-description": "", "vc-preamble": "use vstd::calc;\nuse vstd::prelude::*;\nuse vstd::seq_lib::lemma_multiset_commutative;\nuse vstd::seq_lib::lemma_seq_contains_after_push;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn unique(s: Vec<i32>) -> (result: Vec<i32>)\n\n    ensures\n        forall|i: int, j: int| 0 <= i < j < result.len() ==> result[i] < result[j],\n        forall|i: int| #![auto] 0 <= i < result.len() ==> s@.contains(result[i]),\n        forall|i: int| #![trigger s[i]] 0 <= i < s.len() ==> result@.contains(s[i]),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "035-max-element", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn max_element(a: &Vec<i32>) -> (max: i32)\n\n    requires\n        a.len() > 0,\n\n    ensures\n        forall|i: int| 0 <= i < a.len() ==> a[i] <= max,\n        exists|i: int| 0 <= i < a.len() && a[i] == max,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "037-sort_even", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn count<T>(s: Seq<T>, x: T) -> (result:int)\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        0\n    } else {\n        count(s.skip(1), x) + if s[0] == x {\n            1int\n        } else {\n            0int\n        }\n    }\n}\n\nspec fn permutes<T>(s1: Seq<T>, s2: Seq<T>) -> (result:bool) {\n    forall|x: T| count(s1, x) == count(s2, x)\n}\n\nspec fn inner_expr_lemma_update_effect_on_count<T>(s: Seq<T>, i: int, v: T, x: T) -> (result:bool) {\n    count(s.update(i, v), x) == if v == x && s[i] != x {\n        count(s, x) + 1\n    } else if v != x && s[i] == x {\n        count(s, x) - 1\n    } else {\n        count(s, x)\n    }\n}", "vc-helpers": "", "vc-spec": "#[verifier::loop_isolation(false)]\nfn sort_even(l: Vec<i32>) -> (result: Vec<i32>)\n\n    ensures\n        l.len() == result.len(),\n        permutes(result@, l@),\n        forall|i: int| 0 <= i < l.len() && i % 2 == 1 ==> result[i] == l[i],\n        forall|i: int, j: int|\n            #![auto]\n            0 <= i < j < l.len() && i % 2 == 0 && j % 2 == 0 ==> result[i] <= result[j],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "042-incr-list", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn incr_list(l: Vec<i32>) -> (result: Vec<i32>)\n\n    requires\n        forall|i: int| 0 <= i < l.len() ==> l[i] + 1 <= i32::MAX,\n\n    ensures\n        result.len() == l.len(),\n        forall|i: int| 0 <= i < l.len() ==> #[trigger] result[i] == l[i] + 1,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "043-pairs-sum-to-zero", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "#[verifier::loop_isolation(false)]\nfn pairs_sum_to_zero(nums: &[i32], target: i32) -> (found: bool)\n\n    requires\n        nums.len() >= 2,\n        forall|i: int, j: int|\n            0 <= i < j < nums.len() ==> nums[i] + nums[j] <= i32::MAX && nums[i] + nums[j]\n                >= i32::MIN,\n\n    ensures\n        found <==> exists|i: int, j: int| 0 <= i < j < nums.len() && nums[i] + nums[j] == target,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "045-triangle_area", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn triangle_area(a: u64, h: u64) -> (area: u64)\n\n    requires\n        a > 0,\n        h > 0,\n        a * h / 2 <= u64::MAX\n        ,\n\n    ensures\n        area == a * h / 2,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "048-is-palindrome", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn is_palindrome(text: &str) -> (result: bool)\n\n    ensures\n        result == forall|i: int|\n            0 <= i < text@.len() ==> #[trigger] text@[i] == text@[text@.len() - 1 - i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "049-modp", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn modp_rec(n: nat, p: nat) -> (result:nat)\n    decreases n,\n{\n    if n == 0 {\n        1nat % p\n    } else {\n        (modp_rec((n - 1) as nat, p) * 2) % p\n    }\n}", "vc-helpers": "", "vc-spec": "#[verifier::loop_isolation(false)]\nfn modp(n: u32, p: u32) -> (r: u32)\n    by (nonlinear_arith)\n\n    requires\n        p > 0,\n\n    ensures\n        r == modp_rec(n as nat, p as nat),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "050-encode_shift", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn encode_char_spec(c: int) -> (result:int)\n    recommends\n        65 <= c <= 90,\n{\n    (c - 65 + 5) % 26 + 65\n}\nspec fn decode_char_spec(c: int) -> (result:int)\n    recommends\n        65 <= c <= 90,\n{\n    (c - 65 + 26 - 5) % 26 + 65\n}", "vc-helpers": "", "vc-spec": "#[verifier::loop_isolation(false)]\nfn decode_shift(s: &Vec<u8>) -> (t: Vec<u8>)\n\n    requires\n        forall|i: int| #![trigger s[i]] 0 <= i < s.len() ==> 65 <= s[i] <= 90,\n\n    ensures\n        s.len() == t.len(),\n        forall|i: int| #![auto] 0 <= i < t.len() ==> t[i] == decode_char_spec(s[i] as int),\n        forall|i: int| #![auto] 0 <= i < t.len() ==> encode_char_spec(t[i] as int) == s[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "051-remove_vowels", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_vowel_spec(c: char) -> (result:bool) {\n    c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I'\n        || c == 'O' || c == 'U'\n}", "vc-helpers": "", "vc-spec": "fn remove_vowels(str: &[char]) -> (str_without_vowels: Vec<char>)\n\n    ensures\n        str_without_vowels@ == str@.filter(|x: char| !is_vowel_spec(x)),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "052-below-threshold", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn below_threshold(l: &[i32], t: i32) -> (result: bool)\n\n    ensures\n        result == forall|i: int| 0 <= i < l.len() ==> l[i] < t,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "053-add", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn add(x: i32, y: i32) -> (res: Option<i32>)\n\n    ensures\n        res.is_some() ==> res.unwrap() == x + y,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "054-same-chars", "vc-description": "", "vc-preamble": "use vstd::hash_set::HashSetWithView;\nuse vstd::prelude::*;\nuse vstd::std_specs::hash::axiom_u8_obeys_hash_table_key_model;\n\nverus! {", "vc-helpers": "", "vc-spec": "#[verifier::loop_isolation(false)]\nfn same_chars(s0: &Vec<u8>, s1: &Vec<u8>) -> (same: bool)\n\n    ensures\n        same <==> (forall|i: int| #![auto] 0 <= i < s0.len() ==> s1@.contains(s0[i])) && (forall|\n            i: int,\n        |\n            #![auto]\n            0 <= i < s1.len() ==> s0@.contains(s1[i])),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "055-fib", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n#[verifier::memoize]\nspec fn spec_fib(n: nat) -> (ret:nat)\n    decreases n,\n{\n    if (n == 0) {\n        0\n    } else if (n == 1) {\n        1\n    } else {\n        spec_fib((n - 1) as nat) + spec_fib((n - 2) as nat)\n    }\n}\n\nspec fn inner_expr_fib(n: u32, ret: Option<u32>) -> (result:bool) {\n    match ret {\n        None => spec_fib(n as nat) > u32::MAX,\n        Some(f) => f == spec_fib(n as nat),\n    }\n}", "vc-helpers": "", "vc-spec": "fn fib(n: u32) -> (ret: Option<u32>)\n\n    ensures\n        inner_expr_fib(n, ret),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "056-correct_bracketing", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn spec_bracketing_helper(brackets: Seq<char>) -> (result:(int, bool)) {\n    brackets.fold_left(\n        (0, true),\n        |p: (int, bool), c|\n            {\n                let (x, b) = p;\n                match (c) {\n                    '<' => (x + 1, b),\n                    '>' => (x - 1, b && x - 1 >= 0),\n                    _ => (x, b),\n                }\n            },\n    )\n}\n\nspec fn spec_bracketing(brackets: Seq<char>) -> (result:bool) {\n    let p = spec_bracketing_helper(brackets);\n    p.1 && p.0 == 0\n}", "vc-helpers": "", "vc-spec": "fn correct_bracketing(brackets: &str) -> (ret: bool)\n\n    requires\n        brackets@.len() <= i32::MAX,\n        -brackets@.len() >= i32::MIN,\n\n    ensures\n        ret <==> spec_bracketing(brackets@),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "057-monotonic", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn monotonic(l: Vec<i32>) -> (ret: bool)\n\n    ensures\n        ret <==> (forall|i: int, j: int| 0 <= i < j < l@.len() ==> l@.index(i) <= l@.index(j)) || (\n        forall|i: int, j: int| 0 <= i < j < l@.len() ==> l@.index(i) >= l@.index(j)),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "059-largest-prime-factor", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn spec_prime_helper(num: int, limit: int) -> (ret:bool) {\n    forall|j: int| 2 <= j < limit ==> (#[trigger] (num % j)) != 0\n}\n\nspec fn spec_prime(num: int) -> (ret:bool) {\n    spec_prime_helper(num, num)\n}", "vc-helpers": "", "vc-spec": "fn largest_prime_factor(n: u32) -> (largest: u32)\n\n    requires\n        n >= 2,\n\n    ensures\n        1 <= largest <= n,\n        spec_prime(largest as int),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "060-sum_to_n", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn spec_sum_to_n(n: nat) -> (ret:nat)\n    decreases n,\n{\n    if (n == 0) {\n        0\n    } else {\n        n + spec_sum_to_n((n - 1) as nat)\n    }\n}", "vc-helpers": "", "vc-spec": "fn sum_to_n(n: u32) -> (sum: Option<u32>)\n\n    ensures\n        sum.is_some() ==> sum.unwrap() == spec_sum_to_n(n as nat),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "061-correct_bracketing", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn spec_bracketing_helper(brackets: Seq<char>) -> (ret:(int, bool)) {\n    brackets.fold_left(\n        (0, true),\n        |p: (int, bool), c|\n            {\n                let (x, b) = p;\n                match (c) {\n                    '(' => (x + 1, b),\n                    ')' => (x - 1, b && x - 1 >= 0),\n                    _ => (x, b),\n                }\n            },\n    )\n}\n\nspec fn spec_bracketing(brackets: Seq<char>) -> (ret:bool) {\n    let p = spec_bracketing_helper(brackets);\n    p.1 && p.0 == 0\n}", "vc-helpers": "", "vc-spec": "fn correct_bracketing(brackets: &str) -> (ret: bool)\n\n    requires\n        brackets@.len() <= i32::MAX,\n        -brackets@.len() >= i32::MIN,\n\n    ensures\n        ret <==> spec_bracketing(brackets@),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "062-derivative", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn derivative(xs: &Vec<usize>) -> (ret: Option<Vec<usize>>)\n\n    ensures\n        ret.is_some() ==> xs@.len() == 0 || xs@.map(|i: int, x| i * x).skip(1)\n            =~= ret.unwrap()@.map_values(|x| x as int),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "063-fibfib", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn spec_fibfib(n: nat) -> (ret: nat)\n    decreases n,\n{\n    if (n == 0) {\n        0\n    } else if (n == 1) {\n        0\n    } else if (n == 2) {\n        1\n    } else {\n        spec_fibfib((n - 1) as nat) + spec_fibfib((n - 2) as nat) + spec_fibfib((n - 3) as nat)\n    }\n}", "vc-helpers": "", "vc-spec": "fn fibfib(x: u32) -> (ret: Option<u32>)\n\n    ensures\n        ret.is_some() ==> spec_fibfib(x as nat) == ret.unwrap(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "064-vowel_count", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_vowel(c: char) -> (ret:bool) {\n    c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I'\n        || c == 'O' || c == 'U'\n}\n\nspec fn vowels(s: Seq<char>) -> (ret:Seq<char>) {\n    s.filter(|c| is_vowel(c))\n}\n\nspec fn inner_expr_vowels_count(s: &str, ret: u32) -> (ret:bool) {\n    ret == vowels(s@).len() + if (s@.len() > 0 && (s@.last() == 'y' || s@.last() == 'Y')) {\n        1int\n\n    } else {\n        0int\n    }\n}", "vc-helpers": "", "vc-spec": "fn vowels_count(s: &str) -> (ret: u32)\n\n    requires\n        s@.len() <= u32::MAX,\n\n    ensures\n        inner_expr_vowels_count(s, ret),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "066-digitSum", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_upper_case(c: char) -> (ret:bool) {\n    c >= 'A' && c <= 'Z'\n}\n\nspec fn count_uppercase_sum(seq: Seq<char>) -> (ret:int)\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n        0\n    } else {\n        count_uppercase_sum(seq.drop_last()) + if is_upper_case(seq.last()) {\n            seq.last() as int\n        } else {\n            0 as int\n        }\n    }\n}", "vc-helpers": "", "vc-spec": "fn digit_sum(text: &[char]) -> (sum: u128)\n\n    ensures\n        count_uppercase_sum(text@) == sum,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "068-pluck", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn pluck_smallest_even(nodes: &Vec<u32>) -> (result: Vec<u32>)\n\n    requires\n        nodes@.len() <= u32::MAX,\n\n    ensures\n        result@.len() == 0 || result@.len() == 2,\n        result@.len() == 0 ==> forall|i: int| 0 <= i < nodes@.len() ==> nodes@[i] % 2 != 0,\n        result@.len() == 2 ==> {\n            let node = result@[0];\n            let index = result@[1];\n            &&& 0 <= index < nodes@.len()\n            &&& nodes@[index as int] == node\n            &&& node % 2 == 0\n            &&& forall|i: int|\n                0 <= i < nodes@.len() && nodes@[i] % 2 == 0 ==> node <= nodes@[i] && forall|i: int|\n                    0 <= i < result@[1] ==> nodes@[i] % 2 != 0 || nodes@[i] > node\n        },", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "070-strange_sort_list", "vc-description": "", "vc-preamble": "use vstd::calc;\nuse vstd::prelude::*;\nuse vstd::seq_lib::lemma_multiset_commutative;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn strange_sort_list(s: &Vec<i32>) -> (ret: Vec<i32>)\n\n    ensures\n        s@.len() == ret@.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "073-smallest_change", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn zip_halves<T>(v: Seq<T>) -> (ret: Seq<(T, T)>) {\n    v.take((v.len() / 2) as int).zip_with(v.skip(((v.len() + 1) / 2) as int).reverse())\n}\n\nspec fn diff(s: Seq<(i32, i32)>) -> (ret: int) {\n    s.fold_left(\n        0,\n        |acc: int, x: (i32, i32)|\n            if (x.0 != x.1) {\n                acc + 1\n            } else {\n                acc\n            },\n    )\n}", "vc-helpers": "", "vc-spec": "fn smallest_change(v: Vec<i32>) -> (change: usize)\n\n    requires\n        v@.len() < usize::MAX,\n\n    ensures\n        change == diff(zip_halves(v@)),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "074-total_match", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn spec_sum(s: Seq<nat>) -> (ret: int) {\n    s.fold_left(0, |x: int, y| x + y)\n}\n\nspec fn total_str_len(strings: Seq<&str>) -> (ret: int) {\n    spec_sum(strings.map_values(|s: &str| s@.len()))\n}\nspec fn inner_expr_total_match<'a>(lst1: Vec<&'a str>, lst2: Vec<&'a str>, ret: Option<Vec<&'a str>>) -> (ret:bool) {\n    ret.is_some() ==> ret.unwrap() == if total_str_len(lst1@) <= total_str_len(lst2@) {\n        lst1\n    } else {\n        lst2\n    }\n}", "vc-helpers": "", "vc-spec": "fn total_match<'a>(lst1: Vec<&'a str>, lst2: Vec<&'a str>) -> (ret: Option<Vec<&'a str>>)\n\n    ensures\n        ret.is_some() <== total_str_len(lst1@) <= usize::MAX && total_str_len(lst2@) <= usize::MAX,\n        inner_expr_total_match(lst1, lst2, ret),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "075-is_multiply_prime", "vc-description": "", "vc-preamble": "use vstd::arithmetic::mul::*;\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn spec_prime(p: int) -> (ret:bool) {\n    p > 1 && forall|k: int| 1 < k < p ==> #[trigger] (p % k) != 0\n}", "vc-helpers": "", "vc-spec": "fn is_multiply_prime(x: u32) -> (ans: bool)\n\n    requires\n        x > 1,\n\n    ensures\n        ans <==> exists|a: int, b: int, c: int|\n            spec_prime(a) && spec_prime(b) && spec_prime(c) && x == a * b * c,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "080-is_happy", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn three_distinct_spec(s: Seq<char>, i: int) -> (ret:bool)\n    recommends\n        0 < i && i + 1 < s.len(),\n{\n    (s[i - 1] != s[i]) && (s[i] != s[i + 1]) && (s[i] != s[i + 1])\n}\nspec fn happy_spec(s: Seq<char>) -> (ret:bool) {\n    s.len() >= 3 && (forall|i: int| 0 < i && i + 1 < s.len() ==> three_distinct_spec(s, i))\n}", "vc-helpers": "", "vc-spec": "#[verifier::loop_isolation(false)]\nfn is_happy(s: &Vec<char>) -> (happy: bool)\n\n    ensures\n        happy <==> happy_spec(s@),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "082-prime_length", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_divisible(n: int, divisor: int) -> (ret:bool) {\n    (n % divisor) == 0\n}\n\nspec fn is_prime(n: int) -> (ret:bool) {\n    if n < 2 {\n        false\n    } else {\n        (forall|k: int| 2 <= k < n ==> !is_divisible(n as int, k))\n    }\n}", "vc-helpers": "", "vc-spec": "fn prime_length(str: &[char]) -> (result: bool)\n\n    ensures\n        result == is_prime(str.len() as int),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "085-add", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn odd_or_zero(x: u32) -> (ret:u32) {\n    if x % 2 == 0 {\n        x\n    } else {\n        0\n    }\n}\n\nspec fn add_odd_evens(lst: Seq<u32>) -> (ret:int)\n    decreases lst.len(),\n{\n    if (lst.len() < 2) {\n        0\n    } else {\n        odd_or_zero(lst[1]) + add_odd_evens(lst.skip(2))\n    }\n}", "vc-helpers": "", "vc-spec": "fn add(lst: Vec<u32>) -> (sum: u64)\n\n    requires\n        0 < lst.len() < u32::MAX,\n\n    ensures\n        sum == add_odd_evens(lst@),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "136-largest_smallest_integers", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn largest_smallest_integers(arr: &Vec<i32>) -> (res: (Option<i32>, Option<i32>))\n\n    ensures\n        ({\n            let a = res.0;\n            let b = res.1;\n            &&& a.is_none() ==> forall|i: int| 0 <= i < arr@.len() ==> arr@[i] >= 0\n            &&& a.is_some() ==> arr@.contains(a.unwrap()) && a.unwrap() < 0\n            &&& a.is_some() ==> forall|i: int|\n                0 <= i < arr@.len() && arr@[i] < 0 ==> arr@[i] <= a.unwrap()\n            &&& b.is_none() ==> forall|i: int| 0 <= i < arr@.len() ==> arr@[i] <= 0\n            &&& b.is_some() ==> arr@.contains(b.unwrap()) && b.unwrap() > 0\n            &&& b.is_some() ==> forall|i: int|\n                0 <= i < arr@.len() && arr@[i] > 0 ==> arr@[i] >= b.unwrap()\n        }),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "139-special_factorial", "vc-description": "", "vc-preamble": "use vstd::arithmetic::mul::*;\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn factorial(n: nat) -> (ret:nat)\n    decreases n,\n{\n    if n <= 1 {\n        1\n    } else {\n        n * factorial((n - 1) as nat)\n    }\n}\n\nspec fn brazilian_factorial(n: nat) -> (ret:nat)\n    decreases n,\n{\n    if n <= 1 {\n        factorial(1)\n    } else {\n        factorial(n) * brazilian_factorial((n - 1) as nat)\n    }\n}", "vc-helpers": "", "vc-spec": "fn brazilian_factorial_impl(n: u64) -> (ret: Option<u64>)\n\n    ensures\n        match ret {\n            None => brazilian_factorial(n as nat) > u64::MAX,\n            Some(bf) => bf == brazilian_factorial(n as nat),\n        },", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "146-specialFilter", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn extract_first_digit_spec(n: int) -> (ret:int)\n    decreases n,\n{\n    if n < 10 {\n        n\n    } else {\n        extract_first_digit_spec(n / 10)\n    }\n}\nspec fn extract_last_digit_spec(n: int) -> (ret:int) {\n    n % 10\n}\nspec fn is_odd(n: int) -> (ret:bool) {\n    (n % 2) != 0\n}\n\nspec fn is_valid_element_spec(n: int) -> (ret:bool) {\n    &&& (n > 10)\n    &&& is_odd(extract_first_digit_spec(n))\n    &&& is_odd(extract_last_digit_spec(n))\n}\nspec fn special_filter_spec(seq: Seq<i32>) -> (ret:int)\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n        0\n    } else {\n        special_filter_spec(seq.drop_last()) + if (is_valid_element_spec(seq.last() as int)) {\n            1 as int\n        } else {\n            0 as int\n        }\n    }\n}", "vc-helpers": "", "vc-spec": "fn special_filter(numbers: &Vec<i32>) -> (count: usize)\n\n    ensures\n        count == special_filter_spec(numbers@),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
