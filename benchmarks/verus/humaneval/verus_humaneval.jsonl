{"id": "VH0000", "language": "verus", "source": "humaneval", "source_id": "humaneval_000", "vc-description": "This verification task involves implementing a method to determine if any two numbers in a given list have an absolute difference less than a specified threshold. The implementation uses nested loops to compare all pairs of elements and returns true as soon as a close pair is found, or false if no such pair exists.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(numbers: Seq<int>, threshold: int) -> bool {\n    true\n}\n\nspec fn abs_diff(a: int, b: int) -> int {\n    if a >= b { a - b } else { b - a }\n}\n\nspec fn has_close_elements(numbers: Seq<int>, threshold: int) -> bool {\n    exists|i: int, j: int| 0 <= i < j < numbers.len() && abs_diff(numbers[i], numbers[j]) < threshold\n}\n\nspec fn seq_map_to_int(numbers: Seq<i8>) -> Seq<int> {\n        numbers.map(|_i: int, x: i8| x as int)\n}", "vc-helpers": "", "vc-spec": "fn has_close_elements_impl(numbers: Vec<i8>, threshold: i8) -> (result: bool)\n    requires valid_input(seq_map_to_int(numbers@), threshold as int)\n    ensures result == has_close_elements(seq_map_to_int(numbers@), threshold as int)", "vc-code": "{\n    assume(false);\n    false\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0001", "language": "verus", "source": "humaneval", "source_id": "humaneval_001_separate-paren-groups", "vc-description": "function_signature: def separate_paren_groups(paren_string: str) -> List[str]\n\nInput to this function is a string containing multiple groups of nested parentheses.\nYour goal is to separate those group into separate strings and return the list of\nthose. Separate groups are balanced (each open brace is properly closed) and not\nnested within each other Ignore any spaces in the input string.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn parentheses_depth(s: Seq<char>, i: int, j: int) -> int\n    decreases j - i\n{\n    if !(0 <= i <= j <= s.len()) {\n        0\n    } else if i == j {\n        0\n    } else if s[i] == '(' {\n        parentheses_depth(s, i + 1, j) + 1\n    } else if s[i] == ')' {\n        parentheses_depth(s, i + 1, j) - 1\n    } else {\n        parentheses_depth(s, i + 1, j)\n    }\n}\n\nspec fn inner_depths_positive(s: Seq<char>) -> bool {\n    forall|i: int| 0 < i < s.len() ==> parentheses_depth(s, 0, i) > 0\n}\n\nspec fn inner_depths_nonnegative(s: Seq<char>) -> bool {\n    forall|i: int| 0 < i < s.len() ==> parentheses_depth(s, 0, i) >= 0\n}", "vc-helpers": "", "vc-spec": "fn separate_paren_groups(paren_string: Vec<char>) -> (res: Vec<Vec<char>>)\n    requires \n        parentheses_depth(paren_string@, 0, paren_string.len() as int) == 0,\n        inner_depths_nonnegative(paren_string@)\n    ensures \n        forall|k: int| 0 <= k < res.len() ==> parentheses_depth(#[trigger] res[k as int]@, 0, res[k as int].len() as int) == 0,\n        forall|k: int| 0 <= k < res.len() ==> inner_depths_positive(#[trigger] res[k as int]@)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0002", "language": "verus", "source": "humaneval", "source_id": "humaneval_002", "vc-description": "This task implements a function to extract the decimal (fractional)\npart of a positive floating point number. Given a number like 3.5, it should return\n0.5, and for 1.25, it should return 0.25. The implementation involves subtracting\nthe floor (integer part) from the original number.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(number: int) -> bool {\n    number >= 0\n}\n\nspec fn valid_output(result: int, input: int) -> bool {\n    0 <= result < 1 && result == input - floor_spec(input)\n}\n\nspec fn floor_spec(x: int) -> int {\n    if x >= 0 {\n        floor_nonnegative(x)\n    } else {\n        -ceil_nonnegative(-x)\n    }\n}\n\nspec fn floor_nonnegative(x: int) -> int {\n    floor_helper(x, 0)\n}\n\nspec fn floor_helper(x: int, n: int) -> int \n    decreases x when x >= 0 && n >= 0\n{\n    if x < 1 { \n        n\n    } else { \n        floor_helper(x - 1, n + 1)\n    }\n}\n\nspec fn ceil_nonnegative(x: int) -> int {\n    if x == 0 { \n        0\n    } else if floor_nonnegative(x) == x {\n        x\n    } else {\n        floor_nonnegative(x) + 1\n    }\n}", "vc-helpers": "", "vc-spec": "fn truncate_number(number: i8) -> (result: i8)\n    requires valid_input(number as int)\n    ensures valid_output(result as int, number as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0003", "language": "verus", "source": "humaneval", "source_id": "humaneval_003", "vc-description": "Given a list of integers representing bank account operations (positive for deposits, negative for withdrawals), determine if the account balance ever drops below zero. The account starts with a balance of zero.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sum_prefix(ops: Seq<int>, len: nat) -> int\n  recommends len <= ops.len()\n  decreases len\n{\n  if len == 0 { 0 }\n  else { sum_prefix(ops, (len - 1) as nat) + ops[len - 1] }\n}\n\nspec fn vec_to_seq_int(v: Vec<i8>) -> Seq<int> {\n  v@.map(|i, x: i8| x as int)\n}\n\n  // </vc-preamble>", "vc-helpers": "", "vc-spec": "fn below_zero(operations: Vec<i8>) -> (result: bool)\n  ensures result <==> (exists|i: int| 0 < i <= operations@.len() && #[trigger] sum_prefix(vec_to_seq_int(operations), i as nat) < 0)", "vc-code": "{\n    assume(false);\n    false\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0005", "language": "verus", "source": "humaneval", "source_id": "humaneval_005", "vc-description": "This verification task involves implementing a method that inserts a delimiter between every two consecutive elements in a sequence of integers. The method should handle edge cases like empty sequences or single-element sequences, and for longer sequences, it should produce a result with alternating original elements and delimiters.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(numbers: Seq<int>, delimiter: int) -> bool {\n        true /* Any sequence and delimiter are valid inputs */\n}\n    \nspec fn valid_output(numbers: Seq<int>, delimiter: int, result: Seq<int>) -> bool {\n        if numbers.len() <= 1 {\n            result == numbers\n        } else {\n            result.len() == 2 * numbers.len() - 1 &&\n            (forall|i: int| 0 <= i < numbers.len() ==> #[trigger] result[2 * i] == numbers[i]) &&\n            (forall|i: int| 0 <= i < numbers.len() - 1 ==> #[trigger] result[2 * i + 1] == delimiter)\n        }\n}", "vc-helpers": "", "vc-spec": "fn insert_delimiter(numbers: Vec<i8>, delimiter: i8) -> (result: Vec<i8>)\n    requires valid_input(numbers@.map(|_i: int, x: i8| x as int), delimiter as int)\n    ensures valid_output(numbers@.map(|_i: int, x: i8| x as int), delimiter as int, result@.map(|_i: int, x: i8| x as int))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0006", "language": "verus", "source": "humaneval", "source_id": "humaneval_006", "vc-description": "This verification task implements a parser for nested parentheses strings. Given a string containing groups of nested parentheses separated by spaces, the goal is to find the maximum nesting depth for each group independently. The implementation must correctly split the input by spaces, calculate nesting depths, and return a sequence of maximum depths corresponding to each group.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn split_by_spaces_result(s: Seq<char>) -> Seq<Seq<char>> {\n    if s.len() == 0 {\n        seq![]\n    } else {\n        let groups = seq![];\n        let current_group = seq![];\n        let i = 0;\n        split_by_spaces_helper(s, i, current_group, groups)\n    }\n}\n\nspec fn max_nesting_depth(group: Seq<char>) -> int {\n    max_nesting_depth_helper(group, 0, 0, 0)\n}\n\nspec fn split_by_spaces_helper(s: Seq<char>, i: int, current_group: Seq<char>, groups: Seq<Seq<char>>) -> Seq<Seq<char>>\n    decreases s.len() - i when 0 <= i <= s.len()\n{\n    if i == s.len() {\n        if current_group.len() > 0 { groups.push(current_group) } else { groups }\n    } else if s[i] == ' ' {\n        if current_group.len() > 0 {\n            split_by_spaces_helper(s, i + 1, seq![], groups.push(current_group))\n        } else {\n            split_by_spaces_helper(s, i + 1, current_group, groups)\n        }\n    } else {\n        split_by_spaces_helper(s, i + 1, current_group.push(s[i]), groups)\n    }\n}\n\nspec fn max_nesting_depth_helper(group: Seq<char>, index: int, current_depth: int, max_depth: int) -> int\n    decreases group.len() - index when 0 <= index <= group.len()\n{\n    if index == group.len() {\n        max_depth\n    } else if group[index] == '(' {\n        let new_current = current_depth + 1;\n        let new_max = if new_current > max_depth { new_current } else { max_depth };\n        max_nesting_depth_helper(group, index + 1, new_current, new_max)\n    } else if group[index] == ')' {\n        max_nesting_depth_helper(group, index + 1, current_depth - 1, max_depth)\n    } else {\n        max_nesting_depth_helper(group, index + 1, current_depth, max_depth)\n    }\n}\n\nfn split_by_spaces(s: Seq<char>) -> (groups: Seq<Seq<char>>)\n    requires forall|i: int| 0 <= i < s.len() ==> s[i] == '(' || s[i] == ')' || s[i] == ' '\n{\n    assume(false);\n    unreached()\n}", "vc-helpers": "", "vc-spec": "fn parse_nested_parens(paren_string: Vec<char>) -> (result: Vec<i8>)\n    requires forall|i: int| 0 <= i < paren_string@.len() ==> paren_string@[i] == '(' || paren_string@[i] == ')' || paren_string@[i] == ' '\n    ensures forall|i: int| 0 <= i < result@.len() ==> result[i] as int >= 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0007", "language": "verus", "source": "humaneval", "source_id": "humaneval_007", "vc-description": "This task implements a string filtering function that takes a list\nof strings and a substring, returning a new list containing only the strings that\ncontain the given substring. The filtering should preserve the original order of\nmatching strings and be case-sensitive.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn contains_substring(s: Seq<char>, sub: Seq<char>) -> bool\n    decreases s.len()\n{\n    if sub.len() == 0 { \n        true\n    } else if sub.len() > s.len() { \n        false\n    } else if s.len() == sub.len() {\n        s == sub\n    } else {\n        (s.subrange(0, sub.len() as int) == sub) || contains_substring(s.subrange(1, s.len() as int), sub)\n    }\n}\n\nspec fn filter_sequence(strings: Seq<Seq<char>>, substring: Seq<char>) -> Seq<Seq<char>> {\n    filter_sequence_helper(strings, substring, strings.len() as int)\n}\n\nspec fn filter_sequence_helper(strings: Seq<Seq<char>>, substring: Seq<char>, n: int) -> Seq<Seq<char>>\n    decreases n when 0 <= n <= strings.len()\n{\n    if n <= 0 {\n        strings.take(0 as int)\n    } else if contains_substring(strings[n-1], substring) {\n        filter_sequence_helper(strings, substring, n-1).push(strings[n-1])\n    } else {\n        filter_sequence_helper(strings, substring, n-1)\n    }\n}", "vc-helpers": "", "vc-spec": "fn filter_by_substring(strings: Seq<Seq<char>>, substring: Seq<char>) -> (result: Seq<Seq<char>>)\n    ensures \n        result.len() <= strings.len(),\n        forall|i: int| 0 <= i < result.len() ==> strings.contains(result[i]),\n        forall|i: int| 0 <= i < result.len() ==> contains_substring(result[i], substring),\n        forall|i: int| 0 <= i < strings.len() && contains_substring(strings[i], substring) ==> result.contains(strings[i]),\n        forall|i: int, j: int| 0 <= i < j < result.len() ==> \n            exists|k1: int, k2: int| 0 <= k1 < k2 < strings.len() && #[trigger] result[i] =~= strings[k1] && #[trigger] result[j] =~= strings[k2],\n        forall|s: Seq<char>| result.contains(s) <==> (strings.contains(s) && contains_substring(s, substring)),\n        result =~= filter_sequence(strings, substring)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0008", "language": "verus", "source": "humaneval", "source_id": "humaneval_008", "vc-description": "This verification task implements a method to compute both the sum\nand product of all integers in a given sequence. For an empty list, the method should\nreturn (0, 1) representing the empty sum and empty product respectively. The implementation\nuses iterative computation while maintaining loop invariants to ensure correctness.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s[0] + sum_seq(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn product_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        1\n    } else {\n        s[0] * product_seq(s.subrange(1, s.len() as int))\n    }\n}", "vc-helpers": "proof fn sum_seq_append(s: Seq<int>, x: int)\n    ensures sum_seq(s.add(seq![x])) == sum_seq(s) + x\n    decreases s.len()\n{\n    assume(false); /* TODO: Remove this line and implement the proof */\n}\n\nproof fn product_seq_append(s: Seq<int>, x: int)\n    ensures product_seq(s.add(seq![x])) == product_seq(s) * x\n    decreases s.len()\n{\n    assume(false); /* TODO: Remove this line and implement the proof */\n}", "vc-spec": "fn sum_product(numbers: Vec<i8>) -> (result: (i8, i8))\n    ensures ({\n        let (sum, product) = result;\n        sum as int == sum_seq(numbers@.map(|i, x| x as int)) &&\n        product as int == product_seq(numbers@.map(|i, x| x as int)) &&\n        (numbers@.len() == 0 ==> sum == 0 && product == 1)\n    })", "vc-code": "{\n    assume(false);\n    (0, 1)\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0009", "language": "verus", "source": "humaneval", "source_id": "humaneval_009", "vc-description": "This verification task implements a rolling maximum function that\ntakes a list of integers and returns a list where each element represents the maximum\nvalue encountered from the beginning of the list up to and including the current\nposition.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn max_up_to(numbers: Seq<int>, index: int) -> int\n    decreases index when 0 <= index < numbers.len()\n{\n    if 0 <= index < numbers.len() {\n        if index == 0 {\n            numbers[0]\n        } else {\n            let prev_max = max_up_to(numbers, index - 1);\n            if numbers[index] > prev_max { numbers[index] } else { prev_max }\n        }\n    } else {\n        0\n    }\n}", "vc-helpers": "spec fn vec_to_seq_int(v: Vec<i8>) -> Seq<int> {\n    v@.map(|i, x| x as int)\n}", "vc-spec": "fn rolling_max(numbers: Vec<i8>) -> (result: Vec<i8>)\n    ensures \n        result.len() == numbers.len() &&\n        (numbers.len() == 0 ==> result.len() == 0) &&\n        (numbers.len() > 0 ==> result.len() > 0) &&\n        (forall|i: int| #![trigger result[i]] 0 <= i < result.len() ==>\n            result[i] as int == max_up_to(vec_to_seq_int(numbers), i)) &&\n        (forall|i: int| #![trigger result[i]] 0 <= i < result.len() ==>\n            forall|j: int| #![trigger numbers@[j]] 0 <= j <= i ==> numbers@[j] as int <= result[i] as int) &&\n        (forall|i: int| #![trigger result[i]] 0 <= i < result.len() ==>\n            exists|j: int| 0 <= j <= i && numbers@[j] as int == result[i] as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0010", "language": "verus", "source": "humaneval", "source_id": "humaneval_010_is_palindrome__make_palindrome", "vc-description": "function_signature: fn make_palindrome(s: &str) -> (result: String)\n\nProcess input. Ensures: the size is bounded; the result is a palindrome; ensures starts_with(result, s).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_palindrome(s: Seq<char>) -> bool {\n    forall|k: int| #![trigger s.index(k)] 0 <= k < s.len() ==> s.index(k) == s.index(s.len() - 1 - k)\n}\n\nspec fn starts_with(result: Seq<char>, s: Seq<char>) -> bool {\n    result.len() >= s.len() && forall|k: int| #![trigger result.index(k)] 0 <= k < s.len() ==> result.index(k) == s.index(k)\n}", "vc-helpers": "", "vc-spec": "fn make_palindrome(s: &str) -> (result: String)\n    ensures \n        result@.len() <= 2 * s@.len(),\n        is_palindrome(result@),\n        starts_with(result@, s@)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0011", "language": "verus", "source": "humaneval", "source_id": "humaneval_011", "vc-description": "This task implements a bitwise XOR operation on two binary strings\nof equal length. Given two strings containing only '0' and '1' characters, the method\nshould return a new string where each position contains '0' if the corresponding\ncharacters in the input strings are the same, and '1' if they are different.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_binary_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}", "vc-helpers": "", "vc-spec": "fn string_xor(a: Vec<char>, b: Vec<char>) -> (result: Vec<char>)\n    requires \n        a.len() == b.len(),\n        is_binary_string(a@),\n        is_binary_string(b@),\n    ensures \n        result.len() == a.len(),\n        is_binary_string(result@),\n        forall|i: int| 0 <= i < a.len() as int ==> \n            (a@[i] == b@[i] ==> result@[i] == '0') &&\n            (a@[i] != b@[i] ==> result@[i] == '1'),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0012", "language": "verus", "source": "humaneval", "source_id": "humaneval_012", "vc-description": "This task involves finding the longest string in a sequence of strings.\nIf multiple strings have the same maximum length, the method should return the first\none that appears in the list. If the list is empty, it should return None using\nan Option type.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_result(strings: Seq<Seq<char>>, result: Option<Seq<char>>) -> bool {\n    if strings.len() == 0 {\n        matches!(result, Option::None)\n    } else {\n        match result {\n            Option::Some(value) => {\n                exists|i: int| 0 <= i < strings.len() && #[trigger] strings[i] == value &&\n                (forall|s: Seq<char>| strings.contains(s) ==> value.len() >= #[trigger] (s.len())) &&\n                (forall|j: int| 0 <= j < i ==> #[trigger] (strings[j].len()) < value.len())\n            },\n            Option::None => false\n        }\n    }\n}", "vc-helpers": "", "vc-spec": "fn longest(strings: Vec<Vec<char>>) -> (result: Option<Vec<char>>)\n    ensures match result {\n        Option::Some(value) => valid_result(strings@.map(|_i: int, v: Vec<char>| v@), Option::Some(value@)),\n        Option::None => valid_result(strings@.map(|_i: int, v: Vec<char>| v@), Option::None),\n    }", "vc-code": "{\n    assume(false);\n    Option::None\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0013", "language": "verus", "source": "humaneval", "source_id": "humaneval_013", "vc-description": "This task involves implementing the greatest common divisor (GCD)\nfunction for two integers. The GCD is the largest positive integer that divides\nboth numbers without remainder, with special cases for zero values.\n\nThe implementation should use the Euclidean algorithm, which repeatedly applies\nthe property that GCD(a,b) = GCD(b, a mod b) until one operand becomes zero.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn abs(x: int) -> nat {\n    if x >= 0 { x as nat } else { (-x) as nat }\n}\n\nspec fn divides(d: int, n: int) -> bool {\n    if d == 0 { n == 0 } else { n % d == 0 }\n}", "vc-helpers": "", "vc-spec": "fn greatest_common_divisor(a: i8, b: i8) -> (result: u8)\n    ensures \n        result > 0 <==> (a != 0 || b != 0),\n        result == 0 <==> (a == 0 && b == 0),\n        divides(result as int, a as int) && divides(result as int, b as int),\n        forall|d: int| d > 0 && divides(d, a as int) && divides(d, b as int) ==> d <= result as int", "vc-code": "{\n    assume(false);\n    0\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0014", "language": "verus", "source": "humaneval", "source_id": "humaneval_014", "vc-description": "Given a string, return a list of all its prefixes ordered from shortest\nto longest. A prefix is a substring that starts from the beginning of the original\nstring.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_prefixes(s: Seq<char>, result: Seq<Seq<char>>) -> bool {\n    result.len() == s.len() &&\n    forall|i: int| 0 <= i < result.len() ==> result[i] == s.subrange(0, i + 1)\n}", "vc-helpers": "", "vc-spec": "fn all_prefixes(s: Vec<char>) -> (result: Vec<Vec<char>>)\n    ensures valid_prefixes(s@, result@.map(|i, v: Vec<char>| v@))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0015", "language": "verus", "source": "humaneval", "source_id": "humaneval_016", "vc-description": "Count the number of distinct characters in a string, ignoring case\ndifferences. The implementation should return an integer representing the count\nof unique characters, treating 'A' and 'a' as the same character through case-insensitive\ncomparison.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn to_lower_char(c: char) -> char {\n    if 'A' <= c && c <= 'Z' {\n        ((c as u8 - 'A' as u8 + 'a' as u8) as char)\n    } else {\n        c\n    }\n}\n\nspec fn char_set_from_string(s: Seq<char>) -> Set<char> {\n    Set::new(|c: char| exists|i: int| 0 <= i < s.len() && #[trigger] to_lower_char(s[i]) == c)\n}", "vc-helpers": "", "vc-spec": "fn count_distinct_characters(s: &str) -> (count: usize)\n    ensures \n        count <= s@.len(),\n        count == char_set_from_string(s@).len(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0016", "language": "verus", "source": "humaneval", "source_id": "humaneval_018_how_many_times", "vc-description": "function_signature: fn how_many_times(string: Seq<char>, substring: Seq<char>) -> usize\n\nFind how many times a given substring can be found in the original string. Count\noverlaping cases.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn how_many_times(s: Vec<char>, substr: Vec<char>) -> (times: usize)\n    ensures times == Set::new(|i: int| 0 <= i <= s@.len() - substr@.len() && s@.subrange(i, i + substr@.len()) == substr@).len()", "vc-code": "{\n    assume(false);\n    0\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0017", "language": "verus", "source": "humaneval", "source_id": "humaneval_020", "vc-description": "Given a list of numbers with at least two elements, find the pair\nof numbers with the smallest absolute difference between them. Return the pair as\na tuple ordered from smaller to larger value. The implementation uses nested loops\nto compare all pairs and track the minimum difference found.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn abs_diff(x: int, y: int) -> int {\n        if x >= y { x - y } else { y - x }\n    }\n    \nspec fn valid_input(numbers: Seq<int>) -> bool {\n        numbers.len() >= 2\n    }\n    \nspec fn is_optimal_pair(numbers: Seq<int>, pair: (int, int)) -> bool {\n        numbers.contains(pair.0) &&\n        numbers.contains(pair.1) &&\n        pair.0 <= pair.1 &&\n        forall|i: int, j: int| 0 <= i < numbers.len() && 0 <= j < numbers.len() && i != j ==>\n            abs_diff(numbers[i], numbers[j]) >= abs_diff(pair.0, pair.1)\n    }\n    \n// </vc-preamble>", "vc-helpers": "", "vc-spec": "fn find_closest_elements(numbers: Vec<i8>) -> (result: (i8, i8))\n    requires valid_input(numbers@.map(|_index, x| x as int))\n    ensures is_optimal_pair(numbers@.map(|_index, x| x as int), (result.0 as int, result.1 as int))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0018", "language": "verus", "source": "humaneval", "source_id": "humaneval_021_rescale_to_unit", "vc-description": "function_signature: def rescale_to_unit(numbers: List[float]) -> List[float]\n\nGiven list of numbers (of at least two elements), apply a linear transform to that\nlist, such that the smallest number will become 0 and the largest will become 1", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn affine(x: int, shift: int, scale: int) -> int {\n    if scale > 0 { (x + shift) / scale } else { 0 }\n}\n\nspec fn affine_seq(s: Seq<int>, r: Seq<int>, shift: int, scale: int) -> bool {\n        scale > 0 && r.len() == s.len() &&\n        forall|i: int| 0 <= i < s.len() ==> #[trigger] r[i] == #[trigger] affine(s[i], shift, scale)\n}", "vc-helpers": "", "vc-spec": "fn rescale_to_unit(s: Vec<i8>) -> (r: Vec<i8>)\n    requires s@.len() >= 2,\n             exists|i: int, j: int| (0 <= i < j < s@.len()) && s@[i] != s@[j]\n    ensures r@.len() == s@.len(),\n            forall|i: int| 0 <= i < s@.len() ==> 0 <= r@[i] as int && r@[i] as int <= 1,\n            exists|i: int| 0 <= i < s@.len() && r@[i] as int == 0,\n            exists|i: int| 0 <= i < s@.len() && r@[i] as int == 1,\n            ({\n                let s_int = s@.map(|i, x| x as int);\n                let r_int = r@.map(|i, x| x as int);\n                exists|shift: int, scale: int| affine_seq(s_int, r_int, shift, scale) && scale > 0\n            })", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0019", "language": "verus", "source": "humaneval", "source_id": "humaneval_022", "vc-description": "Given a list containing values of various types, return a new list\ncontaining only the integer values. In Python, booleans are considered integers\n(True=1, False=0), so they should be included in the result. The task requires implementing\na function that filters a sequence of mixed-type values to extract only integers\nand boolean values (converted to 0/1).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\npub enum Value {\n    IntVal(int),\n    BoolVal(bool),\n    StringVal(Seq<char>),\n    RealVal(int), /* using int for real approximation */\n    OtherVal,\n}\n\nspec fn valid_input(values: Seq<Value>) -> bool {\n    true  /* All sequences of Value are valid input */\n}\n\nspec fn integer_values(values: Seq<Value>) -> Seq<int> \n    decreases values.len()\n{\n    if values.len() == 0 {\n        Seq::<int>::empty()\n    } else {\n        match values.index(0) {\n            Value::IntVal(i) => seq![i].add(integer_values(values.subrange(1, values.len() as int))),\n            Value::BoolVal(b) => seq![if b { 1int } else { 0int }].add(integer_values(values.subrange(1, values.len() as int))),\n            _ => integer_values(values.subrange(1, values.len() as int))\n        }\n    }\n}\n\nspec fn valid_output(input: Seq<Value>, output: Seq<int>) -> bool {\n    output == integer_values(input)\n}", "vc-helpers": "", "vc-spec": "fn filter_integers(values: Vec<Value>) -> (result: Vec<i8>)\n    requires\n        valid_input(values@),\n    ensures\n        valid_output(values@, result@.map(|i: int, v: i8| v as int)),\n        result.len() <= values.len()", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0020", "language": "verus", "source": "humaneval", "source_id": "humaneval_023", "vc-description": "Implement a function that returns the length of a given string. The\nfunction should handle empty strings and return 0 for them. For non-empty strings,\nit should return the count of characters.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(s: Seq<char>) -> bool {\n    true\n}\n\nspec fn correct_length(s: Seq<char>) -> int {\n    s.len() as int\n}", "vc-helpers": "", "vc-spec": "fn strlen(s: &str) -> (result: usize)\n    requires valid_input(s@)\n    ensures correct_length(s@) == (result as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0021", "language": "verus", "source": "humaneval", "source_id": "humaneval_024_largest-divisor", "vc-description": "function_signature: fn largest_divisor(n: int) -> int\n\nFor a given number n, find the largest number that divides n evenly, smaller than n", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn largest_divisor(n: i8) -> (d: i8)\n    requires \n        n as int > 1\n    ensures \n        1 <= d as int &&\n        (d as int) < (n as int) &&\n        n as int % d as int == 0 &&\n        (forall|k: int| (d as int) < k && k < (n as int) ==> #[trigger] ((n as int) % k) != 0)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0022", "language": "verus", "source": "humaneval", "source_id": "humaneval_025", "vc-description": "Given a positive integer n, return a list of its prime factors in\nascending order. Each prime factor should appear in the list as many times as it\ndivides n (i.e., according to its multiplicity in the prime factorization).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_prime(n: int) -> bool {\n    n >= 2 && forall|k: int| 2 <= k < n ==> #[trigger] (n % k) != 0\n}\n\nspec fn product(factors: Seq<int>) -> int\n    decreases factors.len()\n{\n    if factors.len() == 0 {\n        1\n    } else {\n        factors[0] * product(factors.subrange(1, factors.len() as int))\n    }\n}\n\nspec fn is_non_decreasing(factors: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < factors.len() ==> #[trigger] factors[i] <= #[trigger] factors[j]\n}", "vc-helpers": "", "vc-spec": "fn factorize(n: i8) -> (factors: Vec<i8>)\n    requires n >= 0\n    ensures \n        n <= 1 ==> factors.len() == 0,\n        n > 1 ==> product(factors@.map(|i: int, x: i8| x as int)) == n as int,\n        forall|i: int| 0 <= i < factors.len() ==> is_prime(#[trigger] factors@[i] as int),\n        is_non_decreasing(factors@.map(|i: int, x: i8| x as int)),\n        forall|i: int| 0 <= i < factors.len() ==> #[trigger] factors@[i] >= 2", "vc-code": "{\n    assume(false);\n    Vec::new()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0023", "language": "verus", "source": "humaneval", "source_id": "humaneval_026_remove_duplicates__count", "vc-description": "function_signature: fn count(a: Seq<int>, x: int) -> (cnt: int)\n\nCount occurrences. Ensures: returns the correct count; returns the correct count.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn count_rec(a: Seq<int>, x: int) -> int\n    decreases a.len()\n{\n    if a.len() == 0 {\n        0\n    } else {\n        count_rec(a.subrange(1, a.len() as int), x) + (if a[0] == x { 1 as int } else { 0 as int })\n    }\n}", "vc-helpers": "", "vc-spec": "fn count(a: Vec<i8>, x: i8) -> (cnt: i8)\n    ensures \n        cnt as int == count_rec(a@.map(|i: int, v: i8| v as int), x as int)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0024", "language": "verus", "source": "humaneval", "source_id": "humaneval_026_remove_duplicates__remove_duplicates", "vc-description": "function_signature: fn remove_duplicates(a: Seq<int>) -> (result: Seq<int>)\nProcess input. Requires: the condition holds for all values. Ensures: the condition holds for all values; the condition holds for all values.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn count_rec(a: Seq<int>, x: int) -> int\n    decreases a.len()\n{\n    if a.len() == 0 {\n        0int\n    } else {\n        count_rec(a.subrange(1, a.len() as int), x) + (if a[0] == x { 1int } else { 0int })\n    }\n}\n\n// </vc-preamble>", "vc-helpers": "", "vc-spec": "fn remove_duplicates(a: Vec<i8>) -> (result: Vec<i8>)\n    requires \n        forall|i: int| 0 <= i < a@.len() ==> count_rec(a@.map(|_i: int, x: i8| x as int), a@[i] as int) >= 1\n    ensures \n        forall|i: int| 0 <= i < result@.len() ==> count_rec(a@.map(|_i: int, x: i8| x as int), result@[i] as int) == 1,\n        forall|i: int| 0 <= i < a@.len() ==> (result@.map(|_i: int, x: i8| x as int).contains(a@[i] as int) <==> count_rec(a@.map(|_i: int, x: i8| x as int), a@[i] as int) == 1)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0025", "language": "verus", "source": "humaneval", "source_id": "humaneval_027", "vc-description": "This verification task involves implementing a string case-flipping\nfunction that converts all lowercase letters to uppercase and all uppercase letters\nto lowercase, while leaving non-alphabetic characters unchanged. The implementation\nshould process each character in the input string and return a new string with the\nappropriate case transformations.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_lowercase(c: char) -> bool {\n    'a' <= c <= 'z'\n}\n\nspec fn is_uppercase(c: char) -> bool {\n    'A' <= c <= 'Z'\n}\n\nspec fn flip_char(c: char) -> char {\n    if is_lowercase(c) { \n        ((c as u8) - ('a' as u8) + ('A' as u8)) as char\n    } else if is_uppercase(c) { \n        ((c as u8) - ('A' as u8) + ('a' as u8)) as char\n    } else { \n        c \n    }\n}\n\nspec fn valid_flip_case(s: Seq<char>, result: Seq<char>) -> bool {\n    result.len() == s.len() &&\n    forall|i: int| 0 <= i < s.len() ==> #[trigger] result[i] == #[trigger] flip_char( #[trigger] s[i])\n}", "vc-helpers": "", "vc-spec": "fn flip_case(s: Vec<char>) -> (result: Vec<char>)\n    ensures valid_flip_case(s@, result@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0026", "language": "verus", "source": "humaneval", "source_id": "humaneval_028", "vc-description": "This task involves implementing string concatenation. Given a sequence of strings, return a single string that is the concatenation of all strings in the list in order. The implementation should match the behavior of a recursive specification function.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn concat_strings(strings: Seq<Seq<char>>, index: nat) -> Seq<char>\n    decreases strings.len() - index\n{\n    if index >= strings.len() {\n        Seq::<char>::empty()\n    } else {\n        strings[index as int] + concat_strings(strings, index + 1)\n    }\n}", "vc-helpers": "", "vc-spec": "fn concatenate(strings: Vec<Vec<char>>) -> (result: Vec<char>)\n    ensures \n        result@ == concat_strings(strings@.map(|i, s: Vec<char>| s@), 0) &&\n        (strings@.len() == 0 ==> result@ == Seq::<char>::empty())", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0027", "language": "verus", "source": "humaneval", "source_id": "humaneval_029_filter_by_prefix", "vc-description": "function_signature: def filter_by_prefix(strings: List[str], prefix: str) -> List[str]\n\nFilter an input list of strings only for ones that start with a given prefix.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn starts_with(s: Seq<char>, p: Seq<char>) -> bool\n    decreases s.len() + p.len()\n{\n    p.len() == 0 || (s.len() != 0 && s.len() >= p.len() && s[0] == p[0] && starts_with(s.subrange(1, s.len() as int), p.subrange(1, p.len() as int)))\n}", "vc-helpers": "", "vc-spec": "fn filter_by_prefix(xs: Vec<Vec<char>>, p: Vec<char>) -> (filtered: Vec<Vec<char>>)\n    ensures forall|i: int| 0 <= i < filtered@.len() ==> starts_with(#[trigger] filtered@[i]@, #[trigger] p@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0028", "language": "verus", "source": "humaneval", "source_id": "humaneval_030", "vc-description": "This task implements a function to filter positive numbers from a\nlist of integers. The function should return a new sequence containing only the\npositive numbers (greater than 0) while preserving their original order from the\ninput sequence.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_positive(x: int) -> bool {\n    x > 0\n}\n\nspec fn all_positive(s: Seq<int>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> is_positive(#[trigger] s[i])\n}\n\nspec fn all_elements_from_original(result: Seq<int>, original: Seq<int>) -> bool {\n    forall|x: int| #[trigger] result.contains(x) ==> original.contains(x)\n}\n\nspec fn contains_all_positives(result: Seq<int>, original: Seq<int>) -> bool {\n    forall|i: int| 0 <= i < original.len() && is_positive(original[i]) ==> result.contains(#[trigger] original[i])\n}\n\nspec fn preserves_order(result: Seq<int>, original: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < result.len() ==> \n        (exists|k1: int, k2: int| 0 <= k1 < k2 < original.len() && original[k1] == #[trigger] result[i] && original[k2] == #[trigger] result[j] &&\n        forall|k: int| k1 < k < k2 ==> !is_positive(#[trigger] original[k]))\n}\n\nspec fn count_positives(s: Seq<int>) -> int {\n    s.len() as int\n}", "vc-helpers": "", "vc-spec": "fn get_positive(l: Vec<i8>) -> (result: Vec<i8>)\n    ensures \n        all_positive(result@.map(|i: int, x: i8| x as int)),\n        all_elements_from_original(result@.map(|i: int, x: i8| x as int), l@.map(|i: int, x: i8| x as int)),\n        contains_all_positives(result@.map(|i: int, x: i8| x as int), l@.map(|i: int, x: i8| x as int)),\n        result.len() == count_positives(l@.map(|i: int, x: i8| x as int)),\n        preserves_order(result@.map(|i: int, x: i8| x as int), l@.map(|i: int, x: i8| x as int)),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0029", "language": "verus", "source": "humaneval", "source_id": "humaneval_031", "vc-description": "This verification task involves implementing a method to determine\nif a positive integer is a prime number. A prime number is defined as a natural\nnumber greater than 1 that has exactly two distinct positive divisors: 1 and itself.\n\nThe implementation should efficiently check for primality by testing divisibility\nup to the square root of the input number, with optimizations for even numbers.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_prime_number(n: int) -> bool\n{\n    n >= 2 && forall|k: int| 2 <= k < n ==> #[trigger] (n % k) != 0\n}", "vc-helpers": "", "vc-spec": "fn is_prime(n: i8) -> (result: bool)\n    ensures result <==> is_prime_number(n as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0030", "language": "verus", "source": "humaneval", "source_id": "humaneval_033_sort_third__SortSeqPred", "vc-description": "function_signature: fn sort_seq_pred(s: Seq<int>, p: Seq<bool>) -> (sorted: Seq<int>)\n\nSort elements. Requires: returns the correct size/count. Ensures: returns the correct\nsize/count; the result is sorted according to the ordering relation; returns a sorted\npermutation of the input; the result is sorted according to the ordering relation.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn sort_seq_pred(s: Vec<i8>, p: Vec<bool>) -> (sorted: Vec<i8>)\n  requires s.len() == p.len(),\n  ensures \n    sorted.len() == s.len(),\n    forall|i: int, j: int| 0 <= i < j < sorted.len() && p[i] && p[j] ==> sorted[i] as int <= sorted[j] as int,\n    s@.to_multiset() == sorted@.to_multiset(),\n    forall|i: int| 0 <= i < s.len() && !p[i] ==> sorted[i] == s[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0031", "language": "verus", "source": "humaneval", "source_id": "humaneval_033_sort_third__sort_third", "vc-description": "function_signature: fn sort_third(a: &Vec<i8>) -> (sorted_even: Vec<i8>)\n\nSort elements. Requires: requires size of a > 0. Ensures: returns the correct\nsize/count; the result is sorted according to the ordering relation; the result\nis sorted according to the ordering relation; returns a sorted permutation of the\ninput.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn sort_third(a: &Vec<i8>) -> (sorted_even: Vec<i8>)\n    requires a@.len() > 0\n    ensures \n        sorted_even@.len() == a@.len(),\n        forall|i: int, j: int| 0 <= i < j < sorted_even@.len() && i % 3 == 0 && j % 3 == 0 ==>\n            sorted_even@[i] <= sorted_even@[j],\n        forall|i: int| 0 <= i < a@.len() && i % 3 != 0 ==> sorted_even@[i] == a@[i],\n        a@.to_multiset() == sorted_even@.to_multiset()", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0032", "language": "verus", "source": "humaneval", "source_id": "humaneval_034_unique__SortSeq", "vc-description": "function_signature: fn sort_seq(s: Seq<int>) -> (sorted: Seq<int>)\n\nSort elements. Ensures: the result is sorted according to the ordering relation;\nreturns the correct size/count; returns a sorted permutation of the input.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn sort_seq(s: Vec<i8>) -> (sorted: Vec<i8>)\n    ensures \n        forall|i: int, j: int| 0 <= i < j < sorted@.len() ==> sorted@[i] <= sorted@[j],\n        sorted@.len() == s@.len(),\n        s@.to_multiset() == sorted@.to_multiset()", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0033", "language": "verus", "source": "humaneval", "source_id": "humaneval_034_unique__unique", "vc-description": "function_signature: fn unique(s: Seq<int>) -> (result: Seq<int>)\n\nProcess input. Ensures: the condition holds for all values; the condition holds\nfor all values; the condition holds for all values.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn unique(s: Vec<i8>) -> (result: Vec<i8>)\n    ensures\n        forall|i: int, j: int| 0 <= i < j < result@.len() ==> (result@[i] as int) < (result@[j] as int) &&\n        forall|x: i8| result@.contains(x) ==> s@.contains(x) &&\n        forall|x: i8| s@.contains(x) ==> result@.contains(x)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0034", "language": "verus", "source": "humaneval", "source_id": "humaneval_034_unique__uniqueSorted", "vc-description": "function_signature: fn unique_sorted(s: Seq<int>) -> (result: Seq<int>)\n\nSort elements. Requires: the condition holds for all values. Ensures: the condition holds for all values; the condition holds for all values; the condition holds for all values.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn unique_sorted(s: Vec<i8>) -> (result: Vec<i8>)\n    requires \n        forall|i: int, j: int| 0 <= i < j < s@.len() ==> s@[i] <= s@[j],\n    ensures \n        forall|i: int, j: int| 0 <= i < j < result@.len() ==> result@[i] < result@[j],\n        forall|x: i8| result@.contains(x) ==> s@.contains(x),\n        forall|x: i8| s@.contains(x) ==> result@.contains(x),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0035", "language": "verus", "source": "humaneval", "source_id": "humaneval_035", "vc-description": "Find and return the maximum element in a given list of numbers. The\nlist must be non-empty, and the maximum element is the largest value present in\nthe list, which must be an actual element of the list.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(l: Seq<int>) -> bool {\n    l.len() > 0\n}\n\nspec fn is_max_element(l: Seq<int>, max_val: int) -> bool {\n    l.contains(max_val) && forall|i: int| 0 <= i < l.len() ==> l[i] <= max_val\n}\n\nspec fn max_element_func(l: Seq<int>) -> int\n    decreases l.len()\n{\n    if l.len() == 1 {\n        l[0]\n    } else if l.len() > 1 {\n        let rest_max = max_element_func(l.subrange(1, l.len() as int));\n        if l[0] > rest_max { l[0] } else { rest_max }\n    } else {\n        0int\n    }\n}\n\n// </vc-preamble>", "vc-helpers": "", "vc-spec": "fn find_max_element(l: Vec<i8>) -> (max_val: i8)\n    requires valid_input(l@.map(|i, x| x as int))\n    ensures is_max_element(l@.map(|i, x| x as int), max_val as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0036", "language": "verus", "source": "humaneval", "source_id": "humaneval_036_fizz_buzz__count7", "vc-description": "function_signature: fn count7(x: nat) -> (count: nat)\n\nCount occurrences. Ensures: returns the correct value.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn count7_r(x: nat) -> nat \n    decreases x\n{\n    let lst = if x % 10 == 7 { 1 as nat } else { 0 as nat };\n    if x < 10 { lst } else { lst + count7_r(x / 10) }\n}\n\nspec fn sum(s: Seq<int>) -> int \n    decreases s.len()\n{\n    if s.len() == 0 { 0 } else { s[0] + sum(s.subrange(1, s.len() as int)) }\n}", "vc-helpers": "", "vc-spec": "fn count7(x: u8) -> (count: u8)\n    ensures count as nat == count7_r(x as nat)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0037", "language": "verus", "source": "humaneval", "source_id": "humaneval_036_fizz_buzz__fizz_buzz", "vc-description": "function_signature: fn fizz_buzz(n: nat) -> (result: nat)\n\nProcess input. Requires: returns the correct size/count. Ensures: returns the correct\nvalue.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn count7_r(x: nat) -> nat\n    decreases x\n{\n    let lst = if x % 10 == 7 { 1 } else { 0 };\n    if x < 10 { lst } else { lst + count7_r(x / 10) }\n}\n\nspec fn sum(s: Seq<nat>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 { 0 } else { s[0] + sum(s.subrange(1, s.len() as int)) }\n}", "vc-helpers": "", "vc-spec": "fn fizz_buzz(n: u8) -> (result: u8)\n    ensures result as nat == sum(\n        Seq::new(n as nat, |i: int| \n            if 0 <= i < n as nat && (i % 11 == 0 || i % 13 == 0) { count7_r(i as nat) } else { 0 }\n        )\n    )", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0038", "language": "verus", "source": "humaneval", "source_id": "humaneval_037_sort_even__SortSeqPred", "vc-description": "function_signature: fn sort_seq_pred(s: Seq<int>, p: Seq<bool>) -> (sorted: Seq<int>)\n\nSort elements. Requires: returns the correct size/count. Ensures: returns the correct\nsize/count; the result is sorted according to the ordering relation; returns a sorted\npermutation of the input; the result is sorted according to the ordering relation.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn sort_seq_pred(s: Vec<i8>, p: Vec<bool>) -> (sorted: Vec<i8>)\n    requires s.len() == p.len(),\n    ensures \n        sorted.len() == s.len(),\n        forall|i: int, j: int| 0 <= i < j < sorted.len() && p[i as int] && p[j as int] ==> sorted[i] as int <= sorted[j] as int,\n        s@.to_multiset() == sorted@.to_multiset(),\n        forall|i: int| 0 <= i < s.len() && !p[i as int] ==> sorted[i] == s[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0039", "language": "verus", "source": "humaneval", "source_id": "humaneval_037_sort_even__sorted_even", "vc-description": "function_signature: fn sorted_even(a: Seq<int>) -> (sorted: Seq<int>)\n\nSort elements. Requires: requires size of a > 0. Ensures: returns the correct\nsize/count; the result is sorted according to the ordering relation; the result\nis sorted according to the ordering relation; returns a sorted permutation of the\ninput.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn sorted_even(a: Vec<i8>) -> (sorted: Vec<i8>)\n    requires \n        a@.len() > 0\n    ensures \n        sorted@.len() == a@.len(),\n        forall|i: int, j: int| 0 <= i < j && 2 * i < sorted@.len() && 2 * j < sorted@.len() ==> #[trigger] sorted@[2 * i] <= #[trigger] sorted@[2 * j],\n        forall|i: int| 0 <= i < a@.len() && i % 2 == 1 ==> #[trigger] sorted@[i] == #[trigger] a@[i],\n        a@.to_multiset() == sorted@.to_multiset()", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0040", "language": "verus", "source": "humaneval", "source_id": "humaneval_038_encode_cyclic__decode_cyclic", "vc-description": "function_signature: fn decode_cyclic(s: &Vec<i8>) -> (res: Vec<i8>)\n\nDecode data. Ensures: returns the correct size/count; the condition holds for all values; the condition holds for all values; the condition holds for all values.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn decode_cyclic(s: &Vec<i8>) -> (res: Vec<i8>)\n    ensures \n        s.len() == res.len(),\n        forall|i: int| s@.len() - s@.len() % 3 <= i < s@.len() ==> res@[i] == s@[i],\n        forall|i: int| 0 <= i < s@.len() - s@.len() % 3 ==> (i % 3 == 0 ==> res@[i] == s@[i + 2]),\n        forall|i: int| 0 <= i < s@.len() - s@.len() % 3 ==> (i % 3 == 1 ==> res@[i] == s@[i - 1])", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0041", "language": "verus", "source": "humaneval", "source_id": "humaneval_038_encode_cyclic__encode_cyclic", "vc-description": "function_signature: fn encode_cyclic(s: Vec<i8>) -> (res: Vec<i8>)\n\nEncode data. Ensures: returns the correct size/count; the condition holds for all\nvalues; the condition holds for all values; the condition holds for all values;\nthe condition holds for all values.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn encode_cyclic(s: Vec<i8>) -> (res: Vec<i8>)\n    ensures \n        s.len() == res.len(),\n        forall|i: int| 0 <= i < s@.len() - s@.len() % 3 ==> (i % 3 == 0 ==> res@[i] == s@[i + 1]),\n        forall|i: int| 0 <= i < s@.len() - s@.len() % 3 ==> (i % 3 == 1 ==> res@[i] == s@[i + 1]),\n        forall|i: int| 0 <= i < s@.len() - s@.len() % 3 ==> (i % 3 == 2 ==> res@[i] == s@[i - 2]),\n        forall|i: int| s@.len() - s@.len() % 3 <= i < s@.len() ==> (res@[i] == s@[i])", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0042", "language": "verus", "source": "humaneval", "source_id": "humaneval_040", "vc-description": "This verification task involves implementing a method to determine\nif there exist three distinct elements at different positions in a list of integers\nthat sum to zero. The implementation should exhaustively check all possible combinations\nof three indices and return true if any triple sums to zero.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn has_triple_sum_to_zero(l: Seq<int>) -> bool {\n    exists|i: int, j: int, k: int| 0 <= i < j < k < l.len() && l[i] + l[j] + l[k] == 0\n}", "vc-helpers": "", "vc-spec": "fn triples_sum_to_zero(l: Vec<i8>) -> (result: bool)\n    ensures result == has_triple_sum_to_zero(l@.map(|i, x: i8| x as int))", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0043", "language": "verus", "source": "humaneval", "source_id": "humaneval_041", "vc-description": "Given n cars moving left-to-right and n cars moving right-to-left\non a straight infinite road, all at the same speed, calculate the total number of\ncollisions. Cars pass through each other when they collide and continue moving.\nEach left-moving car will collide with each right-moving car exactly once, resulting\nin n * n total collisions.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int) -> bool {\n    n >= 0\n}\n\nspec fn collision_count(n: int) -> int\n    recommends valid_input(n)\n{\n    n * n\n}\n\nspec fn valid_result(n: int, result: int) -> bool\n    recommends valid_input(n)\n{\n    result == collision_count(n) && result >= 0\n}", "vc-helpers": "", "vc-spec": "fn car_race_collision(n: i8) -> (result: i8)\n    requires valid_input(n as int)\n    ensures valid_result(n as int, result as int)", "vc-code": "{\n    assume(false);\n    0\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0044", "language": "verus", "source": "humaneval", "source_id": "humaneval_042", "vc-description": "This task implements a function to increment each element in a list\nof integers by 1. Given a sequence of integers, the function should return a new\nsequence where each element is the corresponding element from the input sequence\nplus one.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(l: Seq<int>) -> bool\n{\n    true\n}\n\nspec fn correct_output(l: Seq<int>, result: Seq<int>) -> bool\n{\n    result.len() == l.len() && \n    forall|i: int| 0 <= i < l.len() ==> result[i] == l[i] + 1\n}", "vc-helpers": "", "vc-spec": "fn incr_list(l: Vec<i8>) -> (result: Vec<i8>)\n    requires valid_input(l@.map(|i: int, x: i8| x as int))\n    ensures correct_output(l@.map(|i: int, x: i8| x as int), result@.map(|i: int, x: i8| x as int))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0045", "language": "verus", "source": "humaneval", "source_id": "humaneval_043", "vc-description": "Given a list of integers, determine if there exist two distinct elements\nat different positions that sum to zero. This task requires implementing an efficient\nalgorithm to check for the existence of such a pair.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn has_pair_sum_to_zero(l: Seq<int>) -> bool {\n    exists|i: int, j: int| 0 <= i < j < l.len() && l[i] + l[j] == 0\n}", "vc-helpers": "", "vc-spec": "fn pairs_sum_to_zero(l: Vec<i8>) -> (result: bool)\n    ensures result == has_pair_sum_to_zero(l@.map(|i: int, x: i8| x as int))", "vc-code": "{\n    assume(false);\n    false\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0046", "language": "verus", "source": "humaneval", "source_id": "humaneval_044", "vc-description": "This verification task implements a function to convert an integer\nfrom base 10 to a specified base (where base < 10) and return its string representation.\nThe implementation should correctly handle the conversion process by repeatedly\ndividing by the target base to extract digits, then reversing the resulting digit\nsequence to produce the final string representation.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn power_of_base(base: int, exp: int) -> int\n  decreases exp\n{\n  if base >= 2 && exp >= 0 {\n    if exp == 0 { 1 } else { base * power_of_base(base, exp - 1) }\n  } else {\n    0\n  }\n}\n\nspec fn digits_to_int(digits: Seq<char>, base: int) -> int\n  decreases digits.len()\n{\n  if base >= 2 && (forall|i: int| 0 <= i < digits.len() ==> '0' <= digits[i] <= '9' && (digits[i] as int) - ('0' as int) < base) {\n    if digits.len() == 0 { 0 }\n    else { (digits[0] as int) - ('0' as int) + base * digits_to_int(digits.subrange(1, digits.len() as int), base) }\n  } else {\n    0\n  }\n}\n\nspec fn string_to_int_in_base(s: Seq<char>, base: int) -> int\n  decreases s.len()\n{\n  if base >= 2 && s.len() > 0 && (forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] <= '9' && (s[i] as int) - ('0' as int) < base) {\n    if s.len() == 1 {\n      (s[0] as int) - ('0' as int)\n    } else {\n      string_to_int_in_base(s.subrange(0, s.len() - 1), base) * base + ((s[s.len() - 1] as int) - ('0' as int))\n    }\n  } else {\n    0\n  }\n}", "vc-helpers": "", "vc-spec": "fn change_base(x: i8, base: i8) -> (result: Vec<char>)\n  requires \n    base >= 2 && base < 10,\n    x >= 0,\n  ensures \n    x as int == 0 ==> result@ == seq!['0'],\n    x as int > 0 ==> result@.len() > 0 && result@[0] != '0',\n    forall|i: int| 0 <= i < result@.len() ==> '0' <= result@[i] <= '9' && (result@[i] as int) - ('0' as int) < base as int,\n    x as int > 0 ==> string_to_int_in_base(result@, base as int) == x as int,", "vc-code": "{\n  assume(false);\n  Vec::new()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0047", "language": "verus", "source": "humaneval", "source_id": "humaneval_045", "vc-description": "This task involves calculating the area of a triangle given the length of its base and height using the standard formula: Area = (base × height) ÷ 2. The implementation should handle non-negative inputs and ensure the result is also non-negative.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(base: int, height: int) -> bool {\n    base >= 0 && height >= 0\n}\n\nspec fn triangle_area_formula(base: int, height: int) -> int {\n    (base * height) / 2\n}\n\nspec fn triangle_area(a: int, h: int) -> int {\n    (a * h) / 2\n}\n\n// </vc-preamble>", "vc-helpers": "", "vc-spec": "fn calculate_triangle_area(base: u8, height: u8) -> (area: u8)\n    requires \n        valid_input(base as int, height as int)\n    ensures \n        area as int >= 0,\n        area as int == triangle_area_formula(base as int, height as int),\n        (base == 0 || height == 0) ==> area == 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0048", "language": "verus", "source": "humaneval", "source_id": "humaneval_046", "vc-description": "This task implements an iterative solution to compute the n-th element\nof the Fib4 sequence. The Fib4 sequence is defined with base cases fib4(0)=0, fib4(1)=0,\nfib4(2)=2, fib4(3)=0, and for n≥4, fib4(n) = fib4(n-1) + fib4(n-2) + fib4(n-3) +\nfib4(n-4).\n\nThe implementation must be iterative and efficient, using a sliding window approach\nto maintain the last 4 values instead of recursion, while proving equivalence to\nthe recursive specification.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn fib4_func(n: int) -> int\n    recommends n >= 0\n    decreases n\n{\n    if n < 0 { 0 }\n    else if n == 0 { 0 }\n    else if n == 1 { 0 }\n    else if n == 2 { 2 }\n    else if n == 3 { 0 }\n    else { fib4_func(n-1) + fib4_func(n-2) + fib4_func(n-3) + fib4_func(n-4) }\n}", "vc-helpers": "", "vc-spec": "fn fib4(n: i8) -> (result: i8)\n    requires n >= 0\n    ensures \n        result as int == fib4_func(n as int) &&\n        (n == 0 ==> result == 0) &&\n        (n == 1 ==> result == 0) &&\n        (n == 2 ==> result == 2) &&\n        (n == 3 ==> result == 0) &&\n        (n >= 4 ==> result as int == fib4_func(n as int - 1) + fib4_func(n as int - 2) + fib4_func(n as int - 3) + fib4_func(n as int - 4))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0049", "language": "verus", "source": "humaneval", "source_id": "humaneval_047", "vc-description": "This verification task implements a median function for a sequence\nof real numbers. For odd-length lists, it returns the middle element after sorting.\nFor even-length lists, it returns the average of the two middle elements after sorting.\n\nThe implementation uses helper functions for insertion sort and includes comprehensive\nspecifications to ensure the sorted list preserves the original multiset and maintains\nproper ordering.", "vc-preamble": "use vstd::prelude::*;\nuse vstd::multiset::*;\n\nverus! {\n\nspec fn insert_sorted(x: int, sorted: Seq<int>) -> Seq<int>\n    decreases sorted.len()\n{\n    if sorted.len() == 0 {\n        seq![x]\n    } else if x <= sorted[0] {\n        seq![x].add(sorted)\n    } else {\n        seq![sorted[0]].add(insert_sorted(x, sorted.subrange(1, sorted.len() as int)))\n    }\n}\n\nspec fn sort(s: Seq<int>) -> Seq<int>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        seq![]\n    } else {\n        insert_sorted(s[0], sort(s.subrange(1, s.len() as int)))\n    }\n}\n\nspec fn is_sorted(s: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] <= s[j]\n}\n\nspec fn multiset_from_seq(s: Seq<int>) -> Multiset<int>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        Multiset::empty()\n    } else {\n        Multiset::singleton(s[0]).add(multiset_from_seq(s.subrange(1, s.len() as int)))\n    }\n}\n\nspec fn valid_input(l: Seq<int>) -> bool {\n    l.len() > 0\n}\n\nspec fn median_value(l: Seq<int>) -> int {\n    if l.len() == 0 {\n        0int\n    } else {\n        let sorted_list = sort(l);\n        let n = sorted_list.len();\n        if n % 2 == 1 {\n            sorted_list[(n / 2) as int]\n        } else {\n            (sorted_list[(n / 2 - 1) as int] + sorted_list[(n / 2) as int]) / 2\n        }\n    }\n}", "vc-helpers": "", "vc-spec": "fn median(l: Seq<int>) -> (result: int)\n    requires valid_input(l)\n    ensures \n        result == median_value(l) &&\n        ({\n            let sorted_list = sort(l);\n            let n = sorted_list.len();\n            n % 2 == 1 ==> result == sorted_list[(n / 2) as int]\n        }) &&\n        ({\n            let sorted_list = sort(l);\n            let n = sorted_list.len();\n            n % 2 == 0 ==> result == (sorted_list[(n / 2 - 1) as int] + sorted_list[(n / 2) as int]) / 2\n        }) &&\n        is_sorted(sort(l)) &&\n        multiset_from_seq(sort(l)) == multiset_from_seq(l) &&\n        (l.len() == 1 ==> result == l[0])", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0050", "language": "verus", "source": "humaneval", "source_id": "humaneval_048", "vc-description": "Determine if a given string is a palindrome (reads the same forwards\nand backwards). The comparison should be case-insensitive, requiring implementation\nof a case conversion function and a palindrome checking predicate.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn to_lower(c: char) -> char {\n    if 'A' <= c && c <= 'Z' {\n        ((c as u8 - 'A' as u8 + 'a' as u8) as char)\n    } else {\n        c\n    }\n}\n\nspec fn is_palindrome_spec(text: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < text.len() ==> #[trigger] to_lower(text[i]) == to_lower(text[text.len() - 1 - i])\n}", "vc-helpers": "", "vc-spec": "fn is_palindrome(text: Vec<char>) -> (result: bool)\n    ensures result <==> is_palindrome_spec(text@)", "vc-code": "{\n    assume(false);\n    false\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0051", "language": "verus", "source": "humaneval", "source_id": "humaneval_049", "vc-description": "This verification task involves implementing efficient modular exponentiation\nto compute 2^n mod p. The method should use binary exponentiation (repeated squaring)\nfor optimal O(log n) time complexity, maintaining appropriate loop invariants to\nprove correctness.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn power(base: int, exp: nat) -> int\n    decreases exp\n{\n    if exp == 0 {\n        1\n    } else {\n        base * power(base, (exp - 1) as nat)\n    }\n}", "vc-helpers": "", "vc-spec": "fn modp(n: i8, p: i8) -> (result: i8)\n    requires \n        n >= 0 && p > 0,\n    ensures \n        result >= 0 && result < p,\n        result as int == power(2, n as nat) % (p as int),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0052", "language": "verus", "source": "humaneval", "source_id": "humaneval_050_encode_shift__decode_shift", "vc-description": "function_signature: fn decode_shift(s: Vec<char>) -> (t: Vec<char>)\n\nDecode data. Requires: the condition holds for all values. Ensures: returns the\ncorrect size/count; the condition holds for all values.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn encode_char(c: char) -> char {\n    ((c as int - 'a' as int + 5) % 26 + 'a' as int) as char\n}\n\nspec fn decode_char(c: char) -> char {\n    ((c as int - 'a' as int - 5) % 26 + 'a' as int) as char\n}\n\nspec fn valid_char(c: char) -> bool {\n    'a' <= c <= 'z'\n}", "vc-helpers": "", "vc-spec": "fn decode_shift(s: Vec<char>) -> (t: Vec<char>)\n    requires forall|i: int| 0 <= i < s.len() ==> valid_char(s[i])\n    ensures s.len() == t.len(),\n            forall|i: int| 0 <= i < s.len() ==> t[i] == decode_char(s[i])", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0053", "language": "verus", "source": "humaneval", "source_id": "humaneval_050_encode_shift__encode_shift", "vc-description": "function_signature: fn encode_shift(s: Vec<char>) -> (t: Vec<char>)\n\nEncode data. Requires: the condition holds for all values. Ensures: returns the\ncorrect size/count; the condition holds for all values.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn encode_char(c: char) -> char {\n    ((c as int - 'a' as int + 5) % 26 + 'a' as int) as char\n}\n\nspec fn decode_char(c: char) -> char {\n    ((c as int - 'a' as int - 5) % 26 + 'a' as int) as char\n}", "vc-helpers": "", "vc-spec": "fn encode_shift(s: Vec<char>) -> (t: Vec<char>)\n    requires forall|i: int| 0 <= i < s@.len() ==> 'a' <= #[trigger] s@[i] <= 'z'\n    ensures s@.len() == t@.len() && forall|i: int| 0 <= i < s@.len() ==> t@[i] == encode_char(s@[i])", "vc-code": "{\n    assume(false);\n    Vec::new()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0054", "language": "verus", "source": "humaneval", "source_id": "humaneval_051", "vc-description": "This verification task involves removing all vowels (both lowercase and uppercase) from a given string and returning the resulting string. Vowels are defined as the characters: a, e, i, o, u, A, E, I, O, U. The implementation must preserve the order of non-vowel characters and ensure the result contains only characters from the original string that are not vowels.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_vowel(c: char) -> bool {\n    c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || \n    c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U'\n}\n\nspec fn valid_result(text: Seq<char>, result: Seq<char>) -> bool {\n    && result.len() <= text.len()\n    && (forall|i: int| 0 <= i < result.len() ==> !is_vowel(result[i]))\n    && (forall|i: int, j: int| #![trigger result[i], result[j]] 0 <= i < j < result.len() ==> \n        (exists|k: int, l: int| 0 <= k < l < text.len() && text[k] == result[i] && text[l] == result[j] &&\n        !is_vowel(text[k]) && !is_vowel(text[l])))\n    && ((forall|i: int| 0 <= i < text.len() ==> is_vowel(text[i])) ==> result.len() == 0)\n    && (forall|i: int| 0 <= i < text.len() && !is_vowel(text[i]) ==> result.contains(text[i]))\n    && (forall|c: char| result.contains(c) ==> text.contains(c) && !is_vowel(c))\n}", "vc-helpers": "", "vc-spec": "fn remove_vowels(text: &str) -> (result: String)\n    ensures valid_result(text@, result@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0055", "language": "verus", "source": "humaneval", "source_id": "humaneval_052", "vc-description": "This verification task implements a method to check if all integers\nin a given list are strictly less than a specified threshold value. The method should\nreturn true if and only if every element in the sequence satisfies the threshold\ncondition.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn below_threshold(l: Seq<int>, t: int) -> bool {\n    forall|i: int| 0 <= i < l.len() ==> l[i] < t\n}", "vc-helpers": "", "vc-spec": "fn check_below_threshold(l: Vec<i8>, t: i8) -> (result: bool)\n    ensures result == below_threshold(l@.map(|_i: int, x: i8| x as int), t as int)", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0056", "language": "verus", "source": "humaneval", "source_id": "humaneval_053", "vc-description": "This verification task implements a simple addition function that\ntakes two integers as input and returns their sum. The implementation should correctly\nadd the two input integers and satisfy the postcondition that the result equals\nthe mathematical sum of the inputs.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(x: int, y: int) -> bool\n{\n    true\n}\n\nspec fn correct_sum(x: int, y: int) -> int\n{\n    x + y\n}", "vc-helpers": "", "vc-spec": "fn add(x: i8, y: i8) -> (result: i8)\n    requires valid_input(x as int, y as int)\n    ensures result as int == correct_sum(x as int, y as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0057", "language": "verus", "source": "humaneval", "source_id": "humaneval_054", "vc-description": "This task involves determining if two strings contain exactly the\nsame set of unique characters, regardless of character frequency or order. The implementation\nshould compare the set of characters in each string and return true if they are\nidentical sets.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn char_set(s: Seq<char>) -> Set<char> {\n    s.to_set()\n}", "vc-helpers": "", "vc-spec": "fn same_chars(s0: Vec<char>, s1: Vec<char>) -> (result: bool)\n    ensures result == (char_set(s0@) == char_set(s1@))", "vc-code": "{\n    assume(false);\n    false\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0058", "language": "verus", "source": "humaneval", "source_id": "humaneval_055", "vc-description": "This task involves computing the n-th Fibonacci number using 1-based\nindexing, where fib(1) = 1 and fib(2) = 1. The implementation should efficiently\ncalculate the result for positive integers n.\n\nThe solution uses an iterative approach with loop invariants to maintain correctness\nwhile avoiding the exponential time complexity of a naive recursive implementation.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int) -> bool {\n    n > 0\n}\n\nspec fn fib_spec(n: int) -> int\n    decreases n\n{\n    if n <= 0 { 1 }\n    else if n == 1 { 1 }\n    else if n == 2 { 1 }\n    else { fib_spec(n - 1) + fib_spec(n - 2) }\n}", "vc-helpers": "", "vc-spec": "fn fib(n: i8) -> (result: i8)\n    requires valid_input(n as int)\n    ensures \n        result as int == fib_spec(n as int) &&\n        result > 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0059", "language": "verus", "source": "humaneval", "source_id": "humaneval_056", "vc-description": "This verification task implements a bracket matching algorithm that\ndetermines if a string containing only \"<\" and \">\" characters has properly nested\nbrackets. Every opening bracket \"<\" must have a corresponding closing bracket \">\"\nand they must be correctly nested, meaning at no point should the number of closing\nbrackets exceed the number of opening brackets in any prefix.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn count_brackets_prefix(s: Seq<char>, end: int, bracket: char) -> int\n    decreases end\n{\n    if end == 0 {\n        0\n    } else if 0 <= end <= s.len() && (bracket == '<' || bracket == '>') && s[end - 1] == bracket {\n        1 + count_brackets_prefix(s, end - 1, bracket)\n    } else if 0 <= end <= s.len() && (bracket == '<' || bracket == '>') {\n        count_brackets_prefix(s, end - 1, bracket)\n    } else {\n        0\n    }\n}\n\nspec fn valid_bracket_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> s[i] == '<' || s[i] == '>'\n}\n\nspec fn properly_nested(brackets: Seq<char>) -> bool {\n    valid_bracket_string(brackets) &&\n    (forall|k: int| 0 <= k <= brackets.len() ==> \n        count_brackets_prefix(brackets, k, '<') >= count_brackets_prefix(brackets, k, '>')) &&\n    count_brackets_prefix(brackets, brackets.len() as int, '<') == count_brackets_prefix(brackets, brackets.len() as int, '>')\n}", "vc-helpers": "", "vc-spec": "fn correct_bracketing(brackets: Vec<char>) -> (result: bool)\n    requires valid_bracket_string(brackets@)\n    ensures result <==> properly_nested(brackets@)", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0060", "language": "verus", "source": "humaneval", "source_id": "humaneval_057", "vc-description": "This verification task implements a function to determine if a list of numbers is monotonic. A list is monotonic if it is either entirely non-decreasing (monotonically increasing) or entirely non-increasing (monotonically decreasing). Empty lists and single-element lists are considered monotonic, and lists with equal consecutive elements are allowed.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn monotonic(l: Seq<int>) -> bool {\n    if l.len() <= 1 {\n        true\n    } else {\n        let increasing = forall|i: nat| #![trigger l[i as int]] i < l.len() - 1 ==> l[i as int] <= l[(i + 1) as int];\n        let decreasing = forall|i: nat| #![trigger l[i as int]] i < l.len() - 1 ==> l[i as int] >= l[(i + 1) as int];\n        increasing || decreasing\n    }\n}", "vc-helpers": "", "vc-spec": "fn is_monotonic(l: Vec<i8>) -> (result: bool)\n    ensures result == monotonic(l@.map(|_i: int, x: i8| x as int))", "vc-code": "{\n    assume(false);\n    false\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0061", "language": "verus", "source": "humaneval", "source_id": "humaneval_058_common", "vc-description": "function_signature: fn common(l1: &Vec<i32>, l2: &Vec<i32>) -> Set<i32>\n\nReturn sorted unique common elements for two lists.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn common(l1: &Vec<i32>, l2: &Vec<i32>) -> (c: Set<i32>)\n    ensures \n        (forall|i: i32| c.contains(i) ==> l1@.contains(i) && l2@.contains(i)) &&\n        (forall|i: i32| l1@.contains(i) && l2@.contains(i) ==> c.contains(i))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0062", "language": "verus", "source": "humaneval", "source_id": "humaneval_059", "vc-description": "This verification task implements an algorithm to find the largest\nprime factor of a composite integer n (where n > 1 and n is not prime). The algorithm\nuses trial division, first removing all factors of 2, then checking odd factors\nup to the square root of the remaining number.\n\n\nThe implementation must ensure that the returned result is indeed a prime number,\ndivides n, and is the largest such prime factor among all factors of n.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_prime(n: int) -> bool {\n    n > 1 && forall|k: int| 2 <= k < n ==> #[trigger] (n % k) != 0\n}\n\nspec fn power_of_2_factor(n: int, current: int) -> int\n    recommends n > 0 && current > 0\n    decreases current\n    when current > 0\n{\n    if current % 2 != 0 { 1 }\n    else { 2 * power_of_2_factor(n, current / 2) }\n}", "vc-helpers": "", "vc-spec": "fn largest_prime_factor(n: i8) -> (result: i8)\n    requires \n        n as int > 1,\n        !is_prime(n as int),\n    ensures \n        result as int > 1,\n        (n as int) % (result as int) == 0,\n        forall|k: int| k > result as int && (n as int) % k == 0 ==> !is_prime(k),\n        is_prime(result as int),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0063", "language": "verus", "source": "humaneval", "source_id": "humaneval_060", "vc-description": "This verification task implements the computation of the sum of all\nintegers from 1 to n inclusive, where n is a positive integer. The expected implementation\nshould use the well-known mathematical formula n*(n+1)/2 for efficiency.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int) -> bool {\n    n >= 1\n}\n\nspec fn sum_from_one_to_n(n: int) -> int\n    recommends n >= 1\n{\n    n * (n + 1) / 2\n}", "vc-helpers": "", "vc-spec": "fn sum_to_n(n: i8) -> (result: i8)\n    requires valid_input(n as int)\n    ensures result as int == sum_from_one_to_n(n as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0064", "language": "verus", "source": "humaneval", "source_id": "humaneval_062", "vc-description": "This task involves computing the derivative of a polynomial given its coefficients. Given a sequence of coefficients where xs[i] represents the coefficient of x^i, the method should return the derivative coefficients where [a₀, a₁, a₂, ...] becomes [a₁, 2a₂, 3a₃, ...].", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(xs: Seq<int>) -> bool {\n    true  /* Any sequence of coefficients is valid input */\n}\n\nspec fn derivative_length(xs: Seq<int>) -> nat {\n    if xs.len() <= 1 { 0nat } else { (xs.len() - 1) as nat }\n}\n\nspec fn correct_derivative_coefficients(xs: Seq<int>, result: Seq<int>) -> bool {\n    xs.len() <= 1 ==> result == Seq::<int>::empty() &&\n    xs.len() > 1 ==> (result.len() == xs.len() - 1 && \n                      forall|j: int| 0 <= j < result.len() ==> result[j] == (j + 1) * xs[j + 1])\n}", "vc-helpers": "", "vc-spec": "fn derivative(xs: Vec<i8>) -> (result: Vec<i8>)\n    requires \n        valid_input(xs@.map(|i: int, x: i8| x as int))\n    ensures \n        correct_derivative_coefficients(xs@.map(|i: int, x: i8| x as int), result@.map(|i: int, x: i8| x as int)),\n        result@.len() == derivative_length(xs@.map(|i: int, x: i8| x as int))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0065", "language": "verus", "source": "humaneval", "source_id": "humaneval_063", "vc-description": "This verification task involves implementing the FibFib sequence, which is a modified Fibonacci sequence. The FibFib sequence is defined with base cases fibfib(0) = 0, fibfib(1) = 0, fibfib(2) = 1, and for n >= 3, fibfib(n) = fibfib(n-1) + fibfib(n-2) + fibfib(n-3). The expected implementation should efficiently compute the n-th element using dynamic programming rather than naive recursion.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn fibfib_spec(n: int) -> int\n    recommends n >= 0\n    decreases n when n >= 0\n{\n    if n == 0 { 0 }\n    else if n == 1 { 0 }\n    else if n == 2 { 1 }\n    else if n >= 3 { fibfib_spec(n-1) + fibfib_spec(n-2) + fibfib_spec(n-3) }\n    else { 0 }\n}", "vc-helpers": "", "vc-spec": "fn fibfib(n: u8) -> (result: u8)\n    requires n >= 0\n    ensures \n        result as int == fibfib_spec(n as int) &&\n        (n == 0 ==> result == 0) &&\n        (n == 1 ==> result == 0) &&\n        (n == 2 ==> result == 1) &&\n        (n >= 3 ==> result as int == fibfib_spec((n-1) as int) + fibfib_spec((n-2) as int) + fibfib_spec((n-3) as int))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0066", "language": "verus", "source": "humaneval", "source_id": "humaneval_064_vowels_count", "vc-description": "function_signature: def remove_vowels(string: str) -> Nat\n\nWrite a function vowels_count which takes a string representing a word as input\nand returns the number of vowels in the string. Vowels in this case are 'a', 'e',\n'i', 'o', 'u'. Here, 'y' is also a vowel, but only when it is at the end\nof the given word.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_vowel(c: char) -> bool\n{\n  c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U'\n}\n\nspec fn count_vowels(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0int\n    } else {\n        count_vowels(s.subrange(1, s.len() as int)) + (if is_vowel(s[0]) { 1int } else { 0int })\n    }\n}", "vc-helpers": "", "vc-spec": "fn vowel_count(s: &Vec<char>) -> (count: u8)\n  ensures\n    count as int >= 0,\n    count as int == count_vowels(s@) + (if s@.len() > 0 && s@[s@.len() - 1] == 'y' { 1int } else { 0int })", "vc-code": "{\n    assume(false);\n    0\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0067", "language": "verus", "source": "humaneval", "source_id": "humaneval_065", "vc-description": "This verification task implements a circular right shift operation\non the digits of an integer. Given an integer x and a shift amount, the method performs\na circular right shift on the digits of x and returns the result as a string. A\ncircular right shift moves digits from the end to the beginning. If the shift amount\nexceeds the number of digits in x, the method returns the digits of x in reversed\norder instead.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn int_to_string(x: int) -> Seq<char>\n    recommends x >= 0\n{\n    if x == 0 { seq!['0'] }\n    else { int_to_string_helper(x, seq![]) }\n}\n\nspec fn int_to_string_helper(x: int, acc: Seq<char>) -> Seq<char>\n    recommends x >= 0\n    decreases x when x >= 0\n{\n    if x <= 0 { acc }\n    else { \n        let digit_char = ((x % 10) + ('0' as int)) as char;\n        int_to_string_helper(x / 10, seq![digit_char].add(acc))\n    }\n}\n\nspec fn reverse_string(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() <= 1 { s }\n    else { reverse_string(s.subrange(1, s.len() as int)).add(seq![s[0]]) }\n}", "vc-helpers": "", "vc-spec": "fn circular_shift(x: i8, shift: i8) -> (result: Vec<char>)\n    ensures \n        ({\n            let abs_x = if (x as int) < 0 { -((x as int)) } else { x as int };\n            result.len() == int_to_string(abs_x).len()\n        }) &&\n        ({\n            let abs_x = if (x as int) < 0 { -((x as int)) } else { x as int };\n            shift as int > int_to_string(abs_x).len() ==> \n                result@ == reverse_string(int_to_string(abs_x))\n        }) &&\n        ({\n            let abs_x = if (x as int) < 0 { -((x as int)) } else { x as int };\n            shift as int <= int_to_string(abs_x).len() && int_to_string(abs_x).len() > 0 ==> {\n                let digits = int_to_string(abs_x);\n                let n = digits.len() as int;\n                let normalized_shift = (shift as int) % n;\n                normalized_shift == 0 ==> result@ == digits\n            }\n        }) &&\n        ({\n            let abs_x = if (x as int) < 0 { -((x as int)) } else { x as int };\n            shift as int <= int_to_string(abs_x).len() && int_to_string(abs_x).len() > 0 ==> {\n                let digits = int_to_string(abs_x);\n                let n = digits.len() as int;\n                let normalized_shift = (shift as int) % n;\n                normalized_shift > 0 ==> result@ == digits.subrange(n - normalized_shift, n).add(digits.subrange(0, n - normalized_shift))\n            }\n        }) &&\n        (forall|i: int| 0 <= i < result.len() ==> '0' <= result[i] && result[i] <= '9')", "vc-code": "{\n    assume(false);\n    Vec::new()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0068", "language": "verus", "source": "humaneval", "source_id": "humaneval_066", "vc-description": "This task involves calculating the sum of ASCII values of all uppercase letters in a string. The function should return 0 for empty strings and only consider characters from 'A' to 'Z' as uppercase. The implementation needs to be verified with an iterative method that maintains proper loop invariants.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sum_of_uppercase_ascii(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0\n    } else {\n        let c = s[0];\n        let rest = sum_of_uppercase_ascii(s.subrange(1, s.len() as int));\n        if 'A' <= c && c <= 'Z' { \n            (c as int) + rest\n        } else {\n            rest\n        }\n    }\n}", "vc-helpers": "", "vc-spec": "fn digit_sum(s: Vec<char>) -> (result: i32)\n    ensures \n        result >= 0,\n        result == sum_of_uppercase_ascii(s@)", "vc-code": "{\n    assume(false);\n    0\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0069", "language": "verus", "source": "humaneval", "source_id": "humaneval_067", "vc-description": "Given a string containing quantities of apples and oranges and the\ntotal number of fruits, calculate the number of mangoes. The basket contains only\napples, oranges, and mangoes. The implementation must extract numbers from the input\nstring, sum them up, and subtract from the total to find the number of mangoes.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int) -> bool {\n    n >= 0\n}\n\nspec fn sum_of_numbers_in_string(s: Seq<char>) -> int {\n    let numbers = extract_numbers_from_string(s);\n    sum_sequence(numbers)\n}\n\nspec fn extract_numbers_from_string(s: Seq<char>) -> Seq<int> {\n    extract_numbers_helper(s, 0, 0, false, seq![])\n}\n\nspec fn sum_sequence(numbers: Seq<int>) -> int\n    decreases numbers.len()\n{\n    if numbers.len() == 0 {\n        0int\n    } else {\n        numbers[0] + sum_sequence(numbers.subrange(1, numbers.len() as int))\n    }\n}\nspec fn extract_numbers_helper(s: Seq<char>, i: int, current_number: int, in_number: bool, numbers: Seq<int>) -> Seq<int>\n    decreases s.len() - i when 0 <= i <= s.len() && current_number >= 0\n{\n    if 0 <= i <= s.len() && current_number >= 0 {\n        if i == s.len() {\n            if in_number { numbers.push(current_number) } else { numbers }\n        } else {\n            let c = s[i];\n            if '0' <= c && c <= '9' {\n                let digit = c as int - '0' as int;\n                extract_numbers_helper(s, i + 1, current_number * 10 + digit, true, numbers)\n            } else {\n                if in_number {\n                    extract_numbers_helper(s, i + 1, 0, false, numbers.push(current_number))\n                } else {\n                    extract_numbers_helper(s, i + 1, 0, false, numbers)\n                }\n            }\n        }\n    } else {\n        seq![]\n    }\n}", "vc-helpers": "", "vc-spec": "fn fruit_distribution(s: &Vec<char>, n: u32) -> (mangoes: u32)\n    requires valid_input(n as int)\n    ensures mangoes as int == (n as int) - sum_of_numbers_in_string(s@),\n            (mangoes as int >= 0) <==> ((n as int) >= sum_of_numbers_in_string(s@))", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0070", "language": "verus", "source": "humaneval", "source_id": "humaneval_068", "vc-description": "This verification task implements a function that finds the smallest\neven value in an array of non-negative integers and returns it along with its index.\nIf multiple occurrences of the same smallest even value exist, it should return\nthe one with the smallest index. If no even values exist or the array is empty,\nit returns an empty list.\n\nThe implementation must correctly handle edge cases and maintain loop invariants\nto prove that the returned result satisfies all the postconditions, including finding\nthe true minimum even value and the earliest index for that value.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(arr: Seq<int>) -> bool {\n    forall|i: int| 0 <= i < arr.len() ==> arr[i] >= 0\n}\n\nspec fn has_even_value(arr: Seq<int>) -> bool {\n    exists|i: int| 0 <= i < arr.len() && arr[i] % 2 == 0\n}\n\nspec fn smallest_even_value(arr: Seq<int>) -> int {\n    smallest_even_value_helper(arr, 0, -1)\n}\n\nspec fn smallest_even_value_helper(arr: Seq<int>, index: int, current_min: int) -> int\n    decreases arr.len() - index\n{\n    if index >= arr.len() {\n        current_min\n    } else if arr[index] % 2 == 0 {\n        if current_min == -1 || arr[index] < current_min {\n            smallest_even_value_helper(arr, index + 1, arr[index])\n        } else {\n            smallest_even_value_helper(arr, index + 1, current_min)\n        }\n    } else {\n        smallest_even_value_helper(arr, index + 1, current_min)\n    }\n}\n\nspec fn first_index_of_value(arr: Seq<int>, value: int) -> int\n    decreases arr.len()\n{\n    if arr.len() > 0 && arr[0] == value {\n        0\n    } else if arr.len() > 0 {\n        1 + first_index_of_value(arr.subrange(1, arr.len() as int), value)\n    } else {\n        0\n    }\n}", "vc-helpers": "", "vc-spec": "fn pluck(arr: Vec<i8>) -> (result: Vec<i8>)\n    requires \n        valid_input(arr@.map_values(|x: i8| x as int))\n    ensures \n        arr@.len() == 0 ==> result@.len() == 0,\n        !has_even_value(arr@.map_values(|x: i8| x as int)) ==> result@.len() == 0,\n        has_even_value(arr@.map_values(|x: i8| x as int)) ==> result@.len() == 2,\n        result@.len() == 2 ==> (0 <= (result@[1] as int) && (result@[1] as int) < (arr@.len() as int)),\n        result@.len() == 2 ==> arr@[result@[1] as int] as int == result@[0] as int,\n        result@.len() == 2 ==> result@[0] as int % 2 == 0,\n        result@.len() == 2 ==> forall|i: int| 0 <= i < arr@.len() && arr@[i] as int % 2 == 0 ==> result@[0] as int <= arr@[i] as int,\n        result@.len() == 2 ==> forall|i: int| 0 <= i < arr@.len() && arr@[i] as int % 2 == 0 && arr@[i] as int == result@[0] as int ==> result@[1] as int <= i", "vc-code": "{\n    assume(false);\n    Vec::new()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0071", "language": "verus", "source": "humaneval", "source_id": "humaneval_069", "vc-description": "This verification task involves finding the greatest integer in a\nlist whose frequency is greater than or equal to its own value. Given a non-empty\nlist of positive integers, the implementation should return this greatest qualifying\ninteger, or -1 if no such integer exists.\n\nThe task requires building a frequency map for all elements in the list, then identifying\nwhich elements have frequencies meeting the criteria, and finally selecting the\nmaximum among those valid elements.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn count(s: Seq<int>, x: int) -> int {\n    s.filter(|i: int| i == x).len() as int\n}\n\nspec fn max_seq(s: Seq<int>) -> int\n    recommends s.len() > 0\n{\n    if s.len() == 1 { s[0] } else { choose|x: int| s.contains(x) }\n}\n\nspec fn valid_input(lst: Seq<int>) -> bool {\n    lst.len() > 0 && forall|i: int| 0 <= i < lst.len() ==> lst[i] > 0\n}\n\nspec fn valid_result(lst: Seq<int>, result: int) -> bool\n    recommends valid_input(lst)\n{\n    if result == -1 {\n        forall|x: int| #![auto] lst.contains(x) ==> count(lst, x) < x\n    } else {\n        result > 0 &&\n        lst.contains(result) && \n        count(lst, result) >= result &&\n        forall|y: int| #![auto] lst.contains(y) && count(lst, y) >= y ==> y <= result\n    }\n}\n\n// </vc-preamble>", "vc-helpers": "", "vc-spec": "fn search(lst: Vec<i8>) -> (result: i8)\n    requires valid_input(lst@.map(|_index: int, x: i8| x as int))\n    ensures valid_result(lst@.map(|_index: int, x: i8| x as int), result as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0072", "language": "verus", "source": "humaneval", "source_id": "humaneval_070_strange_sort_list__strange_sort_list_helper", "vc-description": "function_signature: fn strange_sort_list_helper(s: Vec<i8>) -> (Vec<i8>, Vec<i8>)\n\nSort elements. Ensures: returns a sorted permutation of the input; returns the correct\nsize/count; the result is sorted according to the ordering relation; the result\nis sorted according to the ordering relation.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn strange_sort_list_helper(s: Vec<i8>) -> (res: (Vec<i8>, Vec<i8>))\n    ensures \n        s@.to_multiset() == res.0@.to_multiset(),\n        s@.len() == res.0@.len() && s@.len() == res.1@.len(),\n        forall|i: int| 0 <= i < s@.len() && i % 2 == 0 ==> res.1@[i] == res.0@[i / 2],\n        forall|i: int| 0 <= i < s@.len() && i % 2 == 1 ==> res.1@[i] == res.0@[s@.len() - (i - 1) / 2 - 1]", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0073", "language": "verus", "source": "humaneval", "source_id": "humaneval_072", "vc-description": "This task determines if an object will fly based on two conditions:\nthe given list of numbers must be palindromic, and the sum of all elements must\nbe within a specified weight limit. The implementation needs to check both conditions\nand return true only if both are satisfied.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn is_palindrome(s: Seq<int>) -> bool {\n    forall|i: int| #![trigger s[i]] 0 <= i < s.len() ==> s[i] == s[s.len() - 1 - i]\n}\n\nspec fn sum_elements(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s[0] + sum_elements(s.subrange(1, s.len() as int))\n    }\n}\n\n// </vc-preamble>", "vc-helpers": "", "vc-spec": "fn will_it_fly(q: Vec<i8>, w: i8) -> (result: bool)\n    ensures result == (is_palindrome(q@.map(|i: int, x: i8| x as int)) && sum_elements(q@.map(|i: int, x: i8| x as int)) <= w as int)", "vc-code": "{\n    assume(false);\n    false\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0074", "language": "verus", "source": "humaneval", "source_id": "humaneval_073", "vc-description": "This verification task involves finding the minimum number of elements\nthat must be changed to make an array palindromic. A palindromic array reads the\nsame forwards and backwards. The solution should count the number of mismatched\npairs between corresponding positions from the start and end of the array.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn count_mismatched_pairs(arr: Seq<int>) -> int {\n    count_mismatched_pairs_up_to(arr, arr.len() as int / 2)\n}\n\nspec fn count_mismatched_pairs_up_to(arr: Seq<int>, limit: int) -> int\n    decreases limit\n{\n    if limit <= 0 || limit > arr.len() as int / 2 {\n        0 as int\n    } else if limit == 0 {\n        0 as int\n    } else {\n        (if arr[limit - 1] != arr[arr.len() as int - limit] { 1 as int } else { 0 as int }) +\n        count_mismatched_pairs_up_to(arr, limit - 1)\n    }\n}\n\nspec fn can_make_palindromic_with_changes(arr: Seq<int>, num_changes: int) -> bool {\n    num_changes >= 0 && num_changes >= count_mismatched_pairs(arr)\n}", "vc-helpers": "", "vc-spec": "fn smallest_change(arr: Vec<i8>) -> (changes: usize)\n    ensures \n        changes <= arr@.len() / 2,\n        changes as int == count_mismatched_pairs(arr@.map(|i, x| x as int)),\n        arr@.len() <= 1 ==> changes == 0,\n        ({\n            let arr_int = arr@.map(|i, x| x as int);\n            forall|c: int| can_make_palindromic_with_changes(arr_int, c) ==> (0 <= c < changes as int ==> !can_make_palindromic_with_changes(arr_int, c))\n        }),\n        ({\n            let arr_int = arr@.map(|i, x| x as int);\n            can_make_palindromic_with_changes(arr_int, changes as int)\n        })", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0075", "language": "verus", "source": "humaneval", "source_id": "humaneval_074", "vc-description": "This task implements a function that compares two lists of strings\nby their total character count. Given two lists of strings, the function should\nreturn the list that has the smaller total character count across all its strings.\nIf both lists have the same total character count, return the first list.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn total_chars(lst: Seq<Seq<char>>) -> nat\n    decreases lst.len()\n{\n    if lst.len() == 0 {\n        0\n    } else {\n        lst[0].len() + total_chars(lst.subrange(1, lst.len() as int))\n    }\n}", "vc-helpers": "", "vc-spec": "fn total_match(lst1: Vec<Vec<char>>, lst2: Vec<Vec<char>>) -> (result: Vec<Vec<char>>)\n    ensures \n        result@ == lst1@ || result@ == lst2@,\n        total_chars(lst1@.map_values(|v: Vec<char>| v@)) <= total_chars(lst2@.map_values(|v: Vec<char>| v@)) ==> result@ == lst1@,\n        total_chars(lst1@.map_values(|v: Vec<char>| v@)) > total_chars(lst2@.map_values(|v: Vec<char>| v@)) ==> result@ == lst2@", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0076", "language": "verus", "source": "humaneval", "source_id": "humaneval_075", "vc-description": "This verification task implements a method to determine if a given\ninteger (less than 100) is the product of exactly 3 prime numbers, counting repetitions.\nThe method performs prime factorization and checks if exactly 3 prime factors (with\nrepetitions) multiply to the original number.\n\nThe expected implementation uses trial division to find all prime factors, starting\nwith factors of 2, then checking odd numbers up to the square root, and finally\nhandling any remaining prime factor greater than the square root.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_prime_number(n: int) -> bool {\n    n >= 2 && forall|k: int| #[trigger] (n % k) != 0 ==> (2 <= k < n ==> n % k != 0)\n}\n\nspec fn seq_product(factors: Seq<int>) -> int\n    decreases factors.len()\n{\n    if factors.len() == 0 { \n        1 \n    } else { \n        factors[0] * seq_product(factors.subrange(1, factors.len() as int))\n    }\n}\n\nspec fn power(base: int, exp: nat) -> int\n    decreases exp\n{\n    if exp == 0 { \n        1 \n    } else { \n        base * power(base, (exp - 1) as nat)\n    }\n}", "vc-helpers": "", "vc-spec": "fn is_multiply_prime(a: i8) -> (result: bool)\n    requires \n        a >= 0 && a < 100\n    ensures \n        a < 8 ==> result == false,\n        result == true <==> (exists|p1: int, p2: int, p3: int|\n            p1 >= 2 && p2 >= 2 && p3 >= 2 && \n            is_prime_number(p1) && is_prime_number(p2) && is_prime_number(p3) &&\n            a as int == p1 * p2 * p3)", "vc-code": "{\n    assume(false);\n    false\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0077", "language": "verus", "source": "humaneval", "source_id": "humaneval_076_is_simple_power", "vc-description": "function_signature: def is_simple_power(x: int, n: int) -> bool\n\nYour task is to write a function that returns true if a number x is a simple power\nof n and false in other cases. x is a simple power of n if n**int=x", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn power(x: nat, y: nat) -> nat\n    decreases y\n{\n    if y == 0 { 1 } else { x * power(x, (y - 1) as nat) }\n}", "vc-helpers": "", "vc-spec": "fn is_simple_power(x: u8, n: i8) -> (ans: bool)\n    requires x > 0\n    ensures ans <==> exists|y: nat| n as int == power(x as nat, y) as int", "vc-code": "{\n    assume(false);\n    false\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0078", "language": "verus", "source": "humaneval", "source_id": "humaneval_077_iscube__cube_root", "vc-description": "function_signature: fn cube_root(n: nat) -> (r: nat)\n\nFind the integer cube root. Ensures: the result r is the largest integer such that\nr³ ≤ N < (r+1)³; the result is at most N.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn cube(n: nat) -> nat { n * n * n }", "vc-helpers": "", "vc-spec": "fn cube_root(n: u8) -> (r: u8)\n    ensures \n        cube(r as nat) <= n as nat,\n        (n as nat) < cube((r as nat) + 1),\n        r as nat <= n as nat,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0079", "language": "verus", "source": "humaneval", "source_id": "humaneval_077_iscube__is_cube", "vc-description": "function_signature: fn is_cube(n: nat) -> (r: bool)\n\nCheck if condition holds. Ensures: if true, then there exists an integer r such\nthat N = r³; if false, then no integer r satisfies N = r³.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn cube(n: int) -> int {\n    n * n * n\n}", "vc-helpers": "", "vc-spec": "fn is_cube(n: u8) -> (r: bool)\n    ensures r == exists|k: int| 0 <= k <= n as int && n as int == cube(k)", "vc-code": "{\n    assume(false);\n    false\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0080", "language": "verus", "source": "humaneval", "source_id": "humaneval_078", "vc-description": "This task involves counting hexadecimal digits that represent prime numbers in a given hexadecimal string. The prime hexadecimal digits are: 2, 3, 5, 7, B (decimal 11), and D (decimal 13). The implementation should iterate through the string and count occurrences of these specific characters.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_hex_char(c: char) -> bool {\n    '0' <= c <= '9' || 'A' <= c <= 'F'\n}\n\nspec fn is_valid_hex_string(s: Seq<char>) -> bool {\n    forall|i: int| #![auto] 0 <= i < s.len() ==> is_hex_char(s[i])\n}\n\nspec fn is_prime_hex_digit(c: char) -> bool {\n    c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D'\n}\n\nspec fn count_prime_hex_digits(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0int\n    } else {\n        (if is_prime_hex_digit(s[0]) { 1int } else { 0int }) + count_prime_hex_digits(s.subrange(1, s.len() as int))\n    }\n}", "vc-helpers": "", "vc-spec": "fn hex_key(num: &str) -> (count: usize)\n    requires\n        is_valid_hex_string(num@),\n    ensures\n        count as int >= 0,\n        count as int <= num@.len(),\n        count as int == count_prime_hex_digits(num@),", "vc-code": "{\n    assume(false);\n    0\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0081", "language": "verus", "source": "humaneval", "source_id": "humaneval_079_decimal_to_binary", "vc-description": "function_signature: fn decimal_to_binary(decimal: nat) -> Seq<char>\n\nYou will be given a number in decimal form and your task is to convert it to binary\nformat. The function should return a sequence, with each character representing a\nbinary number. Each character in the sequence will be '0' or '1'.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_binary_string(s: Seq<char>) -> bool {\n  s.len() > 0 && (s.len() > 1 ==> s[0] != '0') &&\n  forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn decimal_to_binary_helper(n: nat) -> Seq<char>\n  decreases n\n{\n  if n == 0 {\n    seq!['0']\n  } else if n == 1 {\n    seq!['1']\n  } else {\n    decimal_to_binary_helper(n / 2).add(decimal_to_binary_helper(n % 2))\n  }\n}\n\nspec fn binary_to_decimal(s: Seq<char>) -> nat\n  decreases s.len()\n{\n  if s.len() <= 0 {\n    0\n  } else if s.len() == 1 {\n    if s[0] == '0' { 0 } else { 1 }\n  } else {\n    binary_to_decimal(s.take((s.len() - 1) as int)) * 2 + \n    binary_to_decimal(s.skip((s.len() - 1) as int))\n  }\n}", "vc-helpers": "", "vc-spec": "fn decimal_to_binary(n: u8) -> (s: Vec<char>)\n  ensures\n    is_binary_string(s@),\n    binary_to_decimal(s@) == n as nat,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0082", "language": "verus", "source": "humaneval", "source_id": "humaneval_080", "vc-description": "This task involves determining if a string is \"happy\". A string is\nconsidered happy if it has a length of at least 3 characters and in every substring\nof 3 consecutive characters, all characters are distinct (no duplicates). The implementation\nshould efficiently check this condition and return the appropriate boolean result.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_length(s: Seq<char>) -> bool {\n    s.len() >= 3\n}\n\nspec fn all_windows_distinct(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i <= s.len() - 3 ==> #[trigger] s[i] != s[i+1] && s[i] != s[i+2] && s[i+1] != s[i+2]\n}\n\nspec fn is_happy_spec(s: Seq<char>) -> bool {\n    valid_length(s) && all_windows_distinct(s)\n}", "vc-helpers": "", "vc-spec": "fn is_happy(s: Vec<char>) -> (result: bool)\n    ensures result == is_happy_spec(s@)", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0083", "language": "verus", "source": "humaneval", "source_id": "humaneval_081", "vc-description": "Convert a list of numerical GPA values to corresponding letter grades\nusing a specified grading scale. The grading scale maps GPA ranges to letter grades\nfrom A+ (4.0) down to E (0.0).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn get_letter_grade(gpa: int) -> Seq<char> {\n    if gpa == 40 { seq!['A', '+'] }\n    else if gpa > 37 { seq!['A'] }\n    else if gpa > 33 { seq!['A', '-'] }\n    else if gpa > 30 { seq!['B', '+'] }\n    else if gpa > 27 { seq!['B'] }\n    else if gpa > 23 { seq!['B', '-'] }\n    else if gpa > 20 { seq!['C', '+'] }\n    else if gpa > 17 { seq!['C'] }\n    else if gpa > 13 { seq!['C', '-'] }\n    else if gpa > 10 { seq!['D', '+'] }\n    else if gpa > 7 { seq!['D'] }\n    else if gpa > 0 { seq!['D', '-'] }\n    else { seq!['E'] }\n}\n\nspec fn valid_letter_grades(grades: Seq<String>) -> bool {\n    forall|i: int| 0 <= i < grades.len() ==> {\n        let grade = #[trigger] grades[i]@;\n        grade == seq!['A', '+'] || grade == seq!['A'] || grade == seq!['A', '-'] ||\n        grade == seq!['B', '+'] || grade == seq!['B'] || grade == seq!['B', '-'] ||\n        grade == seq!['C', '+'] || grade == seq!['C'] || grade == seq!['C', '-'] ||\n        grade == seq!['D', '+'] || grade == seq!['D'] || grade == seq!['D', '-'] ||\n        grade == seq!['E']\n    }\n}", "vc-helpers": "", "vc-spec": "fn numerical_letter_grade(grades: Vec<i8>) -> (letter_grades: Vec<String>)\n    ensures \n        letter_grades.len() == grades.len() &&\n        (forall|i: int| 0 <= i < grades.len() ==> \n            #[trigger] letter_grades[i]@ == get_letter_grade(grades[i] as int)) &&\n        valid_letter_grades(letter_grades@)", "vc-code": "{\n    assume(false);\n    Vec::new()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0084", "language": "verus", "source": "humaneval", "source_id": "humaneval_082", "vc-description": "This task verifies a function that determines whether a string's length\nis a prime number. A prime number is defined as an integer greater than or equal\nto 2 that has no divisors other than 1 and itself.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_prime_number(n: int) -> bool {\n    n >= 2 && (forall|k: int| 2 <= k < n ==> #[trigger] (n % k) != 0)\n}", "vc-helpers": "proof fn is_prime(n: usize) -> (result: bool)\n    requires n < usize::MAX,\n    ensures result <==> is_prime_number(n as int)\n{\n    assume(false);\n    true\n}", "vc-spec": "fn prime_length(s: Vec<char>) -> (result: bool)\n    ensures result <==> is_prime_number(s@.len() as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0085", "language": "verus", "source": "humaneval", "source_id": "humaneval_083", "vc-description": "Count n-digit positive integers that start with 1 OR end with 1 using\ninclusion-exclusion principle. The task requires implementing a function that uses\nthe inclusion-exclusion principle to count numbers that either start with 1, end\nwith 1, or both, avoiding double-counting those that satisfy both conditions.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int) -> bool {\n  n >= 1\n}\n\nspec fn power(base: int, exp: int) -> int\n  decreases exp when exp >= 0\n{\n  if exp <= 0 { 1 } else { base * power(base, exp - 1) }\n}\n\nspec fn count_starts_with_1(n: int) -> int {\n  power(10, n - 1)\n}\n\nspec fn count_ends_with_1(n: int) -> int {\n  if n == 1 { 1 } else { 9 * power(10, n - 2) }\n}\n\nspec fn count_starts_and_ends_with_1(n: int) -> int {\n  if n <= 2 { 1 } else { power(10, n - 2) }\n}", "vc-helpers": "", "vc-spec": "fn starts_one_ends(n: i8) -> (result: i8)\n  requires \n    valid_input(n as int)\n  ensures \n    result as int == count_starts_with_1(n as int) + count_ends_with_1(n as int) - count_starts_and_ends_with_1(n as int),\n    result >= 0", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0086", "language": "verus", "source": "humaneval", "source_id": "humaneval_084_solve", "vc-description": "function_signature: def solve(n: int) -> str\n\nGiven a positive integer N, return the total sum of its digits in binary.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn popcount(n: nat) -> nat\n    decreases n\n{\n    if n == 0 { 0 } else { (n % 2) + popcount(n / 2) }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: u8) -> (r: u8)\n    ensures r as nat == popcount(n as nat)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0087", "language": "verus", "source": "humaneval", "source_id": "humaneval_085_add", "vc-description": "function_signature: def solve(n: list[int]) -> int\n\nGiven a non-empty list of integers lst, add the even elements that are at odd indices.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sumc(s: Seq<int>, p: Seq<bool>) -> int\n    recommends s.len() == p.len()\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        (if p[0] { s[0] } else { 0 }) + sumc(s.subrange(1, s.len() as int), p.subrange(1, p.len() as int))\n    }\n}\n\nspec fn add_condition(lst: Seq<int>) -> Seq<bool> {\n    Seq::new(lst.len(), |i: int| i % 2 == 1 && lst[i] % 2 == 0)\n}", "vc-helpers": "", "vc-spec": "fn add(v: Vec<i8>) -> (r: i8)\n    ensures r == sumc(v@.map_values(|x: i8| x as int), add_condition(v@.map_values(|x: i8| x as int)))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0088", "language": "verus", "source": "humaneval", "source_id": "humaneval_087_get_row__SortSeq", "vc-description": "function_signature: fn sort_seq(s: SortSeqState) -> (sorted: SortSeqState)\n\nSort elements. Ensures: the result is sorted according to the ordering relation;\nreturns the correct size/count; returns a sorted permutation of the input.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\ntype SortSeqState = Seq<(int, int)>;\n\nspec fn less(a: (int, int), b: (int, int)) -> bool {\n    let (x, y) = a;\n    let (u, v) = b;\n    x < u || (x == u && y > v)\n}\n\nspec fn less_eq(a: (int, int), b: (int, int)) -> bool {\n    let (x, y) = a;\n    let (u, v) = b;\n    (x == u && y == v) || less(a, b)\n}", "vc-helpers": "", "vc-spec": "fn sort_seq(s: Vec<(i8, i8)>) -> (sorted: Vec<(i8, i8)>)\n    ensures \n        forall|i: int, j: int| 0 <= i < j < sorted@.len() ==> less_eq((sorted[i].0 as int, sorted[i].1 as int), (sorted[j].0 as int, sorted[j].1 as int)),\n        sorted@.len() == s@.len(),\n        s@.map(|i: int, x: (i8, i8)| (x.0 as int, x.1 as int)).to_multiset() == sorted@.map(|i: int, x: (i8, i8)| (x.0 as int, x.1 as int)).to_multiset()", "vc-code": "{\n    assume(false);\n    s\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0089", "language": "verus", "source": "humaneval", "source_id": "humaneval_087_get_row__get_row", "vc-description": "function_signature: fn get_row(lst: &Seq<Seq<int>>, x: int) -> (pos: SortSeqState)\n\nRetrieve elements. Ensures: the condition holds for all values; the condition holds for all values; the condition holds for all values.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\ntype SortSeqState = Seq<(int, int)>;\n\nspec fn less(a: (int, int), b: (int, int)) -> bool {\n    let (x, y) = a;\n    let (u, v) = b;\n    x < u || (x == u && y > v)\n}\n\nspec fn less_eq(a: (int, int), b: (int, int)) -> bool {\n    let (x, y) = a;\n    let (u, v) = b;\n    (x == u && y == v) || less(a, b)\n}", "vc-helpers": "", "vc-spec": "fn get_row(lst: &Vec<Vec<i8>>, x: i8) -> (pos: SortSeqState)\n    ensures \n        (forall|i: int| 0 <= i < pos.len() ==> #[trigger] pos[i].0 >= 0 && #[trigger] pos[i].1 >= 0 && {\n            let (a, b) = pos[i];\n            0 <= a < lst@.len() && 0 <= b < lst@[a].len() && lst@[a][b] as int == x as int\n        }) &&\n        (forall|i: int, j: int| 0 <= i < lst@.len() && 0 <= j < lst@[i].len() && lst@[i][j] as int == x as int ==> #[trigger] pos.contains((i, j))) &&\n        (forall|i: int, j: int| 0 <= i < j < pos.len() ==> #[trigger] less_eq(pos[i], pos[j]))", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0090", "language": "verus", "source": "humaneval", "source_id": "humaneval_088", "vc-description": "This verification task implements a conditional sorting algorithm\nfor arrays of non-negative integers. The sorting order is determined by the sum\nof the first and last elements: if the sum is odd, the array is sorted in ascending\norder; if the sum is even, it's sorted in descending order. The implementation\nmust return a sorted copy without modifying the original array and preserve all\nelements (multiset equality).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(arr: Seq<int>) -> bool {\n    forall|i: int| 0 <= i < arr.len() ==> arr[i] >= 0\n}\n\nspec fn is_ascending_sorted(s: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] <= s[j]\n}\n\nspec fn is_descending_sorted(s: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] >= s[j]\n}\n\nspec fn should_sort_ascending(arr: Seq<int>) -> bool {\n    arr.len() > 1 && (arr[0] + arr[arr.len() - 1]) % 2 == 1\n}\n\nspec fn should_sort_descending(arr: Seq<int>) -> bool {\n    arr.len() > 1 && (arr[0] + arr[arr.len() - 1]) % 2 == 0\n}\n\nspec fn correctly_sorted(arr: Seq<int>, result: Seq<int>) -> bool {\n    (arr.len() <= 1 ==> result == arr) &&\n    (should_sort_ascending(arr) ==> is_ascending_sorted(result)) &&\n    (should_sort_descending(arr) ==> is_descending_sorted(result))\n}\n\nfn sort_ascending(arr: Seq<int>) -> (result: Seq<int>)\n    ensures\n        result.to_multiset() == arr.to_multiset(),\n        is_ascending_sorted(result)\n{\n    assume(false);\n    unreached()\n}\n\n\nfn sort_descending(arr: Seq<int>) -> (result: Seq<int>)\n    ensures\n        result.to_multiset() == arr.to_multiset(),\n        is_descending_sorted(result)\n{\n    assume(false);\n    unreached()\n}", "vc-helpers": "", "vc-spec": "fn sort_array(arr: Vec<i8>) -> (result: Vec<i8>)\n    requires valid_input(arr@.map(|i: int, x: i8| x as int))\n    ensures \n        result@.map(|i: int, x: i8| x as int).to_multiset() == arr@.map(|i: int, x: i8| x as int).to_multiset(),\n        correctly_sorted(arr@.map(|i: int, x: i8| x as int), result@.map(|i: int, x: i8| x as int))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0091", "language": "verus", "source": "humaneval", "source_id": "humaneval_089", "vc-description": "This verification task implements a string encryption algorithm that shifts each alphabetic character forward by 4 positions in the alphabet with wraparound. The implementation should preserve the case of letters and leave non-alphabetic characters unchanged.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn encrypt_char(c: char) -> char {\n    if 'a' <= c && c <= 'z' {\n        (((c as int - 'a' as int + 4) % 26) + 'a' as int) as char\n    } else if 'A' <= c && c <= 'Z' {\n        (((c as int - 'A' as int + 4) % 26) + 'A' as int) as char\n    } else {\n        c\n    }\n}", "vc-helpers": "", "vc-spec": "fn encrypt(s: Vec<char>) -> (result: Vec<char>)\n    requires s@.len() >= 0\n    ensures result@.len() == s@.len(),\n            forall|i: int| 0 <= i < s@.len() ==> #[trigger] result@[i] == #[trigger] encrypt_char(#[trigger] s@[i])", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0092", "language": "verus", "source": "humaneval", "source_id": "humaneval_090_next_smallest", "vc-description": "function_signature: def next_smallest(lst: List[int]) -> Optional[int]\n\nYou are given a list of integers. Write a function next_smallest() that returns\nthe 2nd smallest element of the list. Return None if there is no such element. TODO(George):\nRemove this when being reviewed The spec is defined as: if result is none there\nis no second smallest element, which exists in a finite list iff there are at least\ntwo distinct elements in the list. If result is some x, then x is the second smallest\nelement of the list, the spec obtains the sublist of elements smaller than the result,\nand checks that this sublist does not contain two distinct elements (they are all\nthe same).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn get_val(mx: Option<int>) -> int\n    recommends matches!(mx, Some(_))\n{\n    match mx {\n        Some(n) => n,\n        None => 0\n    }\n}", "vc-helpers": "", "vc-spec": "fn rolling_max(s: &Vec<i8>) -> (res: Option<i8>)\n    ensures \n        matches!(res, None) <==> s@.len() < 2,\n        matches!(res, Some(_)) ==> exists|x: int| 0 <= x < s@.len() && s@[x] as int == get_val(match res { Some(v) => Some(v as int), None => None }),\n        forall|x: int, y: int| 0 <= x < y < s@.len() ==> s@[x] as int <= get_val(match res { Some(v) => Some(v as int), None => None }) || s@[y] as int <= get_val(match res { Some(v) => Some(v as int), None => None }),", "vc-code": "{\n    assume(false);\n    None\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0094", "language": "verus", "source": "humaneval", "source_id": "humaneval_092", "vc-description": "This verification task involves implementing a function that checks if three real numbers satisfy two conditions: all three must be integers, and one of the numbers must equal the sum of the other two. The function should return true only if both conditions are met, false otherwise.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_integer(x: int) -> bool {\n    true\n}\n\nspec fn all_integers(x: int, y: int, z: int) -> bool {\n    is_integer(x) && is_integer(y) && is_integer(z)\n}\n\nspec fn one_equals_sum_of_other_two(x: int, y: int, z: int) -> bool {\n    x == y + z || y == x + z || z == x + y\n}\n\nspec fn valid_result(x: int, y: int, z: int, result: bool) -> bool {\n    result <==> (all_integers(x, y, z) && one_equals_sum_of_other_two(x, y, z))\n}\n\n// </vc-preamble>", "vc-helpers": "", "vc-spec": "fn any_int(x: i8, y: i8, z: i8) -> (result: bool)\n    ensures valid_result(x as int, y as int, z as int, result)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0095", "language": "verus", "source": "humaneval", "source_id": "humaneval_093", "vc-description": "Implement a message encoding algorithm that applies two transformations\nto each character: first replace vowels with letters appearing 2 positions later\nin the alphabet, then swap the case of all letters. Spaces are preserved unchanged,\nand the input contains only letters and spaces.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_vowel(c: char) -> bool {\n    c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n    c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U'\n}\n\nspec fn get_vowel_replacement(c: char) -> char\n    recommends is_vowel(c)\n{\n    if c == 'a' { 'c' }\n    else if c == 'e' { 'g' }\n    else if c == 'i' { 'k' }\n    else if c == 'o' { 'q' }\n    else if c == 'u' { 'w' }\n    else if c == 'A' { 'C' }\n    else if c == 'E' { 'G' }\n    else if c == 'I' { 'K' }\n    else if c == 'O' { 'Q' }\n    else if c == 'U' { 'W' }\n    else { c }\n}\n\nspec fn swap_case(c: char) -> char {\n    if 'a' <= c && c <= 'z' {\n        ((c as u8 - 'a' as u8 + 'A' as u8) as char)\n    } else if 'A' <= c && c <= 'Z' {\n        ((c as u8 - 'A' as u8 + 'a' as u8) as char)\n    } else {\n        c\n    }\n}", "vc-helpers": "", "vc-spec": "fn encode(message: Vec<char>) -> (result: Vec<char>)\n    requires forall|i: int| 0 <= i < message@.len() ==> \n        (('a' <= message@[i] && message@[i] <= 'z') || \n         ('A' <= message@[i] && message@[i] <= 'Z') || \n         message@[i] == ' ')\n    ensures result@.len() == message@.len(),\n            forall|i: int| 0 <= i < message@.len() ==> \n                if #[trigger] message@[i] == ' ' {\n                    #[trigger] result@[i] == ' '\n                } else if is_vowel(#[trigger] message@[i]) {\n                    result@[i] == swap_case(#[trigger] get_vowel_replacement(#[trigger] message@[i]))\n                } else {\n                    #[trigger] result@[i] == swap_case(#[trigger] message@[i])\n                }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0097", "language": "verus", "source": "humaneval", "source_id": "humaneval_095_check_dict_case", "vc-description": "function_signature: def check_dict_case(s : dict[str, str]) -> bool\n\nGiven a dictionary, return True if all keys are strings in lower case or all keys\nare strings in upper case, else return False. The function should return False is\nthe given dictionary is empty. Note(George): Modified the problem to use strings\nonly for both keys and values.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_lower_case(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> ('a' <= #[trigger] s[i] <= 'z')\n}\n\nspec fn is_upper_case(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> ('A' <= #[trigger] s[i] <= 'Z')\n}\n\ntype DictCase = Map<Seq<char>, Seq<char>>;", "vc-helpers": "", "vc-spec": "fn check_dict_case(dict: Map<Vec<char>, Vec<char>>) -> (result: bool)\n    ensures\n        (dict.len() == 0) ==> !result,\n        result ==> ((forall|k: Vec<char>| #[trigger] dict.contains_key(k) ==> is_lower_case(k@)) || (forall|k: Vec<char>| #[trigger] dict.contains_key(k) ==> is_upper_case(k@))),\n        !result ==> ((dict.len() == 0) || ((exists|k: Vec<char>| #[trigger] dict.contains_key(k) && !is_lower_case(k@)) && (exists|k: Vec<char>| #[trigger] dict.contains_key(k) && !is_upper_case(k@))))", "vc-code": "{\n    assume(false);\n    false\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0098", "language": "verus", "source": "humaneval", "source_id": "humaneval_096", "vc-description": "This verification task involves implementing a function that returns\nall prime numbers strictly less than a given non-negative integer n, in ascending\norder. The implementation should correctly identify prime numbers using a helper\nmethod and build the result sequence while maintaining the sorted order.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_prime_number(num: int) -> bool {\n    num >= 2 && forall|k: int| 2 <= k < num ==> #[trigger] (num % k) != 0\n}", "vc-helpers": "", "vc-spec": "fn count_up_to(n: i8) -> (result: Vec<i8>)\n    requires n as int >= 0\n    ensures \n        forall|i: int| 0 <= i < result.len() ==> is_prime_number(#[trigger] result[i] as int),\n        forall|i: int| 0 <= i < result.len() ==> #[trigger] (result[i] as int) < (n as int),\n        forall|p: int| 2 <= p < (n as int) && is_prime_number(p) ==> result@.contains(p as i8),\n        forall|i: int, j: int| 0 <= i < j < result.len() ==> #[trigger] (result[i] as int) < #[trigger] (result[j] as int)", "vc-code": "{\n    assume(false);\n    Vec::new()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0099", "language": "verus", "source": "humaneval", "source_id": "humaneval_097", "vc-description": "This task implements a function to compute the product of the unit\ndigits of two integers. The unit digit is defined as the ones place digit of the\nabsolute value of a number. Given two integers (which can be positive, negative,\nor zero), the method should return the product of their respective unit digits.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn unit_digit(n: int) -> int {\n    (if n >= 0 { n } else { -n }) % 10\n}\n\nspec fn product_of_unit_digits(a: int, b: int) -> int {\n    unit_digit(a) * unit_digit(b)\n}\n\nspec fn valid_result(result: int) -> bool {\n    result >= 0 && result <= 81\n}", "vc-helpers": "", "vc-spec": "fn multiply(a: i8, b: i8) -> (result: i8)\n    ensures \n        result as int == product_of_unit_digits(a as int, b as int),\n        valid_result(result as int),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0100", "language": "verus", "source": "humaneval", "source_id": "humaneval_098_count_upper", "vc-description": "function_signature: def count_upper(s : String) -> Int\n\nGiven a string s, count the number of uppercase vowels in even indices.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_upper_vowel(c: char) -> bool {\n    c == 'A' || c == 'E' || c == 'U' || c == 'I' || c == 'O'\n}", "vc-helpers": "", "vc-spec": "fn count_upper(s: Vec<char>) -> (cnt: usize)\n    ensures cnt == Set::<int>::new(|i: int| 0 <= i < s@.len() && i % 2 == 0 && is_upper_vowel(s@[i])).len()", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0101", "language": "verus", "source": "humaneval", "source_id": "humaneval_100", "vc-description": "This verification task implements a method to create a pile of stones\nwith n levels. The first level contains n stones, and each subsequent level contains\nthe next number with the same parity (odd/even) as n. This creates an arithmetic\nsequence where each level has 2 more stones than the previous level.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int) -> bool {\n    n > 0\n}\n\nspec fn valid_pile(pile: Seq<int>, n: int) -> bool {\n    &&& pile.len() == n\n    &&& (n > 0 ==> pile.len() > 0 && pile[0] == n)\n    &&& (forall|i: int| 0 <= i < pile.len() ==> pile[i] == n + 2 * i)\n    &&& (forall|i: int| 0 <= i < pile.len() - 1 ==> #[trigger] pile.index(i + 1) == pile.index(i) + 2)\n}", "vc-helpers": "", "vc-spec": "fn make_a_pile(n: i8) -> (pile: Vec<i8>)\n    requires valid_input(n as int)\n    ensures valid_pile(pile@.map(|i: int, x: i8| x as int), n as int)", "vc-code": "{\n    assume(false);\n    Vec::new()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0102", "language": "verus", "source": "humaneval", "source_id": "humaneval_102", "vc-description": "This task involves implementing a method to find the largest even\ninteger in a given range [x, y] inclusive, where x and y are positive integers.\nIf no even integer exists in the range, the method should return -1.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(x: int, y: int) -> bool {\n    x > 0 && y > 0\n}\n\nspec fn no_even_in_range(x: int, y: int) -> bool {\n    forall|i: int| x <= i <= y ==> #[trigger] (i % 2) != 0\n}\n\nspec fn is_largest_even_in_range(x: int, y: int, result: int) -> bool {\n    result % 2 == 0 && \n    x <= result <= y && \n    (forall|i: int| x <= i <= y && #[trigger] (i % 2) == 0 ==> i <= result)\n}\n\nspec fn correct_result(x: int, y: int, result: int) -> bool {\n    if x > y { \n        result == -1\n    } else {\n        (result == -1 && no_even_in_range(x, y)) ||\n        is_largest_even_in_range(x, y, result)\n    }\n}", "vc-helpers": "", "vc-spec": "fn choose_num(x: i8, y: i8) -> (result: i8)\n    requires valid_input(x as int, y as int)\n    ensures correct_result(x as int, y as int, result as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0103", "language": "verus", "source": "humaneval", "source_id": "humaneval_103", "vc-description": "Given two positive integers n and m, compute the average of all integers\nin the range [n, m] (inclusive).\n\nRound the result to the nearest integer using banker's rounding (round half to\neven) and return the binary representation as a string prefixed with \"0b\". If n\n> m, return \"-1\".", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn int_to_binary(n: nat) -> Seq<char> {\n    if n == 0 { seq!['0'] }\n    else { int_to_binary_helper(n) }\n}\n\nspec fn int_to_binary_helper(n: nat) -> Seq<char>\n    decreases n\n{\n    if n <= 1 { seq!['1'] }\n    else { int_to_binary_helper(n / 2) + (if n % 2 == 1 { seq!['1'] } else { seq!['0'] }) }\n}", "vc-helpers": "", "vc-spec": "fn rounded_avg(n: int, m: int) -> (result: String)\n    requires n > 0 && m > 0\n    ensures (n > m) ==> (result@ == seq!['-', '1']) &&\n            (n <= m) ==> (\n        result@.len() >= 3 &&\n        result@.subrange(0, 2) == seq!['0', 'b'] &&\n        ({\n            let count = m - n + 1;\n            let total_sum = count * (n + m) / 2;\n            let quotient = total_sum / count;\n            let remainder = total_sum % count;\n            let rounded = if remainder * 2 < count { quotient }\n                         else if remainder * 2 > count { quotient + 1 }\n                         else if quotient % 2 == 0 { quotient }\n                         else { quotient + 1 };\n            result@ == seq!['0', 'b'] + int_to_binary(rounded as nat)\n        })\n    )", "vc-code": "{\n    assume(false);\n    \"\".to_string()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0104", "language": "verus", "source": "humaneval", "source_id": "humaneval_104_unique_digits", "vc-description": "function_signature: def unique_digits(x: List[nat]) -> List[nat]\n\nGiven a list of positive integers x. return a sorted list of all elements that hasn't\nany even digit.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn has_no_even_digit(n: int) -> bool\n  decreases n\n{\n  n >= 0 && ((n < 10 && n % 2 == 1) || (n % 2 == 1 && has_no_even_digit(n / 10)))\n}", "vc-helpers": "", "vc-spec": "fn unique_digits(x: Vec<u8>) -> (result: Vec<u8>)\n  ensures \n    forall|i: int| 0 <= i < result@.len() ==> has_no_even_digit(result@[i] as int) &&\n    forall|i: int, j: int| 0 <= i < j < result@.len() ==> result@[i] <= result@[j] &&\n    forall|e: u8| x@.contains(e) && has_no_even_digit(e as int) ==> result@.contains(e) &&\n    forall|e: u8| result@.contains(e) ==> x@.contains(e)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0105", "language": "verus", "source": "humaneval", "source_id": "humaneval_105_by_length__SortReverseAndName", "vc-description": "function_signature: fn sort_reverse_and_name(arr: &Seq<int>) -> (result: Seq<Seq<char>>)\nSort elements. Ensures: the size is bounded; the condition holds for all values.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn number_to_name(n: int) -> Seq<char> {\n  if 1 <= n <= 9 {\n    if n == 1 { seq!['O', 'n', 'e'] }\n    else if n == 2 { seq!['T', 'w', 'o'] }\n    else if n == 3 { seq!['T', 'h', 'r', 'e', 'e'] }\n    else if n == 4 { seq!['F', 'o', 'u', 'r'] }\n    else if n == 5 { seq!['F', 'i', 'v', 'e'] }\n    else if n == 6 { seq!['S', 'i', 'x'] }\n    else if n == 7 { seq!['S', 'e', 'v', 'e', 'n'] }\n    else if n == 8 { seq!['E', 'i', 'g', 'h', 't'] }\n    else { seq!['N', 'i', 'n', 'e'] }\n  } else {\n    seq!['I', 'n', 'v', 'a', 'l', 'i', 'd']\n  }\n}", "vc-spec": "fn sort_reverse_and_name(arr: &Vec<i8>) -> (result: Vec<Vec<char>>)\n  ensures \n    result.len() <= arr.len(),\n    forall|i: int| 0 <= i < result@.len() ==> (\n      result@[i]@ == seq!['O', 'n', 'e'] || result@[i]@ == seq!['T', 'w', 'o'] || result@[i]@ == seq!['T', 'h', 'r', 'e', 'e'] || \n      result@[i]@ == seq!['F', 'o', 'u', 'r'] || result@[i]@ == seq!['F', 'i', 'v', 'e'] || result@[i]@ == seq!['S', 'i', 'x'] || \n      result@[i]@ == seq!['S', 'e', 'v', 'e', 'n'] || result@[i]@ == seq!['E', 'i', 'g', 'h', 't'] || result@[i]@ == seq!['N', 'i', 'n', 'e']\n    )", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0106", "language": "verus", "source": "humaneval", "source_id": "humaneval_105_by_length__SortSeq", "vc-description": "function_signature: fn sort_seq(s: Vec<i8>) -> (sorted: Vec<i8>)\n\nSort elements. Ensures: the result is sorted according to the ordering relation;\nreturns the correct size/count; returns a sorted permutation of the input.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn number_to_name(n: int) -> &'static str {\n  if n == 1 { \"One\" }\n  else if n == 2 { \"Two\" }\n  else if n == 3 { \"Three\" }\n  else if n == 4 { \"Four\" }\n  else if n == 5 { \"Five\" }\n  else if n == 6 { \"Six\" }\n  else if n == 7 { \"Seven\" }\n  else if n == 8 { \"Eight\" }\n  else if n == 9 { \"Nine\" }\n  else { \"Unknown\" }\n}", "vc-helpers": "", "vc-spec": "fn sort_seq(s: Vec<i8>) -> (sorted: Vec<i8>)\n  ensures \n    forall|i: int, j: int| 0 <= i < j < sorted.len() ==> sorted[i] as int <= sorted[j] as int &&\n    sorted.len() == s.len() &&\n    s@.to_multiset() == sorted@.to_multiset()", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0107", "language": "verus", "source": "humaneval", "source_id": "humaneval_105_by_length__reverse", "vc-description": "function_signature: fn reverse(s: Vec<i8>) -> (rev: Vec<i8>)\n\nReverse order. Ensures: returns the correct size/count; the condition holds for\nall values.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn number_to_name(n: int) -> &'static str\n{\n    if n == 1 { \"One\" }\n    else if n == 2 { \"Two\" }\n    else if n == 3 { \"Three\" }\n    else if n == 4 { \"Four\" }\n    else if n == 5 { \"Five\" }\n    else if n == 6 { \"Six\" }\n    else if n == 7 { \"Seven\" }\n    else if n == 8 { \"Eight\" }\n    else { \"Nine\" }\n}", "vc-helpers": "", "vc-spec": "fn reverse(s: Vec<i8>) -> (rev: Vec<i8>)\n    ensures \n        rev.len() == s.len(),\n        forall|k: int| 0 <= k < s.len() ==> rev[k] as int == s@[s.len() - 1 - k] as int", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0108", "language": "verus", "source": "humaneval", "source_id": "humaneval_106", "vc-description": "This task requires implementing a method that generates a sequence\nof natural numbers based on position-dependent calculations. For each position i\n(0-indexed), if (i+1) is even, the element should be the factorial of (i+1); if\n(i+1) is odd, the element should be the sum of integers from 1 to (i+1).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn factorial(n: nat) -> nat\n    decreases n\n{\n    if n <= 1 { 1 } else { n * factorial((n - 1) as nat) }\n}\n\nspec fn sum_range(n: nat) -> nat\n    decreases n\n{\n    if n == 0 { 0 } else { n + sum_range((n - 1) as nat) }\n}\n\nspec fn valid_result(n: nat, result: Seq<nat>) -> bool\n{\n    result.len() == n &&\n    forall|i: int| 0 <= i < n ==> \n        (if (i + 1) % 2 == 0 { result[i] == factorial((i + 1) as nat) }\n         else { result[i] == sum_range((i + 1) as nat) })\n}", "vc-helpers": "", "vc-spec": "fn f(n: u8) -> (result: Vec<u8>)\n    ensures valid_result(n as nat, result@.map(|i: int, x: u8| x as nat))", "vc-code": "{\n    assume(false);\n    Vec::new()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0109", "language": "verus", "source": "humaneval", "source_id": "humaneval_107", "vc-description": "This verification task implements a function to count even and odd\npalindromic integers in the range [1, n] inclusive. A palindromic integer reads\nthe same forwards and backwards (e.g., 121, 7, 1331). The function should return\na tuple (even_count, odd_count) representing the counts of even and odd palindromic\nintegers respectively.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: nat) -> bool {\n    n >= 1\n}\n\nspec fn digits_of(n: nat) -> Seq<nat>\n    decreases n\n{\n    if n < 10 {\n        seq![n]\n    } else {\n        digits_of(n / 10).push(n % 10)\n    }\n}\n\nspec fn reverse_seq<T>(s: Seq<T>) -> Seq<T>\n    decreases s.len()\n{\n    if s.len() <= 1 {\n        s\n    } else {\n        reverse_seq(s.subrange(1, s.len() as int)).push(s[0])\n    }\n}\n\nspec fn is_palindrome(n: nat) -> bool {\n    let digits = digits_of(n);\n    digits == reverse_seq(digits)\n}\n\nspec fn count_palindromes_in_range(start: nat, end: nat) -> nat\n    decreases end - start + 1\n{\n    if start > end {\n        0\n    } else if is_palindrome(start) {\n        1 + count_palindromes_in_range(start + 1, end)\n    } else {\n        count_palindromes_in_range(start + 1, end)\n    }\n}\n\nspec fn count_even_palindromes_in_range(start: nat, end: nat) -> nat\n    decreases end - start + 1\n{\n    if start > end {\n        0\n    } else if is_palindrome(start) && start % 2 == 0 {\n        1 + count_even_palindromes_in_range(start + 1, end)\n    } else {\n        count_even_palindromes_in_range(start + 1, end)\n    }\n}\n\nspec fn count_odd_palindromes_in_range(start: nat, end: nat) -> nat\n    decreases end - start + 1\n{\n    if start > end {\n        0\n    } else if is_palindrome(start) && start % 2 == 1 {\n        1 + count_odd_palindromes_in_range(start + 1, end)\n    } else {\n        count_odd_palindromes_in_range(start + 1, end)\n    }\n}\n\nspec fn count_palindromes_helper(n: nat, current: nat, even_count: nat, odd_count: nat) -> (nat, nat)\n    decreases n - current + 1\n{\n    if current > n {\n        (even_count, odd_count)\n    } else if is_palindrome(current) {\n        if current % 2 == 0 {\n            count_palindromes_helper(n, current + 1, even_count + 1, odd_count)\n        } else {\n            count_palindromes_helper(n, current + 1, even_count, odd_count + 1)\n        }\n    } else {\n        count_palindromes_helper(n, current + 1, even_count, odd_count)\n    }\n}\n\n// </vc-preamble>", "vc-helpers": "", "vc-spec": "fn even_odd_palindrome(n: u32) -> (result: (u32, u32))\n    requires \n        n >= 1\n    ensures \n        result.0 >= 0,\n        result.1 >= 0,\n        result.0 == count_even_palindromes_in_range(1, n as nat),\n        result.1 == count_odd_palindromes_in_range(1, n as nat),\n        result.0 + result.1 == count_palindromes_in_range(1, n as nat),", "vc-code": "{\n    // impl-start\n    assume(false);\n    (0, 0)\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0110", "language": "verus", "source": "humaneval", "source_id": "humaneval_108", "vc-description": "Given an array of integers, count how many elements have a positive sum of digits. For digit sum calculation: positive numbers sum all digits normally, negative numbers have the first digit as negative and remaining digits as positive, and zero has digit sum 0. Return the count of numbers whose digit sum is greater than 0.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn digit_sum_func(n: int) -> int {\n    if n == 0 {\n        0\n    } else if n > 0 {\n        sum_of_digits_pos(n as nat) as int\n    } else {\n        sum_of_digits_pos((-n) as nat) as int - 2 * first_digit((-n) as nat) as int\n    }\n}\n\nspec fn sum_of_digits_pos(n: nat) -> nat\n    recommends n >= 0\n    decreases n\n{\n    if n == 0 {\n        0\n    } else {\n        (n % 10) + sum_of_digits_pos(n / 10)\n    }\n}\n\nspec fn first_digit(n: nat) -> nat\n    recommends n > 0\n    decreases n\n{\n    if n < 10 {\n        n\n    } else {\n        first_digit(n / 10)\n    }\n}\n\nspec fn valid_input(arr: Seq<i32>) -> bool {\n    true\n}\n\nspec fn valid_output(arr: Seq<i32>, count: int) -> bool {\n    0 <= count <= arr.len()\n}", "vc-helpers": "", "vc-spec": "fn count_nums(arr: &Vec<i32>) -> (count: usize)\n    requires valid_input(arr@)\n    ensures valid_output(arr@, count as int)", "vc-code": "{\n    assume(false);\n    0\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0111", "language": "verus", "source": "humaneval", "source_id": "humaneval_109", "vc-description": "Given an array of unique integers, determine if it's possible to sort\nthe array in non-decreasing order using only right shift operations. A right shift\nmoves all elements one position to the right, with the last element moving to the\nfirst. The method should return True if the array is sortable via rotations, False\notherwise, with empty arrays returning True.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_sorted(s: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] <= s[j]\n}\n\nspec fn rotate_right(arr: Seq<int>, k: int) -> Seq<int>\n    recommends 0 <= k <= arr.len()\n{\n    if arr.len() == 0 {\n        arr\n    } else if k == 0 {\n        arr\n    } else {\n        arr.subrange((arr.len() - k) as int, arr.len() as int) + arr.subrange(0, (arr.len() - k) as int)\n    }\n}", "vc-helpers": "", "vc-spec": "fn move_one_ball(arr: Vec<i8>) -> (result: bool)\n    requires \n        forall|i: int, j: int| 0 <= i < j < arr.len() ==> arr[i as int] != arr[j as int]\n    ensures \n        arr.len() == 0 ==> result == true,\n        result == true ==> (arr.len() == 0 || exists|k: int| #[trigger] is_sorted(rotate_right(arr@.map(|i, x: i8| x as int), k)) && 0 <= k < arr.len()),\n        result == false ==> forall|k: int| 0 <= k < arr.len() ==> !is_sorted(rotate_right(arr@.map(|i, x: i8| x as int), k))", "vc-code": "{\n    assume(false);\n    false\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0112", "language": "verus", "source": "humaneval", "source_id": "humaneval_110", "vc-description": "This task involves determining if it's possible to exchange elements\nbetween two non-empty lists of integers such that the first list contains only even\nnumbers. The method should return \"YES\" if such an exchange is possible, \"NO\" otherwise.\n\n\nThe key insight is that we need at least as many even numbers across both lists\nas the length of the first list to make the first list contain only even numbers.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn count_even(lst: Seq<int>) -> int\n    decreases lst.len()\n{\n    if lst.len() == 0 {\n        0\n    } else {\n        if lst[0] % 2 == 0 {\n            1 + count_even(lst.skip(1))\n        } else {\n            count_even(lst.skip(1))\n        }\n    }\n}\n\nspec fn valid_input(lst1: Seq<int>, lst2: Seq<int>) -> bool {\n    lst1.len() > 0 && lst2.len() > 0\n}\n\nspec fn can_exchange(lst1: Seq<int>, lst2: Seq<int>) -> bool {\n    count_even(lst1) + count_even(lst2) >= lst1.len()\n}", "vc-helpers": "", "vc-spec": "fn exchange(lst1: Vec<i8>, lst2: Vec<i8>) -> (result: String)\n    requires \n        valid_input(lst1.view().map(|_i, x| x as int), lst2.view().map(|_i, x| x as int)),\n    ensures \n        result@ == seq!['Y', 'E', 'S'] || result@ == seq!['N', 'O'],\n        (result@ == seq!['Y', 'E', 'S']) == can_exchange(lst1.view().map(|_i, x| x as int), lst2.view().map(|_i, x| x as int)),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0113", "language": "verus", "source": "humaneval", "source_id": "humaneval_111_histogram", "vc-description": "function_signature: def histogram(s : str) -> Dict[str, int]\n\nGiven a string representing a space separated lowercase letters, return a dictionary\nof the letter with the most repetition and containing the corresponding count. If\nseveral letters have the same occurrence, return all of them.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\ntype BiggestMap = Map<int, int>;", "vc-helpers": "", "vc-spec": "fn count(a: Vec<i8>) -> (biggest: BiggestMap)\n  ensures forall|i: int| 0 <= i < a@.len() && biggest.dom().contains(a@[i] as int) ==>\n    #[trigger] biggest[a@[i] as int] == Set::new(|j: int| 0 <= j < a@.len() && a@[j] as int == a@[i] as int).len()", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0114", "language": "verus", "source": "humaneval", "source_id": "humaneval_112", "vc-description": "This task implements a string filtering and palindrome checking function.\nGiven two strings s and c, it removes all characters from string s that appear anywhere\nin string c, then determines if the resulting string is a palindrome (reads the\nsame forwards and backwards). The method returns a tuple containing the filtered\nstring and a boolean indicating whether it's a palindrome.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn filter_chars(s: Seq<char>, c: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        Seq::empty()\n    } else if c.contains(s[0]) {\n        filter_chars(s.subrange(1, s.len() as int), c)\n    } else {\n        seq![s[0]].add(filter_chars(s.subrange(1, s.len() as int), c))\n    }\n}\n\nspec fn reverse_seq(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        Seq::empty()\n    } else {\n        reverse_seq(s.subrange(1, s.len() as int)).add(seq![s[0]])\n    }\n}", "vc-helpers": "", "vc-spec": "fn reverse_delete(s: Vec<char>, c: Vec<char>) -> (result: (Vec<char>, bool))\n    ensures\n        result.0@ == filter_chars(s@, c@),\n        result.1 == (result.0@ == reverse_seq(result.0@)),\n        result.0@.len() <= s@.len(),\n        forall|i: int| #![auto] 0 <= i < result.0@.len() ==> !c@.contains(result.0@[i]),\n        forall|i: int| #![auto] 0 <= i < result.0@.len() ==> s@.contains(result.0@[i]),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0115", "language": "verus", "source": "humaneval", "source_id": "humaneval_113", "vc-description": "Given a list of strings containing only digits, count the odd digits (1,3,5,7,9) in each string and return formatted messages where the count is embedded in a template message. The task involves string processing, digit counting, and message formatting with proper verification of loop invariants and postconditions.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_all_digits(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> ('0' <= s[i] && s[i] <= '9')\n}\n\nspec fn count_odd_digits(s: Seq<char>) -> int\n    recommends is_all_digits(s)\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        let digit = s[0] as int - '0' as int;\n        let is_odd: int = if digit % 2 == 1 { 1 } else { 0 };\n        is_odd + count_odd_digits(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn int_to_string_func(n: int) -> Seq<char>\n    recommends n >= 0\n{\n    if n == 0 {\n        Seq::new(1, |i: int| '0')\n    } else {\n        int_to_string_rec(n, Seq::empty())\n    }\n}\n\nspec fn format_message(count: int) -> Seq<char>\n    recommends count >= 0\n{\n    let count_str = int_to_string_func(count);\n    Seq::new(25, |i: int| 't').add(count_str).add(Seq::new(10, |i: int| 'n')).add(count_str).add(Seq::new(3, |i: int| 'g')).add(count_str).add(Seq::new(8, |i: int| ' ')).add(count_str).add(Seq::new(5, |i: int| 'n'))\n}\n\nspec fn int_to_string_rec(n: int, acc: Seq<char>) -> Seq<char>\n    recommends n >= 0\n    decreases n\n    when n > 0\n{\n    if n == 0 {\n        acc\n    } else {\n        let digit = n % 10;\n        let digit_char = ('0' as int + digit) as char;\n        int_to_string_rec(n / 10, Seq::new(1, |i: int| digit_char).add(acc))\n    }\n}\n\nfn int_to_string(n: u32) -> (s: Vec<char>)\n    requires n >= 0\n{\n    assume(false);\n    vec!['0']\n}", "vc-helpers": "", "vc-spec": "fn odd_count(lst: Vec<Vec<char>>) -> (result: Vec<Vec<char>>)\n    requires forall|i: int| #![auto] 0 <= i < lst.len() ==> is_all_digits(lst[i as int]@),\n    ensures \n        result.len() == lst.len(),\n        forall|i: int| #![auto] 0 <= i < result.len() ==> result[i as int]@ == format_message(count_odd_digits(lst[i as int]@))", "vc-code": "{\n    assume(false);\n    vec![]\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0116", "language": "verus", "source": "humaneval", "source_id": "humaneval_114_minSubArraySum", "vc-description": "function_signature: def minSubArraySum(nums : list[int]) -> int\n\nGiven an array of integers nums, find the minimum sum of any non-empty sub-array\nof nums.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sum(a: Seq<int>, s: int, t: int) -> int\n  decreases t - s\n{\n  if 0 <= s <= t <= a.len() {\n    if s == t {\n      0\n    } else {\n      sum(a, s, t - 1) + a[t - 1]\n    }\n  } else {\n    0\n  }\n}", "vc-helpers": "", "vc-spec": "fn min_sub_array_sum(a: Vec<int>) -> (s: int)\n  ensures \n    forall|p: int, q: int| 0 <= p <= q <= a@.len() ==> sum(a@, p, q) >= s as int,\n    exists|k: int, m: int| 0 <= k <= m <= a@.len() && s as int == sum(a@, k, m)", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0117", "language": "verus", "source": "humaneval", "source_id": "humaneval_115", "vc-description": "This verification task involves implementing a solution to determine the minimum number of bucket operations needed to empty all wells in a 2D binary grid. Each row represents a well, each 1 represents a unit of water, and each bucket has a fixed capacity. The implementation must correctly calculate the total number of bucket trips required across all wells.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(grid: Seq<Seq<int>>, capacity: int) -> bool {\n    capacity > 0\n}\n\nspec fn sum_water(well: Seq<int>) -> int\n    decreases well.len()\n{\n    if well.len() == 0 {\n        0\n    } else {\n        well[0] + sum_water(well.subrange(1, well.len() as int))\n    }\n}\n\nspec fn trips_for_well(well: Seq<int>, capacity: int) -> int {\n    let water_units = sum_water(well);\n    if water_units == 0 {\n        0\n    } else {\n        (water_units + capacity - 1) / capacity\n    }\n}\n\nspec fn sum_of_trips(grid: Seq<Seq<int>>, capacity: int) -> int\n    decreases grid.len()\n{\n    if grid.len() == 0 {\n        0\n    } else {\n        trips_for_well(grid[0], capacity) + sum_of_trips(grid.subrange(1, grid.len() as int), capacity)\n    }\n}\n\n\n// </vc-preamble>", "vc-helpers": "", "vc-spec": "fn max_fill(grid: Vec<Vec<i8>>, capacity: i8) -> (result: i8)\n    requires valid_input(grid@.map(|i, row: Vec<i8>| row@.map(|j, x: i8| x as int)), capacity as int)\n    ensures \n        result >= 0,\n        result as int == sum_of_trips(grid@.map(|i, row: Vec<i8>| row@.map(|j, x: i8| x as int)), capacity as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0118", "language": "verus", "source": "humaneval", "source_id": "humaneval_116_sort_array", "vc-description": "function_signature: def max_fill_count(grid : list[list[int]], capacity : int) -> int\n\nPlease write a function that sorts an array of non-negative integers according to\nnumber of ones in their binary representation in ascending order. For similar number\nof ones, sort based on decimal value.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn popcount(n: nat) -> nat\n    decreases n\n{\n    if n == 0 { 0 } else { popcount(n / 2) + n % 2 }\n}", "vc-helpers": "", "vc-spec": "fn sort_array(s: Vec<u8>) -> (sorted: Vec<u8>)\n    ensures \n        forall|i: int, j: int| 0 <= i < j < sorted@.len() ==> popcount(sorted@[i] as nat) <= popcount(sorted@[j] as nat)\n            && sorted@.len() == s@.len()\n            && s@.to_multiset() == sorted@.to_multiset()", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0119", "language": "verus", "source": "humaneval", "source_id": "humaneval_118_get_closest_vowel", "vc-description": "function_signature: def get_closest_vowel(s : str) -> str\n\nYou are given a word. Your task is to find the closest vowel that stands between\ntwo consonants from the right side of the word (case sensitive).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_vowel(c: char) -> bool {\n    c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n    c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U'\n}\n\nspec fn is_consonant(c: char) -> bool {\n    (('A' <= c && c <= 'Z') || ('a' <= c && c <= 'z')) && !is_vowel(c)\n}", "vc-helpers": "", "vc-spec": "fn get_closest_vowel(word: Vec<char>) -> (result: Vec<char>)\n    requires forall|i: int| 0 <= i < word.len() ==> (('A' <= word@[i] && word@[i] <= 'Z') || ('a' <= word@[i] && word@[i] <= 'z'))\n    ensures ({\n        &&& result.len() <= 1\n        &&& (result.len() == 1 ==> is_vowel(result@[0]))\n        &&& (result.len() == 1 ==> exists|i: int| \n            1 <= i && i + 1 < word.len()\n                && is_vowel(word@[i]) && is_consonant(word@[i - 1]) && is_consonant(word@[i + 1])\n                && (forall|j: int| i < j < word.len() - 1 ==> !is_vowel(word@[j]) || !is_consonant(word@[j - 1]) || !is_consonant(word@[j + 1])))\n    })", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0120", "language": "verus", "source": "humaneval", "source_id": "humaneval_119", "vc-description": "Given a list of exactly two strings containing only '(' and ')' characters,\ndetermine if it's possible to concatenate them in some order to create a balanced\nparentheses string. Return 'Yes' if either concatenation order produces a balanced\nstring, 'No' otherwise.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_paren_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> s[i] == '(' || s[i] == ')'\n}\n\nspec fn is_balanced_helper(s: Seq<char>, depth: int) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        depth\n    } else if s[0] == '(' {\n        is_balanced_helper(s.subrange(1, s.len() as int), depth + 1)\n    } else if s[0] == ')' {\n        if depth > 0 {\n            is_balanced_helper(s.subrange(1, s.len() as int), depth - 1)\n        } else {\n            -1\n        }\n    } else {\n        is_balanced_helper(s.subrange(1, s.len() as int), depth)\n    }\n}\n\nspec fn is_balanced(s: Seq<char>) -> bool {\n    is_balanced_helper(s, 0) == 0\n}\n\nspec fn valid_input(lst: Seq<Seq<char>>) -> bool {\n    lst.len() == 2 && valid_paren_string(lst[0]) && valid_paren_string(lst[1])\n}\n\nspec fn yes_string() -> Seq<char> {\n    seq!['Y', 'e', 's']\n}\n\nspec fn no_string() -> Seq<char> {\n    seq!['N', 'o']\n}\n\nspec fn correct_output(lst: Seq<Seq<char>>, result: Seq<char>) -> bool {\n    (result == yes_string() || result == no_string()) &&\n    (result == yes_string() <==> (is_balanced(lst[0].add(lst[1])) || is_balanced(lst[1].add(lst[0]))))\n}", "vc-helpers": "", "vc-spec": "fn match_parens(lst: Vec<Vec<char>>) -> (result: Vec<char>)\n    requires valid_input(seq![lst[0]@, lst[1]@])\n    ensures correct_output(seq![lst[0]@, lst[1]@], result@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0121", "language": "verus", "source": "humaneval", "source_id": "humaneval_120_maximum__SortSeq", "vc-description": "function_signature: fn sort_seq(s: &Vec<i8>) -> (sorted: Vec<i8>)\n\nSort elements. Ensures: the result is sorted according to the ordering relation;\nreturns the correct size/count; returns a sorted permutation of the input; the result\nis sorted according to the ordering relation; the result is sorted according to\nthe ordering relation; the result is sorted according to the ordering relation;\nthe result is sorted according to the ordering relation.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn sort_seq(s: &Vec<i8>) -> (sorted: Vec<i8>)\n    ensures \n        forall|i: int, j: int| 0 <= i < j < sorted@.len() ==> #[trigger] sorted@[i] <= #[trigger] sorted@[j],\n        sorted@.len() == s@.len(),\n        s@.to_multiset() == sorted@.to_multiset(),\n        forall|i: int| 0 <= i < s@.len() ==> exists|j: int| 0 <= j < sorted@.len() && #[trigger] s@[i] == #[trigger] sorted@[j],\n        forall|x: i8| #[trigger] s@.contains(x) ==> #[trigger] sorted@.contains(x),\n        forall|i: int| 0 <= i < s@.len() ==> exists|j: int| 0 <= j < sorted@.len() && #[trigger] sorted@[i] == #[trigger] s@[j],\n        forall|x: i8| #[trigger] sorted@.contains(x) ==> #[trigger] s@.contains(x),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0122", "language": "verus", "source": "humaneval", "source_id": "humaneval_120_maximum__maximum", "vc-description": "function_signature: fn maximum(s: Seq<int>, k: int) -> (result: Seq<int>)\n\nProcess input. Requires: the size is bounded; the size is bounded; the condition\nholds for all values. Ensures: returns the correct size/count; the condition holds\nfor all values; the condition holds for all values.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn maximum(s: Vec<i8>, k: i8) -> (result: Vec<i8>)\n  requires \n      1 <= k as int <= s@.len(),\n      1 <= s@.len() <= 1000,\n      forall|x: i8| s@.contains(x) ==> -1000 <= x as int <= 1000,\n  ensures \n      result@.len() == k as int,\n      forall|i: int, j: int| 0 <= i < j < k as int ==> result@[i] as int <= result@[j] as int,\n      forall|x: i8| result@.contains(x) ==> s@.contains(x),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0123", "language": "verus", "source": "humaneval", "source_id": "humaneval_121", "vc-description": "This task requires implementing a method that calculates the sum of all odd numbers located at even-indexed positions in a non-empty sequence of integers. The positions are 0-indexed, so we consider positions 0, 2, 4, etc.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sum_odd_at_even_positions(lst: Seq<int>, pos: int) -> int\n    decreases if pos < lst.len() { lst.len() - pos } else { 0 }\n{\n    if pos >= lst.len() {\n        0\n    } else if lst[pos] % 2 == 1 {\n        lst[pos] + sum_odd_at_even_positions(lst, pos + 2)\n    } else {\n        sum_odd_at_even_positions(lst, pos + 2)\n    }\n}", "vc-helpers": "", "vc-spec": "fn solution(lst: Vec<i8>) -> (result: i8)\n    requires lst@.len() > 0\n    ensures result as int == sum_odd_at_even_positions(lst@.map(|i: int, x: i8| x as int), 0)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0124", "language": "verus", "source": "humaneval", "source_id": "humaneval_122", "vc-description": "This verification task involves computing the sum of all elements\nthat have at most two digits among the first k elements of an array. An element\nhas at most two digits if its absolute value is between 0 and 99 (inclusive).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(arr: Seq<int>, k: int) -> bool {\n  1 <= arr.len() <= 100 && 1 <= k <= arr.len()\n}\n\nspec fn sum_valid_elements(arr: Seq<int>, k: int) -> int {\n  sum_valid_elements_up_to(arr, k)\n}\n\nspec fn sum_valid_elements_up_to(arr: Seq<int>, n: int) -> int\n  decreases n\n{\n  if n == 0 {\n    0int\n  } else if 0 <= n-1 < arr.len() {\n    let current = if -99 <= arr[n-1] <= 99 { arr[n-1] } else { 0int };\n    sum_valid_elements_up_to(arr, n-1) + current\n  } else {\n    0int\n  }\n}", "vc-helpers": "", "vc-spec": "fn add_elements(arr: Vec<i8>, k: i8) -> (result: i8)\n  requires valid_input(arr@.map(|i: int, x: i8| x as int), k as int)\n  ensures result as int == sum_valid_elements(arr@.map(|i: int, x: i8| x as int), k as int)", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0125", "language": "verus", "source": "humaneval", "source_id": "humaneval_123_get_odd_collatz__get_odd_collatz", "vc-description": "function_signature: fn get_odd_collatz(n: nat) -> (sorted: Vec<int>)\n\nRetrieve elements. Requires: requires n > 1. Ensures: the result is sorted according\nto the ordering relation; the result is sorted according to the ordering relation.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn iterate_to_odd(n: nat) -> nat\n  decreases n\n{\n  if n % 2 == 0 && n > 0 {\n    if (n / 2) % 2 == 1 { n / 2 } else { iterate_to_odd(n / 2) }\n  } else {\n    1\n  }\n}\n\nspec fn next_odd_collatz(n: nat) -> nat {\n  if n > 0 {\n    if n % 2 == 0 { iterate_to_odd(n) } else { iterate_to_odd(3 * n + 1) }\n  } else {\n    1\n  }\n}", "vc-helpers": "", "vc-spec": "fn get_odd_collatz(n: u8) -> (sorted: Vec<i8>)\n  requires n as nat > 1\n  ensures \n      forall|i: int, j: int| 0 <= i < j < sorted@.len() ==> sorted@[i] <= sorted@[j],\n      forall|i: int| 0 <= i < sorted@.len() ==> sorted@[i] % 2 == 1,", "vc-code": "{\n  assume(false);\n  Vec::new()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0126", "language": "verus", "source": "humaneval", "source_id": "humaneval_123_get_odd_collatz__get_odd_collatz_unsorted", "vc-description": "function_signature: fn get_odd_collatz_unsorted(n: nat) -> (odd_collatz: Vec<nat>)\n\nSort elements. Requires: requires n > 1. Ensures: the condition holds for all values;\nthe condition holds for all values.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn iterate_to_odd(n: nat) -> nat\n  decreases n,\n{\n  if n % 2 == 0 && n > 0 {\n    if (n / 2) % 2 == 1 { n / 2 } else { iterate_to_odd(n / 2) }\n  } else {\n    1\n  }\n}\n\nspec fn next_odd_collatz(n: nat) -> nat {\n  if n > 0 {\n    if n % 2 == 0 { iterate_to_odd(n) } else { iterate_to_odd(3 * n + 1) }\n  } else {\n    1\n  }\n}", "vc-helpers": "", "vc-spec": "fn get_odd_collatz_unsorted(n: u8) -> (odd_collatz: Vec<u8>)\n  requires n as nat > 1,\n  ensures \n    forall|i: int| 0 <= i < odd_collatz@.len() ==> #[trigger] odd_collatz@[i] as nat % 2 == 1,\n    forall|i: int| 1 <= i < odd_collatz@.len() ==> #[trigger] odd_collatz@[i] as nat == next_odd_collatz(odd_collatz@[i - 1] as nat),", "vc-code": "{\n  assume(false);\n  Vec::new()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0127", "language": "verus", "source": "humaneval", "source_id": "humaneval_123_get_odd_collatz__next_odd_collatz_iter", "vc-description": "function_signature: fn next_odd_collatz_iter(n: nat) -> (next: nat)\n\nProcess input. Requires: requires n > 0. Ensures: returns the correct value; returns the correct value.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn iterate_to_odd(n: nat) -> nat\n  decreases n,\n{\n  if n % 2 == 0 && n > 0 {\n    if (n / 2) % 2 == 1 { n / 2 } else { iterate_to_odd(n / 2) }\n  } else {\n    1\n  }\n}\n\nspec fn next_odd_collatz(n: nat) -> nat {\n  if n > 0 {\n    if n % 2 == 0 { iterate_to_odd(n) } else { iterate_to_odd(3 * n + 1) }\n  } else {\n    1\n  }\n}", "vc-helpers": "", "vc-spec": "fn next_odd_collatz_iter(n: u8) -> (next: u8)\n  requires n > 0,\n  ensures \n    (next as nat) % 2 == 1,\n    next as nat == next_odd_collatz(n as nat),", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0128", "language": "verus", "source": "humaneval", "source_id": "humaneval_124", "vc-description": "Implement a function to validate date strings according to specific\nformatting and validity rules. The date must be in \"mm-dd-yyyy\" format with exactly\ntwo hyphens as separators, contain only numeric components, have a valid month (1-12),\nand have a valid day for the given month (considering different month lengths including\nFebruary with 29 days maximum).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_date_format(date: Seq<char>) -> bool {\n    date.len() > 0 &&\n    count_char(date, '-') == 2 && {\n        let parts = split_by_hyphen(date);\n        parts.len() == 3 &&\n        parts[0].len() > 0 && parts[1].len() > 0 && parts[2].len() > 0 &&\n        is_numeric(parts[0]) && is_numeric(parts[1]) && is_numeric(parts[2]) && {\n            let month = string_to_int(parts[0]);\n            let day = string_to_int(parts[1]);\n            1 <= month <= 12 &&\n            if month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12 {\n                1 <= day <= 31\n            } else if month == 4 || month == 6 || month == 9 || month == 11 {\n                1 <= day <= 30\n            } else {\n                1 <= day <= 29\n            }\n        }\n    }\n}\n\nspec fn count_char(s: Seq<char>, c: char) -> nat \n    decreases s.len()\n{\n    if s.len() == 0 { \n        0\n    } else if s[0] == c { \n        1 + count_char(s.subrange(1, s.len() as int), c)\n    } else { \n        count_char(s.subrange(1, s.len() as int), c)\n    }\n}\n\nspec fn is_digit(c: char) -> bool {\n    '0' <= c <= '9'\n}\n\nspec fn is_numeric(s: Seq<char>) -> bool {\n    s.len() > 0 && (forall|i: int| 0 <= i < s.len() ==> is_digit(s[i]))\n}\n\nspec fn char_to_int(c: char) -> int {\n    c as int - '0' as int\n}\n\nspec fn string_to_int(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { \n        0\n    } else if s.len() == 1 { \n        char_to_int(s[0])\n    } else { \n        string_to_int(s.subrange(0, s.len() - 1)) * 10 + char_to_int(s[s.len() - 1])\n    }\n}\n\nspec fn find_first_hyphen(s: Seq<char>, start: int) -> int\n    decreases s.len() - start\n{\n    if start >= s.len() { \n        s.len() as int\n    } else if s[start] == '-' { \n        start\n    } else { \n        find_first_hyphen(s, start + 1)\n    }\n}\n\nspec fn split_by_hyphen(s: Seq<char>) -> Seq<Seq<char>> {\n    let first_hyphen = find_first_hyphen(s, 0);\n    if first_hyphen >= s.len() { \n        seq![s]\n    } else {\n        let second_hyphen = find_first_hyphen(s, first_hyphen + 1);\n        if second_hyphen >= s.len() { \n            seq![s.subrange(0, first_hyphen), s.subrange(first_hyphen + 1, s.len() as int)]\n        } else { \n            seq![s.subrange(0, first_hyphen), s.subrange(first_hyphen + 1, second_hyphen), s.subrange(second_hyphen + 1, s.len() as int)]\n        }\n    }\n}", "vc-helpers": "", "vc-spec": "fn valid_date(date: &str) -> (result: bool)\n    ensures result == valid_date_format(date@)", "vc-code": "{\n    assume(false);\n    false\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0129", "language": "verus", "source": "humaneval", "source_id": "humaneval_125", "vc-description": "This verification task implements a string processing function that applies rules in a specific order. Given a string, it first checks if the string contains whitespace and splits on whitespace if so. If there's no whitespace but the string contains commas, it splits on commas. Otherwise, it counts the lowercase letters that are at odd positions in the alphabet (b, d, f, h, etc.).\n\nThe implementation uses a datatype to represent either a sequence of strings (for splitting results) or an integer count, with helper functions for each operation and appropriate specifications ensuring correctness.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nenum SplitResult {\n    StringSeq { words: Seq<Seq<char>> },\n    Count { value: int },\n}\n\nspec fn contains_space(txt: Seq<char>) -> bool {\n    exists|i: int| 0 <= i < txt.len() && txt[i] == ' '\n}\n\nspec fn contains_comma(txt: Seq<char>) -> bool {\n    exists|i: int| 0 <= i < txt.len() && txt[i] == ','\n}", "vc-helpers": "spec fn split_on_whitespace(txt: Seq<char>) -> Seq<Seq<char>>\n    decreases txt.len()\n{\n    if txt.len() == 0 {\n        seq![]\n    } else {\n        split_on_whitespace_helper(txt, 0, seq![], seq![])\n    }\n}\n\nspec fn split_on_whitespace_helper(txt: Seq<char>, i: int, result: Seq<Seq<char>>, current_word: Seq<char>) -> Seq<Seq<char>>\n    decreases txt.len() - i when 0 <= i <= txt.len()\n{\n    if i >= txt.len() {\n        if current_word.len() > 0 {\n            result.push(current_word)\n        } else {\n            result\n        }\n    } else if txt[i] == ' ' {\n        if current_word.len() > 0 {\n            split_on_whitespace_helper(txt, i + 1, result.push(current_word), seq![])\n        } else {\n            split_on_whitespace_helper(txt, i + 1, result, seq![])\n        }\n    } else {\n        split_on_whitespace_helper(txt, i + 1, result, current_word.push(txt[i]))\n    }\n}\n\nspec fn split_on_comma(txt: Seq<char>) -> Seq<Seq<char>>\n    decreases txt.len()\n{\n    if txt.len() == 0 {\n        seq![seq![]]\n    } else {\n        split_on_comma_helper(txt, 0, seq![], seq![])\n    }\n}\n\nspec fn split_on_comma_helper(txt: Seq<char>, i: int, result: Seq<Seq<char>>, current_word: Seq<char>) -> Seq<Seq<char>>\n    decreases txt.len() - i when 0 <= i <= txt.len()\n{\n    if i >= txt.len() {\n        result.push(current_word)\n    } else if txt[i] == ',' {\n        split_on_comma_helper(txt, i + 1, result.push(current_word), seq![])\n    } else {\n        split_on_comma_helper(txt, i + 1, result, current_word.push(txt[i]))\n    }\n}\n\nspec fn count_odd_position_lowercase(txt: Seq<char>) -> int {\n    count_odd_position_lowercase_helper(txt, 0)\n}\n\nspec fn count_odd_position_lowercase_helper(txt: Seq<char>, i: int) -> int\n    decreases txt.len() - i when 0 <= i <= txt.len()\n{\n    if i >= txt.len() {\n        0\n    } else {\n        let c = txt[i];\n        let count_rest = count_odd_position_lowercase_helper(txt, i + 1);\n        if 'a' <= c <= 'z' && (c as int - 'a' as int) % 2 == 1 {\n            1 + count_rest\n        } else {\n            count_rest\n        }\n    }\n}", "vc-spec": "fn split_words(txt: Vec<char>) -> (result: SplitResult)\n    ensures \n        (contains_space(txt@) ==> matches!(result, SplitResult::StringSeq { .. })) &&\n        (!contains_space(txt@) && contains_comma(txt@) ==> matches!(result, SplitResult::StringSeq { .. })) &&\n        (!contains_space(txt@) && !contains_comma(txt@) ==> matches!(result, SplitResult::Count { .. })) &&\n        (contains_space(txt@) ==> result == SplitResult::StringSeq { words: split_on_whitespace(txt@) }) &&\n        (!contains_space(txt@) && contains_comma(txt@) ==> \n            result == SplitResult::StringSeq { words: split_on_comma(txt@) }) &&\n        (!contains_space(txt@) && !contains_comma(txt@) ==> \n            result == SplitResult::Count { value: count_odd_position_lowercase(txt@) }) &&\n        (match result {\n            SplitResult::StringSeq { words } => words.len() >= 0,\n            SplitResult::Count { value } => value >= 0,\n        }) &&\n        (contains_space(txt@) ==> match result {\n            SplitResult::StringSeq { words } => forall|w: Seq<char>| words.contains(w) ==> w.len() > 0,\n            _ => true,\n        }) &&\n        (!contains_space(txt@) && contains_comma(txt@) ==> match result {\n            SplitResult::StringSeq { words } => words.len() > 0,\n            _ => true,\n        })", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0130", "language": "verus", "source": "humaneval", "source_id": "humaneval_126", "vc-description": "This verification task checks if a list of non-negative integers satisfies two conditions: (1) the list is sorted in non-decreasing (ascending) order, and (2) no number appears more than twice in the list. The implementation uses helper functions to check these conditions efficiently and returns true if both are met, false otherwise.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(lst: Seq<int>) -> bool {\n    forall|i: int| 0 <= i < lst.len() ==> lst[i] >= 0\n}\n\nspec fn is_sorted_ascending(lst: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < lst.len() ==> lst[i] <= lst[j]\n}\n\nspec fn no_more_than_two_duplicates(lst: Seq<int>) -> bool {\n    forall|i: int| #![auto] 0 <= i < lst.len() ==> count_occurrences(lst, lst[i]) <= 2\n}\n\nspec fn valid_list(lst: Seq<int>) -> bool {\n    valid_input(lst) && is_sorted_ascending(lst) && no_more_than_two_duplicates(lst)\n}\nspec fn count_occurrences(lst: Seq<int>, value: int) -> int\n    decreases lst.len()\n{\n    if lst.len() == 0 {\n        0\n    } else if lst[0] == value {\n        1 + count_occurrences(lst.drop_first(), value)\n    } else {\n        count_occurrences(lst.drop_first(), value)\n    }\n}\n\nspec fn has_more_than_two_occurrences(lst: Seq<int>, index: int) -> bool\n    decreases lst.len() - index when 0 <= index <= lst.len()\n{\n    if index == lst.len() {\n        false\n    } else if 0 <= index < lst.len() && count_occurrences(lst, lst[index]) > 2 {\n        true\n    } else if 0 <= index < lst.len() {\n        has_more_than_two_occurrences(lst, index + 1)\n    } else {\n        false\n    }\n}\n\nspec fn is_sorted_ascending_from_index(lst: Seq<int>, index: int) -> bool\n    decreases lst.len() - index when 0 <= index <= lst.len()\n{\n    if index >= lst.len() - 1 {\n        true\n    } else if 0 <= index < lst.len() - 1 && lst[index] > lst[index + 1] {\n        false\n    } else if 0 <= index < lst.len() {\n        is_sorted_ascending_from_index(lst, index + 1)\n    } else {\n        true\n    }\n}\n\nspec fn is_sorted(lst: Seq<int>) -> bool {\n    if lst.len() <= 1 {\n        true\n    } else if !is_sorted_ascending_from_index(lst, 0) {\n        false\n    } else {\n        !has_more_than_two_occurrences(lst, 0)\n    }\n}", "vc-helpers": "", "vc-spec": "fn check_valid_list(lst: Vec<i8>) -> (result: bool)\n    requires \n        valid_input(lst@.map(|_i: int, x: i8| x as int))\n    ensures \n        result == valid_list(lst@.map(|_i: int, x: i8| x as int)),\n        result == (is_sorted_ascending(lst@.map(|_i: int, x: i8| x as int)) && no_more_than_two_duplicates(lst@.map(|_i: int, x: i8| x as int)))", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0131", "language": "verus", "source": "humaneval", "source_id": "humaneval_127_intersection", "vc-description": "function_signature: def intersection(interval1: Tuple[Int, Int], interval2: Tuple[Int, Int]) -> str\nYou are given two intervals, where each interval is a pair of integers. For example, interval = (start, end) = (1, 2). The given intervals are closed which means that the interval (start, end) includes both start and end. For each given interval, it is assumed that its start is less or equal its end. Your task is to determine whether the length of intersection of these two intervals is a prime number. Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3) which its length is 1, which not a prime number. If the length of the intersection is a prime number, return \"YES\", otherwise, return \"NO\". If the two intervals do not intersect, return \"NO\".", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn is_prime(n: nat) -> bool {\n    n > 1 &&\n    forall|k: nat| #[trigger] (n % k) != 0 ==> 2 <= k < n\n}\n\nspec fn min(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n\nspec fn max(a: int, b: int) -> int {\n    if a >= b { a } else { b }\n}", "vc-spec": "fn intersection(start1: i8, end1: i8, start2: i8, end2: i8) -> (result: String)\n    requires start1 as int <= end1 as int && start2 as int <= end2 as int,\n    ensures (result@ =~= seq!['Y', 'E', 'S'] || result@ =~= seq!['N', 'O']) && (result@ =~= seq!['Y', 'E', 'S'] <==> (max(start1 as int, start2 as int) <= min(end1 as int, end2 as int) && is_prime((min(end1 as int, end2 as int) - max(start1 as int, start2 as int) + 1) as nat))),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0132", "language": "verus", "source": "humaneval", "source_id": "humaneval_128", "vc-description": "This task implements a function that calculates the sum of absolute\nvalues of all elements in an array, multiplied by the product of signs of all elements.\nThe sign function returns 1 for positive numbers, -1 for negative numbers, and 0\nfor zero. If the array is empty, the function returns None; otherwise, it returns\nSome with the computed result.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn abs(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\nspec fn sign(x: int) -> int {\n    if x > 0 { 1 } else if x < 0 { -1 } else { 0 }\n}\n\nspec fn sum_of_magnitudes(arr: Seq<int>) -> int\n    decreases arr.len()\n{\n    if arr.len() == 0 { 0 } else { abs(arr[0]) + sum_of_magnitudes(arr.subrange(1, arr.len() as int)) }\n}\n\nspec fn product_of_signs(arr: Seq<int>) -> int\n    decreases arr.len()\n{\n    if arr.len() == 0 { 1 } else { sign(arr[0]) * product_of_signs(arr.subrange(1, arr.len() as int)) }\n}", "vc-helpers": "", "vc-spec": "fn prod_signs(arr: Vec<i8>) -> (result: Option<i8>)\n    ensures \n        (arr@.len() == 0) ==> (result == Option::<i8>::None) &&\n        (arr@.len() > 0) ==> (result == Option::<i8>::Some((sum_of_magnitudes(arr@.map(|i: int, x: i8| x as int)) * product_of_signs(arr@.map(|i: int, x: i8| x as int))) as i8))", "vc-code": "{\n    // impl-start\n    assume(false);\n    Option::<i8>::None\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0133", "language": "verus", "source": "humaneval", "source_id": "humaneval_130_tri", "vc-description": "function_signature: fn tri(n: nat) -> nat\n\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in the\nlast couple centuries. However, what people don't know is Tribonacci sequence.\nTribonacci sequence is defined by the recurrence: tri(1) = 3 tri(n) = 1 + n / 2,\nif n is even. tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd. For example:\ntri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 +\n3 = 8 You are given a non-negative integer number n, you have to a return a list\nof the first n + 1 numbers of the Tribonacci sequence.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn tri(n: nat) -> nat\n  decreases if n % 2 == 0 { 0 } else { n }\n{\n  if n == 1 { 3 }\n  else if n % 2 == 0 { 1 + n / 2 }\n  else { tri((n - 1) as nat) + tri((n - 2) as nat) + tri(n + 1) }\n}", "vc-helpers": "", "vc-spec": "fn tribonacci(n: u8) -> (result: Vec<u8>)\n  ensures \n    result.len() == n as int + 1 &&\n    (forall|i: int| 0 <= i <= n as int ==> result[i] as nat == tri(i as nat))", "vc-code": "{\n  assume(false);\n  Vec::new()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0134", "language": "verus", "source": "humaneval", "source_id": "humaneval_132_is_nested", "vc-description": "function_signature: fn is_nested(string: &str) -> bool\n\nCreate a function that takes a string as input which contains only parentheses.\nThe function should return True if and only if there is a valid subsequence of parentheses\nwhere at least one parenthesis in the subsequence is nested.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn is_nested(s: Vec<i8>) -> (res: bool)\n    ensures res == exists|x: int, y: int, z: int, w: int| 0 <= x < y < z < w < s@.len() && s@[x] == 0 && s@[y] == 0 && s@[z] == 1 && s@[w] == 1", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0135", "language": "verus", "source": "humaneval", "source_id": "humaneval_133_sum_squares", "vc-description": "function_signature: def sum_squares(lst: List[float]) -> int\n\nYou are given a list of numbers. You need to return the sum of squared numbers in\nthe given list, round each element in the list to the upper int(Ceiling) first.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sum(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 } else { s[0] + sum(s.subrange(1, s.len() as int)) }\n}\n\nspec fn ceil(f: int) -> int {\n    f + 1\n}\n\nspec fn square_seq(lst: Seq<int>) -> Seq<int> {\n    Seq::new(lst.len(), |i: int| ceil(lst[i]) * ceil(lst[i]))\n}", "vc-helpers": "", "vc-spec": "fn sum_squares(lst: Vec<i8>) -> (r: i8)\n    ensures r as int == sum(square_seq(lst@.map(|i: int, x: i8| x as int)))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0136", "language": "verus", "source": "humaneval", "source_id": "humaneval_134", "vc-description": "This verification task involves implementing a method to determine\nif the last character of a string is an alphabetical character that stands alone\n(not part of a word). A \"word\" is defined as a group of characters separated by\nspaces. The method should return true if the last character is a letter AND is not\npart of a word, false otherwise. A standalone letter is either the entire string\n(single character) or a letter preceded by a space.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_alpha(c: char) -> bool {\n    ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')\n}\n\nspec fn valid_last_char_is_standalone_letter(txt: Seq<char>) -> bool {\n    txt.len() > 0 && is_alpha(txt[txt.len() - 1]) && (txt.len() == 1 || txt[txt.len() - 2] == ' ')\n}", "vc-helpers": "", "vc-spec": "fn check_if_last_char_is_a_letter(txt: &str) -> (result: bool)\n    ensures result == valid_last_char_is_standalone_letter(txt@)", "vc-code": "{\n    assume(false);\n    false\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0137", "language": "verus", "source": "humaneval", "source_id": "humaneval_135", "vc-description": "The task is to find the largest index in an array of distinct integers\nwhere an element is smaller than the element immediately before it. If no such index\nexists (i.e., the array is non-decreasing), return -1. The implementation should\nscan from right to left to efficiently find the largest such index.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(arr: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < arr.len() ==> arr[i] != arr[j]\n}\n\nspec fn has_decrease_at(arr: Seq<int>, i: int) -> bool {\n    1 <= i < arr.len() && arr[i] < arr[i-1]\n}\n\nspec fn is_largest_decrease_index(arr: Seq<int>, result: int) -> bool {\n    has_decrease_at(arr, result) && \n    (forall|j: int| result < j < arr.len() ==> #[trigger] arr[j] >= arr[j-1])\n}\n\nspec fn is_non_decreasing(arr: Seq<int>) -> bool {\n    forall|i: int| 1 <= i < arr.len() ==> #[trigger] arr[i] >= arr[i-1]\n}\n\nspec fn seq_map_to_int(arr: Seq<i8>) -> Seq<int> {\n    arr.map(|_i: int, x: i8| x as int)\n}", "vc-helpers": "", "vc-spec": "fn can_arrange(arr: Vec<i8>) -> (result: i8)\n  requires \n      valid_input(seq_map_to_int(arr@)),\n  ensures \n      (result == -1) || (0 < result as int && (result as int) < (arr@.len() as int)),\n      result == -1 ==> is_non_decreasing(seq_map_to_int(arr@)),\n      result != -1 ==> is_largest_decrease_index(seq_map_to_int(arr@), result as int),\n      result != -1 ==> (exists|i: int| has_decrease_at(seq_map_to_int(arr@), i))", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0138", "language": "verus", "source": "humaneval", "source_id": "humaneval_136_largest_smallest_integers", "vc-description": "function_signature: def largest_smallest_integers(lst: List[int]) -> Tuple[ Optional[Int], Optional[Int] ]\n\nCreate a function that returns a tuple (a, b), where 'a' is the largest of negative\nintegers, and 'b' is the smallest of positive integers in a list. If there is\nno negative or positive integers, return them as None.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn get_value(o: Option<int>) -> int\n    recommends o.is_Some()\n{\n    o.get_Some_0()\n}", "vc-helpers": "", "vc-spec": "fn largest_smallest_integers(arr: Vec<i8>) -> (result: (Option<i8>, Option<i8>))", "vc-code": "{\n    assume(false);\n    (Option::None, Option::None)\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0139", "language": "verus", "source": "humaneval", "source_id": "humaneval_137", "vc-description": "This verification task implements a function that compares two values\nof different types (integers, reals, or strings representing real numbers) and returns\nthe larger one in its original format. If the values are numerically equal, the\nfunction returns None. The challenge is handling different value types while maintaining\ntheir original representation in the result.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n#[derive(PartialEq, Eq)]\npub enum Value {\n    Int(int),\n    Real(int), /* Using int to represent reals for simplicity */\n    Str(String),\n}\n\nspec fn is_valid_numeric_string(s: String) -> bool {\n    true\n}\n\nspec fn value_to_real(v: Value) -> int {\n    match v {\n        Value::Int(i) => i,\n        Value::Real(r) => r,\n        Value::Str(s) => string_to_real(s),\n    }\n}\n\nspec fn string_to_real(s: String) -> int {\n    0\n}", "vc-helpers": "", "vc-spec": "fn compare_one(a: Value, b: Value) -> (result: Option<Value>)\n    requires \n        matches!(a, Value::Str(_)) ==> is_valid_numeric_string(a.arrow_Str_0()),\n        matches!(b, Value::Str(_)) ==> is_valid_numeric_string(b.arrow_Str_0()),\n    ensures \n        value_to_real(a) == value_to_real(b) <==> matches!(result, Option::None),\n        value_to_real(a) > value_to_real(b) <==> result == Some(a),\n        value_to_real(b) > value_to_real(a) <==> result == Some(b),\n        matches!(result, Option::Some(_)) ==> (result.arrow_Some_0() == a || result.arrow_Some_0() == b),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0140", "language": "verus", "source": "humaneval", "source_id": "humaneval_138", "vc-description": "This verification task determines whether a given positive integer\nn can be expressed as the sum of exactly 4 positive even numbers. The key insight\nis that the minimum sum is 8 (2+2+2+2), and only even numbers can be expressed this\nway since the sum of 4 even numbers is always even.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int) -> bool {\n    n > 0\n}\n\nspec fn can_be_sum_of_four_positive_evens(n: int) -> bool {\n    n % 2 == 0 && n >= 8\n}", "vc-helpers": "", "vc-spec": "fn is_equal_to_sum_even(n: i8) -> (result: bool)\n    requires valid_input(n as int)\n    ensures result == can_be_sum_of_four_positive_evens(n as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0141", "language": "verus", "source": "humaneval", "source_id": "humaneval_139", "vc-description": "Compute the special factorial of a positive integer n, defined as the product of all factorials from 1! to n!: special_factorial(n) = n! × (n-1)! × (n-2)! × ... × 1!. The implementation should use an iterative approach with proper loop invariants to ensure correctness.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn factorial_func(num: int) -> int\n    recommends num >= 0\n    decreases num\n{\n    if num <= 1 { 1 } else { num * factorial_func(num - 1) }\n}\n\nspec fn special_factorial_func(n: int) -> int\n    recommends n >= 0\n    decreases n\n{\n    if n <= 0 { 1 }\n    else { special_factorial_func(n - 1) * factorial_func(n) }\n}\n\nfn factorial(num: int) -> (result: int)\n    requires \n        num >= 0,\n    ensures \n        result == factorial_func(num),\n        result > 0,\n{\n    assume(false);\n    unreached()\n}", "vc-helpers": "", "vc-spec": "fn special_factorial(n: i8) -> (result: i8)\n    requires \n        n >= 0,\n    ensures \n        result as int == special_factorial_func(n as int),\n        result > 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0142", "language": "verus", "source": "humaneval", "source_id": "humaneval_140", "vc-description": "This verification task involves implementing a string transformation\nmethod that replaces spaces according to specific rules: individual spaces or pairs\nof consecutive spaces become underscores (one per space), while sequences of more\nthan 2 consecutive spaces become a single dash. The implementation must preserve\nthe order of non-space characters and satisfy several correctness predicates.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(text: Seq<char>) -> bool {\n    true\n}\n\nspec fn is_space_sequence(text: Seq<char>, start: int, end: int) -> bool {\n    &&& 0 <= start <= end < text.len()\n    &&& (forall|k: int| start <= k <= end ==> text[k] == ' ')\n    &&& (start == 0 || text[start-1] != ' ')\n    &&& (end == text.len()-1 || text[end+1] != ' ')\n}\n\nspec fn valid_result(text: Seq<char>, result: Seq<char>) -> bool {\n    &&& result.len() <= text.len()\n    &&& (text.len() == 0 ==> result.len() == 0)\n    &&& (forall|i: int| 0 <= i < result.len() ==> result[i] != ' ')\n    &&& (forall|i: int| 0 <= i < result.len() ==> result[i] == '_' || result[i] == '-' || text.contains(result[i]))\n    &&& ((forall|i: int| 0 <= i < text.len() ==> text[i] != ' ') ==> result == text)\n    &&& (forall|i: int| 0 <= i < text.len() && text[i] != ' ' ==> result.contains(text[i]))\n}\n\nspec fn preserves_order(text: Seq<char>, result: Seq<char>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < text.len() && text[i] != ' ' && text[j] != ' ' ==>\n        exists|i_prime: int, j_prime: int| 0 <= i_prime < j_prime < result.len() && result[i_prime] == text[i] && result[j_prime] == text[j]\n}\n\nspec fn correct_space_transformation(text: Seq<char>, result: Seq<char>) -> bool {\n    &&& (forall|i: int| 0 <= i < text.len() ==> #[trigger] text[i] != ' ' ==> result.contains(#[trigger] text[i]))\n    &&& (forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i] != ' ')\n    &&& (forall|i: int, j: int| 0 <= i < j < text.len() && #[trigger] text[i] != ' ' && #[trigger] text[j] != ' ' ==>\n        exists|i_prime: int, j_prime: int| 0 <= i_prime < j_prime < result.len() && result[i_prime] == #[trigger] text[i] && result[j_prime] == #[trigger] text[j])\n    &&& (forall|i: int| 0 <= i < text.len() && #[trigger] text[i] == ' ' ==> \n        (i == 0 || text[i-1] != ' ') && (i == text.len()-1 || text[i+1] != ' ') ==> \n        exists|j: int| 0 <= j < result.len() && ( #[trigger] result[j] == '_' || #[trigger] result[j] == '-'))\n}", "vc-helpers": "", "vc-spec": "fn fix_spaces(text: Seq<char>) -> (result: Seq<char>)\n    requires \n        valid_input(text),\n    ensures \n        valid_result(text, result),\n        preserves_order(text, result),\n        correct_space_transformation(text, result)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0143", "language": "verus", "source": "humaneval", "source_id": "humaneval_142", "vc-description": "Transform each element in a list of integers based on its index position:\nsquare elements at indices that are multiples of 3, cube elements at indices that\nare multiples of 4 but not 3, and leave other elements unchanged. Return the sum\nof all transformed elements.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn transform_element(value: int, index: int) -> int\n{\n    if index % 3 == 0 { \n        value * value\n    } else if index % 4 == 0 { \n        value * value * value\n    } else { \n        value\n    }\n}\n\nspec fn sum_partial(lst: Seq<int>, n: int) -> int\n    decreases n\n    when 0 <= n <= lst.len()\n{\n    if n == 0 { \n        0\n    } else { \n        sum_partial(lst, n-1) + transform_element(lst[n-1], n-1)\n    }\n}\n\nspec fn sum_transformed(lst: Seq<int>) -> int\n{\n    sum_partial(lst, lst.len() as int)\n}", "vc-helpers": "spec fn seq_to_int(s: Seq<i8>) -> Seq<int> {\n    s.map(|i, x: i8| x as int)\n}", "vc-spec": "fn sum_squares(lst: Vec<i8>) -> (result: i8)\n    ensures result as int == sum_transformed(seq_to_int(lst@))", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0144", "language": "verus", "source": "humaneval", "source_id": "humaneval_144", "vc-description": "This verification challenge involves implementing a method that determines\nif the product of two fractions is a whole number. Given two fractions represented\nas strings in the format \"numerator/denominator\", the task is to multiply them and\ncheck if the result is an integer (i.e., the numerator of the product is divisible\nby the denominator).\n\nThe implementation must correctly parse the fraction strings, extract numerators\nand denominators, perform the multiplication, and check divisibility while maintaining\nall verification conditions.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_fraction(s: Seq<char>) -> bool {\n    s.len() > 0 && \n    (exists|i: int| 0 <= i < s.len() && #[trigger] s[i] == '/') &&\n    (forall|j: int| 0 <= j < s.len() ==> (s[j] == '/' || ('0' <= s[j] <= '9'))) &&\n    (exists|k: int| 0 <= k < s.len() && #[trigger] s[k] == '/' && \n        k > 0 && k + 1 < s.len() &&\n        string_to_int(s.subrange(0, k)) > 0 && string_to_int(s.subrange(k+1, s.len() as int)) > 0) &&\n    (forall|i: int| 0 <= i < s.len() && #[trigger] s[i] == '/' ==> \n        i > 0 && i + 1 < s.len() &&\n        string_to_int(s.subrange(0, i)) > 0 && string_to_int(s.subrange(i+1, s.len() as int)) > 0)\n}\n\nspec fn get_numerator(s: Seq<char>) -> int\n    recommends valid_fraction(s)\n{\n    let slash_pos = find_slash(s);\n    string_to_int(s.subrange(0, slash_pos))\n}\n\nspec fn get_denominator(s: Seq<char>) -> int\n    recommends valid_fraction(s)\n{\n    let slash_pos = find_slash(s);\n    string_to_int(s.subrange(slash_pos+1, s.len() as int))\n}\n\nspec fn find_slash(s: Seq<char>) -> int\n    recommends exists|i: int| 0 <= i < s.len() && s[i] == '/'\n{\n    find_slash_helper(s, 0)\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    string_to_int_helper(s, 0)\n}\n\nspec fn char_to_int(c: char) -> int {\n    if c == '0' { 0 }\n    else if c == '1' { 1 }\n    else if c == '2' { 2 }\n    else if c == '3' { 3 }\n    else if c == '4' { 4 }\n    else if c == '5' { 5 }\n    else if c == '6' { 6 }\n    else if c == '7' { 7 }\n    else if c == '8' { 8 }\n    else if c == '9' { 9 }\n    else { 0 }\n}", "vc-helpers": "spec fn find_slash_helper(s: Seq<char>, pos: int) -> int\n    decreases s.len() - pos when 0 <= pos <= s.len() && exists|i: int| pos <= i < s.len() && s[i] == '/'\n{\n    if pos < s.len() && s[pos] == '/' { pos }\n    else { find_slash_helper(s, pos + 1) }\n}\n\nspec fn string_to_int_helper(s: Seq<char>, acc: int) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { acc }\n    else { string_to_int_helper(s.subrange(1, s.len() as int), acc * 10 + char_to_int(s[0])) }\n}", "vc-spec": "fn simplify(x: Vec<char>, n: Vec<char>) -> (result: bool)\n    requires \n        x.len() > 0 && n.len() > 0,\n        exists|i: int| 0 <= i < x@.len() && x@[i] == '/',\n        exists|j: int| 0 <= j < n@.len() && n@[j] == '/',\n        forall|i: int| 0 <= i < x@.len() ==> (x@[i] == '/' || ('0' <= x@[i] <= '9')),\n        forall|j: int| 0 <= j < n@.len() ==> (n@[j] == '/' || ('0' <= n@[j] <= '9')),\n        valid_fraction(x@),\n        valid_fraction(n@),\n    ensures result <==> (get_numerator(x@) * get_numerator(n@)) % (get_denominator(x@) * get_denominator(n@)) == 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0145", "language": "verus", "source": "humaneval", "source_id": "humaneval_145_order_by_points", "vc-description": "function_signature: fn order_by_points(nums: Vec<int>) -> Vec<int>\nWrite a function which sorts the given list of integers in ascending order according to the sum of their digits. Note: if there are several items with similar sum of their digits, order them based on their index in original list.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn digits_sum_pos(n: int) -> int\n  decreases n\n{\n  if n >= 0 {\n    if n < 10 { n } else { digits_sum_pos(n / 10) + n % 10 }\n  } else {\n    0\n  }\n}\n\nspec fn digits_sum(n: int) -> int {\n  if n < 0 { digits_sum_pos(-n) } else { digits_sum_pos(n) }\n}", "vc-helpers": "", "vc-spec": "fn order_by_points(s: Vec<i8>) -> (sorted: Vec<i8>)\n  ensures \n      forall|i: int, j: int| 0 <= i < j < sorted@.len() ==> digits_sum(sorted@[i] as int) <= digits_sum(sorted@[j] as int),\n      sorted@.len() == s@.len(),\n      s@.to_multiset() == sorted@.to_multiset()", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0146", "language": "verus", "source": "humaneval", "source_id": "humaneval_146", "vc-description": "Count the numbers in an array that satisfy all three conditions:\n1) Greater than 10, 2) First digit is odd (1, 3, 5, 7, 9), and 3) Last digit is\nodd (1, 3, 5, 7, 9).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn first_digit(n: int) -> int\n    recommends n > 0\n    decreases n\n{\n    if n < 10 { n } else { first_digit(n / 10) }\n}\n\nspec fn last_digit(n: int) -> int\n    recommends n > 0\n{\n    n % 10\n}\n\nspec fn is_odd(n: int) -> bool\n{\n    n == 1 || n == 3 || n == 5 || n == 7 || n == 9\n}\n\nspec fn satisfies_condition(n: int) -> bool\n{\n    n > 10 && is_odd(first_digit(n)) && is_odd(last_digit(n))\n}\n\nspec fn valid_input(nums: Seq<int>) -> bool\n{\n    true\n}\nspec fn count_helper(nums: Seq<int>, index: int) -> int\n    recommends 0 <= index <= nums.len()\n    decreases nums.len() - index when 0 <= index <= nums.len()\n{\n    if index == nums.len() {\n        0\n    } else {\n        let current = nums[index];\n        let contribution: int = if satisfies_condition(current) { 1 } else { 0 };\n        contribution + count_helper(nums, index + 1)\n    }\n}", "vc-helpers": "", "vc-spec": "fn special_filter(nums: Seq<int>) -> (count: int)\n    requires \n        valid_input(nums)\n    ensures \n        count >= 0,\n        count <= nums.len(),\n        count == Set::new(|i: int| 0 <= i < nums.len() && satisfies_condition(nums[i])).len(),\n        nums.len() == 0 ==> count == 0,\n        forall|i: int| #![auto] 0 <= i < nums.len() && satisfies_condition(nums[i]) ==> \n            nums[i] > 10 && is_odd(first_digit(nums[i])) && is_odd(last_digit(nums[i]))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0147", "language": "verus", "source": "humaneval", "source_id": "humaneval_147", "vc-description": "This verification task involves counting valid triples from a special\narray. Given a positive integer n, create an array where each element a[i] = i²\n- i + 1 for positions 1 to n. The goal is to count the number of triples (a[i],\na[j], a[k]) where i < j < k and their sum is divisible by 3.\n\nThe implementation uses the mathematical insight that elements can be categorized\nby their modulo 3 value, and valid triples must either come from all elements with\nthe same modulo value.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn array_element(i: int) -> int\n  recommends i >= 1\n{\n  i * i - i + 1\n}\n\nspec fn count_elements_mod_0(n: int) -> int\n  recommends n >= 0\n  decreases n when n >= 0\n{\n  if n <= 0 { 0 }\n  else if n % 3 == 2 { 1 + count_elements_mod_0(n - 1) }\n  else { count_elements_mod_0(n - 1) }\n}\n\nspec fn count_elements_mod_1(n: int) -> int\n  recommends n >= 0\n  decreases n when n >= 0\n{\n  if n <= 0 { 0 }\n  else if n % 3 != 2 { 1 + count_elements_mod_1(n - 1) }\n  else { count_elements_mod_1(n - 1) }\n}\n\nspec fn combination(n: int, k: int) -> int\n  recommends n >= 0 && k >= 0\n{\n  if k > n || k < 0 { 0 }\n  else if k == 0 || k == n { 1 }\n  else if k == 1 { n }\n  else if k == 2 { n * (n - 1) / 2 }\n  else if k == 3 { n * (n - 1) * (n - 2) / 6 }\n  else { 0 }\n}\n\nspec fn count_valid_triples(n: int) -> int\n  recommends n >= 1\n{\n  let count_0 = count_elements_mod_0(n);\n  let count_1 = count_elements_mod_1(n);\n  combination(count_0, 3) + combination(count_1, 3)\n}\n\nspec fn valid_input(n: int) -> bool\n{\n  n >= 1\n}", "vc-helpers": "", "vc-spec": "fn get_max_triples(n: i8) -> (result: i8)\n  requires\n      valid_input(n as int),\n  ensures\n      result >= 0,\n      result as int == count_valid_triples(n as int),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0148", "language": "verus", "source": "humaneval", "source_id": "humaneval_148_bf", "vc-description": "function_signature: def bf(planet1: str, planet2: str) -> List[str]\n\nThere are eight planets in our solar system: the closest to the Sun is Mercury,\nthe next one is Venus, then Earth, Mars, Jupiter, Saturn, Uranus, Neptune. Write\na function that takes two planet names as strings planet1 and planet2. The function\nshould return a tuple containing all planets whose orbits are located between the\norbit of planet1 and the orbit of planet2, sorted by the proximity to the sun. The\nfunction should return an empty tuple if planet1 or planet2 are not correct planet\nnames.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n#[derive(PartialEq, Eq, Clone, Copy)]\nenum Planet {\n    Mercury,\n    Venus,\n    Earth,\n    Mars,\n    Jupiter,\n    Saturn,\n    Uranus,\n    Neptune,\n}\n\nspec fn planet_from_string(name: Seq<char>) -> Option<Planet> {\n    if name == seq!['M','e','r','c','u','r','y'] {\n        Some(Planet::Mercury)\n    } else if name == seq!['V','e','n','u','s'] {\n        Some(Planet::Venus)\n    } else if name == seq!['E','a','r','t','h'] {\n        Some(Planet::Earth)\n    } else if name == seq!['M','a','r','s'] {\n        Some(Planet::Mars)\n    } else if name == seq!['J','u','p','i','t','e','r'] {\n        Some(Planet::Jupiter)\n    } else if name == seq!['S','a','t','u','r','n'] {\n        Some(Planet::Saturn)\n    } else if name == seq!['U','r','a','n','u','s'] {\n        Some(Planet::Uranus)\n    } else if name == seq!['N','e','p','t','u','n','e'] {\n        Some(Planet::Neptune)\n    } else {\n        None\n    }\n}\n\nspec fn planet_index(p: Planet) -> int {\n    match p {\n        Planet::Mercury => 0int,\n        Planet::Venus => 1int,\n        Planet::Earth => 2int,\n        Planet::Mars => 3int,\n        Planet::Jupiter => 4int,\n        Planet::Saturn => 5int,\n        Planet::Uranus => 6int,\n        Planet::Neptune => 7int,\n    }\n}\n\nspec fn get_planets_between(planet1: Seq<char>, planet2: Seq<char>) -> Seq<Seq<char>> {\n    let p1 = planet_from_string(planet1);\n    let p2 = planet_from_string(planet2);\n    if p1.is_none() || p2.is_none() {\n        seq![]\n    } else {\n        let i1 = planet_index(p1.unwrap());\n        let i2 = planet_index(p2.unwrap());\n        if i1 < i2 {\n            get_planets_between_indices(i1 + 1, i2 - 1)\n        } else if i1 > i2 {\n            get_planets_between_indices(i2 + 1, i1 - 1)\n        } else {\n            seq![]\n        }\n    }\n}\n\nspec fn get_planets_between_indices(start: int, end: int) -> Seq<Seq<char>>\n    recommends 0 <= start <= 7 && 0 <= end <= 7\n    decreases if start <= end { end - start + 1 } else { 0 }\n{\n    if start > end {\n        seq![]\n    } else {\n        if start == 0int {\n            seq![seq!['M','e','r','c','u','r','y']].add(get_planets_between_indices(1int, end))\n        } else if start == 1int {\n            seq![seq!['V','e','n','u','s']].add(get_planets_between_indices(2int, end))\n        } else if start == 2int {\n            seq![seq!['E','a','r','t','h']].add(get_planets_between_indices(3int, end))\n        } else if start == 3int {\n            seq![seq!['M','a','r','s']].add(get_planets_between_indices(4int, end))\n        } else if start == 4int {\n            seq![seq!['J','u','p','i','t','e','r']].add(get_planets_between_indices(5int, end))\n        } else if start == 5int {\n            seq![seq!['S','a','t','u','r','n']].add(get_planets_between_indices(6int, end))\n        } else if start == 6int {\n            seq![seq!['U','r','a','n','u','s']].add(get_planets_between_indices(7int, end))\n        } else if start == 7int {\n            seq![seq!['N','e','p','t','u','n','e']]\n        } else {\n            seq![]\n        }\n    }\n}\n\nspec fn seq_char_to_string(chars: Seq<char>) -> String {\n    arbitrary()\n}\n\nspec fn planets_seq_to_string_vec(planets: Seq<Seq<char>>) -> Seq<String> \n    decreases planets.len()\n{\n    if planets.len() == 0 {\n        seq![]\n    } else {\n        let first_planet = planets[0];\n        let rest = planets.drop_first();\n        seq![seq_char_to_string(first_planet)].add(planets_seq_to_string_vec(rest))\n    }\n}", "vc-helpers": "", "vc-spec": "fn bf(planet1: String, planet2: String) -> (planets: Vec<String>)\n    ensures planets@ == planets_seq_to_string_vec(get_planets_between(planet1@, planet2@))", "vc-code": "{\n    assume(false);\n    Vec::new()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0149", "language": "verus", "source": "humaneval", "source_id": "humaneval_149_sorted_list_sum__sort_lengths", "vc-description": "function_signature: fn sort_lengths(list: &Seq<Seq<char>>) -> (sorted: Seq<Seq<char>>)\n\nSort elements. Requires: the condition holds for all values. Ensures: the result\nis sorted according to the ordering relation; returns the correct size/count; returns\na sorted permutation of the input; the result is sorted according to the ordering\nrelation.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn comparison(a: Seq<char>, b: Seq<char>, i: int) -> bool\n    decreases a.len() - i, b.len() - i\n{\n    if (i < a.len() && i < b.len()) {\n        if a.index(i) < b.index(i) {\n            true\n        } else if a.index(i) > b.index(i) {\n            false\n        } else {\n            comparison(a, b, i + 1)\n        }\n    } else {\n        if a.len() <= b.len() {\n            true\n        } else {\n            false\n        }\n    }\n}", "vc-helpers": "", "vc-spec": "fn sort_lengths(list: &Vec<Vec<char>>) -> (sorted: Vec<Vec<char>>)\n    requires \n        forall|i: int| 0 <= i < list@.len() ==> list@.index(i).len() % 2 == 0\n    ensures \n        forall|i: int| 0 <= i < sorted@.len() ==> sorted@.index(i).len() % 2 == 0,\n        sorted@.len() == list@.len(),\n        sorted@.to_multiset() == list@.to_multiset(),\n        forall|x: int, y: int| 0 <= x < y < sorted@.len() ==> sorted@.index(x).len() <= sorted@.index(y).len()", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0150", "language": "verus", "source": "humaneval", "source_id": "humaneval_149_sorted_list_sum__sort_strings", "vc-description": "function_signature: fn sort_strings(list: Seq<Seq<char>>) -> (sorted: Seq<Seq<char>>)\n\nSort elements. Ensures: returns the correct size/count; returns a sorted permutation\nof the input.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn comparison(a: Seq<char>, b: Seq<char>, i: int) -> bool \n    decreases a.len() - i, b.len() - i\n{\n    if (0 <= i <= a.len() && 0 <= i <= b.len()) {\n        if (i < a.len() && i < b.len()) {\n            if a.index(i) < b.index(i) {\n                true\n            } else if a.index(i) > b.index(i) {\n                false\n            } else {\n                comparison(a, b, i + 1)\n            }\n        } else {\n            if a.len() <= b.len() {\n                true\n            } else {\n                false\n            }\n        }\n    } else {\n        false\n    }\n}", "vc-helpers": "", "vc-spec": "fn sort_strings(list: Vec<Vec<char>>) -> (sorted: Vec<Vec<char>>)\n    ensures\n        sorted@.len() == list@.len(),\n        sorted@.to_multiset() == list@.to_multiset(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0151", "language": "verus", "source": "humaneval", "source_id": "humaneval_149_sorted_list_sum__sorted_list_sum", "vc-description": "function_signature: fn sorted_list_sum(list: Seq<Seq<char>>) -> (sorted: Seq<Seq<char>>)\n\nSort elements. Requires: requires size of list > 0. Ensures: the size is bounded; the result is sorted according to the ordering relation; the result is sorted according to the ordering relation; returns a sorted permutation of the input.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn comparison(a: Seq<char>, b: Seq<char>, i: int) -> bool\n    recommends 0 <= i <= a.len() && 0 <= i <= b.len()\n    decreases a.len() - i, b.len() - i\n{\n    if (i < a.len() && i < b.len()) {\n        if a[i] < b[i] {\n            true\n        } else if a[i] > b[i] {\n            false\n        } else {\n            comparison(a, b, i + 1)\n        }\n    } else {\n        if a.len() <= b.len() {\n            true\n        } else {\n            false\n        }\n    }\n}", "vc-helpers": "", "vc-spec": "fn sorted_list_sum(list: Vec<Vec<char>>) -> (sorted: Vec<Vec<char>>)\n    requires \n        list@.len() > 0\n    ensures \n        sorted@.len() <= list@.len(),\n        forall|i: int| 0 <= i < sorted@.len() ==> sorted@[i].len() % 2 == 0,\n        forall|x: int, y: int| 0 <= x < y < sorted@.len() ==> sorted@[x].len() <= sorted@[y].len(),\n        sorted@.to_multiset().subset_of(list@.to_multiset())", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0152", "language": "verus", "source": "humaneval", "source_id": "humaneval_150_x_or_y", "vc-description": "function_signature: def x_or_y(int n, int x, int y) -> int\n\nA simple program which should return the value of x if n is a prime number and should\nreturn the value of y otherwise.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_prime(n: nat) -> bool {\n    n > 1 &&\n    forall|k: nat| 2 <= k < n ==> #[trigger] (n % k) != 0\n}", "vc-helpers": "", "vc-spec": "fn x_or_y(n: u8, x: i8, y: i8) -> (result: i8)\n    ensures \n        is_prime(n as nat) ==> result == x,\n        !is_prime(n as nat) ==> result == y,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0153", "language": "verus", "source": "humaneval", "source_id": "humaneval_151", "vc-description": "This verification task implements a function that computes the sum\nof squares of all positive odd integers in a list containing both integers and real\nnumbers. The function should ignore negative numbers and non-integers, returning\n0 for an empty list.\n\nThe implementation needs to handle a mixed datatype that can represent both integers\nand reals, properly identify positive odd integers (including reals that represent\nintegers), and maintain correctness through loop invariants.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nenum Number {\n    Int(int),\n    Real(int), /* Using int to represent real since Verus doesn't have native real type */\n}\n\nspec fn is_integer(r: int) -> bool {\n    true /* Since we're using int to represent real, this is always true */\n}\n\nspec fn is_positive_odd_integer(n: Number) -> bool {\n    match n {\n        Number::Int(i) => i > 0 && i % 2 == 1,\n        Number::Real(r) => is_integer(r) && r > 0 && r % 2 == 1,\n    }\n}\n\nspec fn square_value(n: Number) -> int {\n    match n {\n        Number::Int(i) => i * i,\n        Number::Real(r) => r * r,\n    }\n}\n\nspec fn sum_of_squares(lst: Seq<Number>, i: nat) -> int\n    decreases i\n{\n    if i == 0 {\n        0\n    } else if is_positive_odd_integer(lst[(i - 1) as int]) {\n        square_value(lst[(i - 1) as int]) + sum_of_squares(lst, (i - 1) as nat)\n    } else {\n        sum_of_squares(lst, (i - 1) as nat)\n    }\n}", "vc-helpers": "", "vc-spec": "fn double_the_difference(lst: Vec<Number>) -> (result: i32)\n    ensures \n        result >= 0,\n        result == sum_of_squares(lst@, lst@.len()) as i32,\n        lst@.len() == 0 ==> result == 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0154", "language": "verus", "source": "humaneval", "source_id": "humaneval_152", "vc-description": "This verification task involves implementing a function that compares\ntwo arrays of equal length representing actual game scores and guessed scores. The\nimplementation should calculate how far off each guess was from the actual result\nby computing the absolute difference between corresponding elements.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(game: Seq<int>, guess: Seq<int>) -> bool {\n    game.len() == guess.len()\n}\n\nspec fn valid_output(game: Seq<int>, guess: Seq<int>, result: Seq<int>) -> bool {\n    game.len() == guess.len() ==> (\n        && result.len() == game.len()\n        && (forall|i: int| 0 <= i < game.len() ==> result[i] == abs_value(game[i] - guess[i]))\n        && (forall|i: int| 0 <= i < result.len() ==> result[i] >= 0)\n    )\n}\n\nspec fn abs_value(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}", "vc-helpers": "", "vc-spec": "fn compare(game: Vec<i8>, guess: Vec<i8>) -> (result: Vec<i8>)\n    requires valid_input(game@.map_values(|x: i8| x as int), guess@.map_values(|x: i8| x as int))\n    ensures valid_output(game@.map_values(|x: i8| x as int), guess@.map_values(|x: i8| x as int), result@.map_values(|x: i8| x as int))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0155", "language": "verus", "source": "humaneval", "source_id": "humaneval_153", "vc-description": "Given a class name (string) and a list of extension names (strings),\nfind the \"strongest\" extension and return the result in the format \"ClassName.StrongestExtensionName\".\nThe strength of an extension is calculated as: (number of uppercase letters) - (number\nof lowercase letters). Choose the extension with the highest strength value. If\nmultiple extensions have the same highest strength, choose the first one that appears\nin the list.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn count_upper(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0int\n    } else {\n        (if 'A' <= s[0] && s[0] <= 'Z' { 1int } else { 0int }) + count_upper(s.skip(1))\n    }\n}\n\nspec fn count_lower(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0int\n    } else {\n        (if 'a' <= s[0] && s[0] <= 'z' { 1int } else { 0int }) + count_lower(s.skip(1))\n    }\n}\n\nspec fn strength(s: Seq<char>) -> int {\n    count_upper(s) - count_lower(s)\n}", "vc-helpers": "", "vc-spec": "fn strongest_extension(class_name: Vec<char>, extensions: Vec<Vec<char>>) -> (result: Vec<char>)\n    requires extensions@.len() > 0\n    ensures exists|i: int| 0 <= i < extensions@.len() && \n            result@ == class_name@ + seq!['.'] + extensions@[i]@ &&\n            (forall|j: int| 0 <= j < extensions@.len() ==> \n                strength(extensions@[i]@) >= strength(extensions@[j]@)) &&\n            (forall|j: int| 0 <= j < i ==> \n                strength(extensions@[j]@) < strength(extensions@[i]@))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0156", "language": "verus", "source": "humaneval", "source_id": "humaneval_154_cycpattern_check", "vc-description": "function_signature: def cycpattern_check(String a, String b) -> Bool\n\nYou are given 2 words. You need to return True if the second word or any of its\nrotations is a substring in the first word, else False", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn is_substring(s: Seq<char>, sub: Seq<char>) -> bool\n    decreases s.len()\n{\n    if sub.len() == 0 {\n        true\n    } else if s.len() < sub.len() {\n        false\n    } else if s.len() == sub.len() {\n        s == sub\n    } else {\n        (s.subrange(0, sub.len() as int) == sub) || is_substring(s.subrange(1, s.len() as int), sub)\n    }\n}\n\nspec fn rotate_string(s: Seq<char>, n: nat) -> Seq<char>\n    recommends 0 <= n <= s.len()\n{\n    s.subrange(n as int, s.len() as int).add(s.subrange(0, n as int))\n}", "vc-spec": "fn cycpattern_check(word: Seq<char>, pattern: Seq<char>) -> (result: bool)\n    ensures result == exists|i: int| 0 <= i <= pattern.len() && is_substring(word, #[trigger] rotate_string(pattern, i as nat))", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0157", "language": "verus", "source": "humaneval", "source_id": "humaneval_155", "vc-description": "This verification task implements a function to count the number of even and odd digits in the absolute value of an integer. The function should return a tuple containing the count of even digits and the count of odd digits.\n\nThe implementation uses helper functions to define digit counting operations and ensures correctness through loop invariants that maintain the relationship between processed and remaining digits.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn abs_value(x: int) -> nat {\n    if x < 0 { (-x) as nat } else { x as nat }\n}\n\nspec fn count_digits(n: nat) -> nat\n    recommends n >= 0\n    decreases n\n{\n    if n < 10 { 1nat } else { 1nat + count_digits(n / 10) }\n}\n\nspec fn is_even_digit(d: nat) -> bool\n    recommends d < 10\n{\n    d % 2 == 0\n}\n\nspec fn count_even_digits(n: nat) -> nat\n    recommends n >= 0\n    decreases n\n{\n    if n < 10 {\n        if is_even_digit(n) { 1nat } else { 0nat }\n    } else {\n        (if is_even_digit(n % 10) { 1nat } else { 0nat }) + count_even_digits(n / 10)\n    }\n}\n\nspec fn count_odd_digits(n: nat) -> nat\n    recommends n >= 0\n    decreases n\n{\n    if n < 10 {\n        if !is_even_digit(n) { 1nat } else { 0nat }\n    } else {\n        (if !is_even_digit(n % 10) { 1nat } else { 0nat }) + count_odd_digits(n / 10)\n    }\n}", "vc-helpers": "", "vc-spec": "fn even_odd_count(num: i8) -> (result: (i8, i8))\n    ensures \n        result.0 >= 0 && result.1 >= 0 &&\n        result.0 + result.1 >= 1 &&\n        ({\n            let abs_num = abs_value(num as int);\n            result.0 as nat == count_even_digits(abs_num) &&\n            result.1 as nat == count_odd_digits(abs_num)\n        }) &&\n        result.0 + result.1 == count_digits(abs_value(num as int)) as i8 &&\n        (num == 0 ==> (result.0 == 1 && result.1 == 0)) &&\n        (abs_value(num as int) == abs_value((-num) as int) ==> \n            (result.0 as nat == count_even_digits(abs_value((-num) as int)) && \n             result.1 as nat == count_odd_digits(abs_value((-num) as int))))", "vc-code": "{\n    // impl-start\n    assume(false);\n    (0, 0)\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0158", "language": "verus", "source": "humaneval", "source_id": "humaneval_157", "vc-description": "This verification task involves implementing a method to determine\nif three positive numbers representing triangle side lengths form a right-angled\ntriangle. The implementation must check both that the sides form a valid triangle\n(positive lengths satisfying triangle inequality) and that they satisfy the Pythagorean\ntheorem.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn valid_triangle(a: int, b: int, c: int) -> bool {\n    a > 0 && b > 0 && c > 0 &&\n    a + b > c && a + c > b && b + c > a\n}\n\nspec fn is_right_triangle(a: int, b: int, c: int) -> bool {\n    a * a + b * b == c * c || \n    a * a + c * c == b * b || \n    b * b + c * c == a * a\n}\n\nspec fn valid_right_triangle(a: int, b: int, c: int) -> bool {\n    valid_triangle(a, b, c) && is_right_triangle(a, b, c)\n}", "vc-spec": "fn right_angle_triangle(a: i8, b: i8, c: i8) -> (result: bool)\n    ensures result <==> valid_right_triangle(a as int, b as int, c as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0159", "language": "verus", "source": "humaneval", "source_id": "humaneval_158_find_max", "vc-description": "function_signature: fn find_max(words: Vec<String>) -> String\n\nWrite a function that accepts a list of strings. The list contains different words.\nReturn the word with maximum number of unique characters. If multiple strings have\nmaximum number of unique characters, return the one which comes first in lexicographical\norder.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn string_unique_chars(s: Seq<char>) -> int {\n    s.to_set().len() as int\n}", "vc-helpers": "", "vc-spec": "fn find_max(strings: Vec<String>) -> (s: String)\n    requires \n        strings.len() > 0,\n    ensures \n        exists|i: int| 0 <= i < strings.len() && #[trigger] strings@.index(i)@ == s@,\n        forall|i: int| 0 <= i < strings.len() ==> \n            string_unique_chars(s@) >= #[trigger] string_unique_chars(#[trigger] strings@.index(i)@),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0160", "language": "verus", "source": "humaneval", "source_id": "humaneval_159", "vc-description": "This verification task involves implementing a method that calculates\ncarrot consumption for a rabbit. Given the number of carrots already eaten, the\nnumber of additional carrots needed, and the number of carrots remaining in stock,\nthe method should return the total carrots that will be eaten and how many carrots\nwill be left. The rabbit will eat as many carrots as possible from the remaining\nstock, up to the number needed.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(number: int, need: int, remaining: int) -> bool\n{\n    0 <= number <= 1000 && 0 <= need <= 1000 && 0 <= remaining <= 1000\n}\n\nspec fn can_eat(need: int, remaining: int) -> int\n{\n    if need <= remaining { need } else { remaining }\n}\n\nspec fn total_eaten(number: int, need: int, remaining: int) -> int\n{\n    number + can_eat(need, remaining)\n}\n\nspec fn carrots_left(need: int, remaining: int) -> int\n{\n    remaining - can_eat(need, remaining)\n}\n\nspec fn valid_result(result: Seq<int>, number: int, need: int, remaining: int) -> bool\n{\n    result.len() == 2 &&\n    result[0] == total_eaten(number, need, remaining) &&\n    result[1] == carrots_left(need, remaining) &&\n    result[0] >= number &&\n    result[1] >= 0 &&\n    result[1] <= remaining\n}", "vc-helpers": "", "vc-spec": "fn eat(number: i8, need: i8, remaining: i8) -> (result: Vec<i8>)\n    requires valid_input(number as int, need as int, remaining as int)\n    ensures valid_result(result@.map(|i, x| x as int), number as int, need as int, remaining as int)", "vc-code": "{\n    assume(false);\n    Vec::new()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0161", "language": "verus", "source": "humaneval", "source_id": "humaneval_161", "vc-description": "This task involves implementing a string transformation method that applies one of two operations based on whether the string contains letters. If the string has at least one letter, swap the case of each letter (lowercase ↔ uppercase) while keeping non-letters unchanged. If the string contains no letters, reverse the entire string.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn has_letter(s: Seq<char>) -> bool\n{\n    exists|i: int| 0 <= i < s.len() && (('A' <= s[i] && s[i] <= 'Z') || ('a' <= s[i] && s[i] <= 'z'))\n}\n\nspec fn reverse_string(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 { \n        s \n    } else { \n        s.subrange(s.len() as int - 1, s.len() as int).add(reverse_string(s.subrange(0, s.len() as int - 1)))\n    }\n}\n\nspec fn swap_case(c: char) -> char\n{\n    if 'A' <= c && c <= 'Z' { \n        ((c as u32 + 32) as char)\n    } else if 'a' <= c && c <= 'z' { \n        ((c as u32 - 32) as char)\n    } else { \n        c \n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(s: Vec<char>) -> (result: Vec<char>)\n    ensures (if has_letter(s@) {\n        result@.len() == s@.len() && \n        (forall|i: int| 0 <= i < s@.len() ==> result@[i] == swap_case(s@[i]))\n    } else {\n        result@ == reverse_string(s@)\n    }) && result@.len() == s@.len()", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0162", "language": "verus", "source": "humaneval", "source_id": "humaneval_162", "vc-description": "This verification task implements a string to MD5 hash conversion\nfunction. The method takes a string input and returns an Option type containing\neither None (for empty input) or Some with a valid 32-character lowercase hexadecimal\nMD5 hash string.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_valid_md5_hash(s: Seq<char>) -> bool {\n    s.len() == 32 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s.index(i) == s.index(i) && {\n        let c = s.index(i);\n        ('0' <= c && c <= '9') || ('a' <= c && c <= 'f')\n    }\n}", "vc-helpers": "", "vc-spec": "fn string_to_md5(text: String) -> (result: Option<String>)\n    ensures ({\n        (text@.len() == 0 ==> matches!(result, Option::None)) &&\n        (text@.len() != 0 ==> match result {\n            Option::Some(value) => is_valid_md5_hash(value@),\n            Option::None => false,\n        })\n    })", "vc-code": "{\n    // impl-start\n    assume(false);\n    Option::None\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "VH0163", "language": "verus", "source": "humaneval", "source_id": "humaneval_163_generate_integers__generate_integers", "vc-description": "function_signature: fn generate_integers(a: int, b: int) -> (result: Vec<int>)\n\nGenerate elements. Ensures: the condition holds for all values; the condition holds\nfor all values.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn generate_integers(a: i8, b: i8) -> (result: Vec<i8>)\n    ensures (forall|i: int| 0 <= i < result@.len() ==> result@[i] % 2 == 0) &&\n            (forall|i: int| 0 <= i < result@.len() ==> (result@[i] == 2 || result@[i] == 4 || result@[i] == 6 || result@[i] == 8))", "vc-code": "{\n    assume(false);\n    Vec::new()\n}", "vc-postamble": "\n}\n\nfn main() {}"}
