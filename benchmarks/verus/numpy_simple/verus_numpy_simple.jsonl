{"id": "NpAbs-spec", "vc-description": "Computes the absolute value of each element in a vector.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn abs_int(x: int) -> int {\n    if x < 0 { -x } else { x }\n}", "vc-helpers": "", "vc-spec": "fn abs(a: Vec<i32>) -> (result: Vec<i32>)\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> result[i] == abs_int(a[i] as int),\n        forall|i: int| 0 <= i < result.len() ==> result[i] >= 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpAdd-spec", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn add(a: Vec<i32>, b: Vec<i32>) -> (result: Vec<i32>)\n    requires a.len() == b.len(),\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] + b[i]", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpArange-spec", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn arange_length(start: int, stop: int, step: int) -> nat\n{\n    if step != 0 {\n        if step < 0 {\n            if start > stop {\n                ((start - stop) / (-step)) as nat\n            } else {\n                0\n            }\n        } else {\n            if start < stop {\n                ((stop - start) / step) as nat\n            } else {\n                0\n            }\n        }\n    } else {\n        0\n    }\n}\n\nfn arange(start: int, stop: int, step: int) -> (result: Vec<int>)\n    requires \n        step != 0,\n        if step < 0 { start > stop } else { start < stop },\n    ensures\n        result.len() == arange_length(start, stop, step),\n        result.len() > 0,\n        result[0] == start", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpArgmax-spec", "vc-description": "Finds the index of the maximum element in a non-empty vector of floats.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn argmax(arr: Vec<i32>) -> (result: usize)\n    requires arr.len() > 0,\n    ensures \n        result < arr.len(),\n        forall|i: int| 0 <= i < result ==> arr[result as int] > arr[i],\n        forall|i: int| result < i < arr.len() ==> arr[result as int] >= arr[i]", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpArgsort-spec", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn argsort(a: Vec<i32>) -> (result: Vec<usize>)\n    ensures \n        result.len() == a.len(),\n        forall|i: int, j: int| 0 <= i < j < result.len() ==> #[trigger] a[result[i] as int] <= #[trigger] a[result[j] as int],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpBitwiseAnd-spec", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn bitwise_and(a: Vec<u32>, b: Vec<u32>) -> (result: Vec<u32>)\n    requires a.len() == b.len(),\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == (a[i] & b[i])", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpBitwiseOr-spec", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn bitwise_or(a: Vec<u32>, b: Vec<u32>) -> (result: Vec<u32>)\n    requires a.len() == b.len(),\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == (a[i] | b[i]),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpBitwiseXor-spec", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn bitwise_xor(a: Vec<u32>, b: Vec<u32>) -> (result: Vec<u32>)\n    requires \n        a.len() == b.len(),\n        a.len() > 0,\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> result[i] == a[i] ^ b[i],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpBroadcast-spec", "vc-description": "Broadcast operation that reshapes a vector into a matrix according to broadcasting rules.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n/* Matrix type definition - represents an m√ón matrix */\npub struct Matrix<T> {\n    pub data: Vec<Vec<T>>,\n    pub rows: usize,\n    pub cols: usize,\n}\n\nimpl<T: Copy> Matrix<T> {\n    pub open spec fn view(self) -> Seq<Seq<T>> {\n        self.data@.map(|i: int, row: Vec<T>| row@)\n    }\n\n    pub open spec fn wf(self) -> bool {\n        &&& self.data.len() == self.rows\n        &&& forall|i: int| 0 <= i < self.data.len() ==> self.data[i].len() == self.cols\n    }\n\n    pub open spec fn index(self, i: int, j: int) -> T \n        recommends 0 <= i < self.rows && 0 <= j < self.cols && self.wf()\n    {\n        self.data[i][j]\n    }\n\n    pub open spec fn size(self) -> int {\n        self.rows * self.cols\n    }\n}", "vc-helpers": "", "vc-spec": "fn broadcast(a: Vec<i32>, shape: Vec<usize>) -> (ret: Matrix<i32>)\n    requires \n        a.len() > 0,\n        shape.len() == 2,\n        shape[0] > 0,\n        shape[1] > 0,\n        shape[0] == a.len() || shape[1] == a.len(),\n    ensures\n        ret.wf(),\n        ret.rows == shape[0],\n        ret.cols == shape[1],\n        ret.size() == shape[0] * shape[1],\n        forall|i: int, j: int| 0 <= i < shape[0] && 0 <= j < shape[1] ==> {\n            if shape[0] == a.len() {\n                ret.index(i, j) == a[i as int]\n            } else {\n                ret.index(i, j) == a[j as int]\n            }\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    Matrix {\n        data: Vec::new(),\n        rows: 0,\n        cols: 0,\n    }\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpCenter-spec", "vc-description": "Centers strings within a given width by adding appropriate padding.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn center(input: Vec<String>, width: usize) -> (result: Vec<String>)\n    requires \n        input.len() > 0,\n        forall|i: int| 0 <= i < input.len() ==> input[i]@.len() >= 1,\n    ensures\n        result.len() == input.len(),\n        forall|i: int| 0 <= i < input.len() ==> \n            if input[i]@.len() > width {\n                result[i]@.len() == input[i]@.len()\n            } else {\n                result[i]@.len() == width\n            },\n        forall|i: int| 0 <= i < input.len() ==> \n            if input[i]@.len() < width {\n                let start_pos = (width - input[i]@.len() + 1) / 2;\n                result[i]@.skip(start_pos as int).take(input[i]@.len() as int) == input[i]@\n            } else {\n                true\n            }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpClip-spec", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn clip(a: Vec<i32>, min: i32, max: i32) -> (result: Vec<i32>)\n    requires min < max,\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> {\n            if a[i] < min {\n                result[i] == min\n            } else if a[i] > max {\n                result[i] == max\n            } else {\n                result[i] == a[i]\n            }\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpColumnStack-spec", "vc-description": "Creates a matrix by stacking column vectors horizontally.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn column_stack(input: Vec<Vec<i32>>, m: usize, n: usize) -> (result: Vec<Vec<i32>>)\n    requires \n        n > 0,\n        input.len() == n,\n        forall|i: int| 0 <= i < n ==> #[trigger] input[i].len() == m,\n    ensures\n        result.len() == m,\n        forall|j: int| 0 <= j < m ==> result[j].len() == n,\n        result.len() * n == m * n,\n        forall|i: int, j: int| 0 <= i < n && 0 <= j < m ==> \n            result[j][i] == input[i][j],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpConvolve-spec", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn convolution_sum(arr1: Seq<f32>, arr2: Seq<f32>, n: nat) -> f32\n{\n    0.0\n}\n\nfn convolution_sum_impl(arr1: &Vec<f32>, arr2: &Vec<f32>, n: usize) -> f32\n{\n    // impl-start\n    assume(false);\n    0.0\n    // impl-end\n}\n\nfn convolve(arr1: &Vec<f32>, arr2: &Vec<f32>) -> (result: Vec<f32>)\n    requires \n        arr1.len() > 0,\n        arr2.len() > 0,\n    ensures \n        result.len() == arr1.len() + arr2.len() - 1,", "vc-code": "{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpCopy-spec", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn copy(arr: &Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        result.len() == arr.len(),\n        forall|i: int| 0 <= i < arr.len() ==> result[i] == arr[i],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpCountnonzero-spec", "vc-description": "Counts the number of non-zero elements in a float vector.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn nonzero_helper(arr: Seq<f32>) -> nat \n    decreases arr.len()\n{\n    if arr.len() == 0 {\n        0\n    } else {\n        let rest_count = nonzero_helper(arr.skip(1));\n        if arr[0] == 0.0f32 {\n            rest_count\n        } else {\n            rest_count + 1\n        }\n    }\n}\n\nfn nonzero(arr: Vec<f32>) -> (result: usize)\n    ensures \n        result <= arr.len(),\n        result == nonzero_helper(arr@),\n        arr.len() > 0 && arr[0] == 0.0f32 ==> \n            nonzero_helper(arr@.skip(1)) == if result > 0 { result - 1 } else { 0 }", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpCumProd-spec", "vc-description": "Computes the cumulative product of a vector where each element is the product of all elements up to that index.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn cum_prod(a: Vec<i32>) -> (result: Vec<i32>)\n    requires a.len() > 0,\n    ensures \n        result.len() == a.len(),\n        result[0] == a[0],\n        forall|i: int| 0 < i < a.len() ==> result[i] == result[i-1] * a[i]", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpCumSum-spec", "vc-description": "Computes the cumulative sum of elements in a vector, where each position contains the sum of all elements from the start up to that position.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn cum_sum(a: Vec<i32>) -> (result: Vec<i32>)\n    requires a.len() > 0,\n    ensures \n        result.len() == a.len(),\n        result[0] == a[0],\n        forall|i: int| 1 <= i < a.len() ==> result[i] == result[i - 1] + a[i]", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpDiagonal-spec", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "/* Matrix type represented as a 2D vector */\ntype Matrix<T> = Vec<Vec<T>>;\n\nfn diagonal(arr: Matrix<i32>, k: i32) -> (result: Vec<i32>)\n    requires \n        arr.len() > 0,\n        arr.len() == arr[0].len(), /* square matrix */\n        forall|i: int| 0 <= i < arr.len() ==> arr[i].len() == arr.len(),\n        -(arr.len() as i32) < k && k < (arr.len() as i32),\n    ensures\n        if k > 0 {\n            result.len() == arr.len() - (k as usize) &&\n            forall|i: int| 0 <= i < result.len() ==> result[i] == arr[i][i + (k as usize)]\n        } else {\n            result.len() == arr.len() + ((-k) as usize) &&\n            forall|i: int| 0 <= i < result.len() ==> result[i] == arr[i + ((-k) as usize)][i]\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpEqual-spec", "vc-description": "Element-wise comparison of two vectors, returning a boolean vector indicating equality at each position.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn equal(a: Vec<i32>, b: Vec<i32>) -> (result: Vec<bool>)\n    requires a.len() == b.len(),\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> result[i] == (a[i] == b[i])", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpFlatten-spec", "vc-description": "Flattens a 2D matrix into a 1D vector in row-major order.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* Matrix type definition - 2D array represented as vector of vectors */\npub struct Matrix {\n    pub data: Vec<Vec<i32>>,\n    pub rows: usize,\n    pub cols: usize,\n}\n\nimpl Matrix {\n    pub open spec fn size(&self) -> nat {\n        (self.rows * self.cols) as nat\n    }\n\n    pub open spec fn valid(&self) -> bool {\n        &&& self.data.len() == self.rows\n        &&& forall|i: int| 0 <= i < self.rows ==> self.data[i].len() == self.cols\n    }\n\n    pub open spec fn get(&self, i: usize, j: usize) -> i32 \n        recommends self.valid() && i < self.rows && j < self.cols\n    {\n        self.data[i as int][j as int]\n    }\n}", "vc-helpers": "", "vc-spec": "fn flatten2(mat: &Matrix) -> (ret: Vec<i32>)\n    requires \n        mat.rows > 0,\n        mat.cols > 0,\n        mat.valid(),\n    ensures\n        ret.len() == mat.rows * mat.cols,\n        forall|i: int, j: int| \n            0 <= i < mat.rows && 0 <= j < mat.cols ==> \n            #[trigger] ret[(i * (mat.cols as int) + j) as int] == mat.get(i as usize, j as usize),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpFloorDivide-spec", "vc-description": "Element-wise floor division of two vectors where the divisor vector has no zero elements.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_non_zero_vector(v: Seq<i32>) -> bool {\n    forall|i: int| 0 <= i < v.len() ==> v[i] != 0\n}\n\nfn floor_divide(a: Vec<i32>, b: Vec<i32>) -> (result: Vec<i32>)\n    requires \n        a.len() == b.len(),\n        is_non_zero_vector(b@),\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] / b[i],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpGcd-spec", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn gcd_int(a: i32, b: i32) -> (result: i32)\n    ensures\n        result >= 0,\n        a % result == 0,\n        b % result == 0,\n        forall|d: i32| d > 0 && #[trigger] (a % d) == 0 && #[trigger] (b % d) == 0 ==> d <= result,", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpGreater-spec", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn greater(a: Vec<i32>, b: Vec<i32>) -> (result: Vec<bool>)\n    requires a.len() == b.len(),\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> result[i] == (a[i] > b[i])", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpGreaterEqual-spec", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn greater_equal(a: Vec<i32>, b: Vec<i32>) -> (result: Vec<bool>)\n    requires a.len() == b.len(),\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> result[i] == (a[i] >= b[i])", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpHistogram-spec", "vc-description": "Computes a histogram of floating-point data given bin boundaries.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn histogram(data: Vec<f32>, bins: Vec<f32>) -> (result: Vec<i32>)\n    requires \n        bins.len() >= 2,\n    ensures\n        result.len() == bins.len() - 1,\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n\nfn histogram_helper(data: Vec<f32>, bins: Vec<f32>, hist: Vec<i32>, index: i32) -> (result: Vec<i32>)\n    requires \n        bins.len() >= 2,\n        hist.len() == bins.len() - 1,\n    ensures\n        result.len() == bins.len() - 1,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpIntersect-spec", "vc-description": "Computes the intersection of two vectors containing common elements.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn intersect(a: Vec<f32>, b: Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() < a.len() && result.len() < b.len(),\n        forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < b.len() ==> (\n            (a[i] == b[j] ==> exists|k: int| 0 <= k < result.len() && result[k] == a[i]) &&\n            (a[i] != b[j] ==> !exists|k: int| 0 <= k < result.len() && result[k] == a[i])\n        )", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpInvert-spec", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn pow2(n: nat) -> nat \n    decreases n\n{\n    if n == 0 {\n        1nat\n    } else {\n        2nat * pow2((n - 1) as nat)\n    }\n}", "vc-helpers": "", "vc-spec": "fn invert(bit_width: u32, a: Vec<u32>) -> (result: Vec<u32>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> result[i] == (pow2(bit_width as nat) - 1) - a[i]", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpIsalpha-spec", "vc-description": "Checks if all strings in a vector contain only alphabetic characters (A-Z, a-z).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_alpha_char(c: char) -> bool {\n    ('A' <= c && c <= 'Z') || ('a' <= c && c <= 'z')\n}\n\nspec fn string_is_alpha(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> is_alpha_char(s[i])\n}\n\nfn is_alpha(input: Vec<String>) -> (ret: Vec<bool>)\n    ensures\n        ret.len() == input.len(),\n        forall|i: int| 0 <= i < input.len() ==> \n            ret[i] == string_is_alpha(input[i]@)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpIsclose-spec", "vc-description": "Computes element-wise absolute difference comparison within tolerance for two integer vectors.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn np_isclose(a: Vec<i32>, b: Vec<i32>, tol: i32) -> (result: Vec<bool>)\n    requires \n        a.len() > 0,\n        a.len() == b.len(),\n        tol > 0,\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> \n            result[i] == (-tol < a[i] - b[i] && a[i] - b[i] < tol),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpLcm-spec", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn lcm_int(a: i32, b: i32) -> (result: i32)\n    requires a != 0 && b != 0,\n    ensures \n        result >= 0,\n        result % a == 0,\n        result % b == 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpLeftShift-spec", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn shift_left_int(x: int, shift: nat) -> int;\n\nfn left_shift(a: Vec<i32>, b: Vec<u32>) -> (result: Vec<i32>)\n    requires \n        a.len() == b.len(),\n        forall|i: int| 0 <= i < b.len() ==> b[i] < 64,\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == shift_left_int(a[i] as int, b[i] as nat),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpLess-spec", "vc-description": "Element-wise comparison of two vectors, returning a boolean vector indicating where the first vector is less than the second.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn less(a: Vec<i32>, b: Vec<i32>) -> (result: Vec<bool>)\n    requires a.len() == b.len(),\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> result[i] == (a[i] < b[i])", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpLessEqual-spec", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn less_equal(a: Vec<i32>, b: Vec<i32>) -> (result: Vec<bool>)\n    requires a.len() == b.len(),\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> result[i] == (a[i] <= b[i])", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpMax-spec", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn max(a: Vec<i32>) -> (result: i32)\n    requires a.len() > 0,\n    ensures \n        exists|i: int| 0 <= i < a.len() && result == a[i],\n        forall|i: int| 0 <= i < a.len() ==> a[i] <= result", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpMin-spec", "vc-description": "Finds the minimum element in a non-empty vector.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn min(a: Vec<i32>) -> (result: i32)\n    requires a.len() > 0,\n    ensures \n        exists|i: int| 0 <= i < a.len() && result == a[i],\n        forall|i: int| 0 <= i < a.len() ==> result <= a[i]", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpMod-spec", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn all_nonzero(v: Seq<i32>) -> bool {\n    forall|i: int| 0 <= i < v.len() ==> v[i] != 0\n}\n\nfn mod_vec(a: Vec<i32>, b: Vec<i32>) -> (result: Vec<i32>)\n    requires \n        a.len() == b.len(),\n        all_nonzero(b@),\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] % b[i],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpMultiply-spec", "vc-description": "Element-wise multiplication of two vectors of the same length.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn multiply(a: Vec<i32>, b: Vec<i32>) -> (result: Vec<i32>)\n    requires a.len() == b.len(),\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> result[i] == a[i] * b[i]", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpNotEqual-spec", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn not_equal(a: Vec<i32>, b: Vec<i32>) -> (result: Vec<bool>)\n    requires a.len() == b.len(),\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> result[i] == (a[i] != b[i])", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpPiecewise-spec", "vc-description": "Implements a piecewise function that applies different functions to elements based on conditions.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn piecewise(x: Vec<f32>, condlist: Vec<spec_fn(f32) -> bool>, funclist: Vec<spec_fn(f32) -> f32>) -> (ret: Vec<f32>)\n    requires condlist.len() == funclist.len(),\n    ensures\n        ret.len() == x.len(),\n        forall|i: int, j: int| 0 <= i < x.len() && 0 <= j < condlist.len() && \n            condlist[j](x[i]) ==> ret[i] == funclist[j](x[i])", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpPoly-spec", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn poly_helper_spec(roots: Seq<f32>, val: nat) -> Seq<f32>;\n\nfn poly_helper(roots: Vec<f32>, val: usize) -> (result: Vec<f32>)\n    requires \n        roots.len() > 0,\n        val > 0,\n    ensures \n        result.len() == roots.len(),\n        result.len() > 0 ==> result[0] == 1.0f32\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n\nfn poly(roots: Vec<f32>) -> (result: Vec<f32>)\n    requires roots.len() > 0,\n    ensures \n        result.len() == roots.len(),\n        forall|i: int| 0 <= i < result.len() ==> \n            result[i] == poly_helper_spec(roots@, (roots.len() - 1) as nat)[i]", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpPolyder-spec", "vc-description": "Computes the polynomial derivative of order m for a given polynomial represented as a vector of coefficients.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn polyder(poly: Vec<f32>, m: i32) -> (result: Vec<f32>)\n    requires \n        m > 0,\n        m <= poly.len() as i32,\n    ensures \n        result.len() == poly.len() - (m as usize),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpPower-spec", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn int_pow(base: int, exp: nat) -> int\n    decreases exp\n{\n    if exp == 0 {\n        1\n    } else {\n        base * int_pow(base, (exp - 1) as nat)\n    }\n}", "vc-helpers": "", "vc-spec": "fn power(a: Vec<i32>, b: Vec<u32>) -> (result: Vec<i32>)\n    requires a.len() == b.len(),\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> result[i] == int_pow(a[i] as int, b[i] as nat),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpProd-spec", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn prod_spec_helper(a: Seq<i32>, start: int, finish: int) -> int\n    decreases finish - start\n{\n    if start >= finish {\n        1\n    } else {\n        a[start] * prod_spec_helper(a, start + 1, finish)\n    }\n}\n\nspec fn prod_spec(a: Seq<i32>) -> int {\n    prod_spec_helper(a, 0, a.len() as int)\n}\n\nspec fn prod_array_spec(a: Seq<i32>, start: int, finish: int) -> int {\n    prod_spec_helper(a, start, finish)\n}\n\nfn prod(a: Vec<i32>) -> (result: i32)\n    ensures result == prod_spec(a@)\n{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}\n\nfn prod_array(a: Vec<i32>, start: usize, finish: usize) -> (result: i32)\n    requires \n        start <= finish,\n        finish <= a.len(),\n    ensures result == prod_array_spec(a@, start as int, finish as int)\n{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}\n\nproof fn prod_theorem(a: Vec<i32>)\n    requires a.len() > 0,\n    ensures \n        prod_spec(a@) == prod_array_spec(a@, 0, a.len() as int) &&\n        (forall|i: int| 0 <= i < a.len() && a[i] == 0 ==> prod_spec(a@) == 0)\n{\n    assume(false);\n}", "vc-code": "", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpRavel-spec", "vc-description": "Flattens a 2D matrix into a 1D vector in row-major order.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* Matrix type definition: function from row,col indices to values */\ntype Matrix<T> = spec_fn(usize, usize) -> T;\n\n/* Get matrix element at position (i,j) */\nspec fn matrix_get<T>(mat: Matrix<T>, i: usize, j: usize) -> T {\n    mat(i, j)\n}\n\n/* Matrix size helper */\nspec fn matrix_size(m: usize, n: usize) -> usize {\n    (m * n) as usize\n}", "vc-helpers": "", "vc-spec": "fn ravel(arr: Matrix<i32>, m: usize, n: usize) -> (ret: Vec<i32>)\n    requires m > 0 && n > 0,\n    ensures \n        ret.len() == m * n,\n        forall|i: usize, j: usize| i < m && j < n ==> \n            ret[(i * n + j) as int] == matrix_get(arr, i, j)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpRemainder-spec", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn remainder(a: Vec<i32>, b: Vec<i32>) -> (result: Vec<i32>)\n    requires \n        a.len() == b.len(),\n        forall|i: int| 0 <= i < b.len() ==> b[i] != 0,\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] % b[i],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpReshape-spec", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "type Matrix<T> = Vec<Vec<T>>;\n\nspec fn matrix_size<T>(mat: Matrix<T>) -> nat {\n    if mat.len() == 0 { 0 } else { (mat.len() * mat[0].len()) as nat }\n}\n\nspec fn get_matrix_element<T>(mat: Matrix<T>, i: nat, j: nat) -> T {\n    mat[i as int][j as int]\n}\n\nspec fn get_vector_element<T>(arr: Seq<T>, i: nat) -> T {\n    arr[i as int]\n}\n\nfn reshape(arr: Vec<i32>, shape: Vec<usize>) -> (result: Matrix<i32>)\n    requires \n        arr.len() > 0,\n        shape.len() == 2,\n        forall|i: int| 0 <= i < 2 ==> (shape[i] > 0 || shape[i] == 0),\n        !(shape[0] == 0 && shape[1] == 0),\n        (if shape[0] > 0 && shape[1] > 0 { \n            shape[0] * shape[1] == arr.len()\n        } else if shape[0] == 0 { \n            arr.len() % shape[1] == 0\n        } else { \n            arr.len() % shape[0] == 0\n        }),\n    ensures\n        result.len() > 0,\n        result[0].len() > 0,\n        (if shape[0] > 0 { \n            matrix_size(result) / (if shape[1] > 0 { shape[1] as nat } else { (arr.len() / shape[0]) as nat }) == shape[0] as nat\n        } else { \n            matrix_size(result) / (if shape[1] > 0 { shape[1] as nat } else { (arr.len() / shape[0]) as nat }) == (arr.len() / shape[1]) as nat\n        }),\n        forall|i: nat| i < arr.len() ==> #[trigger] get_vector_element(arr@, i) == result[((i as usize) / result[0].len()) as int][((i as usize) % result[0].len()) as int]", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpRightShift-spec", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\nuse vstd::arithmetic::power2::pow2;\n\nverus! {\nspec fn shift_right_int(x: int, n: nat) -> int {\n    if x >= 0 {\n        x / (pow2(n) as int)\n    } else {\n        -((((-x) - 1) / (pow2(n) as int)) + 1)\n    }\n}", "vc-helpers": "", "vc-spec": "fn right_shift(a: Vec<i32>, b: Vec<u32>) -> (result: Vec<i32>)\n    requires \n        a.len() == b.len(),\n        forall|i: int| 0 <= i < b.len() ==> b[i] < 64,\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> \n            result[i] as int == shift_right_int(a[i] as int, b[i] as nat),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpSelect-spec", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn select(condlist: Vec<Vec<bool>>, choicelist: Vec<Vec<f32>>) -> (result: Vec<f32>)\n    requires \n        condlist.len() > 0,\n        condlist.len() == choicelist.len(),\n        forall|i: int| 0 <= i < condlist.len() ==> condlist[i].len() > 0,\n        forall|i: int| 0 <= i < condlist.len() ==> condlist[i].len() == choicelist[i].len(),\n        forall|i: int, j: int| 0 <= i < condlist.len() && 0 <= j < condlist.len() ==> \n            condlist[i].len() == condlist[j].len(),\n    ensures\n        result.len() == condlist[0].len(),\n        forall|i: int, j: int| \n            0 <= i < condlist.len() && 0 <= j < result.len() && condlist[i][j] ==> \n            result[j] == choicelist[i][j],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpShape-spec", "vc-description": "Matrix and array shape computation functions", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "struct Matrix<T> {\n    m: usize,\n    n: usize,\n    data: Vec<Vec<T>>,\n}\n\nimpl<T> Matrix<T> {\n    spec fn size(&self) -> nat {\n        (self.m as nat) * (self.n as nat)\n    }\n}\n\nenum Arrays {\n    ArrayOne(Vec<f32>),\n    ArrayTwo(Vec<Vec<f32>>),\n    ArrayThree(Vec<Vec<Vec<f32>>>),\n}\n\nspec fn arrays_ndim(a: &Arrays) -> nat {\n    match a {\n        Arrays::ArrayOne(_) => 1nat,\n        Arrays::ArrayTwo(_) => 2nat,\n        Arrays::ArrayThree(_) => 3nat,\n    }\n}\n\nfn shape_arrays(a: &Arrays) -> (result: Vec<usize>)\n    ensures\n        result.len() == arrays_ndim(a),\n        match a {\n            Arrays::ArrayOne(arr) => result.len() == 1 && result[0] == arr.len(),\n            Arrays::ArrayTwo(arr) => result.len() == 2 && result[0] == arr.len() && \n                result[1] == (if arr.len() > 0 { arr[0].len() } else { 0 }),\n            Arrays::ArrayThree(arr) => result.len() == 3 && result[0] == arr.len() && \n                result[1] == (if arr.len() > 0 { arr[0].len() } else { 0 }) &&\n                result[2] == (if arr.len() > 0 && arr[0].len() > 0 { arr[0][0].len() } else { 0 })\n        }\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n\nfn shape_matrix(a: &Matrix<f32>) -> (result: Vec<usize>)\n    ensures\n        result.len() == 2,\n        result[0] == a.m,\n        result[1] == a.n\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-code": "", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpSign-spec", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn sign(a: Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> {\n            (a[i] > 0 ==> result[i] == 1) &&\n            (a[i] == 0 ==> result[i] == 0) &&\n            (a[i] < 0 ==> result[i] == -1)\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpSort-spec", "vc-description": "Sorts a vector of floating-point numbers in ascending order.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn multiset_count<T>(s: Seq<T>, x: T) -> nat {\n    s.filter(|y| y == x).len()\n}", "vc-helpers": "", "vc-spec": "fn sort(a: Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int, j: int| 0 <= i < j < result.len() ==> result[i] <= result[j],\n        forall|x: i32| multiset_count(result@, x) == multiset_count(a@, x),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpSquare-spec", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn square(arr: Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        result.len() == arr.len(),\n        forall|i: int| 0 <= i < arr.len() ==> result[i] == arr[i] * arr[i],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpSubtract-spec", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn subtract(a: Vec<i32>, b: Vec<i32>) -> (result: Vec<i32>)\n    requires a.len() == b.len(),\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> result[i] == a[i] - b[i],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpSum-spec", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn sum_range(a: Seq<i32>, start: int, len: int) -> int\n    decreases len\n{\n    if len <= 0 || start < 0 || start + len > a.len() {\n        0\n    } else if len == 0 {\n        0\n    } else {\n        a[start] + sum_range(a, start + 1, len - 1)\n    }\n}\n\nspec fn seq_sum(a: Seq<i32>) -> int {\n    sum_range(a, 0, a.len() as int)\n}\n\nfn sum(a: Vec<i32>) -> (result: i32)\n    ensures result == seq_sum(a@)\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n\nfn sum_array(a: Vec<i32>, start: usize, finish: usize) -> (result: i32)\n    requires start <= finish, finish <= a.len(),\n    ensures result == sum_range(a@, start as int, (finish - start) as int)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpTranspose-spec", "vc-description": "Matrix transpose operation that swaps rows and columns.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "type Matrix = Vec<Vec<i32>>;\n\nspec fn matrix_get(mat: Matrix, i: int, j: int) -> i32\n    recommends \n        0 <= i < mat.len(),\n        i < mat.len() ==> 0 <= j < mat[i].len()\n{\n    mat[i][j]\n}\n\nspec fn matrix_rows(mat: Matrix) -> int {\n    mat.len() as int\n}\n\nspec fn matrix_cols(mat: Matrix) -> int\n    recommends mat.len() > 0\n{\n    if mat.len() > 0 { mat[0].len() as int } else { 0 }\n}\n\nspec fn matrix_size(mat: Matrix) -> int {\n    matrix_rows(mat) * matrix_cols(mat)\n}\n\nfn transpose(arr: Matrix) -> (ret: Matrix)\n    requires \n        arr.len() > 0,\n        forall|i: int| 0 <= i < arr.len() ==> #[trigger] arr[i].len() == arr[0].len(),\n    ensures\n        ret.len() == arr[0].len(),\n        forall|i: int| 0 <= i < ret.len() ==> #[trigger] ret[i].len() == arr.len(),\n        matrix_size(ret) == matrix_cols(arr) * matrix_rows(arr),\n        forall|i: int, j: int| \n            (0 <= i < matrix_rows(arr) && 0 <= j < matrix_cols(arr)) ==>\n            #[trigger] matrix_get(ret, j, i) == matrix_get(arr, i, j)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpTril-spec", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "type Matrix<T> = Vec<Vec<T>>;\n\nspec fn matrix_size<T>(m: Matrix<T>) -> nat {\n    (m.len() * (if m.len() > 0 { m[0].len() } else { 0 })) as nat\n}\n\nfn tril(arr: Matrix<i32>, k: i32) -> (ret: Matrix<i32>)\n    requires \n        arr.len() > 0,\n        arr[0].len() > 0,\n        -((arr.len() as i32) - 1) < k && k < (arr[0].len() as i32) - 1,\n    ensures\n        matrix_size(ret) == matrix_size(arr),\n        ret.len() == arr.len(),\n        forall|i: int, j: int| \n            0 <= i < arr.len() && 0 <= j < arr[0].len() ==> \n                if j - i > k { ret[i][j] == 0 } else { ret[i][j] == arr[i][j] }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpUniqueall-spec", "vc-description": "Removes duplicate elements from a vector, preserving the order of first occurrences.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn unique_all(arr: Vec<i32>) -> (ret: Vec<i32>)\n    ensures\n        ret.len() <= arr.len(),\n        forall|i: int| 0 <= i < arr.len() ==> exists|j: int| 0 <= j < ret.len() && ret[j] == #[trigger] arr[i],\n        forall|i: int, j: int| 0 <= i < ret.len() && 0 <= j < i ==> ret[i] != ret[j],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpWhere-spec", "vc-description": "Vector where functions for conditional element selection and transformation.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn where_fn(condition: Vec<bool>, x: Vec<i32>, y: Vec<i32>) -> (result: Vec<i32>)\n    requires \n        condition.len() == x.len(),\n        x.len() == y.len(),\n    ensures \n        result.len() == condition.len(),\n        forall|i: int| 0 <= i < result.len() ==> \n            result[i] == if condition[i] { x[i] } else { y[i] }\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n\nfn where_with_transform(arr: Vec<i32>) -> (result: Vec<i32>)\n    requires arr.len() >= 0,\n    ensures \n        result.len() == arr.len()\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-code": "", "vc-postamble": "\n}\nfn main() {}"}
{"id": "NpZeros-spec", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn zeros(n: usize) -> (result: Vec<i32>)\n    ensures \n        result.len() == n,\n        forall|i: int| 0 <= i < n ==> result[i] == 0\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n\nfn zeros2d(rows: usize, cols: usize) -> (result: Vec<Vec<i32>>)\n    ensures \n        result.len() == rows,\n        forall|i: int| 0 <= i < rows ==> result[i].len() == cols,\n        forall|i: int, j: int| 0 <= i < rows && 0 <= j < cols ==> result[i][j] == 0\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-code": "", "vc-postamble": "\n}\nfn main() {}"}
