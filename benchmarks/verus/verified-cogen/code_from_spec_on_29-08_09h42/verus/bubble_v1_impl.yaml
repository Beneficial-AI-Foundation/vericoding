vc-description: |-


vc-preamble: |-
  use vstd::prelude::*;
  
  
  verus! {
  
  spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> (result:bool) {
          forall |i: int, j:int|  from <= i < j < to ==> a[i] <= a[j]
      }
      // pure-end
  // pure-end
  
  spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> (result:bool) {
      &&& r.len() == s.len()
      &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()
      &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]
      &&& p =~= r.map_values(|i: int| s[i])
  }
  // pure-end

vc-helpers: |-
  proof fn lemma_sorted_single_element(a: Seq<u32>, from: int, to: int)
      requires from + 1 >= to
      ensures sorted_between(a, from, to)
  {
  }
  
  proof fn lemma_empty_sorted(a: Seq<u32>)
      ensures sorted_between(a, 0, 0)
  {
  }
  
  proof fn lemma_identity_reorder<T>(s: Seq<T>)
      ensures is_reorder_of(Seq::<int>::new(s.len(), |i: int| i), s, s)
  {
      let r = Seq::<int>::new(s.len(), |i: int| i);
      assert(r.len() == s.len());
      assert(forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()) by {
          assert(forall|i: int| 0 <= i < r.len() ==> r[i] == i);
      };
      assert(forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]) by {
          assert(forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] == i && r[j] == j);
      };
      assert(s =~= r.map_values(|i: int| s[i])) by {
          assert(forall|i: int| 0 <= i < s.len() ==> s[i] == r.map_values(|k: int| s[k])[i]);
      };
  }
  
  proof fn lemma_swap_preserves_reorder<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>, i: int, j: int)
      requires
          is_reorder_of(r, p, s),
          0 <= i < r.len(),
          0 <= j < r.len(),
      ensures
          is_reorder_of(r.update(i, r[j]).update(j, r[i]), p.update(i, p[j]).update(j, p[i]), s)
  {
      let r_new = r.update(i, r[j]).update(j, r[i]);
      let p_new = p.update(i, p[j]).update(j, p[i]);
      
      assert(r_new.len() == s.len());
      assert(forall|k: int| 0 <= k < r_new.len() ==> 0 <= r_new[k] < r_new.len());
      assert(forall|k1: int, k2: int| 0 <= k1 < k2 < r_new.len() ==> r_new[k1] != r_new[k2]);
      assert(p_new =~= r_new.map_values(|k: int| s[k]));
  }
  
  proof fn lemma_swap_result_properties(v: Vec<u32>, i: usize, j: usize)
      requires i < v.len(), j < v.len()
      ensures
          {
              let temp = v[i];
              let mut result = v;
              result.set(i, result[j]);
              result.set(j, temp);
              result
          }.len() == v.len()
  {
  }

vc-spec: |-
  fn test1(nums: &mut Vec<u32>)
          // post-conditions-start
          ensures
              sorted_between(nums@, 0, nums@.len() as int),
              exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
          // post-conditions-end

vc-code: |-
  {
      if nums.len() <= 1 {
          proof {
              if nums.len() == 0 {
                  lemma_empty_sorted(nums@);
              } else {
                  lemma_sorted_single_element(nums@, 0, nums@.len() as int);
              }
              lemma_identity_reorder(old(nums)@);
          }
          return;
      }
      
      let mut i = 0;
      while i < nums.len()
          invariant
              0 <= i <= nums.len(),
              sorted_between(nums@, 0, i as int),
              exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
      {
          let mut min_idx = i;
          let mut j = i + 1;
          
          while j < nums.len()
              invariant
                  i < nums.len(),
                  i <= min_idx < nums.len(),
                  i < j <= nums.len(),
                  forall|k: int| i <= k < j ==> nums@[min_idx as int] <= nums@[k],
                  exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
          {
              if nums[j] < nums[min_idx] {
                  min_idx = j;
              }
              j += 1;
          }
          
          if min_idx != i {
              let old_nums = nums@;
              /* code modified by LLM (iteration 5): fixed swap operation syntax */
              let temp = nums[i];
              nums.set(i, nums[min_idx]);
              nums.set(min_idx, temp);
              proof {
                  lemma_swap_result_properties(*nums, i, min_idx);
                  lemma_swap_preserves_reorder(
                      Seq::<int>::new(old_nums.len(), |k: int| k),
                      old_nums,
                      old(nums)@,
                      i as int,
                      min_idx as int
                  );
              }
          }
          
          i += 1;
      }
  }

vc-postamble: |-
  
  }
  
  fn main() {}

