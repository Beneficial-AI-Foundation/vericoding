vc-description: |-


vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> (result:bool) {
      forall |i: int, j:int|  from <= i < j < to ==> a[i] <= a[j]
  }
  // pure-end
  // pure-end
  
  spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> (result:bool) {
      &&& r.len() == s.len()
      &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()
      &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]
      &&& p =~= r.map_values(|i: int| s[i])
  }
  // pure-end

vc-helpers: |-
  proof fn lemma_swap_preserves_multiset<T>(v: Vec<T>, i: usize, j: usize)
      requires
          i < v.len(),
          j < v.len(),
      ensures
          /* code modified by LLM (iteration 5): use update instead of swap for sequences */
          v@.update(i as int, v@[j as int]).update(j as int, v@[i as int]).to_multiset() =~= v@.to_multiset(),
  {
  }
  
  proof fn lemma_sorted_between_complete(a: Seq<u32>) 
      ensures sorted_between(a, 0, a.len() as int)
  {
  }
  
  proof fn construct_identity_reorder<T: Copy>(s: Seq<T>) -> (r: Seq<int>)
      ensures is_reorder_of(r, s, s)
  {
      let r = Seq::new(s.len(), |i: int| i);
      assert(r.len() == s.len());
      assert forall|i: int| 0 <= i < r.len() implies 0 <= #[trigger] r[i] < r.len() by {
          assert(r[i] == i);
      };
      assert forall|i: int, j: int| 0 <= i < j < r.len() implies r[i] != r[j] by {
          assert(r[i] == i && r[j] == j);
      };
      assert(s =~= r.map_values(|i: int| s[i])) by {
          assert forall|k: int| 0 <= k < s.len() implies s[k] == r.map_values(|i: int| s[i])[k] by {
              /* code modified by LLM (iteration 5): simplified assertion without chained equality */
              assert(r[k] == k);
              assert(r.map_values(|i: int| s[i])[k] == s[r[k]]);
              assert(s[r[k]] == s[k]);
          }
      };
      r
  }
  
  proof fn construct_swap_reorder<T>(r_old: Seq<int>, s_old: Seq<T>, s_new: Seq<T>, i: int, j: int) -> (r_new: Seq<int>)
      requires
          is_reorder_of(r_old, s_old, s_new),
          0 <= i < s_new.len(),
          0 <= j < s_new.len(),
          /* code modified by LLM (iteration 5): use update instead of swap */
          s_old =~= s_new.update(i, s_new[j]).update(j, s_new[i]),
      ensures
          /* code modified by LLM (iteration 5): use update instead of swap */
          is_reorder_of(r_new, s_old, s_new.update(i, s_new[j]).update(j, s_new[i])),
  {
      r_old
  }
  
  proof fn lemma_multiset_transitive<T>(a: Seq<T>, b: Seq<T>, c: Seq<T>)
      requires
          a.to_multiset() =~= b.to_multiset(),
          b.to_multiset() =~= c.to_multiset(),
      ensures
          a.to_multiset() =~= c.to_multiset(),
  {
  }

vc-spec: |-
  fn test1(nums: &mut Vec<u32>)
      // post-conditions-start
      ensures
          sorted_between(nums@, 0, nums@.len() as int),
          exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
      // post-conditions-end

vc-code: |-
  {
      let old_nums = Ghost(nums@);
      
      if nums.len() <= 1 {
          proof {
              /* code modified by LLM (iteration 5): fixed type conversion for sorted_between */
              let r = construct_identity_reorder(nums@);
              assert(is_reorder_of(r, nums@, old_nums@));
          }
          return;
      }
      
      let mut i = 0;
      
      while i < nums.len() - 1
          invariant
              0 <= i <= nums.len() - 1,
              sorted_between(nums@, 0, i as int + 1),
              nums@.to_multiset() =~= old_nums@.to_multiset(),
      {
          let mut min_idx = i;
          let mut j = i + 1;
          
          while j < nums.len()
              invariant
                  i <= min_idx < nums.len(),
                  i < j <= nums.len(),
                  forall|k: int| (i as int) <= k < (j as int) ==> nums@[min_idx as int] <= nums@[k],
                  sorted_between(nums@, 0, i as int + 1),
                  nums@.to_multiset() =~= old_nums@.to_multiset(),
          {
              if nums[j] < nums[min_idx] {
                  min_idx = j;
              }
              j += 1;
          }
          
          if min_idx != i {
              /* code modified by LLM (iteration 5): manual swap implementation */
              let old_nums_snapshot = Ghost(nums@);
              let temp = nums[i];
              nums.set(i, nums[min_idx]);
              nums.set(min_idx, temp);
              proof {
                  assert(nums@.to_multiset() =~= old_nums_snapshot@.to_multiset()) by {
                      lemma_swap_preserves_multiset(*nums, i, min_idx);
                      assert(old_nums_snapshot@.update(i as int, old_nums_snapshot@[min_idx as int]).update(min_idx as int, old_nums_snapshot@[i as int]) =~= nums@);
                  }
                  lemma_multiset_transitive(nums@, old_nums_snapshot@, old_nums@);
              }
          }
          
          i += 1;
      }
      
      proof {
          /* code modified by LLM (iteration 5): fixed type conversions and reorder proof */
          assert(sorted_between(nums@, 0, nums@.len() as int)) by {
              lemma_sorted_between_complete(nums@);
          }
          let r = construct_identity_reorder(old_nums@);
          assert(is_reorder_of(r, nums@, old_nums@)) by {
              assert(nums@.to_multiset() =~= old_nums@.to_multiset());
          }
      }
  }

vc-postamble: |-
  
  }
  
  fn main() {}

