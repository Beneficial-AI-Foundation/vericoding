vc-description: |-


vc-preamble: |-
  use vstd::prelude::*;
  
  verus!{

vc-helpers: |-
  proof fn lemma_filter_preserves_contains<T>(v: Seq<T>, f: spec_fn(T) -> bool, x: T)
      requires v.contains(x), f(x)
      ensures v.filter(f).contains(x)
  {
      let filtered = v.filter(f);
      assert(filtered.contains(x));
  }
  
  proof fn lemma_filter_only_contains<T>(v: Seq<T>, f: spec_fn(T) -> bool, x: T)
      requires v.filter(f).contains(x)
      ensures v.contains(x) && f(x)
  {
      /* code modified by LLM (iteration 5): added proper proof for filter property */
      let filtered = v.filter(f);
      assert(v.contains(x)) by {
          assert(filtered.contains(x));
          assert(exists |j: int| 0 <= j < v.len() && v[j] == x && f(v[j]));
      };
      assert(f(x)) by {
          assert(filtered.contains(x));
          assert(exists |j: int| 0 <= j < v.len() && v[j] == x && f(v[j]));
      };
  }

vc-spec: |-
  fn remove_all_greater(v: Vec<i32>, e: i32) -> (result: Vec<i32>)
      // pre-conditions-start
      requires 
          forall |k1:int,k2:int| 0 <= k1 < k2 < v.len() ==> v[k1] != v[k2],
      // pre-conditions-end
      // post-conditions-start
      ensures
          forall |k:int| 0 <= k < result.len() ==> result[k] <= e && v@.contains(result[k]),
          forall |k:int| 0 <= k < v.len() && v[k] <= e ==> result@.contains(v[k]),
      // post-conditions-end

vc-code: |-
  {
      /* code modified by LLM (iteration 5): fixed type mismatch by using @ for sequence access */
      let mut result: Vec<i32> = Vec::new();
      let mut i = 0;
      
      while i < v.len()
          invariant
              0 <= i <= v.len(),
              forall |k:int| 0 <= k < result.len() ==> result[k] <= e && v@.contains(result[k]),
              forall |k:int| 0 <= k < i && v[k] <= e ==> result@.contains(v[k]),
          decreases v.len() - i
      {
          if v[i] <= e {
              result.push(v[i]);
              /* code modified by LLM (iteration 5): fixed type mismatch by using @ for sequence access */
              proof {
                  assert(v@[i as int] <= e);
                  assert(v@.contains(v@[i as int]));
                  assert(result@.contains(v@[i as int]));
              }
          }
          i += 1;
      }
      
      result
  }

vc-postamble: |-
  
  }
  
  fn main() {}

