vc-description: |-


vc-preamble: |-
  use vstd::prelude::*;
  
  verus!{

vc-helpers: |-
  // Helper lemma to prove arithmetic bounds are preserved
  proof fn arithmetic_bounds_preserved(old_val: i32)
      requires old_val <= 0x7FFF_FFFB
      ensures old_val + 4 <= 0x7FFF_FFFF
  {
      // The proof follows from the precondition and arithmetic
  }

vc-spec: |-
  fn myfun2(x: &mut Vec<i32>) 
      // pre-conditions-start
      requires 
          forall |k:int| 0 <= k < old(x).len() ==> old(x)[k] <= 0x7FFF_FFFB,
      // pre-conditions-end
      // post-conditions-start
      ensures 
          x@.len() == old(x)@.len(),
          forall |k:int| 0 <= k < x.len() ==> #[trigger] x@[k] == old(x)@[k] + 4,
      // post-conditions-end

vc-code: |-
  {
      // impl-start
      let mut i = 0;
      while i < x.len()
          invariant
              0 <= i <= x.len(),
              x@.len() == old(x)@.len(),
              forall |k:int| 0 <= k < i ==> #[trigger] x@[k] == old(x)@[k] + 4,
              forall |k:int| i <= k < x.len() ==> #[trigger] x@[k] == old(x)@[k],
              /* code modified by LLM (iteration 4): added arithmetic bound preservation invariant */
              forall |k:int| 0 <= k < old(x).len() ==> old(x)@[k] <= 0x7FFF_FFFB,
          decreases x.len() - i
      {
          /* code modified by LLM (iteration 4): store current value and prove arithmetic safety */
          let old_val = x[i];
          proof {
              arithmetic_bounds_preserved(old_val);
          }
          x.set(i, old_val + 4);
          i += 1;
      }
      // impl-end
  }

vc-postamble: |-
  
  }
  
  fn main() {}

