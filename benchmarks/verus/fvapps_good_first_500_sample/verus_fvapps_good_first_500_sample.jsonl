{"id": "fvapps_000002", "vc-description": "You are given three sequences: $a_1, a_2, \\ldots, a_n$; $b_1, b_2, \\ldots, b_n$; $c_1, c_2, \\ldots, c_n$.\n\nFor each $i$, $a_i \\neq b_i$, $a_i \\neq c_i$, $b_i \\neq c_i$.\n\nFind a sequence $p_1, p_2, \\ldots, p_n$, that satisfy the following conditions:\n\n $p_i \\in \\{a_i, b_i, c_i\\}$\n\n $p_i \\neq p_{(i \\mod n) + 1}$.\n\nIn other words, for each element, you need to choose one of the three possible values, such that no two adjacent elements (where we consider elements $i,i+1$ adjacent for $i<n$ and also elements $1$ and $n$) will have equal value.\n\nIt can be proved that in the given constraints solution always exists. You don't need to minimize/maximize anything, you need to find any proper sequence.\n\n-----Input-----\n\nThe first line of input contains one integer $t$ ($1 \\leq t \\leq 100$): the number of test cases.\n\nThe first line of each test case contains one integer $n$ ($3 \\leq n \\leq 100$): the number of elements in the given sequences.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq 100$).\n\nThe third line contains $n$ integers $b_1, b_2, \\ldots, b_n$ ($1 \\leq b_i \\leq 100$).\n\nThe fourth line contains $n$ integers $c_1, c_2, \\ldots, c_n$ ($1 \\leq c_i \\leq 100$).\n\nIt is guaranteed that $a_i \\neq b_i$, $a_i \\neq c_i$, $b_i \\neq c_i$ for all $i$.\n\n-----Output-----\n\nFor each test case, print $n$ integers: $p_1, p_2, \\ldots, p_n$ ($p_i \\in \\{a_i, b_i, c_i\\}$, $p_i \\neq p_{i \\mod n + 1}$).\n\nIf there are several solutions, you can print any.\n\n-----Example-----\nInput\n5\n3\n1 1 1\n2 2 2\n3 3 3\n4\n1 2 1 2\n2 1 2 1\n3 4 3 4\n7\n1 3 3 1 1 1 1\n2 4 4 3 2 2 4\n4 2 2 2 4 4 2\n3\n1 2 1\n2 3 3\n3 1 2\n10\n1 1 1 2 2 2 3 3 3 1\n2 2 2 3 3 3 1 1 1 2\n3 3 3 1 1 1 2 2 2 3\n\nOutput\n1 2 3\n1 2 1 2\n1 3 4 3 2 4 2\n1 3 2\n1 2 3 1 2 3 1 2 3 2\n\n-----Note-----\n\nIn the first test case $p = [1, 2, 3]$.\n\nIt is a correct answer, because:\n\n  $p_1 = 1 = a_1$, $p_2 = 2 = b_2$, $p_3 = 3 = c_3$  $p_1 \\neq p_2 $, $p_2 \\neq p_3 $, $p_3 \\neq p_1$ \n\nAll possible correct answers to this test case are: $[1, 2, 3]$, $[1, 3, 2]$, $[2, 1, 3]$, $[2, 3, 1]$, $[3, 1, 2]$, $[3, 2, 1]$.\n\nIn the second test case $p = [1, 2, 1, 2]$.\n\nIn this sequence $p_1 = a_1$, $p_2 = a_2$, $p_3 = a_3$, $p_4 = a_4$. Also we can see, that no two adjacent elements of the sequence are equal.\n\nIn the third test case $p = [1, 3, 4, 3, 2, 4, 2]$.\n\nIn this sequence $p_1 = a_1$, $p_2 = a_2$, $p_3 = b_3$, $p_4 = b_4$, $p_5 = b_5$, $p_6 = c_6$, $p_7 = c_7$. Also we can see, that no two adjacent elements of the sequence are equal.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_sequence(n: usize, a: Vec<u32>, b: Vec<u32>, c: Vec<u32>) -> (result: Vec<u32>)\n    requires\n        n >= 2,\n        a.len() == n,\n        b.len() == n,\n        c.len() == n,\n        forall|i: int| 0 <= i < n ==> a[i] != b[i],\n        forall|i: int| 0 <= i < n ==> a[i] != c[i],\n        forall|i: int| 0 <= i < n ==> b[i] != c[i],\n    ensures\n        result.len() == n,\n        forall|i: int| 0 <= i < n ==> \n            result[i] == a[i] || result[i] == b[i] || result[i] == c[i],\n        forall|i: int, j: int| 0 <= i < n && j == (i + 1) % (n as int) ==> \n            result[i] != result[j],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: unguarded\n}"}
{"id": "fvapps_000004", "vc-description": "You are given a permutation p=[p_1, p_2, ..., p_n] of integers from 1 to n. Let's call the number m (1 ≤ m ≤ n) beautiful, if there exists two indices l, r (1 ≤ l ≤ r ≤ n), such that the numbers [p_l, p_{l+1}, ..., p_r] is a permutation of numbers 1, 2, ..., m.\n\nFor example, let p = [4, 5, 1, 3, 2, 6]. In this case, the numbers 1, 3, 5, 6 are beautiful and 2, 4 are not. It is because: if l = 3 and r = 3 we will have a permutation [1] for m = 1; if l = 3 and r = 5 we will have a permutation [1, 3, 2] for m = 3; if l = 1 and r = 5 we will have a permutation [4, 5, 1, 3, 2] for m = 5; if l = 1 and r = 6 we will have a permutation [4, 5, 1, 3, 2, 6] for m = 6; it is impossible to take some l and r, such that [p_l, p_{l+1}, ..., p_r] is a permutation of numbers 1, 2, ..., m for m = 2 and for m = 4.\n\nYou are given a permutation p=[p_1, p_2, ..., p_n]. For all m (1 ≤ m ≤ n) determine if it is a beautiful number or not.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_permutation_of_range(seq: Seq<nat>, m: nat) -> bool {\n    seq.len() == m && \n    forall|i: nat| 1 <= i <= m ==> #[trigger] seq.contains(i) &&\n    forall|x: nat| #[trigger] seq.contains(x) ==> 1 <= x <= m\n}\n\nspec fn is_beautiful_number(nums: Seq<nat>, m: nat) -> bool {\n    exists|l: int, r: int| \n        0 <= l <= r < nums.len() &&\n        #[trigger] is_permutation_of_range(nums.subrange(l, r + 1), m)\n}\n\nfn solve_beautiful_permutation(nums: Vec<nat>) -> (result: Vec<nat>)\n    requires nums.len() > 0,\n    ensures \n        result.len() == nums.len(),\n        forall|i: int| 0 <= i < result.len() ==> (result[i] == 0 || result[i] == 1),\n        forall|i: int| 0 <= i < result.len() ==> \n            (result[i] == 1 <==> is_beautiful_number(nums@, (i + 1) as nat))", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = solve_beautiful_permutation(vec![4, 5, 1, 3, 2, 6]);\n    // println!(\"{:?}\", result1); // Expected: [1, 0, 1, 0, 1, 1]\n\n    // let result2 = solve_beautiful_permutation(vec![5, 3, 1, 2, 4]);\n    // println!(\"{:?}\", result2); // Expected: [1, 1, 1, 1, 1]\n\n    // let result3 = solve_beautiful_permutation(vec![1, 4, 3, 2]);\n    // println!(\"{:?}\", result3); // Expected: [1, 0, 0, 1]\n}"}
{"id": "fvapps_000005", "vc-description": "The sequence of m integers is called the permutation if it contains all integers from 1 to m exactly once. The number m is called the length of the permutation.\n\nDreamoon has two permutations p_1 and p_2 of non-zero lengths l_1 and l_2.\n\nNow Dreamoon concatenates these two permutations into another sequence a of length l_1 + l_2. First l_1 elements of a is the permutation p_1 and next l_2 elements of a is the permutation p_2. \n\nYou are given the sequence a, and you need to find two permutations p_1 and p_2. If there are several possible ways to restore them, you should find all of them. (Note that it is also possible that there will be no ways.)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn contains_all_from_1_to_n(arr: Seq<i32>, n: i32) -> bool {\n    forall|i: i32| 1 <= i <= n ==> #[trigger] arr.contains(i)\n}\n\nspec fn has_no_duplicates(arr: Seq<i32>) -> bool {\n    forall|i: int, j: int| 0 <= i < arr.len() && 0 <= j < arr.len() && i != j ==> #[trigger] arr[i] != #[trigger] arr[j]\n}\n\nspec fn is_permutation(arr: Seq<i32>, n: i32) -> bool {\n    arr.len() == n &&\n    contains_all_from_1_to_n(arr, n) &&\n    has_no_duplicates(arr) &&\n    forall|i: int| 0 <= i < arr.len() ==> 1 <= #[trigger] arr[i] <= n\n}\n\nspec fn is_valid_split(arr: Seq<i32>, l1: usize, l2: usize) -> bool {\n    l1 > 0 && l2 > 0 && l1 + l2 == arr.len() &&\n    is_permutation(arr.take(l1 as int), l1 as i32) &&\n    is_permutation(arr.skip(l1 as int), l2 as i32)\n}\n\nfn find_permutations(arr: Vec<i32>) -> (result: Vec<(usize, usize)>)\n    requires \n        arr.len() >= 2,\n        forall|i: int| 0 <= i < arr.len() ==> arr[i] > 0,\n    ensures\n        forall|i: int| 0 <= i < result.len() ==> {\n            #[trigger] result[i].0 > 0 && #[trigger] result[i].1 > 0 && \n            result[i].0 + result[i].1 == arr.len() &&\n            is_valid_split(arr@, result[i].0, result[i].1)\n        },\n        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result.len() && i != j ==> \n            #[trigger] result[i] != #[trigger] result[j],", "vc-code": "{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000006", "vc-description": "Arthur owns a ski resort on a mountain. There are n landing spots on the mountain numbered from 1 to n from the top to the foot of the mountain. The spots are connected with one-directional ski tracks. All tracks go towards the foot of the mountain, so there are no directed cycles formed by the tracks. There are at most two tracks leaving each spot, but many tracks may enter the same spot.\n\nA skier can start skiing from one spot and stop in another spot if there is a sequence of tracks that lead from the starting spot and end in the ending spot. Unfortunately, recently there were many accidents, because the structure of the resort allows a skier to go through dangerous paths, by reaching high speed and endangering himself and the other customers. Here, a path is called dangerous, if it consists of at least two tracks.\n\nArthur wants to secure his customers by closing some of the spots in a way that there are no dangerous paths in the resort. When a spot is closed, all tracks entering and leaving that spot become unusable. \n\nFormally, after closing some of the spots, there should not be a path that consists of two or more tracks.\n\nArthur doesn't want to close too many spots. He will be happy to find any way to close at most 4/7 * n spots so that the remaining part is safe. Help him find any suitable way to do so.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn valid_track(n: nat, track: (nat, nat)) -> bool {\n    let (u, v) = track;\n    1 <= u && u <= n && 1 <= v && v <= n && u != v\n}", "vc-spec": "fn solve_ski_resort(test_cases: Vec<(nat, nat, Vec<(nat, nat)>)>) -> (result: Vec<(nat, Vec<nat>)>)\n    requires test_cases.len() > 0,\n    ensures \n        result.len() == test_cases.len()", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let test_cases = vec![(4, 6, vec![(1, 2), (1, 3), (2, 3), (2, 4), (3, 4), (3, 4)]),\n    //                      (7, 6, vec![(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)])];\n    // let result = solve_ski_resort(test_cases);\n    // println!(\"{:?}\", result);\n}"}
{"id": "fvapps_000008", "vc-description": "You like playing chess tournaments online.\n\nIn your last tournament you played $n$ games. For the sake of this problem, each chess game is either won or lost (no draws). When you lose a game you get $0$ points. When you win you get $1$ or $2$ points: if you have won also the previous game you get $2$ points, otherwise you get $1$ point. If you win the very first game of the tournament you get $1$ point (since there is not a \"previous game\").\n\nThe outcomes of the $n$ games are represented by a string $s$ of length $n$: the $i$-th character of $s$ is W if you have won the $i$-th game, while it is L if you have lost the $i$-th game.\n\nAfter the tournament, you notice a bug on the website that allows you to change the outcome of at most $k$ of your games (meaning that at most $k$ times you can change some symbol L to W, or W to L). Since your only goal is to improve your chess rating, you decide to cheat and use the bug.\n\nCompute the maximum score you can get by cheating in the optimal way.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn calculate_max_score(n: usize, k: usize, games: Vec<char>) -> (result: usize)\n    requires \n        n > 0,\n        games.len() == n,\n        k <= n,\n    ensures\n        result >= 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let games1 = vec!['W', 'L', 'W', 'L', 'L'];\n    // let result1 = calculate_max_score(5, 2, games1);\n    // assert(result1 == 7);\n    \n    // let games2 = vec!['L', 'L', 'L', 'W', 'W', 'L'];\n    // let result2 = calculate_max_score(6, 5, games2);\n    // assert(result2 == 11);\n    \n    // let games3 = vec!['L', 'W', 'L', 'W', 'L', 'W', 'L'];\n    // let result3 = calculate_max_score(7, 1, games3);\n    // assert(result3 == 6);\n}"}
{"id": "fvapps_000010", "vc-description": "Given a permutation p of length n, find its subsequence s_1, s_2, ..., s_k of length at least 2 such that: |s_1-s_2|+|s_2-s_3|+...+|s_{k-1}-s_k| is as big as possible over all subsequences of p with length at least 2. Among all such subsequences, choose the one whose length, k, is as small as possible.\n\nIf multiple subsequences satisfy these conditions, you are allowed to find any of them.\n\nA sequence a is a subsequence of an array b if a can be obtained from b by deleting some (possibly, zero or all) elements.\n\nA permutation of length n is an array of length n in which every element from 1 to n occurs exactly once.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_subsequence(sub: Seq<i32>, arr: Seq<i32>) -> bool\n    decreases sub.len()\n{\n    if sub.len() == 0 {\n        true\n    } else {\n        exists|i: int| 0 <= i < arr.len() && \n            arr[i] == sub[0] && \n            is_subsequence(sub.skip(1), arr.skip(i + 1))\n    }\n}\n\nspec fn absolute_diff(a: i32, b: i32) -> int {\n    if a >= b { (a - b) as int } else { (b - a) as int }\n}\n\nspec fn subsequence_diff_sum(sub: Seq<i32>) -> int\n    decreases sub.len()\n{\n    if sub.len() <= 1 {\n        0\n    } else {\n        absolute_diff(sub[0], sub[1]) + subsequence_diff_sum(sub.skip(1))\n    }\n}\n\nfn find_max_diff_subsequence(arr: Vec<i32>) -> (result: Vec<i32>)\n    requires arr.len() >= 2,\n    ensures \n        result.len() >= 2,\n        is_subsequence(result@, arr@),\n        result[0] == arr[0],\n        result[result.len() - 1] == arr[arr.len() - 1],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000012", "vc-description": "Once again, Boris needs the help of Anton in creating a task. This time Anton needs to solve the following problem:\n\nThere are two arrays of integers $a$ and $b$ of length $n$. It turned out that array $a$ contains only elements from the set $\\{-1, 0, 1\\}$.\n\nAnton can perform the following sequence of operations any number of times:  Choose any pair of indexes $(i, j)$ such that $1 \\le i < j \\le n$. It is possible to choose the same pair $(i, j)$ more than once.   Add $a_i$ to $a_j$. In other words, $j$-th element of the array becomes equal to $a_i + a_j$. \n\nFor example, if you are given array $[1, -1, 0]$, you can transform it only to $[1, -1, -1]$, $[1, 0, 0]$ and $[1, -1, 1]$ by one operation.\n\nAnton wants to predict if it is possible to apply some number (zero or more) of these operations to the array $a$ so that it becomes equal to array $b$. Can you help him?", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn can_be_transformed(a: Seq<i32>, b: Seq<i32>) -> bool {\n    a.len() == b.len() && (a == b || exists_transformation_sequence(a, b))\n}\n\nspec fn exists_transformation_sequence(a: Seq<i32>, b: Seq<i32>) -> bool {\n    true  // Placeholder for actual transformation logic\n}\n\nfn can_transform_array(n: usize, a: Vec<i32>, b: Vec<i32>) -> (result: bool)\n    requires\n        a.len() == n,\n        b.len() == n,\n        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i] >= -1 && #[trigger] a[i] <= 1,\n    ensures\n        result == can_be_transformed(a@, b@)", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: unguarded\n    //\n    // Example tests:\n    // assert(can_transform_array(3, vec![1, -1, 0], vec![1, 1, -2]) == true);\n    // assert(can_transform_array(3, vec![0, 1, 1], vec![0, 2, 2]) == false);\n    // assert(can_transform_array(5, vec![0, 1, -1, 1, -1], vec![1, 1, -1, 1, -1]) == false);\n}"}
{"id": "fvapps_000013", "vc-description": "Your company was appointed to lay new asphalt on the highway of length $n$. You know that every day you can either repair one unit of the highway (lay new asphalt over one unit of the highway) or skip repairing.\n\nSkipping the repair is necessary because of the climate. The climate in your region is periodical: there are $g$ days when the weather is good and if you lay new asphalt these days it becomes high-quality pavement; after that, the weather during the next $b$ days is bad, and if you lay new asphalt these days it becomes low-quality pavement; again $g$ good days, $b$ bad days and so on.\n\nYou can be sure that you start repairing at the start of a good season, in other words, days $1, 2, \\dots, g$ are good.\n\nYou don't really care about the quality of the highway, you just want to make sure that at least half of the highway will have high-quality pavement. For example, if the $n = 5$ then at least $3$ units of the highway should have high quality; if $n = 4$ then at least $2$ units should have high quality.\n\nWhat is the minimum number of days is needed to finish the repair of the whole highway?", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn calc_min_days(n: u64, g: u64, b: u64) -> (result: u64)\n    requires \n        n > 0,\n        g > 0,\n        b > 0,\n    ensures \n        result >= n,\n        result >= (n + 1) / 2,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // #eval calc_min_days 5 1 1\n    // #eval calc_min_days 8 10 10  \n    // #eval calc_min_days 1000000 1 1000000\n}"}
{"id": "fvapps_000014", "vc-description": "Vasya claims that he had a paper square. He cut it into two rectangular parts using one vertical or horizontal cut. Then Vasya informed you the dimensions of these two rectangular parts. You need to check whether Vasya originally had a square. In other words, check if it is possible to make a square using two given rectangles.\n\n-----Input-----\n\nThe first line contains an integer $t$ ($1 \\le t \\le 10^4$) — the number of test cases in the input. Then $t$ test cases follow.\n\nEach test case is given in two lines.\n\nThe first line contains two integers $a_1$ and $b_1$ ($1 \\le a_1, b_1 \\le 100$) — the dimensions of the first one obtained after cutting rectangle. The sizes are given in random order (that is, it is not known which of the numbers is the width, and which of the numbers is the length).\n\nThe second line contains two integers $a_2$ and $b_2$ ($1 \\le a_2, b_2 \\le 100$) — the dimensions of the second obtained after cutting rectangle. The sizes are given in random order (that is, it is not known which of the numbers is the width, and which of the numbers is the length).\n\n-----Output-----\n\nPrint $t$ answers, each of which is a string \"YES\" (in the case of a positive answer) or \"NO\" (in the case of a negative answer). The letters in words can be printed in any case (upper or lower).\n\n-----Example-----\nInput\n3\n2 3\n3 1\n3 2\n1 3\n3 3\n1 3\n\nOutput\nYes\nYes\nNo", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn can_make_square_spec(a1: u32, b1: u32, a2: u32, b2: u32) -> bool {\n    /* Two rectangles can form a square if they can be arranged to create a square\n       Either horizontally adjacent or vertically adjacent */\n    (a1 == a2 && b1 + b2 == a1) || \n    (a1 == b2 && b1 + a2 == a1) ||\n    (b1 == a2 && a1 + b2 == b1) ||\n    (b1 == b2 && a1 + a2 == b1)\n}\n\nfn can_make_square(a1: u32, b1: u32, a2: u32, b2: u32) -> (result: bool)\n    requires a1 > 0 && b1 > 0 && a2 > 0 && b2 > 0,\n    ensures result == can_make_square_spec(a1, b1, a2, b2),", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "proof fn can_make_square_symmetric_first_rect(a1: u32, b1: u32, a2: u32, b2: u32)\n    requires a1 > 0 && b1 > 0 && a2 > 0 && b2 > 0,\n    ensures can_make_square_spec(a1, b1, a2, b2) == can_make_square_spec(b1, a1, a2, b2),\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn can_make_square_symmetric_second_rect(a1: u32, b1: u32, a2: u32, b2: u32)\n    requires a1 > 0 && b1 > 0 && a2 > 0 && b2 > 0,\n    ensures can_make_square_spec(a1, b1, a2, b2) == can_make_square_spec(a1, b1, b2, a2),\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn can_make_square_symmetric_swap_rects(a1: u32, b1: u32, a2: u32, b2: u32)\n    requires a1 > 0 && b1 > 0 && a2 > 0 && b2 > 0,\n    ensures can_make_square_spec(a1, b1, a2, b2) == can_make_square_spec(a2, b2, a1, b1),\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn can_make_square_identical_rects_false(n: u32)\n    requires n > 0,\n    ensures can_make_square_spec(n, n, n, n) == false,\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn can_make_square_known_case1()\n    ensures can_make_square_spec(2, 3, 3, 1) == true,\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn can_make_square_known_case2()\n    ensures can_make_square_spec(3, 2, 1, 3) == true,\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn can_make_square_known_case3()\n    ensures can_make_square_spec(3, 3, 1, 3) == false,\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\n}\n\nfn main() {}"}
{"id": "fvapps_000015", "vc-description": "Screen resolution of Polycarp's monitor is a × b pixels. Unfortunately, there is one dead pixel at his screen. It has coordinates (x, y) (0 ≤ x < a, 0 ≤ y < b). You can consider columns of pixels to be numbered from 0 to a-1, and rows — from 0 to b-1.\n\nPolycarp wants to open a rectangular window of maximal size, which doesn't contain the dead pixel. The boundaries of the window should be parallel to the sides of the screen.\n\nPrint the maximal area (in pixels) of a window that doesn't contain the dead pixel inside itself.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn max_window_size(a: usize, b: usize, x: usize, y: usize) -> (result: usize)\n    requires \n        a >= 1,\n        b >= 1,\n        x < a,\n        y < b,\n    ensures\n        result == vstd::math::max(vstd::math::max(x * b, (a - 1 - x) * b), vstd::math::max(y * a, (b - 1 - y) * a)),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // #eval max_window_size 8 8 0 0\n    // #eval max_window_size 1 10 0 3  \n    // #eval max_window_size 17 31 10 4\n}"}
{"id": "fvapps_000017", "vc-description": "You are given an array $a_1, a_2 \\dots a_n$. Calculate the number of tuples $(i, j, k, l)$ such that:   $1 \\le i < j < k < l \\le n$;  $a_i = a_k$ and $a_j = a_l$; \n\n-----Input-----\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 100$) — the number of test cases.\n\nThe first line of each test case contains a single integer $n$ ($4 \\le n \\le 3000$) — the size of the array $a$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le n$) — the array $a$.\n\nIt's guaranteed that the sum of $n$ in one test doesn't exceed $3000$.\n\n-----Output-----\n\nFor each test case, print the number of described tuples.\n\n-----Example-----\nInput\n2\n5\n2 2 2 2 2\n6\n1 3 3 1 2 3\n\nOutput\n5\n2\n\n-----Note-----\n\nIn the first test case, for any four indices $i < j < k < l$ are valid, so the answer is the number of tuples.\n\nIn the second test case, there are $2$ valid tuples:   $(1, 2, 4, 6)$: $a_1 = a_4$ and $a_2 = a_6$;  $(1, 3, 4, 6)$: $a_1 = a_4$ and $a_3 = a_6$.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn count_equal_tuples(n: usize, arr: Vec<i32>) -> (result: usize)\n    requires \n        n >= 4,\n        arr.len() == n,\n        forall|i: int| 0 <= i < arr.len() ==> #[trigger] arr[i] >= 1 && arr[i] <= n,\n    ensures \n        result >= 0,\n        (forall|i: int, j: int| 0 <= i < n && 0 <= j < n && i != j ==> #[trigger] arr[i] != #[trigger] arr[j]) ==> result == 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n/* Apps difficulty: interview */\n/* Assurance level: unguarded */\n\n}\nfn main() {\n    // #eval count_equal_tuples 5 [2, 2, 2, 2, 2]\n    // #eval count_equal_tuples 6 [1, 3, 3, 1, 2, 3]  \n    // #eval count_equal_tuples 4 [1, 1, 1, 1]\n}"}
{"id": "fvapps_000018", "vc-description": "The statement of this problem is the same as the statement of problem C2. The only difference is that, in problem C1, $n$ is always even, and in C2, $n$ is always odd.\n\nYou are given a regular polygon with $2 \\cdot n$ vertices (it's convex and has equal sides and equal angles) and all its sides have length $1$. Let's name it as $2n$-gon.\n\nYour task is to find the square of the minimum size such that you can embed $2n$-gon in the square. Embedding $2n$-gon in the square means that you need to place $2n$-gon in the square in such way that each point which lies inside or on a border of $2n$-gon should also lie inside or on a border of the square.\n\nYou can rotate $2n$-gon and/or the square.\n\n-----Input-----\n\nThe first line contains a single integer $T$ ($1 \\le T \\le 200$) — the number of test cases.\n\nNext $T$ lines contain descriptions of test cases — one per line. Each line contains single even integer $n$ ($2 \\le n \\le 200$). Don't forget you need to embed $2n$-gon, not an $n$-gon.\n\n-----Output-----\n\nPrint $T$ real numbers — one per test case. For each test case, print the minimum length of a side of the square $2n$-gon can be embedded in. Your answer will be considered correct if its absolute or relative error doesn't exceed $10^{-6}$.\n\n-----Example-----\nInput\n3\n2\n4\n200\n\nOutput\n1.000000000\n2.414213562\n127.321336469", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn pi() -> f64 {\n    3.14159265359\n}", "vc-spec": "fn min_square_size(n: nat) -> (result: f64)\n    requires n >= 2", "vc-code": "{\n    // impl-start\n    assume(false);\n    0.0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000020", "vc-description": "Gildong owns a bulgogi restaurant. The restaurant has a lot of customers, so many of them like to make a reservation before visiting it.\n\nGildong tries so hard to satisfy the customers that he even memorized all customers' preferred temperature ranges! Looking through the reservation list, he wants to satisfy all customers by controlling the temperature of the restaurant.\n\nThe restaurant has an air conditioner that has 3 states: off, heating, and cooling. When it's off, the restaurant's temperature remains the same. When it's heating, the temperature increases by 1 in one minute. Lastly, when it's cooling, the temperature decreases by 1 in one minute. Gildong can change the state as many times as he wants, at any integer minutes. The air conditioner is off initially.\n\nEach customer is characterized by three values: t_i — the time (in minutes) when the i-th customer visits the restaurant, l_i — the lower bound of their preferred temperature range, and h_i — the upper bound of their preferred temperature range.\n\nA customer is satisfied if the temperature is within the preferred range at the instant they visit the restaurant. Formally, the i-th customer is satisfied if and only if the temperature is between l_i and h_i (inclusive) in the t_i-th minute.\n\nGiven the initial temperature, the list of reserved customers' visit times and their preferred temperature ranges, you're going to help him find if it's possible to satisfy all customers.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "type CustomerInfo = Seq<(u32, i32, i32)>;\n\nspec fn customer_info_time_monotonic(info: CustomerInfo) -> bool {\n    forall|i: int, j: int| 0 <= i < j < info.len() ==> info[i].0 <= info[j].0\n}\n\nspec fn customer_satisfiable(initial_temp: i32, customer: (u32, i32, i32)) -> bool {\n    let (t, l, h) = customer;\n    let temp_range_low = initial_temp - (t as i32);\n    let temp_range_high = initial_temp + (t as i32);\n    !(h < temp_range_low || temp_range_high < l)\n}\n\nfn check_restaurant_temps(initial_temp: i32, customer_info: Vec<(u32, i32, i32)>) -> (result: bool)\n    requires customer_info_time_monotonic(customer_info@),\n    ensures \n        customer_info@.len() == 0 ==> result == true,\n        customer_info@.len() == 1 ==> \n            (customer_satisfiable(initial_temp, customer_info@[0]) <==> result == true)", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = check_restaurant_temps(0, vec![(5, 1, 2), (7, 3, 5), (10, -1, 0)]);\n    // println!(\"{}\", if result1 { \"YES\" } else { \"NO\" }); // Should be \"YES\"\n    \n    // let result2 = check_restaurant_temps(12, vec![(5, 7, 10), (10, 16, 20)]);\n    // println!(\"{}\", if result2 { \"YES\" } else { \"NO\" }); // Should be \"NO\"\n    \n    // let result3 = check_restaurant_temps(-100, vec![(100, 0, 0), (100, -50, 50), (200, 100, 100)]);\n    // println!(\"{}\", if result3 { \"YES\" } else { \"NO\" }); // Should be \"YES\"\n}"}
{"id": "fvapps_000021", "vc-description": "Among Johnny's numerous hobbies, there are two seemingly harmless ones: applying bitwise operations and sneaking into his dad's office. As it is usually the case with small children, Johnny is unaware that combining these two activities can get him in a lot of trouble.\n\nThere is a set S containing very important numbers on his dad's desk. The minute Johnny heard about it, he decided that it's a good idea to choose a positive integer k and replace each element s of the set S with s ⊕ k (⊕ denotes the exclusive or operation). \n\nHelp him choose such k that Johnny's dad will not see any difference after his son is done playing (i.e. Johnny will get the same set as before playing). It is possible that no such number exists. It is also possible that there are many of them. In such a case, output the smallest one. Note that the order of elements in a set doesn't matter, i.e. set {1, 2, 3} equals to set {2, 1, 3}.\n\nFormally, find the smallest positive integer k such that {s ⊕ k | s ∈ S} = S or report that there is no such number.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn bxor(a: u32, b: u32) -> u32\n{\n    a ^ b\n}\n\nspec fn apply_xor_to_seq(s: Seq<u32>, k: u32) -> Seq<u32>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        seq![]\n    } else {\n        seq![bxor(s[0], k)].add(apply_xor_to_seq(s.skip(1), k))\n    }\n}\n\nspec fn seqs_have_same_elements(s1: Seq<u32>, s2: Seq<u32>) -> bool\n{\n    s1.to_set() == s2.to_set()\n}\n\nfn find_smallest_k(n: usize, s: Vec<u32>) -> (result: i32)\n    requires \n        s.len() == n,\n        n >= 1,\n        forall|i: int, j: int| 0 <= i < s.len() && 0 <= j < s.len() && i != j ==> s[i] != s[j],\n        forall|i: int| 0 <= i < s.len() ==> s[i] < 1024,\n    ensures \n        result == -1 || (result > 0 && result <= 1024),\n        result != -1 ==> seqs_have_same_elements(apply_xor_to_seq(s@, result as u32), s@),\n        result != -1 ==> forall|k: u32| 0 < k < result ==> !seqs_have_same_elements(apply_xor_to_seq(s@, k), s@)", "vc-code": "{\n    // impl-start\n    assume(false);\n    -1\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000023", "vc-description": "The only difference between easy and hard versions is constraints.\n\nNow elections are held in Berland and you want to win them. More precisely, you want everyone to vote for you.\n\nThere are $n$ voters, and two ways to convince each of them to vote for you. The first way to convince the $i$-th voter is to pay him $p_i$ coins. The second way is to make $m_i$ other voters vote for you, and the $i$-th voter will vote for free.\n\nMoreover, the process of such voting takes place in several steps. For example, if there are five voters with $m_1 = 1$, $m_2 = 2$, $m_3 = 2$, $m_4 = 4$, $m_5 = 5$, then you can buy the vote of the fifth voter, and eventually everyone will vote for you. Set of people voting for you will change as follows: ${5} \\rightarrow {1, 5} \\rightarrow {1, 2, 3, 5} \\rightarrow {1, 2, 3, 4, 5}$.\n\nCalculate the minimum number of coins you have to spend so that everyone votes for you.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn sum_prices(voters: Seq<(usize, usize)>) -> nat \n    decreases voters.len()\n{\n    if voters.len() == 0 {\n        0nat\n    } else {\n        voters[0].1 as nat + sum_prices(voters.skip(1))\n    }\n}", "vc-spec": "fn solve_elections(n: usize, voters: Vec<(usize, usize)>) -> (result: usize)\n    requires \n        n > 0,\n        voters.len() == n,\n        forall|i: int| 0 <= i < voters.len() ==> voters[i].0 < n,\n    ensures\n        result >= 0,\n        result <= sum_prices(voters@),\n        (forall|i: int| 0 <= i < voters.len() ==> voters[i].0 == 0) ==> result == 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "}\n\nfn main() {\n    // let test1 = solve_elections(3, vec![(1, 5), (2, 10), (2, 8)]);\n    // println!(\"{}\", test1); // Expected: 8\n\n    // let test2 = solve_elections(7, vec![(0, 1), (3, 1), (1, 1), (6, 1), (1, 1), (4, 1), (4, 1)]);\n    // println!(\"{}\", test2); // Expected: 0\n\n    // let test3 = solve_elections(6, vec![(2, 6), (2, 3), (2, 8), (2, 7), (4, 4), (5, 5)]);\n    // println!(\"{}\", test3); // Expected: 7\n}"}
{"id": "fvapps_000024", "vc-description": "Try guessing the statement from this picture: $3$ \n\nYou are given a non-negative integer $d$. You have to find two non-negative real numbers $a$ and $b$ such that $a + b = d$ and $a \\cdot b = d$.\n\n-----Input-----\n\nThe first line contains $t$ ($1 \\le t \\le 10^3$) — the number of test cases.\n\nEach test case contains one integer $d$ $(0 \\le d \\le 10^3)$.\n\n-----Output-----\n\nFor each test print one line.\n\nIf there is an answer for the $i$-th test, print \"Y\", and then the numbers $a$ and $b$.\n\nIf there is no answer for the $i$-th test, print \"N\".\n\nYour answer will be considered correct if $|(a + b) - a \\cdot b| \\le 10^{-6}$ and $|(a + b) - d| \\le 10^{-6}$.\n\n-----Example-----\nInput\n7\n69\n0\n1\n4\n5\n999\n1000\n\nOutput\nY 67.985071301 1.014928699\nY 0.000000000 0.000000000\nN\nY 2.000000000 2.000000000\nY 3.618033989 1.381966011\nY 997.998996990 1.001003010\nY 998.998997995 1.001002005", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn int_to_float(x: i32) -> f64 {\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n\nfn solve_equation(d: i32) -> (result: (bool, f64, f64))\n    ensures\n        d >= 5 && d <= 1000 ==> result.0 == true,\n        d <= 0 && d >= -1000 ==> result.0 == true,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000025", "vc-description": "We are committed to the well being of all participants. Therefore, instead of the problem, we suggest you enjoy a piece of cake.\n\nUh oh. Somebody cut the cake. We told them to wait for you, but they did it anyway. There is still some left, though, if you hurry back. Of course, before you taste the cake, you thought about how the cake was cut.\n\nIt is known that the cake was originally a regular n-sided polygon, each vertex of which had a unique number from 1 to n. The vertices were numbered in random order.\n\nEach piece of the cake is a triangle. The cake was cut into n - 2 pieces as follows: each time one cut was made with a knife (from one vertex to another) such that exactly one triangular piece was separated from the current cake, and the rest continued to be a convex polygon. In other words, each time three consecutive vertices of the polygon were selected and the corresponding triangle was cut off.\n\nA possible process of cutting the cake is presented in the picture below. [Image] Example of 6-sided cake slicing. \n\nYou are given a set of n-2 triangular pieces in random order. The vertices of each piece are given in random order — clockwise or counterclockwise. Each piece is defined by three numbers — the numbers of the corresponding n-sided cake vertices.\n\nFor example, for the situation in the picture above, you could be given a set of pieces: [3, 6, 5], [5, 2, 4], [5, 4, 6], [6, 3, 1].\n\nYou are interested in two questions.  What was the enumeration of the n-sided cake vertices?  In what order were the pieces cut? \n\nFormally, you have to find two permutations p_1, p_2, ..., p_n (1 ≤ p_i ≤ n) and q_1, q_2, ..., q_{n - 2} (1 ≤ q_i ≤ n - 2) such that if the cake vertices are numbered with the numbers p_1, p_2, ..., p_n in order clockwise or counterclockwise, then when cutting pieces of the cake in the order q_1, q_2, ..., q_{n - 2} always cuts off a triangular piece so that the remaining part forms one convex polygon.\n\nFor example, in the picture above the answer permutations could be: p=[2, 4, 6, 1, 3, 5] (or any of its cyclic shifts, or its reversal and after that any cyclic shift) and q=[2, 4, 1, 3].\n\nWrite a program that, based on the given triangular pieces, finds any suitable permutations p and q.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_triangle(x: nat, y: nat, z: nat) -> bool {\n    x > 0 && y > 0 && z > 0\n}\n\nfn polygon_cut(n: nat, triangles: Vec<(nat, nat, nat)>) -> (result: (Vec<nat>, Vec<nat>))\n    requires \n        n >= 3,\n        triangles.len() == n - 2,\n    ensures\n        result.0.len() == n,\n        result.1.len() == n - 2,\n        forall|i: int| 0 <= i < result.0.len() ==> #[trigger] result.0[i] >= 1 && result.0[i] <= n,\n        forall|i: int| 0 <= i < result.1.len() ==> #[trigger] result.1[i] >= 1 && result.1[i] <= (triangles.len() as int),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "/* Apps difficulty: interview */\n/* Assurance level: unguarded */\n\n}\n\nfn main() {\n    // let n1 = 6;\n    // let vertices1 = vec![1, 6, 4, 2, 5, 3];\n    // let cuts1 = vec![4, 2, 3, 1];\n    \n    // let n2 = 6; \n    // let vertices2 = vec![1, 4, 2, 6, 5, 3];\n    // let cuts2 = vec![3, 4, 2, 1];\n    \n    // println!(\"n1: {}\", n1);\n    // println!(\"vertices1 length: {}\", vertices1.len());\n    // println!(\"cuts1 length: {}\", cuts1.len());\n    \n    // println!(\"n2: {}\", n2);\n    // println!(\"vertices2 length: {}\", vertices2.len()); \n    // println!(\"cuts2 length: {}\", cuts2.len());\n}"}
{"id": "fvapps_000026", "vc-description": "You are given a special jigsaw puzzle consisting of n⋅m identical pieces. Every piece has three tabs and one blank, as pictured below.\n\nThe jigsaw puzzle is considered solved if the following conditions hold: The pieces are arranged into a grid with n rows and m columns. For any two pieces that share an edge in the grid, a tab of one piece fits perfectly into a blank of the other piece.\n\nThrough rotation and translation of the pieces, determine if it is possible to solve the jigsaw puzzle.\n\nInput: The test consists of multiple test cases. The first line contains a single integer t (1≤t≤1000) — the number of test cases. Next t lines contain descriptions of test cases.\n\nEach test case contains two integers n and m (1 ≤ n,m ≤ 10^5).\n\nOutput: For each test case output a single line containing \"YES\" if it is possible to solve the jigsaw puzzle, or \"NO\" otherwise. You can print each letter in any case (upper or lower).\n\nExample:\nInput\n3\n1 3\n100000 100000\n2 2\n\nOutput\nYES\nNO\nYES\n\nNote: For the first test case, this is an example solution. For the second test case, we can show that no solution exists. For the third test case, this is an example solution.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn solve_jigsaw_spec(n: nat, m: nat) -> bool {\n    n == 1 || m == 1 || (n == 2 && m == 2)\n}\n\nfn solve_jigsaw(n: nat, m: nat) -> (result: bool)\n    ensures result == solve_jigsaw_spec(n, m)", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "proof fn solve_jigsaw_symmetry(n: nat, m: nat)\n    ensures solve_jigsaw_spec(n, m) == solve_jigsaw_spec(m, n)\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn solve_jigsaw_one_row(n: nat)\n    ensures solve_jigsaw_spec(1, n) == true\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn solve_jigsaw_2x2()\n    ensures solve_jigsaw_spec(2, 2) == true\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn solve_jigsaw_large_grids(n: nat, m: nat)\n    requires n >= 3 && m >= 3,\n    ensures solve_jigsaw_spec(n, m) == false\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\n}\n\nfn main() {\n    // assert(solve_jigsaw(1, 3) == true);\n    // assert(solve_jigsaw(100000, 100000) == false);\n    // assert(solve_jigsaw(2, 2) == true);\n}"}
{"id": "fvapps_000027", "vc-description": "There are n positive integers a_1, a_2, ..., a_n. For the one move you can choose any even value c and divide by two all elements that equal c.\n\nFor example, if a=[6,8,12,6,3,12] and you choose c=6, and a is transformed into a=[3,8,12,3,3,12] after the move.\n\nYou need to find the minimal number of moves for transforming a to an array of only odd integers (each element shouldn't be divisible by 2).\n\nInput: The first line of the input contains one integer t (1 ≤ t ≤ 10^4) — the number of test cases in the input. Then t test cases follow.\n\nThe first line of a test case contains n (1 ≤ n ≤ 2⋅10^5) — the number of integers in the sequence a. The second line contains positive integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^9).\n\nThe sum of n for all test cases in the input doesn't exceed 2⋅10^5.\n\nOutput: For t test cases print the answers in the order of test cases in the input. The answer for the test case is the minimal number of moves needed to make all numbers in the test case odd (i.e. not divisible by 2).\n\nExample:\nInput\n4\n6\n40 6 40 3 20 1\n1\n1024\n4\n2 4 8 16\n3\n3 1 7\n\nOutput\n4\n10\n4\n0\n\nNote: In the first test case of the example, the optimal sequence of moves can be as follows:\nbefore making moves a=[40, 6, 40, 3, 20, 1]; choose c=6; now a=[40, 3, 40, 3, 20, 1]; choose c=40; now a=[20, 3, 20, 3, 20, 1]; choose c=20; now a=[10, 3, 10, 3, 10, 1]; choose c=10; now a=[5, 3, 5, 3, 5, 1] — all numbers are odd.\n\nThus, all numbers became odd after 4 moves. In 3 or fewer moves, you cannot make them all odd.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn count_trailing_zeros(n: nat) -> nat \n    decreases n\n{\n    if n % 2 == 1 { \n        0 \n    } else if n == 0 {\n        0\n    } else { \n        1 + count_trailing_zeros(n / 2) \n    }\n}\n\nfn min_moves_to_odd(arrays: Vec<Vec<nat>>) -> (result: Vec<nat>)\n    ensures \n        result.len() == arrays.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] >= 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded_and_plausible\n\n    // assert_eq!(min_moves_to_odd(vec![vec![40, 6, 40, 3, 20, 1]]), vec![4]);\n    // assert_eq!(min_moves_to_odd(vec![vec![1024]]), vec![10]);\n    // assert_eq!(min_moves_to_odd(vec![vec![2, 4, 8, 16]]), vec![4]);\n    // assert_eq!(min_moves_to_odd(vec![vec![3, 1, 7]]), vec![0]);\n}"}
{"id": "fvapps_000029", "vc-description": "You are given an array a consisting of n integers numbered from 1 to n.\n\nLet's define the k-amazing number of the array as the minimum number that occurs in all of the subsegments of the array having length k (recall that a subsegment of a of length k is a contiguous part of a containing exactly k elements). If there is no integer occuring in all subsegments of length k for some value of k, then the k-amazing number is -1.\n\nFor each k from 1 to n calculate the k-amazing number of the array a.\n\nInput: The first line contains one integer t (1 ≤ t ≤ 1000) — the number of test cases. Then t test cases follow.\nThe first line of each test case contains one integer n (1 ≤ n ≤ 3 · 10^5) — the number of elements in the array. The second line contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ n) — the elements of the array.\nIt is guaranteed that the sum of n over all test cases does not exceed 3 · 10^5.\n\nOutput: For each test case print n integers, where the i-th integer is equal to the i-amazing number of the array.\n\nExample:\nInput\n3\n5\n1 2 3 4 5\n5\n4 4 4 4 2\n6\n1 3 1 5 3 1\n\nOutput\n-1 -1 3 2 1 \n-1 4 4 4 2 \n-1 -1 1 1 1 1", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn find_amazing_numbers(n: usize, arr: Vec<usize>) -> (result: Vec<i32>)\n    requires\n        n > 0,\n        arr.len() == n,\n        forall|i: int| 0 <= i < arr.len() ==> #[trigger] arr[i] >= 1 && #[trigger] arr[i] <= n,\n    ensures\n        result.len() == n,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000031", "vc-description": "Skier rides on a snowy field. Its movements can be described by a string of characters 'S', 'N', 'W', 'E' (which correspond to $1$ meter movement in the south, north, west or east direction respectively).\n\nIt is known that if he moves along a previously unvisited segment of a path (i.e. this segment of the path is visited the first time), then the time of such movement is $5$ seconds. If he rolls along previously visited segment of a path (i.e., this segment of the path has been covered by his path before), then it takes $1$ second.\n\nFind the skier's time to roll all the path.\n\n-----Input-----\n\nThe first line contains an integer $t$ ($1 \\le t \\le 10^4$) — the number of test cases in the input. Then $t$ test cases follow.\n\nEach set is given by one nonempty string of the characters 'S', 'N', 'W', 'E'. The length of the string does not exceed $10^5$ characters.\n\nThe sum of the lengths of $t$ given lines over all test cases in the input does not exceed $10^5$.\n\n-----Output-----\n\nFor each test case, print the desired path time in seconds.\n\n-----Example-----\nInput\n5\nNNN\nNS\nWWEN\nWWEE\nNWNWS\n\nOutput\n15\n6\n16\n12\n25", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn calculate_ski_time(path: Seq<char>) -> nat\n    decreases path.len()\n{\n    if path.len() == 0 {\n        0\n    } else {\n        5 // Placeholder - actual implementation would track visited segments\n    }\n}\n\nfn calculate_ski_time_exec(path: Seq<char>) -> (result: nat)\n    requires path.len() > 0,\n    ensures \n        result > 0,\n        result >= path.len(),\n        result <= path.len() * 5,\n        result == calculate_ski_time(path),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "/* Time should always be positive */\nproof fn ski_time_positive(path: Seq<char>)\n    requires path.len() > 0,\n    ensures calculate_ski_time(path) > 0,\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\n/* Time is at least path length */  \nproof fn ski_time_lower_bound(path: Seq<char>)\n    requires path.len() > 0,\n    ensures calculate_ski_time(path) >= path.len(),\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\n/* Time is at most path length * 5 */\nproof fn ski_time_upper_bound(path: Seq<char>)\n    requires path.len() > 0,\n    ensures calculate_ski_time(path) <= path.len() * 5,\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\n/* Concatenated paths are bounded by sum of individual path times */\nproof fn ski_time_composition_bound(path1: Seq<char>, path2: Seq<char>)\n    requires path1.len() > 0 && path2.len() > 0,\n    ensures calculate_ski_time(path1.add(path2)) <= calculate_ski_time(path1) + calculate_ski_time(path2),\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\n/* Edge cases */\nproof fn north_direction_time()\n    ensures calculate_ski_time(seq!['N']) == 5,\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn north_south_time()\n    ensures calculate_ski_time(seq!['N', 'S']) == 6,\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\n/* Apps difficulty: interview */\n/* Assurance level: guarded_and_plausible */\n\n}\n\nfn main() {\n    // println!(\"{}\", calculate_ski_time_exec(seq!['N', 'N', 'N']));  // Should output: 15\n    // println!(\"{}\", calculate_ski_time_exec(seq!['N', 'S']));   // Should output: 6\n    // println!(\"{}\", calculate_ski_time_exec(seq!['N', 'W', 'N', 'W', 'S'])); // Should output: 25\n}"}
{"id": "fvapps_000032", "vc-description": "Lately, Mr. Chanek frequently plays the game Arena of Greed. As the name implies, the game's goal is to find the greediest of them all, who will then be crowned king of Compfestnesia.\n\nThe game is played by two people taking turns, where Mr. Chanek takes the first turn. Initially, there is a treasure chest containing N gold coins. The game ends if there are no more gold coins in the chest. In each turn, the players can make one of the following moves: Take one gold coin from the chest. Take half of the gold coins on the chest. This move is only available if the number of coins in the chest is even.\n\nBoth players will try to maximize the number of coins they have. Mr. Chanek asks your help to find the maximum number of coins he can get at the end of the game if both he and the opponent plays optimally.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_arena_of_greed(n: u64) -> (result: u64)\n    requires n > 0,\n    ensures \n        result <= n,\n        result >= 0,\n        result <= (n + 1) / 2 + n / 2,\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n\nfn is_pow2(n: u64) -> (result: bool)\n    requires n > 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = solve_arena_of_greed(5);\n    // println!(\"{}\", result1); // Expected: 2\n    \n    // let result2 = solve_arena_of_greed(6);\n    // println!(\"{}\", result2); // Expected: 4\n    \n    // let result3 = solve_arena_of_greed(8);\n    // println!(\"{}\", result3); // Expected: 5\n}"}
{"id": "fvapps_000033", "vc-description": "Numbers 1, 2, 3, ..., n (each integer from 1 to n once) are written on a board. In one operation you can erase any two numbers a and b from the board and write one integer (a + b)/2 rounded up instead.\n\nYou should perform the given operation n - 1 times and make the resulting number that will be left on the board as small as possible. \n\nFor example, if n = 4, the following course of action is optimal: choose a = 4 and b = 2, so the new number is 3, and the whiteboard contains [1, 3, 3]; choose a = 3 and b = 3, so the new number is 3, and the whiteboard contains [1, 3]; choose a = 1 and b = 3, so the new number is 2, and the whiteboard contains [2]. \n\nIt's easy to see that after n - 1 operations, there will be left only one number. Your goal is to minimize it.\n\nInput: The first line contains one integer t (1 ≤ t ≤ 1000) — the number of test cases. The only line of each test case contains one integer n (2 ≤ n ≤ 2 × 10^5) — the number of integers written on the board initially. It's guaranteed that the total sum of n over test cases doesn't exceed 2 × 10^5.\n\nOutput: For each test case, in the first line, print the minimum possible number left on the board after n - 1 operations. Each of the next n - 1 lines should contain two integers — numbers a and b chosen and erased in each operation.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn minimize_board_operations(n: u32) -> (result: (u32, Vec<(u32, u32)>))\n    requires 2 <= n && n <= 1000,\n    ensures result.0 == 2,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000034", "vc-description": "You have a large electronic screen which can display up to 998244353 decimal digits. The digits are displayed in the same way as on different electronic alarm clocks: each place for a digit consists of 7 segments which can be turned on and off to compose different digits. The following picture describes how you can display all 10 decimal digits:\n\n[Image]\n\nAs you can see, different digits may require different number of segments to be turned on. For example, if you want to display 1, you have to turn on 2 segments of the screen, and if you want to display 8, all 7 segments of some place to display a digit should be turned on.\n\nYou want to display a really large integer on the screen. Unfortunately, the screen is bugged: no more than n segments can be turned on simultaneously. So now you wonder what is the greatest integer that can be displayed by turning on no more than n segments.\n\nYour program should be able to process t different test cases.\n\nInput:\nThe first line contains one integer t (1 ≤ t ≤ 100) — the number of test cases in the input.\n\nThen the test cases follow, each of them is represented by a separate line containing one integer n (2 ≤ n ≤ 10^5) — the maximum number of segments that can be turned on in the corresponding testcase.\n\nIt is guaranteed that the sum of n over all test cases in the input does not exceed 10^5.\n\nOutput:\nFor each test case, print the greatest integer that can be displayed by turning on no more than n segments of the screen. Note that the answer may not fit in the standard 32-bit or 64-bit integral data type.\n\nExample:\nInput\n2\n3\n4\n\nOutput\n7\n11", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn digit_segments(digit: u8) -> nat {\n    match digit {\n        0 => 6,\n        1 => 2,\n        2 => 5,\n        3 => 5,\n        4 => 4,\n        5 => 5,\n        6 => 6,\n        7 => 3,\n        8 => 7,\n        9 => 6,\n        _ => 0,\n    }\n}\n\nspec fn digit_char_to_digit(c: char) -> u8 {\n    match c {\n        '0' => 0,\n        '1' => 1,\n        '2' => 2,\n        '3' => 3,\n        '4' => 4,\n        '5' => 5,\n        '6' => 6,\n        '7' => 7,\n        '8' => 8,\n        '9' => 9,\n        _ => 0,\n    }\n}\n\nspec fn nat_to_string(n: nat) -> Seq<char>;\n\nspec fn is_valid_digit_char(c: char) -> bool {\n    c == '0' || c == '1' || c == '2' || c == '3' || c == '4' || \n    c == '5' || c == '6' || c == '7' || c == '8' || c == '9'\n}\n\nfn find_max_display(n: nat) -> (result: nat)\n    requires n >= 2,\n    ensures \n        result > 0,\n        forall|c: char| nat_to_string(result).contains(c) ==> (c == '1' || c == '7'),\n        n % 2 == 1 ==> nat_to_string(result)[0] == '7',\n        n % 2 == 0 && n >= 4 ==> forall|c: char| nat_to_string(result).contains(c) ==> c == '1'", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Example usage:\n    // println!(\"{}\", find_max_display(3)); // Should output 7\n    // println!(\"{}\", find_max_display(4)); // Should output 11\n    // println!(\"{}\", find_max_display(5)); // Should output 71\n}"}
{"id": "fvapps_000035", "vc-description": "Young wilderness explorers set off to their first expedition led by senior explorer Russell. Explorers went into a forest, set up a camp and decided to split into groups to explore as much interesting locations as possible. Russell was trying to form groups, but ran into some difficulties...\n\nMost of the young explorers are inexperienced, and sending them alone would be a mistake. Even Russell himself became senior explorer not long ago. Each of young explorers has a positive integer parameter $e_i$ — his inexperience. Russell decided that an explorer with inexperience $e$ can only join the group of $e$ or more people.\n\nNow Russell needs to figure out how many groups he can organize. It's not necessary to include every explorer in one of the groups: some can stay in the camp. Russell is worried about this expedition, so he asked you to help him.\n\n-----Input-----\n\nThe first line contains the number of independent test cases $T$($1 \\leq T \\leq 2 \\cdot 10^5$). Next $2T$ lines contain description of test cases.\n\nThe first line of description of each test case contains the number of young explorers $N$ ($1 \\leq N \\leq 2 \\cdot 10^5$).\n\nThe second line contains $N$ integers $e_1, e_2, \\ldots, e_N$ ($1 \\leq e_i \\leq N$), where $e_i$ is the inexperience of the $i$-th explorer.\n\nIt's guaranteed that sum of all $N$ doesn't exceed $3 \\cdot 10^5$.\n\n-----Output-----\n\nPrint $T$ numbers, each number on a separate line.\n\nIn $i$-th line print the maximum number of groups Russell can form in $i$-th test case.\n\n-----Example-----\nInput\n2\n3\n1 1 1\n5\n2 3 1 2 2\n\nOutput\n3\n2\n\n-----Note-----\n\nIn the first example we can organize three groups. There will be only one explorer in each group. It's correct because inexperience of each explorer equals to $1$, so it's not less than the size of his group.\n\nIn the second example we can organize two groups. Explorers with inexperience $1$, $2$ and $3$ will form the first group, and the other two explorers with inexperience equal to $2$ will form the second group.\n\nThis solution is not unique. For example, we can form the first group using the three explorers with inexperience equal to $2$, and the second group using only one explorer with inexperience equal to $1$. In this case the young explorer with inexperience equal to $3$ will not be included in any group.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn solve_explorer_groups_spec(n: usize, explorers: Seq<usize>) -> usize\n{\n    0  /* placeholder spec implementation */\n}\n\nfn solve_explorer_groups(n: usize, explorers: Vec<usize>) -> (result: usize)\n    requires \n        n == explorers.len(),\n        n > 0,\n        forall|i: int| 0 <= i < explorers.len() ==> #[trigger] explorers[i] >= 1 && explorers[i] <= n,\n    ensures\n        result <= n,\n        result == solve_explorer_groups_spec(n, explorers@),", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\nproof fn solve_explorer_groups_all_ones(n: usize, explorers: Vec<usize>)\n    requires \n        n > 0 && n <= 5,\n        n == explorers.len(),\n        forall|i: int| 0 <= i < explorers.len() ==> #[trigger] explorers[i] == 1,\n    ensures solve_explorer_groups_spec(n, explorers@) == n\n{\n    assume(false); /* TODO: Remove this line and implement the proof */\n}\n\n}\n\nfn main() {\n    // let result1 = solve_explorer_groups(3, vec![1, 1, 1]);\n    // println!(\"{}\", result1);  // Expected: 3\n    \n    // let result2 = solve_explorer_groups(5, vec![2, 3, 1, 2, 2]);\n    // println!(\"{}\", result2);  // Expected: 2\n    \n    // let result3 = solve_explorer_groups(4, vec![1, 2, 3, 4]);\n    // println!(\"{}\", result3);  // Expected: 1\n}"}
{"id": "fvapps_000037", "vc-description": "Yeah, we failed to make up a New Year legend for this problem.\n\nA permutation of length $n$ is an array of $n$ integers such that every integer from $1$ to $n$ appears in it exactly once. \n\nAn element $y$ of permutation $p$ is reachable from element $x$ if $x = y$, or $p_x = y$, or $p_{p_x} = y$, and so on. \n\nThe decomposition of a permutation $p$ is defined as follows: firstly, we have a permutation $p$, all elements of which are not marked, and an empty list $l$. Then we do the following: while there is at least one not marked element in $p$, we find the leftmost such element, list all elements that are reachable from it in the order they appear in $p$, mark all of these elements, then cyclically shift the list of those elements so that the maximum appears at the first position, and add this list as an element of $l$. After all elements are marked, $l$ is the result of this decomposition.\n\nFor example, if we want to build a decomposition of $p = [5, 4, 2, 3, 1, 7, 8, 6]$, we do the following:  initially $p = [5, 4, 2, 3, 1, 7, 8, 6]$ (bold elements are marked), $l = []$;  the leftmost unmarked element is $5$; $5$ and $1$ are reachable from it, so the list we want to shift is $[5, 1]$; there is no need to shift it, since maximum is already the first element;  $p = [\\textbf{5}, 4, 2, 3, \\textbf{1}, 7, 8, 6]$, $l = [[5, 1]]$;  the leftmost unmarked element is $4$, the list of reachable elements is $[4, 2, 3]$; the maximum is already the first element, so there's no need to shift it;  $p = [\\textbf{5}, \\textbf{4}, \\textbf{2}, \\textbf{3}, \\textbf{1}, 7, 8, 6]$, $l = [[5, 1], [4, 2, 3]]$;  the leftmost unmarked element is $7$, the list of reachable elements is $[7, 8, 6]$; we have to shift it, so it becomes $[8, 6, 7]$;  $p = [\\textbf{5}, \\textbf{4}, \\textbf{2}, \\textbf{3}, \\textbf{1}, \\textbf{7}, \\textbf{8}, \\textbf{6}]$, $l = [[5, 1], [4, 2, 3], [8, 6, 7]]$;  all elements are marked, so $[[5, 1], [4, 2, 3], [8, 6, 7]]$ is the result. \n\nThe New Year transformation of a permutation is defined as follows: we build the decomposition of this permutation; then we sort all lists in decomposition in ascending order of the first elements (we don't swap the elements in these lists, only the lists themselves); then we concatenate the lists into one list which becomes a new permutation. For example, the New Year transformation of $p = [5, 4, 2, 3, 1, 7, 8, 6]$ is built as follows:  the decomposition is $[[5, 1], [4, 2, 3], [8, 6, 7]]$;  after sorting the decomposition, it becomes $[[4, 2, 3], [5, 1], [8, 6, 7]]$;  $[4, 2, 3, 5, 1, 8, 6, 7]$ is the result of the transformation. \n\nWe call a permutation good if the result of its transformation is the same as the permutation itself. For example, $[4, 3, 1, 2, 8, 5, 6, 7]$ is a good permutation; and $[5, 4, 2, 3, 1, 7, 8, 6]$ is bad, since the result of transformation is $[4, 2, 3, 5, 1, 8, 6, 7]$.\n\nYour task is the following: given $n$ and $k$, find the $k$-th (lexicographically) good permutation of length $n$.\n\n-----Input-----\n\nThe first line contains one integer $t$ ($1 \\le t \\le 1000$) — the number of test cases.\n\nThen the test cases follow. Each test case is represented by one line containing two integers $n$ and $k$ ($1 \\le n \\le 50$, $1 \\le k \\le 10^{18}$).\n\n-----Output-----\n\nFor each test case, print the answer to it as follows: if the number of good permutations of length $n$ is less than $k$, print one integer $-1$; otherwise, print the $k$-th good permutation on $n$ elements (in lexicographical order).\n\n-----Example-----\nInput\n5\n3 3\n5 15\n4 13\n6 8\n4 2\n\nOutput\n2 1 3 \n3 1 2 5 4 \n-1\n1 2 6 3 4 5 \n1 2 4 3", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn fact(n: nat) -> nat\n    decreases n\n{\n    if n == 0 {\n        1\n    } else {\n        n * fact((n - 1) as nat)\n    }\n}", "vc-spec": "fn solve_good_permutations(n: usize, k: u64) -> (result: Vec<usize>)\n    requires n <= 50, k >= 1,\n    ensures\n        (n == 0 && k == 1 ==> result.len() == 0) &&\n        (n > 0 && result.len() > 1 ==> \n            result.len() == n &&\n            forall|i: int, j: int| 0 <= i < j < result.len() ==> #[trigger] result[i] != #[trigger] result[j] &&\n            forall|i: int| 0 <= i < result.len() ==> 1 <= #[trigger] result[i] <= n) &&\n        (n > 0 && k > fact((n - 1) as nat) * (n as nat) ==> result.len() == 1 && result[0] == 0)\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n\nfn factorial(n: usize) -> (result: u64)\n    ensures result == fact(n as nat)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: unguarded\n}"}
{"id": "fvapps_000039", "vc-description": "After a long party Petya decided to return home, but he turned out to be at the opposite end of the town from his home. There are n crossroads in the line in the town, and there is either the bus or the tram station at each crossroad.\n\nThe crossroads are represented as a string s of length n, where s_i = A, if there is a bus station at i-th crossroad, and s_i = B, if there is a tram station at i-th crossroad. Currently Petya is at the first crossroad (which corresponds to s_1) and his goal is to get to the last crossroad (which corresponds to s_n).\n\nIf for two crossroads i and j for all crossroads i, i+1, ..., j-1 there is a bus station, one can pay a roubles for the bus ticket, and go from i-th crossroad to the j-th crossroad by the bus (it is not necessary to have a bus station at the j-th crossroad). Formally, paying a roubles Petya can go from i to j if s_t = A for all i ≤ t < j.\n\nIf for two crossroads i and j for all crossroads i, i+1, ..., j-1 there is a tram station, one can pay b roubles for the tram ticket, and go from i-th crossroad to the j-th crossroad by the tram (it is not necessary to have a tram station at the j-th crossroad). Formally, paying b roubles Petya can go from i to j if s_t = B for all i ≤ t < j.\n\nNow Petya is at the first crossroad, and he wants to get to the n-th crossroad. After the party he has left with p roubles. He's decided to go to some station on foot, and then go to home using only public transport.\n\nHelp him to choose the closest crossroad i to go on foot the first, so he has enough money to get from the i-th crossroad to the n-th, using only tram and bus tickets.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn find_min_start_point(cost1: u32, cost2: u32, cost3: u32, str: Vec<char>) -> (result: u32)\n    requires \n        cost1 > 0,\n        cost2 > 0,\n        cost3 > 0,\n        str.len() >= 1,\n    ensures \n        result >= 1,\n        result <= str.len() as u32,", "vc-code": "{\n    // impl-start\n    assume(false);\n    1\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let str1: Vec<char> = \"BB\".chars().collect();\n    // let result1 = find_min_start_point(2, 2, 1, str1);\n    // println!(\"{}\", result1);\n    \n    // let str2: Vec<char> = \"AB\".chars().collect();\n    // let result2 = find_min_start_point(1, 1, 1, str2);\n    // println!(\"{}\", result2);\n    \n    // let str3: Vec<char> = \"AABBBBAABB\".chars().collect();\n    // let result3 = find_min_start_point(3, 2, 8, str3);\n    // println!(\"{}\", result3);\n}"}
{"id": "fvapps_000040", "vc-description": "You are given a sequence $a_1, a_2, \\dots, a_n$, consisting of integers.\n\nYou can apply the following operation to this sequence: choose some integer $x$ and move all elements equal to $x$ either to the beginning, or to the end of $a$. Note that you have to move all these elements in one direction in one operation.\n\nFor example, if $a = [2, 1, 3, 1, 1, 3, 2]$, you can get the following sequences in one operation (for convenience, denote elements equal to $x$ as $x$-elements):   $[1, 1, 1, 2, 3, 3, 2]$ if you move all $1$-elements to the beginning;  $[2, 3, 3, 2, 1, 1, 1]$ if you move all $1$-elements to the end;  $[2, 2, 1, 3, 1, 1, 3]$ if you move all $2$-elements to the beginning;  $[1, 3, 1, 1, 3, 2, 2]$ if you move all $2$-elements to the end;  $[3, 3, 2, 1, 1, 1, 2]$ if you move all $3$-elements to the beginning;  $[2, 1, 1, 1, 2, 3, 3]$ if you move all $3$-elements to the end; \n\nYou have to determine the minimum number of such operations so that the sequence $a$ becomes sorted in non-descending order. Non-descending order means that for all $i$ from $2$ to $n$, the condition $a_{i-1} \\le a_i$ is satisfied.\n\nNote that you have to answer $q$ independent queries.\n\n-----Input-----\n\nThe first line contains one integer $q$ ($1 \\le q \\le 3 \\cdot 10^5$) — the number of the queries. Each query is represented by two consecutive lines.\n\nThe first line of each query contains one integer $n$ ($1 \\le n \\le 3 \\cdot 10^5$) — the number of elements.\n\nThe second line of each query contains $n$ integers $a_1, a_2, \\dots , a_n$ ($1 \\le a_i \\le n$) — the elements.\n\nIt is guaranteed that the sum of all $n$ does not exceed $3 \\cdot 10^5$.\n\n-----Output-----\n\nFor each query print one integer — the minimum number of operation for sorting sequence $a$ in non-descending order.\n\n-----Example-----\nInput\n3\n7\n3 1 6 6 3 1 1\n8\n1 1 4 4 4 7 8 8\n7\n4 2 5 2 6 2 7\n\nOutput\n2\n0\n1\n\n-----Note-----\n\nIn the first query, you can move all $1$-elements to the beginning (after that sequence turn into $[1, 1, 1, 3, 6, 6, 3]$) and then move all $6$-elements to the end.\n\nIn the second query, the sequence is sorted initially, so the answer is zero.\n\nIn the third query, you have to move all $2$-elements to the beginning.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn count_distinct_elements(arr: Seq<nat>) -> nat\n    decreases arr.len()\n{\n    if arr.len() == 0 {\n        0\n    } else {\n        let distinct_in_rest = count_distinct_elements(arr.skip(1));\n        if arr.skip(1).contains(arr[0]) {\n            distinct_in_rest\n        } else {\n            distinct_in_rest + 1\n        }\n    }\n}\n\nfn min_ops_to_sort(arr: Vec<nat>) -> (result: nat)\n    ensures \n        result >= 0,\n        result <= count_distinct_elements(arr@),\n        arr.len() == 1 ==> result == 0,\n        count_distinct_elements(arr@) == 1 ==> result == 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let test1 = vec![3, 1, 6, 6, 3, 1, 1];\n    // let result1 = min_ops_to_sort(test1);\n    // println!(\"Result 1: {}\", result1); // Expected: 2\n\n    // let test2 = vec![1, 1, 4, 4, 4, 7, 8, 8];\n    // let result2 = min_ops_to_sort(test2);\n    // println!(\"Result 2: {}\", result2); // Expected: 0\n\n    // let test3 = vec![4, 2, 5, 2, 6, 2, 7];\n    // let result3 = min_ops_to_sort(test3);\n    // println!(\"Result 3: {}\", result3); // Expected: 1\n}"}
{"id": "fvapps_000041", "vc-description": "You are fed up with your messy room, so you decided to clean it up.\n\nYour room is a bracket sequence s=s₁s₂...sₙ of length n. Each character of this string is either an opening bracket '(' or a closing bracket ')'.\n\nIn one operation you can choose any consecutive substring of s and reverse it. In other words, you can choose any substring s[l...r]=sₗ, sₗ₊₁, ..., sᵣ and change the order of elements in it into sᵣ, sᵣ₋₁, ..., sₗ.\n\nFor example, if you will decide to reverse substring s[2...4] of string s=\"((()))\" it will be equal to s=\"()(())\".\n\nA regular (aka balanced) bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters '1' and '+' between the original characters of the sequence. For example, bracket sequences \"()()\", \"(())\" are regular (the resulting expressions are: \"(1)+(1)\", \"((1+1)+1)\"), and \")(\" and \"(\" are not.\n\nA prefix of a string s is a substring that starts at position 1. For example, for s=\"(())()\" there are 6 prefixes: \"(\", \"((\", \"(()\", \"(())\", \"(())(\" and \"(())()\".\n\nIn your opinion, a neat and clean room s is a bracket sequence that:\n  the whole string s is a regular bracket sequence; and there are exactly k prefixes of this sequence which are regular (including whole s itself).\n\nFor example, if k = 2, then \"(())()\" is a neat and clean room.\n\nYou want to use at most n operations to make your room neat and clean. Operations are applied one after another sequentially.\n\nIt is guaranteed that the answer exists. Note that you do not need to minimize the number of operations: find any way to achieve the desired configuration in n or less operations.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_bracket_sequence(n: usize, k: usize, s: Vec<char>) -> (result: Vec<Vec<usize>>)\n    requires \n        n >= 2,\n        n % 2 == 0,\n        k >= 1,\n        k <= n / 2,\n        s.len() == n,\n        forall|i: int| 0 <= i < s.len() ==> (s[i] == '(' || s[i] == ')'),\n    ensures\n        result.len() <= n,\n        forall|i: int| 0 <= i < result.len() ==> (\n            result[i].len() == 2 &&\n            result[i][0] >= 1 &&\n            result[i][1] <= n &&\n            result[i][0] <= result[i][1]\n        ),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000042", "vc-description": "You are given a binary string $s$ (recall that a string is binary if each character is either $0$ or $1$).\n\nLet $f(t)$ be the decimal representation of integer $t$ written in binary form (possibly with leading zeroes). For example $f(011) = 3, f(00101) = 5, f(00001) = 1, f(10) = 2, f(000) = 0$ and $f(000100) = 4$.\n\nThe substring $s_{l}, s_{l+1}, \\dots , s_{r}$ is good if $r - l + 1 = f(s_l \\dots s_r)$.\n\nFor example string $s = 1011$ has $5$ good substrings: $s_1 \\dots s_1 = 1$, $s_3 \\dots s_3 = 1$, $s_4 \\dots s_4 = 1$, $s_1 \\dots s_2 = 10$ and $s_2 \\dots s_4 = 011$. \n\nYour task is to calculate the number of good substrings of string $s$.\n\nYou have to answer $t$ independent queries.\n\n-----Input-----\n\nThe first line contains one integer $t$ ($1 \\le t \\le 1000$) — the number of queries.\n\nThe only line of each query contains string $s$ ($1 \\le |s| \\le 2 \\cdot 10^5$), consisting of only digits $0$ and $1$.\n\nIt is guaranteed that $\\sum\\limits_{i=1}^{t} |s_i| \\le 2 \\cdot 10^5$.\n\n-----Output-----\n\nFor each query print one integer — the number of good substrings of string $s$.\n\n-----Example-----\nInput\n4\n0110\n0101\n00001000\n0001000\n\nOutput\n4\n3\n4\n3", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_binary_string(s: Seq<u8>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == 48u8 || s[i] == 49u8)\n}\n\nspec fn count_ones(s: Seq<u8>) -> nat {\n    s.filter(|c: u8| c == 49u8).len() as nat\n}\n\nspec fn has_one(s: Seq<u8>) -> bool {\n    exists|i: int| 0 <= i < s.len() && s[i] == 49u8\n}\n\nfn solve_binary_substrings(s: Vec<u8>) -> (result: usize)\n    requires is_binary_string(s@),\n    ensures \n        result >= 0,\n        has_one(s@) ==> result >= count_ones(s@),", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let test_cases = vec![vec![48, 49, 49, 48], vec![48, 49, 48, 49], vec![48, 48, 48, 48, 49, 48, 48, 48], vec![48, 48, 48, 49, 48, 48, 48]];\n    // for s in test_cases {\n    //     println!(\"{}\", solve_binary_substrings(s));\n    // }\n}"}
{"id": "fvapps_000044", "vc-description": "Today the kindergarten has a new group of n kids who need to be seated at the dinner table. The chairs at the table are numbered from 1 to 4n. Two kids can't sit on the same chair. It is known that two kids who sit on chairs with numbers a and b (a ≠ b) will indulge if: gcd(a, b) = 1 or, a divides b or b divides a. \n\ngcd(a, b) — the maximum number x such that a is divisible by x and b is divisible by x.\n\nFor example, if n=3 and the kids sit on chairs with numbers 2, 3, 4, then they will indulge since 4 is divided by 2 and gcd(2, 3) = 1. If kids sit on chairs with numbers 4, 6, 10, then they will not indulge.\n\nThe teacher really doesn't want the mess at the table, so she wants to seat the kids so there are no 2 of the kid that can indulge. More formally, she wants no pair of chairs a and b that the kids occupy to fulfill the condition above.\n\nSince the teacher is very busy with the entertainment of the kids, she asked you to solve this problem.\n\n-----Input-----\n\nThe first line contains one integer t (1 ≤ t ≤ 100) — the number of test cases. Then t test cases follow.\n\nEach test case consists of one line containing an integer n (1 ≤ n ≤ 100) — the number of kids.\n\n-----Output-----\n\nOutput t lines, which contain n distinct integers from 1 to 4n — the numbers of chairs that the kids should occupy in the corresponding test case. If there are multiple answers, print any of them. You can print n numbers in any order.\n\n-----Example-----\nInput\n3\n2\n3\n4\n\nOutput\n6 4\n4 6 10\n14 10 12 8", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn gcd(a: nat, b: nat) -> nat;\n\nspec fn will_indulge(a: nat, b: nat) -> bool {\n    a != b && (gcd(a, b) == 1 || a % b == 0 || b % a == 0)\n}\n\nfn solve_seats(n: nat) -> (result: Vec<nat>)\n    requires n > 0 && n <= 100,\n    ensures\n        result.len() == n,\n        forall|x: nat| #[trigger] result@.contains(x) ==> x > 0 && x % 2 == 0,\n        forall|i: int, j: int| 0 <= i < j < result.len() ==> result[i] >= result[j],\n        forall|i: int, j: int| 0 <= i < j < result.len() ==> !will_indulge(result[i], result[j]),\n        forall|x: nat| #[trigger] result@.contains(x) ==> x > 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: unguarded\n\n    // #eval sorted solve_seats(2)\n    // #eval sorted solve_seats(3)  \n    // #eval sorted solve_seats(4)\n}"}
{"id": "fvapps_000045", "vc-description": "Jett is tired after destroying the town and she wants to have a rest. She likes high places, that's why for having a rest she wants to get high and she decided to craft staircases.\n\nA staircase is a squared figure that consists of square cells. Each staircase consists of an arbitrary number of stairs. If a staircase has $n$ stairs, then it is made of $n$ columns, the first column is $1$ cell high, the second column is $2$ cells high, $\\ldots$, the $n$-th column if $n$ cells high. The lowest cells of all stairs must be in the same row.\n\nA staircase with $n$ stairs is called nice, if it may be covered by $n$ disjoint squares made of cells. All squares should fully consist of cells of a staircase. This is how a nice covered staircase with $7$ stairs looks like: [Image] \n\nFind out the maximal number of different nice staircases, that can be built, using no more than $x$ cells, in total. No cell can be used more than once.\n\n-----Input-----\n\nThe first line contains a single integer $t$ $(1 \\le t \\le 1000)$  — the number of test cases.\n\nThe description of each test case contains a single integer $x$ $(1 \\le x \\le 10^{18})$  — the number of cells for building staircases.\n\n-----Output-----\n\nFor each test case output a single integer  — the number of different nice staircases, that can be built, using not more than $x$ cells, in total.\n\n-----Example-----\nInput\n4\n1\n8\n6\n1000000000000000000\n\nOutput\n1\n2\n1\n30\n\n-----Note-----\n\nIn the first test case, it is possible to build only one staircase, that consists of $1$ stair. It's nice. That's why the answer is $1$.\n\nIn the second test case, it is possible to build two different nice staircases: one consists of $1$ stair, and another consists of $3$ stairs. This will cost $7$ cells. In this case, there is one cell left, but it is not possible to use it for building any nice staircases, that have not been built yet. That's why the answer is $2$.\n\nIn the third test case, it is possible to build only one of two nice staircases: with $1$ stair or with $3$ stairs. In the first case, there will be $5$ cells left, that may be used only to build a staircase with $2$ stairs. This staircase is not nice, and Jett only builds nice staircases. That's why in this case the answer is $1$. If Jett builds a staircase with $3$ stairs, then there are no more cells left, so the answer is $1$ again.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn count_nice_staircases_spec(n: nat) -> nat\n    decreases n\n{\n    if n == 0 {\n        0\n    } else {\n        1\n    }\n}\n\nfn count_nice_staircases(n: nat) -> (result: nat)\n    ensures \n        n > 0 ==> result > 0,\n        result <= n,\n        result == count_nice_staircases_spec(n)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded_and_plausible\n\n    // #guard_msgs in\n    // #eval count_nice_staircases 1\n\n    // #guard_msgs in  \n    // #eval count_nice_staircases 8\n\n    // #guard_msgs in\n    // #eval count_nice_staircases 6\n\n    // #guard_msgs in\n    // #eval count_nice_staircases 1000000000000000000\n}"}
{"id": "fvapps_000047", "vc-description": "This is the easy version of the problem. The difference between the versions is that the easy version has no swap operations. You can make hacks only if all versions of the problem are solved.\n\nPikachu is a cute and friendly pokémon living in the wild pikachu herd.\n\nBut it has become known recently that infamous team R wanted to steal all these pokémon! Pokémon trainer Andrew decided to help Pikachu to build a pokémon army to resist.\n\nFirst, Andrew counted all the pokémon — there were exactly $n$ pikachu. The strength of the $i$-th pokémon is equal to $a_i$, and all these numbers are distinct.\n\nAs an army, Andrew can choose any non-empty subsequence of pokemons. In other words, Andrew chooses some array $b$ from $k$ indices such that $1 \\le b_1 < b_2 < \\dots < b_k \\le n$, and his army will consist of pokémons with forces $a_{b_1}, a_{b_2}, \\dots, a_{b_k}$.\n\nThe strength of the army is equal to the alternating sum of elements of the subsequence; that is, $a_{b_1} - a_{b_2} + a_{b_3} - a_{b_4} + \\dots$.\n\nAndrew is experimenting with pokémon order. He performs $q$ operations. In $i$-th operation Andrew swaps $l_i$-th and $r_i$-th pokémon.\n\nNote: $q=0$ in this version of the task.\n\nAndrew wants to know the maximal stregth of the army he can achieve with the initial pokémon placement. He also needs to know the maximal strength after each operation.\n\nHelp Andrew and the pokémon, or team R will realize their tricky plan!", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn list_maximum(xs: Seq<nat>) -> nat {\n    if xs.len() == 0 {\n        0\n    } else {\n        xs.fold_left(0, |acc: nat, x: nat| if x > acc { x } else { acc })\n    }\n}", "vc-spec": "fn find_max_army_strength(n: usize, arr: Vec<nat>) -> (result: nat)\n    requires \n        n == arr.len(),\n        arr.len() > 0,\n    ensures \n        result >= list_maximum(arr@),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded\n    \n    // let result1 = find_max_army_strength(3, vec![1, 3, 2]);\n    // println!(\"{}\", result1); // Expected: 3\n    \n    // let result2 = find_max_army_strength(2, vec![1, 2]);\n    // println!(\"{}\", result2); // Expected: 2\n    \n    // let result3 = find_max_army_strength(7, vec![1, 2, 5, 4, 3, 6, 7]);\n    // println!(\"{}\", result3); // Expected: 9\n}"}
{"id": "fvapps_000048", "vc-description": "You are playing a very popular game called Cubecraft. Initially, you have one stick and want to craft k torches. One torch can be crafted using one stick and one coal.\n\nHopefully, you've met a very handsome wandering trader who has two trade offers: exchange 1 stick for x sticks (you lose 1 stick and gain x sticks). exchange y sticks for 1 coal (you lose y sticks and gain 1 coal). \n\nDuring one trade, you can use only one of these two trade offers. You can use each trade offer any number of times you want to, in any order.\n\nYour task is to find the minimum number of trades you need to craft at least k torches. The answer always exists under the given constraints.\n\nYou have to answer t independent test cases.\n\nInput: The first line of the input contains one integer t (1 ≤ t ≤ 2 · 10^4) — the number of test cases. Then t test cases follow.\n\nThe only line of the test case contains three integers x, y and k (2 ≤ x ≤ 10^9; 1 ≤ y, k ≤ 10^9) — the number of sticks you can buy with one stick, the number of sticks required to buy one coal and the number of torches you need, respectively.\n\nOutput: For each test case, print the answer: the minimum number of trades you need to craft at least k torches. The answer always exists under the given constraints.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn min_trades(x: nat, y: nat, k: nat) -> (result: nat)\n    requires \n        x >= 2,\n        y >= 1,\n        k >= 1,\n    ensures\n        result >= 0,\n        result >= k,\n        result > 0,\n        (result - k) * (x - 1) >= y * k + k - 1,\n        (result - k) > 0 ==> (result - k - 1) * (x - 1) < y * k + k - 1", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = min_trades(2, 1, 5);\n    // println!(\"min_trades(2, 1, 5) = {}\", result1);\n    \n    // let result2 = min_trades(42, 13, 24);\n    // println!(\"min_trades(42, 13, 24) = {}\", result2);\n    \n    // let result3 = min_trades(12, 11, 12);\n    // println!(\"min_trades(12, 11, 12) = {}\", result3);\n}"}
{"id": "fvapps_000049", "vc-description": "Let's call some positive integer classy if its decimal representation contains no more than 3 non-zero digits. For example, numbers 4, 200000, 10203 are classy and numbers 4231, 102306, 7277420000 are not.\n\nYou are given a segment [L; R]. Count the number of classy integers x such that L ≤ x ≤ R.\n\nEach testcase contains several segments, for each of them you are required to solve the problem separately.\n\nInput: The first line contains a single integer T (1 ≤ T ≤ 10^4) — the number of segments in a testcase.\nEach of the next T lines contains two integers L_i and R_i (1 ≤ L_i ≤ R_i ≤ 10^18).\n\nOutput: Print T lines — the i-th line should contain the number of classy integers on a segment [L_i; R_i].", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn count_nonzero_digits(n: nat) -> nat\n    decreases n\n{\n    if n == 0 { 0 }\n    else { \n        let digit = n % 10;\n        let rest_count = count_nonzero_digits(n / 10);\n        if digit == 0 { rest_count } else { rest_count + 1 }\n    }\n}\n\nspec fn is_classy_number(n: nat) -> bool {\n    count_nonzero_digits(n) <= 3\n}\n\nfn is_classy_number_impl(n: u64) -> (result: bool)\n    ensures result == is_classy_number(n as nat)\n{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}\n\nfn count_classy_integers(start: u64, finish: u64) -> (result: u64)\n    requires start <= finish,\n    ensures \n        result >= 0,\n        result <= finish - start + 1,\n        start > finish ==> result == 0,\n        start == finish ==> result == (if is_classy_number(start as nat) { 1u64 } else { 0u64 })\n{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-code": "", "vc-postamble": "\n}\nfn main() {\n    // let test_cases = vec![(1, 1000), (1024, 1024), (65536, 65536), (999999, 1000001)];\n    // for (l, r) in test_cases {\n    //     let count = count_classy_integers(l, r);\n    //     println!(\"{}\", count);\n    // }\n}"}
{"id": "fvapps_000050", "vc-description": "Karlsson has recently discovered a huge stock of berry jam jars in the basement of the house. More specifically, there were 2n jars of strawberry and blueberry jam.\n\nAll the 2n jars are arranged in a row. The stairs to the basement are exactly in the middle of that row. So when Karlsson enters the basement, he sees exactly n jars to his left and n jars to his right.\n\nBeing the straightforward man he is, he immediately starts eating the jam. In one minute he chooses to empty either the first non-empty jar to his left or the first non-empty jar to his right.\n\nFinally, Karlsson decided that at the end the amount of full strawberry and blueberry jam jars should become the same.\n\nJars are numbered from 1 to 2n from left to right, so Karlsson initially stands between jars n and n+1.\n\nWhat is the minimum number of jars Karlsson is required to empty so that an equal number of full strawberry and blueberry jam jars is left?", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_jams(n: usize, jams: Vec<usize>) -> (result: usize)\n    requires \n        n > 0,\n        jams.len() == 2 * n,\n        forall|i: int| 0 <= i < jams.len() ==> (jams[i] == 1 || jams[i] == 2),\n    ensures \n        result >= 0,\n        result <= 2 * n,", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let result1 = solve_jams(6, vec![1, 1, 1, 2, 2, 1, 2, 1, 2, 1, 1, 2]);\n    // println!(\"{}\", result1); // Expected: 6\n    \n    // let result2 = solve_jams(2, vec![1, 2, 1, 2]);\n    // println!(\"{}\", result2); // Expected: 0\n    \n    // let result3 = solve_jams(3, vec![1, 1, 1, 1, 1, 1]);\n    // println!(\"{}\", result3); // Expected: 6\n}"}
{"id": "fvapps_000051", "vc-description": "There are n games in a football tournament. Three teams are participating in it. Currently k games had already been played. \n\nYou are an avid football fan, but recently you missed the whole k games. Fortunately, you remember a guess of your friend for these k games. Your friend did not tell exact number of wins of each team, instead he thought that absolute difference between number of wins of first and second team will be d_1 and that of between second and third team will be d_2.\n\nYou don't want any of team win the tournament, that is each team should have the same number of wins after n games. That's why you want to know: does there exist a valid tournament satisfying the friend's guess such that no team will win this tournament?\n\nNote that outcome of a match can not be a draw, it has to be either win or loss.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn can_have_no_winner(n: u64, k: u64, d1: u64, d2: u64) -> (result: bool)\n    requires\n        k <= n,\n        d1 <= k,\n        d2 <= k,\n    ensures\n        /* For no winner to exist, n must be divisible by 3 (each team gets equal wins) */\n        n % 3 != 0 ==> result == false,\n        /* If k > n or differences exceed bounds, impossible */\n        (k > n || d1 > n || d2 > n) ==> result == false,\n        /* If differences are zero and k is divisible by 3, should be possible */\n        (d1 == 0 && d2 == 0 && k % 3 == 0 && k <= n && n % 3 == 0) ==> result == true,", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let test1 = can_have_no_winner(3, 0, 0, 0);\n    // let test2 = can_have_no_winner(3, 3, 0, 0);\n    // let test3 = can_have_no_winner(6, 4, 1, 0);\n    // let test4 = can_have_no_winner(6, 3, 3, 0);\n    // let test5 = can_have_no_winner(3, 3, 3, 2);\n}"}
{"id": "fvapps_000052", "vc-description": "Harry Water, Ronaldo, Her-my-oh-knee and their friends have started a new school year at their MDCS School of Speechcraft and Misery. At the time, they are very happy to have seen each other after a long time. The sun is shining, birds are singing, flowers are blooming, and their Potions class teacher, professor Snipe is sulky as usual. Due to his angst fueled by disappointment in his own life, he has given them a lot of homework in Potions class. \n\nEach of the n students has been assigned a single task. Some students do certain tasks faster than others. Thus, they want to redistribute the tasks so that each student still does exactly one task, and that all tasks are finished. Each student has their own laziness level, and each task has its own difficulty level. Professor Snipe is trying hard to improve their work ethics, so each student's laziness level is equal to their task's difficulty level. Both sets of values are given by the sequence a, where a_{i} represents both the laziness level of the i-th student and the difficulty of his task. \n\nThe time a student needs to finish a task is equal to the product of their laziness level and the task's difficulty. They are wondering, what is the minimum possible total time they must spend to finish all tasks if they distribute them in the optimal way. Each person should receive one task and each task should be given to one person. Print the answer modulo 10 007.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn min_time_tasks(n: usize, difficulties: Vec<usize>) -> (result: usize)\n    requires \n        n > 0,\n        difficulties.len() == n,\n        forall|i: int| 0 <= i < difficulties.len() ==> #[trigger] difficulties[i] >= 1 && #[trigger] difficulties[i] <= 100000,\n    ensures \n        result < 10007,\n        result >= 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = min_time_tasks(2, vec![1, 3]);\n    // assert(result1 == 6);\n    // \n    // let result2 = min_time_tasks(3, vec![1, 2, 3]);\n    // assert(result2 == 10);\n    // \n    // let result3 = min_time_tasks(4, vec![1, 2, 3, 4]);\n    // assert(result3 == 20);\n}"}
{"id": "fvapps_000055", "vc-description": "A penguin Rocher has n sticks. He has exactly one stick with length i for all 1 ≤ i ≤ n.\n\nHe can connect some sticks. If he connects two sticks that have lengths a and b, he gets one stick with length a + b. Two sticks, that were used in the operation disappear from his set and the new connected stick appears in his set and can be used for the next connections.\n\nHe wants to create the maximum number of sticks that have the same length. It is not necessary to make all sticks have the same length, some sticks can have the other length. How many sticks with the equal length he can create?\n\n-----Input-----\n\nThe input consists of multiple test cases. The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases. Next t lines contain descriptions of test cases.\n\nFor each test case, the only line contains a single integer n (1 ≤ n ≤ 10^9).\n\n-----Output-----\n\nFor each test case, print a single integer — the answer to the problem.\n\n-----Example-----\nInput\n4\n1\n2\n3\n4\n\nOutput\n1\n1\n2\n2\n\n-----Note-----\n\nIn the third case, he can connect two sticks with lengths 1 and 2 and he will get one stick with length 3. So, he will have two sticks with lengths 3.\n\nIn the fourth case, he can connect two sticks with lengths 1 and 3 and he will get one stick with length 4. After that, he will have three sticks with lengths {2, 4, 4}, so two sticks have the same length, and one stick has the other length.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn max_equal_sticks(n: nat) -> (result: nat)\n    requires n >= 1,\n    ensures \n        result == (n + 1) / 2,\n        result <= n,\n        result >= 1", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // assert(max_equal_sticks(1) == 1);\n    // assert(max_equal_sticks(3) == 2);\n    // assert(max_equal_sticks(4) == 2);\n}"}
{"id": "fvapps_000057", "vc-description": "You are given an array $a$ of length $n$, which initially is a permutation of numbers from $1$ to $n$. In one operation, you can choose an index $i$ ($1 \\leq i < n$) such that $a_i < a_{i + 1}$, and remove either $a_i$ or $a_{i + 1}$ from the array (after the removal, the remaining parts are concatenated). \n\nFor example, if you have the array $[1, 3, 2]$, you can choose $i = 1$ (since $a_1 = 1 < a_2 = 3$), then either remove $a_1$ which gives the new array $[3, 2]$, or remove $a_2$ which gives the new array $[1, 2]$.\n\nIs it possible to make the length of this array equal to $1$ with these operations?\n\n-----Input-----\n\nThe first line contains a single integer $t$ ($1 \\leq t \\leq 2 \\cdot 10^4$)  — the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\leq n \\leq 3 \\cdot 10^5$)  — the length of the array.\n\nThe second line of each test case contains $n$ integers $a_1$, $a_2$, ..., $a_n$ ($1 \\leq a_i \\leq n$, $a_i$ are pairwise distinct) — elements of the array.\n\nIt is guaranteed that the sum of $n$ over all test cases doesn't exceed $3 \\cdot 10^5$.\n\n-----Output-----\n\nFor each test case, output on a single line the word \"YES\" if it is possible to reduce the array to a single element using the aforementioned operation, or \"NO\" if it is impossible to do so.\n\n-----Example-----\nInput\n4\n3\n1 2 3\n4\n3 1 2 4\n3\n2 3 1\n6\n2 4 6 1 3 5\n\nOutput\nYES\nYES\nNO\nYES\n\n-----Note-----\n\nFor the first two test cases and the fourth test case, we can operate as follow (the bolded elements are the pair chosen for that operation):\n\n$[\\text{1}, \\textbf{2}, \\textbf{3}] \\rightarrow [\\textbf{1}, \\textbf{2}] \\rightarrow [\\text{1}]$\n\n$[\\text{3}, \\textbf{1}, \\textbf{2}, \\text{4}] \\rightarrow [\\text{3}, \\textbf{1}, \\textbf{4}] \\rightarrow [\\textbf{3}, \\textbf{4}] \\rightarrow [\\text{4}]$\n\n$[\\textbf{2}, \\textbf{4}, \\text{6}, \\text{1}, \\text{3}, \\text{5}] \\rightarrow [\\textbf{4}, \\textbf{6}, \\text{1}, \\text{3}, \\text{5}] \\rightarrow [\\text{4}, \\text{1}, \\textbf{3}, \\textbf{5}] \\rightarrow [\\text{4}, \\textbf{1}, \\textbf{5}] \\rightarrow [\\textbf{4}, \\textbf{5}] \\rightarrow [\\text{4}]$", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve(n: u32, arr: Vec<i32>) -> (result: bool)\n    requires \n        arr.len() > 0,\n        n as usize == arr.len(),\n    ensures \n        result == (arr[arr.len() - 1] > arr[0])", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\nfn main() {}\n\n}"}
{"id": "fvapps_000058", "vc-description": "You have a rectangular chocolate bar consisting of n × m single squares. You want to eat exactly k squares, so you may need to break the chocolate bar. \n\nIn one move you can break any single rectangular piece of chocolate in two rectangular pieces. You can break only by lines between squares: horizontally or vertically. The cost of breaking is equal to square of the break length.\n\nFor example, if you have a chocolate bar consisting of 2 × 3 unit squares then you can break it horizontally and get two 1 × 3 pieces (the cost of such breaking is 3^2 = 9), or you can break it vertically in two ways and get two pieces: 2 × 1 and 2 × 2 (the cost of such breaking is 2^2 = 4).\n\nFor several given values n, m and k find the minimum total cost of breaking. You can eat exactly k squares of chocolate if after all operations of breaking there is a set of rectangular pieces of chocolate with the total size equal to k squares. The remaining n·m - k squares are not necessarily form a single rectangular piece.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn find_min_chocolate_break_cost(n: nat, m: nat, k: nat) -> (result: nat)\n    requires \n        n > 0,\n        m > 0,\n        k <= 25,\n    ensures \n        (n * m == k) ==> (result == 0),\n        (k == 0) ==> (result == 0),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "}\n\nfn main() {\n    // let result1 = find_min_chocolate_break_cost(2, 2, 1);\n    // assert(result1 == 5);\n    \n    // let result2 = find_min_chocolate_break_cost(2, 2, 3);\n    // assert(result2 == 5);\n    \n    // let result3 = find_min_chocolate_break_cost(2, 2, 4);\n    // assert(result3 == 0);\n}"}
{"id": "fvapps_000060", "vc-description": "In order to celebrate Twice's 5th anniversary, Tzuyu and Sana decided to play a game.\n\nTzuyu gave Sana two integers $a$ and $b$ and a really important quest.\n\nIn order to complete the quest, Sana has to output the smallest possible value of ($a \\oplus x$) + ($b \\oplus x$) for any given $x$, where $\\oplus$ denotes the bitwise XOR operation.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_xor_expression(a: u32, b: u32) -> (result: u32)\n    ensures result == a ^ b,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // /* Apps difficulty: interview */\n    // /* Assurance level: guarded */\n    \n    // /* Test cases */\n    // assert(solve_xor_expression(6, 12) == 10);\n    // assert(solve_xor_expression(4, 9) == 13);\n    // assert(solve_xor_expression(1, 1) == 0);\n}"}
{"id": "fvapps_000062", "vc-description": "Lee just became Master in Codeforces, and so, he went out to buy some gifts for his friends. He bought $n$ integers, now it's time to distribute them between his friends rationally...\n\nLee has $n$ integers $a_1, a_2, \\ldots, a_n$ in his backpack and he has $k$ friends. Lee would like to distribute all integers in his backpack between his friends, such that the $i$-th friend will get exactly $w_i$ integers and each integer will be handed over to exactly one friend.\n\nLet's define the happiness of a friend as the sum of the maximum and the minimum integer he'll get.\n\nLee would like to make his friends as happy as possible, in other words, he'd like to maximize the sum of friends' happiness. Now he asks you to calculate the maximum sum of friends' happiness.\n\n-----Input-----\n\nThe first line contains one integer $t$ ($1 \\le t \\le 10^4$) — the number of test cases.\n\nNext $3t$ lines contain test cases — one per three lines.\n\nThe first line of each test case contains two integers $n$ and $k$ ($1 \\le n \\le 2 \\cdot 10^5$; $1 \\le k \\le n$) — the number of integers Lee has and the number of Lee's friends.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($-10^9 \\le a_i \\le 10^9$) — the integers Lee has.\n\nThe third line contains $k$ integers $w_1, w_2, \\ldots, w_k$ ($1 \\le w_i \\le n$; $w_1 + w_2 + \\ldots + w_k = n$) — the number of integers Lee wants to give to each friend. \n\nIt's guaranteed that the sum of $n$ over test cases is less than or equal to $2 \\cdot 10^5$.\n\n-----Output-----\n\nFor each test case, print a single integer — the maximum sum of happiness Lee can achieve.\n\n-----Example-----\nInput\n3\n4 2\n1 13 7 17\n1 3\n6 2\n10 10 10 10 11 11\n3 3\n4 4\n1000000000 1000000000 1000000000 1000000000\n1 1 1 1\n\nOutput\n48\n42\n8000000000\n\n-----Note-----\n\nIn the first test case, Lee should give the greatest integer to the first friend (his happiness will be $17 + 17$) and remaining integers to the second friend (his happiness will be $13 + 1$).\n\nIn the second test case, Lee should give $\\{10, 10, 11\\}$ to the first friend and to the second friend, so the total happiness will be equal to $(11 + 10) + (11 + 10)$\n\nIn the third test case, Lee has four friends and four integers, it doesn't matter how he distributes the integers between his friends.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn vec_sum(v: Seq<usize>) -> int\n    decreases v.len()\n{\n    if v.len() == 0 {\n        0\n    } else {\n        v[0] as int + vec_sum(v.skip(1))\n    }\n}", "vc-spec": "spec fn solve_spec(n: usize, k: usize, nums: Seq<i64>, friends: Seq<usize>) -> i64;\n\nfn solve(n: usize, k: usize, nums: Vec<i64>, friends: Vec<usize>) -> (result: i64)\n    requires \n        k >= 1,\n        n >= k,\n        nums.len() == n,\n        friends.len() == k,\n        vec_sum(friends@) == n as int,\n        forall|i: int| 0 <= i < friends.len() ==> friends[i] >= 1,\n    ensures\n        result == solve_spec(n, k, nums@, friends@),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n\nproof fn solve_case1() {\n    assume(solve_spec(4, 2, seq![1, 13, 7, 17], seq![1, 3]) == 48);\n}\n\nproof fn solve_case2() {\n    assume(solve_spec(6, 2, seq![10, 10, 10, 10, 11, 11], seq![3, 3]) == 42);\n}\n\nproof fn solve_case3() {\n    assume(solve_spec(4, 4, seq![1000000000, 1000000000, 1000000000, 1000000000], seq![1, 1, 1, 1]) == 8000000000);\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "fvapps_000063", "vc-description": "There is a road with length $l$ meters. The start of the road has coordinate $0$, the end of the road has coordinate $l$.\n\nThere are two cars, the first standing at the start of the road and the second standing at the end of the road. They will start driving simultaneously. The first car will drive from the start to the end and the second car will drive from the end to the start.\n\nInitially, they will drive with a speed of $1$ meter per second. There are $n$ flags at different coordinates $a_1, a_2, \\ldots, a_n$. Each time when any of two cars drives through a flag, the speed of that car increases by $1$ meter per second.\n\nFind how long will it take for cars to meet (to reach the same coordinate). \n\n-----Input-----\n\nThe first line contains one integer $t$ ($1 \\leq t \\leq 10^4$): the number of test cases.\n\nThe first line of each test case contains two integers $n$, $l$ ($1 \\leq n \\leq 10^5$, $1 \\leq l \\leq 10^9$): the number of flags and the length of the road.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ in the increasing order ($1 \\leq a_1 < a_2 < \\ldots < a_n < l$).\n\nIt is guaranteed that the sum of $n$ among all test cases does not exceed $10^5$.\n\n-----Output-----\n\nFor each test case print a single real number: the time required for cars to meet.\n\nYour answer will be considered correct, if its absolute or relative error does not exceed $10^{-6}$. More formally, if your answer is $a$ and jury's answer is $b$, your answer will be considered correct if $\\frac{|a-b|}{\\max{(1, b)}} \\leq 10^{-6}$.\n\n-----Example-----\nInput\n5\n2 10\n1 9\n1 10\n1\n5 7\n1 2 3 4 6\n2 1000000000\n413470354 982876160\n9 478\n1 10 25 33 239 445 453 468 477\n\nOutput\n3.000000000000000\n3.666666666666667\n2.047619047619048\n329737645.750000000000000\n53.700000000000000\n\n-----Note-----\n\nIn the first test case cars will meet in the coordinate $5$.\n\nThe first car will be in the coordinate $1$ in $1$ second and after that its speed will increase by $1$ and will be equal to $2$ meters per second. After $2$ more seconds it will be in the coordinate $5$. So, it will be in the coordinate $5$ in $3$ seconds.\n\nThe second car will be in the coordinate $9$ in $1$ second and after that its speed will increase by $1$ and will be equal to $2$ meters per second. After $2$ more seconds it will be in the coordinate $5$. So, it will be in the coordinate $5$ in $3$ seconds.\n\nIn the second test case after $1$ second the first car will be in the coordinate $1$ and will have the speed equal to $2$ meters per second, the second car will be in the coordinate $9$ and will have the speed equal to $1$ meter per second. So, they will meet after $\\frac{9-1}{2+1} = \\frac{8}{3}$ seconds. So, the answer is equal to $1 + \\frac{8}{3} = \\frac{11}{3}$.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn is_sorted_increasing(flags: Seq<usize>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < flags.len() ==> flags[i] < flags[j]\n}\n\nspec fn flags_in_bounds(flags: Seq<usize>, l: usize) -> bool {\n    forall|i: int| 0 <= i < flags.len() ==> 0 < flags[i] && flags[i] < l\n}", "vc-spec": "fn solve_cars_meeting(n: usize, l: usize, flags: Vec<usize>) -> (result: usize)\n    requires \n        n > 0,\n        l > n,\n        flags.len() == n,\n        is_sorted_increasing(flags@),\n        flags_in_bounds(flags@, l),\n    ensures \n        result > 0,\n        result < l,\n        result <= l / 2,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000064", "vc-description": "You and your friend are playing the game Mortal Kombat XI. You are trying to pass a challenge tower. There are n bosses in this tower, numbered from 1 to n. The type of the i-th boss is a_i. If the i-th boss is easy then its type is a_i = 0, otherwise this boss is hard and its type is a_i = 1.\n\nDuring one session, either you or your friend can kill one or two bosses (neither you nor your friend can skip the session, so the minimum number of bosses killed during one session is at least one). After your friend session, your session begins, then again your friend session begins, your session begins, and so on. The first session is your friend's session.\n\nYour friend needs to get good because he can't actually kill hard bosses. To kill them, he uses skip points. One skip point can be used to kill one hard boss.\n\nYour task is to find the minimum number of skip points your friend needs to use so you and your friend kill all n bosses in the given order.\n\nFor example: suppose n = 8, a = [1, 0, 1, 1, 0, 1, 1, 1]. Then the best course of action is the following:\n\n  your friend kills two first bosses, using one skip point for the first boss;  you kill the third and the fourth bosses;  your friend kills the fifth boss;  you kill the sixth and the seventh bosses;  your friend kills the last boss, using one skip point, so the tower is completed using two skip points. \n\nYou have to answer t independent test cases.\n\nInput:\nThe first line of the input contains one integer t (1 ≤ t ≤ 2 × 10^4) — the number of test cases. Then t test cases follow.\n\nThe first line of the test case contains one integer n (1 ≤ n ≤ 2 × 10^5) — the number of bosses. The second line of the test case contains n integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 1), where a_i is the type of the i-th boss.\n\nIt is guaranteed that the sum of n does not exceed 2 × 10^5 (∑ n ≤ 2 × 10^5).\n\nOutput:\nFor each test case, print the answer: the minimum number of skip points your friend needs to use so you and your friend kill all n bosses in the given order.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn count_ones(arr: Seq<usize>) -> nat\n    decreases arr.len()\n{\n    if arr.len() == 0 {\n        0nat\n    } else {\n        (arr[0] as nat) + count_ones(arr.skip(1))\n    }\n}\n\nfn min_skip_points(n: usize, arr: Vec<usize>) -> (result: usize)\n    requires \n        n > 0,\n        arr.len() == n,\n        forall|i: int| 0 <= i < arr.len() ==> (arr[i] == 0 || arr[i] == 1),\n    ensures \n        (result as nat) <= count_ones(arr@),", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // Examples from the problem:\n    // min_skip_points(8, vec![1, 0, 1, 1, 0, 1, 1, 1]) should return 2\n    // min_skip_points(5, vec![1, 1, 1, 1, 0]) should return 2\n    // min_skip_points(1, vec![0]) should return 0\n}"}
{"id": "fvapps_000067", "vc-description": "You have a string s consisting of n characters. Each character is either 0 or 1.\n\nYou can perform operations on the string. Each operation consists of two steps: select an integer i from 1 to the length of the string s, then delete the character s_i (the string length gets reduced by 1, the indices of characters to the right of the deleted one also get reduced by 1); if the string s is not empty, delete the maximum length prefix consisting of the same characters (the indices of the remaining characters and the string length get reduced by the length of the deleted prefix).\n\nNote that both steps are mandatory in each operation, and their order cannot be changed.\n\nFor example, if you have a string s = 111010, the first operation can be one of the following: select i = 1: we'll get 111010 → 11010 → 010; select i = 2: we'll get 111010 → 11010 → 010; select i = 3: we'll get 111010 → 11010 → 010; select i = 4: we'll get 111010 → 11110 → 0; select i = 5: we'll get 111010 → 11100 → 00; select i = 6: we'll get 111010 → 11101 → 01.\n\nYou finish performing operations when the string s becomes empty. What is the maximum number of operations you can perform?", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_string_operations(s: Vec<u8>) -> (result: usize)\n    requires s.len() > 0,\n    ensures \n        result > 0,\n        result <= s.len(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded_and_plausible\n    \n    // Test cases would go here but are commented out for verification\n}"}
{"id": "fvapps_000068", "vc-description": "Bertown is a city with n buildings in a straight line.\n\nThe city's security service discovered that some buildings were mined. A map was compiled, which is a string of length n, where the i-th character is \"1\" if there is a mine under the building number i and \"0\" otherwise.\n\nBertown's best sapper knows how to activate mines so that the buildings above them are not damaged. When a mine under the building numbered x is activated, it explodes and activates two adjacent mines under the buildings numbered x-1 and x+1 (if there were no mines under the building, then nothing happens). Thus, it is enough to activate any one mine on a continuous segment of mines to activate all the mines of this segment. For manual activation of one mine, the sapper takes a coins. He can repeat this operation as many times as you want.\n\nAlso, a sapper can place a mine under a building if it wasn't there. For such an operation, he takes b coins. He can also repeat this operation as many times as you want.\n\nThe sapper can carry out operations in any order.\n\nYou want to blow up all the mines in the city to make it safe. Find the minimum number of coins that the sapper will have to pay so that after his actions there are no mines left in the city.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn has_mine(mine_map: Seq<char>) -> bool {\n    exists|i: int| 0 <= i < mine_map.len() && mine_map[i] == '1'\n}\n\nspec fn count_mines(mine_map: Seq<char>) -> nat\n    decreases mine_map.len()\n{\n    if mine_map.len() == 0 {\n        0\n    } else {\n        let count_rest = count_mines(mine_map.skip(1));\n        if mine_map[0] == '1' {\n            count_rest + 1\n        } else {\n            count_rest\n        }\n    }\n}\n\nfn min_cost_clear_mines(a: u32, b: u32, mine_map: &str) -> (result: u32)\n    ensures\n        has_mine(mine_map@) ==> result >= a,\n        result <= a * count_mines(mine_map@) as u32", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // println!(\"{}\", min_cost_clear_mines(1, 1, \"01000010\"));\n    // println!(\"{}\", min_cost_clear_mines(5, 1, \"01101110\"));\n    // println!(\"{}\", min_cost_clear_mines(3, 2, \"1011\"));\n}"}
{"id": "fvapps_000071", "vc-description": "Phoenix loves beautiful arrays. An array is beautiful if all its subarrays of length k have the same sum. A subarray of an array is any sequence of consecutive elements.\n\nPhoenix currently has an array a of length n. He wants to insert some number of integers, possibly zero, into his array such that it becomes beautiful. The inserted integers must be between 1 and n inclusive. Integers may be inserted anywhere (even before the first or after the last element), and he is not trying to minimize the number of inserted integers.\n\nInput: The input consists of multiple test cases. The first line contains an integer t (1 ≤ t ≤ 50) — the number of test cases. The first line of each test case contains two integers n and k (1 ≤ k ≤ n ≤ 100). The second line of each test case contains n space-separated integers (1 ≤ a_i ≤ n) — the array that Phoenix currently has. This array may or may not be already beautiful.\n\nOutput: For each test case, if it is impossible to create a beautiful array, print -1. Otherwise, print two lines. The first line should contain the length of the beautiful array m (n ≤ m ≤ 10^4). You don't need to minimize m. The second line should contain m space-separated integers (1 ≤ b_i ≤ n) — a beautiful array that Phoenix can obtain after inserting some, possibly zero, integers into his array a. You may print integers that weren't originally in array a.\n\nIf there are multiple solutions, print any. It's guaranteed that if we can make array a beautiful, we can always make it with resulting length no more than 10^4.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn count_distinct(l: Seq<u32>) -> nat {\n    l.to_set().len() as nat\n}", "vc-spec": "fn solve_beautiful_array(n: u32, k: u32, a: Vec<u32>) -> (result: Vec<u32>)\n    requires \n        n > 0,\n        k > 0,\n        n <= 10,\n        k <= 10,\n        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i] >= 1 && #[trigger] a[i] <= 10,\n        a.len() > 0,\n        a.len() <= 20,\n    ensures\n        match result.len() {\n            0 => count_distinct(a@) > k,\n            _ => result.len() == n * k &&\n                 (forall|x: u32| a@.contains(x) ==> result@.contains(x)) &&\n                 count_distinct(result@) <= k &&\n                 (forall|i: int| 0 <= i < n && i * k as int + k as int <= result.len() ==> \n                     #[trigger] result@.subrange(0, k as int) =~= #[trigger] result@.subrange(i * k as int, i * k as int + k as int))\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000072", "vc-description": "You're given an array of n integers between 0 and n inclusive.\n\nIn one operation, you can choose any element of the array and replace it by the MEX of the elements of the array (which may change after the operation).\n\nFor example, if the current array is [0, 2, 2, 1, 4], you can choose the second element and replace it by the MEX of the present elements — 3. Array will become [0, 3, 2, 1, 4].\n\nYou must make the array non-decreasing, using at most 2n operations.\n\nIt can be proven that it is always possible. Please note that you do not have to minimize the number of operations. If there are many solutions, you can print any of them.\n\nAn array b[1 … n] is non-decreasing if and only if b_1 ≤ b_2 ≤ … ≤ b_n.\n\nThe MEX (minimum excluded) of an array is the smallest non-negative integer that does not belong to the array. For instance: The MEX of [2, 2, 1] is 0, because 0 does not belong to the array. The MEX of [3, 1, 0, 1] is 2, because 0 and 1 belong to the array, but 2 does not. The MEX of [0, 3, 1, 2] is 4 because 0, 1, 2 and 3 belong to the array, but 4 does not.\n\nIt's worth mentioning that the MEX of an array of length n is always between 0 and n inclusive.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_non_decreasing(arr: Seq<usize>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < arr.len() ==> arr[i] <= arr[j]\n}\n\nfn make_non_decreasing(arr: Vec<usize>) -> (result: (usize, Vec<usize>))\n    requires arr.len() >= 3,\n            forall|i: int| 0 <= i < arr.len() ==> arr[i] <= arr.len(),\n    ensures \n        result.1.len() <= 2 * arr.len(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    (0, Vec::new())\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000073", "vc-description": "Polycarp plays a computer game. In this game, the players summon armies of magical minions, which then fight each other.\n\nPolycarp can summon $n$ different minions. The initial power level of the $i$-th minion is $a_i$, and when it is summoned, all previously summoned minions' power levels are increased by $b_i$. The minions can be summoned in any order.\n\nUnfortunately, Polycarp cannot have more than $k$ minions under his control. To get rid of unwanted minions after summoning them, he may destroy them. Each minion can be summoned (and destroyed) only once.\n\nPolycarp's goal is to summon the strongest possible army. Formally, he wants to maximize the sum of power levels of all minions under his control (those which are summoned and not destroyed).\n\nHelp Polycarp to make up a plan of actions to summon the strongest possible army!\n\n-----Input-----\n\nThe first line contains one integer $T$ ($1 \\le T \\le 75$) — the number of test cases.\n\nEach test case begins with a line containing two integers $n$ and $k$ ($1 \\le k \\le n \\le 75$) — the number of minions availible for summoning, and the maximum number of minions that can be controlled by Polycarp, respectively.\n\nThen $n$ lines follow, the $i$-th line contains $2$ integers $a_i$ and $b_i$ ($1 \\le a_i \\le 10^5$, $0 \\le b_i \\le 10^5$) — the parameters of the $i$-th minion.\n\n-----Output-----\n\nFor each test case print the optimal sequence of actions as follows:\n\nFirstly, print $m$ — the number of actions which Polycarp has to perform ($0 \\le m \\le 2n$). Then print $m$ integers $o_1$, $o_2$, ..., $o_m$, where $o_i$ denotes the $i$-th action as follows: if the $i$-th action is to summon the minion $x$, then $o_i = x$, and if the $i$-th action is to destroy the minion $x$, then $o_i = -x$. Each minion can be summoned at most once and cannot be destroyed before being summoned (and, obviously, cannot be destroyed more than once). The number of minions in Polycarp's army should be not greater than $k$ after every action.\n\nIf there are multiple optimal sequences, print any of them.\n\n-----Example-----\nInput\n3\n5 2\n5 3\n7 0\n5 0\n4 0\n10 0\n2 1\n10 100\n50 10\n5 5\n1 5\n2 4\n3 3\n4 2\n5 1\n\nOutput\n4\n2 1 -1 5\n1\n2\n5\n5 4 3 2 1\n\n-----Note-----\n\nConsider the example test.\n\nIn the first test case, Polycarp can summon the minion $2$ with power level $7$, then summon the minion $1$, which will increase the power level of the previous minion by $3$, then destroy the minion $1$, and finally, summon the minion $5$. After this, Polycarp will have two minions with power levels of $10$.\n\nIn the second test case, Polycarp can control only one minion, so he should choose the strongest of them and summon it.\n\nIn the third test case, Polycarp is able to summon and control all five minions.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn list_merge_properties(a1: Seq<i32>, a2: Seq<i32>, result: Seq<i32>) -> bool {\n    result.len() == a1.len() + a2.len()\n}\n\nfn merge_sorted_arrays(a1: Vec<i32>, a2: Vec<i32>) -> (result: Vec<i32>)\n    ensures list_merge_properties(a1@, a2@, result@)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000074", "vc-description": "The statement of this problem is the same as the statement of problem C1. The only difference is that, in problem C1, n is always even, and in C2, n is always odd.\n\nYou are given a regular polygon with 2 * n vertices (it's convex and has equal sides and equal angles) and all its sides have length 1. Let's name it as 2n-gon.\n\nYour task is to find the square of the minimum size such that you can embed 2n-gon in the square. Embedding 2n-gon in the square means that you need to place 2n-gon in the square in such way that each point which lies inside or on a border of 2n-gon should also lie inside or on a border of the square.\n\nYou can rotate 2n-gon and/or the square.\n\n-----Input-----\n\nThe first line contains a single integer T (1 ≤ T ≤ 200) — the number of test cases.\n\nNext T lines contain descriptions of test cases — one per line. Each line contains single odd integer n (3 ≤ n ≤ 199). Don't forget you need to embed 2n-gon, not an n-gon.\n\n-----Output-----\n\nPrint T real numbers — one per test case. For each test case, print the minimum length of a side of the square 2n-gon can be embedded in. Your answer will be considered correct if its absolute or relative error doesn't exceed 10^{-6}.\n\n-----Example-----\nInput\n3\n3\n5\n199\n\nOutput\n1.931851653\n3.196226611\n126.687663595", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn min_square_side(n: nat) -> (result: nat)\n    requires n >= 3,\n    ensures result > 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\nproof fn min_square_side_positive(n: nat)\n    requires n >= 3\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn min_square_side_monotone(n: nat)\n    requires n >= 3\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\n}\nfn main() {}"}
{"id": "fvapps_000075", "vc-description": "Lee is going to fashionably decorate his house for a party, using some regular convex polygons...\n\nLee thinks a regular n-sided (convex) polygon is beautiful if and only if he can rotate it in such a way that at least one of its edges is parallel to the OX-axis and at least one of its edges is parallel to the OY-axis at the same time.\n\nRecall that a regular n-sided polygon is a convex polygon with n vertices such that all the edges and angles are equal.\n\nNow he is shopping: the market has t regular polygons. For each of them print YES if it is beautiful and NO otherwise.\n\n-----Input-----\n\nThe first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of polygons in the market. \n\nEach of the next t lines contains a single integer n_i (3 ≤ n_i ≤ 10^9): it means that the i-th polygon is a regular n_i-sided polygon. \n\n-----Output-----\n\nFor each polygon, print YES if it's beautiful or NO otherwise (case insensitive).\n\n-----Example-----\nInput\n4\n3\n4\n12\n1000000000\n\nOutput\nNO\nYES\nYES\nYES\n\n-----Note-----\n\nIn the example, there are 4 polygons in the market. It's easy to see that an equilateral triangle (a regular 3-sided polygon) is not beautiful, a square (a regular 4-sided polygon) is beautiful and a regular 12-sided polygon (is shown below) is beautiful as well. [Image]", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn check_polygon_beauty(n: nat) -> (result: bool)\n    requires n > 0,\n    ensures result == (n % 4 == 0),", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = check_polygon_beauty(8);\n    // println!(\"check_polygon_beauty(8) = {}\", result1);\n    // \n    // let result2 = check_polygon_beauty(7);\n    // println!(\"check_polygon_beauty(7) = {}\", result2);\n}"}
{"id": "fvapps_000076", "vc-description": "You have a fence consisting of n vertical boards. The width of each board is 1. The height of the i-th board is a_i. You think that the fence is great if there is no pair of adjacent boards having the same height. More formally, the fence is great if and only if for all indices from 2 to n, the condition a_{i-1} ≠ a_i holds.\n\nUnfortunately, it is possible that now your fence is not great. But you can change it! You can increase the length of the i-th board by 1, but you have to pay b_i rubles for it. The length of each board can be increased any number of times (possibly, zero).\n\nCalculate the minimum number of rubles you have to spend to make the fence great again!", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn list_sum(costs: Seq<nat>) -> nat\n    decreases costs.len()\n{\n    if costs.len() == 0 {\n        0\n    } else {\n        costs[0] + list_sum(costs.drop_first())\n    }\n}", "vc-spec": "fn solve_fence(heights: Vec<nat>, costs: Vec<nat>) -> (result: nat)\n    requires heights.len() == costs.len(),\n    ensures \n        result >= 0,\n        heights.len() <= 1 ==> result == 0,\n        result <= list_sum(costs@.map_values(|c: nat| c * 2))", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = solve_fence(vec![2, 2, 3], vec![4, 1, 5]);\n    // println!(\"Result 1: {}\", result1); // Expected: 2\n    \n    // let result2 = solve_fence(vec![2, 2, 2], vec![3, 10, 6]);\n    // println!(\"Result 2: {}\", result2); // Expected: 9\n    \n    // let result3 = solve_fence(vec![1, 3, 2, 1000000000], vec![7, 3, 6, 2]);\n    // println!(\"Result 3: {}\", result3); // Expected: 0\n}"}
{"id": "fvapps_000077", "vc-description": "You are given a picture consisting of n rows and m columns. Rows are numbered from 1 to n from the top to the bottom, columns are numbered from 1 to m from the left to the right. Each cell is painted either black or white. \n\nYou think that this picture is not interesting enough. You consider a picture to be interesting if there is at least one cross in it. A cross is represented by a pair of numbers x and y, where 1 ≤ x ≤ n and 1 ≤ y ≤ m, such that all cells in row x and all cells in column y are painted black.\n\nFor examples, each of these pictures contain crosses:\n\n [Image] \n\nThe fourth picture contains 4 crosses: at (1, 3), (1, 5), (3, 3) and (3, 5).\n\nFollowing images don't contain crosses:\n\n [Image] \n\nYou have a brush and a can of black paint, so you can make this picture interesting. Each minute you may choose a white cell and paint it black.\n\nWhat is the minimum number of minutes you have to spend so the resulting picture contains at least one cross?\n\nYou are also asked to answer multiple independent queries.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_valid_grid(grid: Seq<Vec<char>>) -> bool {\n    grid.len() > 0 && \n    forall|i: int| #![trigger grid[i]] 0 <= i < grid.len() ==> grid[i].len() == grid[0].len()\n}\n\nspec fn has_cross_at(grid: Seq<Vec<char>>, row: int, col: int) -> bool \n    recommends is_valid_grid(grid)\n{\n    0 <= row < grid.len() && \n    0 <= col < grid[0].len() &&\n    forall|j: int| #![trigger grid[row][j]] 0 <= j < grid[0].len() ==> grid[row][j] == '*' &&\n    forall|i: int| #![trigger grid[i][col]] 0 <= i < grid.len() ==> grid[i][col] == '*'\n}\n\nspec fn has_any_cross(grid: Seq<Vec<char>>) -> bool \n    recommends is_valid_grid(grid)\n{\n    exists|row: int, col: int| has_cross_at(grid, row, col)\n}\n\nfn min_minutes_for_cross(grid: Vec<Vec<char>>) -> (result: usize)\n    requires \n        grid.len() > 0,\n        grid.len() <= 50000,\n        forall|i: int| #![trigger grid[i]] 0 <= i < grid.len() ==> grid[i].len() == grid[0].len(),\n        grid[0].len() > 0,\n        grid[0].len() <= 50000,\n        is_valid_grid(grid@),\n    ensures \n        result <= grid.len() + grid[0].len() - 1,\n        has_any_cross(grid@) ==> result == 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000078", "vc-description": "An agent called Cypher is decrypting a message, that contains a composite number n. All divisors of n, which are greater than 1, are placed in a circle. Cypher can choose the initial order of numbers in the circle.\n\nIn one move Cypher can choose two adjacent numbers in a circle and insert their least common multiple between them. He can do that move as many times as needed.\n\nA message is decrypted, if every two adjacent numbers are not coprime. Note that for such constraints it's always possible to decrypt the message.\n\nFind the minimal number of moves that Cypher should do to decrypt the message, and show the initial order of numbers in the circle for that.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn get_prime_factors(n: nat) -> Seq<nat> {\n    Seq::empty()\n}\n\nfn get_prime_factors_impl(n: u32) -> (result: Vec<u32>)\n    requires n >= 4,\n    ensures forall|x: u32| result@.contains(x) ==> (n % x == 0 && x > 1)\n{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}\n\nfn solve_cipher(n: u32) -> (result: (Vec<u32>, u32))\n    requires n >= 4 && n <= 10000,\n    ensures\n        forall|x: u32| result.0@.contains(x) ==> (n % x == 0 && x > 1),\n        forall|i: int, j: int| 0 <= i < result.0.len() && 0 <= j < result.0.len() && i != j \n            ==> result.0[i] != result.0[j],\n        (get_prime_factors(n as nat).len() == 2) ==> (\n            result.1 == 1 &&\n            (exists|x: u32, y: u32, z: u32| \n                result.0@.contains(x) && result.0@.contains(y) && result.0@.contains(z) &&\n                x * y == z)\n        ),\n        (get_prime_factors(n as nat).len() != 2) ==> result.1 == 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    (Vec::new(), 0)\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000079", "vc-description": "While doing some spring cleaning, Daniel found an old calculator that he loves so much. However, it seems like it is broken. When he tries to compute $1 + 3$ using the calculator, he gets $2$ instead of $4$. But when he tries computing $1 + 4$, he gets the correct answer, $5$. Puzzled by this mystery, he opened up his calculator and found the answer to the riddle: the full adders became half adders! \n\nSo, when he tries to compute the sum $a + b$ using the calculator, he instead gets the xorsum $a \\oplus b$ (read the definition by the link: https://en.wikipedia.org/wiki/Exclusive_or).\n\nAs he saw earlier, the calculator sometimes gives the correct answer. And so, he wonders, given integers $l$ and $r$, how many pairs of integers $(a, b)$ satisfy the following conditions: $$a + b = a \\oplus b$$ $$l \\leq a \\leq r$$ $$l \\leq b \\leq r$$\n\nHowever, Daniel the Barman is going to the bar and will return in two hours. He tells you to solve the problem before he returns, or else you will have to enjoy being blocked.\n\n-----Input-----\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 100$) — the number of testcases.\n\nThen, $t$ lines follow, each containing two space-separated integers $l$ and $r$ ($0 \\le l \\le r \\le 10^9$).\n\n-----Output-----\n\nPrint $t$ integers, the $i$-th integer should be the answer to the $i$-th testcase.\n\n-----Example-----\nInput\n3\n1 4\n323 323\n1 1000000\n\nOutput\n8\n0\n3439863766\n\n-----Note-----\n\n$a \\oplus b$ denotes the bitwise XOR of $a$ and $b$.\n\nFor the first testcase, the pairs are: $(1, 2)$, $(1, 4)$, $(2, 1)$, $(2, 4)$, $(3, 4)$, $(4, 1)$, $(4, 2)$, and $(4, 3)$.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_broken_calc(l: nat, r: nat) -> (result: nat)\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n\nproof fn same_value(x: nat) {\n    // impl-start  \n    assume(false);\n    // impl-end\n}\n\nproof fn consecutive_valid(x: nat) {\n    // impl-start\n    assume(false);\n    // impl-end\n}\n\nproof fn range_validity(l: nat, r: nat) {\n    // impl-start\n    assume(false);\n    // impl-end\n}", "vc-code": "", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: unguarded\n\n    // #eval solve_broken_calc 1 4\n    // Expected output: 8\n\n    // #eval solve_broken_calc 323 323  \n    // Expected output: 0\n\n    // #eval solve_broken_calc 1 1000000\n    // Expected output: 3439863766\n}"}
{"id": "fvapps_000080", "vc-description": "You are given three strings a, b and c of the same length n. The strings consist of lowercase English letters only. The i-th letter of a is a_i, the i-th letter of b is b_i, the i-th letter of c is c_i.\n\nFor every i (1 ≤ i ≤ n) you must swap (i.e. exchange) c_i with either a_i or b_i. So in total you'll perform exactly n swap operations, each of them either c_i ↔ a_i or c_i ↔ b_i (i iterates over all integers between 1 and n, inclusive).\n\nFor example, if a is \"code\", b is \"true\", and c is \"help\", you can make c equal to \"crue\" taking the 1-st and the 4-th letters from a and the others from b. In this way a becomes \"hodp\" and b becomes \"tele\".\n\nIs it possible that after these swaps the string a becomes exactly the same as the string b?", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn can_strings_equal(s1: Vec<u8>, s2: Vec<u8>, target: Vec<u8>) -> (result: bool)\n    requires \n        s1.len() == s2.len(),\n        s1.len() == target.len(),\n        s1.len() > 0,\n    ensures result == true ==> (\n        exists|choices: Seq<bool>| #[trigger] choices.len() == s1.len() &&\n        forall|i: int| 0 <= i < s1.len() ==> (\n            if choices[i] {\n                s1[i] == target[i] &&\n                s2[i] == s2[i]\n            } else {\n                s1[i] == s1[i] &&\n                s2[i] == target[i]\n            }\n        )\n    )", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let test1 = can_strings_equal(b\"aaa\".to_vec(), b\"bbb\".to_vec(), b\"ccc\".to_vec());\n    // let test2 = can_strings_equal(b\"abc\".to_vec(), b\"bca\".to_vec(), b\"bca\".to_vec());\n    // let test3 = can_strings_equal(b\"aabb\".to_vec(), b\"bbaa\".to_vec(), b\"baba\".to_vec());\n    // let test4 = can_strings_equal(b\"imi\".to_vec(), b\"mii\".to_vec(), b\"iim\".to_vec());\n}"}
{"id": "fvapps_000081", "vc-description": "A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2 appears twice in the array) and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).\n\nLet p be any permutation of length n. We define the fingerprint F(p) of p as the sorted array of sums of adjacent elements in p. More formally,\n\nF(p) = sort([p_1+p_2, p_2+p_3, ..., p_{n-1}+p_n]).\n\nFor example, if n=4 and p=[1,4,2,3], then the fingerprint is given by F(p) = sort([1+4,4+2,2+3]) = sort([5,6,5]) = [5,5,6].\n\nYou are given a permutation p of length n. Your task is to find a different permutation p' with the same fingerprint. Two permutations p and p' are considered different if there is some index i such that p_i ≠ p'_i.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_permutation(p: Seq<nat>) -> bool {\n    p.len() > 0 &&\n    (forall|i: int| 0 <= i < p.len() ==> #[trigger] p[i] >= 1 && #[trigger] p[i] <= p.len()) &&\n    (forall|i: int, j: int| 0 <= i < p.len() && 0 <= j < p.len() && i != j ==> #[trigger] p[i] != #[trigger] p[j])\n}\n\nspec fn adjacent_sums(p: Seq<nat>) -> Seq<nat> {\n    if p.len() < 2 {\n        Seq::empty()\n    } else {\n        Seq::new((p.len() - 1) as nat, |i: int| p[i] + p[i + 1])\n    }\n}\n\nfn solve_fingerprint(n: usize, p: Vec<nat>) -> (result: Vec<nat>)\n    requires \n        n >= 2,\n        p.len() == n,\n        is_permutation(p@),\n    ensures\n        result.len() == p.len(),\n        is_permutation(result@),\n        result@ != p@,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000082", "vc-description": "Being tired of participating in too many Codeforces rounds, Gildong decided to take some rest in a park. He sat down on a bench, and soon he found two rabbits hopping around. One of the rabbits was taller than the other.\n\nHe noticed that the two rabbits were hopping towards each other. The positions of the two rabbits can be represented as integer coordinates on a horizontal line. The taller rabbit is currently on position x, and the shorter rabbit is currently on position y (x < y). Every second, each rabbit hops to another position. The taller rabbit hops to the positive direction by a, and the shorter rabbit hops to the negative direction by b.\n\nFor example, let's say x=0, y=10, a=2, and b=3. At the 1-st second, each rabbit will be at position 2 and 7. At the 2-nd second, both rabbits will be at position 4.\n\nGildong is now wondering: Will the two rabbits be at the same position at the same moment? If so, how long will it take? Let's find a moment in time (in seconds) after which the rabbits will be at the same point.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_rabbits(x: i32, y: i32, a: i32, b: i32) -> (result: i32)\n    requires \n        x < y,\n        a > 0,\n        b > 0,\n    ensures\n        (result == -1) || (result >= 0 && x + a * result == y - b * result),\n        result == -1 <==> ((y - x) % (a + b) != 0),\n        result >= 0 ==> (result == (y - x) / (a + b)),", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = solve_rabbits(0, 10, 2, 3);\n    // assert(result1 == 2);\n    \n    // let result2 = solve_rabbits(0, 10, 3, 3);\n    // assert(result2 == -1);\n    \n    // let result3 = solve_rabbits(900000000, 1000000000, 1, 9999999);\n    // assert(result3 == 10);\n}"}
{"id": "fvapps_000086", "vc-description": "Berland year consists of m months with d days each. Months are numbered from 1 to m. Berland week consists of w days. The first day of the year is also the first day of the week. Note that the last week of the year might be shorter than w days.\n\nA pair (x, y) such that x < y is ambiguous if day x of month y is the same day of the week as day y of month x.\n\nCount the number of ambiguous pairs.\n\nInput: The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of testcases.\nEach of the next t lines contains three integers m, d and w (1 ≤ m, d, w ≤ 10^9) — the number of months in a year, the number of days in a month and the number of days in a week.\n\nOutput: Print t integers — for each testcase output the number of pairs (x, y) such that x < y and day x of month y is the same day of the week as day y of month x.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn count_ambiguous_pairs(m: nat, d: nat, w: nat) -> nat\n{\n    0  /* placeholder specification */\n}\n\nfn count_ambiguous_pairs_impl(m: u64, d: u64, w: u64) -> (result: u64)\n    requires \n        m >= 1,\n        d >= 1,\n        w >= 1,\n    ensures result >= 0\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n\nproof fn count_ambiguous_pairs_nonnegative(m: u64, d: u64, w: u64)\n    requires \n        m >= 1,\n        d >= 1,\n        w >= 1,\n    ensures count_ambiguous_pairs(m as nat, d as nat, w as nat) >= 0\n{\n    // impl-start\n    assume(false);\n    // impl-end\n}\n\nproof fn count_ambiguous_pairs_equal_inputs(n: u64)\n    requires n >= 1,\n    ensures count_ambiguous_pairs(n as nat, n as nat, n as nat) <= n * (n - 1) / 2\n{\n    // impl-start\n    assume(false);\n    // impl-end\n}\n\nproof fn count_ambiguous_pairs_week_one(m: u64, d: u64)\n    requires \n        m >= 1,\n        d >= 1,\n    ensures count_ambiguous_pairs(m as nat, d as nat, 1) <= if m <= d { m * (m - 1) / 2 } else { d * (d - 1) / 2 }\n{\n    // impl-start\n    assume(false);\n    // impl-end\n}", "vc-code": "", "vc-postamble": "\n}\nfn main() {\n    // assert count_ambiguous_pairs_impl(6, 7, 4) == 6;\n    // assert count_ambiguous_pairs_impl(10, 7, 12) == 9;\n    // assert count_ambiguous_pairs_impl(12, 30, 7) == 5;\n}"}
{"id": "fvapps_000087", "vc-description": "Bob is playing with 6-sided dice. A net of such standard cube is shown below.\n\n[Image]\n\nHe has an unlimited supply of these dice and wants to build a tower by stacking multiple dice on top of each other, while choosing the orientation of each dice. Then he counts the number of visible pips on the faces of the dice.\n\nFor example, the number of visible pips on the tower below is 29 — the number visible on the top is 1, from the south 5 and 3, from the west 4 and 2, from the north 2 and 4 and from the east 3 and 5.\n\n[Image]\n\nThe one at the bottom and the two sixes by which the dice are touching are not visible, so they are not counted towards total.\n\nBob also has t favourite integers x_i, and for every such integer his goal is to build such a tower that the number of visible pips is exactly x_i. For each of Bob's favourite integers determine whether it is possible to build a tower that has exactly that many visible pips.\n\n-----Input-----\n\nThe first line contains a single integer t (1 ≤ t ≤ 1000) — the number of favourite integers of Bob. \n\nThe second line contains t space-separated integers x_i (1 ≤ x_i ≤ 10^18) — Bob's favourite integers.\n\n-----Output-----\n\nFor each of Bob's favourite integers, output \"YES\" if it is possible to build the tower, or \"NO\" otherwise (quotes for clarity).\n\n-----Example-----\nInput\n4\n29 34 19 38\n\nOutput\nYES\nYES\nYES\nNO\n\n-----Note-----\n\nThe first example is mentioned in the problem statement.\n\nIn the second example, one can build the tower by flipping the top dice from the previous tower.\n\nIn the third example, one can use a single die that has 5 on top.\n\nThe fourth example is impossible.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_dice_tower(nums: Vec<nat>) -> (result: Vec<String>)\n    ensures result.len() == nums.len()", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "}\n\nfn main() {\n    // println!(\"{:?}\", solve_dice_tower(vec![29, 34, 19, 38]));\n    // println!(\"{:?}\", solve_dice_tower(vec![7, 14, 21]));\n    // println!(\"{:?}\", solve_dice_tower(vec![16, 29, 34]));\n}"}
{"id": "fvapps_000088", "vc-description": "Monocarp had a tree which consisted of n vertices and was rooted at vertex 1. He decided to study BFS (Breadth-first search), so he ran BFS on his tree, starting from the root. BFS can be described by the following pseudocode:a = [] # the order in which vertices were processed\n\nq = Queue()\n\nq.put(1) # place the root at the end of the queue\n\nwhile not q.empty():\n\n    k = q.pop() # retrieve the first vertex from the queue\n\n    a.append(k) # append k to the end of the sequence in which vertices were visited\n\n    for y in g[k]: # g[k] is the list of all children of vertex k, sorted in ascending order\n\n        q.put(y)\n\nMonocarp was fascinated by BFS so much that, in the end, he lost his tree. Fortunately, he still has a sequence of vertices, in which order vertices were visited by the BFS algorithm (the array a from the pseudocode). Monocarp knows that each vertex was visited exactly once (since they were put and taken from the queue exactly once). Also, he knows that all children of each vertex were viewed in ascending order.\n\nMonocarp knows that there are many trees (in the general case) with the same visiting order a, so he doesn't hope to restore his tree. Monocarp is okay with any tree that has minimum height.\n\nThe height of a tree is the maximum depth of the tree's vertices, and the depth of a vertex is the number of edges in the path from the root to it. For example, the depth of vertex 1 is 0, since it's the root, and the depth of all root's children are 1.\n\nHelp Monocarp to find any tree with given visiting order a and minimum height.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_minimum_tree_height(n: usize, xs: Vec<i32>) -> (result: usize)\n    requires \n        xs.len() > 0,\n        n >= 2,\n        xs.len() == n,\n    ensures \n        result <= xs.len() - 1,", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = solve_minimum_tree_height(4, vec![1, 4, 3, 2]);\n    // assert(result1 == 3);\n    \n    // let result2 = solve_minimum_tree_height(2, vec![1, 2]);\n    // assert(result2 == 1);\n    \n    // let result3 = solve_minimum_tree_height(3, vec![1, 2, 3]);\n    // assert(result3 == 1);\n}"}
{"id": "fvapps_000089", "vc-description": "You are given an array consisting of n integers.\n\nEach position i (1 ≤ i ≤ n) of the array is either locked or unlocked. You can take the values on the unlocked positions, rearrange them in any order and place them back into the unlocked positions. You are not allowed to remove any values, add the new ones or rearrange the values on the locked positions. You are allowed to leave the values in the same order as they were.\n\nFor example, let a = [-1, 1, 3, 2, -2, 1, -4, 0], the underlined positions are locked. You can obtain various arrays by rearranging unlocked positions.\n\nLet p be a sequence of prefix sums of the array a after the rearrangement. So p_1 = a_1, p_2 = a_1 + a_2, p_3 = a_1 + a_2 + a_3, ..., p_n = a_1 + a_2 + ... + a_n.\n\nLet k be the maximum j (1 ≤ j ≤ n) such that p_j < 0. If there are no j such that p_j < 0, then k = 0.\n\nYour goal is to rearrange the values in such a way that k is minimum possible.\n\nOutput the array a after the rearrangement such that the value k for it is minimum possible. If there are multiple answers then print any of them.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn prefix_sum(arr: Seq<i32>, idx: int) -> int\n    decreases idx\n{\n    if idx <= 0 {\n        0\n    } else if idx > arr.len() {\n        prefix_sum(arr, arr.len() as int)\n    } else {\n        prefix_sum(arr, idx - 1) + arr[(idx - 1) as int]\n    }\n}\n\nspec fn multiset_equivalent_except_locked(original: Seq<i32>, result: Seq<i32>, locks: Seq<bool>) -> bool {\n    true\n}\n\nspec fn is_valid_rearrangement(original: Seq<i32>, locks: Seq<bool>, result: Seq<i32>) -> bool {\n    &&& original.len() == locks.len()\n    &&& result.len() == original.len()\n    &&& forall|i: int| 0 <= i < locks.len() && locks[i] ==> result[i] == original[i]\n    &&& multiset_equivalent_except_locked(original, result, locks)\n}\n\nfn rearrange_array(n: usize, arr: Vec<i32>, can: Vec<bool>) -> (result: Vec<i32>)\n    requires \n        n == arr.len(),\n        n == can.len(),\n        n > 0,\n    ensures \n        result.len() == n,\n        is_valid_rearrangement(arr@, can@, result@),\n        forall|i: int| 0 <= i < n as int && can@[i] ==> result@[i] == arr@[i],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000091", "vc-description": "You are given two strings of equal length s and t consisting of lowercase Latin letters. You may perform any number (possibly, zero) operations on these strings.\n\nDuring each operation you choose two adjacent characters in any string and assign the value of the first character to the value of the second or vice versa.\n\nFor example, if s is \"acbc\" you can get the following strings in one operation:   \"aabc\" (if you perform s_2 = s_1);  \"ccbc\" (if you perform s_1 = s_2);  \"accc\" (if you perform s_3 = s_2 or s_3 = s_4);  \"abbc\" (if you perform s_2 = s_3);  \"acbb\" (if you perform s_4 = s_3); \n\nNote that you can also apply this operation to the string t.\n\nPlease determine whether it is possible to transform s into t, applying the operation above any number of times.\n\nNote that you have to answer q independent queries.\n\n-----Input-----\n\nThe first line contains one integer q (1 ≤ q ≤ 100) — the number of queries. Each query is represented by two consecutive lines.\n\nThe first line of each query contains the string s (1 ≤ |s| ≤ 100) consisting of lowercase Latin letters.\n\nThe second line of each query contains the string t (1 ≤ |t| ≤ 100, |t| = |s|) consisting of lowercase Latin letters.\n\n-----Output-----\n\nFor each query, print \"YES\" if it is possible to make s equal to t, and \"NO\" otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will all be recognized as positive answer).\n\n-----Example-----\nInput\n3\nxabb\naabx\ntechnocup\ntechnocup\na\nz\n\nOutput\nYES\nYES\nNO\n\n-----Note-----\n\nIn the first query, you can perform two operations s_1 = s_2 (after it s turns into \"aabb\") and t_4 = t_3 (after it t turns into \"aabb\"). \n\nIn the second query, the strings are equal initially, so the answer is \"YES\".\n\nIn the third query, you can not make strings s and t equal. Therefore, the answer is \"NO\".", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn string_to_char_set(s: Seq<char>) -> Set<char> {\n    Set::new(|c: char| exists|i: int| 0 <= i < s.len() && s[i] == c)\n}\n\nfn are_strings_transformable(s: Vec<char>, t: Vec<char>) -> (result: bool)\n    requires \n        s.len() == t.len(),\n        s.len() > 0,\n    ensures \n        result == true <==> (\n            string_to_char_set(s@).intersect(string_to_char_set(t@)).len() > 0\n        ),\n        result == (s@ == t@) ==> result == true,\n        (forall|c: char| !(#[trigger] string_to_char_set(s@).contains(c)) || !string_to_char_set(t@).contains(c)) ==> result == false,", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000092", "vc-description": "Santa has to send presents to the kids. He has a large stack of n presents, numbered from 1 to n; the topmost present has number a_1, the next present is a_2, and so on; the bottom present has number a_n. All numbers are distinct.\n\nSanta has a list of m distinct presents he has to send: b_1, b_2, ..., b_m. He will send them in the order they appear in the list.\n\nTo send a present, Santa has to find it in the stack by removing all presents above it, taking this present and returning all removed presents on top of the stack. So, if there are k presents above the present Santa wants to send, it takes him 2k + 1 seconds to do it. Fortunately, Santa can speed the whole process up — when he returns the presents to the stack, he may reorder them as he wishes (only those which were above the present he wanted to take; the presents below cannot be affected in any way).\n\nWhat is the minimum time required to send all of the presents, provided that Santa knows the whole list of presents he has to send and reorders the presents optimally? Santa cannot change the order of presents or interact with the stack of presents in any other way.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn min_time_to_send_presents(n: nat, m: nat, stack: Vec<nat>, send_list: Vec<nat>) -> (result: nat)\n    requires \n        n > 0,\n        n <= 100000,\n        stack.len() == n,\n        m <= n,\n        send_list.len() == m,\n        forall|i: int| 0 <= i < stack.len() ==> 1 <= stack[i] && stack[i] <= n,\n        forall|i: int| 0 <= i < send_list.len() ==> 1 <= send_list[i] && send_list[i] <= n,\n        // All elements in stack are unique\n        forall|i: int, j: int| 0 <= i < stack.len() && 0 <= j < stack.len() && i != j ==> stack[i] != stack[j],\n        // All elements in send_list are unique  \n        forall|i: int, j: int| 0 <= i < send_list.len() && 0 <= j < send_list.len() && i != j ==> send_list[i] != send_list[j],\n    ensures\n        // Identity permutation takes n seconds\n        (stack@ == send_list@ ==> result == n),\n        // Reverse order takes at least as long as identity order\n        result >= m,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let result1 = min_time_to_send_presents(3, 3, vec![3, 1, 2], vec![3, 2, 1]);\n    // println!(\"Result 1: {}\", result1); // Should be 5\n    \n    // let result2 = min_time_to_send_presents(7, 2, vec![2, 1, 7, 3, 4, 5, 6], vec![3, 1]);\n    // println!(\"Result 2: {}\", result2); // Should be 8\n}"}
{"id": "fvapps_000093", "vc-description": "RedDreamer has an array a consisting of n non-negative integers, and an unlucky integer T.\n\nLet's denote the misfortune of array b having length m as f(b) — the number of pairs of integers (i, j) such that 1 ≤ i < j ≤ m and b_i + b_j = T. RedDreamer has to paint each element of a into one of two colors, white and black (for each element, the color is chosen independently), and then create two arrays c and d so that all white elements belong to c, and all black elements belong to d (it is possible that one of these two arrays becomes empty). RedDreamer wants to paint the elements in such a way that f(c) + f(d) is minimum possible.\n\nFor example:\n\n  if n = 6, T = 7 and a = [1, 2, 3, 4, 5, 6], it is possible to paint the 1-st, the 4-th and the 5-th elements white, and all other elements black. So c = [1, 4, 5], d = [2, 3, 6], and f(c) + f(d) = 0 + 0 = 0;  if n = 3, T = 6 and a = [3, 3, 3], it is possible to paint the 1-st element white, and all other elements black. So c = [3], d = [3, 3], and f(c) + f(d) = 0 + 1 = 1. \n\nHelp RedDreamer to paint the array optimally!", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_color_array(n: usize, t: usize, arr: Vec<usize>) -> (result: Vec<usize>)\n    requires \n        arr.len() == n,\n        n > 0,\n    ensures \n        result.len() == arr.len(),\n        forall|i: int| 0 <= i < result.len() ==> (result[i] == 0 || result[i] == 1),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000094", "vc-description": "You are given a integer $n$ ($n > 0$). Find any integer $s$ which satisfies these conditions, or report that there are no such numbers:\n\nIn the decimal representation of $s$:   $s > 0$,  $s$ consists of $n$ digits,  no digit in $s$ equals $0$,  $s$ is not divisible by any of it's digits. \n\n-----Input-----\n\nThe input consists of multiple test cases. The first line of the input contains a single integer $t$ ($1 \\leq t \\leq 400$), the number of test cases. The next $t$ lines each describe a test case.\n\nEach test case contains one positive integer $n$ ($1 \\leq n \\leq 10^5$).\n\nIt is guaranteed that the sum of $n$ for all test cases does not exceed $10^5$.\n\n-----Output-----\n\nFor each test case, print an integer $s$ which satisfies the conditions described above, or \"-1\" (without quotes), if no such number exists. If there are multiple possible solutions for $s$, print any solution.\n\n-----Example-----\nInput\n4\n1\n2\n3\n4\n\nOutput\n-1\n57\n239\n6789\n\n-----Note-----\n\nIn the first test case, there are no possible solutions for $s$ consisting of one digit, because any such solution is divisible by itself.\n\nFor the second test case, the possible solutions are: $23$, $27$, $29$, $34$, $37$, $38$, $43$, $46$, $47$, $49$, $53$, $54$, $56$, $57$, $58$, $59$, $67$, $68$, $69$, $73$, $74$, $76$, $78$, $79$, $83$, $86$, $87$, $89$, $94$, $97$, and $98$.\n\nFor the third test case, one possible solution is $239$ because $239$ is not divisible by $2$, $3$ or $9$ and has three digits (none of which equals zero).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn count_digits(n: int) -> nat;\n\nspec fn get_digit(n: int, pos: nat) -> nat;\n\nspec fn contains_zero_digit(n: int) -> bool;\n\nspec fn all_digits_nonzero(n: int) -> bool {\n    !contains_zero_digit(n)\n}\n\nspec fn not_divisible_by_any_digit(n: int) -> bool;\n\nfn solve_uneven_digit(n: nat) -> (result: i32)\n    requires n > 0,\n    ensures \n        (n == 1) ==> (result == -1),\n        (n == 2) ==> (result == 23),\n        (n > 1) ==> (result > 0),\n        (n > 1) ==> (count_digits(result as int) == n),\n        (n > 1) ==> all_digits_nonzero(result as int),\n        (n > 1) ==> not_divisible_by_any_digit(result as int)", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "/* Apps difficulty: interview */\n/* Assurance level: unguarded */\n\n}\n\nfn main() {\n    // #guard_msgs in\n    // #eval solve_uneven_digit 1\n\n    // #guard_msgs in  \n    // #eval len str(result)\n\n    // #guard_msgs in\n    // #eval len str(result)\n}"}
{"id": "fvapps_000096", "vc-description": "Your friend Jeff Zebos has been trying to run his new online company, but it's not going very well. He's not getting a lot of sales on his website which he decided to call Azamon. His big problem, you think, is that he's not ranking high enough on the search engines. If only he could rename his products to have better names than his competitors, then he'll be at the top of the search results and will be a millionaire.\n\nAfter doing some research, you find out that search engines only sort their results lexicographically. If your friend could rename his products to lexicographically smaller strings than his competitor's, then he'll be at the top of the rankings!\n\nTo make your strategy less obvious to his competitors, you decide to swap no more than two letters of the product names.\n\nPlease help Jeff to find improved names for his products that are lexicographically smaller than his competitor's!\n\nGiven the string $s$ representing Jeff's product name and the string $c$ representing his competitor's product name, find a way to swap at most one pair of characters in $s$ (that is, find two distinct indices $i$ and $j$ and swap $s_i$ and $s_j$) such that the resulting new name becomes strictly lexicographically smaller than $c$, or determine that it is impossible.\n\nNote: String $a$ is strictly lexicographically smaller than string $b$ if and only if one of the following holds:  $a$ is a proper prefix of $b$, that is, $a$ is a prefix of $b$ such that $a \\neq b$;  There exists an integer $1 \\le i \\le \\min{(|a|, |b|)}$ such that $a_i < b_i$ and $a_j = b_j$ for $1 \\le j < i$. \n\n-----Input-----\n\nThe first line of input contains a single integer $t$ ($1 \\le t \\le 1500$) denoting the number of test cases. The next lines contain descriptions of the test cases.\n\nEach test case consists of a single line containing two space-separated strings $s$ and $c$ ($2 \\le |s| \\le 5000, 1 \\le |c| \\le 5000$). The strings $s$ and $c$ consists of uppercase English letters.\n\nIt is guaranteed that the sum of $|s|$ in the input is at most $5000$ and the sum of the $|c|$ in the input is at most $5000$.\n\n-----Output-----\n\nFor each test case, output a single line containing a single string, which is either  the new name which is obtained after swapping no more than one pair of characters that is strictly lexicographically smaller than $c$. In case there are many possible such strings, you can output any of them;  three dashes (the string \"---\" without quotes) if it is impossible. \n\n-----Example-----\nInput\n3\nAZAMON APPLE\nAZAMON AAAAAAAAAAALIBABA\nAPPLE BANANA\n\nOutput\nAMAZON\n---\nAPPLE\n\n-----Note-----\n\nIn the first test case, it is possible to swap the second and the fourth letters of the string and the resulting string \"AMAZON\" is lexicographically smaller than \"APPLE\".\n\nIt is impossible to improve the product's name in the second test case and satisfy all conditions.\n\nIn the third test case, it is possible not to swap a pair of characters. The name \"APPLE\" is lexicographically smaller than \"BANANA\". Note that there are other valid answers, e.g., \"APPEL\".", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn improve_product_name(s: String, c: String) -> (result: String)\n    requires\n        s@.len() >= 2,\n        c@.len() >= 1,", "vc-code": "{\n    // impl-start\n    assume(false);\n    \"---\".to_string()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: unguarded\n\n    // println!(\"{}\", improve_product_name(\"AZAMON\".to_string(), \"APPLE\".to_string()));\n    // println!(\"{}\", improve_product_name(\"AZAMON\".to_string(), \"AAAAAAAAAAALIBABA\".to_string()));\n    // println!(\"{}\", improve_product_name(\"APPLE\".to_string(), \"BANANA\".to_string()));\n}"}
{"id": "fvapps_000097", "vc-description": "You may have already known that a standard ICPC team consists of exactly three members. The perfect team however has more restrictions. A student can have some specialization: coder or mathematician. She/he can have no specialization, but can't have both at the same time.\n\nSo the team is considered perfect if it includes at least one coder, at least one mathematician and it consists of exactly three members.\n\nYou are a coach at a very large university and you know that $c$ of your students are coders, $m$ are mathematicians and $x$ have no specialization.\n\nWhat is the maximum number of full perfect teams you can distribute them into? \n\nNote that some students can be left without a team and each student can be a part of no more than one team.\n\nYou are also asked to answer $q$ independent queries.\n\n-----Input-----\n\nThe first line contains a single integer $q$ ($1 \\le q \\le 10^4$) — the number of queries. \n\nEach of the next $q$ lines contains three integers $c$, $m$ and $x$ ($0 \\le c, m, x \\le 10^8$) — the number of coders, mathematicians and students without any specialization in the university, respectively.\n\nNote that the no student is both coder and mathematician at the same time. \n\n-----Output-----\n\nPrint $q$ integers — the $i$-th of them should be the answer to the $i$ query in the order they are given in the input. The answer is the maximum number of full perfect teams you can distribute your students into. \n\n-----Example-----\nInput\n6\n1 1 1\n3 6 0\n0 0 0\n0 1 1\n10 1 10\n4 4 1\n\nOutput\n1\n3\n0\n0\n1\n3\n\n-----Note-----\n\nIn the first example here are how teams are formed:  the only team of 1 coder, 1 mathematician and 1 without specialization;  all three teams consist of 1 coder and 2 mathematicians;  no teams can be formed;  no teams can be formed;  one team consists of 1 coder, 1 mathematician and 1 without specialization, the rest aren't able to form any team;  one team consists of 1 coder, 1 mathematician and 1 without specialization, one consists of 2 coders and 1 mathematician and one consists of 1 coder and 2 mathematicians.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn max_perfect_teams(c: nat, m: nat, x: nat) -> (result: nat)\n    ensures\n        result >= 0,\n        result <= c,\n        result <= m,\n        result * 3 <= c + m + x,\n        result == vstd::math::min(vstd::math::min(c as int, m as int), (c + m + x) as int / 3) as nat", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded_and_plausible\n\n    // assert_eq!(max_perfect_teams(1, 1, 1), 1);\n    // assert_eq!(max_perfect_teams(3, 6, 0), 3);\n    // assert_eq!(max_perfect_teams(0, 0, 0), 0);\n    // assert_eq!(max_perfect_teams(0, 1, 1), 0);\n}"}
{"id": "fvapps_000099", "vc-description": "You have three piles of candies: red, green and blue candies: the first pile contains only red candies and there are $r$ candies in it, the second pile contains only green candies and there are $g$ candies in it, the third pile contains only blue candies and there are $b$ candies in it. \n\nEach day Tanya eats exactly two candies of different colors. She is free to choose the colors of eaten candies: the only restriction that she can't eat two candies of the same color in a day.\n\nFind the maximal number of days Tanya can eat candies? Each day she needs to eat exactly two candies.\n\n-----Input-----\n\nThe first line contains integer $t$ ($1 \\le t \\le 1000$) — the number of test cases in the input. Then $t$ test cases follow.\n\nEach test case is given as a separate line of the input. It contains three integers $r$, $g$ and $b$ ($1 \\le r, g, b \\le 10^8$) — the number of red, green and blue candies, respectively.\n\n-----Output-----\n\nPrint $t$ integers: the $i$-th printed integer is the answer on the $i$-th test case in the input.\n\n-----Example-----\nInput\n6\n1 1 1\n1 2 1\n4 1 1\n7 4 10\n8 1 4\n8 2 8\n\nOutput\n1\n2\n2\n10\n5\n9\n\n-----Note-----\n\nIn the first example, Tanya can eat candies for one day only. She can eat any pair of candies this day because all of them have different colors.\n\nIn the second example, Tanya can eat candies for two days. For example, she can eat red and green candies on the first day, and green and blue candies on the second day.\n\nIn the third example, Tanya can eat candies for two days. For example, she can eat red and green candies on the first day, and red and blue candies on the second day. Note, that two red candies will remain uneaten.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_candies(r: nat, g: nat, b: nat) -> (result: nat)\n    ensures \n        result >= 0,\n        result <= r + g,\n        result <= r + b,\n        result <= g + b,\n        result <= (r + g + b) / 2,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded_and_plausible\n\n    // Tests for solve_candies function\n    // assert(solve_candies(1, 1, 1) == 1);\n    // assert(solve_candies(1, 2, 1) == 2);\n    // assert(solve_candies(7, 4, 10) == 10);\n}"}
{"id": "fvapps_000100", "vc-description": "Polycarp lives on the coordinate axis Ox and travels from the point x=a to x=b. It moves uniformly rectilinearly at a speed of one unit of distance per minute.\n\nOn the axis Ox at the point x=c the base station of the mobile operator is placed. It is known that the radius of its coverage is r. Thus, if Polycarp is at a distance less than or equal to r from the point x=c, then he is in the network coverage area, otherwise — no. The base station can be located both on the route of Polycarp and outside it.\n\nPrint the time in minutes during which Polycarp will not be in the coverage area of the network, with a rectilinear uniform movement from x=a to x=b. His speed — one unit of distance per minute.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn abs_spec(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\nspec fn max_spec(x: int, y: int) -> int {\n    if x >= y { x } else { y }\n}\n\nspec fn time_without_coverage_spec(a: int, b: int, c: int, r: int) -> int;", "vc-helpers": "", "vc-spec": "fn time_without_coverage(a: i32, b: i32, c: i32, r: i32) -> (result: i32)\n    ensures \n        result >= 0,\n        time_without_coverage_spec(a as int, b as int, c as int, r as int) == \n        time_without_coverage_spec(b as int, a as int, c as int, r as int)", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded_and_plausible\n\n    // Example test cases:\n    // time_without_coverage(1, 10, 7, 1) should return 7\n    // time_without_coverage(3, 3, 3, 0) should return 0\n    // time_without_coverage(8, 2, 10, 4) should return 4\n}"}
{"id": "fvapps_000101", "vc-description": "Hooray! Polycarp turned n years old! The Technocup Team sincerely congratulates Polycarp!\n\nPolycarp celebrated all of his n birthdays: from the 1-th to the n-th. At the moment, he is wondering: how many times he turned beautiful number of years?\n\nAccording to Polycarp, a positive integer is beautiful if it consists of only one digit repeated one or more times. For example, the following numbers are beautiful: 1, 77, 777, 44 and 999999. The following numbers are not beautiful: 12, 11110, 6969 and 987654321.\n\nOf course, Polycarpus uses the decimal numeral system (i.e. radix is 10).\n\nHelp Polycarpus to find the number of numbers from 1 to n (inclusive) that are beautiful.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_beautiful(x: nat) -> bool {\n    x > 0\n}\n\nspec fn count_beautiful_numbers_spec(n: nat) -> nat {\n    1\n}\n\nfn count_beautiful_numbers(n: u32) -> (result: u32)\n    requires n > 0,\n    ensures \n        1 <= result && result <= 81,\n        count_beautiful_numbers_spec(n as nat) == result as nat", "vc-code": "{\n    // impl-start\n    assume(false);\n    1u32\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded_and_plausible\n\n    // println!(\"{}\", count_beautiful_numbers(18)); // Should output 10\n    // println!(\"{}\", count_beautiful_numbers(9));  // Should output 9\n    // println!(\"{}\", count_beautiful_numbers(100500)); // Should output 45\n}"}
{"id": "fvapps_000103", "vc-description": "You are given a colored permutation p_1, p_2, ..., p_n. The i-th element of the permutation has color c_i.\n\nLet's define an infinite path as infinite sequence i, p[i], p[p[i]], p[p[p[i]]] ... where all elements have same color (c[i] = c[p[i]] = c[p[p[i]]] = ...).\n\nWe can also define a multiplication of permutations a and b as permutation c = a × b where c[i] = b[a[i]]. Moreover, we can define a power k of permutation p as p^k=p × p × ... × p (k times).\n\nFind the minimum k > 0 such that p^k has at least one infinite path (i.e. there is a position i in p^k such that the sequence starting from i is an infinite path).\n\nIt can be proved that the answer always exists.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn find_min_k_infinite_path(n: usize, perm: Vec<usize>, colors: Vec<usize>) -> (result: usize)\n    requires \n        n > 0,\n        perm.len() == n,\n        colors.len() == n,\n        forall|i: int| 0 <= i < n ==> #[trigger] perm[i] >= 1 && #[trigger] perm[i] <= n,\n        forall|i: int, j: int| 0 <= i < n && 0 <= j < n && i != j ==> #[trigger] perm[i] != #[trigger] perm[j],\n    ensures \n        result > 0,\n        result <= n,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "}\n\nfn main() {\n    // let test1_result = find_min_k_infinite_path(4, vec![1, 3, 4, 2], vec![1, 2, 2, 3]);\n    // assert(test1_result == 1);\n    \n    // let test2_result = find_min_k_infinite_path(5, vec![2, 3, 4, 5, 1], vec![1, 2, 3, 4, 5]);\n    // assert(test2_result == 5);\n    \n    // let test3_result = find_min_k_infinite_path(8, vec![7, 4, 5, 6, 1, 8, 3, 2], vec![5, 3, 6, 4, 7, 5, 8, 4]);\n    // assert(test3_result == 2);\n}"}
{"id": "fvapps_000106", "vc-description": "You're given an array a_1, ..., a_n of n non-negative integers.\n\nLet's call it sharpened if and only if there exists an integer 1 <= k <= n such that a_1 < a_2 < ... < a_k and a_k > a_{k+1} > ... > a_n. In particular, any strictly increasing or strictly decreasing array is sharpened. For example: The arrays [4], [0, 1], [12, 10, 8] and [3, 11, 15, 9, 7, 4] are sharpened; The arrays [2, 8, 2, 8, 6, 5], [0, 1, 1, 0] and [2, 5, 6, 9, 8, 8] are not sharpened.\n\nYou can do the following operation as many times as you want: choose any strictly positive element of the array, and decrease it by one. Formally, you can choose any i (1 <= i <= n) such that a_i>0 and assign a_i := a_i - 1.\n\nTell if it's possible to make the given array sharpened using some number (possibly zero) of these operations.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn is_array_sharpenable(n: usize, arr: Vec<i32>) -> (result: bool)\n    requires\n        n > 0,\n        arr.len() > 0,\n    ensures result == true || result == false,", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000109", "vc-description": "You are given an image, that can be represented with a 2-d n by m grid of pixels. Each pixel of the image is either on or off, denoted by the characters \"0\" or \"1\", respectively. You would like to compress this image. You want to choose an integer k > 1 and split the image into k by k blocks. If n and m are not divisible by k, the image is padded with only zeros on the right and bottom so that they are divisible by k. Each pixel in each individual block must have the same value. The given image may not be compressible in its current state. Find the minimum number of pixels you need to toggle (after padding) in order for the image to be compressible for some k. More specifically, the steps are to first choose k, then the image is padded with zeros, then, we can toggle the pixels so it is compressible for this k. The image must be compressible in that state.\n\n-----Input-----\n\nThe first line of input will contain two integers n, m (2 ≤ n, m ≤ 2 500), the dimensions of the image.\n\nThe next n lines of input will contain a binary string with exactly m characters, representing the image.\n\n-----Output-----\n\nPrint a single integer, the minimum number of pixels needed to toggle to make the image compressible.\n\n-----Example-----\nInput\n3 5\n00100\n10110\n11001\n\nOutput\n5\n\n-----Note-----\n\nWe first choose k = 2.\n\nThe image is padded as follows: \n\n001000\n\n101100\n\n110010\n\n000000\n\nWe can toggle the image to look as follows: \n\n001100\n\n001100\n\n000000\n\n000000\n\nWe can see that this image is compressible for k = 2.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn compress_image(m: usize, n: usize, grid: Seq<Seq<char>>) -> usize\n    decreases grid.len() + m + n\n{\n    0\n}", "vc-code": "proof fn compress_minimal_cases_2x2_perfect(grid: Seq<Seq<char>>)\n    requires \n        grid.len() == 2,\n        grid[0] == seq!['1', '1'],\n        grid[1] == seq!['1', '1'],\n    ensures compress_image(2, 2, grid) == 0\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn compress_minimal_cases_2x2_worst(grid: Seq<Seq<char>>)\n    requires\n        grid.len() == 2,\n        grid[0] == seq!['1', '0'],\n        grid[1] == seq!['0', '1'],\n    ensures compress_image(2, 2, grid) == 2\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn compress_minimal_cases_rect_2x3(grid: Seq<Seq<char>>)\n    requires\n        grid.len() == 2,\n        grid[0] == seq!['0', '1', '0'],\n        grid[1] == seq!['1', '0', '1'],\n    ensures compress_image(2, 3, grid) == 3\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn compress_minimal_cases_rect_3x2(grid: Seq<Seq<char>>)\n    requires\n        grid.len() == 3,\n        grid[0] == seq!['0', '1'],\n        grid[1] == seq!['1', '0'],\n        grid[2] == seq!['0', '1'],\n    ensures compress_image(3, 2, grid) == 3\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn compress_example_case(grid: Seq<Seq<char>>)\n    requires\n        grid.len() == 3,\n        grid[0] == seq!['0', '0', '1', '0', '0'],\n        grid[1] == seq!['1', '0', '1', '1', '0'],\n        grid[2] == seq!['1', '1', '0', '0', '1'],\n    ensures compress_image(3, 5, grid) == 5\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn compress_larger_3x3_all_ones(grid: Seq<Seq<char>>)\n    requires\n        grid.len() == 3,\n        grid[0] == seq!['1', '1', '1'],\n        grid[1] == seq!['1', '1', '1'],\n        grid[2] == seq!['1', '1', '1'],\n    ensures compress_image(3, 3, grid) == 0\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn compress_larger_3x3_all_zeros(grid: Seq<Seq<char>>)\n    requires\n        grid.len() == 3,\n        grid[0] == seq!['0', '0', '0'],\n        grid[1] == seq!['0', '0', '0'],\n        grid[2] == seq!['0', '0', '0'],\n    ensures compress_image(3, 3, grid) == 0\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn compress_larger_3x3_checkerboard(grid: Seq<Seq<char>>)\n    requires\n        grid.len() == 3,\n        grid[0] == seq!['1', '0', '1'],\n        grid[1] == seq!['0', '1', '0'],\n        grid[2] == seq!['1', '0', '1'],\n    ensures compress_image(3, 3, grid) == 4\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000111", "vc-description": "Bob watches TV every day. He always sets the volume of his TV to $b$. However, today he is angry to find out someone has changed the volume to $a$. Of course, Bob has a remote control that can change the volume.\n\nThere are six buttons ($-5, -2, -1, +1, +2, +5$) on the control, which in one press can either increase or decrease the current volume by $1$, $2$, or $5$. The volume can be arbitrarily large, but can never be negative. In other words, Bob cannot press the button if it causes the volume to be lower than $0$.\n\nAs Bob is so angry, he wants to change the volume to $b$ using as few button presses as possible. However, he forgets how to do such simple calculations, so he asks you for help. Write a program that given $a$ and $b$, finds the minimum number of presses to change the TV volume from $a$ to $b$.\n\n-----Input-----\n\nEach test contains multiple test cases. The first line contains the number of test cases $T$ ($1 \\le T \\le 1\\,000$). Then the descriptions of the test cases follow.\n\nEach test case consists of one line containing two integers $a$ and $b$ ($0 \\le a, b \\le 10^{9}$) — the current volume and Bob's desired volume, respectively.\n\n-----Output-----\n\nFor each test case, output a single integer — the minimum number of presses to change the TV volume from $a$ to $b$. If Bob does not need to change the volume (i.e. $a=b$), then print $0$.\n\n-----Example-----\nInput\n3\n4 0\n5 14\n3 9\n\nOutput\n2\n3\n2\n\n-----Note-----\n\nIn the first example, Bob can press the $-2$ button twice to reach $0$. Note that Bob can not press $-5$ when the volume is $4$ since it will make the volume negative. \n\nIn the second example, one of the optimal ways for Bob is to press the $+5$ twice, then press $-1$ once.\n\nIn the last example, Bob can press the $+5$ once, then press $+1$.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn min_button_presses(a: i32, b: i32) -> (result: i32)\n    requires a >= 0 && b >= 0,\n    ensures \n        result >= 0,\n        (a == b) ==> (result == 0),\n        result * 5 >= if a >= b { a - b } else { b - a },", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let test1 = min_button_presses(4, 0);\n    // println!(\"Test 1: {}\", test1); // Expected: 2\n    //\n    // let test2 = min_button_presses(5, 14);\n    // println!(\"Test 2: {}\", test2); // Expected: 3\n    //\n    // let test3 = min_button_presses(3, 9);\n    // println!(\"Test 3: {}\", test3); // Expected: 2\n}"}
{"id": "fvapps_000117", "vc-description": "Assume that you have k one-dimensional segments s_1, s_2, ... s_k (each segment is denoted by two integers — its endpoints). Then you can build the following graph on these segments. The graph consists of k vertexes, and there is an edge between the i-th and the j-th vertexes (i ≠ j) if and only if the segments s_i and s_j intersect (there exists at least one point that belongs to both of them).\n\nFor example, if s_1 = [1, 6], s_2 = [8, 20], s_3 = [4, 10], s_4 = [2, 13], s_5 = [17, 18], then the resulting graph is the following: [Image] \n\nA tree of size m is good if it is possible to choose m one-dimensional segments so that the graph built on these segments coincides with this tree.\n\nYou are given a tree, you have to find its good subtree with maximum possible size. Recall that a subtree is a connected subgraph of a tree.\n\nNote that you have to answer q independent queries.\n\n-----Input-----\n\nThe first line contains one integer q (1 ≤ q ≤ 15 · 10^4) — the number of the queries. \n\nThe first line of each query contains one integer n (2 ≤ n ≤ 3 · 10^5) — the number of vertices in the tree.\n\nEach of the next n - 1 lines contains two integers x and y (1 ≤ x, y ≤ n) denoting an edge between vertices x and y. It is guaranteed that the given graph is a tree.\n\nIt is guaranteed that the sum of all n does not exceed 3 · 10^5.\n\n-----Output-----\n\nFor each query print one integer — the maximum size of a good subtree of the given tree.\n\n-----Example-----\nInput\n1\n10\n1 2\n1 3\n1 4\n2 5\n2 6\n3 7\n3 8\n4 9\n4 10\n\nOutput\n8\n\n-----Note-----\n\nIn the first query there is a good subtree of size 8. The vertices belonging to this subtree are {9, 4, 10, 2, 5, 1, 6, 3}.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn find_max_good_subtree(n: usize, edges: Vec<(usize, usize)>) -> (result: usize)\n    requires \n        n > 0,\n        n <= 100000,\n        edges.len() == n - 1,\n    ensures \n        result > 0,\n        result <= n,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Example usage:\n    // let edges = vec![(1, 2), (1, 3), (1, 4), (2, 5), (2, 6), (3, 7), (3, 8), (4, 9), (4, 10)];\n    // let result = find_max_good_subtree(10, edges);\n    // println!(\"{}\", result); // Should output 8\n}"}
{"id": "fvapps_000118", "vc-description": "Ayoub thinks that he is a very smart person, so he created a function f(s), where s is a binary string (a string which contains only symbols \"0\" and \"1\"). The function f(s) is equal to the number of substrings in the string s that contains at least one symbol, that is equal to \"1\".\n\nMore formally, f(s) is equal to the number of pairs of integers (l, r), such that 1 ≤ l ≤ r ≤ |s| (where |s| is equal to the length of string s), such that at least one of the symbols s_l, s_{l+1}, ..., s_r is equal to \"1\". \n\nFor example, if s = \"01010\" then f(s) = 12, because there are 12 such pairs (l, r): (1, 2), (1, 3), (1, 4), (1, 5), (2, 2), (2, 3), (2, 4), (2, 5), (3, 4), (3, 5), (4, 4), (4, 5).\n\nAyoub also thinks that he is smarter than Mahmoud so he gave him two integers n and m and asked him this problem. For all binary strings s of length n which contains exactly m symbols equal to \"1\", find the maximum value of f(s).\n\nMahmoud couldn't solve the problem so he asked you for help. Can you help him? \n\nInput: The input consists of multiple test cases. The first line contains a single integer t (1 ≤ t ≤ 10^5) — the number of test cases. The description of the test cases follows. The only line for each test case contains two integers n, m (1 ≤ n ≤ 10^9, 0 ≤ m ≤ n) — the length of the string and the number of symbols equal to \"1\" in it.\n\nOutput: For every test case print one integer number — the maximum value of f(s) over all strings s of length n, which has exactly m symbols, equal to \"1\".", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn max_substring_value(n: u64, m: u64) -> (result: u64)\n    requires m <= n,\n    ensures\n        /* If m=0, result should be 0 */\n        m == 0 ==> result == 0,\n        /* If m=n, result should be triangular number */\n        m == n ==> result == n * (n + 1) / 2,\n        /* Output should be between 0 and triangular number */\n        0 <= result && result <= n * (n + 1) / 2,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // Test cases from the problem\n    // assert(max_substring_value(3, 1) == 4);\n    // assert(max_substring_value(3, 2) == 5);\n    // assert(max_substring_value(3, 3) == 6);\n    // assert(max_substring_value(4, 0) == 0);\n    // assert(max_substring_value(5, 2) == 12);\n}"}
{"id": "fvapps_000121", "vc-description": "Your music player contains N different songs and she wants to listen to L (not necessarily different) songs during your trip.  You create a playlist so that:\n\nEvery song is played at least once\nA song can only be played again only if K other songs have been played\n\nReturn the number of possible playlists.  As the answer can be very large, return it modulo 10^9 + 7.\n\nExample 1:\nInput: N = 3, L = 3, K = 1\nOutput: 6\nExplanation: There are 6 possible playlists. [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1].\n\nExample 2:\nInput: N = 2, L = 3, K = 0\nOutput: 6\nExplanation: There are 6 possible playlists. [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2, 1], [2, 1, 2], [1, 2, 2]\n\nExample 3:\nInput: N = 2, L = 3, K = 1\nOutput: 2\nExplanation: There are 2 possible playlists. [1, 2, 1], [2, 1, 2]\n\nNote:\n\n0 <= K < N <= L <= 100", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn num_music_playlists_spec(n: u32, l: u32, k: u32) -> u32;\n\nfn num_music_playlists(n: u32, l: u32, k: u32) -> (result: u32)\n    requires \n        n > 0,\n        l >= n,\n        k < n,\n    ensures \n        result < 1000000007,\n        result == num_music_playlists_spec(n, l, k),", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}\n\nproof fn playlists_bounds(n: u32, l: u32, k: u32) \n    requires \n        n > 0,\n        l >= n,\n        k < n,\n    ensures num_music_playlists_spec(n, l, k) < 1000000007\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn playlists_k_eq_n_minus_one(n: u32, l: u32, k: u32)\n    requires \n        n > 0,\n        l >= n,\n        k == n - 1,\n    ensures num_music_playlists_spec(n, l, k) > 0\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn playlists_trivial_cases_one_song()\n    ensures num_music_playlists_spec(1, 1, 0) == 1\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn playlists_impossible_cases_one()\n    ensures num_music_playlists_spec(1, 2, 1) == 0\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn playlists_impossible_cases_two()\n    ensures num_music_playlists_spec(2, 4, 2) == 0\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}", "vc-postamble": "\n}\n\nfn main() {\n    // println!(\"{}\", num_music_playlists(3, 3, 1)); // Expected: 6\n    // println!(\"{}\", num_music_playlists(2, 3, 0)); // Expected: 6\n    // println!(\"{}\", num_music_playlists(2, 3, 1)); // Expected: 2\n}"}
{"id": "fvapps_000122", "vc-description": "Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.\n\n(i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]).\n\nYou are given a target value to search. If found in the array return true, otherwise return false.\n\nExample 1:\n\nInput: nums = [2,5,6,0,0,1,2], target = 0\nOutput: true\n\nExample 2:\n\nInput: nums = [2,5,6,0,0,1,2], target = 3\nOutput: false\n\nFollow up:\n\n       This is a follow up problem to Search in Rotated Sorted Array, where nums may contain duplicates.\n       Would this affect the run-time complexity? How and why?", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn search(list: Vec<i32>, target: i32) -> (result: bool)\n    ensures result == list@.contains(target)", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "/* Apps difficulty: interview */\n/* Assurance level: unguarded */\n\n}\n\nfn main() {\n    // let result1 = search(vec![2, 5, 6, 0, 0, 1, 2], 0);\n    // println!(\"Result 1: {}\", result1); // Should be true\n    \n    // let result2 = search(vec![2, 5, 6, 0, 0, 1, 2], 3);\n    // println!(\"Result 2: {}\", result2); // Should be false\n    \n    // let result3 = search(vec![1], 1);\n    // println!(\"Result 3: {}\", result3); // Should be true\n}"}
{"id": "fvapps_000124", "vc-description": "Given a string s, return the maximum number of ocurrences of any substring under the following rules:\n\nThe number of unique characters in the substring must be less than or equal to maxLetters.\nThe substring size must be between minSize and maxSize inclusive.\n\nExample 1:\nInput: s = \"aababcaab\", maxLetters = 2, minSize = 3, maxSize = 4\nOutput: 2\nExplanation: Substring \"aab\" has 2 ocurrences in the original string.\nIt satisfies the conditions, 2 unique letters and size 3 (between minSize and maxSize).\n\nExample 2:\nInput: s = \"aaaa\", maxLetters = 1, minSize = 3, maxSize = 3\nOutput: 2\nExplanation: Substring \"aaa\" occur 2 times in the string. It can overlap.\n\nExample 3:\nInput: s = \"aabcabcab\", maxLetters = 2, minSize = 2, maxSize = 3\nOutput: 3\n\nExample 4:\nInput: s = \"abcde\", maxLetters = 2, minSize = 3, maxSize = 3\nOutput: 0\n\nConstraints:\n\n1 <= s.length <= 10^5\n1 <= maxLetters <= 26\n1 <= minSize <= maxSize <= min(26, s.length)\ns only contains lowercase English letters.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn max_freq(s: Vec<char>, max_letters: usize, min_size: usize, max_size: usize) -> (result: usize)\n    requires \n        min_size <= max_size,\n        min_size >= 1,\n        max_letters >= 1,\n        max_letters <= 26,\n        s.len() >= 1,\n        min_size <= s.len(),\n        max_size <= s.len(),\n    ensures\n        result <= s.len() - min_size + 1,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let s1: Vec<char> = \"aababcaab\".chars().collect();\n    // let result1 = max_freq(s1, 2, 3, 4);\n    // println!(\"Result 1: {}\", result1);\n    \n    // let s2: Vec<char> = \"aaaa\".chars().collect();\n    // let result2 = max_freq(s2, 1, 3, 3);\n    // println!(\"Result 2: {}\", result2);\n    \n    // let s3: Vec<char> = \"aabcabcab\".chars().collect();\n    // let result3 = max_freq(s3, 2, 2, 3);\n    // println!(\"Result 3: {}\", result3);\n}"}
{"id": "fvapps_000127", "vc-description": "Given an array A of positive integers, A[i] represents the value of the i-th sightseeing spot, and two sightseeing spots i and j have distance j - i between them.\nThe score of a pair (i < j) of sightseeing spots is (A[i] + A[j] + i - j) : the sum of the values of the sightseeing spots, minus the distance between them.\nReturn the maximum score of a pair of sightseeing spots.\n\nExample 1:\nInput: [8,1,5,2,6]\nOutput: 11\nExplanation: i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11\n\nNote:\n\n2 <= A.length <= 50000\n1 <= A[i] <= 1000", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn score_pair(values: Seq<u32>, i: int, j: int) -> int {\n    (values[i] as int) + (values[j] as int) + i - j\n}\n\nfn max_score_sightseeing_pair(values: Vec<u32>) -> (result: u32)\n    requires \n        values.len() >= 2,\n        forall|i: int| 0 <= i < values.len() ==> #[trigger] values[i] >= 1 && #[trigger] values[i] <= 1000,\n    ensures \n        values@ == seq![8u32, 1u32, 5u32, 2u32, 6u32] ==> result == 11u32,\n        values@ == seq![1u32, 2u32] ==> result == 2u32,\n        values@ == seq![5u32, 5u32, 5u32, 5u32] ==> result == 9u32,\n        values@ == seq![1u32, 1u32] ==> result == 1u32,", "vc-code": "{\n    // impl-start\n    assume(false);\n    0u32\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000129", "vc-description": "You are given a string expression representing a Lisp-like expression to return the integer value of.\n\nThe syntax for these expressions is given as follows.\n\nAn expression is either an integer, a let-expression, an add-expression, a mult-expression, or an assigned variable.  Expressions always evaluate to a single integer.\n\n(An integer could be positive or negative.)\n\nA let-expression takes the form (let v1 e1 v2 e2 ... vn en expr), where let is always the string \"let\", then there are 1 or more pairs of alternating variables and expressions, meaning that the first variable v1 is assigned the value of the expression e1, the second variable v2 is assigned the value of the expression e2, and so on sequentially; and then the value of this let-expression is the value of the expression expr.\n\nAn add-expression takes the form (add e1 e2) where add is always the string \"add\", there are always two expressions e1, e2, and this expression evaluates to the addition of the evaluation of e1 and the evaluation of e2.\n\nA mult-expression takes the form (mult e1 e2) where mult is always the string \"mult\", there are always two expressions e1, e2, and this expression evaluates to the multiplication of the evaluation of e1 and the evaluation of e2.\n\nFor the purposes of this question, we will use a smaller subset of variable names.  A variable starts with a lowercase letter, then zero or more lowercase letters or digits.  Additionally for your convenience, the names \"add\", \"let\", or \"mult\" are protected and will never be used as variable names.\n\nFinally, there is the concept of scope.  When an expression of a variable name is evaluated, within the context of that evaluation, the innermost scope (in terms of parentheses) is checked first for the value of that variable, and then outer scopes are checked sequentially.  It is guaranteed that every expression is legal.  Please see the examples for more details on scope.\n\nEvaluation Examples:\n\nInput: (add 1 2)\nOutput: 3\n\nInput: (mult 3 (add 2 3))\nOutput: 15\n\nInput: (let x 2 (mult x 5))\nOutput: 10\n\nInput: (let x 2 (mult x (let x 3 y 4 (add x y))))\nOutput: 14\nExplanation: In the expression (add x y), when checking for the value of the variable x,\nwe check from the innermost scope to the outermost in the context of the variable we are trying to evaluate.\nSince x = 3 is found first, the value of x is 3.\n\nInput: (let x 3 x 2 x)\nOutput: 2\nExplanation: Assignment in let statements is processed sequentially.\n\nInput: (let x 1 y 2 x (add x y) (add x y))\nOutput: 5\nExplanation: The first (add x y) evaluates as 3, and is assigned to x.\nThe second (add x y) evaluates as 3+2 = 5.\n\nInput: (let x 2 (add (let x 3 (let x 4 x)) x))\nOutput: 6\nExplanation: Even though (let x 4 x) has a deeper scope, it is outside the context\nof the final x in the add-expression.  That final x will equal 2.\n\nInput: (let a1 3 b2 (add a1 1) b2) \nOutput 4\nExplanation: Variable names can contain digits after the first character.\n\nNote:\nThe given string expression is well formatted: There are no leading or trailing spaces, there is only a single space separating different components of the string, and no space between adjacent parentheses.  The expression is guaranteed to be legal and evaluate to an integer.\nThe length of expression is at most 2000.  (It is also non-empty, as that would not be a legal expression.)\nThe answer and all intermediate calculations of that answer are guaranteed to fit in a 32-bit integer.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn evaluate_lisp(s: String) -> (result: i32)\n    requires s@.len() > 0 && s@.len() <= 2000,", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000130", "vc-description": "In a country popular for train travel, you have planned some train travelling one year in advance. The days of the year that you will travel is given as an array days. Each day is an integer from 1 to 365.\nTrain tickets are sold in 3 different ways:\n\na 1-day pass is sold for costs[0] dollars;\na 7-day pass is sold for costs[1] dollars;\na 30-day pass is sold for costs[2] dollars.\n\nThe passes allow that many days of consecutive travel. For example, if we get a 7-day pass on day 2, then we can travel for 7 days: day 2, 3, 4, 5, 6, 7, and 8.\nReturn the minimum number of dollars you need to travel every day in the given list of days.\n\nExample 1:\nInput: days = [1,4,6,7,8,20], costs = [2,7,15]\nOutput: 11\nExplanation: \nFor example, here is one way to buy passes that lets you travel your travel plan:\nOn day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1.\nOn day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9.\nOn day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20.\nIn total you spent $11 and covered all the days of your travel.\n\nExample 2:\nInput: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]\nOutput: 17\nExplanation: \nFor example, here is one way to buy passes that lets you travel your travel plan:\nOn day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, ..., 30.\nOn day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31.\nIn total you spent $17 and covered all the days of your travel.\n\nNote:\n\n1 <= days.length <= 365\n1 <= days[i] <= 365\ndays is in strictly increasing order.\ncosts.length == 3\n1 <= costs[i] <= 1000", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn min_cost_tickets(days: Vec<nat>, costs: Vec<nat>) -> (result: nat)\n    requires \n        days.len() > 0,\n        costs.len() == 3,\n        forall|i: int| 0 <= i < days.len() ==> #[trigger] days[i] >= 1 && #[trigger] days[i] <= 365,\n        forall|i: int| 0 <= i < costs.len() ==> #[trigger] costs[i] >= 1 && #[trigger] costs[i] <= 1000,\n        forall|i: int, j: int| 0 <= i < j < days.len() ==> #[trigger] days[i] < #[trigger] days[j],\n    ensures\n        result >= if costs[0] <= costs[1]/7 && costs[0] <= costs[2]/30 { costs[0] * days.len() } \n                  else if costs[1]/7 <= costs[2]/30 { (costs[1]/7) * days.len() }\n                  else { (costs[2]/30) * days.len() },\n        result <= costs[0] * days.len()", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // println!(\"{}\", min_cost_tickets(vec![1, 4, 6, 7, 8, 20], vec![2, 7, 15]));\n    // println!(\"{}\", min_cost_tickets(vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31], vec![2, 7, 15]));\n}"}
{"id": "fvapps_000132", "vc-description": "Given a positive integer N, return the number of positive integers less than or equal to N that have at least 1 repeated digit.\n\nExample 1:\nInput: 20\nOutput: 1\nExplanation: The only positive number (<= 20) with at least 1 repeated digit is 11.\n\nExample 2:\nInput: 100\nOutput: 10\nExplanation: The positive numbers (<= 100) with atleast 1 repeated digit are 11, 22, 33, 44, 55, 66, 77, 88, 99, and 100.\n\nExample 3:\nInput: 1000\nOutput: 262\n\nNote:\n\n1 <= N <= 10^9", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn count_numbers_with_repeated_digits(n: u32) -> (result: u32)\n    requires n > 0,\n    ensures \n        result <= n,\n        (n > 0 && n < 10) ==> result == 0,\n        n == 20 ==> result == 1,\n        n == 100 ==> result == 10,\n        n == 1000 ==> result == 262,", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let test1 = count_numbers_with_repeated_digits(20);\n    // assert(test1 == 1);\n    // let test2 = count_numbers_with_repeated_digits(100);\n    // assert(test2 == 10);\n    // let test3 = count_numbers_with_repeated_digits(1000);\n    // assert(test3 == 262);\n}"}
{"id": "fvapps_000133", "vc-description": "Given two sequences pushed and popped with distinct values, return true if and only if this could have been the result of a sequence of push and pop operations on an initially empty stack.\n\nExample 1:\nInput: pushed = [1,2,3,4,5], popped = [4,5,3,2,1]\nOutput: true\nExplanation: We might do the following sequence:\npush(1), push(2), push(3), push(4), pop() -> 4,\npush(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1\n\nExample 2:\nInput: pushed = [1,2,3,4,5], popped = [4,3,5,1,2]\nOutput: false\nExplanation: 1 cannot be popped before 2.\n\nConstraints:\n\n0 <= pushed.length == popped.length <= 1000\n0 <= pushed[i], popped[i] < 1000\npushed is a permutation of popped.\npushed and popped have distinct values.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn validate_stack_sequences(pushed: Vec<i32>, popped: Vec<i32>) -> (result: bool)", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "}\n\nfn main() {\n    // println!(\"{}\", validate_stack_sequences(vec![1, 2, 3, 4, 5], vec![4, 5, 3, 2, 1]));\n    // println!(\"{}\", validate_stack_sequences(vec![1, 2, 3, 4, 5], vec![4, 3, 5, 1, 2]));\n    // println!(\"{}\", validate_stack_sequences(vec![1, 2, 3], vec![1, 2, 3]));\n}"}
{"id": "fvapps_000135", "vc-description": "Given an integer n, you must transform it into 0 using the following operations any number of times:\n\nChange the rightmost (0th) bit in the binary representation of n.\nChange the ith bit in the binary representation of n if the (i-1)th bit is set to 1 and the (i-2)th through 0th bits are set to 0.\n\nReturn the minimum number of operations to transform n into 0.\n\nExample 1:\nInput: n = 0\nOutput: 0\n\nExample 2:\nInput: n = 3\nOutput: 2\nExplanation: The binary representation of 3 is \"11\".\n\"11\" -> \"01\" with the 2nd operation since the 0th bit is 1.\n\"01\" -> \"00\" with the 1st operation.\n\nExample 3:\nInput: n = 6\nOutput: 4\nExplanation: The binary representation of 6 is \"110\".\n\"110\" -> \"010\" with the 2nd operation since the 1st bit is 1 and 0th through 0th bits are 0.\n\"010\" -> \"011\" with the 1st operation.\n\"011\" -> \"001\" with the 2nd operation since the 0th bit is 1.\n\"001\" -> \"000\" with the 1st operation.\n\nExample 4:\nInput: n = 9\nOutput: 14\n\nExample 5:\nInput: n = 333\nOutput: 393\n\nConstraints:\n\n0 <= n <= 109", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn minimum_one_bit_operations(n: nat) -> (result: nat)\n    ensures \n        result >= 0,\n        (n == 0 ==> result == 0),\n        (n == 1 ==> result == 1),\n        (n == 2 ==> result == 3),\n        (n == 3 ==> result == 2),\n        (n == 4 ==> result == 7),\n        (n == 6 ==> result == 4),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: unguarded\n\n    // assert(minimum_one_bit_operations(0) == 0);\n    // assert(minimum_one_bit_operations(3) == 2);\n    // assert(minimum_one_bit_operations(6) == 4);\n}"}
{"id": "fvapps_000136", "vc-description": "Given an array of integers nums, find the maximum length of a subarray where the product of all its elements is positive.\nA subarray of an array is a consecutive sequence of zero or more values taken out of that array.\nReturn the maximum length of a subarray with positive product.\n\nExample 1:\nInput: nums = [1,-2,-3,4]\nOutput: 4\nExplanation: The array nums already has a positive product of 24.\n\nExample 2:\nInput: nums = [0,1,-2,-3,-4]\nOutput: 3\nExplanation: The longest subarray with positive product is [1,-2,-3] which has a product of 6.\nNotice that we cannot include 0 in the subarray since that'll make the product 0 which is not positive.\nExample 3:\nInput: nums = [-1,-2,-3,0,1]\nOutput: 2\nExplanation: The longest subarray with positive product is [-1,-2] or [-2,-3].\n\nExample 4:\nInput: nums = [-1,2]\nOutput: 1\n\nExample 5:\nInput: nums = [1,2,3,5,-6,4,0,10]\nOutput: 4\n\nConstraints:\n\n1 <= nums.length <= 10^5\n-10^9 <= nums[i] <= 10^9", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn get_max_len(nums: Vec<i32>) -> (result: usize)\n    ensures \n        result <= nums.len(),\n        (forall|x: i32| nums@.contains(x) && x == 0) ==> result == 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: unguarded\n\n    // assert(get_max_len(vec![1, -2, -3, 4]) == 4);\n    // assert(get_max_len(vec![0, 1, -2, -3, -4]) == 3);\n    // assert(get_max_len(vec![-1, -2, -3, 0, 1]) == 2);\n}"}
{"id": "fvapps_000138", "vc-description": "Given a non-empty array of numbers, a0, a1, a2, … , an-1, where 0 ≤ ai < 231.\n\nFind the maximum result of ai XOR aj, where 0 ≤ i, j < n.\n\nCould you do this in O(n) runtime?\n\nExample:\n\nInput: [3, 10, 5, 25, 2, 8]\n\nOutput: 28\n\nExplanation: The maximum result is 5 ^ 25 = 28.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn max_xor_brute_force(nums: Seq<u32>) -> u32 \n    decreases nums.len()\n{\n    if nums.len() <= 1 {\n        0\n    } else {\n        let max_rest = max_xor_brute_force(nums.skip(1));\n        let max_with_first = spec_max_xor_with_element(nums[0], nums.skip(1));\n        if max_with_first > max_rest { max_with_first } else { max_rest }\n    }\n}\n\nspec fn spec_max_xor_with_element(x: u32, nums: Seq<u32>) -> u32 \n    decreases nums.len()\n{\n    if nums.len() == 0 {\n        0\n    } else {\n        let current_xor = x ^ nums[0];\n        let rest_max = spec_max_xor_with_element(x, nums.skip(1));\n        if current_xor > rest_max { current_xor } else { rest_max }\n    }\n}\n\nfn find_maximum_xor(nums: Vec<u32>) -> (result: u32)\n    requires nums.len() > 0,\n    ensures \n        result <= max_xor_brute_force(nums@),\n        nums.len() == 1 ==> result == 0,\n        (exists|i: int, j: int| 0 <= i < nums.len() && 0 <= j < nums.len() && (nums[i] ^ nums[j]) == result) || result == 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000142", "vc-description": "Initially on a notepad only one character 'A' is present. You can perform two operations on this notepad for each step: \n\nCopy All: You can copy all the characters present on the notepad (partial copy is not allowed).\nPaste: You can paste the characters which are copied last time.\n\nGiven a number n. You have to get exactly n 'A' on the notepad by performing the minimum number of steps permitted. Output the minimum number of steps to get n 'A'. \n\nExample 1:\n\nInput: 3\nOutput: 3\nExplanation:\nIntitally, we have one character 'A'.\nIn step 1, we use Copy All operation.\nIn step 2, we use Paste operation to get 'AA'.\nIn step 3, we use Paste operation to get 'AAA'.\n\nNote:\n\nThe n will be in the range [1, 1000].", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_prime(n: nat) -> bool {\n    n >= 2 && forall|k: nat| 2 <= k < n ==> #[trigger] (n % k) != 0\n}\n\nfn min_steps(n: nat) -> (result: nat)\n    requires n >= 1\n    ensures \n        result >= 0 &&\n        (n >= 2 ==> result <= n) &&\n        (n == 1 ==> result == 0) &&\n        (n == 2 ==> result == 2) &&\n        (n == 4 ==> result == 4)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // #eval min_steps 3\n    // #eval min_steps 1  \n    // #eval min_steps 9\n}"}
{"id": "fvapps_000144", "vc-description": "Given an encoded string, return it's decoded string.\n\nThe encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.\n\nYou may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.\n\nFurthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won't be input like 3a or 2[4].\n\nExamples:\n\ns = \"3[a]2[bc]\", return \"aaabcbc\".\ns = \"3[a2[c]]\", return \"accaccacc\".\ns = \"2[abc]3[cd]ef\", return \"abcabccdcdcdef\".", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn string_contains_char(s: Seq<char>, c: char) -> bool {\n    exists|i: int| 0 <= i < s.len() && s[i] == c\n}\n\nspec fn is_alpha_char(c: char) -> bool;", "vc-spec": "fn decode_string(s: &str) -> (result: String)\n    ensures\n        forall|c: char| string_contains_char(result@, c) ==> is_alpha_char(c),\n        forall|c: char| string_contains_char(result@, c) ==>\n            exists|c_orig: char| string_contains_char(s@, c_orig) && c == c_orig && is_alpha_char(c_orig)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "}\nfn main() {\n    // println!(\"{}\", decode_string(\"3[a]2[bc]\"));\n    // println!(\"{}\", decode_string(\"3[a2[c]]\"));\n    // println!(\"{}\", decode_string(\"2[abc]3[cd]ef\"));\n}"}
{"id": "fvapps_000146", "vc-description": "We have jobs: difficulty[i] is the difficulty of the ith job, and profit[i] is the profit of the ith job. \nNow we have some workers. worker[i] is the ability of the ith worker, which means that this worker can only complete a job with difficulty at most worker[i]. \nEvery worker can be assigned at most one job, but one job can be completed multiple times.\nFor example, if 3 people attempt the same job that pays $1, then the total profit will be $3.  If a worker cannot complete any job, his profit is $0.\nWhat is the most profit we can make?\nExample 1:\nInput: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]\nOutput: 100 \nExplanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get profit of [20,20,30,30] seperately.\nNotes:\n\n1 <= difficulty.length = profit.length <= 10000\n1 <= worker.length <= 10000\ndifficulty[i], profit[i], worker[i]  are in range [1, 10^5]", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn max_profit_in_list(profit: Seq<i32>) -> i32\n    decreases profit.len()\n{\n    if profit.len() == 0 {\n        0\n    } else {\n        if profit[0] > max_profit_in_list(profit.skip(1)) {\n            profit[0]\n        } else {\n            max_profit_in_list(profit.skip(1))\n        }\n    }\n}\n\nfn max_profit_assignment(difficulty: Vec<i32>, profit: Vec<i32>, worker: Vec<i32>) -> (result: i32)\n    requires \n        difficulty.len() == profit.len(),\n        forall|i: int| 0 <= i < difficulty.len() ==> 1 <= difficulty[i] && difficulty[i] <= 100000,\n        forall|i: int| 0 <= i < profit.len() ==> 1 <= profit[i] && profit[i] <= 100000,\n        forall|i: int| 0 <= i < worker.len() ==> 1 <= worker[i] && worker[i] <= 100000,\n    ensures \n        result >= 0,\n        result <= max_profit_in_list(profit@) * (worker.len() as i32),\n        (forall|i: int| 0 <= i < worker.len() ==> worker[i] == 0) ==> result == 0,\n        (forall|i: int| 0 <= i < worker.len() ==> worker[i] >= 100) ==> \n            result == (worker.len() as i32) * max_profit_in_list(profit@)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = max_profit_assignment(vec![2, 4, 6, 8, 10], vec![10, 20, 30, 40, 50], vec![4, 5, 6, 7]);\n    // println!(\"{}\", result1); // Expected: 100\n\n    // let result2 = max_profit_assignment(vec![1, 2, 3], vec![10, 20, 30], vec![1, 2]);  \n    // println!(\"{}\", result2); // Expected: 30\n\n    // let result3 = max_profit_assignment(vec![5], vec![100], vec![1, 2, 3]);\n    // println!(\"{}\", result3); // Expected: 0\n}"}
{"id": "fvapps_000147", "vc-description": "Given a string s, a k duplicate removal consists of choosing k adjacent and equal letters from s and removing them causing the left and the right side of the deleted substring to concatenate together.\nWe repeatedly make k duplicate removals on s until we no longer can.\nReturn the final string after all such duplicate removals have been made.\nIt is guaranteed that the answer is unique.\n\nExample 1:\nInput: s = \"abcd\", k = 2\nOutput: \"abcd\"\nExplanation: There's nothing to delete.\nExample 2:\nInput: s = \"deeedbbcccbdaa\", k = 3\nOutput: \"aa\"\nExplanation: \nFirst delete \"eee\" and \"ccc\", get \"ddbbbdaa\"\nThen delete \"bbb\", get \"dddaa\"\nFinally delete \"ddd\", get \"aa\"\nExample 3:\nInput: s = \"pbbcggttciiippooaais\", k = 2\nOutput: \"ps\"\n\nConstraints:\n\n1 <= s.length <= 10^5\n2 <= k <= 10^4\ns only contains lower case English letters.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn remove_duplicates_spec(s: Seq<char>, k: int) -> Seq<char>;", "vc-spec": "fn remove_duplicates(s: Vec<char>, k: usize) -> (result: Vec<char>)\n    requires \n        s.len() >= 1,\n        k >= 2,\n        k <= 10000,\n    ensures\n        result.len() <= s.len(),\n        forall|c: char| result@.contains(c) ==> s@.contains(c),\n        remove_duplicates_spec(result@, k as int) == result@,\n        s.len() == 0 ==> result.len() == 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let s1: Vec<char> = \"abcd\".chars().collect();\n    // let result1 = remove_duplicates(s1, 2);\n    // println!(\"{:?}\", result1);\n    \n    // let s2: Vec<char> = \"deeedbbcccbdaa\".chars().collect();\n    // let result2 = remove_duplicates(s2, 3);\n    // println!(\"{:?}\", result2);\n    \n    // let s3: Vec<char> = \"pbbcggttciiippooaais\".chars().collect();\n    // let result3 = remove_duplicates(s3, 2);\n    // println!(\"{:?}\", result3);\n}"}
{"id": "fvapps_000152", "vc-description": "Given a rectangular cake with height h and width w, and two arrays of integers horizontalCuts and verticalCuts where horizontalCuts[i] is the distance from the top of the rectangular cake to the ith horizontal cut and similarly, verticalCuts[j] is the distance from the left of the rectangular cake to the jth vertical cut.\nReturn the maximum area of a piece of cake after you cut at each horizontal and vertical position provided in the arrays horizontalCuts and verticalCuts. Since the answer can be a huge number, return this modulo 10^9 + 7.\n\nExample 1:\n\nInput: h = 5, w = 4, horizontalCuts = [1,2,4], verticalCuts = [1,3]\nOutput: 4 \nExplanation: The figure above represents the given rectangular cake. Red lines are the horizontal and vertical cuts. After you cut the cake, the green piece of cake has the maximum area.\n\nExample 2:\n\nInput: h = 5, w = 4, horizontalCuts = [3,1], verticalCuts = [1]\nOutput: 6\nExplanation: The figure above represents the given rectangular cake. Red lines are the horizontal and vertical cuts. After you cut the cake, the green and yellow pieces of cake have the maximum area.\n\nExample 3:\nInput: h = 5, w = 4, horizontalCuts = [3], verticalCuts = [3]\nOutput: 9\n\nConstraints:\n\n2 <= h, w <= 10^9\n1 <= horizontalCuts.length < min(h, 10^5)\n1 <= verticalCuts.length < min(w, 10^5)\n1 <= horizontalCuts[i] < h\n1 <= verticalCuts[i] < w\nIt is guaranteed that all elements in horizontalCuts are distinct.\nIt is guaranteed that all elements in verticalCuts are distinct.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "const MOD: u64 = 1_000_000_007;\n\nfn max_area(h: u64, w: u64, horizontal_cuts: Vec<u64>, vertical_cuts: Vec<u64>) -> (result: u64)\n    requires \n        h >= 2,\n        w >= 2,\n        horizontal_cuts.len() >= 1,\n        vertical_cuts.len() >= 1,\n    ensures \n        result < MOD,", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = max_area(5, 4, vec![1, 2, 4], vec![1, 3]);\n    // println!(\"Result 1: {}\", result1); // Expected: 4\n    \n    // let result2 = max_area(5, 4, vec![3, 1], vec![1]);\n    // println!(\"Result 2: {}\", result2); // Expected: 6\n    \n    // let result3 = max_area(5, 4, vec![3], vec![3]);\n    // println!(\"Result 3: {}\", result3); // Expected: 9\n}"}
{"id": "fvapps_000153", "vc-description": "Given an array of integers arr and an integer d. In one step you can jump from index i to index:\n\ni + x where: i + x < arr.length and  0 < x <= d.\ni - x where: i - x >= 0 and  0 < x <= d.\n\nIn addition, you can only jump from index i to index j if arr[i] > arr[j] and arr[i] > arr[k] for all indices k between i and j (More formally min(i, j) < k < max(i, j)).\nYou can choose any index of the array and start jumping. Return the maximum number of indices you can visit.\nNotice that you can not jump outside of the array at any time.\n\nExample 1:\n\nInput: arr = [6,4,14,6,8,13,9,7,10,6,12], d = 2\nOutput: 4\nExplanation: You can start at index 10. You can jump 10 --> 8 --> 6 --> 7 as shown.\nNote that if you start at index 6 you can only jump to index 7. You cannot jump to index 5 because 13 > 9. You cannot jump to index 4 because index 5 is between index 4 and 6 and 13 > 9.\nSimilarly You cannot jump from index 3 to index 2 or index 1.\n\nExample 2:\nInput: arr = [3,3,3,3,3], d = 3\nOutput: 1\nExplanation: You can start at any index. You always cannot jump to any index.\n\nExample 3:\nInput: arr = [7,6,5,4,3,2,1], d = 1\nOutput: 7\nExplanation: Start at index 0. You can visit all the indicies. \n\nExample 4:\nInput: arr = [7,1,7,1,7,1], d = 2\nOutput: 2\n\nExample 5:\nInput: arr = [66], d = 1\nOutput: 1\n\nConstraints:\n\n1 <= arr.length <= 1000\n1 <= arr[i] <= 10^5\n1 <= d <= arr.length", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn max_jumps(arr: Vec<i32>, d: usize) -> (result: usize)\n    requires\n        arr.len() >= 1,\n        arr.len() <= 1000,\n        forall|i: int| 0 <= i < arr.len() ==> 1 <= arr[i] && arr[i] <= 100000,\n        d >= 1 && d <= arr.len(),\n    ensures\n        result >= 1 && result <= arr.len(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = max_jumps(vec![6, 4, 14, 6, 8, 13, 9, 7, 10, 6, 12], 2);\n    // println!(\"Example 1 result: {}\", result1); // Expected: 4\n    \n    // let result2 = max_jumps(vec![3, 3, 3, 3, 3], 3);\n    // println!(\"Example 2 result: {}\", result2); // Expected: 1\n    \n    // let result3 = max_jumps(vec![7, 6, 5, 4, 3, 2, 1], 1);\n    // println!(\"Example 3 result: {}\", result3); // Expected: 7\n}"}
{"id": "fvapps_000155", "vc-description": "Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*'.\n\n'?' Matches any single character.\n'*' Matches any sequence of characters (including the empty sequence).\n\nThe matching should cover the entire input string (not partial).\n\nNote:\n\n       s could be empty and contains only lowercase letters a-z.\n       p could be empty and contains only lowercase letters a-z, and characters like ? or *.\n\nExample 1:\n\nInput:\ns = \"aa\"\np = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\n\nExample 2:\n\nInput:\ns = \"aa\"\np = \"*\"\nOutput: true\nExplanation: '*' matches any sequence.\n\nExample 3:\n\nInput:\ns = \"cb\"\np = \"?a\"\nOutput: false\nExplanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.\n\nExample 4:\n\nInput:\ns = \"adceb\"\np = \"*a*b\"\nOutput: true\nExplanation: The first '*' matches the empty sequence, while the second '*' matches the substring \"dce\".\n\nExample 5:\n\nInput:\ns = \"acdcb\"\np = \"a*c?b\"\nOutput: false", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn is_match(s: &str, p: &str) -> (result: bool)\n    ensures \n        (p == \"\" ==> result == (s == \"\")),\n        (p == \"*\" ==> result == true),\n        (p == \"**\" ==> result == true),\n        (s == p ==> result == true)", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "}\n\nfn main() {\n    // println!(\"{}\", is_match(\"aa\", \"a\"));\n    // println!(\"{}\", is_match(\"aa\", \"*\"));\n    // println!(\"{}\", is_match(\"adceb\", \"*a*b\"));\n}"}
{"id": "fvapps_000156", "vc-description": "Given an integer array nums and an integer k, return the maximum sum of a non-empty subsequence of that array such that for every two consecutive integers in the subsequence, nums[i] and nums[j], where i < j, the condition j - i <= k is satisfied.\nA subsequence of an array is obtained by deleting some number of elements (can be zero) from the array, leaving the remaining elements in their original order.\n\nExample 1:\nInput: nums = [10,2,-10,5,20], k = 2\nOutput: 37\nExplanation: The subsequence is [10, 2, 5, 20].\n\nExample 2:\nInput: nums = [-1,-2,-3], k = 1\nOutput: -1\nExplanation: The subsequence must be non-empty, so we choose the largest number.\n\nExample 3:\nInput: nums = [10,-2,-10,-5,20], k = 2\nOutput: 23\nExplanation: The subsequence is [10, -2, -5, 20].\n\nConstraints:\n\n1 <= k <= nums.length <= 10^5\n-10^4 <= nums[i] <= 10^4", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn constrained_max_subset_sum(nums: Vec<i32>, k: usize) -> (result: i32)\n    requires \n        nums.len() > 0,\n        k > 0,\n        k <= nums.len(),\n    ensures \n        exists|x: i32| nums@.contains(x) && result >= x,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: unguarded\n\n    // println!(\"{}\", constrained_max_subset_sum(vec![10, 2, -10, 5, 20], 2));\n    // println!(\"{}\", constrained_max_subset_sum(vec![-1, -2, -3], 1));\n    // println!(\"{}\", constrained_max_subset_sum(vec![10, -2, -10, -5, 20], 2));\n}"}
{"id": "fvapps_000157", "vc-description": "Alex and Lee play a game with piles of stones. There are an even number of piles arranged in a row, and each pile has a positive integer number of stones piles[i].\nThe objective of the game is to end with the most stones. The total number of stones is odd, so there are no ties.\nAlex and Lee take turns, with Alex starting first. Each turn, a player takes the entire pile of stones from either the beginning or the end of the row. This continues until there are no more piles left, at which point the person with the most stones wins.\nAssuming Alex and Lee play optimally, return True if and only if Alex wins the game.\n\nExample 1:\nInput: piles = [5,3,4,5]\nOutput: true\nExplanation: \nAlex starts first, and can only take the first 5 or the last 5.\nSay he takes the first 5, so that the row becomes [3, 4, 5].\nIf Lee takes 3, then the board is [4, 5], and Alex takes 5 to win with 10 points.\nIf Lee takes the last 5, then the board is [3, 4], and Alex takes 4 to win with 9 points.\nThis demonstrated that taking the first 5 was a winning move for Alex, so we return true.\n\nConstraints:\n\n2 <= piles.length <= 500\npiles.length is even.\n1 <= piles[i] <= 500\nsum(piles) is odd.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn stone_game(piles: Vec<usize>) -> (result: bool)\n    requires \n        piles.len() >= 2,\n        piles.len() % 2 == 0,\n        forall|i: int| 0 <= i < piles.len() ==> piles[i] > 0,\n    ensures result == true", "vc-code": "{\n    // impl-start\n    assume(false);\n    true\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = stone_game(vec![5, 3, 4, 5]);\n    // println!(\"stone_game([5, 3, 4, 5]) = {}\", result1);\n    \n    // let result2 = stone_game(vec![3, 7, 2, 3]);\n    // println!(\"stone_game([3, 7, 2, 3]) = {}\", result2);\n    \n    // let result3 = stone_game(vec![1, 2, 3, 4]);\n    // println!(\"stone_game([1, 2, 3, 4]) = {}\", result3);\n}"}
{"id": "fvapps_000158", "vc-description": "One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node's value. If it is a null node, we record using a sentinel value such as #.\n\n     _9_\n    /   \\\n   3     2\n  / \\   / \\\n 4   1  #  6\n/ \\ / \\   / \\\n# # # #   # #\n\nFor example, the above binary tree can be serialized to the string \"9,3,4,#,#,1,#,#,2,#,6,#,#\", where # represents a null node.\n\nGiven a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree. Find an algorithm without reconstructing the tree.\n\nEach comma separated value in the string must be either an integer or a character '#' representing null pointer.\n\nYou may assume that the input format is always valid, for example it could never contain two consecutive commas such as \"1,,3\".\n\nExample 1:\n\nInput: \"9,3,4,#,#,1,#,#,2,#,6,#,#\"\nOutput: true\n\nExample 2:\n\nInput: \"1,#\"\nOutput: false\n\nExample 3:\n\nInput: \"9,#,#,1\"\nOutput: false", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn is_valid_serialization(s: &str) -> (result: bool)", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: unguarded\n\n    // #eval is_valid_serialization \"9,3,4,#,#,1,#,#,2,#,6,#,#\"\n    // Expected: true\n\n    // #eval is_valid_serialization \"1,#\"\n    // Expected: false\n\n    // #eval is_valid_serialization \"9,#,#,1\"\n    // Expected: false\n}"}
{"id": "fvapps_000159", "vc-description": "Given two strings text1 and text2, return the length of their longest common subsequence.\nA subsequence of a string is a new string generated from the original string with some characters(can be none) deleted without changing the relative order of the remaining characters. (eg, \"ace\" is a subsequence of \"abcde\" while \"aec\" is not). A common subsequence of two strings is a subsequence that is common to both strings.\n\nIf there is no common subsequence, return 0.\n\nExample 1:\nInput: text1 = \"abcde\", text2 = \"ace\" \nOutput: 3  \nExplanation: The longest common subsequence is \"ace\" and its length is 3.\n\nExample 2:\nInput: text1 = \"abc\", text2 = \"abc\"\nOutput: 3\nExplanation: The longest common subsequence is \"abc\" and its length is 3.\n\nExample 3:\nInput: text1 = \"abc\", text2 = \"def\"\nOutput: 0\nExplanation: There is no such common subsequence, so the result is 0.\n\nConstraints:\n\n1 <= text1.length <= 1000\n1 <= text2.length <= 1000\nThe input strings consist of lowercase English characters only.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn longest_common_subsequence(s1: Vec<char>, s2: Vec<char>) -> (result: usize)\n    requires \n        1 <= s1.len() <= 1000,\n        1 <= s2.len() <= 1000,\n    ensures \n        result <= s1.len(),\n        result <= s2.len(),\n        s1.len() == 0 || s2.len() == 0 ==> result == 0,\n        s1 == s2 ==> result == s1.len(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "}\nfn main() {\n    // let s1 = vec!['a', 'b', 'c', 'd', 'e'];\n    // let s2 = vec!['a', 'c', 'e'];\n    // let result1 = longest_common_subsequence(s1, s2);\n    // println!(\"Result 1: {}\", result1); // Should be 3\n    \n    // let s3 = vec!['a', 'b', 'c'];\n    // let s4 = vec!['a', 'b', 'c'];\n    // let result2 = longest_common_subsequence(s3, s4);\n    // println!(\"Result 2: {}\", result2); // Should be 3\n    \n    // let s5 = vec!['a', 'b', 'c'];\n    // let s6 = vec!['d', 'e', 'f'];\n    // let result3 = longest_common_subsequence(s5, s6);\n    // println!(\"Result 3: {}\", result3); // Should be 0\n}"}
{"id": "fvapps_000160", "vc-description": "Given a string s and a string t, check if s is subsequence of t.\n\nYou may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and s is a short string (\n\nA subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, \"ace\" is a subsequence of \"abcde\" while \"aec\" is not).\n\nExample 1:\ns = \"abc\", t = \"ahbgdc\"\n\nReturn true.\n\nExample 2:\ns = \"axc\", t = \"ahbgdc\"\n\nReturn false.\n\nFollow up:\nIf there are lots of incoming S, say S1, S2, ... , Sk where k >= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code?\n\nCredits:Special thanks to @pbrother for adding this problem and creating all test cases.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn is_subsequence(s: Vec<u8>, t: Vec<u8>) -> (result: bool)\n    ensures\n        s.len() == 0 ==> result == true,\n        s@ == t@ ==> result == true,\n        s.len() > t.len() ==> result == false,", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "/* Apps difficulty: interview\n   Assurance level: unguarded */\n\n}\n\nfn main() {\n    // let s1 = \"abc\".as_bytes().to_vec();\n    // let t1 = \"ahbgdc\".as_bytes().to_vec();\n    // println!(\"{}\", is_subsequence(s1, t1));\n    // \n    // let s2 = \"axc\".as_bytes().to_vec();\n    // let t2 = \"ahbgdc\".as_bytes().to_vec();\n    // println!(\"{}\", is_subsequence(s2, t2));\n    // \n    // let s3 = \"\".as_bytes().to_vec();\n    // let t3 = \"ahbgdc\".as_bytes().to_vec();\n    // println!(\"{}\", is_subsequence(s3, t3));\n}"}
{"id": "fvapps_000162", "vc-description": "Given a string and a string dictionary, find the longest string in the dictionary that can be formed by deleting some characters of the given string. If there are more than one possible results, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.\n\nExample 1:\n\nInput:\ns = \"abpcplea\", d = [\"ale\",\"apple\",\"monkey\",\"plea\"]\n\nOutput: \n\"apple\"\n\nExample 2:\n\nInput:\ns = \"abpcplea\", d = [\"a\",\"b\",\"c\"]\n\nOutput: \n\"a\"\n\nNote:\n\nAll the strings in the input will only contain lower-case letters.\nThe size of the dictionary won't exceed 1,000.\nThe length of all the strings in the input won't exceed 1,000.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn is_subsequence(sub: Seq<char>, word: Seq<char>) -> bool\n    decreases word.len()\n{\n    if sub.len() == 0 {\n        true\n    } else if word.len() == 0 {\n        false\n    } else if sub[0] == word[0] {\n        is_subsequence(sub.skip(1), word.skip(1))\n    } else {\n        is_subsequence(sub, word.skip(1))\n    }\n}\n\nspec fn seq_lex_lt(s1: Seq<char>, s2: Seq<char>) -> bool\n    decreases s1.len() + s2.len()\n{\n    if s1.len() == 0 && s2.len() == 0 {\n        false\n    } else if s1.len() == 0 {\n        true\n    } else if s2.len() == 0 {\n        false\n    } else if s1[0] < s2[0] {\n        true\n    } else if s1[0] > s2[0] {\n        false\n    } else {\n        seq_lex_lt(s1.skip(1), s2.skip(1))\n    }\n}", "vc-spec": "fn is_subsequence_fn(sub: &str, word: &str) -> (result: bool)\n    ensures result == is_subsequence(sub@, word@)\n{\n    assume(false);\n    false\n}\n\nfn find_longest_word(s: &str, dict: Vec<String>) -> (result: String)\n    ensures\n        s@.len() == 0 ==> result@ == Seq::<char>::empty(),\n        dict@.len() == 0 ==> result@ == Seq::<char>::empty(),\n        result@.len() == 0 || (exists|i: int| 0 <= i < dict@.len() && dict@[i]@ == result@),\n        result@.len() == 0 || is_subsequence(result@, s@),\n        forall|i: int| 0 <= i < dict@.len() ==> \n            dict@[i]@.len() > result@.len() ==> \n                !is_subsequence(dict@[i]@, s@),\n        forall|i: int| 0 <= i < dict@.len() ==> \n            (dict@[i]@.len() == result@.len() && seq_lex_lt(dict@[i]@, result@)) ==> \n                !is_subsequence(dict@[i]@, s@)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "}\n\nfn main() {\n    // let result1 = find_longest_word(\"abpcplea\", vec![\"ale\".to_string(), \"apple\".to_string(), \"monkey\".to_string(), \"plea\".to_string()]);\n    // println!(\"{}\", result1); // Should print \"apple\"\n    \n    // let result2 = find_longest_word(\"abpcplea\", vec![\"a\".to_string(), \"b\".to_string(), \"c\".to_string()]);\n    // println!(\"{}\", result2); // Should print \"a\"\n    \n    // let result3 = find_longest_word(\"aaa\", vec![\"aaa\".to_string(), \"aa\".to_string(), \"a\".to_string()]);\n    // println!(\"{}\", result3); // Should print \"aaa\"\n}"}
{"id": "fvapps_000164", "vc-description": "You are given K eggs, and you have access to a building with N floors from 1 to N. \nEach egg is identical in function, and if an egg breaks, you cannot drop it again.\nYou know that there exists a floor F with 0 <= F <= N such that any egg dropped at a floor higher than F will break, and any egg dropped at or below floor F will not break.\nEach move, you may take an egg (if you have an unbroken one) and drop it from any floor X (with 1 <= X <= N). \nYour goal is to know with certainty what the value of F is.\nWhat is the minimum number of moves that you need to know with certainty what F is, regardless of the initial value of F?\n\nExample 1:\nInput: K = 1, N = 2\nOutput: 2\nExplanation: \nDrop the egg from floor 1.  If it breaks, we know with certainty that F = 0.\nOtherwise, drop the egg from floor 2.  If it breaks, we know with certainty that F = 1.\nIf it didn't break, then we know with certainty F = 2.\nHence, we needed 2 moves in the worst case to know what F is with certainty.\n\nExample 2:\nInput: K = 2, N = 6\nOutput: 3\n\nExample 3:\nInput: K = 3, N = 14\nOutput: 4\n\nNote:\n\n1 <= K <= 100\n1 <= N <= 10000", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn super_egg_drop(k: u32, n: u32) -> (result: u32)\n    requires \n        k > 0,\n        n > 0,\n    ensures \n        result > 0,\n        result <= n,\n        k == 1 ==> result == n,", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = super_egg_drop(1, 2);\n    // println!(\"super_egg_drop(1, 2) = {}\", result1);\n    \n    // let result2 = super_egg_drop(2, 6);\n    // println!(\"super_egg_drop(2, 6) = {}\", result2);\n    \n    // let result3 = super_egg_drop(3, 14);\n    // println!(\"super_egg_drop(3, 14) = {}\", result3);\n}"}
{"id": "fvapps_000166", "vc-description": "Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get.\n\nFor example, given n = 2, return 1 (2 = 1 + 1); given n = 10, return 36 (10 = 3 + 3 + 4).\n\nNote: You may assume that n is not less than 2 and not larger than 58.\n\nCredits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn integer_break(n: nat) -> (result: nat)\n    requires n >= 2\n    ensures \n        result > 0,\n        n >= 4 ==> result >= n,\n        n == 2 ==> result == 1,\n        n == 3 ==> result == 2", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded\n\n    // #guard_msgs in\n    // #eval integer_break 2\n\n    // #guard_msgs in  \n    // #eval integer_break 10\n\n    // #guard_msgs in\n    // #eval integer_break 8\n}"}
{"id": "fvapps_000171", "vc-description": "Suppose we abstract our file system by a string in the following manner:\n\nThe string \"dir\\n\\tsubdir1\\n\\tsubdir2\\n\\t\\tfile.ext\" represents:\n\ndir\n    subdir1\n    subdir2\n        file.ext\n\nThe directory dir contains an empty sub-directory subdir1 and a sub-directory subdir2 containing a file file.ext.\n\nThe string \"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\" represents:\n\ndir\n    subdir1\n        file1.ext\n        subsubdir1\n    subdir2\n        subsubdir2\n            file2.ext\n\nThe directory dir contains two sub-directories subdir1 and subdir2. subdir1 contains a file file1.ext and an empty second-level sub-directory subsubdir1. subdir2 contains a second-level sub-directory subsubdir2 containing a file file2.ext.\n\nWe are interested in finding the longest (number of characters) absolute path to a file within our file system. For example, in the second example above, the longest absolute path is \"dir/subdir2/subsubdir2/file2.ext\", and its length is 32 (not including the double quotes).\n\nGiven a string representing the file system in the above format, return the length of the longest absolute path to file in the abstracted file system. If there is no file in the system, return 0.\n\nNote:\n\nThe name of a file contains at least a . and an extension.\nThe name of a directory or sub-directory will not contain a ..\n\nTime complexity required: O(n) where n is the size of the input string.\n\nNotice that a/aa/aaa/file1.txt is not the longest file path, if there is another path aaaaaaaaaaaaaaaaaaaaa/sth.png.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn contains_dot(s: Seq<char>) -> bool {\n    exists|i: int| 0 <= i < s.len() && s[i] == '.'\n}\n\nspec fn contains_newline(s: Seq<char>) -> bool {\n    exists|i: int| 0 <= i < s.len() && s[i] == '\\n'\n}\n\nfn length_longest_path(input: &str) -> (result: usize)\n    ensures \n        input@.len() == 0 ==> result == 0,\n        (input@.len() > 0 && contains_dot(input@) && !contains_newline(input@)) ==> result == input@.len(),\n        (input@.len() > 0 && !contains_dot(input@) && !contains_newline(input@)) ==> result == 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded_and_plausible\n\n    // Test cases:\n    // length_longest_path(\"dir\\n\\tsubdir1\\n\\tsubdir2\\n\\t\\tfile.ext\") should return 20\n    // length_longest_path(\"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\") should return 32\n    // length_longest_path(\"\") should return 0\n}"}
{"id": "fvapps_000172", "vc-description": "Given a positive integer n, find the number of non-negative integers less than or equal to n, whose binary representations do NOT contain consecutive ones.\n\nExample 1:\n\nInput: 5\nOutput: 5\nExplanation: \nHere are the non-negative integers \n\nNote:\n1 9", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn find_integers_without_consecutive_ones(n: u32) -> (result: u32)\n    ensures \n        result >= 2,\n        result > 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "/* Apps difficulty: interview */\n/* Assurance level: unguarded */\n\n}\n\nfn main() {\n    // println!(\"{}\", find_integers_without_consecutive_ones(1)); // Should output: 2\n    // println!(\"{}\", find_integers_without_consecutive_ones(5)); // Should output: 5  \n    // println!(\"{}\", find_integers_without_consecutive_ones(10)); // Should output: 8\n}"}
{"id": "fvapps_000174", "vc-description": "Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).\n\nExample:\n\nInput: S = \"ADOBECODEBANC\", T = \"ABC\"\nOutput: \"BANC\"\n\nNote:\n\n       If there is no such window in S that covers all characters in T, return the empty string \"\".\n       If there is such window, you are guaranteed that there will always be only one unique minimum window in S.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn verify_contains(window: Seq<char>, target: Seq<char>) -> bool {\n    forall|c: char| target.contains(c) ==> window.contains(c)\n}\n\nfn min_window(s: Vec<char>, t: Vec<char>) -> (result: Vec<char>)\n    ensures\n        t.len() == 0 ==> result.len() == 0,\n        result.len() > 0 ==> (\n            exists|start: int, end: int| 0 <= start <= end <= s.len() &&\n            result@ == s@.subrange(start, end) &&\n            verify_contains(result@, t@) &&\n            result.len() <= s.len()\n        ),\n        result.len() > 0 ==> verify_contains(result@, t@),\n        t.len() == 1 ==> (\n            (exists|i: int| 0 <= i < s.len() && s[i] == t[0]) ==>\n            (result.len() == 1 && result@ == t@)\n        ),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "}\n\nfn main() {\n    // let result1 = min_window(\"ADOBECODEBANC\".chars().collect(), \"ABC\".chars().collect());\n    // println!(\"{:?}\", result1.iter().collect::<String>());\n    \n    // let result2 = min_window(\"AAAA\".chars().collect(), \"A\".chars().collect());\n    // println!(\"{:?}\", result2.iter().collect::<String>());\n    \n    // let result3 = min_window(\"ABCD\".chars().collect(), \"XY\".chars().collect());\n    // println!(\"{:?}\", result3.iter().collect::<String>());\n}"}
{"id": "fvapps_000176", "vc-description": "Run-length encoding is a string compression method that works by replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string \"aabccc\" we replace \"aa\" by \"a2\" and replace \"ccc\" by \"c3\". Thus the compressed string becomes \"a2bc3\".\nNotice that in this problem, we are not adding '1' after single characters.\nGiven a string s and an integer k. You need to delete at most k characters from s such that the run-length encoded version of s has minimum length.\nFind the minimum length of the run-length encoded version of s after deleting at most k characters.\n\nExample 1:\nInput: s = \"aaabcccd\", k = 2\nOutput: 4\nExplanation: Compressing s without deleting anything will give us \"a3bc3d\" of length 6. Deleting any of the characters 'a' or 'c' would at most decrease the length of the compressed string to 5, for instance delete 2 'a' then we will have s = \"abcccd\" which compressed is abc3d. Therefore, the optimal way is to delete 'b' and 'd', then the compressed version of s will be \"a3c3\" of length 4.\nExample 2:\nInput: s = \"aabbaa\", k = 2\nOutput: 2\nExplanation: If we delete both 'b' characters, the resulting compressed string would be \"a4\" of length 2.\n\nExample 3:\nInput: s = \"aaaaaaaaaaa\", k = 0\nOutput: 3\nExplanation: Since k is zero, we cannot delete anything. The compressed string is \"a11\" of length 3.\n\nConstraints:\n\n1 <= s.length <= 100\n0 <= k <= s.length\ns contains only lowercase English letters.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn naive_compression_length(s: Seq<char>) -> nat\n{\n    s.len()\n}\n\nspec fn get_length_of_optimal_compression_spec(s: Seq<char>, k: nat) -> nat\n{\n    0\n}\n\nfn get_length_of_optimal_compression(s: Vec<char>, k: usize) -> (result: usize)\n    requires \n        s.len() >= 1,\n        k <= s.len(),\n    ensures \n        result >= 0,\n        result <= naive_compression_length(s@),\n        result <= s.len(),\n        result == get_length_of_optimal_compression_spec(s@, k as nat),\n{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}\n\nproof fn compressed_length_non_negative(s: Vec<char>, k: usize)\n    requires s.len() >= 1, k <= s.len(),\n    ensures get_length_of_optimal_compression_spec(s@, k as nat) >= 0,\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn compressed_length_not_longer_than_naive(s: Vec<char>, k: usize)\n    requires s.len() >= 1, k <= s.len(),\n    ensures get_length_of_optimal_compression_spec(s@, k as nat) <= naive_compression_length(s@),\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn compressed_length_not_longer_than_original(s: Vec<char>, k: usize)\n    requires s.len() >= 1, k <= s.len(),\n    ensures get_length_of_optimal_compression_spec(s@, k as nat) <= s.len(),\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn binary_string_min_length(s: Vec<char>, k: usize)\n    requires \n        s.len() > 0,\n        k < s.len(),\n    ensures get_length_of_optimal_compression_spec(s@, k as nat) >= 1,\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}", "vc-code": "", "vc-postamble": "/* Apps difficulty: interview */\n/* Assurance level: unguarded */\n\n/*\nTest cases:\nget_length_of_optimal_compression(vec!['a','a','a','b','c','c','c','d'], 2) should return 4\nget_length_of_optimal_compression(vec!['a','a','b','b','a','a'], 2) should return 2\nget_length_of_optimal_compression(vec!['a','a','a','a','a','a','a','a','a','a','a'], 0) should return 3\n*/\n\n}\n\nfn main() {\n    // let test1 = vec!['a','a','a','b','c','c','c','d'];\n    // println!(\"{}\", get_length_of_optimal_compression(test1, 2));\n    // let test2 = vec!['a','a','b','b','a','a'];\n    // println!(\"{}\", get_length_of_optimal_compression(test2, 2));\n    // let test3 = vec!['a','a','a','a','a','a','a','a','a','a','a'];\n    // println!(\"{}\", get_length_of_optimal_compression(test3, 0));\n}"}
{"id": "fvapps_000178", "vc-description": "Say you have an array for which the ith element is the price of a given stock on day i.\n\nDesign an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:\n\n       You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).\n       After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)\n\nExample:\n\nInput: [1,2,3,0,2]\nOutput: 3 \nExplanation: transactions = [buy, sell, cooldown, buy, sell]", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn spec_adjacent_diffs_sum(prices: Seq<nat>) -> nat\n    decreases prices.len()\n{\n    if prices.len() <= 1 {\n        0nat\n    } else {\n        let diff = if prices[1] > prices[0] { (prices[1] - prices[0]) as nat } else { 0nat };\n        diff + spec_adjacent_diffs_sum(prices.skip(1))\n    }\n}\n\nspec fn max_stock_profit_with_cooldown_spec(prices: Seq<nat>) -> nat {\n    0nat  /* placeholder uninterpreted function body */\n}\n\nfn max_stock_profit_with_cooldown(prices: Vec<nat>) -> (result: nat)\n    ensures\n        /* Empty or single price returns zero profit */\n        prices.len() <= 1 ==> result == 0,\n        /* Result is always non-negative */\n        result >= 0,\n        /* Decreasing prices yield zero profit */\n        (prices.len() >= 2 && (forall|i: int, j: int| 0 <= i < j < prices.len() ==> prices[i] >= prices[j])) ==> result == 0,\n        /* Profit is bounded by sum of positive adjacent differences */\n        prices.len() >= 2 ==> result <= spec_adjacent_diffs_sum(prices@),\n        /* Repeated list profit is at least original profit */\n        prices.len() >= 1 ==> max_stock_profit_with_cooldown_spec(prices@ + prices@) >= result,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "}\n\nfn main() {\n    // let result1 = max_stock_profit_with_cooldown(vec![1, 2, 3, 0, 2]);\n    // println!(\"Result 1: {}\", result1); // Expected: 3\n    \n    // let result2 = max_stock_profit_with_cooldown(vec![1]);\n    // println!(\"Result 2: {}\", result2); // Expected: 0\n    \n    // let result3 = max_stock_profit_with_cooldown(vec![2, 1, 4]);\n    // println!(\"Result 3: {}\", result3); // Expected: 3\n}"}
{"id": "fvapps_000179", "vc-description": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.\n\nThe above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!\n\nExample:\n\nInput: [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn trap(heights: Vec<usize>) -> (result: usize)\n    ensures \n        heights.len() == 0 ==> result == 0,\n        heights.len() == 1 ==> result == 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded_and_plausible\n\n    // Example: trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) should return 6\n    // Example: trap([4, 2, 0, 3, 2, 5]) should return 9\n    // Example: trap([]) should return 0\n}"}
{"id": "fvapps_000181", "vc-description": "Given a string text, we are allowed to swap two of the characters in the string. Find the length of the longest substring with repeated characters.\n\nExample 1:\nInput: text = \"ababa\"\nOutput: 3\nExplanation: We can swap the first 'b' with the last 'a', or the last 'b' with the first 'a'. Then, the longest repeated character substring is \"aaa\", which its length is 3.\n\nExample 2:\nInput: text = \"aaabaaa\"\nOutput: 6\nExplanation: Swap 'b' with the last 'a' (or the first 'a'), and we get longest repeated character substring \"aaaaaa\", which its length is 6.\n\nExample 3:\nInput: text = \"aaabbaaa\"\nOutput: 4\n\nExample 4:\nInput: text = \"aaaaa\"\nOutput: 5\nExplanation: No need to swap, longest repeated character substring is \"aaaaa\", length is 5.\n\nExample 5:\nInput: text = \"abcdef\"\nOutput: 1\n\nConstraints:\n\n1 <= text.length <= 20000\ntext consist of lowercase English characters only.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn count_unique_chars(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        let first = s[0];\n        let rest_count = count_unique_chars(s.skip(1));\n        if s.skip(1).contains(first) {\n            rest_count\n        } else {\n            rest_count + 1\n        }\n    }\n}\n\nfn max_repeated_chars_with_swap(s: Vec<char>) -> (result: usize)\n    requires s.len() > 0,\n    ensures \n        1 <= result && result <= s.len(),\n        (count_unique_chars(s@) == 1 ==> result == s.len()),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = max_repeated_chars_with_swap(vec!['a', 'b', 'a', 'b', 'a']);\n    // println!(\"{}\", result1); // Should print 3\n    \n    // let result2 = max_repeated_chars_with_swap(vec!['a', 'a', 'a', 'b', 'a', 'a', 'a']);\n    // println!(\"{}\", result2); // Should print 6\n    \n    // let result3 = max_repeated_chars_with_swap(vec!['a', 'a', 'a', 'b', 'b', 'a', 'a', 'a']);\n    // println!(\"{}\", result3); // Should print 4\n}"}
{"id": "fvapps_000183", "vc-description": "Given an array of integers cost and an integer target. Return the maximum integer you can paint under the following rules:\n\nThe cost of painting a digit (i+1) is given by cost[i] (0 indexed).\nThe total cost used must be equal to target.\nInteger does not have digits 0.\n\nSince the answer may be too large, return it as string.\nIf there is no way to paint any integer given the condition, return \"0\".\n\nExample 1:\nInput: cost = [4,3,2,5,6,7,2,5,5], target = 9\nOutput: \"7772\"\nExplanation:  The cost to paint the digit '7' is 2, and the digit '2' is 3. Then cost(\"7772\") = 2*3+ 3*1 = 9. You could also paint \"977\", but \"7772\" is the largest number.\nDigit    cost\n  1  ->   4\n  2  ->   3\n  3  ->   2\n  4  ->   5\n  5  ->   6\n  6  ->   7\n  7  ->   2\n  8  ->   5\n  9  ->   5\n\nExample 2:\nInput: cost = [7,6,5,5,5,6,8,7,8], target = 12\nOutput: \"85\"\nExplanation: The cost to paint the digit '8' is 7, and the digit '5' is 5. Then cost(\"85\") = 7 + 5 = 12.\n\nExample 3:\nInput: cost = [2,4,6,2,4,6,4,4,4], target = 5\nOutput: \"0\"\nExplanation: It's not possible to paint any integer with total cost equal to target.\n\nExample 4:\nInput: cost = [6,10,15,40,40,40,40,40,40], target = 47\nOutput: \"32211\"\n\nConstraints:\n\ncost.length == 9\n1 <= cost[i] <= 5000\n1 <= target <= 5000", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_valid_digit_char(c: char) -> bool {\n    c >= '1' && c <= '9'\n}\n\nspec fn char_to_digit(c: char) -> int {\n    (c as int) - ('0' as int)\n}\n\nspec fn digit_cost_sum(s: Seq<char>, costs: Seq<nat>) -> int \n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        let digit = char_to_digit(s[0]);\n        if 1 <= digit <= 9 && costs.len() == 9 {\n            costs[digit - 1] + digit_cost_sum(s.skip(1), costs)\n        } else {\n            0\n        }\n    }\n}\n\nfn largest_number(costs: Vec<nat>, target: int) -> (result: String)\n    requires \n        costs.len() == 9,\n        forall|i: int| 0 <= i < 9 ==> #[trigger] costs[i] >= 1 && #[trigger] costs[i] <= 5000,\n        1 <= target <= 5000,\n    ensures\n        result@.len() > 0,\n        result@ == seq!['0'] || digit_cost_sum(result@, costs@) == target,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "}\n\nfn main() {\n    // let result1 = largest_number(vec![4, 3, 2, 5, 6, 7, 2, 5, 5], 9);\n    // println!(\"{}\", result1); // Expected: \"7772\"\n    \n    // let result2 = largest_number(vec![7, 6, 5, 5, 5, 6, 8, 7, 8], 12);\n    // println!(\"{}\", result2); // Expected: \"85\"\n    \n    // let result3 = largest_number(vec![2, 4, 6, 2, 4, 6, 4, 4, 4], 5);\n    // println!(\"{}\", result3); // Expected: \"0\"\n}"}
{"id": "fvapps_000186", "vc-description": "Given two integer arrays A and B, return the maximum length of an subarray that appears in both arrays.\n\nExample 1:\n\nInput:\nA: [1,2,3,2,1]\nB: [3,2,1,4,7]\nOutput: 3\nExplanation: \nThe repeated subarray with maximum length is [3, 2, 1].\n\nNote:\n\n1 \n0", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn find_max_repeated_subarray(a: Vec<u32>, b: Vec<u32>) -> (result: usize)\n    ensures \n        result <= a.len(),\n        result <= b.len(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let result1 = find_max_repeated_subarray(vec![1, 2, 3, 2, 1], vec![3, 2, 1, 4, 7]);\n    // assert_eq!(result1, 3);\n    \n    // let result2 = find_max_repeated_subarray(vec![1, 2, 3], vec![4, 5, 6]);\n    // assert_eq!(result2, 0);\n    \n    // let result3 = find_max_repeated_subarray(vec![1, 1, 1], vec![1, 1, 1]);\n    // assert_eq!(result3, 3);\n}"}
{"id": "fvapps_000193", "vc-description": "Given a string s, determine if it is valid.\nA string s is valid if, starting with an empty string t = \"\", you can transform t into s after performing the following operation any number of times:\n\nInsert string \"abc\" into any position in t. More formally, t becomes tleft + \"abc\" + tright, where t == tleft + tright. Note that tleft and tright may be empty.\n\nReturn true if s is a valid string, otherwise, return false.\n\nExample 1:\nInput: s = \"aabcbc\"\nOutput: true\nExplanation:\n\"\" -> \"abc\" -> \"aabcbc\"\nThus, \"aabcbc\" is valid.\nExample 2:\nInput: s = \"abcabcababcc\"\nOutput: true\nExplanation:\n\"\" -> \"abc\" -> \"abcabc\" -> \"abcabcabc\" -> \"abcabcababcc\"\nThus, \"abcabcababcc\" is valid.\n\nExample 3:\nInput: s = \"abccba\"\nOutput: false\nExplanation: It is impossible to get \"abccba\" using the operation.\n\nExample 4:\nInput: s = \"cababc\"\nOutput: false\nExplanation: It is impossible to get \"cababc\" using the operation.\n\nConstraints:\n\n1 <= s.length <= 2 * 104\ns consists of letters 'a', 'b', and 'c'", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn string_after_abc_removal(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() < 3 {\n        s\n    } else if s.subrange(0, 3) == seq!['a', 'b', 'c'] {\n        string_after_abc_removal(s.subrange(3, s.len() as int))\n    } else {\n        seq![s[0]] + string_after_abc_removal(s.subrange(1, s.len() as int))\n    }\n}\n\nfn is_valid(s: &str) -> (result: bool)\n    ensures \n        result == (string_after_abc_removal(s@) == Seq::<char>::empty()),\n        s@ == Seq::<char>::empty() ==> result == true,\n        s@.contains('d') ==> result == false", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // println!(\"{}\", is_valid(\"aabcbc\"));\n    // println!(\"{}\", is_valid(\"abcabcababcc\"));\n    // println!(\"{}\", is_valid(\"abccba\"));\n}"}
{"id": "fvapps_000194", "vc-description": "You are given two strings s and t of the same length. You want to change s to t. Changing the i-th character of s to i-th character of t costs |s[i] - t[i]| that is, the absolute difference between the ASCII values of the characters.\nYou are also given an integer maxCost.\nReturn the maximum length of a substring of s that can be changed to be the same as the corresponding substring of twith a cost less than or equal to maxCost.\nIf there is no substring from s that can be changed to its corresponding substring from t, return 0.\n\nExample 1:\nInput: s = \"abcd\", t = \"bcdf\", maxCost = 3\nOutput: 3\nExplanation: \"abc\" of s can change to \"bcd\". That costs 3, so the maximum length is 3.\nExample 2:\nInput: s = \"abcd\", t = \"cdef\", maxCost = 3\nOutput: 1\nExplanation: Each character in s costs 2 to change to charactor in t, so the maximum length is 1.\n\nExample 3:\nInput: s = \"abcd\", t = \"acde\", maxCost = 0\nOutput: 1\nExplanation: You can't make any change, so the maximum length is 1.\n\nConstraints:\n\n1 <= s.length, t.length <= 10^5\n0 <= maxCost <= 10^6\ns and t only contain lower case English letters.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn equal_substring(s: Vec<char>, t: Vec<char>, max_cost: u32) -> (result: u32)\n    requires s.len() == t.len(),\n    ensures\n        result <= s.len(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded_and_plausible\n\n    // println!(\"{}\", equal_substring(\"abcd\", \"bcdf\", 3)); // Should output 3\n    // println!(\"{}\", equal_substring(\"abcd\", \"cdef\", 3)); // Should output 1  \n    // println!(\"{}\", equal_substring(\"abcd\", \"acde\", 0)); // Should output 1\n}"}
{"id": "fvapps_000196", "vc-description": "Given an integer k, return the minimum number of Fibonacci numbers whose sum is equal to k. The same Fibonacci number can be used multiple times.\nThe Fibonacci numbers are defined as:\n\nF1 = 1\nF2 = 1\nFn = Fn-1 + Fn-2 for n > 2.\n\nIt is guaranteed that for the given constraints we can always find such Fibonacci numbers that sum up to k.\n\nExample 1:\nInput: k = 7\nOutput: 2 \nExplanation: The Fibonacci numbers are: 1, 1, 2, 3, 5, 8, 13, ... \nFor k = 7 we can use 2 + 5 = 7.\nExample 2:\nInput: k = 10\nOutput: 2 \nExplanation: For k = 10 we can use 2 + 8 = 10.\n\nExample 3:\nInput: k = 19\nOutput: 3 \nExplanation: For k = 19 we can use 1 + 5 + 13 = 19.\n\nConstraints:\n\n1 <= k <= 10^9", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn fib(n: nat) -> nat\n    decreases n\n{\n    if n <= 2 {\n        1\n    } else {\n        fib((n - 1) as nat) + fib((n - 2) as nat)\n    }\n}\n\nfn find_min_fibonacci_numbers(k: u32) -> (result: u32)\n    requires k > 0,\n    ensures\n        result <= k,\n        result <= 2 * (32 - k.leading_zeros()) + 1,\n        k <= 10 ==> result <= 3", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000197", "vc-description": "Given n, how many structurally unique BST's (binary search trees) that store values 1 ... n?\n\nExample:\n\nInput: 3\nOutput: 5\nExplanation:\nGiven n = 3, there are a total of 5 unique BST's:\n\n   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn num_unique_bst_spec(n: nat) -> nat\n    decreases n\n{\n    if n == 0 { 1 }\n    else if n == 1 { 1 }\n    else if n == 2 { 2 }\n    else if n == 3 { 5 }\n    else if n == 4 { 14 }\n    else if n == 5 { 42 }\n    else if n == 6 { 132 }\n    else if n == 7 { 429 }\n    else { 1 } /* placeholder for unknown values */\n}", "vc-spec": "fn num_unique_bst(n: nat) -> (result: nat)\n    ensures \n        result > 0,\n        result == num_unique_bst_spec(n),\n        n == 0 ==> result == 1,\n        n == 1 ==> result == 1,\n        n == 2 ==> result == 2,\n        n == 3 ==> result == 5,\n        n == 4 ==> result == 14,\n        n == 5 ==> result == 42,\n        n == 6 ==> result == 132,\n        n == 7 ==> result == 429,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000199", "vc-description": "A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).\n\nThe robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).\n\nHow many possible unique paths are there?\n\nAbove is a 7 x 3 grid. How many possible unique paths are there?\n\nNote: m and n will be at most 100.\n\nExample 1:\n\nInput: m = 3, n = 2\nOutput: 3\nExplanation:\nFrom the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n1. Right -> Right -> Down\n2. Right -> Down -> Right\n3. Down -> Right -> Right\n\nExample 2:\n\nInput: m = 7, n = 3\nOutput: 28", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn unique_paths_spec(m: nat, n: nat) -> nat\n    recommends m > 0 && n > 0\n    decreases m + n\n{\n    if m == 1 || n == 1 {\n        1nat\n    } else if m > 1 && n > 1 {\n        unique_paths_spec(sub(m, 1nat), n) + unique_paths_spec(m, sub(n, 1nat))\n    } else {\n        0nat\n    }\n}\n\nfn unique_paths(m: u32, n: u32) -> (result: u32)\n    requires m > 0 && n > 0,\n    ensures \n        result > 0,\n        result == unique_paths_spec(m as nat, n as nat) as u32", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "proof fn unique_paths_positive(m: u32, n: u32)\n    requires m > 0 && n > 0,\n    ensures unique_paths_spec(m as nat, n as nat) > 0,\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn unique_paths_symmetry(m: u32, n: u32)\n    ensures unique_paths_spec(m as nat, n as nat) == unique_paths_spec(n as nat, m as nat),\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn unique_paths_single_row(n: u32)\n    requires n > 0,\n    ensures unique_paths_spec(1nat, n as nat) == 1nat,\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn unique_paths_single_col(n: u32)\n    requires n > 0,\n    ensures unique_paths_spec(n as nat, 1nat) == 1nat,\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\n}\n\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded_and_plausible\n    \n    // assert(unique_paths(3, 2) == 3);\n    // assert(unique_paths(7, 3) == 28);\n    // assert(unique_paths(3, 7) == 28);\n}"}
{"id": "fvapps_000200", "vc-description": "Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.\n\n(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).\n\nYou are given a target value to search. If found in the array return its index, otherwise return -1.\n\nYou may assume no duplicate exists in the array.\n\nYour algorithm's runtime complexity must be in the order of O(log n).\n\nExample 1:\n\nInput: nums = [4,5,6,7,0,1,2], target = 0\nOutput: 4\n\nExample 2:\n\nInput: nums = [4,5,6,7,0,1,2], target = 3\nOutput: -1", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn search(arr: Vec<i32>, target: i32) -> (result: i32)\n    ensures\n        arr.len() == 0 ==> result == -1,\n        arr.len() > 0 ==> (\n            (exists|i: int| 0 <= i < arr.len() && arr[i] == target) ==> \n            (result >= 0 && result < arr.len() && arr[result as int] == target)\n        ),\n        arr.len() > 0 ==> (\n            (forall|i: int| 0 <= i < arr.len() ==> arr[i] != target) ==> \n            result == -1\n        )", "vc-code": "{\n    // impl-start\n    assume(false);\n    -1\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // println!(\"{}\", search(vec![4, 5, 6, 7, 0, 1, 2], 0));\n    // println!(\"{}\", search(vec![4, 5, 6, 7, 0, 1, 2], 3));\n    // println!(\"{}\", search(vec![1], 1));\n}"}
{"id": "fvapps_000201", "vc-description": "In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue.\nFor now, suppose you are a dominator of m 0s and n 1s respectively. On the other hand, there is an array with strings consisting of only 0s and 1s.\n\nNow your task is to find the maximum number of strings that you can form with given m 0s and n 1s. Each 0 and 1 can be used at most once.\n\nNote:\n\nThe given numbers of 0s and 1s will both not exceed 100\nThe size of given string array won't exceed 600.\n\nExample 1:\n\nInput: Array = {\"10\", \"0001\", \"111001\", \"1\", \"0\"}, m = 5, n = 3\nOutput: 4\n\nExplanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are \"10,\"0001\",\"1\",\"0\"\n\nExample 2:\n\nInput: Array = {\"10\", \"0\", \"1\"}, m = 1, n = 1\nOutput: 2\n\nExplanation: You could form \"10\", but then you'd have nothing left. Better form \"0\" and \"1\".", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn count_zeros(s: &str) -> nat;\n\nspec fn count_ones(s: &str) -> nat;\n\nfn find_max_form(strs: Vec<String>, m: usize, n: usize) -> (result: usize)\n    ensures \n        result <= strs.len(),\n        result >= 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n/* Apps difficulty: interview */\n/* Assurance level: guarded_and_plausible */\n\n}\nfn main() {\n    // let result1 = find_max_form(vec![\"10\".to_string(), \"0001\".to_string(), \"111001\".to_string(), \"1\".to_string(), \"0\".to_string()], 5, 3);\n    // println!(\"{}\", result1); // Should be 4\n    \n    // let result2 = find_max_form(vec![\"10\".to_string(), \"0\".to_string(), \"1\".to_string()], 1, 1);\n    // println!(\"{}\", result2); // Should be 2\n    \n    // let result3 = find_max_form(vec![\"10\".to_string(), \"0\".to_string()], 1, 1);\n    // println!(\"{}\", result3); // Should be 1\n}"}
{"id": "fvapps_000202", "vc-description": "Given an array of scores that are non-negative integers. Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on. Each time a player picks a number, that number will not be available for the next player. This continues until all the scores have been chosen. The player with the maximum score wins. \n\nGiven an array of scores, predict whether player 1 is the winner. You can assume each player plays to maximize his score. \n\nExample 1:\n\nInput: [1, 5, 2]\nOutput: False\nExplanation: Initially, player 1 can choose between 1 and 2. If he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). So, final score of player 1 is 1 + 2 = 3, and player 2 is 5. Hence, player 1 will never be the winner and you need to return False.\n\nExample 2:\n\nInput: [1, 5, 233, 7]\nOutput: True\nExplanation: Player 1 first chooses 1. Then player 2 have to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.Finally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.\n\nNote:\n\n1 \nAny scores in the given array are non-negative integers and will not exceed 10,000,000.\nIf the scores of both players are equal, then player 1 is still the winner.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn predict_the_winner(nums: Vec<i32>) -> (result: bool)\n    ensures \n        nums.len() == 0 ==> result == true,\n        nums.len() % 2 == 0 ==> result == true,", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let test1 = vec![1, 5, 2];\n    // let result1 = predict_the_winner(test1);\n    // assert(result1 == false);\n    \n    // let test2 = vec![1, 5, 233, 7];\n    // let result2 = predict_the_winner(test2);\n    // assert(result2 == true);\n    \n    // let test3 = vec![];\n    // let result3 = predict_the_winner(test3);\n    // assert(result3 == true);\n}"}
{"id": "fvapps_000203", "vc-description": "Given a list of non negative integers, arrange them such that they form the largest number.\n\nExample 1:\n\nInput: [10,2]\nOutput: \"210\"\n\nExample 2:\n\nInput: [3,30,34,5,9]\nOutput: \"9534330\"\n\nNote: The result may be very large, so you need to return a string instead of an integer.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn largest_number(l: Vec<nat>) -> (result: String)\n    ensures\n        l.len() == 0 ==> result.view() == seq!['0'],\n        l@ == seq![0nat] ==> result.view() == seq!['0'],\n        l@ == seq![0nat, 0nat] ==> result.view() == seq!['0'],\n        l@ == seq![10nat, 2nat] ==> result.view() == seq!['2', '1', '0'],\n        l@ == seq![3nat, 30nat, 34nat, 5nat, 9nat] ==> result.view() == seq!['9', '5', '3', '4', '3', '3', '0']", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let result1 = largest_number(vec![10, 2]);\n    // println!(\"{}\", result1); // Should print \"210\"\n    \n    // let result2 = largest_number(vec![3, 30, 34, 5, 9]);\n    // println!(\"{}\", result2); // Should print \"9534330\"\n    \n    // let result3 = largest_number(vec![0, 0]);\n    // println!(\"{}\", result3); // Should print \"0\"\n}"}
{"id": "fvapps_000204", "vc-description": "In the world of Dota2, there are two parties: the Radiant and the Dire.\n\nThe Dota2 senate consists of senators coming from two parties. Now the senate wants to make a decision about a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise one of the two rights:\n\nBan one senator's right: A senator can make another senator lose all his rights in this and all the following rounds.\nAnnounce the victory: If this senator found the senators who still have rights to vote are all from the same party, he can announce the victory and make the decision about the change in the game.\n\nGiven a string representing each senator's party belonging. The character 'R' and 'D' represent the Radiant party and the Dire party respectively. Then if there are n senators, the size of the given string will be n.\n\nThe round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure.\n\nSuppose every senator is smart enough and will play the best strategy for his own party, you need to predict which party will finally announce the victory and make the change in the Dota2 game. The output should be Radiant or Dire.\n\nExample 1:\n\nInput: \"RD\"\nOutput: \"Radiant\"\nExplanation: The first senator comes from Radiant and he can just ban the next senator's right in the round 1. And the second senator can't exercise any rights any more since his right has been banned. And in the round 2, the first senator can just announce the victory since he is the only guy in the senate who can vote.\n\nExample 2:\n\nInput: \"RDD\"\nOutput: \"Dire\"\nExplanation: \nThe first senator comes from Radiant and he can just ban the next senator's right in the round 1. And the second senator can't exercise any rights anymore since his right has been banned. And the third senator comes from Dire and he can ban the first senator's right in the round 1. And in the round 2, the third senator can just announce the victory since he is the only guy in the senate who can vote.\n\nNote:\n\nThe length of the given string will in the range [1, 10,000].", "vc-preamble": "use vstd::prelude::*;\nuse vstd::string::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn predict_party_victory(senate: Vec<char>) -> (result: String)\n    requires senate.len() > 0,\n    ensures \n        result@ == \"Radiant\"@ || result@ == \"Dire\"@", "vc-code": "{\n    // impl-start\n    assume(false);\n    \"Radiant\".to_string()\n    // impl-end\n}", "vc-postamble": "}\n\nfn main() {\n    // let rd: Vec<char> = \"RD\".chars().collect();\n    // println!(\"{}\", predict_party_victory(rd));\n    // let rdd: Vec<char> = \"RDD\".chars().collect();\n    // println!(\"{}\", predict_party_victory(rdd));\n    // let rrddd: Vec<char> = \"RRDDD\".chars().collect();\n    // println!(\"{}\", predict_party_victory(rrddd));\n}"}
{"id": "fvapps_000206", "vc-description": "Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k.\n\nExample 1:\nInput: nums = [1,2,3,1], k = 3, t = 0\nOutput: true\n\nExample 2:\nInput: nums = [1,0,1,1], k = 1, t = 2\nOutput: true\n\nExample 3:\nInput: nums = [1,5,9,1,5,9], k = 2, t = 3\nOutput: false", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn abs_spec(i: int) -> int {\n    if i >= 0 { i } else { -i }\n}", "vc-helpers": "", "vc-spec": "fn contains_nearby_almost_duplicate(nums: Vec<i32>, k: i32, t: i32) -> (result: bool)\n    ensures \n        (k <= 0 && t < 0) ==> !result,\n        (k > 0 && t >= 0 && nums.len() >= 2 && nums.len() <= 100) ==> (\n            result == exists|i: int, j: int| \n                0 <= i && i < nums.len() &&\n                0 <= j && j < nums.len() &&\n                i != j &&\n                abs_spec(i - j) <= k &&\n                abs_spec(nums[i] - nums[j]) <= t\n        )", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // #eval contains_nearby_almost_duplicate(vec![1, 2, 3, 1], 3, 0);\n    // #eval contains_nearby_almost_duplicate(vec![1, 0, 1, 1], 1, 2);\n    // #eval contains_nearby_almost_duplicate(vec![1, 5, 9, 1, 5, 9], 2, 3);\n}"}
{"id": "fvapps_000207", "vc-description": "Given a string s, return the maximum number of unique substrings that the given string can be split into.\nYou can split string s into any list of non-empty substrings, where the concatenation of the substrings forms the original string. However, you must split the substrings such that all of them are unique.\nA substring is a contiguous sequence of characters within a string.\n\nExample 1:\nInput: s = \"ababccc\"\nOutput: 5\nExplanation: One way to split maximally is ['a', 'b', 'ab', 'c', 'cc']. Splitting like ['a', 'b', 'a', 'b', 'c', 'cc'] is not valid as you have 'a' and 'b' multiple times.\n\nExample 2:\nInput: s = \"aba\"\nOutput: 2\nExplanation: One way to split maximally is ['a', 'ba'].\n\nExample 3:\nInput: s = \"aa\"\nOutput: 1\nExplanation: It is impossible to split the string any further.\n\nConstraints:\n\n1 <= s.length <= 16\n\ns contains only lower case English letters.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn max_unique_split(s: Seq<char>) -> nat;\n\nfn max_unique_split_exec(s: Vec<char>) -> (result: usize)\n    requires s.len() >= 1,\n    ensures \n        result >= 1,\n        result <= s.len(),\n        result == max_unique_split(s@),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n\nproof fn max_unique_split_single_char(s: Seq<char>)\n    requires s.len() == 1,\n    ensures max_unique_split(s) == 1,\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn max_unique_split_aa()\n    ensures max_unique_split(seq!['a', 'a']) == 1,\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn max_unique_split_aba()\n    ensures max_unique_split(seq!['a', 'b', 'a']) == 2,\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "fvapps_000208", "vc-description": "Given an array of unique integers, each integer is strictly greater than 1.\nWe make a binary tree using these integers and each number may be used for any number of times.\nEach non-leaf node's value should be equal to the product of the values of it's children.\nHow many binary trees can we make?  Return the answer modulo 10 ** 9 + 7.\nExample 1:\nInput: A = [2, 4]\nOutput: 3\nExplanation: We can make these trees: [2], [4], [4, 2, 2]\nExample 2:\nInput: A = [2, 4, 5, 10]\nOutput: 7\nExplanation: We can make these trees: [2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2].\n\nNote:\n\n1 <= A.length <= 1000.\n2 <= A[i] <= 10 ^ 9.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn num_factored_binary_trees(arr: Vec<u32>) -> (result: u32)\n    requires \n        arr.len() >= 1,\n        arr.len() <= 1000,\n        forall|i: int| 0 <= i < arr.len() ==> arr[i] >= 2,\n        forall|i: int, j: int| 0 <= i < j < arr.len() ==> arr[i] != arr[j],\n    ensures \n        result > 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "/* Apps difficulty: interview\n   Assurance level: guarded_and_plausible */\n\n}\n\nfn main() {\n    // print!(\"{}\", num_factored_binary_trees(vec![2, 4]));\n    // print!(\"{}\", num_factored_binary_trees(vec![2, 4, 5, 10]));\n    // print!(\"{}\", num_factored_binary_trees(vec![2, 3]));\n}"}
{"id": "fvapps_000212", "vc-description": "Given the string croakOfFrogs, which represents a combination of the string \"croak\" from different frogs, that is, multiple frogs can croak at the same time, so multiple \"croak\" are mixed. Return the minimum number of different frogs to finish all the croak in the given string.\nA valid \"croak\" means a frog is printing 5 letters 'c', 'r', 'o', 'a', 'k' sequentially. The frogs have to print all five letters to finish a croak. If the given string is not a combination of valid \"croak\" return -1.\n\nExample 1:\nInput: croakOfFrogs = \"croakcroak\"\nOutput: 1 \nExplanation: One frog yelling \"croak\" twice.\n\nExample 2:\nInput: croakOfFrogs = \"crcoakroak\"\nOutput: 2 \nExplanation: The minimum number of frogs is two. \nThe first frog could yell \"crcoakroak\".\nThe second frog could yell later \"crcoakroak\".\n\nExample 3:\nInput: croakOfFrogs = \"croakcrook\"\nOutput: -1\nExplanation: The given string is an invalid combination of \"croak\" from different frogs.\n\nExample 4:\nInput: croakOfFrogs = \"croakcroa\"\nOutput: -1\n\nConstraints:\n\n1 <= croakOfFrogs.length <= 10^5\nAll characters in the string are: 'c', 'r', 'o', 'a' or 'k'.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn count_char(s: Seq<char>, c: char) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0nat\n    } else {\n        (if s[0] == c { 1nat } else { 0nat }) + count_char(s.skip(1), c)\n    }\n}\n\nspec fn is_valid_croak_string(s: Seq<char>) -> bool {\n    let c_count = count_char(s, 'c');\n    let r_count = count_char(s, 'r');\n    let o_count = count_char(s, 'o');\n    let a_count = count_char(s, 'a');\n    let k_count = count_char(s, 'k');\n    \n    c_count == r_count && r_count == o_count && o_count == a_count && a_count == k_count &&\n    s.len() % 5 == 0 &&\n    (s.len() > 0 ==> s[0] == 'c') &&\n    (s.len() > 0 ==> s[s.len() - 1] == 'k')\n}\n\nfn min_number_of_frogs(s: &str) -> (result: i32)\n    ensures result >= -1\n{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}\n\nfn is_valid_croak(s: &str) -> (result: bool)", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded_and_plausible\n\n    // println!(\"{}\", min_number_of_frogs(\"croakcroak\"));   // Expected: 1\n    // println!(\"{}\", min_number_of_frogs(\"crcoakroak\"));   // Expected: 2  \n    // println!(\"{}\", min_number_of_frogs(\"croakcrook\"));   // Expected: -1\n}"}
{"id": "fvapps_000214", "vc-description": "A string S of lowercase letters is given. Then, we may make any number of moves.\nIn each move, we choose one of the first K letters (starting from the left), remove it, and place it at the end of the string.\nReturn the lexicographically smallest string we could have after any number of moves.\n\nExample 1:\nInput: S = \"cba\", K = 1\nOutput: \"acb\"\nExplanation: \nIn the first move, we move the 1st character (\"c\") to the end, obtaining the string \"bac\".\nIn the second move, we move the 1st character (\"b\") to the end, obtaining the final result \"acb\".\n\nExample 2:\nInput: S = \"baaca\", K = 3\nOutput: \"aaabc\"\nExplanation: \nIn the first move, we move the 1st character (\"b\") to the end, obtaining the string \"aacab\".\nIn the second move, we move the 3rd character (\"c\") to the end, obtaining the final result \"aaabc\".\n\nNote:\n1 <= K <= S.length <= 1000\nS consists of lowercase letters only.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn string_to_sorted_string(s: Seq<char>) -> Seq<char> {\n    s  /* placeholder since we can't sort without proper implementation */\n}\n\nspec fn char_seq_drop_take(s: Seq<char>, i: int) -> Seq<char> {\n    if 0 <= i <= s.len() {\n        s.subrange(i, s.len() as int) + s.subrange(0, i)\n    } else {\n        s\n    }\n}\n\nspec fn lex_le(s1: Seq<char>, s2: Seq<char>) -> bool \n    decreases s1.len() + s2.len()\n{\n    if s1.len() == 0 && s2.len() == 0 {\n        true\n    } else if s1.len() == 0 {\n        true\n    } else if s2.len() == 0 {\n        false\n    } else if s1[0] < s2[0] {\n        true\n    } else if s1[0] > s2[0] {\n        false\n    } else {\n        lex_le(s1.skip(1), s2.skip(1))\n    }\n}", "vc-spec": "fn orderly_queue(s: Vec<char>, k: usize) -> (result: Vec<char>)\n    requires \n        s.len() > 0,\n        k > 0,\n        k <= s.len(),\n    ensures\n        /* When k > 1, result is equivalent to sorted string */\n        k > 1 ==> string_to_sorted_string(result@) == string_to_sorted_string(s@),\n        /* Length is preserved */\n        result.len() == s.len(),\n        /* Character multiset is preserved */\n        string_to_sorted_string(result@) == string_to_sorted_string(s@),\n        /* When k = 1, result is a rotation of original string */\n        k == 1 ==> exists|i: int| 0 <= i < s.len() && result@ == char_seq_drop_take(s@, i),\n        /* When k = 1, result is lexicographically minimal among all rotations */\n        k == 1 ==> forall|i: int| 0 <= i < s.len() ==> lex_le(result@, char_seq_drop_take(s@, i))", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = orderly_queue(vec!['c', 'b', 'a'], 1);\n    // println!(\"Result 1: {:?}\", result1);  // Should be \"acb\"\n    \n    // let result2 = orderly_queue(vec!['b', 'a', 'a', 'c', 'a'], 3);\n    // println!(\"Result 2: {:?}\", result2);  // Should be \"aaabc\"\n    \n    // let result3 = orderly_queue(vec!['a', 'b', 'c', 'd'], 2);\n    // println!(\"Result 3: {:?}\", result3);  // Should be \"abcd\"\n}"}
{"id": "fvapps_000215", "vc-description": "We are given hours, a list of the number of hours worked per day for a given employee.\nA day is considered to be a tiring day if and only if the number of hours worked is (strictly) greater than 8.\nA well-performing interval is an interval of days for which the number of tiring days is strictly larger than the number of non-tiring days.\nReturn the length of the longest well-performing interval.\n\nExample 1:\nInput: hours = [9,9,6,0,6,6,9]\nOutput: 3\nExplanation: The longest well-performing interval is [9,9,6].\n\nConstraints:\n\n1 <= hours.length <= 10000\n0 <= hours[i] <= 16", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_tiring(hours: nat) -> bool {\n    hours > 8\n}\n\nspec fn count_tiring_days(hours: Seq<nat>) -> nat\n    decreases hours.len()\n{\n    if hours.len() == 0 {\n        0nat\n    } else {\n        (if is_tiring(hours[0]) { 1nat } else { 0nat }) + count_tiring_days(hours.skip(1))\n    }\n}\n\nspec fn is_well_performing_interval(hours: Seq<nat>) -> bool {\n    let tiring_days = count_tiring_days(hours);\n    let non_tiring_days = hours.len() - tiring_days;\n    tiring_days > non_tiring_days\n}\n\nfn longest_wpi(hours: Vec<nat>) -> (result: nat)\n    requires \n        hours.len() >= 1,\n        hours.len() <= 10000,\n        forall|i: int| 0 <= i < hours.len() ==> hours[i] <= 16,\n    ensures \n        result >= 0,\n        result <= hours.len(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let test1 = vec![9, 9, 6, 0, 6, 6, 9];\n    // let result1 = longest_wpi(test1);\n    // println!(\"Test 1 result: {}\", result1);\n    \n    // let test2 = vec![6, 6, 6];\n    // let result2 = longest_wpi(test2);\n    // println!(\"Test 2 result: {}\", result2);\n    \n    // let test3 = vec![9, 9, 9];\n    // let result3 = longest_wpi(test3);\n    // println!(\"Test 3 result: {}\", result3);\n}"}
{"id": "fvapps_000216", "vc-description": "Today, the bookstore owner has a store open for customers.length minutes.  Every minute, some number of customers (customers[i]) enter the store, and all those customers leave after the end of that minute.\nOn some minutes, the bookstore owner is grumpy.  If the bookstore owner is grumpy on the i-th minute, grumpy[i] = 1, otherwise grumpy[i] = 0.  When the bookstore owner is grumpy, the customers of that minute are not satisfied, otherwise they are satisfied.\nThe bookstore owner knows a secret technique to keep themselves not grumpy for X minutes straight, but can only use it once.\nReturn the maximum number of customers that can be satisfied throughout the day.\n\nExample 1:\nInput: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], X = 3\nOutput: 16\nExplanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. \nThe maximum number of customers that can be satisfied = 1 + 1 + 1 + 1 + 7 + 5 = 16.\n\nNote:\n\n1 <= X <= customers.length == grumpy.length <= 20000\n0 <= customers[i] <= 1000\n0 <= grumpy[i] <= 1", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn sum_vec(l: Seq<nat>) -> nat\n    decreases l.len()\n{\n    if l.len() == 0 {\n        0\n    } else {\n        l[0] + sum_vec(l.skip(1))\n    }\n}\n\nspec fn minimum_vec(l: Seq<nat>) -> nat \n    decreases l.len()\n{\n    if l.len() == 0 {\n        0\n    } else if l.len() == 1 {\n        l[0]\n    } else {\n        let rest_min = minimum_vec(l.skip(1));\n        if l[0] < rest_min { l[0] } else { rest_min }\n    }\n}", "vc-spec": "spec fn base_satisfied(customers: Seq<nat>, grumpy: Seq<nat>) -> nat\n    decreases customers.len()\n{\n    if customers.len() == 0 || grumpy.len() == 0 {\n        0\n    } else {\n        let current = if grumpy[0] == 0 { customers[0] } else { 0 };\n        current + base_satisfied(customers.skip(1), grumpy.skip(1))\n    }\n}\n\nspec fn all_zeros(grumpy: Seq<nat>) -> bool {\n    forall|i: int| 0 <= i < grumpy.len() ==> grumpy[i] == 0\n}\n\nfn max_satisfied(customers: Vec<nat>, grumpy: Vec<nat>, x: nat) -> (result: nat)\n    requires\n        customers.len() > 0,\n        grumpy.len() == customers.len(),\n        x > 0,\n        forall|i: int| 0 <= i < customers.len() ==> customers[i] <= 1000,\n        forall|i: int| 0 <= i < grumpy.len() ==> grumpy[i] <= 1,\n    ensures\n        result >= base_satisfied(customers@, grumpy@),\n        result <= sum_vec(customers@),\n        all_zeros(grumpy@) ==> result == sum_vec(customers@),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let customers1 = vec![1, 0, 1, 2, 1, 1, 7, 5];\n    // let grumpy1 = vec![0, 1, 0, 1, 0, 1, 0, 1];\n    // let result1 = max_satisfied(customers1, grumpy1, 3);\n    // println!(\"Test 1 result: {}\", result1);\n    \n    // let customers2 = vec![1];\n    // let grumpy2 = vec![0];\n    // let result2 = max_satisfied(customers2, grumpy2, 1);\n    // println!(\"Test 2 result: {}\", result2);\n    \n    // let customers3 = vec![2, 4, 1, 4, 1];\n    // let grumpy3 = vec![1, 1, 1, 1, 1];\n    // let result3 = max_satisfied(customers3, grumpy3, 2);\n    // println!(\"Test 3 result: {}\", result3);\n}"}
{"id": "fvapps_000219", "vc-description": "Given an array of citations sorted in ascending order (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index.\n\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each.\"\n\nExample:\n\nInput: citations = [0,1,3,5,6]\nOutput: 3 \nExplanation: [0,1,3,5,6] means the researcher has 5 papers in total and each of them had \n             received 0, 1, 3, 5, 6 citations respectively. \n             Since the researcher has 3 papers with at least 3 citations each and the remaining \n             two with no more than 3 citations each, her h-index is 3.\n\nNote:\n\nIf there are several possible values for h, the maximum one is taken as the h-index.\n\nFollow up:\n\n       This is a follow up problem to H-Index, where citations is now guaranteed to be sorted in ascending order.\n       Could you solve it in logarithmic time complexity?", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn count_papers_with_at_least_citations(citations: Seq<u32>, h: u32) -> nat {\n    citations.filter(|x: u32| x >= h).len()\n}\n\nspec fn is_valid_h_index(citations: Seq<u32>, h: u32) -> bool {\n    let papers_with_at_least_h = count_papers_with_at_least_citations(citations, h);\n    papers_with_at_least_h >= h && (citations.len() - papers_with_at_least_h) <= h\n}\n\nfn h_index(citations: Vec<u32>) -> (result: u32)\n    ensures \n        result <= citations.len(),\n        is_valid_h_index(citations@, result),\n        forall|h: u32| h > result ==> !is_valid_h_index(citations@, h),", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // #eval h_index [0, 1, 3, 5, 6]  // Expected: 3\n    // #eval h_index [0]              // Expected: 0  \n    // #eval h_index [5, 5, 5]        // Expected: 3\n}"}
{"id": "fvapps_000220", "vc-description": "Given a string S and a string T, count the number of distinct subsequences of S which equals T.\n\nA subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, \"ACE\" is a subsequence of \"ABCDE\" while \"AEC\" is not).\n\nExample 1:\n\nInput: S = \"rabbbit\", T = \"rabbit\"\nOutput: 3\nExplanation:\n\nAs shown below, there are 3 ways you can generate \"rabbit\" from S.\n(The caret symbol ^ means the chosen letters)\n\nrabbbit\n^^^^ ^^\nrabbbit\n^^ ^^^^\nrabbbit\n^^^ ^^^\n\nExample 2:\n\nInput: S = \"babgbag\", T = \"bag\"\nOutput: 5\nExplanation:\n\nAs shown below, there are 5 ways you can generate \"bag\" from S.\n(The caret symbol ^ means the chosen letters)\n\nbabgbag\n^^ ^\nbabgbag\n^^    ^\nbabgbag\n^    ^^\nbabgbag\n  ^  ^^\nbabgbag\n    ^^^", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn count_subsequences_spec(s: Seq<char>, t: Seq<char>) -> nat\n    decreases s.len() + t.len()\n{\n    if t.len() == 0 {\n        1\n    } else if s.len() == 0 {\n        0\n    } else if s[0] == t[0] {\n        count_subsequences_spec(s.skip(1), t.skip(1)) + count_subsequences_spec(s.skip(1), t)\n    } else {\n        count_subsequences_spec(s.skip(1), t)\n    }\n}\n\nfn count_distinct_subsequences(s: &str, t: &str) -> (result: u32)\n    ensures result as nat == count_subsequences_spec(s@, t@)", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // println!(\"{}\", count_distinct_subsequences(\"rabbbit\", \"rabbit\"));\n    // println!(\"{}\", count_distinct_subsequences(\"babgbag\", \"bag\"));\n    // println!(\"{}\", count_distinct_subsequences(\"abc\", \"abc\"));\n}"}
{"id": "fvapps_000221", "vc-description": "There are N dominoes in a line, and we place each domino vertically upright.\nIn the beginning, we simultaneously push some of the dominoes either to the left or to the right.\n\nAfter each second, each domino that is falling to the left pushes the adjacent domino on the left.\nSimilarly, the dominoes falling to the right push their adjacent dominoes standing on the right.\nWhen a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces.\nFor the purposes of this question, we will consider that a falling domino expends no additional force to a falling or already fallen domino.\nGiven a string \"S\" representing the initial state. S[i] = 'L', if the i-th domino has been pushed to the left; S[i] = 'R', if the i-th domino has been pushed to the right; S[i] = '.', if the i-th domino has not been pushed.\nReturn a string representing the final state. \nExample 1:\nInput: \".L.R...LR..L..\"\nOutput: \"LL.RR.LLRRLL..\"\n\nExample 2:\nInput: \"RR.L\"\nOutput: \"RR.L\"\nExplanation: The first domino expends no additional force on the second domino.\n\nNote:\n\n0 <= N <= 10^5\nString dominoes contains only 'L', 'R' and '.'", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn valid_domino_char(c: char) -> bool {\n    c == '.' || c == 'L' || c == 'R'\n}\n\nspec fn all_valid_chars(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> valid_domino_char(s[i])\n}\n\nspec fn push_dominoes_spec(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n    s\n}\n\nfn push_dominoes(s: Vec<char>) -> (result: Vec<char>)\n    requires all_valid_chars(s@),\n    ensures\n        result@.len() == s@.len(),\n        all_valid_chars(result@),\n        push_dominoes_spec(result@) == result@,\n        (forall|i: int| 0 <= i < s@.len() && s@[i] != '.' ==> result@ == s@) ==> result == s,\n        (forall|i: int| 0 <= i < s@.len() && s@[i] == '.') ==> (forall|j: int| 0 <= j < result@.len() ==> result@[j] == '.'),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let test1: Vec<char> = \".L.R...LR..L..\".chars().collect();\n    // let result1 = push_dominoes(test1);\n    // println!(\"{}\", result1.iter().collect::<String>()); // Should output: \"LL.RR.LLRRLL..\"\n    \n    // let test2: Vec<char> = \"RR.L\".chars().collect();\n    // let result2 = push_dominoes(test2);\n    // println!(\"{}\", result2.iter().collect::<String>()); // Should output: \"RR.L\"\n    \n    // let test3: Vec<char> = \"...\".chars().collect();\n    // let result3 = push_dominoes(test3);\n    // println!(\"{}\", result3.iter().collect::<String>()); // Should output: \"...\"\n}"}
{"id": "fvapps_000225", "vc-description": "Given an array of integers A with even length, return true if and only if it is possible to reorder it such that A[2 * i + 1] = 2 * A[2 * i] for every 0 <= i < len(A) / 2.\n\nExample 1:\nInput: A = [3,1,3,6]\nOutput: false\n\nExample 2:\nInput: A = [2,1,2,6]\nOutput: false\n\nExample 3:\nInput: A = [4,-2,2,-4]\nOutput: true\nExplanation: We can take two groups, [-2,-4] and [2,4] to form [-2,-4,2,4] or [2,4,-2,-4].\n\nExample 4:\nInput: A = [1,2,4,16,8,4]\nOutput: false\n\nConstraints:\n\n0 <= A.length <= 3 * 104\nA.length is even.\n-105 <= A[i] <= 105", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn count_occurrences(n: i32, lst: Seq<i32>) -> nat\n    decreases lst.len()\n{\n    if lst.len() == 0 {\n        0nat\n    } else {\n        (if lst[0] == n { 1nat } else { 0nat }) + count_occurrences(n, lst.skip(1))\n    }\n}", "vc-spec": "fn can_reorder_doubled(lst: Vec<i32>) -> (result: bool)\n    requires lst.len() % 2 == 0,\n    ensures\n        lst@.len() == 0 ==> result == true,\n        (forall|i: int| 0 <= i < lst@.len() ==> lst@[i] == 0) ==> result == true", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "}\n\nfn main() {\n    // let result1 = can_reorder_doubled(vec![3, 1, 3, 6]);\n    // assert(result1 == false);\n    \n    // let result2 = can_reorder_doubled(vec![4, -2, 2, -4]);\n    // assert(result2 == true);\n    \n    // let result3 = can_reorder_doubled(vec![1, 2, 4, 16, 8, 4]);\n    // assert(result3 == false);\n}"}
{"id": "fvapps_000226", "vc-description": "Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible.\n\nNote:\n\nThe length of num is less than 10002 and will be ≥ k.\nThe given num does not contain any leading zero.\n\nExample 1:\n\nInput: num = \"1432219\", k = 3\nOutput: \"1219\"\nExplanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.\n\nExample 2:\n\nInput: num = \"10200\", k = 1\nOutput: \"200\"\nExplanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.\n\nExample 3:\n\nInput: num = \"10\", k = 2\nOutput: \"0\"\nExplanation: Remove all the digits from the number and it is left with nothing which is 0.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_digit(c: char) -> bool {\n    '0' <= c && c <= '9'\n}\n\nspec fn string_contains_digit(s: Seq<char>) -> bool {\n    exists|i: int| 0 <= i < s.len() && is_digit(s[i])\n}\n\nspec fn drop_leading_zeros_spec(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        seq!['0']\n    } else if s[0] == '0' {\n        drop_leading_zeros_spec(s.skip(1))\n    } else {\n        s\n    }\n}\n\nspec fn final_result_spec(s: Seq<char>) -> Seq<char> {\n    let dropped = drop_leading_zeros_spec(s);\n    if dropped.len() == 0 {\n        seq!['0']\n    } else {\n        dropped\n    }\n}\n\nfn remove_k_digits(num: &str, k: usize) -> (result: String)\n    requires \n        k <= num@.len(),\n        string_contains_digit(num@),\n    ensures \n        k == 0 ==> result@ == final_result_spec(num@),\n        k == num@.len() ==> result@ == seq!['0'],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "}\n\nfn main() {\n    // // Apps difficulty: interview\n    // // Assurance level: unguarded\n    // \n    // println!(\"{}\", remove_k_digits(\"1432219\", 3)); // Should print \"1219\"\n    // println!(\"{}\", remove_k_digits(\"10200\", 1));   // Should print \"200\"\n    // println!(\"{}\", remove_k_digits(\"10\", 2));      // Should print \"0\"\n}"}
{"id": "fvapps_000227", "vc-description": "Given an unsorted integer array, find the smallest missing positive integer.\n\nExample 1:\n\nInput: [1,2,0]\nOutput: 3\n\nExample 2:\n\nInput: [3,4,-1,1]\nOutput: 2\n\nExample 3:\n\nInput: [7,8,9,11,12]\nOutput: 1\n\nNote:\n\nYour algorithm should run in O(n) time and uses constant extra space.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn contains_positive(xs: Seq<i32>, val: i32) -> bool {\n    exists|i: int| 0 <= i < xs.len() && xs[i] == val && val > 0\n}\n\nspec fn all_positives_below(xs: Seq<i32>, bound: i32) -> bool {\n    forall|i: i32| 1 <= i < bound ==> contains_positive(xs, i)\n}\n\nspec fn seq_from_vec(v: Vec<i32>) -> Seq<i32>;\n\nfn find_first_missing_positive(xs: Vec<i32>) -> (result: u32)\n    ensures \n        result > 0,\n        !contains_positive(seq_from_vec(xs), result as i32),\n        all_positives_below(seq_from_vec(xs), result as i32),", "vc-code": "{\n    // impl-start\n    assume(false);\n    1\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded_and_plausible\n\n    // let result1 = find_first_missing_positive(vec![1, 2, 0]);\n    // assert_eq!(result1, 3);\n\n    // let result2 = find_first_missing_positive(vec![3, 4, -1, 1]);\n    // assert_eq!(result2, 2);\n\n    // let result3 = find_first_missing_positive(vec![7, 8, 9, 11, 12]);\n    // assert_eq!(result3, 1);\n}"}
{"id": "fvapps_000228", "vc-description": "In LOL world, there is a hero called Teemo and his attacking can make his enemy Ashe be in poisoned condition. Now, given the Teemo's attacking ascending time series towards Ashe and the poisoning time duration per Teemo's attacking, you need to output the total time that Ashe is in poisoned condition.\n\nYou may assume that Teemo attacks at the very beginning of a specific time point, and makes Ashe be in poisoned condition immediately.\n\nExample 1:\n\nInput: [1,4], 2\nOutput: 4\nExplanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned immediately. This poisoned status will last 2 seconds until the end of time point 2. And at time point 4, Teemo attacks Ashe again, and causes Ashe to be in poisoned status for another 2 seconds. So you finally need to output 4.\n\nExample 2:\n\nInput: [1,2], 2\nOutput: 3\nExplanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned. This poisoned status will last 2 seconds until the end of time point 2. However, at the beginning of time point 2, Teemo attacks Ashe again who is already in poisoned status. Since the poisoned status won't add up together, though the second poisoning attack will still work at time point 2, it will stop at the end of time point 3. So you finally need to output 3.\n\nNote:\n\nYou may assume the length of given time series array won't exceed 10000.\nYou may assume the numbers in the Teemo's attacking time series and his poisoning time duration per attacking are non-negative integers, which won't exceed 10,000,000.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn find_poisoned_duration(time_series: Vec<i32>, duration: i32) -> (result: i32)\n    requires duration > 0,\n    ensures \n        result >= 0,\n        time_series.len() == 0 ==> result == 0,\n        time_series.len() > 0 ==> result <= (time_series[time_series.len() - 1] - time_series[0]) + duration", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded\n    \n    // Example test cases:\n    // find_poisoned_duration([1, 4], 2) should return 4\n    // find_poisoned_duration([1, 2], 2) should return 3\n    // find_poisoned_duration([], 5) should return 0\n}"}
{"id": "fvapps_000229", "vc-description": "In a N x N grid composed of 1 x 1 squares, each 1 x 1 square consists of a /, \\, or blank space.  These characters divide the square into contiguous regions.\n(Note that backslash characters are escaped, so a \\ is represented as \"\\\\.\")\nReturn the number of regions.\n\nExample 1:\nInput:\n[\n  \" /\",\n  \"/ \"\n]\nOutput: 2\nExplanation: The 2x2 grid is as follows:\n\nExample 2:\nInput:\n[\n  \" /\",\n  \"  \"\n]\nOutput: 1\nExplanation: The 2x2 grid is as follows:\n\nExample 3:\nInput:\n[\n  \"\\\\/\",\n  \"/\\\\\"\n]\nOutput: 4\nExplanation: (Recall that because \\ characters are escaped, \"\\\\/\" refers to \\/, and \"/\\\\\" refers to /\\.)\nThe 2x2 grid is as follows:\n\nExample 4:\nInput:\n[\n  \"/\\\\\",\n  \"\\\\/\"\n]\nOutput: 5\nExplanation: (Recall that because \\ characters are escaped, \"/\\\\\" refers to /\\, and \"\\\\/\" refers to \\/.)\nThe 2x2 grid is as follows:\n\nExample 5:\nInput:\n[\n  \"//\",\n  \"/ \"\n]\nOutput: 3\nExplanation: The 2x2 grid is as follows:\n\nNote:\n\n1 <= grid.length == grid[0].length <= 30\ngrid[i][j] is either '/', '\\', or ' '.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn regions_by_slashes(grid: Seq<Seq<char>>) -> (result: nat)\n    requires \n        grid.len() > 0,\n        grid.len() <= 30,\n        #[trigger] grid[0].len() <= 30,\n        forall|i: int| 0 <= i < grid.len() ==> #[trigger] grid[i].len() == grid[0].len(),\n    ensures \n        result > 0,\n        result <= 4 * grid.len() * grid.len(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000231", "vc-description": "A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\n\nFor example, these are arithmetic sequence:\n1, 3, 5, 7, 9\n7, 7, 7, 7\n3, -1, -5, -9\n\nThe following sequence is not arithmetic. 1, 1, 2, 5, 7 \n\nA zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 \n\nA slice (P, Q) of array A is called arithmetic if the sequence:\n    A[P], A[p + 1], ..., A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 < Q.\n\nThe function should return the number of arithmetic slices in the array A. \n\nExample:\n\nA = [1, 2, 3, 4]\n\nreturn: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn number_of_arithmetic_slices(nums: Vec<i32>) -> (result: usize)\n    ensures \n        result >= 0,\n        nums.len() < 3 ==> result == 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000232", "vc-description": "A string of '0's and '1's is monotone increasing if it consists of some number of '0's (possibly 0), followed by some number of '1's (also possibly 0.)\nWe are given a string S of '0's and '1's, and we may flip any '0' to a '1' or a '1' to a '0'.\nReturn the minimum number of flips to make S monotone increasing.\n\nExample 1:\nInput: \"00110\"\nOutput: 1\nExplanation: We flip the last digit to get 00111.\n\nExample 2:\nInput: \"010110\"\nOutput: 2\nExplanation: We flip to get 011111, or alternatively 000111.\n\nExample 3:\nInput: \"00011000\"\nOutput: 2\nExplanation: We flip to get 00000000.\n\nNote:\n\n1 <= S.length <= 20000\nS only consists of '0' and '1' characters.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn min_flips_mono_incr(s: Vec<char>) -> (result: usize)\n    requires s.len() > 0,\n    ensures result <= s.len()", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n/* Apps difficulty: interview */\n/* Assurance level: guarded_and_plausible */\n\n}\n\nfn main() {\n    // let test1 = vec!['0', '0', '1', '1', '0'];\n    // println!(\"{}\", min_flips_mono_incr(test1)); // Expected: 1\n    \n    // let test2 = vec!['0', '1', '0', '1', '1', '0'];\n    // println!(\"{}\", min_flips_mono_incr(test2)); // Expected: 2\n    \n    // let test3 = vec!['0', '0', '0', '1', '1', '0', '0', '0'];\n    // println!(\"{}\", min_flips_mono_incr(test3)); // Expected: 2\n}"}
{"id": "fvapps_000233", "vc-description": "In an array A of 0s and 1s, how many non-empty subarrays have sum S?\n\nExample 1:\nInput: A = [1,0,1,0,1], S = 2\nOutput: 4\nExplanation: \nThe 4 subarrays are bolded below:\n[1,0,1,0,1]\n[1,0,1,0,1]\n[1,0,1,0,1]\n[1,0,1,0,1]\n\nNote:\n\nA.length <= 30000\n0 <= S <= A.length\nA[i] is either 0 or 1.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn seq_sum(nums: Seq<u32>) -> int\n    decreases nums.len()\n{\n    if nums.len() == 0 {\n        0\n    } else {\n        nums[0] as int + seq_sum(nums.skip(1))\n    }\n}", "vc-spec": "fn num_subarrays_with_sum(nums: Vec<u32>, target: u32) -> (result: u32)\n    requires forall|i: int| 0 <= i < nums.len() ==> nums[i] <= 1,\n    ensures \n        target as int > seq_sum(nums@) ==> result == 0,\n        nums@.len() > 0 && seq_sum(nums@) > 0 && target as int == seq_sum(nums@) ==> result >= 1,\n        target == 0 && nums@.len() > 0 && (forall|i: int| 0 <= i < nums.len() ==> nums[i] == 0) \n            ==> result == (nums@.len() as u32 * (nums@.len() as u32 + 1)) / 2,\n        nums@.len() > 0 && seq_sum(nums@) > 0 && target == 1 ==> result as int >= seq_sum(nums@)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let result1 = num_subarrays_with_sum(vec![1, 0, 1, 0, 1], 2);\n    // assert(result1 == 4);\n    \n    // let result2 = num_subarrays_with_sum(vec![0, 0, 0, 0, 0], 0);\n    // assert(result2 == 15);\n}"}
{"id": "fvapps_000234", "vc-description": "Say you have an array for which the ith element is the price of a given stock on day i.\n\nDesign an algorithm to find the maximum profit. You may complete at most two transactions.\n\nNote: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).\n\nExample 1:\n\nInput: [3,3,5,0,0,3,1,4]\nOutput: 6\nExplanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\n             Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.\n\nExample 2:\n\nInput: [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\n             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are\n             engaging multiple transactions at the same time. You must sell before buying again.\n\nExample 3:\n\nInput: [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transaction is done, i.e. max profit = 0.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_descending(prices: Seq<u32>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < prices.len() ==> prices[i] >= prices[j]\n}\n\nspec fn is_ascending(prices: Seq<u32>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < prices.len() ==> prices[i] <= prices[j]\n}\n\nspec fn is_constant(prices: Seq<u32>) -> bool {\n    forall|i: int, j: int| 0 <= i < prices.len() && 0 <= j < prices.len() ==> prices[i] == prices[j]\n}\n\nfn max_profit(prices: Vec<u32>) -> (result: u32)\n    ensures \n        result >= 0,\n        prices.len() == 0 ==> result == 0,\n        prices.len() > 0 && is_descending(prices@) ==> result == 0,\n        prices.len() > 0 && is_constant(prices@) ==> result == 0,\n        prices.len() >= 4 && is_ascending(prices@) ==> \n            result <= (prices[prices.len() - 1] - prices[0]) + (prices[prices.len() - 2] - prices[1]),\n        prices.len() >= 2 && prices.len() < 4 && is_ascending(prices@) ==> \n            result == prices[prices.len() - 1] - prices[0]", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // println!(\"{}\", max_profit(vec![3, 3, 5, 0, 0, 3, 1, 4])); // Expected: 6\n    // println!(\"{}\", max_profit(vec![1, 2, 3, 4, 5]));          // Expected: 4  \n    // println!(\"{}\", max_profit(vec![7, 6, 4, 3, 1]));          // Expected: 0\n}"}
{"id": "fvapps_000238", "vc-description": "Given an array nums of positive integers, return the longest possible length of an array prefix of nums, such that it is possible to remove exactly one element from this prefix so that every number that has appeared in it will have the same number of occurrences.\nIf after removing one element there are no remaining elements, it's still considered that every appeared number has the same number of ocurrences (0).\n\nExample 1:\nInput: nums = [2,2,1,1,5,3,3,5]\nOutput: 7\nExplanation: For the subarray [2,2,1,1,5,3,3] of length 7, if we remove nums[4]=5, we will get [2,2,1,1,3,3], so that each number will appear exactly twice.\n\nExample 2:\nInput: nums = [1,1,1,2,2,2,3,3,3,4,4,4,5]\nOutput: 13\n\nExample 3:\nInput: nums = [1,1,1,2,2,2]\nOutput: 5\n\nExample 4:\nInput: nums = [10,2,8,9,3,8,1,5,2,3,7,6]\nOutput: 8\n\nConstraints:\n\n2 <= nums.length <= 10^5\n1 <= nums[i] <= 10^5", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn max_equal_freq(nums: Vec<u32>) -> (result: usize)\n    requires \n        nums.len() >= 2,\n        nums.len() <= 100000,\n        forall|i: int| 0 <= i < nums.len() ==> #[trigger] nums[i] >= 1 && #[trigger] nums[i] <= 100000,\n    ensures\n        result <= nums.len(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let result1 = max_equal_freq(vec![2, 2, 1, 1, 5, 3, 3, 5]);\n    // println!(\"Result 1: {}\", result1); // Expected: 7\n    \n    // let result2 = max_equal_freq(vec![1, 1, 1, 2, 2, 2]);\n    // println!(\"Result 2: {}\", result2); // Expected: 5\n    \n    // let result3 = max_equal_freq(vec![1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5]);\n    // println!(\"Result 3: {}\", result3); // Expected: 13\n}"}
{"id": "fvapps_000239", "vc-description": "On a table are N cards, with a positive integer printed on the front and back of each card (possibly different).\nWe flip any number of cards, and after we choose one card. \nIf the number X on the back of the chosen card is not on the front of any card, then this number X is good.\nWhat is the smallest number that is good?  If no number is good, output 0.\nHere, fronts[i] and backs[i] represent the number on the front and back of card i. \nA flip swaps the front and back numbers, so the value on the front is now on the back and vice versa.\nExample:\nInput: fronts = [1,2,4,4,7], backs = [1,3,4,1,3]\nOutput: 2\nExplanation: If we flip the second card, the fronts are [1,3,4,4,7] and the backs are [1,2,4,1,3].\nWe choose the second card, which has number 2 on the back, and it isn't on the front of any card, so 2 is good.\n\nNote:\n\n1 <= fronts.length == backs.length <= 1000.\n1 <= fronts[i] <= 2000.\n1 <= backs[i] <= 2000.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_in_list(val: nat, list: Seq<nat>) -> bool {\n    exists|i: int| 0 <= i < list.len() && list[i] == val\n}\n\nspec fn same_front_back(fronts: Seq<nat>, backs: Seq<nat>, val: nat) -> bool {\n    exists|i: int| 0 <= i < fronts.len() && fronts[i] == backs[i] && fronts[i] == val\n}\n\nfn flipgame(fronts: Vec<nat>, backs: Vec<nat>) -> (result: nat)\n    requires fronts.len() == backs.len(),\n    ensures\n        result != 0 ==> is_in_list(result, fronts@) || is_in_list(result, backs@),\n        result != 0 ==> !same_front_back(fronts@, backs@, result),\n        result != 0 ==> forall|n: nat| #[trigger] is_in_list(n, fronts@) || is_in_list(n, backs@) ==>\n                            !same_front_back(fronts@, backs@, n) ==> result <= n,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let test1 = flipgame(vec![1, 2, 4, 4, 7], vec![1, 3, 4, 1, 3]);\n    // assert(test1 == 2);\n    \n    // let test2 = flipgame(vec![1, 1], vec![1, 1]);\n    // assert(test2 == 0);\n    \n    // let test3 = flipgame(vec![1, 2], vec![2, 1]);\n    // assert(test3 == 1);\n}"}
{"id": "fvapps_000241", "vc-description": "Given a list of positive integers, the adjacent integers will perform the float division. For example, [2,3,4] -> 2 / 3 / 4.\n\nHowever, you can add any number of parenthesis at any position to change the priority of operations. You should find out how to add parenthesis to get the maximum result, and return the corresponding expression in string format. Your expression should NOT contain redundant parenthesis.\n\nExample:\n\nInput: [1000,100,10,2]\nOutput: \"1000/(100/10/2)\"\nExplanation:\n1000/(100/10/2) = 1000/((100/10)/2) = 200\nHowever, the bold parenthesis in \"1000/((100/10)/2)\" are redundant, since they don't influence the operation priority. So you should return \"1000/(100/10/2)\". \n\nOther cases:\n1000/(100/10)/2 = 50\n1000/(100/(10/2)) = 50\n1000/100/10/2 = 0.5\n1000/100/(10/2) = 2\n\nNote:\n\nThe length of the input array is [1, 10].\nElements in the given array will be in range [2, 1000].\nThere is only one optimal division for each test case.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn optimal_division(nums: Vec<u32>) -> (result: String)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000246", "vc-description": "There are N workers.  The i-th worker has a quality[i] and a minimum wage expectation wage[i].\nNow we want to hire exactly K workers to form a paid group.  When hiring a group of K workers, we must pay them according to the following rules:\n\nEvery worker in the paid group should be paid in the ratio of their quality compared to other workers in the paid group.\nEvery worker in the paid group must be paid at least their minimum wage expectation.\n\nReturn the least amount of money needed to form a paid group satisfying the above conditions.\n\nExample 1:\nInput: quality = [10,20,5], wage = [70,50,30], K = 2\nOutput: 105.00000\nExplanation: We pay 70 to 0-th worker and 35 to 2-th worker.\n\nExample 2:\nInput: quality = [3,1,10,10,1], wage = [4,8,2,2,7], K = 3\nOutput: 30.66667\nExplanation: We pay 4 to 0-th worker, 13.33333 to 2-th and 3-th workers seperately. \n\nNote:\n\n1 <= K <= N <= 10000, where N = quality.length = wage.length\n1 <= quality[i] <= 10000\n1 <= wage[i] <= 10000\nAnswers within 10^-5 of the correct answer will be considered correct.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn min_cost_to_hire_workers(quality: Vec<i32>, wage: Vec<i32>, k: i32) -> (result: f64)\n    requires \n        quality.len() == wage.len(),\n        quality.len() > 0,\n        1 <= k <= quality.len(),\n        forall|i: int| 0 <= i < quality.len() ==> 1 <= quality[i] && quality[i] <= 100,\n        forall|i: int| 0 <= i < wage.len() ==> 1 <= wage[i] && wage[i] <= 1000,", "vc-code": "{\n    // impl-start\n    assume(false);\n    0.0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000247", "vc-description": "Normally, the factorial of a positive integer n is the product of all positive integers less than or equal to n.  For example, factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1.\nWe instead make a clumsy factorial: using the integers in decreasing order, we swap out the multiply operations for a fixed rotation of operations: multiply (*), divide (/), add (+) and subtract (-) in this order.\nFor example, clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1.  However, these operations are still applied using the usual order of operations of arithmetic: we do all multiplication and division steps before any addition or subtraction steps, and multiplication and division steps are processed left to right.\nAdditionally, the division that we use is floor division such that 10 * 9 / 8 equals 11.  This guarantees the result is an integer.\nImplement the clumsy function as defined above: given an integer N, it returns the clumsy factorial of N.\n\nExample 1:\nInput: 4\nOutput: 7\nExplanation: 7 = 4 * 3 / 2 + 1\n\nExample 2:\nInput: 10\nOutput: 12\nExplanation: 12 = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1\n\nNote:\n\n1 <= N <= 10000\n-2^31 <= answer <= 2^31 - 1  (The answer is guaranteed to fit within a 32-bit integer.)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn abs(n: int) -> int {\n    if n < 0 { -n } else { n }\n}", "vc-helpers": "", "vc-spec": "fn clumsy(n: u32) -> (result: i32)\n    requires n >= 1 && n <= 10000,\n    ensures \n        n == 1 ==> result == 1,\n        n == 2 ==> result == 2,\n        n >= 3 && n <= 100 ==> (n as int) - 1 <= result && result <= (n as int) + 3", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // println!(\"{}\", clumsy(4));\n    // println!(\"{}\", clumsy(10)); \n    // println!(\"{}\", clumsy(1));\n}"}
{"id": "fvapps_000248", "vc-description": "There is a one-dimensional garden on the x-axis. The garden starts at the point 0 and ends at the point n. (i.e The length of the garden is n).\nThere are n + 1 taps located at points [0, 1, ..., n] in the garden.\nGiven an integer n and an integer array ranges of length n + 1 where ranges[i] (0-indexed) means the i-th tap can water the area [i - ranges[i], i + ranges[i]] if it was open.\nReturn the minimum number of taps that should be open to water the whole garden, If the garden cannot be watered return -1.\n\nExample 1:\n\nInput: n = 5, ranges = [3,4,1,1,0,0]\nOutput: 1\nExplanation: The tap at point 0 can cover the interval [-3,3]\nThe tap at point 1 can cover the interval [-3,5]\nThe tap at point 2 can cover the interval [1,3]\nThe tap at point 3 can cover the interval [2,4]\nThe tap at point 4 can cover the interval [4,4]\nThe tap at point 5 can cover the interval [5,5]\nOpening Only the second tap will water the whole garden [0,5]\n\nExample 2:\nInput: n = 3, ranges = [0,0,0,0]\nOutput: -1\nExplanation: Even if you activate all the four taps you cannot water the whole garden.\n\nExample 3:\nInput: n = 7, ranges = [1,2,1,0,2,1,0,1]\nOutput: 3\n\nExample 4:\nInput: n = 8, ranges = [4,0,0,0,0,0,0,0,4]\nOutput: 2\n\nExample 5:\nInput: n = 8, ranges = [4,0,0,0,4,0,0,0,4]\nOutput: 1\n\nConstraints:\n\n1 <= n <= 10^4\nranges.length == n + 1\n0 <= ranges[i] <= 100", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn min_taps(n: i32, ranges: Vec<i32>) -> (result: i32)\n    requires \n        n >= 1,\n        n <= 10000,\n        ranges.len() == (n + 1) as usize,\n        forall|i: int| 0 <= i < ranges.len() ==> #[trigger] ranges[i] >= 0 && ranges[i] <= 100,\n    ensures\n        result == -1 || result >= 1,", "vc-code": "{\n    // impl-start\n    assume(false);\n    -1\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // // Apps difficulty: interview\n    // // Assurance level: unguarded\n\n    // // Example evaluations:\n    // // min_taps(5, vec![3, 4, 1, 1, 0, 0]) should return 1\n    // // min_taps(3, vec![0, 0, 0, 0]) should return -1\n    // // min_taps(7, vec![1, 2, 1, 0, 2, 1, 0, 1]) should return 3\n}"}
{"id": "fvapps_000250", "vc-description": "Given a non-negative integer n, count all numbers with unique digits, x, where 0 ≤ x < 10^n.\n\nExample:\nGiven n = 2, return 91. (The answer should be the total numbers in the range of 0 ≤ x < 100, excluding [11,22,33,44,55,66,77,88,99])\n\nCredits: Special thanks to @memoryless for adding this problem and creating all test cases.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn count_numbers_with_unique_digits(n: u32) -> (result: u32)\n    ensures \n        result > 0,\n        n == 0 ==> result == 1,\n        n == 1 ==> result == 10", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded\n\n    // Example outputs:\n    // count_numbers_with_unique_digits(2) should return 91\n    // count_numbers_with_unique_digits(0) should return 1  \n    // count_numbers_with_unique_digits(1) should return 10\n}"}
{"id": "fvapps_000251", "vc-description": "Given an array of non-negative integers, you are initially positioned at the first index of the array.\n\nEach element in the array represents your maximum jump length at that position.\n\nYour goal is to reach the last index in the minimum number of jumps.\n\nExample:\n\nInput: [2,3,1,1,4]\nOutput: 2\nExplanation: The minimum number of jumps to reach the last index is 2.\n    Jump 1 step from index 0 to 1, then 3 steps to the last index.\n\nNote:\n\nYou can assume that you can always reach the last index.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn jump_spec(v: Seq<usize>) -> usize;\n\nfn jump(v: Vec<usize>) -> (result: usize)\n    requires v.len() > 0,\n    ensures \n        result == jump_spec(v@),\n        /* Property that result is the minimum number of jumps to reach the last index */", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "proof fn jump_single_element(n: usize)\n    ensures jump_spec(seq![n]) == 0\n{\n    assume(false);\n}\n\nproof fn jump_two_elements()\n    ensures jump_spec(seq![2, 1]) == 1\n{\n    assume(false);\n}\n\nproof fn jump_three_ones()\n    ensures jump_spec(seq![1, 1, 1]) == 2\n{\n    assume(false);\n}\n\nproof fn jump_complex_case1()\n    ensures jump_spec(seq![2, 3, 1, 1, 4]) == 2\n{\n    assume(false);\n}\n\nproof fn jump_complex_case2()\n    ensures jump_spec(seq![2, 1, 1, 1]) == 2\n{\n    assume(false);\n}\n\nproof fn jump_ascending()\n    ensures jump_spec(seq![1, 2, 3]) == 2\n{\n    assume(false);\n}\n\nproof fn jump_long_sequence()\n    ensures jump_spec(seq![5, 9, 3, 2, 1, 0, 2, 3, 3, 1, 0, 0]) == 3\n{\n    assume(false);\n}\n\nproof fn jump_descending()\n    ensures jump_spec(seq![3, 2, 1]) == 1\n{\n    assume(false);\n}\n\nproof fn jump_mixed_sequence()\n    ensures jump_spec(seq![4, 1, 1, 3, 1, 1, 1]) == 2\n{\n    assume(false);\n}\n\n}\n\nfn main() {\n    // println!(\"{}\", jump(vec![2, 3, 1, 1, 4]));\n    // println!(\"{}\", jump(vec![1, 2, 3]));\n    // println!(\"{}\", jump(vec![1]));\n}"}
{"id": "fvapps_000253", "vc-description": "You are given an undirected weighted graph of n nodes (0-indexed), represented by an edge list where edges[i] = [a, b] is an undirected edge connecting the nodes a and b with a probability of success of traversing that edge succProb[i].\nGiven two nodes start and end, find the path with the maximum probability of success to go from start to end and return its success probability.\nIf there is no path from start to end, return 0. Your answer will be accepted if it differs from the correct answer by at most 1e-5.\n\nExample 1:\n\nInput: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2\nOutput: 0.25000\nExplanation: There are two paths from start to end, one having a probability of success = 0.2 and the other has 0.5 * 0.5 = 0.25.\n\nExample 2:\n\nInput: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.3], start = 0, end = 2\nOutput: 0.30000\n\nExample 3:\n\nInput: n = 3, edges = [[0,1]], succProb = [0.5], start = 0, end = 2\nOutput: 0.00000\nExplanation: There is no path between 0 and 2.\n\nConstraints:\n\n2 <= n <= 10^4\n0 <= start, end < n\nstart != end\n0 <= a, b < n\na != b\n0 <= succProb.length == edges.length <= 2*10^4\n0 <= succProb[i] <= 1\nThere is at most one edge between every two nodes.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn max_probability(n: usize, edges: Vec<Vec<usize>>, probs: Vec<f64>, s: usize, t: usize) -> (result: f64)\n    requires \n        n >= 2,\n        s < n,\n        t < n,\n        edges.len() == probs.len(),\n        forall|i: int| 0 <= i < edges.len() ==> edges[i].len() == 2,\n        forall|i: int| 0 <= i < edges.len() ==> edges[i][0] < n && edges[i][1] < n,\n        forall|i: int| 0 <= i < edges.len() ==> edges[i][0] != edges[i][1],", "vc-code": "{\n    // impl-start\n    assume(false);\n    0.0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000262", "vc-description": "Given an array nums of 0s and 1s and an integer k, return True if all 1's are at least k places away from each other, otherwise return False.\n\nExample 1:\n\nInput: nums = [1,0,0,0,1,0,0,1], k = 2\nOutput: true\nExplanation: Each of the 1s are at least 2 places away from each other.\n\nExample 2:\n\nInput: nums = [1,0,0,1,0,1], k = 2\nOutput: false\nExplanation: The second 1 and third 1 are only one apart from each other.\nExample 3:\nInput: nums = [1,1,1,1,1], k = 0\nOutput: true\n\nExample 4:\nInput: nums = [0,1,0,1], k = 1\nOutput: true\n\nConstraints:\n\n1 <= nums.length <= 10^5\n0 <= k <= nums.length\nnums[i] is 0 or 1", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn k_length_apart(nums: Vec<usize>, k: usize) -> (result: bool)\n    requires \n        nums.len() >= 1,\n        nums.len() <= 100000,\n        k <= nums.len(),\n        forall|i: int| 0 <= i < nums.len() ==> nums[i] <= 1,\n    ensures\n        result == true ==> (\n            forall|i: int, j: int| \n                0 <= i < nums.len() && 0 <= j < nums.len() && \n                nums[i] == 1 && nums[j] == 1 && i < j ==> \n                j - i > k\n        ),\n        result == false ==> (\n            exists|i: int, j: int| \n                0 <= i < nums.len() && 0 <= j < nums.len() && \n                nums[i] == 1 && nums[j] == 1 && i < j && \n                j - i <= k\n        ),", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let test1 = vec![1, 0, 0, 0, 1, 0, 0, 1];\n    // let result1 = k_length_apart(test1, 2);\n    // assert!(result1 == true);\n    \n    // let test2 = vec![1, 0, 0, 1, 0, 1];\n    // let result2 = k_length_apart(test2, 2);\n    // assert!(result2 == false);\n    \n    // let test3 = vec![0, 1, 0, 1];\n    // let result3 = k_length_apart(test3, 1);\n    // assert!(result3 == true);\n}"}
{"id": "fvapps_000264", "vc-description": "Given an array of non-negative integers, you are initially positioned at the first index of the array.\n\nEach element in the array represents your maximum jump length at that position.\n\nDetermine if you are able to reach the last index.\n\nExample 1:\n\nInput: [2,3,1,1,4]\nOutput: true\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.\n\nExample 2:\n\nInput: [3,2,1,0,4]\nOutput: false\nExplanation: You will always arrive at index 3 no matter what. Its maximum\n             jump length is 0, which makes it impossible to reach the last index.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn can_jump(nums: Vec<nat>) -> (result: bool)\n    requires nums.len() > 0,\n    ensures\n        /* Single element arrays are always reachable */\n        nums.len() == 1 ==> result == true,\n        /* If all non-last elements are non-zero, end is reachable */\n        (nums.len() > 0 && forall|i: int| 0 <= i < nums.len() - 1 ==> nums[i] > 0) ==> result == true,\n        /* If first element is zero and array has more than one element, end is not reachable */\n        (nums.len() > 1 && nums[0] == 0) ==> result == false,\n        /* If there's a zero at position and we can still reach the end, \n           then there must be some earlier position that can jump past it */\n        forall|idx: int| 0 <= idx < nums.len() - 1 && nums[idx] == 0 && result == true ==>\n            exists|j: int| 0 <= j < idx && j + nums[j] > idx", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "}\n\nfn main() {\n    // /* Apps difficulty: interview */\n    // /* Assurance level: unguarded */\n\n    // /* Example evaluations */\n    // /* can_jump([2, 3, 1, 1, 4]) should return true */\n    // /* can_jump([3, 2, 1, 0, 4]) should return false */\n    // /* can_jump([0]) should return true */\n}"}
{"id": "fvapps_000266", "vc-description": "Your car starts at position 0 and speed +1 on an infinite number line.  (Your car can go into negative positions.)\nYour car drives automatically according to a sequence of instructions A (accelerate) and R (reverse).\nWhen you get an instruction \"A\", your car does the following: position += speed, speed *= 2.\nWhen you get an instruction \"R\", your car does the following: if your speed is positive then speed = -1 , otherwise speed = 1.  (Your position stays the same.)\nFor example, after commands \"AAR\", your car goes to positions 0->1->3->3, and your speed goes to 1->2->4->-1.\nNow for some target position, say the length of the shortest sequence of instructions to get there.\nExample 1:\nInput: \ntarget = 3\nOutput: 2\nExplanation: \nThe shortest instruction sequence is \"AA\".\nYour position goes from 0->1->3.\n\nExample 2:\nInput: \ntarget = 6\nOutput: 5\nExplanation: \nThe shortest instruction sequence is \"AAARA\".\nYour position goes from 0->1->3->7->7->6.\n\nNote: \n\n1 <= target <= 10000.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn log2_upper_bound(n: nat) -> nat \n    decreases n\n{\n    if n <= 1 { 0 } else { 1 + log2_upper_bound(n / 2) }\n}\n\nfn racecar(target: nat) -> (result: nat)\n    requires target > 0,\n    ensures \n        result > 0,\n        result <= 4 * log2_upper_bound(target),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n/* Apps difficulty: interview\n   Assurance level: unguarded */\n\n}\n\nfn main() {\n    // assert(racecar(3) == 2);\n    // assert(racecar(6) == 5);\n    // assert(racecar(4) == 5);\n}"}
{"id": "fvapps_000268", "vc-description": "Given a string containing only three types of characters: '(', ')' and '*', write a function to check whether this string is valid. We define the validity of a string by these rules:\n\nAny left parenthesis '(' must have a corresponding right parenthesis ')'.\nAny right parenthesis ')' must have a corresponding left parenthesis '('.\nLeft parenthesis '(' must go before the corresponding right parenthesis ')'.\n'*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string.\nAn empty string is also valid.\n\nExample 1:\n\nInput: \"()\"\nOutput: True\n\nExample 2:\n\nInput: \"(*)\"\nOutput: True\n\nExample 3:\n\nInput: \"(*))\"\nOutput: True\n\nNote:\n\nThe string size will be in the range [1, 100].", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn count_char(s: Seq<char>, c: char) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0nat\n    } else {\n        (if s[0] == c { 1nat } else { 0nat }) + count_char(s.skip(1), c)\n    }\n}\n\n#[verifier::external_body]\nspec fn is_balanced_without_stars(s: Seq<char>) -> bool {\n    unimplemented!()\n}\n\nfn check_valid_string(s: &str) -> (result: bool)\n    ensures\n        s == \"\" ==> result == true,\n        s == \"*\" ==> result == true,\n        (forall|c: char| s@.contains(c) ==> (c == '(' || c == ')')) ==> \n            result == is_balanced_without_stars(s@),\n        count_char(s@, ')') > count_char(s@, '(') + count_char(s@, '*') ==> \n            result == false", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let result1 = check_valid_string(\"()\");\n    // println!(\"Result for '()': {}\", result1);\n    \n    // let result2 = check_valid_string(\"(*)\");\n    // println!(\"Result for '(*)': {}\", result2);\n    \n    // let result3 = check_valid_string(\"(*))\");\n    // println!(\"Result for '(*))': {}\", result3);\n}"}
{"id": "fvapps_000269", "vc-description": "Think about Zuma Game. You have a row of balls on the table, colored red(R), yellow(Y), blue(B), green(G), and white(W). You also have several balls in your hand.\n\nEach time, you may choose a ball in your hand, and insert it into the row (including the leftmost place and rightmost place). Then, if there is a group of 3 or more balls in the same color touching, remove these balls. Keep doing this until no more balls can be removed.\n\nFind the minimal balls you have to insert to remove all the balls on the table. If you cannot remove all the balls, output -1.\n\nExamples:\nInput: \"WRRBBW\", \"RB\"\nOutput: -1\nExplanation: WRRBBW -> WRR[R]BBW -> WBBW -> WBB[B]W -> WW\n\nInput: \"WWRRBBWW\", \"WRBRW\"\nOutput: 2\nExplanation: WWRRBBWW -> WWRR[R]BBWW -> WWBBWW -> WWBB[B]WW -> WWWW -> empty\n\nInput:\"G\", \"GGGGG\"\nOutput: 2\nExplanation: G -> G[G] -> GG[G] -> empty \n\nInput: \"RBYYBBRRB\", \"YRBGB\"\nOutput: 3\nExplanation: RBYYBBRRB -> RBYY[Y]BBRRB -> RBBBRRB -> RRRB -> B -> B[B] -> BB[B] -> empty \n\nNote:\n\nYou may assume that the initial row of balls on the table won't have any 3 or more consecutive balls with the same color.\nThe number of balls on the table won't exceed 20, and the string represents these balls is called \"board\" in the input.\nThe number of balls in your hand won't exceed 5, and the string represents these balls is called \"hand\" in the input.\nBoth input strings will be non-empty and only contain characters 'R','Y','B','G','W'.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn find_min_step(board: &str, hand: &str) -> (result: i32)\n    ensures result >= -1\n{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-code": "", "vc-postamble": "}\n\nfn main() {\n    // println!(\"{}\", find_min_step(\"WRRBBW\", \"RB\"));\n    // println!(\"{}\", find_min_step(\"WWRRBBWW\", \"WRBRW\"));\n    // println!(\"{}\", find_min_step(\"G\", \"GGGGG\"));\n}"}
{"id": "fvapps_000271", "vc-description": "Given an integer array of digits, return the largest multiple of three that can be formed by concatenating some of the given digits in any order.\nSince the answer may not fit in an integer data type, return the answer as a string.\nIf there is no answer return an empty string.\n\nExample 1:\nInput: digits = [8,1,9]\nOutput: \"981\"\n\nExample 2:\nInput: digits = [8,6,7,1,0]\nOutput: \"8760\"\n\nExample 3:\nInput: digits = [1]\nOutput: \"\"\n\nExample 4:\nInput: digits = [0,0,0,0,0,0]\nOutput: \"0\"\n\nConstraints:\n\n1 <= digits.length <= 10^4\n0 <= digits[i] <= 9\nThe returning answer must not contain unnecessary leading zeros.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn string_to_nat(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        let digit = (s[0] as u8 - '0' as u8) as nat;\n        digit * pow(10, (s.len() - 1) as nat) + string_to_nat(s.skip(1))\n    }\n}\n\nspec fn pow(base: nat, exp: nat) -> nat\n    decreases exp\n{\n    if exp == 0 {\n        1\n    } else {\n        base * pow(base, (exp - 1) as nat)\n    }\n}\n\nspec fn count_digit_in_string(s: Seq<char>, d: char) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        let count_rest = count_digit_in_string(s.skip(1), d);\n        if s[0] == d {\n            1 + count_rest\n        } else {\n            count_rest\n        }\n    }\n}\n\nspec fn count_digit_in_list(digits: Seq<u8>, d: u8) -> nat\n    decreases digits.len()\n{\n    if digits.len() == 0 {\n        0\n    } else {\n        let count_rest = count_digit_in_list(digits.skip(1), d);\n        if digits[0] == d {\n            1 + count_rest\n        } else {\n            count_rest\n        }\n    }\n}", "vc-spec": "fn largest_multiple_of_three(digits: Vec<u8>) -> (result: Option<String>)\n    requires\n        digits.len() >= 1,\n        digits.len() <= 10000,\n        forall|i: int| 0 <= i < digits.len() ==> digits[i] <= 9,\n    ensures\n        match result {\n            Some(s) => {\n                /* Result is multiple of three */\n                string_to_nat(s@) % 3 == 0 &&\n                /* Result uses valid digits */\n                forall|d: u8| d <= 9 ==> count_digit_in_string(s@, (d + '0' as u8) as char) <= count_digit_in_list(digits@, d) &&\n                /* Handles leading zeros properly */\n                (s@ == seq!['0'] || s@.len() == 0 || s@[0] != '0')\n            },\n            None => true\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    None\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let result1 = largest_multiple_of_three(vec![9, 8, 1]);\n    // println!(\"Result 1: {:?}\", result1);\n    \n    // let result2 = largest_multiple_of_three(vec![8, 6, 7, 1, 0]);\n    // println!(\"Result 2: {:?}\", result2);\n    \n    // let result3 = largest_multiple_of_three(vec![1]);\n    // println!(\"Result 3: {:?}\", result3);\n}"}
{"id": "fvapps_000272", "vc-description": "The set [1,2,3,...,n] contains a total of n! unique permutations.\n\nBy listing and labeling all of the permutations in order, we get the following sequence for n = 3:\n\n       \"123\"\n       \"132\"\n       \"213\"\n       \"231\"\n       \"312\"\n       \"321\"\n\nGiven n and k, return the kth permutation sequence.\n\nNote:\n\n       Given n will be between 1 and 9 inclusive.\n       Given k will be between 1 and n! inclusive.\n\nExample 1:\n\nInput: n = 3, k = 3\nOutput: \"213\"\n\nExample 2:\n\nInput: n = 4, k = 9\nOutput: \"2314\"", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn factorial(n: nat) -> nat\n    decreases n\n{\n    if n == 0 {\n        1\n    } else {\n        n * factorial((n - 1) as nat)\n    }\n}", "vc-helpers": "", "vc-spec": "fn get_permutation(n: usize, k: usize) -> (result: Vec<char>)\n    requires\n        n >= 1,\n        n <= 9,\n        k >= 1,\n        k <= factorial(n as nat),\n    ensures\n        result.len() == n,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let perm = get_permutation(3, 3);\n    // println!(\"{:?}\", perm); // Should output ['2', '1', '3']\n    // let perm = get_permutation(4, 9);\n    // println!(\"{:?}\", perm); // Should output ['2', '3', '1', '4']\n    // let perm = get_permutation(2, 2);\n    // println!(\"{:?}\", perm); // Should output ['2', '1']\n}"}
{"id": "fvapps_000273", "vc-description": "You are given a string s containing lowercase letters and an integer k. You need to :\n\nFirst, change some characters of s to other lowercase English letters.\nThen divide s into k non-empty disjoint substrings such that each substring is palindrome.\n\nReturn the minimal number of characters that you need to change to divide the string.\n\nExample 1:\nInput: s = \"abc\", k = 2\nOutput: 1\nExplanation: You can split the string into \"ab\" and \"c\", and change 1 character in \"ab\" to make it palindrome.\n\nExample 2:\nInput: s = \"aabbc\", k = 3\nOutput: 0\nExplanation: You can split the string into \"aa\", \"bb\" and \"c\", all of them are palindrome.\nExample 3:\nInput: s = \"leetcode\", k = 8\nOutput: 0\n\nConstraints:\n\n1 <= k <= s.length <= 100.\ns only contains lowercase English letters.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn palindrome_partition(s: Vec<char>, k: usize) -> (result: usize)\n    requires \n        k > 0,\n        k <= s.len(),\n        s.len() > 0,\n    ensures \n        result <= s.len(),\n        k == s.len() ==> result == 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: unguarded\n    \n    // let s1 = vec!['a', 'b', 'c'];\n    // println!(\"{}\", palindrome_partition(s1, 2));\n    // let s2 = vec!['a', 'a', 'b', 'b', 'c'];\n    // println!(\"{}\", palindrome_partition(s2, 3));\n    // let s3 = vec!['l', 'e', 'e', 't', 'c', 'o', 'd', 'e'];\n    // println!(\"{}\", palindrome_partition(s3, 8));\n}"}
{"id": "fvapps_000274", "vc-description": "Given two strings s and t, your goal is to convert s into t in k moves or less.\nDuring the ith (1 <= i <= k) move you can:\n\nChoose any index j (1-indexed) from s, such that 1 <= j <= s.length and j has not been chosen in any previous move, and shift the character at that index i times.\nDo nothing.\n\nShifting a character means replacing it by the next letter in the alphabet (wrapping around so that 'z' becomes 'a'). Shifting a character by i means applying the shift operations i times.\nRemember that any index j can be picked at most once.\nReturn true if it's possible to convert s into t in no more than k moves, otherwise return false.\n\nExample 1:\nInput: s = \"input\", t = \"ouput\", k = 9\nOutput: true\nExplanation: In the 6th move, we shift 'i' 6 times to get 'o'. And in the 7th move we shift 'n' to get 'u'.\n\nExample 2:\nInput: s = \"abc\", t = \"bcd\", k = 10\nOutput: false\nExplanation: We need to shift each character in s one time to convert it into t. We can shift 'a' to 'b' during the 1st move. However, there is no way to shift the other characters in the remaining moves to obtain t from s.\n\nExample 3:\nInput: s = \"aab\", t = \"bbb\", k = 27\nOutput: true\nExplanation: In the 1st move, we shift the first 'a' 1 time to get 'b'. In the 27th move, we shift the second 'a' 27 times to get 'b'.\n\nConstraints:\n\n1 <= s.length, t.length <= 10^5\n0 <= k <= 10^9\ns, t contain only lowercase English letters.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn can_convert_string(s: Vec<u8>, t: Vec<u8>, k: u32) -> (result: bool)\n    ensures\n        (s.len() != t.len()) ==> (result == false),\n        (s == t) ==> (result == true),\n        (s.len() == t.len() && k == 0) ==> (result == (s == t))", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let s1 = \"input\".as_bytes().to_vec();\n    // let t1 = \"ouput\".as_bytes().to_vec();\n    // println!(\"{}\", can_convert_string(s1, t1, 9));\n    \n    // let s2 = \"abc\".as_bytes().to_vec();\n    // let t2 = \"bcd\".as_bytes().to_vec();\n    // println!(\"{}\", can_convert_string(s2, t2, 10));\n    \n    // let s3 = \"aab\".as_bytes().to_vec();\n    // let t3 = \"bbb\".as_bytes().to_vec();\n    // println!(\"{}\", can_convert_string(s3, t3, 27));\n}"}
{"id": "fvapps_000277", "vc-description": "You have an initial power P, an initial score of 0 points, and a bag of tokens.\nEach token can be used at most once, has a value token[i], and has potentially two ways to use it.\n\nIf we have at least token[i] power, we may play the token face up, losing token[i] power, and gaining 1 point.\nIf we have at least 1 point, we may play the token face down, gaining token[i] power, and losing 1 point.\n\nReturn the largest number of points we can have after playing any number of tokens.\n\nExample 1:\nInput: tokens = [100], P = 50\nOutput: 0\n\nExample 2:\nInput: tokens = [100,200], P = 150\nOutput: 1\n\nExample 3:\nInput: tokens = [100,200,300,400], P = 200\nOutput: 2\n\nNote:\n\ntokens.length <= 1000\n0 <= tokens[i] < 10000\n0 <= P < 10000", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn bag_of_tokens_score(tokens: Vec<u32>, power: u32) -> (result: u32)\n    requires \n        tokens.len() <= 1000,\n        (forall|i: int| 0 <= i < tokens.len() ==> tokens[i] < 10000),\n        power < 10000,\n    ensures \n        result <= tokens.len(),\n        result >= 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: unguarded\n\n    // let result1 = bag_of_tokens_score(vec![100], 50);\n    // println!(\"{}\", result1); // Should be 0\n\n    // let result2 = bag_of_tokens_score(vec![100, 200], 150);\n    // println!(\"{}\", result2); // Should be 1\n\n    // let result3 = bag_of_tokens_score(vec![100, 200, 300, 400], 200);\n    // println!(\"{}\", result3); // Should be 2\n}"}
{"id": "fvapps_000278", "vc-description": "Given an array A of integers, for each integer A[i] we need to choose either x = -K or x = K, and add x to A[i] (only once).\nAfter this process, we have some array B.\nReturn the smallest possible difference between the maximum value of B and the minimum value of B.\n\nExample 1:\nInput: A = [1], K = 0\nOutput: 0\nExplanation: B = [1]\n\nExample 2:\nInput: A = [0,10], K = 2\nOutput: 6\nExplanation: B = [2,8]\n\nExample 3:\nInput: A = [1,3,6], K = 3\nOutput: 3\nExplanation: B = [4,6,3]\n\nNote:\n\n1 <= A.length <= 10000\n0 <= A[i] <= 10000\n0 <= K <= 10000", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn maximum(xs: Seq<i32>) -> i32 \n    decreases xs.len()\n{\n    if xs.len() == 0 {\n        0\n    } else if xs.len() == 1 {\n        xs[0]\n    } else {\n        let max_rest = maximum(xs.subrange(1, xs.len() as int));\n        if xs[0] > max_rest { xs[0] } else { max_rest }\n    }\n}\n\nspec fn minimum(xs: Seq<i32>) -> i32 \n    decreases xs.len()\n{\n    if xs.len() == 0 {\n        0\n    } else if xs.len() == 1 {\n        xs[0]\n    } else {\n        let min_rest = minimum(xs.subrange(1, xs.len() as int));\n        if xs[0] < min_rest { xs[0] } else { min_rest }\n    }\n}", "vc-helpers": "", "vc-spec": "fn smallest_range_ii(nums: Vec<i32>, k: i32) -> (result: i32)\n    requires k >= 0\n    ensures \n        result >= 0,\n        nums.len() == 1 ==> result == 0,\n        nums.len() == 0 ==> result == 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // #eval smallest_range_ii([1], 0) == 0\n    // #eval smallest_range_ii([0, 10], 2) == 6\n    // #eval smallest_range_ii([1, 3, 6], 3) == 3\n}"}
{"id": "fvapps_000280", "vc-description": "Suppose you have N integers from 1 to N. We define a beautiful arrangement as an array that is constructed by these N numbers successfully if one of the following is true for the ith position (1-indexed):\n1. The number at the ith position is divisible by i.\n2. i is divisible by the number at the ith position.\n\nNow given N, how many beautiful arrangements can you construct?\n\nExample 1:\nInput: 2\nOutput: 2\nExplanation: \nThe first beautiful arrangement is [1, 2]:\nNumber at the 1st position (i=1) is 1, and 1 is divisible by i (i=1).\nNumber at the 2nd position (i=2) is 2, and 2 is divisible by i (i=2).\nThe second beautiful arrangement is [2, 1]:\nNumber at the 1st position (i=1) is 2, and 2 is divisible by i (i=1).\nNumber at the 2nd position (i=2) is 1, and i (i=2) is divisible by 1.\n\nNote:\nN is a positive integer and will not exceed 15.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn count_beautiful_arrangements(n: usize) -> (result: usize)\n    requires n > 0 && n <= 15,\n    ensures result > 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result2 = count_beautiful_arrangements(2);\n    // println!(\"{}\", result2); // Should print 2\n    \n    // let result3 = count_beautiful_arrangements(3);\n    // println!(\"{}\", result3); // Should print 3\n    \n    // let result4 = count_beautiful_arrangements(4);\n    // println!(\"{}\", result4); // Should print 8\n}"}
{"id": "fvapps_000281", "vc-description": "There is a room with n lights which are turned on initially and 4 buttons on the wall. After performing exactly m unknown operations towards buttons, you need to return how many different kinds of status of the n lights could be.\n\nSuppose n lights are labeled as number [1, 2, 3 ..., n], function of these 4 buttons are given below:\n\nFlip all the lights.\nFlip lights with even numbers.\nFlip lights with odd numbers.\nFlip lights with (3k + 1) numbers, k = 0, 1, 2, ...\n\nExample 1:\n\nInput: n = 1, m = 1.\nOutput: 2\nExplanation: Status can be: [on], [off]\n\nExample 2:\n\nInput: n = 2, m = 1.\nOutput: 3\nExplanation: Status can be: [on, off], [off, on], [off, off]\n\nExample 3:\n\nInput: n = 3, m = 1.\nOutput: 4\nExplanation: Status can be: [off, on, off], [on, off, on], [off, off, off], [off, on, on].\n\nNote:\nn and m both fit in range [0, 1000].", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn flip_lights_spec(n: nat, m: nat) -> nat\n    decreases m\n{\n    if n == 0 {\n        0\n    } else if m == 0 {\n        1\n    } else {\n        // Simplified specification for demo\n        if n <= 4 { (1u32 << (n as u32)) as nat } else { 16 }\n    }\n}", "vc-spec": "fn flip_lights(n: nat, m: nat) -> (result: nat)\n    requires n > 0,\n    ensures \n        1 <= result && result <= (if n <= 4 { (1u32 << (n as u32)) } else { 16 }) as nat,\n        (m == 0) ==> (result == 1),\n        flip_lights_spec(n, 1000) == flip_lights_spec(n, 1001)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "}\n\nfn main() {\n    // let test1 = flip_lights(1, 1);\n    // assert(test1 == 2);\n    // \n    // let test2 = flip_lights(2, 1);\n    // assert(test2 == 3);\n    // \n    // let test3 = flip_lights(3, 1);\n    // assert(test3 == 4);\n}"}
{"id": "fvapps_000282", "vc-description": "Given an array A of non-negative integers, return the maximum sum of elements in two non-overlapping (contiguous) subarrays, which have lengths L and M.  (For clarification, the L-length subarray could occur before or after the M-length subarray.)\nFormally, return the largest V for which V = (A[i] + A[i+1] + ... + A[i+L-1]) + (A[j] + A[j+1] + ... + A[j+M-1]) and either:\n\n0 <= i < i + L - 1 < j < j + M - 1 < A.length, or\n0 <= j < j + M - 1 < i < i + L - 1 < A.length.\n\nExample 1:\nInput: A = [0,6,5,2,2,5,1,9,4], L = 1, M = 2\nOutput: 20\nExplanation: One choice of subarrays is [9] with length 1, and [6,5] with length 2.\n\nExample 2:\nInput: A = [3,8,1,3,2,1,8,9,0], L = 3, M = 2\nOutput: 29\nExplanation: One choice of subarrays is [3,8,1] with length 3, and [8,9] with length 2.\n\nExample 3:\nInput: A = [2,1,5,6,0,9,5,0,3,8], L = 4, M = 3\nOutput: 31\nExplanation: One choice of subarrays is [5,6,0,9] with length 4, and [3,8] with length 3.\n\nNote:\n\nL >= 1\nM >= 1\nL + M <= A.length <= 1000\n0 <= A[i] <= 1000", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn subarray_sum(a: Seq<i32>, start: int, length: int) -> int\n    decreases length\n{\n    if length <= 0 || start < 0 || start + length > a.len() {\n        0\n    } else if length == 1 {\n        a[start] as int\n    } else {\n        (a[start] as int) + subarray_sum(a, start + 1, length - 1)\n    }\n}\n\nfn max_sum_two_no_overlap(a: Vec<i32>, l: usize, m: usize) -> (result: i32)\n    requires \n        l >= 1,\n        m >= 1,\n        l + m <= a.len(),\n        a.len() <= 1000,\n    ensures\n        result >= 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = max_sum_two_no_overlap(vec![0, 6, 5, 2, 2, 5, 1, 9, 4], 1, 2);\n    // println!(\"{}\", result1); // Expected: 20\n\n    // let result2 = max_sum_two_no_overlap(vec![3, 8, 1, 3, 2, 1, 8, 9, 0], 3, 2);\n    // println!(\"{}\", result2); // Expected: 29\n\n    // let result3 = max_sum_two_no_overlap(vec![2, 1, 5, 6, 0, 9, 5, 0, 3, 8], 4, 3);\n    // println!(\"{}\", result3); // Expected: 31\n}"}
{"id": "fvapps_000283", "vc-description": "Given a wooden stick of length n units. The stick is labelled from 0 to n. For example, a stick of length 6 is labelled as follows:\n\nGiven an integer array cuts where cuts[i] denotes a position you should perform a cut at.\nYou should perform the cuts in order, you can change the order of the cuts as you wish.\nThe cost of one cut is the length of the stick to be cut, the total cost is the sum of costs of all cuts. When you cut a stick, it will be split into two smaller sticks (i.e. the sum of their lengths is the length of the stick before the cut). Please refer to the first example for a better explanation.\nReturn the minimum total cost of the cuts.\n\nExample 1:\n\nInput: n = 7, cuts = [1,3,4,5]\nOutput: 16\nExplanation: Using cuts order = [1, 3, 4, 5] as in the input leads to the following scenario:\n\nThe first cut is done to a rod of length 7 so the cost is 7. The second cut is done to a rod of length 6 (i.e. the second part of the first cut), the third is done to a rod of length 4 and the last cut is to a rod of length 3. The total cost is 7 + 6 + 4 + 3 = 20.\nRearranging the cuts to be [3, 5, 1, 4] for example will lead to a scenario with total cost = 16 (as shown in the example photo 7 + 4 + 3 + 2 = 16).\nExample 2:\nInput: n = 9, cuts = [5,6,1,4,2]\nOutput: 22\nExplanation: If you try the given cuts ordering the cost will be 25.\nThere are much ordering with total cost <= 25, for example, the order [4, 6, 5, 2, 1] has total cost = 22 which is the minimum possible.\n\nConstraints:\n\n2 <= n <= 10^6\n1 <= cuts.length <= min(n - 1, 100)\n1 <= cuts[i] <= n - 1\nAll the integers in cuts array are distinct.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn filter_valid_cuts(cuts: Seq<nat>, n: nat) -> Seq<nat> {\n    cuts.filter(|c: nat| 0 < c && c < n)\n}\n\nfn min_cost(n: nat, cuts: Vec<nat>) -> (result: nat)\n    requires n >= 2,\n    ensures \n        result >= 0,\n        cuts.len() == 0 || (forall|c: nat| cuts@.contains(c) && !(0 < c && c < n)) ==> result == 0,\n        result <= n * filter_valid_cuts(cuts@, n).len(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = min_cost(7, vec![1, 3, 4, 5]);\n    // println!(\"Result 1: {}\", result1); // Expected: 16\n    \n    // let result2 = min_cost(9, vec![5, 6, 1, 4, 2]);\n    // println!(\"Result 2: {}\", result2); // Expected: 22\n    \n    // let result3 = min_cost(7, vec![1, 3, 4, 5, 0, 7]);\n    // println!(\"Result 3: {}\", result3); // Expected: 16\n}"}
{"id": "fvapps_000284", "vc-description": "Given an array of integers arr. Return the number of sub-arrays with odd sum.\nAs the answer may grow large, the answer must be computed modulo 10^9 + 7.\n\nExample 1:\nInput: arr = [1,3,5]\nOutput: 4\nExplanation: All sub-arrays are [[1],[1,3],[1,3,5],[3],[3,5],[5]]\nAll sub-arrays sum are [1,4,9,3,8,5].\nOdd sums are [1,9,3,5] so the answer is 4.\n\nExample 2:\nInput: arr = [2,4,6]\nOutput: 0\nExplanation: All sub-arrays are [[2],[2,4],[2,4,6],[4],[4,6],[6]]\nAll sub-arrays sum are [2,6,12,4,10,6].\nAll sub-arrays have even sum and the answer is 0.\n\nExample 3:\nInput: arr = [1,2,3,4,5,6,7]\nOutput: 16\n\nExample 4:\nInput: arr = [100,100,99,99]\nOutput: 4\n\nExample 5:\nInput: arr = [7]\nOutput: 1\n\nConstraints:\n\n1 <= arr.length <= 10^5\n1 <= arr[i] <= 100", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn count_odd_subarrays(arr: Seq<nat>) -> nat\n    decreases arr.len()\n{\n    if arr.len() == 0 {\n        0\n    } else {\n        let first = arr[0];\n        let rest = arr.skip(1);\n        let current_odd_count = if first % 2 == 1 { \n            (arr.len() + 1) / 2 \n        } else { \n            arr.len() / 2 \n        };\n        current_odd_count + count_odd_subarrays(rest)\n    }\n}\n\nfn num_of_subarrays(arr: Vec<nat>) -> (result: nat)\n    requires \n        arr.len() > 0,\n        arr.len() <= 100000,\n        forall|i: int| 0 <= i < arr.len() ==> #[trigger] arr[i] >= 1 && #[trigger] arr[i] <= 100,\n    ensures\n        result < 1000000007,\n        result >= 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let test1 = vec![1, 3, 5];\n    // let result1 = num_of_subarrays(test1);\n    // assert(result1 == 4);\n    \n    // let test2 = vec![2, 4, 6];\n    // let result2 = num_of_subarrays(test2);\n    // assert(result2 == 0);\n    \n    // let test3 = vec![1, 2, 3, 4, 5, 6, 7];\n    // let result3 = num_of_subarrays(test3);\n    // assert(result3 == 16);\n}"}
{"id": "fvapps_000285", "vc-description": "Given two arrays of integers with equal lengths, return the maximum value of:\n|arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j|\nwhere the maximum is taken over all 0 <= i, j < arr1.length.\n\nExample 1:\nInput: arr1 = [1,2,3,4], arr2 = [-1,4,5,6]\nOutput: 13\n\nExample 2:\nInput: arr1 = [1,-2,-5,0,10], arr2 = [0,-2,-1,-7,-4]\nOutput: 20\n\nConstraints:\n\n2 <= arr1.length == arr2.length <= 40000\n-10^6 <= arr1[i], arr2[i] <= 10^6", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn abs_diff(a: int, b: int) -> int {\n    if a >= b { a - b } else { b - a }\n}\n\nspec fn max_abs_val_expr_value(arr1: Seq<i32>, arr2: Seq<i32>, i: int, j: int) -> int {\n    if 0 <= i < arr1.len() && 0 <= j < arr1.len() && arr1.len() == arr2.len() {\n        abs_diff(arr1[i] as int, arr1[j] as int) + abs_diff(arr2[i] as int, arr2[j] as int) + abs_diff(i, j)\n    } else {\n        0\n    }\n}\n\nfn max_abs_val_expr(arr1: Vec<i32>, arr2: Vec<i32>) -> (result: i32)\n    requires \n        arr1.len() == arr2.len(),\n        arr1.len() >= 2,\n        forall|i: int| 0 <= i < arr1.len() ==> #[trigger] arr1[i] >= -1000000 && #[trigger] arr1[i] <= 1000000,\n        forall|i: int| 0 <= i < arr2.len() ==> #[trigger] arr2[i] >= -1000000 && #[trigger] arr2[i] <= 1000000,\n    ensures \n        result >= 0,\n        exists|i: int, j: int| 0 <= i < arr1.len() && 0 <= j < arr1.len() && \n            result as int == max_abs_val_expr_value(arr1@, arr2@, i, j),\n        forall|i: int, j: int| 0 <= i < arr1.len() && 0 <= j < arr1.len() ==> \n            result as int >= max_abs_val_expr_value(arr1@, arr2@, i, j),", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let result1 = max_abs_val_expr(vec![1, 2, 3, 4], vec![-1, 4, 5, 6]);\n    // println!(\"Result 1: {}\", result1); // Expected: 13\n    \n    // let result2 = max_abs_val_expr(vec![1, -2, -5, 0, 10], vec![0, -2, -1, -7, -4]);\n    // println!(\"Result 2: {}\", result2); // Expected: 20\n    \n    // let result3 = max_abs_val_expr(vec![1, 1], vec![1, 1]);\n    // println!(\"Result 3: {}\", result3); // Expected: 1\n}"}
{"id": "fvapps_000287", "vc-description": "The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.\n\nGiven an integer n, return the number of distinct solutions to the n-queens puzzle.\n\nExample:\n\nInput: 4\nOutput: 2\nExplanation: There are two distinct solutions to the 4-queens puzzle as shown below.\n[\n [\".Q..\",  // Solution 1\n  \"...Q\",\n  \"Q...\",\n  \"..Q.\"],\n\n [\"..Q.\",  // Solution 2\n  \"Q...\",\n  \"...Q\",\n  \".Q..\"]\n]", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn total_n_queens_spec(n: usize) -> usize\n{\n    0  // Placeholder specification\n}\n\nfn total_n_queens(n: usize) -> (result: usize)\n    ensures result >= 0 && result == total_n_queens_spec(n)", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "proof fn total_n_queens_nonneg(n: usize)\n    ensures total_n_queens_spec(n) >= 0\n{\n    assume(false);\n}\n\nproof fn total_n_queens_unique(n1: usize, n2: usize)\n    requires n1 == n2\n    ensures total_n_queens_spec(n1) == total_n_queens_spec(n2)\n{\n    assume(false);\n}\n\n}\n\nfn main() {}"}
{"id": "fvapps_000288", "vc-description": "You are given an array x of n positive numbers. You start at point (0,0) and moves x[0] metres to the north, then x[1] metres to the west,\n    x[2] metres to the south,\n    x[3] metres to the east and so on. In other words, after each move your direction changes\n    counter-clockwise.\n\n    Write a one-pass algorithm with O(1) extra space to determine, if your path crosses itself, or not.\n\nExample 1:\n\nGiven x = [2, 1, 1, 2],\n┌───┐\n│   │\n└──→┘>\n    │\n\nReturn true (self crossing)\n\nExample 2:\n\nGiven x = [1, 2, 3, 4],\n┌──────┐\n│      │\n│\n│\n└─────────>\n\nReturn false (not self crossing)\n\nExample 3:\n\nGiven x = [1, 1, 1, 1],\n┌───┐\n│   │\n└──→┘>\n\nReturn true (self crossing)\n\nCredits:Special thanks to @dietpepsi for adding this problem and creating all test cases.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn is_self_crossing(moves: Vec<i32>) -> (result: bool)\n    requires forall|i: int| 0 <= i < moves.len() ==> moves[i] >= 0,\n    ensures \n        moves.len() < 4 ==> result == false,\n        (moves.len() == 4 && forall|i: int, j: int| 0 <= i < moves.len() && 0 <= j < moves.len() ==> moves[i] == moves[j] && moves[i] > 0) ==> result == true,\n        (moves.len() == 4 && moves[0] > 0 && moves[1] > 0 && moves[2] > 0 && moves[3] > 0 && moves[0] < moves[1] && moves[1] < moves[2] && moves[2] < moves[3]) ==> result == false,\n        (exists|x: int| 0 <= x < moves.len() && moves[x] < 0) ==> result == false,\n        (moves.len() >= 6 && forall|i: int| #[trigger] moves[i] >= 0 && moves.len() >= 6 && moves[5] >= moves[3] && moves[4] == moves[2]) ==> result == true", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // #eval is_self_crossing [2, 1, 1, 2]\n    // #eval is_self_crossing [1, 2, 3, 4]\n    // #eval is_self_crossing [1, 1, 1, 1]\n}"}
{"id": "fvapps_000289", "vc-description": "Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.\n\n(i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]).\n\nFind the minimum element.\n\nThe array may contain duplicates.\n\nExample 1:\n\nInput: [1,3,5]\nOutput: 1\n\nExample 2:\n\nInput: [2,2,2,0,1]\nOutput: 0\n\nNote:\n\n       This is a follow up problem to Find Minimum in Rotated Sorted Array.\n       Would allow duplicates affect the run-time complexity? How and why?", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn min_element_in_seq(nums: Seq<i32>) -> i32\n    decreases nums.len()\n{\n    if nums.len() == 0 {\n        0  // placeholder for empty sequence\n    } else if nums.len() == 1 {\n        nums[0]\n    } else {\n        if nums[0] <= min_element_in_seq(nums.skip(1)) {\n            nums[0]\n        } else {\n            min_element_in_seq(nums.skip(1))\n        }\n    }\n}\n\nfn find_min(nums: Vec<i32>) -> (result: i32)\n    requires nums.len() > 0,\n    ensures \n        result == min_element_in_seq(nums@),\n        forall|i: int| 0 <= i < nums.len() ==> result <= nums[i],\n        exists|i: int| 0 <= i < nums.len() && result == nums[i],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let test1 = vec![1, 3, 5];\n    // println!(\"Test 1: {}\", find_min(test1));\n    \n    // let test2 = vec![2, 2, 2, 0, 1];\n    // println!(\"Test 2: {}\", find_min(test2));\n    \n    // let test3 = vec![4, 5, 6, 7, 0, 1, 2];\n    // println!(\"Test 3: {}\", find_min(test3));\n}"}
{"id": "fvapps_000290", "vc-description": "You have n tiles, where each tile has one letter tiles[i] printed on it.\nReturn the number of possible non-empty sequences of letters you can make using the letters printed on those tiles.\n\nExample 1:\nInput: tiles = \"AAB\"\nOutput: 8\nExplanation: The possible sequences are \"A\", \"B\", \"AA\", \"AB\", \"BA\", \"AAB\", \"ABA\", \"BAA\".\n\nExample 2:\nInput: tiles = \"AAABBC\"\nOutput: 188\n\nExample 3:\nInput: tiles = \"V\"\nOutput: 1\n\nConstraints:\n\n1 <= tiles.length <= 7\ntiles consists of uppercase English letters.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn num_tile_possibilities(s: &str) -> (result: usize)\n    requires \n        s@.len() >= 1,\n        s@.len() <= 7,\n    ensures \n        result >= 1,\n        s@.len() == 1 ==> result == 1,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = num_tile_possibilities(\"AAB\");\n    // println!(\"Result 1: {}\", result1); // Should be 8\n    \n    // let result2 = num_tile_possibilities(\"AAABBC\");\n    // println!(\"Result 2: {}\", result2); // Should be 188\n    \n    // let result3 = num_tile_possibilities(\"V\");\n    // println!(\"Result 3: {}\", result3); // Should be 1\n}"}
{"id": "fvapps_000291", "vc-description": "Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\n\nExample 1:\n\nInput: num1 = \"2\", num2 = \"3\"\nOutput: \"6\"\n\nExample 2:\n\nInput: num1 = \"123\", num2 = \"456\"\nOutput: \"56088\"\n\nNote:\n\n       The length of both num1 and num2 is < 110.\n       Both num1 and num2 contain only digits 0-9.\n       Both num1 and num2 do not contain any leading zero, except the number 0 itself.\n       You must not use any built-in BigInteger library or convert the inputs to integer directly.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn string_to_nat(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        let digit = (s[0] as u8 - '0' as u8) as nat;\n        digit * pow(10, (s.len() - 1) as nat) + string_to_nat(s.skip(1))\n    }\n}\n\nspec fn pow(base: nat, exp: nat) -> nat\n    decreases exp\n{\n    if exp == 0 {\n        1\n    } else {\n        base * pow(base, (exp - 1) as nat)\n    }\n}\n\nspec fn valid_digit_string(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] >= '0' && #[trigger] s[i] <= '9'\n}\n\nfn multiply(a: String, b: String) -> (result: String)\n    requires \n        valid_digit_string(a@),\n        valid_digit_string(b@),\n    ensures \n        valid_digit_string(result@),\n        string_to_nat(result@) == string_to_nat(a@) * string_to_nat(b@),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let result1 = multiply(\"2\".to_string(), \"3\".to_string());\n    // println!(\"{}\", result1); // Should print \"6\"\n    \n    // let result2 = multiply(\"123\".to_string(), \"456\".to_string());\n    // println!(\"{}\", result2); // Should print \"56088\"\n    \n    // let result3 = multiply(\"0\".to_string(), \"0\".to_string());\n    // println!(\"{}\", result3); // Should print \"0\"\n}"}
{"id": "fvapps_000292", "vc-description": "Given a m x n grid. Each cell of the grid has a sign pointing to the next cell you should visit if you are currently in this cell. The sign of grid[i][j] can be:\n\n1 which means go to the cell to the right. (i.e go from grid[i][j] to grid[i][j + 1])\n2 which means go to the cell to the left. (i.e go from grid[i][j] to grid[i][j - 1])\n3 which means go to the lower cell. (i.e go from grid[i][j] to grid[i + 1][j])\n4 which means go to the upper cell. (i.e go from grid[i][j] to grid[i - 1][j])\n\nNotice that there could be some invalid signs on the cells of the grid which points outside the grid.\nYou will initially start at the upper left cell (0,0). A valid path in the grid is a path which starts from the upper left cell (0,0) and ends at the bottom-right cell (m - 1, n - 1) following the signs on the grid. The valid path doesn't have to be the shortest.\nYou can modify the sign on a cell with cost = 1. You can modify the sign on a cell one time only.\nReturn the minimum cost to make the grid have at least one valid path.\n\nExample 1:\n\nInput: grid = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]\nOutput: 3\nExplanation: You will start at point (0, 0).\nThe path to (3, 3) is as follows. (0, 0) --> (0, 1) --> (0, 2) --> (0, 3) change the arrow to down with cost = 1 --> (1, 3) --> (1, 2) --> (1, 1) --> (1, 0) change the arrow to down with cost = 1 --> (2, 0) --> (2, 1) --> (2, 2) --> (2, 3) change the arrow to down with cost = 1 --> (3, 3)\nThe total cost = 3.\n\nExample 2:\n\nInput: grid = [[1,1,3],[3,2,2],[1,1,4]]\nOutput: 0\nExplanation: You can follow the path from (0, 0) to (2, 2).\n\nExample 3:\n\nInput: grid = [[1,2],[4,3]]\nOutput: 1\n\nExample 4:\nInput: grid = [[2,2,2],[2,2,2]]\nOutput: 3\n\nExample 5:\nInput: grid = [[4]]\nOutput: 0\n\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 100", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "type Grid = Vec<Vec<usize>>;\n\nfn min_cost_to_valid_path(grid: Grid) -> (result: i32)\n    requires\n        grid.len() >= 1,\n        grid.len() <= 100,\n        forall|i: int| 0 <= i < grid.len() ==> #[trigger] grid[i].len() >= 1 && grid[i].len() <= 100,\n        forall|i: int| 0 <= i < grid.len() ==> #[trigger] grid[i].len() == grid[0].len(),\n        forall|i: int, j: int| \n            0 <= i < grid.len() && 0 <= j < grid[i].len() ==> \n            #[trigger] grid[i][j] >= 1 && grid[i][j] <= 4,\n    ensures\n        result == -1 || result >= 0,\n        grid.len() == 1 && grid[0].len() == 1 ==> result == 0,\n        grid.len() >= 2 ==> (result == -1 || result < (grid.len() * grid.len()) as i32),", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let grid1 = vec![vec![1, 1, 1, 1], vec![2, 2, 2, 2], vec![1, 1, 1, 1], vec![2, 2, 2, 2]];\n    // println!(\"{}\", min_cost_to_valid_path(grid1)); // Expected: 3\n    \n    // let grid2 = vec![vec![1, 1, 3], vec![3, 2, 2], vec![1, 1, 4]];\n    // println!(\"{}\", min_cost_to_valid_path(grid2)); // Expected: 0\n    \n    // let grid3 = vec![vec![1, 2], vec![4, 3]];\n    // println!(\"{}\", min_cost_to_valid_path(grid3)); // Expected: 1\n}"}
{"id": "fvapps_000293", "vc-description": "Given a single positive integer x, we will write an expression of the form x (op1) x (op2) x (op3) x ... where each operator op1, op2, etc. is either addition, subtraction, multiplication, or division (+, -, *, or /).  For example, with x = 3, we might write 3 * 3 / 3 + 3 - 3 which is a value of 3.\nWhen writing such an expression, we adhere to the following conventions:\n\nThe division operator (/) returns rational numbers.\nThere are no parentheses placed anywhere.\nWe use the usual order of operations: multiplication and division happens before addition and subtraction.\nIt's not allowed to use the unary negation operator (-).  For example, \"x - x\" is a valid expression as it only uses subtraction, but \"-x + x\" is not because it uses negation.\n\nWe would like to write an expression with the least number of operators such that the expression equals the given target.  Return the least number of operators used.\n\nExample 1:\nInput: x = 3, target = 19\nOutput: 5\nExplanation: 3 * 3 + 3 * 3 + 3 / 3.  The expression contains 5 operations.\n\nExample 2:\n\nInput: x = 5, target = 501\nOutput: 8\nExplanation: 5 * 5 * 5 * 5 - 5 * 5 * 5 + 5 / 5.  The expression contains 8 operations.\n\nExample 3:\nInput: x = 100, target = 100000000\nOutput: 3\nExplanation: 100 * 100 * 100 * 100.  The expression contains 3 operations.\n\nNote:\n\n2 <= x <= 100\n1 <= target <= 2 * 10^8", "vc-preamble": "use vstd::prelude::*;\nuse vstd::arithmetic::power::pow;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn least_ops_express_target_spec(x: nat, target: nat) -> nat;\n\nfn least_ops_express_target(x: usize, target: usize) -> (result: usize)\n    requires \n        x >= 2,\n        x <= 100,\n        target >= 1,\n        target <= 200000000,\n    ensures\n        result >= 0,\n        result == least_ops_express_target_spec(x as nat, target as nat),\n        (x == target) ==> (result <= 2),", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}\n\nproof fn output_is_non_negative(x: usize, target: usize)\n    requires \n        x >= 2,\n        x <= 100,\n        target >= 1,\n        target <= 1000000,\n    ensures\n        least_ops_express_target_spec(x as nat, target as nat) >= 0,\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn target_equals_x_minimal_ops(x: usize)\n    requires \n        x >= 2,\n        x <= 100,\n    ensures\n        least_ops_express_target_spec(x as nat, x as nat) <= 2,\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn power_requires_fewer_ops(x: usize, power: usize)\n    requires \n        x >= 2,\n        x <= 20,\n        power >= 2,\n        power <= 5,\n    ensures\n        least_ops_express_target_spec(x as nat, pow(x as int, power as nat) as nat) <= least_ops_express_target_spec(x as nat, pow(x as int, power as nat) as nat + 1),\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: unguarded\n}"}
{"id": "fvapps_000297", "vc-description": "Some people will make friend requests. The list of their ages is given and ages[i] is the age of the ith person. \nPerson A will NOT friend request person B (B != A) if any of the following conditions are true:\n\nage[B] <= 0.5 * age[A] + 7\nage[B] > age[A]\nage[B] > 100 && age[A] < 100\n\nOtherwise, A will friend request B.\nNote that if A requests B, B does not necessarily request A.  Also, people will not friend request themselves.\nHow many total friend requests are made?\nExample 1:\nInput: [16,16]\nOutput: 2\nExplanation: 2 people friend request each other.\n\nExample 2:\nInput: [16,17,18]\nOutput: 2\nExplanation: Friend requests are made 17 -> 16, 18 -> 17.\nExample 3:\nInput: [20,30,100,110,120]\nOutput: 3\nExplanation: Friend requests are made 110 -> 100, 120 -> 110, 120 -> 100.\n\nNotes:\n\n1 <= ages.length <= 20000.\n1 <= ages[i] <= 120.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn will_friend_request(age_a: nat, age_b: nat) -> bool {\n    age_a != age_b &&\n    !(age_b <= (age_a / 2) + 7) &&\n    !(age_b > age_a) &&\n    !(age_b > 100 && age_a < 100)\n}\n\nfn num_friend_requests(ages: Vec<nat>) -> (result: nat)\n    requires \n        ages.len() >= 1,\n        ages.len() <= 20000,\n        forall|i: int| #[trigger] ages[i] == ages[i] && 0 <= i < ages.len() ==> 1 <= ages[i] <= 120,\n    ensures \n        result >= 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // println!(\"{}\", num_friend_requests(vec![16, 16]));\n    // println!(\"{}\", num_friend_requests(vec![16, 17, 18]));  \n    // println!(\"{}\", num_friend_requests(vec![20, 30, 100, 110, 120]));\n}"}
{"id": "fvapps_000298", "vc-description": "Return the number of distinct non-empty substrings of text that can be written as the concatenation of some string with itself (i.e. it can be written as a + a where a is some string).\n\nExample 1:\nInput: text = \"abcabcabc\"\nOutput: 3\nExplanation: The 3 substrings are \"abcabc\", \"bcabca\" and \"cabcab\".\n\nExample 2:\nInput: text = \"leetcodeleetcode\"\nOutput: 2\nExplanation: The 2 substrings are \"ee\" and \"leetcodeleetcode\".\n\nConstraints:\n\n1 <= text.length <= 2000\ntext has only lowercase English letters.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn distinct_echo_substrings(text: Vec<u8>) -> (result: usize)\n    requires text.len() > 0,\n    ensures \n        result <= text.len() / 2", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let text1 = \"abcabcabc\".as_bytes().to_vec();\n    // println!(\"Result for text1: {}\", distinct_echo_substrings(text1));\n    \n    // let text2 = \"leetcodeleetcode\".as_bytes().to_vec();\n    // println!(\"Result for text2: {}\", distinct_echo_substrings(text2));\n    \n    // let text3 = \"aaa\".as_bytes().to_vec();\n    // println!(\"Result for text3: {}\", distinct_echo_substrings(text3));\n}"}
{"id": "fvapps_000299", "vc-description": "Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.\n\nExample:\n\nnums = [1, 2, 3]\ntarget = 4\n\nThe possible combination ways are:\n(1, 1, 1, 1)\n(1, 1, 2)\n(1, 2, 1)\n(1, 3)\n(2, 1, 1)\n(2, 2)\n(3, 1)\n\nNote that different sequences are counted as different combinations.\n\nTherefore the output is 7.\n\nFollow up:\nWhat if negative numbers are allowed in the given array?\nHow does it change the problem?\nWhat limitation we need to add to the question to allow negative numbers? \n\nCredits:Special thanks to @pbrother for adding this problem and creating all test cases.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn combination_sum4(nums: Seq<i32>, target: i32) -> int\n    recommends \n        forall|n: i32| nums.contains(n) ==> n > 0,\n        target > 0\n{\n    if nums.len() == 0 || target <= 0 {\n        0\n    } else {\n        1 // placeholder\n    }\n}\n\nfn combination_sum4_exec(nums: Vec<i32>, target: i32) -> (result: i32)\n    requires \n        forall|n: i32| nums@.contains(n) ==> n > 0,\n        target > 0,\n    ensures result >= 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "proof fn combination_sum4_non_negative(nums: Vec<i32>, target: i32)\n    requires \n        forall|n: i32| nums@.contains(n) ==> n > 0,\n        target > 0,\n    ensures combination_sum4(nums@, target) >= 0\n{\n    assume(false);\n}\n\nproof fn combination_sum4_matches_single(nums: Vec<i32>, target: i32)\n    requires \n        nums@.contains(target),\n        forall|n: i32| nums@.contains(n) ==> n > 0,\n        target > 0,\n    ensures combination_sum4(nums@, target) >= 1\n{\n    assume(false);\n}\n\nproof fn combination_sum4_all_greater(nums: Vec<i32>, target: i32)\n    requires \n        forall|n: i32| nums@.contains(n) ==> n > target,\n        target > 0,\n    ensures combination_sum4(nums@, target) == 0\n{\n    assume(false);\n}\n\nproof fn combination_sum4_less_than_min(nums: Vec<i32>, target: i32)\n    requires \n        forall|n: i32| nums@.contains(n) ==> n > 0,\n        target > 0,\n        forall|n: i32| nums@.contains(n) ==> target < n,\n    ensures combination_sum4(nums@, target) == 0\n{\n    assume(false);\n}\n\nproof fn combination_sum4_order_independent(nums1: Vec<i32>, nums2: Vec<i32>, target: i32)\n    requires \n        forall|n: i32| nums1@.contains(n) ==> n > 0,\n        target > 0,\n        forall|n: i32| nums1@.contains(n) <==> nums2@.contains(n),\n    ensures combination_sum4(nums1@, target) == combination_sum4(nums2@, target)\n{\n    assume(false);\n}\n\n}\n\nfn main() {\n    // let result1 = combination_sum4_exec(vec![1, 2, 3], 4);\n    // println!(\"Result for [1, 2, 3] with target 4: {}\", result1);\n    \n    // let result2 = combination_sum4_exec(vec![1, 2], 3);\n    // println!(\"Result for [1, 2] with target 3: {}\", result2);\n    \n    // let result3 = combination_sum4_exec(vec![2], 2);\n    // println!(\"Result for [2] with target 2: {}\", result3);\n}"}
{"id": "fvapps_000300", "vc-description": "There are two types of soup: type A and type B. Initially we have N ml of each type of soup. There are four kinds of operations:\n\nServe 100 ml of soup A and 0 ml of soup B\nServe 75 ml of soup A and 25 ml of soup B\nServe 50 ml of soup A and 50 ml of soup B\nServe 25 ml of soup A and 75 ml of soup B\n\nWhen we serve some soup, we give it to someone and we no longer have it.  Each turn, we will choose from the four operations with equal probability 0.25. If the remaining volume of soup is not enough to complete the operation, we will serve as much as we can.  We stop once we no longer have some quantity of both types of soup.\nNote that we do not have the operation where all 100 ml's of soup B are used first.  \nReturn the probability that soup A will be empty first, plus half the probability that A and B become empty at the same time.\n\nExample:\nInput: N = 50\nOutput: 0.625\nExplanation: \nIf we choose the first two operations, A will become empty first. For the third operation, A and B will become empty at the same time. For the fourth operation, B will become empty first. So the total probability of A becoming empty first plus half the probability that A and B become empty at the same time, is 0.25 * (1 + 1 + 0.5 + 0) = 0.625.\n\nNotes: \n\n0 <= N <= 10^9. \nAnswers within 10^-6 of the true value will be accepted as correct.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn soup_servings(n: u32) -> (result: f64)", "vc-code": "{\n    // impl-start\n    assume(false);\n    0.0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000303", "vc-description": "There are N children standing in a line. Each child is assigned a rating value.\n\nYou are giving candies to these children subjected to the following requirements:\n\n       Each child must have at least one candy.\n       Children with a higher rating get more candies than their neighbors.\n\nWhat is the minimum candies you must give?\n\nExample 1:\n\nInput: [1,0,2]\nOutput: 5\nExplanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.\n\nExample 2:\n\nInput: [1,2,2]\nOutput: 4\nExplanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively.\n             The third child gets 1 candy because it satisfies the above two conditions.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn candy(ratings: Vec<usize>) -> (result: usize)\n    ensures \n        ratings.len() == 0 ==> result == 0,\n        ratings.len() == 1 ==> result == 1", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = candy(vec![1, 0, 2]);\n    // println!(\"Result 1: {}\", result1); // Expected: 5\n    \n    // let result2 = candy(vec![1, 2, 2]);\n    // println!(\"Result 2: {}\", result2); // Expected: 4\n    \n    // let result3 = candy(vec![]);\n    // println!(\"Result 3: {}\", result3); // Expected: 0\n}"}
{"id": "fvapps_000306", "vc-description": "Given a binary string s (a string consisting only of '0' and '1's).\nReturn the number of substrings with all characters 1's.\nSince the answer may be too large, return it modulo 10^9 + 7.\n\nExample 1:\nInput: s = \"0110111\"\nOutput: 9\nExplanation: There are 9 substring in total with only 1's characters.\n\"1\" -> 5 times.\n\"11\" -> 3 times.\n\"111\" -> 1 time.\nExample 2:\nInput: s = \"101\"\nOutput: 2\nExplanation: Substring \"1\" is shown 2 times in s.\n\nExample 3:\nInput: s = \"111111\"\nOutput: 21\nExplanation: Each substring contains only 1's characters.\n\nExample 4:\nInput: s = \"000\"\nOutput: 0\n\nConstraints:\n\ns[i] == '0' or s[i] == '1'\n1 <= s.length <= 10^5", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn count_substrings_ones(s: Vec<char>) -> (result: u32)\n    requires \n        s.len() > 0,\n        s.len() <= 100000,\n        forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1'),\n    ensures \n        result < 1000000007,\n        (s.len() == 0 || (forall|c: char| s@.contains(c) ==> c == '0')) ==> result == 0,\n        (forall|c: char| s@.contains(c) ==> c == '1') ==> result == ((s.len() * (s.len() + 1) / 2) % 1000000007) as u32,", "vc-code": "{\n    // impl-start\n    assume(false);\n    0u32\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let test1 = vec!['0', '1', '1', '0', '1', '1', '1'];\n    // let result1 = count_substrings_ones(test1);\n    // println!(\"Result for '0110111': {}\", result1);\n    \n    // let test2 = vec!['1', '0', '1'];\n    // let result2 = count_substrings_ones(test2);\n    // println!(\"Result for '101': {}\", result2);\n    \n    // let test3 = vec!['1', '1', '1', '1', '1', '1'];\n    // let result3 = count_substrings_ones(test3);\n    // println!(\"Result for '111111': {}\", result3);\n}"}
{"id": "fvapps_000308", "vc-description": "A string is called a happy prefix if is a non-empty prefix which is also a suffix (excluding itself).\nGiven a string s. Return the longest happy prefix of s .\nReturn an empty string if no such prefix exists.\n\nExample 1:\nInput: s = \"level\"\nOutput: \"l\"\nExplanation: s contains 4 prefix excluding itself (\"l\", \"le\", \"lev\", \"leve\"), and suffix (\"l\", \"el\", \"vel\", \"evel\"). The largest prefix which is also suffix is given by \"l\".\n\nExample 2:\nInput: s = \"ababab\"\nOutput: \"abab\"\nExplanation: \"abab\" is the largest prefix which is also suffix. They can overlap in the original string.\n\nExample 3:\nInput: s = \"leetcodeleet\"\nOutput: \"leet\"\n\nExample 4:\nInput: s = \"a\"\nOutput: \"\"\n\nConstraints:\n\n1 <= s.length <= 10^5\ns contains only lowercase English letters.", "vc-preamble": "use vstd::prelude::*;\nuse vstd::string::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_prefix_of(prefix: Seq<char>, s: Seq<char>) -> bool {\n    prefix.len() <= s.len() && \n    forall|i: int| 0 <= i < prefix.len() ==> prefix[i] == s[i]\n}\n\nspec fn is_suffix_of(suffix: Seq<char>, s: Seq<char>) -> bool {\n    suffix.len() <= s.len() && \n    forall|i: int| 0 <= i < suffix.len() ==> suffix[i] == s[s.len() - suffix.len() + i]\n}\n\nfn longest_prefix(s: Vec<char>) -> (result: Vec<char>)\n    requires s.len() > 0,\n    ensures\n        result.len() < s.len(),\n        is_prefix_of(result@, s@),\n        result.len() == 0 || is_suffix_of(result@, s@),", "vc-code": "{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let s1: Vec<char> = \"level\".chars().collect();\n    // let result1 = longest_prefix(s1);\n    // println!(\"{:?}\", result1);\n    \n    // let s2: Vec<char> = \"ababab\".chars().collect();\n    // let result2 = longest_prefix(s2);\n    // println!(\"{:?}\", result2);\n    \n    // let s3: Vec<char> = \"leetcodeleet\".chars().collect();\n    // let result3 = longest_prefix(s3);\n    // println!(\"{:?}\", result3);\n}"}
{"id": "fvapps_000309", "vc-description": "We are given S, a length n string of characters from the set {'D', 'I'}. (These letters stand for \"decreasing\" and \"increasing\".)\nA valid permutation is a permutation P[0], P[1], ..., P[n] of integers {0, 1, ..., n}, such that for all i:\n\nIf S[i] == 'D', then P[i] > P[i+1], and;\nIf S[i] == 'I', then P[i] < P[i+1].\n\nHow many valid permutations are there?  Since the answer may be large, return your answer modulo 10^9 + 7.\n\nExample 1:\nInput: \"DID\"\nOutput: 5\nExplanation: \nThe 5 valid permutations of (0, 1, 2, 3) are:\n(1, 0, 3, 2)\n(2, 0, 3, 1)\n(2, 1, 3, 0)\n(3, 0, 2, 1)\n(3, 1, 2, 0)\n\nNote:\n\n1 <= S.length <= 200\nS consists only of characters from the set {'D', 'I'}.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "const MOD: u32 = 1000000007;\n\nfn num_perms_di_sequence(s: Vec<u8>) -> (result: u32)\n    requires \n        s.len() > 0,\n        s.len() <= 200,\n        forall|i: int| 0 <= i < s.len() ==> (s[i] == 68u8 || s[i] == 73u8),\n    ensures \n        result < MOD,\n        (forall|i: int| 0 <= i < s.len() ==> s[i] == 68u8) ==> result == 1,\n        (forall|i: int| 0 <= i < s.len() ==> s[i] == 73u8) ==> result == 1,", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = num_perms_di_sequence(vec![68u8, 73u8, 68u8]); // \"DID\"\n    // println!(\"Result for 'DID': {}\", result1); // Expected: 5\n    \n    // let result2 = num_perms_di_sequence(vec![68u8]); // \"D\"\n    // println!(\"Result for 'D': {}\", result2); // Expected: 1\n    \n    // let result3 = num_perms_di_sequence(vec![73u8, 73u8, 73u8]); // \"III\"\n    // println!(\"Result for 'III': {}\", result3); // Expected: 1\n}"}
{"id": "fvapps_000311", "vc-description": "Alice and Bob continue their games with piles of stones. There are several stones arranged in a row, and each stone has an associated value which is an integer given in the array stoneValue.\nAlice and Bob take turns, with Alice starting first. On each player's turn, that player can take 1, 2 or 3 stones from the first remaining stones in the row.\nThe score of each player is the sum of values of the stones taken. The score of each player is 0 initially.\nThe objective of the game is to end with the highest score, and the winner is the player with the highest score and there could be a tie. The game continues until all the stones have been taken.\nAssume Alice and Bob play optimally.\nReturn \"Alice\" if Alice will win, \"Bob\" if Bob will win or \"Tie\" if they end the game with the same score.\n\nExample 1:\nInput: values = [1,2,3,7]\nOutput: \"Bob\"\nExplanation: Alice will always lose. Her best move will be to take three piles and the score become 6. Now the score of Bob is 7 and Bob wins.\n\nExample 2:\nInput: values = [1,2,3,-9]\nOutput: \"Alice\"\nExplanation: Alice must choose all the three piles at the first move to win and leave Bob with negative score.\nIf Alice chooses one pile her score will be 1 and the next move Bob's score becomes 5. The next move Alice will take the pile with value = -9 and lose.\nIf Alice chooses two piles her score will be 3 and the next move Bob's score becomes 3. The next move Alice will take the pile with value = -9 and also lose.\nRemember that both play optimally so here Alice will choose the scenario that makes her win.\n\nExample 3:\nInput: values = [1,2,3,6]\nOutput: \"Tie\"\nExplanation: Alice cannot win this game. She can end the game in a draw if she decided to choose all the first three piles, otherwise she will lose.\n\nExample 4:\nInput: values = [1,2,3,-1,-2,-3,7]\nOutput: \"Alice\"\n\nExample 5:\nInput: values = [-1,-2,-3]\nOutput: \"Tie\"\n\nConstraints:\n\n1 <= values.length <= 50000\n-1000 <= values[i] <= 1000", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "#[derive(PartialEq, Eq)]\npub enum GameResult {\n    Alice,\n    Bob,\n    Tie,\n}\n\nfn stone_game_iii(stones: Vec<i32>) -> (result: GameResult)\n    requires stones.len() >= 1,\n    ensures \n        result == GameResult::Alice || result == GameResult::Bob || result == GameResult::Tie", "vc-code": "{\n    // impl-start\n    assume(false);\n    GameResult::Tie\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let test1 = vec![1, 2, 3, 7];\n    // println!(\"{:?}\", stone_game_iii(test1));\n    // \n    // let test2 = vec![1, 2, 3, -9]; \n    // println!(\"{:?}\", stone_game_iii(test2));\n    //\n    // let test3 = vec![1, 2, 3, 6];\n    // println!(\"{:?}\", stone_game_iii(test3));\n}"}
{"id": "fvapps_000315", "vc-description": "Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.\n\nExample 1:\n\nInput: s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\"\nOutput: true\n\nExample 2:\n\nInput: s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbbaccc\"\nOutput: false", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn is_interleave(s1: Seq<char>, s2: Seq<char>, s3: Seq<char>) -> (result: bool)\n    ensures\n        (s1.len() + s2.len() != s3.len()) ==> result == false,\n        (s1.len() == 0 && s2.len() == 0) ==> (result == (s3.len() == 0)),\n        (s1.len() == 0) ==> (result == (s2 == s3)),\n        (s2.len() == 0) ==> (result == (s1 == s3))", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let s1 = seq!['a', 'a', 'b', 'c', 'c'];\n    // let s2 = seq!['d', 'b', 'b', 'c', 'a'];\n    // let s3 = seq!['a', 'a', 'd', 'b', 'b', 'c', 'b', 'c', 'a', 'c'];\n    // let result1 = is_interleave(s1, s2, s3);\n    // println!(\"Result 1: {}\", result1);\n}"}
{"id": "fvapps_000317", "vc-description": "The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n\nP   A   H   N\nA P L S I I G\nY   I   R\n\nAnd then read line by line: \"PAHNAPLSIIGYIR\"\n\nWrite the code that will take a string and make this conversion given a number of rows:\n\nstring convert(string s, int numRows);\n\nExample 1:\n\nInput: s = \"PAYPALISHIRING\", numRows = 3\nOutput: \"PAHNAPLSIIGYIR\"\n\nExample 2:\n\nInput: s = \"PAYPALISHIRING\", numRows = 4\nOutput: \"PINALSIGYAHRPI\"\nExplanation:\n\nP     I    N\nA   L S  I G\nY A   H R\nP     I", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn convert_zigzag(s: &str, num_rows: usize) -> (result: String)\n    requires \n        num_rows > 0,\n        num_rows <= 100,\n    ensures \n        result@.len() == s@.len(),\n        num_rows == 1 ==> result@ == s@,\n        s@.len() == 0 ==> result@ == s@,\n        s@.len() == 1 ==> result@ == s@,\n        s@.len() >= num_rows && num_rows > 1 ==> {\n            result@.len() > 0 ==> result@[0] == s@[0]\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let s1 = \"PAYPALISHIRING\";\n    // let result1 = convert_zigzag(s1, 3);\n    // println!(\"{}\", result1);\n    \n    // let s2 = \"PAYPALISHIRING\";\n    // let result2 = convert_zigzag(s2, 4);\n    // println!(\"{}\", result2);\n    \n    // let s3 = \"AB\";\n    // let result3 = convert_zigzag(s3, 1);\n    // println!(\"{}\", result3);\n}"}
{"id": "fvapps_000318", "vc-description": "Given a string, find the length of the longest substring without repeating characters.\n\nExamples:\n\nGiven \"abcabcbb\", the answer is \"abc\", which the length is 3.\n\nGiven \"bbbbb\", the answer is \"b\", with the length of 1.\n\nGiven \"pwwkew\", the answer is \"wke\", with the length of 3. Note that the answer must be a substring, \"pwke\" is a subsequence and not a substring.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn has_duplicate_chars(s: Seq<char>, start: int, end: int) -> bool {\n    exists|i: int, j: int| start <= i < j < end && s[i] == s[j]\n}\n\nspec fn is_valid_substring_range(s: Seq<char>, start: int, end: int) -> bool {\n    0 <= start <= end <= s.len()\n}\n\nspec fn substring_length(start: int, end: int) -> int {\n    end - start\n}\n\nfn length_of_longest_substring(s: &Vec<char>) -> (result: usize)\n    ensures \n        0 <= result <= s.len(),\n        exists|start: int, end: int| \n            is_valid_substring_range(s@, start, end) &&\n            substring_length(start, end) == result &&\n            !has_duplicate_chars(s@, start, end) &&\n            (forall|s2: int, e2: int| \n                is_valid_substring_range(s@, s2, e2) && !has_duplicate_chars(s@, s2, e2) \n                ==> substring_length(s2, e2) <= result),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n#[verifier::external_body]\nproof fn test_empty_string() {\n    assume(false);\n}\n\n#[verifier::external_body]  \nproof fn test_single_char() {\n    assume(false);\n}\n\n#[verifier::external_body]\nproof fn test_all_unique() {\n    assume(false);\n}\n\n}\n\nfn main() {}"}
{"id": "fvapps_000320", "vc-description": "You are given a rows x cols matrix grid. Initially, you are located at the top-left corner (0, 0), and in each step, you can only move right or down in the matrix.\nAmong all possible paths starting from the top-left corner (0, 0) and ending in the bottom-right corner (rows - 1, cols - 1), find the path with the maximum non-negative product. The product of a path is the product of all integers in the grid cells visited along the path.\nReturn the maximum non-negative product modulo 109 + 7. If the maximum product is negative return -1.\nNotice that the modulo is performed after getting the maximum product.\n\nExample 1:\nInput: grid = [[-1,-2,-3],\n               [-2,-3,-3],\n               [-3,-3,-2]]\nOutput: -1\nExplanation: It's not possible to get non-negative product in the path from (0, 0) to (2, 2), so return -1.\n\nExample 2:\nInput: grid = [[1,-2,1],\n               [1,-2,1],\n               [3,-4,1]]\nOutput: 8\nExplanation: Maximum non-negative product is in bold (1 * 1 * -2 * -4 * 1 = 8).\n\nExample 3:\nInput: grid = [[1, 3],\n               [0,-4]]\nOutput: 0\nExplanation: Maximum non-negative product is in bold (1 * 0 * -4 = 0).\n\nExample 4:\nInput: grid = [[ 1, 4,4,0],\n               [-2, 0,0,1],\n               [ 1,-1,1,1]]\nOutput: 2\nExplanation: Maximum non-negative product is in bold (1 * -2 * 1 * -1 * 1 * 1 = 2).\n\nConstraints:\n\n1 <= rows, cols <= 15\n-4 <= grid[i][j] <= 4", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn max_product_path(grid: Vec<Vec<i32>>) -> (result: i32)\n    requires \n        grid.len() > 0,\n        forall|i: int| #[trigger] grid[i].len() == grid[0].len() && 0 <= i < grid.len(),\n        grid[0].len() > 0,\n        1 <= grid.len() <= 15,\n        1 <= grid[0].len() <= 15,\n        forall|i: int, j: int| 0 <= i < grid.len() && 0 <= j < grid[i].len() ==> -4 <= #[trigger] grid[i][j] && grid[i][j] <= 4,\n    ensures\n        result == -1 || (0 <= result && result <= 1000000007)", "vc-code": "{\n    // impl-start\n    assume(false);\n    -1\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let grid1 = vec![vec![-1, -2, -3], vec![-2, -3, -3], vec![-3, -3, -2]];\n    // println!(\"{}\", max_product_path(grid1)); // Expected: -1\n\n    // let grid2 = vec![vec![1, -2, 1], vec![1, -2, 1], vec![3, -4, 1]];\n    // println!(\"{}\", max_product_path(grid2)); // Expected: 8\n\n    // let grid3 = vec![vec![1, 3], vec![0, -4]];\n    // println!(\"{}\", max_product_path(grid3)); // Expected: 0\n}"}
{"id": "fvapps_000322", "vc-description": "Given two numbers, hour and minutes. Return the smaller angle (in degrees) formed between the hour and the minute hand.\n\nExample 1:\n\nInput: hour = 12, minutes = 30\nOutput: 165\n\nExample 2:\n\nInput: hour = 3, minutes = 30\nOutput: 75\n\nExample 3:\n\nInput: hour = 3, minutes = 15\nOutput: 7.5\n\nExample 4:\nInput: hour = 4, minutes = 50\nOutput: 155\n\nExample 5:\nInput: hour = 12, minutes = 0\nOutput: 0\n\nConstraints:\n\n1 <= hour <= 12\n0 <= minutes <= 59\nAnswers within 10^-5 of the actual value will be accepted as correct.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn angle_between_hands(hour: u32, minutes: u32) -> (result: u32)\n    requires \n        1 <= hour && hour <= 12,\n        minutes <= 59,\n    ensures \n        result <= 180,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000324", "vc-description": "Given an array of integers arr, you are initially positioned at the first index of the array.\nIn one step you can jump from index i to index:\n\ni + 1 where: i + 1 < arr.length.\ni - 1 where: i - 1 >= 0.\nj where: arr[i] == arr[j] and i != j.\n\nReturn the minimum number of steps to reach the last index of the array.\nNotice that you can not jump outside of the array at any time.\n\nExample 1:\nInput: arr = [100,-23,-23,404,100,23,23,23,3,404]\nOutput: 3\nExplanation: You need three jumps from index 0 --> 4 --> 3 --> 9. Note that index 9 is the last index of the array.\n\nExample 2:\nInput: arr = [7]\nOutput: 0\nExplanation: Start index is the last index. You don't need to jump.\n\nExample 3:\nInput: arr = [7,6,9,6,9,6,9,7]\nOutput: 1\nExplanation: You can jump directly from index 0 to index 7 which is last index of the array.\n\nExample 4:\nInput: arr = [6,1,9]\nOutput: 2\n\nExample 5:\nInput: arr = [11,22,7,7,7,7,7,7,7,22,13]\nOutput: 3\n\nConstraints:\n\n1 <= arr.length <= 5 * 10^4\n-10^8 <= arr[i] <= 10^8", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn min_jumps(arr: Vec<i32>) -> (result: i32)\n    requires arr.len() > 0,\n    ensures \n        result >= -1,\n        result <= arr.len() as i32", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: unguarded\n\n    // min_jumps([100, -23, -23, 404, 100, 23, 23, 23, 3, 404]) == 3\n    // min_jumps([7]) == 0\n    // min_jumps([7, 6, 9, 6, 9, 6, 9, 7]) == 1\n}"}
{"id": "fvapps_000327", "vc-description": "Given two equal-size strings s and t. In one step you can choose any character of t and replace it with another character.\nReturn the minimum number of steps to make t an anagram of s.\nAn Anagram of a string is a string that contains the same characters with a different (or the same) ordering.\n\nExample 1:\nInput: s = \"bab\", t = \"aba\"\nOutput: 1\nExplanation: Replace the first 'a' in t with b, t = \"bba\" which is anagram of s.\n\nExample 2:\nInput: s = \"leetcode\", t = \"practice\"\nOutput: 5\nExplanation: Replace 'p', 'r', 'a', 'i' and 'c' from t with proper characters to make t anagram of s.\n\nExample 3:\nInput: s = \"anagram\", t = \"mangaar\"\nOutput: 0\nExplanation: \"anagram\" and \"mangaar\" are anagrams. \n\nExample 4:\nInput: s = \"xxyyzz\", t = \"xxyyzz\"\nOutput: 0\n\nExample 5:\nInput: s = \"friend\", t = \"family\"\nOutput: 4\n\nConstraints:\n\n1 <= s.length <= 50000\ns.length == t.length\ns and t contain lower-case English letters only.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn min_steps_to_anagram(s1: Vec<char>, s2: Vec<char>) -> (result: usize)\n    requires s1.len() == s2.len()\n    ensures \n        result <= s2.len(),\n        (s1@ == s2@) ==> (result == 0)", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "/* Apps difficulty: interview\n   Assurance level: guarded_and_plausible */\n\n}\nfn main() {\n    // let s1 = vec!['b', 'a', 'b'];\n    // let s2 = vec!['a', 'b', 'a'];\n    // let result1 = min_steps_to_anagram(s1, s2);\n    // println!(\"Result 1: {}\", result1); // Expected: 1\n    \n    // let s3 = vec!['l', 'e', 'e', 't', 'c', 'o', 'd', 'e'];\n    // let s4 = vec!['p', 'r', 'a', 'c', 't', 'i', 'c', 'e'];\n    // let result2 = min_steps_to_anagram(s3, s4);\n    // println!(\"Result 2: {}\", result2); // Expected: 5\n    \n    // let s5 = vec!['a', 'n', 'a', 'g', 'r', 'a', 'm'];\n    // let s6 = vec!['m', 'a', 'n', 'g', 'a', 'a', 'r'];\n    // let result3 = min_steps_to_anagram(s5, s6);\n    // println!(\"Result 3: {}\", result3); // Expected: 0\n}"}
{"id": "fvapps_000328", "vc-description": "There are N gas stations along a circular route, where the amount of gas at station i is gas[i].\n\nYou have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.\n\nReturn the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1.\n\nNote:\n\n       If there exists a solution, it is guaranteed to be unique.\n       Both input arrays are non-empty and have the same length.\n       Each element in the input arrays is a non-negative integer.\n\nExample 1:\n\nInput: \ngas  = [1,2,3,4,5]\ncost = [3,4,5,1,2]\n\nOutput: 3\n\nExplanation:\nStart at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 4. Your tank = 4 - 1 + 5 = 8\nTravel to station 0. Your tank = 8 - 2 + 1 = 7\nTravel to station 1. Your tank = 7 - 3 + 2 = 6\nTravel to station 2. Your tank = 6 - 4 + 3 = 5\nTravel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.\nTherefore, return 3 as the starting index.\n\nExample 2:\n\nInput: \ngas  = [2,3,4]\ncost = [3,4,3]\n\nOutput: -1\n\nExplanation:\nYou can't start at station 0 or 1, as there is not enough gas to travel to the next station.\nLet's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 0. Your tank = 4 - 3 + 2 = 3\nTravel to station 1. Your tank = 3 - 3 + 3 = 3\nYou cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.\nTherefore, you can't travel around the circuit once no matter where you start.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn sum_list(l: Seq<nat>) -> nat \n    decreases l.len()\n{\n    if l.len() == 0 {\n        0\n    } else {\n        l[0] + sum_list(l.skip(1))\n    }\n}\n\nfn can_complete_circuit(gas: Vec<nat>, cost: Vec<nat>) -> (result: i32)\n    requires\n        gas.len() > 0,\n        cost.len() > 0,\n        gas.len() == cost.len(),\n    ensures\n        result == -1 || (0 <= result < gas.len()),\n        /* If insufficient total gas, result is -1 */\n        sum_list(gas@) < sum_list(cost@) ==> result == -1,\n        /* If gas and cost arrays are identical, starting station is 0 */\n        gas@ == cost@ ==> result == 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // /* Apps difficulty: interview */\n    // /* Assurance level: unguarded */\n\n    // /* Test cases */\n    // let result1 = can_complete_circuit(vec![1, 2, 3, 4, 5], vec![3, 4, 5, 1, 2]);\n    // println!(\"{}\", result1);  // Expected: 3\n\n    // let result2 = can_complete_circuit(vec![2, 3, 4], vec![3, 4, 3]);\n    // println!(\"{}\", result2);  // Expected: -1\n\n    // let result3 = can_complete_circuit(vec![5, 1, 2, 3, 4], vec![4, 4, 1, 5, 1]);\n    // println!(\"{}\", result3);  // Expected: 4\n}"}
{"id": "fvapps_000329", "vc-description": "Given the strings s1 and s2 of size n, and the string evil. Return the number of good strings.\nA good string has size n, it is alphabetically greater than or equal to s1, it is alphabetically smaller than or equal to s2, and it does not contain the string evil as a substring. Since the answer can be a huge number, return this modulo 10^9 + 7.\n\nExample 1:\nInput: n = 2, s1 = \"aa\", s2 = \"da\", evil = \"b\"\nOutput: 51 \nExplanation: There are 25 good strings starting with 'a': \"aa\",\"ac\",\"ad\",...,\"az\". Then there are 25 good strings starting with 'c': \"ca\",\"cc\",\"cd\",...,\"cz\" and finally there is one good string starting with 'd': \"da\". \n\nExample 2:\nInput: n = 8, s1 = \"leetcode\", s2 = \"leetgoes\", evil = \"leet\"\nOutput: 0 \nExplanation: All strings greater than or equal to s1 and smaller than or equal to s2 start with the prefix \"leet\", therefore, there is not any good string.\n\nExample 3:\nInput: n = 2, s1 = \"gx\", s2 = \"gz\", evil = \"x\"\nOutput: 2\n\nConstraints:\n\ns1.length == n\ns2.length == n\ns1 <= s2\n1 <= n <= 500\n1 <= evil.length <= 50\nAll strings consist of lowercase English letters.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn string_lex_ge(s1: Seq<char>, s2: Seq<char>) -> bool\n    decreases s1.len()\n{\n    if s1.len() == 0 && s2.len() == 0 {\n        true\n    } else if s1.len() == 0 {\n        false\n    } else if s2.len() == 0 {\n        true\n    } else if s1[0] > s2[0] {\n        true\n    } else if s1[0] < s2[0] {\n        false\n    } else {\n        string_lex_ge(s1.skip(1), s2.skip(1))\n    }\n}\n\nspec fn string_lex_le(s1: Seq<char>, s2: Seq<char>) -> bool\n    decreases s1.len()\n{\n    if s1.len() == 0 && s2.len() == 0 {\n        true\n    } else if s1.len() == 0 {\n        true\n    } else if s2.len() == 0 {\n        false\n    } else if s1[0] < s2[0] {\n        true\n    } else if s1[0] > s2[0] {\n        false\n    } else {\n        string_lex_le(s1.skip(1), s2.skip(1))\n    }\n}\n\nspec fn has_substring_at(s: Seq<char>, pattern: Seq<char>, pos: int) -> bool\n{\n    pos >= 0 && pos + pattern.len() <= s.len() &&\n    s.subrange(pos, pos + pattern.len()) == pattern\n}\n\nspec fn contains_substring(s: Seq<char>, pattern: Seq<char>) -> bool\n{\n    pattern.len() > 0 && \n    (exists|pos: int| #[trigger] has_substring_at(s, pattern, pos))\n}\n\nfn failure(pattern: &Vec<char>) -> (result: Vec<usize>)\n{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}\n\nfn find_good_strings(n: usize, s1: &Vec<char>, s2: &Vec<char>, evil: &Vec<char>) -> (result: usize)\n    requires \n        n > 0,\n        s1.len() == n,\n        s2.len() == n,\n        evil.len() > 0,\n        string_lex_le(s1@, s2@),\n    ensures \n        result < 1000000007", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    /*\n    let s1 = vec!['a', 'a'];\n    let s2 = vec!['d', 'a'];\n    let evil = vec!['b'];\n    println!(\"{}\", find_good_strings(2, &s1, &s2, &evil));\n    \n    let s1 = vec!['l', 'e', 'e', 't', 'c', 'o', 'd', 'e'];\n    let s2 = vec!['l', 'e', 'e', 't', 'g', 'o', 'e', 's'];\n    let evil = vec!['l', 'e', 'e', 't'];\n    println!(\"{}\", find_good_strings(8, &s1, &s2, &evil));\n    \n    let s1 = vec!['g', 'x'];\n    let s2 = vec!['g', 'z'];\n    let evil = vec!['x'];\n    println!(\"{}\", find_good_strings(2, &s1, &s2, &evil));\n    */\n}"}
{"id": "fvapps_000330", "vc-description": "Given two arrays of integers nums1 and nums2, return the number of triplets formed (type 1 and type 2) under the following rules:\n\nType 1: Triplet (i, j, k) if nums1[i]2 == nums2[j] * nums2[k] where 0 <= i < nums1.length and 0 <= j < k < nums2.length.\nType 2: Triplet (i, j, k) if nums2[i]2 == nums1[j] * nums1[k] where 0 <= i < nums2.length and 0 <= j < k < nums1.length.\n\nExample 1:\nInput: nums1 = [7,4], nums2 = [5,2,8,9]\nOutput: 1\nExplanation: Type 1: (1,1,2), nums1[1]^2 = nums2[1] * nums2[2]. (4^2 = 2 * 8). \n\nExample 2:\nInput: nums1 = [1,1], nums2 = [1,1,1]\nOutput: 9\nExplanation: All Triplets are valid, because 1^2 = 1 * 1.\nType 1: (0,0,1), (0,0,2), (0,1,2), (1,0,1), (1,0,2), (1,1,2).  nums1[i]^2 = nums2[j] * nums2[k].\nType 2: (0,0,1), (1,0,1), (2,0,1). nums2[i]^2 = nums1[j] * nums1[k].\n\nExample 3:\nInput: nums1 = [7,7,8,3], nums2 = [1,2,9,7]\nOutput: 2\nExplanation: There are 2 valid triplets.\nType 1: (3,0,2).  nums1[3]^2 = nums2[0] * nums2[2].\nType 2: (3,0,1).  nums2[3]^2 = nums1[0] * nums1[1].\n\nExample 4:\nInput: nums1 = [4,7,9,11,23], nums2 = [3,5,1024,12,18]\nOutput: 0\nExplanation: There are no valid triplets.\n\nConstraints:\n\n1 <= nums1.length, nums2.length <= 1000\n1 <= nums1[i], nums2[i] <= 10^5", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn num_triplets_spec(nums1: Seq<u32>, nums2: Seq<u32>) -> nat {\n    if nums1.len() == 0 || nums2.len() == 0 {\n        0\n    } else {\n        0\n    }\n}\n\nfn num_triplets(nums1: Vec<u32>, nums2: Vec<u32>) -> (result: u32)\n    requires\n        nums1.len() >= 1,\n        nums2.len() >= 1,\n        nums1.len() <= 1000,\n        nums2.len() <= 1000,\n        forall|i: int| 0 <= i < nums1.len() ==> #[trigger] nums1[i] >= 1 && #[trigger] nums1[i] <= 100000,\n        forall|i: int| 0 <= i < nums2.len() ==> #[trigger] nums2[i] >= 1 && #[trigger] nums2[i] <= 100000,\n    ensures\n        result == num_triplets_spec(nums1@, nums2@),", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}\n\nproof fn num_triplets_nonnegative_proof(nums1: Vec<u32>, nums2: Vec<u32>)\n    requires\n        nums1.len() >= 1,\n        nums2.len() >= 1,\n        nums1.len() <= 1000,\n        nums2.len() <= 1000,\n        forall|i: int| 0 <= i < nums1.len() ==> #[trigger] nums1[i] >= 1 && #[trigger] nums1[i] <= 100000,\n        forall|i: int| 0 <= i < nums2.len() ==> #[trigger] nums2[i] >= 1 && #[trigger] nums2[i] <= 100000,\n    ensures num_triplets_spec(nums1@, nums2@) >= 0\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn num_triplets_symmetric_proof(nums1: Vec<u32>, nums2: Vec<u32>)\n    requires\n        nums1.len() >= 1,\n        nums2.len() >= 1,\n        nums1.len() <= 1000,\n        nums2.len() <= 1000,\n        forall|i: int| 0 <= i < nums1.len() ==> #[trigger] nums1[i] >= 1 && #[trigger] nums1[i] <= 100000,\n        forall|i: int| 0 <= i < nums2.len() ==> #[trigger] nums2[i] >= 1 && #[trigger] nums2[i] <= 100000,\n    ensures num_triplets_spec(nums1@, nums2@) == num_triplets_spec(nums2@, nums1@)\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn num_triplets_empty_first_proof(nums2: Vec<u32>)\n    requires\n        nums2.len() >= 1,\n        nums2.len() <= 1000,\n        forall|i: int| 0 <= i < nums2.len() ==> #[trigger] nums2[i] >= 1 && #[trigger] nums2[i] <= 100000,\n    ensures num_triplets_spec(Seq::empty(), nums2@) == 0\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn num_triplets_empty_second_proof(nums1: Vec<u32>)\n    requires\n        nums1.len() >= 1,\n        nums1.len() <= 1000,\n        forall|i: int| 0 <= i < nums1.len() ==> #[trigger] nums1[i] >= 1 && #[trigger] nums1[i] <= 100000,\n    ensures num_triplets_spec(nums1@, Seq::empty()) == 0\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let result1 = num_triplets(vec![7, 4], vec![5, 2, 8, 9]);\n    // println!(\"Result 1: {}\", result1); // Expected: 1\n    \n    // let result2 = num_triplets(vec![1, 1], vec![1, 1, 1]);\n    // println!(\"Result 2: {}\", result2); // Expected: 9\n    \n    // let result3 = num_triplets(vec![7, 7, 8, 3], vec![1, 2, 9, 7]);\n    // println!(\"Result 3: {}\", result3); // Expected: 2\n}"}
{"id": "fvapps_000332", "vc-description": "Write a program to find the n-th ugly number.\n\nUgly numbers are positive numbers whose prime factors only include 2, 3, 5. \n\nExample:\n\nInput: n = 10\nOutput: 12\nExplanation: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.\n\nNote:  \n\n       1 is typically treated as an ugly number.\n       n does not exceed 1690.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_ugly_number(x: int) -> bool {\n    x > 0 && exists|a: nat, b: nat, c: nat| x == pow(2int, a) * pow(3int, b) * pow(5int, c)\n}\n\nspec fn pow(base: int, exp: nat) -> int \n    decreases exp\n{\n    if exp == 0 {\n        1int\n    } else {\n        base * pow(base, (exp - 1) as nat)\n    }\n}\n\nfn nth_ugly_number(n: i32) -> (result: Option<i32>)\n    ensures\n        n <= 0 ==> result.is_none(),\n        n > 0 ==> match result {\n            Some(x) => x > 0 && is_ugly_number(x as int),\n            None => false,\n        },\n        n == 1 ==> result == Some(1i32),", "vc-code": "{\n    // impl-start\n    if n <= 0 {\n        None\n    } else {\n        assume(false);\n        Some(0i32)\n    }\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let result1 = nth_ugly_number(10);\n    // println!(\"{:?}\", result1);\n    \n    // let result2 = nth_ugly_number(1);\n    // println!(\"{:?}\", result2);\n    \n    // let result3 = nth_ugly_number(7);\n    // println!(\"{:?}\", result3);\n}"}
{"id": "fvapps_000334", "vc-description": "Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n.\n\nExample 1:\n\nInput: n = 12\nOutput: 3 \nExplanation: 12 = 4 + 4 + 4.\n\nExample 2:\n\nInput: n = 13\nOutput: 2\nExplanation: 13 = 4 + 9.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn sqrt(n: u32) -> (result: u32)\n    ensures result * result <= n && (result + 1) * (result + 1) > n\n{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}\n\nfn num_squares(n: u32) -> (result: u32)\n    requires n >= 1,\n    ensures \n        result >= 1 && result <= 4\n{\n    // impl-start\n    assume(false);\n    1\n    // impl-end\n}", "vc-code": "", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded_and_plausible\n    \n    // println!(\"{}\", num_squares(12)); // Expected: 3\n    // println!(\"{}\", num_squares(13)); // Expected: 2\n    // println!(\"{}\", num_squares(7));  // Expected: 4\n}"}
{"id": "fvapps_000335", "vc-description": "We are given an array A of N lowercase letter strings, all of the same length.\nNow, we may choose any set of deletion indices, and for each string, we delete all the characters in those indices.\nFor example, if we have an array A = [\"babca\",\"bbazb\"] and deletion indices {0, 1, 4}, then the final array after deletions is [\"bc\",\"az\"].\nSuppose we chose a set of deletion indices D such that after deletions, the final array has every element (row) in lexicographic order.\nFor clarity, A[0] is in lexicographic order (ie. A[0][0] <= A[0][1] <= ... <= A[0][A[0].length - 1]), A[1] is in lexicographic order (ie. A[1][0] <= A[1][1] <= ... <= A[1][A[1].length - 1]), and so on.\nReturn the minimum possible value of D.length.\n\nExample 1:\nInput: [\"babca\",\"bbazb\"]\nOutput: 3\nExplanation: After deleting columns 0, 1, and 4, the final array is A = [\"bc\", \"az\"].\nBoth these rows are individually in lexicographic order (ie. A[0][0] <= A[0][1] and A[1][0] <= A[1][1]).\nNote that A[0] > A[1] - the array A isn't necessarily in lexicographic order.\n\nExample 2:\nInput: [\"edcba\"]\nOutput: 4\nExplanation: If we delete less than 4 columns, the only row won't be lexicographically sorted.\n\nExample 3:\nInput: [\"ghi\",\"def\",\"abc\"]\nOutput: 0\nExplanation: All rows are already lexicographically sorted.\n\nNote:\n\n1 <= A.length <= 100\n1 <= A[i].length <= 100", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn min_deletion_size(strings: Vec<String>) -> (result: usize)\n    requires \n        strings.len() > 0,\n        forall|i: int| 0 <= i < strings.len() ==> strings[i]@.len() > 0,\n        forall|i: int, j: int| 0 <= i < strings.len() && 0 <= j < strings.len() ==> strings[i]@.len() == strings[j]@.len(),\n    ensures result <= if strings.len() > 0 { strings[0]@.len() } else { 0 }", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = min_deletion_size(vec![\"babca\".to_string(), \"bbazb\".to_string()]);\n    // println!(\"Result 1: {}\", result1); // Expected: 3\n    \n    // let result2 = min_deletion_size(vec![\"edcba\".to_string()]);\n    // println!(\"Result 2: {}\", result2); // Expected: 4\n    \n    // let result3 = min_deletion_size(vec![\"ghi\".to_string(), \"def\".to_string(), \"abc\".to_string()]);\n    // println!(\"Result 3: {}\", result3); // Expected: 0\n}"}
{"id": "fvapps_000337", "vc-description": "Given an array of integers nums and an integer k. A continuous subarray is called nice if there are k odd numbers on it.\nReturn the number of nice sub-arrays.\n\nExample 1:\nInput: nums = [1,1,2,1,1], k = 3\nOutput: 2\nExplanation: The only sub-arrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1].\n\nExample 2:\nInput: nums = [2,4,6], k = 1\nOutput: 0\nExplanation: There is no odd numbers in the array.\n\nExample 3:\nInput: nums = [2,2,2,1,2,2,1,2,2,2], k = 2\nOutput: 16\n\nConstraints:\n\n1 <= nums.length <= 50000\n1 <= nums[i] <= 10^5\n1 <= k <= nums.length", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn count_odd_in_range(nums: Seq<i32>, start: int, end: int) -> int \n    decreases end - start\n{\n    if start >= end {\n        0int\n    } else if start < 0 || start >= nums.len() {\n        0int\n    } else {\n        (if nums[start] % 2 == 1 { 1int } else { 0int }) + count_odd_in_range(nums, start + 1, end)\n    }\n}\n\nspec fn is_nice_subarray(nums: Seq<i32>, start: int, end: int, k: int) -> bool {\n    start >= 0 && end <= nums.len() && start < end &&\n    count_odd_in_range(nums, start, end) == k\n}\n\nfn number_of_subarrays(nums: Vec<i32>, k: i32) -> (result: i32)\n    requires \n        nums.len() >= 1,\n        nums.len() <= 50000,\n        forall|i: int| 0 <= i < nums.len() ==> 1 <= nums[i] && nums[i] <= 100000,\n        1 <= k && k <= nums.len(),\n    ensures \n        result >= 0,\n        k > nums.len() ==> result == 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = number_of_subarrays(vec![1, 1, 2, 1, 1], 3);\n    // println!(\"Result 1: {}\", result1); // Expected: 2\n    \n    // let result2 = number_of_subarrays(vec![2, 4, 6], 1);\n    // println!(\"Result 2: {}\", result2); // Expected: 0\n    \n    // let result3 = number_of_subarrays(vec![2, 2, 2, 1, 2, 2, 1, 2, 2, 2], 2);\n    // println!(\"Result 3: {}\", result3); // Expected: 16\n}"}
{"id": "fvapps_000341", "vc-description": "Given an array A of positive integers, call a (contiguous, not necessarily distinct) subarray of A good if the number of different integers in that subarray is exactly K.\n(For example, [1,2,3,1,2] has 3 different integers: 1, 2, and 3.)\nReturn the number of good subarrays of A.\n\nExample 1:\nInput: A = [1,2,1,2,3], K = 2\nOutput: 7\nExplanation: Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].\n\nExample 2:\nInput: A = [1,2,1,3,4], K = 3\nOutput: 3\nExplanation: Subarrays formed with exactly 3 different integers: [1,2,1,3], [2,1,3], [1,3,4].\n\nNote:\n\n1 <= A.length <= 20000\n1 <= A[i] <= A.length\n1 <= K <= A.length", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn unique_elements(a: Seq<nat>) -> Set<nat>\n    decreases a.len()\n{\n    if a.len() == 0 {\n        set![]\n    } else {\n        unique_elements(a.skip(1)).insert(a[0])\n    }\n}", "vc-spec": "fn subarrays_with_k_distinct(a: Vec<nat>, k: nat) -> (result: nat)\n    requires \n        a.len() > 0,\n        1 <= k <= 50,\n        forall|x: nat| a@.contains(x) ==> 1 <= x <= 100,\n    ensures \n        result >= 0,\n        k == 1 ==> result >= a.len(),\n        k == unique_elements(a@).len() ==> result >= 1,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000342", "vc-description": "On a broken calculator that has a number showing on its display, we can perform two operations:\n\nDouble: Multiply the number on the display by 2, or;\nDecrement: Subtract 1 from the number on the display.\n\nInitially, the calculator is displaying the number X.\nReturn the minimum number of operations needed to display the number Y.\n\nExample 1:\nInput: X = 2, Y = 3\nOutput: 2\nExplanation: Use double operation and then decrement operation {2 -> 4 -> 3}.\n\nExample 2:\nInput: X = 5, Y = 8\nOutput: 2\nExplanation: Use decrement and then double {5 -> 4 -> 8}.\n\nExample 3:\nInput: X = 3, Y = 10\nOutput: 3\nExplanation:  Use double, decrement and double {3 -> 6 -> 5 -> 10}.\n\nExample 4:\nInput: X = 1024, Y = 1\nOutput: 1023\nExplanation: Use decrement operations 1023 times.\n\nNote:\n\n1 <= X <= 10^9\n1 <= Y <= 10^9", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn broken_calc(start: nat, target: nat) -> (result: nat)\n    requires\n        1 <= start <= 1000000000,\n        1 <= target <= 1000000000,\n    ensures\n        result >= 0,\n        start == target ==> result == 0,\n        start > target ==> result == start - target,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded_and_plausible\n\n    // #eval broken_calc 2 3  // Expected: 2\n    // #eval broken_calc 5 8  // Expected: 2 \n    // #eval broken_calc 3 10 // Expected: 3\n}"}
{"id": "fvapps_000343", "vc-description": "Given a list of words, each word consists of English lowercase letters.\nLet's say word1 is a predecessor of word2 if and only if we can add exactly one letter anywhere in word1 to make it equal to word2.  For example, \"abc\" is a predecessor of \"abac\".\nA word chain is a sequence of words [word_1, word_2, ..., word_k] with k >= 1, where word_1 is a predecessor of word_2, word_2 is a predecessor of word_3, and so on.\nReturn the longest possible length of a word chain with words chosen from the given list of words.\n\nExample 1:\nInput: [\"a\",\"b\",\"ba\",\"bca\",\"bda\",\"bdca\"]\nOutput: 4\nExplanation: one of the longest word chain is \"a\",\"ba\",\"bda\",\"bdca\".\n\nNote:\n\n1 <= words.length <= 1000\n1 <= words[i].length <= 16\nwords[i] only consists of English lowercase letters.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn longest_str_chain(words: Vec<String>) -> (result: nat)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let test1 = vec![\"a\".to_string(), \"b\".to_string(), \"ba\".to_string(), \"bca\".to_string(), \"bda\".to_string(), \"bdca\".to_string()];\n    // println!(\"{}\", longest_str_chain(test1));\n    \n    // let test2 = vec![\"xbc\".to_string(), \"pcxbcf\".to_string(), \"xb\".to_string(), \"cxbc\".to_string(), \"pcxbc\".to_string()];\n    // println!(\"{}\", longest_str_chain(test2));\n    \n    // let test3 = vec![\"a\".to_string(), \"b\".to_string(), \"ab\".to_string(), \"bac\".to_string()];\n    // println!(\"{}\", longest_str_chain(test3));\n}"}
{"id": "fvapps_000344", "vc-description": "Given an array of integers nums and an integer target.\nReturn the number of non-empty subsequences of nums such that the sum of the minimum and maximum element on it is less or equal than target.\nSince the answer may be too large, return it modulo 10^9 + 7.\n\nExample 1:\nInput: nums = [3,5,6,7], target = 9\nOutput: 4\nExplanation: There are 4 subsequences that satisfy the condition.\n[3] -> Min value + max value <= target (3 + 3 <= 9)\n[3,5] -> (3 + 5 <= 9)\n[3,5,6] -> (3 + 6 <= 9)\n[3,6] -> (3 + 6 <= 9)\n\nExample 2:\nInput: nums = [3,3,6,8], target = 10\nOutput: 6\nExplanation: There are 6 subsequences that satisfy the condition. (nums can have repeated numbers).\n[3] , [3] , [3,3], [3,6] , [3,6] , [3,3,6]\nExample 3:\nInput: nums = [2,3,3,4,6,7], target = 12\nOutput: 61\nExplanation: There are 63 non-empty subsequences, two of them don't satisfy the condition ([6,7], [7]).\nNumber of valid subsequences (63 - 2 = 61).\n\nExample 4:\nInput: nums = [5,2,4,1,7,6,8], target = 16\nOutput: 127\nExplanation: All non-empty subset satisfy the condition (2^7 - 1) = 127\n\nConstraints:\n\n1 <= nums.length <= 10^5\n1 <= nums[i] <= 10^6\n1 <= target <= 10^6", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn minimum(l: Seq<u32>) -> Option<u32> {\n    if l.len() == 0 {\n        None\n    } else {\n        Some(l.fold_left(l[0], |acc: u32, x: u32| if x < acc { x } else { acc }))\n    }\n}", "vc-spec": "fn num_subseq(nums: Vec<u32>, target: u32) -> (result: u32)\n    requires\n        target >= 2,\n        nums.len() >= 1,\n        forall|i: int| 0 <= i < nums.len() ==> nums[i] >= 1 && nums[i] <= 1000,\n    ensures\n        result < 1000000007,\n        (nums.len() == 1 && nums[0] >= 1 && nums[0] <= 100) ==> \n            result == (if nums[0] * 2 <= nums[0] * 3 { 1u32 } else { 0u32 })", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded_and_plausible\n\n    // #eval numSubseq [3, 5, 6, 7] 9 should output 4\n    // #eval numSubseq [3, 3, 6, 8] 10 should output 6  \n    // #eval numSubseq [2, 3, 3, 4, 6, 7] 12 should output 61\n}"}
{"id": "fvapps_000345", "vc-description": "A die simulator generates a random number from 1 to 6 for each roll. You introduced a constraint to the generator such that it cannot roll the number i more than rollMax[i] (1-indexed) consecutive times. \nGiven an array of integers rollMax and an integer n, return the number of distinct sequences that can be obtained with exact n rolls.\nTwo sequences are considered different if at least one element differs from each other. Since the answer may be too large, return it modulo 10^9 + 7.\n\nExample 1:\nInput: n = 2, rollMax = [1,1,2,2,2,3]\nOutput: 34\nExplanation: There will be 2 rolls of die, if there are no constraints on the die, there are 6 * 6 = 36 possible combinations. In this case, looking at rollMax array, the numbers 1 and 2 appear at most once consecutively, therefore sequences (1,1) and (2,2) cannot occur, so the final answer is 36-2 = 34.\n\nExample 2:\nInput: n = 2, rollMax = [1,1,1,1,1,1]\nOutput: 30\n\nExample 3:\nInput: n = 3, rollMax = [1,1,1,2,2,3]\nOutput: 181\n\nConstraints:\n\n1 <= n <= 5000\nrollMax.length == 6\n1 <= rollMax[i] <= 15", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn die_simulator_spec(n: usize, roll_max: Seq<usize>) -> usize\n{\n    0  // placeholder specification\n}\n\nfn die_simulator(n: usize, roll_max: Vec<usize>) -> (result: usize)\n    requires \n        1 <= n && n <= 20,\n        roll_max.len() == 6,\n        forall|i: int| 0 <= i < roll_max.len() ==> 1 <= roll_max[i] && roll_max[i] <= 15,\n    ensures \n        0 <= result && result < 1000000007,\n        result == die_simulator_spec(n, roll_max@),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\nproof fn die_simulator_within_bounds(n: usize, roll_max: Vec<usize>)\n    requires \n        1 <= n && n <= 20,\n        roll_max.len() == 6,\n        forall|i: int| 0 <= i < roll_max.len() ==> 1 <= roll_max[i] && roll_max[i] <= 15,\n    ensures ({\n        let result = die_simulator_spec(n, roll_max@);\n        0 <= result && result < 1000000007\n    })\n{\n    assume(false); /* TODO: Remove this line and implement the proof */\n}\n\nproof fn die_simulator_base_case(roll_max: Vec<usize>)\n    requires \n        roll_max.len() == 6,\n        forall|i: int| 0 <= i < roll_max.len() ==> 1 <= roll_max[i] && roll_max[i] <= 15,\n    ensures \n        die_simulator_spec(1, roll_max@) == 6,\n{\n    assume(false); /* TODO: Remove this line and implement the proof */\n}\n\nproof fn die_simulator_monotonic(n: usize, strict: Vec<usize>, loose: Vec<usize>)\n    requires \n        strict.len() == 6,\n        loose.len() == 6,\n        forall|i: int| 0 <= i < strict.len() ==> strict[i] == 1,\n        forall|i: int| 0 <= i < loose.len() ==> loose[i] == 15,\n    ensures \n        die_simulator_spec(n, strict@) <= die_simulator_spec(n, loose@),\n{\n    assume(false); /* TODO: Remove this line and implement the proof */\n}\n\n}\n\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded\n\n    // #guard_msgs in\n    // #eval dieSimulator 2 [1, 1, 2, 2, 2, 3]\n    // Expected: 34\n\n    // #guard_msgs in  \n    // #eval dieSimulator 2 [1, 1, 1, 1, 1, 1]\n    // Expected: 30\n\n    // #guard_msgs in\n    // #eval dieSimulator 3 [1, 1, 1, 2, 2, 3]\n    // Expected: 181\n}"}
{"id": "fvapps_000346", "vc-description": "Given integers n and k, find the lexicographically k-th smallest integer in the range from 1 to n.\n\nNote: 1 ≤ k ≤ n ≤ 109.\n\nExample:\n\nInput:\nn: 13   k: 2\n\nOutput:\n10\n\nExplanation:\nThe lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn find_kth_number(n: nat, k: nat) -> nat\n    recommends 1 <= k <= n\n{\n    if n == 13 && k == 2 { 10 }\n    else if n == 10 && k == 3 { 2 }\n    else if n == 100 && k == 10 { 17 }\n    else if n == 20 && k == 1 { 1 }\n    else if n == 50 && k == 5 { 13 }\n    else { 1 }\n}\n\nfn find_kth_number_exec(n: u32, k: u32) -> (result: u32)\n    requires 1 <= k <= n,\n    ensures result as nat == find_kth_number(n as nat, k as nat)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n\nproof fn find_kth_number_fixed_cases()\n    ensures \n        find_kth_number(13, 2) == 10 &&\n        find_kth_number(10, 3) == 2 &&\n        find_kth_number(100, 10) == 17 &&\n        find_kth_number(20, 1) == 1 &&\n        find_kth_number(50, 5) == 13\n{\n    // This follows directly from the definition of find_kth_number\n}", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: unguarded\n\n    // println!(\"{}\", find_kth_number_exec(13, 2));\n    // println!(\"{}\", find_kth_number_exec(10, 3));\n    // println!(\"{}\", find_kth_number_exec(100, 10));\n}"}
{"id": "fvapps_000348", "vc-description": "You are given an array representing a row of seats where seats[i] = 1 represents a person sitting in the ith seat, and seats[i] = 0 represents that the ith seat is empty (0-indexed).\nThere is at least one empty seat, and at least one person sitting.\nAlex wants to sit in the seat such that the distance between him and the closest person to him is maximized. \nReturn that maximum distance to the closest person.\n\nExample 1:\n\nInput: seats = [1,0,0,0,1,0,1]\nOutput: 2\nExplanation: \nIf Alex sits in the second open seat (i.e. seats[2]), then the closest person has distance 2.\nIf Alex sits in any other open seat, the closest person has distance 1.\nThus, the maximum distance to the closest person is 2.\n\nExample 2:\nInput: seats = [1,0,0,0]\nOutput: 3\nExplanation: \nIf Alex sits in the last seat (i.e. seats[3]), the closest person is 3 seats away.\nThis is the maximum distance possible, so the answer is 3.\n\nExample 3:\nInput: seats = [0,1]\nOutput: 1\n\nConstraints:\n\n2 <= seats.length <= 2 * 104\nseats[i] is 0 or 1.\nAt least one seat is empty.\nAt least one seat is occupied.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn longest_consecutive_ones(xs: Seq<nat>, n: nat) -> nat {\n    0\n}", "vc-spec": "fn max_dist_to_closest(seats: Vec<nat>) -> (result: nat)\n    requires \n        seats.len() >= 2,\n        seats.len() <= 20000,\n        forall|i: int| 0 <= i < seats.len() ==> (seats[i] == 0 || seats[i] == 1),\n        exists|i: int| 0 <= i < seats.len() && seats[i] == 1,\n        exists|i: int| 0 <= i < seats.len() && seats[i] == 0,\n    ensures\n        result >= 0,\n        result <= seats.len(),\n        forall|i: int, j: int| (0 <= i < seats.len() && 0 <= j < seats.len() && \n                                i < j && seats[i] == 1 && seats[j] == 1) ==>\n                               ((j - i - 1) + 1) / 2 <= result,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let test1 = vec![1, 0, 0, 0, 1, 0, 1];\n    // let result1 = max_dist_to_closest(test1);\n    // println!(\"Test 1 result: {}\", result1);\n\n    // let test2 = vec![1, 0, 0, 0];\n    // let result2 = max_dist_to_closest(test2);\n    // println!(\"Test 2 result: {}\", result2);\n\n    // let test3 = vec![0, 1];\n    // let result3 = max_dist_to_closest(test3);\n    // println!(\"Test 3 result: {}\", result3);\n}"}
{"id": "fvapps_000352", "vc-description": "Given a rectangle of size n x m, find the minimum number of integer-sided squares that tile the rectangle.\n\nExample 1:\n\nInput: n = 2, m = 3\nOutput: 3\nExplanation: 3 squares are necessary to cover the rectangle.\n2 (squares of 1x1)\n1 (square of 2x2)\nExample 2:\n\nInput: n = 5, m = 8\nOutput: 5\n\nExample 3:\n\nInput: n = 11, m = 13\nOutput: 6\n\nConstraints:\n\n1 <= n <= 13\n1 <= m <= 13", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn tile_rectangle(n: u32, m: u32) -> (result: u32)\n    requires \n        n > 0,\n        m > 0,\n    ensures\n        result >= 1,\n        result <= n * m,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "}\n\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded\n\n    // info: 3\n    // assert(tile_rectangle(2, 3) == 3);\n\n    // info: 5\n    // assert(tile_rectangle(5, 8) == 5);\n\n    // info: 6\n    // assert(tile_rectangle(11, 13) == 6);\n}"}
{"id": "fvapps_000353", "vc-description": "There are n people and 40 types of hats labeled from 1 to 40.\nGiven a list of list of integers hats, where hats[i] is a list of all hats preferred by the i-th person.\nReturn the number of ways that the n people wear different hats to each other.\nSince the answer may be too large, return it modulo 10^9 + 7.\n\nExample 1:\nInput: hats = [[3,4],[4,5],[5]]\nOutput: 1\nExplanation: There is only one way to choose hats given the conditions. \nFirst person choose hat 3, Second person choose hat 4 and last one hat 5.\nExample 2:\nInput: hats = [[3,5,1],[3,5]]\nOutput: 4\nExplanation: There are 4 ways to choose hats\n(3,5), (5,3), (1,3) and (1,5)\n\nExample 3:\nInput: hats = [[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4]]\nOutput: 24\nExplanation: Each person can choose hats labeled from 1 to 4.\nNumber of Permutations of (1,2,3,4) = 24.\n\nExample 4:\nInput: hats = [[1,2,3],[2,3,5,6],[1,3,7,9],[1,8,9],[2,5,7]]\nOutput: 111\n\nConstraints:\n\nn == hats.length\n1 <= n <= 10\n1 <= hats[i].length <= 40\n1 <= hats[i][j] <= 40\nhats[i] contains a list of unique integers.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn number_ways(hats: Vec<Vec<i32>>) -> (result: nat)\n    requires\n        hats.len() >= 1,\n        hats.len() <= 10,\n        forall|i: int| 0 <= i < hats.len() ==> hats[i].len() >= 1,\n        forall|i: int| 0 <= i < hats.len() ==> hats[i].len() <= 40,\n        forall|i: int, j: int| 0 <= i < hats.len() && 0 <= j < hats[i].len() ==> 1 <= hats[i][j] && hats[i][j] <= 40,\n    ensures\n        result < 1000000007,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded_and_plausible\n}"}
{"id": "fvapps_000354", "vc-description": "Given a 2D array A, each cell is 0 (representing sea) or 1 (representing land)\nA move consists of walking from one land square 4-directionally to another land square, or off the boundary of the grid.\nReturn the number of land squares in the grid for which we cannot walk off the boundary of the grid in any number of moves.\n\nExample 1:\nInput: [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]\nOutput: 3\nExplanation: \nThere are three 1s that are enclosed by 0s, and one 1 that isn't enclosed because its on the boundary.\nExample 2:\nInput: [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]\nOutput: 0\nExplanation: \nAll 1s are either on the boundary or can reach the boundary.\n\nNote:\n\n1 <= A.length <= 500\n1 <= A[i].length <= 500\n0 <= A[i][j] <= 1\nAll rows have the same size.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn num_enclaves(grid: Vec<Vec<usize>>) -> (result: usize)\n    requires \n        grid.len() > 0,\n        grid.len() <= 500,\n        grid[0].len() > 0,\n        grid[0].len() <= 500,\n        forall|i: int| 0 <= i < grid.len() ==> #[trigger] grid[i].len() == grid[0].len(),\n        forall|i: int, j: int| 0 <= i < grid.len() && 0 <= j < grid[i].len() ==> #[trigger] grid[i][j] <= 1,\n    ensures\n        result >= 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: unguarded\n\n    // Test cases:\n    // Example 1: [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]] -> 3\n    // Example 2: [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]] -> 0\n    // Example 3: [[0,0,0,1],[0,1,1,0],[0,1,0,0]] -> 0\n}"}
{"id": "fvapps_000357", "vc-description": "Find the length of the longest substring T of a given string (consists of lowercase letters only) such that every character in T appears no less than k times.\n\nExample 1:\n\nInput:\ns = \"aaabb\", k = 3\n\nOutput:\n3\n\nThe longest substring is \"aaa\", as 'a' is repeated 3 times.\n\nExample 2:\n\nInput:\ns = \"ababbc\", k = 2\n\nOutput:\n5\n\nThe longest substring is \"ababb\", as 'a' is repeated 2 times and 'b' is repeated 3 times.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn longest_substring_with_k_occurrences(s: Vec<char>, k: usize) -> (result: usize)\n    requires k > 0,\n    ensures\n        result <= s.len(),\n        (s.len() == 1 && k == 1) ==> result == 1,\n        (s.len() == 1 && k > 1) ==> result == 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded_and_plausible\n\n    // info: 3\n    // println!(\"{}\", longest_substring_with_k_occurrences(\"aaabb\".chars().collect(), 3));\n\n    // info: 5\n    // println!(\"{}\", longest_substring_with_k_occurrences(\"ababbc\".chars().collect(), 2));\n\n    // info: 0\n    // println!(\"{}\", longest_substring_with_k_occurrences(\"abcdef\".chars().collect(), 2));\n}"}
{"id": "fvapps_000359", "vc-description": "A chef has collected data on the satisfaction level of his n dishes. Chef can cook any dish in 1 unit of time.\nLike-time coefficient of a dish is defined as the time taken to cook that dish including previous dishes multiplied by its satisfaction level  i.e.  time[i]*satisfaction[i]\nReturn the maximum sum of Like-time coefficient that the chef can obtain after dishes preparation.\nDishes can be prepared in any order and the chef can discard some dishes to get this maximum value.\n\nExample 1:\nInput: satisfaction = [-1,-8,0,5,-9]\nOutput: 14\nExplanation: After Removing the second and last dish, the maximum total Like-time coefficient will be equal to (-1*1 + 0*2 + 5*3 = 14). Each dish is prepared in one unit of time.\nExample 2:\nInput: satisfaction = [4,3,2]\nOutput: 20\nExplanation: Dishes can be prepared in any order, (2*1 + 3*2 + 4*3 = 20)\n\nExample 3:\nInput: satisfaction = [-1,-4,-5]\nOutput: 0\nExplanation: People don't like the dishes. No dish is prepared.\n\nExample 4:\nInput: satisfaction = [-2,5,-1,0,3,-3]\nOutput: 35\n\nConstraints:\n\nn == satisfaction.length\n1 <= n <= 500\n-10^3 <= satisfaction[i] <= 10^3", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn max_satisfaction(satisfaction: Vec<i32>) -> (result: i32)\n    ensures\n        result >= 0,\n        satisfaction@ == Seq::<i32>::empty() ==> result == 0,\n        satisfaction@.len() == 1 && satisfaction@[0] == 0 ==> result == 0,\n        satisfaction@.len() == 1 && satisfaction@[0] == 1 ==> result == 1,\n        satisfaction@.len() == 1 && satisfaction@[0] == -1 ==> result == 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "/* Apps difficulty: interview\n   Assurance level: guarded_and_plausible */\n\n}\n\nfn main() {\n    // let result1 = max_satisfaction(vec![-1, -8, 0, 5, -9]);\n    // println!(\"Result 1: {}\", result1); // Expected: 14\n\n    // let result2 = max_satisfaction(vec![4, 3, 2]);\n    // println!(\"Result 2: {}\", result2); // Expected: 20\n\n    // let result3 = max_satisfaction(vec![-2, 5, -1, 0, 3, -3]);\n    // println!(\"Result 3: {}\", result3); // Expected: 35\n}"}
{"id": "fvapps_000361", "vc-description": "Given a non-empty array of unique positive integers A, consider the following graph:\n\nThere are A.length nodes, labelled A[0] to A[A.length - 1];\nThere is an edge between A[i] and A[j] if and only if A[i] and A[j] share a common factor greater than 1.\n\nReturn the size of the largest connected component in the graph.\n\nExample 1:\nInput: [4,6,15,35]\nOutput: 4\n\nExample 2:\nInput: [20,50,9,63]\nOutput: 2\n\nExample 3:\nInput: [2,3,6,7,4,12,21,39]\nOutput: 8\n\nNote:\n\n1 <= A.length <= 20000\n1 <= A[i] <= 100000", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn gcd(a: nat, b: nat) -> nat\n    decreases b\n{\n    if b == 0 { a } else { gcd(b, a % b) }\n}\n\nspec fn have_common_factor(a: nat, b: nat) -> bool {\n    gcd(a, b) > 1\n}\n\nfn largest_component_size(nums: Vec<nat>) -> (result: nat)\n    requires nums.len() > 0,\n    ensures \n        result > 0,\n        result <= nums.len(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n/* Apps difficulty: interview */\n/* Assurance level: unguarded */\n\n/*\nfn test_examples() {\n    // Example 1: [4,6,15,35] should output 4\n    // Example 2: [20,50,9,63] should output 2  \n    // Example 3: [2,3,6,7,4,12,21,39] should output 8\n}\n*/\n\n}\n\nfn main() {}"}
{"id": "fvapps_000363", "vc-description": "Given an input string (s) and a pattern (p), implement regular expression matching with support for '.' and '*'.\n\n'.' Matches any single character.\n'*' Matches zero or more of the preceding element.\n\nThe matching should cover the entire input string (not partial).\n\nNote:\n\n       s could be empty and contains only lowercase letters a-z.\n       p could be empty and contains only lowercase letters a-z, and characters like . or *.\n\nExample 1:\n\nInput:\ns = \"aa\"\np = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\n\nExample 2:\n\nInput:\ns = \"aa\"\np = \"a*\"\nOutput: true\nExplanation: '*' means zero or more of the precedeng element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".\n\nExample 3:\n\nInput:\ns = \"ab\"\np = \".*\"\nOutput: true\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\n\nExample 4:\n\nInput:\ns = \"aab\"\np = \"c*a*b\"\nOutput: true\nExplanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches \"aab\".\n\nExample 5:\n\nInput:\ns = \"mississippi\"\np = \"mis*is*p*.\"\nOutput: false", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn is_match(s: Vec<char>, p: Vec<char>) -> (result: bool)\n    ensures \n        /* empty pattern matches only empty string */\n        p.len() == 0 ==> (result == (s.len() == 0)),\n        /* dot-star pattern matches everything */\n        (p.len() == 2 && p[0] == '.' && p[1] == '*') ==> result == true,\n        /* self matching */\n        s@ == p@ ==> result == true,\n        /* empty string edge cases */\n        (s.len() == 0 && p.len() == 0) ==> result == true,\n        (s.len() == 0 && p.len() == 2 && p[0] == 'a' && p[1] == '*') ==> result == true,\n        (s.len() > 0 && p.len() == 0) ==> result == false", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let s1 = vec!['a', 'a'];\n    // let p1 = vec!['a'];\n    // let result1 = is_match(s1, p1);\n    // println!(\"is_match([a,a], [a]) = {}\", result1);\n    \n    // let s2 = vec!['a', 'a'];\n    // let p2 = vec!['a', '*'];\n    // let result2 = is_match(s2, p2);\n    // println!(\"is_match([a,a], [a,*]) = {}\", result2);\n    \n    // let s3 = vec!['a', 'b'];\n    // let p3 = vec!['.', '*'];\n    // let result3 = is_match(s3, p3);\n    // println!(\"is_match([a,b], [.,*]) = {}\", result3);\n}"}
{"id": "fvapps_000367", "vc-description": "Given N, consider a convex N-sided polygon with vertices labelled A[0], A[i], ..., A[N-1] in clockwise order.\nSuppose you triangulate the polygon into N-2 triangles.  For each triangle, the value of that triangle is the product of the labels of the vertices, and the total score of the triangulation is the sum of these values over all N-2 triangles in the triangulation.\nReturn the smallest possible total score that you can achieve with some triangulation of the polygon.\n\nExample 1:\nInput: [1,2,3]\nOutput: 6\nExplanation: The polygon is already triangulated, and the score of the only triangle is 6.\n\nExample 2:\n\nInput: [3,7,4,5]\nOutput: 144\nExplanation: There are two triangulations, with possible scores: 3*7*5 + 4*5*7 = 245, or 3*4*5 + 3*4*7 = 144.  The minimum score is 144.\n\nExample 3:\nInput: [1,3,1,4,1,5]\nOutput: 13\nExplanation: The minimum score triangulation has score 1*1*3 + 1*1*4 + 1*1*5 + 1*1*1 = 13.\n\nNote:\n\n3 <= A.length <= 50\n1 <= A[i] <= 100", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn min_score_triangulation(vertices: Vec<u32>) -> (result: u32)\n    requires vertices.len() >= 3,\n    ensures result >= 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "/* Apps difficulty: interview */\n/* Assurance level: unguarded */\n\n}\n\nfn main() {\n    // let result1 = min_score_triangulation(vec![1, 2, 3]);\n    // assert(result1 == 6);\n    \n    // let result2 = min_score_triangulation(vec![3, 7, 4, 5]);\n    // assert(result2 == 144);\n    \n    // let result3 = min_score_triangulation(vec![1, 3, 1, 4, 1, 5]);\n    // assert(result3 == 13);\n}"}
{"id": "fvapps_000368", "vc-description": "A positive integer is magical if it is divisible by either A or B.\nReturn the N-th magical number.  Since the answer may be very large, return it modulo 10^9 + 7.\n\nExample 1:\nInput: N = 1, A = 2, B = 3\nOutput: 2\n\nExample 2:\nInput: N = 4, A = 2, B = 3\nOutput: 6\n\nExample 3:\nInput: N = 5, A = 2, B = 4\nOutput: 10\n\nExample 4:\nInput: N = 3, A = 6, B = 4\nOutput: 8\n\nNote:\n\n1 <= N <= 10^9\n2 <= A <= 40000\n2 <= B <= 40000", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "const MOD: u32 = 1000000007;\n\nfn nth_magical_number(n: u32, a: u32, b: u32) -> (result: u32)\n    requires \n        n > 0,\n        a > 0,\n        b > 0,\n        n <= 1000000000,\n        a >= 2 && a <= 40000,\n        b >= 2 && b <= 40000,\n    ensures \n        result < MOD,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded\n\n    // println!(\"{}\", nth_magical_number(1, 2, 3)); // Expected: 2\n    // println!(\"{}\", nth_magical_number(4, 2, 3)); // Expected: 6\n    // println!(\"{}\", nth_magical_number(5, 2, 4)); // Expected: 10\n}"}
{"id": "fvapps_000371", "vc-description": "Write a function to check whether an input string is a valid IPv4 address or IPv6 address or neither.\n\nIPv4 addresses are canonically represented in dot-decimal notation, which consists of four decimal numbers, each ranging from 0 to 255, separated by dots (\".\"), e.g.,172.16.254.1;\n\nBesides, leading zeros in the IPv4 is invalid. For example, the address 172.16.254.01 is invalid.\n\nIPv6 addresses are represented as eight groups of four hexadecimal digits, each group representing 16 bits. The groups are separated by colons (\":\"). For example, the address 2001:0db8:85a3:0000:0000:8a2e:0370:7334 is a valid one. Also, we could omit some leading zeros among four hexadecimal digits and some low-case characters in the address to upper-case ones, so 2001:db8:85a3:0:0:8A2E:0370:7334 is also a valid IPv6 address(Omit leading zeros and using upper cases).\n\nHowever, we don't replace a consecutive group of zero value with a single empty group using two consecutive colons (::) to pursue simplicity. For example, 2001:0db8:85a3::8A2E:0370:7334 is an invalid IPv6 address.\n\nBesides, extra leading zeros in the IPv6 is also invalid. For example, the address 02001:0db8:85a3:0000:0000:8a2e:0370:7334 is invalid.\n\nNote:\nYou may assume there is no extra space or special characters in the input string.\n\nExample 1:\nInput: \"172.16.254.1\"\nOutput: \"IPv4\"\nExplanation: This is a valid IPv4 address, return \"IPv4\".\n\nExample 2:\nInput: \"2001:0db8:85a3:0:0:8A2E:0370:7334\"\nOutput: \"IPv6\"\nExplanation: This is a valid IPv6 address, return \"IPv6\".\n\nExample 3:\nInput: \"256.256.256.256\"\nOutput: \"Neither\"\nExplanation: This is neither a IPv4 address nor a IPv6 address.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn validate_ip_address(ip: &str) -> (result: String)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // println!(\"{}\", validate_ip_address(\"172.16.254.1\"));\n    // println!(\"{}\", validate_ip_address(\"2001:0db8:85a3:0:0:8A2E:0370:7334\"));\n    // println!(\"{}\", validate_ip_address(\"256.256.256.256\"));\n}"}
{"id": "fvapps_000373", "vc-description": "A peak element is an element that is greater than its neighbors.\n\nGiven an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index.\n\nThe array may contain multiple peaks, in that case return the index to any one of the peaks is fine.\n\nYou may imagine that nums[-1] = nums[n] = -∞.\n\nExample 1:\n\nInput: nums = [1,2,3,1]\nOutput: 2\nExplanation: 3 is a peak element and your function should return the index number 2.\n\nExample 2:\n\nInput: nums = [1,2,1,3,5,6,4]\nOutput: 1 or 5 \nExplanation: Your function can return either index number 1 where the peak element is 2, \n             or index number 5 where the peak element is 6.\n\nNote:\n\nYour solution should be in logarithmic complexity.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn find_peak_element(nums: Vec<i32>) -> (result: i32)\n    ensures \n        nums.len() == 0 ==> result == -1,\n        nums.len() > 0 ==> (0 <= result && result < nums.len()),\n        nums.len() == 1 ==> result == 0,\n        (result == 0 && nums.len() > 1) ==> \n            (nums[0] >= nums[1]),\n        (result == (nums.len() - 1) as i32 && nums.len() > 1) ==> \n            (nums[result as int] >= nums[(result - 1) as int]),\n        (0 < result && (result as int) < nums.len() - 1) ==> \n            (nums[result as int] >= nums[(result - 1) as int] && nums[result as int] >= nums[(result + 1) as int])", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = find_peak_element(vec![1, 2, 3, 1]);\n    // let result2 = find_peak_element(vec![1]);\n}"}
{"id": "fvapps_000375", "vc-description": "Given two positive integers n and k.\nA factor of an integer n is defined as an integer i where n % i == 0.\nConsider a list of all factors of n sorted in ascending order, return the kth factor in this list or return -1 if n has less than k factors.\n\nExample 1:\nInput: n = 12, k = 3\nOutput: 3\nExplanation: Factors list is [1, 2, 3, 4, 6, 12], the 3rd factor is 3.\n\nExample 2:\nInput: n = 7, k = 2\nOutput: 7\nExplanation: Factors list is [1, 7], the 2nd factor is 7.\n\nExample 3:\nInput: n = 4, k = 4\nOutput: -1\nExplanation: Factors list is [1, 2, 4], there is only 3 factors. We should return -1.\n\nExample 4:\nInput: n = 1, k = 1\nOutput: 1\nExplanation: Factors list is [1], the 1st factor is 1.\n\nExample 5:\nInput: n = 1000, k = 3\nOutput: 4\nExplanation: Factors list is [1, 2, 4, 5, 8, 10, 20, 25, 40, 50, 100, 125, 200, 250, 500, 1000].\n\nConstraints:\n\n1 <= k <= n <= 1000", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn count_factors_up_to(n: nat, limit: nat) -> nat \n    decreases limit\n{\n    if limit == 0 {\n        0nat\n    } else {\n        count_factors_up_to(n, (limit - 1) as nat) + \n        if n > 0 && limit > 0 && n % limit == 0 { 1nat } else { 0nat }\n    }\n}\n\nfn kth_factor(n: u32, k: u32) -> (result: i32)\n    requires n > 0 && k > 0,\n    ensures \n        (k == 1 ==> result == 1),\n        (result != -1 ==> result > 0 && n % (result as u32) == 0),\n        (result == -1 ==> count_factors_up_to(n as nat, n as nat) < k as nat),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded\n\n    // Example outputs:\n    // kth_factor(12, 3) should return 3\n    // kth_factor(7, 2) should return 7  \n    // kth_factor(4, 4) should return -1\n}"}
{"id": "fvapps_000376", "vc-description": "Given an integer n, your task is to count how many strings of length n can be formed under the following rules:\n\nEach character is a lower case vowel ('a', 'e', 'i', 'o', 'u')\nEach vowel 'a' may only be followed by an 'e'.\nEach vowel 'e' may only be followed by an 'a' or an 'i'.\nEach vowel 'i' may not be followed by another 'i'.\nEach vowel 'o' may only be followed by an 'i' or a 'u'.\nEach vowel 'u' may only be followed by an 'a'.\n\nSince the answer may be too large, return it modulo 10^9 + 7.\n\nExample 1:\nInput: n = 1\nOutput: 5\nExplanation: All possible strings are: \"a\", \"e\", \"i\" , \"o\" and \"u\".\n\nExample 2:\nInput: n = 2\nOutput: 10\nExplanation: All possible strings are: \"ae\", \"ea\", \"ei\", \"ia\", \"ie\", \"io\", \"iu\", \"oi\", \"ou\" and \"ua\".\n\nExample 3: \nInput: n = 5\nOutput: 68\n\nConstraints:\n\n1 <= n <= 2 * 10^4", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn count_vowel_permutation(n: nat) -> (result: nat)\n    requires n > 0,\n    ensures\n        result > 0,\n        result < 1000000007,\n        n == 1 ==> result == 5,\n        n == 2 ==> result == 10", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let result1 = count_vowel_permutation(1);\n    // println!(\"Result for n=1: {}\", result1);\n    \n    // let result2 = count_vowel_permutation(2);\n    // println!(\"Result for n=2: {}\", result2);\n    \n    // let result5 = count_vowel_permutation(5);\n    // println!(\"Result for n=5: {}\", result5);\n}"}
{"id": "fvapps_000377", "vc-description": "In a special ranking system, each voter gives a rank from highest to lowest to all teams participated in the competition.\nThe ordering of teams is decided by who received the most position-one votes. If two or more teams tie in the first position, we consider the second position to resolve the conflict, if they tie again, we continue this process until the ties are resolved. If two or more teams are still tied after considering all positions, we rank them alphabetically based on their team letter.\nGiven an array of strings votes which is the votes of all voters in the ranking systems. Sort all teams according to the ranking system described above.\nReturn a string of all teams sorted by the ranking system.\n\nExample 1:\nInput: votes = [\"ABC\",\"ACB\",\"ABC\",\"ACB\",\"ACB\"]\nOutput: \"ACB\"\nExplanation: Team A was ranked first place by 5 voters. No other team was voted as first place so team A is the first team.\nTeam B was ranked second by 2 voters and was ranked third by 3 voters.\nTeam C was ranked second by 3 voters and was ranked third by 2 voters.\nAs most of the voters ranked C second, team C is the second team and team B is the third.\n\nExample 2:\nInput: votes = [\"WXYZ\",\"XYZW\"]\nOutput: \"XWYZ\"\nExplanation: X is the winner due to tie-breaking rule. X has same votes as W for the first position but X has one vote as second position while W doesn't have any votes as second position. \n\nExample 3:\nInput: votes = [\"ZMNAGUEDSJYLBOPHRQICWFXTVK\"]\nOutput: \"ZMNAGUEDSJYLBOPHRQICWFXTVK\"\nExplanation: Only one voter so his votes are used for the ranking.\n\nExample 4:\nInput: votes = [\"BCA\",\"CAB\",\"CBA\",\"ABC\",\"ACB\",\"BAC\"]\nOutput: \"ABC\"\nExplanation: \nTeam A was ranked first by 2 voters, second by 2 voters and third by 2 voters.\nTeam B was ranked first by 2 voters, second by 2 voters and third by 2 voters.\nTeam C was ranked first by 2 voters, second by 2 voters and third by 2 voters.\nThere is a tie and we rank teams ascending by their IDs.\n\nExample 5:\nInput: votes = [\"M\",\"M\",\"M\",\"M\"]\nOutput: \"M\"\nExplanation: Only team M in the competition so it has the first rank.\n\nConstraints:\n\n1 <= votes.length <= 1000\n1 <= votes[i].length <= 26\nvotes[i].length == votes[j].length for 0 <= i, j < votes.length.\nvotes[i][j] is an English upper-case letter.\nAll characters of votes[i] are unique.\nAll the characters that occur in votes[0] also occur in votes[j] where 1 <= j < votes.length.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn is_uppercase_char(c: char) -> bool {\n    'A' <= c && c <= 'Z'\n}", "vc-spec": "fn rank_teams(votes: Vec<String>) -> (result: String)\n    requires\n        votes.len() > 0,\n        forall|i: int| 0 <= i < votes.len() ==> #[trigger] votes[i]@.len() == votes[0]@.len(),\n        forall|i: int| 0 <= i < votes.len() ==> #[trigger] votes[i]@.no_duplicates(),\n        forall|i: int| 0 <= i < votes.len() ==> votes[i]@.len() > 0,\n        forall|i: int, j: int| 0 <= i < votes.len() && 0 <= j < votes[i]@.len() ==> #[trigger] is_uppercase_char(votes[i]@.index(j)),\n    ensures\n        result@.len() == votes[0]@.len(),\n        forall|c: char| result@.contains(c) ==> is_uppercase_char(c),\n        result@.to_set() == votes[0]@.to_set(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = rank_teams(vec![\"ABC\".to_string(), \"ACB\".to_string(), \"ABC\".to_string(), \"ACB\".to_string(), \"ACB\".to_string()]);\n    // println!(\"{}\", result1); // Should print \"ACB\"\n    \n    // let result2 = rank_teams(vec![\"WXYZ\".to_string(), \"XYZW\".to_string()]);\n    // println!(\"{}\", result2); // Should print \"XWYZ\"\n    \n    // let result3 = rank_teams(vec![\"ZMNAGUEDSJYLBOPHRQICWFXTVK\".to_string()]);\n    // println!(\"{}\", result3); // Should print \"ZMNAGUEDSJYLBOPHRQICWFXTVK\"\n}"}
{"id": "fvapps_000380", "vc-description": "Alice and Bob take turns playing a game, with Alice starting first.\nInitially, there are n stones in a pile.  On each player's turn, that player makes a move consisting of removing any non-zero square number of stones in the pile.\nAlso, if a player cannot make a move, he/she loses the game.\nGiven a positive integer n. Return True if and only if Alice wins the game otherwise return False, assuming both players play optimally.\n\nExample 1:\nInput: n = 1\nOutput: true\nExplanation: Alice can remove 1 stone winning the game because Bob doesn't have any moves.\nExample 2:\nInput: n = 2\nOutput: false\nExplanation: Alice can only remove 1 stone, after that Bob removes the last one winning the game (2 -> 1 -> 0).\nExample 3:\nInput: n = 4\nOutput: true\nExplanation: n is already a perfect square, Alice can win with one move, removing 4 stones (4 -> 0).\n\nExample 4:\nInput: n = 7\nOutput: false\nExplanation: Alice can't win the game if Bob plays optimally.\nIf Alice starts removing 4 stones, Bob will remove 1 stone then Alice should remove only 1 stone and finally Bob removes the last one (7 -> 3 -> 2 -> 1 -> 0). \nIf Alice starts removing 1 stone, Bob will remove 4 stones then Alice only can remove 1 stone and finally Bob removes the last one (7 -> 6 -> 2 -> 1 -> 0).\nExample 5:\nInput: n = 17\nOutput: false\nExplanation: Alice can't win the game if Bob plays optimally.\n\nConstraints:\n\n1 <= n <= 10^5", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_perfect_square(n: nat) -> bool {\n    n == 1 || n == 4 || n == 9 || n == 16 || n == 25 || n == 36 || n == 49 || n == 64 || n == 81 || n == 100\n}\n\nfn can_alice_win_stones(n: u32) -> (result: bool)\n    requires n > 0,\n    ensures \n        n == 2 ==> result == false,\n        n == 1 ==> result == true,\n        n == 4 ==> result == true", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // #eval can_alice_win_stones 1\n    // #eval can_alice_win_stones 2\n    // #eval can_alice_win_stones 4\n}"}
{"id": "fvapps_000385", "vc-description": "You are given an integer array A. From some starting index, you can make a series of jumps. The (1st, 3rd, 5th, ...) jumps in the series are called odd numbered jumps, and the (2nd, 4th, 6th, ...) jumps in the series are called even numbered jumps.\nYou may from index i jump forward to index j (with i < j) in the following way:\n\nDuring odd numbered jumps (ie. jumps 1, 3, 5, ...), you jump to the index j such that A[i] <= A[j] and A[j] is the smallest possible value. If there are multiple such indexes j, you can only jump to the smallest such index j.\nDuring even numbered jumps (ie. jumps 2, 4, 6, ...), you jump to the index j such that A[i] >= A[j] and A[j] is the largest possible value. If there are multiple such indexes j, you can only jump to the smallest such index j.\n(It may be the case that for some index i, there are no legal jumps.)\n\nA starting index is good if, starting from that index, you can reach the end of the array (index A.length - 1) by jumping some number of times (possibly 0 or more than once.)\nReturn the number of good starting indexes.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn odd_even_jumps(arr: Vec<i32>) -> (result: usize)\n    requires arr.len() > 0,\n    ensures \n        1 <= result && result <= arr.len(),\n        result <= arr.len()", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = odd_even_jumps(vec![10, 13, 12, 14, 15]);\n    // assert_eq!(result1, 2);\n    \n    // let result2 = odd_even_jumps(vec![2, 3, 1, 1, 4]);\n    // assert_eq!(result2, 3);\n    \n    // let result3 = odd_even_jumps(vec![5, 1, 3, 4, 2]);\n    // assert_eq!(result3, 3);\n}"}
{"id": "fvapps_000387", "vc-description": "Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.\n\nExample:\n\nInput: 13\nOutput: 6 \nExplanation: Digit 1 occurred in the following numbers: 1, 10, 11, 12, 13.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn count_ones_in_number(n: nat) -> nat\n    decreases n\n{\n    if n == 0 {\n        0nat\n    } else {\n        let digit = n % 10;\n        let rest = n / 10;\n        (if digit == 1 { 1nat } else { 0nat }) + count_ones_in_number(rest)\n    }\n}\n\nspec fn count_ones_brute_force_spec(n: nat) -> nat\n    decreases n\n{\n    if n == 0 {\n        count_ones_in_number(0nat)\n    } else {\n        count_ones_in_number(n) + count_ones_brute_force_spec((n - 1) as nat)\n    }\n}\n\nspec fn count_digit_one_spec(n: nat) -> nat;\n\nspec fn count_ones_brute_force_ghost(n: nat) -> nat;\n\nfn count_digit_one(n: u32) -> (result: u32)\n    ensures result as nat == count_digit_one_spec(n as nat)\n{\n    assume(false);\n    0\n}\n\nfn count_ones_brute_force(n: u32) -> (result: u32)\n    ensures result as nat == count_ones_brute_force_ghost(n as nat)\n{\n    assume(false);\n    0\n}", "vc-code": "/* No additional implementation needed - functions defined above */", "vc-postamble": "\nproof fn count_digit_one_matches_brute_force(n: u32)\n    ensures count_digit_one_spec(n as nat) == count_ones_brute_force_ghost(n as nat)\n{\n    assume(false);\n}\n\nproof fn count_digit_one_boundary_values(n: u32)\n    requires n == 0 || n == 1 || n == 9 || n == 10 || n == 11 || n == 99 || n == 100\n    ensures count_digit_one_spec(n as nat) == count_ones_brute_force_ghost(n as nat)\n{\n    assume(false);\n}\n\nproof fn count_digit_one_monotonic(n: u32)\n    requires n < u32::MAX\n    ensures count_digit_one_spec(n as nat) <= count_digit_one_spec((n + 1) as nat)\n{\n    assume(false);\n}\n\nproof fn count_digit_one_nonnegative(n: u32)\n    ensures count_digit_one_spec(n as nat) >= 0\n{\n    assume(false);\n}\n\nproof fn count_digit_one_zero()\n    ensures count_digit_one_spec(0 as nat) == 0\n{\n    assume(false);\n}\n\n}\n\nfn main() {}"}
{"id": "fvapps_000392", "vc-description": "In a 1 million by 1 million grid, the coordinates of each grid square are (x, y) with 0 <= x, y < 10^6.\nWe start at the source square and want to reach the target square.  Each move, we can walk to a 4-directionally adjacent square in the grid that isn't in the given list of blocked squares.\nReturn true if and only if it is possible to reach the target square through a sequence of moves.\n\nExample 1:\nInput: blocked = [[0,1],[1,0]], source = [0,0], target = [0,2]\nOutput: false\nExplanation: \nThe target square is inaccessible starting from the source square, because we can't walk outside the grid.\n\nExample 2:\nInput: blocked = [], source = [0,0], target = [999999,999999]\nOutput: true\nExplanation: \nBecause there are no blocked cells, it's possible to reach the target square.\n\nNote:\n\n0 <= blocked.length <= 200\nblocked[i].length == 2\n0 <= blocked[i][j] < 10^6\nsource.length == target.length == 2\n0 <= source[i][j], target[i][j] < 10^6\nsource != target", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "type Point = (usize, usize);\n\nfn is_escape_possible(blocked: Vec<Point>, source: Point, target: Point) -> (result: bool)\n    requires \n        source.0 < 1000000 && source.1 < 1000000,\n        target.0 < 1000000 && target.1 < 1000000,\n        blocked.len() <= 200,\n        forall|i: int| 0 <= i < blocked.len() ==> \n            blocked[i].0 < 1000000 && blocked[i].1 < 1000000,\n        source != target,\n    ensures\n        /* Empty blocked list always allows escape */\n        blocked.len() == 0 ==> result == true,\n        /* Source or target in blocked makes escape impossible */\n        (blocked@.contains(source) || blocked@.contains(target)) ==> result == false,\n        /* Same source and target with unblocked source is possible */\n        (source == target && !blocked@.contains(source)) ==> result == true,", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let test1 = is_escape_possible(vec![(0, 1), (1, 0)], (0, 0), (0, 2));\n    // println!(\"Test 1: {}\", test1);  // Should be false\n    \n    // let test2 = is_escape_possible(vec![], (0, 0), (999999, 999999));\n    // println!(\"Test 2: {}\", test2);  // Should be true\n    \n    // let test3 = is_escape_possible(vec![(10, 9), (9, 10), (10, 11), (11, 10)], (0, 0), (10, 10));\n    // println!(\"Test 3: {}\", test3);  // Should be false\n}"}
{"id": "fvapps_000393", "vc-description": "Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.\n\nFormally the function should:\nReturn true if there exists i, j, k  \nsuch that arr[i] < arr[j] < arr[k] given 0 ≤ i < j < k ≤ n-1 \nelse return false.\n\nYour algorithm should run in O(n) time complexity and O(1) space complexity.\n\nExamples:\nGiven [1, 2, 3, 4, 5],\nreturn true.\n\nGiven [5, 4, 3, 2, 1],\nreturn false.\n\nCredits:Special thanks to @DjangoUnchained for adding this problem and creating all test cases.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn has_increasing_triplet_spec(nums: Seq<i32>) -> bool {\n    exists|i: int, j: int, k: int| \n        0 <= i < j && j < k && k < nums.len() &&\n        nums[i] < nums[j] && nums[j] < nums[k]\n}\n\nfn has_increasing_triplet(nums: Vec<i32>) -> (result: bool)\n    ensures result == has_increasing_triplet_spec(nums@)", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let test1 = vec![1, 2, 3, 4, 5];\n    // println!(\"{}\", has_increasing_triplet(test1));\n    \n    // let test2 = vec![5, 4, 3, 2, 1];\n    // println!(\"{}\", has_increasing_triplet(test2));\n    \n    // let test3 = vec![2, 1, 5, 0, 4, 6];\n    // println!(\"{}\", has_increasing_triplet(test3));\n}"}
{"id": "fvapps_000395", "vc-description": "Alice plays the following game, loosely based on the card game \"21\".\nAlice starts with 0 points, and draws numbers while she has less than K points.  During each draw, she gains an integer number of points randomly from the range [1, W], where W is an integer.  Each draw is independent and the outcomes have equal probabilities.\nAlice stops drawing numbers when she gets K or more points.  What is the probability that she has N or less points?\nExample 1:\nInput: N = 10, K = 1, W = 10\nOutput: 1.00000\nExplanation:  Alice gets a single card, then stops.\n\nExample 2:\nInput: N = 6, K = 1, W = 10\nOutput: 0.60000\nExplanation:  Alice gets a single card, then stops.\nIn 6 out of W = 10 possibilities, she is at or below N = 6 points.\n\nExample 3:\nInput: N = 21, K = 17, W = 10\nOutput: 0.73278\nNote:\n\n0 <= K <= N <= 10000\n1 <= W <= 10000\nAnswers will be accepted as correct if they are within 10^-5 of the correct answer.\nThe judging time limit has been reduced for this question.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn new21_game(n: u32, k: u32, w: u32) -> (result: f64)\n    requires \n        w >= 1,\n        k <= n + 1\n{\n    // impl-start\n    assume(false);\n    0.0\n    // impl-end\n}\n\nfn approx_equal(a: f64, b: f64, epsilon: f64) -> (result: bool)\n{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-code": "", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000396", "vc-description": "Given two words (beginWord and endWord), and a dictionary's word list, find the length of shortest transformation sequence from beginWord to endWord, such that:\n\n       Only one letter can be changed at a time.\n       Each transformed word must exist in the word list. Note that beginWord is not a transformed word.\n\nNote:\n\n       Return 0 if there is no such transformation sequence.\n       All words have the same length.\n       All words contain only lowercase alphabetic characters.\n       You may assume no duplicates in the word list.\n       You may assume beginWord and endWord are non-empty and are not the same.\n\nExample 1:\n\nInput:\nbeginWord = \"hit\",\nendWord = \"cog\",\nwordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n\nOutput: 5\n\nExplanation: As one shortest transformation is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\",\nreturn its length 5.\n\nExample 2:\n\nInput:\nbeginWord = \"hit\"\nendWord = \"cog\"\nwordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n\nOutput: 0\n\nExplanation: The endWord \"cog\" is not in wordList, therefore no possible transformation.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn chars_differ_by_one(s1: Seq<char>, s2: Seq<char>) -> bool {\n    s1.len() == s2.len() && \n    (exists|i: int| 0 <= i < s1.len() && \n     s1[i] != s2[i] && \n     (forall|j: int| 0 <= j < s1.len() && j != i ==> s1[j] == s2[j]))\n}\n\nspec fn word_list_contains(word_list: Seq<Seq<char>>, word: Seq<char>) -> bool {\n    exists|i: int| 0 <= i < word_list.len() && word_list[i] == word\n}\n\nfn ladder_length(begin_word: &str, end_word: &str, word_list: &Vec<String>) -> (result: usize)\n    ensures\n        result >= 0,\n        (!word_list_contains(word_list@.map(|i: int, s: String| s@), end_word@)) ==> result == 0,\n        (begin_word@.len() != end_word@.len()) ==> result == 0,\n        (word_list_contains(word_list@.map(|i: int, s: String| s@), end_word@) && \n         begin_word@.len() == end_word@.len() && \n         chars_differ_by_one(begin_word@, end_word@)) ==> result == 2", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = ladder_length(\"hit\", \"cog\", &vec![\"hot\".to_string(), \"dot\".to_string(), \"dog\".to_string(), \"lot\".to_string(), \"log\".to_string(), \"cog\".to_string()]);\n    // println!(\"{}\", result1); // Should print 5\n    \n    // let result2 = ladder_length(\"hit\", \"cog\", &vec![\"hot\".to_string(), \"dot\".to_string(), \"dog\".to_string(), \"lot\".to_string(), \"log\".to_string()]);\n    // println!(\"{}\", result2); // Should print 0\n    \n    // let result3 = ladder_length(\"dog\", \"cog\", &vec![\"cog\".to_string()]);\n    // println!(\"{}\", result3); // Should print 2\n}"}
{"id": "fvapps_000399", "vc-description": "Given an integer array arr and an integer k, modify the array by repeating it k times.\nFor example, if arr = [1, 2] and k = 3 then the modified array will be [1, 2, 1, 2, 1, 2].\nReturn the maximum sub-array sum in the modified array. Note that the length of the sub-array can be 0 and its sum in that case is 0.\nAs the answer can be very large, return the answer modulo 10^9 + 7.\n\nExample 1:\nInput: arr = [1,2], k = 3\nOutput: 9\n\nExample 2:\nInput: arr = [1,-2,1], k = 5\nOutput: 2\n\nExample 3:\nInput: arr = [-1,-2], k = 7\nOutput: 0\n\nConstraints:\n\n1 <= arr.length <= 10^5\n1 <= k <= 10^5\n-10^4 <= arr[i] <= 10^4", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn MOD() -> int { 1000000007 }\n\nspec fn list_sum(arr: Seq<i32>) -> int\n    decreases arr.len()\n{\n    if arr.len() == 0 {\n        0\n    } else {\n        arr[0] as int + list_sum(arr.skip(1))\n    }\n}\n\nfn k_concatenation_max_sum(arr: Vec<i32>, k: usize) -> (result: i32)\n    requires \n        k > 0,\n        arr.len() >= 1,\n    ensures \n        result >= 0,\n        result < MOD(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "}\n\nfn main() {\n    // println!(\"{}\", k_concatenation_max_sum(vec![1, 2], 3));\n    // println!(\"{}\", k_concatenation_max_sum(vec![1, -2, 1], 5));\n    // println!(\"{}\", k_concatenation_max_sum(vec![-1, -2], 7));\n}"}
{"id": "fvapps_000401", "vc-description": "Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.\n\nNote:\n\n       The same word in the dictionary may be reused multiple times in the segmentation.\n       You may assume the dictionary does not contain duplicate words.\n\nExample 1:\n\nInput: s = \"leetcode\", wordDict = [\"leet\", \"code\"]\nOutput: true\nExplanation: Return true because \"leetcode\" can be segmented as \"leet code\".\n\nExample 2:\n\nInput: s = \"applepenapple\", wordDict = [\"apple\", \"pen\"]\nOutput: true\nExplanation: Return true because \"applepenapple\" can be segmented as \"apple pen apple\".\n             Note that you are allowed to reuse a dictionary word.\n\nExample 3:\n\nInput: s = \"catsandog\", wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]\nOutput: false", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn join_words_spec(words: Seq<Seq<char>>) -> Seq<char>\n    decreases words.len()\n{\n    if words.len() == 0 {\n        seq![]\n    } else {\n        words[0] + join_words_spec(words.skip(1))\n    }\n}\n\nspec fn join_words(words: Seq<Seq<char>>) -> Seq<char> {\n    join_words_spec(words)\n}", "vc-spec": "fn word_break(s: String, dict: Vec<String>) -> (result: bool)\n    ensures \n        (dict.len() == 0 && s@.len() > 0) ==> result == false,\n        s@.len() == 0 ==> result == true", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "/* Apps difficulty: interview */\n/* Assurance level: unguarded */\n\nfn main() {\n    // let result1 = word_break(\"leetcode\".to_string(), vec![\"leet\".to_string(), \"code\".to_string()]);\n    // println!(\"Result 1: {}\", result1); // Should be true\n    \n    // let result2 = word_break(\"applepenapple\".to_string(), vec![\"apple\".to_string(), \"pen\".to_string()]);\n    // println!(\"Result 2: {}\", result2); // Should be true\n    \n    // let result3 = word_break(\"catsandog\".to_string(), vec![\"cats\".to_string(), \"dog\".to_string(), \"sand\".to_string(), \"and\".to_string(), \"cat\".to_string()]);\n    // println!(\"Result 3: {}\", result3); // Should be false\n}\n\n}"}
{"id": "fvapps_000408", "vc-description": "Given a positive integer n and you can do operations as follow:\n\nIf n is even, replace n with n/2.\nIf n is odd, you can replace n with either n + 1 or n - 1.\n\nWhat is the minimum number of replacements needed for n to become 1?\n\nExample 1:\n\nInput:\n8\n\nOutput:\n3\n\nExplanation:\n8 -> 4 -> 2 -> 1\n\nExample 2:\n\nInput:\n7\n\nOutput:\n4\n\nExplanation:\n7 -> 8 -> 4 -> 2 -> 1\nor\n7 -> 6 -> 3 -> 2 -> 1", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn integer_replacement(n: u32) -> (result: u32)\n    requires n > 0\n    ensures \n        result >= 0,\n        n == 1 ==> result == 0,\n        n == 2 ==> result == 1", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded_and_plausible\n\n    // println!(\"{}\", integer_replacement(8)); // Should output 3\n    // println!(\"{}\", integer_replacement(7)); // Should output 4\n    // println!(\"{}\", integer_replacement(3)); // Should output 2\n}"}
{"id": "fvapps_000409", "vc-description": "There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the i-th round, you toggle every i bulb. For the n-th round, you only toggle the last bulb. Find how many bulbs are on after n rounds.\n\nExample:\n\nInput: 3\nOutput: 1 \nExplanation: \nAt first, the three bulbs are [off, off, off].\nAfter first round, the three bulbs are [on, on, on].\nAfter second round, the three bulbs are [on, off, on].\nAfter third round, the three bulbs are [on, off, off]. \n\nSo you should return 1, because there is only one bulb is on.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn bulb_switch(n: i32) -> (result: i32)\n    ensures \n        n >= 0 ==> (result >= 0 && result <= n),\n        n < 0 ==> result == -1,\n        n == 0 ==> result == 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: unguarded\n\n    // #eval bulb_switch 3 should return 1\n    // #eval bulb_switch 0 should return 0  \n    // #eval bulb_switch 4 should return 2\n}"}
{"id": "fvapps_000415", "vc-description": "Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.\n\nReturn the quotient after dividing dividend by divisor.\n\nThe integer division should truncate toward zero.\n\nExample 1:\n\nInput: dividend = 10, divisor = 3\nOutput: 3\n\nExample 2:\n\nInput: dividend = 7, divisor = -3\nOutput: -2\n\nNote:\n\n       Both dividend and divisor will be 32-bit signed integers.\n       The divisor will never be 0.\n       Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 231 − 1 when the division result overflows.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "const MAX_INT: i32 = 2147483647;\nconst MIN_INT: i32 = -2147483648;\n\nspec fn int_abs(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}", "vc-spec": "fn divide(dividend: i32, divisor: i32) -> (result: i32)\n    ensures\n        MIN_INT <= result && result <= MAX_INT,\n        divisor != 0 ==> (\n            result != MAX_INT ==> int_abs((result as int) * (divisor as int) - (dividend as int)) < int_abs(divisor as int)\n        ),\n        divisor == 0 ==> result == MAX_INT,\n        dividend == MIN_INT && divisor == -1 ==> result == MAX_INT,\n        (dividend as int) * (divisor as int) > 0 ==> result >= 0,\n        (dividend as int) * (divisor as int) < 0 && result != MAX_INT ==> result <= 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: unguarded\n\n    // #eval divide 10 3\n    // Expected: 3\n\n    // #eval divide 7 -3  \n    // Expected: -2\n\n    // #eval divide -2147483648 -1\n    // Expected: 2147483647\n}"}
{"id": "fvapps_000417", "vc-description": "Given n orders, each order consist in pickup and delivery services. \nCount all valid pickup/delivery possible sequences such that delivery(i) is always after of pickup(i). \nSince the answer may be too large, return it modulo 10^9 + 7.\n\nExample 1:\nInput: n = 1\nOutput: 1\nExplanation: Unique order (P1, D1), Delivery 1 always is after of Pickup 1.\n\nExample 2:\nInput: n = 2\nOutput: 6\nExplanation: All possible orders: \n(P1,P2,D1,D2), (P1,P2,D2,D1), (P1,D1,P2,D2), (P2,P1,D1,D2), (P2,P1,D2,D1) and (P2,D2,P1,D1).\nThis is an invalid order (P1,D2,P2,D1) because Pickup 2 is after of Delivery 2.\n\nExample 3:\nInput: n = 3\nOutput: 90\n\nConstraints:\n\n1 <= n <= 500", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "const M: u64 = 1000000007;", "vc-spec": "spec fn count_valid_delivery_orders_spec(n: nat) -> nat\n    decreases n\n{\n    if n == 0 {\n        0\n    } else if n == 1 {\n        1\n    } else {\n        // This is a placeholder specification - actual combinatorial formula would go here\n        n * count_valid_delivery_orders_spec((n - 1) as nat)\n    }\n}\n\nfn count_valid_delivery_orders(n: usize) -> (result: usize)\n    requires n > 0,\n    ensures \n        result > 0,\n        result == count_valid_delivery_orders_spec(n as nat)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n\nproof fn count_valid_delivery_orders_positive(n: usize)\n    requires n > 0,\n    ensures count_valid_delivery_orders_spec(n as nat) > 0\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn count_valid_delivery_orders_base_case()\n    ensures count_valid_delivery_orders_spec(1) == 1\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}", "vc-postamble": "}\n\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded_and_plausible\n\n    // assert(count_valid_delivery_orders(1) == 1);\n    // assert(count_valid_delivery_orders(2) == 6);\n    // assert(count_valid_delivery_orders(3) == 90);\n}"}
{"id": "fvapps_000420", "vc-description": "Given a string S, count the number of distinct, non-empty subsequences of S .\nSince the result may be large, return the answer modulo 10^9 + 7.\n\nExample 1:\nInput: \"abc\"\nOutput: 7\nExplanation: The 7 distinct subsequences are \"a\", \"b\", \"c\", \"ab\", \"ac\", \"bc\", and \"abc\".\n\nExample 2:\nInput: \"aba\"\nOutput: 6\nExplanation: The 6 distinct subsequences are \"a\", \"b\", \"ab\", \"ba\", \"aa\" and \"aba\".\n\nExample 3:\nInput: \"aaa\"\nOutput: 3\nExplanation: The 3 distinct subsequences are \"a\", \"aa\" and \"aaa\".\n\nNote:\n\nS contains only lowercase letters.\n1 <= S.length <= 2000", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn distinct_subseq_count(s: Vec<u8>) -> (result: u32)\n    requires \n        s.len() > 0,\n        s.len() <= 2000,\n        forall|i: int| 0 <= i < s.len() ==> s[i] >= 97 && s[i] <= 122,\n    ensures \n        result < 1000000007,\n        result >= s.len() as u32,\n        (forall|i: int| 0 <= i < s.len() ==> s[i] == 97) ==> result == s.len() as u32,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let s1 = vec![97, 98, 99]; // \"abc\"\n    // let result1 = distinct_subseq_count(s1);\n    // assert(result1 == 7);\n    \n    // let s2 = vec![97, 98, 97]; // \"aba\"\n    // let result2 = distinct_subseq_count(s2);\n    // assert(result2 == 6);\n    \n    // let s3 = vec![97, 97, 97]; // \"aaa\"\n    // let result3 = distinct_subseq_count(s3);\n    // assert(result3 == 3);\n}"}
{"id": "fvapps_000422", "vc-description": "Given an array of integers nums and a positive integer k, find whether it's possible to divide this array into sets of k consecutive numbers\nReturn True if its possible otherwise return False.\n\nExample 1:\nInput: nums = [1,2,3,3,4,4,5,6], k = 4\nOutput: true\nExplanation: Array can be divided into [1,2,3,4] and [3,4,5,6].\n\nExample 2:\nInput: nums = [3,2,1,2,3,4,3,4,5,9,10,11], k = 3\nOutput: true\nExplanation: Array can be divided into [1,2,3] , [2,3,4] , [3,4,5] and [9,10,11].\n\nExample 3:\nInput: nums = [3,3,2,2,1,1], k = 3\nOutput: true\n\nExample 4:\nInput: nums = [1,2,3,4], k = 3\nOutput: false\nExplanation: Each array should be divided in subarrays of size 3.\n\nConstraints:\n\n1 <= nums.length <= 10^5\n1 <= nums[i] <= 10^9\n1 <= k <= nums.length", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn is_possible_divide(nums: Vec<u32>, k: u32) -> (result: bool)\n    requires \n        k > 0,\n        k as usize <= nums.len(),\n    ensures \n        k == 1 ==> result == true,\n        nums.len() % k as usize != 0 ==> result == false,", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = is_possible_divide(vec![1, 2, 3, 3, 4, 4, 5, 6], 4);\n    // assert(result1 == true);\n    \n    // let result2 = is_possible_divide(vec![3, 2, 1, 2, 3, 4, 3, 4, 5, 9, 10, 11], 3);\n    // assert(result2 == true);\n    \n    // let result3 = is_possible_divide(vec![1, 2, 3, 4], 3);\n    // assert(result3 == false);\n}"}
{"id": "fvapps_000423", "vc-description": "Given an array of integers arr and two integers k and threshold.\nReturn the number of sub-arrays of size k and average greater than or equal to threshold.\n\nExample 1:\nInput: arr = [2,2,2,2,5,5,5,8], k = 3, threshold = 4\nOutput: 3\nExplanation: Sub-arrays [2,5,5],[5,5,5] and [5,5,8] have averages 4, 5 and 6 respectively. All other sub-arrays of size 3 have averages less than 4 (the threshold).\n\nExample 2:\nInput: arr = [1,1,1,1,1], k = 1, threshold = 0\nOutput: 5\n\nExample 3:\nInput: arr = [11,13,17,23,29,31,7,5,2,3], k = 3, threshold = 5\nOutput: 6\nExplanation: The first 6 sub-arrays of size 3 have averages greater than 5. Note that averages are not integers.\n\nExample 4:\nInput: arr = [7,7,7,7,7,7,7], k = 7, threshold = 7\nOutput: 1\n\nExample 5:\nInput: arr = [4,4,4,4], k = 4, threshold = 1\nOutput: 1\n\nConstraints:\n\n1 <= arr.length <= 10^5\n1 <= arr[i] <= 10^4\n1 <= k <= arr.length\n0 <= threshold <= 10^4", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn subarray_sum(arr: Seq<i32>, start: nat, len: nat) -> int\n    decreases len\n{\n    if len == 0 || start >= arr.len() {\n        0\n    } else {\n        arr[start as int] + subarray_sum(arr, start + 1, (len - 1) as nat)\n    }\n}\n\nfn num_of_subarrays(arr: Vec<i32>, k: usize, threshold: i32) -> (result: usize)\n    requires k > 0 && k <= arr.len(),\n    ensures \n        result >= 0 &&\n        (arr.len() < k ==> result == 0) &&\n        (arr.len() >= k ==> result <= arr.len() - k + 1)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = num_of_subarrays(vec![2, 2, 2, 2, 5, 5, 5, 8], 3, 4);\n    // println!(\"Result 1: {}\", result1); // Expected: 3\n    \n    // let result2 = num_of_subarrays(vec![1, 1, 1, 1, 1], 1, 0);\n    // println!(\"Result 2: {}\", result2); // Expected: 5\n    \n    // let result3 = num_of_subarrays(vec![11, 13, 17, 23, 29, 31, 7, 5, 2, 3], 3, 5);\n    // println!(\"Result 3: {}\", result3); // Expected: 6\n}"}
{"id": "fvapps_000424", "vc-description": "Given a binary array nums, you should delete one element from it.\nReturn the size of the longest non-empty subarray containing only 1's in the resulting array.\nReturn 0 if there is no such subarray.\n\nExample 1:\nInput: nums = [1,1,0,1]\nOutput: 3\nExplanation: After deleting the number in position 2, [1,1,1] contains 3 numbers with value of 1's.\nExample 2:\nInput: nums = [0,1,1,1,0,1,1,0,1]\nOutput: 5\nExplanation: After deleting the number in position 4, [0,1,1,1,1,1,0,1] longest subarray with value of 1's is [1,1,1,1,1].\nExample 3:\nInput: nums = [1,1,1]\nOutput: 2\nExplanation: You must delete one element.\nExample 4:\nInput: nums = [1,1,0,0,1,1,1,0,1]\nOutput: 4\n\nExample 5:\nInput: nums = [0,0,0]\nOutput: 0\n\nConstraints:\n\n1 <= nums.length <= 10^5\nnums[i] is either 0 or 1.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn longest_subarray_ones_after_delete(nums: Vec<u32>) -> (result: u32)\n    requires \n        nums.len() > 0,\n        forall|i: int| 0 <= i < nums.len() ==> nums[i] <= 1,\n    ensures \n        result >= 0,\n        result <= nums.len()", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "}\n\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded\n\n    // let test1 = vec![1, 1, 0, 1];\n    // assert_eq!(longest_subarray_ones_after_delete(test1), 3);\n\n    // let test2 = vec![0, 1, 1, 1, 0, 1, 1, 0, 1];\n    // assert_eq!(longest_subarray_ones_after_delete(test2), 5);\n\n    // let test3 = vec![1, 1, 1];\n    // assert_eq!(longest_subarray_ones_after_delete(test3), 2);\n}"}
{"id": "fvapps_000425", "vc-description": "Given an array A of integers, return the number of (contiguous, non-empty) subarrays that have a sum divisible by K.\n\nExample 1:\nInput: A = [4,5,0,-2,-3,1], K = 5\nOutput: 7\nExplanation: There are 7 subarrays with a sum divisible by K = 5:\n[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]\n\nNote:\n\n1 <= A.length <= 30000\n-10000 <= A[i] <= 10000\n2 <= K <= 10000", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn subarrays_div_by_k(nums: Vec<i32>, k: i32) -> (result: i32)\n    requires \n        nums.len() >= 1,\n        nums.len() <= 30000,\n        k >= 2,\n        k <= 10000,\n        forall|i: int| 0 <= i < nums.len() ==> #[trigger] nums[i] >= -10000 && #[trigger] nums[i] <= 10000,\n    ensures\n        result >= 0,\n        k == 5 && nums@ == seq![4i32, 5i32, 0i32, -2i32, -3i32, 1i32] ==> result == 7,\n        k == 5 && nums@ == seq![5i32] ==> result == 1,\n        k == 5 && nums@ == seq![4i32, 5i32, 0i32, -2i32, -3i32, 1i32, 5i32] ==> result == 9", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "/* Apps difficulty: interview\n   Assurance level: guarded_and_plausible */\n\n}\n\nfn main() {\n    // #eval subarraysDivByK [4, 5, 0, -2, -3, 1] 5\n    // Expected: 7\n    \n    // #eval subarraysDivByK [5] 5\n    // Expected: 1\n    \n    // #eval subarraysDivByK [4, 5, 0, -2, -3, 1, 5] 5\n    // Expected: 9\n}"}
{"id": "fvapps_000426", "vc-description": "There are n oranges in the kitchen and you decided to eat some of these oranges every day as follows:\n\nEat one orange.\nIf the number of remaining oranges (n) is divisible by 2 then you can eat  n/2 oranges.\nIf the number of remaining oranges (n) is divisible by 3 then you can eat  2*(n/3) oranges.\n\nYou can only choose one of the actions per day.\nReturn the minimum number of days to eat n oranges.\n\nExample 1:\nInput: n = 10\nOutput: 4\nExplanation: You have 10 oranges.\nDay 1: Eat 1 orange,  10 - 1 = 9.  \nDay 2: Eat 6 oranges, 9 - 2*(9/3) = 9 - 6 = 3. (Since 9 is divisible by 3)\nDay 3: Eat 2 oranges, 3 - 2*(3/3) = 3 - 2 = 1. \nDay 4: Eat the last orange  1 - 1  = 0.\nYou need at least 4 days to eat the 10 oranges.\n\nExample 2:\nInput: n = 6\nOutput: 3\nExplanation: You have 6 oranges.\nDay 1: Eat 3 oranges, 6 - 6/2 = 6 - 3 = 3. (Since 6 is divisible by 2).\nDay 2: Eat 2 oranges, 3 - 2*(3/3) = 3 - 2 = 1. (Since 3 is divisible by 3)\nDay 3: Eat the last orange  1 - 1  = 0.\nYou need at least 3 days to eat the 6 oranges.\n\nExample 3:\nInput: n = 1\nOutput: 1\n\nExample 4:\nInput: n = 56\nOutput: 6\n\nConstraints:\n\n1 <= n <= 2*10^9", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn min_days_to_eat_oranges(n: nat) -> (result: nat)\n    requires n > 0,\n    ensures result >= 0 && result <= n", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "/* Apps difficulty: interview */\n/* Assurance level: guarded_and_plausible */\n\n}\nfn main() {\n    // println!(\"{}\", min_days_to_eat_oranges(10)); // Expected: 4\n    // println!(\"{}\", min_days_to_eat_oranges(6));  // Expected: 3\n    // println!(\"{}\", min_days_to_eat_oranges(56)); // Expected: 6\n}"}
{"id": "fvapps_000427", "vc-description": "An encoded string S is given.  To find and write the decoded string to a tape, the encoded string is read one character at a time and the following steps are taken:\n\nIf the character read is a letter, that letter is written onto the tape.\nIf the character read is a digit (say d), the entire current tape is repeatedly written d-1 more times in total.\n\nNow for some encoded string S, and an index K, find and return the K-th letter (1 indexed) in the decoded string.\n\nExample 1:\nInput: S = \"leet2code3\", K = 10\nOutput: \"o\"\nExplanation: \nThe decoded string is \"leetleetcodeleetleetcodeleetleetcode\".\nThe 10th letter in the string is \"o\".\n\nExample 2:\nInput: S = \"ha22\", K = 5\nOutput: \"h\"\nExplanation: \nThe decoded string is \"hahahaha\".  The 5th letter is \"h\".\n\nExample 3:\nInput: S = \"a2345678999999999999999\", K = 1\nOutput: \"a\"\nExplanation: \nThe decoded string is \"a\" repeated 8301530446056247680 times.  The 1st letter is \"a\".\n\nConstraints:\n\n2 <= S.length <= 100\nS will only contain lowercase letters and digits 2 through 9.\nS starts with a letter.\n1 <= K <= 10^9\nIt's guaranteed that K is less than or equal to the length of the decoded string.\nThe decoded string is guaranteed to have less than 2^63 letters.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_letter(c: char) -> bool {\n    'a' <= c && c <= 'z'\n}\n\nspec fn char_to_digit(c: char) -> int {\n    (c as u8 - '0' as u8) as int\n}\n\nspec fn string_contains_letter(s: Seq<char>) -> bool {\n    exists|i: int| 0 <= i < s.len() && is_letter(s[i])\n}\n\nspec fn string_starts_with_letter(s: Seq<char>) -> bool {\n    s.len() > 0 && is_letter(s[0])\n}\n\nfn decode_at_index(s: Vec<char>, k: usize) -> (result: char)\n    requires \n        k > 0,\n        string_contains_letter(s@),\n        string_starts_with_letter(s@),\n    ensures \n        is_letter(result),\n        exists|i: int| 0 <= i < s.len() && is_letter(s[i]) && result == s[i],", "vc-code": "{\n    // impl-start\n    assume(false);\n    'a'\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let s1 = vec!['l', 'e', 'e', 't', '2', 'c', 'o', 'd', 'e', '3'];\n    // println!(\"{}\", decode_at_index(s1, 10));\n    // let s2 = vec!['h', 'a', '2', '2'];\n    // println!(\"{}\", decode_at_index(s2, 5));\n    // let s3 = vec!['a', '2', '3', '4', '5', '6', '7', '8', '9', '9', '9', '9', '9', '9', '9', '9', '9', '9', '9', '9', '9', '9', '9'];\n    // println!(\"{}\", decode_at_index(s3, 1));\n}"}
{"id": "fvapps_000428", "vc-description": "Given an array arr that represents a permutation of numbers from 1 to n. You have a binary string of size n that initially has all its bits set to zero.\nAt each step i (assuming both the binary string and arr are 1-indexed) from 1 to n, the bit at position arr[i] is set to 1. You are given an integer m and you need to find the latest step at which there exists a group of ones of length m. A group of ones is a contiguous substring of 1s such that it cannot be extended in either direction.\nReturn the latest step at which there exists a group of ones of length exactly m. If no such group exists, return -1.\n\nExample 1:\nInput: arr = [3,5,1,2,4], m = 1\nOutput: 4\nExplanation:\nStep 1: \"00100\", groups: [\"1\"]\nStep 2: \"00101\", groups: [\"1\", \"1\"]\nStep 3: \"10101\", groups: [\"1\", \"1\", \"1\"]\nStep 4: \"11101\", groups: [\"111\", \"1\"]\nStep 5: \"11111\", groups: [\"11111\"]\nThe latest step at which there exists a group of size 1 is step 4.\nExample 2:\nInput: arr = [3,1,5,4,2], m = 2\nOutput: -1\nExplanation:\nStep 1: \"00100\", groups: [\"1\"]\nStep 2: \"10100\", groups: [\"1\", \"1\"]\nStep 3: \"10101\", groups: [\"1\", \"1\", \"1\"]\nStep 4: \"10111\", groups: [\"1\", \"111\"]\nStep 5: \"11111\", groups: [\"11111\"]\nNo group of size 2 exists during any step.\n\nExample 3:\nInput: arr = [1], m = 1\nOutput: 1\n\nExample 4:\nInput: arr = [2,1], m = 2\nOutput: 2\n\nConstraints:\n\nn == arr.length\n1 <= n <= 10^5\n1 <= arr[i] <= n\nAll integers in arr are distinct.\n1 <= m <= arr.length", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn find_latest_step(arr: Vec<usize>, target: usize) -> (result: i32)\n    requires \n        arr.len() > 0,\n        target >= 1,\n        target <= arr.len(),\n        forall|i: int| 0 <= i < arr.len() ==> #[trigger] arr[i] >= 1 && #[trigger] arr[i] <= arr.len(),\n        forall|i: int, j: int| 0 <= i < j < arr.len() ==> #[trigger] arr[i] != #[trigger] arr[j],\n    ensures \n        result == -1 || (result >= 1 && result <= arr.len())", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n#[verifier::external_body]\nproof fn find_latest_step_basic_cases() \n{\n}\n\n}\nfn main() {}"}
{"id": "fvapps_000429", "vc-description": "A subarray A[i], A[i+1], ..., A[j] of A is said to be turbulent if and only if:\n\nFor i <= k < j, A[k] > A[k+1] when k is odd, and A[k] < A[k+1] when k is even;\nOR, for i <= k < j, A[k] > A[k+1] when k is even, and A[k] < A[k+1] when k is odd.\n\nThat is, the subarray is turbulent if the comparison sign flips between each adjacent pair of elements in the subarray.\nReturn the length of a maximum size turbulent subarray of A.\n\nExample 1:\nInput: [9,4,2,10,7,8,8,1,9]\nOutput: 5\nExplanation: (A[1] > A[2] < A[3] > A[4] < A[5])\n\nExample 2:\nInput: [4,8,12,16]\nOutput: 2\n\nExample 3:\nInput: [100]\nOutput: 1\n\nNote:\n\n1 <= A.length <= 40000\n0 <= A[i] <= 10^9", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn max_turbulence_size(arr: Vec<i32>) -> (result: nat)\n    requires arr.len() >= 1,\n    ensures \n        1 <= result <= arr.len(),\n        result >= 1,\n        result <= arr.len(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let test1 = vec![9, 4, 2, 10, 7, 8, 8, 1, 9];\n    // assert(max_turbulence_size(test1) == 5);\n    // \n    // let test2 = vec![4, 8, 12, 16];\n    // assert(max_turbulence_size(test2) == 2);\n    // \n    // let test3 = vec![100];\n    // assert(max_turbulence_size(test3) == 1);\n}"}
{"id": "fvapps_000430", "vc-description": "There is a special square room with mirrors on each of the four walls. Except for the southwest corner, there are receptors on each of the remaining corners, numbered 0, 1, and 2.\nThe square room has walls of length p, and a laser ray from the southwest corner first meets the east wall at a distance q from the 0th receptor.\nReturn the number of the receptor that the ray meets first. (It is guaranteed that the ray will meet a receptor eventually.)\n\nExample 1:\nInput: p = 2, q = 1\nOutput: 2\nExplanation: The ray meets receptor 2 the first time it gets reflected back to the left wall.\n\nNote:\n1 <= p <= 1000\n0 <= q <= p", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn mirror_reflection(p: u32, q: u32) -> (result: u32)\n    requires \n        p > 0,\n        q <= p,\n    ensures \n        result == 0 || result == 1 || result == 2,", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "}\n\nfn main() {\n    // assert(mirror_reflection(2, 1) == 2);\n    // assert(mirror_reflection(4, 2) == 2);\n    // assert(mirror_reflection(5, 5) == 1);\n}"}
{"id": "fvapps_000433", "vc-description": "There are n soldiers standing in a line. Each soldier is assigned a unique rating value.\nYou have to form a team of 3 soldiers amongst them under the following rules:\n\nChoose 3 soldiers with index (i, j, k) with rating (rating[i], rating[j], rating[k]).\nA team is valid if:  (rating[i] < rating[j] < rating[k]) or (rating[i] > rating[j] > rating[k]) where (0 <= i < j < k < n).\n\nReturn the number of teams you can form given the conditions. (soldiers can be part of multiple teams).\n\nExample 1:\nInput: rating = [2,5,3,4,1]\nOutput: 3\nExplanation: We can form three teams given the conditions. (2,3,4), (5,4,1), (5,3,1). \n\nExample 2:\nInput: rating = [2,1,3]\nOutput: 0\nExplanation: We can't form any team given the conditions.\n\nExample 3:\nInput: rating = [1,2,3,4]\nOutput: 4\n\nConstraints:\n\nn == rating.length\n1 <= n <= 200\n1 <= rating[i] <= 10^5", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn num_teams(rating: Vec<i32>) -> (result: usize)\n    ensures \n        result >= 0,\n        rating.len() < 3 ==> result == 0,\n        (forall|x: i32, y: i32| #[trigger] rating@.contains(x) && #[trigger] rating@.contains(y) ==> x == y) ==> result == 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: unguarded\n\n    // println!(\"{}\", num_teams(vec![2, 5, 3, 4, 1])); // Expected: 3\n    // println!(\"{}\", num_teams(vec![2, 1, 3])); // Expected: 0  \n    // println!(\"{}\", num_teams(vec![1, 2, 3, 4])); // Expected: 4\n}"}
{"id": "fvapps_000434", "vc-description": "n passengers board an airplane with exactly n seats. The first passenger has lost the ticket and picks a seat randomly. But after that, the rest of passengers will:\n\nTake their own seat if it is still available, \nPick other seats randomly when they find their seat occupied \n\nWhat is the probability that the n-th person can get his own seat?\n\nExample 1:\nInput: n = 1\nOutput: 1.00000\nExplanation: The first person can only get the first seat.\nExample 2:\nInput: n = 2\nOutput: 0.50000\nExplanation: The second person has a probability of 0.5 to get the second seat (when first person gets the first seat).\n\nConstraints:\n\n1 <= n <= 10^5", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn nth_person_gets_nth_seat(n: nat) -> int {\n    if n == 1 {\n        1\n    } else if n > 1 {\n        0\n    } else {\n        0\n    }\n}\n\nproof fn prob_bounds(n: nat)\n    requires n > 0,\n    ensures \n        0 <= nth_person_gets_nth_seat(n) && nth_person_gets_nth_seat(n) <= 1,\n{\n    assume(false);\n}\n\nproof fn non_first_person_prob(n: nat)\n    requires n > 1,\n    ensures nth_person_gets_nth_seat(n) == 0,\n{\n    assume(false);\n}\n\nproof fn first_person_prob()\n    ensures nth_person_gets_nth_seat(1) == 1,\n{\n    assume(false);\n}", "vc-code": "", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: unguarded\n\n    // #guard_msgs in\n    // #eval nth_person_gets_nth_seat 1\n\n    // #guard_msgs in\n    // #eval nth_person_gets_nth_seat 2\n\n    // #guard_msgs in\n    // #eval nth_person_gets_nth_seat 100\n}"}
{"id": "fvapps_000436", "vc-description": "Given an array of integers arr and an integer k. Find the least number of unique integers after removing exactly k elements.\n\nExample 1:\nInput: arr = [5,5,4], k = 1\nOutput: 1\nExplanation: Remove the single 4, only 5 is left.\n\nExample 2:\nInput: arr = [4,3,1,1,3,3,2], k = 3\nOutput: 2\nExplanation: Remove 4, 2 and either one of the two 1s or three 3s. 1 and 3 will be left.\n\nConstraints:\n\n1 <= arr.length <= 10^5\n1 <= arr[i] <= 10^9\n0 <= k <= arr.length", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn find_least_num_unique_ints(arr: Vec<i32>, k: usize) -> (result: usize)\n    requires \n        arr.len() > 0,\n        k <= arr.len(),\n    ensures \n        result <= arr.len(),\n        k == arr.len() ==> result == 0,\n        k == 0 ==> result == arr.len(),\n        k > arr.len() ==> result == 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "}\n\nfn main() {\n    // let result1 = find_least_num_unique_ints(vec![5, 5, 4], 1);\n    // println!(\"Result 1: {}\", result1); // Expected: 1\n    \n    // let result2 = find_least_num_unique_ints(vec![4, 3, 1, 1, 3, 3, 2], 3);\n    // println!(\"Result 2: {}\", result2); // Expected: 2\n    \n    // let result3 = find_least_num_unique_ints(vec![2, 4, 1, 8, 3, 5, 1, 3], 3);\n    // println!(\"Result 3: {}\", result3); // Expected: 3\n}"}
{"id": "fvapps_000437", "vc-description": "Given a string which contains only lowercase letters, remove duplicate letters so that every letter appear once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.\n\nExample 1:\n\nInput: \"bcabc\"\nOutput: \"abc\"\n\nExample 2:\n\nInput: \"cbacdcbc\"\nOutput: \"acdb\"", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn char_count(s: Seq<char>, c: char) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s[0] == c {\n        1 + char_count(s.skip(1), c)\n    } else {\n        char_count(s.skip(1), c)\n    }\n}\n\nfn remove_duplicate_letters(s: Vec<char>) -> (result: Vec<char>)\n    requires s.len() > 0,\n    ensures\n        forall|c: char| result@.contains(c) ==> s@.contains(c),\n        forall|c: char| char_count(result@, c) <= 1,", "vc-code": "{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "fvapps_000438", "vc-description": "Given a list of non-negative numbers and a target integer k, write a function to check if the array has a continuous subarray of size at least 2 that sums up to the multiple of k, that is, sums up to n*k where n is also an integer.\n\nExample 1:\n\nInput: [23, 2, 4, 6, 7],  k=6\nOutput: True\nExplanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6.\n\nExample 2:\n\nInput: [23, 2, 6, 4, 7],  k=6\nOutput: True\nExplanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42.\n\nNote:\n\nThe length of the array won't exceed 10,000.\nYou may assume the sum of all the numbers is in the range of a signed 32-bit integer.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn subarray_sum(nums: Seq<i32>, start: int, end: int) -> int\n    decreases end - start\n{\n    if start >= end {\n        0\n    } else {\n        nums[start] + subarray_sum(nums, start + 1, end)\n    }\n}\n\nfn check_subarray_sum(nums: Vec<i32>, k: i32) -> (result: bool)\n    ensures\n        result == true <==> (\n            exists|i: int, j: int| \n                0 <= i < j < nums.len() &&\n                j - i >= 2 &&\n                (k == 0 ==> subarray_sum(nums@, i, j) == 0) &&\n                (k != 0 ==> subarray_sum(nums@, i, j) % (k as int) == 0)\n        ),\n        (nums.len() <= 1) ==> (result == false),\n        (nums.len() < 2) ==> (result == false),\n        (k == 1 && nums.len() >= 2) ==> (result == true),", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = check_subarray_sum(vec![23, 2, 4, 6, 7], 6);\n    // println!(\"Result 1: {}\", result1);\n    \n    // let result2 = check_subarray_sum(vec![23, 2, 6, 4, 7], 6);\n    // println!(\"Result 2: {}\", result2);\n    \n    // let result3 = check_subarray_sum(vec![1, 2], 2);\n    // println!(\"Result 3: {}\", result3);\n}"}
{"id": "fvapps_000443", "vc-description": "There is a row of m houses in a small city, each house must be painted with one of the n colors (labeled from 1 to n), some houses that has been painted last summer should not be painted again.\nA neighborhood is a maximal group of continuous houses that are painted with the same color. (For example: houses = [1,2,2,3,3,2,1,1] contains 5 neighborhoods  [{1}, {2,2}, {3,3}, {2}, {1,1}]).\nGiven an array houses, an m * n matrix cost and an integer target where:\n\nhouses[i]: is the color of the house i, 0 if the house is not painted yet.\ncost[i][j]: is the cost of paint the house i with the color j+1.\n\nReturn the minimum cost of painting all the remaining houses in such a way that there are exactly target neighborhoods, if not possible return -1.\n\nExample 1:\nInput: houses = [0,0,0,0,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3\nOutput: 9\nExplanation: Paint houses of this way [1,2,2,1,1]\nThis array contains target = 3 neighborhoods, [{1}, {2,2}, {1,1}].\nCost of paint all houses (1 + 1 + 1 + 1 + 5) = 9.\n\nExample 2:\nInput: houses = [0,2,1,2,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3\nOutput: 11\nExplanation: Some houses are already painted, Paint the houses of this way [2,2,1,2,2]\nThis array contains target = 3 neighborhoods, [{2,2}, {1}, {2,2}}. \nCost of paint the first and last house (10 + 1) = 11.\n\nExample 3:\nInput: houses = [0,0,0,0,0], cost = [[1,10],[10,1],[1,10],[10,1],[1,10]], m = 5, n = 2, target = 5\nOutput: 5\n\nExample 4:\nInput: houses = [3,1,2,3], cost = [[1,1,1],[1,1,1],[1,1,1],[1,1,1]], m = 4, n = 3, target = 3\nOutput: -1\nExplanation: Houses are already painted with a total of 4 neighborhoods [{3},{1},{2},{3}] different of target = 3.\n\nConstraints:\n\nm == houses.length == cost.length\nn == cost[i].length\n1 <= m <= 100\n1 <= n <= 20\n1 <= target <= m\n0 <= houses[i] <= n\n1 <= cost[i][j] <= 10^4", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn count_neighborhoods(houses: Seq<nat>) -> nat \n    decreases houses.len()\n{\n    if houses.len() <= 1 {\n        if houses.len() == 0 { 0 } else { 1 }\n    } else {\n        let rest_count = count_neighborhoods(houses.skip(1));\n        if houses[0] != houses[1] {\n            1 + rest_count\n        } else {\n            rest_count\n        }\n    }\n}\n\nfn min_cost(houses: Vec<nat>, cost: Vec<Vec<nat>>, m: nat, n: nat, target: nat) -> (result: i32)\n    requires \n        houses.len() == m,\n        cost.len() == m,\n        forall|i: int| 0 <= i < cost.len() ==> cost[i].len() == n,\n        m >= 1,\n        n >= 1,\n        target >= 1,\n        target <= m,\n        forall|i: int| 0 <= i < houses.len() ==> houses[i] <= n,\n        forall|i: int, j: int| 0 <= i < cost.len() && 0 <= j < cost[i].len() ==> cost[i][j] <= 10000,\n    ensures \n        result == -1 || result >= 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "}\n\nfn main() {\n    // // Example 1: Expected output 9\n    // let houses1 = vec![0, 0, 0, 0, 0];\n    // let cost1 = vec![vec![1, 10], vec![10, 1], vec![10, 1], vec![1, 10], vec![5, 1]];\n    // println!(\"{}\", min_cost(houses1, cost1, 5, 2, 3));\n    \n    // // Example 2: Expected output 11  \n    // let houses2 = vec![0, 2, 1, 2, 0];\n    // let cost2 = vec![vec![1, 10], vec![10, 1], vec![10, 1], vec![1, 10], vec![5, 1]];\n    // println!(\"{}\", min_cost(houses2, cost2, 5, 2, 3));\n    \n    // // Example 3: Expected output -1\n    // let houses3 = vec![3, 1, 2, 3];\n    // let cost3 = vec![vec![1, 1, 1], vec![1, 1, 1], vec![1, 1, 1], vec![1, 1, 1]];\n    // println!(\"{}\", min_cost(houses3, cost3, 4, 3, 3));\n}"}
{"id": "fvapps_000446", "vc-description": "A frog is crossing a river. The river is divided into x units and at each unit there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.\n\nGiven a list of stones' positions (in units) in sorted ascending order, determine if the frog is able to cross the river by landing on the last stone. Initially, the frog is on the first stone and assume the first jump must be 1 unit.\n\nIf the frog's last jump was k units, then its next jump must be either k - 1, k, or k + 1 units. Note that the frog can only jump in the forward direction.\n\nNote:\n\nThe number of stones is ≥ 2 and is < 1,100.\nEach stone's position will be a non-negative integer < 231.\nThe first stone's position is always 0.\n\nExample 1:\n\n[0,1,3,5,6,8,12,17]\n\nThere are a total of 8 stones.\nThe first stone at the 0th unit, second stone at the 1st unit,\nthird stone at the 3rd unit, and so on...\nThe last stone at the 17th unit.\n\nReturn true. The frog can jump to the last stone by jumping \n1 unit to the 2nd stone, then 2 units to the 3rd stone, then \n2 units to the 4th stone, then 3 units to the 6th stone, \n4 units to the 7th stone, and 5 units to the 8th stone.\n\nExample 2:\n\n[0,1,2,3,4,8,9,11]\n\nReturn false. There is no way to jump to the last stone as \nthe gap between the 5th and 6th stone is too large.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn can_cross(stones: Vec<nat>) -> (result: bool)\n    ensures\n        stones.len() == 0 ==> result == false,\n        stones.len() == 1 ==> result == true,\n        stones.len() >= 2 && stones[0] != 0 ==> result == false,\n        result == true || result == false", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // // Apps difficulty: interview\n    // // Assurance level: unguarded\n\n    // assert(can_cross(vec![0, 1, 3, 5, 6, 8, 12, 17]) == true);\n    // assert(can_cross(vec![0, 1, 2, 3, 4, 8, 9, 11]) == false);\n    // assert(can_cross(vec![0, 1, 3, 4, 5, 7, 9, 10, 12]) == true);\n}"}
{"id": "fvapps_000447", "vc-description": "You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\nYou may assume that you have an infinite number of each kind of coin.\n\nExample 1:\nInput: coins = [1,2,5], amount = 11\nOutput: 3\nExplanation: 11 = 5 + 5 + 1\n\nExample 2:\nInput: coins = [2], amount = 3\nOutput: -1\n\nExample 3:\nInput: coins = [1], amount = 0\nOutput: 0\n\nExample 4:\nInput: coins = [1], amount = 1\nOutput: 1\n\nExample 5:\nInput: coins = [1], amount = 2\nOutput: 2\n\nConstraints:\n\n1 <= coins.length <= 12\n1 <= coins[i] <= 231 - 1\n0 <= amount <= 104", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn list_min(coins: Seq<u32>) -> u32\n    decreases coins.len()\n{\n    if coins.len() == 0 {\n        0\n    } else if coins.len() == 1 {\n        coins[0]\n    } else {\n        let x = coins[0];\n        let min_rest = list_min(coins.skip(1));\n        if x < min_rest { x } else { min_rest }\n    }\n}", "vc-spec": "fn coin_change(coins: Vec<u32>, amount: u32) -> (result: i32)\n    requires \n        coins.len() > 0,\n        forall|i: int| 0 <= i < coins.len() ==> coins[i] > 0 && coins[i] <= 20,\n    ensures \n        result >= -1,\n        result != -1 ==> result <= amount,\n        amount == 0 ==> result == 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = coin_change(vec![1, 2, 5], 11);\n    // println!(\"{}\", result1); // Should print 3\n\n    // let result2 = coin_change(vec![2], 3);\n    // println!(\"{}\", result2); // Should print -1\n\n    // let result3 = coin_change(vec![1], 0);\n    // println!(\"{}\", result3); // Should print 0\n}"}
{"id": "fvapps_000450", "vc-description": "A zero-indexed array A of length N contains all integers from 0 to N-1. Find and return the longest length of set S, where S[i] = {A[i], A[A[i]], A[A[A[i]]], ... } subjected to the rule below.\n\nSuppose the first element in S starts with the selection of element A[i] of index = i, the next element in S should be A[A[i]], and then A[A[A[i]]]… By that analogy, we stop adding right before a duplicate element occurs in S.\n\nExample 1:\n\nInput: A = [5,4,0,3,1,6,2]\nOutput: 4\nExplanation: \nA[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.\n\nOne of the longest S[K]:\nS[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}\n\nNote:\n\nN is an integer within the range [1, 20,000].\nThe elements of A are all distinct.\nEach element of A is an integer within the range [0, N-1].", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn array_nesting(nums: Vec<usize>) -> (result: usize)", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let test1 = vec![5, 4, 0, 3, 1, 6, 2];\n    // assert(array_nesting(test1) == 4);\n    \n    // let test2 = vec![0, 1, 2];\n    // assert(array_nesting(test2) == 1);\n    \n    // let test3 = vec![1, 2, 0];\n    // assert(array_nesting(test3) == 3);\n}"}
{"id": "fvapps_000451", "vc-description": "A company has n employees with a unique ID for each employee from 0 to n - 1. The head of the company has is the one with headID.\nEach employee has one direct manager given in the manager array where manager[i] is the direct manager of the i-th employee, manager[headID] = -1. Also it's guaranteed that the subordination relationships have a tree structure.\nThe head of the company wants to inform all the employees of the company of an urgent piece of news. He will inform his direct subordinates and they will inform their subordinates and so on until all employees know about the urgent news.\nThe i-th employee needs informTime[i] minutes to inform all of his direct subordinates (i.e After informTime[i] minutes, all his direct subordinates can start spreading the news).\nReturn the number of minutes needed to inform all the employees about the urgent news.\n\nExample 1:\nInput: n = 1, headID = 0, manager = [-1], informTime = [0]\nOutput: 0\nExplanation: The head of the company is the only employee in the company.\n\nExample 2:\n\nInput: n = 6, headID = 2, manager = [2,2,-1,2,2,2], informTime = [0,0,1,0,0,0]\nOutput: 1\nExplanation: The head of the company with id = 2 is the direct manager of all the employees in the company and needs 1 minute to inform them all.\nThe tree structure of the employees in the company is shown.\n\nExample 3:\n\nInput: n = 7, headID = 6, manager = [1,2,3,4,5,6,-1], informTime = [0,6,5,4,3,2,1]\nOutput: 21\nExplanation: The head has id = 6. He will inform employee with id = 5 in 1 minute.\nThe employee with id = 5 will inform the employee with id = 4 in 2 minutes.\nThe employee with id = 4 will inform the employee with id = 3 in 3 minutes.\nThe employee with id = 3 will inform the employee with id = 2 in 4 minutes.\nThe employee with id = 2 will inform the employee with id = 1 in 5 minutes.\nThe employee with id = 1 will inform the employee with id = 0 in 6 minutes.\nNeeded time = 1 + 2 + 3 + 4 + 5 + 6 = 21.\n\nExample 4:\nInput: n = 15, headID = 0, manager = [-1,0,0,1,1,2,2,3,3,4,4,5,5,6,6], informTime = [1,1,1,1,1,1,1,0,0,0,0,0,0,0,0]\nOutput: 3\nExplanation: The first minute the head will inform employees 1 and 2.\nThe second minute they will inform employees 3, 4, 5 and 6.\nThe third minute they will inform the rest of employees.\n\nExample 5:\nInput: n = 4, headID = 2, manager = [3,3,-1,2], informTime = [0,0,162,914]\nOutput: 1076\n\nConstraints:\n\n1 <= n <= 10^5\n0 <= headID < n\nmanager.length == n\n0 <= manager[i] < n\nmanager[headID] == -1\ninformTime.length == n\n0 <= informTime[i] <= 1000\ninformTime[i] == 0 if employee i has no subordinates.\nIt is guaranteed that all the employees can be informed.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn num_of_minutes(n: usize, head_id: usize, manager: Vec<i32>, inform_time: Vec<usize>) -> (result: usize)\n    requires \n        n >= 1,\n        head_id < n,\n        manager.len() == n,\n        inform_time.len() == n,\n        manager[head_id as int] == -1,\n        forall|i: int| 0 <= i < n ==> \n            (manager[i] == -1 ==> i == head_id) &&\n            (manager[i] != -1 ==> 0 <= manager[i] < n),\n        forall|i: int| 0 <= i < n ==> inform_time[i] <= 1000,", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = num_of_minutes(1, 0, vec![-1], vec![0]);\n    // println!(\"Test 1: {}\", result1); // Expected: 0\n    \n    // let result2 = num_of_minutes(6, 2, vec![2, 2, -1, 2, 2, 2], vec![0, 0, 1, 0, 0, 0]);\n    // println!(\"Test 2: {}\", result2); // Expected: 1\n    \n    // let result3 = num_of_minutes(7, 6, vec![1, 2, 3, 4, 5, 6, -1], vec![0, 6, 5, 4, 3, 2, 1]);\n    // println!(\"Test 3: {}\", result3); // Expected: 21\n}"}
{"id": "fvapps_000454", "vc-description": "You have an array arr of length n where arr[i] = (2 * i) + 1 for all valid values of i (i.e. 0 <= i < n).\nIn one operation, you can select two indices x and y where 0 <= x, y < n and subtract 1 from arr[x] and add 1 to arr[y] (i.e. perform arr[x] -=1 and arr[y] += 1). The goal is to make all the elements of the array equal. It is guaranteed that all the elements of the array can be made equal using some operations.\nGiven an integer n, the length of the array. Return the minimum number of operations needed to make all the elements of arr equal.\n\nExample 1:\nInput: n = 3\nOutput: 2\nExplanation: arr = [1, 3, 5]\nFirst operation choose x = 2 and y = 0, this leads arr to be [2, 3, 4]\nIn the second operation choose x = 2 and y = 0 again, thus arr = [3, 3, 3].\n\nExample 2:\nInput: n = 6\nOutput: 9\n\nConstraints:\n\n1 <= n <= 10^4", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn min_operations(n: u32) -> (result: u32)\n    requires 1 <= n <= 10000", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = min_operations(3);\n    // println!(\"Result for n=3: {}\", result1);\n    \n    // let result2 = min_operations(6);\n    // println!(\"Result for n=6: {}\", result2);\n    \n    // let result3 = min_operations(1);\n    // println!(\"Result for n=1: {}\", result3);\n}"}
{"id": "fvapps_000455", "vc-description": "Given a string s, partition s such that every substring of the partition is a palindrome.\n\nReturn the minimum cuts needed for a palindrome partitioning of s.\n\nExample:\n\nInput: \"aab\"\nOutput: 1\nExplanation: The palindrome partitioning [\"aa\",\"b\"] could be produced using 1 cut.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_palindrome(s: Seq<char>) -> bool {\n    s =~= s.reverse()\n}\n\nspec fn min_palindrome_cuts(s: Seq<char>) -> nat {\n    0\n}\n\nproof fn min_cuts_nonnegative(s: Seq<char>)\n    ensures min_palindrome_cuts(s) >= 0,\n{\n    assume(false);\n}\n\nproof fn binary_string_small_cuts(s: Seq<char>)\n    requires s.len() <= 2,\n    ensures min_palindrome_cuts(s) <= 1,\n{\n    assume(false);\n}\n\nproof fn empty_string_no_cuts()\n    ensures min_palindrome_cuts(Seq::<char>::empty()) == 0,\n{\n    assume(false);\n}\n\nproof fn single_char_no_cuts(c: char)\n    ensures min_palindrome_cuts(seq![c]) == 0,\n{\n    assume(false);\n}\n\nproof fn cuts_monotonicity()\n    ensures min_palindrome_cuts(seq!['a']) <= min_palindrome_cuts(seq!['a', 'b']) && \n            min_palindrome_cuts(seq!['a', 'b']) <= min_palindrome_cuts(seq!['a', 'b', 'c']),\n{\n    assume(false);\n}", "vc-code": "", "vc-postamble": "/* Apps difficulty: interview\n   Assurance level: guarded_and_plausible */\n\n}\n\nfn main() {\n    // let result1 = min_palindrome_cuts(seq!['a', 'a', 'b']);\n    // println!(\"{}\", result1); // Should print 1\n    \n    // let result2 = min_palindrome_cuts(seq!['a', 'b', 'a']);\n    // println!(\"{}\", result2); // Should print 0\n    \n    // let result3 = min_palindrome_cuts(seq!['a', 'b', 'b', 'a']);\n    // println!(\"{}\", result3); // Should print 0\n}"}
{"id": "fvapps_000456", "vc-description": "We are given a personal information string S, which may represent either an email address or a phone number.\nWe would like to mask this personal information according to the following rules:\n\n1. Email address:\nWe define a name to be a string of length ≥ 2 consisting of only lowercase letters a-z or uppercase letters A-Z.\nAn email address starts with a name, followed by the symbol '@', followed by a name, followed by the dot '.' and followed by a name. \nAll email addresses are guaranteed to be valid and in the format of \"name1@name2.name3\".\nTo mask an email, all names must be converted to lowercase and all letters between the first and last letter of the first name must be replaced by 5 asterisks '*'.\n\n2. Phone number:\nA phone number is a string consisting of only the digits 0-9 or the characters from the set {'+', '-', '(', ')', ' '}. You may assume a phone number contains 10 to 13 digits.\nThe last 10 digits make up the local number, while the digits before those make up the country code. Note that the country code is optional. We want to expose only the last 4 digits and mask all other digits.\nThe local number should be formatted and masked as \"***-***-1111\", where 1 represents the exposed digits.\nTo mask a phone number with country code like \"+111 111 111 1111\", we write it in the form \"+***-***-***-1111\".  The '+' sign and the first '-' sign before the local number should only exist if there is a country code.  For example, a 12 digit phone number mask should start with \"+**-\".\nNote that extraneous characters like \"(\", \")\", \" \", as well as extra dashes or plus signs not part of the above formatting scheme should be removed.\n\nReturn the correct \"mask\" of the information provided.\n\nExample 1:\nInput: \"LeetCode@LeetCode.com\"\nOutput: \"l*****e@leetcode.com\"\nExplanation: All names are converted to lowercase, and the letters between the\n             first and last letter of the first name is replaced by 5 asterisks.\n             Therefore, \"leetcode\" -> \"l*****e\".\n\nExample 2:\nInput: \"AB@qq.com\"\nOutput: \"a*****b@qq.com\"\nExplanation: There must be 5 asterisks between the first and last letter \n             of the first name \"ab\". Therefore, \"ab\" -> \"a*****b\".\n\nExample 3:\nInput: \"1(234)567-890\"\nOutput: \"***-***-7890\"\nExplanation: 10 digits in the phone number, which means all digits make up the local number.\n\nExample 4:\nInput: \"86-(10)12345678\"\nOutput: \"+**-***-***-5678\"\nExplanation: 12 digits, 2 digits for country code and 10 digits for local number. \n\nNotes:\n\nS.length <= 40.\nEmails have length at least 8.\nPhone numbers have length at least 10.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_digit_char(c: char) -> bool {\n    '0' <= c && c <= '9'\n}\n\nspec fn count_digits(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0nat\n    } else {\n        (if is_digit_char(s[0]) { 1nat } else { 0nat }) + count_digits(s.skip(1))\n    }\n}\n\nspec fn last_n_chars(s: Seq<char>, n: nat) -> Seq<char> {\n    if n >= s.len() {\n        s\n    } else {\n        s.skip((s.len() - n) as int)\n    }\n}\n\nfn mask_pii(s: String) -> (result: String)\n    requires \n        s@.len() <= 40,\n        s@.len() >= 8,\n    ensures\n        /* For 10-digit phone numbers (all digits) */\n        (s@.len() == 10 && forall|i: int| 0 <= i < s@.len() ==> is_digit_char(s@[i])) ==>\n            result@ == seq!['*', '*', '*', '-', '*', '*', '*', '-'] + last_n_chars(s@, 4),\n        /* For phone numbers with more than 10 digits */\n        (count_digits(s@) > 10) ==>\n            result@.len() > 0 &&\n            result@[0] == '+' &&\n            exists|i: int| 0 <= i < result@.len() && result@[i] == '-' &&\n            exists|j: int| 0 <= j < result@.len() && result@[j] == '*',\n        /* For specific email example */\n        s@ == \"LeetCode@LeetCode.com\"@ ==> result@ == \"l*****e@leetcode.com\"@", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let result1 = mask_pii(\"LeetCode@LeetCode.com\".to_string());\n    // println!(\"{}\", result1); // Should print: l*****e@leetcode.com\n    \n    // let result2 = mask_pii(\"1(234)567-890\".to_string()); \n    // println!(\"{}\", result2); // Should print: ***-***-7890\n    \n    // let result3 = mask_pii(\"86-(10)12345678\".to_string());\n    // println!(\"{}\", result3); // Should print: +**-***-***-5678\n}"}
{"id": "fvapps_000457", "vc-description": "Given an integer array nums, return the sum of divisors of the integers in that array that have exactly four divisors.\nIf there is no such integer in the array, return 0.\n\nExample 1:\nInput: nums = [21,4,7]\nOutput: 32\nExplanation:\n21 has 4 divisors: 1, 3, 7, 21\n4 has 3 divisors: 1, 2, 4\n7 has 2 divisors: 1, 7\nThe answer is the sum of divisors of 21 only.\n\nConstraints:\n\n1 <= nums.length <= 10^4\n1 <= nums[i] <= 10^5", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn count_divisors(n: nat) -> nat;\n\nspec fn sum_divisors(n: nat) -> nat;\n\nfn sum_four_divisors(nums: Vec<u32>) -> (result: u32)\n    requires nums.len() >= 1,\n    ensures result >= 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded_and_plausible\n\n    // let result1 = sum_four_divisors(vec![21, 4, 7]);\n    // assert_eq!(result1, 32);\n\n    // let result2 = sum_four_divisors(vec![1, 2, 3, 4]);\n    // assert_eq!(result2, 0);\n\n    // let result3 = sum_four_divisors(vec![21]);\n    // assert_eq!(result3, 32);\n}"}
{"id": "fvapps_000462", "vc-description": "Given an array of non-negative integers arr, you are initially positioned at start index of the array. When you are at index i, you can jump to i + arr[i] or i - arr[i], check if you can reach to any index with value 0.\nNotice that you can not jump outside of the array at any time.\n\nExample 1:\nInput: arr = [4,2,3,0,3,1,2], start = 5\nOutput: true\nExplanation: \nAll possible ways to reach at index 3 with value 0 are: \nindex 5 -> index 4 -> index 1 -> index 3 \nindex 5 -> index 6 -> index 4 -> index 1 -> index 3 \n\nExample 2:\nInput: arr = [4,2,3,0,3,1,2], start = 0\nOutput: true \nExplanation: \nOne possible way to reach at index 3 with value 0 is: \nindex 0 -> index 4 -> index 1 -> index 3\n\nExample 3:\nInput: arr = [3,0,2,1,2], start = 2\nOutput: false\nExplanation: There is no way to reach at index 1 with value 0.\n\nConstraints:\n\n1 <= arr.length <= 5 * 10^4\n0 <= arr[i] < arr.length\n0 <= start < arr.length", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn can_reach(arr: Vec<usize>, start: usize) -> (result: bool)\n    requires \n        start < arr.len(),\n        arr.len() >= 1,\n        forall|i: int| 0 <= i < arr.len() ==> arr[i] < arr.len(),\n    ensures\n        start >= arr.len() ==> result == false,\n        (forall|i: int| 0 <= i < arr.len() ==> arr[i] != 0) ==> result == false,\n        result == true ==> (\n            exists|path: Seq<int>| \n                path.len() > 0 &&\n                path[0] == start as int &&\n                (exists|pos: int| 0 <= pos < arr.len() && path.contains(pos) && arr[pos as int] == 0) &&\n                (forall|i: int, j: int| \n                    0 <= i < path.len() - 1 && j == i + 1 ==> (\n                        0 <= path[i] < arr.len() && \n                        0 <= path[j] < arr.len() &&\n                        (path[j] == path[i] + arr[path[i] as int] as int || \n                         (path[i] >= arr[path[i] as int] as int && path[j] == path[i] - arr[path[i] as int] as int))\n                    )\n                )\n        )", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = can_reach(vec![4, 2, 3, 0, 3, 1, 2], 5);\n    // println!(\"Test 1: {}\", result1);  // Should be true\n    \n    // let result2 = can_reach(vec![4, 2, 3, 0, 3, 1, 2], 0);\n    // println!(\"Test 2: {}\", result2);  // Should be true\n    \n    // let result3 = can_reach(vec![3, 0, 2, 1, 2], 2);\n    // println!(\"Test 3: {}\", result3);  // Should be false\n}"}
{"id": "fvapps_000463", "vc-description": "Given an array of integers arr.\nWe want to select three indices i, j and k where (0 <= i < j <= k < arr.length).\nLet's define a and b as follows:\n\na = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]\nb = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]\n\nNote that ^ denotes the bitwise-xor operation.\nReturn the number of triplets (i, j and k) Where a == b.\n\nExample 1:\nInput: arr = [2,3,1,6,7]\nOutput: 4\nExplanation: The triplets are (0,1,2), (0,2,2), (2,3,4) and (2,4,4)\n\nExample 2:\nInput: arr = [1,1,1,1,1]\nOutput: 10\n\nExample 3:\nInput: arr = [2,3]\nOutput: 0\n\nExample 4:\nInput: arr = [1,3,5,7,9]\nOutput: 3\n\nExample 5:\nInput: arr = [7,11,12,9,5,2,7,17,22]\nOutput: 8\n\nConstraints:\n\n1 <= arr.length <= 300\n1 <= arr[i] <= 10^8", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn xor_range(arr: Seq<u32>, start: int, end: int) -> u32\n    decreases end - start\n{\n    if start >= end {\n        0\n    } else {\n        arr[start] ^ xor_range(arr, start + 1, end)\n    }\n}\n\nfn count_triplets(arr: Vec<u32>) -> (result: usize)\n    requires arr.len() >= 1,\n    ensures result >= 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let arr1 = vec![2, 3, 1, 6, 7];\n    // let result1 = count_triplets(arr1);\n    // assert_eq!(result1, 4);\n    \n    // let arr2 = vec![1, 1, 1, 1, 1];\n    // let result2 = count_triplets(arr2);\n    // assert_eq!(result2, 10);\n    \n    // let arr3 = vec![1, 3, 5, 7, 9];\n    // let result3 = count_triplets(arr3);\n    // assert_eq!(result3, 3);\n}"}
{"id": "fvapps_000466", "vc-description": "N cars are going to the same destination along a one lane road. The destination is target miles away.\nEach car i has a constant speed speed[i] (in miles per hour), and initial position position[i] miles towards the target along the road.\nA car can never pass another car ahead of it, but it can catch up to it, and drive bumper to bumper at the same speed.\nThe distance between these two cars is ignored - they are assumed to have the same position.\nA car fleet is some non-empty set of cars driving at the same position and same speed. Note that a single car is also a car fleet.\nIf a car catches up to a car fleet right at the destination point, it will still be considered as one car fleet.\n\nHow many car fleets will arrive at the destination?\n\nExample 1:\nInput: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]\nOutput: 3\nExplanation:\nThe cars starting at 10 and 8 become a fleet, meeting each other at 12.\nThe car starting at 0 doesn't catch up to any other car, so it is a fleet by itself.\nThe cars starting at 5 and 3 become a fleet, meeting each other at 6.\nNote that no other cars meet these fleets before the destination, so the answer is 3.\n\nNote:\n0 <= N <= 10 ^ 4\n0 < target <= 10 ^ 6\n0 < speed[i] <= 10 ^ 6\n0 <= position[i] < target\nAll initial positions are different.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn car_fleet(target: i32, positions: Vec<i32>, speeds: Vec<i32>) -> (result: i32)\n    requires \n        target > 0,\n        target <= 1000,\n        positions.len() == speeds.len(),\n        positions.len() <= 10,\n        forall|i: int| 0 <= i < positions.len() ==> 0 <= positions[i] && positions[i] <= 100,\n        forall|i: int| 0 <= i < speeds.len() ==> 1 <= speeds[i] && speeds[i] <= 10,\n    ensures \n        result <= positions.len(),\n        positions.len() == 0 ==> result == 0,\n        positions.len() == 1 ==> result == 1,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = car_fleet(12, vec![10, 8, 0, 5, 3], vec![2, 4, 1, 1, 3]);\n    // assert(result1 == 3);\n    \n    // let result2 = car_fleet(10, vec![0], vec![1]);\n    // assert(result2 == 1);\n    \n    // let result3 = car_fleet(10, vec![], vec![]);\n    // assert(result3 == 0);\n}"}
{"id": "fvapps_000469", "vc-description": "There is a brick wall in front of you. The wall is rectangular and has several rows of bricks. The bricks have the same height but different width. You want to draw a vertical line from the top to the bottom and cross the least bricks. \n\nThe brick wall is represented by a list of rows. Each row is a list of integers representing the width of each brick in this row from left to right. \n\nIf your line go through the edge of a brick, then the brick is not considered as crossed. You need to find out how to draw the line to cross the least bricks and return the number of crossed bricks. \n\nYou cannot draw a line just along one of the two vertical edges of the wall, in which case the line will obviously cross no bricks. \n\nExample:\n\nInput: \n[[1,2,2,1],\n [3,1,2],\n [1,3,2],\n [2,4],\n [3,1,2],\n [1,3,1,1]]\nOutput: 2\nExplanation: \n\nNote:\n\nThe width sum of bricks in different rows are the same and won't exceed INT_MAX.\nThe number of bricks in each row is in range [1,10,000]. The height of wall is in range [1,10,000]. Total number of bricks of the wall won't exceed 20,000.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn least_bricks(wall: Vec<Vec<usize>>) -> (result: usize)\n    ensures \n        wall.len() == 0 ==> result == 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let test_wall = vec![vec![1, 2, 2, 1], vec![3, 1, 2], vec![1, 3, 2], vec![2, 4], vec![3, 1, 2], vec![1, 3, 1, 1]];\n    // println!(\"{}\", least_bricks(test_wall)); // Should output 2\n    // \n    // let empty_wall = vec![];\n    // println!(\"{}\", least_bricks(empty_wall)); // Should output 0\n    // \n    // let uniform_wall = vec![vec![5], vec![5], vec![5]];\n    // println!(\"{}\", least_bricks(uniform_wall)); // Should output 3\n}"}
{"id": "fvapps_000470", "vc-description": "You have a pointer at index 0 in an array of size arrLen. At each step, you can move 1 position to the left, 1 position to the right in the array or stay in the same place  (The pointer should not be placed outside the array at any time).\nGiven two integers steps and arrLen, return the number of ways such that your pointer still at index 0 after exactly steps steps.\nSince the answer may be too large, return it modulo 10^9 + 7.\n\nExample 1:\nInput: steps = 3, arrLen = 2\nOutput: 4\nExplanation: There are 4 differents ways to stay at index 0 after 3 steps.\nRight, Left, Stay\nStay, Right, Left\nRight, Stay, Left\nStay, Stay, Stay\n\nExample 2:\nInput: steps = 2, arrLen = 4\nOutput: 2\nExplanation: There are 2 differents ways to stay at index 0 after 2 steps\nRight, Left\nStay, Stay\n\nExample 3:\nInput: steps = 4, arrLen = 2\nOutput: 8\n\nConstraints:\n\n1 <= steps <= 500\n1 <= arrLen <= 10^6", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn num_ways(steps: u32, arr_len: u32) -> (result: u32)\n    requires \n        steps >= 1,\n        steps <= 500,\n        arr_len >= 1,\n        arr_len <= 1000000,\n    ensures \n        1 <= result,\n        result <= 1000000007,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "}\n\nfn main() {\n    // assert_eq!(num_ways(3, 2), 4);\n    // assert_eq!(num_ways(2, 4), 2);\n    // assert_eq!(num_ways(4, 2), 8);\n}"}
{"id": "fvapps_000471", "vc-description": "Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.\n\nExample:\n\nGiven array nums = [-1, 2, 1, -4], and target = 1.\n\nThe sum that is closest to the target is 2. (-1 + 2 + 1 = 2).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn abs_spec(x: int) -> int {\n    if x < 0 { -x } else { x }\n}", "vc-helpers": "", "vc-spec": "fn three_sum_closest(nums: Vec<i32>, target: i32) -> (result: i32)\n    requires nums.len() >= 3,\n    ensures \n        (exists|i: int, j: int, k: int| \n            0 <= i < j && j < k && k < nums.len() && \n            result == nums[i] + nums[j] + nums[k])\n        &&\n        (forall|i: int, j: int, k: int| \n            (0 <= i < j && j < k && k < nums.len()) ==>\n            abs_spec(result - target) <= abs_spec(nums[i] + nums[j] + nums[k] - target))", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "}\n\nfn main() {\n    // let result1 = three_sum_closest(vec![-4, -1, 1, 2], 1);\n    // println!(\"Result: {}\", result1);\n    \n    // let result2 = three_sum_closest(vec![1, 1, 1, 0], 100);\n    // println!(\"Result: {}\", result2);\n    \n    // let result3 = three_sum_closest(vec![0, 2, 1, -3], 1);\n    // println!(\"Result: {}\", result3);\n}"}
{"id": "fvapps_000472", "vc-description": "Given an array arr of positive integers, consider all binary trees such that:\n\nEach node has either 0 or 2 children;\nThe values of arr correspond to the values of each leaf in an in-order traversal of the tree.  (Recall that a node is a leaf if and only if it has 0 children.)\nThe value of each non-leaf node is equal to the product of the largest leaf value in its left and right subtree respectively.\n\nAmong all possible binary trees considered, return the smallest possible sum of the values of each non-leaf node.  It is guaranteed this sum fits into a 32-bit integer.\n\nExample 1:\nInput: arr = [6,2,4]\nOutput: 32\nExplanation:\nThere are two possible trees.  The first has non-leaf node sum 36, and the second has non-leaf node sum 32.\n\n    24            24\n   /  \\          /  \\\n  12   4        6    8\n /  \\               / \\\n6    2             2   4\n\nConstraints:\n\n2 <= arr.length <= 40\n1 <= arr[i] <= 15\nIt is guaranteed that the answer fits into a 32-bit signed integer (ie. it is less than 2^31).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn mct_from_leaf_values(arr: Vec<i32>) -> (result: i32)\n    requires \n        forall|i: int| 0 <= i < arr.len() ==> #[trigger] arr[i] >= 1 && #[trigger] arr[i] <= 15,\n    ensures\n        arr.len() == 0 ==> result == 0,\n        arr.len() == 1 ==> result == 0,\n        arr.len() == 2 ==> result == arr[0] * arr[1],", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\nproof fn test_base_cases() {\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\n}\n\nfn main() {\n    // let test1 = vec![6, 2, 4];\n    // println!(\"{}\", mct_from_leaf_values(test1)); // Should output 32\n    \n    // let test2 = vec![4, 11];\n    // println!(\"{}\", mct_from_leaf_values(test2)); // Should output 44\n    \n    // let test3 = vec![15, 13, 5, 3, 15];\n    // println!(\"{}\", mct_from_leaf_values(test3)); // Should output 500\n}"}
{"id": "fvapps_000475", "vc-description": "In an array A containing only 0s and 1s, a K-bit flip consists of choosing a (contiguous) subarray of length K and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0.\nReturn the minimum number of K-bit flips required so that there is no 0 in the array.  If it is not possible, return -1.\n\nExample 1:\nInput: A = [0,1,0], K = 1\nOutput: 2\nExplanation: Flip A[0], then flip A[2].\n\nExample 2:\nInput: A = [1,1,0], K = 2\nOutput: -1\nExplanation: No matter how we flip subarrays of size 2, we can't make the array become [1,1,1].\n\nExample 3:\nInput: A = [0,0,0,1,0,1,1,0], K = 3\nOutput: 3\nExplanation:\nFlip A[0],A[1],A[2]: A becomes [1,1,1,1,0,1,1,0]\nFlip A[4],A[5],A[6]: A becomes [1,1,1,1,1,0,0,0]\nFlip A[5],A[6],A[7]: A becomes [1,1,1,1,1,1,1,1]\n\nNote:\n\n1 <= A.length <= 30000\n1 <= K <= A.length", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn min_k_bit_flips(a: Vec<usize>, k: usize) -> (result: i32)\n    requires \n        a.len() >= 1,\n        k >= 1,\n        k <= a.len(),\n        forall|i: int| 0 <= i < a.len() ==> (a[i] == 0 || a[i] == 1),\n    ensures \n        result >= -1,\n        result != -1 ==> result >= 0 && result <= a.len(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = min_k_bit_flips(vec![0, 1, 0], 1);\n    // println!(\"Result 1: {}\", result1); // Expected: 2\n    \n    // let result2 = min_k_bit_flips(vec![1, 1, 0], 2);\n    // println!(\"Result 2: {}\", result2); // Expected: -1\n    \n    // let result3 = min_k_bit_flips(vec![0, 0, 0, 1, 0, 1, 1, 0], 3);\n    // println!(\"Result 3: {}\", result3); // Expected: 3\n}"}
{"id": "fvapps_000479", "vc-description": "There are N rooms and you start in room 0.  Each room has a distinct number in 0, 1, 2, ..., N-1, and each room may have some keys to access the next room. \nFormally, each room i has a list of keys rooms[i], and each key rooms[i][j] is an integer in [0, 1, ..., N-1] where N = rooms.length.  A key rooms[i][j] = v opens the room with number v.\nInitially, all the rooms start locked (except for room 0). \nYou can walk back and forth between rooms freely.\nReturn true if and only if you can enter every room.\n\nExample 1:\nInput: [[1],[2],[3],[]]\nOutput: true\nExplanation:  \nWe start in room 0, and pick up key 1.\nWe then go to room 1, and pick up key 2.\nWe then go to room 2, and pick up key 3.\nWe then go to room 3.  Since we were able to go to every room, we return true.\n\nExample 2:\nInput: [[1,3],[3,0,1],[2],[0]]\nOutput: false\nExplanation: We can't enter the room with number 2.\n\nNote:\n\n1 <= rooms.length <= 1000\n0 <= rooms[i].length <= 1000\nThe number of keys in all rooms combined is at most 3000.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_valid_path(rooms: Seq<Vec<nat>>, path: Seq<nat>) -> bool {\n    path.len() > 0 &&\n    path[0] == 0 &&\n    (forall|j: int| 0 <= j < path.len() - 1 ==> {\n        j + 1 < path.len() &&\n        path[j] < rooms.len() &&\n        path[j + 1] < rooms.len() &&\n        rooms[path[j] as int]@.contains(path[j + 1])\n    })\n}\n\nspec fn can_reach_room(rooms: Seq<Vec<nat>>, target_room: nat) -> bool {\n    target_room < rooms.len() &&\n    exists|path: Seq<nat>| {\n        is_valid_path(rooms, path) &&\n        path[path.len() - 1] == target_room\n    }\n}\n\nfn can_visit_all_rooms(rooms: Vec<Vec<nat>>) -> (result: bool)\n    requires \n        rooms.len() >= 1,\n        rooms.len() <= 1000,\n        forall|i: int| 0 <= i < rooms.len() ==> rooms[i].len() <= 1000,\n        forall|i: int, j: int| 0 <= i < rooms.len() && 0 <= j < rooms[i].len() ==> rooms[i][j] < rooms.len(),\n    ensures \n        result == true <==> (forall|i: nat| i < rooms.len() ==> can_reach_room(rooms@, i)),\n        result == false <==> (exists|i: nat| i < rooms.len() && !can_reach_room(rooms@, i))", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let test1 = vec![vec![1], vec![2], vec![3], vec![]];\n    // println!(\"{}\", can_visit_all_rooms(test1));\n    \n    // let test2 = vec![vec![1, 3], vec![3, 0, 1], vec![2], vec![0]];\n    // println!(\"{}\", can_visit_all_rooms(test2));\n    \n    // let test3 = vec![vec![1], vec![2], vec![3], vec![], vec![], vec![]];\n    // println!(\"{}\", can_visit_all_rooms(test3));\n}"}
{"id": "fvapps_000480", "vc-description": "Consider the string s to be the infinite wraparound string of \"abcdefghijklmnopqrstuvwxyz\", so s will look like this: \"...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....\".\n\nNow we have another string p. Your job is to find out how many unique non-empty substrings of p are present in s. In particular, your input is the string p and you need to output the number of different non-empty substrings of p in the string s.\n\nNote: p consists of only lowercase English letters and the size of p might be over 10000.\n\nExample 1:\n\nInput: \"a\"\nOutput: 1\n\nExplanation: Only the substring \"a\" of string \"a\" is in the string s.\n\nExample 2:\n\nInput: \"cac\"\nOutput: 2\nExplanation: There are two substrings \"a\", \"c\" of string \"cac\" in the string s.\n\nExample 3:\n\nInput: \"zab\"\nOutput: 6\nExplanation: There are six substrings \"z\", \"a\", \"b\", \"za\", \"ab\", \"zab\" of string \"zab\" in the string s.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn find_substrings_in_wraparound(s: Vec<u8>) -> (result: usize)\n    ensures \n        result >= 0,\n        s.len() >= 1 ==> result >= 1", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded_and_plausible\n\n    // Expected output: 1\n    // find_substrings_in_wraparound(\"a\".as_bytes().to_vec());\n\n    // Expected output: 2\n    // find_substrings_in_wraparound(\"cac\".as_bytes().to_vec());\n\n    // Expected output: 6\n    // find_substrings_in_wraparound(\"zab\".as_bytes().to_vec());\n}"}
{"id": "fvapps_000488", "vc-description": "Given an array of positive integers target and an array initial of same size with all zeros.\nReturn the minimum number of operations to form a target array from initial if you are allowed to do the following operation:\n\nChoose any subarray from initial and increment each value by one.\n\nThe answer is guaranteed to fit within the range of a 32-bit signed integer.\n\nExample 1:\nInput: target = [1,2,3,2,1]\nOutput: 3\nExplanation: We need at least 3 operations to form the target array from the initial array.\n[0,0,0,0,0] increment 1 from index 0 to 4 (inclusive).\n[1,1,1,1,1] increment 1 from index 1 to 3 (inclusive).\n[1,2,2,2,1] increment 1 at index 2.\n[1,2,3,2,1] target array is formed.\n\nExample 2:\nInput: target = [3,1,1,2]\nOutput: 4\nExplanation: (initial)[0,0,0,0] -> [1,1,1,1] -> [1,1,1,2] -> [2,1,1,2] -> [3,1,1,2] (target).\n\nExample 3:\nInput: target = [3,1,5,4,2]\nOutput: 7\nExplanation: (initial)[0,0,0,0,0] -> [1,1,1,1,1] -> [2,1,1,1,1] -> [3,1,1,1,1] \n                                  -> [3,1,2,2,2] -> [3,1,3,3,2] -> [3,1,4,4,2] -> [3,1,5,4,2] (target).\n\nExample 4:\nInput: target = [1,1,1,1]\nOutput: 1\n\nConstraints:\n\n1 <= target.length <= 10^5\n1 <= target[i] <= 10^5", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn min_number_operations(nums: Vec<u32>) -> (result: u32)\n    requires \n        nums.len() > 0,\n        forall|i: int| 0 <= i < nums.len() ==> nums[i] >= 1,\n    ensures \n        result >= 0,\n        result >= nums[0],", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let result1 = min_number_operations(vec![1, 2, 3, 2, 1]);\n    // println!(\"Result 1: {}\", result1); // Expected: 3\n    \n    // let result2 = min_number_operations(vec![3, 1, 1, 2]);\n    // println!(\"Result 2: {}\", result2); // Expected: 4\n    \n    // let result3 = min_number_operations(vec![1, 1, 1, 1]);\n    // println!(\"Result 3: {}\", result3); // Expected: 1\n}"}
{"id": "fvapps_000489", "vc-description": "Implement a basic calculator to evaluate a simple expression string.\n\nThe expression string contains only non-negative integers, +, -, *, / operators and empty spaces. The integer division should truncate toward zero.\n\nExample 1:\nInput: \"3+2*2\"\nOutput: 7\n\nExample 2:\nInput: \" 3/2 \"\nOutput: 1\n\nExample 3:\nInput: \" 3+5 / 2 \"\nOutput: 5\n\nNote:\nYou may assume that the given expression is always valid.\nDo not use the eval built-in library function.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn calculate(s: String) -> (result: Option<i32>)", "vc-code": "{\n    // impl-start\n    assume(false);\n    None\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded_and_plausible\n    \n    // println!(\"{:?}\", calculate(\"3+2*2\".to_string()));  // Should output: Some(7)\n    // println!(\"{:?}\", calculate(\" 3/2 \".to_string()));  // Should output: Some(1) \n    // println!(\"{:?}\", calculate(\" 3+5 / 2 \".to_string()));  // Should output: Some(5)\n}"}
{"id": "fvapps_000491", "vc-description": "In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1.\nSome nodes initial are initially infected by malware.  Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware.  This spread of malware will continue until no more nodes can be infected in this manner.\nSuppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops.\nWe will remove one node from the initial list.  Return the node that if removed, would minimize M(initial).  If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.\nNote that if a node was removed from the initial list of infected nodes, it may still be infected later as a result of the malware spread.\n\nExample 1:\nInput: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]\nOutput: 0\n\nExample 2:\nInput: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]\nOutput: 0\n\nExample 3:\nInput: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]\nOutput: 1\n\nNote:\n\n1 < graph.length = graph[0].length <= 300\n0 <= graph[i][j] == graph[j][i] <= 1\ngraph[i][i] == 1\n1 <= initial.length <= graph.length\n0 <= initial[i] < graph.length", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn min_malware_spread(graph: Vec<Vec<usize>>, initial: Vec<usize>) -> (result: usize)\n    requires \n        graph.len() > 0,\n        initial.len() > 0,\n        forall|i: int| 0 <= i < initial.len() ==> initial[i] < graph.len(),\n        forall|i: int| 0 <= i < graph.len() ==> graph[i].len() == graph.len(),\n        forall|i: int, j: int| 0 <= i < graph.len() && 0 <= j < graph.len() ==> \n            graph[i][j] == graph[j][i],\n        forall|i: int| 0 <= i < graph.len() ==> graph[i][i] == 1,\n        forall|i: int, j: int| 0 <= i < graph.len() && 0 <= j < graph.len() ==> \n            graph[i][j] <= 1,\n    ensures\n        exists|k: int| 0 <= k < initial.len() && initial[k] == result,\n        forall|x: int| 0 <= x < initial.len() ==> result <= initial[x],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let test_graph1 = vec![vec![1, 1, 0], vec![1, 1, 0], vec![0, 0, 1]];\n    // let test_initial1 = vec![0, 1];\n    // let result1 = min_malware_spread(test_graph1, test_initial1);\n    // println!(\"Result 1: {}\", result1);\n\n    // let test_graph2 = vec![vec![1, 0, 0], vec![0, 1, 0], vec![0, 0, 1]];\n    // let test_initial2 = vec![0, 2];\n    // let result2 = min_malware_spread(test_graph2, test_initial2);\n    // println!(\"Result 2: {}\", result2);\n\n    // let test_graph3 = vec![vec![1, 1, 1], vec![1, 1, 1], vec![1, 1, 1]];\n    // let test_initial3 = vec![1, 2];\n    // let result3 = min_malware_spread(test_graph3, test_initial3);\n    // println!(\"Result 3: {}\", result3);\n}"}
{"id": "fvapps_000492", "vc-description": "Given a sentence text (A sentence is a string of space-separated words) in the following format:\n\nFirst letter is in upper case.\nEach word in text are separated by a single space.\n\nYour task is to rearrange the words in text such that all words are rearranged in an increasing order of their lengths. If two words have the same length, arrange them in their original order.\nReturn the new text following the format shown above.\n\nExample 1:\nInput: text = \"Leetcode is cool\"\nOutput: \"Is cool leetcode\"\nExplanation: There are 3 words, \"Leetcode\" of length 8, \"is\" of length 2 and \"cool\" of length 4.\nOutput is ordered by length and the new first word starts with capital letter.\n\nExample 2:\nInput: text = \"Keep calm and code on\"\nOutput: \"On and keep calm code\"\nExplanation: Output is ordered as follows:\n\"On\" 2 letters.\n\"and\" 3 letters.\n\"keep\" 4 letters in case of tie order by position in original text.\n\"calm\" 4 letters.\n\"code\" 4 letters.\n\nExample 3:\nInput: text = \"To be or not to be\"\nOutput: \"To be or to be not\"\n\nConstraints:\n\ntext begins with a capital letter and then contains lowercase letters and single space between words.\n1 <= text.length <= 10^5", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn count_spaces(s: Seq<char>) -> int \n    decreases s.len()\n{\n    if s.len() == 0 {\n        0int\n    } else {\n        (if s[0] == ' ' { 1int } else { 0int }) + count_spaces(s.skip(1))\n    }\n}\n\nspec fn word_count(s: Seq<char>) -> int {\n    count_spaces(s) + 1int\n}\n\nfn arrange_words(s: String) -> (result: String)\n    requires s@.len() > 0,\n    ensures\n        result@.len() > 0,\n        word_count(s@) == word_count(result@)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000493", "vc-description": "You are given a string s that consists of lower case English letters and brackets. \nReverse the strings in each pair of matching parentheses, starting from the innermost one.\nYour result should not contain any brackets.\n\nExample 1:\nInput: s = \"(abcd)\"\nOutput: \"dcba\"\n\nExample 2:\nInput: s = \"(u(love)i)\"\nOutput: \"iloveu\"\nExplanation: The substring \"love\" is reversed first, then the whole string is reversed.\n\nExample 3:\nInput: s = \"(ed(et(oc))el)\"\nOutput: \"leetcode\"\nExplanation: First, we reverse the substring \"oc\", then \"etco\", and finally, the whole string.\n\nExample 4:\nInput: s = \"a(bcdefghijkl(mno)p)q\"\nOutput: \"apmnolkjihgfedcbq\"\n\nConstraints:\n\n0 <= s.length <= 2000\ns only contains lower case English characters and parentheses.\nIt's guaranteed that all parentheses are balanced.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn count_char(s: Seq<char>, c: char) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0nat\n    } else {\n        (if s[0] == c { 1nat } else { 0nat }) + count_char(s.skip(1), c)\n    }\n}\n\nspec fn contains_char(s: Seq<char>, c: char) -> bool {\n    exists|i: int| 0 <= i < s.len() && s[i] == c\n}\n\nfn reverse_parentheses(s: &str) -> (result: String)\n    ensures \n        result@.len() + count_char(s@, '(') + count_char(s@, ')') == s@.len(),\n        !contains_char(result@, '('),\n        !contains_char(result@, ')'),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let test1 = reverse_parentheses(\"(abcd)\");\n    // println!(\"Test 1: {}\", test1);\n    \n    // let test2 = reverse_parentheses(\"(u(love)i)\");\n    // println!(\"Test 2: {}\", test2);\n    \n    // let test3 = reverse_parentheses(\"a(bcdefghijkl(mno)p)q\");\n    // println!(\"Test 3: {}\", test3);\n}"}
{"id": "fvapps_000498", "vc-description": "Given is an undirected connected graph with N vertices numbered 1 to N, and M edges numbered 1 to M.\nThe given graph may contain multi-edges but not self loops.\nEach edge has an integer label between 1 and N (inclusive).\nEdge i has a label c_i, and it connects Vertex u_i and v_i bidirectionally.\nSnuke will write an integer between 1 and N (inclusive) on each vertex (multiple vertices may have the same integer written on them) and then keep only the edges satisfying the condition below, removing the other edges.\nCondition: Let x and y be the integers written on the vertices that are the endpoints of the edge. Exactly one of x and y equals the label of the edge.\nWe call a way of writing integers on the vertices good if (and only if) the graph is still connected after removing the edges not satisfying the condition above. Determine whether a good way of writing integers exists, and present one such way if it exists.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_valid_edge_condition(vertex_labels: Seq<nat>, u: nat, v: nat, edge_label: nat) -> bool {\n    u > 0 && v > 0 && u <= vertex_labels.len() && v <= vertex_labels.len() &&\n    ((vertex_labels[u - 1] == edge_label) != (vertex_labels[v - 1] == edge_label))\n}\n\nspec fn count_valid_edges(vertex_labels: Seq<nat>, edges: Seq<(nat, nat, nat)>) -> nat \n    decreases edges.len()\n{\n    if edges.len() == 0 {\n        0\n    } else {\n        let (u, v, c) = edges[0];\n        let count_rest = count_valid_edges(vertex_labels, edges.skip(1));\n        if is_valid_edge_condition(vertex_labels, u, v, c) {\n            count_rest + 1\n        } else {\n            count_rest\n        }\n    }\n}\n\nfn solve_graph_labeling(n: nat, edges: Vec<(nat, nat, nat)>) -> (result: Vec<nat>)\n    requires \n        n >= 2,\n        edges.len() >= n - 1,\n        forall|i: int| 0 <= i < edges.len() ==> {\n            let (u, v, c) = #[trigger] edges[i];\n            1 <= u <= n && 1 <= v <= n && 1 <= c <= n && u != v\n        },\n    ensures\n        result.len() == 0 || result.len() == n,\n        result.len() == n ==> forall|i: int| 0 <= i < n ==> 1 <= #[trigger] result[i] <= n,\n        result.len() == n ==> count_valid_edges(result@, edges@) >= n - 1,", "vc-code": "{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000500", "vc-description": "There are N Snuke Cats numbered 1, 2, \\ldots, N, where N is even.\nEach Snuke Cat wears a red scarf, on which his favorite non-negative integer is written.\nRecently, they learned the operation called xor (exclusive OR).What is xor?\n\nFor n non-negative integers x_1, x_2, \\ldots, x_n, their xor, x_1~\\textrm{xor}~x_2~\\textrm{xor}~\\ldots~\\textrm{xor}~x_n is defined as follows:\n\n -  When x_1~\\textrm{xor}~x_2~\\textrm{xor}~\\ldots~\\textrm{xor}~x_n is written in base two, the digit in the 2^k's place (k \\geq 0) is 1 if the number of integers among x_1, x_2, \\ldots, x_n whose binary representations have 1 in the 2^k's place is odd, and 0 if that count is even. \nFor example, 3~\\textrm{xor}~5 = 6.\n\nThey wanted to use this operation quickly, so each of them calculated the xor of the integers written on their scarfs except his scarf.\nWe know that the xor calculated by Snuke Cat i, that is, the xor of the integers written on the scarfs except the scarf of Snuke Cat i is a_i.\nUsing this information, restore the integer written on the scarf of each Snuke Cat.\n\n-----Constraints-----\n - All values in input are integers.\n - 2 \\leq N \\leq 200000\n - N is even.\n - 0 \\leq a_i \\leq 10^9\n - There exists a combination of integers on the scarfs that is consistent with the given information.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN\na_1 a_2 \\ldots a_N\n\n-----Output-----\nPrint a line containing N integers separated with space.\nThe i-th of the integers from the left should represent the integer written on the scarf of Snuke Cat i.\nIf there are multiple possible solutions, you may print any of them.\n\n-----Sample Input-----\n4\n20 11 9 24\n\n-----Sample Output-----\n26 5 7 22\n\n - 5~\\textrm{xor}~7~\\textrm{xor}~22 = 20\n - 26~\\textrm{xor}~7~\\textrm{xor}~22 = 11\n - 26~\\textrm{xor}~5~\\textrm{xor}~22 = 9\n - 26~\\textrm{xor}~5~\\textrm{xor}~7 = 24\nThus, this output is consistent with the given information.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn xor_all_except(result: Seq<u32>, i: int) -> u32\n    recommends 0 <= i < result.len()\n{\n    if result.len() == 0 {\n        0\n    } else if result.len() == 1 {\n        0\n    } else if i == 0 {\n        xor_seq(result.skip(1))\n    } else if i == result.len() - 1 {\n        xor_seq(result.take(result.len() - 1))\n    } else {\n        xor_seq(result.take(i)) ^ xor_seq(result.skip(i + 1))\n    }\n}\n\nspec fn xor_seq(s: Seq<u32>) -> u32\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s[0] ^ xor_seq(s.skip(1))\n    }\n}\n\nfn solve_scarf_xor(n: usize, a: Vec<u32>) -> (result: Vec<u32>)\n    requires \n        n >= 2,\n        n % 2 == 0,\n        a.len() == n,\n    ensures \n        result.len() == n,\n        forall|i: int| 0 <= i < n ==> xor_all_except(result@, i) == a[i],\n        forall|i: int| 0 <= i < n ==> result[i] >= 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000501", "vc-description": "There is a tree with N vertices numbered 1 to N.\nThe i-th edge in this tree connects Vertex a_i and Vertex b_i, and the color and length of that edge are c_i and d_i, respectively.\nHere the color of each edge is represented by an integer between 1 and N-1 (inclusive). The same integer corresponds to the same color, and different integers correspond to different colors.\nAnswer the following Q queries:\n - Query j (1 \\leq j \\leq Q): assuming that the length of every edge whose color is x_j is changed to y_j, find the distance between Vertex u_j and Vertex v_j. (The changes of the lengths of edges do not affect the subsequent queries.)\n\n-----Constraints-----\n - 2 \\leq N \\leq 10^5\n - 1 \\leq Q \\leq 10^5\n - 1 \\leq a_i, b_i \\leq N\n - 1 \\leq c_i \\leq N-1\n - 1 \\leq d_i \\leq 10^4\n - 1 \\leq x_j \\leq N-1\n - 1 \\leq y_j \\leq 10^4\n - 1 \\leq u_j < v_j \\leq N\n - The given graph is a tree.\n - All values in input are integers.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_tree_distance_queries(n: usize, root: usize, edges: Vec<(usize, usize, usize, usize)>, queries: Vec<(usize, usize, usize, usize)>) -> (result: Vec<usize>)\n    requires \n        n >= 2,\n        root >= 1 && root <= n,\n        edges.len() == n - 1,\n        queries.len() > 0,\n    ensures \n        result.len() == queries.len()", "vc-code": "{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "fvapps_000502", "vc-description": "We have a tree with N vertices, whose i-th edge connects Vertex u_i and Vertex v_i.\nVertex i has an integer a_i written on it.\nFor every integer k from 1 through N, solve the following problem:\n - We will make a sequence by lining up the integers written on the vertices along the shortest path from Vertex 1 to Vertex k, in the order they appear. Find the length of the longest increasing subsequence of this sequence.\nHere, the longest increasing subsequence of a sequence A of length L is the subsequence A_{i_1} , A_{i_2} , ... , A_{i_M} with the greatest possible value of M such that 1 \\leq i_1 < i_2 < ... < i_M \\leq L and A_{i_1} < A_{i_2} < ... < A_{i_M}.\n\n-----Constraints-----\n - 2 \\leq N \\leq 2 \\times 10^5\n - 1 \\leq a_i \\leq 10^9\n - 1 \\leq u_i , v_i \\leq N\n - u_i \\neq v_i\n - The given graph is a tree.\n - All values in input are integers.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN\na_1 a_2 ... a_N\nu_1 v_1\nu_2 v_2\n:\nu_{N-1} v_{N-1}\n\n-----Output-----\nPrint N lines. The k-th line, print the length of the longest increasing subsequence of the sequence obtained from the shortest path from Vertex 1 to Vertex k.\n\n-----Sample Input-----\n10\n1 2 5 3 4 6 7 3 2 4\n1 2\n2 3\n3 4\n4 5\n3 6\n6 7\n1 8\n8 9\n9 10\n\n-----Sample Output-----\n1\n2\n3\n3\n4\n4\n5\n2\n2\n3\n\nFor example, the sequence A obtained from the shortest path from Vertex 1 to Vertex 5 is 1,2,5,3,4. Its longest increasing subsequence is A_1, A_2, A_4, A_5, with the length of 4.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn find_longest_increasing_paths(n: usize, values: Vec<usize>, edges: Vec<(usize, usize)>) -> (result: Vec<usize>)\n    requires \n        n >= 2,\n        values.len() == n,\n        edges.len() == n - 1,\n    ensures\n        result.len() == n,\n        forall|i: int| 0 <= i < result.len() ==> result[i] >= 1,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000503", "vc-description": "Write a program to take two numbers as input and print their difference if the first number is greater than the second number otherwise print their sum.\n\n-----Input:-----\n- First line will contain the first number (N1)\n- Second line will contain the second number (N2)\n\n-----Output:-----\nOutput a single line containing the difference of 2 numbers (N1−N2) if the first number is greater than the second number otherwise output their sum (N1+N2).\n\n-----Constraints-----\n- −1000≤N1≤1000\n- −1000≤N2≤1000\n\n-----Sample Input:-----\n82\n28\n\n-----Sample Output:-----\n54", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn compare_and_calc(n1: i32, n2: i32) -> (result: i32)\n    requires \n        -1000 <= n1 <= 1000,\n        -1000 <= n2 <= 1000,\n    ensures result == if n1 > n2 { n1 - n2 } else { n1 + n2 }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let result1 = compare_and_calc(82, 28);\n    // println!(\"{}\", result1);  // Should print 54\n    // \n    // let result2 = compare_and_calc(10, 20);\n    // println!(\"{}\", result2);  // Should print 30\n    // \n    // let result3 = compare_and_calc(0, 0);\n    // println!(\"{}\", result3);  // Should print 0\n}"}
{"id": "fvapps_000506", "vc-description": "Indian National Olympiad in Informatics 2015\nA string is any nonempty sequence of 0s and 1s. Examples of strings are 00, 101, 111000, 1, 0, 01. The length of a string is the number of symbols in it. For example, the length of 111000 is 6. If u and v are strings, then uv is the string obtained by concatenating u and v. For example if u = 110 and v = 0010 then uv = 1100010.\nA string w is periodic if there exists a string v such that w = vn = vv · · · v (n times), for some n ≥ 2. Note that in this case the length of v is strictly less than that of w. For example, 110110 is periodic, because it is vv for v = 110.\nGiven a positive integer N , find the number of strings of length N which are not periodic. Report the answer modulo M . The non-periodic strings of length 2 are 10 and 01. The non- periodic strings of length 3 are 001, 010, 011, 100, 101, and 110.", "vc-preamble": "use vstd::prelude::*;\nuse vstd::arithmetic::power::pow;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_non_periodic_strings(n: nat, m: nat) -> (result: nat)\n    requires \n        n >= 2,\n        n <= 10000,\n        m > 0,\n        m <= 1000000000,\n    ensures \n        result >= 0,\n        result < m,\n        result < pow(2, n),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded_and_plausible\n    \n    // Example test cases:\n    // solve_non_periodic_strings(3, 176) should return 6\n    // solve_non_periodic_strings(4, 100) should return 12  \n    // solve_non_periodic_strings(2, 50) should return 2\n}"}
{"id": "fvapps_000507", "vc-description": "Finally, the pandemic is over in ChefLand, and the chef is visiting the school again. Chef likes to climb the stairs of his school's floor by skipping one step, sometimes chef climbs the stairs one by one. Simply, the chef can take one or 2 steps in one upward movement. There are N stairs between ground and next floor. The chef is on the ground floor and he wants to go to the next floor with Cheffina but, Cheffina asks chef in how many ways, the chef can reach the next floor normally or any combination of skipping one step, where order doesn't matter. \n\n-----Input:-----\n- First-line will contain $T$, the number of test cases. Then the test cases follow. \n- Each test case contains a single line of input, two integers $N$. \n\n-----Output:-----\nFor each test case, output in a single line answer as the number of ways.\n\n-----Constraints-----\n- $1 \\leq T \\leq 1000$\n- $1 \\leq N \\leq 10^5$\n\n-----Sample Input:-----\n1\n3\n\n-----Sample Output:-----\n2\n\n-----EXPLANATION:-----\nways: [1,1,1], here chef climb to the next floor, one by one stair.\n[1,2], here chef climb to the next floor, one step first and after that 2 stairs at once.\nNote, [2,1] consider the same as that of [1,2] hence ignored.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn count_ways_to_climb(n: nat) -> (result: nat)\n    requires n > 0,\n    ensures \n        result > 0,\n        result <= n,\n        result >= (n + 1) / 2,\n        (n == 1) ==> (result == 1),\n        (n == 2) ==> (result == 2),\n        (n > 0 && n % 2 == 0) ==> (result == n / 2 + 1),\n        (n > 0 && n % 2 == 1) ==> (result == (n - 1) / 2 + 1),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded_and_plausible\n\n    // #guard_msgs in\n    // #eval count_ways_to_climb 3\n\n    // #guard_msgs in\n    // #eval count_ways_to_climb 4\n\n    // #guard_msgs in\n    // #eval count_ways_to_climb 5\n}"}
{"id": "fvapps_000508", "vc-description": "Indian National Olympiad in Informatics 2016\n\tThere are k types of brackets each with its own opening bracket and closing bracket. We assume that the first pair is denoted by the numbers 1 and k+1, the second by 2 and k+2 and so on. Thus the opening brackets are denoted by 1,2,.., k, and the corresponding closing brackets are denoted by k+1,k+2,..., 2*k respectively.\n\n\tSome sequences with elements from 1,2, ... 2*k form well-bracketed sequences while others don't. A sequence is well-bracketed, if we can match or pair up opening brackets and closing brackets of the same type in such a way that the following holds:\n\n\t 1) every bracket is paired up\n\n\t 2) in each matched pair, the opening bracket occurs before the closing bracket\n\n\t 3) for a matched pair, any other matched pair lies either completely between them or outside them.\n\n\tFor the examples discussed below, let us assume that k = 2. The sequence 1,1,3 is not well-bracketed as one of the two 1's cannot be paired. The sequence 3,1,3,1 is not well-bracketed as there is no way to match the second 1 to a closing bracket occurring after it. The sequence 1,2,3,4 is not well-bracketed as the matched pair 2,4 is neither completely between the matched pair 1,3 nor completely outside it. That is, the matched pairs cannot overlap. The sequence 1,2,4,3,1,3 is well-bracketed. We match the first 1 with the first 3, the 2 with the 4 and the second 1 with the second 3, satisfying all the 3 conditions. If you rewrite these sequences using [,{,],} instead of 1,2,3,4 respectively, this will be quite clear.\n\n\tIn this problem you are given a sequence of brackets, of length N: B[1], .., B[N], where each B[i] is one of the brackets. You are also given an array of Values: V[1],.., V[N].\n\n\tAmong all the subsequences in the Values array, such that the corresponding bracket subsequence in the B Array is a well-bracketed sequence, you need to find the maximum sum. Suppose N = 6, k = 3 and the values of V and B are as follows:\n\ni\t1\t2\t3\t4\t5\t6\nV[i]\t4\t5\t-2\t1\t1\t6\nB[i]\t1\t3\t4\t2\t5\t6\n\n\tThen, the brackets in positions 1,3 form a well-bracketed sequence (1,4) and the sum of the values in these positions is 2 (4 + -2 = 2). The brackets in positions 1,3,4,5 form a well-bracketed sequence (1,4,2,5) and the sum of the values in these positions is 4. Finally, the brackets in positions 2,4,5,6 forms a well-bracketed sequence (3,2,5,6) and the sum of the values in these positions is 13. The sum of the values in positions 1,2,5,6 is 16 but the brackets in these positions (1,3,5,6) do not form a well-bracketed sequence. You can check the best sum from positions whose brackets form a well-bracketed sequence is 13.\n\n-----Input format-----\n\tOne line, which contains (2*N + 2) space separate integers. The first integer denotes N. The next integer is k. The next N integers are V[1],..., V[N]. The last N integers are B[1],.., B[N].\n\n-----Output format-----\n\tOne integer, which is the maximum sum possible satisfying the requirement mentioned above. \n\n-----Test data-----\n\n\t\t1 ≤ k ≤ 7\n\n\t\t-106 ≤ V[i] ≤ 106, for all i\n\n\t\t1 ≤ B[i] ≤ 2*k, for all i.\n\nSubtask 1 (40 Marks) 1 ≤ n ≤ 10.\nSubtask 2 (60 Marks) 1 ≤ n ≤ 700.\n\n-----Sample Input-----\n6 3 4 5 -2 1 1 6 1 3 4 2 5 6\n\n-----Sample Output-----\n13", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_well_bracketed_sum(n: usize, k: usize, values: Vec<i64>, brackets: Vec<usize>) -> (result: i64)\n    requires \n        values.len() == n,\n        brackets.len() == n,\n        k >= 1,\n    ensures\n        n == 1 ==> result == 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result = solve_well_bracketed_sum(6, 3, vec![4, 5, -2, 1, 1, 6], vec![1, 3, 4, 2, 5, 6]);\n    // println!(\"{}\", result);\n}"}
{"id": "fvapps_000510", "vc-description": "Nature photographing may be fun for tourists, but it is one of the most complicated things for photographers. To capture all the facets of a bird, you might need more than one cameras. You recently encountered such a situation.\nThere are $n$ photographers, so there are $n$ cameras in a line on the x-axis. All the cameras are at distinct coordinates. \nYou want to pair up these cameras ($n$ is even) in such a way that the sum of angles subtended on the bird by the pair of cameras is maximized. Formally, let A, B be two cameras, and let P be the bird to be captured by these two cameras. The angle will APB. \nNote: All angles are in radians.\n\n-----Input-----\n- The first line of the input contains an integer $T$ denoting the number of test cases. The description of the test cases follows.\n- The first line of each test case contains an integer $n$.\n- The second line of each test case contains $n$ space-separated integers denoting the $x_i$ coordinates of the cameras.\n- The third line of each test case contains two space-separated integers $P, Q$ denoting the x and y coordinates of the bird respectively.\n\n-----Output-----\nFor each test case, output your answer in a single line. Your answer would be considered correct if its absolute error is less than or equal to 1e-6 of the actual answer. \n\n-----Constraints-----\n- $1 \\le T \\le 10$\n- $2 \\le n \\leq  100$\n- $1 \\le x_i \\leq 300$\n- $0 \\le P \\leq 300$\n- $1 \\le Q \\leq 300$\n\n-----Example Input-----\n2\n2\n0 1\n0 1\n2\n0 1\n100 1\n\n-----Example Output-----\n0.785398163397\n0.000100999899\n\n-----Explanation-----\nNote: $1 \\leq x_i$ is not being satisfied by the sample input, but will be satisfied in the actual test data.\nTestcase 1: There are only 2 cameras, so they have to paired up with each other. And the angle subtended by then is 45 degrees. Converting this to radians gives the output.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_camera_angles(n: usize, cameras: Vec<i32>, bird_x: i32, bird_y: i32) -> (result: f64)\n    requires\n        n >= 2,\n        n % 2 == 0,\n        cameras.len() == n,\n        bird_y > 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    0.0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000511", "vc-description": "Maheshmati and Sangu are playing a game. First, Maheshmati gives Sangu a sequence of N distinct integers a_1, a_2, ..., a_N (not necessarily sorted) and an integer K. Sangu has to create all subsequences of this sequence with length K. For each subsequence, he has to write down the product of K-2 integers: all elements of this subsequence except the minimum and maximum element.\nSangu wins the game if he is able to write down all these numbers and tell Maheshmati their product (modulo 10^9+7, since it can be very large). However, Sangu is a very lazy child and thus wants you to help him win this game. Compute the number Sangu should tell Maheshmati!\n\nInput:\n- The first line of the input contains a single integer T denoting the number of test cases. The description of T test cases follows.\n- The first line of each test case contains two space-separated integers N and K.\n- The second line contains N space-separated integers a_1, a_2, ..., a_N.\n\nOutput:\nFor each test case, print a single line containing one integer — the product of all numbers written down by Sangu modulo 10^9+7.\n\nConstraints:\n- 1 ≤ T ≤ 10\n- 3 ≤ N ≤ 5,000\n- 3 ≤ K ≤ N\n- 1 ≤ a_i ≤ 10,000 for each valid i\n- the numbers a_1, a_2, ..., a_N are pairwise distinct\n\nExample Input:\n1\n4 3 \n1 2 3 4 \n\nExample Output:\n36\n\nExplanation:\nExample case 1: There are four possible subsequences:\n- [1, 2, 3] (Sangu should write down 2.)\n- [1, 3, 4] (Sangu should write down 3.)\n- [1, 2, 4] (Sangu should write down 2.)\n- [2, 3, 4] (Sangu should write down 3.)\nThe required product is 2 * 3 * 2 * 3 = 36.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_game(n: nat, k: nat, arr: Vec<nat>) -> (result: nat)\n    requires \n        n > 0,\n        k > 0,\n        k <= n,\n        arr.len() == n,\n        forall|i: int| 0 <= i < arr.len() ==> arr[i] > 0 && arr[i] <= 1000,\n    ensures\n        result < 1000000007,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000512", "vc-description": "You are given three numbers a, b, c. Write a program to determine the largest number that is less than or equal to c and leaves a remainder b when divided by a.\n\n-----Input:-----\n- First line will contain T, number of testcases. Then the testcases follow.\n- Each testcase contains a single line of input, having three integers a, b, c.\n\n-----Output:-----\n- For each testcase, output in a single line the largest number less than or equal to c.\n\n-----Constraints:-----\n- 1 ≤ T ≤ 100000\n- 0 ≤ b < a < c ≤ 10^18\n\n-----Sample Input:-----\n1\n7 2 10\n\n-----Sample Output:-----\n9", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_remainder(a: nat, b: nat, c: nat) -> (result: nat)\n    requires \n        a > 0,\n        b < a,\n        c > 0,\n    ensures \n        result <= c,\n        result % a == b,\n        result + a > c || (result + a) % a != b,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // println!(\"{}\", solve_remainder(7, 2, 10));\n    // println!(\"{}\", solve_remainder(5, 3, 12));\n    // println!(\"{}\", solve_remainder(10, 5, 100));\n}"}
{"id": "fvapps_000514", "vc-description": "Recently in JEC ants have become huge, the Principal is on a journey to snipe them !!\nPrincipal has limited N practice Bullets to practice so that he can be sure to kill ants.\n- The Practice ground has max length L.\n- There is a Limit X such that if the bullet is fired beyond this, it will destroy and it wont be of any further use.\n- Bullet can be reused if fired in a range strictly less than X.\nHe wants to find minimum number of shots taken to find  the distance X by using N bullets.\n\n-----Input:-----\n- First line will contain T, number of testcases. Then the testcases follow. \n- Each testcase contains of a single line of input, two integers N, L. \n\n-----Output:-----\nFor each testcase, output in a single line answer the minimum number of shots to find the distance X.\n\n-----Constraints-----\n- 1 ≤ T ≤ 10\n- 2 ≤ N,L ≤ 100\n*N is always less than  equal to square root of L\n\n-----Subtasks-----\n- 10 points : N = 1\n- 40 points : N = 2\n- 50 points : Original Constraints.\n\n-----Sample Input:-----\n2\n1 10\n2 10\n\n-----Sample Output:-----\n10\n4\n\n-----EXPLANATION:-----\n- \nThere is only single bullet which is to be fired from distance 1 to 10 to get the distance X so in the worst case it can take up to 10 shots to find the distance X.\n- \nthere are 2 bullets and distance 10 meters suppose if distance X is 10 we can get to that by firing first bullet at 4 then 7 then 9 then  at 10 it will break  it took only 4 turns, and if the distance X was 3, we can get that by firing first bullet at 4 it will get destroyed than we use 2nd bullet at 1 , 2, 3  and 2nd bullet will also break it also took 4 turns. You can check for any position minimum number of turns will be at most 4.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn min_shots_to_find_x(n: nat, l: nat) -> nat\n{\n    if n == 1 {\n        l\n    } else if n == 2 {\n        if l <= 4 { l } else { 4 }\n    } else {\n        l / (n + 1) + 1\n    }\n}\n\nfn min_shots_to_find_x_impl(n: u32, l: u32) -> (result: u32)\n    requires n > 0 && l > 0,\n    ensures \n        result > 0,\n        result <= l,\n        n == 1 ==> result == l", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}\n\nproof fn single_bullet_shots(l: nat)\n    requires l > 0,\n    ensures min_shots_to_find_x(1, l) == l\n{\n    assume(false);\n}\n\nproof fn two_bullets_shots(l: nat) \n    requires l > 0,\n    ensures min_shots_to_find_x(2, l) >= 1\n{\n    assume(false);\n}\n\nproof fn n_bullets_shots(n: nat, l: nat)\n    requires n > 2 && l > 0,\n    ensures min_shots_to_find_x(n, l) * (n + 1) >= l\n{\n    assume(false);\n}\n\nproof fn shots_always_positive(n: nat, l: nat)\n    requires n > 0 && l > 0,\n    ensures min_shots_to_find_x(n, l) > 0\n{\n    assume(false);\n}\n\nproof fn shots_less_than_length(n: nat, l: nat)\n    requires n > 0 && l > 0,\n    ensures min_shots_to_find_x(n, l) <= l\n{\n    assume(false);\n}", "vc-postamble": "\n}\n\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded\n\n    // Example evaluations:\n    // min_shots_to_find_x(1, 10) should return 10\n    // min_shots_to_find_x(2, 10) should return 4\n    // min_shots_to_find_x(3, 16) should return 4\n}"}
{"id": "fvapps_000515", "vc-description": "Given an integer N. Integers A and B are chosen randomly in the range [1..N]. Calculate the probability that the Greatest Common Divisor(GCD) of A and B equals to B.\n\n-----Input-----\nThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows. Each test case consists of a single integer N on a separate line.\n\n-----Output-----\nFor each test case, output a single line containing probability as an irreducible fraction. \n\n-----Example-----\nInput:\n3\n1\n2\n3\n\nOutput:\n1/1\n3/4\n5/9\n\n-----Constraints-----\n\n1<=T<=103\n\n1<=N<=109", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn parse_fraction_parts(result: String) -> (u32, u32);\n\nspec fn gcd_spec(a: u32, b: u32) -> u32;\n\nfn calc_gcd_prob(n: u32) -> (result: String)\n    requires n > 0 && n <= 1000,\n    ensures \n        parse_fraction_parts(result).1 > 0,\n        gcd_spec(parse_fraction_parts(result).0, parse_fraction_parts(result).1) == 1,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "/* Apps difficulty: interview */\n/* Assurance level: unguarded */\n\nfn main() {\n    // println!(\"{}\", calc_gcd_prob(1)); // Should output \"1/1\"\n    // println!(\"{}\", calc_gcd_prob(2)); // Should output \"3/4\"\n    // println!(\"{}\", calc_gcd_prob(3)); // Should output \"5/9\"\n}\n\n}"}
{"id": "fvapps_000516", "vc-description": "The median of a sequence is the element in the middle of the sequence after it is sorted. For a sequence with even size, the median is the average of the two middle elements of the sequence after sorting. For example, for a sequence A = [1, 3, 3, 5, 4, 7, 11], the median is equal to 4, and for A = [2, 3, 4, 5], the median is equal to (3+4)/2 = 3.5.\nFulu is a famous programmer in his country. He wrote the following program (given in pseudocode) for finding the median in a sequence A with length N:\nread(N)\nread(A[0], A[1], ..., A[N-1])\nsort(A)\n# simultaneously remove elements A[K] and A[N mod K] from the array A\n# the order of the remaining N-2 elements is unchanged\nremove(A[K], A[N mod K])\nreturn A[(N-2)/2] # integer division\n\nThe program takes an integer K as a parameter. Fulu can choose this integer arbitrarily between 1 and N-1 inclusive.\nLittle Lima, Fulu's friend, thinks Fulu's program is wrong (as always). As finding one counterexample would be an easy task for Lima (he has already found the sequence A = [34, 23, 35, 514], which is a counterexample for any K ≤ 3), Lima decided to make hacking more interesting. Fulu should give him four parameters S, K, m, M (in addition to N) and Lima should find the lexicographically smallest proper sequence A with length N as a counterexample.\nWe say that a sequence A with length N (0-indexed) is proper if it satisfies the following conditions:\n- it contains only positive integers\n- A_0 + A_1 +A_2 + ... + A_{N-1} = S\n- m ≤ A_i ≤ M for each 0 ≤ i < N\n- the number returned by Fulu's program, ran with the given parameter K, is different from the correct median of the sequence A\nCan you help Lima find the lexicographically smallest counterexample or determine that Fulu's program works perfectly for the given parameters?", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn list_sum(a: Seq<nat>) -> nat\n    decreases a.len()\n{\n    if a.len() == 0 {\n        0\n    } else {\n        a[0] + list_sum(a.skip(1))\n    }\n}", "vc-spec": "fn find_sequence(n: nat, s: nat, k: nat, m: nat, M: nat) -> (result: Option<Vec<nat>>)\n    requires \n        n >= 3,\n        n <= 20,\n        k >= 1,\n        k <= 20,\n        m <= 10,\n        M <= 20,\n        s <= 200,\n        m <= M,\n        k <= n - 2,\n        n * m <= s && s <= n * M,\n    ensures \n        match result {\n            Some(seq) => \n                seq.len() == n &&\n                forall|i: int| 0 <= i < seq.len() ==> m <= seq[i] && seq[i] <= M &&\n                list_sum(seq@) == s,\n            None => true\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000518", "vc-description": "To help Lavanya learn all about binary numbers and binary sequences, her father has bought her a collection of square tiles, each of which has either a 0 or a 1 written on it. Her brother Nikhil has played a rather nasty prank. He has glued together pairs of tiles with 0 written on them. Lavanya now has square tiles with 1 on them and rectangular tiles with two 0's on them, made up of two square tiles with 0 stuck together). Thus, she can no longer make all possible binary sequences using these tiles.\nTo amuse herself, Lavanya has decided to pick a number $N$ and try and construct as many binary sequences of length $N$ as possible using her collection of tiles. For example if $N$ = 1, she can only make the sequence 1. For $N$=2, she can make 11 and 00. For $N$=4, there are 5 possibilities: 0011, 0000, 1001, 1100 and 1111.\nLavanya would like you to write a program to compute the number of arrangements possible with $N$ tiles so that she can verify that she has generated all of them. Since she cannot count beyond 15746, it is sufficient to report this number modulo 15746.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn count_binary_sequences(n: nat) -> (result: nat)\n    requires n >= 1,\n    ensures\n        result < 15746,\n        result >= 0,\n        (n == 1) ==> (result == 1),\n        (n == 2) ==> (result == 2),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: unguarded\n}"}
{"id": "fvapps_000523", "vc-description": "Zonal Computing Olympiad 2015, 29 Nov 2014\n\nWe say that two integers x and y have a variation of at least K, if |x − y| ≥ K (the absolute value of their difference is at least K). Given a sequence of N integers a1,a2,...,aN and K, the total variation count is the number of pairs of elements in the sequence with variation at least K, i.e. it is the size of the set of pairs\n\n{(i,j)|1≤i<j≤N and|ai−aj|≥K} \n\nFor example if K = 1 and the sequence is 3,2,4 the answer is 3. If K = 1 and the sequence is 3, 1, 3 then the answer is 2.\n\nYour task is to write a program that takes a sequence and the value K as input and computes the total variation count.\n\n-----Input format-----\nThe first line contains two positive integers N and K, separated by a space.\n\nThis is followed by a line containing N integers separated by space giving the values\nof the sequence.\n\n-----Output format-----\nA single integer in a single line giving the total variation count.\n\n-----Test data-----\nYou may assume that all integers in the input are in the range 0 to 10^8 inclusive.\n\nSubtask 1 (40 marks) : 1 ≤ N ≤ 4000, 1 ≤ K ≤ 10^8 \nSubtask 2 (60 marks) : 1 ≤ N ≤ 65000, 1 ≤ K ≤ 10^8 \n\n-----Sample Input-----\n3 1 \n3 1 3\n\n-----Sample Output-----\n2", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn abs_diff(x: int, y: int) -> int {\n    if x >= y { x - y } else { y - x }\n}\n\nspec fn count_valid_pairs(sequence: Seq<i32>, k: int, start: int) -> nat\n    decreases sequence.len() - start\n{\n    if start >= sequence.len() {\n        0\n    } else {\n        let count_with_current = count_pairs_from_index(sequence, k, start, start + 1);\n        count_with_current + count_valid_pairs(sequence, k, start + 1)\n    }\n}\n\nspec fn count_pairs_from_index(sequence: Seq<i32>, k: int, i: int, j: int) -> nat\n    decreases sequence.len() - j\n{\n    if j >= sequence.len() {\n        0nat\n    } else {\n        let has_variation: nat = if abs_diff(sequence[i] as int, sequence[j] as int) >= k { 1nat } else { 0nat };\n        has_variation + count_pairs_from_index(sequence, k, i, j + 1)\n    }\n}\n\nfn total_variation_count(n: usize, k: i32, sequence: Vec<i32>) -> (result: usize)\n    requires \n        sequence.len() == n,\n        n > 0,\n        k >= 0,\n    ensures \n        result >= 0,\n        result <= (n * (n - 1)) / 2,\n        result == count_valid_pairs(sequence@, k as int, 0),", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "fvapps_000525", "vc-description": "Bob has got some injury in his leg and due to this he can take exactly M steps in one move. \nBob enters a square field of size NxN. The field is only having one gate(for both entrance and exit) at its one of the corners. Bob started walking along the perimeter of square field.(remember Bob can only take exactly M steps in one move and cannot reverse his direction of motion).\nBob wants to know how many minimum number of moves he needs to come out(i.e. he reaches the same gate from where he entered into the field) from the square field. Tell the answer to Bob ASAP.\nLuckily, you came to know M=N+1.\n\n-----Input-----\n- The first line of the input contains an integer T denoting the number of test cases.\n-  Each test case contains a single integer N denoting the sides of the square.\n\n-----Output-----\n- For each test case, output a single line containing minimum number of moves Bob required to come out from the field.\n\n-----Constraints-----\n- 1 ≤ T ≤ 10000\n- 1 ≤ N ≤ 1000000000\n\n-----Example-----\nInput:\n2\n1\n2\n\nOutput:\n2\n8\n\n-----Explanation-----\nExample case 1.Let four corners of square be (0,0), (0,1), (1,1), (1,0). Let gate be at (0,0). Bob takes 2 steps in one move. Let movement of Bob be as follows (0,0) -> (1,1) -> (0,0). Thus minimum moves needed were 2. \nExample case 2.Let four corners of square be (0,0), (0,2), (2,2), (2,0). Let gate be at (0,0). Bob takes 3 steps in one move. Let movement of Bob be as follows (0,0) -> (2,1) -> (0,2) -> (1,0) -> (2,2) -> (0,1) -> (2,0) -> (1,2) -> (0,0). Thus minimum number of moves needed are 8.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn min_moves_to_exit(n: nat) -> (result: nat)\n    requires n > 0,\n    ensures \n        result > 0,\n        result <= 4 * n,\n        (n % 2 == 0) ==> (result == n * 4),\n        (n % 4 == 3) ==> (result == n),\n        (n % 2 != 0 && n % 4 != 3) ==> (result == n * 2),\n        n == 1 ==> result == 2,\n        n == 2 ==> result == 8,\n        n == 3 ==> result == 3,\n        n == 4 ==> result == 16,\n        n == 7 ==> result == 7,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded_and_plausible\n}"}
{"id": "fvapps_000528", "vc-description": "Chef has just finished the construction of his new garden. He has sown the garden with patches of the most beautiful carpet grass he could find. He has filled it with patches of different color and now he wants to evaluate how elegant his garden is.\nChef's garden looks like a rectangular grid of cells with N rows and M columns. So there are N x M cells in total. In each cell Chef planted grass of some color.\nThe elegance of the garden is defined by the number of squares, composed of at least four garden cells, with edges parallel to the sides of the garden, that have four corner cells of the same color.\nGiven the description of Chef's garden, calculate how many such squares exist.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "type Grid = Vec<Vec<char>>;\n\nfn count_colored_squares(grid: Grid) -> (result: usize)\n    requires grid.len() >= 2,\n    ensures \n        result <= (grid.len() - 1) * (grid.len() - 1) * 4,", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let test1 = vec![vec!['a', 'a'], vec!['a', 'A']];\n    // let result1 = count_colored_squares(test1);\n    // assert(result1 == 0);\n    \n    // let test2 = vec![vec!['a', 'b', 'a'], vec!['b', 'a', 'b'], vec!['a', 'b', 'a']];\n    // let result2 = count_colored_squares(test2);\n    // assert(result2 == 1);\n    \n    // let test3 = vec![vec!['a', 'a', 'b', 'b'], vec!['a', 'a', 'b', 'b'], vec!['b', 'b', 'a', 'a'], vec!['b', 'b', 'a', 'a']];\n    // let result3 = count_colored_squares(test3);\n    // assert(result3 == 4);\n}"}
{"id": "fvapps_000529", "vc-description": "Ram and Shyam are playing a game of Truth and Dare. In this game, Shyam will ask Ram to perform tasks of two types:\n- Truth task: Ram has to truthfully answer a question.\n- Dare task: Ram has to perform a given task.\nEach task is described by an integer. (If a truth task and a dare task are described by the same integer, they are still different tasks.) You are given four lists of tasks:\n- T_r,1, T_r,2, ..., T_r,t_r: the truth tasks Ram can perform.\n- D_r,1, D_r,2, ..., D_r,d_r: the dare tasks Ram can perform.\n- T_s,1, T_s,2, ..., T_s,t_s: the truth tasks Shyam can ask Ram to perform.\n- D_s,1, D_s,2, ..., D_s,d_s: the dare tasks Shyam can ask Ram to perform.\nNote that the elements of these lists are not necessarily distinct, each task may be repeated any number of times in each list.\nShyam wins the game if he can find a task Ram cannot perform. Ram wins if he performs all tasks Shyam asks him to. Find the winner of the game.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn contains_all(tr_list: Seq<i32>, ts_list: Seq<i32>) -> bool {\n    forall|t: i32| ts_list.contains(t) ==> tr_list.contains(t)\n}\n\nfn can_ram_win(tr_list: Vec<i32>, dr_list: Vec<i32>, ts_list: Vec<i32>, ds_list: Vec<i32>) -> (result: String)\n    ensures\n        (result@ == \"yes\"@) || (result@ == \"no\"@),\n        (result@ == \"yes\"@) <==> (\n            contains_all(tr_list@, ts_list@) && \n            contains_all(dr_list@, ds_list@)\n        )", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = can_ram_win(vec![1, 2], vec![1, 3, 2], vec![2], vec![3, 2]);\n    // println!(\"{}\", result1);\n    \n    // let result2 = can_ram_win(vec![1, 2], vec![1, 3, 2], vec![2], vec![3, 2, 4]);\n    // println!(\"{}\", result2);\n    \n    // let result3 = can_ram_win(vec![3, 2, 5], vec![2, 100], vec![2], vec![100]);\n    // println!(\"{}\", result3);\n}"}
{"id": "fvapps_000530", "vc-description": "An encoder encodes the first 16 lowercase English letters using 4 bits each. The first bit (from the left) of the code is 0 if the letter lies among the first 8 letters, else it is 1, signifying that it lies among the last 8 letters. The second bit of the code is 0 if the letter lies among the first 4 letters of those 8 letters found in the previous step, else it's 1, signifying that it lies among the last 4 letters of those 8 letters. Similarly, the third and the fourth bit each signify the half in which the letter lies. \nFor example, the letter j would be encoded as :\n- Among (a,b,c,d,e,f,g,h | i,j,k,l,m,n,o,p), j appears in the second half. So the first bit of its encoding is 1.\n- Now, among (i,j,k,l | m,n,o,p), j appears in the first half. So the second bit of its encoding is 0.\n- Now, among (i,j | k,l), j appears in the first half. So the third bit of its encoding is 0.\n- Now, among (i | j), j appears in the second half. So the fourth and last bit of its encoding is 1.\nSo j's encoding is 1001,\nGiven a binary encoded string S, of length at most 10^5, decode the string. That is, the first 4 bits are the encoding of the first letter of the secret message, the next 4 bits encode the second letter, and so on. It is guaranteed that the string's length is a multiple of 4.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_valid_letter(c: char) -> bool {\n    c == 'a' || c == 'b' || c == 'c' || c == 'd' ||\n    c == 'e' || c == 'f' || c == 'g' || c == 'h' ||\n    c == 'i' || c == 'j' || c == 'k' || c == 'l' ||\n    c == 'm' || c == 'n' || c == 'o' || c == 'p'\n}\n\nspec fn is_binary_char(c: char) -> bool {\n    c == '0' || c == '1'\n}\n\nfn decode_binary_string(s: Vec<char>) -> (result: Vec<char>)\n    requires \n        s.len() % 4 == 0,\n        forall|i: int| 0 <= i < s.len() ==> is_binary_char(s[i]),\n    ensures\n        result.len() == s.len() / 4,\n        forall|i: int| 0 <= i < result.len() ==> is_valid_letter(result[i])", "vc-code": "{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let test1 = vec!['0', '0', '0', '0'];\n    // let result1 = decode_binary_string(test1);\n    // println!(\"{:?}\", result1);\n    //\n    // let test2 = vec!['0', '0', '0', '0', '1', '1', '1', '1'];\n    // let result2 = decode_binary_string(test2);\n    // println!(\"{:?}\", result2);\n    //\n    // let test3 = vec!['1', '0', '0', '1'];\n    // let result3 = decode_binary_string(test3);\n    // println!(\"{:?}\", result3);\n}"}
{"id": "fvapps_000531", "vc-description": "Chef wants to serve mankind by making people immortal by preparing a dish, a dish of life - a dish with the best taste in the universe, one with the smell and splash of fresh water flowing down the springs of the mountain, one with the smell of the best lily flowers of the garden, one that has contained the very essence of life in a real sense. \nThis dish will contain K ingredients that are found only in remote islands amid mountains. For sake of convenience, we enumerate the ingredients by the integers from 1 to K, both inclusive. There are N islands and each of them offers some ingredients. Chef being a little child did not know how to collect the ingredients for the recipe. He went to all the islands and bought all the ingredients offered in each island. Could he possibly have saved some time by skipping some island? If it was not possible for Chef to collect the required ingredients (i.e. all the K ingredients), output \"sad\". If it was possible for him to skip some islands, output \"some\", otherwise output \"all\".\n\n-----Input-----\nFirst line of the input contains an integer T denoting number of test cases. The description of T test cases follow.\nThe first line of each test case contains two space separated integers N, K.\nThe i-th of the next lines will contain first an integer Pi, denoting the number of ingredients grown in the i-th island, followed by Pi distinct integers in the range [1, K]. All the integers are space separated. \n\n-----Output-----\nFor each test case, output a single line containing one of the strings \"sad\", \"all\" or \"some\" (without quotes) according to the situation. \n\n-----Constraints-----\n- 1 ≤ T  ≤ 10\n- 1 ≤ N, K ≤ 105\n- 1 ≤ Pi ≤ K\n- Sum of Pi over all test cases ≤ 106\n\n-----Subtasks-----\nSubtask #1 (30 points)\n- 1 ≤ N, K ≤ 50\n\nSubtask #2 (30 points)\n- 1 ≤ K ≤ 50\n\nSubtask #3 (40 points)\n- original constraints\n\n-----Example-----\nInput\n3\n3 4\n3 1 2 3\n2 1 3\n2 1 2\n2 3\n3 1 2 3\n2 1 3\n2 3\n2 1 2\n2 1 3\n\nOutput\nsad\nsome\nall\n\n-----Explanation-----\nExample 1. The ingredient 4 is not available in any island, so Chef can't make the dish of life. Hence, the answer is \"sad\".\nExample 2. Chef can just go to the first island and collect all the three ingredients required. He does not need to visit the second island. So, the answer is \"some\".\nExample 3. Chef has to visit both the islands in order to obtain all the three ingredients. So, the answer is \"all\".", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "type Island = Vec<nat>;\n\nenum RecipeResult {\n    Sad,\n    Some,\n    All,\n}\n\nfn solve_recipes(islands: Vec<Island>, num_ingredients: nat) -> (result: RecipeResult)\n    requires num_ingredients >= 1,\n    ensures match result {\n        RecipeResult::Sad => true,\n        RecipeResult::Some => true,\n        RecipeResult::All => true,\n    }", "vc-code": "{\n    // impl-start\n    assume(false);\n    RecipeResult::Sad\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: unguarded\n\n    // #[cfg(test)]\n    // mod tests {\n    //     use super::*;\n    //     \n    //     #[test]\n    //     fn test_solve_recipes() {\n    //         assert_eq!(solve_recipes(vec![vec![3, 1, 2, 3], vec![2, 1, 3], vec![2, 1, 2]], 4), RecipeResult::Sad);\n    //         assert_eq!(solve_recipes(vec![vec![3, 1, 2, 3], vec![2, 1, 3]], 3), RecipeResult::Some);\n    //         assert_eq!(solve_recipes(vec![vec![2, 1, 2], vec![2, 1, 3]], 3), RecipeResult::All);\n    //     }\n    // }\n}"}
{"id": "fvapps_000534", "vc-description": "The chef is trying to solve some pattern problems, Chef wants your help to code it. Chef has one number K to form a new pattern. Help the chef to code this pattern problem.\n\n-----Input:-----\n- First-line will contain $T$, the number of test cases. Then the test cases follow. \n- Each test case contains a single line of input, one integer $K$. \n\n-----Output:-----\nFor each test case, output as the pattern.\n\n-----Constraints-----\n- $1 \\leq T \\leq 100$\n- $1 \\leq K \\leq 100$\n\n-----Sample Input:-----\n4\n1\n2\n3\n4\n\n-----Sample Output:-----\n*\n*\n*\n*\n***\n***\n*\n*\n***\n***\n*****\n*****\n*\n*\n***\n***\n*****\n*****\n*******\n*******\n\n-----EXPLANATION:-----\nNo need, else pattern can be decode easily.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn generate_pattern(k: usize) -> (result: Vec<String>)\n    requires k > 0,\n    ensures\n        result.len() == 2 * k,\n        forall|i: int| 0 <= i < k ==> #[trigger] result[2*i as int] == #[trigger] result[2*i as int + 1]", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "}\n\nfn main() {}"}
{"id": "fvapps_000535", "vc-description": "In a fictitious city of CODASLAM there were many skyscrapers. The mayor of the city decided to make the city beautiful and for this he decided to arrange the skyscrapers in descending order of their height, and the order must be strictly decreasing but he also didn't want to waste much money so he decided to get the minimum cuts possible. Your job is to output the minimum value of cut that is possible to arrange the skyscrapers in descending order.\n\n-----Input-----\n\n*First line of input is the number of sky-scrappers in the city\n*Second line of input is the height of the respective sky-scrappers\n\n-----Output-----\n\n* Your output should be the minimum value of cut required to arrange these sky-scrappers in descending order.\n\n-----Example-----\nInput:\n5\n1 2 3 4 5\n\nOutput:\n8\n\nBy:\nChintan,Asad,Ashayam,Akanksha", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn min_cuts_for_skyscrapers(n: usize, heights: Seq<usize>) -> usize\n    decreases heights.len()\n{\n    if heights.len() <= 1 {\n        0\n    } else {\n        // Placeholder specification - actual cutting algorithm would be complex\n        0\n    }\n}\n\nfn min_cuts_for_skyscrapers_exec(n: usize, heights: Vec<usize>) -> (result: usize)\n    requires \n        n > 0,\n        heights.len() == n,\n    ensures \n        result == min_cuts_for_skyscrapers(n, heights@),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\nproof fn cuts_non_negative(n: usize, heights: Vec<usize>)\n    requires n > 0, heights.len() == n,\n    ensures min_cuts_for_skyscrapers(n, heights@) >= 0,\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn single_building_no_cuts(h: usize)\n    ensures min_cuts_for_skyscrapers(1, seq![h]) == 0,\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn cuts_non_negative_multi(n: usize, heights: Vec<usize>)\n    requires n >= 2, heights.len() == n,\n    ensures min_cuts_for_skyscrapers(n, heights@) >= 0,\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: unguarded\n    \n    // let heights1 = vec![1, 2, 3, 4, 5];\n    // let result1 = min_cuts_for_skyscrapers_exec(5, heights1);\n    // assert(result1 == 8);\n    \n    // let heights2 = vec![5, 4, 3, 2, 1];\n    // let result2 = min_cuts_for_skyscrapers_exec(5, heights2);\n    // assert(result2 == 0);\n}"}
{"id": "fvapps_000539", "vc-description": "Johnny was asked by his math teacher to compute nn (n to the power of n, where n is an integer), and has to read his answer out loud. This is a bit of a tiring task, since the result is probably an extremely large number, and would certainly keep Johnny occupied for a while if he were to do it honestly. But Johnny knows that the teacher will certainly get bored when listening to his answer, and will sleep through most of it! So, Johnny feels he will get away with reading only the first k digits of the result before the teacher falls asleep, and then the last k digits when the teacher wakes up.\n\nWrite a program to help Johnny to compute the digits he will need to read out.\n\n-----Input-----\nThe first line contains t, the number of test cases (about 30000). Then t test cases follow.\nEach test case consists of one line containing two numbers n and k (1 ≤ n ≤ 109, 1 ≤ k ≤ 9). It is guaranteed that k is not more than the number of digits of nn.\n\n-----Output-----\nFor each test case, print out one line containing two numbers, separated by a space, which are the first and the last k digits of nn.\n\n-----Example-----\nInput\n2\n4 2\n9 3\n\nOutput\n25 56\n387 489", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn is_digit_char(c: char) -> bool {\n    '0' <= c && c <= '9'\n}\n\nspec fn string_all_digits(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> is_digit_char(s[i])\n}", "vc-spec": "fn solve(n: u32, k: u32) -> (result: (String, String))\n    requires \n        n >= 2,\n        k >= 1,\n        n <= 1000000,\n        k <= 10,\n    ensures\n        string_all_digits(result.0@),\n        string_all_digits(result.1@),\n        result.0@.len() == k,\n        result.1@.len() == k,\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n\nfn string_to_nat(s: String) -> (result: u32) {\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-code": "", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded_and_plausible\n}"}
{"id": "fvapps_000543", "vc-description": "The city of Siruseri is impeccably planned. The city is divided into a rectangular array of cells with M rows and N columns. Each cell has a metro station. There is one train running left to right and back along each row, and one running top to bottom and back along each column. Each trains starts at some time T and goes back and forth along its route (a row or a column) forever.\nOrdinary trains take two units of time to go from one station to the next. There are some fast trains that take only one unit of time to go from one station to the next. Finally, there are some slow trains that take three units of time to go from one station the next. You may assume that the halting time at any station is negligible.\nHere is a description of a metro system with 3 rows and 4 columns:\n\nS(1)  F(2)  O(2)  F(4)\nF(3)    .     .     .     .\nS(2)    .     .     .     .\nO(2)    .     .     .     .\n\nThe label at the beginning of each row/column indicates the type of train (F for fast, O for ordinary, S for slow) and its starting time. Thus, the train that travels along row 1 is a fast train and it starts at time 3. It starts at station (1, 1) and moves right, visiting the stations along this row at times 3, 4, 5 and 6 respectively. It then returns back visiting the stations from right to left at times 6, 7, 8 and 9. It again moves right now visiting the stations at times 9, 10, 11 and 12, and so on. Similarly, the train along column 3 is an ordinary train starting at time 2. So, starting at the station (3,1), it visits the three stations on column 3 at times 2, 4 and 6, returns back to the top of the column visiting them at times 6,8 and 10, and so on.\nGiven a starting station, the starting time and a destination station, your task is to determine the earliest time at which one can reach the destination using these trains.\nFor example suppose we start at station (2,3) at time 8 and our aim is to reach the station (1,1). We may take the slow train of the second row at time 8 and reach (2,4) at time 11. It so happens that at time 11, the fast train on column 4 is at (2,4) travelling upwards, so we can take this fast train and reach (1,4) at time 12. Once again we are lucky and at time 12 the fast train on row 1 is at (1,4), so we can take this fast train and reach (1, 1) at time 15. An alternative route would be to take the ordinary train on column 3 from (2,3) at time 8 and reach (1,3) at time 10. We then wait there till time 13 and take the fast train on row 1 going left, reaching (1,1) at time 15. You can verify that there is no way of reaching (1,1) earlier than that.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_metro_system(m: usize, n: usize, row_trains: Vec<(usize, usize)>, \n                      col_trains: Vec<(usize, usize)>, start_x: usize, start_y: usize, \n                      start_time: usize, end_x: usize, end_y: usize) -> (result: usize)\n    requires \n        m > 0,\n        n > 0,\n        row_trains.len() > 0,\n        col_trains.len() > 0,\n        start_x <= m,\n        start_y <= n,\n        end_x <= m,\n        end_y <= n,\n    ensures \n        result >= start_time,\n        (start_x == end_x && start_y == end_y) ==> result == start_time,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: unguarded\n}"}
{"id": "fvapps_000544", "vc-description": "Taxis of Kharagpur are famous for making sharp turns. You are given the coordinates where a particular taxi was on a 2-D planes at N different moments: (x1, y1), (x2, y2), ..., (xN, yN). In between these coordinates, the taxi moves on a straight line. A turn at the i-th (2 ≤ i ≤ N-1) coordinate is said to be a sharp turn if the angle by which it turns at Point B = (xi, yi) when going from coordinates A = (xi-1, yi-1) to C = (xi+1, yi+1) via (xi, yi) is greater than 45 degrees. ie. suppose you extend the line segment AB further till a point D, then the angle DBC would be greater than 45 degrees.\nYou have to identify whether the taxi made a sharp turn somewhere or not (Please look at Output section for details). If it made a sharp turn, also identify whether it is possible to change the coordinates at one of the N moments to make sure that the taxi doesn't make any sharp turn. Note that all the N pairs of coordinates (including the new coordinates) should be integers and distinct and should have their x and y coordinates at least 0 and at most 50.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn solve_taxi_turns_spec(coords: Seq<(i32, i32)>) -> u8 {\n    0 /* placeholder */\n}\n\nfn solve_taxi_turns(coords: Vec<(i32, i32)>) -> (result: u8)\n    requires \n        coords.len() >= 3,\n        coords.len() <= 50,\n    ensures\n        result == 0 || result == 1 || result == 2,\n        result == solve_taxi_turns_spec(coords@),", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000545", "vc-description": "Chef is the judge of a competition. There are two players participating in this competition — Alice and Bob.\nThe competition consists of N races. For each i (1 ≤ i ≤ N), Alice finished the i-th race in Ai minutes, while Bob finished it in Bi minutes. The player with the smallest sum of finish times wins. If this total time is the same for Alice and for Bob, a draw is declared.\nThe rules of the competition allow each player to choose a race which will not be counted towards their total time. That is, Alice may choose an index x and her finish time in the race with this index will be considered zero; similarly, Bob may choose an index y and his finish time in the race with this index will be considered zero. Note that x can be different from y; the index chosen by Alice does not affect Bob's total time or vice versa.\nChef, as the judge, needs to announce the result of the competition. He knows that both Alice and Bob play optimally and will always choose the best option. Please help Chef determine the result!", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn seq_sum(lst: Seq<nat>) -> nat \n    decreases lst.len()\n{\n    if lst.len() == 0 {\n        0\n    } else {\n        lst[0] + seq_sum(lst.skip(1))\n    }\n}\n\nfn determine_winner(n: usize, alice: Vec<usize>, bob: Vec<usize>) -> (result: String)\n    requires \n        n >= 2,\n        alice.len() == n,\n        bob.len() == n,\n    ensures \n        result.view() == \"Alice\".view() || result.view() == \"Bob\".view() || result.view() == \"Draw\".view()", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = determine_winner(5, vec![3, 1, 3, 3, 4], vec![1, 6, 2, 5, 3]);\n    // println!(\"{}\", result1); // Should print \"Alice\"\n    \n    // let result2 = determine_winner(5, vec![1, 6, 2, 5, 3], vec![3, 1, 3, 3, 4]);\n    // println!(\"{}\", result2); // Should print \"Bob\"\n    \n    // let result3 = determine_winner(3, vec![4, 1, 3], vec![2, 2, 7]);\n    // println!(\"{}\", result3); // Should print \"Draw\"\n}"}
{"id": "fvapps_000547", "vc-description": "Chef loves to play chess, so he bought a new chessboard with width M and height N recently.\nChef considers a chessboard correct if its width (number of columns) is equal to its height (number of rows) and each cell has no side-adjacent cell of the same color (this is the so-called \"chess order\" which you can see in real-world chessboards). Chef's chessboard does not have to be a correct chessboard (in particular, it may have N≠M).\nA sub-board of Chef's chessboard is a rectangular piece of this board with an arbitrarily chosen top left and bottom right cell (possibly equal to the original chessboard). Every sub-board is also a chessboard.\nChef can invert some cells; inverting a cell means changing its color from white to black or from black to white. After inverting those cells, he wants to cut the maximum correct sub-board out of the original chessboard.\nChef has not yet decided how many cells he would like to invert. Now he wonders about the answers to Q question. In the i-th question (1≤i≤Q), he is allowed to invert at most ci cells (possibly zero); he would like to know the side length of the largest possible correct sub-board of his chessboard. Help Chef answer these questions.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn min_usize(a: usize, b: usize) -> usize {\n    if a <= b { a } else { b }\n}\n\nfn max_chess_subboard(n: usize, m: usize, board: Vec<Vec<u8>>, queries: Vec<usize>) -> (result: Vec<usize>)\n    requires\n        n > 0,\n        m > 0,\n        board.len() == n,\n        forall|i: int| 0 <= i < board.len() ==> board[i].len() == m,\n        queries.len() > 0,\n        forall|i: int, j: int| 0 <= i < board.len() && 0 <= j < board[i].len() ==> (board[i][j] == 0 || board[i][j] == 1),\n    ensures\n        result.len() == queries.len(),\n        forall|i: int| 0 <= i < result.len() ==> 1 <= result[i] && result[i] <= min_usize(n, m),\n        forall|i: int, j: int| 0 <= i < j < result.len() && queries[i] <= queries[j] ==> result[i] <= result[j],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000549", "vc-description": "Coal Company\n\nThe Tunisian Coal Mining company uses a train to ferry out coal blocks from its coal mines. The train has N containers numbered from 1 to N which need to\n\nbe filled with blocks of coal. Assume there are infinite coal blocks. The containers are arranged in increasing order of capacity, and the ith container\n\nhas capacity i. Every container has a specific loading cost ci. The workers fill the containers in rounds. In every round, they choose a subset of\n\ncontainers and load them with coal blocks. This subset should be such that each subsequent container chosen in a round should be more spacious than the\n\nprevious one. Also, the difference in loading cost of consecutive containers should be at least K.\n\nWhat is the least number of rounds in which all containers can be filled?\n\nInput: The first line contains the number of test cases T. T test cases follow.\nEach case contains an integer N and K on the first line, followed by integers c1,...,cn on the second line.\n1 <= T <= 100, 1 <= N <= 300, 1 <= ci <= 1000, 1 <= K <= 1000\n\nOutput: Output T lines, one for each test case, containing the minimum number of rounds in which all containers could be filled.\n\nExample:\nInput: 2, 3 2, 5 4 7, 5 1, 5 3 4 5 6\nOutput: 2, 1\n\nExplanation: For the first example, workers can fill the containers of cost 5 and 7 in the first round and the container with cost 4 in the next round. Note that the containers with cost 5 and 4 cannot be filled consecutively because the loading costs should differ by at least K (which is 2). Also, the containers cannot be filled in order 5, 7, 4 in one round because the containers filled in a round should be in increasing capacity.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_coal_containers(n: usize, k: usize, costs: Vec<usize>) -> (result: usize)\n    requires \n        n > 0,\n        k > 0,\n        costs.len() == n,\n        forall|i: int| 0 <= i < costs.len() ==> costs[i] >= 1 && costs[i] <= 1000,\n    ensures \n        result >= 1,\n        result <= n,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded_and_plausible\n\n    // #eval solve_coal_containers(3, 2, vec![5, 4, 7]) should return 2\n    // #eval solve_coal_containers(5, 1, vec![5, 3, 4, 5, 6]) should return 1\n}"}
{"id": "fvapps_000550", "vc-description": "If you didn't copy assignments during your engineering course, did you even do engineering?\nThere are Q students in Chef's class. Chef's teacher has given the students a simple assignment:\nWrite a function that takes as arguments an array A containing only unique elements and a number X guaranteed to be present in the array and returns the (1-based) index of the element that is equal to X.\nThe teacher was expecting a linear search algorithm, but since Chef is such an amazing programmer, he decided to write the following binary search function:\ninteger binary_search(array a, integer n, integer x):\ninteger low, high, mid\nlow := 1\nhigh := n\nwhile low ≤ high:\nmid := (low + high) / 2\nif a[mid] == x:\nbreak\nelse if a[mid] is less than x:\nlow := mid+1\nelse:\nhigh := mid-1\nreturn mid\n\nAll of Chef's classmates have copied his code and submitted it to the teacher.\nChef later realised that since he forgot to sort the array, the binary search algorithm may not work. Luckily, the teacher is tired today, so she asked Chef to assist her with grading the codes. Each student's code is graded by providing an array A and an integer X to it and checking if the returned index is correct. However, the teacher is lazy and provides the exact same array to all codes. The only thing that varies is the value of X.\nChef was asked to type in the inputs. He decides that when typing in the input array for each code, he's not going to use the input array he's given, but an array created by swapping some pairs of elements of this original input array. However, he cannot change the position of the element that's equal to X itself, since that would be suspicious.\nFor each of the Q students, Chef would like to know the minimum number of swaps required to make the algorithm find the correct answer.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn contains_value(arr: Seq<i32>, val: i32) -> bool {\n    exists|i: int| 0 <= i < arr.len() && arr[i] == val\n}\n\nspec fn all_distinct(arr: Seq<i32>) -> bool {\n    forall|i: int, j: int| 0 <= i < arr.len() && 0 <= j < arr.len() && i != j ==> arr[i] != arr[j]\n}\n\nfn find_min_swaps(arr: Vec<i32>, queries: Vec<i32>) -> (result: Vec<i32>)\n    requires \n        arr.len() > 0,\n        queries.len() > 0,\n        all_distinct(arr@),\n        forall|q: int| 0 <= q < queries.len() ==> contains_value(arr@, queries[q]),\n    ensures\n        result.len() == queries.len(),\n        forall|i: int| 0 <= i < result.len() ==> (result[i] == -1 || result[i] >= 0),\n        forall|i: int| 0 <= i < result.len() && arr.len() <= 10 ==> (result[i] == -1 || result[i] < arr.len()),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000551", "vc-description": "Chef likes strings a lot but he likes palindromic strings more. Today, Chef has two strings A and B, each consisting of lower case alphabets.\n\nChef is eager to know whether it is possible to choose some non empty strings s1 and s2 where s1 is a substring of A, s2 is a substring of B such that s1 + s2 is a palindromic string. Here '+' denotes the concatenation between the strings.\nNote:\nA string is a palindromic string if it can be read same both forward as well as backward. To know more about palindromes click here.\n\n-----Input-----\n- First line of input contains a single integer T denoting the number of test cases.\n- For each test case:\n\n- First line contains the string A\n- Second line contains the string B.\n\n-----Output-----\nFor each test case, Print \"Yes\" (without quotes) if it possible to choose such strings s1 & s2. Print \"No\" (without quotes) otherwise.\n\n-----Constraints-----\n- 1 ≤ T ≤ 10 \n- 1 ≤ |A|, |B| ≤ 1000 \n\n-----Subtasks-----\n-  Subtask 1: 1 ≤ |A|, |B| ≤ 10 : ( 40 pts )\n-  Subtask 2: 1 ≤ |A|, |B| ≤ 1000 : ( 60 pts )\n\n-----Example-----Input\n3\nabc\nabc\na\nb\nabba\nbaab\n\nOutput\nYes\nNo\nYes\n\n-----Explanation-----\n- Test 1: One possible way of choosing s1 & s2 is s1 = \"ab\", s2 = \"a\" such that s1 + s2 i.e \"aba\" is a palindrome.\n- Test 2: There is no possible way to choose s1 & s2 such that s1 + s2 is a palindrome.\n- Test 3: You can figure it out yourself.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn check_palindrome_possible(s1: String, s2: String) -> (result: String)\n    ensures \n        result@ == seq!['Y', 'e', 's'] || result@ == seq!['N', 'o'],\n        s1@.len() > 0 && s2@.len() > 0 && \n        (exists|c: char| s1@.contains(c) && s2@.contains(c)) ==> result@ == seq!['Y', 'e', 's'],\n        s1@ == s2@ && s1@.len() > 0 ==> result@ == seq!['Y', 'e', 's']", "vc-code": "{\n    // impl-start\n    assume(false);\n    \"No\".to_string()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // println!(\"{}\", check_palindrome_possible(\"abc\".to_string(), \"abc\".to_string()));\n    // println!(\"{}\", check_palindrome_possible(\"a\".to_string(), \"b\".to_string()));\n    // println!(\"{}\", check_palindrome_possible(\"abba\".to_string(), \"baab\".to_string()));\n}"}
{"id": "fvapps_000552", "vc-description": "Chef's new hobby is painting, but he learned the fact that it's not easy to paint 2D pictures in a hard way, after wasting a lot of canvas paper, paint and of course time. From now on, he decided to paint 1D pictures only.\nChef's canvas is N millimeters long and is initially all white. For simplicity, colors will be represented by an integer between 0 and 105. 0 indicates white. The picture he is envisioning is also N millimeters long and the ith millimeter consists purely of the color Ci. Unfortunately, his brush isn't fine enough to paint every millimeter one by one. The brush is 3 millimeters wide and so it can only paint three millimeters at a time with the same color. Painting over the same place completely replaces the color by the new one. Also, Chef has lots of bottles of paints of each color, so he will never run out of paint of any color.\nChef also doesn't want to ruin the edges of the canvas, so he doesn't want to paint any part beyond the painting. This means, for example, Chef cannot paint just the first millimeter of the canvas, or just the last two millimeters, etc.\nHelp Chef by telling him whether he can finish the painting or not with these restrictions.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn has_three_consecutive_helper(arr: Seq<i32>, i: int) -> bool {\n    1 <= i < arr.len() - 1 && arr[i-1] == arr[i] && arr[i] == arr[i+1]\n}\n\nspec fn has_three_consecutive(arr: Seq<i32>) -> bool {\n    exists|i: int| #[trigger] has_three_consecutive_helper(arr, i)\n}", "vc-spec": "fn can_chef_paint(arr: Vec<i32>) -> (result: bool)\n    requires \n        arr.len() >= 3,\n        forall|i: int| 0 <= i < arr.len() ==> 1 <= arr[i] && arr[i] <= 100000,\n    ensures \n        result <==> has_three_consecutive(arr@)", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let test1 = vec![1, 5, 5, 5];\n    // let result1 = can_chef_paint(test1);\n    // println!(\"{}\", if result1 { \"Yes\" } else { \"No\" }); // Should print \"Yes\"\n    \n    // let test2 = vec![1, 1, 1, 5];\n    // let result2 = can_chef_paint(test2);\n    // println!(\"{}\", if result2 { \"Yes\" } else { \"No\" }); // Should print \"Yes\"\n    \n    // let test3 = vec![5, 5, 2];\n    // let result3 = can_chef_paint(test3);\n    // println!(\"{}\", if result3 { \"Yes\" } else { \"No\" }); // Should print \"No\"\n}"}
{"id": "fvapps_000553", "vc-description": "Kefaa has developed a novel decomposition of a tree. He claims that this decomposition solves many difficult problems related to trees. However, he doesn't know how to find it quickly, so he asks you to help him.\nYou are given a tree with $N$ vertices numbered $1$ through $N$. Let's denote an edge between vertices $u$ and $v$ by $(u, v)$. The triple-tree decomposition is a partition of edges of the tree into unordered triples of edges $(a, b), (a, c), (a, d)$ such that $a \\neq b \\neq c \\neq d$. Each edge must belong to exactly one triple.\nHelp Kefaa with this problem — find a triple-tree decomposition of the given tree or determine that no such decomposition exists.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_triple_tree_decomposition(n: usize, edges: Vec<(usize, usize)>) -> (result: Vec<String>)\n    requires\n        n >= 2,\n        edges.len() == n - 1,\n    ensures\n        result.len() >= 1,\n        (n - 1) % 3 != 0 ==> result.len() == 1,\n        result.len() > 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000554", "vc-description": "Sandu, a teacher in Chefland introduced his students to a new sequence i.e.\n0,1,0,1,2,0,1,2,3,0,1,2,3,4........\nThe Sequence starts from 0 and increases by one till i(initially i equals to 1), then repeat itself with i changed to i+1\nStudents being curious about the sequence asks the Nth element of the sequence. Help Sandu to answer the Students\n\n-----Input:-----\n- The first-line will contain T, the number of test cases. Then the test case follows. \n- Each test case contains a single numbers N.\n\n-----Output:-----\nPrint the Nth element of the sequence\n\n-----Constraints-----\n- 1 ≤ T ≤ 1000\n- 1 ≤ N  ≤ 10^18\n\n-----Sample Input:-----\n5\n8\n9\n20\n32\n109\n\n-----Sample Output:-----\n2\n3\n5\n4\n4", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn find_nth_sequence_element(n: nat) -> (result: nat)\n    requires n > 0,\n    ensures result < n", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // #eval find_nth_sequence_element 8\n    // #eval find_nth_sequence_element 9\n    // #eval find_nth_sequence_element 20\n}"}
{"id": "fvapps_000557", "vc-description": "Today is Chef's birthday. His mom has surprised him with truly fruity gifts: 2 fruit baskets. The first basket contains N apples, and the second one contains M oranges. Chef likes apples and oranges very much but he likes them equally, and therefore, wants to have the minimum possible difference between the number of apples and oranges he has. To do so, he can purchase 1 apple or 1 orange by paying exactly 1 gold coin (that's some expensive fruit, eh?). Chef can purchase fruits at most K times (as he has only K gold coins in his pocket) to make the difference the minimum possible.\nOur little Chef is busy in celebrating his birthday to the fullest, and therefore, he has handed this job to his best friend — you. Can you help him by finding the minimum possible difference he can achieve between the number of apples and orange he owns?\n\n-----Input-----\nThe first line of input contains a single integer T denoting the number of test cases. The first and only line of each test case contains 3 space separated integers — N, M and K — denoting the number of apples, number of oranges, and number of gold coins our little Chef has.\n\n-----Output-----\nFor each test case, output the minimum possible difference between the number of apples and oranges that Chef can achieve.\n\n-----Constraints-----\n- 1 ≤ T ≤ 100\n- 1 ≤ N, M, K ≤ 100\n\n-----Example-----Input\n3\n3 4 1\n5 2 1\n3 4 3\n\nOutput\n0\n2\n0\n\n-----Explanation-----\n- Test 1: Chef will buy 1 apple by paying 1 gold coin and will have equal number of apples and oranges. \n- Test 2: Chef will buy 1 orange by paying 1 gold coin and will have 5 apples and 3 oranges.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn abs_diff(a: nat, b: nat) -> nat {\n    if a >= b { \n        (a - b) as nat \n    } else { \n        (b - a) as nat \n    }\n}", "vc-helpers": "", "vc-spec": "fn min_fruit_diff(apples: u32, oranges: u32, gold: u32) -> (result: u32)\n    ensures \n        result <= abs_diff(apples as nat, oranges as nat),\n        (apples == oranges) ==> (result == 0),\n        (gold == 0) ==> (result == abs_diff(apples as nat, oranges as nat)),\n        (gold >= abs_diff(apples as nat, oranges as nat)) ==> (result <= 1)", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let result1 = min_fruit_diff(3, 4, 1);\n    // assert(result1 == 0);\n    // \n    // let result2 = min_fruit_diff(5, 2, 1);\n    // assert(result2 == 2);\n    // \n    // let result3 = min_fruit_diff(3, 4, 3);\n    // assert(result3 == 0);\n}"}
{"id": "fvapps_000558", "vc-description": "After acquiring an extraordinary amount of knowledge through programming contests, Malvika decided to harness her expertise to train the next generation of Indian programmers. So, she decided to hold a programming camp. In the camp, she held a discussion session for n members (n-1 students, and herself). They are sitting in a line from left to right numbered through 1 to n.\n\nMalvika is sitting in the nth spot. She wants to teach m topics of competitive programming to the students. As the people taking part in the camp are all newbies, they know none of the topics being taught, i.e., initially, the first n - 1 people in the line know none of the topics, while the nth knows all of them.\n\nIt takes one hour for a person to learn a topic from his neighbour. Obviously, one person cannot both teach a topic as well as learn one during the same hour. That is, in any particular hour, a person can either teach a topic that he knows to one of his neighbors, or he can learn a topic from one of his neighbors, or he can sit idly. It is also obvious that if person x is learning from person y at a particular hour, then person y must be teaching person x at that hour.\n\nAlso, note that people can work parallely too, i.e., in the same hour when the 4th person is teaching the 3rd person, the 1st person can also teach the 2nd or learn from 2nd.\n\nFind out the minimum number of hours needed so that each person learns all the m topics.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_training_camp(n: nat, m: nat) -> (result: nat)\n    requires n >= 1,\n    ensures \n        result >= 0,\n        n == 1 ==> result == 0,\n        n == 2 ==> result == m,\n        n > 2 && m == 0 ==> result == (n - 3)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "}\n\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded_and_plausible\n\n    // Example test cases:\n    // solve_training_camp(2, 1) should return 1\n    // solve_training_camp(3, 2) should return 4  \n    // solve_training_camp(1, 5) should return 0\n}"}
{"id": "fvapps_000560", "vc-description": "Chef found a strange string yesterday - a string of signs s, where each sign is either a '<', '=' or a '>'. Let N be the length of this string. Chef wants to insert N + 1 positive integers into this sequence and make it valid. A valid sequence is a sequence where every sign is preceded and followed by an integer, and the signs are correct. That is, if a sign '<' is preceded by the integer a and followed by an integer b, then a should be less than b. Likewise for the other two signs as well. \nChef can take some positive integers in the range [1, P] and use a number in the range as many times as he wants.\nHelp Chef find the minimum possible P with which he can create a valid sequence.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn find_min_valid_sequence(s: &str) -> u32 {\n    1\n}", "vc-code": "// Placeholder implementation - not the actual algorithm", "vc-postamble": "proof fn output_positive(s: &str)\n    ensures find_min_valid_sequence(s) >= 1\n{\n}\n\nproof fn equals_removal(s: &str, no_equals: &str)\n    ensures find_min_valid_sequence(s) == find_min_valid_sequence(no_equals)\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn empty_string()\n    ensures find_min_valid_sequence(\"\") == 1\n{\n}\n\nproof fn single_equals()\n    ensures find_min_valid_sequence(\"=\") == 1\n{\n}\n\nproof fn multiple_equals()\n    ensures find_min_valid_sequence(\"===\") == 1\n{\n}\n\n}\n\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded_and_plausible\n    \n    // assert(find_min_valid_sequence(\"<<<\") == 4);\n    // assert(find_min_valid_sequence(\"<><\") == 2);\n    // assert(find_min_valid_sequence(\"<=>\") == 2);\n    // assert(find_min_valid_sequence(\"<=<\") == 3);\n}"}
{"id": "fvapps_000561", "vc-description": "You came across this story while reading a book. Long a ago when the modern entertainment systems did not exist people used to go to watch plays in theaters, where people would perform live in front of an audience. There was a beautiful actress who had a disability she could not pronounce the character 'r'. To win her favours which many have been denied in past, you decide to write a whole play without the character 'r'. Now you have to get the script reviewed by the editor before presenting it to her.\nThe editor was flattered by the script and agreed to you to proceed. The editor will edit the script in this way to suit her style. For each word replace it with a sub-sequence of itself such that it contains the character 'a'. \nA subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements Wikipedia \nNow given a script with N words, for each word in the script you wish to know the number of subsequences with which it can be replaced. \n\n-----Input:-----\n- First-line will contain N, the number of words in the script. Then next N line with one test case each. \n- Each test case contains a single word W_i\n\n-----Output:-----\nFor each test case, output in a single line number of subsequences with which it can be replaced. \n\n-----Constraints-----\n- 1 ≤ N ≤ 1000\n- 1 ≤ length of W_i ≤ 20\n- W_i on contains lowercase english alphabets and does not have the character 'r'\n\n-----Sample Input 1:-----\n2\nabc\naba\n\n-----Sample Output 1:-----\n4\n6\n\n-----EXPLANATION:-----\nThis subsequences with which abc can be replaed : {a,ab,ac,abc}. \nThis subsequences with which aba can be replaed : {a,ab,aba,a,ba,a}. \n\n-----Sample Input 2:-----\n3\nabcde\nabcdea\nxyz\n\n-----Sample Output 2:-----\n16\n48\n0", "vc-preamble": "use vstd::prelude::*;\nuse vstd::arithmetic::power2::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn count_valid_subsequences(words: Vec<Seq<char>>) -> (result: Vec<nat>)\n    ensures\n        result.len() == words.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] >= 0,\n        forall|i: int| 0 <= i < words.len() ==>\n            (forall|j: int| 0 <= j < words[i].len() ==> words[i][j] != 'a') ==>\n            result[i] == 0,\n        forall|i: int| 0 <= i < words.len() ==>\n            (forall|j: int| 0 <= j < words[i].len() ==> words[i][j] == 'a') ==>\n            result[i] == (pow2(words[i].len()) - 1),\n        forall|i: int| 0 <= i < words.len() ==>\n            result[i] < pow2(words[i].len())", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000562", "vc-description": "Not everyone probably knows that Chef has younder brother Jeff. Currently Jeff learns to read.\nHe knows some subset of the letter of Latin alphabet. In order to help Jeff to study, Chef gave him a book with the text consisting of N words. Jeff can read a word iff it consists only of the letters he knows.\nNow Chef is curious about which words his brother will be able to read, and which are not. Please help him!\n\n-----Input-----\nThe first line of the input contains a lowercase Latin letter string S, consisting of the letters Jeff can read. Every letter will appear in S no more than once.\nThe second line of the input contains an integer N denoting the number of words in the book.\nEach of the following N lines contains a single lowecase Latin letter string Wi, denoting the ith word in the book.\n\n-----Output-----\nFor each of the words, output \"Yes\" (without quotes) in case Jeff can read it, and \"No\" (without quotes) otherwise.\n\n-----Constraints-----\n- 1 ≤ |S| ≤ 26\n- 1 ≤ N ≤ 1000\n- 1 ≤ |Wi| ≤ 12\n- Each letter will appear in S no more than once.\n- S, Wi consist only of lowercase Latin letters.\n\n-----Subtasks-----\n- Subtask #1 (31 point): |S| = 1, i.e. Jeff knows only one letter.\n- Subtask #2 (69 point)\t: no additional constraints\n\n-----Example-----\nInput:act\n2\ncat\ndog\n\nOutput:Yes\nNo\n\n-----Explanation-----\nThe first word can be read.\nThe second word contains the letters d, o and g that aren't known by Jeff.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn all_chars_known(word: Seq<char>, known_letters: Seq<char>) -> bool {\n    forall|c: char| word.contains(c) ==> known_letters.contains(c)\n}\n\nspec fn some_char_unknown(word: Seq<char>, known_letters: Seq<char>) -> bool {\n    exists|c: char| word.contains(c) && !known_letters.contains(c)\n}\n\nfn can_read_words(known_letters: &str, word_list: &Vec<String>) -> (result: Vec<String>)\n    requires known_letters@.len() > 0,\n    ensures \n        result@.len() == word_list@.len(),\n        forall|i: int| 0 <= i < result@.len() ==> (result@[i]@ == \"Yes\"@ || result@[i]@ == \"No\"@),\n        forall|i: int| 0 <= i < result@.len() && result@[i]@ == \"Yes\"@ ==> \n            all_chars_known(word_list@[i]@, known_letters@),\n        forall|i: int| 0 <= i < result@.len() && result@[i]@ == \"No\"@ ==> \n            some_char_unknown(word_list@[i]@, known_letters@),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = can_read_words(\"act\", &vec![\"cat\".to_string(), \"dog\".to_string()]);\n    // println!(\"{:?}\", result1); // Should output: [\"Yes\", \"No\"]\n    \n    // let result2 = can_read_words(\"a\", &vec![\"a\".to_string(), \"b\".to_string(), \"aa\".to_string()]);\n    // println!(\"{:?}\", result2); // Should output: [\"Yes\", \"No\", \"Yes\"]\n    \n    // let result3 = can_read_words(\"xyz\", &vec![\"x\".to_string(), \"xy\".to_string(), \"xyz\".to_string(), \"abc\".to_string()]);\n    // println!(\"{:?}\", result3); // Should output: [\"Yes\", \"Yes\", \"Yes\", \"No\"]\n}"}
{"id": "fvapps_000563", "vc-description": "Chef has a calculator which has two screens and two buttons. Initially, each screen shows the number zero. Pressing the first button increments the number on the first screen by 1, and each click of the first button consumes 1 unit of energy.\nPressing the second button increases the number on the second screen by the number which is currently appearing on the first screen. Each click of the second button consumes B units of energy.\nInitially the calculator has N units of energy.\nNow chef wonders what the maximum possible number is, that he gets on the second screen of the calculator, with the limited energy.\n\n-----Input-----\nThe first line of the input contains an integer T denoting the number of test cases.\nEach test case is described using a single line containing two integers, N and B.\n\n-----Output-----\nFor each test case, output a single line containing the answer to this test case.\n\n-----Constraints-----\n- 1 ≤ T ≤ 10,000\n- 1 ≤ N, B ≤ 1,000,000,000\n\n-----Subtasks-----\n- Subtask 1 (20 points): 1 ≤ N, B ≤ 1,000\n- Subtask 2 (80 points): Original constraints\n\n-----Example-----\nInput:\n3\n10 2\n8 5\n6 1\n\nOutput:\n12\n3\n9\n\n-----Explanation-----\nExample case 1. There are 10 units of energy available. Pressing second button takes 2 units of energy. Chef can achieve 12 on the second screen as follows.\n\n- Press first button to get scores (1, 0). 9 units of energey is left.\n- Press first button to get scores (2, 0). 8 units of energy remaining.\n- Press first button to get scores (3, 0). 7 units of energy remaining.\n- Press first button to get scores (4, 0). 6 units of energy remaining.\n- Press second button to get scores (4, 4). 4 units of energy remaining.\n- Press second button to get scores (4, 8). 2 units of energy remaining.\n- Press second button to get scores (4, 12). 0 units of energy remaining.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn calc_max_second_screen(n: u64, b: u64) -> (result: u64)\n    requires\n        n >= 1,\n        b >= 1,\n    ensures result >= 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded_and_plausible\n\n    // assert(calc_max_second_screen(10, 2) == 12);\n    // assert(calc_max_second_screen(8, 5) == 3);\n    // assert(calc_max_second_screen(6, 1) == 9);\n}"}
{"id": "fvapps_000564", "vc-description": "The chef is trying to decode some pattern problems, Chef wants your help to code it. Chef has one number K(odd) to form a new pattern. Help the chef to code this pattern problem.\n\n-----Input:-----\n- First-line will contain $T$, the number of test cases. Then the test cases follow. \n- Each test case contains a single line of input, one integer $K$. \n\n-----Output:-----\nFor each test case, output as the pattern.\n\n-----Constraints-----\n- $1 \\leq T \\leq 100$\n- $1 \\leq K \\leq 100$\n\n-----Sample Input:-----\n4\n1\n3\n5\n7\n\n-----Sample Output:-----\n1\n111\n111\n111\n11111\n11 11\n1 1 1\n11 11\n11111\n1111111\n11   11\n1 1 1 1\n1  1  1\n1 1 1 1\n11   11\n1111111\n\n-----EXPLANATION:-----\nNo need, else pattern can be decode easily.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn print_pattern(n: usize) -> (result: Vec<Vec<char>>)\n    requires n > 0,\n    ensures \n        result.len() == n,\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == n,\n        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result[i].len() ==> (result[i][j] == '1' || result[i][j] == ' ')", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000565", "vc-description": "Humpy, the little elephant, has his birthday coming up. He invited all his cousins but doesn't know how many of them are really coming as some of them are having exams coming up. He will only get to know how many of them are coming on the day of his birthday.\n\nHe ordered sugarcane for his party, of length L.\n\nHumpy's mom decided that she will be dividing the sugarcane among Humty and his friends in a way such that they get the sugarcane in ratio of their ages.\n\nYour task is to determine whether it is possible to serve sugarcane to everyone as integral multiples of their ages.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn sum_ages(ages: Seq<nat>) -> nat\n    decreases ages.len()\n{\n    if ages.len() == 0 {\n        0\n    } else {\n        ages[0] + sum_ages(ages.skip(1))\n    }\n}\n\nfn can_serve_sugarcane(k: nat, l: nat, e: nat, ages: Vec<nat>) -> (result: bool)\n    ensures result == true ==> l % (e + sum_ages(ages@)) == 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let result1 = can_serve_sugarcane(4, 10, 2, vec![2, 2, 3, 1]);\n    // println!(\"Test 1: {}\", result1); // Should be true\n    \n    // let result2 = can_serve_sugarcane(4, 12, 3, vec![6, 5, 7, 3]);\n    // println!(\"Test 2: {}\", result2); // Should be false\n}"}
{"id": "fvapps_000566", "vc-description": "You may have tried your level best to help Chef but Dr Doof has managed to come up with his masterplan in the meantime. Sadly, you have to help Chef once again. Dr Doof has designed a parenthesis-inator. It throws a stream of N brackets at the target, 1 bracket per second. The brackets can either be opening or closing. Chef appears in front of the stream at time t. If Chef faces an opening bracket, he gets hit. However, if he faces a closing bracket, he may choose to let it pass through him (Chef is immune to closing brackets). Chef gets a chance to counter attack Doof as soon as he finds a balanced non-empty bracket sequence. Help Chef by providing him the minimum time x at which he will be able to launch his counter attack. If Chef is unable to counter attack, answer -1.\n\nFormally, you are given a string S of length N consisting only of opening brackets ( and closing brackets ). The substring of S starting at index L and ending at index R, i.e. S_L S_{L+1} ... S_{R} is denoted by S[L, R] . Consider Q cases. In the i^{th} case, Chef appears at time t_i (1 ≤ t_i ≤ N) and faces all characters from index t_i to N. Find the minimum index x (t_i ≤ x ≤ N) such that the substring S[t_i, x] contains a non-empty balanced bracket subsequence containing the same number of opening brackets as S[t_i, x] (i.e., you cannot remove any opening bracket from the substring). If such an x does not exist, print -1.\n\nA string X is called a subsequence of a string Y if it is possible to obtain X by erasing some (possibly zero) characters from Y without changing the order of the remaining characters.\nA balanced bracket sequence is defined as:  \n- an empty string is a balanced bracket sequence.\n- if s is a balanced bracket sequence, then so is (s).\n- if s and t are balanced bracket sequences, then so is st.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_balanced_bracket_char(c: char) -> bool {\n    c == '(' || c == ')'\n}\n\nspec fn count_opening_brackets(s: Seq<char>, start: int, end: int) -> int\n    decreases end - start\n{\n    if start >= end {\n        0\n    } else if s[start] == '(' {\n        1 + count_opening_brackets(s, start + 1, end)\n    } else {\n        count_opening_brackets(s, start + 1, end)\n    }\n}\n\nspec fn count_closing_brackets(s: Seq<char>, start: int, end: int) -> int\n    decreases end - start\n{\n    if start >= end {\n        0\n    } else if s[start] == ')' {\n        1 + count_closing_brackets(s, start + 1, end)\n    } else {\n        count_closing_brackets(s, start + 1, end)\n    }\n}\n\nfn solve_bracket_sequence(s: &Vec<char>, queries: &Vec<usize>) -> (result: Vec<i32>)\n    requires \n        s.len() > 0,\n        queries.len() > 0,\n        forall|c: char| s@.contains(c) ==> (c == '(' || c == ')'),\n        forall|q: usize| #[trigger] queries@.contains(q) ==> (0 < q && q <= s.len()),\n    ensures \n        result.len() == queries.len(),\n        forall|i: int| 0 <= i < result.len() ==> (-1 <= result[i] && result[i] <= s.len() as i32),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000568", "vc-description": "Given a binary string S consisting of only 1's and 0's where 1 represents a Square and 0 represents a Circle. The diameter of the circle and the side of the square must be any integer (obviously > 0) . You will have to perfectly inscribe (as shown in the example below) the respective geometric figure at S[i+1] inside of S[i] where i ∈ [0,N-2], if it is possible. Note that, it will not be possible to inscribe if the dimension of the geometric figure you are perfectly inscribing is not an integer and you will discard the rest of the string. Find the maximum number of circles we can inscribe in a square according to the given string.  \nFor a given binary string there can be only one geometric figure and this figure is concentric.  \nFor example : the string 1100 can be represented as the figure below, the first two squares have the same side length and the next two circles have the same diameter.  \n\nAnother example : the string 0001 can be represented as the one given below\nAgain here, we have 3 circles of the same diameter and one square inscribed in them.  \n\nInput:\nThe first line contains N, the number of strings\n\nThen each of the next N lines contains a binary string S.  \n\nOutput:\nThe N lines of output should have N integers in separate lines, the maximum number of circles we can inscribe in a square according to the given string S .  \n\nConstraints:\n- 1 ≤ N ≤ 10³\n- 1 ≤ length of string S ≤ 10⁴\n\nSample Input:\n3\n\n1110\n\n0010\n\n1001000  \n\nSample Output:\n1\n\n0\n\n2  \n\nExplanation:\nIn  the first case, we can inscribe the string 1110 as :  three squares of side length 4 units (on top of each other) and then  we can inscribe one circle of diameter 4 units.\nThe answer is 1 since, there is 1 circle inscribed in a square.\n\nIn the second case 0010, Let the first two circles be of some diameter 10, we can see that we cannot inscribe another square of any integer dimension inside them.\n\nSo, the answer is 0.\n\nIn the third case 1001000, we can take the first square of size 10, then inscribe two circles of diameter 5, then we cannot inscribe another square in this since, it will not be of any possible integer dimension and we discard the rest of the string.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn string_has_no_ones(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> s[i] != '1'\n}\n\nspec fn string_starts_with_zero(s: Seq<char>) -> bool {\n    s.len() > 0 && s[0] == '0'\n}\n\nspec fn string_all_ones(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> s[i] == '1'\n}\n\nfn count_inscribed_circles(s: &str) -> (result: usize)", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "}\n\nfn main() {\n    // let test1 = count_inscribed_circles(\"1110\");\n    // assert_eq!(test1, 1);\n    \n    // let test2 = count_inscribed_circles(\"0010\");\n    // assert_eq!(test2, 0);\n    \n    // let test3 = count_inscribed_circles(\"1001000\");\n    // assert_eq!(test3, 2);\n}"}
{"id": "fvapps_000570", "vc-description": "Teacher Sungjae wanted to hold a programming competition for his students where every participant need to be included into team. The participants submitted their team names before the deadline. After the competition ran for half an hour, (It is assured that each registered team will submit absolutely once within half an hour) Sungjae mistakenly pressed a button that changed the order of the registered team names. Now in the submission list, order of the characters in the team's name doesn't matter. That means abc, acb, bac, bca, cab, cba refers to the same team. The competition ran for two hours and then ended. Sungjae now counting each of the team's score and wants to print the registered team names and score. The scoreboard should be ordered based on scores in decreasing order and if two teams have same score, Sangjae would follow lexicographical order.\nN.B. frequency of each character's in a registered team's name will not match with another team. \nThat means two teams named xoxo and oxox is not possible. Because both of them have the same frequency of each of the characters (two 'o' and two 'x'). Similarly abb and bab is not possible (because both of them have one 'a' and two 'b').\nIt is ensured that only possible test cases will be given.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn extract_points_from_entry(entry: Seq<char>) -> nat {\n    0  // Simplified spec - in real implementation would parse the string\n}\n\nfn get_scoreboard(n: usize, k: usize, submissions: Vec<(String, usize)>) -> (result: Vec<String>)\n    requires \n        n > 0,\n        k <= n,\n        submissions.len() == n,\n    ensures \n        forall|i: int, j: int| 0 <= i < j < result.len() ==> \n            extract_points_from_entry(result[i]@) >= extract_points_from_entry(result[j]@)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000571", "vc-description": "On a planet called RUIZ LAND, which is ruled by the queen, Erika Ruiz. Each person on that planet has a strength value (strength value >0).\nThat planet has a special rule made by the queen that a boy and a girl will form a couple if their Hate value is a prime number where $Hate$ is given by the formula:-\nHate = (boy's strength value)  XOR (girl's strength value )\nYou are given $N$ numbers denoting the strength value of $N$ girls, and each of the $N$ girls has to form a couple with a boy such that sum of $Hate$ value of all the $N$ couples will be minimum.\nYou need to print the strength value of each boy, Where the boy at index $i$ will form a couple with the girl at index $i$, where $1 \\leq i \\leq N$.\nAssume that you can always find at least one boy having that strength for each girl.\n\n-----Input:-----\n- First line will contain $N$, the number of Girls. \n- Next line contains $N$ numbers separated by space denoting strength value for each girl.\n\n-----Output:-----\nPrint the required $N$ numbers denoting strength of boys.\n\n-----Constraints-----\n- $1 \\leq N \\leq 100000$\n- $1 \\leq A_i \\leq 10^9$ , (where $1 \\leq i \\leq N$) and $A_i$ denotes strength of i'th girl.\n\n-----Sample Input:-----\n2\n10 16\n\n-----Sample Output:-----\n8 18", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn find_boy_strengths(n: usize, girls: Vec<u32>) -> (result: Vec<u32>)\n    requires n > 0,\n    ensures\n        result.len() == girls.len(),\n        forall|x: u32| #[trigger] result@.contains(x) ==> x >= 0,\n        forall|i: int| 0 <= i < girls.len() ==> {\n            let girl = #[trigger] girls[i];\n            let boy = result[i];\n            if girl == 2 {\n                boy == 1\n            } else {\n                boy == (girl ^ 2)\n            }\n        },", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000573", "vc-description": "Digory Kirke and Polly Plummer are two kids living next door to each other. The attics of the two houses are connected to each other through a passage. Digory's Uncle Andrew has been secretly doing strange things in the attic of his house, and he always ensures that the room is locked. Being curious, Digory suspects that there is another route into the attic through Polly's house, and being curious as kids always are, they wish to find out what it is that Uncle Andrew is secretly up to.\n\nSo they start from Polly's house, and walk along the passageway to Digory's. Unfortunately, along the way, they suddenly find that some of the floorboards are missing, and that taking a step forward would have them plummet to their deaths below.\n\nDejected, but determined, they return to Polly's house, and decide to practice long-jumping in the yard before they re-attempt the crossing of the passage. It takes them exactly one day to master long-jumping a certain length. Also, once they have mastered jumping a particular length L, they are able to jump any amount less than equal to L as well.\n\nThe next day they return to their mission, but somehow find that there is another place further up the passage, that requires them to jump even more than they had practiced for. So they go back and repeat the process.\n\nNote the following:\n\n-  At each point, they are able to sense only how much they need to jump at that point, and have no idea of the further reaches of the passage till they reach there. That is, they are able to only see how far ahead is the next floorboard. \n-  The amount they choose to practice for their jump is exactly the amount they need to get across that particular part of the passage. That is, if they can currently jump upto a length L0, and they require to jump a length L1(> L0) at that point, they will practice jumping length L1 that day. \n-  They start by being able to \"jump\" a length of 1. \n\nFind how many days it will take them to cross the passageway. In the input, the passageway is described as a string P of '#'s and '.'s. A '#' represents a floorboard, while a '.' represents the absence of a floorboard. The string, when read from left to right, describes the passage from Polly's house to Digory's, and not vice-versa.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_jumps(s: String) -> (result: u32)", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // println!(\"{}\", solve_jumps(\"####\".to_string()));\n    // println!(\"{}\", solve_jumps(\"##.#..#\".to_string()));\n    // println!(\"{}\", solve_jumps(\"##..#.#\".to_string()));\n    // println!(\"{}\", solve_jumps(\"##.#....#\".to_string()));\n}"}
{"id": "fvapps_000574", "vc-description": "Chef has an array A consisting of N integers (1-based indexing). He asks you to perform the following operation M times:\n\n\tfor i = 2 to N:\n\t\tAi = Ai + Ai-1\n\nYour task is to find the xth element of the array (i.e., Ax) after performing the above operation M times. As the answer could be large, please output it modulo 109 + 7.\n\n-----Input-----\n- The first line of input contains an integer T denoting the number of test cases.\n- The first line of each test case contains three space-separated integers — N, x, and M — denoting the size of the array, index of the element you need to find, and the amount of times you need to repeat operation before finding the element, respectively. The second line contains N space-separated integers A1, A2, …, AN.\n\n-----Output-----\nFor each test case, output a single line containing one integer: Ax modulo 109 + 7. \n\n-----Constraints-----\n- 1 ≤ T ≤ 10\n- 1 ≤ x ≤ N ≤ 105\n- 1 ≤ M ≤ 1018 \n- 1 ≤ Ai  ≤ 1018\n\n-----Subtasks-----Subtask 1 (8 points):\n- 1 ≤ x ≤ min{2, N}Subtask 2 (24 points):\n- 1 ≤ N * M ≤ 106Subtask 3 (68 points):  No additional constraints\n\n-----Example-----\nInput:\n2\n3 2 3\n1 2 3\n3 3 3 \n1 2 3\n\nOutput:\n5\n15\n\n-----Explanation-----\nValues in the array A:\n- Before the operations: [1, 2, 3]\n- After the first operation: [1, 3, 6]\n- After the second operation: [1, 4, 10]\n- After the third operation: [1, 5, 15]\n\nSince input file can be fairly large (about 8 MB), it's recommended to use fast I/O (for example, in C++, use scanf/printf instead of cin/cout).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_array_ops(n: usize, x: usize, m: usize, arr: Vec<usize>) -> (result: usize)\n    requires \n        1 <= n && n <= 100,\n        1 <= x && x <= n,\n        m <= 100,\n        arr.len() >= n,\n    ensures\n        /* Zero operations: returns original element */\n        m == 0 ==> result == arr[x-1],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded_and_plausible\n\n    // #eval solve_array_ops(3, 2, 3, vec![1, 2, 3]) // Expected: 5\n    // #eval solve_array_ops(3, 3, 3, vec![1, 2, 3]) // Expected: 15\n    // #eval solve_array_ops(2, 2, 2, vec![1, 1])    // Expected: 3\n}"}
{"id": "fvapps_000575", "vc-description": "Ganesh lives in Gopalmath. He is looking for Jojo. So he decides to collect Aadhar Card Information of all the citizens of India from UIDAI.\nSomeone told Ganesh that the sum of all the digits of Jojo's Aadhar number is divisible by 10 and it is greater than zero. After finding all Aadhar numbers which are divisible by 10, Jojo's Aadhar number is $N$th smallest Aadhar number. Hence, Ganesh wants to find Jojo's  Aadhar number which satisfies all of the above conditions. (In this chaotic world, Aadhar numbers can be any natural number.)\nHowever, Guruji refused Ganesh to carry out this task, because he is weak in Maths. Therefore, Ganesh assigns this task to Paritoshbhai who possesses excellent Mathematical skills. Since Paritoshbhai is busy in his jewellery business, help him in this task.\n\n-----Input:-----\n- The first line of the input contains a single integer T denoting the number of test cases. The description of T test cases follows.\n- The first and only line of each test case contains a single integer N.\n\n-----Output:-----\nFor each test case, print a single line containing Aadhar number of Jojo.\n\n-----Constraints-----\n- $1 \\leq T \\leq 1000$\n- $1 \\leq N \\leq 10^{100,000}$\n\n-----Sample Input:-----\n1\n3\n\n-----Sample Output:-----\n37", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn sum_digits(n: nat) -> nat\n    decreases n\n{\n    if n == 0 {\n        0\n    } else {\n        (n % 10) + sum_digits(n / 10)\n    }\n}\n\nfn find_jojo_aadhar(n: nat) -> (result: nat)\n    ensures \n        sum_digits(result) % 10 == 0,\n        result / 10 == n,\n        0 <= result % 10 && result % 10 <= 9", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "/* Apps difficulty: interview */\n/* Assurance level: unguarded */\n\n}\n\nfn main() {\n    // #guard_msgs in\n    // #eval find_jojo_aadhar 3\n\n    // #guard_msgs in  \n    // #eval find_jojo_aadhar 10\n\n    // #guard_msgs in\n    // #eval find_jojo_aadhar 42\n}"}
{"id": "fvapps_000576", "vc-description": "Teddy and Tracy like to play a game based on strings. The game is as follows. Initially, Tracy writes a long random string on a whiteboard. Then, each player starting with Teddy makes turn alternately. Each turn, the player must erase a contiguous substring that exists in the dictionary. The dictionary consists of N words.\nOf course, the player that can't erase any substring in his turn loses the game, and the other player is declared the winner.\nNote that after a substring R is erased, the remaining substring becomes separated, i.e. they cannot erase a word that occurs partially to the left of R and partially to the right of R.\n\nDetermine the winner of the game, assuming that both players play optimally.\n\n-----Input-----\nThe first line contains a single integer T, the number of test cases. T test cases follow. The first line of each testcase contains a string S, the string Tracy writes on the whiteboard. The next line contains a single integer N. N lines follow. The i-th line contains a single string wi, the i-th word in the dictionary.\n\n-----Output-----\nFor each test case, output a single line containing the name of the winner of the game.\n\n-----Example-----\nInput:\n3\ncodechef\n2\ncode\nchef\nfoo\n1\nbar\nmississippi\n4\nssissi\nmippi\nmi\nppi\n\nOutput:\nTracy\nTracy\nTeddy\n\n-----Constraints-----\n- 1 <= T <= 5\n- 1 <= N <= 30\n- 1 <= |S| <= 30\n- 1 <= |wi| <= 30\n- S and wi contain only characters 'a'-'z'", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_string_game(s: String, dict: Vec<String>) -> (result: String)\n    ensures \n        result@ == \"Teddy\"@ || result@ == \"Tracy\"@,", "vc-code": "{\n    // impl-start\n    assume(false);\n    \"Tracy\".to_string()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let result1 = solve_string_game(\"codechef\".to_string(), vec![\"code\".to_string(), \"chef\".to_string()]);\n    // println!(\"{}\", result1); // Should print \"Tracy\"\n    \n    // let result2 = solve_string_game(\"foo\".to_string(), vec![\"bar\".to_string()]);\n    // println!(\"{}\", result2); // Should print \"Tracy\"\n    \n    // let result3 = solve_string_game(\"mississippi\".to_string(), vec![\"ssissi\".to_string(), \"mippi\".to_string(), \"mi\".to_string(), \"ppi\".to_string()]);\n    // println!(\"{}\", result3); // Should print \"Teddy\"\n}"}
{"id": "fvapps_000577", "vc-description": "Mathison recently inherited an ancient papyrus that contained some text. Unfortunately, the text was not a\npangram. Now, Mathison has a particular liking for holoalphabetic strings and the text bothers him. The good news is that Mathison can buy letters from the local store in order to turn his text into a pangram.\n\nHowever, each letter has a price and Mathison is not very rich. Can you help Mathison find the cheapest way to obtain a pangram?\n\n-----Input-----\nThe first line of the input file will contain one integer, T, representing the number of tests.\nEach test will be formed from two lines. The first one contains 26 space-separated integers, representing the prices of all letters.\nThe second will contain Mathison's initial text (a string of N lowercase letters).\n\n-----Output-----\nThe output file will contain T lines, one for each test. Each line will contain the answer for the corresponding test.\n\n-----Constraints and notes-----\n- 1 ≤ T ≤ 10\n- 1 ≤ N ≤ 50,000\n- All prices are natural numbers between 1 and 1,000,000 (i.e. 106).\n- A pangram is a string that contains every letter of the Latin alphabet at least once.\n- All purchased letters are added to the end of the string.\n\n-----Subtaks-----\nSubtask #1 (30 points):\n\n- N = 1\n\nSubtask #2 (70 points):\n\n- Original constraints\n\n-----Example-----\nInput:\n2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26\nabcdefghijklmopqrstuvwz\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26\nthequickbrownfoxjumpsoverthelazydog\n\nOutput:\n63\n0\n\n-----Explanation-----\nFirst test\nThere are three letters missing from the original string: n (price 14), x (price 24), and y (price 25).\nTherefore the answer is 14 + 24 + 25 = 63.\n\nSecond test\nNo letter is missing so there is no point in buying something. The answer is 0.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn sum_list(prices: Seq<nat>) -> nat \n    decreases prices.len()\n{\n    if prices.len() == 0 {\n        0\n    } else {\n        prices[0] + sum_list(prices.skip(1))\n    }\n}\n\nfn get_pangram_cost(prices: Vec<nat>, text: Vec<u8>) -> (result: nat)\n    requires prices.len() == 26,\n    ensures \n        result >= 0,\n        text.len() == 0 ==> result == sum_list(prices@)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded_and_plausible\n\n    // Test cases would go here but are commented out for verification\n    // let prices1 = vec![1nat, 2nat, 3nat, 4nat, 5nat, 6nat, 7nat, 8nat, 9nat, 10nat, 11nat, 12nat, 13nat, 14nat, 15nat, 16nat, 17nat, 18nat, 19nat, 20nat, 21nat, 22nat, 23nat, 24nat, 25nat, 26nat];\n    // let result1 = get_pangram_cost(prices1, \"abcdefghijklmopqrstuvwz\".as_bytes().to_vec());\n    // println!(\"{}\", result1); // Expected: 63\n    \n    // let prices2 = vec![1nat, 2nat, 3nat, 4nat, 5nat, 6nat, 7nat, 8nat, 9nat, 10nat, 11nat, 12nat, 13nat, 14nat, 15nat, 16nat, 17nat, 18nat, 19nat, 20nat, 21nat, 22nat, 23nat, 24nat, 25nat, 26nat];\n    // let result2 = get_pangram_cost(prices2, \"thequickbrownfoxjumpsoverthelazydog\".as_bytes().to_vec());\n    // println!(\"{}\", result2); // Expected: 0\n    \n    // let prices3 = vec![1nat; 26];\n    // let result3 = get_pangram_cost(prices3, \"a\".as_bytes().to_vec());\n    // println!(\"{}\", result3); // Expected: 25\n}"}
{"id": "fvapps_000579", "vc-description": "Chef is playing a game on the non-negative x-axis. It takes him 1 second to reach from i-th position to (i-1)-th position or (i+1)-th position. The chef never goes to the negative x-axis. Also, Chef doesn't stop at any moment of time.\nThe movement of chef can be described as follows.\n- At the start he is standing at x=0 at time 0.\n- In the first round, he moves towards x=1 and comes back to the x=0 position. \n- In the second round, he moves towards the x=2 and comes back again to x=0. \n- Generalizing, in the k-th round, he moves from x=0 to x=k and then returns back to x=0 at the end of the round. This goes on as the game progresses.\nFor Example, the path of Chef for 3rd round is given below.\n0 - 1 - 2 - 3 - 2 - 1 - 0 \nThe overall path followed by Chef would look somewhat like this:\n0 - 1 - 0 - 1 - 2 - 1 - 0 - 1 - 2 - 3 - 2 - 1 - 0 - 1 - 2 - 3 - 4 - 3 - ...\nYou are given two non-negative integers N and K. You have to tell the time at which Chef arrives at x=N for the K-th time. \nNote - Chef can not skip a position while visiting the positions.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "const MOD: u32 = 1000000007;\n\nfn calculate_time_at_position(n: u32, k: u32) -> (result: u32)\n    requires k > 0,\n    ensures result >= 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let test1 = calculate_time_at_position(0, 1);\n    // assert(test1 == 0);\n    \n    // let test2 = calculate_time_at_position(1, 1);\n    // assert(test2 == 1);\n    \n    // let test3 = calculate_time_at_position(1, 3);\n    // assert(test3 == 5);\n}"}
{"id": "fvapps_000580", "vc-description": "Chef Ada is building a new restaurant in the following way:\n- First, N points X_1, X_2, ..., X_N are chosen on the x-axis.\n- Then, N columns (numbered 1 through N) are made. For simplicity, the columns are represented as vertical segments; for each valid i, the height of the i-th segment is H_i.\n- Ada assigns a column to each of the points X_1, X_2, ..., X_N in an arbitrary way (each column must be assigned to exactly one point).\n- Finally, Ada constructs the roof of the restaurant, represented by a polyline with N vertices. Let's denote the column assigned to the i-th point by P_i. For each valid i, the i-th of these vertices is (X_i, H_{P_i}), i.e. the polyline joins the tops of the columns from left to right.\nAda wants the biggest restaurant. Help her choose the positions of the columns in such a way that the area below the roof is the biggest possible. Formally, she wants to maximise the area of the polygon whose perimeter is formed by the roof and the segments (X_N, H_{P_N}) - (X_N, 0) - (X_1, 0) - (X_1, H_{P_1}). Let S be this maximum area; you should compute 2 * S (it is guaranteed that 2 * S is an integer).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn calculate_restaurant_area(points: Vec<(i32, i32)>) -> (result: i32)\n    ensures result >= 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let test_points = vec![(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)];\n    // let result = calculate_restaurant_area(test_points);\n    // println!(\"{}\", result);\n}"}
{"id": "fvapps_000583", "vc-description": "The Fibonacci sequence F_0, F_1, ... is a special infinite sequence of non-negative integers, where F_0 = 0, F_1 = 1 and for each integer n >= 2, F_n = F_{n-1} + F_{n-2}.\nConsider the sequence D of the last decimal digits of the first N Fibonacci numbers, i.e. D = (F_0 % 10, F_1 % 10, ..., F_{N-1} % 10). Now, you should perform the following process:\n- Let D = (D_1, D_2, ..., D_l).\n- If l = 1, the process ends.\n- Create a new sequence E = (D_2, D_4, ..., D_{2 floor(l/2)}). In other words, E is the sequence created by removing all odd-indexed elements from D.\n- Change D to E.\nWhen this process terminates, the sequence D contains only one number. You have to find this number.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn find_last_fibonacci_digit(n: u64) -> (result: u64)\n    requires n >= 1,\n    ensures \n        0 <= result <= 9,\n        n == 1 ==> result == 0,\n        n == 2 ==> result == 1,\n        n == 4 ==> result == 2,\n        n == 8 ==> result == 3,\n        n == 9 ==> result == 3,\n        n == 10 ==> result == 3", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let test_result = find_last_fibonacci_digit(9);\n    // println!(\"Result for n=9: {}\", test_result);\n    \n    // let test_result_1 = find_last_fibonacci_digit(1);\n    // println!(\"Result for n=1: {}\", test_result_1);\n    \n    // let test_result_10 = find_last_fibonacci_digit(10);\n    // println!(\"Result for n=10: {}\", test_result_10);\n}"}
{"id": "fvapps_000584", "vc-description": "The bustling town of Siruseri has just one sports stadium. There are a number of schools, colleges, sports associations, etc. that use this stadium as the venue for their sports events.\nAnyone interested in using the stadium has to apply to the Manager of the stadium indicating both the starting date (a positive integer S) and the length of the sporting event in days (a positive integer D) they plan to organise. Since these requests could overlap it may not be possible to satisfy everyone. Also, there should be at least one gap day between any two approved events, so that the stadium can be cleaned.\nIt is the job of the Manager to decide who gets to use the stadium and who does not. The Manager, being a genial man, would like to keep as many organisations happy as possible and hence would like to allocate the stadium so that maximum number of events are held.\nSuppose, for example, the Manager receives the following 4 requests:\n\nEvent No.   Starting Date        Length \n1                   2                    5\n2                   9                    7\n3                  15                    6\n4                   9                    3\n\nHe would allot the stadium to events 1, 4 and 3. Event 1 begins on day 2 and ends on day 6, event 4 begins on day 9 and ends on day 11 and event 3 begins on day 15 and ends on day 20. You can verify that it is not possible to schedule all the 4 events (since events 2 and 3 overlap and only one of them can get to use the stadium).\nYour task is to help the manager find the best possible allotment (i.e., the maximum number of events that can use the stadium).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn events_overlap(event1: (u32, u32), event2: (u32, u32)) -> bool {\n    let (start1, duration1) = event1;\n    let (start2, duration2) = event2;\n    let end1 = start1 + duration1;\n    let end2 = start2 + duration2;\n    /* Events overlap if one starts before the other ends (with gap requirement) */\n    (start1 < end2 + 1) && (start2 < end1 + 1)\n}\n\nspec fn valid_schedule(events: Seq<(u32, u32)>, selected: Seq<bool>) -> bool {\n    selected.len() == events.len() &&\n    forall|i: int, j: int| 0 <= i < events.len() && 0 <= j < events.len() && i != j &&\n        selected[i] && selected[j] ==> !events_overlap(events[i], events[j])\n}\n\nspec fn count_selected(selected: Seq<bool>) -> nat \n    decreases selected.len()\n{\n    if selected.len() == 0 {\n        0 as nat\n    } else {\n        (if selected[0] { 1 as nat } else { 0 as nat }) + count_selected(selected.skip(1))\n    }\n}\n\nfn max_stadium_events(events: Vec<(u32, u32)>) -> (result: u32)\n    ensures\n        result <= events.len(),\n        exists|selected: Seq<bool>| valid_schedule(events@, selected) && count_selected(selected) == result,\n        forall|selected: Seq<bool>| valid_schedule(events@, selected) ==> count_selected(selected) <= result", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let test_events = vec![(2u32, 5u32), (9u32, 7u32), (15u32, 6u32), (9u32, 3u32)];\n    // println!(\"{}\", max_stadium_events(test_events));\n}"}
{"id": "fvapps_000585", "vc-description": "Chef Loves to listen to remix songs, but currently he had already finished the entire playlist of remix songs.\nAs Chef is smart, so he thought let's make my own remix songs of the original songs.\nChef is not having much knowledge of making remix songs, so he came up with the simple technique in which he will pick the word which contains the smallest number of characters from the lyrics of the song, and then he will append that word to the start and end of the lyrics, also Chef will insert this word between every two words of the lyrics.\nNote: While inserting a new word Chef will also insert extra white-spaces, so that every word in the final remixed lyrics is separated by space.\nIt is Recommended to use fast Input/Ouput techniques.\n\n-----Input:-----\n- The input contains the text $S$, which denotes the lyrics of the song.\n\n-----Output:-----\n- Print the Remixed, lyrics as done by Chef.\n\n-----Constraints:-----\n- $1 \\leq Length of text $S$ \\leq 10^7$\n\n-----Sample Input:-----\nMai Hu Jiyaan\n\n-----Sample Output:-----\nHu Mai Hu Hu Hu Jiyaan Hu", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn count_char_occurrences(text: Seq<char>, ch: char) -> nat\n    decreases text.len()\n{\n    if text.len() == 0 {\n        0\n    } else {\n        let count_rest = count_char_occurrences(text.skip(1), ch);\n        if text[0] == ch {\n            count_rest + 1\n        } else {\n            count_rest\n        }\n    }\n}\n\nspec fn starts_with_char(text: Seq<char>, ch: char) -> bool {\n    text.len() > 0 && text[0] == ch\n}\n\nspec fn ends_with_char(text: Seq<char>, ch: char) -> bool {\n    text.len() > 0 && text[text.len() - 1] == ch\n}\n\nfn process_text(text: &str) -> (result: String)\n    requires text@.len() > 0,\n    ensures \n        result@.len() > 0,\n        starts_with_char(result@, 'I') && ends_with_char(result@, 'I')", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000586", "vc-description": "You need to find a string which has exactly K positions in it such that the character at that position comes alphabetically later than the character immediately after it. If there are many such strings, print the one which has the shortest length. If there is still a tie, print the string which comes the lexicographically earliest (would occur earlier in a dictionary).\n\nInput: The first line contains the number of test cases T. Each test case contains an integer K (≤ 100).\n\nOutput: Output T lines, one for each test case, containing the required string. Use only lower-case letters a-z.\n\nSample Input:\n2\n1\n2\n\nSample Output:\nba\ncba", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn is_lowercase_letter(c: char) -> bool {\n    let n = c as u32;\n    97 <= n && n <= 122\n}\n\nspec fn count_descending_pairs(s: Seq<char>) -> nat \n    decreases s.len()\n{\n    if s.len() <= 1 {\n        0\n    } else {\n        let first_pair: nat = if s[0] > s[1] { 1 } else { 0 };\n        first_pair + count_descending_pairs(s.skip(1))\n    }\n}", "vc-spec": "fn find_k_descending_pairs(k: u32) -> (result: Vec<char>)\n    requires k > 0,\n    ensures \n        count_descending_pairs(result@) == k,\n        forall|c: char| result@.contains(c) ==> is_lowercase_letter(c),\n        result.len() == k + 1 + (if k > 25 { (k - 26) / 25 + 1 } else { 0 }),\n        forall|c: char| result@.contains(c) ==> (97 <= c as u32 && c as u32 <= 122)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = find_k_descending_pairs(1);\n    // println!(\"{:?}\", result1.iter().collect::<String>());\n    \n    // let result2 = find_k_descending_pairs(2); \n    // println!(\"{:?}\", result2.iter().collect::<String>());\n    \n    // let result3 = find_k_descending_pairs(3);\n    // println!(\"{:?}\", result3.iter().collect::<String>());\n}"}
{"id": "fvapps_000588", "vc-description": "There is a rectangular grid of cells consisting of n rows and m columns.\nYou will place a robot on one of the grid cells and provide it with a command string s, consisting of characters 'L', 'R', 'U', 'D'.\nAfter being placed, the robot will follow the instructions of the command string, where 'L' corresponds moving to the left, 'R' towards the right, 'U' for moving up, and 'D' means down.\n\nYou have already selected the command string s, and are wondering if it is possible to place the robot in one of the grid cells initially and have it always stay entirely within the grid upon execution of the command string s.\nOutput \"safe\" if there is a starting cell for which the robot doesn't fall off the grid on following command s, otherwise, output \"unsafe\".", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn count_char(s: Seq<char>, c: char) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0nat\n    } else {\n        (if s[0] == c { 1nat } else { 0nat }) + count_char(s.skip(1), c)\n    }\n}\n\nenum SafetyResult {\n    Safe,\n    Unsafe,\n}\n\nfn solve_robot_safety(n: usize, m: usize, commands: Vec<char>) -> (result: SafetyResult)\n    requires \n        n > 0,\n        m > 0,\n        commands.len() > 0,\n        forall|i: int| 0 <= i < commands.len() ==> \n            (commands[i] == 'U' || commands[i] == 'D' || commands[i] == 'L' || commands[i] == 'R'),\n    ensures \n        match result {\n            SafetyResult::Safe => true,\n            SafetyResult::Unsafe => true,\n        },", "vc-code": "{\n    // impl-start\n    assume(false);\n    SafetyResult::Unsafe\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = solve_robot_safety(1, 1, vec!['R']);\n    // match result1 {\n    //     SafetyResult::Safe => println!(\"safe\"),\n    //     SafetyResult::Unsafe => println!(\"unsafe\"),\n    // }\n    \n    // let result2 = solve_robot_safety(2, 3, vec!['L', 'L', 'R', 'U']);\n    // match result2 {\n    //     SafetyResult::Safe => println!(\"safe\"),\n    //     SafetyResult::Unsafe => println!(\"unsafe\"),\n    // }\n}"}
{"id": "fvapps_000589", "vc-description": "Consider the infinite x axis. There are N impacts on this X-axis at integral points (X1,X2,....XN) (all distinct) . An impact at a point Xi propagates such that at a point X0, the effect of the impact is K|Xi−X0|. Given the point X0, N and K. Assume the total impact on X0 is M, find if it is possible to do so.Note: You are not required to find the set X\n\nFormally print \"yes\" if this is possible and \"no\" if not possible.\n\n-----Input:-----\n- First line will contain T, number of testcases. Then the testcases follow. \n-  Each testcase contains of a single line of input, four integers N,K,M,X0 \n\n-----Output:-----\n-  The output of each test case is either \"yes\" or \"no\"\n\n-----Constraints -----\n-  1≤T≤1000\n-  1≤N≤100\n-  1≤K≤1000\n-  1≤M≤10^18\n-  −10^9≤X0≤10^9 \n\n-----Sample Input:-----\n\t2\n\n4 3 10 10\n\n2 3 10 10\n\n-----Sample Output:-----\n\tno\n\nyes", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_impact_points(n: u32, k: u32, m: u64, x0: i64) -> (result: String)\n    requires \n        1 <= n && n <= 100,\n        1 <= k && k <= 1000,\n        1 <= m && m <= 1000000000000000000u64,\n        -1000000000i64 <= x0 && x0 <= 1000000000i64,\n    ensures\n        equal(result@, seq!['y', 'e', 's']) || equal(result@, seq!['n', 'o']),", "vc-code": "{\n    // impl-start\n    assume(false);\n    \"no\".to_string()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000590", "vc-description": "You are given a sequence A_1, A_2, ..., A_N. You have to split the array into maximum number of non-empty subarrays such that the gcd of elements of each subarray is equal to 1.\n\nInput:\n- The first line of the input contains a single integer T denoting the number of test cases. The description of T test cases follows.\n- The first line of each test case contains a single integer N.\n- The second line contains N space-separated integers A_1, A_2, ..., A_N.\n\nOutput:\nFor each test case, print a single line containing one integer — the maximum number of subarrays formed, or -1 if the array cannot be split while satisfying the above condition.\n\nConstraints:\n- 1 ≤ T ≤ 3\n- 1 ≤ N ≤ 5 × 10^5\n- 1 ≤ A_i ≤ 10^6 for each valid i\n\nSample Input:\n2\n3\n2 2 3\n4\n2 3 3 2\n\nSample Output:\n1\n2", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn gcd_of_list(nums: Seq<nat>) -> nat\n{\n    1nat\n}\n\nfn max_gcd_subarrays(n: nat, arr: Vec<nat>) -> (result: i32)\n    requires arr.len() == n,\n    ensures \n        (forall|i: int| 0 <= i < arr.len() ==> arr[i] >= 1),\n        result == -1 || result > 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = max_gcd_subarrays(3, vec![2, 2, 3]);\n    // println!(\"{}\", result1); // Expected: 1\n    \n    // let result2 = max_gcd_subarrays(4, vec![2, 3, 3, 2]);\n    // println!(\"{}\", result2); // Expected: 2\n    \n    // let result3 = max_gcd_subarrays(2, vec![4, 6]);\n    // println!(\"{}\", result3); // Expected: -1\n}"}
{"id": "fvapps_000592", "vc-description": "Chef published a blog post, and is now receiving many queries about it. On day i, he receives Q_i queries. But Chef can answer at most k queries in a single day. \nChef always answers the maximum number of questions that he can on any given day (note however that this cannot be more than k). The remaining questions (if any) will be carried over to the next day.\nFortunately, after n days, the queries have stopped. Chef would like to know the first day during which he has some free time, i.e. the first day when he answered less than k questions. \n\n-----Input:-----\n- First line will contain T, the number of testcases. Then the testcases follow.\n- The first line of each testcase contains two space separated integers n and k.\n- The second line of each testcase contains n space separated integers, namely Q_1, Q_2, ... Q_n.\n\n-----Output:-----\nFor each testcase, output in a single line the first day during which chef answers less than k questions. \n\n-----Constraints-----\n- 1 ≤ T ≤ 10^5\n- 1 ≤ sum of n over all testcases ≤ 10^5\n- 1 ≤ k ≤ 10^8\n- 0 ≤ Q_i ≤ 10^8\n\n-----Subtasks-----\n- Subtask 1 - 20% points - Sum of Q_i over all testcases and days ≤ 3 . 10^6\n- Subtask 2 - 80% points - Original constraints\n\n-----Sample Input:-----\n2 \n6 5 \n10 5 5 3 2 1 \n1 1\n100\n\n-----Sample Output:-----\n6\n101\n\n-----Explanation:-----\nTest Case 1\nOn the first day, chef answers 5 questions and leaves the remaining 5 (out of the 10) for the future days.\nOn the second day, chef has 10 questions waiting to be answered (5 received on the second day and 5 unanswered questions from day 1). Chef answers 5 of these questions and leaves the remaining 5 for the future.\nOn the third day, chef has 10 questions waiting to be answered (5 received on the third day and 5 unanswered questions from earlier). Chef answers 5 of these questions and leaves the remaining 5 for later.\nOn the fourth day, chef has 8 questions waiting to be answered (3 received on the fourth day and 5 unanswered questions from earlier). Chef answers 5 of these questions and leaves the remaining 3 for later.\nOn the fifth day, chef has 5 questions waiting to be answered (2 received on the fifth day and 3 unanswered questions from earlier). Chef answers all 5 of these questions.\nOn the sixth day, chef has 1 question, which he answers. This is the first day he answers less than 5 questions, and so the answer is 6.\nTest Case 2\nChef answers 1 question a day for the first 100 days. On day 101, he is free.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn queries_sum(queries: Seq<nat>) -> nat\n    decreases queries.len()\n{\n    if queries.len() == 0 {\n        0\n    } else {\n        queries[0] + queries_sum(queries.skip(1))\n    }\n}\n\nfn solve_free_time(n: usize, k: usize, queries: Vec<usize>) -> (result: usize)\n    requires \n        n > 0,\n        k > 0,\n        queries.len() == n,\n    ensures \n        result > 0,\n        1 <= result,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let test1_result = solve_free_time(6, 5, vec![10, 5, 5, 3, 2, 1]);\n    // assert(test1_result == 6);\n    \n    // let test2_result = solve_free_time(1, 1, vec![100]);\n    // assert(test2_result == 101);\n    \n    // let test3_result = solve_free_time(3, 2, vec![1, 1, 1]);\n    // assert(test3_result == 1);\n}"}
{"id": "fvapps_000593", "vc-description": "Due to the COVID pandemic, people have been advised to stay at least 6 feet away from any other person. Now, people are lining up in a queue at the local shop and it is your duty to check whether they are all following this advice.\nThere are a total of N spots (numbered 1 through N) where people can stand in front of the local shop. The distance between each pair of adjacent spots is 1 foot. Each spot may be either empty or occupied; you are given a sequence A_1, A_2, ..., A_N, where for each valid i, A_i = 0 means that the i-th spot is empty, while A_i = 1 means that there is a person standing at this spot. It is guaranteed that the queue is not completely empty.\nFor example, if N = 11 and the sequence A is (0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1), then this is a queue in which people are not following the advice because there are two people at a distance of just 3 feet from each other.\nYou need to determine whether the people outside the local shop are following the social distancing advice or not. As long as some two people are standing at a distance smaller than 6 feet from each other, it is bad and you should report it, since social distancing is not being followed.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn check_social_distancing(n: usize, arr: Vec<usize>) -> (result: bool)\n    requires \n        n >= 1 && n <= 100,\n        arr.len() == n,\n        forall|i: int| 0 <= i < arr.len() ==> (arr[i] == 0 || arr[i] == 1),\n    ensures\n        result == (forall|i: int, j: int| \n            0 <= i < arr.len() && 0 <= j < arr.len() && i < j && \n            arr[i] == 1 && arr[j] == 1 ==> j - i >= 6),", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = check_social_distancing(3, vec![1, 0, 1]);\n    // println!(\"{}\", if result1 { \"YES\" } else { \"NO\" }); // Should print \"NO\"\n    \n    // let result2 = check_social_distancing(7, vec![1, 0, 0, 0, 0, 0, 1]);\n    // println!(\"{}\", if result2 { \"YES\" } else { \"NO\" }); // Should print \"YES\"\n    \n    // let result3 = check_social_distancing(11, vec![0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1]);\n    // println!(\"{}\", if result3 { \"YES\" } else { \"NO\" }); // Should print \"NO\"\n}"}
{"id": "fvapps_000594", "vc-description": "\"What do you know about happiness?\" — Yoda \nChef is happy only if three conditions hold:\n- Chef finished cooking a delicious meal\n- Chef got AC for a programming problem with an almost correct code\n- Chef got a new problem with a sequence of integers\nToday, all three conditions are satisfied. Chef would like you to feel his happiness and provide him with a solution for this new problem with a sequence of integers. The problem is as follows.\nYou are given a sequence $A_1, A_2, \\dots, A_N$. You need to determine if it is possible to choose two indices $i$ and $j$ such that $A_i \\neq A_j$, but $A_{A_i}$ = $A_{A_j}$. (If it was possible, Chef would be truly happy.)\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains a single integer $N$.\n- The second line contains $N$ space-separated integers $A_1, A_2, \\ldots, A_N$.\n\n-----Output-----\nFor each test case, print a single line containing the string \"Truly Happy\" if it is possible to choose required indices or \"Poor Chef\" otherwise.\n\n-----Constraints-----\n- $1 \\le T \\le 1,000$\n- $1 \\le N \\le 10^5$\n- $1 \\le A_i \\le N$ for each valid $i$\n- the sum of $N$ over all test cases does not exceed $2 \\cdot 10^5$\n\n-----Subtasks-----\nSubtask #1 (27 points): $1 \\le N \\le 1,000$\nSubtask #2 (73 points): original constraints\n\n-----Example Input-----\n4\n4\n1 1 2 3\n4\n2 1 3 3\n5\n5 4 4 3 1\n5\n3 2 1 1 4\n\n-----Example Output-----\nTruly Happy\nPoor Chef\nPoor Chef\nTruly Happy\n\n-----Explanation-----\nExample case 1: Chef is truly happy because $A_{A_3} = A_{A_1}$ and $A_3 \\neq A_1$.\nExample case 2: There is no pair of indices which would make Chef truly happy. For instance, $A_{A_3} = A_{A_4}$, but $A_3 = A_4$,", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_happiness(n: usize, arr: Vec<usize>) -> (result: &'static str)\n    requires \n        n >= 1,\n        n <= 100000,\n        arr.len() == n,\n        forall|i: int| 0 <= i < arr.len() ==> 1 <= arr[i] && arr[i] <= n,\n    ensures \n        result == \"Truly Happy\" || result == \"Poor Chef\",\n        (result == \"Truly Happy\") <==> \n            (exists|i: int, j: int| \n                #![trigger arr[i], arr[j]]\n                0 <= i < arr.len() && \n                0 <= j < arr.len() && \n                i != j &&\n                arr[i] != arr[j] &&\n                1 <= arr[i] && arr[i] <= arr.len() &&\n                1 <= arr[j] && arr[j] <= arr.len() &&\n                arr[(arr[i] - 1) as int] == arr[(arr[j] - 1) as int])", "vc-code": "{\n    // impl-start\n    assume(false);\n    \"Poor Chef\"\n    // impl-end\n}", "vc-postamble": "\nproof fn solve_happiness_basic_cases() {\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn solve_happiness_increasing_sequence(n: usize, arr: Vec<usize>)\n    requires\n        n >= 1,\n        n <= 10,\n        arr.len() == n,\n        forall|i: int| 0 <= i < arr.len() ==> arr[i] == (i + 1) as usize,\n    ensures\n        !(exists|i: int, j: int| \n            #![trigger arr[i], arr[j]]\n            0 <= i < arr.len() && \n            0 <= j < arr.len() && \n            i != j &&\n            arr[i] != arr[j] &&\n            1 <= arr[i] && arr[i] <= arr.len() &&\n            1 <= arr[j] && arr[j] <= arr.len() &&\n            arr[(arr[i] - 1) as int] == arr[(arr[j] - 1) as int])\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\n}\n\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: unguarded\n\n    // println!(\"{}\", solve_happiness(4, vec![1, 1, 2, 3]));  // Expected: \"Truly Happy\"\n    // println!(\"{}\", solve_happiness(4, vec![2, 1, 3, 3]));  // Expected: \"Poor Chef\"  \n    // println!(\"{}\", solve_happiness(5, vec![3, 2, 1, 1, 4])); // Expected: \"Truly Happy\"\n}"}
{"id": "fvapps_000595", "vc-description": "Lots of geeky customers visit our chef's restaurant everyday. So, when asked to fill the feedback form, these customers represent the feedback using a binary string (i.e a string that contains only characters '0' and '1'. \n\nNow since chef is not that great in deciphering binary strings, he has decided the following criteria to classify the feedback as Good or Bad : \n\nIf the string contains the substring \"010\" or \"101\", then the feedback is Good, else it is Bad. Note that, to be Good it is not necessary to have both of them as substring.\n\nSo given some binary strings, you need to output whether according to the chef, the strings are Good or Bad. \n\n-----Input-----\nThe first line contains an integer T denoting the number of feedbacks. Each of the next T lines contains a string composed of only '0'  and '1'.\n\n-----Output-----\nFor every test case, print in a single line Good or Bad as per the Chef's method of classification.\n\n-----Constraints-----\n-  1 ≤  T ≤   100 \n-  1  ≤  |S|   ≤  105 \n\nSum of length of all strings in one test file will not exceed 6*106.\n\n-----Example-----\nInput:\n2\n11111110\n10101010101010\n\nOutput:\nBad\nGood\n\n-----Explanation-----\nExample case 1.\n\nThe string doesn't contain 010 or 101 as substrings.\n\nExample case 2.\n\nThe string contains both 010 and 101 as substrings.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn contains_substring(s: Seq<char>, sub: Seq<char>) -> bool \n    decreases s.len()\n{\n    if sub.len() == 0 {\n        true\n    } else if s.len() < sub.len() {\n        false\n    } else if s.take(sub.len() as int) == sub {\n        true\n    } else {\n        contains_substring(s.skip(1), sub)\n    }\n}\n\nfn classify_feedback(s: Vec<char>) -> (result: &'static str)\n    requires s.len() > 0,\n    ensures \n        result == \"Good\" || result == \"Bad\",\n        result == \"Good\" <==> (contains_substring(s@, \"010\"@) || contains_substring(s@, \"101\"@)),\n        s.len() < 3 ==> result == \"Bad\",\n        s@ == \"010\"@ || s@ == \"101\"@ ==> result == \"Good\",\n        !(contains_substring(s@, \"010\"@) || contains_substring(s@, \"101\"@)) ==> result == \"Bad\"", "vc-code": "{\n    // impl-start\n    assume(false);\n    \"Bad\"\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let s1: Vec<char> = \"11111110\".chars().collect();\n    // let result1 = classify_feedback(s1);\n    // println!(\"{}\", result1);\n    \n    // let s2: Vec<char> = \"10101010101010\".chars().collect();\n    // let result2 = classify_feedback(s2);\n    // println!(\"{}\", result2);\n    \n    // let s3: Vec<char> = \"00010\".chars().collect();\n    // let result3 = classify_feedback(s3);\n    // println!(\"{}\", result3);\n}"}
{"id": "fvapps_000596", "vc-description": "Nikki's latest work is writing a story of letters. However, she finds writing story so boring that, after working for three hours, she realized that all she has written are M long words consisting entirely of letters A and B. Having accepted that she will never finish the story in time, Nikki has decided to at least have some fun with it by counting bubbly words.\n\nNow Nikki is connecting pairs of identical letters (A with A, B with B) by drawing lines above the word. A given word is bubbly if each letter can be connected to exactly one other letter in such a way that no two lines intersect. So here is your task. Help Nikki count how many words are bubbly.\n\nInput:\n- The first line of input contains the positive integer M, the number of words written down by Nikki.\n- Each of the following M lines contains a single word consisting of letters A and B, with length between 2 and 10^5, inclusive. The sum of lengths of all words doesn't exceed 10^6.\n\nOutput:\nThe first and only line of output must contain the number of bubbly words.\n\nConstraints:\n- 1 ≤ M ≤ 100\n\nSample Input:\n3\nABAB\nAABB\nABBA\n\nSample Output:\n2\n\nExplanation:\n- ABAB - It is not bubbly as A(indexed 1) will connect to A(indexed 3) by a line and when we try to connect B(indexed 2) with B(indexed 4) by a line then it will intersect with the line b/w A and A.\n- AABB - It is bubbly as line b/w A and A will not intersect with the line b/w B and B.\n- ABBA - It is also bubbly as lines will not intersect. We can draw line b/w A and A above the line b/w B and B.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_bubbly_spec(word: Seq<char>) -> bool {\n    true  /* placeholder specification */\n}\n\nfn is_bubbly(word: Vec<char>) -> (result: bool)\n    ensures result == is_bubbly_spec(word@)\n{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}\n\nspec fn count_bubbly_words_spec(words: Seq<Vec<char>>) -> nat\n    decreases words.len()\n{\n    if words.len() == 0 {\n        0nat\n    } else {\n        (if is_bubbly_spec(words[0]@) { 1nat } else { 0nat }) + count_bubbly_words_spec(words.skip(1))\n    }\n}\n\nfn count_bubbly_words(words: Vec<Vec<char>>) -> (result: usize)\n    ensures \n        result as nat == count_bubbly_words_spec(words@),\n        result <= words.len()", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let test_words = vec![\n    //     vec!['A', 'B', 'A', 'B'],\n    //     vec!['A', 'A', 'B', 'B'], \n    //     vec!['A', 'B', 'B', 'A']\n    // ];\n    // let result = count_bubbly_words(test_words);\n    // println!(\"{}\", result);\n}"}
{"id": "fvapps_000597", "vc-description": "Chef would like go shopping to buy ingredients for his special dish. The local grocery store has some special discount offers. If you want to buy some set of ingredients you will pay for all ingredients except the cheapest one. Chef would like to spend as little money as possible. You have to help him. :)\n\nThe store is pretty small and stocks only one unit of each ingredients. Opposite each ingredient is a hanging price tag corresponding to it. The salesman walked away for a minute, giving Chef an opportunity to swap some price tags. He would like to swap some tags to minimize his purchase cost.\n\n-----Input-----\nThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows. \n\nThe first line of each test case contains a single integer N denoting the number of ingredients Chef needs to buy. The second line contains N space-separated integers A1, A2, ... , AN denoting the value  written on the price tags opposite the needed ingredients. The third line contains a single integer M denoting the number of special offers. The following M lines lists inventory of special offers, one offer per line. Each line contains an integer Ci followed by Ci integers denoting the indices of ingredients constituting the ith discount offer.\n\n-----Output-----\nFor each test case, output a single line containing the minimal purchase cost.\n\n-----Constraints-----\n- T ≤ 5\n- 1 ≤ N ≤ 15\n- 1 ≤ Ai ≤ 106\n- 0 ≤ M ≤ 2N-1\n- 2 ≤ Ci ≤ N\n- Subtask 1 (15 points):  1 ≤ N ≤  5\n- Subtask 2 (25 points):  1 ≤ N ≤ 10\n- Subtask 3 (60 points):  1 ≤ N ≤ 15\n\n-----Example-----\nInput:\n1\n4 \n1 2 3 4\n3\n2 1 2\n2 3 4\n3 1 2 3\n\nOutput:\n6", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sum(l: Seq<nat>) -> nat\n    decreases l.len()\n{\n    if l.len() == 0 {\n        0\n    } else {\n        l[0] + sum(l.skip(1))\n    }\n}\n\nspec fn minimum(l: Seq<nat>) -> nat\n    decreases l.len()\n{\n    if l.len() == 0 {\n        0\n    } else if l.len() == 1 {\n        l[0]\n    } else {\n        if l[0] <= minimum(l.skip(1)) { l[0] } else { minimum(l.skip(1)) }\n    }\n}\n\nspec fn maximum(l: Seq<nat>) -> nat\n    decreases l.len()\n{\n    if l.len() == 0 {\n        0\n    } else if l.len() == 1 {\n        l[0]\n    } else {\n        if l[0] >= maximum(l.skip(1)) { l[0] } else { maximum(l.skip(1)) }\n    }\n}", "vc-helpers": "", "vc-spec": "fn calculate_min_cost(n: nat, arr: Vec<nat>, m: nat, offers: Vec<Vec<nat>>) -> (result: nat)\n    requires n == arr.len(),\n    ensures \n        result <= sum(arr@),\n        n == 1 ==> result == arr[0],\n        (n == 2 && exists|o: Vec<nat>| #[trigger] offers@.contains(o) && o.len() >= 2) \n            ==> result <= sum(arr@) && (arr.len() > 0 ==> result >= maximum(arr@)),\n        (n == 4 && offers.len() >= 4 && arr.len() > 0) ==> result <= sum(arr@) - minimum(arr@)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    /* Apps difficulty: interview\n    Assurance level: unguarded\n\n    #eval calculate_min_cost 4 [1, 2, 3, 4] 3 [[2, 1, 2], [2, 3, 4], [3, 1, 2, 3]]\n    Expected: 6\n\n    #eval calculate_min_cost 3 [1, 2, 3] 1 [[2, 1, 2]]\n    Expected: 4\n\n    #eval calculate_min_cost 2 [5, 10] 1 [[2, 1, 2]]\n    Expected: 10 */\n}"}
{"id": "fvapps_000598", "vc-description": "Nexus 4.O is going to be organized by ASME, GLA University. Shubhanshu, Head of Finance Team is working for it. He has N number of bills of different values as a1, a2, a3…an.\nHe is interested in a game in which one has to do the addition of the bills. But due to privacy concerns, he cannot share the details with others. \nHe can only trust his best friend Avani with such a confidential thing. So, he asked her to play this game.\nRules of the game :\n- Avani needs to answer Q queries.\n- Every Qi query has 2 values Xi and Yi.\n- Avani needs to find the sum of the values between Xi and Yi (inclusive).\nSo, you need to help Avani in answering the Q queries\n\n-----Input:-----\n- First line will contain T, number of testcases. Then the testcases follow. \n- The first line of each test case contains the value N and Q.\n- The second line of each test case contains the N space-separated values as a1, a2, a3…an.\n- The next line of each test case containing Q query with Xi and Yi.\n\n-----Output:-----\nFor each test case, Print the total amount between Xi and Yi for Q number of queries.\n\n-----Constraints-----\n- 1 ≤ T ≤ 100\n- 1 ≤ N ≤ 10^5\n- 1 ≤ Q ≤ 10^5\n- 1 ≤ ai ≤ 10^9\n\n-----Sample Input:-----\n1\n8 3\n1 2 3 4 5 6 7 8\n2 3\n1 6\n5 8\n\n-----Sample Output:-----\n5\n21\n26\n\n-----EXPLANATION:-----\nQ1 : (2,3) 2+3=5\nQ2 : (1,6) 1+2+3+4+5+6=21\nQ3 : (5,8) 5+6+7+8=26", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn range_sum(bills: Seq<nat>, start: nat, end: nat) -> nat \n    decreases end - start\n{\n    if start > end || start >= bills.len() {\n        0\n    } else if start == end {\n        bills[start as int]\n    } else {\n        bills[start as int] + range_sum(bills, start + 1, end)\n    }\n}\n\nfn solve_bill_queries(n: usize, q: usize, bills: Vec<nat>, queries: Vec<(usize, usize)>) -> (result: Vec<nat>)\n    requires \n        bills.len() > 0,\n        queries.len() > 0,\n        n == bills.len(),\n        q == queries.len(),\n    ensures \n        result.len() == queries.len(),\n        forall|i: int| 0 <= i < result.len() ==> \n            #[trigger] result[i] == range_sum(bills@, (queries[i].0 - 1) as nat, (queries[i].1 - 1) as nat),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let test_bills = vec![1, 2, 3, 4, 5, 6, 7, 8];\n    // let test_queries = vec![(2, 3), (1, 6), (5, 8)];\n    // let result = solve_bill_queries(8, 3, test_bills, test_queries);\n    // println!(\"Result: {:?}\", result); // Expected: [5, 21, 26]\n}"}
{"id": "fvapps_000602", "vc-description": "In a regular table tennis match, the player who serves changes every time after 2 points are scored, regardless of which players scored them.\nChef and Cook are playing a different match — they decided that the player who serves would change every time after K points are scored instead (again regardless of which players scored them). When the game starts, it's Chef's turn to serve.\nYou are given the current number of points scored by Chef and Cook (P_1 and P_2 respectively). Find out whether Chef or Cook has to serve next.\n\nInput:\n- The first line of the input contains a single integer T denoting the number of test cases. The description of T test cases follows.\n- The first and only line of each test case contains three space-separated integers P_1, P_2 and K.\n\nOutput:\nFor each test case, print a single line containing the string \"CHEF\" if it is Chef's turn or \"COOK\" if it is Cook's turn.\n\nConstraints:\n- 1 ≤ T ≤ 10^5\n- 1 ≤ K ≤ 10^9\n- 0 ≤ P_1, P_2 ≤ 10^9\n\nExample:\nInput:\n3\n1 3 2\n0 3 2\n34 55 2\n\nOutput:\nCHEF\nCOOK\nCHEF\n\nExplanation:\nExample case 1: Chef serves for the first two points, Cook serves for the next two, so Chef has to serve again now.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn determine_server(p1: u32, p2: u32, k: u32) -> (result: &'static str)\n    requires k > 0,\n    ensures \n        result == \"CHEF\" || result == \"COOK\",\n        ((p1 + p2) % (2 * k) < k) ==> result == \"CHEF\",\n        ((p1 + p2) % (2 * k) >= k) ==> result == \"COOK\"", "vc-code": "{\n    // impl-start\n    assume(false);\n    \"CHEF\"\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000603", "vc-description": "Find the length of the longest contiguous segment in an array, in which if a given element K is inserted, K becomes the second largest element of that subarray.\n\nInput:\n- The first line will contain T, number of test cases. Then the test cases follow. \n- The first line of each test case contains two integers N and K.\n- The next line contains N space-separated integers Ai denoting the elements of the array.\n\nOutput:\nPrint a single line corresponding to each test case — the length of the largest segment.\n\nConstraints:\n- 1 ≤ T ≤ 10\n- 1 ≤ N ≤ 10^6\n- 1 ≤ Ai, K ≤ 10^9\n- Sum of N across all test cases doesn't exceed 10^6\n\nSample Input:\n2\n5 3\n2 4 2 4 2\n8 5\n9 3 5 7 8 11 17 2\n\nSample Output:\n5\n3\n\nExplanation:\nIf 3 is inserted at anywhere in the array, it is the second largest element. Hence the maximum length is 5.\nIf 5 is inserted anywhere between 1st and 4th element, it is the second largest element. The length of such subarray is 3.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_longest_segment(n: usize, k: u32, nums: Vec<u32>) -> (result: usize)\n    requires \n        n > 0,\n        nums.len() == n,\n    ensures\n        result <= n,\n        result >= 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000605", "vc-description": "Chef has a rectangular piece of paper. He puts it on a big board in such a way that two sides of the paper are horizontal and two are vertical, and then he performs a sequence of $N$ operations. You are given a string $S$ with length $N$; for each valid $i$, the $i$-th character of $S$ determines the type of the $i$-th operation:\n- 'R': Pick up the paper from the right side and fold it onto the left side.\n- 'L': Pick up the paper from the left side and fold it onto the right side.\n- 'U': Pick up the paper from the upper side and fold it onto the bottom side.\n- 'D': Pick up the paper from the bottom side and fold it onto the upper side.\nThe paper is folded in such a way that there is still a flat rectangular sheet of paper lying on the table after each operation, but it consists of multiple layers of the original sheet. The lengths of the horizontal and vertical sides of the resulting sheet (after performing these $N$ operations) are $W$ and $H$ respectively. Let's build an Euclidean coordinate system on the paper, where the point $(0, 0)$ corresponds to the bottom left corner and $(W, H)$ to the upper right corner.\nChef then draws $M$ points on this folded sheet of paper. The ink used to draw them soaks deep into the paper, so each point is drawn on all layers of the paper (and also on both faces of each layer). \nFinally, Chef completely unfolds the paper. He's asking you to compute the distance between the nearest pair of points.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_paper_folding(n: usize, m: usize, w: usize, h: usize, s: Vec<char>, points: Vec<(usize, usize)>) -> (result: f64)\n    requires \n        n >= 1,\n        m >= 2,\n        w >= 3,\n        h >= 3,\n        s.len() == n,\n        points.len() == m", "vc-code": "{\n    // impl-start\n    assume(false);\n    0.0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000609", "vc-description": "The Chef has prepared the appetizers in the shapes of letters to spell a special message for the guests. There are n appetizers numbered from 0 to n-1 such that if the appetizers are arrayed in this order, they will display the message. The Chef plans to display them in this order on a table that can be viewed by all guests as they enter. The appetizers will only be served once all guests are seated.\n\nThe appetizers are not necessarily finished in the same order as they are numbered. So, when an appetizer is finished the Chef will write the number on a piece of paper and place it beside the appetizer on a counter between the kitchen and the restaurant. A server will retrieve this appetizer and place it in the proper location according to the number written beside it.\n\nThe Chef has a penchant for binary numbers. The number of appetizers created is a power of 2, say n = 2k. Furthermore, he has written the number of the appetizer in binary with exactly k bits. That is, binary numbers with fewer than k bits are padded on the left with zeros so they are written with exactly k bits.\n\nUnfortunately, this has unforseen complications. A binary number still \"looks\" binary when it is written upside down. For example, the binary number \"0101\" looks like \"1010\" when read upside down and the binary number \"110\" looks like \"011\" (the Chef uses simple vertical lines to denote a 1 bit). The Chef didn't realize that the servers would read the numbers upside down so he doesn't rotate the paper when he places it on the counter. Thus, when the server picks up an appetizer they place it the location indexed by the binary number when it is read upside down.\n\nYou are given the message the chef intended to display and you are to display the message that will be displayed after the servers move all appetizers to their locations based on the binary numbers they read.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn scramble_message(step: usize, input: &str) -> (result: String)\n    requires step > 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000611", "vc-description": "Naturally, the magical girl is very good at performing magic. She recently met her master wizard Devu, who gifted her R potions of red liquid, \nB potions of blue liquid, and G potions of green liquid.\n\nThe red liquid potions have liquid amounts given by r[1], ..., r[R] liters. \n\nThe green liquid potions have liquid amounts given by g[1], ..., g[G] liters. \n\nThe blue liquid potions have liquid amounts given by b[1], ..., b[B] liters. \n\nShe want to play with the potions by applying magic tricks on them. In a single magic trick, she will choose a particular color. Then she will pick all the potions of the chosen color and decrease the amount of liquid in them to half (i.e. if initial amount \nof liquid is x, then the amount after decrement will be x / 2  where division is integer division, e.g. 3 / 2 = 1 and 4 / 2 = 2). \n\nBecause she has to go out of station to meet her uncle Churu, a wannabe wizard, only M minutes are left for her. In a single minute, she can perform at most one magic trick. Hence, she can perform at most M magic tricks.\n\nShe would like to minimize the maximum amount of liquid among all of Red, Green and Blue colored potions. Formally Let v be the maximum value of amount of liquid in any potion. We want to minimize the value of v.\nPlease help her.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn list_max(l: Seq<nat>) -> nat \n    decreases l.len()\n{\n    if l.len() == 0 {\n        0\n    } else if l.len() == 1 {\n        l[0]\n    } else {\n        let rest_max = list_max(l.skip(1));\n        if l[0] > rest_max { l[0] } else { rest_max }\n    }\n}", "vc-spec": "fn solve_magic_potions(R: nat, G: nat, B: nat, M: nat, r: Vec<nat>, g: Vec<nat>, b: Vec<nat>) -> (result: nat)\n    requires \n        R > 0,\n        G > 0,\n        B > 0,\n        r.len() == R,\n        g.len() == G,\n        b.len() == B,\n        forall|x: nat| r@.contains(x) || g@.contains(x) || b@.contains(x) ==> x > 0,\n    ensures\n        result >= 0,\n        result <= {\n            let max_r = list_max(r@);\n            let max_g = list_max(g@);\n            let max_b = list_max(b@);\n            if max_r >= max_g && max_r >= max_b { max_r }\n            else if max_g >= max_b { max_g }\n            else { max_b }\n        },", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "}\n\nfn main() {\n    // let result1 = solve_magic_potions(1, 1, 1, 1, vec![1], vec![2], vec![3]);\n    // println!(\"Result 1: {}\", result1);\n    \n    // let result2 = solve_magic_potions(1, 1, 1, 1, vec![2], vec![4], vec![6]);\n    // println!(\"Result 2: {}\", result2);\n    \n    // let result3 = solve_magic_potions(3, 2, 2, 2, vec![1, 2, 3], vec![2, 4], vec![6, 8]);\n    // println!(\"Result 3: {}\", result3);\n}"}
{"id": "fvapps_000612", "vc-description": "Cersei wants to be the queen of seven kingdoms.\n\nFor this to happen, she needs to address the soldiers in her army. There are n soldiers in her army (numbered 1 through n). Cersei passes on the message to the first soldier (soldier 1).   \nThis message needs to reach every soldier in the army. For this, the soldiers communicate among themselves by one soldier passing the message to another soldier through some communication links. It is known that the message could reach every soldier using the given links.\nNow, each soldier will receive the message from exactly one soldier or Cersei and could pass on the message to atmost two soldiers. That is each soldier (except soldier 1) has only one incoming link and every soldier (including soldier 1) has atmost two outgoing links.  \nNow, the High Sparrow feels that Cersei is planning to kill his people first. Hence, for the sake of his people, he decided to appoint some sparrows to overhear every conversation between the soldiers (The conversation between Cersei and the first soldier needn't be overheard due to the fear of Ser Gregor Clegane).   \nTo overhear a conversation between soldiers A and B, there needs to be a sparrow either at soldier A or soldier B or both.\nAlso, by his research, the High Sparrow has found that the soldiers are partitioned into some classes (1 to k). That is, every soldier belongs to exactly one class. He then demands the presence of atleast one sparrow with each class he knows (1 to k).\nFind the minimum number of sparrows the High Sparrow needs to recruit for the job or tell that he couldn't.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_sparrow_problem(n: nat, k: nat, classes: Vec<nat>, links: Vec<(nat, nat)>) -> (result: i32)\n    requires \n        n >= 1,\n        k >= 1,\n        classes.len() == n,\n        links.len() == n - 1,\n        forall|i: int| 0 <= i < n ==> #[trigger] classes[i] >= 1 && #[trigger] classes[i] <= k,\n    ensures\n        result >= -1\n{\n    // impl-start\n    assume(false);\n    -1\n    // impl-end\n}\n\nfn is_valid_tree(n: nat, links: Vec<(nat, nat)>) -> (result: bool)\n    requires n >= 1\n{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-code": "", "vc-postamble": "\n}\nfn main() {\n    // let result1 = solve_sparrow_problem(5, 3, vec![1, 1, 2, 2, 3], vec![(1, 2), (1, 3), (2, 4), (2, 5)]);\n    // assert(result1 == 3);\n    \n    // let result2 = solve_sparrow_problem(5, 5, vec![1, 1, 2, 2, 3], vec![(1, 2), (1, 3), (2, 4), (2, 5)]);\n    // assert(result2 == -1);\n}"}
{"id": "fvapps_000615", "vc-description": "Lyra Belacqua is a very gifted girl. She is one of a very small set of people capable of reading an alethiometer, more commonly known as The Golden Compass. It has one specific use: to tell the truth. The name in fact, is derived from \"Aletheia\" meaning truth, and \"-ometer\", meaning \"measuring device\".\n\nThe alethiometer had four needles, out of which the user would direct three of them to lie over symbols on the face of the device to ask a question. The fourth needle then swung into action and pointed to various symbols one after another, thus telling the answer.\n\nFor this problem, consider the alethiometer consisting of symbols : digits '0'-'9' and letters 'A'-'Z'. Learned scholars were debating the age of the Universe, and they requested Lyra to find out the age from the alethiometer. Having asked the question, the fourth needle started spouting out symbols, which Lyra quickly recorded. In that long string of characters, she knows that some substring corresponds to the age of the Universe. She also knows that the alethiometer could have wrongly pointed out atmost one digit (0-9) as a letter (A-Z). She then wonders what is the maximum possible age of the Universe.\n\nGiven the set of symbols the alethiometer pointed out, help her find the maximum age of the Universe, which could correspond to a substring of the original string with atmost one letter changed.\n\nNote: We consider a substring to be a contiguous part of the string S \n\nAlso, the alethiometer wrongly reports only a letter. All the digits remain as they are.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_uppercase_letter(c: char) -> bool {\n    'A' <= c && c <= 'Z'\n}\n\nspec fn all_uppercase_letters(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> is_uppercase_letter(s[i])\n}\n\nfn process_string(s: Vec<char>) -> (result: u64)\n    ensures \n        all_uppercase_letters(s@) ==> result == s.len() as u64,\n        s.len() == 1 && !is_uppercase_letter(s@[0]) ==> result < 10,\n        s.len() == 2 && !all_uppercase_letters(s@) ==> result >= 10 && result < 100,\n        s.len() >= 3 && !all_uppercase_letters(s@) ==> result >= 100,", "vc-code": "{\n    // impl-start\n    assume(false);\n    0u64\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000619", "vc-description": "You will be given m strings. For each of those strings, you need to count the total number of appearances of that string as substrings in all possible strings of length n containing only lower case English letters. \n\nA string may appear in a string multiple times. Also, these appearances may overlap. All these must be counted separately. For example, aa appears thrice in the string aaacaa: aaacaa, aaacaa and aaacaa.\n\n-----Input-----\n- The first line contains one integer, T, the number of test cases. The description of each test case follows:\n- The first line of each test case will contain two integers n and m.\n- The ith of the next m lines will have one string in each line. All the strings will consist only of lower case English letters.\n\n-----Output-----\n- For each test case, print \"Case x:\" (without quotes. x is the test case number, 1-indexed) in the first line.\n- Then print m lines. The ith line should contain the number of appearances of the ith string in all possible strings of length n. As the numbers can be very large, print the answers modulo 109+7.\n\n-----Constraints-----\n- 1 ≤ T ≤ 100\n- 1 ≤ n ≤ 100000\n- 1 ≤ m ≤ 1000 \n- 1 ≤ Length of every string in input\n- 1 ≤ Total length of all strings in one test case ≤ 5 * 105\n- 1 ≤ Total length of all strings in one test file ≤ 5 * 106\n\n-----Example-----\nInput:\n3\n2 1\naa\n2 1\nd\n12 3\ncdmn\nqweewef\nqs\n\nOutput:\nCase 1:\n1\nCase 2:\n52\nCase 3:\n443568031\n71288256\n41317270\n\n-----Explanation:-----\nTestcase 1: aa is the only string of length 2 which contains aa as a substring. And it occurs only once. Hence the answer is 1.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn MOD() -> nat { 1000000007 }\n\nfn count_substring_appearances(n: usize, strings: Vec<Vec<char>>) -> (result: Vec<usize>)\n    ensures \n        result.len() == strings.len(),\n        forall|i: int| 0 <= i < strings.len() ==> {\n            if strings[i].len() > n {\n                result[i] == 0\n            } else {\n                result[i] < MOD()\n            }\n        },\n        strings.len() == 0 ==> result.len() == 0,\n        (n == 1 && strings.len() == 1 && strings[0].len() == 1) ==> result[0] == 1,\n        (n == 1 && strings.len() == 1 && strings[0].len() > 1) ==> result[0] == 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded_and_plausible\n\n    // Test cases:\n    // count_substring_appearances(2, vec![vec!['a', 'a']]) should return [1]\n    // count_substring_appearances(2, vec![vec!['d']]) should return [52] \n    // count_substring_appearances(12, vec![vec!['c','d','m','n'], vec!['q','w','e','e','w','e','f'], vec!['q','s']]) should return [443568031, 71288256, 41317270]\n}"}
{"id": "fvapps_000621", "vc-description": "Chef made two laddus with sweetness X and Y respectively. Cheffina comes and sees the chef created two laddus with different sweetness (might be same). Cheffina has the magical power to make the sweetness of laddus equal. Cheffina requires 1 unit of power to increase the sweetness of laddu by its original value i.e. 1 unit to convert Z to 2Z and 2 unit to convert Z to 3Z and so on… How many units of power does cheffina want to make the sweetness equal?\n\n-----Input:-----\n- First-line will contain $T$, the number of test cases. Then the test cases follow. \n- Each test case contains a single line of input, two integers $X, Y$. \n\n-----Output:-----\nFor each test case, output in a single line answer as power required.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10^5$\n- $1 \\leq X,Y \\leq 10^5$\n\n-----Sample Input:-----\n2\n2 2\n4 6\n\n-----Sample Output:-----\n0\n3\n\n-----EXPLANATION:-----\nFor 1) Sweetness are same so no need to use power.\nFor 2) \n1st laddu\n2 Unit power = 4 -> 12\n2nd Laddu\n1 Unit power = 6 -> 12\nAfter using total 3 unit power sweetness of both laddus are same.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_laddu_power(x: nat, y: nat) -> (result: nat)\n    ensures \n        result >= 0,\n        x == y ==> result == 0,\n        (x == 1 && y == 1) ==> result == 0,\n        (x == 2 && y == 2) ==> result == 0,\n        (x == 4 && y == 6) ==> result == 3,\n        (x == 3 && y == 9) ==> result == 2", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "}\n\nfn main() {\n    // // Apps difficulty: interview\n    // // Assurance level: unguarded\n    // \n    // assert(solve_laddu_power(2, 2) == 0);\n    // assert(solve_laddu_power(4, 6) == 3);\n    // assert(solve_laddu_power(3, 9) == 2);\n}"}
{"id": "fvapps_000626", "vc-description": "Chef has K chocolates and he wants to distribute them to N people (numbered 1 through N). These people are standing in a line in such a way that for each i (1 ≤ i ≤ N-1), person i and person i+1 are adjacent.\nFirst, consider some way to distribute chocolates such that for each valid i, the number of chocolates the i-th person would receive from Chef is A_i and the sum S_1 = ∑_{i=1}^{N-1} |A_i - A_{i+1}| is minimum possible. Of course, each person must receive a non-negative integer number of chocolates.\nThen, Chef wants to create a new sequence B_1, B_2, …, B_N by rearranging (permuting) the elements of the sequence A_1, A_2, …, A_N. For each valid i, the number of chocolates the i-th person actually receives from Chef is B_i. Chef wants to distribute the chocolates (choose B_1, B_2, …, B_N by permuting the sequence A and give B_i chocolates to the i-th person for each valid i) in such a way that S_2 = ∑_{i=1}^{N-1} |B_i – B_{i+1}| is maximum possible. You need to find the maximum value of S_2.\nIt is guaranteed that S_2 does not depend on the exact choice of the sequence A_1, A_2, …, A_N, as long as it is a sequence that minimises S_1.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_chocolate_distribution(n: nat, k: nat) -> (result: nat)\n    requires n > 0,\n    ensures \n        result >= 0,\n        result <= 2 * n - 1,\n        k == 0 ==> result == 0,\n        k % n == 0 ==> result == 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let result1 = solve_chocolate_distribution(3, 2);\n    // println!(\"Result for (3, 2): {}\", result1);\n    \n    // let result2 = solve_chocolate_distribution(2, 2);\n    // println!(\"Result for (2, 2): {}\", result2);\n    \n    // let result3 = solve_chocolate_distribution(3, 4);\n    // println!(\"Result for (3, 4): {}\", result3);\n}"}
{"id": "fvapps_000628", "vc-description": "Ashley wrote a random number generator code.\nDue to some reasons, the code only generates random positive integers which are not evenly divisible by 10. She gives N and S as input to the random number generator. The code generates a random number with number of digits equal to N and sum of digits equal to S. The code returns -1 if no number can be generated. Print \"-1\" in such cases (without quotes). Else print the minimum possible product of digits of the random number generated.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_random_generator(n: nat, s: nat) -> (result: i32)\n    ensures \n        result >= -1 &&\n        (n == 1 ==> result == s as i32) &&\n        (n == 2 && s > 1 ==> result == (s - 1) as i32) &&\n        (n > 2 && s > 1 ==> result == 0) &&\n        (s <= 1 && n > 1 ==> result == -1)", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let test1 = solve_random_generator(1, 5);\n    // let test2 = solve_random_generator(2, 2);\n    // let test3 = solve_random_generator(3, 5);\n}"}
{"id": "fvapps_000635", "vc-description": "Three numbers A, B and C are the inputs. Write a program to find second largest among them.\n\n-----Input-----\n\nThe first line contains an integer T, the total number of testcases. Then T lines follow, each line contains three integers A, B and C. \n\n-----Output-----\nFor each test case, display the second largest among A, B and C, in a new line.\n\n-----Constraints-----\n- 1 ≤ T ≤ 1000\n- 1 ≤ A,B,C ≤ 1000000\n\n-----Example-----\nInput\n3 \n120 11 400\n10213 312 10\n10 3 450\n\nOutput\n\n120\n312\n10", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn find_second_largest(l: Vec<i32>) -> (result: i32)\n    requires l.len() >= 3,\n    ensures\n        exists|x: i32| l@.contains(x) && x > result,\n        exists|x: i32| l@.contains(x) && x < result,\n        l@.contains(result)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "/* Apps difficulty: interview */\n/* Assurance level: guarded */\n\n// #guard_msgs in\n// #eval find_second_largest [120, 11, 400]\n\n// #guard_msgs in\n// #eval find_second_largest [10213, 312, 10]\n\n// #guard_msgs in\n// #eval find_second_largest [10, 3, 450]\n\n}\n\nfn main() {}"}
{"id": "fvapps_000637", "vc-description": "Write a program to obtain a number N and increment its value by 1 if the number is divisible by 4 otherwise decrement its value by 1.\n\n-----Input:-----\n- First line will contain a number N.\n\n-----Output:-----\nOutput a single line, the new value of the number.\n\n-----Constraints-----\n- 0 ≤ N ≤ 1000\n\n-----Sample Input:-----\n5\n\n-----Sample Output:-----\n4\n\n-----EXPLANATION:-----\nSince 5 is not divisible by 4 hence, its value is decreased by 1.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn increment_or_decrement(n: i32) -> (result: i32)\n    requires 0 <= n <= 1000,\n    ensures \n        (n % 4 == 0) ==> (result == n + 1),\n        (n % 4 != 0) ==> (result == n - 1),\n        (result - n == 1) || (result - n == -1),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // #guard_msgs in\n    // #eval increment_or_decrement 5\n\n    // #guard_msgs in  \n    // #eval increment_or_decrement 8\n\n    // #guard_msgs in\n    // #eval increment_or_decrement 3\n}"}
{"id": "fvapps_000639", "vc-description": "A sequence of integers (a_1, a_2, ..., a_k) is said to be UpDown, if these inequalities hold true:\n- a_1 ≤ a_2\n- a_2 ≥ a_3\n- a_3 ≤ a_4\nand so on.\nThat is, every even-indexed element should be at least as large as its adjacent elements. And every odd-indexed element should be at most as large as its adjacent elements. Formally, a_{2i} ≥ a_{2i+1} and a_{2i+1} ≤ a_{2i+2}, for all valid positions.\nA subsegment is a consecutive portion of a sequence. That is, a subsegment of (b_1, b_2, ..., b_k) will be of the form (b_i, b_{i+1}, ..., b_j), for some i and j.\nYou are given a sequence (s_1, s_2, ..., s_n). You can insert at most one integer anywhere in this sequence. It could be any integer. After inserting an integer (or choosing not to), suppose you have the new sequence (t_1, t_2, ..., t_m). Note that m will either be n+1 or n. You want to maximize the length of the longest subsegment of (t_1, t_2, ..., t_m) which is UpDown, and output the length of that.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn find_updown_length(n: nat, arr: Vec<i32>) -> (result: nat)\n    requires \n        arr.len() == n,\n        n >= 1,\n    ensures \n        n >= 2 ==> result >= 2,\n        result <= n + 1", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = find_updown_length(7, vec![100, 1, 10, 3, 20, 25, 24]);\n    // println!(\"Result 1: {}\", result1); // Should be 7\n    \n    // let result2 = find_updown_length(5, vec![3, 3, 2, 4, 1]);\n    // println!(\"Result 2: {}\", result2); // Should be 6\n    \n    // let result3 = find_updown_length(4, vec![1, 2, 1, 3]);\n    // println!(\"Result 3: {}\", result3); // Should be 5\n}"}
{"id": "fvapps_000641", "vc-description": "The chef was busy in solving algebra, he found some interesting results, that there are many numbers which can be formed by the sum of the factorial of the digits, he wrote all those interesting numbers in the diary(in increasing order) and went to sleep. Cheffina came and stole his diary, in morning chef found that his diary is missing. Now the chef wants your help to find those numbers, Chef asks you whether N is that interesting number or not. If N is an interesting number then print 1. Else print 0. \n\n-----Input:-----\n- First-line will contain $T$, the number of test cases. Then the test cases follow. \n- Each test case contains a single line of input, $N$. \n\n-----Output:-----\nFor each test case, output in a single line answer 1 or 0.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10^6$\n- $0 \\leq N \\leq 10^9$\n\n-----Sample Input:-----\n2\n2\n10\n\n-----Sample Output:-----\n1\n0\n\n-----EXPLANATION:-----\nFor 1) Factorial of 2 is 2, hence it is an interesting number.\nFor 2) conversion for 10 is 1! + 0! = 2, which is not equal to 10, hence not an interesting number.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn is_special_factorial_number(n: i32) -> (result: i32)\n    ensures \n        result == 0 || result == 1,\n        (n == 1 || n == 2 || n == 145 || n == 40585) ==> result == 1,\n        (n != 1 && n != 2 && n != 145 && n != 40585) ==> result == 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded\n}"}
{"id": "fvapps_000642", "vc-description": "Raju has created a program to find the square root of a number. But his program can store only integers. Being a newbie, he didn't know about rounding the numbers. Hence his program returns the absolute value of the result if possible. For example, sqrt(3) = 1.73205080757……. His program will return 1\nGiven a number $N$, and it's integral square root $S$, His instructor will consider the answer correct if Difference between $N$ and the square of $S$ is within less than or equal to $X$% of $N$.\n\n-----Input:-----\n- First line contains $T$ no. of test cases and $X$ separated by space\n- For every test case, a line contains an integer $N$\n\n-----Output:-----\nFor every test case, print yes  if his programs return square root and (N-(S^2)) <= 0.01XN . For everything else, print no on a new line\n\n-----Constraints-----\n10 points:\n- $1 \\leq T \\leq 10$\n- $0\\leq N \\leq 10$\n20 points:\n- $1 \\leq T \\leq 30000$\n- $-10^9 \\leq N \\leq 10^9$\n70 points:\n- $1 \\leq T \\leq 10^6$\n- $-10^9 \\leq N \\leq 10^9$\n\n-----Sample Input:-----\n2 20\n5\n3\n\n-----Sample Output:-----\nyes\nno\n\n-----EXPLANATION:-----\nIn #1, sqrt(5) = 2.2360679775. Taking integral value, S = 2.\n\nS2 = 4. Difference=1 which is within 20% of 5\nIn #1, sqrt(3) = 1.73205080757. Taking integral value, S = 1.\n\nS2 = 1. Difference=2  which is not within 20% of 3", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn sqrt(n: i32) -> (result: i32)\n    ensures \n        result >= 0,\n        n >= 0 ==> result * result <= n && (result + 1) * (result + 1) > n\n{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}\n\nfn check_sqrt_accuracy(scale: i32, tolerance: i32, numbers: Vec<i32>) -> (result: Vec<String>)\n    requires \n        0 < tolerance,\n        tolerance <= 100\n    ensures \n        result.len() == numbers.len()", "vc-code": "{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000644", "vc-description": "You are given a string S and an integer L. A operation is described as :- \"You are allowed to pick any substring from first L charcaters of S, and place it at the end of the string S. \nA string A is a substring of an string B if A can be obtained from B by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) elements from the end.\nFind the lexographically smallest string after performing this opertaion any number of times (possibly zero).\nFor example S = \"codechef\" and L=4. Then, we can take substring \"ode\" from S[0-3] and place it at end of the string S = \"cchefode\".\n\n-----Input:-----\n- First line will contain T, number of testcases. \n- Then each of the N lines contain an integer L and a string S. \n\n-----Output:-----\nFor each testcase, output in a single line answer lexographically smallest string.\n\n-----Constraints-----\n- 1 ≤ T ≤ 10^4\n- 2 ≤ |S| ≤ 10^3\n- 1 ≤ L ≤ N \n\n-----Sample Input:-----\n2\n1 rga\n2 cab\n\n-----Sample Output:-----\narg\nabc\n\n-----EXPLANATION:-----\nIn the first testcase:\nsubstring 'r' is picked and placed at the end of the string. rga -> gar\nThen performing same operation gives :- gar -> arg", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn char_count(s: Seq<char>, c: char) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0nat\n    } else {\n        (if s[0] == c { 1nat } else { 0nat }) + char_count(s.skip(1), c)\n    }\n}\n\nspec fn is_rotation(s1: Seq<char>, s2: Seq<char>) -> bool {\n    s1.len() == s2.len() && \n    exists|i: int| 0 <= i < s1.len() && s2 == s1.skip(i) + s1.take(i)\n}\n\nspec fn lex_compare(s1: Seq<char>, s2: Seq<char>) -> bool\n    decreases s1.len() + s2.len()\n{\n    if s1.len() == 0 { true }\n    else if s2.len() == 0 { false }\n    else if s1[0] < s2[0] { true }\n    else if s1[0] > s2[0] { false }\n    else { lex_compare(s1.skip(1), s2.skip(1)) }\n}\n\nfn solve(l: usize, s: Vec<char>) -> (result: Vec<char>)\n    requires \n        l >= 1,\n        l <= s.len(),\n        s.len() > 0,\n    ensures\n        result.len() == s.len(),\n        forall|c: char| char_count(result@, c) == char_count(s@, c),\n        l == 1 ==> is_rotation(s@, result@),\n        l == 1 ==> forall|i: int| 0 <= i < s.len() ==> \n            lex_compare(result@, s@.skip(i) + s@.take(i)),\n        l >= 2 ==> lex_compare(result@, s@),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = solve(1, vec!['r', 'g', 'a']);\n    // assert(result1 == vec!['a', 'r', 'g']);\n    \n    // let result2 = solve(2, vec!['c', 'a', 'b']);\n    // assert(result2 == vec!['a', 'b', 'c']);\n    \n    // let result3 = solve(4, vec!['c', 'o', 'd', 'e', 'c', 'h', 'e', 'f']);\n    // println!(\"Results verified\");\n}"}
{"id": "fvapps_000645", "vc-description": "This year p footballers and q cricketers have been invited to participate in IPL (Indian Programming League) as guests. You have to accommodate them in r rooms such that-\n- No room may remain empty.\n- A room may contain either only footballers or only cricketers, not both.\n- No cricketers are allowed to stay alone in a room.\nFind the number of ways to place the players. Note though, that all the rooms are identical. But each of the cricketers and footballers are unique. \nSince the number of ways can be very large, print the answer modulo 998,244,353.\n\n-----Input-----\n- The first line of the input contains a single integer T denoting the number of test cases. The description of T test cases follows.\n- The first and only line of each test case contains three space-separated integers p, q and r denoting the number of footballers, cricketers and rooms.\n\n-----Output-----\nFor each test case, output the number of ways to place the players modulo 998,244,353.\n\n-----Constraints-----\n- 1 ≤ T ≤ 100\n- 1 ≤ p, q, r ≤ 100\n\n-----Example Input-----\n4\n2 1 4\n2 4 4\n2 5 4\n2 8 4\n\n-----Example Output-----\n0\n3\n10\n609\n\n-----Explanation-----\nExample case 2: Three possible ways are:\n- {Footballer 1}, {Footballer 2}, {Cricketer 1, Cricketer 2}, {Cricketer 3, Cricketer 4}\n- {Footballer 1}, {Footballer 2}, {Cricketer 1, Cricketer 3}, {Cricketer 2, Cricketer 4}\n- {Footballer 1}, {Footballer 2}, {Cricketer 1, Cricketer 4}, {Cricketer 2, Cricketer 3}    \nPlease note that the rooms are identical.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn MOD() -> nat { 998244353 }\n\nfn solve_ipl_rooms(p: u32, q: u32, r: u32) -> (result: u32)\n    requires p > 0 && q > 0 && r > 0,\n    ensures \n        result < MOD(),\n        (p + q/2 < r) ==> (result == 0),", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // /* Apps difficulty: interview */\n    // /* Assurance level: guarded_and_plausible */\n\n    // /* Test cases:\n    //  * solve_ipl_rooms(2, 1, 4) should return 0\n    //  * solve_ipl_rooms(2, 4, 4) should return 3\n    //  * solve_ipl_rooms(2, 5, 4) should return 10\n    //  */\n}"}
{"id": "fvapps_000646", "vc-description": "Chef organised a chess tournament, which spanned over M months. There were N players, and player i was rated R_i before the start of the tournament. To see the progress of the players, he noted their rating changes at the end of each month.\nAfter the tournament, FIDE asked Chef to find the number of players whose peak rating and peak ranking did not occur in the same month. In other words, Chef was asked to find the ratings and ranking of each player after each of the M months. Then, using this data, he should find the number of players, such that the month in which they achieved their highest rating over all the months, was different from the month in which they achieved their best rank (based on ratings), over all the months. Note that we do not consider the initial rating/ranking, but only the rating and rankings after each of the M months. \nFor a particular player, if there are multiple peak rating or peak ranking months, Chef was to consider the earliest of them. If multiple players had the same rating at the end of some month, they were to be given the same rank. For example, if there were 5 players, and their ratings at the end of some month were (2600, 2590, 2600, 2600 and 2590), players 1, 3 and 4 were to be given the first rank, while players 2 and 5 should be given the fourth rank.\nAs Chef hates statistics, he asks you, his friend, to help him find this. Can you help Chef?", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_chess_tournament(n: usize, m: usize, initial_ratings: Vec<usize>, rating_changes: Vec<Vec<i32>>) -> (result: usize)\n    requires\n        n >= 1,\n        m >= 1,\n        initial_ratings.len() == n,\n        rating_changes.len() == n,\n        forall|i: int| 0 <= i < n ==> #[trigger] rating_changes[i].len() == m,\n    ensures\n        result <= n,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Test cases from the problem\n    // let result1 = solve_chess_tournament(3, 3, vec![2500, 2500, 2520], vec![vec![10, -5, -20], vec![10, 15, 20], vec![-15, 17, 13]]);\n    // assert(result1 == 2);\n    \n    // let result2 = solve_chess_tournament(2, 3, vec![2125, 2098], vec![vec![-20, 10, -10], vec![10, 10, -20]]);\n    // assert(result2 == 2);\n}"}
{"id": "fvapps_000647", "vc-description": "The chef is trying to solve some pattern problems, Chef wants your help to code it. Chef has one number K to form a new pattern. Help the chef to code this pattern problem.\n\n-----Input:-----\n- First-line will contain $T$, the number of test cases. Then the test cases follow. \n- Each test case contains a single line of input, one integer $K$. \n\n-----Output:-----\nFor each test case, output as the pattern.\n\n-----Constraints-----\n- $1 \\leq T \\leq 100$\n- $1 \\leq K \\leq 100$\n\n-----Sample Input:-----\n4\n1\n2\n3\n4\n\n-----Sample Output:-----\n1\n12\n34\n123\n456\n789\n1234\n5678\n9101112\n13141516\n\n-----EXPLANATION:-----\nNo need, else pattern can be decode easily.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_pattern(k: nat) -> (result: Vec<String>)\n    requires k > 0 && k <= 10,\n    ensures \n        result.len() == k", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let test_result = solve_pattern(1);\n    // assert(test_result.len() == 1);\n    \n    // let test_result2 = solve_pattern(2);\n    // assert(test_result2.len() == 2);\n    \n    // let test_result3 = solve_pattern(3);\n    // assert(test_result3.len() == 3);\n    \n    // let test_result4 = solve_pattern(4);\n    // assert(test_result4.len() == 4);\n}"}
{"id": "fvapps_000648", "vc-description": "Diana is planning to make a very long journey. Her journey consists of N bus routes, numbered from 1 to N in the order she must take them. The buses themselves are very fast but do not run often. The i-th bus route only runs every Xi days.\n\nMore specifically, she can only take the i-th bus on day Xi, 2Xi, 3Xi, and so on. Since the buses are very fast, she can take multiple buses on the same day.\n\nDiana must finish her journey by day D, but she would like to start the journey as late as possible. What is the latest day she could take the first bus, and still finish her journey by day D?\nIt is guaranteed that it is possible for Diana to finish her journey by day D.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_latest_bus(n: usize, d: usize, buses: Vec<usize>) -> (result: usize)\n    requires \n        n > 0,\n        d > 0,\n        buses.len() == n,\n        forall|i: int| 0 <= i < buses.len() ==> buses[i] > 0 && buses[i] <= d,\n    ensures \n        result <= d,\n        result > 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let result1 = solve_latest_bus(3, 10, vec![3, 7, 2]);\n    // println!(\"{}\", result1); // Should print 6\n    \n    // let result2 = solve_latest_bus(4, 100, vec![11, 10, 5, 50]);\n    // println!(\"{}\", result2); // Should print 99\n    \n    // let result3 = solve_latest_bus(1, 1, vec![1]);\n    // println!(\"{}\", result3); // Should print 1\n}"}
{"id": "fvapps_000650", "vc-description": "Nadaca is a country with N cities. These cities are numbered 1 through N and connected by M bidirectional roads. Each city can be reached from every other city using these roads.\nInitially, Ryan is in city 1. At each of the following K seconds, he may move from his current city to an adjacent city (a city connected by a road to his current city) or stay at his current city. Ryan also has Q conditions (a1,b1),(a2,b2),…,(aQ,bQ) meaning that during this K-second trip, for each valid i, he wants to be in city ai after exactly bi seconds.\nSince you are very good with directions, Ryan asked you to tell him how many different trips he could make while satisfying all conditions. Compute this number modulo 10^9 + 7. A trip is a sequence of Ryan's current cities after 1, 2, …, K seconds.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_path_conditions(n: usize, m: usize, k: usize, roads: Vec<(usize, usize)>, q: usize, conditions: Vec<(usize, usize)>) -> (result: usize)\n    requires\n        n >= 1,\n        k >= 0,\n        q >= 0,\n        roads.len() == m,\n        conditions.len() == q,\n    ensures\n        result >= 0,\n        result < 1000000007,", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000651", "vc-description": "Sereja has an array A of N positive integers : A[1], A[2], A[3], ... , A[N]. \n\nIn a single operation on the array, he performs the following two steps :  \n\n- Pick two indices i, j s.t. A[i] > A[j]\n- A[i] -= A[j]\n\nSereja can apply these operations any number of times (possibly zero), such that the sum of resulting elements of the array is as small as possible.\n\nHelp Sereja find this minimum sum.\n\n-----Input-----\n\nFirst line of input contains an integer T - the number of test cases. T test cases follow.\n\nFirst line of each test case contains the integer N. The next line contains N integers — A[1], A[2], A[3], ... , A[N].\n\n-----Output-----\nFor each test case, output a single line with the answer.\n\n-----Constraints-----\n- 1 ≤ T ≤ 10\n- 1 ≤ N ≤ 105\n- 1 ≤ A[i] ≤ 109\n\n-----Example-----\nInput:\n2\n1\n1\n3\n2 4 6\n\nOutput:\n1\n6\n\n-----Explanation-----\nExample case 2. In this case, one possible way in which Sereja can perform the operations could be as follows. \n\n-  Pick i = 2, j = 1. A[2] -= A[1]. Now the resulting array would be [2, 2, 6].\n-  Pick i = 3, j = 2. A[3] -= A[2]. Now the resulting array would be [2, 2, 4].\n-  Pick i = 3, j = 2. A[3] -= A[2]. Now the resulting array would be [2, 2, 2]. \n\nAs the resulting array is [2 2 2], so the sum is 6.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn gcd(a: nat, b: nat) -> nat\n    decreases a + b\n{\n    if a == 0 {\n        b\n    } else if b == 0 {\n        a\n    } else if a <= b {\n        gcd(a, (b - a) as nat)\n    } else {\n        gcd((a - b) as nat, b)\n    }\n}\n\nspec fn gcd_list(arr: Seq<nat>) -> nat\n    decreases arr.len()\n{\n    if arr.len() == 0 {\n        0\n    } else if arr.len() == 1 {\n        arr[0]\n    } else {\n        gcd(arr[0], gcd_list(arr.skip(1)))\n    }\n}", "vc-spec": "fn find_minimum_array_sum(arr: Vec<nat>) -> (result: nat)\n    requires \n        arr.len() > 0,\n        forall|i: int| 0 <= i < arr.len() ==> arr[i] > 0,\n    ensures \n        result == (arr.len() as nat) * gcd_list(arr@),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let test1 = vec![1nat];\n    // let result1 = find_minimum_array_sum(test1);\n    // assert(result1 == 1);\n    \n    // let test2 = vec![2nat, 4nat, 6nat];\n    // let result2 = find_minimum_array_sum(test2);\n    // assert(result2 == 6);\n    \n    // let test3 = vec![3nat, 6nat, 9nat, 12nat];\n    // let result3 = find_minimum_array_sum(test3);\n    // assert(result3 == 12);\n}"}
{"id": "fvapps_000653", "vc-description": "In my town ,there live a coder named Chef . He is a cool programmer . One day , he participate in a programming contest ,the contest give him only one problem . If he can't solve the problem ,the problem setter will kill him . But the round allow you to help Chef. Can you save the life of Chef from problem setter ? :p\nYou are given two point of a straightline in X and Y axis and they are A(x1 , y1) and B(x2 ,y2) . Problem setter will give you another point C(x3 , y3) . If C exist in AB straightline ,then print \"YES\" . Otherwise ,print \"NO\" in first line and print the minimum distance from C to AB straightline in second line .\nPlease , save the life of Chef .\nNote : It is not possible that A and B point is similar .\n\n-----Input:-----\nThe first line of the input contains a single integer t (1≤t≤100) — the number of test cases .\nEach test case starts with four integers( x1, y1 , x2 , y2 ) in first line .\nNext line contains a single number q ,the number of queries . Each query contains two integers ( x3 ,y3 )\n\n-----Output:-----\nPrint , q number of \"YES\" or \"NO\" (as it mentioned above) in each test case .For every test case , print \"Test case : i \" ( 1<= i <=T )\n\n-----Constraints-----\n-1000 <=  x1 , y1 , x2 , y2 , x3 , y3 <= 1000\n\n-----Sample Input:-----\n2\n3  5  6  5\n2\n4  5\n6  8\n3  4  7  10\n1\n7  4\n\n-----Sample Output:-----\nTest case : 1\nYES\nNO\n3.000000\nTest case : 2\nNO\n3.328201", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_geometry(x1: i32, y1: i32, x2: i32, y2: i32, queries: Vec<(i32, i32)>) -> (result: Vec<String>)\n    requires x1 != x2,\n    ensures \n        result.len() == queries.len() || result.len() == 2 * queries.len()", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000654", "vc-description": "Its Christmas time and Santa has started his ride to deliver gifts to children waiting for him in a 1-dimentional city. All houses in this city are on a number line numbered as 1, 2, 3… and so on. Santa wants to deliver to houses from n to m, but he found that all the kids living at positions that are divisible by a, a+d, a+2d, a+3d or a+4d are naughty and he does not want to deliver them any gifts. Santa wants to know how many gifts he has to carry before leaving to the city given that there is only one kid in a house. Help him out!\nFormally, Given $m, n, a, d \\in \\mathbb{N}$ where $n < m$, find the number of $x \\in \\{n, n+1, ..., m-1, m\\}$ such that $x$ is not divisible by $a$, $a+d$, $a+2d$, $a+3d$ or $a+4d$\n\n-----Input-----\nThe first line is the number $t$, corresponding to number of test cases\\\nThis is followed by $t$ lines of the format: $n$ $m$ $a$ $d$\n\n-----Output-----\nFor each test case, print a single number that is the number of gifts Santa should pack.\n\n-----Constraints-----\n- $1 < m, n, a \\leq 2^{32}$\n- $1 < d \\leq 2^{10}$\n\n-----Sample Input:-----\n1\n2 20 2 1\n\n-----Sample Output:-----\n5\n\n-----Explanation:-----\nIn the range {2, 3, 4, …, 19, 20}, only {7, 11, 13, 17, 19} are not divisible by 2, 3, 4, 5, or 6", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_naughty(x: nat, a: nat, d: nat) -> bool {\n    x % a == 0 || \n    x % (a + d) == 0 || \n    x % (a + 2*d) == 0 || \n    x % (a + 3*d) == 0 || \n    x % (a + 4*d) == 0\n}\n\nfn count_santa_gifts(n: nat, m: nat, a: nat, d: nat) -> (result: nat)\n    requires \n        n > 0,\n        m > 0,\n        a > 0,\n        d > 0,\n        n <= m,\n    ensures\n        result >= 0,\n        result <= m - n + 1,\n        /* Core property: result counts houses in range [n,m] that are not naughty */\n        forall|x: nat| n <= x <= m && !is_naughty(x, a, d) ==> result > 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: unguarded\n\n    // Test cases would go here:\n    // count_santa_gifts(2, 20, 2, 1) should return 5\n    // count_santa_gifts(1, 5, 2, 1) should return 1  \n    // count_santa_gifts(3, 7, 2, 1) should return 1\n}"}
{"id": "fvapps_000655", "vc-description": "Chef bought an electronic board and pen. He wants to use them to record his clients' signatures.\nThe board is a grid with N rows (numbered 1 through N) and M columns (numbered 1 through M) of pixels. Initially, all pixels are white. A client uses the electronic pen to sign on the board; whenever the pen touches a pixel, this pixel becomes black. Note that a signature may be non-continuous (a client may lift the pen while signing).\nChef stores a typical signature of his current client as a matrix of characters A_{i, j}, where for each valid i and j, A_{i, j} is either '1' (if the cell in the i-th row and j-th column is black) or '0' (if this cell is white). The client just signed on the board; this signature is stored in the same form as a matrix B_{i, j}. Chef wants to know how close this signature is to this client's typical signature.\nTwo signatures are considered the same if it is possible to choose (possibly negative) integers dr and dc such that for each 1 ≤ i ≤ N and 1 ≤ j ≤ M, A_{i, j} = B_{i + dr, j + dc}. Here, if B_{i + dr, j + dc} does not correspond to a valid cell, it is considered to be '0'.\nTo compare the signatures, the colours of zero or more cells must be flipped in such a way that the signatures become the same (each flipped cell may be in any matrix). The error in the client's current signature is the minimum number of cells whose colours must be flipped. Find the error in the signature.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn compare_signatures(n: usize, m: usize, sig1: Vec<Seq<char>>, sig2: Vec<Seq<char>>) -> (result: usize)\n    requires \n        n >= 2,\n        m >= 2,\n        n <= 25,\n        m <= 25,\n        sig1.len() == n,\n        sig2.len() == n,\n        forall|i: int| 0 <= i < n ==> sig1[i].len() == m,\n        forall|i: int| 0 <= i < n ==> sig2[i].len() == m,\n    ensures \n        result <= n * m,", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let sig1_1 = vec![seq!['1', '0', '0'], seq!['0', '1', '0'], seq!['0', '0', '0']];\n    // let sig2_1 = vec![seq!['0', '0', '0'], seq!['0', '1', '0'], seq!['0', '0', '1']];\n    // let result1 = compare_signatures(3, 3, sig1_1, sig2_1);\n    // println!(\"{}\", result1); // Expected: 0\n}"}
{"id": "fvapps_000656", "vc-description": "A permutation p_1,p_2...p_N of {1, 2, ..., N} is beautiful if p_i & p_{i+1} is greater than 0 for every 1 ≤ i < N. You are given an integer N, and your task is to construct a beautiful permutation of length N or determine that it's impossible.\nNote that a & b denotes the bitwise AND of a and b.\n\n-----Input:-----\nFirst line will contain T, number of testcases. Then the testcases follow. \nEach testcase contains a single line of input, an integer N.\n\n-----Output:-----\nFor each test case output -1 if there is no suitable permutation of length N, otherwise output N integers in a single line which form a beautiful permutation. If there are multiple answers output any of them.\n\n-----Constraints-----\n- 1 ≤ N ≤ 10^5\n- The sum of N over all test cases does not exceed 10^6\n\n-----Subtasks-----\n- 50 points : 1 ≤ N,T ≤ 9\n- 50 points : Original constraints\n\n-----Sample Input:-----\n3\n4\n3\n5\n\n-----Sample Output:-----\n-1\n1 3 2\n2 3 1 5 4", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_power_of_two(n: usize) -> bool {\n    n > 0 && exists|k: nat| n == (1 << k)\n}\n\nfn solve_beautiful_permutation(n: usize) -> (result: Vec<usize>)\n    requires n > 0,\n    ensures\n        (n == 1 ==> result.len() == 1 && result[0] == 1),\n        (is_power_of_two(n) && n != 1 ==> result.len() == 1 && result[0] == 0),\n        (!is_power_of_two(n) && n != 1 ==> result.len() == n),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: unguarded\n\n    // #eval solve_beautiful_permutation 4\n    // Expected: [-1] or [0]\n\n    // #eval solve_beautiful_permutation 3  \n    // Expected: [2, 3, 1]\n\n    // #eval solve_beautiful_permutation 5\n    // Expected: [2, 3, 1, 5, 4]\n}"}
{"id": "fvapps_000659", "vc-description": "Snackdown 2019 is coming! People have started to spread the word and tell other people about the contest.\nThere are N people numbered 1 through N. Initially, only person 1 knows about Snackdown. On each day, everyone who already knows about Snackdown tells other people about it. For each valid i, person i can tell up to A_i people per day. People spread the information among the people who don't know about Snackdown in the ascending order of their indices; you may assume that no two people try to tell someone about Snackdown at the same moment. Each person is only allowed to start telling other people about Snackdown since the day after he/she gets to know about it (person 1 can start telling other people already on day 1). How many days does it take for all people to know about Snackdown?\n\nInput:\n- The first line of the input contains a single integer T denoting the number of test cases. The description of T test cases follows.\n- The first line of each test case contains a single integer N.\n- The second line contains N space-separated integers A_1, A_2, ..., A_N.\n\nOutput:\nFor each test case, print a single line containing one integer — the number of days.\n\nConstraints:\n- 1 ≤ T ≤ 1,000\n- 2 ≤ N ≤ 10^5\n- the sum of N for all test cases does not exceed 10^6\n- 0 ≤ A_i ≤ N for each valid i\n- 1 ≤ A_1\n\nExample Input:\n2\n7\n2 1 1 5 5 5 5\n5\n5 1 3 2 1\n\nExample Output:\n2\n1\n\nExplanation:\nExample case 1: On day 1, person 1 tells people 2 and 3 about Snackdown. On day 2, the first three people know about Snackdown, so they can tell 2+1+1 = 4 people about it in a single day. That means the last four people get to know about Snackdown on day 2, so the total number of days is 2.\nExample case 2: On each day, person 1 can tell up to 5 people about Snackdown, so on the first day, he simply tells all people about it and the total number of days is 1.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_snackdown_spread(n: usize, arr: Vec<usize>) -> (result: usize)\n    requires \n        n >= 2,\n        arr.len() == n,\n        forall|i: int| 0 <= i < arr.len() ==> 1 <= arr[i] && arr[i] <= 5,\n        arr.len() > 0,\n    ensures \n        result >= 0,\n        result <= n,", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = solve_snackdown_spread(7, vec![2, 1, 1, 5, 5, 5, 5]);\n    // println!(\"{}\", result1); // Expected: 2\n    \n    // let result2 = solve_snackdown_spread(5, vec![5, 1, 3, 2, 1]);\n    // println!(\"{}\", result2); // Expected: 1\n    \n    // let result3 = solve_snackdown_spread(3, vec![2, 1, 1]);\n    // println!(\"{}\", result3); // Expected: 1\n}"}
{"id": "fvapps_000660", "vc-description": "Harry is a bright student. To prepare thoroughly for exams, he completes all the exercises in his book! Now that the exams are approaching fast, he is doing book exercises day and night. He writes down and keeps updating the remaining number of exercises on the back cover of each book.\nHarry has a lot of books messed on the floor. Therefore, he wants to pile up the books that still have some remaining exercises into a single pile. He will grab the books one-by-one and add the books that still have remaining exercises to the top of the pile.\nWhenever he wants to do a book exercise, he will pick the book with the minimum number of remaining exercises from the pile. In order to pick the book, he has to remove all the books above it. Therefore, if there are more than one books with the minimum number of remaining exercises, he will take the one which requires the least number of books to remove. The removed books are returned to the messy floor. After he picks the book, he will do all the remaining exercises and trash the book.\nSince number of books is rather large, he needs your help to tell him the number of books he must remove, for picking the book with the minimum number of exercises.\n\nNote that more than one book can have the same name.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn count_books(books: Vec<String>, queries: Vec<String>) -> (result: Vec<String>)\n    ensures\n        result.len() == queries.len(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000661", "vc-description": "You are given two integer sequences A₁, A₂, ..., Aₙ and B₁, B₂, ..., Bₘ. For any two sequences U₁, U₂, ..., Uₚ and V₁, V₂, ..., Vq, we define\nScore(U,V) = ∑ᵢ₌₁ᵖ ∑ⱼ₌₁q Uᵢ · Vⱼ.\nYou should process Q queries of three types:\n- 1 L R X: Add X to each of the elements Aₗ, Aₗ₊₁, ..., Aᵣ.\n- 2 L R X: Add X to each of the elements Bₗ, Bₗ₊₁, ..., Bᵣ.\n- 3: Print Score(A, B) modulo 998,244,353.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn sequence_score(a: Seq<i32>, b: Seq<i32>) -> int {\n    a.fold_left(0, |acc: int, x: i32| \n        acc + b.fold_left(0, |acc2: int, y: i32| \n            acc2 + (x as int) * (y as int)))\n}\n\nspec fn mod_value() -> int { 998244353 }\n\nspec fn count_type3_queries(queries: Seq<Vec<i32>>) -> int {\n    queries.fold_left(0, |acc: int, q: Vec<i32>| \n        if q.len() > 0 && q[0] == 3 { acc + 1 } else { acc })\n}\n\nfn process_array_queries(n: usize, m: usize, a: Vec<i32>, b: Vec<i32>, queries: Vec<Vec<i32>>) -> (result: Vec<i32>)\n    requires \n        n > 0 && m > 0,\n        a.len() == n,\n        b.len() == m,\n        forall|i: int| 0 <= i < queries.len() ==> queries[i].len() > 0,\n    ensures\n        result.len() == count_type3_queries(queries@),\n        forall|i: int| 0 <= i < result.len() ==> 0 <= #[trigger] result[i] && #[trigger] result[i] < mod_value(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000662", "vc-description": "You are playing following game: given an array A of N natural numbers. All numbers in the array A are at most M. On every turn you may pick any two different elements Ai and Aj (i≠j), such that Ai, Aj ≤ M, and add K to both. The game ends when you are not able to continue. That is, when there is no pair (i,j) left such that both of them are less than equal to M.\n\nLet's call two arrays different if the sum of all their elements is different. When the game ends, you note down the final array A. How many different final arrays can you have.\n\n-----Input-----\n\nThe first line contains three integers N, M and K. N elements of the array follow in the next line.\n\n-----Output-----\n\nOutput single integer - answer for the given problem modulo 109+7.\n\n-----Constraints-----\n-  1 ≤ N ≤ 105\n-  1 ≤ M,K ≤ 1012\n-  1 ≤ Ai ≤ M\n\n-----Example-----\nInput:\n3 3 2\n1 2 3\nOutput:\n2\n\n-----Explanation-----\n\nAll possible sums are 14 and 10. You can get them by, for example, these arrays:\nA=(5, 4, 5),\nA=(1, 4, 5)\n\nThe above arrays are different because their sums are different.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn count_different_arrays(n: nat, m: nat, k: nat, a: Vec<nat>) -> (result: nat)\n    requires \n        n >= 1,\n        m >= 1, \n        k >= 1,\n        a.len() == n,\n        forall|i: int| 0 <= i < a.len() ==> a[i] >= 1 && a[i] <= m,\n    ensures\n        1 <= result && result <= 1000000007,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "}\n\nfn main() {}"}
{"id": "fvapps_000663", "vc-description": "Rohit collects coins: he has exactly one coin for every year from 1 to n. Naturally, Rohit keeps all the coins in his collection in the order in which they were released. Once Rohit's younger brother made a change — he took all the coins whose release year dated from l to r inclusively and put them in the reverse order. That is, he took a certain segment [l, r] and reversed it. At that, the segment's endpoints did not coincide. For example, if n = 8, then initially Rohit's coins were kept in the order 1 2 3 4 5 6 7 8. If Rohit's younger brother chose the segment [2, 6], then after the reversal the coin order will change to 1 6 5 4 3 2 7 8. Rohit suspects that someone else could have spoilt the permutation after his brother. Help him to find that out. Check if the given permutation can be obtained from the permutation 1 2 … n using exactly one segment reversal. If it is possible, find the segment itself.\n\n-----Input:-----\n- The first line contains an integer N which is the number of coins in Rohit's collection. \n- The second line contains space-separated n integers which are the spoilt sequence of coins. It is guaranteed that the given sequence is a permutation, i.e. it contains only integers from 1 to n, and every number is used exactly 1 time.\n\n-----Output:-----\nIf it is impossible to obtain the given permutation from the original one in exactly one action, print 0 0. Otherwise, print two numbers l, r (1 ≤ l < r ≤ n) which are the endpoints of the segment that needs to be reversed to obtain from permutation 1 2 … n the given one.\n\n-----Constraints-----\n- $1 \\leq N \\leq 1000$\n- $1 \\leq A[N] \\leq 10^9$\n\n-----Sample Input:-----\n8\n1 6 5 4 3 2 7 8\n\n-----Sample Output:-----\n2 6", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve(n: usize, seq: Vec<usize>) -> (result: (usize, usize))\n    requires \n        n > 0,\n        seq.len() == n,\n    ensures\n        (result.0 == 0 && result.1 == 0) || (1 <= result.0 < result.1 <= n),\n{\n    // impl-start\n    assume(false);\n    (0, 0)\n    // impl-end\n}\n\nfn is_valid_after_reverse(seq: Vec<usize>, l: usize, r: usize) -> (result: bool)\n    requires \n        seq.len() > 0,\n        l > 0,\n        r <= seq.len(),\n        l < r,\n{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-code": "", "vc-postamble": "\n}\nfn main() {\n    // let result = solve(8, vec![1, 6, 5, 4, 3, 2, 7, 8]);\n    // println!(\"{:?}\", result);\n    // \n    // let result2 = solve(4, vec![1, 2, 3, 4]);\n    // println!(\"{:?}\", result2);\n    // \n    // let result3 = solve(3, vec![3, 2, 1]);\n    // println!(\"{:?}\", result3);\n}"}
{"id": "fvapps_000664", "vc-description": "Problem Statement\nWrite a program that accepts a number, n, and outputs the same.\n\nInput\nThe only line contains a single integer. \n\nOutput\nOutput the answer in a single line.\n\nConstraints\n- 0 ≤ n ≤ 105\n\nSample Input\n123\n\nSample Output\n123", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn return_number(n: i32) -> (result: i32)\n    ensures result == n", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n/* Apps difficulty: interview\n   Assurance level: guarded_and_plausible */\n\n}\n\nfn main() {\n    // println!(\"{}\", return_number(123));\n    // println!(\"{}\", return_number(0)); \n    // println!(\"{}\", return_number(99999));\n}"}
{"id": "fvapps_000665", "vc-description": "Congratulations !!! You have successfully completed the heist by looting all the gifts in Santa's locker. Now it's time to decide who gets to take all the gifts, you or the Grinch, there will be no splitting. So you and Grinch decide to play a game.\nTo start the game, an Integer N will be given. The game is played in turns and for each turn, the player can make any one of the following moves:\n- Divide N by any of it's odd divisors greater than 1.\n- Subtract 1 from N if N is greater than 1.\nDivisor of a number includes the number itself.\nThe player who is unable to make a move loses the game.\nSince you are the mastermind of the heist, you get to play the first move.\n\n-----Input-----\nThe first line contains a single integer T (1 ≤ T ≤ 100) — the number of test cases. The description of the test cases follows.\nThe only line of each test case contains a single integer — N (1 ≤ N ≤ 109).\n\n-----Output-----\nFor each test case, print \" Me\" if you win, and \" Grinch\" if otherwise (without quotes).\n\n-----Sample Input-----\n7\n1\n2\n3\n4\n5\n6\n12\n\n-----Sample Output-----\nGrinch\nMe\nMe\nGrinch\nMe\nGrinch\nMe", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn find_winner(n: u32) -> (result: &'static str)\n    requires n > 0,\n    ensures \n        result == \"Me\" || result == \"Grinch\",\n        n == 1 ==> result == \"Grinch\",\n        n == 2 ==> result == \"Me\",\n        (n > 1 && n % 2 == 1) ==> result == \"Me\",\n        n == 4 ==> result == \"Grinch\",\n        n == 6 ==> result == \"Grinch\",\n        n == 12 ==> result == \"Me\",\n        n == 16 ==> result == \"Grinch\"", "vc-code": "{\n    // impl-start\n    assume(false);\n    \"Me\"\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000666", "vc-description": "You are given an axis-aligned rectangle in a 2D Cartesian plane. The bottom left corner of this rectangle has coordinates (0,0) and the top right corner has coordinates (N-1,N-1). You are also given K light sources; each light source is a point inside or on the perimeter of the rectangle.\nFor each light source, let's divide the plane into four quadrants by a horizontal and a vertical line passing through this light source. The light source can only illuminate one of these quadrants (including its border, i.e. the point containing the light source and two half-lines), but the quadrants illuminated by different light sources may be different.\nYou want to assign a quadrant to each light source in such a way that when they illuminate their respective quadrants, the entire rectangle (including its perimeter) is illuminated. Find out whether it is possible to assign quadrants to light sources in such a way.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_corner_point(x: usize, y: usize, n: usize) -> bool {\n    (x == 0 && y == 0) || (x == 0 && y == n-1) || \n    (x == n-1 && y == 0) || (x == n-1 && y == n-1)\n}\n\nfn assess_lights(k: usize, n: usize, points: Vec<(usize, usize)>) -> (result: &'static str)\n    requires \n        1 <= k <= 100,\n        1 <= n <= 1000000000,\n        points.len() == k,\n        forall|i: int| 0 <= i < points.len() ==> #[trigger] points[i].0 < n && #[trigger] points[i].1 < n,\n    ensures \n        result == \"yes\" || result == \"no\",\n        /* If k > 3, then result is \"yes\" */\n        k > 3 ==> result == \"yes\",\n        /* If any point is a corner, then result is \"yes\" */\n        (exists|i: int| 0 <= i < points.len() && #[trigger] is_corner_point(points[i].0, points[i].1, n)) ==> result == \"yes\",", "vc-code": "{\n    // impl-start\n    assume(false);\n    \"no\"\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Example usage:\n    // let result1 = assess_lights(2, 10, vec![(0, 0), (1, 0)]);\n    // println!(\"{}\", result1); // Should print \"yes\"\n    // \n    // let result2 = assess_lights(2, 10, vec![(1, 2), (1, 1)]);\n    // println!(\"{}\", result2); // Should print \"no\"\n    //\n    // let result3 = assess_lights(3, 5, vec![(0, 0), (4, 2), (2, 4)]);\n    // println!(\"{}\", result3); // Should print \"yes\"\n}"}
{"id": "fvapps_000667", "vc-description": "Chef has been working in a restaurant which has N floors. He wants to minimize the time it takes him to go from the N-th floor to ground floor. He can either take the elevator or the stairs. \nThe stairs are at an angle of 45 degrees and Chef's velocity is V1 m/s when taking the stairs down. The elevator on the other hand moves with a velocity V2 m/s. Whenever an elevator is called, it always starts from ground floor and goes to N-th floor where it collects Chef (collecting takes no time), it then makes its way down to the ground floor with Chef in it.  \n\nThe elevator cross a total distance equal to N meters when going from N-th floor to ground floor or vice versa, while the length of the stairs is sqrt(2) * N because the stairs is at angle 45 degrees.\n\nChef has enlisted your help to decide whether he should use stairs or the elevator to minimize his travel time. Can you help him out?\n\n-----Input-----\nThe first line contains a single integer T, the number of test cases. Each test case is described by a single line containing three space-separated integers N, V1, V2. \n\n-----Output-----\nFor each test case, output a single line with string Elevator or Stairs, denoting the answer to the problem.\n\n-----Constraints-----\n- 1 ≤ T ≤  1000 \n- 1 ≤ N, V1, V2 ≤  100 \n\n-----Example-----\nInput:\n3\n5 10 15\n2 10 14\n7 14 10\n\nOutput:\nElevator\nStairs\nStairs", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_chef_transport(n: u32, v1: u32, v2: u32) -> (result: String)\n    requires \n        n > 0,\n        v1 > 0,\n        v2 > 0,\n    ensures \n        result@ == seq!['S', 't', 'a', 'i', 'r', 's'] || result@ == seq!['E', 'l', 'e', 'v', 'a', 't', 'o', 'r'],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let test1 = solve_chef_transport(5, 10, 15);\n    // let test2 = solve_chef_transport(2, 10, 14);\n    // let test3 = solve_chef_transport(7, 14, 10);\n}"}
{"id": "fvapps_000668", "vc-description": "The Little Elephant likes permutations. This time he has a permutation A[1], A[2], ..., A[N] of numbers 1, 2, ..., N.\n\nHe calls a permutation A good, if the number of its inversions is equal to the number of its local inversions. The number of inversions is equal to the number of pairs of integers (i; j) such that 1 ≤ i < j ≤ N and A[i] > A[j], and the number of local inversions is the number of integers i such that 1 ≤ i < N and A[i] > A[i+1].\n\nThe Little Elephant has several such permutations. Help him to find for each permutation whether it is good or not. Print YES for a corresponding test case if it is good and NO otherwise.\n\n-----Input-----\n\nThe first line of the input contains a single integer T, the number of test cases. T test cases follow. The first line of each test case contains a single integer N, the size of a permutation. The next line contains N space separated integers A[1], A[2], ..., A[N].\n\n-----Output-----\n\nFor each test case output a single line containing the answer for the corresponding test case. It should be YES if the corresponding permutation is good and NO otherwise.\n\n-----Constraints-----\n1 ≤ T ≤ 474 \n\n1 ≤ N ≤ 100 \n\nIt is guaranteed that the sequence A[1], A[2], ..., A[N] is a permutation of numbers 1, 2, ..., N.\n\n-----Example-----\nInput:\n4\n1\n1\n2\n2 1\n3\n3 2 1\n4\n1 3 2 4\n\nOutput:\nYES\nYES\nNO\nYES\n\n-----Explanation-----\nCase 1. Here N = 1, so we have no pairs (i; j) with 1 ≤ i < j ≤ N. So the number of inversions is equal to zero. The number of local inversion is also equal to zero. Hence this permutation is good.\n\nCase 2. Here N = 2, and we have one pair (i; j) with 1 ≤ i < j ≤ N, the pair (1; 2). Since A[1] = 2 and A[2] = 1 then A[1] > A[2] and the number of inversions is equal to 1. The number of local inversion is also equal to 1 since we have one value of i for which 1 ≤ i < N (the value i = 1) and A[i] > A[i+1] for this value of i since A[1] > A[2]. Hence this permutation is also good.\n\nCase 3. Here N = 3, and we have three pairs (i; j) with 1 ≤ i < j ≤ N. We have A[1] = 3, A[2] = 2, A[3] = 1. Hence A[1] > A[2], A[1] > A[3] and A[2] > A[3]. So the number of inversions is equal to 3. To count the number of local inversion we should examine inequalities A[1] > A[2] and A[2] > A[3]. They both are satisfied in our case, so we have 2 local inversions. Since 2 ≠ 3 this permutations is not good.\n\nCase 4. Here we have only one inversion and it comes from the pair (2; 3) since A[2] = 3 > 2 = A[3]. This pair gives also the only local inversion in this permutation. Hence the number of inversions equals to the number of local inversions and equals to one. So this permutation is good.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn count_inversions(arr: Seq<nat>) -> nat\n    decreases arr.len()\n{\n    if arr.len() <= 1 {\n        0\n    } else {\n        let count_first: nat = arr.skip(1).filter(|x: nat| x < arr[0]).len();\n        count_first + count_inversions(arr.skip(1))\n    }\n}\n\nspec fn count_local_inversions(arr: Seq<nat>) -> nat\n    decreases arr.len()\n{\n    if arr.len() <= 1 {\n        0\n    } else if arr.len() == 2 {\n        if arr[0] > arr[1] { 1 } else { 0 }\n    } else {\n        let local_first: nat = if arr[0] > arr[1] { 1 } else { 0 };\n        local_first + count_local_inversions(arr.skip(1))\n    }\n}\n\nspec fn is_permutation(n: nat, arr: Seq<nat>) -> bool {\n    arr.len() == n &&\n    forall|i: nat| 1 <= i <= n ==> arr.contains(i) &&\n    forall|i: int, j: int| 0 <= i < arr.len() && 0 <= j < arr.len() && i != j ==> arr[i] != arr[j]\n}", "vc-spec": "fn is_good_permutation(n: nat, arr: Vec<nat>) -> (result: bool)\n    requires \n        n > 0,\n        arr.len() == n,\n        is_permutation(n, arr@),\n    ensures result == (count_inversions(arr@) == count_local_inversions(arr@))\n{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-code": "", "vc-postamble": "}\n\nfn main() {\n    // /* Apps difficulty: interview */\n    // /* Assurance level: unguarded */\n    \n    // /* Test cases */\n    // assert(is_good_permutation(1, vec![1]));\n    // assert(is_good_permutation(2, vec![2, 1]));\n    // assert(!is_good_permutation(3, vec![3, 2, 1]));\n    // assert(is_good_permutation(4, vec![1, 3, 2, 4]));\n}"}
{"id": "fvapps_000670", "vc-description": "In africa jungle , there were zebra's who liked to spit.\nThere owner watched them for whole day and noted in his sheet where each zebra spitted.\nNow he's in a confusion and wants to know if in the jungle there are two zebra's which spitted at each other.\nHelp him solve this task.\nIf the zebra is present in position a spits b metres right , he can hit only zebra in position a+b , if such a zebra exists.\n\n-----Input:-----\n- The first line contains integer t(1<=t<100)- amount of zebras in jungle.\n- Each of following t lines contains two integers a(i) and b(i)(-10^4<=x(i)<=10^4,1<|d(i)|<=2.10^4) - records in owner sheet.\n- a(i) is the position of i-th zebra and b(i) is distance at which the i-th camel spitted.\nPositive values of d(i) correspond to spits right, negative values correspond to spit left.No two zebras may stand in the same position.\n\n-----Output:-----\nIf there are two zebras , which spitted at each other , output YES, otherwise , output NO.\n\n-----Sample Input:-----\n2\n0 1\n1 -1\n\n-----Sample Output:-----\nYES", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn can_zebras_spat_at_each_other(positions: Vec<(i32, i32)>) -> (result: bool)\n    requires positions.len() > 0,\n    ensures \n        result == exists|i: int, j: int| \n            0 <= i < positions.len() && \n            0 <= j < positions.len() && \n            i != j && \n            positions[i].0 + positions[i].1 == positions[j].0 &&\n            positions[j].0 + positions[j].1 == positions[i].0", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // #eval can_zebras_spit_at_each_other [[0, 1], [1, -1]]\n    // #eval can_zebras_spit_at_each_other [[0, 1], [2, -1]]\n    // #eval can_zebras_spit_at_each_other [[0, 2], [1, 1], [2, -2]]\n}"}
{"id": "fvapps_000671", "vc-description": "You are a king and you are at war. If the enemy breaks through your frontline you lose.\nEnemy can break the line only if the sum of morale of any K continuous soldiers is strictly less than M. So, you being a motivational orator decides to boost their morale by giving a speech. On hearing it morale of a soldier multiplies by X which depends on you and your speech (i.e. X can be any positive value) but atmost only K continuous speakers can hear your speech.\nN soldiers are standing on the frontline with A[i] morale. \nDetermine the minimum number of speeches you need to give.\n\n-----Input:-----\nThe first line contains three space seperated integers N,K,M.\nThe next line contains N space integers, ith of which denotes the morale of ith soldier.\n\n-----Output:-----\nOutput the minimum number of speeches required. In case if it is impossible to achieve, print -1.\n\n-----Constraints:-----\n1 ≤ N,M ≤ 10^5\n1 ≤ k ≤ N\n0 ≤ Ai ≤ 10^5 \n\n-----Sample Input:-----\n6 2 5\n1 1 1 1 1 1\n\n-----Sample Output:-----\n2\n\n-----Explanation:-----\nWe multiply 2nd ,3rd  and 5th,6th by 5. Resulting array will be 1 5 5 1 5 5.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn min_speeches(n: usize, k: usize, m: usize, arr: Vec<usize>) -> (result: i32)\n    requires \n        k <= n,\n        arr.len() == n,\n        k > 0,\n        n > 0,\n    ensures\n        /* If array contains 0, result is -1 */\n        (exists|i: int| 0 <= i < arr.len() && arr[i] == 0) ==> result == -1,\n        /* If no zeros in array, result is non-negative */\n        (forall|i: int| 0 <= i < arr.len() ==> arr[i] != 0) ==> result >= 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = min_speeches(6, 2, 5, vec![1, 1, 1, 1, 1, 1]);\n    // assert(result1 == 3);\n    \n    // let result2 = min_speeches(5, 2, 4, vec![1, 1, 1, 1, 1]);\n    // assert(result2 == 2);\n    \n    // let result3 = min_speeches(4, 2, 3, vec![0, 1, 1, 0]);\n    // assert(result3 == -1);\n}"}
{"id": "fvapps_000672", "vc-description": "You are given a sequence A_1, A_2, ..., A_N. For each valid i, the star value of the element A_i is the number of valid indices j < i such that A_j is divisible by A_i.\nChef is a curious person, so he wants to know the maximum star value in the given sequence. Help him find it.\n\nInput:\n- The first line of the input contains a single integer T which denotes the number of test cases.\n- The first line of each test case contains a single integer N.\n- The second line of each test case contains N space-separated integers A_1, A_2, ..., A_N.\n\nOutput:\nFor each test case, print a single line containing one integer — the maximum star value.\n\nConstraints:\n- 1 ≤ T ≤ 10\n- 1 ≤ N ≤ 10^5\n- 1 ≤ A_i ≤ 10^6 for each valid i\n- Sum of N over all test cases does not exceed 100,000.\n\nExample:\nInput: [8, 1, 28, 4, 2, 6, 7]\nOutput: 3\nExplanation: A_5 = 2 divides 4, 28 and 8, so its star value is 3. There is no element with a higher star value.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn count_divisible_before(arr: Seq<nat>, i: int) -> nat\n    decreases i\n{\n    if i <= 0 || arr.len() == 0 {\n        0\n    } else {\n        let idx = i - 1;\n        let current_count: nat = if idx >= 0 && idx < arr.len() && i < arr.len() && arr[idx] % arr[i] == 0 { 1 } else { 0 };\n        current_count + count_divisible_before(arr, i - 1)\n    }\n}\n\nspec fn star_value(arr: Seq<nat>, i: int) -> nat {\n    if i >= arr.len() || i < 0 {\n        0\n    } else {\n        count_divisible_before(arr, i)\n    }\n}\n\nspec fn max_star_value_spec(arr: Seq<nat>) -> nat\n    decreases arr.len()\n{\n    if arr.len() == 0 {\n        0\n    } else if arr.len() == 1 {\n        0\n    } else {\n        let current_star = star_value(arr, arr.len() - 1);\n        let rest_max = max_star_value_spec(arr.drop_last());\n        if current_star > rest_max { current_star } else { rest_max }\n    }\n}\n\nfn find_max_star_value(arr: Vec<nat>) -> (result: nat)\n    ensures result == max_star_value_spec(arr@)\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n\nfn count_divisible(arr: Vec<nat>, i: usize) -> (result: nat)\n    requires i < arr.len(),\n    ensures result == count_divisible_before(arr@, i as int)\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-code": "/* placeholder for additional code */", "vc-postamble": "\n}\n\nfn main() {\n    // let test_arr = vec![8, 1, 28, 4, 2, 6, 7];\n    // let result = find_max_star_value(test_arr);\n    // println!(\"Result: {}\", result);\n}"}
{"id": "fvapps_000675", "vc-description": "The MarkiT online virtual market startup wants to organize its grand opening in NIT Patna.\nbut they want maximum crowd for their inauguration. So the manager told  this  to Praveen a student in NITP who suggested them:\nThe first-year students come to campus  every x hour,\nSecond-year students come to campus every y hour,\nThird-year students come to campus every z hour and \nFourth-year is very busy so they don't come regularly.\nSo Praveen being very clever told him the no of times in n days he can have an audience of all year student (1st,2nd & 3rd) at max. So can you code what Praveen has done?\n\n-----Input:-----\n- First line will contain $T$, number of testcases. Then the testcases follow. \n- Each testcase contains of a 2 line of input, first line contain one  integers $N$ (No of Days). \n-Next line contain 3 space separated integer the  value of x y z\n\n-----Output:-----\nFor each testcase, output in a single line answer the no of times audience consists of all year.\n\n-----Constraints-----\n- $1 \\leq T \\leq 1000$\n- $1 \\leq N \\leq 10^8$\n- $1 \\leq x,y,z \\leq 10^5$\n\n-----Sample Input:-----\n1\n10\n8 10 6\n\n-----Sample Output:-----\n2\n\n-----EXPLANATION:-----\nFirst favourable condition will come on 5th day and Second on 10th day.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn hours_to_lcm(x: int, y: int, z: int) -> int\n    recommends x > 0, y > 0, z > 0\n{\n    // For practical purposes, we'll use a simplified approximation\n    // The actual LCM calculation would be more complex\n    if x == y && y == z {\n        x\n    } else {\n        x * y * z\n    }\n}\n\nfn calculate_audience_meetings(days: u32, x: u32, y: u32, z: u32) -> (result: u32)\n    requires \n        1 <= days,\n        1 <= x,\n        1 <= y, \n        1 <= z,\n    ensures\n        result == (days * 24) / hours_to_lcm(x as int, y as int, z as int),", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000676", "vc-description": "You are given three non-negative integers X, Y and N. Find the number of integers Z such that 0 ≤ Z ≤ N and (X ⊕ Z) < (Y ⊕ Z), where ⊕ denotes the bitwise XOR operation.\n\n-----Input-----\n- The first line of the input contains a single integer T denoting the number of test cases. The description of T test cases follows.\n- The first and only line of each test case contains three space-separated integers X, Y and N.\n\n-----Output-----\nFor each test case, print a single line containing one integer ― the number of integers Z which satisfy all conditions.\n\n-----Constraints-----\n- 1 ≤ T ≤ 1,000\n- 0 ≤ X, Y, N ≤ 2^30 - 1\n\n-----Subtasks-----\nSubtask #1 (5 points): X, Y, N ≤ 2^6 - 1\nSubtask #2 (95 points): original constraints\n\n-----Example Input-----\n3\n1 2 10\n2 1 10\n0 0 7\n\n-----Example Output-----\n6\n5\n0", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn count_xor_pairs(x: u32, y: u32, n: u32) -> (result: u32)\n    ensures \n        result >= 0,\n        result <= n + 1,\n        (x == y) ==> (result == 0),", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n/* Apps difficulty: interview */\n/* Assurance level: guarded_and_plausible */\n\n}\n\nfn main() {\n    // let test1 = count_xor_pairs(1, 2, 10);\n    // println!(\"{}\", test1); // Expected: 6\n    \n    // let test2 = count_xor_pairs(2, 1, 10);\n    // println!(\"{}\", test2); // Expected: 5\n    \n    // let test3 = count_xor_pairs(0, 0, 7);\n    // println!(\"{}\", test3); // Expected: 0\n}"}
{"id": "fvapps_000677", "vc-description": "You are given a permutation of natural integers from 1 to N, inclusive. Initially, the permutation is 1, 2, 3, ..., N.\nYou are also given M pairs of integers, where the i-th is (Li Ri). In a single turn you can choose any of these pairs (let's say with the index j) and arbitrarily shuffle the elements of our permutation on the positions from Lj to Rj, inclusive (the positions are 1-based). You are not limited in the number of turns and you can pick any pair more than once.\n\nThe goal is to obtain the permutation P, that is given to you. If it's possible, output \"Possible\", otherwise output \"Impossible\" (without quotes).\n\nInput:\nThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\nThe first line of each test case contains two space separated integers N and M denoting the size of the permutation P and the number of pairs described above. \nThe next line contains N integers - the permutation P.\nEach of the following M lines contain pair of integers Li and Ri.\n\nOutput:\nFor each test case, output a single line containing the answer to the corresponding test case.\n\nConstraints:\n- 1 ≤ T ≤ 35\n- 1 ≤ N, M ≤ 100000\n- 1 ≤ Li ≤ Ri ≤ N\n\nExample:\nInput:\n2\n7 4\n3 1 2 4 5 7 6\n1 2\n4 4\n6 7\n2 3\n4 2\n2 1 3 4\n2 4\n2 3\n\nOutput:\nPossible\nImpossible", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn can_obtain_permutation(n: usize, m: usize, perm: Vec<usize>, pairs: Vec<Vec<usize>>) -> (result: &'static str)\n    requires \n        n > 0,\n        m > 0,\n        perm.len() == n,\n        pairs.len() == m,\n        forall|i: int| 0 <= i < perm.len() ==> #[trigger] perm[i] >= 1 && #[trigger] perm[i] <= n,\n        forall|i: int, j: int| 0 <= i < j < perm.len() ==> #[trigger] perm[i] != #[trigger] perm[j],\n        forall|i: int| 0 <= i < pairs.len() ==> #[trigger] pairs[i].len() == 2,\n        forall|i: int| 0 <= i < pairs.len() ==> #[trigger] pairs[i][0] >= 1 && #[trigger] pairs[i][0] <= #[trigger] pairs[i][1] && #[trigger] pairs[i][1] <= n,\n    ensures \n        result == \"Possible\" || result == \"Impossible\"", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = can_obtain_permutation(7, 4, vec![3, 1, 2, 4, 5, 7, 6], vec![vec![1, 2], vec![4, 4], vec![6, 7], vec![2, 3]]);\n    // assert(result1 == \"Possible\");\n    \n    // let result2 = can_obtain_permutation(4, 2, vec![2, 1, 3, 4], vec![vec![2, 4], vec![2, 3]]);\n    // assert(result2 == \"Impossible\");\n}"}
{"id": "fvapps_000683", "vc-description": "This is a peculiar functioning setup.\nTwo Tanks are separated from each other by a wall. There is a pipe in the wall which connects both tanks which allows flow of water between them. Due to this, there is change in temperature of both tanks, every minute temperature of Tank with larger temperature among two decreases by one and temperature of Tank with smaller temperature among two increases by two until equilibrium is reached, But there is a problem.\nThe pipe can't control this flow of water if there is Non-equilibrium (inequality of temperature on both sides) even after m minutes and the pipe will burst after it, your task is to predict whether the pipe will burst or not.\nNote: If equilibrium cannot be reached the process will continue forever.\nThe initial temperature of Cold Tank is Tc, of Hot Tank it is Th.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn will_pipe_burst(m: nat, tc: int, th: int) -> (result: bool)\n    requires tc <= th,\n    ensures \n        ((th - tc) % 3 != 0) ==> result == true,\n        ((th - tc) % 3 == 0) ==> result == ((th - tc) / 3 > m),\n        (tc == th) ==> result == false", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // #guard_msgs in\n    // #eval will_pipe_burst 4 5 10\n\n    // #guard_msgs in  \n    // #eval will_pipe_burst 2 2 5\n\n    // #guard_msgs in\n    // #eval will_pipe_burst 1 1 7\n}"}
{"id": "fvapps_000689", "vc-description": "You are given a square matrix M with N rows (numbered 1 through N) and N columns (numbered 1 through N). Initially, all the elements of this matrix are equal to A. The matrix is broken down in N steps (numbered 1 through N); note that during this process, some elements of the matrix are simply marked as removed, but all elements are still indexed in the same way as in the original matrix. For each valid i, the i-th step consists of the following:\n- Elements M_{1, N-i+1}, M_{2, N-i+1}, ..., M_{i-1, N-i+1} are removed.\n- Elements M_{i, N-i+1}, M_{i, N-i+2}, ..., M_{i, N} are removed.\n- Let's denote the product of all 2i-1 elements removed in this step by p_i. Each of the remaining elements of the matrix (those which have not been removed yet) is multiplied by p_i.\nFind the sum p_1 + p_2 + p_3 + ... + p_N. Since this number could be very large, compute it modulo 10^9+7.\n\nInput:\n- The first line of the input contains a single integer T denoting the number of test cases. The description of T test cases follows.\n- The first and only line of each test case contains two space-separated integers N and A.\n\nOutput:\nFor each test case, print a single line containing one integer ― the sum of products at each step modulo 10^9+7.\n\nConstraints:\n- 1 ≤ T ≤ 250\n- 1 ≤ N ≤ 10^5\n- 0 ≤ A ≤ 10^9\n- the sum of N over all test cases does not exceed 10^5\n\nExample Input:\n1\n3 2\n\nExample Output:\n511620149", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_matrix_product(n: u32, a: u32) -> (result: u32)\n    requires n >= 1,\n    ensures \n        result < 1000000007,\n        n >= 1 ==> (a == 0 ==> result == 0),\n        n == 1 ==> result == a % 1000000007", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "}\n\nfn main() {\n    // // let test_result_1 = solve_matrix_product(3, 2);\n    // // println!(\"Test result 1: {}\", test_result_1); // Expected: 511620149\n    \n    // // let test_result_2 = solve_matrix_product(1, 2);\n    // // println!(\"Test result 2: {}\", test_result_2); // Expected: 2\n    \n    // // let test_result_3 = solve_matrix_product(5, 0);\n    // // println!(\"Test result 3: {}\", test_result_3); // Expected: 0\n}"}
{"id": "fvapps_000691", "vc-description": "Blob is a computer science student. He recently got an internship from Chef's enterprise. Along with the programming he has various other skills too like graphic designing, digital marketing and social media management. Looking at his skills Chef has provided him different tasks A[1…N] which have their own scores. Blog wants to maximize the value of the expression A[d]-A[c]+A[b]-A[a] such that d>c>b>a.\n\nCan you help him in this?\n\n-----Input:-----\n- The first line contain the integer N\n- The second line contains N space separated integers representing A[1], A[2] … A[N]\n\n-----Output:-----\nThe maximum score that is possible\n\n-----Constraints-----\n- 4 ≤ N ≤ 10^4\n- 0 ≤ A[i] ≤ 10^5\n\n-----Sample Input:-----\n6\n\n3 9 10 1 30 40\n\n-----Sample Output:-----\n46", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn maxval(arr: Vec<i32>) -> (result: i32)\n    requires arr.len() >= 4,\n    ensures \n        exists|a: int, b: int, c: int, d: int| \n            0 <= a < b && b < c && c < d && d < arr.len() &&\n            result == arr[d] - arr[c] + arr[b] - arr[a],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "fvapps_000692", "vc-description": "The notorious hacker group \"Sed\" managed to obtain a string S from their secret sources. The string contains only lowercase English letters along with the character '?'.\nA substring of S is a contiguous subsequence of that string. For example, the string \"chef\" is a substring of the string \"codechef\", but the string \"codeh\" is not a substring of \"codechef\".\nA substring of S is good if it is possible to choose a lowercase English letter C such that the following process succeeds:\n- Create a string R, which is a copy of the substring, but with each '?' replaced by the letter c. Note that all occurrences of '?' must be replaced by the same letter.\n- For each lowercase English letter:\n- Compute the number of times it occurs in S and the number of times it occurs in R; let's denote them by A and B respectively. The '?' characters in the original string S are ignored when computing A.\n- Check the parity of A and B. If they do not have the same parity, i.e. one of them is even while the other is odd, then this process fails.\n- If the parities of the number of occurrences in S and R are the same for each letter, the process succeeds.\nFor different substrings, we may choose different values of C.\nHelp Sed find the number of good substrings in the string S.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn count_char(s: Seq<char>, c: char) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0nat\n    } else {\n        (if s[0] == c { 1nat } else { 0nat }) + count_char(s.skip(1), c)\n    }\n}\n\nspec fn is_good_substring(s: Seq<char>, start: int, end: int) -> bool {\n    0 <= start <= end <= s.len()\n}\n\nfn solve(s: Vec<char>) -> (result: usize)\n    requires s.len() > 0,\n    ensures result <= s.len() * (s.len() + 1) / 2", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000698", "vc-description": "Today is rose day, batch mates of Kabir and Tara decided to celebrate this day by exchanging roses with each other. \nNote: exchanging means both the boy and the girl will give rose to each other. \nIn the class there are B boys and G girls. \nExchange of rose will take place if and only if at least one of them hasn't received a rose from anyone else and a rose can be exchanged only once.\nTara has to bring maximum sufficient roses for everyone and is confused as she don't know how many roses to buy.You are a friend of Kabir, so help him to solve the problem so that he can impress Tara by helping her. \n\n-----Input:-----\n- First line will contain T, number of test cases. \n- Each test case contains two space separated integers B (Number of boys) and  G (Number of Girls).\n\n-----Output:-----\nFor each test case, output in a single line the total number of roses exchanged.\n\n-----Constraints:-----\n- 1≤T≤10^5\n- 1≤B≤10^9\n- 1≤G≤10^9\n\n-----Sample Input:-----\n1\n2 3\n\n-----Sample Output:-----\n8", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn calculate_roses_spec(boys: nat, girls: nat) -> nat \n    recommends boys > 0 && girls > 0\n{\n    ((2 * ((boys + girls) - 1)) as nat)\n}\n\nfn calculate_roses(boys: nat, girls: nat) -> (result: nat)\n    requires boys > 0 && girls > 0,\n    ensures result % 2 == 0 && result >= 0 && result == calculate_roses_spec(boys, girls),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\nproof fn roses_is_even(boys: nat, girls: nat)\n    requires boys > 0 && girls > 0,\n    ensures calculate_roses_spec(boys, girls) % 2 == 0,\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn roses_is_nonnegative(boys: nat, girls: nat)\n    requires boys > 0 && girls > 0,\n    ensures calculate_roses_spec(boys, girls) >= 0,\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn roses_formula(boys: nat, girls: nat)\n    requires boys > 0 && girls > 0,\n    ensures calculate_roses_spec(boys, girls) == ((2 * ((boys + girls) - 1)) as nat),\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn equal_boys_girls(n: nat)\n    requires n > 0,\n    ensures calculate_roses_spec(n, n) == ((2 * (2 * n - 1)) as nat),\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn minimum_case()\n    ensures calculate_roses_spec(1, 1) == 2,\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\n}\n\nfn main() {\n    // assert(calculate_roses(2, 3) == 8);\n    // assert(calculate_roses(3, 3) == 10);\n    // assert(calculate_roses(1, 1) == 2);\n}"}
{"id": "fvapps_000700", "vc-description": "Problem: Suppose there is a circle. There are N Juice shops on that circle. Juice shops are numbered 0 to N-1 (both inclusive). You have two pieces of information corresponding to each of the juice shop:\n(1) the amount of Juice that a particular Juice shop can provide and \n(2) the distance from that juice shop to the next juice shop.\n\nInitially, there is a man with a bottle of infinite capacity carrying no juice. He can start the tour at any of the juice shops. Calculate the first point from where the man will be able to complete the circle. Consider that the man will stop at every Juice Shop. The man will move one kilometer for each litre of the juice.\n\nInput:\n- The first line will contain the value of N.\n- The next N lines will contain a pair of integers each, i.e. the amount of juice that a juice shop can provide(in litres) and the distance between that juice shop and the next juice shop.\n\nOutput:\nAn integer which will be the smallest index of the juice shop from which he can start the tour.\n\nConstraints:\n- 1 ≤ N ≤ 10^5\n- 1 ≤ amt of juice, distance ≤ 10^9\n\nSample Input:\n3\n1 5\n10 3\n3 4\n\nSample Output:\n1\n\nExplanation:\nHe can start the tour from the SECOND Juice shop.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn find_starting_juice_shop(juices: Vec<int>, distances: Vec<int>) -> (result: i32)\n    requires \n        juices.len() == distances.len(),\n    ensures\n        (juices.len() == 0 || distances.len() == 0) ==> result == -1,\n        result == -1 || (0 <= result < juices.len()),", "vc-code": "{\n    // impl-start\n    assume(false);\n    -1\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let result1 = find_starting_juice_shop(vec![1, 10, 3], vec![5, 3, 4]);\n    // assert(result1 == 1);\n    \n    // let result2 = find_starting_juice_shop(vec![5, 2, 3], vec![4, 3, 2]);\n    // assert(result2 == 0);\n    \n    // let result3 = find_starting_juice_shop(vec![1, 2, 3], vec![4, 5, 6]);\n    // assert(result3 == -1);\n}"}
{"id": "fvapps_000701", "vc-description": "All strings in Chefland are beautiful because they are binary strings (a binary string contains only characters '0' and '1'). The beauty of a binary string S is defined as the number of pairs (i, j) (1 ≤ i ≤ j ≤ |S|) such that the substring S_i, S_{i+1}, ..., S_j is special.\nFor a binary string U, let's denote the number of occurrences of the characters '1' and '0' in U by cnt_1 and cnt_0 respectively; then, U is special if cnt_0 = cnt_1 * cnt_1.\nToday, Chef's friend Araspa is celebrating her birthday. Chef wants to give Araspa the most beautiful binary string he can find. Currently, he is checking out binary strings in a shop, but he needs your help to calculate their beauties. Tell Chef the beauty of each binary string he gives you.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn is_binary_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nspec fn count_zeros(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0nat\n    } else {\n        (if s[0] == '0' { 1nat } else { 0nat }) + count_zeros(s.skip(1))\n    }\n}\n\nspec fn count_ones(s: Seq<char>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0nat\n    } else {\n        (if s[0] == '1' { 1nat } else { 0nat }) + count_ones(s.skip(1))\n    }\n}\n\nspec fn is_special_substring(s: Seq<char>) -> bool {\n    let cnt_0 = count_zeros(s);\n    let cnt_1 = count_ones(s);\n    cnt_0 == cnt_1 * cnt_1\n}", "vc-spec": "fn count_special_substrings(s: Vec<char>) -> (result: usize)\n    requires is_binary_string(s@),\n    ensures result <= s.len() * (s.len() + 1) / 2", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "}\n\nfn main() {\n    // let result1 = count_special_substrings(vec!['0', '1', '0', '0', '0', '1']);\n    // println!(\"Result for '010001': {}\", result1); // Expected: 4\n    \n    // let result2 = count_special_substrings(vec!['1', '0']);\n    // println!(\"Result for '10': {}\", result2); // Expected: 1\n    \n    // let result3 = count_special_substrings(vec!['1', '1', '0', '0']);\n    // println!(\"Result for '1100': {}\", result3); // Expected: 1\n}"}
{"id": "fvapps_000703", "vc-description": "The kingdom of the snakes is an NxN grid. Their most-valued possession is a huge collection of poison, which is stored in the central KxK grid. It is guaranteed that both N and K are odd. What we mean by 'central' is this: suppose in the NxN grid, (i, j) refers to the cell in the i-th row and j-th column and (1,1) refers to the top-left corner and (N,N) refers to the bottom-right corner. Then the poison is stored in the KxK square whose top-left corner is ( (N - K)/2 + 1, (N - K)/2 + 1 ).\n\nBut there are thieves who want to steal the poison. They cannot enter the NxN grid, but they can shoot arrows from outside. These arrows travel across a row (from left to right, or right to left), or across a column (top to bottom or bottom to top) in a straight line. If the arrow enters the KxK grid, some of the poison will stick to the arrow, and if it exits the NxN grid after that, the thieves will have successfully stolen some of the poison.\nAs the King of the snakes, you want to thwart these attempts. You know that the arrows will break and stop if they hit a snake's scaly skin, but won't hurt the snakes. There are some snakes already guarding the poison. Each snake occupies some consecutive cells in a straight line inside the NxN grid. That is, they are either part of a row, or part of a column. Note that there can be intersections between the snakes.  A configuration of snakes is 'safe', if the thieves cannot steal poison. That is, no matter which row or column they shoot arrows from, either the arrow should hit a snake and stop (this can happen even after it has entered and exited the KxK grid), or it shouldn't ever enter the KxK grid.\nThe King has other duties for the snakes, and hence wants to remove as many snakes as possible from this configuration, such that the remaining configuration is still 'safe'. Help him find the minimum number of snakes he needs to leave behind to protect the poison.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_snake_kingdom(n: nat, k: nat, snakes: Vec<Vec<nat>>) -> (result: i32)\n    requires \n        3 <= n,\n        n <= 1000000000,\n        1 <= k,\n        k <= n - 2,\n        n % 2 == 1,\n        k % 2 == 1,\n        snakes.len() <= 100000,\n        forall|i: int| 0 <= i < snakes.len() ==> snakes[i].len() == 4,\n    ensures\n        result == -1 || result >= 0,\n        snakes.len() == 0 ==> result == -1,", "vc-code": "{\n    // impl-start\n    assume(false);\n    -1\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000708", "vc-description": "To protect people from evil, \na long and tall wall was constructed a few years ago. \nBut just a wall is not safe, there should also be soldiers on it, \nalways keeping vigil. \nThe wall is very long and connects the left and the right towers. \nThere are exactly N spots (numbered 1 to N) on the wall for soldiers. \nThe Kth spot is K miles far from the left tower and (N+1-K) miles from the right tower.\n\nGiven a permutation of spots P of {1, 2, ..., N}, soldiers occupy the N spots in that order. \nThe P[i]th spot is occupied before the P[i+1]th spot. \nWhen a soldier occupies a spot, he is connected to his nearest soldier already placed to his left. \nIf there is no soldier to his left, he is connected to the left tower. The same is the case with right side. \nA connection between two spots requires a wire of length equal to the distance between the two.\n\nThe realm has already purchased a wire of M miles long from Nokia, \npossibly the wire will be cut into smaller length wires. \nAs we can observe, the total length of the used wire depends on the permutation of the spots P. Help the realm in minimizing the length of the unused wire. If there is not enough wire, output -1.\n\nInput:\nFirst line contains an integer T (number of test cases, 1 ≤ T ≤ 10 ). Each of the next T lines contains two integers N M, as explained in the problem statement (1 ≤ N ≤ 30 , 1 ≤ M ≤ 1000).\n\nOutput:\nFor each test case, output the minimum length of the unused wire, or -1 if the the wire is not sufficient.\n\nExample:\nInput:\n4\n3 8\n3 9\n2 4\n5 25\n\nOutput:\n0\n0\n-1\n5\n\nExplanation:\n\nIn the 1st case, for example, the permutation P = {2, 1, 3} will use the exact 8 miles wires in total.\n\nIn the 2nd case, for example, the permutation P = {1, 3, 2} will use the exact 9 miles wires in total.\n\nTo understand the first two cases, you can see the following figures:\n\nIn the 3rd case, the minimum length of wire required is 5, for any of the permutations {1,2} or {2,1}, so length 4 is not sufficient.\n\nIn the 4th case, for the permutation {1, 2, 3, 4, 5} we need the maximum length of the wire = 20. So minimum possible unused wire length = 25 - 20 = 5.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_wire_problem(n: u32, m: u32) -> (result: i32)\n    requires \n        1 <= n && n <= 30,\n        m <= 1000,\n    ensures \n        result == -1 || result >= 0,\n        m < 2 * n ==> result == -1", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Test cases from the problem\n    // assert(solve_wire_problem(3, 8) == 0);\n    // assert(solve_wire_problem(3, 9) == 0);\n    // assert(solve_wire_problem(2, 4) == -1);\n    // assert(solve_wire_problem(5, 25) == 5);\n}"}
{"id": "fvapps_000709", "vc-description": "Given a square matrix of size N×N, calculate the absolute difference between the sums of its diagonals. \n\n-----Input-----\nThe first line contains a single integer N. The next N lines denote the matrix's rows, with each line containing N space-separated integers describing the columns.\n\n-----Output-----\nPrint the absolute difference between the two sums of the matrix's diagonals as a single integer.\n\n-----Constraints-----\n1<=N<=10\n\n-----Example-----\nInput:\n3\n11 2 4\n4 5 6\n10 8 -12\n\nOutput:\n15\n\n-----Explanation-----\nThe primary diagonal is: \n11\n5\n-12\nSum across the primary diagonal: 11 + 5 - 12 = 4\nThe secondary diagonal is:\n4\n5\n10\nSum across the secondary diagonal: 4 + 5 + 10 = 19 \nDifference: |4 - 19| = 15", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_square_matrix(matrix: Seq<Seq<i32>>) -> bool {\n    matrix.len() > 0 && forall|i: int| 0 <= i < matrix.len() ==> matrix[i].len() == matrix.len()\n}\n\nspec fn primary_diagonal_sum(matrix: Seq<Seq<i32>>, idx: nat) -> int\n    decreases matrix.len() - idx\n{\n    if idx >= matrix.len() || !is_square_matrix(matrix) {\n        0\n    } else {\n        (matrix[idx as int][idx as int] as int) + primary_diagonal_sum(matrix, idx + 1)\n    }\n}\n\nspec fn secondary_diagonal_sum(matrix: Seq<Seq<i32>>, idx: nat) -> int\n    decreases matrix.len() - idx\n{\n    if idx >= matrix.len() || !is_square_matrix(matrix) {\n        0\n    } else {\n        (matrix[idx as int][(matrix.len() - 1 - idx) as int] as int) + secondary_diagonal_sum(matrix, idx + 1)\n    }\n}\n\nfn diagonal_difference(matrix: Vec<Vec<i32>>) -> (result: i32)\n    requires \n        matrix.len() > 0,\n        forall|i: int| 0 <= i < matrix.len() ==> matrix[i]@.len() == matrix.len(),\n    ensures \n        matrix.len() == 1 ==> result == 0,\n        result >= 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let test_matrix = vec![vec![11, 2, 4], vec![4, 5, 6], vec![10, 8, -12]];\n    // println!(\"{}\", diagonal_difference(test_matrix));\n    \n    // let test_matrix2 = vec![vec![1, 2], vec![3, 4]];\n    // println!(\"{}\", diagonal_difference(test_matrix2));\n    \n    // let test_matrix3 = vec![vec![5]];\n    // println!(\"{}\", diagonal_difference(test_matrix3));\n}"}
{"id": "fvapps_000715", "vc-description": "Chef has N markers. There is a cap on each marker. For each valid i, the i-th marker has colour a_i. Initially, for each valid i, the colour of the cap on the i-th marker is also a_i.\nChef wants to rearrange the caps in such a way that no marker has the same colour as its cap. (Obviously, each marker must have exactly one cap.) Can he do that? If he can, find one such way to rearrange the caps. If there are multiple solutions, you may find any one.\n\n-----Input-----\n- The first line of the input contains a single integer T denoting the number of test cases. The description of T test cases follows.\n- The first line of each test case contains a single integer N.\n- The second line contains N space-separated integers a_1, a_2, ..., a_N.\n\n-----Output-----\n- For each test case:\n- If Chef cannot successfully rearrange the caps, print a single line containing the string \"No\" (without quotes).\n- Otherwise, print two lines. The first line should contain the string \"Yes\" (without quotes). The second line should contain N space-separated integers describing a valid rearrangement of caps. For each valid i, the i-th of these integers should denote the final colour of the cap on the i-th marker.\n\n-----Constraints-----\n- 1 ≤ T ≤ 10\n- 1 ≤ N ≤ 10^5\n- 1 ≤ a_i ≤ 10^9 for each valid i\n\n-----Example Input-----\n2\n9\n1 1 1 2 2 2 3 3 3\n2\n1 1\n\n-----Example Output-----\nYes\n2 2 2 3 3 3 1 1 1\nNo", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn count_occurrences(nums: Seq<u32>, value: u32) -> nat\n    decreases nums.len()\n{\n    if nums.len() == 0 {\n        0nat\n    } else {\n        (if nums[0] == value { 1nat } else { 0nat }) + count_occurrences(nums.skip(1), value)\n    }\n}\n\nfn rearrange_caps(nums: Vec<u32>) -> (result: Option<Vec<u32>>)\n    ensures \n        match result {\n            Some(caps) => {\n                &&& caps.len() == nums.len()\n                &&& (forall|i: int| 0 <= i < caps.len() ==> caps[i] != nums[i])\n                &&& (forall|value: u32| count_occurrences(nums@, value) == count_occurrences(caps@, value))\n            },\n            None => {\n                exists|majority_value: u32| count_occurrences(nums@, majority_value) > nums.len() / 2\n            }\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    None\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000716", "vc-description": "Harish has decided to go to Arya's hotel this morning. We all know he is crazy for masala dosas. And as usual he is always hungry. He decided to order all the masala dosas at once. But then he realised that he did not have enough money to buy all of them. So he decided to share the amount with his friend Ozil. But both of them are fans of even numbers. Both of them says they want to eat even number of dosas. Ozil is ready to put the share if and only if , he is sure that he can get even number of dosas. So given N number of dosas can you please help Harish to decide, if he will be able to get all the dosas at once from the hotel.\n\n-----Input-----\nThe first line of input contains an integer T which denotes the number of test files. Next T lines contains an integer N where N is the total number of dosas.\n\n-----Output-----\nPrint \"YES\" if both can get even number of dosas. If it is not possible print \"NO\".\n\n-----Constraints-----\n- 1 ≤ T ≤ 10^6\n- 1 ≤ N ≤ 10^18\n\n-----Subtasks-----\nSubtask #1 : (20 points)\n- 1 ≤ T ≤ 10\n- 1 ≤ N≤ 100\n\nSubtask 2 : (80 points) \n\n- 1 ≤ T ≤ 10^6\n- 1 ≤ N≤ 10^18\n\n-----Example-----\nInput:\n2 \n16 \n27\nOutput:\nYES\nNO", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn can_split_dosas_evenly(n: u64) -> (result: String)\n    ensures\n        result@ === seq!['Y', 'E', 'S'] || result@ === seq!['N', 'O'],\n        result@ === (if n % 2 == 0 { seq!['Y', 'E', 'S'] } else { seq!['N', 'O'] }),\n        (n % 2 == 0) ==> result@ === seq!['Y', 'E', 'S'],\n        (n % 2 != 0) ==> result@ === seq!['N', 'O']", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: unguarded\n    //\n    // Example test cases:\n    // assert(can_split_dosas_evenly(16)@ === seq!['Y', 'E', 'S']);\n    // assert(can_split_dosas_evenly(27)@ === seq!['N', 'O']);\n    // assert(can_split_dosas_evenly(100)@ === seq!['Y', 'E', 'S']);\n}"}
{"id": "fvapps_000721", "vc-description": "There is a field with plants — a grid with N rows (numbered 1 through N) and M columns (numbered 1 through M); out of its NM cells, K cells contain plants, while the rest contain weeds. Two cells are adjacent if they have a common side.\nYou want to build fences in the field in such a way that the following conditions hold for each cell that contains a plant:\n- it is possible to move from this cell to each adjacent cell containing a plant without crossing any fences\n- it is impossible to move from this cell to any cell containing weeds or to leave the grid without crossing any fences\nThe fences can only be built between cells or on the boundary of the grid, i.e. on the sides of cells. The total length of the built fences is the number of pairs of side-adjacent cells such that there is a fence built on their common side plus the number of sides of cells on the boundary of the grid which have fences built on them. Find the minimum required total length of fences that need to be built.\n\n-----Input-----\n- The first line of the input contains a single integer T denoting the number of test cases. The description of T test cases follows.\n- The first line of each test case contains three space-separated integers N, M and K.\n- K lines follow. Each of these lines contains two space-separated integers r and c denoting that the cell in row r and column c contains a plant.\n\n-----Output-----\nFor each test case, print a single line containing one integer — the minimum required length of fences.\n\n-----Constraints-----\n- 1 ≤ T ≤ 10\n- 1 ≤ N, M ≤ 10^9\n- 1 ≤ K ≤ 10^5\n- 1 ≤ r ≤ N\n- 1 ≤ c ≤ M\n- the cells containing plants are pairwise distinct\n\n-----Subtasks-----\nSubtask #1 (30 points): 1 ≤ N, M ≤ 1,000\nSubtask #2 (70 points): original constraints\n\n-----Example Input-----\n2\n4 4 9\n1 4\n2 1 \n2 2\n2 3\n3 1\n3 3\n4 1\n4 2\n4 3\n4 4 1\n1 1\n\n-----Example Output-----\n20\n4\n\n-----Explanation-----\nExample case 1: The field looks like this ('x' denotes a cell containing a plant, '.' denotes a cell containing weeds):\n...x\nxxx.\nx.x.\nxxx.\n\nAn optimal solution is to build fences around the topmost plant (with length 4), around the remaining eight plants (with length 12) and around the hole between them (with length 4). The total length is 4+12+4 = 20.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn calculate_min_fences(n: nat, m: nat, plants: Vec<(nat, nat)>) -> (result: nat)\n    requires \n        n > 0,\n        m > 0,\n        plants.len() > 0,\n    ensures \n        result > 0,\n        plants.len() == 1 ==> result == 4,\n        result <= 4 * plants.len(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000724", "vc-description": "Yesterday, Chef found K empty boxes in the cooler and decided to fill them with apples. He ordered N apples, where N is a multiple of K. Now, he just needs to hire someone who will distribute the apples into the boxes with professional passion. \nOnly two candidates passed all the interviews for the box filling job. In one minute, each candidate can put K apples into boxes, but they do it in different ways: the first candidate puts exactly one apple in each box, while the second one chooses a random box with the smallest number of apples and puts K apples in it.\nChef is wondering if the final distribution of apples can even depend on which candidate he hires. Can you answer that question?\nNote: The boxes are distinguishable (labeled), while the apples are not. Therefore, two distributions of apples are different if there is a box such that the number of apples in it when the first candidate finishes working can be different from the number of apples in it when the second candidate finishes working.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_apple_distribution(n: u64, k: u64) -> (result: bool)\n    requires \n        n > 0,\n        k > 0,\n        n % k == 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = solve_apple_distribution(5, 1);\n    // println!(\"{}\", result1); // Should return false (NO)\n    \n    // let result2 = solve_apple_distribution(4, 2);\n    // println!(\"{}\", result2); // Should return false (NO)\n    \n    // let result3 = solve_apple_distribution(10, 10);\n    // println!(\"{}\", result3); // Should return true (YES)\n}"}
{"id": "fvapps_000725", "vc-description": "The chef is trying to solve some pattern problems, Chef wants your help to code it. Chef has one number K (odd) to form a new pattern. Help the chef to code this pattern problem.\n\n-----Input:-----\n- First-line will contain $T$, the number of test cases. Then the test cases follow. \n- Each test case contains a single line of input, one integer $K$. \n\n-----Output:-----\nFor each test case, output as the pattern.\n\n-----Constraints-----\n- $1 \\leq T \\leq 100$\n- $1 \\leq K \\leq 100$\n\n-----Sample Input:-----\n4\n1\n3\n5\n7\n\n-----Sample Output:-----\n*\n*\n**\n*\n*\n**\n* *\n**\n*\n*\n**\n* *\n*  *\n* *\n**\n*\n\n-----EXPLANATION:-----\nNo need, else pattern can be decode easily.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn generate_pattern(k: usize) -> (result: Vec<String>)\n    requires k % 2 == 1,\n    ensures\n        result.len() == k,\n        result@ == result@.reverse(),\n        k >= 1 ==> result[0]@ == seq!['*'],\n        k >= 1 ==> result[k - 1]@ == seq!['*'],\n        k > 1 ==> result[1]@ == seq!['*', '*'],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let pattern1 = generate_pattern(1);\n    // println!(\"{:?}\", pattern1);\n    \n    // let pattern3 = generate_pattern(3);\n    // println!(\"{:?}\", pattern3);\n    \n    // let pattern5 = generate_pattern(5);\n    // println!(\"{:?}\", pattern5);\n}"}
{"id": "fvapps_000730", "vc-description": "The Government of Siruseri is no different from any other when it comes to being \"capital-centric\" in its policies. Recently the government decided to set up a nationwide fiber-optic network to take Siruseri into the digital age. And as usual, this decision was implemented in a capital centric manner --- from each city in the country, a fiber optic cable was laid to the capital! Thus, traffic between any two cities had to go through the capital.\nSoon, it became apparent that this was not quite a clever idea, since any breakdown at the capital resulted in the disconnection of services between other cities. So, in the second phase, the government plans to connect a few more pairs of cities directly by fiber-optic cables. The government has specified that this is to be done in such a way that the disruption of services at any one city will still leave the rest of the country connected.\nThe government has data on the cost of laying fiber optic cables between every pair of cities. You task is to compute the minimum cost of additional cabling required to ensure the requirement described above is met.\nFor example, if Siruseri has $4$ cities numbered $1,2,3$ and $4$ where $1$ is the capital and further suppose that the cost of laying cables between these cities are as given in the table below:\n\nNote that the government has already connected the capital with every other city. So, if we connect the cities $2$ and $3$ as well as $3$ and $4$, you can check that disruption of service at any one city will still leave the other cities connected. The cost of connecting these two pairs is $4 + 6 = 10$. The same effect could have been achieved by connecting $2$ and $3$ as well as $2$ and $4$, which would have cost $4 + 5 = 9$. You can check that this is the best you can do.\nYour task is to write a program that allows the government to determine the minimum cost it has to incur in laying additional cables to fulfil the requirement.\n\n-----Input:-----\n- The first line of the input contains a single integer $N$ indicating the number of cities in Siruseri. You may assume that the capital city is always numbered $1$. \n- This is followed by $N$ lines of input each containing $N$ integers. \n- The $j^{th}$ integer on line $i$ is the cost of connecting city $i$ with city $j$. The $j^{th}$ integer on line $i$ will be the same as the $i^{th}$ integer on line $j$ (since the links are bidirectional) and the $i^{th}$ entry on line $i$ will always be $0$ (there is no cost in connecting a city with itself).\n\n-----Output:-----\nA single integer indicating the minimum total cost of the links to be added to ensure that disruption of services at one city does not disconnect the rest of the cities.\n\n-----Constraints:-----\n- $1 \\leq N \\leq 2000$.\n- $0 \\leq$ costs given in the input $\\leq 100000$\n\n-----Sample Input-----\n4\n0 7 8 10\n7 0 4 5 \n8 4 0 6\n10 5 6 0\n\n-----Sample Output-----\n9", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn total_cost_lists(costs: Seq<Seq<usize>>) -> nat\n    decreases costs.len()\n{\n    if costs.len() == 0 {\n        0\n    } else {\n        row_sum(costs[0]) + total_cost_lists(costs.skip(1))\n    }\n}\n\nspec fn row_sum(row: Seq<usize>) -> nat\n    decreases row.len()\n{\n    if row.len() == 0 {\n        0\n    } else {\n        (row[0] as nat) + row_sum(row.skip(1))\n    }\n}\n\nspec fn max_element_lists(costs: Seq<Seq<usize>>) -> usize\n    decreases costs.len()\n{\n    if costs.len() == 0 {\n        0\n    } else {\n        spec_max(row_max(costs[0]), max_element_lists(costs.skip(1)))\n    }\n}\n\nspec fn row_max(row: Seq<usize>) -> usize\n    decreases row.len()\n{\n    if row.len() == 0 {\n        0\n    } else {\n        spec_max(row[0], row_max(row.skip(1)))\n    }\n}\n\nspec fn spec_max(a: usize, b: usize) -> usize {\n    if a >= b { a } else { b }\n}\n\nfn min_cable_cost(n: usize, costs: Vec<Vec<usize>>) -> (result: usize)\n    requires \n        n > 0,\n        costs.len() == n,\n        forall|i: int| 0 <= i < n ==> costs[i].len() == n,\n    ensures \n        result <= total_cost_lists(costs@.map(|i: int, row: Vec<usize>| row@)) / 2,\n        result <= (n * (n - 1)) / 2 * (max_element_lists(costs@.map(|i: int, row: Vec<usize>| row@)) as nat),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result = min_cable_cost(4, vec![vec![0, 7, 8, 10], vec![7, 0, 4, 5], vec![8, 4, 0, 6], vec![10, 5, 6, 0]]);\n    // println!(\"{}\", result);\n    \n    // let result2 = min_cable_cost(3, vec![vec![0, 1, 2], vec![1, 0, 3], vec![2, 3, 0]]);\n    // println!(\"{}\", result2);\n}"}
{"id": "fvapps_000731", "vc-description": "Some programming contest problems are really tricky: not only do they\nrequire a different output format from what you might have expected, but\nalso the sample output does not show the difference. For an example,\nlet us look at permutations.\n\nA permutation of the integers 1 to n is an\nordering of\nthese integers. So the natural way to represent a permutation is\nto list the integers in this order. With n = 5, a\npermutation might look like 2, 3, 4, 5, 1. \n\nHowever, there is another possibility of representing a permutation:\nYou create a list of numbers where the i-th number is the\nposition of the integer i in the permutation. \nLet us call this second\npossibility an inverse permutation. The inverse permutation\nfor the sequence above is 5, 1, 2, 3, 4.\n\nAn ambiguous permutation is a permutation which cannot be\ndistinguished from its inverse permutation. The permutation 1, 4, 3, 2\nfor example is ambiguous, because its inverse permutation is the same.\nTo get rid of such annoying sample test cases, you have to write a\nprogram which detects if a given permutation is ambiguous or not.\n\n-----Input Specification-----\nThe input contains several test cases.\n\nThe first line of each test case contains an integer n\n(1 ≤ n ≤ 100000).\nThen a permutation of the integers 1 to n follows\nin the next line. There is exactly one space character\nbetween consecutive integers.\nYou can assume that every integer between 1 and n\nappears exactly once in the permutation.\n\nThe last test case is followed by a zero.\n\n-----Output Specification-----\nFor each test case output whether the permutation is ambiguous or not.\nAdhere to the format shown in the sample output.\n\n-----Sample Input-----\n4\n1 4 3 2\n5\n2 3 4 5 1\n1\n1\n0\n\n-----Sample Output-----\nambiguous\nnot ambiguous\nambiguous", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn permutation_inverse(xs: Seq<usize>) -> Seq<usize>\n    decreases xs.len()\n{\n    if xs.len() == 0 {\n        seq![]\n    } else {\n        let result = Seq::new(xs.len(), |i: int| 0);\n        result\n    }\n}\n\nfn is_ambiguous_permutation(xs: Vec<usize>) -> (result: bool)\n    requires \n        xs.len() > 0,\n        forall|i: int| 0 <= i < xs.len() ==> #[trigger] xs[i] >= 1 && #[trigger] xs[i] <= xs.len(),\n        forall|i: int, j: int| 0 <= i < xs.len() && 0 <= j < xs.len() && i != j ==> #[trigger] xs[i] != #[trigger] xs[j],\n    ensures \n        result <==> (xs@ == permutation_inverse(permutation_inverse(xs@))),\n        result <==> (permutation_inverse(xs@) == xs@)", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let test1 = vec![1, 4, 3, 2];\n    // let test2 = vec![2, 3, 4, 5, 1];\n    // let test3 = vec![1];\n    // println!(\"{}\", is_ambiguous_permutation(test1));\n    // println!(\"{}\", is_ambiguous_permutation(test2));\n    // println!(\"{}\", is_ambiguous_permutation(test3));\n}"}
{"id": "fvapps_000733", "vc-description": "Many internet protocols these days include the option of associating a\nmedia type with the content being sent.\nThe type is usually inferred from the file extension.\nYou are to write a program that facilitates the lookup of media types for\na number of files.\nYou will be given a table of media type associations that associate a certain\nfile extension with a certain media type.\nYou will then be given a number of file names, and tasked to determine the correct\nmedia type for each file.\nA file extension is defined as the part of the file name after the final period.\nIf a file name has no periods, then it has no extension and the media type cannot\nbe determined.\nIf the file extension is not present in the table, then the media type cannot be\ndetermined.\nIn such cases you will print \"unknown\" as the media type.\nIf the file extension does appear in the table (case matters), then print the associated\nmedia type.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn determine_media_types(associations: Vec<(String, String)>, filenames: Vec<String>) -> (result: Vec<String>)\n    ensures \n        result.len() == filenames.len(),\n        associations.len() == 0 ==> \n            forall|i: int| 0 <= i < result.len() ==> result[i]@ == \"unknown\"@", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000734", "vc-description": "It's autumn now, the time of the leaf fall.\nSergey likes to collect fallen leaves in autumn. In his city, he can find fallen leaves of maple, oak and poplar. These leaves can be of three different colors: green, yellow or red.\nSergey has collected some leaves of each type and color. Now he wants to create the biggest nice bouquet from them. He considers the bouquet nice iff all the leaves in it are either from the same type of tree or of the same color (or both). Moreover, he doesn't want to create a bouquet with even number of leaves in it, since this kind of bouquets are considered to attract bad luck. However, if it's impossible to make any nice bouquet, he won't do anything, thus, obtaining a bouquet with zero leaves.\nPlease help Sergey to find the maximal number of leaves he can have in a nice bouquet, which satisfies all the above mentioned requirements.\nPlease note that Sergey doesn't have to use all the leaves of the same color or of the same type. For example, if he has 20 maple leaves, he can still create a bouquet of 19 leaves.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn find_max_bouquet(mg: u32, my: u32, mr: u32, og: u32, oy: u32, or_: u32, pg: u32, py: u32, pr: u32) -> (result: u32)\n    ensures\n        /* The result is the maximum odd number of leaves that can form a nice bouquet */\n        result % 2 == 1 || result == 0,\n        /* A nice bouquet uses leaves of same type or same color */\n        result <= mg + og + pg || /* all green leaves */\n        result <= my + oy + py || /* all yellow leaves */\n        result <= mr + or_ + pr || /* all red leaves */\n        result <= mg + my + mr || /* all maple leaves */\n        result <= og + oy + or_ || /* all oak leaves */\n        result <= pg + py + pr,    /* all poplar leaves */\n        /* Special case: all same values should return 3*n or 3*n-1 */\n        (mg == my && my == mr && mr == og && og == oy && oy == or_ && or_ == pg && pg == py && py == pr) ==>\n            (result == 3 * mg || (3 * mg > 0 && result == 3 * mg - 1) || result == 0),\n        /* Zero case */\n        (mg == 0 && my == 0 && mr == 0 && og == 0 && oy == 0 && or_ == 0 && pg == 0 && py == 0 && pr == 0) ==>\n            result == 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = find_max_bouquet(1, 2, 3, 3, 2, 1, 1, 3, 4);\n    // let result2 = find_max_bouquet(0, 0, 0, 0, 0, 0, 0, 0, 0);\n    // let result3 = find_max_bouquet(1, 1, 1, 1, 1, 1, 1, 1, 1);\n}"}
{"id": "fvapps_000738", "vc-description": "Saket loves to play with strings. One day , while he was having fun with Cyclic Permutations of available strings to him, he observed that despite being scarce in numbers Vowels were really clingy.Being clingy means for almost every given string, there was a Cyclic Permutation in which atleast two vowels were together.\nSo he decided to check this property for all the available strings to him. As the number of strings can be very large, help Saket determine whether the given string is clingy or not.\n\n-----Input:-----\nThe first line of the input contains a single integer T$T$ denoting the number of test cases. The description of T$T$ test cases follows.\nFirst line of every test case contains an integer N$N$ denoting the length of the string.\nSecond line contains a string S$S$ of length N$N$, consisting only of uppercase english alphabets.\n\n-----Output:-----\nFor each test case, print a single line containing \"Yes\" if any of the cyclic permutations of the string is clingy else print \"No\".\n\n-----Constraints-----\n- 1≤T≤1000$1 \\leq T \\leq 1000$\n- 1≤N≤1000$1 \\leq N \\leq 1000$\n- String S$S$ consists of only upper case english alphabets.\n\n-----Subtasks-----\n- 20 points : 1≤N≤5$1 \\leq N \\leq 5$\n- 80 points : Original$Original$ Constraints$Constraints$\n\n-----Sample Input:-----\n2\n5\nAUXFC\n6\nXBCDEF\n\n-----Sample Output:-----\nYes\n\nNo\n\n-----EXPLANATION:-----\nExample$Example$ case1:$ case 1: $ One of the cyclic permutation is the original string itself, which has \"A\" and \"U\" together.\nExample$Example$ case2:$ case 2: $     None of the cyclic permutation will have 2 vowels together.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn vowels() -> Set<char> {\n    set!['A', 'E', 'I', 'O', 'U']\n}\n\nspec fn is_vowel(c: char) -> bool {\n    vowels().contains(c)\n}\n\nspec fn is_uppercase_char(c: char) -> bool {\n    c >= 'A' && c <= 'Z'\n}\n\nspec fn has_adjacent_vowels(s: Seq<char>) -> bool \n    decreases s.len()\n{\n    if s.len() < 2 {\n        false\n    } else {\n        (is_vowel(s[0]) && is_vowel(s[1])) || has_adjacent_vowels(s.skip(1))\n    }\n}\n\nspec fn rotate_string(s: Seq<char>, i: nat) -> Seq<char> {\n    if i >= s.len() {\n        s\n    } else {\n        s.subrange(i as int, s.len() as int) + s.subrange(0, i as int)\n    }\n}\n\nspec fn exists_clingy_rotation(s: Seq<char>) -> bool {\n    exists|i: nat| i < s.len() && has_adjacent_vowels(rotate_string(s, i))\n}\n\nspec fn all_uppercase(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> is_uppercase_char(s[i])\n}\n\nspec fn all_vowels(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> is_vowel(s[i])\n}\n\nspec fn all_consonants(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> !is_vowel(s[i])\n}", "vc-spec": "fn is_clingy(s: Vec<char>) -> (result: bool)\n    requires all_uppercase(s@),\n    ensures \n        result <==> exists_clingy_rotation(s@),\n        all_vowels(s@) && s@.len() >= 2 ==> result == true,\n        all_consonants(s@) ==> result == false,\n        s@.len() == 1 ==> result == false", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\n/* Apps difficulty: interview */\n/* Assurance level: unguarded */\n\n/*\nfn test_is_clingy() {\n    assert(is_clingy(vec!['A', 'U', 'X', 'F', 'C']));\n    assert(!is_clingy(vec!['X', 'B', 'C', 'D', 'E', 'F']));\n    assert(is_clingy(vec!['A', 'E', 'I', 'O', 'U']));\n}\n*/\n\n}\n\nfn main() {\n    // test_is_clingy();\n}"}
{"id": "fvapps_000739", "vc-description": "Everyone loves short problem statements.\nGiven a function f(x) find its minimum value over the range 0 < x < π/2\nf(x) = ( x^2 + b*x + c ) / sin( x )\n\n-----Input:-----\n- First-line will contain T, the number of test cases. Then the test cases follow. \n- Each test case contains a single line of input, two real numbers b, c. \n\n-----Output:-----\nFor each test case, output the minimum value of f(x) over the given range. Absolute error of 10^-6 is allowed.\n\n-----Constraints-----\n- 1 ≤ T ≤ 100000\n- 1 ≤ b,c ≤ 20\n\n-----Sample Input:-----\n1\n2 2\n\n-----Sample Output:-----\n5.8831725615", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn find_min_fx(b: i32, c: i32) -> (result: i32)\n    requires \n        1 <= b && b <= 20,\n        1 <= c && c <= 20,\n    ensures \n        result > 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000742", "vc-description": "Chef spent N days working really hard! He planned loads of tasks: as many as Ai tasks to do on the ith day! Chef's work was brutal, so he only managed to finish Bi tasks on the ith day.\nThe good news is that Chef has a Time Machine! \nThe Time Machine has K white buttons and M black buttons. Each button has a positive integer printed on it. Now Chef goes through all N days consequently and presses buttons. Each day Chef can only press one button (either white or black). After using a button once, it becomes inactive.\nPressing a white button with integer x printed on it reduces the number of planned tasks on the day it was pressed by exactly x. Note that this white button can only be pressed if number of planned tasks on the day are greater than or equal to x.\nPressing a black button with integer x printed on it increases the number of completed tasks on the day it was pressed by exactly x. Note that this black button can only be pressed if after pressing it, number of completed tasks don't exceed the number of tasks.\nChef is interested in finding the minimum possible amount of total uncompleted tasks he will still be left with after N days using the Machine in the best way?\nBe careful! Time is sensitive! Chef cannot make a day when he completed more tasks then planned, as this may result in a more-work-than-planned paradox, killing all lazy people on the planet!", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn min_uncompleted_tasks(n: u32, k: u32, m: u32, a: Vec<u32>, b: Vec<u32>, c: Vec<u32>, d: Vec<u32>) -> (result: u32)\n    requires \n        n > 0,\n        n <= 100,\n        k <= 100,\n        m <= 100,\n        a.len() == n,\n        b.len() == n,\n        c.len() == k,\n        d.len() == m,\n        forall|i: int| 0 <= i < a.len() ==> a[i] >= 1 && a[i] <= 100000,\n        forall|i: int| 0 <= i < b.len() ==> b[i] >= 1 && b[i] <= 100000,\n        forall|i: int| 0 <= i < a.len() && 0 <= i < b.len() ==> b[i] <= a[i],\n        forall|i: int| 0 <= i < c.len() ==> c[i] >= 1 && c[i] <= 100000,\n        forall|i: int| 0 <= i < d.len() ==> d[i] >= 1 && d[i] <= 100000,\n    ensures\n        result >= 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let result1 = min_uncompleted_tasks(4, 2, 2, vec![5, 7, 6, 1], vec![3, 3, 1, 1], vec![6, 3], vec![1, 4]);\n    // println!(\"Result 1: {}\", result1); // Expected: 3\n    \n    // let result2 = min_uncompleted_tasks(2, 1, 1, vec![5, 3], vec![2, 1], vec![2], vec![1]);\n    // println!(\"Result 2: {}\", result2); // Expected: 2\n}"}
{"id": "fvapps_000745", "vc-description": "Chef has just found a recipe book, where every dish consists of exactly four ingredients.\nHe is going to choose some two dishes and prepare them for dinner.\nOf course, he likes diversity and wants to know whether the two dishes are similar.\nTwo dishes are called similar if at least half of their ingredients are the same.\nIn other words, at least two of four ingredients of the first dish should also be present in the second dish.\nThe order of ingredients doesn't matter.\nYour task is to examine T pairs of dishes.\nFor each pair, check if the two dishes are similar and print \"similar\" or \"dissimilar\" accordingly.\n\n-----Input-----\nThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\n\nThe first line of each test case contains four distinct strings, denoting ingredients needed for the first dish.\nEach ingredient is represented by a string of length between 2 and 10 inclusive, consisting of lowercase English letters.\n\nThe second line of each test case describes the second dish in the same format.\n\n-----Output-----\nFor each test case, output a single line containing the answer — \"similar\" if at least half of the ingredients are same, and \"dissimilar\" otherwise (without the quotes).\n\n-----Constraints-----\n- 1 ≤ T ≤ 200\n- The length of each string will be between 2 and 10 inclusive.\n\n-----Example-----\nInput:\n5\neggs sugar flour salt\nsugar eggs milk flour\naa ab ac ad\nac ad ae af\ncookies sugar grass lemon\nlemon meat chili wood\none two three four\none two three four\ngibberish jibberish lalalalala popopopopo\njibberisz gibberisz popopopopu lalalalalu\n\nOutput:\nsimilar\nsimilar\ndissimilar\nsimilar\ndissimilar\n\n-----Explanation-----\nTest case 1. The first dish consists of ingredients: eggs, sugar, flour, salt, while the second dish consists of: sugar, eggs, milk, flour. Three of four ingredients are present in both dishes (eggs, sugar, flour) so the two dishes are similar.\nTest case 2. This example shows that strings in the input don't necessarily represent real food.\nThe answer is again \"similar\", because two ingredients are present in both dishes (\"ac\" and \"ad\").\nTest case 3. The only common ingredient is lemon, so the answer is \"dissimilar\".\nRemember that at least two ingredients should be present in both dishes.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn count_common_ingredients(dish1: Seq<String>, dish2: Seq<String>) -> nat\n    decreases dish1.len()\n{\n    if dish1.len() == 0 {\n        0\n    } else {\n        let count_rest = count_common_ingredients(dish1.skip(1), dish2);\n        if dish2.contains(dish1[0]) {\n            count_rest + 1\n        } else {\n            count_rest\n        }\n    }\n}\n\nfn check_similar_dishes(dish1: Vec<String>, dish2: Vec<String>) -> (result: String)\n    requires \n        dish1.len() >= 4,\n        dish2.len() >= 4,\n    ensures \n        ({\n            let common_count = count_common_ingredients(dish1@, dish2@);\n            if common_count >= 2 { \n                result@ == \"similar\"@\n            } else { \n                result@ == \"dissimilar\"@\n            }\n        })", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: unguarded\n\n    /* Test cases would go here:\n    let test1_dish1 = vec![\"eggs\".to_string(), \"sugar\".to_string(), \"flour\".to_string(), \"salt\".to_string()];\n    let test1_dish2 = vec![\"sugar\".to_string(), \"eggs\".to_string(), \"milk\".to_string(), \"flour\".to_string()];\n    let result1 = check_similar_dishes(test1_dish1, test1_dish2);\n    assert_eq!(result1, \"similar\");\n\n    let test2_dish1 = vec![\"aa\".to_string(), \"ab\".to_string(), \"ac\".to_string(), \"ad\".to_string()];\n    let test2_dish2 = vec![\"ac\".to_string(), \"ad\".to_string(), \"ae\".to_string(), \"af\".to_string()];\n    let result2 = check_similar_dishes(test2_dish1, test2_dish2);\n    assert_eq!(result2, \"similar\");\n\n    let test3_dish1 = vec![\"cookies\".to_string(), \"sugar\".to_string(), \"grass\".to_string(), \"lemon\".to_string()];\n    let test3_dish2 = vec![\"lemon\".to_string(), \"meat\".to_string(), \"chili\".to_string(), \"wood\".to_string()];\n    let result3 = check_similar_dishes(test3_dish1, test3_dish2);\n    assert_eq!(result3, \"dissimilar\");\n    */\n}"}
{"id": "fvapps_000746", "vc-description": "Chef likes to travel a lot. Every day Chef tries to visit as much cities as possible. Recently he had a quite a few trips of great Chefland for learning various recipes. Chefland had N cities numbered from 1 to N. People in Chefland are very friendly, friendliness of i-th city is given by Fi.\n\nBefore starting of each trip, Chef's initial enjoyment is 1 unit. Whenever he visits a city with friendliness Fi, his enjoyment gets multiplied by Fi units. \n\nCity 1 is the home city of Chef. He starts each trip from his home city. Before starting a trip, he chooses a parameter R which denotes that he will start from city 1, and go to city 1 + R, then to 1 + 2 * R, then to 1 + 3 * R, till 1 + i * R such that i is largest integer satisfying 1 + i * R ≤ N.\n\nNow, Chef wants you to help him recreate his visit of the cities. Specifically, he will ask you Q queries, each of which can be of following two types.\n\n- 1 p f : friendliness of p-th city changes to f, i.e. Fp = f \n- 2 R   : Find out the total enjoyment Chef will have during this trip. As Chef does not like big numbers, he just asks you to output two things, first digit of the enjoyment and value of enjoyment modulo 10^9 + 7.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn count_type2_queries(queries: Seq<Vec<usize>>) -> nat\n    decreases queries.len()\n{\n    if queries.len() == 0 {\n        0\n    } else {\n        let first_query = queries[0];\n        let rest_count = count_type2_queries(queries.skip(1));\n        if first_query.len() >= 1 && first_query[0] == 2 {\n            rest_count + 1\n        } else {\n            rest_count\n        }\n    }\n}\n\nfn solve_chef_cities(n: usize, friendliness: Vec<usize>, queries: Vec<Vec<usize>>) -> (result: Vec<(usize, usize)>)\n    requires \n        0 < n && n <= 100000,\n        friendliness.len() == n,\n        forall|i: int| 0 <= i < friendliness.len() ==> 0 < friendliness[i] && friendliness[i] <= 1000000000,\n        forall|i: int| 0 <= i < queries.len() ==> (\n            (queries[i].len() == 3 && queries[i][0] == 1 && 1 <= queries[i][1] && queries[i][1] <= n && 1 <= queries[i][2] && queries[i][2] <= 1000000000) ||\n            (queries[i].len() == 2 && queries[i][0] == 2 && 1 <= queries[i][1] && queries[i][1] <= n)\n        ),\n    ensures\n        result.len() == count_type2_queries(queries@),\n        forall|i: int| 0 <= i < result.len() ==> (\n            1 <= result[i].0 && result[i].0 <= 9 && \n            result[i].1 < 1000000007\n        ),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000748", "vc-description": "Indian National Olympiad in Informatics 2012\nThe Republic of Tutaria is celebrating its 37th year of independence. To mark the occasion, the nation is organising a contest where all its N citizens take part. The event has three tracks, a COBOL programming competition, pole vault, and a doughnut-eating competition. Each citizen takes part in these three tracks in the same order—a citizen starts with the programming competition, continues with the pole vault as soon as his or her COBOL masterpiece is ready, and then starts gorging on doughnuts as soon as the pole vault is done.\nThe Supreme Leader of Tutaria closely monitors all citizens and knows the exact amount of time each citizen will take in each of the three tracks. She wants to schedule the event so that it will finish as early as possible. However, the Republic of Tutaria has only one computer, and, as a result, only one person can participate in the COBOL programming event at a time. However, any number of people may simultaneously participate in the pole vault and doughnut-eating competitions.\nThe event works as follows. The Supreme Leader fixes the order in which contestants get access to the computer. At time 0, the first citizen in the list starts writing his or her COBOL program, while the remaining citizens wait for the computer to be free. As soon as the first citizen is done, he or she proceeds to the pole vault, and the second citizen gets the computer for the programming round. In general whenever the computer becomes free, the next citizen gets to use it. Whenever a citizen is done using the computer, he or she proceeds to the pole vault immediately, regardless of what the other citizens are doing. Similarly, whenever a citizen is done with the pole vault, he or she proceeds to the doughnut- eating track immediately, independently of the others. The event ends as soon as all the citizens have finished all the three tracks of the event.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn sum(xs: Seq<nat>) -> nat \n    decreases xs.len()\n{\n    if xs.len() == 0 {\n        0\n    } else {\n        xs[0] + sum(xs.skip(1))\n    }\n}", "vc-spec": "fn find_min_event_time(n: nat, times: Vec<Vec<nat>>) -> (result: nat)\n    requires \n        n == times.len(),\n        forall|i: int| 0 <= i < times.len() ==> times[i].len() == 3,\n    ensures result >= 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "}\n\nfn main() {\n    // let result = find_min_event_time(3, vec![vec![18, 7, 6], vec![23, 10, 27], vec![20, 9, 14]]);\n    // println!(\"Result: {}\", result);\n}"}
{"id": "fvapps_000750", "vc-description": "Pushkar is very good in Number Theory. He takes two numbers A and B and declares them a Pushkar Pair. Pushkar Pair has a property that A has a Modular Inverse modulo B.  \nHe asks you to tell him the largest number L that divides both of them.  \n\n-----Input:-----\n- First line will contain T, number of testcases. Then the testcases follow. \n- Each testcase contains of a single line of input, two integers A, B. \n\n-----Output:-----\nFor each testcase, output in a single line the integer L.\n\n-----Constraints-----\n- 1 ≤ T ≤ 1000\n- 2 ≤ A,B ≤ 10^4\n\n-----Sample Input:-----\n1\n3 4\n\n-----Sample Output:-----\n1", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn find_gcd_pair(a: nat, b: nat) -> (result: nat)\n    requires a > 0 && b > 0,\n    ensures \n        result > 0,\n        a % result == 0,\n        b % result == 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "/* Apps difficulty: interview */\n/* Assurance level: guarded_and_plausible */\n\n}\n\nfn main() {\n    // println!(\"{}\", find_gcd_pair(3, 4));    // Should print 1\n    // println!(\"{}\", find_gcd_pair(12, 18));  // Should print 6  \n    // println!(\"{}\", find_gcd_pair(100, 25)); // Should print 25\n}"}
{"id": "fvapps_000753", "vc-description": "You are given a binary string S of N bits. The bits in the string are indexed starting from 1. S[i] denotes the ith bit of S.\n\nLet's say that a sequence i1, i2, …, iK(1 ≤ K; 1 ≤ i1 < i2 < … < iK ≤ N) produces a palindrome when applied to S, if the string S[i1] S[i2] … S[ik] is a palindrome (that is, reads the same backward or forward).\n\nIn addition, a sequence i1, i2, …, iK(1 ≤ K; 1 ≤ i1 < i2 < … < iK ≤ N) is said to be exponential, if ij + 1 = p * ij for each integer 1 ≤ j < K and for some integer p > 1. Note, that a sequence of one element is always exponential.\n\nYour task is to count the number of exponential sequences that produce a palindrome when applied to S.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn count_exponential_palindromes(s: Vec<char>) -> (result: usize)\n    ensures \n        s.len() > 0 ==> result >= 1,\n        s.len() > 0 ==> result >= s.len(),\n        s.len() == 0 ==> result == 0,\n        s.len() == 1 ==> result == 1", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "}\n\nfn main() {\n    // let s1 = vec!['1', '1', '0', '1', '0'];\n    // let result1 = count_exponential_palindromes(s1);\n    // println!(\"{}\", result1); // Expected: 9\n    \n    // let s2 = vec!['1', '0', '1', '0', '0', '1', '0', '1', '1'];\n    // let result2 = count_exponential_palindromes(s2);\n    // println!(\"{}\", result2); // Expected: 18\n    \n    // let s3 = vec!['1', '1', '0'];\n    // let result3 = count_exponential_palindromes(s3);\n    // println!(\"{}\", result3); // Expected: 4\n}"}
{"id": "fvapps_000754", "vc-description": "A permutation of length n is an array of size n consisting of n distinct integers in the range [1, n]. For example, (3, 2, 4, 1) is a permutation of length 4, but (3, 3, 1, 4) and (2, 3, 4, 5) are not, as (3, 3, 1, 4) contains duplicate elements, and (2, 3, 4, 5) contains elements not in range [1,4].\nA permutation p of length n is good if and only if for any 1 ≤ i ≤ n, pi ≠ i.\nPlease find the lexicographically smallest good permutation p.\nDefinition for \"lexicographically smaller\":\nFor two permutations p and q, we say that p is lexicographically smaller than q if and only if there exists a index 1 ≤ l ≤ n such that:\n- For any 1 ≤ i < l, pi = qi. Note that if l = 1, this constraint means nothing.\n- and, pl < ql.\n\nFor example, (2, 3, 1, 4) < (2, 3, 4, 1) < (3, 4, 1, 2). The lexicographically smallest permutation is, of course, (1, 2, ..., n), though this one is not good.\n\n-----Input-----\nFirst line of the input contains an integer T denoting number of test cases.\nFor each test case, the only line contains an integer n.\n\n-----Output-----\nFor each test case, output the lexicographically smallest good permutation of length n. It's guaranteed that this permutation exists.\n\n-----Constraints-----\n- 1 ≤ T ≤ 10\n- 2 ≤ n ≤ 105\n\n-----Subtasks-----\n- Subtask #1 (17 points): 2 ≤ n ≤ 9\n- Subtask #2 (83 points): Original Constraints\n\n-----Example-----\nInput:\n4\n2\n3\n5\n6\n\nOutput:\n2 1\n2 3 1\n2 1 4 5 3\n2 1 4 3 6 5\n\n-----Explanation-----\nExample case 1. The only good permutation of length 2 is (2, 1).\nExample case 2. Consider all permutations of length 3, they are(in lexicographically order):\n- p = (1, 2, 3), it's not good since p[1] = 1, p[2] = 2 and p[3] = 3;\n- p = (1, 3, 2), it's not good since p[1] = 1;\n- p = (2, 1, 3), it's not good since p[3] = 3;\n- p = (2, 3, 1), it's good since p[1] ≠ 1, p[2] ≠ 2 and p[3] ≠ 3;\n- p = (3, 1, 2), it's good since p[1] ≠ 1, p[2] ≠ 2 and p[3] ≠ 3;\n- p = (3, 2, 1), it's not good since p[2] = 2.\nThus the minimum good one is (2, 3, 1).\nExample case 3. Consider two good permutations for third test case: p=(2, 1, 4, 5, 3) and q=(2, 4, 1, 5, 3), then p < q. You can check lexicographically condition as follows. Find the first index where the entries of two permutations are different, and compare those entries. For example, in this case, the first position where the entries differ is index 2. You can see that p[2] < q[2], as 1 < 4, so p is lexicographically smaller than q.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn find_smallest_good_perm(n: nat) -> (result: String)\n    requires n >= 1", "vc-code": "{\n    // impl-start\n    assume(false);\n    \"\".to_string()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // println!(\"{}\", find_smallest_good_perm(2));\n    // println!(\"{}\", find_smallest_good_perm(3));\n    // println!(\"{}\", find_smallest_good_perm(5));\n    // println!(\"{}\", find_smallest_good_perm(6));\n}"}
{"id": "fvapps_000755", "vc-description": "Nobody knows, but N frogs live in Chef's garden.\nNow they are siting on the X-axis and want to speak to each other. One frog can send a message to another one if the distance between them is less or equal to K.\nChef knows all P pairs of frogs, which want to send messages. Help him to define can they or not!\nNote : More than 1 frog can be on the same point on the X-axis.\n\n-----Input-----\n- The first line contains three integers N, K and P.\n- The second line contains N space-separated integers A_1, A_2, …, A_N denoting the x-coordinates of frogs\".\n- Each of the next P lines contains two integers A and B denoting the numbers of frogs according to the input.\n\n-----Output-----\nFor each pair print \"Yes\" without a brackets if frogs can speak and \"No\" if they cannot.\n\n-----Constraints-----\n- 1 ≤ N, P ≤ 10^5\n- 0 ≤ A_i, K ≤ 10^9\n- 1 ≤ A, B ≤ N\n\n-----Example-----\n\n-----Sample Input:-----\n5 3 3\n0 3 8 5 12\n1 2\n1 3\n2 5\n\n-----Sample Output:-----\nYes\nYes\nNo\n\n-----Explanation-----\n- \nFor pair (1, 2) frog 1 can directly speak to the frog 2 as the distance between them is 3 - 0 = 3 ≤ K . \n- \nFor pair (1, 3) frog 1 can send a message to frog 2, frog 2 can send it to frog 4 and it can send it to frog 3.\n- \nFor pair (2, 5) frogs can't send a message under current constraints.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn absolute_value(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\nspec fn is_valid_result(s: String) -> bool {\n    s@ =~= \"Yes\"@ || s@ =~= \"No\"@\n}\n\nfn can_frogs_communicate(n: usize, k: int, coords: Vec<int>, pairs: Vec<(usize, usize)>) -> (result: Vec<String>)\n    requires \n        n >= 2,\n        coords.len() == n,\n        pairs.len() > 0,\n        forall|i: int| 0 <= i < pairs.len() ==> pairs[i].0 >= 1 && pairs[i].0 <= n && pairs[i].1 >= 1 && pairs[i].1 <= n,\n    ensures\n        result.len() == pairs.len(),\n        forall|i: int| 0 <= i < result.len() ==> is_valid_result(result[i]),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000756", "vc-description": "After six days, professor GukiZ decided to give more candies to his students. Like last time, he has N students, numbered 1 through N. Let's denote the number of candies GukiZ gave to the i-th student by p_i. As GukiZ has a lot of students, he does not remember all the exact numbers of candies he gave to the students. He only remembers the following properties of the sequence p:\n- The numbers of candies given to each of the first K students (p_1, p_2, ..., p_K) are known exactly.\n- All elements of the sequence p are distinct and positive.\n- GukiZ didn't give more than x candies to any student (the maximum value in the sequence p is not greater than x).\n- For each student i, there is at least one other student j such that |p_i - p_j| <= D.\n- The professor gave out the biggest possible total number of candies, i.e. S = p_1 + p_2 + p_3 + ... + p_N is maximum possible.\nGukiZ would like to know the total number of candies S he had at the beginning. However, times change and after six days, the professor is really tired, so it is possible that there is no sequence p which satisfies the constraints. Can you help GukiZ find the number of candies he gave out, or tell him that he must have made a mistake?", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_candies(n: u32, k: u32, x: u32, d: u32, given_candies: Vec<u32>) -> (result: i32)\n    requires \n        given_candies.len() == k,\n        k >= 1,\n        n >= 3,\n        forall|i: int| 0 <= i < given_candies.len() ==> given_candies[i] >= 1 && given_candies[i] <= x,\n        forall|i: int, j: int| 0 <= i < j < given_candies.len() ==> given_candies[i] != given_candies[j],\n    ensures\n        result == -1 || (\n            result >= 0 &&\n            forall|i: int| 0 <= i < given_candies.len() ==> result >= given_candies[i] &&\n            n >= k &&\n            x >= n\n        )", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let test1 = solve_candies(4, 3, 5, 3, vec![2, 1, 5]);\n    // assert(test1 == 12);\n    // let test2 = solve_candies(3, 2, 8, 2, vec![3, 8]);\n    // assert(test2 == -1);\n}"}
{"id": "fvapps_000758", "vc-description": "Pankaj likes to eat Ice cream when he is working late into the night. Today has been yet another long day for Pankaj. So, he wants to eat ice cream now. He opens the fridge and sees that he has 2 types of containers holding the ice cream.\nThe first container is a cone with radius r1 and height h1. There is also a hemisphere on the top of the cone which has the same radius. The other container is a cylindrical with radius r2 and height h2. Pankaj wants to know the amount (volume) of ice cream in both the containers. Since Pankaj is tired after coding all day, you have to help him with this task.\n\n-----Input-----\n- The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\n- Each test case consists of a single line having the r1, h1, r2 and h2. Each value is given upto 2 decimal places. See example for more information.\n\n-----Output-----\n- For each test case, output a single line containing the volumes of the two containers separated by space. The answer is considered correct if it is correct upto 6 decimal places.\n\n-----Constraints-----\n- 1 ≤ T ≤ 100\n- 0 <  r1, h1, r2, h2 ≤ 100\n\n-----Example-----\nInput:\n2\n1.00 1.00 1.00 1.00\n3.02 7.23 5.20 6.00\n\nOutput:\n3.141592654 3.141592654\n126.739919445 509.691992118", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn calculate_ice_cream_volumes(r1: f64, h1: f64, r2: f64, h2: f64) -> (f64, f64)", "vc-code": "{\n    // impl-start\n    assume(false);\n    (0.0, 0.0)\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000759", "vc-description": "Given an Integer N, write a program to reverse it.\n\n-----Input-----\n\nThe first line contains an integer T, total number of testcases. Then follow T lines, each line contains an integer N. \n\n-----Output-----\nFor each test case, display the reverse of the given number N, in a new line.\n\n-----Constraints-----\n- 1 ≤ T ≤ 1000\n- 1 ≤ N ≤ 1000000\n\n-----Example-----\nInput\n4\n12345\n31203\n2123\n2300\nOutput\n54321\n30213\n3212\n32", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn reverse_numbers(nums: Vec<String>) -> (result: Vec<i32>)\n    ensures result.len() == nums.len()\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n\nfn is_palindrome(s: String) -> (result: bool)\n{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-code": "", "vc-postamble": "\n}\n\nfn main() {\n    // let test_cases = vec![\"12345\".to_string(), \"31203\".to_string(), \"2123\".to_string(), \"2300\".to_string()];\n    // let result = reverse_numbers(test_cases);\n    // println!(\"{:?}\", result); // Should output [54321, 30213, 3212, 32]\n    \n    // let test_cases2 = vec![\"100\".to_string(), \"200\".to_string(), \"300\".to_string()];\n    // let result2 = reverse_numbers(test_cases2);\n    // println!(\"{:?}\", result2); // Should output [1, 2, 3]\n    \n    // let test_cases3 = vec![\"1234\".to_string()];\n    // let result3 = reverse_numbers(test_cases3);\n    // println!(\"{:?}\", result3); // Should output [4321]\n}"}
{"id": "fvapps_000760", "vc-description": "Tanish is the president of the chemistry club at his school. He considers everyone who doesn't like chemistry as his enemy. After years of research, he has invented a lethal poison, which he named success. Now Tanish plans to kill all his enemies with his success. Success is extremely deadly and is untraceable in small concentrations.\nTanish has N flasks lying on the shelf of his lab. All of these flasks contain the same volume of poison solution. The concentration of poison in the ith flask is a_i. In one move - Tanish picks up any two flasks, pours half of the contents of each of these flasks into a third initially empty flask, discards the two flasks and places the third flask (which now has the same volume of solution as all other flasks) on the shelf. He performs N-1 such moves to end up with only one flask of poison on the shelf. He wishes to perform these moves such that the concentration of poison in this flask is the minimum possible. What is the minimum concentration of poison that he can achieve?", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn minimum(l: Seq<nat>) -> nat \n    decreases l.len()\n{\n    if l.len() == 0 {\n        0\n    } else if l.len() == 1 {\n        l[0]\n    } else {\n        if l[0] <= minimum(l.skip(1)) {\n            l[0]\n        } else {\n            minimum(l.skip(1))\n        }\n    }\n}\n\nspec fn maximum(l: Seq<nat>) -> nat \n    decreases l.len()\n{\n    if l.len() == 0 {\n        0\n    } else if l.len() == 1 {\n        l[0]\n    } else {\n        if l[0] >= maximum(l.skip(1)) {\n            l[0]\n        } else {\n            maximum(l.skip(1))\n        }\n    }\n}", "vc-spec": "fn min_poison_concentration(n: nat, concentrations: Vec<nat>) -> (result: nat)\n    requires \n        1 <= n,\n        n <= concentrations.len(),\n        concentrations.len() > 0,\n    ensures\n        result >= minimum(concentrations@),\n        result <= maximum(concentrations@),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000761", "vc-description": "Ring Ring!!  \nSherlock's phone suddenly started ringing. And it was none other than Jim Moriarty..\n\"Long time no see ! You miss me right ? Anyway we'll talk about it later . Let me first tell you something. Dr.Watson is with me . And you've got only one chance to save him . Here's your challenge:.\nGiven a number N and another number M, tell if the remainder of N%M is odd or even. If it's odd, then print \"ODD\" else print \"EVEN\" \n\nIf Sherlock can answer the query correctly, then Watson will be set free. He has approached you for help since you being a programmer.Can you help him? \n\n-----Input-----\nThe first line contains, T, the number of test cases..\nEach test case contains an integer, N and M\n\n-----Output-----\nOutput the minimum value for each test case \n\n-----Constraints-----\n1 = T = 20\n1 <= N <= 10^18 \n1 <= M<= 10^9 \n\n-----Subtasks-----\nSubtask #1 : (20 points)\n1 = T = 20\n1 <= N <= 100 \n1 <= M<= 100 \n\nSubtask 2 : (80 points) \n\n1 = T = 20\n1 <= N <= 10^18 \n1 <= M<= 10^9 \n\n-----Example-----\nInput:\n2\n4 4\n6 5\n\nOutput:\nEVEN\nODD", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn check_remainder_parity(n: i64, m: i64) -> (result: &'static str)\n    requires m != 0,\n    ensures \n        result == \"ODD\" || result == \"EVEN\",\n        (result == \"EVEN\" && (n % m) % 2 == 0) || (result == \"ODD\" && (n % m) % 2 == 1)", "vc-code": "{\n    // impl-start\n    assume(false);\n    \"EVEN\"\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = check_remainder_parity(4, 4);\n    // println!(\"{}\", result1); // Should print \"EVEN\"\n    \n    // let result2 = check_remainder_parity(6, 5);\n    // println!(\"{}\", result2); // Should print \"ODD\"\n    \n    // let result3 = check_remainder_parity(10, 3);\n    // println!(\"{}\", result3); // Should print \"ODD\"\n}"}
{"id": "fvapps_000762", "vc-description": "Xorgon is an extremely delicious treat formed by the sequence S of binary integers s_1, s_2,..,s_N. A really interesting property found in a Xorgon is that the xor of all elements in any contiguous subsequence of length K in S will result in 1.   \nChef has been asked to prepare a Xorgon. However, he has at his disposal a binary sequence X containing the binary integers x_1, x_2, ...x_N. To prepare a Xorgon, the chef may flip the value of as many binary digits in X as required.(i.e. turn a 1 to a 0 and 0 to a 1). Unfortunately, flipping a digit takes a lot of time and the chef has to serve many orders. Can you help the chef calculate the minimum number of flips required to cook a Xorgon from the given X?\n\nInput:\n- The first line will contain two space-separated integers N, K.\n- Next line contains N space-separated integers x_1, x_2, ...,x_N. \n\nOutput:\nOutput in a single line minimum number of flips required to turn X into a Xorgon.\n\nConstraints:\n- 1 ≤ K ≤ N ≤ 3*10^6\n- 0 ≤ x_i ≤ 1\n\nSample Input:\n7 5\n1 0 0 1 1 1 1\n\nSample Output:\n1\n\nEXPLANATION:\nFlip the last bit from 1 to 0 to obtain a Xorgon.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_xorgon(n: usize, k: usize, arr: Vec<usize>) -> (result: usize)\n    requires \n        arr.len() > 0,\n        k > 0,\n        n == arr.len(),\n        forall|i: int| 0 <= i < arr.len() ==> (arr[i] == 0 || arr[i] == 1),\n    ensures \n        result >= 0,\n        result <= arr.len(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = solve_xorgon(7, 5, vec![1, 0, 0, 1, 1, 1, 1]);\n    // println!(\"{}\", result1); // Should output 1\n    \n    // let result2 = solve_xorgon(4, 3, vec![1, 1, 0, 0]);\n    // println!(\"{}\", result2); // Should output 1\n    \n    // let result3 = solve_xorgon(3, 3, vec![0, 0, 0]);\n    // println!(\"{}\", result3); // Should output 1\n}"}
{"id": "fvapps_000763", "vc-description": "Naman owns a very famous Ice Cream parlour in Pune. He has a wide range of flavours with different pricing. \n\nEvery flavour costs ₹ X per gram and quantity of each flavour in the parlour is indefinite. Now, Naman has \n\nreceived an order for a party wherein he is asked to prepare each Ice Cream with N number of flavours. \n\nHe needs to prepare each Ice Cream of W grams and at the same time has to keep the cost minimum. \n\nCan you help him out?\n\nNote: If it is not possible to prepare such an Ice Cream, print \"Not Possible\".\n\n-----Input:-----\n\nFirst line contains an integer T denoting the number of test cases.\n\nFirst line of every test case contains an integer N denoting the number of flavours.\n\nThe second line of every test case by N space separated integers denoting the cost per gram of each flavour. \n\nSecond line of every test case contains two space separated integers W and Y denoting the weight \n\nof Ice Cream in grams and the number of flavours to be used respectively. \n\n-----Output:-----\n\nFor each test case, print the total cost of the Ice Cream in a single line.\n\n-----Constraints:-----\n1 ≤ T ≤ 100\n1 ≤ N,W,Y ≤ 40000\n\n-----Example:-----Input:\n2\n5 \n4 6 8 1 10\n10 3\n2\n1 2\n1 2Output:\n\n18\n\nNot Possible\n\n-----Explanation:-----\n\nIn the first test case to achieve the minimum cost, the Ice Cream will consist of 8 grams \n\nof flavour costing ₹1, 1 gram of flavour costing ₹4 and 1 gram of flavour costing ₹6.\n\nIn the second test case it is not possible to make an ice-cream weighing 1 gram using 2 flavours.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_ice_cream(num_flavors: nat, costs: &Vec<nat>, weight: nat, num_required: nat) -> (result: Option<nat>)\n    requires \n        num_flavors > 0,\n        forall|i: int| 0 <= i < costs.len() ==> costs[i] > 0,\n        weight > 0,\n        num_required > 0,\n    ensures\n        match result {\n            Option::None => weight < num_required || num_flavors < num_required,\n            Option::Some(cost) => cost >= 0 && weight >= num_required && num_flavors >= num_required\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    Option::None\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000764", "vc-description": "Spring is interesting season of year. Chef is thinking about different things, but last time he thinks about interesting game - \"Strange Matrix\". \nChef has a matrix that consists of n rows, each contains m elements. Initially, the element aij of matrix equals j. (1 ≤ i ≤ n, 1 ≤ j ≤ m). \nThen p times some element aij is increased by 1. \nThen Chef needs to calculate the following: \n\n- For each row he tries to move from the last element (with number m) to the first one (with the number 1). \n- While staying in aij Chef can only move to aij - 1 only if aij - 1 ≤ aij. \n- The cost of such a movement is aij - aij - 1.\n- Otherwise Chef can't move and lose (in this row).\n- If Chef can move from the last element of the row to the first one, then the answer is the total cost of all the movements. \n- If Chef can't move from the last element of the row to the first one, then the answer is -1. \n\nHelp Chef to find answers for all the rows after P commands of increasing. \n\n-----Input-----\n\n- The first line contains three integers n, m and p denoting the number of rows, the number of elements a single row and the number of increasing commands. \n- Each of next p lines contains two integers i and j denoting that the element aij  is increased by one. \n\n-----Output-----\n- For each row in a single line print the answer after the P increasing commands.\n\n-----Constraints-----\n- 1 ≤ n, m, p ≤ 10 ^ 5\n- 1 ≤ i ≤ n\n- 1 ≤ j ≤ m\n\n-----Example-----\nInput:\n4 4 6\n2 2\n3 2 \n3 2 \n4 3\n4 4\n4 3\n\nOutput:\n3\n3\n-1\n4\n\n-----Explanation-----\n\nHere is the whole matrix after P commands:\n1 2 3 4\n1 3 3 4\n1 4 3 4\n1 2 5 5\n\nExplanations to the answer: \n- The first line is without changes: 4-3=1, 3-2=1, 2-1=1. answer = 3. \n- The second line: 4-3=1, 3-3=0, 3-1=2. The answer is 3. \n- The third line: 4-3=1, 3-4=-1, Chef can't move to the first number here. Therefore, the answer is -1. \n- The fourth line: 5-5=0, 5-2=3, 2-1=1. The answer is 4.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "type Command = (usize, usize);\n\nspec fn valid_commands(n: usize, m: usize, cmds: Seq<Command>) -> bool {\n    forall|i: int| 0 <= i < cmds.len() ==> \n        cmds[i].0 <= n && cmds[i].1 <= m && cmds[i].0 > 0 && cmds[i].1 > 0\n}", "vc-spec": "fn solve_strange_matrix(n: usize, m: usize, k: usize, cmds: Vec<Command>) -> (result: Vec<i32>)\n    requires \n        n > 0,\n        m > 0,\n        valid_commands(n, m, cmds@),\n    ensures \n        result.len() == n,\n        forall|i: int| 0 <= i < result.len() ==> (result[i] >= -1),\n        /* Single column case: all entries are 0 */\n        m == 1 ==> forall|i: int| 0 <= i < result.len() ==> result[i] == 0,\n        /* Single row case: result has length 1 and value m-1 when no commands */\n        n == 1 && cmds.len() == 0 ==> result.len() == 1 && result[0] == (m - 1) as i32", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000765", "vc-description": "One of Chef's friends offered him a deal: during D days, they are going to exchange money. For each i (1 ≤ i ≤ D), on the i-th day, Chef's friend would give Chef A rupees, while Chef would give his friend 2^(i-1) rupees (1 rupee on day 1, 2 rupees on day 2, 4 rupees on day 3, and so on). Chef's profit from the deal is the total number of rupees he received from his friend minus the total number of rupees he gave his friend.\nChef decided to ask for your advice before accepting the deal. You want to help him by telling him two numbers D1 and D2, where D1 is the maximum value of D such that Chef should accept the deal, i.e. his profit from the deal is positive if D = D1, and D2 is the value of D that leads to the maximum possible profit for Chef. If there are multiple values of D that lead to the maximum profit, D2 is the smallest of these values.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn profit(a: nat, d: nat) -> int {\n    (a * d) as int + 1 - pow2(d) as int\n}\n\nspec fn pow2(n: nat) -> nat \n    decreases n\n{\n    if n == 0 {\n        1\n    } else {\n        2 * pow2((n - 1) as nat)\n    }\n}\n\nfn solve_max_profit_days(a: u32) -> (result: (u32, u32))\n    requires a >= 2,\n    ensures \n        result.0 >= result.1,\n        result.0 >= 0,\n        result.1 >= 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    (0, 0)\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let test_cases = vec![5, 8, 9, 1000000000];\n    // for a in test_cases {\n    //     let (d1, d2) = solve_max_profit_days(a);\n    //     println!(\"{} {}\", d1, d2);\n    // }\n}"}
{"id": "fvapps_000767", "vc-description": "Limak is a little polar bear.\nHe is playing a video game and he needs your help.\nThere is a row with N cells, each either empty or occupied by a soldier, denoted by '0' and '1' respectively.\nThe goal of the game is to move all soldiers to the right (they should occupy some number of rightmost cells).\nThe only possible command is choosing a soldier and telling him to move to the right as far as possible.\nChoosing a soldier takes 1 second, and a soldier moves with the speed of a cell per second.\nThe soldier stops immediately if he is in the last cell of the row or the next cell is already occupied.\nLimak isn't allowed to choose a soldier that can't move at all (the chosen soldier must move at least one cell to the right).\nLimak enjoys this game very much and wants to play as long as possible.\nIn particular, he doesn't start a new command while the previously chosen soldier moves.\nCan you tell him, how many seconds he can play at most?", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_all_zeros(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nspec fn is_all_ones(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> s[i] == '1'\n}\n\nspec fn count_ones(s: Seq<char>) -> int \n    decreases s.len()\n{\n    if s.len() == 0 {\n        0int\n    } else {\n        (if s[0] == '1' { 1int } else { 0int }) + count_ones(s.skip(1))\n    }\n}\n\nfn solve_moving_soldiers(s: Vec<char>) -> (result: usize)\n    ensures \n        s.len() == 0 ==> result == 0,\n        is_all_zeros(s@) ==> result == 0,\n        is_all_ones(s@) ==> result == 0,\n        count_ones(s@) == 0 ==> result == 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "}\n\nfn main() {\n    // Test cases\n    // let test1: Vec<char> = \"10100\".chars().collect();\n    // println!(\"{}\", solve_moving_soldiers(test1)); // Expected: 8\n    // let test2: Vec<char> = \"1100001\".chars().collect();\n    // println!(\"{}\", solve_moving_soldiers(test2)); // Expected: 10  \n    // let test3: Vec<char> = \"000000000111\".chars().collect();\n    // println!(\"{}\", solve_moving_soldiers(test3)); // Expected: 0\n}"}
{"id": "fvapps_000768", "vc-description": "If Give an integer N . Write a program to obtain the sum of the first and last digits of this number.\n\n-----Input-----\n\nThe first line contains an integer T, the total number of test cases. Then follow T lines, each line contains an integer N. \n\n-----Output-----\nFor each test case, display the sum of first and last digits of N in a new line.\n\n-----Constraints-----\n- 1 ≤ T ≤ 1000\n- 1 ≤ N ≤ 1000000\n\n-----Example-----\nInput\n3 \n1234\n124894\n242323\n\nOutput\n5\n5\n5", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn sum_first_last_digit(n: nat) -> (result: nat)\n    requires n > 0,\n    ensures \n        result >= 0 && result <= 18,\n        n <= 9 ==> result == n + n", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded\n\n    // println!(\"{}\", sum_first_last_digit(1234));\n    // println!(\"{}\", sum_first_last_digit(124894));\n    // println!(\"{}\", sum_first_last_digit(242323));\n}"}
{"id": "fvapps_000769", "vc-description": "Rani is teaching Raju maths via a game called N-Cube, which involves three sections involving N.\n\nRani gives Raju a number N, and Raju makes a list of Nth powers of integers in increasing order (1^N, 2^N, 3^N.. so on). This teaches him exponentiation. \nThen Raju performs the following subtraction game N times : Take all pairs of consecutive numbers in the list and take their difference. These differences then form the new list for the next iteration of the game. Eg, if N was 6, the list proceeds as [1, 64, 729, 4096 ... ] to [63, 685, 3367 ...], and so on 5 more times.\nAfter the subtraction game, Raju has to correctly tell Rani the Nth element of the list. This number is the value of the game. \nAfter practice Raju became an expert in the game. To challenge him more, Rani will give two numbers M (where M is a prime) and R instead of just a single number N, and the game must start from M^(R - 1) instead of N. Since the value of the game can now become large, Raju just have to tell the largest integer K such that M^K divides this number. Since even K can be large, output K modulo 1000000007 (109+7).\n\n-----Input-----\n\nFirst line will contain T, number of testcases. Then the testcases follow\nEach testcase contains of a single line of input, two integers M R\n\n-----Output-----\n\nFor each testcase, output in a single line answer given by Raju to Rani modulo 1000000007.\n\n-----Constraints-----\n\n1<=T<=1000\n\n2<=M<=109\n\n30 points : 1<=R<=10000\n\n70 points : 1<=R<=109\n\nM is a prime number\n\n-----Example-----\nInput:\n\n1\n\n2 2\n\nOutput:\n\n1", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_n_cube(m: nat, r: nat) -> (result: nat)\n    requires m >= 2 && r >= 1\n    ensures \n        result < 1000000007,\n        (m >= 2 && m <= 5 && r == 2) ==> result == 1", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000770", "vc-description": "Bob has n heap(s) of gravel (initially there are exactly c piece(s) in each). He wants to do m operation(s) with that heaps, each maybe:\n\n- adding pieces of gravel onto the heaps from u to v, exactly k pieces for each,\n- or querying \"how many pieces of gravel are there in the heap p now?\".\n\n-----Request-----\nHelp Bob do operations of the second type.\n\n-----Input-----\n\n- The first line contains the integers n,m,c, respectively.\n- m following lines, each forms:\n\n- S u v k to describe an operation of the first type.\n- Q p to describe an operation of the second type.\n(Each integer on a same line, or between the characters S, Q and the integers is separated by at least one space character)\n\n-----Output-----\nFor each operation of the second type, output (on a single line) an integer answering to the respective query (follows the respective Input order).\n\n-----Example-----Input:\n7 5 0\nQ 7\nS 1 7 1\nQ 3\nS 1 3 1\nQ 3\nOutput:\n0\n1\n2\n\n-----Limitations-----\n- 0<n≤106\n- 0<m≤250 000\n- 0<u≤v≤n\n- 0≤c,k≤109\n- 0<p≤n", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn starts_with_q(s: Seq<char>) -> bool {\n    s.len() > 0 && s[0] == 'Q'\n}\n\nspec fn count_query_ops(ops: Seq<Seq<char>>) -> nat\n    decreases ops.len()\n{\n    if ops.len() == 0 {\n        0\n    } else {\n        let rest_count = count_query_ops(ops.skip(1));\n        if starts_with_q(ops[0]) {\n            rest_count + 1\n        } else {\n            rest_count\n        }\n    }\n}\n\nfn fenwick_operations(n: u32, m: u32, c: i64, ops: Vec<String>) -> (results: Vec<i64>)\n    requires \n        n > 0,\n        m >= 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let test_result = fenwick_operations(7, 5, 0, vec![\"Q 7\".to_string(), \"S 1 7 1\".to_string(), \"Q 3\".to_string(), \"S 1 3 1\".to_string(), \"Q 3\".to_string()]);\n    // println!(\"{:?}\", test_result);\n}"}
{"id": "fvapps_000773", "vc-description": "As lockdown is going on so no is allowed to go outside , so Chef has come with an innovative idea for food home delivery using drone.  But there is an issue with it , the drone can move forward or backward a fix number of steps $x$ . \nAll the houses and chef restaurant are all in a straight line . Homes which need delivery are located at $H[i]$ and chef is located at $y$ coordinate . \nIf Drone is at a location $R$, then it can move to $R-x$ or $R+x$ . \nHelp chef find maximum value of $x$ to complete all the deliveries as he is busy managing the orders.\n\n-----Input:-----\n- First line will contain $n$ and $R$, number of houses that need delivery and the correct coordinate of chef (Drone).\n- Second line contains $n$ integers , the coordinate of all homes that need delivery. \n\n-----Output:-----\n- The maximum value of $x$ , so that drone delivers to all houses.\n\n-----Constraints-----\n- $1 \\leq n \\leq 1000$\n- $1 \\leq R \\leq 10^9$\n- $1 \\leq hi \\leq 10^9$\n- $1 \\leq x  \\leq 10^9$\n\n-----Sample Input:-----\n3 1\n3 5 11\n\n-----Sample Output:-----\n2\n\n-----EXPLANATION:-----\nChef's drone is at 1 initially and he needs to visit 3,5,11 , so optimal solution will be (maximum value of x ) equal to 2.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn abs_diff(a: i32, b: i32) -> int {\n    if a >= b { (a - b) as int } else { (b - a) as int }\n}", "vc-spec": "fn max_drone_step(n: usize, r: i32, h: Vec<i32>) -> (result: usize)\n    requires \n        n > 0,\n        h.len() == n,\n    ensures \n        result > 0,\n        forall|i: int| 0 <= i < h.len() ==> #[trigger] abs_diff(h[i], r) % (result as int) == 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = max_drone_step(3, 1, vec![3, 5, 11]);\n    // println!(\"Result 1: {}\", result1);\n    \n    // let result2 = max_drone_step(2, 4, vec![2, 8]);\n    // println!(\"Result 2: {}\", result2);\n    \n    // let result3 = max_drone_step(4, 5, vec![1, 3, 7, 9]);\n    // println!(\"Result 3: {}\", result3);\n}"}
{"id": "fvapps_000774", "vc-description": "One day, Tanya was studying graph theory. She is very inquisitive, so the following problem soon came to her mind.\nFind the number of undirected unweighted connected simple graphs with $N$ vertices (numbered $1$ through $N$) and $M$ edges, such that for each $i$ ($2 \\le i \\le N$), the shortest path from vertex $1$ to vertex $i$ is unique and its length is equal to $A_i$. In other words, for each $i$ ($2 \\le i \\le N$), there should be exactly one path with length $A_i$ between vertices $1$ and $i$, and there should be no paths with smaller length between these vertices.\nTwo graphs with $N$ vertices are distinct if we can find two vertices $u$ and $v$ such that there is an edge between these vertices in one graph, but not in the other graph.\nSince the answer could be very large, compute it modulo $1,000,000,007$ ($10^9 + 7$).\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains two space-separated integers $N$ and $M$.\n- The second line contains $N - 1$ space-separated integers $A_2, A_3, \\ldots, A_N$.\n\n-----Output-----\nFor each test case, print a single line containing one integer ― the number of graphs modulo $10^9 + 7$.\n\n-----Constraints-----\n- $1 \\le T \\le 1,000$\n- $2 \\le N \\le 10^5$\n- $N-1 \\le M \\le \\mathrm{min}\\left(2\\cdot 10^5, \\frac{N(N-1)}{2}\\right)$\n- $1 \\le A_i \\le N-1$ for each valid $i$\n- the sum of $N$ over all test cases does not exceed $2 \\cdot 10^5$\n- the sum of $M$ over all test cases does not exceed $2 \\cdot 10^5$\n\n-----Subtasks-----\nSubtask #1 (50 points): $M = N-1$\nSubtask #2 (50 points): original constraints\n\n-----Example Input-----\n3\n4 3\n1 2 1\n4 6\n1 2 1\n3 2\n2 2\n\n-----Example Output-----\n2\n0\n0\n\n-----Explanation-----\nExample case 1: The two graphs which satisfy all conditions are:", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn count_graphs(n: usize, m: usize, distances: Vec<usize>) -> (result: usize)\n    requires \n        n >= 2,\n        distances.len() == n - 1,\n        forall|i: int| 0 <= i < distances.len() ==> #[trigger] distances[i] >= 1 && distances[i] <= n - 1,\n    ensures \n        result <= 1000000007,\n        (n >= 3 && forall|i: int| 0 <= i < distances.len() ==> #[trigger] distances[i] == 1 && m == n - 1) ==> result == 1,\n        (n >= 3 && exists|i: int| 0 <= i < distances.len() && #[trigger] distances[i] == n) ==> result == 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = count_graphs(4, 3, vec![1, 2, 1]);\n    // println!(\"{}\", result1);\n    // let result2 = count_graphs(4, 6, vec![1, 2, 1]);\n    // println!(\"{}\", result2);\n    // let result3 = count_graphs(3, 2, vec![2, 2]);\n    // println!(\"{}\", result3);\n}"}
{"id": "fvapps_000775", "vc-description": "In a cricket game, an over is a set of six valid deliveries of balls performed by one player ― the bowler for this over.\nConsider a cricket game with a series of $N$ overs (numbered $1$ through $N$) played by $K$ players (numbered $1$ through $K$). Each player may be the bowler for at most $L$ overs in total, but the same player may not be the bowler for any two consecutive overs. Assign exactly one bowler to each over in such a way that these rules are satisfied or determine that no such assignment exists.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first and only line of each test case contains three space-separated integers $N$, $K$ and $L$. \n\n-----Output-----\nFor each test case:\n- If there is no valid assignment of bowlers to overs, print a single line containing the integer $-1$.\n- Otherwise, print a single line containing $N$ space-separated integers. For each valid $i$, the $i$-th of these integers should be the number of the player assigned as the bowler for the $i$-th over.\n\n-----Constraints-----\n- $1 \\le T \\le 30$\n- $1 \\le N, K, L \\le 10,000$\n\n-----Example Input-----\n2\n4 3 2\n5 4 1\n\n-----Example Output-----\n1 2 3 2\n-1\n\n-----Explanation-----\nExample case 1: The following is a valid assignment:\n- Bowler 1 bowls the $1$-st over.\n- Bowler 2 bowls the $2$-nd and $4$-th overs.\n- Bowler 3 bowls the $3$-rd over.\nIt is valid since no bowler bowls more than $2$ overs and each two consecutive overs have different bowlers.\nExample case 2: There is no valid assignment in which each of $4$ players bowls at most $1$ over out of $5$.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn count_occurrences(result: Seq<usize>, player: usize) -> nat \n    decreases result.len()\n{\n    if result.len() == 0 {\n        0\n    } else {\n        let count_rest = count_occurrences(result.drop_first(), player);\n        if result[0] == player {\n            count_rest + 1\n        } else {\n            count_rest\n        }\n    }\n}\n\nspec fn no_consecutive_same(result: Seq<usize>) -> bool \n    decreases result.len()\n{\n    if result.len() <= 1 {\n        true\n    } else {\n        result[0] != result[1] && no_consecutive_same(result.drop_first())\n    }\n}\n\nfn assign_bowlers(n: usize, k: usize, l: usize) -> (result: Vec<usize>)\n    requires n > 0 && k > 0 && l > 0,\n    ensures\n        /* Valid assignment case */\n        (result.len() > 0 ==> (\n            result.len() == n &&\n            forall|x: usize| #[trigger] result@.contains(x) ==> (1 <= x && x <= k) &&\n            no_consecutive_same(result@) &&\n            forall|player: usize| 1 <= player <= k ==> #[trigger] count_occurrences(result@, player) <= (l as nat)\n        )) &&\n        /* Impossible case conditions */\n        (result.len() == 0 ==> (k * l < n || (k == 1 && n > 1)))", "vc-code": "{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}", "vc-postamble": "\n/* Apps difficulty: interview */\n/* Assurance level: unguarded */\n\n}\nfn main() {\n    // let result1 = assign_bowlers(4, 3, 2);\n    // println!(\"{:?}\", result1);  // Expected: [1, 2, 3, 2]\n    \n    // let result2 = assign_bowlers(5, 4, 1);\n    // println!(\"{:?}\", result2);  // Expected: []\n    \n    // let result3 = assign_bowlers(3, 3, 1);\n    // println!(\"{:?}\", result3);  // Expected: [1, 2, 3]\n}"}
{"id": "fvapps_000779", "vc-description": "One upon a time there were three best friends Abhinav, Harsh, and Akash decided to form a \nteam and take part in ICPC from KIIT. Participants are usually offered several problems during \nthe programming contest. Long before the start, the friends decided that they will implement a \nproblem if at least two of them are sure about the solution. Otherwise, friends won't write the \nproblem's solution. \nThis contest offers $N$ problems to the participants. For each problem we know, which friend is \nsure about the solution. Help the KIITians find the number of problems for which they will write a \nsolution. \nThen n lines contain three integers each, each integer is either 0 or 1. If the first number in the \nline equals 1, then Abhinav is sure about the problem's solution, otherwise, he isn't sure. The \nsecond number shows Harsh's view on the solution, the third number shows Akash's view. The \nnumbers on the lines are \n\n-----Input:-----\n- A single integer will contain $N$, number of problems. \n\n-----Output:-----\nPrint a single integer — the number of problems the friends will implement on the contest. \n\n-----Constraints-----\n- $1 \\leq N \\leq 1000$ \n\n-----Sample Input:-----\n3\n\n1 1 0\n\n1 1 1\n\n1 0 0   \n\n-----Sample Output:-----\n2  \n\n-----EXPLANATION:-----\nIn the first sample, Abhinav and Harsh are sure that they know how to solve the first problem \nand all three of them know how to solve the second problem. That means that they will write \nsolutions for these problems. Only Abhinav is sure about the solution for the third problem, but \nthat isn't enough, so the group won't take it.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn confidence_sum(conf: Seq<int>) -> int\n    decreases conf.len()\n{\n    if conf.len() == 0 {\n        0\n    } else {\n        conf[0] + confidence_sum(conf.skip(1))\n    }\n}\n\nspec fn count_problems_with_at_least_two_confident(confidence_matrix: Seq<Vec<int>>) -> int\n    decreases confidence_matrix.len()\n{\n    if confidence_matrix.len() == 0 {\n        0\n    } else {\n        let first_sum = confidence_sum(confidence_matrix[0]@);\n        let rest_count = count_problems_with_at_least_two_confident(confidence_matrix.skip(1));\n        if first_sum >= 2 {\n            1 + rest_count\n        } else {\n            rest_count\n        }\n    }\n}\n\nfn count_solved_problems(n: usize, confidence_matrix: Vec<Vec<i32>>) -> (result: usize)\n    requires \n        n >= 1,\n        n <= 1000,\n        confidence_matrix.len() == n,\n        forall|i: int| 0 <= i < confidence_matrix.len() ==> confidence_matrix[i].len() == 3,\n        forall|i: int, j: int| 0 <= i < confidence_matrix.len() && 0 <= j < 3 ==> \n            (confidence_matrix[i][j] == 0 || confidence_matrix[i][j] == 1),\n    ensures\n        result <= confidence_matrix.len(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let test_matrix = vec![vec![1, 1, 0], vec![1, 1, 1], vec![1, 0, 0]];\n    // let result = count_solved_problems(3, test_matrix);\n    // println!(\"{}\", result);\n}"}
{"id": "fvapps_000781", "vc-description": "Chefina has two sequences A₁, A₂, …, Aₙ and B₁, B₂, …, Bₙ. She views two sequences with length N as identical if, after they are sorted in non-decreasing order, the i-th element of one sequence is equal to the i-th element of the other sequence for each i (1 ≤ i ≤ N).\nTo impress Chefina, Chef wants to make the sequences identical. He may perform the following operation zero or more times: choose two integers i and j (1 ≤ i,j ≤ N) and swap Aᵢ with Bⱼ. The cost of each such operation is min(Aᵢ, Bⱼ).\nYou have to find the minimum total cost with which Chef can make the two sequences identical.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn is_sorted(l: Seq<u32>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < l.len() ==> l[i] <= l[j]\n}\n\nspec fn sorted_seq(l: Seq<u32>) -> Seq<u32>;\n\nspec fn sequences_identical_when_sorted(a: Seq<u32>, b: Seq<u32>) -> bool {\n    sorted_seq(a) =~= sorted_seq(b)\n}", "vc-spec": "fn solve_sequence_swap(n: usize, a: Vec<u32>, b: Vec<u32>) -> (result: i32)\n    requires \n        n > 0,\n        a.len() == n,\n        b.len() == n,\n    ensures \n        result == -1 || result >= 0,\n        (result == -1) ==> !sequences_identical_when_sorted(a@, b@),\n        (result == 0) ==> sequences_identical_when_sorted(a@, b@),\n        (result > 0) ==> sequences_identical_when_sorted(a@, b@),", "vc-code": "{\n    // impl-start\n    assume(false);\n    -1\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000782", "vc-description": "Chef likes to solve difficult tasks. This time, he tried to solve the Big Famous Unsolvable A+B=C. One of his friends played a prank on Chef and randomly shuffled the bits in A and B (independently in each number). However, the funny thing is that the sum of the resulting numbers remained C even after shuffling.\nChef is now wondering: in how many ways is it possible to shuffle the bits of A and the bits of B such that their sum after shuffling is equal to C? Let's denote the integers obtained by shuffling the bits of A and B by A_s and B_s respectively; two ways (A_s1, B_s1) and (A_s2, B_s2) are considered distinct if A_s1 ≠ A_s2 or B_s1 ≠ B_s2.\nIt is allowed to add any number (possibly zero) of leading zeroes, i.e. bits 0, to A and any number of leading zeroes to B before shuffling the bits.\n\nInput:\n- The first line of the input contains a single integer T denoting the number of test cases. The description of T test cases follows.\n- The first and only line of each test case contains three space-separated integers A, B and C.\n\nOutput:\nFor each test case, print a single line containing one integer — the number of ways to shuffle the bits.\n\nConstraints:\n- 1 ≤ T ≤ 1,000\n- 1 ≤ A, B, C ≤ 10^9\n- A+B = C\n\nSubtasks:\nSubtask #1 (50 points): 1 ≤ A, B, C ≤ 10^5\nSubtask #2 (50 points): original constraints\n\nExample Input:\n2\n1 2 3\n369 428 797\n\nExample Output:\n2\n56\n\nExplanation:\nExample case 1: We can consider A=01 and B=10 in binary. Then, there are two possible ways: swapping the two bits of A and the two bits of B (A_s=10, B_s=01 in binary, 2 and 1 in decimal representation) or not shuffling any bits.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn count_set_bits(n: nat) -> nat\n    decreases n\n{\n    if n == 0 {\n        0nat\n    } else {\n        ((n % 2) as nat) + count_set_bits(n / 2)\n    }\n}\n\nspec fn count_binary_ones(n: nat) -> nat {\n    count_set_bits(n)\n}\n\nfn ways_to_shuffle(a: u32, b: u32, c: u32) -> (result: u32)\n    requires \n        a + b == c,\n        a >= 1 && b >= 1 && c >= 1,\n        a <= 1000000000 && b <= 1000000000 && c <= 1000000000,\n    ensures\n        result >= 0,\n        count_set_bits(a as nat) == count_binary_ones(a as nat),\n        count_set_bits(b as nat) == count_binary_ones(b as nat),", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let result1 = ways_to_shuffle(1, 2, 3);\n    // println!(\"{}\", result1);\n    // let result2 = ways_to_shuffle(369, 428, 797);\n    // println!(\"{}\", result2);\n}"}
{"id": "fvapps_000784", "vc-description": "Bitland declared war on Chefland and sent an army to fight them, but Chefland defended efficiently and Bitland's army has been reduced to N soldiers. They have no chance of winning the war and do not want to surrender, so they are planning to commit group suicide. Josh, the leader of Bitland's remaining soldiers, has different plans — he wants to survive and somehow escape.\nThe soldiers are numbered 1 through N; Josh is soldier N. The soldiers are going to stand in a circle in the order 1,2,…,P−1,N,P,P+1,…,N−1. Formally, they are standing in the circle in such a way that if Josh's position is P (1≤P≤N), then for each i (1≤i≤N−2, i≠P−1), soldier i+1 is directly to the right of soldier i, soldier P (if P≤N−1) or 1 (if P=N) is directly to the right of Josh and Josh is directly to the right of soldier P−1 (if P≥2) or soldier N−1 (if P=1); if 2≤P≤N−2, soldier 1 is also directly to the right of soldier N−1. For each i (1≤i≤N−1), soldier i has a sword with power Ai. Josh plans to take a shield with sufficiently high defense power D.\nFirst, the soldiers start to commit group suicide according to the following rules:\n- Initially, soldier 1 is the attacking soldier.\n- If the attacking soldier is not Josh, this soldier attacks the soldier that is currently to his right.\n- When Josh is attacked with power a, the current defense power of his shield decreases by a, and if it becomes negative, Josh dies. When a different soldier is attacked, he does not try to defend and dies immediately. The power of the attacking soldier's sword does not change.\n- Then, the next living soldier to the right of the current attacking soldier becomes the attacking soldier and the process continues until there is only one soldier left.\nIt is clear that this way, Josh cannot be the last survivor. However, Chefland's general Chef plans to interrupt this process as soon as there are exactly two living soldiers of Bitland left (Josh wants to be one of them) by attacking them with Chefland's full firepower F. Since this attack is unexpected, both attacked soldiers try to defend independently with the weapons they have. Josh survives if the current defense power of his shield is at least F. Any other soldier survives only if the power of his sword is strictly greater than F. Since Chefland does not attack again, if both Josh and another soldier survive, then the other soldier will kill Josh. Therefore, Josh wants to be the only survivor of Chefland's attack.\nYour task is to find the minimum possible value of D such that Josh survives if he chooses his position P optimally (or determine that he cannot survive) and the lowest position P such that Josh survives if he takes a shield with this defense power D.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_bitland_survival(n: usize, soldiers: Vec<usize>, f: usize) -> (result: (&'static str, Option<usize>, Option<usize>))\n    requires \n        n >= 2,\n        soldiers.len() == n - 1,\n        forall|i: int| 0 <= i < soldiers.len() ==> #[trigger] soldiers[i] >= 1 && #[trigger] soldiers[i] <= 100,\n        f >= 1,\n    ensures\n        match result.0 {\n            \"possible\" => exists|p: usize, s: usize| \n                result.1 == Some(p) && result.2 == Some(s) &&\n                p >= 1 && p <= n - 1 && s >= f,\n            \"impossible\" => result.1.is_none() && result.2.is_none(),\n            _ => false,\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    (\"\", None, None)\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000785", "vc-description": "In Chefland, there is a very famous street where N types of street food (numbered 1 through N) are offered. For each valid i, there are S_i stores that offer food of the i-th type, the price of one piece of food of this type is V_i (the same in each of these stores) and each day, P_i people come to buy it; each of these people wants to buy one piece of food of the i-th type.\nChef is planning to open a new store at this street, where he would offer food of one of these N types. Chef assumes that the people who want to buy the type of food he'd offer will split equally among all stores that offer it, and if this is impossible, i.e. the number of these people p is not divisible by the number of these stores s, then only floor(p/s) people will buy food from Chef.\nChef wants to maximise his daily profit. Help Chef choose which type of food to offer and find the maximum daily profit he can make.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_street_food(stores: Vec<(u32, u32, u32)>) -> (result: u32)\n    ensures\n        result >= 0,\n        stores.len() == 0 ==> result == 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: unguarded\n\n    // Test cases would go here but are commented out\n    // solve_street_food(vec![(4, 6, 8), (2, 6, 6), (1, 4, 3)]) should return 12\n    // solve_street_food(vec![(7, 7, 4)]) should return 0\n    // solve_street_food(vec![(1, 10, 5), (2, 15, 4)]) should return 25\n}"}
{"id": "fvapps_000787", "vc-description": "You are given an array A of size N. Let us list down all the subarrays of the given array. There will be a total of N * (N + 1) / 2 subarrays of the given array. Let us sort each of the subarrays in descending order of the numbers in it. \n\nNow you want to sort these subarrays in descending order. You can compare two subarrays B, C, as follows.\n\ncompare(B, C):\nAppend N - |B| zeros at the end of the array B.\nAppend N - |C| zeros at the end of the array C.\nfor i = 1 to N:\nif B[i] < C[i]:\nreturn B is less than C\nif B[i] > C[i]:\nreturn B is greater than C\nreturn B and C are equal.\n\nYou are given M queries asking for the maximum element in the pth subarray (1-based indexing).\n\n-----Input-----\nThe first line of input contains T, the number of test cases.\nThe first line of each test case contains two space separated integers N and M, denoting the array size and the number of queries respectively.\nThe next line contains N space-separated integers denoting the array elements.\n\nEach of the next M lines contains a single integer - p.\n\n-----Output-----\nOutput a single integer corresponding to the maximum element in the pth subarray.\n\n-----Constraints-----\n- 1 ≤ Ai ≤ 109\n- 1 ≤ p ≤ N+1C2\n\n-----Subtasks-----Subtask #1 (20 points):\n- 1 ≤ T ≤ 20\n- 1 ≤ N ≤ 200\n- 1 ≤ M ≤ 104\nSubtask #2 (30 points):\n- 1 ≤ T ≤ 20\n- 1 ≤ N ≤ 3000\n- 1 ≤ M ≤ 104\nSubtask #3 (50 points):\n- 1 ≤ T ≤ 5\n- 1 ≤ N ≤ 105\n- 1 ≤ M ≤ 105\n\n-----Example-----\nInput:1\n4 2\n3 1 2 4\n1\n5\n\nOutput:4\n3", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn list_maximum(l: Seq<i32>) -> i32 \n    decreases l.len()\n{\n    if l.len() == 0 {\n        0\n    } else if l.len() == 1 {\n        l[0]\n    } else {\n        let first = l[0];\n        let rest_max = list_maximum(l.subrange(1, l.len() as int));\n        if first > rest_max { first } else { rest_max }\n    }\n}\n\nfn solve_max_subarray_query(n: usize, arr: Vec<i32>, queries: Vec<usize>) -> (result: Vec<i32>)\n    requires \n        arr.len() > 0,\n        arr.len() <= 5,\n        queries.len() > 0,\n        queries.len() <= 3,\n        forall|x: i32| arr@.contains(x) ==> -100 <= x && x <= 100,\n        forall|q: usize| queries@.contains(q) ==> 1 <= q && q <= 15,\n    ensures\n        result.len() == queries.len(),\n        forall|x: i32| result@.contains(x) ==> x <= list_maximum(arr@),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let test_result = solve_max_subarray_query(4, vec![3, 1, 2, 4], vec![1, 5]);\n    // println!(\"{:?}\", test_result);\n    \n    // let test_result2 = solve_max_subarray_query(3, vec![1, 2, 3], vec![1, 2, 3]);\n    // println!(\"{:?}\", test_result2);\n}"}
{"id": "fvapps_000788", "vc-description": "One day Chef was playing with numbers. He loves Lowest Common Multiple (LCM) too much and he is a very curious guy. He always try to do new things. Now he want to make a large number with it. But he doesn't want to take too many numbers.\n\nHe is willing to take only three numbers less than or equal to N (not necessarily distinct ) and from those three number he want get the maximum number by taking LCM of the numbers.\n\nAs he is busy in playing some more tricks of maths, he assign this task to you.\n\n-----Input-----\nFirst line of input contains an integer t ( t<=1000 ), Number of test cases.\n\nt line follows an integer N\n\n-----Output-----\nPrint t lines contains a single integer — the maximum possible LCM of three not necessarily distinct positive integers that are not greater than N.\n\n-----Constraints-----\n1<= N <= 10^6\n\n-----Example-----\nInput:\n2\n9\n7\n\nOutput:\n504\n210\n\n-----Explanation-----\nExample case 2. For the last example, we can chose numbers 7, 6, 5 and the LCM of them is 7•6•5 = 210. It is the maximum value we can get.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn gcd(a: nat, b: nat) -> nat\n    decreases b\n{\n    if b == 0 {\n        a\n    } else {\n        gcd(b, a % b)\n    }\n}\n\nspec fn lcm(a: nat, b: nat) -> nat {\n    if a == 0 || b == 0 {\n        0\n    } else {\n        (a * b) / gcd(a, b)\n    }\n}\n\nfn max_lcm_three_nums(n: u32) -> (result: u32)\n    requires n >= 1,\n    ensures \n        result >= 1,\n        (n == 1 ==> result == 1),\n        (n == 2 ==> result == 2),\n        (n == 3 ==> result == 6),\n        (n == 7 ==> result == 210),\n        (n == 9 ==> result == 504)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let test_cases = [\n    //     (1, 1),\n    //     (2, 2), \n    //     (3, 6),\n    //     (7, 210),\n    //     (9, 504)\n    // ];\n    // \n    // for (n, expected) in test_cases {\n    //     let result = max_lcm_three_nums(n);\n    //     println!(\"max_lcm_three_nums({}) = {}, expected = {}\", n, result, expected);\n    //     assert_eq!(result, expected);\n    // }\n}"}
{"id": "fvapps_000790", "vc-description": "Chef is frustrated in this lockdown. So to overcome this he plans to travel various mountains.\nHe is very strange so he sets some conditions for each Type 2 query (mentioned below) (i.e. 1 i):\n- Let Chef has travelled till ith mountain from left to right.\n- He does not like to travel the mountain with the height, of which he has travelled till now. More formally,\nLet the height of peak on which he is standing is a_i then he can only go to the peak of height a_j\nwhich is greater than a_i and nearest to ith mountain such that there should be no other peak of same height a_j till a_i (height of ith mountain).\n\nInput format:\n- The first line contains an integer T denoting the number of test cases.\n- The second line of consist of a integer N and Q.\n- The third line contains N not necessarily distinct positive integers a_0, a_1, ..., a_{n-1} denoting the height of N mountains.\n- Then next Q lines follows where each line consisting of either of 2 types of queries:\nType 1: 0 A B i.e. a_A = B (where height of Ath mountain will be updated to B)\nType 2: 1 A i.e. you have to answer a_k which is greater than a_A and nearest to Ath mountain such that there should be no other peak of same height a_k till a_A (height of Ath mountain).\n\nOutput format:\n- For every query of Type 2 there should be an integer a_k on next line for the updated array, If no such a_k exists then a_k = -1, as query of type 1 will have no output.\n\nConstraints:\n- 1 ≤ T ≤ 10^2\n- 1 ≤ N,Q ≤ 10^4\n- 0 ≤ a_i ≤ 10^6\n- 0 ≤ B ≤ 10^6\n- 0 ≤ A ≤ N-1", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn filter_type_1_queries(queries: Seq<Seq<usize>>) -> Seq<Seq<usize>>\n    decreases queries.len()\n{\n    if queries.len() == 0 {\n        seq![]\n    } else {\n        let query = queries[0];\n        let rest_filtered = filter_type_1_queries(queries.skip(1));\n        if query.len() > 0 && query[0] == 1 {\n            seq![query].add(rest_filtered)\n        } else {\n            rest_filtered\n        }\n    }\n}\n\nfn solve_mountain_queries(n: usize, mountains: Vec<usize>, queries: Vec<Vec<usize>>) -> (result: Vec<i32>)\n    requires \n        n >= 2,\n        mountains.len() == n,\n    ensures \n        result.len() == filter_type_1_queries(queries@.map(|i: int, q: Vec<usize>| q@)).len(),\n        forall|i: int| 0 <= i < result.len() ==> (result[i] == -1 || result[i] >= 0),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000792", "vc-description": "DevuLand is a very strange place. There are n villages in it. Some of the villages are occupied by dinosaurs while the remaining ones by villagers.\nYou are given the information of DevuLand \nby an array D of size n. If D[i] is non-negative, it means that there are D[i] villagers in that village. \nOtherwise, it means that are -D[i] \ndinosaurs in that village.\n\nIt is also guaranteed that total number of villagers in DevuLand is equal to total number of dinosaurs.\n\nOnce dinosaurs got very hungry and started eating villagers. Frightened villagers gathered immediately and met their Sarpanch Deviji. Deviji, being a very daring and negotiable person, met to the head\nof dinosaurs. Soon both parties called a truce. It was decided that the villagers will provide laddus to \nthe dinosaurs. So everyday, each villager will take exactly one laddu to one of the dinosaurs in such a way that no dinosaur remains hungry (note that this is possible because number of villagers is the same as the number of dinosaurs).\n\nActually, carrying laddus is a quite a tough job. Villagers have to use a bullock cart for that. It takes one unit of grass a bullock to \ncarry a cart with 1 laddu for 1 kilometre. Laddus used to be very heavy in DevuLand, so a bullock cart can not carry more than one laddu.\n\nIt is also given distance between village indexed i and j is |j - i| (the absolute value) kilometres.\n\nNow villagers sat down and found a strategy to feed laddus to dinosaurs so that they need to buy the least amount of grass from the nearby market. \nThey are not very good in \ncalculations, please find out what is the minimum number of units of grass they need to buy.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn list_sum(l: Seq<i32>) -> int\n    decreases l.len()\n{\n    if l.len() == 0 {\n        0\n    } else {\n        l[0] + list_sum(l.skip(1))\n    }\n}\n\nfn min_grass_needed(arr: Vec<i32>) -> (result: nat)\n    requires \n        arr.len() > 0,\n        list_sum(arr@) == 0,\n    ensures result >= 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // /* Test cases to verify the implementation\n    // let test1 = vec![5, -5];\n    // let result1 = min_grass_needed(test1);\n    // assert(result1 == 5);\n    // \n    // let test2 = vec![-5, 5];  \n    // let result2 = min_grass_needed(test2);\n    // assert(result2 == 5);\n    // \n    // let test3 = vec![1, 2, -3];\n    // let result3 = min_grass_needed(test3);\n    // assert(result3 == 4); */\n}"}
{"id": "fvapps_000795", "vc-description": "Johnny has some difficulty memorizing the small prime numbers. So, his computer science teacher has asked him to play with the following puzzle game frequently.\nThe puzzle is a 3x3 board consisting of numbers from 1 to 9. The objective of the puzzle is to swap the tiles until the following final state is reached:\n1 2 3\n4 5 6\n7 8 9\n\nAt each step, Johnny may swap two adjacent tiles if their sum is a prime number. Two tiles are considered adjacent if they have a common edge.\nHelp Johnny to find the shortest number of steps needed to reach the goal state.\n\n-----Input-----\nThe first line contains t, the number of test cases (about 50). Then t test cases follow. Each test case consists of a 3x3 table describing a puzzle which Johnny would like to solve.\nThe input data for successive test cases is separated by a blank line.\n\n-----Output-----\nFor each test case print a single line containing the shortest number of steps needed to solve the corresponding puzzle. If there is no way to reach the final state, print the number -1.\n\n-----Example-----\nInput:\n2\n\n7 3 2 \n4 1 5 \n6 8 9 \n\n9 8 5 \n2 4 1 \n3 7 6  \n\nOutput:\n6\n-1\n\n-----Output details-----\nThe possible 6 steps in the first test case are described in the following figure:", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_prime_grid_puzzle(grid: Vec<nat>) -> (result: i32)\n    ensures \n        grid@ == seq![1nat, 2nat, 3nat, 4nat, 5nat, 6nat, 7nat, 8nat, 9nat] ==> result == 0,\n        grid@ == seq![7nat, 3nat, 2nat, 4nat, 1nat, 5nat, 6nat, 8nat, 9nat] ==> result == 6,\n        grid@ == seq![9nat, 8nat, 5nat, 2nat, 4nat, 1nat, 3nat, 7nat, 6nat] ==> result == -1,\n        grid.len() != 9 ==> result == -1,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "}\n\nfn main() {\n    // let test1 = vec![7nat, 3nat, 2nat, 4nat, 1nat, 5nat, 6nat, 8nat, 9nat];\n    // println!(\"{}\", solve_prime_grid_puzzle(test1));\n    \n    // let test2 = vec![9nat, 8nat, 5nat, 2nat, 4nat, 1nat, 3nat, 7nat, 6nat];\n    // println!(\"{}\", solve_prime_grid_puzzle(test2));\n    \n    // let test3 = vec![1nat, 2nat, 3nat, 4nat, 5nat, 6nat, 7nat, 8nat, 9nat];\n    // println!(\"{}\", solve_prime_grid_puzzle(test3));\n}"}
{"id": "fvapps_000796", "vc-description": "This is another problem about Indraneel's library. His library has one long shelf. His books are numbered and he identifies the books by their number. Each book has a distinct number.\nHe has lost many books, since many of his friends borrow his books and never bother to return them. He does not want to lose any more books and has decided to keep a record of all books that he lends to his friends. To make the task of borrowing a book a little difficult, he has given the following instructions to his friends: when they borrow a book, they must record in a register its position from the left among the books currently on the shelf.\nSuppose there are 5 books in the library and they are arranged as follows:\n26 1 42 15 3\nIf someone walks in and borrows the book 42, then he will record 3 in the register because this book is the third from the left on the shelf. Now the shelf looks like this:\n26 1 15 3\nIf the next person borrow the book 3, he writes down 4 in the register since this is currently the fourth book from the left on the shelf, and so on.\nIndraneel knows the initial arrangement of the books in his library at the time that he introduced the register system. After a while he examines his register and would like to know which books have been borrowed. Your task is to write a program to help Indraneel solve this problem.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn find_borrowed_books(n: usize, books: Vec<usize>, k: usize, positions: Vec<usize>) -> (result: Vec<usize>)\n    requires \n        n == books.len(),\n        k == positions.len(),\n        k <= n,\n        forall|i: int| 0 <= i < positions.len() ==> positions[i] > 0 && positions[i] <= n - i,\n    ensures \n        result.len() == k,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000797", "vc-description": "Amit is going on a date and he wants to gift his date an array of positive numbers. But he is running short on money. He already has an array of numbers in design. Cost of an array of numbers is the sum of elements in it. But he wants to minimize the cost of making it. \nSo he does the following number of operations one by one for any number of times:\nHe chooses two adjacent elements ,replace them by one element with value = XOR of the two numbers. This operation reduces length of array (and elements are re-numerated accordingly)\nFind the minimum amount of money that Amit needs to spend to gift his date.\n\n-----Input:-----\n- First line will contain $T$, number of testcases. Then the testcases follow. \n- Each testcase contains of $2$ lines of input, first line contains a single integer $N$ and the second line contains $N$ elements - $A1,A2,A3,.....,AN$ \n\n-----Output:-----\nFor each testcase, output in a single line answer denoting the minimum cost\n\n-----Constraints-----\n- $1 \\leq T \\leq 10$\n- $1 \\leq N \\leq 10^5$\n- $0 \\leq Ai \\leq 10^9$ for $1\\leq i \\leq N$\n\n-----Sample Input:-----\n3\n5\n8 4 1 5 0\n5\n1 2 4 0 8\n2\n10 10\n\n-----Sample Output:-----\n8\n15\n0\n\n-----EXPLANATION:-----\nFor first case,\nThis array is :\n$[8,4,1,5,0] -> [8,4,4,0] -> [8,0,0]$. Sum=$8$ So the answer is 8.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn array_xor(arr: Seq<u32>) -> u32 \n    decreases arr.len()\n{\n    if arr.len() == 0 {\n        0\n    } else if arr.len() == 1 {\n        arr[0]\n    } else {\n        arr[0] ^ array_xor(arr.skip(1))\n    }\n}\n\nfn solve_array_xor(n: usize, arr: Vec<u32>) -> (result: u32)\n    requires \n        n == arr.len(),\n        n > 0\n    ensures\n        result == array_xor(arr@)\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-code": "", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded_and_plausible\n\n    // #guard_msgs in\n    // #eval solve_array_xor 5 [8, 4, 1, 5, 0]\n\n    // #guard_msgs in\n    // #eval solve_array_xor 5 [1, 2, 4, 0, 8]\n\n    // #guard_msgs in\n    // #eval solve_array_xor 2 [10, 10]\n}"}
{"id": "fvapps_000798", "vc-description": "We all know Gru loves Agnes very much. One day Agnes asked Gru to answer some of her queries. She lined up N minions in a straight line from 1 to N. \nYou are given an array A which contains the height of minions. Agnes will ask him several queries. In each query, Gru has to tell whether the bitwise AND of A[L…R] is EVEN or ODD. Since Gru is busy planning the biggest heist on Earth, he asks for your help.\n\nInput:\n- First line of the input contains an integer T denoting the number of test cases.\nFor each test case:-\n- First line contains an integer N denoting the number of elements.\n- Second line contains N spaced integer representing array elements.\n- Third line contains Q representing number of query.\n- Next Q lines contains two integer L and R as defined above.\n\nOutput:\nFor each query, output \"EVEN\" or \"ODD\" without quotes.\n\nConstraints:\n- 1 ≤ T ≤ 10\n- 1 ≤ N ≤ 10^5\n- 1 ≤ A_i ≤ 10^5\n- 1 ≤ Q ≤ 10^5\n\nSample Input:\n1\n5\n1 3 2 4 5\n3\n1 2 \n1 5\n3 4\n\nSample Output:\nODD\nEVEN\nEVEN\n\nExplanation:\n- For the first query, the bitwise AND of 1 and 3 is 1, which is Odd. Hence the first output is ODD.\n- For the third query, the bitwise AND of 2 and 4 is 0, which is Even. Hence the third output is EVEN.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn bitwise_and_range(arr: Seq<u32>, start: int, end: int) -> u32\n    decreases end - start\n{\n    if start >= end {\n        0xFFFFFFFF\n    } else if start + 1 == end {\n        arr[start]\n    } else {\n        arr[start] & bitwise_and_range(arr, start + 1, end)\n    }\n}\n\nfn solve_minion_queries(n: usize, arr: Vec<u32>, queries: Vec<(usize, usize)>) -> (result: Vec<String>)\n    requires \n        n == arr.len(),\n        n > 0,\n    ensures\n        result.len() == queries.len()", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let test_arr = vec![1, 3, 2, 4, 5];\n    // let test_queries = vec![(1, 2), (1, 5), (3, 4)];\n    // let result = solve_minion_queries(5, test_arr, test_queries);\n    // println!(\"{:?}\", result);\n}"}
{"id": "fvapps_000799", "vc-description": "Motu wants to learn Cricket from a coach, but firstly coach wants to test his IQ level, so he gave Motu 1 Red ball and 1 Black ball , and asked him to buy other x – 1 red balls and other y – 1 black balls from the market. But he put some conditions on buying balls, that if he has R red and B black balls then he can either buy B red balls or R black balls in one operation. He can perform this operation as many times as he want. But as Motu is not so good in solving problems so he needs your help. So you have to tell him whether his coach's task possible or not.\n\n-----Input:-----\n- First line will contain T, number of testcases. Then the testcases follow. \n- Each testcase contains of a single line of input, two integers x , y. \n\n-----Output:-----\nFor each testcase, print YES, if it is possible to complete coach task, else print NO(without quotes) in a separate line.\n\n-----Constraints-----\n- 1 ≤ T ≤ 100000\n- 1 ≤ x, y ≤ 10^18\n\n-----Sample Input:-----\n2\n1 2\n2 3\n\n-----Sample Output:-----\nYES\nYES", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn gcd(a: nat, b: nat) -> nat\n    decreases b\n{\n    if b == 0 {\n        a\n    } else {\n        gcd(b, a % b)\n    }\n}\n\nfn can_complete_task(x: u64, y: u64) -> (result: bool)\n    requires \n        x > 0,\n        y > 0,\n    ensures \n        result <==> (gcd(x as nat, y as nat) == 1),", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000803", "vc-description": "Chef likes problems which using some math. Now he asks you to solve next one. You have 4 integers, Chef wondering is there non-empty subset which has sum equals 0.\n\n-----Input-----\nThe first line of input contains T - number of test cases. \nEach of the next T lines containing four pairwise distinct integer numbers - a, b, c, d.\n\n-----Output-----\nFor each test case output \"Yes\", if possible to get 0 by choosing non-empty subset of {a, b, c, d} with sum equal 0, or \"No\" in another case.\n\n-----Constraints-----\n- 1 ≤ T ≤ 103\n- -106 ≤ a, b, c, d ≤ 106 \n\n-----Example-----\nInput:\n3\n1 2 0 3\n1 2 4 -1\n1 2 3 4\n\nOutput:\nYes\nYes\nNo\n\n-----Explanation-----\nExample case 1. We can choose subset {0} \nExample case 2. We can choose subset {-1, 1}", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn can_get_zero_sum_subset(a: i32, b: i32, c: i32, d: i32) -> (result: &'static str)\n    ensures \n        result == \"Yes\" || result == \"No\",\n        (a == 0 || b == 0 || c == 0 || d == 0) ==> result == \"Yes\",\n        (a == -b || a == -c || a == -d || b == -c || b == -d || c == -d) ==> result == \"Yes\",\n        (a > 0 && b > 0 && c > 0 && d > 0) ==> result == \"No\",\n        (a < 0 && b < 0 && c < 0 && d < 0) ==> result == \"No\"", "vc-code": "{\n    // impl-start\n    assume(false);\n    \"No\"\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000805", "vc-description": "Our Chef is doing what he is best at, COOKING A BARBECUE for his guests. He has invited all of us, and taking the help of his apprentice to smoke the barbecues. The chef has got BBQ sticks, each can take N fillings, and he presents N distinctly filled sticks in front his guests forming a N*N  matrix\n\nBut here is the problem, he has got only two type of fillings, meat and capsicum, but still wants the N  sticks to look \"presentable\", he is very particular about it. As a solution he fills the main diagonal of the N*N  matrix with the same type of filling (either meat or capsicum) forming a \"presentable\" set\n\nThe Chef's apprentice is a fool, so the Chef asks him to cook M distinctly filled sticks ,so that the Chef is sure that among M there exist N sticks forming a \"presentable\" set. Your job is to determine smallest possible value of M.\n\n-----Input-----\nT, the number of test cases, followed by T lines. \nEach line containing the positive integer N >= 4\n\n-----Output-----\nT lines of output, each line contain the positive integer M\n\n-----Example-----\nInput:\n1\n4\n\nOutput:\n5", "vc-preamble": "use vstd::prelude::*;\nuse vstd::arithmetic::power2::pow2;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_barbecue_sticks(n: nat) -> (result: nat)\n    requires n >= 3,\n    ensures \n        result > 0,\n        result % 2 == 1,\n        result >= pow2((n - 2) as nat)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // #eval solve_barbecue_sticks 4  // Expected: 5\n    // #eval solve_barbecue_sticks 5  // Expected: 9  \n    // #eval solve_barbecue_sticks 6  // Expected: 17\n}"}
{"id": "fvapps_000806", "vc-description": "Let's consider a rectangular table R consisting of N rows and M columns. Rows are enumerated from 1  to N from top to bottom. Columns are enumerated from 1 to M from left to right. Each element of R is a non-negative integer. R is called steady if the sum of elements in the ith row is not less then the sum of elements in the (i-1)th row for each i where 2 ≤ i ≤ N and the sum of elements in the Nth row is less than or equal to M. Your task is to find the number of different steady tables of size N x M modulo 1 000 000 000. \n\n-----Input-----\nThe first line of input contains a single integer T denoting number of test cases. First and the only line of each test case contains two space separated integers N and M denoting the number of rows and columns respectively.\n\n-----Output-----\nFor each test case, print a single integer corresponding to the answer.\n\n-----Constraints-----\n- 1 ≤ T ≤ 10\n- 1 ≤ N, M ≤ 2000\n\n-----Subtasks-----\n- Subtask 1 : 1 ≤ T ≤ 10 , 1 ≤ N,M ≤ 50 : ( 23 pts )\n- Subtask 2 : 1 ≤ T ≤ 10 , 1 ≤ N,M ≤ 500 : ( 29 pts )\n- Subtask 3 : 1 ≤ T ≤ 10 , 1 ≤ N,M ≤ 2000 : ( 48 pts )\n\n-----Example-----\nInput:\n3\n1 1\n2 2\n2 3\nOutput:\n2\n25\n273\n\n-----Explanation-----\nTest case 1 : There are only 2 such grids possible 0 and 1.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn mod_value() -> nat { 1000000000 }\n\nfn compute_steady_tables(n: usize, m: usize) -> (result: usize)\n    requires \n        n > 0,\n        m > 0,\n    ensures \n        result < mod_value(),\n        result >= n,\n        result >= m,\n        (n == 1 && m == 1) ==> result == 2,\n        n > 0 ==> result >= n * n,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let result1 = compute_steady_tables(1, 1);\n    // println!(\"{}\", result1);\n    \n    // let result2 = compute_steady_tables(2, 2);\n    // println!(\"{}\", result2);\n    \n    // let result3 = compute_steady_tables(2, 3);\n    // println!(\"{}\", result3);\n}"}
{"id": "fvapps_000807", "vc-description": "Limak has a string S, that consists of N lowercase English letters.\nLimak then created a new string by repeating S exactly K times.\nFor example, for S = \"abcb\" and K = 2, he would get \"abcbabcb\".\nYour task is to count the number of subsequences \"ab\" (not necessarily consecutive) in the new string.\nIn other words, find the number pairs of indices i < j, such that the i-th and j-th characters in the new string are 'a' and 'b' respectively.\n\n-----Input-----\nThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\nThe first line of each test case contains two integers N and K, denoting the length of the initial string S and the number of repetitions respectively.\nThe second line contains a string S.\nIts length is exactly N, and each of its characters is a lowercase English letter.\n\n-----Output-----\nFor each test case, output a single line containing one integer — the number of subsequences \"ab\" in the new string.\nFor the given constraints, it can be proved that the answer fits in the 64-bit signed type.\n\n-----Constraints-----\n- 1 ≤ T ≤ 10\n- 1 ≤ N ≤ 105\n- 1 ≤ N * K ≤ 109 (in other words, the new string has length up to 109)\n\n-----Example-----\nInput:\n3\n4 2\nabcb\n7 1\naayzbaa\n12 80123123\nabzbabzbazab\n\nOutput:\n6\n2\n64197148392731290\n\n-----Explanation-----\nTest case 1. Limak repeated the string \"abcb\" 2 times, and so he got \"abcbabcb\". There are 6 occurrences of the subsequence \"ab\":\n- ABcbabcb (the two letters marked uppercase)\n- AbcBabcb\n- AbcbaBcb\n- AbcbabcB\n- abcbABcb\n- abcbAbcB\nTest case 2. Since K = 1, the new string is equal to the given S (\"aayzbaa\"). There are 2 occurrences of the subsequence \"ab\" in this string: AayzBaa and aAyzBaa.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn count_subsequences(n: u64, k: u64, s: Vec<char>) -> (result: u64)\n    ensures \n        (forall|c: char| s@.contains(c) ==> c != 'b') ==> result == 0,\n        (forall|c: char| s@.contains(c) ==> c != 'a') ==> result == 0,\n        k == 0 ==> result == 0,\n        s.len() == 0 ==> result == 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    0u64\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let test1 = count_subsequences(4, 2, vec!['a', 'b', 'c', 'b']);\n    // assert(test1 == 6);\n    // \n    // let test2 = count_subsequences(7, 1, vec!['a', 'a', 'y', 'z', 'b', 'a', 'a']);\n    // assert(test2 == 2);\n    // \n    // let test3 = count_subsequences(12, 80123123, vec!['a', 'b', 'z', 'b', 'a', 'b', 'z', 'b', 'a', 'z', 'a', 'b']);\n    // assert(test3 == 64197148392731290);\n}"}
{"id": "fvapps_000808", "vc-description": "Chef lives in a big apartment in Chefland. The apartment charges maintenance fees that he is supposed to pay monthly on time. But Chef is a lazy person and sometimes misses the deadlines. The apartment charges 1000 Rs per month as maintenance fees. Also, they also charge a one-time fine of 100 Rs for each of the late payments. It does not matter how late the payment is done, the fine is fixed to be Rs.100.\nChef has been living in the apartment for N months. Now, he wants to switch the apartment, so he has to pay the entire dues to the apartment. The deadline for the N-th month is also over. From his bank statement, he finds the information whether he paid apartment rent for a particular month for not. You are given this information by an array A of size N, where Ai (can be either 0 or 1) specifies whether he has paid the 1000Rs in the i-th month or not. Assume that Chef paid the fees in the i-th month, then this fees will be considered for the earliest month for which Chef has not yet paid the fees.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn calculate_maintenance_due(n: usize, payments: Vec<String>) -> (result: usize)\n    ensures\n        n == 0 ==> result == 0,\n        payments.len() == 0 ==> result == 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded_and_plausible\n\n    // let result1 = calculate_maintenance_due(2, vec![\"1\".to_string(), \"1\".to_string()]);\n    // assert!(result1 == 0);\n\n    // let result2 = calculate_maintenance_due(2, vec![\"0\".to_string(), \"0\".to_string()]);\n    // assert!(result2 == 2200);\n\n    // let result3 = calculate_maintenance_due(3, vec![\"0\".to_string(), \"1\".to_string(), \"0\".to_string()]);\n    // assert!(result3 == 2300);\n}"}
{"id": "fvapps_000810", "vc-description": "Vivek was quite bored with the lockdown, so he came up with an interesting task. He successfully completed this task and now, he would like you to solve it.\nYou are given two strings A and B, each with length N. Let's index the characters in each string from 0 ― for each i (0 ≤ i < N), the i+1-th characters of A and B are denoted by A_i and B_i respectively. You should convert A to B by performing operations of the following type:\n- Choose a subset S of the set {0, 1, …, N-1}.\n- Let c be the alphabetically smallest character among A_x for all x ∈ S.\n- For each x ∈ S, replace A_x by c.\nYou should find the smallest necessary number of operations or report that it is impossible to convert A to B. If it is possible, you also need to find one way to convert A to B using this smallest number of operations. If there are multiple solutions, you may find any one.\n\nInput:\n- The first line of the input contains a single integer T denoting the number of test cases. The description of T test cases follows.\n- The first line of each test case contains a single integer N.\n- The second line contains a single string A.\n- The third line contains a single string B.\n\nOutput:\nFor each test case:\n- If it is impossible to convert A to B, print a single line containing the integer -1.\n- Otherwise, first, print a line containing a single integer K ― the minimum number of operations.\n- Then, print K lines describing the operations. Each of these lines should contain a positive integer Z, followed by a space and Z pairwise distinct space-separated integers from the set {0, 1, …, N-1} ― the elements of S.\n\nConstraints:\n- 1 ≤ T ≤ 20\n- 1 ≤ N ≤ 10³\n- |A| = |B| = N\n- A and B contain only lowercase English letters\n\nSubtasks:\nSubtask #1 (30 points): B contains only characters 'a' and 'b'\nSubtask #2 (70 points): original constraints\n\nExample Input:\n3\n5\nabcab\naabab\n3\naaa\naab\n2\nde\ncd\n\nExample Output:\n2\n3 1 2 4\n3 0 1 3\n-1\n-1\n\nExplanation:\nExample case 1:\n- First, we can choose S = (1, 2, 4), so the character c is 'b' and the string A after this operation is \"abbab\".\n- Then, we choose S = (0, 1, 3), so c is 'a', and A becomes \"aabab\".\n- There is no way to convert A to B in only one operation.\nExample case 2: We can see that it is impossible to convert A to B since c is always 'a'.\nExample case 3: We can see again that it is impossible to convert A to B since c cannot be 'c'.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn convert_strings(a: Seq<char>, b: Seq<char>) -> (result: Seq<Seq<nat>>)\n    requires a.len() == b.len(),\n    ensures result.len() >= 1\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n\nfn single_element_list(n: nat) -> (result: Seq<nat>)\n    ensures result.len() == 1 && result[0] == n\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-code": "", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000811", "vc-description": "Bear Limak has a sequence of N non-negative integers A1, A2, ..., AN. He defines the score of a segment (consecutive subsequence) as its sum of elements modulo P (not necessarily prime). Find the maximum score of a non-empty segment, and also find the number of segments with this maximum score.\n\nInput:\nFirst line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\nFor each test case, the first line of the input contains two space separated integers, N and P.\nThe second line contains N space separated integers denoting the sequence.\n\nOutput:\nFor each test case, output two space separated integers denoting the maximum score of a segment and the number of segments with the score, respectively.\n\nConstraints:\n- 1 ≤ T ≤ 10\n- 1 ≤ N ≤ 105\n- 1 ≤ P ≤ 109\n- 0 ≤ Ai ≤ 109 \n\nSubtask #1: (25 points)\n- 1 ≤ N ≤ 100\n\nSubtask #2: (25 points)\n- 1 ≤ N ≤ 1000\n\nSubtask #3: (50 points)\n- original constraints\n\nExample:\nInput:\n4\n2 3\n1 2\n3 5\n2 4 3\n3 100\n1 3 5\n4 3\n1 2 3 4\n\nOutput:\n2 1\n4 2\n9 1\n2 2\n\nExplanation:\nExample case 1. There are three segments - [1], [2] and [1, 2]. Sum of these segments are 1, 2 and 3 respectively. Sum of these segments modulo 3 will be 1, 2 and 0. Maximum score among these is 2. There is also only one segment with this score.\nExample case 2. There are six segments - [2], [4], [3], [2, 4], [4, 3] and [2, 4, 3]. Sum of these segments are 2, 4, 3, 6, 7, 9 respectively. Sum of these segments modulo 5 will be 2, 4, 3, 1, 2, 4. Maximum score among these is 4. And there are two segments with this score.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn sum_list(xs: Seq<u32>) -> int\n    decreases xs.len()\n{\n    if xs.len() == 0 {\n        0\n    } else {\n        xs[0] as int + sum_list(xs.skip(1))\n    }\n}", "vc-spec": "fn find_max_segment_scores(n: u32, m: u32, arr: Seq<u32>) -> (result: (u32, u32))\n    requires \n        n > 0,\n        arr.len() == n,\n        m > 0\n    ensures\n        result.0 < m,\n        result.1 > 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    (0u32, 1u32)\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000813", "vc-description": "Galileo's latest project involves determining the density of stars in certain regions of the sky. For this purpose he started looking for datasets online, and discovered a dataset on Newton's blog. Newton had decomposed the night sky into a Voronoi tessellation with the generators arranged in a grid. He has stored the number of stars in a Voronoi cell at a position in a matrix that corresponds to the position of the generator in the grid.\nThis dataset does not directly help Galileo, because he needs to be able to query the number of stars in a rectangular portion of the sky. Galileo tried to write a program that does this on his own, but it turned out to be too slow. Can you help him?\n\n-----Input Format-----\nThe first line contains two integers n and m that denote the height and width of the matrix respectively. This is followed by  n lines each containing m integers each.\nThe line following this would contain a single integer t, the number of queries to be run. Each query line consists of 4 integers px, py, qx, qy. The first two integers denote the row and column numbers of the upper left corner of the rectangular region, and the second pair of numbers correspond to the lower right corner.\n\n-----Output Format-----\nFor each query output a single line containing the number of stars in that rectangular region.\n\n-----Example-----\nInput:\n\n3 3\n10 10 10\n10 10 10\n10 10 10\n4\n1 1 1 1\n1 1 3 3\n2 1 3 3\n3 1 3 3\n\nOutput:\n\n10\n90\n60\n30", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn row_sum(row: Seq<nat>) -> nat\n    decreases row.len()\n{\n    if row.len() == 0 {\n        0\n    } else {\n        row[0] + row_sum(row.skip(1))\n    }\n}\n\nspec fn grid_total_sum(grid: Seq<Seq<nat>>) -> nat\n    decreases grid.len()\n{\n    if grid.len() == 0 {\n        0\n    } else {\n        row_sum(grid[0]) + grid_total_sum(grid.skip(1))\n    }\n}\n\nfn count_stars_in_region(grid: Vec<Vec<nat>>, x1: nat, y1: nat, x2: nat, y2: nat) -> (result: nat)\n    requires \n        grid.len() > 0,\n        forall|i: int| 0 <= i < grid.len() ==> grid[i].len() > 0,\n        x1 >= 1 && y1 >= 1,\n        x1 <= x2 && y1 <= y2,\n    ensures\n        true,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "fvapps_000814", "vc-description": "Chef is stuck in a two dimensional maze having N rows and M columns. He needs to get out of the maze as soon as possible and arrive at the kitchen in order to serve his hungry customers. But, he can get out of the maze only if he is able to successfully find any magical path in the given maze.\n\nA path is defined as magical if it starts from any of the cell (a,b) of the maze and ends at the cell (c,d) such that the following conditions are satisfied :-\n- |a - c| + |b - d| = 1\n- All the cells in the maze are traversed exactly once.\n- It is allowed to move only in the four directions - up, down, left and right from the current cell.\n\n-----Input-----\n- First line of the input contains an integer T denoting the number of different types of scenarios.\n- Each of the next T lines will contain two integers N, M denoting the dimensions of the maze.\n\n-----Output-----\nFor each of the T scenarios, output a single line containing \"Yes\" or \"No\" (without quotes) denoting whether the Chef can get out of the maze or not.\n\n-----Constraints-----\n- 1 ≤ T ≤ 105\n- 1 ≤ N, M ≤ 1018\n\n-----Subtasks-----\nSubtask #1 : (30 points)\n- 1 ≤ T ≤ 100\n- 1 ≤ N, M ≤ 10\n\n-----Subtask #2 : (70 points) \n\nOriginal Constraints\n\n-----Example-----\nInput:\n1\n2 2\n\nOutput:\nYes\n\n-----Explanation-----\nExample case 1.\n\nChef can start from (1,1), move down to (2,1), then move right to (2,2) and finally move upwards to reach (1,2). As, he is able to visit all the cells exactly once and sum of absolute differences of corresponding x and y dimension is 1, we can call this path a magical path.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn solve_maze_path_spec(n: nat, m: nat) -> bool\n{\n    (n == 1 && m == 2) || (n == 2 && m == 1) || \n    (n > 1 && m > 1 && (n * m) % 2 == 0)\n}\n\nfn solve_maze_path(n: nat, m: nat) -> (result: &'static str)\n    requires n > 0, m > 0,\n    ensures \n        result == \"Yes\" || result == \"No\",\n        result == \"Yes\" <==> solve_maze_path_spec(n, m)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: unguarded\n\n    // assert(solve_maze_path(2, 2) == \"Yes\");\n    // assert(solve_maze_path(2, 3) == \"Yes\");\n    // assert(solve_maze_path(1, 3) == \"No\");\n}"}
{"id": "fvapps_000816", "vc-description": "Find sum of all the numbers that are multiples of 10 and are less than or equal to a given number \"N\". (quotes for clarity and be careful of integer overflow)\n\n-----Input-----\nInput will start with an integer T the count of test cases, each case will have an integer N.\n\n-----Output-----\nOutput each values, on a newline.\n\n-----Constraints-----\n- 1 ≤ T ≤ 10\n- 1 ≤ N ≤1000000000\n\n-----Example-----\nInput:\n1\n10\n\nOutput:\n10\n\n-----Explanation-----\nExample case 1. Only integer that is multiple 10 that is less than or equal to 10 is 10", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn sum_multiples_of_ten_spec(n: nat) -> nat\n    decreases n\n{\n    if n < 10 {\n        0\n    } else {\n        let k = n / 10;\n        k * (k + 1) * 5\n    }\n}\n\nfn sum_multiples_of_ten(n: nat) -> (result: nat)\n    ensures\n        result >= 0,\n        result % 10 == 0,\n        result == sum_multiples_of_ten_spec(n),\n        (n == 0 || n < 10) ==> result == 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded_and_plausible\n\n    // Test cases:\n    // assert(sum_multiples_of_ten(10) == 10);\n    // assert(sum_multiples_of_ten(20) == 30);\n    // assert(sum_multiples_of_ten(100) == 550);\n}"}
{"id": "fvapps_000819", "vc-description": "The chef is trying to solve some pattern problems, Chef wants your help to code it. Chef has one number K(odd) to form a new pattern. Help the chef to code this pattern problem.\n\n-----Input:-----\n- First-line will contain $T$, the number of test cases. Then the test cases follow. \n- Each test case contains a single line of input, one integer $K$. \n\n-----Output:-----\nFor each test case, output as the pattern.\n\n-----Constraints-----\n- $1 \\leq T \\leq 50$\n- $1 \\leq K \\leq 50$\n\n-----Sample Input:-----\n4\n1\n3\n5\n7\n\n-----Sample Output:-----\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n\n-----EXPLANATION:-----\nNo need, else pattern can be decode easily.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn pattern_generator(k: usize) -> (result: Vec<String>)\n    requires k > 0,\n    ensures result.len() == k", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let test_result_1 = pattern_generator(1);\n    // println!(\"{:?}\", test_result_1);\n    \n    // let test_result_3 = pattern_generator(3);\n    // println!(\"{:?}\", test_result_3);\n    \n    // let test_result_5 = pattern_generator(5);\n    // println!(\"{:?}\", test_result_5);\n}"}
{"id": "fvapps_000820", "vc-description": "The Petrozavodsk camp takes place in about one month. Jafar wants to participate in the camp, but guess what? His coach is Yalalovichik.\nYalalovichik is a legendary coach, famous in the history of competitive programming. However, he is only willing to send to the camp students who solve really hard problems on Timus. The deadline that Yalalovichik set before has passed and he refuses to send Jafar to the camp.\nJafar decided to make Yalalovichik happy in hopes of changing his decision, so he invented a new sequence of numbers and named them Yalalovichik numbers. Jafar is writing a research paper about their properties and wants to publish it in the Science Eagle yearly journal.\nA Yalalovichik number is created in the following way:\n- Consider an integer $N$ in decimal notation; let's call it the base of the Yalalovichik number $Y_N$. $N$ may not contain the digit $0$.\n- Treat $N$ as a decimal string. Compute all left shifts of this string $N_0, N_1, \\ldots, N_{|N|-1}$ ($|N|$ denotes the number of digits of $N$); specifically, $N_k$ denotes the string formed by moving the first $k$ digits of $N$ to the end in the same order.\n- Concatenate the strings $N_0, N_1, \\ldots, N_{|N|-1}$. The resulting string is the decimal notation of $Y_N$.\nFor example, if $N = 123$, the left shifts are $123, 231, 312$ and thus $Y_N = 123231312$.\nYou are given the base $N$. Calculate the value of $Y_N$ modulo $10^9+7$.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first and only line of each test case contains a single decimal integer $N$.\n\n-----Output-----\nFor each test case, print a single line containing one integer — the value of the Yalalovichik number $Y_N$ modulo $10^9+7$.\n\n-----Constraints-----\n- $1 \\le T \\le 200$\n- $|N| \\le 10^5$\n- $N$ does not contain the digit $0$\n- the sum of $|N|$ over all test cases does not exceed $10^6$\n\n-----Example Input-----\n1\n123\n\n-----Example Output-----\n123231312", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "const MOD: u64 = 1000000007;\n\nfn solve_yalalovichik(s: Vec<u8>) -> (result: u64)\n    requires s.len() > 0,\n    ensures result < MOD", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded_and_plausible\n\n    // Expected: 123231312\n    // println!(\"{}\", solve_yalalovichik(b\"123\".to_vec()));\n\n    // Expected: 3443\n    // println!(\"{}\", solve_yalalovichik(b\"34\".to_vec()));\n\n    // Expected: 9\n    // println!(\"{}\", solve_yalalovichik(b\"9\".to_vec()));\n}"}
{"id": "fvapps_000821", "vc-description": "The chef is trying to solve some pattern problems, Chef wants your help to code it. Chef has one number K to form a new pattern. Help the chef to code this pattern problem.\n\n-----Input:-----\n- First-line will contain $T$, the number of test cases. Then the test cases follow. \n- Each test case contains a single line of input, one integer $K$. \n\n-----Output:-----\nFor each test case, output as the pattern.\n\n-----Constraints-----\n- $1 \\leq T \\leq 100$\n- $1 \\leq K \\leq 100$\n\n-----Sample Input:-----\n3\n5\n3\n4\n\n-----Sample Output:-----\n1   1\n2 2\n3\n4 4\n5   5\n1 1\n2\n3 3\n1  1\n22\n33\n4  4\n\n-----EXPLANATION:-----\nNo need, else pattern can be decode easily.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_pattern(k: usize) -> (result: Vec<String>)\n    requires k >= 2 && k <= 100,\n    ensures \n        result.len() == k,\n        forall|i: int| 0 <= i < k ==> result[i]@.len() > 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000822", "vc-description": "You are given N integer sequences A1, A2, ..., AN. Each of these sequences contains N elements. You should pick N elements, one from each sequence; let's denote the element picked from sequence Ai by Ei. For each i (2 ≤ i ≤ N), Ei should be strictly greater than Ei-1.\nCompute the maximum possible value of E1 + E2 + ... + EN. If it's impossible to pick the elements E1, E2, ..., EN, print -1 instead.\n\nInput:\n- The first line of the input contains a single integer T denoting the number of test cases. The description of T test cases follows.\n- The first line of each test case contains a single integer N.\n- N lines follow. For each valid i, the i-th of these lines contains N space-separated integers Ai1, Ai2, ..., AiN denoting the elements of the sequence Ai.\n\nOutput:\nFor each test case, print a single line containing one integer — the maximum sum of picked elements.\n\nConstraints:\n- 1 ≤ T ≤ 10\n- 1 ≤ N ≤ 700\n- 1 ≤ sum of N in all test-cases ≤ 3700\n- 1 ≤ Aij ≤ 109 for each valid i, j\n\nExample:\nInput:\n1\n3\n1 2 3\n4 5 6\n7 8 9\n\nOutput:\n18\n\nExplanation:\nExample case 1: To maximise the score, pick 3 from the first row, 6 from the second row and 9 from the third row. The resulting sum is E1+E2+E3 = 3+6+9 = 18.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn seq_sum(elements: Seq<i32>) -> int\n    decreases elements.len()\n{\n    if elements.len() == 0 {\n        0\n    } else {\n        elements[0] + seq_sum(elements.skip(1))\n    }\n}", "vc-spec": "fn solve_max_sequence_sum(n: usize, grid: Vec<Vec<i32>>) -> (result: i32)\n    requires \n        n > 0,\n        grid.len() == n,\n        forall|i: int| 0 <= i < grid.len() ==> #[trigger] grid[i].len() == n,\n        forall|i: int, j: int| 0 <= i < grid.len() && 0 <= j < grid[i].len() ==> -1000 <= grid[i][j] && grid[i][j] <= 1000,\n    ensures\n        result == -1 || (\n            exists|elements: Seq<i32>| \n                #[trigger] elements.len() == n &&\n                (forall|i: int, j: int| 0 <= i < j < n ==> #[trigger] elements[i] > #[trigger] elements[j]) &&\n                result == seq_sum(elements)\n        )", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000824", "vc-description": "Give me Biscuit\n\nSunny wants to make slices of biscuit of size c * d into identical pieces.\n\nbut each piece is a square having maximum possible side length with no left over piece of biscuit.\n\nInput Format\n\nThe first line contains an integer N.\n\nN lines follow. Each line contains two space separated integers c and d.\n\nwhich denote length and breadth of the biscuit.\n\nConstraints\n\n1 <= N <= 1000\n\n1 <= c,d <= 1000\nOutput Format\n\nN lines, each containing an integer that denotes the number of squares of maximum size, when the biscuit is cut as per the given condition.\n\nSample Input \n\n2\n\n2 2\n\n6 9\n\nSample Output \n\n1\n\n6\n\nExplanation \n\nThe 1st testcase has a biscuit whose original dimensions are 2 X 2, the biscuit is uncut and is a square.\n\nHence the answer is 1.\n\nThe 2nd testcase has a biscuit of size 6 X 9 . We can cut it into 54 squares of size 1 X 1 , 6 of size 3 X 3 . For other sizes we will have leftovers.\n\nHence, the number of squares of maximum size that can be cut is 6.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn number_of_squares(l: u32, w: u32) -> (result: u32)\n    requires \n        l > 0,\n        w > 0,\n    ensures \n        l == w ==> result == 1,\n        1 <= result,\n        result <= l * w,", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let test1 = number_of_squares(2, 2);\n    // assert(test1 == 1);\n    \n    // let test2 = number_of_squares(6, 9);\n    // assert(test2 == 6);\n    \n    // let test3 = number_of_squares(4, 6);\n    // assert(test3 == 6);\n}"}
{"id": "fvapps_000825", "vc-description": "Harry Potter has one biscuit and zero rupee in his pocket. He will perform the following operations exactly K times in total, in the order he likes:\n- Hit his pocket, which magically increases the number of biscuits by one.\n- Exchange A biscuits to 1 rupee.\n- Exchange 1 rupee to B biscuits.\nFind the maximum possible number of biscuits in Harry's pocket after K operations.\n\nInput is given in the following format:\nK A B\n\nPrint the maximum possible number of biscuits in Harry's pocket after K operations.\n\nConstraints:\n- 1 ≤ K, A, B ≤ 10^9\n- K, A and B are integers.\n\nSample Input:\n4 2 6\n\nSample Output:\n7\n\nEXPLANATION:\nThe number of biscuits in Harry's pocket after K operations is maximized as follows:\n- Hit his pocket. Now he has 2 biscuits and 0 rupee.\n- Exchange 2 biscuits to 1 rupee in his pocket. Now he has 0 biscuits and 1 rupee.\n- Hit his pocket. Now he has 1 biscuits and 1 rupee.\n- Exchange 1 rupee to 6 biscuits. his pocket. Now he has 7 biscuits and 0 rupee.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn harry_biscuits(k: u32, a: u32, b: u32) -> (result: u32)\n    requires a > 0 && b > 0,\n    ensures result >= 1", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = harry_biscuits(4, 2, 6);\n    // assert(result1 == 7);\n    // let result2 = harry_biscuits(3, 3, 4);\n    // assert(result2 == 4);\n    // let result3 = harry_biscuits(5, 2, 3);\n    // assert(result3 == 6);\n}"}
{"id": "fvapps_000826", "vc-description": "Did you know that the people of America eat around 100 acres of pizza per day ? Having read this fact on internet, two chefs from the Elephant city, Arjuna and Bhima are set to make pizza popular in India. They organized a social awareness camp, where N people ( other than these two ) sit around a large pizza. To make it more interesting, they make some pairs among these N people and the two persons in a pair, feed each other.\n\nEach person should be a part of at most one pair and most importantly, to make feeding easy, any two pairs should not cross each other ( see figure for more clarity ). Arjuna and Bhima decided to play a game on making the pairs. In his turn, a player makes a pair ( selects two persons, as long as its valid ) and this pair start feeding each other. Arjuna and Bhima take turns alternately, by making a pair in each turn, and they  play optimally ( see Notes for more clarity ). The one who can not make a pair in his turn, loses. Given N, find who wins the game, if Arjuna starts first. \n\nNotes:\n- 'Optimally' means, if there is a possible move a person can take in his turn that can make him win finally, he will always take that. You can assume both are very intelligent. \n\nInput:\nFirst line contains an integer T ( number of test cases, around 1000 ). Each of the next T lines contains an integer N ( 2 <= N <= 10000 )\n\nOutput:\nFor each test case, output the name of the winner ( either \"Arjuna\" or \"Bhima\" ( without quotes ) ) in a new line.\n\nExample:\nInput:\n4\n2\n4\n5\n6\n\nOutput:\nArjuna\nArjuna\nBhima\nArjuna\n\nExplanation:\n\nLet the people around the table are numbered 1, 2, ... , N in clock-wise order as shown in the image \n\nCase 1 : N = 2. Only two persons and Arjuna makes the only possible pair (1,2)\n\nCase 2 : N = 4. Arjuna can make the pair (1,3). Bhima can not make any more pairs ( without crossing the pair (1,3) )\n\nCase 3 : N = 5. No matter which pair Arjuna makes first, Bhima can always make one more pair, and Arjuna can not make any further", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn get_winner(n: nat) -> (result: &'static str)\n    requires 1 <= n && n <= 19,\n    ensures \n        result == \"Arjuna\" || result == \"Bhima\",\n        n == 2 ==> result == \"Arjuna\",\n        n == 3 ==> result == \"Arjuna\", \n        n == 4 ==> result == \"Arjuna\",\n        n == 7 ==> result == \"Arjuna\",\n        n == 8 ==> result == \"Arjuna\",\n        n == 1 ==> result == \"Bhima\",\n        n == 5 ==> result == \"Bhima\",\n        n == 9 ==> result == \"Bhima\"", "vc-code": "{\n    // impl-start\n    assume(false);\n    \"Arjuna\"\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000828", "vc-description": "We all know how great ABD aka AB-DE-VILLIERS is. However his team mates were jealous of him and posed a problem for him to solve.The problem description is as follows :\n\nGiven an array of integers,find the length of the largest subarray(contiguous) of the given array with the maximum possible GCD (Greatest Common Divisor).\n\nFor info on GCD ,see this link: https://en.wikipedia.org/wiki/Greatest_common_divisor\n\nGCD of the subarray is defined as the GCD of all the elements of the subarray.\nAs ABD is not aware of competitive programming he asks your help. Help him!\n\n-----Input-----\nFirst line will contain integer N denoting the size of array.\n\nSecond line will contain N integers denoting array elements.\n\n-----Output-----\nThe answer as specified in the problem statement .\n\n-----Constraints-----\n1 <= N <= 1000000\n\n1 <= array[i] <=100000000000\n\n-----Example-----\nInput:\n4\n2 4 8 3\n\nOutput:\n1\n\nExplanation\nGCD of all possible subarrays of the given array are : 2 , 2 , 2 , 1 , 4 , 4, 1 , 8 , 1 , 3\n\nLargest GCD possible : 8\n\nLength of the largest subarray with GCD as 8 is 1\n\nHence answer is 1 .", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn gcd(a: nat, b: nat) -> nat \n    decreases b\n{\n    if b == 0 {\n        a\n    } else {\n        gcd(b, a % b)\n    }\n}\n\nspec fn subarray_gcd(arr: Seq<nat>, start: int, end: int) -> nat \n    decreases end - start\n{\n    if start >= end || start < 0 || end > arr.len() {\n        0\n    } else if start + 1 == end {\n        arr[start]\n    } else {\n        gcd(arr[start], subarray_gcd(arr, start + 1, end))\n    }\n}\n\nfn find_largest_gcd_subarray(n: usize, arr: Vec<nat>) -> (result: usize)\n    requires \n        n > 0,\n        arr.len() == n,\n        forall|i: int| 0 <= i < n ==> arr[i] > 0\n    ensures\n        result > 0,\n        result <= n", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "}\n\nfn main() {\n    // println!(\"{}\", find_largest_gcd_subarray(4, vec![2, 4, 8, 3]));\n    // println!(\"{}\", find_largest_gcd_subarray(5, vec![10, 10, 10, 5, 5]));\n    // println!(\"{}\", find_largest_gcd_subarray(3, vec![6, 12, 6]));\n}"}
{"id": "fvapps_000830", "vc-description": "Mr. X has come up with a new string compression algorithm. Consider a string of length N which contains up to K distinct characters. The compression algorithm works as follows: Replace each maximal contiguous substring containing only one distinct character (repeated an arbitrary number of times) and replace it by 2 values: the character and the length of the substring.\nFor example, the string \"aabbaaa\" will be compressed to \"a, 2, b, 2, a, 3\". Thus the length of the compressed string is 6.\n\nSince Mr. X is living in advanced times, the length of any integer is considered to be 1. For example, if a string is compressed to \"a, 111, b, 13\", then its length after compression is considered to be 4.\n\nTo test his algorithm, he needs to know the expected length of the compressed string for given N and K if the input string is randomly uniformly chosen from all possibilities. He wants to run this experiment multiple times for different N, K and needs your help.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn calculate_compression_length(n: u32, k: u32) -> (result: u32)\n    requires \n        n > 0,\n        k > 0,\n    ensures \n        result > 0,\n        result <= 2 * n,\n        n == 1 ==> result == 2,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000831", "vc-description": "The chef is trying to decode some pattern problems, Chef wants your help to code it. Chef has one number K to form a new pattern. Help the chef to code this pattern problem.\n\n-----Input:-----\n- First-line will contain $T$, the number of test cases. Then the test cases follow. \n- Each test case contains a single line of input, one integer $K$. \n\n-----Output:-----\nFor each test case, output as the pattern.\n\n-----Constraints-----\n- $1 \\leq T \\leq 100$\n- $1 \\leq K \\leq 100$\n\n-----Sample Input:-----\n4\n1\n2\n3\n4\n\n-----Sample Output:-----\n0\n01\n10\n010\n101\n010\n0101\n1010\n0101\n1010\n\n-----EXPLANATION:-----\nNo need, else pattern can be decode easily.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn generate_pattern(k: usize) -> (result: Vec<Vec<char>>)\n    requires k > 0,\n    ensures\n        result.len() == k,\n        forall|i: int| 0 <= i < k ==> #[trigger] result[i].len() == k,\n        forall|i: int, j: int| 0 <= i < k && 0 <= j < k ==> \n            (#[trigger] result[i][j] == '0' || #[trigger] result[i][j] == '1'),\n        forall|i: int, j: int| 0 <= i < k && 0 <= j < k ==> \n            #[trigger] result[i][j] == (if (i + j) % 2 == 0 { '0' } else { '1' }),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000832", "vc-description": "A beautiful sequence is defined as a sequence that do not have any repeating elements in it.\nYou will be given any random sequence of integers, and you have to tell whether it is a beautiful sequence or not. \n\n-----Input:-----\n- The first line of the input contains a single integer $T$. $T$ denoting the number of test cases. The description of $T$ test cases is as follows.\n- The next line of the input contains a single integer $N$. $N$ denotes the total number of elements in the sequence.\n- The next line of the input contains $N$ space-separated integers $A1, A2, A3...An$ denoting the sequence.\n\n-----Output:-----\n- Print \"prekrasnyy\"(without quotes) if the given sequence is a beautiful sequence, else print \"ne krasivo\"(without quotes)\nNote: each test case output must be printed on new line\n\n-----Constraints:-----\n- $1 \\leq T \\leq 10^2$\n- $1 \\leq N \\leq 10^3$\n- $1 \\leq A1, A2, A3...An \\leq 10^5$\n\n-----Sample Input:-----\n2\n4\n1 2 3 4\n6\n1 2 3 5 1 4\n\n-----Sample Output:-----\nprekrasnyy\nne krasivo\n\n-----Explanation:-----\n- \nAs 1st sequence do not have any elements repeating, hence it is a beautiful sequence\n- \nAs in 2nd sequence the element 1 is repeated twice, hence it is not a beautiful sequence", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn check_sequence(n: usize, arr: Vec<i32>) -> (result: String)\n    requires \n        n > 0,\n        arr.len() > 0,\n    ensures \n        result@ == \"prekrasnyy\"@ || result@ == \"ne krasivo\"@,\n        result@ == \"prekrasnyy\"@ ==> forall|i: int, j: int| \n            0 <= i < arr.len() && 0 <= j < arr.len() && i != j ==> arr[i] != arr[j],\n        result@ == \"ne krasivo\"@ ==> exists|i: int, j: int| \n            0 <= i < arr.len() && 0 <= j < arr.len() && i != j && arr[i] == arr[j],\n        arr.len() == 1 ==> result@ == \"prekrasnyy\"@,", "vc-code": "{\n    // impl-start\n    assume(false);\n    \"prekrasnyy\".to_string()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let result1 = check_sequence(4, vec![1, 2, 3, 4]);\n    // println!(\"{}\", result1); // Should print \"prekrasnyy\"\n    \n    // let result2 = check_sequence(6, vec![1, 2, 3, 5, 1, 4]);\n    // println!(\"{}\", result2); // Should print \"ne krasivo\"\n    \n    // let result3 = check_sequence(1, vec![1]);\n    // println!(\"{}\", result3); // Should print \"prekrasnyy\"\n}"}
{"id": "fvapps_000833", "vc-description": "Accepts a string from the user and print the reverse string as the output without using any built-in function.\n\n-----Input:-----\nEach testcase contains of a single line of input, a string.\n\n-----Output:-----\nFor each testcase, output in a single line answer, the reverse string.\n\n-----Sample Input:-----\n1\nTracy\n\n-----Sample Output:-----\nycarT", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn reverse_string(s: &str) -> (result: String)\n    ensures \n        result@.len() == s@.len(),\n        forall|i: int| 0 <= i < s@.len() ==> result@[i] == s@[s@.len() - 1 - i]", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let result1 = reverse_string(\"Tracy\");\n    // println!(\"{}\", result1);\n    // \n    // let result2 = reverse_string(\"Hello\");\n    // println!(\"{}\", result2);\n    // \n    // let result3 = reverse_string(\"Python\");\n    // println!(\"{}\", result3);\n}"}
{"id": "fvapps_000834", "vc-description": "You are given a dataset consisting of N items. Each item is a pair of a word and a boolean denoting whether the given word is a spam word or not.\nWe want to use this dataset for training our latest machine learning model. Thus we want to choose some subset of this dataset as training dataset. We want to make sure that there are no contradictions in our training set, i.e. there shouldn't be a word included in the training set that's marked both as spam and not-spam. For example item {\"fck\", 1}, and item {\"fck, 0\"} can't be present in the training set, because first item says the word \"fck\" is a spam, whereas the second item says it is not, which is a contradiction.\nYour task is to select the maximum number of items in the training set.\nNote that same pair of {word, bool} can appear multiple times in input. The training set can also contain the same pair multiple times.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn make_word_label(word: String, label: String) -> (result: String)\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n\nfn solve_spam_dataset(cases: Vec<Vec<String>>) -> (result: Vec<nat>)\n    ensures result.len() == cases.len()", "vc-code": "{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let test1 = vec![/* test case 1 data */];\n    // let test2 = vec![/* test case 2 data */];\n    // let test3 = vec![/* test case 3 data */];\n    // \n    // let result1 = solve_spam_dataset(vec![test1]);\n    // let result2 = solve_spam_dataset(vec![test2]);\n    // let result3 = solve_spam_dataset(vec![test3]);\n    // \n    // println!(\"Results: {:?}, {:?}, {:?}\", result1, result2, result3);\n}"}
{"id": "fvapps_000836", "vc-description": "For Diwali, Chef arranges all K laddus in a row in his sweet shop. Whenever a customer comes to buy laddus, chef follows a rule that each customer must buy all laddus on odd position. After the selection of the laddu, a new row is formed, and again out of these only laddus on odd position are selected. This continues until the chef left with the last laddu. Find out the position of that last laddu in the original row.\n\nInput:\n- First line will contain T, number of testcases. Then the testcases follow. \n- Each testcase contains of a single line of input, one integer K. \n\nOutput:\nFor each testcase, print the position of that laddu who is left, in the original row.\n\nConstraints:\n- 1 ≤ T ≤ 10^5\n- 1 ≤ K ≤ 10^5\n\nSample Input:\n3\n1\n5\n8\n\nSample Output:\n1\n4\n8\n\nEXPLANATION:\nFor 1) Only one laddu which is last so print 1.\nFor 2) Customer 1: [1, 3, 5]\nNew row = [2, 4]\n\nCustomer 2: [2]\n\nLast laddu = 4", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn find_last_laddu(n: nat) -> (result: nat)\n    requires n > 0,\n    ensures \n        0 < result && result <= n,\n        2 * result > n,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // #eval find_last_laddu 1\n    // #eval find_last_laddu 5  \n    // #eval find_last_laddu 8\n}"}
{"id": "fvapps_000027", "vc-description": "There are n positive integers a_1, a_2, ..., a_n. For the one move you can choose any even value c and divide by two all elements that equal c.\n\nFor example, if a=[6,8,12,6,3,12] and you choose c=6, and a is transformed into a=[3,8,12,3,3,12] after the move.\n\nYou need to find the minimal number of moves for transforming a to an array of only odd integers (each element shouldn't be divisible by 2).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn count_trailing_zeros(n: u32) -> u32 \n    decreases n\n{\n    if n % 2 == 1 {\n        0u32\n    } else {\n        1u32 + count_trailing_zeros(n / 2)\n    }\n}\n\nfn min_moves_to_odd(arrays: Vec<Vec<u32>>) -> (result: Vec<u32>)\n    ensures \n        result.len() == arrays.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] >= 0\n{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}\n\nfn count_trailing_zeros_fn(n: u32) -> (result: u32)\n    ensures result == count_trailing_zeros(n)\n{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-code": "", "vc-postamble": "\n}\nfn main() {\n    // let test1 = vec![vec![40, 6, 40, 3, 20, 1]];\n    // let result1 = min_moves_to_odd(test1);\n    // assert_eq!(result1, vec![4]);\n\n    // let test2 = vec![vec![1024]];\n    // let result2 = min_moves_to_odd(test2);\n    // assert_eq!(result2, vec![10]);\n\n    // let test3 = vec![vec![2, 4, 8, 16]];\n    // let result3 = min_moves_to_odd(test3);\n    // assert_eq!(result3, vec![4]);\n\n    // let test4 = vec![vec![3, 1, 7]];\n    // let result4 = min_moves_to_odd(test4);\n    // assert_eq!(result4, vec![0]);\n}"}
{"id": "fvapps_000028", "vc-description": "Acacius is studying strings theory. Today he came with the following problem.\n\nYou are given a string $s$ of length $n$ consisting of lowercase English letters and question marks. It is possible to replace question marks with lowercase English letters in such a way that a string \"abacaba\" occurs as a substring in a resulting string exactly once?\n\nEach question mark should be replaced with exactly one lowercase English letter. For example, string \"a?b?c\" can be transformed into strings \"aabbc\" and \"azbzc\", but can't be transformed into strings \"aabc\", \"a?bbc\" and \"babbc\".\n\nOccurrence of a string $t$ of length $m$ in the string $s$ of length $n$ as a substring is a index $i$ ($1 \\leq i \\leq n - m + 1$) such that string $s[i..i+m-1]$ consisting of $m$ consecutive symbols of $s$ starting from $i$-th equals to string $t$. For example string \"ababa\" has two occurrences of a string \"aba\" as a substring with $i = 1$ and $i = 3$, but there are no occurrences of a string \"aba\" in the string \"acba\" as a substring.\n\nPlease help Acacius to check if it is possible to replace all question marks with lowercase English letters in such a way that a string \"abacaba\" occurs as a substring in a resulting string exactly once.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn check_abacaba_substring(s: &Vec<char>) -> (result: usize)\n    ensures result >= 0\n{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}\n\nfn find_abacaba_substring(n: usize, s: &Vec<char>) -> (result: (bool, Vec<char>))\n    requires s.len() == n\n{\n    // impl-start\n    assume(false);\n    (false, Vec::new())\n    // impl-end\n}", "vc-code": "{\n    // impl-start\n    assume(false);\n    (false, Vec::new())\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: unguarded\n}"}
{"id": "fvapps_000032", "vc-description": "Lately, Mr. Chanek frequently plays the game Arena of Greed. As the name implies, the game's goal is to find the greediest of them all, who will then be crowned king of Compfestnesia.\n\nThe game is played by two people taking turns, where Mr. Chanek takes the first turn. Initially, there is a treasure chest containing N gold coins. The game ends if there are no more gold coins in the chest. In each turn, the players can make one of the following moves: Take one gold coin from the chest. Take half of the gold coins on the chest. This move is only available if the number of coins in the chest is even.\n\nBoth players will try to maximize the number of coins they have. Mr. Chanek asks your help to find the maximum number of coins he can get at the end of the game if both he and the opponent plays optimally.", "vc-preamble": "use vstd::prelude::*;\nuse vstd::arithmetic::power::pow;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_pow2(n: nat) -> bool {\n    exists|k: nat| n == pow(2, k)\n}\n\nfn solve_arena_of_greed(n: nat) -> (result: nat)\n    requires n > 0,\n    ensures \n        result <= n,\n        result <= (n + 1) / 2 + n / 2,", "vc-code": "{\n    // impl-start\n    assume(false);\n    0nat\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded_and_plausible\n    \n    // Example test cases:\n    // solve_arena_of_greed(5) should return 2\n    // solve_arena_of_greed(6) should return 4  \n    // solve_arena_of_greed(8) should return 5\n}"}
{"id": "fvapps_000040", "vc-description": "You are given a sequence $a_1, a_2, \\dots, a_n$, consisting of integers.\n\nYou can apply the following operation to this sequence: choose some integer $x$ and move all elements equal to $x$ either to the beginning, or to the end of $a$. Note that you have to move all these elements in one direction in one operation.\n\nFor example, if $a = [2, 1, 3, 1, 1, 3, 2]$, you can get the following sequences in one operation (for convenience, denote elements equal to $x$ as $x$-elements):   $[1, 1, 1, 2, 3, 3, 2]$ if you move all $1$-elements to the beginning;  $[2, 3, 3, 2, 1, 1, 1]$ if you move all $1$-elements to the end;  $[2, 2, 1, 3, 1, 1, 3]$ if you move all $2$-elements to the beginning;  $[1, 3, 1, 1, 3, 2, 2]$ if you move all $2$-elements to the end;  $[3, 3, 2, 1, 1, 1, 2]$ if you move all $3$-elements to the beginning;  $[2, 1, 1, 1, 2, 3, 3]$ if you move all $3$-elements to the end; \n\nYou have to determine the minimum number of such operations so that the sequence $a$ becomes sorted in non-descending order. Non-descending order means that for all $i$ from $2$ to $n$, the condition $a_{i-1} \\le a_i$ is satisfied.\n\nNote that you have to answer $q$ independent queries.\n\n-----Input-----\n\nThe first line contains one integer $q$ ($1 \\le q \\le 3 \\cdot 10^5$) — the number of the queries. Each query is represented by two consecutive lines.\n\nThe first line of each query contains one integer $n$ ($1 \\le n \\le 3 \\cdot 10^5$) — the number of elements.\n\nThe second line of each query contains $n$ integers $a_1, a_2, \\dots , a_n$ ($1 \\le a_i \\le n$) — the elements.\n\nIt is guaranteed that the sum of all $n$ does not exceed $3 \\cdot 10^5$.\n\n-----Output-----\n\nFor each query print one integer — the minimum number of operation for sorting sequence $a$ in non-descending order.\n\n-----Example-----\nInput\n3\n7\n3 1 6 6 3 1 1\n8\n1 1 4 4 4 7 8 8\n7\n4 2 5 2 6 2 7\n\nOutput\n2\n0\n1\n\n-----Note-----\n\nIn the first query, you can move all $1$-elements to the beginning (after that sequence turn into $[1, 1, 1, 3, 6, 6, 3]$) and then move all $6$-elements to the end.\n\nIn the second query, the sequence is sorted initially, so the answer is zero.\n\nIn the third query, you have to move all $2$-elements to the beginning.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_sorted(arr: Seq<u32>) -> bool {\n    forall|i: int| 0 <= i < arr.len() - 1 ==> arr[i] <= arr[i + 1]\n}\n\nspec fn count_distinct_elems(arr: Seq<u32>) -> nat {\n    if arr.len() == 0 {\n        0\n    } else {\n        1  /* simplified spec function for distinct element count */\n    }\n}\n\nfn min_ops_to_sort(arr: Vec<u32>) -> (result: u32)\n    ensures \n        result >= 0,\n        is_sorted(arr@) ==> result == 0,\n        result <= count_distinct_elems(arr@),\n        arr.len() == 1 ==> result == 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let test1 = vec![3, 1, 6, 6, 3, 1, 1];\n    // println!(\"{}\", min_ops_to_sort(test1));\n    \n    // let test2 = vec![1, 1, 4, 4, 4, 7, 8, 8];\n    // println!(\"{}\", min_ops_to_sort(test2));\n    \n    // let test3 = vec![4, 2, 5, 2, 6, 2, 7];\n    // println!(\"{}\", min_ops_to_sort(test3));\n}"}
{"id": "fvapps_000134", "vc-description": "In a 2 dimensional array grid, each value grid[i][j] represents the height of a building located there. We are allowed to increase the height of any number of buildings, by any amount (the amounts can be different for different buildings). Height 0 is considered to be a building as well. \nAt the end, the \"skyline\" when viewed from all four directions of the grid, i.e. top, bottom, left, and right, must be the same as the skyline of the original grid. A city's skyline is the outer contour of the rectangles formed by all the buildings when viewed from a distance. See the following example.\nWhat is the maximum total sum that the height of the buildings can be increased?\nExample:\nInput: grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]\nOutput: 35\nExplanation: \nThe grid is:\n[ [3, 0, 8, 4], \n  [2, 4, 5, 7],\n  [9, 2, 6, 3],\n  [0, 3, 1, 0] ]\n\nThe skyline viewed from top or bottom is: [9, 4, 8, 7]\nThe skyline viewed from left or right is: [8, 7, 9, 3]\n\nThe grid after increasing the height of buildings without affecting skylines is:\n\ngridNew = [ [8, 4, 8, 7],\n            [7, 4, 7, 7],\n            [9, 4, 8, 7],\n            [3, 3, 3, 3] ]\n\nNotes: \n\n1 < grid.length = grid[0].length <= 50.\nAll heights grid[i][j] are in the range [0, 100].\nAll buildings in grid[i][j] occupy the entire grid cell: that is, they are a 1 x 1 x grid[i][j] rectangular prism.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn max_increase_keeping_skyline(grid: Vec<Vec<nat>>) -> (result: nat)\n    requires \n        grid.len() > 0,\n        grid[0].len() > 0,\n        forall|i: int| 0 <= i < grid.len() ==> grid[i]@.len() == grid[0]@.len(),\n    ensures result >= 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "proof fn uniform_grid_theorem(n: nat, v: nat)\n    requires n > 0,\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn diagonal_grid_theorem(n: nat)\n    requires n > 0,\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn example_case_theorem()\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\n}\n\nfn main() {\n    // println!(\"Test case 1: {:?}\", max_increase_keeping_skyline(vec![vec![3, 0, 8, 4], vec![2, 4, 5, 7], vec![9, 2, 6, 3], vec![0, 3, 1, 0]]));\n    // println!(\"Test case 2: {:?}\", max_increase_keeping_skyline(vec![vec![5]]));\n    // println!(\"Test case 3: {:?}\", max_increase_keeping_skyline(vec![vec![1, 2], vec![2, 1]]));\n}"}
{"id": "fvapps_000143", "vc-description": "You have 4 cards each containing a number from 1 to 9.  You need to judge whether they could operated through *, /, +, -, (, ) to get the value of 24.\n\nExample 1:\n\nInput: [4, 1, 8, 7]\nOutput: True\nExplanation: (8-4) * (7-1) = 24\n\nExample 2:\n\nInput: [1, 2, 1, 2]\nOutput: False\n\nNote:\n\nThe division operator / represents real division, not integer division.  For example, 4 / (1 - 2/3) = 12.\nEvery operation done is between two numbers.  In particular, we cannot use - as a unary operator.  For example, with [1, 1, 1, 1] as input, the expression -1 - 1 - 1 - 1 is not allowed.\nYou cannot concatenate numbers together.  For example, if the input is [1, 2, 1, 2], we cannot write this as 12 + 12.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn judge_point24_spec(nums: Seq<u32>) -> bool {\n    true\n}\n\nfn judge_point24(nums: Vec<u32>) -> (result: bool)\n    requires \n        nums.len() == 4,\n        forall|i: int| 0 <= i < nums.len() ==> 1 <= nums[i] <= 9,\n    ensures \n        result == judge_point24_spec(nums@),", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\nproof fn judge_point24_permutation_invariant_proof(nums1: Vec<u32>, nums2: Vec<u32>)\n    requires \n        nums1.len() == 4,\n        nums2.len() == 4,\n        forall|i: int| 0 <= i < nums1.len() ==> 1 <= nums1[i] <= 9,\n        forall|i: int| 0 <= i < nums2.len() ==> 1 <= nums2[i] <= 9,\n        nums1@.to_multiset() == nums2@.to_multiset(),\n    ensures judge_point24_spec(nums1@) == judge_point24_spec(nums2@)\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn judge_point24_all_ones_impossible_proof(nums: Vec<u32>)\n    requires \n        nums.len() == 4,\n        forall|i: int| 0 <= i < nums.len() ==> nums[i] <= 1,\n    ensures judge_point24_spec(nums@) == false\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn judge_point24_with_24_and_ones_proof(nums: Vec<u32>)\n    requires \n        nums.len() == 4,\n        exists|i: int| 0 <= i < nums.len() && nums[i] == 24,\n        nums@.filter(|x| x == 1).len() == 3,\n    ensures judge_point24_spec(nums@) == true\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\n}\nfn main() {\n    // let result1 = judge_point24(vec![4, 1, 8, 7]);\n    // println!(\"Result for [4, 1, 8, 7]: {}\", result1);\n    \n    // let result2 = judge_point24(vec![1, 2, 1, 2]);\n    // println!(\"Result for [1, 2, 1, 2]: {}\", result2);\n    \n    // let result3 = judge_point24(vec![3, 3, 8, 8]);\n    // println!(\"Result for [3, 3, 8, 8]: {}\", result3);\n}"}
{"id": "fvapps_000145", "vc-description": "There are n engineers numbered from 1 to n and two arrays: speed and efficiency, where speed[i] and efficiency[i] represent the speed and efficiency for the i-th engineer respectively. Return the maximum performance of a team composed of at most k engineers, since the answer can be a huge number, return this modulo 10^9 + 7.\nThe performance of a team is the sum of their engineers' speeds multiplied by the minimum efficiency among their engineers. \n\nExample 1:\nInput: n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 2\nOutput: 60\nExplanation: \nWe have the maximum performance of the team by selecting engineer 2 (with speed=10 and efficiency=4) and engineer 5 (with speed=5 and efficiency=7). That is, performance = (10 + 5) * min(4, 7) = 60.\n\nExample 2:\nInput: n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 3\nOutput: 68\nExplanation:\nThis is the same example as the first but k = 3. We can select engineer 1, engineer 2 and engineer 5 to get the maximum performance of the team. That is, performance = (2 + 10 + 5) * min(5, 4, 7) = 68.\n\nExample 3:\nInput: n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 4\nOutput: 72\n\nConstraints:\n\n1 <= n <= 10^5\nspeed.length == n\nefficiency.length == n\n1 <= speed[i] <= 10^5\n1 <= efficiency[i] <= 10^8\n1 <= k <= n", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "const MOD: u64 = 1000000007;\n\nfn max_performance(n: u32, speeds: Vec<u32>, efficiencies: Vec<u32>, k: u32) -> (result: u64)\n    requires \n        n > 0,\n        speeds.len() == n,\n        efficiencies.len() == n,\n        k > 0,\n        k <= n,\n        forall|i: int| 0 <= i < speeds.len() ==> speeds[i] >= 1 && speeds[i] <= 100000,\n        forall|i: int| 0 <= i < efficiencies.len() ==> efficiencies[i] >= 1 && efficiencies[i] <= 100000000,\n    ensures \n        result < MOD,\n        exists|max_single: u64| max_single == \n            (forall|i: int| 0 <= i < speeds.len() ==> \n                (speeds[i] as u64) * (efficiencies[i] as u64) <= max_single) &&\n            (exists|j: int| 0 <= j < speeds.len() && \n                (speeds[j] as u64) * (efficiencies[j] as u64) == max_single) &&\n            result >= max_single,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = max_performance(6, vec![2, 10, 3, 1, 5, 8], vec![5, 4, 3, 9, 7, 2], 2);\n    // println!(\"Result 1: {}\", result1); // Expected: 60\n\n    // let result2 = max_performance(6, vec![2, 10, 3, 1, 5, 8], vec![5, 4, 3, 9, 7, 2], 3);\n    // println!(\"Result 2: {}\", result2); // Expected: 68\n\n    // let result3 = max_performance(6, vec![2, 10, 3, 1, 5, 8], vec![5, 4, 3, 9, 7, 2], 4);\n    // println!(\"Result 3: {}\", result3); // Expected: 72\n}"}
{"id": "fvapps_000165", "I see the issue. The function declaration in Verus needs to be properly structured. Let me fix the syntax": null, "vc-description": "Given a string s and an integer k. You should construct k non-empty palindrome strings using all the characters in s.\nReturn True if you can use all the characters in s to construct k palindrome strings or False otherwise.\n\nExample 1:\nInput: s = \"annabelle\", k = 2\nOutput: true\nExplanation: You can construct two palindromes using all characters in s.\nSome possible constructions \"anna\" + \"elble\", \"anbna\" + \"elle\", \"anellena\" + \"b\"\n\nExample 2:\nInput: s = \"leetcode\", k = 3\nOutput: false\nExplanation: It is impossible to construct 3 palindromes using all the characters of s.\n\nExample 3:\nInput: s = \"true\", k = 4\nOutput: true\nExplanation: The only possible solution is to put each character in a separate string.\n\nExample 4:\nInput: s = \"yzyzyzyzyzyzyzy\", k = 2\nOutput: true\nExplanation: Simply you can put all z's in one string and all y's in the other string. Both strings will be palindrome.\n\nExample 5:\nInput: s = \"cr\", k = 7\nOutput: false\nExplanation: We don't have enough characters in s to construct 7 palindromes.\n\nConstraints:\n\n1 <= s.length <= 10^5\nAll characters in s are lower-case English letters.\n1 <= k <= 10^5", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn char_count(s: Seq<char>, c: char) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        (if s[0] == c { 1 } else { 0 }) + char_count(s.skip(1), c)\n    }\n}\n\nspec fn count_odd_chars(s: Seq<char>) -> nat\n{\n    0  // Placeholder implementation\n}\n\nfn can_construct_palindromes(s: &str, k: i32) -> (result: bool)\n    requires \n        s.len() > 0,\n        k >= 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let result1 = can_construct_palindromes(\"annabelle\", 2);\n    // println!(\"Result 1: {}\", result1);\n    \n    // let result2 = can_construct_palindromes(\"leetcode\", 3);\n    // println!(\"Result 2: {}\", result2);\n    \n    // let result3 = can_construct_palindromes(\"yzyzyzyzyzyzyzy\", 2);\n    // println!(\"Result 3: {}\", result3);\n}"}
{"id": "fvapps_000210", "vc-description": "Given an array nums of integers, a move consists of choosing any element and decreasing it by 1.\nAn array A is a zigzag array if either:\n\nEvery even-indexed element is greater than adjacent elements, ie. A[0] > A[1] < A[2] > A[3] < A[4] > ...\nOR, every odd-indexed element is greater than adjacent elements, ie. A[0] < A[1] > A[2] < A[3] > A[4] < ...\n\nReturn the minimum number of moves to transform the given array nums into a zigzag array.\n\nExample 1:\nInput: nums = [1,2,3]\nOutput: 2\nExplanation: We can decrease 2 to 0 or 3 to 1.\n\nExample 2:\nInput: nums = [9,6,1,6,2]\nOutput: 4\n\nConstraints:\n\n1 <= nums.length <= 1000\n1 <= nums[i] <= 1000", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn moves_to_make_zigzag(nums: Vec<nat>) -> (result: nat)\n    ensures result >= 0,\n    ensures nums.len() == 1 ==> result == 0,\n    ensures result == 0 && nums.len() >= 2 ==> (\n        forall|i: int| 1 <= i < nums.len() - 1 ==> (\n            (nums[i] > nums[i-1] && nums[i] > nums[i+1]) ||\n            (nums[i] < nums[i-1] && nums[i] < nums[i+1])\n        )\n    )\n\nproof fn moves_nonnegative(nums: Vec<nat>)\n    ensures moves_to_make_zigzag(nums) >= 0\n\nproof fn single_element_zero(nums: Vec<nat>)\n    requires nums.len() == 1\n    ensures moves_to_make_zigzag(nums) == 0\n\nproof fn zigzag_no_moves(nums: Vec<nat>, i: nat)\n    requires nums.len() >= 2,\n    requires moves_to_make_zigzag(nums) == 0,\n    requires 1 <= i < nums.len() - 1\n    ensures (nums[i] > nums[i-1] && nums[i] > nums[i+1]) ||\n            (nums[i] < nums[i-1] && nums[i] < nums[i+1])\n\nspec fn reverse_vec(nums: Seq<nat>) -> Seq<nat>\n    decreases nums.len()\n{\n    if nums.len() == 0 {\n        seq![]\n    } else {\n        reverse_vec(nums.drop_last()).push(nums[nums.len() - 1])\n    }\n}\n\nproof fn symmetric_solution(nums: Vec<nat>)\n    ensures moves_to_make_zigzag(nums) == moves_to_make_zigzag(reverse_vec(nums@).to_vec())", "vc-code": "{\n    // impl-start\n    assume(false);\n    0nat\n    // impl-end\n}\n\n{\n    // impl-start\n    assume(false);\n    // impl-end\n}\n\n{\n    // impl-start\n    assume(false);\n    // impl-end\n}\n\n{\n    // impl-start\n    assume(false);\n    // impl-end\n}\n\n{\n    // impl-start\n    assume(false);\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: unguarded\n\n    // Example usage (commented out for verification):\n    // let result1 = moves_to_make_zigzag(vec![1, 2, 3]);\n    // assert_eq!(result1, 2);\n    \n    // let result2 = moves_to_make_zigzag(vec![9, 6, 1, 6, 2]);\n    // assert_eq!(result2, 4);\n    \n    // let result3 = moves_to_make_zigzag(vec![1]);\n    // assert_eq!(result3, 0);\n}"}
{"id": "fvapps_000218", "vc-description": "A sequence X_1, X_2, ..., X_n is fibonacci-like if:\n\nn >= 3\nX_i + X_{i+1} = X_{i+2} for all i + 2 <= n\n\nGiven a strictly increasing array A of positive integers forming a sequence, find the length of the longest fibonacci-like subsequence of A.  If one does not exist, return 0.\n(Recall that a subsequence is derived from another sequence A by deleting any number of elements (including none) from A, without changing the order of the remaining elements.  For example, [3, 5, 8] is a subsequence of [3, 4, 5, 6, 7, 8].)\n\nExample 1:\nInput: [1,2,3,4,5,6,7,8]\nOutput: 5\nExplanation:\nThe longest subsequence that is fibonacci-like: [1,2,3,5,8].\n\nExample 2:\nInput: [1,3,7,11,12,14,18]\nOutput: 3\nExplanation:\nThe longest subsequence that is fibonacci-like:\n[1,11,12], [3,11,14] or [7,11,18].\n\nNote:\n\n3 <= A.length <= 1000\n1 <= A[0] < A[1] < ... < A[A.length - 1] <= 10^9\n(The time limit has been reduced by 50% for submissions in Java, C, and C++.)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn len_longest_fib_subseq(a: Vec<u32>) -> (result: u32)\n    requires \n        a.len() >= 3,\n        sorted(a@),\n        forall|i: int| 0 <= i < a.len() ==> a[i] > 0,\n    ensures \n        result == 0 || (result >= 3 && result <= a.len())", "vc-code": "{\n    // impl-start\n    assume(false);\n    0u32\n    // impl-end\n}", "vc-postamble": "}\n\nfn main() {\n    // let result1 = len_longest_fib_subseq(vec![1, 2, 3, 4, 5, 6, 7, 8]);\n    // println!(\"{}\", result1); // Expected: 5\n    \n    // let result2 = len_longest_fib_subseq(vec![1, 3, 7, 11, 12, 14, 18]);\n    // println!(\"{}\", result2); // Expected: 3\n    \n    // let result3 = len_longest_fib_subseq(vec![1, 2, 4, 8]);\n    // println!(\"{}\", result3); // Expected: 0\n}"}
{"id": "fvapps_000260", "vc-description": "Evaluate the value of an arithmetic expression in Reverse Polish Notation.\n\nValid operators are +, -, *, /. Each operand may be an integer or another expression.\n\nNote:\n\n       Division between two integers should truncate toward zero.\n       The given RPN expression is always valid. That means the expression would always evaluate to a result and there won't be any divide by zero operation.\n\nExample 1:\n\nInput: [\"2\", \"1\", \"+\", \"3\", \"*\"]\nOutput: 9\nExplanation: ((2 + 1) * 3) = 9\n\nExample 2:\n\nInput: [\"4\", \"13\", \"5\", \"/\", \"+\"]\nOutput: 6\nExplanation: (4 + (13 / 5)) = 6\n\nExample 3:\n\nInput: [\"10\", \"6\", \"9\", \"3\", \"+\", \"-11\", \"*\", \"/\", \"*\", \"17\", \"+\", \"5\", \"+\"]\nOutput: 22\nExplanation: \n  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n= ((10 * (6 / (12 * -11))) + 17) + 5\n= ((10 * (6 / -132)) + 17) + 5\n= ((10 * 0) + 17) + 5\n= (0 + 17) + 5\n= 17 + 5\n= 22", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn eval_rpn(tokens: Seq<String>) -> int\n{\n    0\n}\n\nfn eval_rpn_exec(tokens: Vec<String>) -> (result: i32)", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "/* Apps difficulty: interview */\n/* Assurance level: guarded */\n\nproof fn eval_rpn_empty()\n    ensures eval_rpn(seq![]) == 0\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn eval_rpn_single_positive()\n    ensures eval_rpn(seq![\"5\".to_string()]) == 5\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn eval_rpn_single_negative()\n    ensures eval_rpn(seq![\"-5\".to_string()]) == -5\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn eval_rpn_addition()\n    ensures eval_rpn(seq![\"3\".to_string(), \"2\".to_string(), \"+\".to_string()]) == 5\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn eval_rpn_subtraction()\n    ensures eval_rpn(seq![\"3\".to_string(), \"2\".to_string(), \"-\".to_string()]) == 1\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn eval_rpn_multiplication()\n    ensures eval_rpn(seq![\"3\".to_string(), \"2\".to_string(), \"*\".to_string()]) == 6\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn eval_rpn_division()\n    ensures eval_rpn(seq![\"6\".to_string(), \"2\".to_string(), \"/\".to_string()]) == 3\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn eval_rpn_negative_division_1()\n    ensures eval_rpn(seq![\"6\".to_string(), \"-2\".to_string(), \"/\".to_string()]) == -3\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn eval_rpn_negative_division_2()\n    ensures eval_rpn(seq![\"-6\".to_string(), \"2\".to_string(), \"/\".to_string()]) == -3\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn eval_rpn_negative_multiplication()\n    ensures eval_rpn(seq![\"-2\".to_string(), \"-3\".to_string(), \"*\".to_string()]) == 6\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn eval_rpn_negative_addition()\n    ensures eval_rpn(seq![\"-1\".to_string(), \"1\".to_string(), \"+\".to_string()]) == 0\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn eval_rpn_complex_1()\n    ensures eval_rpn(seq![\"2\".to_string(), \"1\".to_string(), \"+\".to_string(), \"3\".to_string(), \"*\".to_string()]) == 9\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn eval_rpn_complex_2()\n    ensures eval_rpn(seq![\"4\".to_string(), \"13\".to_string(), \"5\".to_string(), \"/\".to_string(), \"+\".to_string()]) == 6\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\n}\n\nfn main() {\n    // println!(\"{}\", eval_rpn_exec(vec![\"2\".to_string(), \"1\".to_string(), \"+\".to_string(), \"3\".to_string(), \"*\".to_string()]));\n    // println!(\"{}\", eval_rpn_exec(vec![\"4\".to_string(), \"13\".to_string(), \"5\".to_string(), \"/\".to_string(), \"+\".to_string()]));\n    // println!(\"{}\", eval_rpn_exec(vec![\"10\".to_string(), \"6\".to_string(), \"9\".to_string(), \"3\".to_string(), \"+\".to_string(), \"-11\".to_string(), \"*\".to_string(), \"/\".to_string(), \"*\".to_string(), \"17\".to_string(), \"+\".to_string(), \"5\".to_string(), \"+\".to_string()]));\n}"}
{"id": "fvapps_000261", "vc-description": "Given a number N, return a string consisting of \"0\"s and \"1\"s that represents its value in base -2 (negative two).\nThe returned string must have no leading zeroes, unless the string is \"0\".\n\nExample 1:\nInput: 2\nOutput: \"110\"\nExplantion: (-2) ^ 2 + (-2) ^ 1 = 2\n\nExample 2:\nInput: 3\nOutput: \"111\"\nExplantion: (-2) ^ 2 + (-2) ^ 1 + (-2) ^ 0 = 3\n\nExample 3:\nInput: 4\nOutput: \"100\"\nExplantion: (-2) ^ 2 = 4\n\nNote:\n\n0 <= N <= 10^9", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn neg_base_2_value(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        let bit_value: int = if s[s.len() - 1] == '1' { 1 } else { 0 };\n        let pos = (s.len() - 1) as int;\n        bit_value * spec_pow(-2, pos) + neg_base_2_value(s.drop_last())\n    }\n}\n\nspec fn spec_pow(base: int, exp: int) -> int\n    decreases exp\n{\n    if exp == 0 {\n        1\n    } else if exp > 0 {\n        base * spec_pow(base, exp - 1)\n    } else {\n        0\n    }\n}\n\nspec fn is_valid_binary_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> (s[i] == '0' || s[i] == '1')\n}\n\nfn base_neg2(n: i32) -> (result: String)\n    requires n >= 0,\n    ensures \n        is_valid_binary_string(result@),\n        result@.len() > 0,\n        neg_base_2_value(result@) == n,\n        n == 0 ==> result@ == seq!['0'],\n        n > 0 ==> result@[0] != '0'", "vc-code": "{\n    // impl-start\n    assume(false);\n    String::new()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let result1 = base_neg2(2);\n    // println!(\"{}\", result1);\n    \n    // let result2 = base_neg2(3);\n    // println!(\"{}\", result2);\n    \n    // let result3 = base_neg2(4);\n    // println!(\"{}\", result3);\n}"}
{"id": "fvapps_000333", "vc-description": "Given an 2D board, count how many battleships are in it. The battleships are represented with 'X's, empty slots are represented with '.'s. You may assume the following rules:\n\nYou receive a valid board, made of only battleships or empty slots.\nBattleships can only be placed horizontally or vertically. In other words, they can only be made of the shape 1xN (1 row, N columns) or Nx1 (N rows, 1 column), where N can be of any size.\nAt least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.\n\nExample:\nX..X\n...X\n...X\n\nIn the above board there are 2 battleships.\n\nInvalid Example:\n...X\nXXXX\n...X\n\nThis is an invalid board that you will not receive - as battleships will always have a cell separating between them.\n\nFollow up:Could you do it in one-pass, using only O(1) extra memory and without modifying the value of the board?", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn count_x_in_row(row: Seq<char>) -> int {\n    row.filter(|c: char| c == 'X').len() as int\n}\n\nspec fn total_x_count(board: Seq<Seq<char>>) -> int \n    decreases board.len()\n{\n    if board.len() == 0 {\n        0\n    } else {\n        count_x_in_row(board[0]) + total_x_count(board.skip(1))\n    }\n}\n\nspec fn count_valid_neighbors(board: Seq<Seq<char>>, i: int, j: int) -> int {\n    (if i + 1 < board.len() && board[i + 1][j] == 'X' { 1 } else { 0 }) +\n    (if i > 0 && board[i - 1][j] == 'X' { 1 } else { 0 }) +\n    (if j + 1 < board[i].len() && board[i][j + 1] == 'X' { 1 } else { 0 }) +\n    (if j > 0 && board[i][j - 1] == 'X' { 1 } else { 0 })\n}\n\nspec fn valid_board_spec(board: Seq<Seq<char>>) -> bool {\n    true\n}\n\nfn count_battleships(board: &Vec<Vec<char>>) -> (result: usize)\n    requires valid_board_spec(board@.map_values(|row: Vec<char>| row@)),\n    ensures \n        (board@.len() == 0) ==> result == 0,\n        (board@.len() == 1 && board@[0].len() == 0) ==> result == 0,\n        result >= 0,\n        (result as int) <= total_x_count(board@.map_values(|row: Vec<char>| row@)),\n        (board@.len() == 1 && board@[0]@ == seq!['X']) ==> result == 1,\n        forall|i: int, j: int| \n            0 <= i && i < board@.len() && 0 <= j && j < board@[i].len() && board@[i][j] == 'X'\n            ==> count_valid_neighbors(board@.map_values(|row: Vec<char>| row@), i, j) <= 2", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let test1 = vec![vec!['X', '.', '.', '.'], vec!['.', '.', '.', '.'], vec!['.', '.', '.', '.']];\n    // println!(\"{}\", count_battleships(&test1));\n    \n    // let test2 = vec![vec!['X', '.', '.', 'X'], vec!['.', '.', '.', 'X'], vec!['.', '.', '.', 'X']];\n    // println!(\"{}\", count_battleships(&test2));\n    \n    // let test3: Vec<Vec<char>> = vec![];\n    // println!(\"{}\", count_battleships(&test3));\n}"}
{"id": "fvapps_000355", "vc-description": "You are given two jugs with capacities x and y litres. There is an infinite amount of water supply available.\nYou need to determine whether it is possible to measure exactly z litres using these two jugs.\n\nIf z liters of water is measurable, you must have z liters of water contained within one or both buckets by the end.\n\nOperations allowed:\n\nFill any of the jugs completely with water.\nEmpty any of the jugs.\nPour water from one jug into another till the other jug is completely full or the first jug itself is empty.\n\nExample 1: (From the famous \"Die Hard\" example)\n\nInput: x = 3, y = 5, z = 4\nOutput: True\n\nExample 2:\n\nInput: x = 2, y = 6, z = 5\nOutput: False\n\nCredits:Special thanks to @vinod23 for adding this problem and creating all test cases.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn gcd(a: u32, b: u32) -> u32\n    decreases if a >= b { a } else { b }\n{\n    if b == 0 {\n        a\n    } else if a == 0 {\n        b\n    } else if a >= b {\n        gcd((a - b) as u32, b)\n    } else {\n        gcd(a, (b - a) as u32)\n    }\n}\n\nfn can_measure_water(x: u32, y: u32, z: u32) -> (result: bool)\n    ensures\n        /* measurement_bounds: if result then z <= x + y && z >= 0 */\n        result ==> z <= x + y,\n        /* zero_target_always_possible: if z == 0 then result == true */\n        z == 0 ==> result == true,\n        /* single_jug_measurements: for single jug cases */\n        (y == 0 && x > 0) ==> (result == (z == x || z == 0)),\n        /* gcd_property: if x > 0 && y > 0 && result then z % gcd(x, y) == 0 */\n        (x > 0 && y > 0 && result) ==> (z % gcd(x, y) == 0),", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // println!(\"{}\", can_measure_water(3, 5, 4)); // True\n    // println!(\"{}\", can_measure_water(2, 6, 5)); // False  \n    // println!(\"{}\", can_measure_water(4, 6, 8)); // True\n}"}
{"id": "fvapps_000358", "vc-description": "Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.\n\nExample 1:\nInput: [1,3,4,2,2]\nOutput: 2\n\nExample 2:\nInput: [3,1,3,4,2]\nOutput: 3\n\nNote:\nYou must not modify the array (assume the array is read only).\nYou must use only constant, O(1) extra space.\nYour runtime complexity should be less than O(n2).\nThere is only one duplicate number in the array, but it could be repeated more than once.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn find_duplicate(nums: Seq<u32>) -> (result: Option<u32>)\n    ensures\n        nums.len() == 0 ==> result == Option::<u32>::None,\n        nums =~= seq![1u32, 3u32, 4u32, 2u32, 2u32] ==> result == Some(2u32),\n        nums =~= seq![3u32, 1u32, 3u32, 4u32, 2u32] ==> result == Some(3u32),\n        nums =~= seq![2u32, 2u32, 2u32, 2u32, 2u32] ==> result == Some(2u32),\n        nums =~= seq![1u32, 1u32] ==> result == Some(1u32),\n        nums =~= seq![1u32, 2u32, 3u32, 4u32, 5u32, 6u32, 7u32, 8u32, 9u32, 5u32] ==> result == Some(5u32)", "vc-code": "{\n    // impl-start\n    assume(false);\n    None\n    // impl-end\n}", "vc-postamble": "\nproof fn test_empty_list_return_none() {\n    assert(find_duplicate(seq![]) == None::<u32>);\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn test_finds_duplicate_in_list1() {\n    assert(find_duplicate(seq![1u32, 3u32, 4u32, 2u32, 2u32]) == Some(2u32));\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn test_finds_duplicate_in_list2() {\n    assert(find_duplicate(seq![3u32, 1u32, 3u32, 4u32, 2u32]) == Some(3u32));\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn test_finds_duplicate_in_list3() {\n    assert(find_duplicate(seq![2u32, 2u32, 2u32, 2u32, 2u32]) == Some(2u32));\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn test_finds_duplicate_in_list4() {\n    assert(find_duplicate(seq![1u32, 1u32]) == Some(1u32));\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn test_minimal_case_finds_one() {\n    assert(find_duplicate(seq![1u32, 1u32]) == Some(1u32));\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn test_finds_in_larger_list() {\n    assert(find_duplicate(seq![1u32, 2u32, 3u32, 4u32, 5u32, 6u32, 7u32, 8u32, 9u32, 5u32]) == Some(5u32));\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\n}\n\nfn main() {\n    // let result1 = find_duplicate(seq![1u32, 3u32, 4u32, 2u32, 2u32]);\n    // println!(\"{:?}\", result1);\n    \n    // let result2 = find_duplicate(seq![3u32, 1u32, 3u32, 4u32, 2u32]);\n    // println!(\"{:?}\", result2);\n    \n    // let result3 = find_duplicate(seq![2u32, 2u32, 2u32, 2u32, 2u32]);\n    // println!(\"{:?}\", result3);\n}"}
{"id": "fvapps_000378", "vc-description": "Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index.\n\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each.\"\n\nExample:\n\nInput: citations = [3,0,6,1,5]\nOutput: 3 \nExplanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had \n             received 3, 0, 6, 1, 5 citations respectively. \n             Since the researcher has 3 papers with at least 3 citations each and the remaining \n             two with no more than 3 citations each, her h-index is 3.\n\nNote: If there are several possible values for h, the maximum one is taken as the h-index.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn count_at_least(citations: Seq<usize>, h: usize) -> usize {\n    citations.filter(|x: usize| *x >= h).len()\n}\n\nspec fn count_at_most(citations: Seq<usize>, h: usize) -> usize {\n    citations.filter(|x: usize| *x <= h).len()\n}\n\nspec fn is_valid_h_index(citations: Seq<usize>, h: usize) -> bool {\n    count_at_least(citations, h) >= h &&\n    count_at_most(citations, h) >= citations.len() - h\n}\n\nfn h_index(citations: Vec<usize>) -> (result: usize)\n    ensures \n        is_valid_h_index(citations@, result),\n        forall|h: usize| h > result ==> !is_valid_h_index(citations@, h),\n        citations.len() == 0 ==> result == 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let citations1 = vec![3, 0, 6, 1, 5];\n    // let result1 = h_index(citations1);\n    // println!(\"h-index of [3,0,6,1,5]: {}\", result1);\n    \n    // let citations2 = vec![0];\n    // let result2 = h_index(citations2);\n    // println!(\"h-index of [0]: {}\", result2);\n    \n    // let citations3 = vec![100];\n    // let result3 = h_index(citations3);\n    // println!(\"h-index of [100]: {}\", result3);\n}"}
{"id": "fvapps_000388", "vc-description": "Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.\n\nExample 1:\n\nInput:nums = [1,1,1], k = 2\nOutput: 2\n\nNote:\n\nThe length of the array is in range [1, 20,000].\nThe range of numbers in the array is [-1000, 1000] and the range of the integer k is [-1e7, 1e7].", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn count_subarrays_with_sum(nums: Vec<i32>, k: i32) -> (result: usize)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}\n\nproof fn empty_list_property(k: i32)\n    ensures count_subarrays_with_sum(vec![], k) == 0,\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn single_element_property(x: i32, k: i32)\n    ensures count_subarrays_with_sum(vec![x], k) == if x == k { 1usize } else { 0usize },\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn uniform_array_property(x: i32, len: usize, arr: Vec<i32>)\n    requires \n        len > 0,\n        arr.len() == len,\n        forall|i: int| 0 <= i < len ==> arr[i] == x,\n        x != 0,\n        len >= 2,\n    ensures count_subarrays_with_sum(arr, (2 * x as int) as i32) > 0,\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn uniform_zeros_property(len: usize, arr: Vec<i32>)\n    requires \n        len > 0,\n        arr.len() == len,\n        forall|i: int| 0 <= i < len ==> arr[i] == 0,\n    ensures count_subarrays_with_sum(arr, 0) == len * (len + 1) / 2,\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn non_negative_result_property(nums: Vec<i32>, k: i32)\n    ensures count_subarrays_with_sum(nums, k) >= 0,\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn reverse_invariant_property(nums: Vec<i32>, k: i32)\n    ensures count_subarrays_with_sum(nums, k) == count_subarrays_with_sum(nums.iter().cloned().rev().collect(), k),\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let result1 = count_subarrays_with_sum(vec![1, 1, 1], 2);\n    // println!(\"Result 1: {}\", result1); // Should be 2\n    \n    // let result2 = count_subarrays_with_sum(vec![1, 2, 3], 3);\n    // println!(\"Result 2: {}\", result2); // Should be 2\n    \n    // let result3 = count_subarrays_with_sum(vec![1, -1, 0], 0);\n    // println!(\"Result 3: {}\", result3); // Should be 3\n}"}
{"id": "fvapps_000405", "vc-description": "We have two integer sequences A and B of the same non-zero length.\nWe are allowed to swap elements A[i] and B[i].  Note that both elements are in the same index position in their respective sequences.\nAt the end of some number of swaps, A and B are both strictly increasing.  (A sequence is strictly increasing if and only if A[0] < A[1] < A[2] < ... < A[A.length - 1].)\nGiven A and B, return the minimum number of swaps to make both sequences strictly increasing.  It is guaranteed that the given input always makes it possible.\nExample:\nInput: A = [1,3,5,4], B = [1,2,3,7]\nOutput: 1\nExplanation: \nSwap A[3] and B[3].  Then the sequences are:\nA = [1, 3, 5, 7] and B = [1, 2, 3, 4]\nwhich are both strictly increasing.\n\nNote:\n\nA, B are arrays with the same length, and that length will be in the range [1, 1000].\nA[i], B[i] are integer values in the range [0, 2000].", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn is_strictly_increasing(arr: Seq<i32>) -> bool {\n    if arr.len() <= 1 {\n        true\n    } else {\n        forall|i: int| 0 <= i < arr.len() - 1 ==> arr.index(i) < arr.index(i + 1)\n    }\n}", "vc-spec": "fn min_swaps_to_increasing(a: Vec<i32>, b: Vec<i32>) -> (result: usize)\n    requires \n        a.len() == b.len(),\n        a.len() > 0,\n        a.len() <= 1000,\n        forall|i: int| 0 <= i < a.len() ==> 0 <= a[i] <= 2000,\n        forall|i: int| 0 <= i < b.len() ==> 0 <= b[i] <= 2000,\n    ensures\n        exists|possible_a: Seq<i32>, possible_b: Seq<i32>| \n            possible_a.len() == a.len() && \n            possible_b.len() == b.len() &&\n            (is_strictly_increasing(possible_a) && is_strictly_increasing(possible_b)),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = min_swaps_to_increasing(vec![1, 3, 5, 4], vec![1, 2, 3, 7]);\n    // println!(\"Result 1: {}\", result1);\n    \n    // let result2 = min_swaps_to_increasing(vec![1, 2, 3], vec![4, 5, 6]);\n    // println!(\"Result 2: {}\", result2);\n    \n    // let result3 = min_swaps_to_increasing(vec![2], vec![1]);\n    // println!(\"Result 3: {}\", result3);\n}"}
{"id": "fvapps_000411", "vc-description": "Given a string s, return the last substring of s in lexicographical order.\n\nExample 1:\nInput: \"abab\"\nOutput: \"bab\"\nExplanation: The substrings are [\"a\", \"ab\", \"aba\", \"abab\", \"b\", \"ba\", \"bab\"]. The lexicographically maximum substring is \"bab\".\n\nExample 2:\nInput: \"leetcode\"\nOutput: \"tcode\"\n\nNote:\n\n1 <= s.length <= 4 * 10^5\ns contains only lowercase English letters.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn substring_at(s: Seq<char>, i: int) -> Seq<char> {\n    if 0 <= i <= s.len() {\n        s.subrange(i, s.len() as int)\n    } else {\n        seq![]\n    }\n}\n\nspec fn string_ends_with(s: Seq<char>, suffix: Seq<char>) -> bool {\n    s.len() >= suffix.len() && s.subrange(s.len() - suffix.len(), s.len() as int) == suffix\n}\n\nspec fn is_lexicographically_ge(s1: Seq<char>, s2: Seq<char>) -> bool {\n    if s1.len() == 0 && s2.len() == 0 {\n        true\n    } else if s1.len() == 0 {\n        false\n    } else if s2.len() == 0 {\n        true\n    } else {\n        s1[0] > s2[0] || (s1[0] == s2[0] && is_lexicographically_ge(s1.skip(1), s2.skip(1)))\n    }\n}\n\nfn last_substring(s: &str) -> (result: String)\n    requires s.len() > 0,\n    ensures\n        result.len() > 0,\n        string_ends_with(s@, result@),\n        forall|i: int| 0 <= i < s.len() ==> is_lexicographically_ge(result@, substring_at(s@, i)),", "vc-code": "{\n    // impl-start\n    assume(false);\n    String::new()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: unguarded\n\n    // #eval last_substring \"abab\"\n    // #eval last_substring \"leetcode\"\n    // #eval last_substring \"zzz\"\n}"}
{"id": "fvapps_000432", "vc-description": "Given an n x n binary grid, in one step you can choose two adjacent rows of the grid and swap them.\nA grid is said to be valid if all the cells above the main diagonal are zeros.\nReturn the minimum number of steps needed to make the grid valid, or -1 if the grid cannot be valid.\nThe main diagonal of a grid is the diagonal that starts at cell (1, 1) and ends at cell (n, n).\n\nExample 1:\n\nInput: grid = [[0,0,1],[1,1,0],[1,0,0]]\nOutput: 3\n\nExample 2:\n\nInput: grid = [[0,1,1,0],[0,1,1,0],[0,1,1,0],[0,1,1,0]]\nOutput: -1\nExplanation: All rows are similar, swaps have no effect on the grid.\n\nExample 3:\n\nInput: grid = [[1,0,0],[1,1,0],[1,1,1]]\nOutput: 0\n\nConstraints:\n\nn == grid.length\nn == grid[i].length\n1 <= n <= 200\ngrid[i][j] is 0 or 1", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_valid_final_grid(grid: Seq<Vec<nat>>) -> bool {\n    grid.len() > 0 && grid.len() == grid[0].len() &&\n    forall|i: int, j: int| 0 <= i < grid.len() && 0 <= j < grid.len() && i < j ==> grid[i][j] == 0\n}\n\nspec fn is_identity_matrix(grid: Seq<Vec<nat>>) -> bool {\n    grid.len() > 0 && grid.len() == grid[0].len() &&\n    forall|i: int, j: int| 0 <= i < grid.len() && 0 <= j < grid.len() ==> \n        if i == j { grid[i][j] == 1 } else { grid[i][j] == 0 }\n}\n\nspec fn is_all_ones_matrix(grid: Seq<Vec<nat>>) -> bool {\n    grid.len() > 0 && grid.len() == grid[0].len() &&\n    forall|i: int, j: int| 0 <= i < grid.len() && 0 <= j < grid.len() ==> grid[i][j] == 1\n}\n\nfn min_swaps(grid: Vec<Vec<nat>>) -> (result: i32)\n    requires \n        grid.len() > 0,\n        forall|i: int| 0 <= i < grid.len() ==> grid[i].len() == grid.len(),\n        forall|i: int, j: int| 0 <= i < grid.len() && 0 <= j < grid.len() ==> grid[i][j] <= 1,\n    ensures\n        (is_identity_matrix(grid@) ==> result == 0) &&\n        (is_all_ones_matrix(grid@) ==> result == -1) &&\n        (result >= 0 ==> is_valid_final_grid(grid@)) &&\n        (result >= 0 ==> result <= (grid.len() * (grid.len() - 1)) / 2)\n\nfn is_valid_final_grid_fn(grid: Vec<Vec<nat>>) -> (result: bool)\n    requires \n        grid.len() > 0,\n        forall|i: int| 0 <= i < grid.len() ==> grid[i].len() == grid.len(),\n    ensures result == is_valid_final_grid(grid@)", "vc-code": "{\n    // impl-start\n    assume(false);\n    -1\n    // impl-end\n}\n\n{\n    // impl-start  \n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let grid1 = vec![vec![0, 0, 1], vec![1, 1, 0], vec![1, 0, 0]];\n    // assert(min_swaps(grid1) == 3);\n    \n    // let grid2 = vec![vec![0, 1, 1, 0], vec![0, 1, 1, 0], vec![0, 1, 1, 0], vec![0, 1, 1, 0]];\n    // assert(min_swaps(grid2) == -1);\n    \n    // let grid3 = vec![vec![1, 0, 0], vec![1, 1, 0], vec![1, 1, 1]];\n    // assert(min_swaps(grid3) == 0);\n}"}
{"id": "fvapps_000441", "vc-description": "Given two strings S and T, each of which represents a non-negative rational number, return True if and only if they represent the same number. The strings may use parentheses to denote the repeating part of the rational number.\nIn general a rational number can be represented using up to three parts: an integer part, a non-repeating part, and a repeating part. The number will be represented in one of the following three ways:\n\n<IntegerPart> (e.g. 0, 12, 123)\n<IntegerPart><.><NonRepeatingPart>  (e.g. 0.5, 1., 2.12, 2.0001)\n<IntegerPart><.><NonRepeatingPart><(><RepeatingPart><)> (e.g. 0.1(6), 0.9(9), 0.00(1212))\n\nThe repeating portion of a decimal expansion is conventionally denoted within a pair of round brackets.  For example:\n1 / 6 = 0.16666666... = 0.1(6) = 0.1666(6) = 0.166(66)\nBoth 0.1(6) or 0.1666(6) or 0.166(66) are correct representations of 1 / 6.\n\nExample 1:\nInput: S = \"0.(52)\", T = \"0.5(25)\"\nOutput: true\nExplanation:\nBecause \"0.(52)\" represents 0.52525252..., and \"0.5(25)\" represents 0.52525252525..... , the strings represent the same number.\n\nExample 2:\nInput: S = \"0.1666(6)\", T = \"0.166(66)\"\nOutput: true\n\nExample 3:\nInput: S = \"0.9(9)\", T = \"1.\"\nOutput: true\nExplanation: \n\"0.9(9)\" represents 0.999999999... repeated forever, which equals 1.  [See this link for an explanation.]\n\"1.\" represents the number 1, which is formed correctly: (IntegerPart) = \"1\" and (NonRepeatingPart) = \"\".\n\nNote:\n\nEach part consists only of digits.\nThe <IntegerPart> will not begin with 2 or more zeros.  (There is no other restriction on the digits of each part.)\n1 <= <IntegerPart>.length <= 4 \n0 <= <NonRepeatingPart>.length <= 4 \n1 <= <RepeatingPart>.length <= 4", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn is_rational_equal(s1: &str, s2: &str) -> (result: bool) {\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}\n\nfn make_rational_str(n: i32, d: i32) -> (result: String)\n    requires d > 0\n{\n    // impl-start\n    assume(false);\n    \"0\".to_string()\n    // impl-end\n}\n\nproof fn equivalent_fractions(n1: i32, d1: i32, n2: i32, d2: i32)\n    requires\n        d1 > 0,\n        d2 > 0,\n        n1 >= -1000,\n        n1 <= 1000,\n        d1 <= 100,\n        n2 >= -1000,\n        n2 <= 1000,\n        d2 <= 100,\n        n1 / d1 == n2 / d2,\n    ensures\n        is_rational_equal(&make_rational_str(n1, d1), &make_rational_str(n2, d2)) == true\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn repeating_nines(n: usize)\n    requires\n        n > 0,\n        n <= 9,\n    ensures\n        is_rational_equal(&format!(\"0.{}(9)\", \"9\".repeat(n)), \"1.\") == true\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}", "vc-code": "", "vc-postamble": "}\n\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: unguarded\n\n    // Example tests commented out for verification:\n    // assert(is_rational_equal(\"0.(52)\", \"0.5(25)\") == true);\n    // assert(is_rational_equal(\"0.1666(6)\", \"0.166(66)\") == true);\n    // assert(is_rational_equal(\"0.9(9)\", \"1.\") == true);\n}"}
{"id": "fvapps_000449", "vc-description": "Given a string that consists of only uppercase English letters, you can replace any letter in the string with another letter at most k times. Find the length of a longest substring containing all repeating letters you can get after performing the above operations.\n\nNote:\nBoth the string's length and k will not exceed 104.\n\nExample 1:\n\nInput:\ns = \"ABAB\", k = 2\n\nOutput:\n4\n\nExplanation:\nReplace the two 'A's with two 'B's or vice versa.\n\nExample 2:\n\nInput:\ns = \"AABABBA\", k = 1\n\nOutput:\n4\n\nExplanation:\nReplace the one 'A' in the middle with 'B' and form \"AABBBBA\".\nThe substring \"BBBB\" has the longest repeating letters, which is 4.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn character_replacement(s: &String, k: usize) -> (result: usize)\n    ensures\n        result <= s.len(),\n        s.len() == 0 ==> result == 0,\n        s.len() > 0 && s.len() <= k + 1 ==> result >= s.len(),\n        s.len() > 0 && s.len() > k + 1 ==> result >= k + 1,\n        k >= s.len() ==> result == s.len(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // println!(\"{}\", character_replacement(&\"ABAB\".to_string(), 2));\n    // println!(\"{}\", character_replacement(&\"AABABBA\".to_string(), 1));\n    // println!(\"{}\", character_replacement(&\"\".to_string(), 2));\n}"}
{"id": "fvapps_000464", "vc-description": "Given a list of words, list of single letters (might be repeating) and score of every character.\nReturn the maximum score of any valid set of words formed by using the given letters (words[i] cannot be used two or more times).\nIt is not necessary to use all characters in letters and each letter can only be used once. Score of letters 'a', 'b', 'c', ... ,'z' is given by score[0], score[1], ... , score[25] respectively.\n\nExample 1:\nInput: words = [\"dog\",\"cat\",\"dad\",\"good\"], letters = [\"a\",\"a\",\"c\",\"d\",\"d\",\"d\",\"g\",\"o\",\"o\"], score = [1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0]\nOutput: 23\nExplanation:\nScore  a=1, c=9, d=5, g=3, o=2\nGiven letters, we can form the words \"dad\" (5+1+5) and \"good\" (3+2+2+5) with a score of 23.\nWords \"dad\" and \"dog\" only get a score of 21.\nExample 2:\nInput: words = [\"xxxz\",\"ax\",\"bx\",\"cx\"], letters = [\"z\",\"a\",\"b\",\"c\",\"x\",\"x\",\"x\"], score = [4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,10]\nOutput: 27\nExplanation:\nScore  a=4, b=4, c=4, x=5, z=10\nGiven letters, we can form the words \"ax\" (4+5), \"bx\" (4+5) and \"cx\" (4+5) with a score of 27.\nWord \"xxxz\" only get a score of 25.\nExample 3:\nInput: words = [\"leetcode\"], letters = [\"l\",\"e\",\"t\",\"c\",\"o\",\"d\"], score = [0,0,1,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0]\nOutput: 0\nExplanation:\nLetter \"e\" can only be used once.\n\nConstraints:\n1 <= words.length <= 14\n1 <= words[i].length <= 15\n1 <= letters.length <= 100\nletters[i].length == 1\nscore.length == 26\n0 <= score[i] <= 10\nwords[i], letters[i] contains only lower case English letters.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn letter_count(letters: Seq<char>) -> Map<char, nat>\n    decreases letters.len()\n{\n    if letters.len() == 0 {\n        Map::empty()\n    } else {\n        let head = letters[0];\n        let tail_count = letter_count(letters.skip(1));\n        if tail_count.dom().contains(head) {\n            tail_count.insert(head, tail_count[head] + 1)\n        } else {\n            tail_count.insert(head, 1)\n        }\n    }\n}\n\nspec fn word_score(word: Seq<char>, scores: Seq<nat>) -> nat\n    decreases word.len()\n{\n    if word.len() == 0 {\n        0\n    } else {\n        let ch = word[0];\n        let index = (ch as u8 - 'a' as u8) as nat;\n        if index < scores.len() {\n            scores[index as int] + word_score(word.skip(1), scores)\n        } else {\n            0\n        }\n    }\n}\n\nspec fn total_letter_score(letters: Seq<char>, scores: Seq<nat>) -> nat\n    decreases letters.len()\n{\n    if letters.len() == 0 {\n        0\n    } else {\n        let ch = letters[0];\n        let index = (ch as u8 - 'a' as u8) as nat;\n        if index < scores.len() {\n            scores[index as int] + total_letter_score(letters.skip(1), scores)\n        } else {\n            0\n        }\n    }\n}\n\nfn max_score_words(words: Vec<String>, letters: Vec<char>, scores: Vec<nat>) -> (result: nat)\n    requires\n        1 <= words.len() <= 14,\n        1 <= letters.len() <= 100,\n        scores.len() == 26,\n        forall|i: int| 0 <= i < scores.len() ==> scores[i] <= 10,\n        forall|i: int| 0 <= i < words.len() ==> 1 <= words[i]@.len() <= 15,\n        forall|i: int| 0 <= i < letters.len() ==> 'a' <= letters[i] <= 'z',\n        forall|i: int| 0 <= i < words.len() ==> forall|j: int| 0 <= j < words[i]@.len() ==> 'a' <= words[i]@[j] <= 'z',\n    ensures\n        result <= total_letter_score(letters@, scores@),\n        result >= 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // Example usage (commented out):\n    // let words1 = vec![\"dog\".to_string(), \"cat\".to_string(), \"dad\".to_string(), \"good\".to_string()];\n    // let letters1 = vec!['a', 'a', 'c', 'd', 'd', 'd', 'g', 'o', 'o'];\n    // let scores1 = vec![1, 0, 9, 5, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    // println!(\"Result: {}\", max_score_words(words1, letters1, scores1));\n}"}
{"id": "fvapps_000467", "vc-description": "Given two positive integers n and k, the binary string Sn is formed as follows:\n\nS1 = \"0\"\nSi = Si-1 + \"1\" + reverse(invert(Si-1)) for i > 1\n\nWhere + denotes the concatenation operation, reverse(x) returns the reversed string x, and invert(x) inverts all the bits in x (0 changes to 1 and 1 changes to 0).\nFor example, the first 4 strings in the above sequence are:\n\nS1 = \"0\"\nS2 = \"011\"\nS3 = \"0111001\"\nS4 = \"011100110110001\"\n\nReturn the kth bit in Sn. It is guaranteed that k is valid for the given n.\n\nExample 1:\nInput: n = 3, k = 1\nOutput: \"0\"\nExplanation: S3 is \"0111001\". The first bit is \"0\".\n\nExample 2:\nInput: n = 4, k = 11\nOutput: \"1\"\nExplanation: S4 is \"011100110110001\". The 11th bit is \"1\".\n\nExample 3:\nInput: n = 1, k = 1\nOutput: \"0\"\n\nExample 4:\nInput: n = 2, k = 3\nOutput: \"1\"\n\nConstraints:\n\n1 <= n <= 20\n1 <= k <= 2n - 1", "vc-preamble": "use vstd::prelude::*;\nuse vstd::arithmetic::power::pow;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn find_kth_bit_spec(n: nat, k: nat) -> char {\n    if n == 1 && k == 1 {\n        '0'\n    } else {\n        '0'\n    }\n}\n\nfn find_kth_bit(n: nat, k: nat) -> (result: char)\n    requires \n        n > 0,\n        k > 0,\n        k <= pow(2, n) - 1,\n    ensures\n        result == '0' || result == '1',\n        find_kth_bit(n, k) == find_kth_bit_spec(n, k),", "vc-code": "{\n    // impl-start\n    assume(false);\n    '0'\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // let result1 = find_kth_bit(3, 1);\n    // println!(\"find_kth_bit(3, 1) = {:?}\", result1);\n    \n    // let result2 = find_kth_bit(4, 11);\n    // println!(\"find_kth_bit(4, 11) = {:?}\", result2);\n    \n    // let result3 = find_kth_bit(1, 1);\n    // println!(\"find_kth_bit(1, 1) = {:?}\", result3);\n}"}
{"id": "fvapps_000521", "vc-description": "Chef got in the trouble! He is the king of Chefland and Chessland. There is one queen in Chefland and one queen in Chessland and they both want a relationship with him. Chef is standing before a difficult choice…\nChessland may be considered a chessboard with $N$ rows (numbered $1$ through $N$) and $M$ columns (numbered $1$ through $M$). Let's denote a unit square in row $r$ and column $c$ by $(r, c)$. Chef lives at square $(X, Y)$ of this chessboard.\nCurrently, both queens are living in Chessland too. Each queen, when alone on the chessboard, can see all squares that lie on the same row, column or diagonal as itself. A queen from $(x_q, y_q)$ cannot see a square $(r, c)$ if the square $(X, Y)$ is strictly between them. Of course, if the queens can see each other, the kingdom will soon be in chaos!\nHelp Chef calculate the number of possible configurations of the queens such that the kingdom will not be in chaos. A configuration is an unordered pair of distinct squares $(x_{q1}, y_{q1})$ and $(x_{q2}, y_{q2})$ such that neither of them is the square $(X, Y)$. Two configurations are different if the position of queen $1$ is different or the position of queen $2$ is different.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve_queens(n: nat, m: nat, x: nat, y: nat) -> (result: nat)\n    requires \n        n >= 2,\n        m >= 2,\n        x >= 1 && x <= n,\n        y >= 1 && y <= m,\n    ensures\n        result >= 0,\n        result % 2 == 0,\n        result <= (n * m) * (n * m - 1),", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n/* proof functions for theorem properties */\nproof fn queens_symmetry_rotate_180(n: nat, m: nat, x: nat, y: nat)\n    requires x <= n && y <= m && n >= x && m >= y\n    ensures solve_queens(n, m, x, y) == solve_queens(n, m, n.checked_sub(x).unwrap_or(0) + 1, m.checked_sub(y).unwrap_or(0) + 1)\n{\n    assume(false);\n}\n\nproof fn queens_square_board_nonnegative(n: nat, x: nat, y: nat)\n    requires x <= n && y <= n\n    ensures solve_queens(n, n, x, y) >= 0\n{\n    assume(false);\n}\n\nproof fn queens_corner_symmetry(n: nat, m: nat)\n    requires n >= 2 && m >= 2\n    ensures solve_queens(n, m, 1, 1) == solve_queens(n, m, n, m)\n{\n    assume(false);\n}\n\n}\nfn main() {\n    // #guard_msgs in\n    // #eval solve_queens 3 3 2 2\n    \n    // #guard_msgs in\n    // #eval solve_queens 4 4 2 3\n}"}
{"id": "fvapps_000533", "vc-description": "Two players are playing a game. The game is played on a sequence of positive integer pairs. The players make their moves alternatively. During his move the player chooses a pair and decreases the larger integer in the pair by a positive multiple of the smaller integer in the pair in such a way that both integers in the pair remain positive. If two numbers in some pair become equal then the pair is removed from the sequence. The player who can not make any move loses (or in another words the player who encounters an empty sequence loses). Given the sequence of positive integer pairs determine whether the first player can win or not (assuming that both players are playing optimally).\n\n-----Input-----\nThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\nEach test starts with an integer N denoting the number of pairs. Each of the next N lines contains a pair of positive integers. \n\n-----Output-----\nFor each test case, output a single line containing \"YES\" if the first player can win and \"NO\" otherwise. \n\n-----Constraints-----\n- 1 ≤ T ≤ 100\n- 1 ≤ N ≤ 100\n- All other integers are between 1 to 108\n- The integers in each pair will be different\n\n-----Example-----\nInput:\n3\n1\n2 3\n2\n4 5\n5 6\n2\n2 3\n3 5\n\nOutput:\nNO\nNO\nYES\n\n-----Explanation-----\nExample case 1. The first player don't have any choice other subtracting 2 from 3. So during the turn of the second player integer pair will be (2,1). The second player will win by subtracting 1 from 2. \nExample case 2. If the first player choose to move (4,5) to (4,1) the second player will make it to (1,1). If the first player choose to move (5,6) to (5,1) the second player will make it to (1,1). So regardless of the move of the first player, the second will always win.\nExample case 3. The first player will select pair (3,5) and make it to (3,2). Now both pairs are equal. So whatever the move of second player he will just mirror that move in another pair. This will ensure his win.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn can_first_player_win(pairs: Vec<(u32, u32)>) -> (result: bool)\n    requires \n        1 <= pairs.len() <= 10,\n        forall|i: int| 0 <= i < pairs.len() ==> \n            1 <= pairs[i].0 <= 100 && \n            1 <= pairs[i].1 <= 100,\n    ensures \n        true", "vc-code": "{\n    // impl-start\n    assume(false);\n    false\n    // impl-end\n}", "vc-postamble": "}\n\nfn main() {\n    // let test1 = vec![(2u32, 3u32)];\n    // let result = can_first_player_win(test1);\n    // println!(\"{}\", if result { \"YES\" } else { \"NO\" });\n    \n    // let test2 = vec![(4u32, 5u32), (5u32, 6u32)];\n    // let result = can_first_player_win(test2);\n    // println!(\"{}\", if result { \"YES\" } else { \"NO\" });\n    \n    // let test3 = vec![(2u32, 3u32), (3u32, 5u32)];\n    // let result = can_first_player_win(test3);\n    // println!(\"{}\", if result { \"YES\" } else { \"NO\" });\n}"}
{"id": "fvapps_000536", "vc-description": "Chef Tobby is playing a rapid fire with Bhuvan. He gives Bhuvan a string S and each time, Bhuvan has to guess whether there exists 2 equal subsequences in the string or not.\nBhuvan got a perfect score in the game with Chef Tobby. However, Chef Tobby has now asked Bhuvan to write a program that will do this automatically given a string S. Bhuvan is an intelligent man but he does not know how to write a code. Can you help him?\nFind two different subsequences such that they are equal in their value, more formally, find two sequences of indices (a1, a2, ..., ak-1, ak) and (b1, b2, ..., bk-1, bk) such that:\n\n- 1≤ ai, bi ≤ |S|\n- ai < ai+1 for all valid i\n- bi < bi+1 for all valid i\n- Sai = Sbi for all valid i\n- there exist at least one i such that ai is not equal to bi\n\nInput section:\nThe first line contains T, the number of test cases.\nEach of the next T lines contain one string S each.\nInput will only consist of lowercase english characters\n\nOutput section:\nFor each test case, output \"yes\" or \"no\" (without quotes) as the solution to the problem.\n\nInput constraints:\n1 ≤ T ≤ 1000\n1 ≤ length of S ≤ 100\n\nSample Input:\n4\nlikecs\nvenivedivici\nbhuvan\ncodechef\n\nSample Output:\nno\nyes\nno\nyes\n\nExplanation:\nIn test case 2, one of the possible equal subsequence is \"vi\" and \"vi\". (one at position {0, 3} and other at {4, 7}, assuming 0-based indexing).\nIn test case 4, one of the possible equal subsequence is \"ce\" and \"ce\". (one at position {0, 3} and other at {4, 6}, assuming 0-based indexing).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn has_equal_subsequences(s: &str) -> (result: String)\n    ensures \n        result == \"yes\".to_string() || result == \"no\".to_string(),\n        s.len() <= 1 ==> result == \"no\".to_string()", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let test1 = has_equal_subsequences(\"likecs\");\n    // println!(\"{}\", test1); // Should print \"no\"\n    \n    // let test2 = has_equal_subsequences(\"venivedivici\");\n    // println!(\"{}\", test2); // Should print \"yes\"\n    \n    // let test3 = has_equal_subsequences(\"bhuvan\");\n    // println!(\"{}\", test3); // Should print \"no\"\n    \n    // let test4 = has_equal_subsequences(\"codechef\");\n    // println!(\"{}\", test4); // Should print \"yes\"\n}"}
{"id": "fvapps_000538", "vc-description": "Consider the following operations on a triple of integers. In one operation, you should:\n- Choose an integer $d$ and an arithmetic operation ― either addition or multiplication.\n- Choose a subset of elements of the triple.\n- Apply the arithmetic operation to each of the chosen elements, i.e. either add $d$ to each of them or multiply each of them by $d$.\nFor example, if we have a triple $(3, 5, 7)$, we may choose to add $3$ to the first and third element, and we get $(6, 5, 10)$ using one operation.\nYou are given an initial triple $(p, q, r)$ and a target triple $(a, b, c)$. Find the minimum number of operations needed to transform $(p, q, r)$ into $(a, b, c)$.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains three space-separated integers $p$, $q$ and $r$.\n- The second line contains three space-separated integers $a$, $b$ and $c$.\n\n-----Output-----\nFor each test case, print a single line containing one integer ― the minimum required number of operations.\n\n-----Constraints-----\n- $1 \\le T \\le 1,000$\n- $|p|, |q|, |r|, |a|, |b|, |c| \\le 10^9$\n\n-----Subtasks-----\nSubtask #1 (10 points): $|p|, |q|, |r|, |a|, |b|, |c| \\le 10$\nSubtask #2 (90 points): original constraints\n\n-----Example Input-----\n2\n3 5 7\n6 5 10\n8 6 3\n9 7 8\n\n-----Example Output-----\n1\n2\n\n-----Explanation-----\nExample case 1: We add $3$ to the first and third element of $(3, 5, 7)$ to form $(6, 5, 10)$.\nExample case 2: We can add $1$ to each element to form $(9, 7, 4)$ and then multiply the third element by $2$.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn eq_solve(v0: i32, v1: i32, u0: i32, u1: i32) -> (result: f32)\n    ensures (v0 == 0 && u0 == 0) ==> result == 1.0\n{\n    // impl-start\n    assume(false);\n    0.0\n    // impl-end\n}\n\nfn min_operations(p: i32, q: i32, r: i32, a: i32, b: i32, c: i32) -> (result: usize)\n    ensures result <= 3,\n    ensures (p == a && q == b && r == c) ==> result == 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // println!(\"{}\", min_operations(3, 5, 7, 6, 5, 10));\n    // println!(\"{}\", min_operations(8, 6, 3, 9, 7, 8));\n}"}
{"id": "fvapps_000587", "vc-description": "You are given a grid with R rows (numbered 1 through R) and C columns (numbered 1 through C). A cell in row r and column c is denoted by (r, c). Two cells in the grid are adjacent if they have a common side. For each valid i and j, there is a value a_{i, j} written in cell a_{i, j}.\nA cell in the grid is stable if the number of cells in the grid which are adjacent to this cell is strictly greater than the value written in this cell. The whole grid is stable if all cells in the grid are stable.\nCan you determine whether the grid is stable?\n\n-----Input-----\n- The first line of the input contains a single integer T denoting the number of test cases. The description of T test cases follows.\n- The first line of each test case contains two space-separated integers R and C.\n- R lines follow. For each i (1 ≤ i ≤ R), the i-th of these lines contains C space-separated integers a_{i, 1}, a_{i, 2}, ..., a_{i, C}.\n\n-----Output-----\nFor each test case, print a single line containing the string \"Stable\" if the grid is stable or \"Unstable\" if it is unstable (without quotes).\n\n-----Constraints-----\n- 1 ≤ T ≤ 3,000\n- 3 ≤ R, C ≤ 10\n- 0 ≤ a_{i, j} ≤ 4 for each valid i, j\n\n-----Example Input-----\n2\n3 3\n1 2 1\n2 3 2\n1 2 1\n3 4\n0 0 0 0\n0 0 0 0\n0 0 4 0\n\n-----Example Output-----\nStable\nUnstable\n\n-----Explanation-----\nExample case 1: Each cell of the grid is stable, so the grid is stable.\nExample case 2: The cell in row 3 and column 3 is unstable since the number of cells adjacent to this cell is 3.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn count_adjacent_cells(rows: nat, cols: nat, r: nat, c: nat) -> nat {\n    let mut count: nat = 0;\n    if r > 0 { count = count + 1; }\n    if r + 1 < rows { count = count + 1; }\n    if c > 0 { count = count + 1; }\n    if c + 1 < cols { count = count + 1; }\n    count\n}\n\nspec fn is_cell_stable(grid: Seq<Seq<nat>>, rows: nat, cols: nat, r: nat, c: nat) -> bool {\n    r < rows && c < cols ==>\n    count_adjacent_cells(rows, cols, r, c) > grid[r as int][c as int]\n}\n\nspec fn is_grid_stable(grid: Seq<Seq<nat>>, rows: nat, cols: nat) -> bool {\n    forall|r: nat, c: nat| r < rows && c < cols ==> is_cell_stable(grid, rows, cols, r, c)\n}\n\nfn modify_list(xs: Vec<nat>, i: usize, v: nat) -> (result: Vec<nat>)\n    requires i < xs.len(),\n    ensures\n        result.len() == xs.len(),\n        result[i as int] == v,\n        forall|j: int| 0 <= j < xs.len() && j != i ==> result[j] == xs[j]\n{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}\n\nfn check_grid_stability(grid: Vec<Vec<nat>>, rows: usize, cols: usize) -> (result: String)\n    requires \n        grid.len() == rows,\n        rows >= 3 && cols >= 3,\n        forall|i: int| 0 <= i < grid.len() ==> grid[i].len() == cols,\n        forall|i: int, j: int| 0 <= i < grid.len() && 0 <= j < grid[i].len() ==> grid[i][j] <= 4,\n    ensures\n        equal(result@, \"Stable\".view()) || equal(result@, \"Unstable\".view())\n{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-code": "", "vc-postamble": "proof fn corner_cells_stability(n: nat)\n    requires n >= 2,\n    ensures\n        ({\n            let grid1 = Seq::<Seq<nat>>::new(n as nat, |_i: int| Seq::<nat>::new(n as nat, |_j: int| 0));\n            let grid2 = grid1.update(0int, grid1[0int].update(0int, 2));\n            let grid3 = grid1.update(0int, grid1[0int].update(0int, 1));\n            !is_grid_stable(grid2, n, n) && is_grid_stable(grid3, n, n)\n        })\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn center_cells_stability(n: nat)\n    requires n >= 3,\n    ensures\n        ({\n            let grid1 = Seq::<Seq<nat>>::new(n as nat, |_i: int| Seq::<nat>::new(n as nat, |_j: int| 0));\n            let center = (n / 2) as int;\n            let grid2 = grid1.update(center, grid1[center].update(center, 4));\n            let grid3 = grid1.update(center, grid1[center].update(center, 3));\n            !is_grid_stable(grid2, n, n) && is_grid_stable(grid3, n, n)\n        })\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn arbitrary_grid_stability(grid: Seq<Seq<nat>>)\n    requires\n        grid.len() > 0,\n        grid[0int].len() > 0,\n        forall|i: int| 0 <= i < grid.len() ==> grid[i].len() == grid[0int].len(),\n        forall|i: int, j: int| 0 <= i < grid.len() && 0 <= j < grid[i].len() ==> grid[i][j] <= 4,\n    ensures\n        ({\n            let rows = grid.len() as nat;\n            let cols = grid[0int].len() as nat;\n            is_grid_stable(grid, rows, cols) || !is_grid_stable(grid, rows, cols)\n        })\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\n}\n\nfn main() {\n    // let test1 = vec![vec![1, 2, 1], vec![2, 3, 2], vec![1, 2, 1]];\n    // println!(\"{}\", check_grid_stability(test1, 3, 3));\n    \n    // let test2 = vec![vec![0, 0, 0, 0], vec![0, 0, 0, 0], vec![0, 0, 4, 0]];\n    // println!(\"{}\", check_grid_stability(test2, 3, 4));\n    \n    // let test3 = vec![vec![1, 1, 1], vec![1, 4, 1], vec![1, 1, 1]];\n    // println!(\"{}\", check_grid_stability(test3, 3, 3));\n}"}
{"id": "fvapps_000620", "vc-description": "For a string S let the unique set of characters that occur in it one or more times be C. Consider a permutation of the elements of C as (c_1, c_2, c_3 ... ). Let f(c) be the number of times c occurs in S.\nIf any such permutation of the elements of C satisfies f(c_i) = f(c_{i-1}) + f(c_{i-2}) for all i >= 3, the string is said to be a dynamic string.\nMr Bancroft is given the task to check if the string is dynamic, but he is busy playing with sandpaper. Would you help him in such a state?\nNote that if the number of distinct characters in the string is less than 3, i.e. if |C| < 3, then the string is always dynamic.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn is_dynamic_string(s: Seq<char>) -> (result: Seq<char>)\n    requires s.len() > 0,\n    ensures\n        result == \"Dynamic\"@ || result == \"Not\"@,", "vc-code": "{\n    // impl-start\n    assume(false);\n    seq![]\n    // impl-end\n}\n\nproof fn dynamic_string_returns_valid_outputs(s: Seq<char>)\n    requires s.len() > 0\n    ensures \n        is_dynamic_string(s) == \"Dynamic\"@ || is_dynamic_string(s) == \"Not\"@\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn few_unique_chars_is_dynamic(s: Seq<char>)\n    requires \n        s.len() > 0,\n        /* unique character count < 3 */\n    ensures is_dynamic_string(s) == \"Dynamic\"@\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn binary_string_is_dynamic(s: Seq<char>)\n    requires \n        s.len() > 0,\n        /* all chars are 'a' or 'b' */\n    ensures is_dynamic_string(s) == \"Dynamic\"@\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn single_char_is_dynamic(c: char)\n    ensures is_dynamic_string(seq![c]) == \"Dynamic\"@\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn repeated_char_is_dynamic(c: char, n: nat)\n    requires n > 0\n    ensures /* is_dynamic_string(repeated_char_seq(c, n)) == \"Dynamic\"@ */\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn equal_freq_three_chars_not_dynamic(s: Seq<char>)\n    requires \n        s.len() >= 6,\n        /* all chars are 'a', 'b', or 'c' with equal frequencies */\n    ensures is_dynamic_string(s) == \"Not\"@\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "fvapps_000649", "vc-description": "You are given an array A with size N (indexed from 0) and an integer K. Let's define another array B with size N · K as the array that's formed by concatenating K copies of array A.\nFor example, if A = {1, 2} and K = 3, then B = {1, 2, 1, 2, 1, 2}.\nYou have to find the maximum subarray sum of the array B. Fomally, you should compute the maximum value of Bi + Bi+1 + Bi+2 + ... + Bj, where 0 ≤ i ≤ j < N · K.\n\n-----Input-----\n\n- The first line of the input contains a single integer T denoting the number of test cases. The description of T test cases follows.\n- The first line of each test case contains two space-separated integers N and K.\n- The second line contains N space-separated integers A0, A1, ..., AN-1.\n\n-----Output-----\nFor each test case, print a single line containing the maximum subarray sum of B.\n\n-----Constraints-----\n- 1 ≤ T ≤ 10\n- 1 ≤ N ≤ 105\n- 1 ≤ K ≤ 105\n- -106 ≤ Ai ≤ 106 for each valid i\n\n-----Subtasks-----\nSubtask #1 (18 points): N · K ≤ 105\nSubtask #2 (82 points): original constraints\n\n-----Example-----\nInput:\n\n2\n2 3\n1 2\n3 2\n1 -2 1\n\nOutput:\n\n9\n2\n\n-----Explanation-----\nExample case 1: B = {1, 2, 1, 2, 1, 2} and the subarray with maximum sum is the whole {1, 2, 1, 2, 1, 2}. Hence, the answer is 9.\nExample case 2: B = {1, -2, 1, 1, -2, 1} and the subarray with maximum sum is {1, 1}. Hence, the answer is 2.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn maximum(xs: Seq<i32>) -> i32 {\n    if xs.len() == 0 {\n        0\n    } else {\n        if xs.len() == 1 {\n            if xs[0] > 0 { xs[0] } else { 0 }\n        } else {\n            let max_rest = maximum(xs.skip(1));\n            if xs[0] > max_rest { xs[0] } else { max_rest }\n        }\n    }\n}\n\nspec fn sum(xs: Seq<i32>) -> i32 \n    decreases xs.len()\n{\n    if xs.len() == 0 {\n        0\n    } else {\n        xs[0] + sum(xs.skip(1))\n    }\n}", "vc-spec": "spec fn max_sum_spec(arr: Seq<i32>) -> i32 {\n    if arr.len() == 0 {\n        0\n    } else {\n        maximum(arr)\n    }\n}\n\nfn max_sum(arr: Vec<i32>) -> (result: i32)\n    requires arr.len() > 0,\n    ensures result == max_sum_spec(arr@)\n\nfn solve(arr: Vec<i32>, k: usize) -> (result: i32)\n    requires arr.len() > 0,\n    requires k > 0,\n    ensures result >= max_sum_spec(arr@)", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: guarded_and_plausible\n\n    // #guard_msgs in\n    // #eval solve [1, 2] 3\n\n    // #guard_msgs in\n    // #eval solve [1, -2, 1] 2\n\n    // #guard_msgs in\n    // #eval solve [-1, -2, -3] 4\n}"}
{"id": "fvapps_000684", "vc-description": "Chef gives an integer K in the input. If the given number is beautiful binary number, print it, Else find its previous beautiful binary number. A beautiful binary number is a number whose binary representation does not contain any consecutive 1s.\nNote: 1 is also a beautiful binary number.\n\n-----Input:-----\n- First-line will contain T, the number of test cases. Then the test cases follow. \n- Each test case contains a single line of input, one integer K. \n\n-----Output:-----\nFor each test case, print a beautiful number.\n\n-----Constraints-----\n- 1 ≤ T ≤ 10^5\n- 1 ≤ K ≤ 10^5\n\n-----Sample Input:-----\n3\n3\n6\n8\n\n-----Sample Output:-----\n2\n5\n8\n\n-----EXPLANATION:-----\nFor 1) 3 is not a beautiful binary number because the binary representation of 3 is \"11\" which has consecutive 1s.  hence 2 which is less than 3 is printed.\nFor 3) 8 is already a beautiful binary number with no consecutive 1s in its binary representation. so, print 8 as it is.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn string_to_int(s: Seq<char>) -> int\n{\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        if s[0] == '0' { 0 }\n        else if s[0] == '1' { 1 }\n        else if s[0] == '2' { 2 }\n        else if s[0] == '3' { 3 }\n        else if s[0] == '4' { 4 }\n        else if s[0] == '5' { 5 }\n        else if s[0] == '6' { 6 }\n        else if s[0] == '7' { 7 }\n        else if s[0] == '8' { 8 }\n        else if s[0] == '9' { 9 }\n        else { 0 }\n    } else {\n        10 * string_to_int(s.drop_last()) + string_to_int(s.last(1))\n    }\n}", "vc-spec": "fn consecutive_sum(arr: Vec<i32>) -> (result: Vec<String>)\n    requires arr.len() >= 3,\n    ensures \n        result.len() == arr.len() - 2,\n        forall|i: int| 0 <= i < result.len() ==> result[i]@.len() >= 1,\n        forall|i: int| 0 <= i < result.len() ==> {\n            let sum_val = arr[i] + arr[i + 1] + arr[i + 2];\n            string_to_int(result[i]@) == sum_val\n        },\n        forall|i: int| 0 <= i < result.len() ==> {\n            let min_val = if arr[i] <= arr[i + 1] && arr[i] <= arr[i + 2] { arr[i] }\n                         else if arr[i + 1] <= arr[i + 2] { arr[i + 1] }\n                         else { arr[i + 2] };\n            string_to_int(result[i]@) >= min_val\n        },\n        (forall|x: i32| arr@.contains(x) ==> x == 0) ==> \n            (forall|i: int| 0 <= i < result.len() ==> result[i]@ == \"0\"@)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000686", "vc-description": "A city of dimension N x N is constructed with grid of lanes. These lanes are fenced by government so that no one can cross any grid diagonally. Although a train \nline runs diagonally from (0,0) to (N,N).\nOur chef has a weird kind of phobia and is very afraid to cross the railway line. He is at point (0,0) and wants to get to the point (N,N). Calculate number of path \nthrough which it is possible to reach to its destination travelling the minimum distance. .\nNote that: \n\n1. Since he is already at position (0,0) he can go to either part of grid (i.e. left or right part - divided by diagonal) but he will remain in that part for the whole path.\n2. He is afraid to \"cross\" the line, i.e. during the route he can go to position (m,m) where 0\n3. You have to calculate the number of path possible. If there is more than one path then you have to print the number of path of minimum distances. \n\n-----Input-----\nThe first line of the input contains an integer T denoting the number of test cases, for each test case enter the grid size i.e value of N.\n\n-----Output-----\nFor each test case, output a single line with number of such paths possible.\n(Note : If no such path possible print 0)\n\n-----Constraints-----\n- 1 <= T <= 100\n- 0 <= N <= 30\n\n-----Example-----\nInput:\n2\n2\n5\nOutput:\n4\n84", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn count_paths(n: u32) -> (result: u32)\n    ensures \n        result >= 0,\n        result % 2 == 0,\n        (n == 0) ==> (result == 0),", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "proof fn count_paths_nonnegative(n: u32)\n    ensures count_paths(n) >= 0 && count_paths(n) % 2 == 0\n{\n    assume(false);\n}\n\nproof fn count_paths_zero()\n    ensures count_paths(0) == 0\n{\n    assume(false);\n}\n\nproof fn count_paths_monotonic(n: u32)\n    requires n > 0\n    ensures count_paths(n) > count_paths(sub(n, 1))\n{\n    assume(false);\n}\n\nproof fn count_paths_superlinear(n: u32)\n    requires n > 1 && count_paths(sub(n, 1)) > 0\n    ensures count_paths(n) / count_paths(sub(n, 1)) > 1\n{\n    assume(false);\n}\n\n}\n\nfn main() {\n    // assert_eq!(count_paths(2), 4);\n    // assert_eq!(count_paths(5), 84);\n    // assert_eq!(count_paths(0), 0);\n}"}
{"id": "fvapps_000704", "vc-description": "In this problem, you will be given a polynomial, you have to print what it becomes after differentiation.\n\nFollowing are the rules for differentiation:\n- For a polynomial f(x), its differentiation is defined as f'(x).\n- If a is a constant, then differentiation of af(x) is af'(x).\n- If f(x) = h(x) + g(x) , then f'(x) = h'(x) + g'(x) \n- If f(x) = x n, then f'(x) = nxn-1. This is true for all  n ≠ 0 .\n- If f(x) = c, where c is a constant, f'(x) = 0.\n\nIf you are still uncomfortable with differentiation, please read the following:\n-  Link to Wikihow page\n- Link to Wikipedia entry.\n\n-----Input-----\n\nFirst line contains T, the number of test cases to follow. \n\nEach test case contains the follows, the first line contains N, the number of non zero terms in the polynomial. Then N lines follow, each line contains a pair of integer which denotes a term in the polynomial, where the first element denotes the coefficient (a) and the second denotes the exponent (p) of the term.\n\n-----Output-----\nPrint the polynomial after differentiation in the desired format as described below.\n-  If the coefficient of a term in the output polynomial is 3, and the corresponding exponent is 2, print it as 3x^2\n- Print \" + \" (with single space on both side) between each output term.\n-  Print the terms in decreasing value of exponent.\n-  For the constant term (if any), you have to just print the coefficient. You should not print x^0.\n\n-----Constraints-----\n- 1 ≤ T ≤ 10\n-   Subtask 1 (20 points)\n\n- 1 ≤ N ≤ 3\n- 1 ≤ a ≤ 10\n- 0 ≤ p ≤ 10\n- Subtask 2 (80 points)\n\n- 1 ≤ N ≤ 10000\n- 1 ≤ a ≤ 100000000\n- 0 ≤ p ≤ 100000000\n-  No two inputs in a test case will have the same exponent.\n\n-----Example-----\nInput:\n2\n1\n1 2\n3\n1 3\n1 1\n1 0\n\nOutput:\n2x^1\n3x^2 + 1", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn differentiate_polynomial(terms: Vec<(i32, u32)>) -> (result: String)\n    ensures\n        /* If all terms are constant (exponent 0) or empty, result is \"0\" */\n        (terms.is_empty() || forall|i: int| 0 <= i < terms.len() ==> terms[i].1 == 0) ==> result@ == \"0\",\n        /* Constant term (exponent 0) derivatives are 0 */\n        terms.len() == 1 && terms[0].1 == 0 ==> result@ == \"0\",\n        /* Linear term derivatives are just the coefficient */\n        terms.len() == 1 && terms[0].1 == 1 && terms[0].0 != 0 ==> {\n            result@.len() > 0\n        },\n        /* Higher power derivatives follow power rule: d/dx(ax^n) = (a*n)x^(n-1) */\n        terms.len() == 1 && terms[0].0 != 0 && terms[0].1 > 1 ==> {\n            let new_coef = terms[0].0 * (terms[0].1 as i32);\n            let new_exp = terms[0].1 - 1;\n            if new_exp == 0 {\n                result@.len() > 0\n            } else {\n                result@.contains('x')\n            }\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // /* Apps difficulty: interview */\n    // /* Assurance level: unguarded */\n\n    // /* Expected output: '2x^1' */\n    // let result1 = differentiate_polynomial(vec![(1, 2)]);\n    // println!(\"{}\", result1);\n\n    // /* Expected output: '3x^2 + 1' */\n    // let result2 = differentiate_polynomial(vec![(1, 3), (1, 1), (1, 0)]);\n    // println!(\"{}\", result2);\n\n    // /* Expected output: '0' */\n    // let result3 = differentiate_polynomial(vec![(5, 0)]);\n    // println!(\"{}\", result3);\n}"}
{"id": "fvapps_000706", "vc-description": "The Little Elephant and his friends from the Zoo of Lviv were returning from the party. But suddenly they were stopped by the policeman Big Hippo, who wanted to make an alcohol test for elephants.\nThere were N elephants ordered from the left to the right in a row and numbered from 0 to N-1. Let R[i] to be the result of breathalyzer test of i-th elephant.\nConsidering current laws in the Zoo, elephants would be arrested if there exists K consecutive elephants among them for which at least M of these K elephants have the maximal test result among these K elephants.\nUsing poor math notations we can alternatively define this as follows. The elephants would be arrested if there exists i from 0 to N-K, inclusive, such that for at least M different values of j from i to i+K-1, inclusive, we have R[j] = max{R[i], R[i+1], ..., R[i+K-1]}.\n\nThe Big Hippo is very old and the Little Elephant can change some of the results. In a single operation he can add 1 to the result of any elephant. But for each of the elephants he can apply this operation at most once.\nWhat is the minimum number of operations that the Little Elephant needs to apply, such that the sequence of results, after all operations will be applied, let elephants to avoid the arrest? If it is impossible to avoid the arrest applying any number of operations, output -1.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn max_in_range(arr: Seq<i32>, start: int, k: int) -> i32\n    decreases k\n{\n    if k <= 0 || start >= arr.len() {\n        0\n    } else if k == 1 {\n        arr[start]\n    } else {\n        let max_rest = max_in_range(arr, start + 1, k - 1);\n        if arr[start] > max_rest { arr[start] } else { max_rest }\n    }\n}\n\nspec fn count_elements_equal_to_max(arr: Seq<i32>, start: int, k: int) -> int\n    decreases k\n{\n    if k <= 0 || start >= arr.len() {\n        0\n    } else if k == 1 {\n        1\n    } else {\n        let max_val = max_in_range(arr, start, k);\n        let count_rest = count_elements_equal_to_max(arr, start + 1, k - 1);\n        if arr[start] == max_val { 1 + count_rest } else { count_rest }\n    }\n}\n\nspec fn causes_arrest(arr: Seq<i32>, n: int, k: int, m: int) -> bool {\n    exists|i: int| 0 <= i && i <= n - k && count_elements_equal_to_max(arr, i, k) >= m\n}\n\nfn find_min_operations(n: usize, k: usize, m: usize, arr: Vec<i32>) -> (result: i32)\n    requires \n        n > 0,\n        k > 0, \n        m > 0,\n        k <= n,\n        arr.len() == n,\n        forall|i: int| #[trigger] arr[i] && 0 <= i < arr.len() ==> 1 <= arr[i] <= 17\n    ensures\n        result >= -1,\n        (result == -1) ==> (forall|modified_arr: Seq<i32>| {\n            modified_arr.len() == n &&\n            (forall|i: int| #[trigger] modified_arr[i] && 0 <= i < n ==> modified_arr[i] >= arr[i]) &&\n            (forall|i: int| #[trigger] modified_arr[i] && 0 <= i < n ==> modified_arr[i] <= arr[i] + 1)\n        } ==> causes_arrest(modified_arr, n as int, k as int, m as int)),\n        (result >= 0) ==> (exists|modified_arr: Seq<i32>| {\n            modified_arr.len() == n &&\n            (forall|i: int| #[trigger] modified_arr[i] && 0 <= i < n ==> modified_arr[i] >= arr[i]) &&\n            (forall|i: int| #[trigger] modified_arr[i] && 0 <= i < n ==> modified_arr[i] <= arr[i] + 1) &&\n            !causes_arrest(modified_arr, n as int, k as int, m as int)\n        })", "vc-code": "{\n    // impl-start\n    assume(false);\n    -1\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {\n    // let result1 = find_min_operations(5, 3, 2, vec![1, 3, 1, 2, 1]);\n    // println!(\"Result 1: {}\", result1); // Expected: 0\n    \n    // let result2 = find_min_operations(5, 3, 3, vec![7, 7, 7, 7, 7]);\n    // println!(\"Result 2: {}\", result2); // Expected: 1\n    \n    // let result3 = find_min_operations(5, 3, 3, vec![7, 7, 7, 8, 8]);\n    // println!(\"Result 3: {}\", result3); // Expected: 1\n    \n    // let result4 = find_min_operations(4, 3, 1, vec![1, 3, 1, 2]);\n    // println!(\"Result 4: {}\", result4); // Expected: -1\n}"}
{"id": "fvapps_000720", "vc-description": "Mr. X stays in a mansion whose door opens in the North. He travels every morning to meet his friend Ms. Y walking a predefined path.\n\nTo cut the distance short, one day he decides to construct a skywalk from his place to his friend's place. Help him to find the shortest distance between the two residences.\n\n-----Input-----\n\nThe first line contains a single positive integer T <= 100, the number of test cases. T test cases follow. The only line of each test case contains a string which is the path from X to Y. The integer value represents the distance. The character R or L represents a Right or a Left respectively.\n\n-----Output-----\n\nFor each test case, output a single line containing the minimum distance and the direction(N,S,W,E,NE,NW,SE,SW) of Y's residence with respect to X's residence. The output distance should have only 1 decimal place with no approximation. Print \"0.0\" if X's and Y's residence coincide.\n\n-----Example-----\nInput:\n1\n2 L 2 R 2 L 1\n\nOutput:\n5.0NW\n\nExplanation\nMr. X travels 2units and then takes a Left, and then he travels 2units and takes a Right, then after travelling 2units he takes a Left and finally travels 1unit to reach Y's residence.\n(Unlike Input, Output does not have spaces between the distance and direction)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn valid_direction(dir: &str) -> bool {\n    dir == \"\" || dir == \"N\" || dir == \"S\" || dir == \"E\" || dir == \"W\" || \n    dir == \"NE\" || dir == \"NW\" || dir == \"SE\" || dir == \"SW\"\n}\n\nspec fn is_direction_char(s: &str) -> bool {\n    s == \"L\" || s == \"R\"\n}\n\nspec fn total_path_distance(moves: Seq<String>) -> nat\n    decreases moves.len()\n{\n    if moves.len() == 0 {\n        0\n    } else {\n        let first = moves[0].as_str();\n        if is_direction_char(first) {\n            total_path_distance(moves.skip(1))\n        } else {\n            1 + total_path_distance(moves.skip(1))  /* simplified numeric parsing */\n        }\n    }\n}\n\nspec fn extract_distance_from_result(result: String) -> nat {\n    if result.as_str() == \"0.0\" {\n        0\n    } else {\n        1  /* simplified distance extraction */\n    }\n}\n\nspec fn has_valid_direction_suffix(result: String) -> bool {\n    exists|dir: String| valid_direction(dir.as_str()) && \n        (result.len() >= dir.len() && \n         result.subrange((result.len() - dir.len()) as int, result.len() as int) == dir.as_str())\n}\n\nfn process(moves: Vec<String>) -> (result: String)\n    ensures\n        has_valid_direction_suffix(result) || result.as_str() == \"0.0\",\n        extract_distance_from_result(result) <= total_path_distance(moves@),\n        (moves@ == seq![\"1\".to_string(), \"R\".to_string(), \"1\".to_string(), \"R\".to_string(), \"1\".to_string(), \"R\".to_string(), \"1\".to_string()]) ==> result.as_str() == \"0.0\",\n        (moves.len() == 1 && !is_direction_char(moves[0].as_str())) ==> has_valid_direction_suffix(result),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000723", "vc-description": "Rakesh has built a model rocket and wants to test how stable it is. He usually uses a magic box which runs some tests on the rocket and tells if it is stable or not, but his friend broke it by trying to find out how stable he is (very delicate magic indeed). The box only gives a polynomial equation now which can help Rakesh find the stability (a failsafe by the manufacturers). \n\nRakesh reads the manual for the magic box and understands that in order to determine stability, he needs to take every other term and put them in two rows. Eg. If the polynomial is:\n10 x^4 + 12 x^3 + 4 x^2 + 5 x + 3, the first two rows will be: \n\nRow 1: 10       4       3\n\nRow 2: 12       5       0\n\nFor all other rows, the nth element of the rth row is found recursively by multiplying the 1st element of the (r-1)th row and (n+1)th element of the (r-2)th row and subtracting it with 1st element of the (r-2)th row multiplied by (n+1)th element of the (r-1)th row.\n\nSo Row 3 will be (12 * 4 - 10 * 5)   (12 * 3 - 10 * 0)\n\nRow 3: -2           36      0\n\nRow 4: -442        0       0\n\nRow 5: -15912    0       0\n\nThere will not be any row six (number of rows = maximum power of x + 1)\n\nThe rocket is stable if there are no sign changes in the first column. \n\nIf all the elements of the rth row are 0, replace the nth element of the rth row by the nth element of the (r-1)th row multiplied by (maximum power of x + 4 - r - 2n).\n\nIf the first element of any row is 0 and some of the other elements are non zero, the rocket is unstable.\n\nCan you help Rakesh check if his rocket is stable?\n\nInput Format:\n\n1. First row with number of test cases (T).\n\n2. Next T rows with the coefficients of the polynomials for each case (10 12 4 5 3 for the case above).\n\nOutput Format:\n\n1. \"1\" if stable (without \"\")\n\n2. \"0\" if unstable (without \"\")\n\nSample Input: \n\n1\n\n10 12 4 5 3\n\nSample Output:\n\n0", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn check_rocket_stability_spec(coeff: Seq<i32>) -> u32 \n{\n    if coeff.len() == 0 { 1 }\n    else if coeff.len() == 1 { 1 }\n    else if forall|i: int| 0 <= i < coeff.len() ==> coeff[i] == 0 { 1 }\n    else { 0 } // placeholder specification\n}\n\nfn check_rocket_stability(coeff: Vec<i32>) -> (result: u32)\n    ensures result == 0 || result == 1", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\nproof fn check_rocket_binary(coeff: Vec<i32>)\n    ensures check_rocket_stability(coeff) == 0 || check_rocket_stability(coeff) == 1\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn zeros_stable(zeros: Vec<i32>)\n    requires forall|i: int| 0 <= i < zeros.len() ==> zeros[i] == 0,\n    ensures check_rocket_stability(zeros) == 1\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn single_coeff_stable(coeff: Vec<i32>)\n    requires coeff.len() == 1,\n    ensures check_rocket_stability(coeff) == 1\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\nproof fn copy_safety(coeff: Vec<i32>)\n    ensures check_rocket_stability(coeff) == 0 || check_rocket_stability(coeff) == 1\n{\n    assume(false); // TODO: Remove this line and implement the proof\n}\n\n}\n\nfn main() {\n    // Apps difficulty: interview\n    // Assurance level: unguarded\n\n    // check_rocket_stability([10, 12, 4, 5, 3]) should output 0\n    // check_rocket_stability([0, 0, 0]) should output 1\n    // check_rocket_stability([5]) should output 1\n}"}
{"id": "fvapps_000757", "vc-description": "You are given an integer D. Find an integer sequence A_1, A_2, ..., A_N such that the following conditions are satisfied:\n- 1 ≤ N ≤ 10^5\n- 1 ≤ A_i ≤ 10^5 for each valid i\n- ∑_{i=1}^N ∑_{j=i}^N (min(A_i, A_{i+1}, ..., A_j) - GCD(A_i, A_{i+1}, ..., A_j)) = D\nIt can be proved that a solution always exists under the given constraints.\nNote: GCD(B_1, B_2, ..., B_M) is the greatest integer which divides all the integers B_1, B_2, ..., B_M.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn gcd_two(a: u32, b: u32) -> u32 \n    decreases vstd::math::max(a as int, b as int)\n{\n    if b == 0 {\n        a\n    } else {\n        gcd_two(b, a % b)\n    }\n}\n\nspec fn gcd_seq(s: Seq<u32>) -> u32\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        s[0]\n    } else {\n        gcd_two(s[0], gcd_seq(s.skip(1)))\n    }\n}\n\nspec fn min_two(a: u32, b: u32) -> u32 {\n    if a <= b { a } else { b }\n}\n\nspec fn min_seq(s: Seq<u32>) -> u32 \n    decreases s.len()\n{\n    if s.len() == 0 {\n        u32::MAX\n    } else if s.len() == 1 {\n        s[0]\n    } else {\n        min_two(s[0], min_seq(s.skip(1)))\n    }\n}\n\nspec fn solve_sequence_spec(d: u32) -> Seq<u32>;\n\nfn solve_sequence(d: u32) -> (result: Vec<u32>)\n    ensures\n        result.len() >= 1 && result.len() <= 100000,\n        forall|i: int| 0 <= i < result.len() ==> result[i] >= 1 && result[i] <= 100000,\n        result@ == solve_sequence_spec(d)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fvapps_000801", "vc-description": "You are given n intervals on the X axis. Each interval i is specified by its ends [L_i, R_i]. You want to color each interval either blue or yellow. After coloring all the intervals, the X axis will will have 4 colors:\n- White, the part of X axis contained in no interval\n- Blue, the part of X axis contained in atleast one blue colored interval and no yellow colored interval.\n- Yellow, the part of X axis contained in atleast one yellow colored interval and no blue colored interval.\n- Green, the part of X axis contained in at least one blue colored interval and at least one yellow colored interval.\nYou want to color the intervals so that the total length of the part colored green is maximized. If there are multiple ways to color which maximize the green part, you can output any of them.\n\n-----Input:-----\n- First line will contain T, number of testcases. Then the testcases follow. \n- The first line of each testcase contains n, the number of intervals.\n- The i^{th} of the next n lines contains two integers L_i and R_i describing the i^{th} interval.\n\n-----Output:-----\nFor each testcase, output a single string on a new line, whose i^{th} character is 0 if you color the i^{th} interval blue, and 1 if you color it yellow.\n\n-----Constraints-----\n- 1 ≤ T ≤ 10^5\n- 1 ≤ n ≤ 10^5\n- The sum of n over all testcases doesn't exceed 10^5.\n- 1 ≤ L_i ≤ R_i ≤ 10^9 for al 1 ≤ i ≤ n.\n\n-----Sample Input:-----\n1\n3\n3 7\n2 5\n6 9\n\n-----Sample Output:-----\n100\n\n-----Explanation:-----\nThe intervals are [3, 7], [2, 5], [6, 9]. It is optimal to color them in yellow, blue and blue respectively. In this coloring:\n- [2, 3) ∪ (7, 9] is colored blue.\n- (5, 6) is colored yellow.\n- [3, 5] ∪ [6, 7] is colored green, with a total length of (5 - 3) + (7 - 6) = 3.\n- Rest of the X axis is colored white.\nPlease note that colors at the endpoints of the intervals don't matter when computing the lengths, and we can ignore them. Open and closed intervals have been used in the explanation section only for clarity, and it doesn't matter whether they are open or closed.\nNote that 011 is also a valid output.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "type Interval = (i32, i32);\n\nspec fn unique_chars_in_bytes(s: Seq<u8>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        let first = s[0];\n        let rest_unique = unique_chars_in_bytes(s.skip(1));\n        if s.skip(1).contains(first) {\n            rest_unique\n        } else {\n            rest_unique + 1\n        }\n    }\n}\n\nfn color_intervals(intervals: Vec<Interval>) -> (result: Vec<u8>)\n    ensures \n        result.len() == intervals.len(),\n        forall|i: int| 0 <= i < result.len() ==> {\n            #[trigger] result[i] == 48u8 || #[trigger] result[i] == 49u8\n        },\n        /* For non-overlapping intervals, at most 2 distinct colors are used */\n        intervals.len() >= 2 ==> \n            (forall|i: int, j: int| 0 <= i < intervals.len() && 0 <= j < intervals.len() && i != j ==> {\n                let int_i = intervals[i];\n                let int_j = intervals[j];\n                int_i.0 < int_i.1 && int_j.0 < int_j.1 ==> \n                    (int_i.1 < int_j.0 || int_j.1 < int_i.0)\n            }) ==> {\n                unique_chars_in_bytes(result@) <= 2\n            }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {\n    // /* Apps difficulty: interview */\n    // /* Assurance level: unguarded */\n    // \n    // let test_intervals = vec![(3, 7), (2, 5), (6, 9)];\n    // let result = color_intervals(test_intervals);\n    // let result_string = String::from_utf8(result).unwrap();\n    // println!(\"{}\", result_string); /* Expected: \"100\" */\n}"}
