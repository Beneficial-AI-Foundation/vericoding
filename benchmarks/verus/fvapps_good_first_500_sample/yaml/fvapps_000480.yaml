vc-description: |-
  Consider the string s to be the infinite wraparound string of "abcdefghijklmnopqrstuvwxyz", so s will look like this: "...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....".

  Now we have another string p. Your job is to find out how many unique non-empty substrings of p are present in s. In particular, your input is the string p and you need to output the number of different non-empty substrings of p in the string s.

  Note: p consists of only lowercase English letters and the size of p might be over 10000.

  Example 1:

  Input: "a"
  Output: 1

  Explanation: Only the substring "a" of string "a" is in the string s.

  Example 2:

  Input: "cac"
  Output: 2
  Explanation: There are two substrings "a", "c" of string "cac" in the string s.

  Example 3:

  Input: "zab"
  Output: 6
  Explanation: There are six substrings "z", "a", "b", "za", "ab", "zab" of string "zab" in the string s.
vc-preamble: |-
  use vstd::prelude::*;

  verus! {
vc-helpers: |-

vc-spec: |-
  fn find_substrings_in_wraparound(s: Vec<u8>) -> (result: usize)
      ensures 
          result >= 0,
          s.len() >= 1 ==> result >= 1
vc-code: |-
  {
      // impl-start
      assume(false);
      unreached()
      // impl-end
  }
vc-postamble: |-

  }
  fn main() {
      // Apps difficulty: interview
      // Assurance level: guarded_and_plausible

      // Expected output: 1
      // find_substrings_in_wraparound("a".as_bytes().to_vec());

      // Expected output: 2
      // find_substrings_in_wraparound("cac".as_bytes().to_vec());

      // Expected output: 6
      // find_substrings_in_wraparound("zab".as_bytes().to_vec());
  }