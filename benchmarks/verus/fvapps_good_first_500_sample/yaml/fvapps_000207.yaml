vc-description: |-
  Given a string s, return the maximum number of unique substrings that the given string can be split into.
  You can split string s into any list of non-empty substrings, where the concatenation of the substrings forms the original string. However, you must split the substrings such that all of them are unique.
  A substring is a contiguous sequence of characters within a string.
  
  Example 1:
  Input: s = "ababccc"
  Output: 5
  Explanation: One way to split maximally is ['a', 'b', 'ab', 'c', 'cc']. Splitting like ['a', 'b', 'a', 'b', 'c', 'cc'] is not valid as you have 'a' and 'b' multiple times.
  
  Example 2:
  Input: s = "aba"
  Output: 2
  Explanation: One way to split maximally is ['a', 'ba'].
  
  Example 3:
  Input: s = "aa"
  Output: 1
  Explanation: It is impossible to split the string any further.
  
  Constraints:
  
  1 <= s.length <= 16
  
  s contains only lower case English letters.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-

vc-spec: |-
  spec fn max_unique_split(s: Seq<char>) -> nat;

  fn max_unique_split_exec(s: Vec<char>) -> (result: usize)
      requires s.len() >= 1,
      ensures 
          result >= 1,
          result <= s.len(),
          result == max_unique_split(s@),

vc-code: |-
  {
      // impl-start
      assume(false);
      unreached()
      // impl-end
  }

  proof fn max_unique_split_single_char(s: Seq<char>)
      requires s.len() == 1,
      ensures max_unique_split(s) == 1,
  {
      assume(false); // TODO: Remove this line and implement the proof
  }

  proof fn max_unique_split_aa()
      ensures max_unique_split(seq!['a', 'a']) == 1,
  {
      assume(false); // TODO: Remove this line and implement the proof
  }

  proof fn max_unique_split_aba()
      ensures max_unique_split(seq!['a', 'b', 'a']) == 2,
  {
      assume(false); // TODO: Remove this line and implement the proof
  }

vc-postamble: |-

  }

  fn main() {}