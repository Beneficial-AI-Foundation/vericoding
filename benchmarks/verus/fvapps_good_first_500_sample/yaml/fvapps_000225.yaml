vc-description: |-
  Given an array of integers A with even length, return true if and only if it is possible to reorder it such that A[2 * i + 1] = 2 * A[2 * i] for every 0 <= i < len(A) / 2.

  Example 1:
  Input: A = [3,1,3,6]
  Output: false

  Example 2:
  Input: A = [2,1,2,6]
  Output: false

  Example 3:
  Input: A = [4,-2,2,-4]
  Output: true
  Explanation: We can take two groups, [-2,-4] and [2,4] to form [-2,-4,2,4] or [2,4,-2,-4].

  Example 4:
  Input: A = [1,2,4,16,8,4]
  Output: false

  Constraints:

  0 <= A.length <= 3 * 104
  A.length is even.
  -105 <= A[i] <= 105
vc-preamble: |-
  use vstd::prelude::*;

  verus! {
vc-helpers: |-
  spec fn count_occurrences(n: i32, lst: Seq<i32>) -> nat
      decreases lst.len()
  {
      if lst.len() == 0 {
          0nat
      } else {
          (if lst[0] == n { 1nat } else { 0nat }) + count_occurrences(n, lst.skip(1))
      }
  }
vc-spec: |-
  fn can_reorder_doubled(lst: Vec<i32>) -> (result: bool)
      requires lst.len() % 2 == 0,
      ensures
          lst@.len() == 0 ==> result == true,
          (forall|i: int| 0 <= i < lst@.len() ==> lst@[i] == 0) ==> result == true
vc-code: |-
  {
      // impl-start
      assume(false);
      false
      // impl-end
  }
vc-postamble: |-
  }

  fn main() {
      // let result1 = can_reorder_doubled(vec![3, 1, 3, 6]);
      // assert(result1 == false);
      
      // let result2 = can_reorder_doubled(vec![4, -2, 2, -4]);
      // assert(result2 == true);
      
      // let result3 = can_reorder_doubled(vec![1, 2, 4, 16, 8, 4]);
      // assert(result3 == false);
  }