vc-description: |-
  You have a rectangular chocolate bar consisting of n × m single squares. You want to eat exactly k squares, so you may need to break the chocolate bar. 

  In one move you can break any single rectangular piece of chocolate in two rectangular pieces. You can break only by lines between squares: horizontally or vertically. The cost of breaking is equal to square of the break length.

  For example, if you have a chocolate bar consisting of 2 × 3 unit squares then you can break it horizontally and get two 1 × 3 pieces (the cost of such breaking is 3^2 = 9), or you can break it vertically in two ways and get two pieces: 2 × 1 and 2 × 2 (the cost of such breaking is 2^2 = 4).

  For several given values n, m and k find the minimum total cost of breaking. You can eat exactly k squares of chocolate if after all operations of breaking there is a set of rectangular pieces of chocolate with the total size equal to k squares. The remaining n·m - k squares are not necessarily form a single rectangular piece.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-

vc-spec: |-
  fn find_min_chocolate_break_cost(n: nat, m: nat, k: nat) -> (result: nat)
      requires 
          n > 0,
          m > 0,
          k <= 25,
      ensures 
          (n * m == k) ==> (result == 0),
          (k == 0) ==> (result == 0),

vc-code: |-
  {
      // impl-start
      assume(false);
      unreached()
      // impl-end
  }

vc-postamble: |-
  }

  fn main() {
      // let result1 = find_min_chocolate_break_cost(2, 2, 1);
      // assert(result1 == 5);
      
      // let result2 = find_min_chocolate_break_cost(2, 2, 3);
      // assert(result2 == 5);
      
      // let result3 = find_min_chocolate_break_cost(2, 2, 4);
      // assert(result3 == 0);
  }