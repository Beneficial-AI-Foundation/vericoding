vc-description: |-
  Chef found a strange string yesterday - a string of signs s, where each sign is either a '<', '=' or a '>'. Let N be the length of this string. Chef wants to insert N + 1 positive integers into this sequence and make it valid. A valid sequence is a sequence where every sign is preceded and followed by an integer, and the signs are correct. That is, if a sign '<' is preceded by the integer a and followed by an integer b, then a should be less than b. Likewise for the other two signs as well. 
  Chef can take some positive integers in the range [1, P] and use a number in the range as many times as he wants.
  Help Chef find the minimum possible P with which he can create a valid sequence.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-

vc-spec: |-
  spec fn find_min_valid_sequence(s: &str) -> u32 {
      1
  }

vc-code: |-
  // Placeholder implementation - not the actual algorithm

vc-postamble: |-
  proof fn output_positive(s: &str)
      ensures find_min_valid_sequence(s) >= 1
  {
  }

  proof fn equals_removal(s: &str, no_equals: &str)
      ensures find_min_valid_sequence(s) == find_min_valid_sequence(no_equals)
  {
      assume(false); // TODO: Remove this line and implement the proof
  }

  proof fn empty_string()
      ensures find_min_valid_sequence("") == 1
  {
  }

  proof fn single_equals()
      ensures find_min_valid_sequence("=") == 1
  {
  }

  proof fn multiple_equals()
      ensures find_min_valid_sequence("===") == 1
  {
  }

  }

  fn main() {
      // Apps difficulty: interview
      // Assurance level: guarded_and_plausible
      
      // assert(find_min_valid_sequence("<<<") == 4);
      // assert(find_min_valid_sequence("<><") == 2);
      // assert(find_min_valid_sequence("<=>") == 2);
      // assert(find_min_valid_sequence("<=<") == 3);
  }