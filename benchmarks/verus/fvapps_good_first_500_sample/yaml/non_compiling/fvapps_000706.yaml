vc-description: |-
  The Little Elephant and his friends from the Zoo of Lviv were returning from the party. But suddenly they were stopped by the policeman Big Hippo, who wanted to make an alcohol test for elephants.
  There were N elephants ordered from the left to the right in a row and numbered from 0 to N-1. Let R[i] to be the result of breathalyzer test of i-th elephant.
  Considering current laws in the Zoo, elephants would be arrested if there exists K consecutive elephants among them for which at least M of these K elephants have the maximal test result among these K elephants.
  Using poor math notations we can alternatively define this as follows. The elephants would be arrested if there exists i from 0 to N-K, inclusive, such that for at least M different values of j from i to i+K-1, inclusive, we have R[j] = max{R[i], R[i+1], ..., R[i+K-1]}.

  The Big Hippo is very old and the Little Elephant can change some of the results. In a single operation he can add 1 to the result of any elephant. But for each of the elephants he can apply this operation at most once.
  What is the minimum number of operations that the Little Elephant needs to apply, such that the sequence of results, after all operations will be applied, let elephants to avoid the arrest? If it is impossible to avoid the arrest applying any number of operations, output -1.
vc-preamble: |-
  use vstd::prelude::*;

  verus! {
vc-helpers: |-

vc-spec: |-
  spec fn max_in_range(arr: Seq<i32>, start: int, k: int) -> i32
      decreases k
  {
      if k <= 0 || start >= arr.len() {
          0
      } else if k == 1 {
          arr[start]
      } else {
          let max_rest = max_in_range(arr, start + 1, k - 1);
          if arr[start] > max_rest { arr[start] } else { max_rest }
      }
  }

  spec fn count_elements_equal_to_max(arr: Seq<i32>, start: int, k: int) -> int
      decreases k
  {
      if k <= 0 || start >= arr.len() {
          0
      } else if k == 1 {
          1
      } else {
          let max_val = max_in_range(arr, start, k);
          let count_rest = count_elements_equal_to_max(arr, start + 1, k - 1);
          if arr[start] == max_val { 1 + count_rest } else { count_rest }
      }
  }

  spec fn causes_arrest(arr: Seq<i32>, n: int, k: int, m: int) -> bool {
      exists|i: int| 0 <= i && i <= n - k && count_elements_equal_to_max(arr, i, k) >= m
  }

  fn find_min_operations(n: usize, k: usize, m: usize, arr: Vec<i32>) -> (result: i32)
      requires 
          n > 0,
          k > 0, 
          m > 0,
          k <= n,
          arr.len() == n,
          forall|i: int| #[trigger] arr[i] && 0 <= i < arr.len() ==> 1 <= arr[i] <= 17
      ensures
          result >= -1,
          (result == -1) ==> (forall|modified_arr: Seq<i32>| {
              modified_arr.len() == n &&
              (forall|i: int| #[trigger] modified_arr[i] && 0 <= i < n ==> modified_arr[i] >= arr[i]) &&
              (forall|i: int| #[trigger] modified_arr[i] && 0 <= i < n ==> modified_arr[i] <= arr[i] + 1)
          } ==> causes_arrest(modified_arr, n as int, k as int, m as int)),
          (result >= 0) ==> (exists|modified_arr: Seq<i32>| {
              modified_arr.len() == n &&
              (forall|i: int| #[trigger] modified_arr[i] && 0 <= i < n ==> modified_arr[i] >= arr[i]) &&
              (forall|i: int| #[trigger] modified_arr[i] && 0 <= i < n ==> modified_arr[i] <= arr[i] + 1) &&
              !causes_arrest(modified_arr, n as int, k as int, m as int)
          })
vc-code: |-
  {
      // impl-start
      assume(false);
      -1
      // impl-end
  }
vc-postamble: |-

  }
  fn main() {
      // let result1 = find_min_operations(5, 3, 2, vec![1, 3, 1, 2, 1]);
      // println!("Result 1: {}", result1); // Expected: 0
      
      // let result2 = find_min_operations(5, 3, 3, vec![7, 7, 7, 7, 7]);
      // println!("Result 2: {}", result2); // Expected: 1
      
      // let result3 = find_min_operations(5, 3, 3, vec![7, 7, 7, 8, 8]);
      // println!("Result 3: {}", result3); // Expected: 1
      
      // let result4 = find_min_operations(4, 3, 1, vec![1, 3, 1, 2]);
      // println!("Result 4: {}", result4); // Expected: -1
  }