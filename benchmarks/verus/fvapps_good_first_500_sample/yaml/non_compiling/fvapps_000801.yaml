vc-description: |-
  You are given n intervals on the X axis. Each interval i is specified by its ends [L_i, R_i]. You want to color each interval either blue or yellow. After coloring all the intervals, the X axis will will have 4 colors:
  - White, the part of X axis contained in no interval
  - Blue, the part of X axis contained in atleast one blue colored interval and no yellow colored interval.
  - Yellow, the part of X axis contained in atleast one yellow colored interval and no blue colored interval.
  - Green, the part of X axis contained in at least one blue colored interval and at least one yellow colored interval.
  You want to color the intervals so that the total length of the part colored green is maximized. If there are multiple ways to color which maximize the green part, you can output any of them.

  -----Input:-----
  - First line will contain T, number of testcases. Then the testcases follow. 
  - The first line of each testcase contains n, the number of intervals.
  - The i^{th} of the next n lines contains two integers L_i and R_i describing the i^{th} interval.

  -----Output:-----
  For each testcase, output a single string on a new line, whose i^{th} character is 0 if you color the i^{th} interval blue, and 1 if you color it yellow.

  -----Constraints-----
  - 1 ≤ T ≤ 10^5
  - 1 ≤ n ≤ 10^5
  - The sum of n over all testcases doesn't exceed 10^5.
  - 1 ≤ L_i ≤ R_i ≤ 10^9 for al 1 ≤ i ≤ n.

  -----Sample Input:-----
  1
  3
  3 7
  2 5
  6 9

  -----Sample Output:-----
  100

  -----Explanation:-----
  The intervals are [3, 7], [2, 5], [6, 9]. It is optimal to color them in yellow, blue and blue respectively. In this coloring:
  - [2, 3) ∪ (7, 9] is colored blue.
  - (5, 6) is colored yellow.
  - [3, 5] ∪ [6, 7] is colored green, with a total length of (5 - 3) + (7 - 6) = 3.
  - Rest of the X axis is colored white.
  Please note that colors at the endpoints of the intervals don't matter when computing the lengths, and we can ignore them. Open and closed intervals have been used in the explanation section only for clarity, and it doesn't matter whether they are open or closed.
  Note that 011 is also a valid output.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-

vc-spec: |-
  type Interval = (i32, i32);

  spec fn unique_chars_in_bytes(s: Seq<u8>) -> nat
      decreases s.len()
  {
      if s.len() == 0 {
          0
      } else {
          let first = s[0];
          let rest_unique = unique_chars_in_bytes(s.skip(1));
          if s.skip(1).contains(first) {
              rest_unique
          } else {
              rest_unique + 1
          }
      }
  }

  fn color_intervals(intervals: Vec<Interval>) -> (result: Vec<u8>)
      ensures 
          result.len() == intervals.len(),
          forall|i: int| 0 <= i < result.len() ==> {
              #[trigger] result[i] == 48u8 || #[trigger] result[i] == 49u8
          },
          /* For non-overlapping intervals, at most 2 distinct colors are used */
          intervals.len() >= 2 ==> 
              (forall|i: int, j: int| 0 <= i < intervals.len() && 0 <= j < intervals.len() && i != j ==> {
                  let int_i = intervals[i];
                  let int_j = intervals[j];
                  int_i.0 < int_i.1 && int_j.0 < int_j.1 ==> 
                      (int_i.1 < int_j.0 || int_j.1 < int_i.0)
              }) ==> {
                  unique_chars_in_bytes(result@) <= 2
              }

vc-code: |-
  {
      // impl-start
      assume(false);
      unreached()
      // impl-end
  }

vc-postamble: |-

  }

  fn main() {
      // /* Apps difficulty: interview */
      // /* Assurance level: unguarded */
      // 
      // let test_intervals = vec![(3, 7), (2, 5), (6, 9)];
      // let result = color_intervals(test_intervals);
      // let result_string = String::from_utf8(result).unwrap();
      // println!("{}", result_string); /* Expected: "100" */
  }