vc-description: |-
  Given two strings S and T, each of which represents a non-negative rational number, return True if and only if they represent the same number. The strings may use parentheses to denote the repeating part of the rational number.
  In general a rational number can be represented using up to three parts: an integer part, a non-repeating part, and a repeating part. The number will be represented in one of the following three ways:

  <IntegerPart> (e.g. 0, 12, 123)
  <IntegerPart><.><NonRepeatingPart>  (e.g. 0.5, 1., 2.12, 2.0001)
  <IntegerPart><.><NonRepeatingPart><(><RepeatingPart><)> (e.g. 0.1(6), 0.9(9), 0.00(1212))

  The repeating portion of a decimal expansion is conventionally denoted within a pair of round brackets.  For example:
  1 / 6 = 0.16666666... = 0.1(6) = 0.1666(6) = 0.166(66)
  Both 0.1(6) or 0.1666(6) or 0.166(66) are correct representations of 1 / 6.

  Example 1:
  Input: S = "0.(52)", T = "0.5(25)"
  Output: true
  Explanation:
  Because "0.(52)" represents 0.52525252..., and "0.5(25)" represents 0.52525252525..... , the strings represent the same number.

  Example 2:
  Input: S = "0.1666(6)", T = "0.166(66)"
  Output: true

  Example 3:
  Input: S = "0.9(9)", T = "1."
  Output: true
  Explanation: 
  "0.9(9)" represents 0.999999999... repeated forever, which equals 1.  [See this link for an explanation.]
  "1." represents the number 1, which is formed correctly: (IntegerPart) = "1" and (NonRepeatingPart) = "".

  Note:

  Each part consists only of digits.
  The <IntegerPart> will not begin with 2 or more zeros.  (There is no other restriction on the digits of each part.)
  1 <= <IntegerPart>.length <= 4 
  0 <= <NonRepeatingPart>.length <= 4 
  1 <= <RepeatingPart>.length <= 4

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-

vc-spec: |-
  fn is_rational_equal(s1: &str, s2: &str) -> (result: bool) {
      // impl-start
      assume(false);
      false
      // impl-end
  }

  fn make_rational_str(n: i32, d: i32) -> (result: String)
      requires d > 0
  {
      // impl-start
      assume(false);
      "0".to_string()
      // impl-end
  }

  proof fn equivalent_fractions(n1: i32, d1: i32, n2: i32, d2: i32)
      requires
          d1 > 0,
          d2 > 0,
          n1 >= -1000,
          n1 <= 1000,
          d1 <= 100,
          n2 >= -1000,
          n2 <= 1000,
          d2 <= 100,
          n1 / d1 == n2 / d2,
      ensures
          is_rational_equal(&make_rational_str(n1, d1), &make_rational_str(n2, d2)) == true
  {
      assume(false); // TODO: Remove this line and implement the proof
  }

  proof fn repeating_nines(n: usize)
      requires
          n > 0,
          n <= 9,
      ensures
          is_rational_equal(&format!("0.{}(9)", "9".repeat(n)), "1.") == true
  {
      assume(false); // TODO: Remove this line and implement the proof
  }

vc-code: |-

vc-postamble: |-
  }

  fn main() {
      // Apps difficulty: interview
      // Assurance level: unguarded

      // Example tests commented out for verification:
      // assert(is_rational_equal("0.(52)", "0.5(25)") == true);
      // assert(is_rational_equal("0.1666(6)", "0.166(66)") == true);
      // assert(is_rational_equal("0.9(9)", "1.") == true);
  }