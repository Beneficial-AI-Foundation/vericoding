vc-description: |-
  Given an array nums of integers, a move consists of choosing any element and decreasing it by 1.
  An array A is a zigzag array if either:

  Every even-indexed element is greater than adjacent elements, ie. A[0] > A[1] < A[2] > A[3] < A[4] > ...
  OR, every odd-indexed element is greater than adjacent elements, ie. A[0] < A[1] > A[2] < A[3] > A[4] < ...

  Return the minimum number of moves to transform the given array nums into a zigzag array.

  Example 1:
  Input: nums = [1,2,3]
  Output: 2
  Explanation: We can decrease 2 to 0 or 3 to 1.

  Example 2:
  Input: nums = [9,6,1,6,2]
  Output: 4

  Constraints:

  1 <= nums.length <= 1000
  1 <= nums[i] <= 1000
vc-preamble: |-
  use vstd::prelude::*;

  verus! {
vc-helpers: |-

vc-spec: |-
  fn moves_to_make_zigzag(nums: Vec<nat>) -> (result: nat)
      ensures result >= 0,
      ensures nums.len() == 1 ==> result == 0,
      ensures result == 0 && nums.len() >= 2 ==> (
          forall|i: int| 1 <= i < nums.len() - 1 ==> (
              (nums[i] > nums[i-1] && nums[i] > nums[i+1]) ||
              (nums[i] < nums[i-1] && nums[i] < nums[i+1])
          )
      )

  proof fn moves_nonnegative(nums: Vec<nat>)
      ensures moves_to_make_zigzag(nums) >= 0

  proof fn single_element_zero(nums: Vec<nat>)
      requires nums.len() == 1
      ensures moves_to_make_zigzag(nums) == 0

  proof fn zigzag_no_moves(nums: Vec<nat>, i: nat)
      requires nums.len() >= 2,
      requires moves_to_make_zigzag(nums) == 0,
      requires 1 <= i < nums.len() - 1
      ensures (nums[i] > nums[i-1] && nums[i] > nums[i+1]) ||
              (nums[i] < nums[i-1] && nums[i] < nums[i+1])

  spec fn reverse_vec(nums: Seq<nat>) -> Seq<nat>
      decreases nums.len()
  {
      if nums.len() == 0 {
          seq![]
      } else {
          reverse_vec(nums.drop_last()).push(nums[nums.len() - 1])
      }
  }

  proof fn symmetric_solution(nums: Vec<nat>)
      ensures moves_to_make_zigzag(nums) == moves_to_make_zigzag(reverse_vec(nums@).to_vec())
vc-code: |-
  {
      // impl-start
      assume(false);
      0nat
      // impl-end
  }

  {
      // impl-start
      assume(false);
      // impl-end
  }

  {
      // impl-start
      assume(false);
      // impl-end
  }

  {
      // impl-start
      assume(false);
      // impl-end
  }

  {
      // impl-start
      assume(false);
      // impl-end
  }
vc-postamble: |-

  }

  fn main() {
      // Apps difficulty: interview
      // Assurance level: unguarded

      // Example usage (commented out for verification):
      // let result1 = moves_to_make_zigzag(vec![1, 2, 3]);
      // assert_eq!(result1, 2);
      
      // let result2 = moves_to_make_zigzag(vec![9, 6, 1, 6, 2]);
      // assert_eq!(result2, 4);
      
      // let result3 = moves_to_make_zigzag(vec![1]);
      // assert_eq!(result3, 0);
  }