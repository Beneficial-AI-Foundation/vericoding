vc-description: |-
  You are given a string S and an integer L. A operation is described as :- "You are allowed to pick any substring from first L charcaters of S, and place it at the end of the string S. 
  A string A is a substring of an string B if A can be obtained from B by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) elements from the end.
  Find the lexographically smallest string after performing this opertaion any number of times (possibly zero).
  For example S = "codechef" and L=4. Then, we can take substring "ode" from S[0-3] and place it at end of the string S = "cchefode".

  -----Input:-----
  - First line will contain T, number of testcases. 
  - Then each of the N lines contain an integer L and a string S. 

  -----Output:-----
  For each testcase, output in a single line answer lexographically smallest string.

  -----Constraints-----
  - 1 ≤ T ≤ 10^4
  - 2 ≤ |S| ≤ 10^3
  - 1 ≤ L ≤ N 

  -----Sample Input:-----
  2
  1 rga
  2 cab

  -----Sample Output:-----
  arg
  abc

  -----EXPLANATION:-----
  In the first testcase:
  substring 'r' is picked and placed at the end of the string. rga -> gar
  Then performing same operation gives :- gar -> arg

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-

vc-spec: |-
  spec fn char_count(s: Seq<char>, c: char) -> nat
      decreases s.len()
  {
      if s.len() == 0 {
          0nat
      } else {
          (if s[0] == c { 1nat } else { 0nat }) + char_count(s.skip(1), c)
      }
  }

  spec fn is_rotation(s1: Seq<char>, s2: Seq<char>) -> bool {
      s1.len() == s2.len() && 
      exists|i: int| 0 <= i < s1.len() && s2 == s1.skip(i) + s1.take(i)
  }

  spec fn lex_compare(s1: Seq<char>, s2: Seq<char>) -> bool
      decreases s1.len() + s2.len()
  {
      if s1.len() == 0 { true }
      else if s2.len() == 0 { false }
      else if s1[0] < s2[0] { true }
      else if s1[0] > s2[0] { false }
      else { lex_compare(s1.skip(1), s2.skip(1)) }
  }

  fn solve(l: usize, s: Vec<char>) -> (result: Vec<char>)
      requires 
          l >= 1,
          l <= s.len(),
          s.len() > 0,
      ensures
          result.len() == s.len(),
          forall|c: char| char_count(result@, c) == char_count(s@, c),
          l == 1 ==> is_rotation(s@, result@),
          l == 1 ==> forall|i: int| 0 <= i < s.len() ==> 
              lex_compare(result@, s@.skip(i) + s@.take(i)),
          l >= 2 ==> lex_compare(result@, s@),

vc-code: |-
  {
      // impl-start
      assume(false);
      unreached()
      // impl-end
  }

vc-postamble: |-

  }
  fn main() {
      // let result1 = solve(1, vec!['r', 'g', 'a']);
      // assert(result1 == vec!['a', 'r', 'g']);
      
      // let result2 = solve(2, vec!['c', 'a', 'b']);
      // assert(result2 == vec!['a', 'b', 'c']);
      
      // let result3 = solve(4, vec!['c', 'o', 'd', 'e', 'c', 'h', 'e', 'f']);
      // println!("Results verified");
  }