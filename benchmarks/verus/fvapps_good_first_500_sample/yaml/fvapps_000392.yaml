vc-description: |-
  In a 1 million by 1 million grid, the coordinates of each grid square are (x, y) with 0 <= x, y < 10^6.
  We start at the source square and want to reach the target square.  Each move, we can walk to a 4-directionally adjacent square in the grid that isn't in the given list of blocked squares.
  Return true if and only if it is possible to reach the target square through a sequence of moves.

  Example 1:
  Input: blocked = [[0,1],[1,0]], source = [0,0], target = [0,2]
  Output: false
  Explanation: 
  The target square is inaccessible starting from the source square, because we can't walk outside the grid.

  Example 2:
  Input: blocked = [], source = [0,0], target = [999999,999999]
  Output: true
  Explanation: 
  Because there are no blocked cells, it's possible to reach the target square.

  Note:

  0 <= blocked.length <= 200
  blocked[i].length == 2
  0 <= blocked[i][j] < 10^6
  source.length == target.length == 2
  0 <= source[i][j], target[i][j] < 10^6
  source != target
vc-preamble: |-
  use vstd::prelude::*;

  verus! {
vc-helpers: |-

vc-spec: |-
  type Point = (usize, usize);

  fn is_escape_possible(blocked: Vec<Point>, source: Point, target: Point) -> (result: bool)
      requires 
          source.0 < 1000000 && source.1 < 1000000,
          target.0 < 1000000 && target.1 < 1000000,
          blocked.len() <= 200,
          forall|i: int| 0 <= i < blocked.len() ==> 
              blocked[i].0 < 1000000 && blocked[i].1 < 1000000,
          source != target,
      ensures
          /* Empty blocked list always allows escape */
          blocked.len() == 0 ==> result == true,
          /* Source or target in blocked makes escape impossible */
          (blocked@.contains(source) || blocked@.contains(target)) ==> result == false,
          /* Same source and target with unblocked source is possible */
          (source == target && !blocked@.contains(source)) ==> result == true,
vc-code: |-
  {
      // impl-start
      assume(false);
      false
      // impl-end
  }
vc-postamble: |-

  }
  fn main() {
      // let test1 = is_escape_possible(vec![(0, 1), (1, 0)], (0, 0), (0, 2));
      // println!("Test 1: {}", test1);  // Should be false
      
      // let test2 = is_escape_possible(vec![], (0, 0), (999999, 999999));
      // println!("Test 2: {}", test2);  // Should be true
      
      // let test3 = is_escape_possible(vec![(10, 9), (9, 10), (10, 11), (11, 10)], (0, 0), (10, 10));
      // println!("Test 3: {}", test3);  // Should be false
  }