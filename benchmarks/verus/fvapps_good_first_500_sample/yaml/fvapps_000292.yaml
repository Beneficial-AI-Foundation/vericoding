vc-description: |-
  Given a m x n grid. Each cell of the grid has a sign pointing to the next cell you should visit if you are currently in this cell. The sign of grid[i][j] can be:

  1 which means go to the cell to the right. (i.e go from grid[i][j] to grid[i][j + 1])
  2 which means go to the cell to the left. (i.e go from grid[i][j] to grid[i][j - 1])
  3 which means go to the lower cell. (i.e go from grid[i][j] to grid[i + 1][j])
  4 which means go to the upper cell. (i.e go from grid[i][j] to grid[i - 1][j])

  Notice that there could be some invalid signs on the cells of the grid which points outside the grid.
  You will initially start at the upper left cell (0,0). A valid path in the grid is a path which starts from the upper left cell (0,0) and ends at the bottom-right cell (m - 1, n - 1) following the signs on the grid. The valid path doesn't have to be the shortest.
  You can modify the sign on a cell with cost = 1. You can modify the sign on a cell one time only.
  Return the minimum cost to make the grid have at least one valid path.

  Example 1:

  Input: grid = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]
  Output: 3
  Explanation: You will start at point (0, 0).
  The path to (3, 3) is as follows. (0, 0) --> (0, 1) --> (0, 2) --> (0, 3) change the arrow to down with cost = 1 --> (1, 3) --> (1, 2) --> (1, 1) --> (1, 0) change the arrow to down with cost = 1 --> (2, 0) --> (2, 1) --> (2, 2) --> (2, 3) change the arrow to down with cost = 1 --> (3, 3)
  The total cost = 3.

  Example 2:

  Input: grid = [[1,1,3],[3,2,2],[1,1,4]]
  Output: 0
  Explanation: You can follow the path from (0, 0) to (2, 2).

  Example 3:

  Input: grid = [[1,2],[4,3]]
  Output: 1

  Example 4:
  Input: grid = [[2,2,2],[2,2,2]]
  Output: 3

  Example 5:
  Input: grid = [[4]]
  Output: 0

  Constraints:

  m == grid.length
  n == grid[i].length
  1 <= m, n <= 100

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-

vc-spec: |-
  type Grid = Vec<Vec<usize>>;

  fn min_cost_to_valid_path(grid: Grid) -> (result: i32)
      requires
          grid.len() >= 1,
          grid.len() <= 100,
          forall|i: int| 0 <= i < grid.len() ==> #[trigger] grid[i].len() >= 1 && grid[i].len() <= 100,
          forall|i: int| 0 <= i < grid.len() ==> #[trigger] grid[i].len() == grid[0].len(),
          forall|i: int, j: int| 
              0 <= i < grid.len() && 0 <= j < grid[i].len() ==> 
              #[trigger] grid[i][j] >= 1 && grid[i][j] <= 4,
      ensures
          result == -1 || result >= 0,
          grid.len() == 1 && grid[0].len() == 1 ==> result == 0,
          grid.len() >= 2 ==> (result == -1 || result < (grid.len() * grid.len()) as i32),

vc-code: |-
  {
      // impl-start
      assume(false);
      0
      // impl-end
  }

vc-postamble: |-

  }
  fn main() {
      // let grid1 = vec![vec![1, 1, 1, 1], vec![2, 2, 2, 2], vec![1, 1, 1, 1], vec![2, 2, 2, 2]];
      // println!("{}", min_cost_to_valid_path(grid1)); // Expected: 3
      
      // let grid2 = vec![vec![1, 1, 3], vec![3, 2, 2], vec![1, 1, 4]];
      // println!("{}", min_cost_to_valid_path(grid2)); // Expected: 0
      
      // let grid3 = vec![vec![1, 2], vec![4, 3]];
      // println!("{}", min_cost_to_valid_path(grid3)); // Expected: 1
  }