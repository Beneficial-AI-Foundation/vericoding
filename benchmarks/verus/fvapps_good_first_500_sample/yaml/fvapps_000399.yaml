vc-description: |-
  Given an integer array arr and an integer k, modify the array by repeating it k times.
  For example, if arr = [1, 2] and k = 3 then the modified array will be [1, 2, 1, 2, 1, 2].
  Return the maximum sub-array sum in the modified array. Note that the length of the sub-array can be 0 and its sum in that case is 0.
  As the answer can be very large, return the answer modulo 10^9 + 7.

  Example 1:
  Input: arr = [1,2], k = 3
  Output: 9

  Example 2:
  Input: arr = [1,-2,1], k = 5
  Output: 2

  Example 3:
  Input: arr = [-1,-2], k = 7
  Output: 0

  Constraints:

  1 <= arr.length <= 10^5
  1 <= k <= 10^5
  -10^4 <= arr[i] <= 10^4
vc-preamble: |-
  use vstd::prelude::*;

  verus! {
vc-helpers: |-

vc-spec: |-
  spec fn MOD() -> int { 1000000007 }

  spec fn list_sum(arr: Seq<i32>) -> int
      decreases arr.len()
  {
      if arr.len() == 0 {
          0
      } else {
          arr[0] as int + list_sum(arr.skip(1))
      }
  }

  fn k_concatenation_max_sum(arr: Vec<i32>, k: usize) -> (result: i32)
      requires 
          k > 0,
          arr.len() >= 1,
      ensures 
          result >= 0,
          result < MOD(),
vc-code: |-
  {
      // impl-start
      assume(false);
      0
      // impl-end
  }
vc-postamble: |-
  }

  fn main() {
      // println!("{}", k_concatenation_max_sum(vec![1, 2], 3));
      // println!("{}", k_concatenation_max_sum(vec![1, -2, 1], 5));
      // println!("{}", k_concatenation_max_sum(vec![-1, -2], 7));
  }