vc-description: |-
  Santa has to send presents to the kids. He has a large stack of n presents, numbered from 1 to n; the topmost present has number a_1, the next present is a_2, and so on; the bottom present has number a_n. All numbers are distinct.

  Santa has a list of m distinct presents he has to send: b_1, b_2, ..., b_m. He will send them in the order they appear in the list.

  To send a present, Santa has to find it in the stack by removing all presents above it, taking this present and returning all removed presents on top of the stack. So, if there are k presents above the present Santa wants to send, it takes him 2k + 1 seconds to do it. Fortunately, Santa can speed the whole process up â€” when he returns the presents to the stack, he may reorder them as he wishes (only those which were above the present he wanted to take; the presents below cannot be affected in any way).

  What is the minimum time required to send all of the presents, provided that Santa knows the whole list of presents he has to send and reorders the presents optimally? Santa cannot change the order of presents or interact with the stack of presents in any other way.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-

vc-spec: |-
  fn min_time_to_send_presents(n: nat, m: nat, stack: Vec<nat>, send_list: Vec<nat>) -> (result: nat)
      requires 
          n > 0,
          n <= 100000,
          stack.len() == n,
          m <= n,
          send_list.len() == m,
          forall|i: int| 0 <= i < stack.len() ==> 1 <= stack[i] && stack[i] <= n,
          forall|i: int| 0 <= i < send_list.len() ==> 1 <= send_list[i] && send_list[i] <= n,
          // All elements in stack are unique
          forall|i: int, j: int| 0 <= i < stack.len() && 0 <= j < stack.len() && i != j ==> stack[i] != stack[j],
          // All elements in send_list are unique  
          forall|i: int, j: int| 0 <= i < send_list.len() && 0 <= j < send_list.len() && i != j ==> send_list[i] != send_list[j],
      ensures
          // Identity permutation takes n seconds
          (stack@ == send_list@ ==> result == n),
          // Reverse order takes at least as long as identity order
          result >= m,

vc-code: |-
  {
      // impl-start
      assume(false);
      unreached()
      // impl-end
  }

vc-postamble: |-

  }

  fn main() {
      // let result1 = min_time_to_send_presents(3, 3, vec![3, 1, 2], vec![3, 2, 1]);
      // println!("Result 1: {}", result1); // Should be 5
      
      // let result2 = min_time_to_send_presents(7, 2, vec![2, 1, 7, 3, 4, 5, 6], vec![3, 1]);
      // println!("Result 2: {}", result2); // Should be 8
  }