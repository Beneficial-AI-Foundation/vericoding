vc-description: |-
  Given an integer array nums and an integer k, return the maximum sum of a non-empty subsequence of that array such that for every two consecutive integers in the subsequence, nums[i] and nums[j], where i < j, the condition j - i <= k is satisfied.
  A subsequence of an array is obtained by deleting some number of elements (can be zero) from the array, leaving the remaining elements in their original order.

  Example 1:
  Input: nums = [10,2,-10,5,20], k = 2
  Output: 37
  Explanation: The subsequence is [10, 2, 5, 20].

  Example 2:
  Input: nums = [-1,-2,-3], k = 1
  Output: -1
  Explanation: The subsequence must be non-empty, so we choose the largest number.

  Example 3:
  Input: nums = [10,-2,-10,-5,20], k = 2
  Output: 23
  Explanation: The subsequence is [10, -2, -5, 20].

  Constraints:

  1 <= k <= nums.length <= 10^5
  -10^4 <= nums[i] <= 10^4
vc-preamble: |-
  use vstd::prelude::*;

  verus! {
vc-helpers: |-

vc-spec: |-
  fn constrained_max_subset_sum(nums: Vec<i32>, k: usize) -> (result: i32)
      requires 
          nums.len() > 0,
          k > 0,
          k <= nums.len(),
      ensures 
          exists|x: i32| nums@.contains(x) && result >= x,
vc-code: |-
  {
      // impl-start
      assume(false);
      unreached()
      // impl-end
  }
vc-postamble: |-

  }
  fn main() {
      // Apps difficulty: interview
      // Assurance level: unguarded

      // println!("{}", constrained_max_subset_sum(vec![10, 2, -10, 5, 20], 2));
      // println!("{}", constrained_max_subset_sum(vec![-1, -2, -3], 1));
      // println!("{}", constrained_max_subset_sum(vec![10, -2, -10, -5, 20], 2));
  }