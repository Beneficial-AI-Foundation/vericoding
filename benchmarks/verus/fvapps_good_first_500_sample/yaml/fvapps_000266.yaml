vc-description: |-
  Your car starts at position 0 and speed +1 on an infinite number line.  (Your car can go into negative positions.)
  Your car drives automatically according to a sequence of instructions A (accelerate) and R (reverse).
  When you get an instruction "A", your car does the following: position += speed, speed *= 2.
  When you get an instruction "R", your car does the following: if your speed is positive then speed = -1 , otherwise speed = 1.  (Your position stays the same.)
  For example, after commands "AAR", your car goes to positions 0->1->3->3, and your speed goes to 1->2->4->-1.
  Now for some target position, say the length of the shortest sequence of instructions to get there.
  Example 1:
  Input: 
  target = 3
  Output: 2
  Explanation: 
  The shortest instruction sequence is "AA".
  Your position goes from 0->1->3.

  Example 2:
  Input: 
  target = 6
  Output: 5
  Explanation: 
  The shortest instruction sequence is "AAARA".
  Your position goes from 0->1->3->7->7->6.

  Note: 

  1 <= target <= 10000.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-

vc-spec: |-
  spec fn log2_upper_bound(n: nat) -> nat 
      decreases n
  {
      if n <= 1 { 0 } else { 1 + log2_upper_bound(n / 2) }
  }

  fn racecar(target: nat) -> (result: nat)
      requires target > 0,
      ensures 
          result > 0,
          result <= 4 * log2_upper_bound(target),

vc-code: |-
  {
      // impl-start
      assume(false);
      unreached()
      // impl-end
  }

vc-postamble: |-

  /* Apps difficulty: interview
     Assurance level: unguarded */

  }

  fn main() {
      // assert(racecar(3) == 2);
      // assert(racecar(6) == 5);
      // assert(racecar(4) == 5);
  }