vc-description: |-
  The Little Elephant likes permutations. This time he has a permutation A[1], A[2], ..., A[N] of numbers 1, 2, ..., N.

  He calls a permutation A good, if the number of its inversions is equal to the number of its local inversions. The number of inversions is equal to the number of pairs of integers (i; j) such that 1 ≤ i < j ≤ N and A[i] > A[j], and the number of local inversions is the number of integers i such that 1 ≤ i < N and A[i] > A[i+1].

  The Little Elephant has several such permutations. Help him to find for each permutation whether it is good or not. Print YES for a corresponding test case if it is good and NO otherwise.

  -----Input-----

  The first line of the input contains a single integer T, the number of test cases. T test cases follow. The first line of each test case contains a single integer N, the size of a permutation. The next line contains N space separated integers A[1], A[2], ..., A[N].

  -----Output-----

  For each test case output a single line containing the answer for the corresponding test case. It should be YES if the corresponding permutation is good and NO otherwise.

  -----Constraints-----
  1 ≤ T ≤ 474 

  1 ≤ N ≤ 100 

  It is guaranteed that the sequence A[1], A[2], ..., A[N] is a permutation of numbers 1, 2, ..., N.

  -----Example-----
  Input:
  4
  1
  1
  2
  2 1
  3
  3 2 1
  4
  1 3 2 4

  Output:
  YES
  YES
  NO
  YES

  -----Explanation-----
  Case 1. Here N = 1, so we have no pairs (i; j) with 1 ≤ i < j ≤ N. So the number of inversions is equal to zero. The number of local inversion is also equal to zero. Hence this permutation is good.

  Case 2. Here N = 2, and we have one pair (i; j) with 1 ≤ i < j ≤ N, the pair (1; 2). Since A[1] = 2 and A[2] = 1 then A[1] > A[2] and the number of inversions is equal to 1. The number of local inversion is also equal to 1 since we have one value of i for which 1 ≤ i < N (the value i = 1) and A[i] > A[i+1] for this value of i since A[1] > A[2]. Hence this permutation is also good.

  Case 3. Here N = 3, and we have three pairs (i; j) with 1 ≤ i < j ≤ N. We have A[1] = 3, A[2] = 2, A[3] = 1. Hence A[1] > A[2], A[1] > A[3] and A[2] > A[3]. So the number of inversions is equal to 3. To count the number of local inversion we should examine inequalities A[1] > A[2] and A[2] > A[3]. They both are satisfied in our case, so we have 2 local inversions. Since 2 ≠ 3 this permutations is not good.

  Case 4. Here we have only one inversion and it comes from the pair (2; 3) since A[2] = 3 > 2 = A[3]. This pair gives also the only local inversion in this permutation. Hence the number of inversions equals to the number of local inversions and equals to one. So this permutation is good.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-
  spec fn count_inversions(arr: Seq<nat>) -> nat
      decreases arr.len()
  {
      if arr.len() <= 1 {
          0
      } else {
          let count_first: nat = arr.skip(1).filter(|x: nat| x < arr[0]).len();
          count_first + count_inversions(arr.skip(1))
      }
  }

  spec fn count_local_inversions(arr: Seq<nat>) -> nat
      decreases arr.len()
  {
      if arr.len() <= 1 {
          0
      } else if arr.len() == 2 {
          if arr[0] > arr[1] { 1 } else { 0 }
      } else {
          let local_first: nat = if arr[0] > arr[1] { 1 } else { 0 };
          local_first + count_local_inversions(arr.skip(1))
      }
  }

  spec fn is_permutation(n: nat, arr: Seq<nat>) -> bool {
      arr.len() == n &&
      forall|i: nat| 1 <= i <= n ==> arr.contains(i) &&
      forall|i: int, j: int| 0 <= i < arr.len() && 0 <= j < arr.len() && i != j ==> arr[i] != arr[j]
  }

vc-spec: |-
  fn is_good_permutation(n: nat, arr: Vec<nat>) -> (result: bool)
      requires 
          n > 0,
          arr.len() == n,
          is_permutation(n, arr@),
      ensures result == (count_inversions(arr@) == count_local_inversions(arr@))
  {
      // impl-start
      assume(false);
      false
      // impl-end
  }

vc-code: |-

vc-postamble: |-
  }

  fn main() {
      // /* Apps difficulty: interview */
      // /* Assurance level: unguarded */
      
      // /* Test cases */
      // assert(is_good_permutation(1, vec![1]));
      // assert(is_good_permutation(2, vec![2, 1]));
      // assert(!is_good_permutation(3, vec![3, 2, 1]));
      // assert(is_good_permutation(4, vec![1, 3, 2, 4]));
  }