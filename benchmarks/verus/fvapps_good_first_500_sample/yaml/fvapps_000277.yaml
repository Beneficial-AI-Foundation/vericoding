vc-description: |-
  You have an initial power P, an initial score of 0 points, and a bag of tokens.
  Each token can be used at most once, has a value token[i], and has potentially two ways to use it.

  If we have at least token[i] power, we may play the token face up, losing token[i] power, and gaining 1 point.
  If we have at least 1 point, we may play the token face down, gaining token[i] power, and losing 1 point.

  Return the largest number of points we can have after playing any number of tokens.

  Example 1:
  Input: tokens = [100], P = 50
  Output: 0

  Example 2:
  Input: tokens = [100,200], P = 150
  Output: 1

  Example 3:
  Input: tokens = [100,200,300,400], P = 200
  Output: 2

  Note:

  tokens.length <= 1000
  0 <= tokens[i] < 10000
  0 <= P < 10000

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-

vc-spec: |-
  fn bag_of_tokens_score(tokens: Vec<u32>, power: u32) -> (result: u32)
      requires 
          tokens.len() <= 1000,
          (forall|i: int| 0 <= i < tokens.len() ==> tokens[i] < 10000),
          power < 10000,
      ensures 
          result <= tokens.len(),
          result >= 0,

vc-code: |-
  {
      // impl-start
      assume(false);
      0
      // impl-end
  }

vc-postamble: |-

  }
  fn main() {
      // Apps difficulty: interview
      // Assurance level: unguarded

      // let result1 = bag_of_tokens_score(vec![100], 50);
      // println!("{}", result1); // Should be 0

      // let result2 = bag_of_tokens_score(vec![100, 200], 150);
      // println!("{}", result2); // Should be 1

      // let result3 = bag_of_tokens_score(vec![100, 200, 300, 400], 200);
      // println!("{}", result3); // Should be 2
  }