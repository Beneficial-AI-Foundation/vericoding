vc-description: |-
  Given an array of integers arr.
  We want to select three indices i, j and k where (0 <= i < j <= k < arr.length).
  Let's define a and b as follows:

  a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]
  b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]

  Note that ^ denotes the bitwise-xor operation.
  Return the number of triplets (i, j and k) Where a == b.

  Example 1:
  Input: arr = [2,3,1,6,7]
  Output: 4
  Explanation: The triplets are (0,1,2), (0,2,2), (2,3,4) and (2,4,4)

  Example 2:
  Input: arr = [1,1,1,1,1]
  Output: 10

  Example 3:
  Input: arr = [2,3]
  Output: 0

  Example 4:
  Input: arr = [1,3,5,7,9]
  Output: 3

  Example 5:
  Input: arr = [7,11,12,9,5,2,7,17,22]
  Output: 8

  Constraints:

  1 <= arr.length <= 300
  1 <= arr[i] <= 10^8
vc-preamble: |-
  use vstd::prelude::*;

  verus! {
vc-helpers: |-

vc-spec: |-
  spec fn xor_range(arr: Seq<u32>, start: int, end: int) -> u32
      decreases end - start
  {
      if start >= end {
          0
      } else {
          arr[start] ^ xor_range(arr, start + 1, end)
      }
  }

  fn count_triplets(arr: Vec<u32>) -> (result: usize)
      requires arr.len() >= 1,
      ensures result >= 0
vc-code: |-
  {
      // impl-start
      assume(false);
      unreached()
      // impl-end
  }
vc-postamble: |-

  }
  fn main() {
      // let arr1 = vec![2, 3, 1, 6, 7];
      // let result1 = count_triplets(arr1);
      // assert_eq!(result1, 4);
      
      // let arr2 = vec![1, 1, 1, 1, 1];
      // let result2 = count_triplets(arr2);
      // assert_eq!(result2, 10);
      
      // let arr3 = vec![1, 3, 5, 7, 9];
      // let result3 = count_triplets(arr3);
      // assert_eq!(result3, 3);
  }