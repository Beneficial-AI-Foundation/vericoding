vc-description: |-
  Cersei wants to be the queen of seven kingdoms.

  For this to happen, she needs to address the soldiers in her army. There are n soldiers in her army (numbered 1 through n). Cersei passes on the message to the first soldier (soldier 1).   
  This message needs to reach every soldier in the army. For this, the soldiers communicate among themselves by one soldier passing the message to another soldier through some communication links. It is known that the message could reach every soldier using the given links.
  Now, each soldier will receive the message from exactly one soldier or Cersei and could pass on the message to atmost two soldiers. That is each soldier (except soldier 1) has only one incoming link and every soldier (including soldier 1) has atmost two outgoing links.  
  Now, the High Sparrow feels that Cersei is planning to kill his people first. Hence, for the sake of his people, he decided to appoint some sparrows to overhear every conversation between the soldiers (The conversation between Cersei and the first soldier needn't be overheard due to the fear of Ser Gregor Clegane).   
  To overhear a conversation between soldiers A and B, there needs to be a sparrow either at soldier A or soldier B or both.
  Also, by his research, the High Sparrow has found that the soldiers are partitioned into some classes (1 to k). That is, every soldier belongs to exactly one class. He then demands the presence of atleast one sparrow with each class he knows (1 to k).
  Find the minimum number of sparrows the High Sparrow needs to recruit for the job or tell that he couldn't.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-

vc-spec: |-
  fn solve_sparrow_problem(n: nat, k: nat, classes: Vec<nat>, links: Vec<(nat, nat)>) -> (result: i32)
      requires 
          n >= 1,
          k >= 1,
          classes.len() == n,
          links.len() == n - 1,
          forall|i: int| 0 <= i < n ==> #[trigger] classes[i] >= 1 && #[trigger] classes[i] <= k,
      ensures
          result >= -1
  {
      // impl-start
      assume(false);
      -1
      // impl-end
  }

  fn is_valid_tree(n: nat, links: Vec<(nat, nat)>) -> (result: bool)
      requires n >= 1
  {
      // impl-start
      assume(false);
      false
      // impl-end
  }

vc-code: |-

vc-postamble: |-

  }
  fn main() {
      // let result1 = solve_sparrow_problem(5, 3, vec![1, 1, 2, 2, 3], vec![(1, 2), (1, 3), (2, 4), (2, 5)]);
      // assert(result1 == 3);
      
      // let result2 = solve_sparrow_problem(5, 5, vec![1, 1, 2, 2, 3], vec![(1, 2), (1, 3), (2, 4), (2, 5)]);
      // assert(result2 == -1);
  }