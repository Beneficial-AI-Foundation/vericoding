vc-description: |-
  A die simulator generates a random number from 1 to 6 for each roll. You introduced a constraint to the generator such that it cannot roll the number i more than rollMax[i] (1-indexed) consecutive times. 
  Given an array of integers rollMax and an integer n, return the number of distinct sequences that can be obtained with exact n rolls.
  Two sequences are considered different if at least one element differs from each other. Since the answer may be too large, return it modulo 10^9 + 7.

  Example 1:
  Input: n = 2, rollMax = [1,1,2,2,2,3]
  Output: 34
  Explanation: There will be 2 rolls of die, if there are no constraints on the die, there are 6 * 6 = 36 possible combinations. In this case, looking at rollMax array, the numbers 1 and 2 appear at most once consecutively, therefore sequences (1,1) and (2,2) cannot occur, so the final answer is 36-2 = 34.

  Example 2:
  Input: n = 2, rollMax = [1,1,1,1,1,1]
  Output: 30

  Example 3:
  Input: n = 3, rollMax = [1,1,1,2,2,3]
  Output: 181

  Constraints:

  1 <= n <= 5000
  rollMax.length == 6
  1 <= rollMax[i] <= 15

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-

vc-spec: |-
  spec fn die_simulator_spec(n: usize, roll_max: Seq<usize>) -> usize
  {
      0  // placeholder specification
  }

  fn die_simulator(n: usize, roll_max: Vec<usize>) -> (result: usize)
      requires 
          1 <= n && n <= 20,
          roll_max.len() == 6,
          forall|i: int| 0 <= i < roll_max.len() ==> 1 <= roll_max[i] && roll_max[i] <= 15,
      ensures 
          0 <= result && result < 1000000007,
          result == die_simulator_spec(n, roll_max@),

vc-code: |-
  {
      // impl-start
      assume(false);
      unreached()
      // impl-end
  }

vc-postamble: |-

  proof fn die_simulator_within_bounds(n: usize, roll_max: Vec<usize>)
      requires 
          1 <= n && n <= 20,
          roll_max.len() == 6,
          forall|i: int| 0 <= i < roll_max.len() ==> 1 <= roll_max[i] && roll_max[i] <= 15,
      ensures ({
          let result = die_simulator_spec(n, roll_max@);
          0 <= result && result < 1000000007
      })
  {
      assume(false); /* TODO: Remove this line and implement the proof */
  }

  proof fn die_simulator_base_case(roll_max: Vec<usize>)
      requires 
          roll_max.len() == 6,
          forall|i: int| 0 <= i < roll_max.len() ==> 1 <= roll_max[i] && roll_max[i] <= 15,
      ensures 
          die_simulator_spec(1, roll_max@) == 6,
  {
      assume(false); /* TODO: Remove this line and implement the proof */
  }

  proof fn die_simulator_monotonic(n: usize, strict: Vec<usize>, loose: Vec<usize>)
      requires 
          strict.len() == 6,
          loose.len() == 6,
          forall|i: int| 0 <= i < strict.len() ==> strict[i] == 1,
          forall|i: int| 0 <= i < loose.len() ==> loose[i] == 15,
      ensures 
          die_simulator_spec(n, strict@) <= die_simulator_spec(n, loose@),
  {
      assume(false); /* TODO: Remove this line and implement the proof */
  }

  }

  fn main() {
      // Apps difficulty: interview
      // Assurance level: guarded

      // #guard_msgs in
      // #eval dieSimulator 2 [1, 1, 2, 2, 2, 3]
      // Expected: 34

      // #guard_msgs in  
      // #eval dieSimulator 2 [1, 1, 1, 1, 1, 1]
      // Expected: 30

      // #guard_msgs in
      // #eval dieSimulator 3 [1, 1, 1, 2, 2, 3]
      // Expected: 181
  }