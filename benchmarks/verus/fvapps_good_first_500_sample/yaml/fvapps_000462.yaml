vc-description: |-
  Given an array of non-negative integers arr, you are initially positioned at start index of the array. When you are at index i, you can jump to i + arr[i] or i - arr[i], check if you can reach to any index with value 0.
  Notice that you can not jump outside of the array at any time.

  Example 1:
  Input: arr = [4,2,3,0,3,1,2], start = 5
  Output: true
  Explanation: 
  All possible ways to reach at index 3 with value 0 are: 
  index 5 -> index 4 -> index 1 -> index 3 
  index 5 -> index 6 -> index 4 -> index 1 -> index 3 

  Example 2:
  Input: arr = [4,2,3,0,3,1,2], start = 0
  Output: true 
  Explanation: 
  One possible way to reach at index 3 with value 0 is: 
  index 0 -> index 4 -> index 1 -> index 3

  Example 3:
  Input: arr = [3,0,2,1,2], start = 2
  Output: false
  Explanation: There is no way to reach at index 1 with value 0.

  Constraints:

  1 <= arr.length <= 5 * 10^4
  0 <= arr[i] < arr.length
  0 <= start < arr.length

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-

vc-spec: |-
  fn can_reach(arr: Vec<usize>, start: usize) -> (result: bool)
      requires 
          start < arr.len(),
          arr.len() >= 1,
          forall|i: int| 0 <= i < arr.len() ==> arr[i] < arr.len(),
      ensures
          start >= arr.len() ==> result == false,
          (forall|i: int| 0 <= i < arr.len() ==> arr[i] != 0) ==> result == false,
          result == true ==> (
              exists|path: Seq<int>| 
                  path.len() > 0 &&
                  path[0] == start as int &&
                  (exists|pos: int| 0 <= pos < arr.len() && path.contains(pos) && arr[pos as int] == 0) &&
                  (forall|i: int, j: int| 
                      0 <= i < path.len() - 1 && j == i + 1 ==> (
                          0 <= path[i] < arr.len() && 
                          0 <= path[j] < arr.len() &&
                          (path[j] == path[i] + arr[path[i] as int] as int || 
                           (path[i] >= arr[path[i] as int] as int && path[j] == path[i] - arr[path[i] as int] as int))
                      )
                  )
          )

vc-code: |-
  {
      // impl-start
      assume(false);
      false
      // impl-end
  }

vc-postamble: |-

  }
  fn main() {
      // let result1 = can_reach(vec![4, 2, 3, 0, 3, 1, 2], 5);
      // println!("Test 1: {}", result1);  // Should be true
      
      // let result2 = can_reach(vec![4, 2, 3, 0, 3, 1, 2], 0);
      // println!("Test 2: {}", result2);  // Should be true
      
      // let result3 = can_reach(vec![3, 0, 2, 1, 2], 2);
      // println!("Test 3: {}", result3);  // Should be false
  }