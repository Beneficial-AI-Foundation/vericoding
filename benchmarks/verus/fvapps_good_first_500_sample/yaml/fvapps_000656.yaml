vc-description: |-
  A permutation p_1,p_2...p_N of {1, 2, ..., N} is beautiful if p_i & p_{i+1} is greater than 0 for every 1 ≤ i < N. You are given an integer N, and your task is to construct a beautiful permutation of length N or determine that it's impossible.
  Note that a & b denotes the bitwise AND of a and b.

  -----Input:-----
  First line will contain T, number of testcases. Then the testcases follow. 
  Each testcase contains a single line of input, an integer N.

  -----Output:-----
  For each test case output -1 if there is no suitable permutation of length N, otherwise output N integers in a single line which form a beautiful permutation. If there are multiple answers output any of them.

  -----Constraints-----
  - 1 ≤ N ≤ 10^5
  - The sum of N over all test cases does not exceed 10^6

  -----Subtasks-----
  - 50 points : 1 ≤ N,T ≤ 9
  - 50 points : Original constraints

  -----Sample Input:-----
  3
  4
  3
  5

  -----Sample Output:-----
  -1
  1 3 2
  2 3 1 5 4
vc-preamble: |-
  use vstd::prelude::*;

  verus! {
vc-helpers: |-

vc-spec: |-
  spec fn is_power_of_two(n: usize) -> bool {
      n > 0 && exists|k: nat| n == (1 << k)
  }

  fn solve_beautiful_permutation(n: usize) -> (result: Vec<usize>)
      requires n > 0,
      ensures
          (n == 1 ==> result.len() == 1 && result[0] == 1),
          (is_power_of_two(n) && n != 1 ==> result.len() == 1 && result[0] == 0),
          (!is_power_of_two(n) && n != 1 ==> result.len() == n),
vc-code: |-
  {
      // impl-start
      assume(false);
      unreached()
      // impl-end
  }
vc-postamble: |-

  }
  fn main() {
      // Apps difficulty: interview
      // Assurance level: unguarded

      // #eval solve_beautiful_permutation 4
      // Expected: [-1] or [0]

      // #eval solve_beautiful_permutation 3  
      // Expected: [2, 3, 1]

      // #eval solve_beautiful_permutation 5
      // Expected: [2, 3, 1, 5, 4]
  }