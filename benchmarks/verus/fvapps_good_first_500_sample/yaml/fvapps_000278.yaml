vc-description: |-
  Given an array A of integers, for each integer A[i] we need to choose either x = -K or x = K, and add x to A[i] (only once).
  After this process, we have some array B.
  Return the smallest possible difference between the maximum value of B and the minimum value of B.

  Example 1:
  Input: A = [1], K = 0
  Output: 0
  Explanation: B = [1]

  Example 2:
  Input: A = [0,10], K = 2
  Output: 6
  Explanation: B = [2,8]

  Example 3:
  Input: A = [1,3,6], K = 3
  Output: 3
  Explanation: B = [4,6,3]

  Note:

  1 <= A.length <= 10000
  0 <= A[i] <= 10000
  0 <= K <= 10000

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

  spec fn maximum(xs: Seq<i32>) -> i32 
      decreases xs.len()
  {
      if xs.len() == 0 {
          0
      } else if xs.len() == 1 {
          xs[0]
      } else {
          let max_rest = maximum(xs.subrange(1, xs.len() as int));
          if xs[0] > max_rest { xs[0] } else { max_rest }
      }
  }

  spec fn minimum(xs: Seq<i32>) -> i32 
      decreases xs.len()
  {
      if xs.len() == 0 {
          0
      } else if xs.len() == 1 {
          xs[0]
      } else {
          let min_rest = minimum(xs.subrange(1, xs.len() as int));
          if xs[0] < min_rest { xs[0] } else { min_rest }
      }
  }

vc-helpers: |-

vc-spec: |-
  fn smallest_range_ii(nums: Vec<i32>, k: i32) -> (result: i32)
      requires k >= 0
      ensures 
          result >= 0,
          nums.len() == 1 ==> result == 0,
          nums.len() == 0 ==> result == 0

vc-code: |-
  {
      // impl-start
      assume(false);
      0
      // impl-end
  }

vc-postamble: |-

  }

  fn main() {
      // #eval smallest_range_ii([1], 0) == 0
      // #eval smallest_range_ii([0, 10], 2) == 6
      // #eval smallest_range_ii([1, 3, 6], 3) == 3
  }