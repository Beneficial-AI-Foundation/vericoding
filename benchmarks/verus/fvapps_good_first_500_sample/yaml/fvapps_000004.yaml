vc-description: |-
  You are given a permutation p=[p_1, p_2, ..., p_n] of integers from 1 to n. Let's call the number m (1 ≤ m ≤ n) beautiful, if there exists two indices l, r (1 ≤ l ≤ r ≤ n), such that the numbers [p_l, p_{l+1}, ..., p_r] is a permutation of numbers 1, 2, ..., m.

  For example, let p = [4, 5, 1, 3, 2, 6]. In this case, the numbers 1, 3, 5, 6 are beautiful and 2, 4 are not. It is because: if l = 3 and r = 3 we will have a permutation [1] for m = 1; if l = 3 and r = 5 we will have a permutation [1, 3, 2] for m = 3; if l = 1 and r = 5 we will have a permutation [4, 5, 1, 3, 2] for m = 5; if l = 1 and r = 6 we will have a permutation [4, 5, 1, 3, 2, 6] for m = 6; it is impossible to take some l and r, such that [p_l, p_{l+1}, ..., p_r] is a permutation of numbers 1, 2, ..., m for m = 2 and for m = 4.

  You are given a permutation p=[p_1, p_2, ..., p_n]. For all m (1 ≤ m ≤ n) determine if it is a beautiful number or not.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-

vc-spec: |-
  spec fn is_permutation_of_range(seq: Seq<nat>, m: nat) -> bool {
      seq.len() == m && 
      forall|i: nat| 1 <= i <= m ==> #[trigger] seq.contains(i) &&
      forall|x: nat| #[trigger] seq.contains(x) ==> 1 <= x <= m
  }

  spec fn is_beautiful_number(nums: Seq<nat>, m: nat) -> bool {
      exists|l: int, r: int| 
          0 <= l <= r < nums.len() &&
          #[trigger] is_permutation_of_range(nums.subrange(l, r + 1), m)
  }

  fn solve_beautiful_permutation(nums: Vec<nat>) -> (result: Vec<nat>)
      requires nums.len() > 0,
      ensures 
          result.len() == nums.len(),
          forall|i: int| 0 <= i < result.len() ==> (result[i] == 0 || result[i] == 1),
          forall|i: int| 0 <= i < result.len() ==> 
              (result[i] == 1 <==> is_beautiful_number(nums@, (i + 1) as nat))

vc-code: |-
  {
      // impl-start
      assume(false);
      unreached()
      // impl-end
  }

vc-postamble: |-

  }
  fn main() {
      // let result1 = solve_beautiful_permutation(vec![4, 5, 1, 3, 2, 6]);
      // println!("{:?}", result1); // Expected: [1, 0, 1, 0, 1, 1]

      // let result2 = solve_beautiful_permutation(vec![5, 3, 1, 2, 4]);
      // println!("{:?}", result2); // Expected: [1, 1, 1, 1, 1]

      // let result3 = solve_beautiful_permutation(vec![1, 4, 3, 2]);
      // println!("{:?}", result3); // Expected: [1, 0, 0, 1]
  }