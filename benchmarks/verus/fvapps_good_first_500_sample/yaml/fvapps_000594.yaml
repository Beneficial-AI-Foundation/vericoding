vc-description: |-
  "What do you know about happiness?" â€” Yoda 
  Chef is happy only if three conditions hold:
  - Chef finished cooking a delicious meal
  - Chef got AC for a programming problem with an almost correct code
  - Chef got a new problem with a sequence of integers
  Today, all three conditions are satisfied. Chef would like you to feel his happiness and provide him with a solution for this new problem with a sequence of integers. The problem is as follows.
  You are given a sequence $A_1, A_2, \dots, A_N$. You need to determine if it is possible to choose two indices $i$ and $j$ such that $A_i \neq A_j$, but $A_{A_i}$ = $A_{A_j}$. (If it was possible, Chef would be truly happy.)

  -----Input-----
  - The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.
  - The first line of each test case contains a single integer $N$.
  - The second line contains $N$ space-separated integers $A_1, A_2, \ldots, A_N$.

  -----Output-----
  For each test case, print a single line containing the string "Truly Happy" if it is possible to choose required indices or "Poor Chef" otherwise.

  -----Constraints-----
  - $1 \le T \le 1,000$
  - $1 \le N \le 10^5$
  - $1 \le A_i \le N$ for each valid $i$
  - the sum of $N$ over all test cases does not exceed $2 \cdot 10^5$

  -----Subtasks-----
  Subtask #1 (27 points): $1 \le N \le 1,000$
  Subtask #2 (73 points): original constraints

  -----Example Input-----
  4
  4
  1 1 2 3
  4
  2 1 3 3
  5
  5 4 4 3 1
  5
  3 2 1 1 4

  -----Example Output-----
  Truly Happy
  Poor Chef
  Poor Chef
  Truly Happy

  -----Explanation-----
  Example case 1: Chef is truly happy because $A_{A_3} = A_{A_1}$ and $A_3 \neq A_1$.
  Example case 2: There is no pair of indices which would make Chef truly happy. For instance, $A_{A_3} = A_{A_4}$, but $A_3 = A_4$,

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-

vc-spec: |-
  fn solve_happiness(n: usize, arr: Vec<usize>) -> (result: &'static str)
      requires 
          n >= 1,
          n <= 100000,
          arr.len() == n,
          forall|i: int| 0 <= i < arr.len() ==> 1 <= arr[i] && arr[i] <= n,
      ensures 
          result == "Truly Happy" || result == "Poor Chef",
          (result == "Truly Happy") <==> 
              (exists|i: int, j: int| 
                  #![trigger arr[i], arr[j]]
                  0 <= i < arr.len() && 
                  0 <= j < arr.len() && 
                  i != j &&
                  arr[i] != arr[j] &&
                  1 <= arr[i] && arr[i] <= arr.len() &&
                  1 <= arr[j] && arr[j] <= arr.len() &&
                  arr[(arr[i] - 1) as int] == arr[(arr[j] - 1) as int])

vc-code: |-
  {
      // impl-start
      assume(false);
      "Poor Chef"
      // impl-end
  }

vc-postamble: |-

  proof fn solve_happiness_basic_cases() {
      assume(false); // TODO: Remove this line and implement the proof
  }

  proof fn solve_happiness_increasing_sequence(n: usize, arr: Vec<usize>)
      requires
          n >= 1,
          n <= 10,
          arr.len() == n,
          forall|i: int| 0 <= i < arr.len() ==> arr[i] == (i + 1) as usize,
      ensures
          !(exists|i: int, j: int| 
              #![trigger arr[i], arr[j]]
              0 <= i < arr.len() && 
              0 <= j < arr.len() && 
              i != j &&
              arr[i] != arr[j] &&
              1 <= arr[i] && arr[i] <= arr.len() &&
              1 <= arr[j] && arr[j] <= arr.len() &&
              arr[(arr[i] - 1) as int] == arr[(arr[j] - 1) as int])
  {
      assume(false); // TODO: Remove this line and implement the proof
  }

  }

  fn main() {
      // Apps difficulty: interview
      // Assurance level: unguarded

      // println!("{}", solve_happiness(4, vec![1, 1, 2, 3]));  // Expected: "Truly Happy"
      // println!("{}", solve_happiness(4, vec![2, 1, 3, 3]));  // Expected: "Poor Chef"  
      // println!("{}", solve_happiness(5, vec![3, 2, 1, 1, 4])); // Expected: "Truly Happy"
  }