vc-description: |-
  A string S of lowercase letters is given. Then, we may make any number of moves.
  In each move, we choose one of the first K letters (starting from the left), remove it, and place it at the end of the string.
  Return the lexicographically smallest string we could have after any number of moves.

  Example 1:
  Input: S = "cba", K = 1
  Output: "acb"
  Explanation: 
  In the first move, we move the 1st character ("c") to the end, obtaining the string "bac".
  In the second move, we move the 1st character ("b") to the end, obtaining the final result "acb".

  Example 2:
  Input: S = "baaca", K = 3
  Output: "aaabc"
  Explanation: 
  In the first move, we move the 1st character ("b") to the end, obtaining the string "aacab".
  In the second move, we move the 3rd character ("c") to the end, obtaining the final result "aaabc".

  Note:
  1 <= K <= S.length <= 1000
  S consists of lowercase letters only.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-
  spec fn string_to_sorted_string(s: Seq<char>) -> Seq<char> {
      s  /* placeholder since we can't sort without proper implementation */
  }

  spec fn char_seq_drop_take(s: Seq<char>, i: int) -> Seq<char> {
      if 0 <= i <= s.len() {
          s.subrange(i, s.len() as int) + s.subrange(0, i)
      } else {
          s
      }
  }

  spec fn lex_le(s1: Seq<char>, s2: Seq<char>) -> bool 
      decreases s1.len() + s2.len()
  {
      if s1.len() == 0 && s2.len() == 0 {
          true
      } else if s1.len() == 0 {
          true
      } else if s2.len() == 0 {
          false
      } else if s1[0] < s2[0] {
          true
      } else if s1[0] > s2[0] {
          false
      } else {
          lex_le(s1.skip(1), s2.skip(1))
      }
  }

vc-spec: |-
  fn orderly_queue(s: Vec<char>, k: usize) -> (result: Vec<char>)
      requires 
          s.len() > 0,
          k > 0,
          k <= s.len(),
      ensures
          /* When k > 1, result is equivalent to sorted string */
          k > 1 ==> string_to_sorted_string(result@) == string_to_sorted_string(s@),
          /* Length is preserved */
          result.len() == s.len(),
          /* Character multiset is preserved */
          string_to_sorted_string(result@) == string_to_sorted_string(s@),
          /* When k = 1, result is a rotation of original string */
          k == 1 ==> exists|i: int| 0 <= i < s.len() && result@ == char_seq_drop_take(s@, i),
          /* When k = 1, result is lexicographically minimal among all rotations */
          k == 1 ==> forall|i: int| 0 <= i < s.len() ==> lex_le(result@, char_seq_drop_take(s@, i))

vc-code: |-
  {
      // impl-start
      assume(false);
      unreached()
      // impl-end
  }

vc-postamble: |-

  }
  fn main() {
      // let result1 = orderly_queue(vec!['c', 'b', 'a'], 1);
      // println!("Result 1: {:?}", result1);  // Should be "acb"
      
      // let result2 = orderly_queue(vec!['b', 'a', 'a', 'c', 'a'], 3);
      // println!("Result 2: {:?}", result2);  // Should be "aaabc"
      
      // let result3 = orderly_queue(vec!['a', 'b', 'c', 'd'], 2);
      // println!("Result 3: {:?}", result3);  // Should be "abcd"
  }