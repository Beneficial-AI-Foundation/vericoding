vc-description: |-
  Given a list of non-negative numbers and a target integer k, write a function to check if the array has a continuous subarray of size at least 2 that sums up to the multiple of k, that is, sums up to n*k where n is also an integer.

  Example 1:

  Input: [23, 2, 4, 6, 7],  k=6
  Output: True
  Explanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6.

  Example 2:

  Input: [23, 2, 6, 4, 7],  k=6
  Output: True
  Explanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42.

  Note:

  The length of the array won't exceed 10,000.
  You may assume the sum of all the numbers is in the range of a signed 32-bit integer.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-

vc-spec: |-
  spec fn subarray_sum(nums: Seq<i32>, start: int, end: int) -> int
      decreases end - start
  {
      if start >= end {
          0
      } else {
          nums[start] + subarray_sum(nums, start + 1, end)
      }
  }

  fn check_subarray_sum(nums: Vec<i32>, k: i32) -> (result: bool)
      ensures
          result == true <==> (
              exists|i: int, j: int| 
                  0 <= i < j < nums.len() &&
                  j - i >= 2 &&
                  (k == 0 ==> subarray_sum(nums@, i, j) == 0) &&
                  (k != 0 ==> subarray_sum(nums@, i, j) % (k as int) == 0)
          ),
          (nums.len() <= 1) ==> (result == false),
          (nums.len() < 2) ==> (result == false),
          (k == 1 && nums.len() >= 2) ==> (result == true),

vc-code: |-
  {
      // impl-start
      assume(false);
      false
      // impl-end
  }

vc-postamble: |-

  }
  fn main() {
      // let result1 = check_subarray_sum(vec![23, 2, 4, 6, 7], 6);
      // println!("Result 1: {}", result1);
      
      // let result2 = check_subarray_sum(vec![23, 2, 6, 4, 7], 6);
      // println!("Result 2: {}", result2);
      
      // let result3 = check_subarray_sum(vec![1, 2], 2);
      // println!("Result 3: {}", result3);
  }