vc-description: |-
  You have a large electronic screen which can display up to 998244353 decimal digits. The digits are displayed in the same way as on different electronic alarm clocks: each place for a digit consists of 7 segments which can be turned on and off to compose different digits. The following picture describes how you can display all 10 decimal digits:

  [Image]

  As you can see, different digits may require different number of segments to be turned on. For example, if you want to display 1, you have to turn on 2 segments of the screen, and if you want to display 8, all 7 segments of some place to display a digit should be turned on.

  You want to display a really large integer on the screen. Unfortunately, the screen is bugged: no more than n segments can be turned on simultaneously. So now you wonder what is the greatest integer that can be displayed by turning on no more than n segments.

  Your program should be able to process t different test cases.

  Input:
  The first line contains one integer t (1 ≤ t ≤ 100) — the number of test cases in the input.

  Then the test cases follow, each of them is represented by a separate line containing one integer n (2 ≤ n ≤ 10^5) — the maximum number of segments that can be turned on in the corresponding testcase.

  It is guaranteed that the sum of n over all test cases in the input does not exceed 10^5.

  Output:
  For each test case, print the greatest integer that can be displayed by turning on no more than n segments of the screen. Note that the answer may not fit in the standard 32-bit or 64-bit integral data type.

  Example:
  Input
  2
  3
  4

  Output
  7
  11
vc-preamble: |-
  use vstd::prelude::*;

  verus! {
vc-helpers: |-

vc-spec: |-
  spec fn digit_segments(digit: u8) -> nat {
      match digit {
          0 => 6,
          1 => 2,
          2 => 5,
          3 => 5,
          4 => 4,
          5 => 5,
          6 => 6,
          7 => 3,
          8 => 7,
          9 => 6,
          _ => 0,
      }
  }

  spec fn digit_char_to_digit(c: char) -> u8 {
      match c {
          '0' => 0,
          '1' => 1,
          '2' => 2,
          '3' => 3,
          '4' => 4,
          '5' => 5,
          '6' => 6,
          '7' => 7,
          '8' => 8,
          '9' => 9,
          _ => 0,
      }
  }

  spec fn nat_to_string(n: nat) -> Seq<char>;

  spec fn is_valid_digit_char(c: char) -> bool {
      c == '0' || c == '1' || c == '2' || c == '3' || c == '4' || 
      c == '5' || c == '6' || c == '7' || c == '8' || c == '9'
  }

  fn find_max_display(n: nat) -> (result: nat)
      requires n >= 2,
      ensures 
          result > 0,
          forall|c: char| nat_to_string(result).contains(c) ==> (c == '1' || c == '7'),
          n % 2 == 1 ==> nat_to_string(result)[0] == '7',
          n % 2 == 0 && n >= 4 ==> forall|c: char| nat_to_string(result).contains(c) ==> c == '1'
vc-code: |-
  {
      // impl-start
      assume(false);
      unreached()
      // impl-end
  }
vc-postamble: |-

  }
  fn main() {
      // Example usage:
      // println!("{}", find_max_display(3)); // Should output 7
      // println!("{}", find_max_display(4)); // Should output 11
      // println!("{}", find_max_display(5)); // Should output 71
  }