vc-description: |-
  Chef is frustrated in this lockdown. So to overcome this he plans to travel various mountains.
  He is very strange so he sets some conditions for each Type 2 query (mentioned below) (i.e. 1 i):
  - Let Chef has travelled till ith mountain from left to right.
  - He does not like to travel the mountain with the height, of which he has travelled till now. More formally,
  Let the height of peak on which he is standing is a_i then he can only go to the peak of height a_j
  which is greater than a_i and nearest to ith mountain such that there should be no other peak of same height a_j till a_i (height of ith mountain).

  Input format:
  - The first line contains an integer T denoting the number of test cases.
  - The second line of consist of a integer N and Q.
  - The third line contains N not necessarily distinct positive integers a_0, a_1, ..., a_{n-1} denoting the height of N mountains.
  - Then next Q lines follows where each line consisting of either of 2 types of queries:
  Type 1: 0 A B i.e. a_A = B (where height of Ath mountain will be updated to B)
  Type 2: 1 A i.e. you have to answer a_k which is greater than a_A and nearest to Ath mountain such that there should be no other peak of same height a_k till a_A (height of Ath mountain).

  Output format:
  - For every query of Type 2 there should be an integer a_k on next line for the updated array, If no such a_k exists then a_k = -1, as query of type 1 will have no output.

  Constraints:
  - 1 ≤ T ≤ 10^2
  - 1 ≤ N,Q ≤ 10^4
  - 0 ≤ a_i ≤ 10^6
  - 0 ≤ B ≤ 10^6
  - 0 ≤ A ≤ N-1

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-

vc-spec: |-
  spec fn filter_type_1_queries(queries: Seq<Seq<usize>>) -> Seq<Seq<usize>>
      decreases queries.len()
  {
      if queries.len() == 0 {
          seq![]
      } else {
          let query = queries[0];
          let rest_filtered = filter_type_1_queries(queries.skip(1));
          if query.len() > 0 && query[0] == 1 {
              seq![query].add(rest_filtered)
          } else {
              rest_filtered
          }
      }
  }

  fn solve_mountain_queries(n: usize, mountains: Vec<usize>, queries: Vec<Vec<usize>>) -> (result: Vec<i32>)
      requires 
          n >= 2,
          mountains.len() == n,
      ensures 
          result.len() == filter_type_1_queries(queries@.map(|i: int, q: Vec<usize>| q@)).len(),
          forall|i: int| 0 <= i < result.len() ==> (result[i] == -1 || result[i] >= 0),

vc-code: |-
  {
      // impl-start
      assume(false);
      unreached()
      // impl-end
  }

vc-postamble: |-

  }
  fn main() {}