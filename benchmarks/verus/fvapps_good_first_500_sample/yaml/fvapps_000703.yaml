vc-description: |-
  The kingdom of the snakes is an NxN grid. Their most-valued possession is a huge collection of poison, which is stored in the central KxK grid. It is guaranteed that both N and K are odd. What we mean by 'central' is this: suppose in the NxN grid, (i, j) refers to the cell in the i-th row and j-th column and (1,1) refers to the top-left corner and (N,N) refers to the bottom-right corner. Then the poison is stored in the KxK square whose top-left corner is ( (N - K)/2 + 1, (N - K)/2 + 1 ).

  But there are thieves who want to steal the poison. They cannot enter the NxN grid, but they can shoot arrows from outside. These arrows travel across a row (from left to right, or right to left), or across a column (top to bottom or bottom to top) in a straight line. If the arrow enters the KxK grid, some of the poison will stick to the arrow, and if it exits the NxN grid after that, the thieves will have successfully stolen some of the poison.
  As the King of the snakes, you want to thwart these attempts. You know that the arrows will break and stop if they hit a snake's scaly skin, but won't hurt the snakes. There are some snakes already guarding the poison. Each snake occupies some consecutive cells in a straight line inside the NxN grid. That is, they are either part of a row, or part of a column. Note that there can be intersections between the snakes.  A configuration of snakes is 'safe', if the thieves cannot steal poison. That is, no matter which row or column they shoot arrows from, either the arrow should hit a snake and stop (this can happen even after it has entered and exited the KxK grid), or it shouldn't ever enter the KxK grid.
  The King has other duties for the snakes, and hence wants to remove as many snakes as possible from this configuration, such that the remaining configuration is still 'safe'. Help him find the minimum number of snakes he needs to leave behind to protect the poison.
vc-preamble: |-
  use vstd::prelude::*;

  verus! {
vc-helpers: |-

vc-spec: |-
  fn solve_snake_kingdom(n: nat, k: nat, snakes: Vec<Vec<nat>>) -> (result: i32)
      requires 
          3 <= n,
          n <= 1000000000,
          1 <= k,
          k <= n - 2,
          n % 2 == 1,
          k % 2 == 1,
          snakes.len() <= 100000,
          forall|i: int| 0 <= i < snakes.len() ==> snakes[i].len() == 4,
      ensures
          result == -1 || result >= 0,
          snakes.len() == 0 ==> result == -1,
vc-code: |-
  {
      // impl-start
      assume(false);
      -1
      // impl-end
  }
vc-postamble: |-

  }
  fn main() {}