vc-description: |-
  You are given a colored permutation p_1, p_2, ..., p_n. The i-th element of the permutation has color c_i.

  Let's define an infinite path as infinite sequence i, p[i], p[p[i]], p[p[p[i]]] ... where all elements have same color (c[i] = c[p[i]] = c[p[p[i]]] = ...).

  We can also define a multiplication of permutations a and b as permutation c = a × b where c[i] = b[a[i]]. Moreover, we can define a power k of permutation p as p^k=p × p × ... × p (k times).

  Find the minimum k > 0 such that p^k has at least one infinite path (i.e. there is a position i in p^k such that the sequence starting from i is an infinite path).

  It can be proved that the answer always exists.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-

vc-spec: |-
  fn find_min_k_infinite_path(n: usize, perm: Vec<usize>, colors: Vec<usize>) -> (result: usize)
      requires 
          n > 0,
          perm.len() == n,
          colors.len() == n,
          forall|i: int| 0 <= i < n ==> #[trigger] perm[i] >= 1 && #[trigger] perm[i] <= n,
          forall|i: int, j: int| 0 <= i < n && 0 <= j < n && i != j ==> #[trigger] perm[i] != #[trigger] perm[j],
      ensures 
          result > 0,
          result <= n,

vc-code: |-
  {
      // impl-start
      assume(false);
      unreached()
      // impl-end
  }

vc-postamble: |-
  }

  fn main() {
      // let test1_result = find_min_k_infinite_path(4, vec![1, 3, 4, 2], vec![1, 2, 2, 3]);
      // assert(test1_result == 1);
      
      // let test2_result = find_min_k_infinite_path(5, vec![2, 3, 4, 5, 1], vec![1, 2, 3, 4, 5]);
      // assert(test2_result == 5);
      
      // let test3_result = find_min_k_infinite_path(8, vec![7, 4, 5, 6, 1, 8, 3, 2], vec![5, 3, 6, 4, 7, 5, 8, 4]);
      // assert(test3_result == 2);
  }