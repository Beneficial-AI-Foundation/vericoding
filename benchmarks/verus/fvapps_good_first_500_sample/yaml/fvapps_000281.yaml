vc-description: |-
  There is a room with n lights which are turned on initially and 4 buttons on the wall. After performing exactly m unknown operations towards buttons, you need to return how many different kinds of status of the n lights could be.

  Suppose n lights are labeled as number [1, 2, 3 ..., n], function of these 4 buttons are given below:

  Flip all the lights.
  Flip lights with even numbers.
  Flip lights with odd numbers.
  Flip lights with (3k + 1) numbers, k = 0, 1, 2, ...

  Example 1:

  Input: n = 1, m = 1.
  Output: 2
  Explanation: Status can be: [on], [off]

  Example 2:

  Input: n = 2, m = 1.
  Output: 3
  Explanation: Status can be: [on, off], [off, on], [off, off]

  Example 3:

  Input: n = 3, m = 1.
  Output: 4
  Explanation: Status can be: [off, on, off], [on, off, on], [off, off, off], [off, on, on].

  Note:
  n and m both fit in range [0, 1000].

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-
  spec fn flip_lights_spec(n: nat, m: nat) -> nat
      decreases m
  {
      if n == 0 {
          0
      } else if m == 0 {
          1
      } else {
          // Simplified specification for demo
          if n <= 4 { (1u32 << (n as u32)) as nat } else { 16 }
      }
  }

vc-spec: |-
  fn flip_lights(n: nat, m: nat) -> (result: nat)
      requires n > 0,
      ensures 
          1 <= result && result <= (if n <= 4 { (1u32 << (n as u32)) } else { 16 }) as nat,
          (m == 0) ==> (result == 1),
          flip_lights_spec(n, 1000) == flip_lights_spec(n, 1001)

vc-code: |-
  {
      // impl-start
      assume(false);
      unreached()
      // impl-end
  }

vc-postamble: |-
  }

  fn main() {
      // let test1 = flip_lights(1, 1);
      // assert(test1 == 2);
      // 
      // let test2 = flip_lights(2, 1);
      // assert(test2 == 3);
      // 
      // let test3 = flip_lights(3, 1);
      // assert(test3 == 4);
  }