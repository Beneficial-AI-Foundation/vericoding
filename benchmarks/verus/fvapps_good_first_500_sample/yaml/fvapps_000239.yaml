vc-description: |-
  On a table are N cards, with a positive integer printed on the front and back of each card (possibly different).
  We flip any number of cards, and after we choose one card. 
  If the number X on the back of the chosen card is not on the front of any card, then this number X is good.
  What is the smallest number that is good?  If no number is good, output 0.
  Here, fronts[i] and backs[i] represent the number on the front and back of card i. 
  A flip swaps the front and back numbers, so the value on the front is now on the back and vice versa.
  Example:
  Input: fronts = [1,2,4,4,7], backs = [1,3,4,1,3]
  Output: 2
  Explanation: If we flip the second card, the fronts are [1,3,4,4,7] and the backs are [1,2,4,1,3].
  We choose the second card, which has number 2 on the back, and it isn't on the front of any card, so 2 is good.

  Note:

  1 <= fronts.length == backs.length <= 1000.
  1 <= fronts[i] <= 2000.
  1 <= backs[i] <= 2000.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-

vc-spec: |-
  spec fn is_in_list(val: nat, list: Seq<nat>) -> bool {
      exists|i: int| 0 <= i < list.len() && list[i] == val
  }

  spec fn same_front_back(fronts: Seq<nat>, backs: Seq<nat>, val: nat) -> bool {
      exists|i: int| 0 <= i < fronts.len() && fronts[i] == backs[i] && fronts[i] == val
  }

  fn flipgame(fronts: Vec<nat>, backs: Vec<nat>) -> (result: nat)
      requires fronts.len() == backs.len(),
      ensures
          result != 0 ==> is_in_list(result, fronts@) || is_in_list(result, backs@),
          result != 0 ==> !same_front_back(fronts@, backs@, result),
          result != 0 ==> forall|n: nat| #[trigger] is_in_list(n, fronts@) || is_in_list(n, backs@) ==>
                              !same_front_back(fronts@, backs@, n) ==> result <= n,

vc-code: |-
  {
      // impl-start
      assume(false);
      unreached()
      // impl-end
  }

vc-postamble: |-

  }
  fn main() {
      // let test1 = flipgame(vec![1, 2, 4, 4, 7], vec![1, 3, 4, 1, 3]);
      // assert(test1 == 2);
      
      // let test2 = flipgame(vec![1, 1], vec![1, 1]);
      // assert(test2 == 0);
      
      // let test3 = flipgame(vec![1, 2], vec![2, 1]);
      // assert(test3 == 1);
  }