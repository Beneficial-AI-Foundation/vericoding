vc-description: |-
  Given a list of words, each word consists of English lowercase letters.
  Let's say word1 is a predecessor of word2 if and only if we can add exactly one letter anywhere in word1 to make it equal to word2.  For example, "abc" is a predecessor of "abac".
  A word chain is a sequence of words [word_1, word_2, ..., word_k] with k >= 1, where word_1 is a predecessor of word_2, word_2 is a predecessor of word_3, and so on.
  Return the longest possible length of a word chain with words chosen from the given list of words.

  Example 1:
  Input: ["a","b","ba","bca","bda","bdca"]
  Output: 4
  Explanation: one of the longest word chain is "a","ba","bda","bdca".

  Note:

  1 <= words.length <= 1000
  1 <= words[i].length <= 16
  words[i] only consists of English lowercase letters.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-

vc-spec: |-
  fn longest_str_chain(words: Vec<String>) -> (result: nat)

vc-code: |-
  {
      // impl-start
      assume(false);
      unreached()
      // impl-end
  }

vc-postamble: |-

  }
  fn main() {
      // let test1 = vec!["a".to_string(), "b".to_string(), "ba".to_string(), "bca".to_string(), "bda".to_string(), "bdca".to_string()];
      // println!("{}", longest_str_chain(test1));
      
      // let test2 = vec!["xbc".to_string(), "pcxbcf".to_string(), "xb".to_string(), "cxbc".to_string(), "pcxbc".to_string()];
      // println!("{}", longest_str_chain(test2));
      
      // let test3 = vec!["a".to_string(), "b".to_string(), "ab".to_string(), "bac".to_string()];
      // println!("{}", longest_str_chain(test3));
  }