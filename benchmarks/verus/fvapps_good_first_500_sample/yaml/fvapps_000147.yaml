vc-description: |-
  Given a string s, a k duplicate removal consists of choosing k adjacent and equal letters from s and removing them causing the left and the right side of the deleted substring to concatenate together.
  We repeatedly make k duplicate removals on s until we no longer can.
  Return the final string after all such duplicate removals have been made.
  It is guaranteed that the answer is unique.

  Example 1:
  Input: s = "abcd", k = 2
  Output: "abcd"
  Explanation: There's nothing to delete.
  Example 2:
  Input: s = "deeedbbcccbdaa", k = 3
  Output: "aa"
  Explanation: 
  First delete "eee" and "ccc", get "ddbbbdaa"
  Then delete "bbb", get "dddaa"
  Finally delete "ddd", get "aa"
  Example 3:
  Input: s = "pbbcggttciiippooaais", k = 2
  Output: "ps"

  Constraints:

  1 <= s.length <= 10^5
  2 <= k <= 10^4
  s only contains lower case English letters.
vc-preamble: |-
  use vstd::prelude::*;

  verus! {
vc-helpers: |-
  spec fn remove_duplicates_spec(s: Seq<char>, k: int) -> Seq<char>;
vc-spec: |-
  fn remove_duplicates(s: Vec<char>, k: usize) -> (result: Vec<char>)
      requires 
          s.len() >= 1,
          k >= 2,
          k <= 10000,
      ensures
          result.len() <= s.len(),
          forall|c: char| result@.contains(c) ==> s@.contains(c),
          remove_duplicates_spec(result@, k as int) == result@,
          s.len() == 0 ==> result.len() == 0,
vc-code: |-
  {
      // impl-start
      assume(false);
      unreached()
      // impl-end
  }
vc-postamble: |-

  }
  fn main() {
      // let s1: Vec<char> = "abcd".chars().collect();
      // let result1 = remove_duplicates(s1, 2);
      // println!("{:?}", result1);
      
      // let s2: Vec<char> = "deeedbbcccbdaa".chars().collect();
      // let result2 = remove_duplicates(s2, 3);
      // println!("{:?}", result2);
      
      // let s3: Vec<char> = "pbbcggttciiippooaais".chars().collect();
      // let result3 = remove_duplicates(s3, 2);
      // println!("{:?}", result3);
  }