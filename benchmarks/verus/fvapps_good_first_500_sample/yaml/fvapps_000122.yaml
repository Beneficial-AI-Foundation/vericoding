vc-description: |-
  Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

  (i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]).

  You are given a target value to search. If found in the array return true, otherwise return false.

  Example 1:

  Input: nums = [2,5,6,0,0,1,2], target = 0
  Output: true

  Example 2:

  Input: nums = [2,5,6,0,0,1,2], target = 3
  Output: false

  Follow up:

         This is a follow up problem to Search in Rotated Sorted Array, where nums may contain duplicates.
         Would this affect the run-time complexity? How and why?

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-

vc-spec: |-
  fn search(list: Vec<i32>, target: i32) -> (result: bool)
      ensures result == list@.contains(target)

vc-code: |-
  {
      // impl-start
      assume(false);
      false
      // impl-end
  }

vc-postamble: |-
  /* Apps difficulty: interview */
  /* Assurance level: unguarded */

  }

  fn main() {
      // let result1 = search(vec![2, 5, 6, 0, 0, 1, 2], 0);
      // println!("Result 1: {}", result1); // Should be true
      
      // let result2 = search(vec![2, 5, 6, 0, 0, 1, 2], 3);
      // println!("Result 2: {}", result2); // Should be false
      
      // let result3 = search(vec![1], 1);
      // println!("Result 3: {}", result3); // Should be true
  }