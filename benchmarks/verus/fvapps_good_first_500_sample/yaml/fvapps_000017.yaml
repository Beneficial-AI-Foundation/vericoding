vc-description: |-
  You are given an array $a_1, a_2 \dots a_n$. Calculate the number of tuples $(i, j, k, l)$ such that:   $1 \le i < j < k < l \le n$;  $a_i = a_k$ and $a_j = a_l$; 

  -----Input-----

  The first line contains a single integer $t$ ($1 \le t \le 100$) — the number of test cases.

  The first line of each test case contains a single integer $n$ ($4 \le n \le 3000$) — the size of the array $a$.

  The second line of each test case contains $n$ integers $a_1, a_2, \dots, a_n$ ($1 \le a_i \le n$) — the array $a$.

  It's guaranteed that the sum of $n$ in one test doesn't exceed $3000$.

  -----Output-----

  For each test case, print the number of described tuples.

  -----Example-----
  Input
  2
  5
  2 2 2 2 2
  6
  1 3 3 1 2 3

  Output
  5
  2

  -----Note-----

  In the first test case, for any four indices $i < j < k < l$ are valid, so the answer is the number of tuples.

  In the second test case, there are $2$ valid tuples:   $(1, 2, 4, 6)$: $a_1 = a_4$ and $a_2 = a_6$;  $(1, 3, 4, 6)$: $a_1 = a_4$ and $a_3 = a_6$.
vc-preamble: |-
  use vstd::prelude::*;

  verus! {
vc-helpers: |-

vc-spec: |-
  fn count_equal_tuples(n: usize, arr: Vec<i32>) -> (result: usize)
      requires 
          n >= 4,
          arr.len() == n,
          forall|i: int| 0 <= i < arr.len() ==> #[trigger] arr[i] >= 1 && arr[i] <= n,
      ensures 
          result >= 0,
          (forall|i: int, j: int| 0 <= i < n && 0 <= j < n && i != j ==> #[trigger] arr[i] != #[trigger] arr[j]) ==> result == 0,
vc-code: |-
  {
      // impl-start
      assume(false);
      0
      // impl-end
  }
vc-postamble: |-
  
  /* Apps difficulty: interview */
  /* Assurance level: unguarded */

  }
  fn main() {
      // #eval count_equal_tuples 5 [2, 2, 2, 2, 2]
      // #eval count_equal_tuples 6 [1, 3, 3, 1, 2, 3]  
      // #eval count_equal_tuples 4 [1, 1, 1, 1]
  }