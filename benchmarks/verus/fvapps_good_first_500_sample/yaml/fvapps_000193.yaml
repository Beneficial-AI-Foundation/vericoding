vc-description: |-
  Given a string s, determine if it is valid.
  A string s is valid if, starting with an empty string t = "", you can transform t into s after performing the following operation any number of times:

  Insert string "abc" into any position in t. More formally, t becomes tleft + "abc" + tright, where t == tleft + tright. Note that tleft and tright may be empty.

  Return true if s is a valid string, otherwise, return false.

  Example 1:
  Input: s = "aabcbc"
  Output: true
  Explanation:
  "" -> "abc" -> "aabcbc"
  Thus, "aabcbc" is valid.
  Example 2:
  Input: s = "abcabcababcc"
  Output: true
  Explanation:
  "" -> "abc" -> "abcabc" -> "abcabcabc" -> "abcabcababcc"
  Thus, "abcabcababcc" is valid.

  Example 3:
  Input: s = "abccba"
  Output: false
  Explanation: It is impossible to get "abccba" using the operation.

  Example 4:
  Input: s = "cababc"
  Output: false
  Explanation: It is impossible to get "cababc" using the operation.

  Constraints:

  1 <= s.length <= 2 * 104
  s consists of letters 'a', 'b', and 'c'

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-

vc-spec: |-
  spec fn string_after_abc_removal(s: Seq<char>) -> Seq<char>
      decreases s.len()
  {
      if s.len() < 3 {
          s
      } else if s.subrange(0, 3) == seq!['a', 'b', 'c'] {
          string_after_abc_removal(s.subrange(3, s.len() as int))
      } else {
          seq![s[0]] + string_after_abc_removal(s.subrange(1, s.len() as int))
      }
  }

  fn is_valid(s: &str) -> (result: bool)
      ensures 
          result == (string_after_abc_removal(s@) == Seq::<char>::empty()),
          s@ == Seq::<char>::empty() ==> result == true,
          s@.contains('d') ==> result == false

vc-code: |-
  {
      // impl-start
      assume(false);
      false
      // impl-end
  }

vc-postamble: |-

  }
  fn main() {
      // println!("{}", is_valid("aabcbc"));
      // println!("{}", is_valid("abcabcababcc"));
      // println!("{}", is_valid("abccba"));
  }