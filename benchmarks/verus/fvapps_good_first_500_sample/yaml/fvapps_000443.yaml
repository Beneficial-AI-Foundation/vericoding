vc-description: |-
  There is a row of m houses in a small city, each house must be painted with one of the n colors (labeled from 1 to n), some houses that has been painted last summer should not be painted again.
  A neighborhood is a maximal group of continuous houses that are painted with the same color. (For example: houses = [1,2,2,3,3,2,1,1] contains 5 neighborhoods  [{1}, {2,2}, {3,3}, {2}, {1,1}]).
  Given an array houses, an m * n matrix cost and an integer target where:

  houses[i]: is the color of the house i, 0 if the house is not painted yet.
  cost[i][j]: is the cost of paint the house i with the color j+1.

  Return the minimum cost of painting all the remaining houses in such a way that there are exactly target neighborhoods, if not possible return -1.

  Example 1:
  Input: houses = [0,0,0,0,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3
  Output: 9
  Explanation: Paint houses of this way [1,2,2,1,1]
  This array contains target = 3 neighborhoods, [{1}, {2,2}, {1,1}].
  Cost of paint all houses (1 + 1 + 1 + 1 + 5) = 9.

  Example 2:
  Input: houses = [0,2,1,2,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3
  Output: 11
  Explanation: Some houses are already painted, Paint the houses of this way [2,2,1,2,2]
  This array contains target = 3 neighborhoods, [{2,2}, {1}, {2,2}}. 
  Cost of paint the first and last house (10 + 1) = 11.

  Example 3:
  Input: houses = [0,0,0,0,0], cost = [[1,10],[10,1],[1,10],[10,1],[1,10]], m = 5, n = 2, target = 5
  Output: 5

  Example 4:
  Input: houses = [3,1,2,3], cost = [[1,1,1],[1,1,1],[1,1,1],[1,1,1]], m = 4, n = 3, target = 3
  Output: -1
  Explanation: Houses are already painted with a total of 4 neighborhoods [{3},{1},{2},{3}] different of target = 3.

  Constraints:

  m == houses.length == cost.length
  n == cost[i].length
  1 <= m <= 100
  1 <= n <= 20
  1 <= target <= m
  0 <= houses[i] <= n
  1 <= cost[i][j] <= 10^4
vc-preamble: |-
  use vstd::prelude::*;

  verus! {
vc-helpers: |-

vc-spec: |-
  spec fn count_neighborhoods(houses: Seq<nat>) -> nat 
      decreases houses.len()
  {
      if houses.len() <= 1 {
          if houses.len() == 0 { 0 } else { 1 }
      } else {
          let rest_count = count_neighborhoods(houses.skip(1));
          if houses[0] != houses[1] {
              1 + rest_count
          } else {
              rest_count
          }
      }
  }

  fn min_cost(houses: Vec<nat>, cost: Vec<Vec<nat>>, m: nat, n: nat, target: nat) -> (result: i32)
      requires 
          houses.len() == m,
          cost.len() == m,
          forall|i: int| 0 <= i < cost.len() ==> cost[i].len() == n,
          m >= 1,
          n >= 1,
          target >= 1,
          target <= m,
          forall|i: int| 0 <= i < houses.len() ==> houses[i] <= n,
          forall|i: int, j: int| 0 <= i < cost.len() && 0 <= j < cost[i].len() ==> cost[i][j] <= 10000,
      ensures 
          result == -1 || result >= 0,
vc-code: |-
  {
      // impl-start
      assume(false);
      unreached()
      // impl-end
  }
vc-postamble: |-
  }

  fn main() {
      // // Example 1: Expected output 9
      // let houses1 = vec![0, 0, 0, 0, 0];
      // let cost1 = vec![vec![1, 10], vec![10, 1], vec![10, 1], vec![1, 10], vec![5, 1]];
      // println!("{}", min_cost(houses1, cost1, 5, 2, 3));
      
      // // Example 2: Expected output 11  
      // let houses2 = vec![0, 2, 1, 2, 0];
      // let cost2 = vec![vec![1, 10], vec![10, 1], vec![10, 1], vec![1, 10], vec![5, 1]];
      // println!("{}", min_cost(houses2, cost2, 5, 2, 3));
      
      // // Example 3: Expected output -1
      // let houses3 = vec![3, 1, 2, 3];
      // let cost3 = vec![vec![1, 1, 1], vec![1, 1, 1], vec![1, 1, 1], vec![1, 1, 1]];
      // println!("{}", min_cost(houses3, cost3, 4, 3, 3));
  }