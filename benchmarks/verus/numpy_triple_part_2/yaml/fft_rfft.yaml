vc-description: |-
  Compute the one-dimensional discrete Fourier Transform for real input.
  Returns only the non-negative frequency terms, exploiting Hermitian symmetry.
  The output length is (n/2)+1 for even n, or (n+1)/2 for odd n.
  
  Specification for rfft: 
  The real FFT computes the DFT of real-valued input, returning only non-negative frequency components.

  Mathematical properties:
  1. Output contains (n/2)+1 complex values representing frequencies 0 to n/2
  2. DC component (k=0) is always real (imaginary part is 0)
  3. For even n, Nyquist frequency (k=n/2) is also real
  4. The result represents the Discrete Fourier Transform for k = 0, 1, ..., n/2
  5. Each output[k] = Σ(j=0 to n-1) input[j] * exp(-2πi*k*j/n)

  Sanity checks:
  - For constant input signals, only the DC component is non-zero
  - The transform is linear: rfft(a + b) = rfft(a) + rfft(b)
  - Energy is preserved according to Parseval's theorem
vc-preamble: |-
  use vstd::prelude::*;

  verus! {

  /* Complex number type for FFT results */
  #[derive(PartialEq, Eq)]
  pub struct Complex {
      pub re: int,
      pub im: int,
  }

  impl Complex {
      pub open spec fn zero() -> Complex {
          Complex { re: 0, im: 0 }
      }

      pub open spec fn add(self, other: Complex) -> Complex {
          Complex { re: self.re + other.re, im: self.im + other.im }
      }

      pub open spec fn mul(self, other: Complex) -> Complex {
          Complex { 
              re: self.re * other.re - self.im * other.im,
              im: self.re * other.im + self.im * other.re
          }
      }

      pub open spec fn from_real(x: int) -> Complex {
          Complex { re: x, im: 0 }
      }
  }

  pub open spec fn complex_sum(values: Seq<Complex>) -> Complex 
      decreases values.len()
  {
      if values.len() == 0 {
          Complex::zero()
      } else {
          values[0].add(complex_sum(values.skip(1)))
      }
  }

  pub open spec fn dft_coefficient(a: Seq<int>, k: nat, j: nat) -> Complex {
      Complex::from_real(a[j as int])
  }

  pub open spec fn compute_dft_sum(a: Seq<int>, k: nat, n: nat) -> Complex 
      decreases n
  {
      if n == 0 {
          Complex::zero()
      } else {
          dft_coefficient(a, k, (n - 1) as nat).add(compute_dft_sum(a, k, (n - 1) as nat))
      }
  }

  spec fn vec_to_int_seq(v: Seq<i32>) -> Seq<int> 
      decreases v.len()
  {
      if v.len() == 0 {
          seq![]
      } else {
          seq![v[0] as int] + vec_to_int_seq(v.skip(1))
      }
  }
vc-helpers: |-

vc-spec: |-
  fn rfft(a: Vec<i32>) -> (result: Vec<Complex>)
      requires a.len() > 0,
      ensures 
          result.len() == (a.len() / 2) + 1,
          forall|k: int| 0 <= k < result.len() ==> 
              result[k] == compute_dft_sum(vec_to_int_seq(a@), k as nat, a.len() as nat),
          result[0].im == 0,
          a.len() % 2 == 0 ==> result[(a.len() / 2) as int].im == 0
vc-code: |-
  {
      // impl-start
      assume(false);
      unreached()
      // impl-end
  }
vc-postamble: |-

  }
  fn main() {}