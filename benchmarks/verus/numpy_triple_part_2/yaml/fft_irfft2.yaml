vc-description: |-
  numpy.fft.irfft2: Computes the inverse of rfft2.

  Performs the inverse 2-dimensional discrete Fourier Transform for real input.
  This function converts a complex frequency domain representation back to the
  real spatial domain. It is the inverse of rfft2.

  The function takes a complex-valued 2D array (represented as nested vectors)
  and returns a real-valued 2D array. The output shape is determined by the
  input shape and the original real signal dimensions.

  This is essentially irfftn with axes=(-2, -1) as defaults.

  Specification: numpy.fft.irfft2 returns the inverse 2D real FFT.

  Precondition: True (input is a well-formed 2D array)
  Postcondition: The result is a real-valued 2D array with the same dimensions.

  Key properties:
  1. The output preserves the matrix structure and dimensions
  2. The transformation processes all elements of the input
  3. The inverse operation produces finite real values
  4. Shape preservation ensures correct 2D FFT behavior
vc-preamble: |-
  use vstd::prelude::*;

  verus! {
vc-helpers: |-

vc-spec: |-
  fn numpy_irfft2(a: Vec<Vec<f32>>) -> (result: Vec<Vec<f32>>)
      requires
          a.len() > 0,
          forall|i: int| 0 <= i < a.len() ==> a[i].len() > 0,
          forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() ==> a[i].len() == a[j].len(),
      ensures
          /* Preserve matrix dimensions */
          result.len() == a.len(),
          forall|i: int| 0 <= i < result.len() ==> result[i].len() == a[0].len(),
          /* Non-trivial transformation: if input is non-zero, result depends on input */
          (exists|i: int, j: int| 0 <= i < a.len() && 0 <= j < a[i].len() && a[i][j] != 0.0f32) ==>
          (exists|k: int, l: int| 0 <= k < result.len() && 0 <= l < result[k].len() && result[k][l] != 0.0f32),
vc-code: |-
  {
      // impl-start
      assume(false);
      unreached()
      // impl-end
  }
vc-postamble: |-

  }
  fn main() {}