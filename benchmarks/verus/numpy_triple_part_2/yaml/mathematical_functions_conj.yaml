vc-description: |-
  Return the complex conjugate of a vector of complex numbers, element-wise

  Specification: conj computes the complex conjugate of each element with the following properties:
      1. Basic definition: conj(a + bi) = a - bi for complex numbers
      2. Real preservation: For purely real numbers, conj(x) = x
      3. Involution property: conj(conj(x)) = x (double conjugation returns original)
      4. Magnitude preservation: |conj(x)| = |x| (conjugate preserves magnitude)
      5. Distributive over addition: conj(x + y) = conj(x) + conj(y)
      6. Distributive over multiplication: conj(x * y) = conj(x) * conj(y)

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

  /* Structure representing a complex number with integer components */
  #[derive(PartialEq, Eq)]
  pub struct Complex {
      /* The real part of the complex number */
      pub real: int,
      /* The imaginary part of the complex number */
      pub imag: int,
  }

  impl Complex {
      /* Addition of complex numbers */
      pub open spec fn add(self, other: Complex) -> Complex {
          Complex { real: self.real + other.real, imag: self.imag + other.imag }
      }

      /* Multiplication of complex numbers */
      pub open spec fn mul(self, other: Complex) -> Complex {
          Complex { 
              real: self.real * other.real - self.imag * other.imag,
              imag: self.real * other.imag + self.imag * other.real
          }
      }

      /* Magnitude squared of a complex number */
      pub open spec fn norm_sq(self) -> int {
          self.real * self.real + self.imag * self.imag
      }

      /* Complex conjugate of a single complex number */
      pub open spec fn conj(self) -> Complex {
          Complex { real: self.real, imag: -self.imag }
      }
  }

vc-helpers: |-

vc-spec: |-
  fn conj(x: Vec<Complex>) -> (result: Vec<Complex>)
      ensures
          result.len() == x.len(),
          forall|i: int| 0 <= i < x.len() ==> 
              result[i].real == x[i].real && result[i].imag == -x[i].imag,
          forall|i: int| 0 <= i < x.len() ==> 
              x[i].imag == 0 ==> result[i] == x[i],
          forall|i: int| 0 <= i < x.len() ==> 
              result[i].conj() == x[i],
          forall|i: int| 0 <= i < x.len() ==> 
              x[i].norm_sq() == result[i].norm_sq(),
          forall|i: int, y: Complex| 0 <= i < x.len() ==> 
              x[i].add(y).conj() == result[i].add(y.conj()),
          forall|i: int, y: Complex| 0 <= i < x.len() ==> 
              x[i].mul(y).conj() == result[i].mul(y.conj())

vc-code: |-
  {
      // impl-start
      assume(false);
      unreached()
      // impl-end
  }

vc-postamble: |-

  }
  fn main() {}