vc-description: |-
  Add one polynomial to another.

  Given two polynomials represented as coefficient vectors (from lowest to highest degree),
  returns their sum. The result has length equal to the maximum of the input lengths,
  with shorter polynomials implicitly padded with zeros.

  Specification: polyadd computes c1 + c2 element-wise, padding with zeros.
  The result has length max(n, m), and for each coefficient position i:
  - If i < min(n, m): result[i] = c1[i] + c2[i]
  - If min(n, m) ≤ i < n: result[i] = c1[i]
  - If min(n, m) ≤ i < m: result[i] = c2[i]

  Additionally, polyadd satisfies mathematical properties:
  - Commutativity: polyadd c1 c2 = polyadd c2 c1
  - Zero identity: polyadd c 0 = c and polyadd 0 c = c
  - Associativity: polyadd (polyadd c1 c2) c3 = polyadd c1 (polyadd c2 c3)
  - Leading coefficient preservation: if c1 and c2 have different degrees,
    the result preserves the leading coefficient of the higher-degree polynomial

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-

vc-spec: |-
  fn polyadd(c1: Vec<i32>, c2: Vec<i32>) -> (result: Vec<i32>)
      ensures
          result.len() == if c1.len() >= c2.len() { c1.len() } else { c2.len() },
          forall|i: int| 0 <= i < result.len() ==> {
              if i < c1.len() && i < c2.len() {
                  result[i] == c1[i] + c2[i]
              } else if i < c1.len() && i >= c2.len() {
                  result[i] == c1[i]
              } else if i >= c1.len() && i < c2.len() {
                  result[i] == c2[i]
              } else {
                  result[i] == 0
              }
          }

vc-code: |-
  {
      // impl-start
      assume(false);
      Vec::new()
      // impl-end
  }

vc-postamble: |-

  }
  fn main() {}