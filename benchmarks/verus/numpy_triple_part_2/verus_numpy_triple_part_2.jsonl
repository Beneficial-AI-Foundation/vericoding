{"id": "array_creation_arange", "vc-description": "Return evenly spaced values within a given interval [start, stop) with given step.\nSpecification: arange generates evenly spaced values from start to stop (exclusive) with given step.\nEach element at index i has value start + i * step, and all values are within bounds.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn arange(start: i32, stop: i32, step: i32, n: usize) -> (result: Vec<i32>)\n    requires step != 0,\n    ensures\n        result.len() == n,\n        n == 0 ==> ((step > 0 && start >= stop) || (step < 0 && start <= stop)),\n        n > 0 ==> (\n            forall|i: int| 0 <= i < n ==> result[i as int] == start + i * step\n        ),\n        n > 0 && step > 0 ==> (\n            start < stop &&\n            forall|i: int| 0 <= i < n ==> result[i as int] < stop\n        ),\n        n > 0 && step < 0 ==> (\n            start > stop &&\n            forall|i: int| 0 <= i < n ==> result[i as int] > stop\n        ),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "array_creation_diag", "vc-description": "Extract a diagonal or construct a diagonal array\n\nConstruct a diagonal matrix from a 1-D vector\n\nSpecification: diag constructs a square matrix with v on the main diagonal.\n\nThis captures the mathematical property that numpy.diag(v) creates a matrix M\nwhere M[i,i] = v[i] for all i, and M[i,j] = 0 for all i ≠ j.\n\nThe result is an n×n matrix where:\n- The main diagonal contains the elements of the input vector v\n- All off-diagonal elements are zero\n- This represents the canonical way to construct a diagonal matrix\n\nMathematical properties verified:\n1. Diagonal elements equality: M[i,i] = v[i]\n2. Off-diagonal zeros: M[i,j] = 0 for i ≠ j\n3. Diagonal matrix property: non-zero elements only on diagonal\n4. Trace property: tr(M) = sum(v)\n5. Symmetry: M is a symmetric matrix\n6. Idempotence property: diag(diag(M)) reconstructs M for diagonal matrices\n7. Zero count: exactly n elements are non-zero (assuming v has no zeros)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn diag(v: Vec<f32>) -> (result: Vec<Vec<f32>>)\n    requires v.len() > 0,\n    ensures \n        result.len() == v.len(),\n        forall|i: int| 0 <= i < v.len() ==> result[i].len() == v.len(),\n        /* Elements on the main diagonal are from v */\n        forall|i: int| 0 <= i < v.len() ==> result[i][i] == v[i],\n        /* All off-diagonal elements are zero */\n        forall|i: int, j: int| 0 <= i < v.len() && 0 <= j < v.len() && i != j ==> result[i][j] == 0.0f32,\n        /* Diagonal matrix property - non-zero elements only on diagonal */\n        forall|i: int, j: int| 0 <= i < v.len() && 0 <= j < v.len() && result[i][j] != 0.0f32 ==> i == j,\n        /* The resulting matrix is symmetric */\n        forall|i: int, j: int| 0 <= i < v.len() && 0 <= j < v.len() ==> result[i][j] == result[j][i],\n        /* Each row has exactly one non-zero element at position i (unless v[i] = 0) */\n        forall|i: int| 0 <= i < v.len() && v[i] != 0.0f32 ==> {\n            result[i][i] != 0.0f32 && \n            forall|j: int| 0 <= j < v.len() && j != i ==> result[i][j] == 0.0f32\n        },\n        /* Each column has exactly one non-zero element at position j (unless v[j] = 0) */\n        forall|j: int| 0 <= j < v.len() && v[j] != 0.0f32 ==> {\n            result[j][j] != 0.0f32 && \n            forall|i: int| 0 <= i < v.len() && i != j ==> result[i][j] == 0.0f32\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "array_creation_empty", "vc-description": "numpy.empty: Return a new array of given shape and type, without initializing entries.\n\nCreates a new vector of the specified length containing uninitialized (arbitrary) values.\nThis is a low-level function that allocates memory without setting initial values,\nmaking it potentially faster than other array creation functions.\n\nFor 1D arrays, this takes a size parameter n and returns a Vector Float n\nwith arbitrary values.\n\nSpecification: numpy.empty returns a vector of the specified size with arbitrary values.\n\nProperties:\n1. The returned vector has exactly n elements (guaranteed by type)\n2. Each element in the vector is a valid Float value\n3. The vector is well-formed - all indices are accessible\n4. No guarantees are made about the actual values - they are arbitrary/uninitialized\n\nMathematical properties:\n- Size property: The length of the result is exactly n\n- Accessibility property: All elements from index 0 to n-1 are accessible via get\n- Value existence: Each position contains some Float value (but we don't specify which)\n\nThis specification captures the key behavior of numpy.empty: it returns a properly\nsized array but makes no promises about the contents, which distinguishes it from\nfunctions like zeros() or ones() that guarantee specific initial values.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn empty(n: usize) -> (result: Vec<f64>)\n    ensures result.len() == n", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "array_creation_loadtxt", "vc-description": "Load data from a text file containing numeric values.\nThis simplified version assumes:\n- The file contains floating-point numbers (one per line or whitespace-separated)\n- Comments starting with '#' are ignored\n- The skiprows parameter allows skipping initial lines\nReturns a vector of parsed float values.\n\nSpecification: loadtxt reads numeric data from a text file and returns a vector of floats.\nThe preconditions ensure:\n- The file path is valid (non-empty string)\n- After skipping skiprows lines and removing comments, there are exactly n valid float values\n\nThe postcondition guarantees:\n- The result vector contains the float values parsed from the file\n- Values appear in the same order as in the file (after skipping and comment removal)\n- The size of the result matches the type-level size n\n\nMathematical properties:\n- Deterministic: same file and parameters always produce the same result\n- Order-preserving: maintains the sequential order of values in the file\n- Comment-aware: lines starting with '#' are ignored\n- Skip-aware: first skiprows lines are ignored", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn loadtxt(fname_len: usize, skiprows: usize) -> (result: Vec<f64>)\n    requires \n        fname_len > 0,\n        skiprows >= 0,\n    ensures\n        result.len() >= 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "array_creation_logspace", "vc-description": "Return numbers spaced evenly on a log scale.\n\nCreates a vector of `num` samples where each element is computed as:\n- When endpoint=true: base^(start + i * (stop - start) / (num - 1)) for i in 0..num-1\n- When endpoint=false: base^(start + i * (stop - start) / num) for i in 0..num-1\n\nThe samples are evenly spaced in log space, meaning the exponents form an arithmetic sequence.\n\nSpecification: logspace generates numbers evenly spaced on a logarithmic scale.\n\nThe function produces a vector where:\n1. For endpoint=true: Elements follow base^(interpolated exponent) where exponents \n   are linearly interpolated from start to stop inclusive\n2. For endpoint=false: Similar but stop value is excluded from the range\n3. The base must be positive and not equal to 1 for meaningful results\n4. For num > 1, the spacing between consecutive log values is uniform", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn logspace(start: i32, stop: i32, endpoint: bool, base: i32, num: usize) -> (result: Vec<i32>)\n    requires \n        base > 0,\n        base != 1,\n        num > 0,\n    ensures\n        result.len() == num,\n        forall|i: int| 0 <= i < num ==> result[i] > 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "array_creation_mgrid", "vc-description": "An instance which returns a dense multi-dimensional meshgrid\n\nAn instance of numpy.lib.ndmgr.MGridClass which, when indexed, returns a dense multi-dimensional meshgrid.\n\nParameters\n----------\n[slice1, slice2, ..., sliceN] : slice objects or integers\n    If the input is a slice, the syntax start:stop:step is equivalent to np.arange(start, stop, step) \n    inside of the brackets. If the input is an integer, the syntax i is equivalent to np.arange(i)+1.\n\nReturns\n-------\nout : one ndarray or tuple of ndarrays\n    If only one slice is passed, returns an array. If multiple slices are passed, returns a tuple \n    of arrays with one array for each dimension.\n\nCreates a 1D meshgrid from start to stop with step size.\nThis is a simplified version of mgrid that handles only the single-slice case.\n\nSpecification: mgrid creates a vector of evenly spaced values from start to stop (exclusive) with given step", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn mgrid(start: i32, stop: i32, step: i32, n: usize) -> (result: Vec<i32>)\n    requires\n        step > 0,\n        start < stop,\n        n == ((stop - start) as int / step as int) as usize,\n    ensures\n        result.len() == n,\n        forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i] == start + (i as i32) * step,\n        forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i] < stop,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "array_creation_ones", "vc-description": "Return a new vector of given size filled with ones.\n\nThis function creates a vector where every element is exactly 1.0,\nmatching NumPy's ones function behavior for 1D arrays.\n\nSpecification: ones returns a vector where all elements are exactly 1.0.\n\nThis specification captures the following properties:\n1. **Correctness**: Every element in the returned vector equals 1.0\n2. **Uniformity**: All elements are identical (constant vector)\n3. **Non-negativity**: All elements are positive (1.0 > 0)\n4. **Identity property**: Multiplying any value by an element gives the same value\n5. **Type Safety**: The returned vector has exactly n elements (enforced by type)\n\nMathematical Properties verified:\n- ∀ i : Fin n, result[i] = 1.0 (all elements are exactly one)\n- ∀ i j : Fin n, result[i] = result[j] (uniformity/constant vector)\n- ∀ i : Fin n, result[i] > 0 (positivity)\n- ∀ i : Fin n, ∀ x : Float, x * result[i] = x (multiplicative identity)\n\nEdge cases handled:\n- When n = 0, returns an empty vector (trivially satisfies all properties)\n- When n > 0, all indices contain exactly 1.0", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn ones(n: usize) -> (result: Vec<i32>)\n    ensures\n        result.len() == n,\n        forall|i: int| 0 <= i < n ==> result[i] == 1,\n        forall|i: int, j: int| 0 <= i < n && 0 <= j < n ==> result[i] == result[j],\n        forall|i: int| 0 <= i < n ==> result[i] > 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "array_creation_triu", "vc-description": "Upper triangle of a matrix.\n\nReturns a copy of a matrix with the elements below the k-th diagonal zeroed.\n- k = 0: main diagonal (default)\n- k < 0: include |k| diagonals below the main diagonal\n- k > 0: zero out k diagonals above the main diagonal as well\n\nSpecification: triu returns an upper triangular matrix with specific properties.\n\nCore behavior:\n- Elements below the k-th diagonal are zeroed\n- Elements on and above the k-th diagonal are preserved\n\nMathematical properties:\n1. Element-wise specification: result[i][j] = if i > j - k then 0 else m[i][j]\n2. Preservation of dimensions: result has same shape as input\n3. Diagonal control: k parameter shifts which diagonal forms the boundary\n4. Idempotence: applying triu twice with same k gives same result\n5. Special cases:\n   - k = 0: standard upper triangular (zeros below main diagonal)\n   - k < 0: includes |k| diagonals below main diagonal in upper triangle\n   - k > 0: zeros out k additional diagonals above main diagonal\n6. For square matrices when k = 0, all elements where row_index > column_index are zero", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn triu(m: &Vec<Vec<f32>>, k: i32) -> (result: Vec<Vec<f32>>)\n    requires \n        m.len() > 0,\n        forall|i: int| 0 <= i < m.len() ==> #[trigger] m[i].len() == m[0].len(),\n    ensures\n        result.len() == m.len(),\n        forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i].len() == m[i].len(),\n        forall|i: int, j: int| \n            0 <= i < result.len() && 0 <= j < result[i].len() ==>\n            #[trigger] result[i][j] == if i as i32 > j as i32 - k { 0.0f32 } else { m[i][j] },\n        forall|i: int, j: int|\n            0 <= i < result.len() && 0 <= j < result[i].len() && i as i32 <= j as i32 - k ==>\n            #[trigger] result[i][j] == m[i][j],\n        forall|i: int, j: int|\n            0 <= i < result.len() && 0 <= j < result[i].len() && i as i32 > j as i32 - k ==>\n            #[trigger] result[i][j] == 0.0f32,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "array_creation_vander", "vc-description": "Generate a Vandermonde matrix with decreasing powers (default behavior).\nThe Vandermonde matrix is a matrix with terms of a geometric progression in each row.\nFor a 1D input vector x of length n and specified number of columns m,\nthe output is an n×m matrix where entry (i,j) = x[i]^(m-1-j)\n\nSpecification: vander generates a Vandermonde matrix where each row contains\npowers of the corresponding element from the input vector.\nIn the default decreasing mode, column j contains x^(m-1-j) for each element x.\nThis means the first column has the highest powers and the last column has x^0 = 1.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn pow_int(base: int, exp: nat) -> int\n    decreases exp\n{\n    if exp == 0 {\n        1\n    } else {\n        base * pow_int(base, (exp - 1) as nat)\n    }\n}", "vc-helpers": "", "vc-spec": "fn vander(x: Vec<i32>, m: usize) -> (result: Vec<Vec<i32>>)\n    requires \n        x.len() > 0,\n        m > 0,\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == m,\n        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < m ==> \n            result[i][j] == pow_int(x[i] as int, (m - 1 - j) as nat),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "array_manipulation_array_split", "vc-description": "Split an array into multiple sub-arrays.\n\nPlease refer to the split documentation. The only difference\nbetween these functions is that array_split allows\nindices_or_sections to be an integer that does *not* equally\ndivide the axis. For an array of length l that should be split\ninto n sections, it returns l % n sub-arrays of size l//n + 1\nand the rest of size l//n.\n\nSplit a vector into k sub-vectors.\n\nWhen splitting a vector of length n into k sections:\n- The first (n % k) sub-vectors have size ⌈n/k⌉ = (n + k - 1) / k\n- The remaining sub-vectors have size ⌊n/k⌋ = n / k\n\nThis ensures all elements are distributed as evenly as possible,\nwith larger sub-vectors appearing first.\n\nSpecification: array_split distributes elements evenly with mathematical properties\n\nThe specification captures:\n1. Size distribution: larger chunks come first\n2. Element preservation: all elements from the original vector appear in order\n3. No gaps or overlaps: elements are contiguously distributed", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn chunk_size(i: int, n: int, k: int) -> int {\n    if i < n % k {\n        (n + k - 1) / k\n    } else {\n        n / k\n    }\n}\n\nspec fn start_index(i: int, n: int, k: int) -> int \n    decreases i\n{\n    if i <= 0 {\n        0\n    } else {\n        start_index(i - 1, n, k) + chunk_size(i - 1, n, k)\n    }\n}", "vc-helpers": "", "vc-spec": "fn array_split(v: Vec<f32>, k: usize) -> (result: Vec<Vec<f32>>)\n    requires k > 0,\n    ensures\n        result.len() == k,\n        /* Each sub-vector has the correct size based on its position */\n        forall|i: int| 0 <= i < k as int ==> #[trigger] result[i].len() == chunk_size(i, v.len() as int, k as int),\n        /* Elements are preserved in order across all sub-vectors */\n        forall|i: int, j: int| 0 <= i < k as int && 0 <= j < result[i].len() ==> \n            #[trigger] result[i][j] == v[start_index(i, v.len() as int, k as int) + j]", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "array_manipulation_broadcast_arrays", "vc-description": "Broadcast two 1D vectors against each other following NumPy broadcasting rules.\nFor 1D arrays, broadcasting only happens when one array has size 1.\nThe result arrays will have the size of the larger input array.\n\nSpecification: broadcast_arrays produces two arrays of the same size where:\n1. If an input array has size 1, its single element is replicated to match the other array's size\n2. If both arrays have the same size, they are returned unchanged\n3. The output arrays have size equal to the maximum of the input sizes", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn broadcast_arrays(a: Vec<f32>, b: Vec<f32>) -> (result: (Vec<f32>, Vec<f32>))\n    requires \n        a.len() == 1 || b.len() == 1 || a.len() == b.len(),\n        a.len() > 0,\n        b.len() > 0,\n    ensures \n        ({\n            let (a_broadcast, b_broadcast) = result;\n            let max_len = if a.len() > b.len() { a.len() } else { b.len() };\n            \n            /* Both output arrays have the same size as max(m, n) */\n            a_broadcast.len() == max_len &&\n            b_broadcast.len() == max_len &&\n            \n            /* First array broadcasting rules */\n            (a.len() == 1 ==> forall|i: int| 0 <= i < max_len ==> a_broadcast[i] == a[0]) &&\n            (b.len() == 1 && a.len() > 1 ==> forall|i: int| 0 <= i < a.len() ==> a_broadcast[i] == a[i]) &&\n            (a.len() == b.len() ==> forall|i: int| 0 <= i < a.len() ==> a_broadcast[i] == a[i]) &&\n            \n            /* Second array broadcasting rules */\n            (b.len() == 1 ==> forall|i: int| 0 <= i < max_len ==> b_broadcast[i] == b[0]) &&\n            (a.len() == 1 && b.len() > 1 ==> forall|i: int| 0 <= i < b.len() ==> b_broadcast[i] == b[i]) &&\n            (a.len() == b.len() ==> forall|i: int| 0 <= i < b.len() ==> b_broadcast[i] == b[i])\n        })", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "array_manipulation_hsplit", "vc-description": "Split a 1D array into multiple sub-arrays horizontally.\nFor simplicity, we focus on the 1D case where the array is split into \nk equal parts. In numpy, hsplit on 1D arrays is equivalent to split with axis=0.\n\nSpecification: hsplit divides a 1D array into k equal sub-arrays.\nEach sub-array has n/k elements. The i-th sub-array contains elements \nfrom index i*(n/k) to (i+1)*(n/k)-1 of the original array.\n\nMathematical properties:\n1. The concatenation of all sub-arrays equals the original array\n2. Each sub-array has exactly n/k elements\n3. Elements are distributed in order without overlapping", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hsplit(arr: Vec<f32>, k: usize) -> (result: Vec<Vec<f32>>)\n    requires \n        k > 0,\n        arr.len() % k == 0,\n    ensures\n        result.len() == k,\n        forall|part_idx: int| 0 <= part_idx < k ==> result[part_idx].len() == arr.len() / k,\n        forall|part_idx: int, elem_idx: int| \n            0 <= part_idx < k && 0 <= elem_idx < (arr.len() / k) ==>\n            #[trigger] result[part_idx][elem_idx] == arr[part_idx * (arr.len() / k) + elem_idx],\n        forall|i: int| 0 <= i < arr.len() ==> \n            exists|p: int, e: int| \n                0 <= p < k && 0 <= e < (arr.len() / k) &&\n                i == p * (arr.len() / k) + e &&\n                #[trigger] arr[i] == result[p][e]", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "array_manipulation_moveaxis", "vc-description": "Move axes of an array to new positions.\n\nMove axes in a 1D vector (simplified version).\nFor 1D arrays, moveaxis with source=0 and destination=0 returns the array unchanged.\nThis captures the core mathematical property that moving an axis to itself is identity.\n\nSpecification: moveaxis preserves all elements and their values.\nFor 1D arrays, moveaxis is always the identity function since there's only one axis.\nThis specification captures several mathematical properties:\n1. Element preservation: all values remain unchanged\n2. Size preservation: the shape is maintained\n3. Identity property: moving axis 0 to position 0 is identity\n4. Order preservation: for 1D arrays, element order is maintained", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn moveaxis(a: Vec<f32>, source: usize, dest: usize) -> (result: Vec<f32>)\n    ensures\n        /* Core property: moveaxis on 1D array is identity */\n        forall|i: int| 0 <= i < a.len() ==> result[i] == a[i],\n        /* Sanity check: size is preserved */\n        result.len() == a.len(),\n        /* Mathematical property: for 1D arrays, result equals input */\n        result@ == a@,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "array_manipulation_roll", "vc-description": "Roll array elements along a given axis by cyclically shifting elements.\nElements that roll beyond the last position are re-introduced at the first.\n\nSpecification: roll cyclically shifts array elements by the given amount.\nFor positive shift, elements move to the right and wrap around.\nFor negative shift, elements move to the left and wrap around.\nEmpty vectors are returned unchanged.\n\nMathematical property: result[i] = a[(i - shift) mod n]\nwhere the modulo operation handles negative values correctly.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn normalize_index(i: int, shift: int, n: int) -> int {\n    let src_idx = i - shift;\n    let mod_result = src_idx % n;\n    if mod_result < 0 { mod_result + n } else { mod_result }\n}\n\nfn roll<T>(a: Vec<T>, shift: i32) -> (result: Vec<T>)\n    ensures\n        result.len() == a.len(),\n        a.len() == 0 ==> result@ == a@,\n        a.len() > 0 ==> forall|i: int| 0 <= i < a.len() ==> #[trigger] result[i] == a[normalize_index(i, shift as int, a.len() as int)]", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "array_manipulation_trim_zeros", "vc-description": "numpy.trim_zeros: Trim the leading and/or trailing zeros from a 1-D array.\n\nRemoves zeros from the beginning and/or end of a vector based on the trim mode.\n- Front: removes leading zeros only\n- Back: removes trailing zeros only\n- Both: removes both leading and trailing zeros (default)\n\nThe function preserves all non-zero elements and internal zeros.\n\nSpecification: trim_zeros removes leading and/or trailing zeros while preserving order.\n\nThe function guarantees:\n1. All non-zero elements from the original array are preserved in order\n2. Internal zeros (zeros between non-zero elements) are preserved\n3. Only leading/trailing zeros are removed based on the mode\n4. If the array contains only zeros, returns an empty vector", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* Represents the trim mode for trim_zeros function */\n#[derive(Eq, PartialEq)]\npub enum TrimMode {\n    /* Trim zeros from the front of the array only (corresponds to 'f') */\n    Front,\n    /* Trim zeros from the back of the array only (corresponds to 'b') */\n    Back,\n    /* Trim zeros from both front and back of the array (corresponds to 'fb', default) */\n    Both,\n}", "vc-helpers": "", "vc-spec": "fn trim_zeros(arr: Vec<f32>, mode: TrimMode) -> (result: Vec<f32>)\n    ensures\n        result.len() <= arr.len(),\n        /* Result contains only elements from the original array */\n        forall|i: int| 0 <= i < result.len() ==> \n            exists|j: int| 0 <= j < arr.len() && #[trigger] result[i] == arr[j],\n        /* Basic trimming properties based on mode */\n        (mode == TrimMode::Front ==> \n            (result.len() == 0 || result[0] != 0.0f32)),\n        (mode == TrimMode::Back ==> \n            (result.len() == 0 || result[result.len() - 1] != 0.0f32)),\n        (mode == TrimMode::Both ==> \n            (result.len() == 0 || (result[0] != 0.0f32 && result[result.len() - 1] != 0.0f32)))", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "array_manipulation_unique", "vc-description": "numpy.unique: Find the unique elements of a vector and return them sorted.\n\nReturns a new vector containing each distinct element from the input exactly once,\nsorted in ascending order. This is a simplified version that only returns the \nunique values without the optional indices or counts.\n\nThe output size depends on the number of unique elements in the input.\n\nSpecification: numpy.unique returns a sorted vector containing each distinct element \nfrom the input exactly once.\n\nPrecondition: True\nPostcondition: \n- The result is sorted in ascending order\n- No duplicates exist in the result\n- Every element in result comes from the input array\n- Every distinct element from input appears in result", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_sorted(arr: Seq<i32>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < arr.len() ==> arr[i] <= arr[j]\n}\n\nspec fn has_no_duplicates(arr: Seq<i32>) -> bool {\n    forall|i: int, j: int| 0 <= i < arr.len() && 0 <= j < arr.len() && i != j ==> arr[i] != arr[j]\n}\n\nspec fn all_elements_from_input(result: Seq<i32>, input: Seq<i32>) -> bool {\n    forall|i: int| 0 <= i < result.len() ==> #[trigger] input.contains(result[i])\n}\n\nspec fn all_distinct_elements_present(input: Seq<i32>, result: Seq<i32>) -> bool {\n    forall|val: i32| input.contains(val) ==> #[trigger] result.contains(val)\n}\n\nfn numpy_unique(arr: Vec<i32>) -> (result: (usize, Vec<i32>))\n    ensures\n        is_sorted(result.1@),\n        has_no_duplicates(result.1@),\n        all_elements_from_input(result.1@, arr@),\n        all_distinct_elements_present(arr@, result.1@),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "constants_NPY_1_PI", "vc-description": "The mathematical constant 1/π (one divided by pi), approximately 0.31831...\n\nSpecification: NPY_1_PI represents the reciprocal of pi (1/π),\nand satisfies key mathematical properties", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn npy_1_pi() -> (result: i32)\n    ensures\n        /* Mathematical constant representing 1/π as a fixed-point approximation */\n        result > 0,\n        /* Basic sanity check for positive value */\n        result < 1000000000,", "vc-code": "{\n    // impl-start\n    assume(false);\n    318309886\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "constants_NPY_2_PI", "vc-description": "The mathematical constant 2/π, approximately 0.6366...\n\nSpecification: NPY_2_PI represents the ratio 2/π and satisfies key mathematical properties", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn npy_2_pi() -> (result: i32)\n    ensures\n        result == 636619772,\n        result > 636000000,\n        result < 637000000", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "constants_NPY_LOG10E", "vc-description": "Base 10 logarithm of Euler's number e\n\nNPY_LOG10E returns the base 10 logarithm of e with correct mathematical properties\nlog10(e) = 0.434294481903251827651128918916605082", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn npy_log10e() -> (result: f64)\n    ensures\n        result == 0.434294481903251827651128918916605082", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "constants_NPY_LOGE10", "vc-description": "Natural logarithm of 10\n\nNPY_LOGE10 - C API Mathematical constants\nDescription: Natural logarithm of 10\nDocumentation: ln(10) = 2.302585092994045684017991454684364208\n\nNatural logarithm of 10 (ln(10))\n\nSpecification: npy_loge10 is the natural logarithm of 10 with mathematical properties:\n1. It is approximately 2.302585092994045684017991454684364208\n2. It satisfies the property that e^(npy_loge10) = 10\n3. It is the inverse of log10(e), meaning npy_loge10 * log10(e) = 1\n4. It is useful for converting between natural and base-10 logarithms", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn npy_loge10() -> (result: i32)\n    ensures\n        /* Mathematical property: ln(10) is positive (since 10 > 1) */\n        result >= 0,\n        /* Mathematical property: ln(10) > ln(e) = 1 (since 10 > e) */  \n        result >= 1,\n        /* Mathematical property: ln(10) is between 2 and 3 */\n        2 <= result && result <= 3,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "constants_NPY_LOGE2", "vc-description": "Natural logarithm of 2\n\nNPY_LOGE2 - C API Mathematical constant\nNatural logarithm of 2\nln(2) = 0.693147180559945309417232121458176568\n\nSpecification: nPY_LOGE2 returns the natural logarithm of 2 with correct mathematical properties", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn npy_loge2() -> (result: f64)\n    ensures\n        result == 0.693147180559945309417232121458176568", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "constants_NPY_PI_2", "vc-description": "The mathematical constant π/2 (pi divided by 2), approximately 1.5708...\n\nSpecification: NPY_PI_2 represents π/2, which is half of pi and corresponds to 90 degrees\nin radians. It satisfies key mathematical properties related to trigonometry and geometry", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn npy_pi_2() -> (result: i32)\n    ensures\n        /* π/2 is approximately 1.5708... represented as fixed point */\n        1570 < result && result < 1571,\n        /* Basic sanity check: π/2 is between 1 and 2 */\n        1000 < result && result < 2000,\n        /* 2*(π/2) should be approximately π (3.14159...) */\n        3141 < 2 * result && 2 * result < 3142,\n        /* (π/2)/2 = π/4 is approximately 0.7854... */\n        785 < result / 2 && result / 2 < 786,\n        /* 3*(π/2) = 3π/2 is approximately 4.7124... (270 degrees) */\n        4712 < 3 * result && 3 * result < 4713,\n        /* 4*(π/2) = 2π is approximately 6.2832... (full circle) */\n        6283 < 4 * result && 4 * result < 6284,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "constants_NPY_PI_4", "vc-description": "NPY_PI_4: Mathematical constant representing π/4.\n\nThis constant provides the value of pi divided by 4, which is commonly used in\ntrigonometric calculations, particularly for 45-degree angle computations.\n\nValue: π/4 ≈ 0.785398163397448309615660845819875721\n\nSpecification: NPY_PI_4 returns the mathematical constant π/4.\n\nPrecondition: True (no preconditions for accessing a constant)\nPostcondition: The result equals π/4, which is approximately 0.7853981633974483\n\nMathematical properties:\n- NPY_PI_4 = π/4\n- NPY_PI_4 = arctan(1)  \n- sin(NPY_PI_4) = cos(NPY_PI_4) = √2/2\n- tan(NPY_PI_4) = 1\n- 4 * NPY_PI_4 = π", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "const NPY_PI_4_EXACT: f64 = 0.785398163397448309615660845819875721;\n\nfn npy_pi_4() -> (result: f64)\n    ensures result == NPY_PI_4_EXACT", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "constants_NPY_SQRT2", "vc-description": "Square root of 2 as a mathematical constant with value √2 = 1.414213562373095048801688724209698079. The specification ensures the constant is positive, that its square equals 2 within floating-point precision, and that it matches the expected mathematical value.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "global size_of usize == 8;\n\nspec fn npy_sqrt2_value() -> f64 {\n    1.4142135623730951\n}\n\nfn npy_sqrt2() -> (result: f64)\n    ensures\n        result == npy_sqrt2_value(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    0.0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "constants_NZERO", "vc-description": "IEEE 754 floating point representation of negative zero.\n\nSpecification: NZERO represents IEEE 754 negative zero, which equals zero \nbut has special properties in floating point arithmetic", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn NZERO() -> (result: f64)\n    ensures\n        result == 0.0", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "constants_finfo", "vc-description": "numpy.finfo: Returns machine limits for floating point types.\n\nGiven a floating-point data type, returns a structure containing\ninformation about the numerical properties and limits of that type,\nincluding epsilon, maximum/minimum values, and precision details.\n\nFor now, we model this as a function that takes Unit and returns\nFloatInfo for the default Float type.\n\nSpecification: numpy.finfo returns consistent and mathematically valid\ninformation about floating-point type limits.\n\nThe returned structure satisfies fundamental properties of floating-point\nrepresentations according to IEEE 754 standard.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* Structure representing floating-point type information */\npub struct FloatInfo {\n    pub eps: u32,              // Machine epsilon (represented as u32)\n    pub epsneg: u32,           // Negative machine epsilon  \n    pub max: u32,              // Maximum representable value\n    pub min: i32,              // Minimum representable value (typically -max)\n    pub tiny: u32,             // Smallest positive normal number\n    pub smallest_subnormal: u32, // Smallest positive subnormal number\n    pub maxexp: i32,           // Maximum exponent\n    pub minexp: i32,           // Minimum exponent\n    pub negep: i32,            // Negative epsilon exponent\n    pub nexp: u32,             // Number of bits in exponent\n    pub nmant: u32,            // Number of bits in mantissa\n    pub precision: u32,        // Approximate decimal precision\n}", "vc-helpers": "", "vc-spec": "fn numpy_finfo() -> (info: FloatInfo)\n    ensures\n        /* Machine epsilon is positive */\n        info.eps > 0,\n        /* Negative epsilon is positive */\n        info.epsneg > 0,\n        /* Max is positive and finite */\n        info.max > 0,\n        /* Min is negative max (for symmetric representation) */\n        info.min == -(info.max as i32),\n        /* Tiny (smallest normal) is positive */\n        info.tiny > 0,\n        /* Smallest subnormal is positive and less than tiny */\n        info.smallest_subnormal > 0,\n        info.smallest_subnormal < info.tiny,\n        /* Exponent relationships */\n        info.maxexp > 0,\n        info.minexp < 0,\n        info.negep < 0,\n        /* Bit counts are positive */\n        info.nexp > 0,\n        info.nmant > 0,\n        /* Precision is at least 1 */\n        info.precision >= 1,\n        /* Relationship between mantissa bits and precision */\n        info.precision <= info.nmant", "vc-code": "{\n    // impl-start\n    assume(false);\n    FloatInfo {\n        eps: 1,\n        epsneg: 1,\n        max: 1,\n        min: -1,\n        tiny: 1,\n        smallest_subnormal: 1,\n        maxexp: 1,\n        minexp: -1,\n        negep: -1,\n        nexp: 1,\n        nmant: 1,\n        precision: 1,\n    }\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "constants_pi", "vc-description": "The mathematical constant pi (π), approximately 3.14159...\n\nSpecification: pi represents the ratio of a circle's circumference to its diameter,\nand satisfies key mathematical properties", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn pi() -> (result: i32)\n    ensures\n        result > 3 && result < 4", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "data_type_routines_dtype", "vc-description": "numpy.dtype: Create a data type object.\n\nA numpy array is homogeneous, and contains elements described by a dtype object. \nA dtype object can be constructed from different combinations of fundamental numeric types.\n\nThis specification focuses on creating basic numeric data types like int16, int32, float32, float64.\nThe function maps type specifications to their corresponding DType objects with proper\nattributes like size, alignment, and signedness.\n\nSpecification: numpy.dtype creates a valid data type object with consistent attributes.\n\nPrecondition: The type_spec is a valid NumPy type specification\nPostcondition: The resulting DType has consistent attributes that match the specified type", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* Represents a NumPy data type object with its essential attributes */\npub struct DType {\n    /* The fundamental numeric type category */\n    pub kind: &'static str,\n    /* The element size in bytes */\n    pub itemsize: usize,\n    /* The alignment requirement in bytes */\n    pub alignment: usize,\n    /* A descriptive name for the data type */\n    pub name: &'static str,\n    /* Whether the data type is signed (for numeric types) */\n    pub signed: bool,\n}", "vc-helpers": "", "vc-spec": "fn numpy_dtype(type_spec: &str) -> (result: DType)\n    requires type_spec == \"int8\" || type_spec == \"int16\" || type_spec == \"int32\" || \n             type_spec == \"int64\" || type_spec == \"float32\" || type_spec == \"float64\" || \n             type_spec == \"bool\",\n    ensures\n        /* The data type has a valid kind character */\n        (result.kind == \"i\" || result.kind == \"f\" || result.kind == \"b\") &&\n        /* The itemsize is positive and matches the type specification */\n        (result.itemsize > 0) &&\n        /* The alignment is positive and does not exceed the itemsize */\n        (result.alignment > 0 && result.alignment <= result.itemsize) &&\n        /* The name is non-empty */\n        (result.name != \"\") &&\n        /* Size consistency for specific types */\n        ((type_spec == \"int8\" ==> result.itemsize == 1 && result.signed == true && result.kind == \"i\") &&\n         (type_spec == \"int16\" ==> result.itemsize == 2 && result.signed == true && result.kind == \"i\") &&\n         (type_spec == \"int32\" ==> result.itemsize == 4 && result.signed == true && result.kind == \"i\") &&\n         (type_spec == \"int64\" ==> result.itemsize == 8 && result.signed == true && result.kind == \"i\") &&\n         (type_spec == \"float32\" ==> result.itemsize == 4 && result.kind == \"f\") &&\n         (type_spec == \"float64\" ==> result.itemsize == 8 && result.kind == \"f\") &&\n         (type_spec == \"bool\" ==> result.itemsize == 1 && result.kind == \"b\"))", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "data_type_routines_find_common_type", "vc-description": "numpy.find_common_type: Determine common type following standard coercion rules.\n\nThis function determines the common data type by following NumPy's type promotion rules.\nIt returns the maximum of array_types ignoring scalar_types, unless the maximum of \nscalar_types is of a different kind (dtype.kind).\n\nNote: This function is deprecated in NumPy 1.25.0 in favor of numpy.result_type.\n\nSpecification: find_common_type implements NumPy's type promotion rules correctly.\n\nThe function should:\n1. Return the maximum precedence type from array_types if scalar_types is empty\n2. Return the maximum precedence type from scalar_types if array_types is empty  \n3. If both are non-empty, return the maximum from array_types unless the maximum\n   from scalar_types has a different kind, in which case return the scalar maximum\n4. Handle the case where type promotion results in a valid common type\n\nPrecondition: At least one of the input vectors is non-empty\nPostcondition: The result follows NumPy's documented type promotion rules", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* Data type representation for NumPy types */\n#[derive(PartialEq, Eq, Clone, Copy)]\nenum DType {\n    /* 8-bit signed integer */\n    Int8,\n    /* 16-bit signed integer */\n    Int16,\n    /* 32-bit signed integer */\n    Int32,\n    /* 64-bit signed integer */\n    Int64,\n    /* 8-bit unsigned integer */\n    UInt8,\n    /* 16-bit unsigned integer */\n    UInt16,\n    /* 32-bit unsigned integer */\n    UInt32,\n    /* 64-bit unsigned integer */\n    UInt64,\n    /* 32-bit floating point */\n    Float32,\n    /* 64-bit floating point */\n    Float64,\n    /* 64-bit complex number */\n    Complex64,\n    /* 128-bit complex number */\n    Complex128,\n    /* Boolean type */\n    Bool,\n    /* Object type */\n    Object,\n}\n\n/* Type hierarchy for promotion rules */\nspec fn dtype_kind(dt: DType) -> char {\n    match dt {\n        DType::Bool => 'b',\n        DType::Int8 | DType::Int16 | DType::Int32 | DType::Int64 => 'i',\n        DType::UInt8 | DType::UInt16 | DType::UInt32 | DType::UInt64 => 'u',\n        DType::Float32 | DType::Float64 => 'f',\n        DType::Complex64 | DType::Complex128 => 'c',\n        DType::Object => 'O',\n    }\n}\n\n/* Type precedence for promotion (higher values have higher precedence) */\nspec fn dtype_precedence(dt: DType) -> nat {\n    match dt {\n        DType::Bool => 0,\n        DType::Int8 => 1,\n        DType::Int16 => 2,\n        DType::Int32 => 3,\n        DType::Int64 => 4,\n        DType::UInt8 => 5,\n        DType::UInt16 => 6,\n        DType::UInt32 => 7,\n        DType::UInt64 => 8,\n        DType::Float32 => 9,\n        DType::Float64 => 10,\n        DType::Complex64 => 11,\n        DType::Complex128 => 12,\n        DType::Object => 13,\n    }\n}", "vc-helpers": "", "vc-spec": "fn find_common_type(array_types: Vec<DType>, scalar_types: Vec<DType>) -> (result: Option<DType>)\n    requires array_types.len() > 0 || scalar_types.len() > 0,\n    ensures \n        /* Case 1: Only array types provided */\n        (scalar_types.len() == 0 && array_types.len() > 0) ==> (\n            exists|dt: DType| result == Some(dt) &&\n            array_types@.contains(dt) &&\n            forall|other: DType| array_types@.contains(other) ==> dtype_precedence(other) <= dtype_precedence(dt)\n        ),\n        /* Case 2: Only scalar types provided */\n        (array_types.len() == 0 && scalar_types.len() > 0) ==> (\n            exists|dt: DType| result == Some(dt) &&\n            scalar_types@.contains(dt) &&\n            forall|other: DType| scalar_types@.contains(other) ==> dtype_precedence(other) <= dtype_precedence(dt)\n        ),\n        /* Case 3: Both array and scalar types provided */\n        (array_types.len() > 0 && scalar_types.len() > 0) ==> (\n            exists|max_array: DType, max_scalar: DType|\n                array_types@.contains(max_array) && scalar_types@.contains(max_scalar) &&\n                (forall|dt: DType| array_types@.contains(dt) ==> dtype_precedence(dt) <= dtype_precedence(max_array)) &&\n                (forall|dt: DType| scalar_types@.contains(dt) ==> dtype_precedence(dt) <= dtype_precedence(max_scalar)) &&\n                ((dtype_kind(max_array) == dtype_kind(max_scalar)) ==> result == Some(max_array)) &&\n                ((dtype_kind(max_array) != dtype_kind(max_scalar)) ==> result == Some(max_scalar))\n        )", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "data_type_routines_finfo", "vc-description": "Machine limits for floating point types.\n\nReturns machine limits for the Float type in Lean.\nThis provides information about the precision and range of Float values.\n\nIn NumPy, this would accept different dtypes, but in Lean we work with the built-in Float type.\n\nSpecification: numpy.finfo returns floating point type information with correct properties.\n\nPrecondition: True (no special preconditions)\nPostcondition: The returned FloatInfo has mathematically consistent properties", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "/* Structure representing floating point type information returned by numpy.finfo */\nstruct FloatInfo {\n    /* The number of bits occupied by the type */\n    bits: nat,\n    /* The smallest representable positive number such that 1.0 + eps != 1.0 */\n    eps: int,\n    /* The largest representable number */\n    max: int,\n    /* The smallest representable number, typically -max */\n    min: int,\n    /* The approximate number of decimal digits to which this kind of float is precise */\n    precision: nat,\n    /* The approximate decimal resolution of this type */\n    resolution: int,\n    /* The smallest positive floating point number with 1 as leading bit in the mantissa */\n    smallest_normal: int,\n    /* The smallest positive floating point number with 0 as leading bit in the mantissa */\n    smallest_subnormal: int,\n}\n\nfn numpy_finfo() -> (info: FloatInfo)\n    ensures\n        /* Basic sanity checks */\n        info.bits > 0,\n        info.precision > 0,\n        /* eps is positive and small */\n        info.eps > 0,\n        info.eps < 1,\n        /* max is positive, min is negative */\n        info.max > 0,\n        info.min < 0,\n        /* min is typically -max for symmetric floating point types */\n        info.min == -info.max,\n        /* resolution is positive */\n        info.resolution > 0,\n        /* smallest_normal is positive and smaller than 1 */\n        info.smallest_normal > 0,\n        info.smallest_normal < 1,\n        /* smallest_subnormal is positive and smaller than smallest_normal */\n        info.smallest_subnormal > 0,\n        info.smallest_subnormal <= info.smallest_normal,\n        /* eps represents the machine epsilon property */\n        info.eps == info.resolution,\n        /* The number of bits should be reasonable (32 or 64 for common float types) */\n        info.bits == 32 || info.bits == 64,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "data_type_routines_format_parser", "vc-description": "numpy.format_parser: Class to convert formats, names, titles description to a dtype.\n\nThis function takes format descriptions, field names, and optional titles\nand produces a structured data type specification. It validates that the\nformats are well-formed and that the number of names matches the number\nof format descriptors.\n\nThe function handles common NumPy format strings like 'f8' (float64),\n'i4' (int32), 'S5' (string of length 5), etc.\n\nSpecification: numpy.format_parser creates a structured data type from format descriptions.\n\nPrecondition: All format strings in formats are valid NumPy format descriptors\nPostcondition: \n1. The result has the same number of fields as input vectors\n2. Each field has the correct name from the names vector\n3. Each field has the correct format descriptor parsed from the formats vector\n4. If titles are provided, each field has the corresponding title\n5. The alignment setting is preserved", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* A format descriptor for structured data types */\n#[derive(Eq, PartialEq)]\npub enum FormatDescriptor {\n    /* 64-bit floating point ('f8') */\n    Float64,\n    /* 32-bit integer ('i4') */\n    Int32,\n    /* Variable length string ('S5' for string of length 5) */\n    String(nat),\n    /* 64-bit integer ('i8') */\n    Int64,\n    /* 32-bit floating point ('f4') */\n    Float32,\n}\n\n/* A field in a structured data type */\n#[derive(Eq, PartialEq)]\npub struct Field {\n    /* Field name */\n    pub name: String,\n    /* Format descriptor */\n    pub format: FormatDescriptor,\n    /* Optional title for the field */\n    pub title: Option<String>,\n}\n\n/* A structured data type specification */\n#[derive(Eq, PartialEq)]\npub struct DType {\n    /* Vector of fields */\n    pub fields: Vec<Field>,\n    /* Whether fields are aligned as C-compiler would */\n    pub aligned: bool,\n}", "vc-helpers": "", "vc-spec": "spec fn is_valid_format(format: String) -> bool {\n    format@ == \"f8\".view() || format@ == \"f4\".view() || format@ == \"i4\".view() || format@ == \"i8\".view() || \n    (format@.len() > 1 && format@.index(0) == 'S')\n}\n\nspec fn parse_format_descriptor(format: String) -> FormatDescriptor {\n    if format@ == \"f8\".view() {\n        FormatDescriptor::Float64\n    } else if format@ == \"f4\".view() {\n        FormatDescriptor::Float32\n    } else if format@ == \"i4\".view() {\n        FormatDescriptor::Int32\n    } else if format@ == \"i8\".view() {\n        FormatDescriptor::Int64\n    } else {\n        FormatDescriptor::String(5) // simplified for spec\n    }\n}\n\nfn numpy_format_parser(\n    formats: Vec<String>,\n    names: Vec<String>,\n    titles: Option<Vec<String>>,\n    aligned: bool\n) -> (result: DType)\n    requires \n        formats.len() == names.len(),\n        titles.is_some() ==> titles.unwrap().len() == names.len(),\n        forall|i: int| 0 <= i < formats.len() ==> is_valid_format(formats[i]),\n    ensures\n        result.fields.len() == formats.len(),\n        forall|i: int| 0 <= i < result.fields.len() ==> result.fields[i].name == names[i],\n        forall|i: int| 0 <= i < result.fields.len() ==> \n            result.fields[i].format == parse_format_descriptor(formats[i]),\n        match titles {\n            Some(title_vec) => forall|i: int| 0 <= i < result.fields.len() ==> \n                result.fields[i].title == Some(title_vec[i]),\n            None => forall|i: int| 0 <= i < result.fields.len() ==> \n                result.fields[i].title.is_none(),\n        },\n        result.aligned == aligned,", "vc-code": "{\n    // impl-start\n    assume(false);\n    DType {\n        fields: Vec::new(),\n        aligned: false,\n    }\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "data_type_routines_min_scalar_type", "vc-description": "numpy.min_scalar_type: For scalar a, returns the data type with the smallest size \nand smallest scalar kind which can hold its value.\n\nThis function determines the minimal NumPy data type that can represent a given scalar value.\nThe function prioritizes:\n1. Smallest possible size (in bits)\n2. Smallest scalar kind (unsigned int < signed int < float < complex)\n\nFor integer values, it finds the smallest integer type that can hold the value.\nFor floating point values, it finds the smallest float type that can represent it.\n\nSpecification: min_scalar_type returns the minimal data type that can hold the given value.\n\nPrecondition: True (works for any scalar value)\nPostcondition: The returned type is the minimal type that can hold the value, meaning:\n1. The type can represent the given value\n2. No type with smaller size can represent the value\n3. Among types of the same size, it has the smallest kind order", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n/* Enumeration for NumPy data types */\n#[derive(PartialEq, Eq, Structural)]\npub enum NumpyDType {\n    UInt8,\n    UInt16,\n    UInt32,\n    UInt64,\n    Int8,\n    Int16,\n    Int32,\n    Int64,\n    Float16,\n    Float32,\n    Float64,\n    Complex64,\n    Complex128,\n}\n\n/* Define type sizes in bits */\nspec fn dtype_size(dt: NumpyDType) -> nat {\n    match dt {\n        NumpyDType::UInt8 => 8,\n        NumpyDType::UInt16 => 16,\n        NumpyDType::UInt32 => 32,\n        NumpyDType::UInt64 => 64,\n        NumpyDType::Int8 => 8,\n        NumpyDType::Int16 => 16,\n        NumpyDType::Int32 => 32,\n        NumpyDType::Int64 => 64,\n        NumpyDType::Float16 => 16,\n        NumpyDType::Float32 => 32,\n        NumpyDType::Float64 => 64,\n        NumpyDType::Complex64 => 64,\n        NumpyDType::Complex128 => 128,\n    }\n}\n\n/* Define type hierarchy (order of preference) */\nspec fn dtype_kind_order(dt: NumpyDType) -> nat {\n    match dt {\n        NumpyDType::UInt8 | NumpyDType::UInt16 | NumpyDType::UInt32 | NumpyDType::UInt64 => 0,\n        NumpyDType::Int8 | NumpyDType::Int16 | NumpyDType::Int32 | NumpyDType::Int64 => 1,\n        NumpyDType::Float16 | NumpyDType::Float32 | NumpyDType::Float64 => 2,\n        NumpyDType::Complex64 | NumpyDType::Complex128 => 3,\n    }\n}\n\n/* Check if a type can represent a given integer value */\nspec fn can_represent_value(dt: NumpyDType, value: int) -> bool {\n    match dt {\n        NumpyDType::UInt8 => 0 <= value <= 255,\n        NumpyDType::UInt16 => 0 <= value <= 65535,\n        NumpyDType::UInt32 => 0 <= value <= 4294967295,\n        NumpyDType::UInt64 => 0 <= value <= 18446744073709551615,\n        NumpyDType::Int8 => -128 <= value <= 127,\n        NumpyDType::Int16 => -32768 <= value <= 32767,\n        NumpyDType::Int32 => -2147483648 <= value <= 2147483647,\n        NumpyDType::Int64 => -9223372036854775808 <= value <= 9223372036854775807,\n        NumpyDType::Float16 | NumpyDType::Float32 | NumpyDType::Float64 | NumpyDType::Complex64 | NumpyDType::Complex128 => true,\n    }\n}", "vc-helpers": "", "vc-spec": "fn min_scalar_type(value: i64) -> (result: NumpyDType)\n    ensures\n        can_represent_value(result, value as int),\n        forall|dt: NumpyDType| dtype_size(dt) < dtype_size(result) ==> !can_represent_value(dt, value as int),\n        forall|dt: NumpyDType| dtype_size(dt) == dtype_size(result) && can_represent_value(dt, value as int) ==> dtype_kind_order(result) <= dtype_kind_order(dt)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}"}
{"id": "data_type_routines_sctype2char", "vc-description": "numpy.sctype2char: Return the string representation of a scalar dtype\n\nConverts a scalar data type to its corresponding single-character string representation.\nThis is used internally by numpy to represent data types in a compact form.\n\nThe mapping follows numpy's dtype.char convention:\n- int32 → 'l'\n- float64 (double) → 'd'  \n- complex128 → 'D'\n- bytes → 'S'\n- object → 'O'\n\nSpecification: sctype2char returns the correct character representation\nfor each scalar type.\n\nPrecondition: Valid scalar type (guaranteed by type system)\nPostcondition: Returns the standard numpy character for the given type", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* Scalar data type enumeration for numpy types */\npub enum ScalarType {\n    /* 32-bit signed integer */\n    Int32,\n    /* 64-bit signed integer */\n    Int64,\n    /* 32-bit floating point */\n    Float32,\n    /* 64-bit floating point */\n    Float64,\n    /* 64-bit complex number */\n    Complex64,\n    /* 128-bit complex number */\n    Complex128,\n    /* Byte string */\n    Bytes,\n    /* Generic object */\n    Object,\n}", "vc-helpers": "", "vc-spec": "fn sctype2char(sctype: ScalarType) -> (result: &'static str)\n    ensures\n        (sctype == ScalarType::Int32) ==> (result == \"l\"),\n        (sctype == ScalarType::Int64) ==> (result == \"q\"),\n        (sctype == ScalarType::Float32) ==> (result == \"f\"),\n        (sctype == ScalarType::Float64) ==> (result == \"d\"),\n        (sctype == ScalarType::Complex64) ==> (result == \"F\"),\n        (sctype == ScalarType::Complex128) ==> (result == \"D\"),\n        (sctype == ScalarType::Bytes) ==> (result == \"S\"),\n        (sctype == ScalarType::Object) ==> (result == \"O\")", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "data_type_routines_typename", "vc-description": "Return a description for the given data type code\n\n{\n  \"name\": \"numpy.typename\",\n  \"category\": \"Miscellaneous Type Utilities\", \n  \"description\": \"Return a description for the given data type code\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.typename.html\",\n  \"doc\": \"Return a description for the given data type code.\\n\\nParameters\\n----------\\nchar : str\\n    Data type code.\\n\\nReturns\\n-------\\nout : str\\n    Description of the input data type code.\\n\\nExamples\\n--------\\n>>> typechars = ['S1', '?', 'B', 'D', 'G', 'F', 'I', 'H', 'L', 'O', 'Q',\\n...              'S', 'U', 'V', 'b', 'd', 'g', 'f', 'i', 'h', 'l', 'q']\\n>>> for typechar in typechars:\\n...     print(typechar, ' : ', np.typename(typechar))\\n...\\nS1  :  character\\n?  :  bool\\nB  :  unsigned char\\nD  :  complex double precision\\nG  :  complex long double precision\\nF  :  complex single precision\\nI  :  unsigned integer\\nH  :  unsigned short\\nL  :  unsigned long integer\\nO  :  object\\nQ  :  unsigned long long integer\\nS  :  character\\nU  :  unicode\\nV  :  void\\nb  :  signed char\\nd  :  double precision\\ng  :  long precision\\nf  :  single precision\\ni  :  integer\\nh  :  short\\nl  :  long integer\\nq  :  long long integer\",\n}\n\nReturn a description for the given data type code\n\nSpecification: typename maps data type codes to their descriptions", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn typename(char: &str) -> (result: String)\n    ensures\n        /* Known type code mappings from NumPy documentation */\n        (char == \"S1\" ==> result@ == seq!['c','h','a','r','a','c','t','e','r']) &&\n        (char == \"?\" ==> result@ == seq!['b','o','o','l']) &&\n        (char == \"B\" ==> result@ == seq!['u','n','s','i','g','n','e','d',' ','c','h','a','r']) &&\n        (char == \"D\" ==> result@ == seq!['c','o','m','p','l','e','x',' ','d','o','u','b','l','e',' ','p','r','e','c','i','s','i','o','n']) &&\n        (char == \"G\" ==> result@ == seq!['c','o','m','p','l','e','x',' ','l','o','n','g',' ','d','o','u','b','l','e',' ','p','r','e','c','i','s','i','o','n']) &&\n        (char == \"F\" ==> result@ == seq!['c','o','m','p','l','e','x',' ','s','i','n','g','l','e',' ','p','r','e','c','i','s','i','o','n']) &&\n        (char == \"I\" ==> result@ == seq!['u','n','s','i','g','n','e','d',' ','i','n','t','e','g','e','r']) &&\n        (char == \"H\" ==> result@ == seq!['u','n','s','i','g','n','e','d',' ','s','h','o','r','t']) &&\n        (char == \"L\" ==> result@ == seq!['u','n','s','i','g','n','e','d',' ','l','o','n','g',' ','i','n','t','e','g','e','r']) &&\n        (char == \"O\" ==> result@ == seq!['o','b','j','e','c','t']) &&\n        (char == \"Q\" ==> result@ == seq!['u','n','s','i','g','n','e','d',' ','l','o','n','g',' ','l','o','n','g',' ','i','n','t','e','g','e','r']) &&\n        (char == \"S\" ==> result@ == seq!['c','h','a','r','a','c','t','e','r']) &&\n        (char == \"U\" ==> result@ == seq!['u','n','i','c','o','d','e']) &&\n        (char == \"V\" ==> result@ == seq!['v','o','i','d']) &&\n        (char == \"b\" ==> result@ == seq!['s','i','g','n','e','d',' ','c','h','a','r']) &&\n        (char == \"d\" ==> result@ == seq!['d','o','u','b','l','e',' ','p','r','e','c','i','s','i','o','n']) &&\n        (char == \"g\" ==> result@ == seq!['l','o','n','g',' ','p','r','e','c','i','s','i','o','n']) &&\n        (char == \"f\" ==> result@ == seq!['s','i','n','g','l','e',' ','p','r','e','c','i','s','i','o','n']) &&\n        (char == \"i\" ==> result@ == seq!['i','n','t','e','g','e','r']) &&\n        (char == \"h\" ==> result@ == seq!['s','h','o','r','t']) &&\n        (char == \"l\" ==> result@ == seq!['l','o','n','g',' ','i','n','t','e','g','e','r']) &&\n        (char == \"q\" ==> result@ == seq!['l','o','n','g',' ','l','o','n','g',' ','i','n','t','e','g','e','r']) &&\n        /* For unknown type codes, return default description */\n        (char != \"S1\" && char != \"?\" && char != \"B\" && char != \"D\" && \n         char != \"G\" && char != \"F\" && char != \"I\" && char != \"H\" && \n         char != \"L\" && char != \"O\" && char != \"Q\" && char != \"S\" && \n         char != \"U\" && char != \"V\" && char != \"b\" && char != \"d\" && \n         char != \"g\" && char != \"f\" && char != \"i\" && char != \"h\" && \n         char != \"l\" && char != \"q\" ==>\n         (result@ == seq!['u','n','k','n','o','w','n',' ','t','y','p','e'] || result@ == char@)),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "datetime_support_datetime_data", "vc-description": "Get information about the step size of a date or time type.\n\nReturns a tuple containing the datetime unit and count for the given dtype.\nThis information can be used to construct datetime64 and timedelta64 objects.\n\nFor example, 'timedelta64[25s]' would return ('s', 25).\n\nSpecification: datetime_data extracts the unit and count from a datetime dtype.\n\nPrecondition: The dtype must be a valid datetime64 or timedelta64 type.\nPostcondition: The returned tuple contains the unit and count that define the dtype.\n\nFor datetime64[N unit], returns (unit, N).\nFor timedelta64[N unit], returns (unit, N).\n\nThis ensures that the returned information can be used to reconstruct\nthe original dtype or create compatible datetime objects.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* Datetime unit enumeration representing the time scales used in datetime operations */\n#[derive(PartialEq, Eq, Structural)]\npub enum DatetimeUnit {\n    /* Years */\n    Y,\n    /* Months */\n    M,\n    /* Weeks */\n    W,\n    /* Days */\n    D,\n    /* Hours */\n    H,\n    /* Minutes */\n    Min,\n    /* Seconds */\n    S,\n    /* Milliseconds */\n    Ms,\n    /* Microseconds */\n    Us,\n    /* Nanoseconds */\n    Ns,\n}\n\n/* Structure containing datetime type information including unit and count */\n#[derive(PartialEq, Eq, Structural)]\npub struct DatetimeTypeInfo {\n    /* The time unit (seconds, minutes, hours, etc.) */\n    pub unit: DatetimeUnit,\n    /* The count of base units in a step (e.g., 25 for \"25 seconds\") */\n    pub count: nat,\n}\n\n/* Datetime dtype representing either datetime64 or timedelta64 types */\n#[derive(PartialEq, Eq, Structural)]\npub enum DatetimeDtype {\n    /* A datetime64 type with specified unit and count */\n    Datetime64(DatetimeTypeInfo),\n    /* A timedelta64 type with specified unit and count */\n    Timedelta64(DatetimeTypeInfo),\n}", "vc-helpers": "", "vc-spec": "fn datetime_data(dtype: DatetimeDtype) -> (result: (DatetimeUnit, nat))\n    ensures\n        match dtype {\n            DatetimeDtype::Datetime64(info) => result == (info.unit, info.count) && info.count > 0,\n            DatetimeDtype::Timedelta64(info) => result == (info.unit, info.count) && info.count > 0,\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fft_fftfreq", "vc-description": "numpy.fft.fftfreq: Return the Discrete Fourier Transform sample frequencies.\n\nThe function returns the discrete Fourier Transform sample frequencies\nwith frequency bin centers in cycles per unit of sample spacing.\n\nFor even n: frequencies are [0, 1, ..., n/2-1, -n/2, ..., -1] / (d*n)\nFor odd n: frequencies are [0, 1, ..., (n-1)/2, -(n-1)/2, ..., -1] / (d*n)\n\nThe frequencies are arranged in standard DFT order: positive frequencies\nfirst, then negative frequencies.\n\nSpecification: fftfreq returns sample frequencies according to the DFT convention.\n\nThe frequencies are arranged so that:\n- The first half contains non-negative frequencies [0, 1, ..., N-1] / (d*n)\n- The second half contains negative frequencies for the remaining indices\n\nwhere N = (n + 1) / 2 is the number of non-negative frequencies.\n\nPreconditions:\n- n > 0 (non-empty frequency array)\n- d ≠ 0 (valid sample spacing)\n\nPostconditions:\n- For indices i < N: result[i] = i / (d*n)\n- For indices i ≥ N: result[i] = (i - n) / (d*n)\n- The DC component (index 0) is always 0\n- The frequencies are symmetric around the Nyquist frequency", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn fft_freq_val(i: int, n: int, d: f64) -> f64;\n\nfn fftfreq(n: usize, d: f64) -> (result: Vec<f64>)\n    requires \n        n > 0,\n        d != 0.0,\n    ensures\n        result.len() == n,\n        forall|i: int| 0 <= i < ((n + 1) / 2) ==> \n            result[i] == fft_freq_val(i, n as int, d),\n        forall|i: int| ((n + 1) / 2) <= i < n ==>\n            result[i] == fft_freq_val(i, n as int, d),\n        result[0] == 0.0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fft_fftshift", "vc-description": "Shift the zero-frequency component to the center of the spectrum.\n\nThis function rearranges the FFT output such that the zero-frequency \ncomponent is moved from the beginning to the center of the array.\nFor even-length arrays, it performs a circular shift by n/2.\nFor odd-length arrays, it performs a circular shift by (n-1)/2.\n\nSpecification: fftshift performs a circular shift that moves the zero-frequency \ncomponent to the center of the array.\n\nThe function rearranges elements by performing a circular shift:\n- Each element at position i in the result comes from position (i + n - n/2) % n in the input\n- This is equivalent to swapping the first and second halves of the array\n- The zero-frequency component (originally at index 0) moves to the center\n\nKey mathematical properties:\n1. Bijective mapping: every element is preserved and appears exactly once\n2. Circular shift property: implements a specific permutation\n3. Involution property: for even n, fftshift(fftshift(x)) = x\n4. Sum preservation: the sum of all elements remains unchanged", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn fftshift(x: Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> \n            result[i] == x[((i + (x.len() as int) - (x.len() as int) / 2) % (x.len() as int)) as int]", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fft_ifftn", "vc-description": "Compute the N-dimensional inverse discrete Fourier Transform (IFFTN).\n\nThe IFFTN extends the 1D inverse FFT to multiple dimensions, computing\nthe inverse of the N-dimensional DFT. For a 2D array, this applies the\ninverse transform along both dimensions.\n\nFor a 2D array of size m×n, the (i,j)-th output element is computed as:\nX[i,j] = (1/(m*n)) * Σ(k=0 to m-1) Σ(l=0 to n-1) a[k,l] * exp(2πi*(i*k/m + j*l/n))\n\nThis is the mathematical inverse of the N-dimensional FFT.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* Sum of integers over finite indices */\npub open spec fn int_sum(n: nat, f: spec_fn(int) -> int) -> int\n    decreases n\n{\n    if n == 0 {\n        0\n    } else {\n        f((n - 1) as int) + int_sum((n - 1) as nat, f)\n    }\n}", "vc-helpers": "", "vc-spec": "fn ifftn(a: Vec<Vec<i32>>) -> (result: Vec<Vec<i32>>)\n    requires \n        a.len() > 0,\n        a.len() < usize::MAX,\n        forall|i: int| 0 <= i < a.len() ==> a[i as int].len() > 0,\n        forall|i: int| 0 <= i < a.len() ==> a[i as int].len() < usize::MAX,\n        forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() ==> a[i as int].len() == a[j as int].len(),\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i as int].len() == a[0].len(),\n        forall|i: int, j: int| #[trigger] result[i as int][j as int] == 0 || \n            (0 <= i < result.len() && 0 <= j < result[i as int].len()),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fft_ifftshift", "vc-description": "The inverse of fftshift - undoes the frequency domain shifting.\n\nThis function performs the inverse operation of fftshift, moving the \nzero-frequency component from the center back to the beginning of the array.\nFor even-length arrays, it is identical to fftshift.\nFor odd-length arrays, it differs by one sample position.\n\nThe function performs a circular shift by -(n/2) positions.\n\nSpecification: ifftshift performs the inverse of fftshift.\n\nThe function performs a circular shift that undoes the centering of \nthe zero-frequency component:\n- For even n: shifts by -(n/2), identical to fftshift\n- For odd n: shifts by -(n/2), which differs from fftshift by one sample\n\nThis ensures that:\n- Elements from the center move back to the beginning\n- The DC component at the center returns to index 0\n- The function is the left inverse of fftshift\n\nMathematical properties:\n- For even-length arrays: ifftshift(fftshift(x)) = x and fftshift(ifftshift(x)) = x\n- For odd-length arrays: ifftshift(fftshift(x)) = x but fftshift(ifftshift(x)) ≠ x\n- Preserves the total energy/sum of the array\n- Is a bijection (permutation) of array elements\n\nThe specification states that each element at position i in the result\ncomes from position (i + n/2) % n in the input, which is equivalent\nto a circular left shift by n/2 positions (or right shift by n - n/2).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn ifftshift(x: Vec<f32>) -> (result: Vec<f32>)\n    requires x.len() > 0,\n    ensures \n        result.len() == x.len(),\n        forall|i: int| 0 <= i < x.len() ==> \n            result[i] == x[((i + (x.len() as int) / 2) % (x.len() as int)) as int]", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fft_ihfft", "vc-description": "numpy.fft.ihfft: Compute the inverse FFT of a signal that has Hermitian symmetry.\n\nThis function computes the inverse FFT of a signal that has Hermitian symmetry,\nwhich means the signal is real in the frequency domain. The input should be\na complex signal with Hermitian symmetry, and the output is a real signal.\n\nThe function is analogous to rfft/irfft but for signals with Hermitian symmetry.\nAccording to the NumPy documentation and source code, it essentially computes \nthe conjugate of the rfft of the input: conjugate(rfft(a, n, axis, new_norm, out))\n\nUnlike hfft which takes a Hermitian symmetric input and produces a real output,\nihfft takes a general complex input and produces a complex output with the \ninverse Hermitian FFT properties.\n\nSpecification: ihfft computes the inverse FFT of a signal with Hermitian symmetry.\n\nAccording to NumPy documentation:\n- ihfft is analogous to rfft/irfft but for signals with Hermitian symmetry\n- The implementation is conjugate(rfft(a, n, axis, new_norm, out))\n\nKey mathematical properties:\n1. Length preservation: output has same length as input\n2. Conjugate relationship: ihfft is related to rfft by conjugation\n3. Linearity: ihfft preserves linear combinations\n4. Hermitian symmetry handling: if input has Hermitian symmetry, special properties hold", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* Complex number type for FFT operations */\n#[derive(PartialEq, Eq)]\nstruct Complex {\n    /* Real part */\n    re: int,\n    /* Imaginary part */\n    im: int,\n}\n\nimpl Complex {\n    /* Complex conjugate */\n    spec fn conj(self) -> Complex {\n        Complex { re: self.re, im: -self.im }\n    }\n\n    /* Complex addition */\n    spec fn add(self, other: Complex) -> Complex {\n        Complex { re: self.re + other.re, im: self.im + other.im }\n    }\n\n    /* Complex multiplication */\n    spec fn mul(self, other: Complex) -> Complex {\n        Complex { \n            re: self.re * other.re - self.im * other.im, \n            im: self.re * other.im + self.im * other.re \n        }\n    }\n\n    /* Check if complex number is real (imaginary part is zero) */\n    spec fn is_real(self) -> bool {\n        self.im == 0\n    }\n}\n\n/* Convert int to Complex */\nspec fn int_to_complex(x: int) -> Complex {\n    Complex { re: x, im: 0 }\n}\n\n/* Complex scaling */\nspec fn scale_complex(z: Complex, alpha: int) -> Complex {\n    Complex { re: alpha * z.re, im: alpha * z.im }\n}", "vc-helpers": "", "vc-spec": "fn ihfft(a: Vec<Complex>) -> (result: Vec<Complex>)\n    ensures\n        /* Length preservation: output has same length as input */\n        result.len() == a.len(),\n        /* Hermitian symmetry property: if input has Hermitian symmetry,\n           then ihfft should produce a real-valued result */\n        (forall|i: int, j: int| \n            0 <= i < a.len() && 0 <= j < a.len() && i + j + 1 == a.len() ==> \n                a[i] == a[j].conj()) ==>\n        (forall|i: int| 0 <= i < result.len() ==> result[i].is_real()),\n        /* Basic conjugate relationship property */\n        exists|rfft_result: Seq<Complex>|\n            rfft_result.len() == result.len() &&\n            forall|i: int| 0 <= i < result.len() ==> \n                result[i] == rfft_result[i].conj()", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fft_irfft", "vc-description": "Computes the inverse of rfft (real-valued inverse FFT).\nSpecification: irfft computes the inverse of rfft with proper length restoration.\n\nnumpy.fft.irfft computes the inverse of the one-dimensional discrete Fourier Transform for real input, \nsuch that irfft(rfft(a), len(a)) == a within numerical accuracy.\n\nParameters:\n- a: Input array (Hermitian-symmetric complex numbers)\n- n: Length of transformed axis (default calculates based on input)\n- axis: Axis to compute inverse FFT (default is last axis)\n- norm: Normalization mode (\"backward\", \"ortho\", \"forward\")\n- out: Optional output array\n\nReturns:\n- Real-valued array transformed along specified axis\n\nNotes:\n- Handles Hermitian-symmetric input from rfft\n- Requires specifying original data length to avoid information loss\n- Can resample a series via Fourier interpolation", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* Complex number type for FFT operations */\npub struct Complex {\n    /* Real part of the complex number */\n    pub re: f64,\n    /* Imaginary part of the complex number */\n    pub im: f64,\n}\n/* Helper function to check if a vector is Hermitian-symmetric */\nspec fn is_hermitian_symmetric(a: Seq<Complex>) -> bool {\n    a.len() > 0 \n}", "vc-helpers": "", "vc-spec": "fn irfft(a: Vec<Complex>, n: usize) -> (result: Vec<f64>)\n    requires \n        a.len() > 0,\n        n == 2 * (a.len() - 1),\n        is_hermitian_symmetric(a@),\n    ensures\n        /* Length preservation: output length matches specified n */\n        result.len() == n,\n        /* DC component preservation: first element is real when input DC is real */\n        a@[0].im == 0.0 ==> exists|i: int| 0 <= i < result.len() && result[i] == a@[0].re,\n        /* Hermitian input constraint: the input must be Hermitian-symmetric */\n        is_hermitian_symmetric(a@),\n        /* Length relationship: output length is twice the input length minus 2 */\n        n == 2 * (a.len() - 1),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fft_irfft2", "vc-description": "numpy.fft.irfft2: Computes the inverse of rfft2.\n\nPerforms the inverse 2-dimensional discrete Fourier Transform for real input.\nThis function converts a complex frequency domain representation back to the\nreal spatial domain. It is the inverse of rfft2.\n\nThe function takes a complex-valued 2D array (represented as nested vectors)\nand returns a real-valued 2D array. The output shape is determined by the\ninput shape and the original real signal dimensions.\n\nThis is essentially irfftn with axes=(-2, -1) as defaults.\n\nSpecification: numpy.fft.irfft2 returns the inverse 2D real FFT.\n\nPrecondition: True (input is a well-formed 2D array)\nPostcondition: The result is a real-valued 2D array with the same dimensions.\n\nKey properties:\n1. The output preserves the matrix structure and dimensions\n2. The transformation processes all elements of the input\n3. The inverse operation produces finite real values\n4. Shape preservation ensures correct 2D FFT behavior", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_irfft2(a: Vec<Vec<f32>>) -> (result: Vec<Vec<f32>>)\n    requires\n        a.len() > 0,\n        forall|i: int| 0 <= i < a.len() ==> a[i].len() > 0,\n        forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() ==> a[i].len() == a[j].len(),\n    ensures\n        /* Preserve matrix dimensions */\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == a[0].len(),\n        /* Non-trivial transformation: if input is non-zero, result depends on input */\n        (exists|i: int, j: int| 0 <= i < a.len() && 0 <= j < a[i].len() && a[i][j] != 0.0f32) ==>\n        (exists|k: int, l: int| 0 <= k < result.len() && 0 <= l < result[k].len() && result[k][l] != 0.0f32),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fft_irfftn", "vc-description": "Computes the inverse of rfftn. This function performs the inverse N-dimensional discrete Fourier Transform for real input using the Fast Fourier Transform (FFT).\n\nFor simplicity, we model this as a 1D version of irfftn, taking complex frequency domain input and producing real time-domain output. The function computes the inverse of rfftn, transforming N-dimensional frequency domain data back to real-valued time domain.\n\nThis is the inverse operation to rfftn, where the input is expected to be Hermitian-symmetric complex data representing the frequency domain, and the output is real-valued time domain data.\n\nSpecification: irfftn computes the inverse N-dimensional discrete Fourier Transform for real output.\n\nThe irfftn function is the inverse of rfftn, satisfying the property that irfftn(rfftn(x), x.shape) ≈ x within numerical accuracy.\n\nMathematical properties:\n1. Inverse relationship: irfftn(rfftn(x)) ≈ x for real input x\n2. The input should be Hermitian-symmetric to produce real output\n3. Output length is determined by the shape parameter or derived from input\n4. Energy conservation (Parseval's theorem) holds with proper normalization\n5. The transform preserves the mathematical structure of the inverse DFT\n\nThe function implements the inverse N-dimensional DFT formula:\nx[j] = (1/N) * Σ(k) a[k] * exp(2πi*k*j/N)\n\nSanity checks:\n- For DC-only input (single non-zero frequency), output is constant\n- Transform is linear: irfftn(α*a + β*b) = α*irfftn(a) + β*irfftn(b)\n- Output is real-valued when input satisfies Hermitian symmetry\n- Proper length relationship between input and output dimensions", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* Complex number type for FFT operations */\npub struct Complex {\n    /* Real part */\n    pub re: f32,\n    /* Imaginary part */\n    pub im: f32,\n}\n\nimpl Complex {\n    pub closed spec fn new(re: f32, im: f32) -> Complex {\n        Complex { re, im }\n    }\n}", "vc-helpers": "", "vc-spec": "fn irfftn(a: Vec<Complex>, n: usize) -> (result: Vec<f32>)\n    requires \n        a.len() > 0,\n        n > 0,\n        a[0].im == 0.0f32,\n    ensures\n        result.len() == n,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fft_rfft", "vc-description": "Compute the one-dimensional discrete Fourier Transform for real input.\nReturns only the non-negative frequency terms, exploiting Hermitian symmetry.\nThe output length is (n/2)+1 for even n, or (n+1)/2 for odd n.\n\nSpecification for rfft: \nThe real FFT computes the DFT of real-valued input, returning only non-negative frequency components.\n\nMathematical properties:\n1. Output contains (n/2)+1 complex values representing frequencies 0 to n/2\n2. DC component (k=0) is always real (imaginary part is 0)\n3. For even n, Nyquist frequency (k=n/2) is also real\n4. The result represents the Discrete Fourier Transform for k = 0, 1, ..., n/2\n5. Each output[k] = Σ(j=0 to n-1) input[j] * exp(-2πi*k*j/n)\n\nSanity checks:\n- For constant input signals, only the DC component is non-zero\n- The transform is linear: rfft(a + b) = rfft(a) + rfft(b)\n- Energy is preserved according to Parseval's theorem", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* Complex number type for FFT results */\n#[derive(PartialEq, Eq)]\npub struct Complex {\n    pub re: int,\n    pub im: int,\n}\n\nimpl Complex {\n    pub open spec fn zero() -> Complex {\n        Complex { re: 0, im: 0 }\n    }\n\n    pub open spec fn add(self, other: Complex) -> Complex {\n        Complex { re: self.re + other.re, im: self.im + other.im }\n    }\n\n    pub open spec fn mul(self, other: Complex) -> Complex {\n        Complex { \n            re: self.re * other.re - self.im * other.im,\n            im: self.re * other.im + self.im * other.re\n        }\n    }\n\n    pub open spec fn from_real(x: int) -> Complex {\n        Complex { re: x, im: 0 }\n    }\n}\n\npub open spec fn complex_sum(values: Seq<Complex>) -> Complex \n    decreases values.len()\n{\n    if values.len() == 0 {\n        Complex::zero()\n    } else {\n        values[0].add(complex_sum(values.skip(1)))\n    }\n}\n\npub open spec fn dft_coefficient(a: Seq<int>, k: nat, j: nat) -> Complex {\n    Complex::from_real(a[j as int])\n}\n\npub open spec fn compute_dft_sum(a: Seq<int>, k: nat, n: nat) -> Complex \n    decreases n\n{\n    if n == 0 {\n        Complex::zero()\n    } else {\n        dft_coefficient(a, k, (n - 1) as nat).add(compute_dft_sum(a, k, (n - 1) as nat))\n    }\n}\n\nspec fn vec_to_int_seq(v: Seq<i32>) -> Seq<int> \n    decreases v.len()\n{\n    if v.len() == 0 {\n        seq![]\n    } else {\n        seq![v[0] as int] + vec_to_int_seq(v.skip(1))\n    }\n}", "vc-helpers": "", "vc-spec": "fn rfft(a: Vec<i32>) -> (result: Vec<Complex>)\n    requires a.len() > 0,\n    ensures \n        result.len() == (a.len() / 2) + 1,\n        forall|k: int| 0 <= k < result.len() ==> \n            result[k] == compute_dft_sum(vec_to_int_seq(a@), k as nat, a.len() as nat),\n        result[0].im == 0,\n        a.len() % 2 == 0 ==> result[(a.len() / 2) as int].im == 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fft_rfft2", "vc-description": "Compute the 2-dimensional FFT of a real array.\n\nThis function transforms a real 2D array into the frequency domain using\na 2D Fast Fourier Transform. The transformation is performed over the\nlast two axes by default.\n\nThe key difference from fft2 is that this function starts with real input\nand exploits the Hermitian symmetry property to compute only the \nnon-negative frequency components along the last axis, making it more\nefficient for real-valued input data.\n\nOutput dimensions: For input of shape (m+1, n+1), output has shape (m+1, (n+1)/2+1)\nwhere the last dimension is reduced due to Hermitian symmetry.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* Complex number type for FFT results */\n#[derive(PartialEq, Eq)]\npub struct Complex {\n    /* Real part */\n    pub re: int,\n    /* Imaginary part */\n    pub im: int,\n}\n\nimpl Complex {\n    pub open spec fn zero() -> Complex {\n        Complex { re: 0, im: 0 }\n    }\n    \n    pub open spec fn add(self, other: Complex) -> Complex {\n        Complex { re: self.re + other.re, im: self.im + other.im }\n    }\n    \n    pub open spec fn mul(self, other: Complex) -> Complex {\n        Complex { \n            re: self.re * other.re - self.im * other.im, \n            im: self.re * other.im + self.im * other.re \n        }\n    }\n}\n\n/* Convert int to Complex */\nspec fn int_to_complex(x: int) -> Complex {\n    Complex { re: x, im: 0 }\n}", "vc-helpers": "", "vc-spec": "fn rfft2(a: Vec<Vec<int>>) -> (result: Vec<Vec<Complex>>)\n    requires \n        a.len() > 0,\n        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i].len() > 0,\n        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i].len() == a[0].len(),\n    ensures\n        result.len() == a.len(),\n        forall|k: int| 0 <= k < result.len() ==> \n            #[trigger] result[k].len() == (a[0].len() / 2) + 1,\n        /* DC component is real (imaginary part is zero) */\n        result[0][0].im == 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "fft_rfftfreq", "vc-description": "numpy.fft.rfftfreq: Return the Discrete Fourier Transform sample frequencies for rfft.\n\nThe function generates frequency bin centers in cycles per unit of sample spacing,\nwith zero at the start. This is specifically designed for use with rfft and irfft.\n\nParameters:\n- n: Window length (input size)\n- d: Sample spacing (defaults to 1.0)\n\nReturns:\n- f: Array of length n//2 + 1 containing sample frequencies\n\nThe frequency calculation follows:\n- For any n: f = [0, 1, ..., n//2] / (d*n)\n- The result length is always n//2 + 1 (for both even and odd n)\n\nSpecification: numpy.fft.rfftfreq generates frequency sample points for rfft.\n\nThe function returns a vector of frequencies from 0 to the Nyquist frequency.\n\nPrecondition: n > 0 and d > 0 (positive sample spacing)\nPostcondition: \n1. The result has length n//2 + 1\n2. The first element is always 0\n3. Each element i represents frequency i / (d * n)\n4. The last element is (n//2) / (d * n) (Nyquist frequency)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_rfftfreq(n: usize, d: int) -> (result: Vec<int>)\n    requires \n        n > 0,\n        d > 0,\n    ensures\n        result.len() == n / 2 + 1,\n        result[0] == 0,\n        forall|i: int| 0 <= i < result.len() ==> result[i] == i / (d * (n as int)),\n        result[(n / 2) as int] == (n / 2) as int / (d * (n as int)),\n        forall|i: int, j: int| 0 <= i <= j < result.len() ==> result[i] <= result[j],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "indexing_slicing_argmin", "vc-description": "numpy.argmin: Returns the index of the minimum value in a vector.\n\nReturns the index of the minimum value among all elements in the array.\nRequires a non-empty array since there is no minimum of an empty set.\n\nThis function returns the position of the smallest element in the array.\nIn case of multiple occurrences of the minimum value, the index of the\nfirst occurrence is returned.\n\nSpecification: argmin returns the index of the minimum element.\n\nPrecondition: True (non-empty constraint is in the type)\nPostcondition: The element at the returned index is the minimum value,\nand it is the first occurrence of this minimum value in the array.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn argmin(a: Vec<i32>) -> (result: usize)\n    requires a.len() > 0,\n    ensures\n        result < a.len(),\n        forall|j: int| 0 <= j < a.len() ==> a[result as int] <= a[j],\n        forall|k: int| 0 <= k < result ==> a[k] > a[result as int],", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "indexing_slicing_diagflat", "vc-description": "numpy.diagflat: Create a two-dimensional array with the flattened input as a diagonal.\n\nCreates a square matrix where the input vector is placed along the main diagonal.\nAll other elements are zero. The resulting matrix has size n×n where n is the\nlength of the input vector.\n\nFor the main diagonal (k=0), the matrix element at position (i,i) contains\nthe i-th element of the input vector.\n\nSpecification: diagflat returns a square matrix where the input vector forms the main diagonal.\n\nProperties:\n1. The result is a square n×n matrix\n2. For all i, j: if i = j then result[i][j] = v[i] (diagonal elements)\n3. For all i, j: if i ≠ j then result[i][j] = 0 (off-diagonal elements are zero)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn diagflat(v: Vec<f32>) -> (result: Vec<Vec<f32>>)\n    requires v.len() > 0,\n    ensures\n        result.len() == v.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == v.len(),\n        forall|i: int, j: int| 0 <= i < v.len() && 0 <= j < v.len() && i == j ==> result[i][j] == v[i],\n        forall|i: int, j: int| 0 <= i < v.len() && 0 <= j < v.len() && i != j ==> result[i][j] == 0.0f32,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "indexing_slicing_ogrid", "vc-description": "numpy.ogrid: Open multi-dimensional \"meshgrid\".\n\nReturns an open (i.e. not fleshed out) mesh-grid when indexed, \nso that only one dimension of each returned array is greater than 1.\n\nThis is a simplified 1D version that generates a linear sequence\nsimilar to arange but with the ogrid interface. The dimension and \nnumber of the output arrays are equal to the number of indexing dimensions.\n\nFor the 1D case, it returns a single vector with evenly spaced values\nfrom start to stop (exclusive) with the given step size.\n\nSpecification: ogrid returns a vector of evenly spaced values.\n\nPrecondition: step ≠ 0 and n = ⌊(stop - start) / step⌋\nPostcondition: The result is a vector where each element i satisfies:\n- result[i] = start + i * step\n- All elements are in the range [start, stop)\n- The sequence is arithmetic with common difference step", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn ogrid(start: i32, stop: i32, step: i32, n: usize) -> (result: Vec<i32>)\n    requires \n        step != 0,\n    ensures\n        result.len() == n,\n        forall|i: int| 0 <= i < n ==> result[i] == start + (i as i32) * step,\n        forall|i: int| 0 <= i < n ==> \n            if step > 0 { \n                start <= result[i] && result[i] < stop\n            } else {\n                stop < result[i] && result[i] <= start\n            },", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "indexing_slicing_trace", "vc-description": "Return the sum along diagonals of the array.\n\nFor a 2D matrix, computes the sum of elements along the diagonal\nwith an optional offset. For offset=0, it computes the sum of \nelements a[i,i] for all valid i. For positive offset, it sums\na[i,i+offset], and for negative offset, it sums a[i-offset,i].\n\nThis implementation focuses on the 2D case as the core functionality.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn trace(a: Vec<Vec<f32>>, offset: i32) -> (result: f32)\n    ensures true", "vc-code": "{\n    // impl-start\n    assume(false);\n    0.0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "io_operations_array_repr", "vc-description": "Return the string representation of a vector, formatted as \"array([v1, v2, ..., vn])\".\nThis provides a structured string representation that includes the \"array()\" wrapper\nand properly formatted element values.\n\nSpecification: array_repr returns a well-formatted string representation of the vector.\n\nThe specification captures:\n1. Basic format: the string starts with \"array(\" and ends with \")\"\n2. Element representation: each element is formatted as a string\n3. Proper bracketing: elements are enclosed in square brackets\n4. Separator consistency: elements are separated by commas and spaces\n5. Precision handling: floating point numbers are formatted to specified precision\n6. Small number suppression: very small numbers can be represented as zero\n7. Non-emptiness: the result is always a non-empty string\n8. Structural integrity: the string format is parseable and well-formed", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn array_repr(arr: Vec<f32>, max_line_width: usize, precision: usize, suppress_small: bool) -> (result: String)\n    requires \n        precision > 0,\n        max_line_width > 0,\n    ensures\n        /* Non-empty result: string representation is always non-empty */\n        result@.len() > 0,\n        /* Precision constraint: reasonable string length bounds */\n        result@.len() <= max_line_width + 20,\n        /* Basic format constraints - minimum length for valid array representation */\n        result@.len() >= 9,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "io_operations_fromregex", "vc-description": "Construct an array from a text file using regular expression parsing\n\nConstruct a structured array from a text file using regular expression parsing\n\nSpecification: fromregex constructs a structured array from regex matches in file content", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* A simple abstraction for regular expressions */\nstruct RegExp {\n    /* The regular expression pattern */\n    pattern: String,\n}\n\n/* A simple abstraction for structured data types */\nstruct StructuredDataType {\n    /* List of field names and their types */\n    fields: Vec<(String, String)>,\n}\n\n/* A simple abstraction for structured array elements */\nstruct StructuredElement {\n    /* List of field values as strings */\n    values: Vec<String>,\n}", "vc-helpers": "", "vc-spec": "fn fromregex(file_content: Vec<u8>, regexp: RegExp, dtype: StructuredDataType) -> (result: Vec<StructuredElement>)\n    requires dtype.fields.len() > 0,\n    ensures\n        forall|i: int| 0 <= i < result.len() ==> result[i].values.len() == dtype.fields.len(),\n        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result.len() ==> \n            result[i].values.len() == result[j].values.len(),\n        result.len() > 0 ==> file_content.len() > 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "io_operations_get_printoptions", "vc-description": "numpy.get_printoptions: Return the current print options\n\nReturns a structure containing the current print options that control\nhow arrays are formatted when displayed. These options include precision\nfor floating point numbers, threshold for array summarization, and\nvarious string representations.\n\nThis function reads the current state of NumPy's print formatting system.\n\nSpecification: get_printoptions returns a valid PrintOptions structure\nwith sensible default values.\n\nPrecondition: True (no special preconditions)\nPostcondition: Result contains valid print options with proper constraints", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "/* Structure representing NumPy print options */\nstruct PrintOptions {\n    /* Number of digits of precision for floating point output */\n    precision: nat,\n    /* Total number of array elements which trigger summarization */\n    threshold: nat,\n    /* Number of array items in summary at beginning and end */\n    edgeitems: nat,\n    /* Number of characters per line for line breaks */\n    linewidth: nat,\n    /* Whether to suppress small floating point values */\n    suppress: bool,\n    /* String representation of floating point not-a-number */\n    nanstr: Seq<char>,\n    /* String representation of floating point infinity */\n    infstr: Seq<char>,\n    /* Controls printing of the sign of floating-point types */\n    sign: Seq<char>,\n    /* Controls interpretation of precision option */\n    floatmode: Seq<char>,\n    /* Legacy printing mode setting */\n    legacy: Option<Seq<char>>,\n}\n\nfn get_printoptions() -> (result: PrintOptions)\n    ensures\n        result.precision > 0,\n        result.threshold > 0,\n        result.edgeitems > 0,\n        result.linewidth > 0,\n        result.nanstr.len() > 0,\n        result.infstr.len() > 0,\n        (result.sign == seq!['-'] || result.sign == seq!['+'] || result.sign == seq![' ']),\n        (result.floatmode == seq!['f','i','x','e','d'] ||\n         result.floatmode == seq!['u','n','i','q','u','e'] ||\n         result.floatmode == seq!['m','a','x','p','r','e','c'] ||\n         result.floatmode == seq!['m','a','x','p','r','e','c','_','e','q','u','a','l'])", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "io_operations_memmap", "vc-description": "numpy.memmap: Create a memory-map to an array stored in a binary file on disk.\n\nMemory-mapped files are used for accessing small segments of large files\non disk, without reading the entire file into memory. The memmap provides\nan array-like interface to the file contents.\n\nThis function creates a Vector view into a binary file on disk with the\nspecified shape and access mode. The file is accessed starting at the\ngiven offset.\n\nSpecification: numpy.memmap creates a memory-mapped view of a file.\n\nThis specification captures the essential properties of memory mapping:\n1. The result is a valid vector of the specified size\n2. The mapping respects the file access mode constraints\n3. The offset is within valid bounds for the file\n4. Read-only modes preserve data integrity\n5. Write modes allow modification of the underlying file\n\nPreconditions:\n- The filename represents a valid file path\n- The offset is non-negative and within the file bounds\n- For WriteNew mode, the file will be created if it doesn't exist\n- For ReadOnly mode, the file must exist and be readable\n\nPostconditions:\n- Returns a vector of the specified size n\n- The vector provides a view into the file starting at the given offset\n- Read operations reflect the file contents at the mapped region\n- Write operations (when mode allows) modify the underlying file\n- The mapping preserves the mathematical properties of array access", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* A simplified representation of file access mode for memory mapping */\n#[derive(PartialEq, Eq)]\nenum FileMode {\n    /* ReadOnly mode ('r') - read-only access to existing file */\n    ReadOnly,\n    /* ReadWrite mode ('r+') - read-write access to existing file */\n    ReadWrite,\n    /* WriteNew mode ('w+') - create new file with read-write access */\n    WriteNew,\n    /* CopyOnWrite mode ('c') - copy-on-write access, changes don't persist to disk */\n    CopyOnWrite,\n}", "vc-helpers": "", "vc-spec": "fn memmap(filename_valid: bool, mode: FileMode, offset: usize, n: usize) -> (result: Vec<f32>)\n    requires \n        filename_valid,\n    ensures\n        result.len() == n,\n        forall|i: int| 0 <= i < n ==> #[trigger] result[i] == result[i],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "io_operations_printoptions", "vc-description": "numpy.printoptions: Context manager for setting print options.\n\nCreates a context manager that temporarily sets print options and restores\nthe original options afterward. This allows for local formatting changes\nwithout affecting global state.\n\nThe context manager returns the current print options that are active\nwithin the context.\n\nSpecification: numpy.printoptions creates a context with temporary print options.\n\nPrecondition: Valid print options are provided\nPostcondition: Returns a context that contains both old and new options,\n               where the new options are the ones that would be active\n               within the context", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* Print options structure to represent configuration */\nstruct PrintOptions {\n    /* Number of digits of precision for floating point output */\n    precision: usize,\n    /* Total number of array elements which trigger summarization */\n    threshold: usize,\n    /* Number of array items in summary at beginning and end */\n    edgeitems: usize,\n    /* Number of characters per line for inserting line breaks */\n    linewidth: usize,\n    /* Whether to suppress small floating point values */\n    suppress: bool,\n    /* String representation of floating point NaN */\n    nanstr: String,\n    /* String representation of floating point infinity */\n    infstr: String,\n}\n\n/* Context manager result representing the temporary state change */\nstruct PrintOptionsContext {\n    /* The original print options before the context change */\n    old_options: PrintOptions,\n    /* The new print options active within the context */\n    new_options: PrintOptions,\n}", "vc-helpers": "", "vc-spec": "fn numpy_printoptions(new_opts: PrintOptions) -> (context: PrintOptionsContext)\n    ensures \n        context.new_options == new_opts,\n        context.old_options != context.new_options,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "io_operations_savez_compressed", "vc-description": "Save several arrays into a single file in compressed .npz format.\n\nThis function saves multiple arrays to a compressed archive file.\nArrays are stored with either provided names or automatic names (arr_0, arr_1, etc.).\nThe resulting file can be loaded back using numpy.load.\n\nSpecification: savez_compressed saves arrays to a compressed archive file.\n\nThe function should:\n1. Create a compressed .npz file at the specified path\n2. Store each array in the archive with proper naming\n3. Ensure the file is readable by compatible loading functions\n4. Handle filename extension automatically (.npz appended if not present)", "vc-preamble": "use vstd::prelude::*;\nuse vstd::string::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn savez_compressed(filename: &str, arrays: &Vec<Vec<f32>>) -> (result: ())\n    requires \n        filename@.len() > 0,\n        arrays.len() > 0,\n    ensures\n        /* File creation and data preservation properties are ensured */\n        true", "vc-code": "{\n    // impl-start\n    assume(false);\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "io_operations_set_printoptions", "vc-description": "numpy.set_printoptions: Set printing options for NumPy arrays\n\nSets the global printing options that control how floating point numbers,\narrays and other NumPy objects are displayed. This function modifies the\nglobal state of NumPy's print formatting system.\n\nAll parameters are optional and only modify the corresponding option if\nprovided. Options not specified retain their current values.\n\nSpecification: set_printoptions correctly updates the global print options\naccording to the provided parameters while validating input constraints.\n\nPrecondition: All optional parameters must satisfy their validation constraints\nPostcondition: The global print state is updated with the provided options", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* Structure representing NumPy print options */\nstruct PrintOptions {\n    /* Number of digits of precision for floating point output */\n    precision: nat,\n    /* Total number of array elements which trigger summarization */\n    threshold: nat,\n    /* Number of array items in summary at beginning and end */\n    edgeitems: nat,\n    /* Number of characters per line for line breaks */\n    linewidth: nat,\n    /* Whether to suppress small floating point values */\n    suppress: bool,\n    /* String representation of floating point not-a-number */\n    nanstr: String,\n    /* String representation of floating point infinity */\n    infstr: String,\n    /* Controls printing of the sign of floating-point types */\n    sign: String,\n    /* Controls interpretation of precision option */\n    floatmode: String,\n    /* Legacy printing mode setting */\n    legacy: Option<String>,\n}", "vc-helpers": "", "vc-spec": "fn set_printoptions(\n    precision: Option<nat>,\n    threshold: Option<nat>,\n    edgeitems: Option<nat>,\n    linewidth: Option<nat>,\n    suppress: Option<bool>,\n    nanstr: Option<String>,\n    infstr: Option<String>,\n    sign: Option<String>,\n    floatmode: Option<String>,\n    legacy: Option<String>\n) -> (result: ())\n    requires\n        forall|p: nat| precision == Some(p) ==> p > 0,\n        forall|t: nat| threshold == Some(t) ==> t > 0,\n        forall|e: nat| edgeitems == Some(e) ==> e > 0,\n        forall|l: nat| linewidth == Some(l) ==> l > 0,\n        forall|n: String| nanstr == Some(n) ==> n@.len() > 0,\n        forall|i: String| infstr == Some(i) ==> i@.len() > 0,\n        forall|s: String| sign == Some(s) ==> (s@.len() == 1 && (s@ == seq!['-'] || s@ == seq!['+'] || s@ == seq![' '])),\n        forall|f: String| floatmode == Some(f) ==> \n            (f@ == seq!['f','i','x','e','d'] || f@ == seq!['u','n','i','q','u','e'] || f@ == seq!['m','a','x','p','r','e','c'] || f@ == seq!['m','a','x','p','r','e','c','_','e','q','u','a','l']),\n        forall|l: String| legacy == Some(l) ==> \n            (l@ == seq!['1','.','1','3'] || l@ == seq!['1','.','2','1'] || l@ == seq!['1','.','2','5'] || l@ == seq!['2','.','1'] || l@ == seq!['2','.','2']),\n    ensures result == ()", "vc-code": "{\n    // impl-start\n    assume(false);\n    ()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "linalg_cond", "vc-description": "Compute the condition number of a matrix.\n\nThe condition number measures how sensitive the solution x is to errors in b for Ax=b.\n\nParameters:\n- x: The matrix\n- p: Order of the norm\n\nReturns:\n- c: The condition number\n\nCompute the condition number of a square matrix using the 2-norm.\n\nThe condition number of a matrix A is defined as ||A|| * ||A^(-1)||,\nwhere ||.|| is the matrix norm. For the 2-norm, this equals the ratio\nof the largest singular value to the smallest singular value.\n\nThe condition number measures how sensitive the solution x is to errors \nin b for the linear system Ax = b. A condition number of 1 indicates\na perfectly conditioned matrix, while large condition numbers indicate\nill-conditioned matrices.\n\nSpecification: The condition number is always non-negative and is at least 1 \nfor any invertible matrix. This captures the fundamental mathematical \nproperties of condition numbers in linear algebra.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn condition_number(x: Vec<Vec<i32>>) -> (result: i32)\n    requires \n        x.len() > 0,\n        forall|i: int| 0 <= i < x.len() ==> x[i].len() == x.len(),\n    ensures \n        result >= 0,\n        result >= 1,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "linalg_cross", "vc-description": "numpy.linalg.cross: Return the cross product of 3-element vectors.\n\nComputes the cross product of two 3-element vectors. The cross product\nof two vectors a and b is a vector perpendicular to both a and b.\n\nFor 3D vectors a = [a₀, a₁, a₂] and b = [b₀, b₁, b₂], the cross product\nis defined as:\na × b = [a₁b₂ - a₂b₁, a₂b₀ - a₀b₂, a₀b₁ - a₁b₀]\n\nThis follows the right-hand rule convention.\n\nSpecification: numpy.linalg.cross returns the cross product of two 3D vectors.\n\nPrecondition: True (both vectors must be 3-dimensional, enforced by type)\n\nPostcondition: The result is a 3D vector where:\n- result[0] = x1[1] * x2[2] - x1[2] * x2[1]\n- result[1] = x1[2] * x2[0] - x1[0] * x2[2]  \n- result[2] = x1[0] * x2[1] - x1[1] * x2[0]\n\nThe cross product has the mathematical property that it is perpendicular\nto both input vectors (i.e., result · x1 = 0 and result · x2 = 0).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_linalg_cross(x1: [i32; 3], x2: [i32; 3]) -> (result: [i32; 3])\n    ensures\n        result[0] == x1[1] * x2[2] - x1[2] * x2[1],\n        result[1] == x1[2] * x2[0] - x1[0] * x2[2],\n        result[2] == x1[0] * x2[1] - x1[1] * x2[0]", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "linalg_det", "vc-description": "Compute the determinant of a square matrix. The determinant satisfies fundamental mathematical properties including explicit formulas for small matrices, multilinear properties, and behavior under elementary row operations.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn det(a: Vec<Vec<i32>>) -> (result: i32)\n    requires \n        a.len() > 0,\n        forall|i: int| 0 <= i < a.len() ==> a[i].len() == a.len(),\n    ensures\n        /* For 1x1 matrices, the determinant is the single element */\n        a.len() == 1 ==> result == a[0][0],\n        /* For 2x2 matrices, the determinant is ad - bc */\n        a.len() == 2 ==> result == a[0][0] * a[1][1] - a[0][1] * a[1][0],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "linalg_eigvals", "vc-description": "Compute the eigenvalues of a general square matrix\n\nSpecification: eigvals computes eigenvalues of a square matrix", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n/* Complex number type for eigenvalues */\nstruct Complex {\n    re: f64,\n    im: f64,\n}\n\n/* Matrix represented as a vector of vectors (rows) */\ntype Matrix<T> = Vec<Vec<T>>;", "vc-helpers": "", "vc-spec": "fn eigvals(a: &Matrix<f64>) -> (result: Vec<Complex>)\n    requires \n        a.len() > 0,\n        forall|i: int| 0 <= i < a.len() ==> a[i].len() == a.len(),\n    ensures\n        result.len() == a.len()", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "linalg_eigvalsh", "vc-description": "Compute the eigenvalues of a complex Hermitian or real symmetric matrix\n\nCompute the eigenvalues of a real symmetric matrix.\nReturns eigenvalues in ascending order without computing eigenvectors.\nThis is the eigenvalues-only version of the symmetric eigenvalue problem.\n\nSpecification: eigvalsh computes eigenvalues of a real symmetric matrix.\n\nThe eigenvalues are real (since the matrix is symmetric) and returned in ascending order.\nKey mathematical properties:\n1. The eigenvalues are real for symmetric matrices\n2. They are returned in ascending order\n3. The trace equals the sum of eigenvalues\n4. The determinant equals the product of eigenvalues\n5. For the identity matrix, all eigenvalues are 1\n6. For diagonal matrices, eigenvalues are the diagonal elements (sorted)\n7. Matrix symmetry: a[i][j] = a[j][i] for all i,j", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn eigvalsh(a: Vec<Vec<i32>>) -> (eigenvals: Vec<i32>)\n    requires\n        a.len() > 0,\n        forall|i: int| 0 <= i < a.len() ==> a[i].len() == a.len(),\n        forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() ==> a[i][j] == a[j][i],\n    ensures\n        eigenvals.len() == a.len(),\n        /* Eigenvalues are in ascending order */\n        forall|i: int, j: int| 0 <= i < j < eigenvals.len() ==> eigenvals[i] <= eigenvals[j],\n        /* Identity matrix has all eigenvalues equal to 1 */\n        (forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() ==> \n            a[i][j] == (if i == j { 1int } else { 0int })) ==> \n            (forall|i: int| 0 <= i < eigenvals.len() ==> eigenvals[i] == 1int),\n        /* Zero matrix has all eigenvalues equal to 0 */\n        (forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() ==> a[i][j] == 0int) ==> \n            (forall|i: int| 0 <= i < eigenvals.len() ==> eigenvals[i] == 0int)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "linalg_lstsq", "vc-description": "Return the least-squares solution to a linear matrix equation.\n\nSolves the equation a @ x = b by minimizing ||b - ax||^2.\n\nParameters:\n- a: Coefficient matrix (M, N)\n- b: Ordinate values (M,) or (M, K)\n- rcond: Cut-off ratio for small singular values\n\nReturns tuple of:\n- x: Least-squares solution\n- residuals: Sums of squared residuals\n- rank: Rank of matrix a\n- s: Singular values of a", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn lstsq(a: Vec<Vec<f32>>, b: Vec<f32>) -> (result: Vec<f32>)\n    requires \n        a.len() > 0,\n        b.len() > 0,\n        a.len() == b.len(),\n        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i].len() > 0,\n        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i].len() == a[0].len(),\n    ensures\n        result.len() == a[0].len()", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "linalg_matrix_norm", "vc-description": "Compute matrix norm of a matrix (Frobenius norm by default)\n\nSpecification: matrix_norm computes the Frobenius norm of a matrix \nThe Frobenius norm is the square root of the sum of squares of all elements.\n\nProperties:\n1. Non-negativity: norm is always ≥ 0\n2. Zero property: norm is 0 iff all elements are 0\n3. Homogeneity: norm(c*A) = |c| * norm(A) for scalar c\n4. Triangle inequality: norm(A + B) ≤ norm(A) + norm(B)\n5. Submultiplicativity: norm(A) dominates the absolute value of any element", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn abs_val(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}", "vc-helpers": "", "vc-spec": "fn matrix_norm(x: Vec<Vec<i32>>) -> (result: i32)\n    requires \n        x.len() > 0,\n        forall|i: int| 0 <= i < x.len() ==> #[trigger] x[i].len() > 0,\n        forall|i: int| 0 <= i < x.len() ==> #[trigger] x[i].len() == x[0].len(),\n    ensures\n        result >= 0,\n        (result == 0) == (forall|i: int, j: int| \n            0 <= i < x.len() && 0 <= j < x[i].len() ==> #[trigger] x[i][j] == 0),\n        forall|i: int, j: int| \n            0 <= i < x.len() && 0 <= j < x[i].len() ==> abs_val(#[trigger] x[i][j] as int) <= result,\n        (exists|i: int, j: int| \n            0 <= i < x.len() && 0 <= j < x[i].len() && #[trigger] x[i][j] != 0) ==> result > 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    0i32\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "linalg_pinv", "vc-description": "numpy.linalg.pinv: Compute the (Moore-Penrose) pseudo-inverse of a matrix.\n\nCalculate the generalized inverse of a matrix using its\nsingular-value decomposition (SVD) and including all\nlarge singular values.\n\nFor a matrix A, the pseudo-inverse A+ is defined as the matrix that\n'solves' the least-squares problem Ax = b. If A is invertible,\nthen pinv(A) == inv(A).\n\nThe pseudo-inverse has the property that A * A+ * A = A and\nA+ * A * A+ = A+ (Moore-Penrose conditions).\n\nSpecification: pinv computes the Moore-Penrose pseudo-inverse of a matrix.\n\nThe pseudo-inverse satisfies the fundamental Moore-Penrose conditions:\n1. A * A+ * A = A  (the pseudo-inverse is a generalized inverse)\n2. A+ * A * A+ = A+  (the pseudo-inverse is reflexive)\n3. (A * A+)† = A * A+  (A * A+ is Hermitian)\n4. (A+ * A)† = A+ * A  (A+ * A is Hermitian)\n\nFor practical purposes, we focus on the first two conditions and\nthe dimensional correctness.\n\nPrecondition: True (pinv is defined for any matrix)\nPostcondition: The result is the pseudo-inverse with correct dimensions\nand satisfies the Moore-Penrose conditions.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn pinv(a: Vec<Vec<f32>>) -> (result: Vec<Vec<f32>>)\n    requires \n        a.len() > 0,\n        forall|i: int| 0 <= i < a.len() ==> a[i].len() > 0,\n    ensures \n        result.len() > 0,\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == a.len(),\n        (forall|i: int, j: int| (0 <= i < a.len() && 0 <= j < a[i].len()) ==> a[i][j] == 0.0f32) ==> \n            (forall|i: int, j: int| (0 <= i < result.len() && 0 <= j < result[i].len()) ==> result[i][j] == 0.0f32)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "linalg_solve", "vc-description": "Solve a linear matrix equation ax = b, where a is an n×n matrix and b is a vector.\nReturns the solution vector x such that ax = b.\nFor non-empty matrices (n > 0), the solution exists and is unique when a is invertible.\n\nSpecification: solve returns a vector x such that ax = b when a is invertible.\nThis specification captures the mathematical properties of linear system solving:\n\n1. **Correctness**: The solution satisfies the matrix equation ax = b\n2. **Invertibility requirement**: Matrix a must be invertible (non-singular)\n3. **Uniqueness**: The solution is unique when it exists\n4. **Mathematical consistency**: The solution preserves linear algebra properties\n\nThe specification handles the general case where:\n- a is an n×n square matrix (represented as Vector of Vector Float)\n- b is an n-dimensional vector\n- The solution x is unique when a is invertible", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve(a: Vec<Vec<f64>>, b: Vec<f64>) -> (result: Vec<f64>)\n    requires \n        a.len() > 0,\n        a.len() == b.len(),\n        forall|i: int| 0 <= i < a.len() ==> a[i].len() == a.len(),\n        /* Matrix a is invertible - there exists an inverse matrix a_inv such that a * a_inv = I and a_inv * a = I */\n        exists|a_inv: Seq<Seq<f64>>| \n            a_inv.len() == a.len() &&\n            forall|k: int| 0 <= k < a_inv.len() ==> a_inv[k].len() == a.len(),\n    ensures\n        result.len() == a.len(),\n        /* Primary property: The solution satisfies ax = b */\n        /* For each row i, the sum of products a[i][j] * result[j] equals b[i] */\n        true, /* Placeholder for matrix equation ax = b */\n        /* Uniqueness: The solution is unique */\n        /* If any other vector y also satisfies ay = b, then y = result */\n        true, /* Placeholder for uniqueness property */\n        /* Mathematical consistency: The solution can be expressed as x = a^(-1)b */\n        true /* Placeholder for inverse relationship */", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "linalg_svd", "vc-description": "numpy.linalg.svd: Singular Value Decomposition.\n\nComputes the singular value decomposition of a matrix, factorizing it as\nA = U @ diag(S) @ Vh, where U and Vh are unitary matrices and S is a \nvector of singular values sorted in descending order.\n\nThis specification focuses on the 2D case with full_matrices=False\nand compute_uv=True (the most common use case).\n\nThe decomposition satisfies: A = U @ diag(S) @ Vh\nwhere U has orthonormal columns, Vh has orthonormal rows,\nand S contains non-negative singular values in descending order.\n\nSpecification: numpy.linalg.svd returns matrices U, S, Vh such that:\n\n1. Matrix reconstruction: A = U @ diag(S) @ Vh\n2. U has orthonormal columns (U^T @ U = I)\n3. Vh has orthonormal rows (Vh @ Vh^T = I)  \n4. S contains non-negative singular values in descending order\n\nThis captures the essential mathematical properties of SVD as implemented in NumPy.\n\nPrecondition: True (SVD is defined for any real matrix)\nPostcondition: The returned decomposition satisfies all SVD properties", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_svd(a: Vec<Vec<f32>>) -> (result: (Vec<Vec<f32>>, Vec<f32>, Vec<Vec<f32>>))\n    requires\n        a.len() > 0,\n        forall|i: int| 0 <= i < a.len() ==> a[i].len() > 0,\n        forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() ==> a[i].len() == a[j].len(),\n    ensures\n        ({\n            let (u, s, vh) = result;\n            let m = a.len() as int;\n            let n = a[0].len() as int;\n            let min_mn = if m <= n { m } else { n };\n            \n            /* Basic structural properties */\n            (u.len() == m) &&\n            (s.len() == min_mn) &&\n            (vh.len() == min_mn) &&\n            (forall|i: int| 0 <= i < u.len() ==> u[i].len() == min_mn) &&\n            (forall|i: int| 0 <= i < vh.len() ==> vh[i].len() == n)\n        })", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "linalg_svdvals", "vc-description": "numpy.linalg.svdvals: Compute singular values of a matrix.\n\nComputes the singular values of a matrix without computing the U and V matrices.\nThe singular values are the square roots of the eigenvalues of A^T @ A (or A @ A^T),\nreturned in descending order.\n\nThis is equivalent to calling numpy.linalg.svd(x, compute_uv=False).\nFor an m×n matrix, this returns min(m,n) singular values.\n\nSpecification: svdvals returns the singular values of the input matrix.\n\nThe singular values are:\n1. Non-negative real numbers\n2. Sorted in descending order\n3. Square roots of eigenvalues of x^T @ x\n4. Measure the \"magnitude\" of the matrix in each singular direction\n\nPrecondition: True (singular values are defined for any matrix)\nPostcondition: Returns singular values in descending order with mathematical properties", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn min_nat(a: nat, b: nat) -> nat {\n    if a <= b { a } else { b }\n}\n\nfn svdvals(x: Vec<Vec<i32>>) -> (result: Vec<i32>)\n    requires \n        x.len() > 0,\n        x.len() < usize::MAX,\n        x[0].len() > 0,\n    ensures \n        result.len() == min_nat(x.len() as nat, x[0].len() as nat),\n        /* Property 1: All singular values are non-negative */\n        forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i] >= 0,\n        /* Property 2: Singular values are sorted in descending order */\n        forall|i: int, j: int| 0 <= i <= j < result.len() ==> #[trigger] result[i] >= #[trigger] result[j],\n        /* Property 4: If the matrix is zero, all singular values are zero */\n        (forall|i: int, j: int| 0 <= i < x.len() && 0 <= j < x[i].len() ==> #[trigger] x[i][j] == 0) ==>\n            (forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i] == 0)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "linalg_trace", "vc-description": "Return the sum along diagonals of the array\n\nIf a is 2-D, returns the sum along the diagonal. If a has more dimensions, then axes along which the trace is taken can be specified.\n\nReturns the sum along the main diagonal of a square matrix.\nThe trace is the sum of diagonal elements at positions (i, i) for i = 0 to n-1.\n\nSpecification: trace computes the sum of the main diagonal elements of a square matrix.\nThe trace is mathematically defined as the sum of elements x[i][i] for i from 0 to n-1.\nThis is a fundamental operation in linear algebra with important mathematical properties:\n- trace(A + B) = trace(A) + trace(B) (linearity)\n- trace(cA) = c * trace(A) (scalar multiplication)\n- trace(A) = trace(A^T) (transpose invariance)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn trace(x: Vec<Vec<f32>>) -> (result: f32)\n    requires \n        x.len() > 0,\n        forall|i: int| 0 <= i < x.len() ==> x[i].len() == x.len(),\n    ensures \n        true, /* The trace equals the sum of diagonal elements matrix[i][i] for i in 0..n-1 */\n        forall|i: int| 0 <= i < x.len() ==> x[i][i] != 0.0f32 ==> result != 0.0f32,", "vc-code": "{\n    // impl-start\n    assume(false);\n    0.0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "logic_functions_greater", "vc-description": "numpy.greater: Return the truth value of (x1 > x2) element-wise.\n\nReturns a boolean vector where each element indicates whether the\ncorresponding element in x1 is greater than the corresponding element in x2.\n\nThis is equivalent to x1 > x2 in terms of array broadcasting.\n\nFollows IEEE 754 standard for floating point comparisons:\n- Comparisons with NaN always return false\n- Returns boolean array of same shape as inputs\n\nSpecification: numpy.greater returns a boolean vector where each element\nis true if and only if the corresponding element in x1 is greater than\nthe corresponding element in x2.\n\nThis specification captures:\n1. Basic element-wise comparison semantics\n2. Antisymmetry property of greater-than relation\n3. Transitivity when combined with other comparisons\n4. IEEE 754 compliant NaN handling\n5. Consistency with standard mathematical ordering", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_greater(x1: &Vec<i32>, x2: &Vec<i32>) -> (result: Vec<bool>)\n    requires x1.len() == x2.len(),\n    ensures \n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> \n            (result[i] == (x1[i] > x2[i])) &&\n            (result[i] == true ==> !(x2[i] > x1[i])) &&\n            (result[i] == true || result[i] == false)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "logic_functions_isclose", "vc-description": "Returns a boolean array where two arrays are element-wise equal within a tolerance.\nFor finite values, isclose uses the equation: absolute(a - b) <= (atol + rtol * absolute(b))\nwhere `b` is treated as the reference value.\n\nSpecification: isclose returns a boolean array indicating element-wise closeness within tolerance", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn isclose(a: Vec<f32>, b: Vec<f32>, rtol: f32, atol: f32, equal_nan: bool) -> (result: Vec<bool>)\n    requires \n        a.len() == b.len(),\n    ensures\n        result.len() == a.len(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "logic_functions_iscomplexobj", "vc-description": "Check for a complex type or an array of complex numbers\n\nThe type of the input is checked, not the value. Even if the input\nhas an imaginary part equal to zero, iscomplexobj evaluates to True.\n\nParameters\n----------\nx : any\n    The input can be of any type and shape.\n\nReturns\n-------\niscomplexobj : bool\n    The return value, True if x is of a complex type or has at least\n    one complex element.\n\nCheck if a vector contains complex numbers\n\nSpecification: iscomplexobj returns True for complex type vectors.\nThis function checks the type, not the values - even complex numbers\nwith zero imaginary part are considered complex objects.\n\nKey properties:\n- Always returns true for vectors of complex numbers\n- Type-based checking: independent of actual values\n- Zero complex numbers (0+0i) are still complex objects\n- Complex vectors with any values are complex objects\n\nMathematical properties:\n- Type consistency: all Complex vectors are complex objects\n- Value independence: result depends only on type, not values\n- Idempotent: checking complex vectors always yields true", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* Complex number with real and imaginary parts */\n#[derive(PartialEq, Structural)]\npub struct Complex {\n    pub re: i32,\n    pub im: i32,\n}", "vc-helpers": "", "vc-spec": "fn iscomplexobj(x: Vec<Complex>) -> (result: bool)\n    ensures \n        result == true", "vc-code": "{\n    // impl-start\n    assume(false);\n    true\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "logic_functions_isfinite", "vc-description": "Test element-wise for finiteness (not infinity and not NaN)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn is_finite_f32(x: f32) -> bool;\nspec fn is_infinite_f32(x: f32) -> bool;\nspec fn is_nan_f32(x: f32) -> bool;", "vc-helpers": "", "vc-spec": "fn isfinite(x: Vec<f32>) -> (result: Vec<bool>)\n    requires x.len() > 0,\n    ensures \n        result.len() == x.len(),\n        forall|i: int| 0 <= i < x.len() ==> {\n            &&& (result[i] == (!is_infinite_f32(x[i]) && !is_nan_f32(x[i])))\n            &&& (result[i] == true <==> is_finite_f32(x[i]))\n            &&& (result[i] == false <==> (is_nan_f32(x[i]) || is_infinite_f32(x[i])))\n            &&& (x[i] == 0.0f32 ==> result[i] == true)\n            &&& (result[i] == false ==> (is_nan_f32(x[i]) || is_infinite_f32(x[i])))\n            &&& (result[i] == true ==> !is_nan_f32(x[i]) && !is_infinite_f32(x[i]))\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "logic_functions_isposinf", "vc-description": "Test element-wise for positive infinity, return result as bool array.\n\nThis function tests each element according to IEEE 754 floating-point standard:\n- Returns true if the element is positive infinity (+∞)\n- Returns false for all other values including negative infinity, NaN, finite numbers, and zero\n\nMathematical properties:\n1. Positive infinity detection: result[i] = true iff x[i] is positive infinity\n2. Distinction from negative infinity: only positive infinity returns true\n3. Distinction from NaN: positive infinity and NaN are mutually exclusive\n4. Result preserves shape: output vector has same length as input\n5. Finite values: All normal, subnormal, and zero values return false", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_pos_inf(x: i32) -> bool {\n    x == 0x7f800000i32\n}\n\nspec fn is_neg_inf(x: i32) -> bool {\n    x == 0xff800000u32 as i32\n}\n\nspec fn is_nan(x: i32) -> bool {\n    (x & 0x7f800000i32) == 0x7f800000i32 && (x & 0x7fffffi32) != 0\n}\n\nspec fn is_finite(x: i32) -> bool {\n    (x & 0x7f800000i32) != 0x7f800000i32\n}\n\nfn isposinf(x: Vec<i32>) -> (result: Vec<bool>)\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < x.len() ==> {\n            /* Primary property: result is true iff input is positive infinity */\n            result[i] == is_pos_inf(x[i]) &&\n            /* Sanity checks: finite values return false */\n            (is_finite(x[i]) ==> result[i] == false) &&\n            /* Negative infinity returns false */\n            (is_neg_inf(x[i]) ==> result[i] == false) &&\n            /* NaN is not positive infinity */\n            (is_nan(x[i]) ==> result[i] == false) &&\n            /* Zero is not positive infinity */\n            (x[i] == 0 ==> result[i] == false) &&\n            /* Mathematical property: if result is true, then x is positive infinity */\n            (result[i] == true ==> is_pos_inf(x[i])) &&\n            /* Exclusivity: cannot be both positive infinity and NaN */\n            (result[i] == true ==> !is_nan(x[i]))\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "logic_functions_less_equal", "vc-description": "Return the truth value of (x1 <= x2) element-wise\n\nSpecification: less_equal returns element-wise comparison x1[i] <= x2[i] with mathematical properties", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn less_equal(x1: Vec<i32>, x2: Vec<i32>) -> (result: Vec<bool>)\n    requires x1.len() == x2.len(),\n    ensures \n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < x1.len() ==> result[i] == (x1[i] <= x2[i]),\n        forall|i: int| 0 <= i < x1.len() ==> (result[i] == true <==> x1[i] <= x2[i]),\n        forall|i: int| 0 <= i < x1.len() ==> (result[i] == false <==> x1[i] > x2[i]),\n        forall|i: int| 0 <= i < x1.len() ==> (x1[i] == x2[i] ==> result[i] == true),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "mathematical_functions_absolute", "vc-description": "Calculate the absolute value element-wise for a vector of integers.\n\nSpecification: absolute computes the absolute value of each element with the following mathematical properties:\n1. Basic definition: |x| = x if x ≥ 0, otherwise -x\n2. Non-negativity: |x| ≥ 0 for all x\n3. Zero preservation: |x| = 0 if and only if x = 0\n4. Idempotence: ||x|| = |x|\n5. Multiplicativity: |x * y| = |x| * |y|", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn abs_spec(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\nfn absolute(x: Vec<i32>) -> (result: Vec<i32>)\n    ensures \n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == abs_spec(x[i] as int),\n        forall|i: int| 0 <= i < result.len() ==> result[i] >= 0,\n        forall|i: int| 0 <= i < result.len() ==> (result[i] == 0 <==> x[i] == 0)", "vc-code": "{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "mathematical_functions_add", "vc-description": "numpy.add: Add arguments element-wise.\n\nAdds two vectors element-wise. If the vectors have the same shape,\neach element of the result is the sum of the corresponding elements\nfrom the input vectors.\n\nThis is equivalent to x1 + x2 in terms of array broadcasting.\nThe function supports all numeric types and handles overflow according\nto the IEEE 754 standard for floating-point arithmetic.\n\nFrom NumPy documentation:\n- Parameters: x1, x2 (array_like) - The arrays to be added\n- Returns: add (ndarray) - The sum of x1 and x2, element-wise\n\nSpecification: numpy.add returns a vector where each element is the sum\nof the corresponding elements from x1 and x2.\n\nMathematical Properties:\n1. Element-wise correctness: result[i] = x1[i] + x2[i]\n2. Commutativity: add(x1, x2) = add(x2, x1)\n3. Associativity: add(add(x1, x2), x3) = add(x1, add(x2, x3))\n4. Identity: add(x, zeros) = x\n5. Preserves vector length: result.size = x1.size = x2.size\n6. Handles finite arithmetic: supports IEEE 754 floating-point addition\n\nPrecondition: True (no special preconditions for basic addition)\nPostcondition: For all indices i, result[i] = x1[i] + x2[i]", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn add(x1: Vec<i32>, x2: Vec<i32>) -> (result: Vec<i32>)\n    requires x1.len() == x2.len(),\n    ensures \n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == x1[i] + x2[i]", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "mathematical_functions_arccos", "vc-description": "Trigonometric inverse cosine, element-wise.\nReturns the arc cosine of each element in the input vector.\nThe result is in the range [0, π].\n\nSpecification: arccos returns the inverse cosine of each element.\nPrecondition: All elements must be in the range [-1, 1] for valid results.\nPostcondition: The result contains the arc cosine of each input element,\nwith values in the range [0, π], and satisfies cos(arccos(x)) = x for valid inputs.\nAdditionally, arccos is monotonically decreasing on its domain [-1, 1].", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn arccos(x: Vec<i32>) -> (result: Vec<i32>)\n    requires \n        x.len() > 0,\n        forall|i: int| 0 <= i < x.len() ==> -1 <= x[i] && x[i] <= 1,\n    ensures \n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> (\n            0 <= result[i] && \n            result[i] <= 3 &&\n            (x[i] == -1 ==> result[i] == 3) &&\n            (x[i] == 1 ==> result[i] == 0)\n        ),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "mathematical_functions_arcsinh", "vc-description": "numpy.arcsinh: Inverse hyperbolic sine element-wise.\n\nComputes the inverse hyperbolic sine of each element in the input vector.\nThe inverse hyperbolic sine is defined as arcsinh(x) = ln(x + sqrt(x² + 1)).\n\nThis function is defined for all real numbers and is the inverse of the\nhyperbolic sine function (sinh).\n\nSpecification: numpy.arcsinh returns a vector where each element is the\ninverse hyperbolic sine of the corresponding element in x.\n\nPrecondition: True (arcsinh is defined for all real numbers)\nPostcondition: For all indices i, result[i] = arcsinh(x[i])\n\nMathematical properties captured:\n1. arcsinh(0) = 0 (sanity check)\n2. arcsinh(-x) = -arcsinh(x) (odd function property)\n3. arcsinh is strictly increasing (monotonicity)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_arcsinh(x: Vec<f32>) -> (result: Vec<f32>)\n    ensures \n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> {\n            /* Sanity check: arcsinh(0) = 0 */\n            x[i] == 0.0f32 ==> result[i] == 0.0f32\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "mathematical_functions_arctan", "vc-description": "Trigonometric inverse tangent, element-wise.\n\nThe inverse of tan, so that if y = tan(x) then x = arctan(y).\n\nComputes the element-wise inverse tangent of a vector.\n\nSpecification: arctan computes the inverse tangent of each element,\nwith comprehensive mathematical properties including range bounds,\nmonotonicity, and behavior at special values.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn arctan(x: Vec<i32>) -> (result: Vec<i32>)\n    requires x.len() > 0,\n    ensures \n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> {\n            /* Range constraint: arctan(x) ∈ (-π/2, π/2) - simplified for integer domain */\n            result[i] >= -2 && result[i] <= 2 &&\n            /* Sign property: arctan preserves sign */\n            (x[i] > 0 ==> result[i] >= 0) &&\n            (x[i] < 0 ==> result[i] <= 0) &&\n            (x[i] == 0 ==> result[i] == 0) &&\n            /* Monotonicity property for specific cases */\n            (x[i] > 10 ==> result[i] >= 1) &&\n            (x[i] < -10 ==> result[i] <= -1) &&\n            /* Bounded function: |arctan(x)| ≤ 2 for integer approximation */\n            result[i] >= -2 && result[i] <= 2\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "mathematical_functions_arctanh", "vc-description": "numpy.arctanh: Inverse hyperbolic tangent element-wise.\n\nComputes the inverse hyperbolic tangent of each element in the input array.\nThe inverse hyperbolic tangent is defined for values in the open interval (-1, 1).\n\nFor a real number x with |x| < 1, arctanh(x) is the value y such that tanh(y) = x.\nMathematically: arctanh(x) = 0.5 * ln((1 + x) / (1 - x))\n\nReturns an array of the same shape as x, containing the inverse hyperbolic tangent \nof each element.\n\nSpecification: numpy.arctanh returns a vector where each element is the inverse\nhyperbolic tangent of the corresponding element in x.\n\nPrecondition: All elements must be in the open interval (-1, 1) for real-valued results\nPostcondition: For all indices i, result[i] = Float.atanh x[i]\n\nMathematical properties:\n- arctanh(0) = 0 (identity property)\n- arctanh is an odd function: arctanh(-x) = -arctanh(x)\n- For |x| < 1: arctanh(x) = 0.5 * ln((1 + x) / (1 - x))\n- arctanh is strictly increasing on (-1, 1)\n- Domain preservation: all results are finite real numbers\n- Range property: arctanh maps (-1, 1) to (-∞, ∞)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_arctanh(x: Vec<i32>) -> (result: Vec<i32>)\n    requires \n        x.len() > 0,\n    ensures\n        result.len() == x.len(),\n        /* Identity property: arctanh(0) = 0 */\n        forall|i: int| 0 <= i < x.len() && x[i] == 0 ==> result[i] == 0,\n        /* Range property: result contains finite numbers */\n        result.len() == x.len(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "mathematical_functions_clip", "vc-description": "numpy.clip: Clip (limit) the values in an array.\n\nGiven an interval [min_val, max_val], values outside the interval are clipped to the interval edges.\nValues smaller than min_val become min_val, and values larger than max_val become max_val.\n\nThis operation is equivalent to but faster than np.minimum(max_val, np.maximum(arr, min_val)).\nThe function performs element-wise clipping and preserves the shape of the input array.\n\nFrom NumPy documentation:\n- Parameters: \n  - a (array_like) - Array containing elements to clip\n  - a_min (scalar) - Minimum value threshold\n  - a_max (scalar) - Maximum value threshold\n- Returns: clipped array with values limited to [a_min, a_max]\n\nSpecial behavior:\n- If a_min > a_max, all values become a_max\n- No validation is performed to ensure a_min < a_max\n\nSpecification: numpy.clip returns a vector where each element is clipped to the interval [min_val, max_val].\n\nMathematical Properties:\n1. Element-wise correctness: \n   - If arr[i] < min_val, then result[i] = min_val\n   - If arr[i] > max_val, then result[i] = max_val  \n   - If min_val ≤ arr[i] ≤ max_val, then result[i] = arr[i]\n2. Boundary behavior: Values are clamped to the closed interval [min_val, max_val]\n3. Preserves vector length: result.size = arr.size\n4. Idempotency: clip(clip(arr, min_val, max_val), min_val, max_val) = clip(arr, min_val, max_val)\n5. Monotonicity: If min_val ≤ max_val, then min_val ≤ result[i] ≤ max_val for all i\n6. Special case: If min_val > max_val, then result[i] = max_val for all i\n\nPrecondition: True (no special preconditions, handles all real number inputs)\nPostcondition: For all indices i, result[i] is the clipped value of arr[i]", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn clip(arr: &Vec<i32>, min_val: i32, max_val: i32) -> (result: Vec<i32>)\n    ensures\n        result.len() == arr.len(),\n        forall|i: int| 0 <= i < result.len() ==> {\n            if min_val <= max_val {\n                if arr[i] < min_val {\n                    result[i] == min_val\n                } else if arr[i] > max_val {\n                    result[i] == max_val\n                } else {\n                    result[i] == arr[i]\n                }\n            } else {\n                result[i] == max_val\n            }\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "mathematical_functions_conj", "vc-description": "Return the complex conjugate of a vector of complex numbers, element-wise\n\nSpecification: conj computes the complex conjugate of each element with the following properties:\n    1. Basic definition: conj(a + bi) = a - bi for complex numbers\n    2. Real preservation: For purely real numbers, conj(x) = x\n    3. Involution property: conj(conj(x)) = x (double conjugation returns original)\n    4. Magnitude preservation: |conj(x)| = |x| (conjugate preserves magnitude)\n    5. Distributive over addition: conj(x + y) = conj(x) + conj(y)\n    6. Distributive over multiplication: conj(x * y) = conj(x) * conj(y)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* Structure representing a complex number with integer components */\n#[derive(PartialEq, Eq)]\npub struct Complex {\n    /* The real part of the complex number */\n    pub real: int,\n    /* The imaginary part of the complex number */\n    pub imag: int,\n}\n\nimpl Complex {\n    /* Addition of complex numbers */\n    pub open spec fn add(self, other: Complex) -> Complex {\n        Complex { real: self.real + other.real, imag: self.imag + other.imag }\n    }\n\n    /* Multiplication of complex numbers */\n    pub open spec fn mul(self, other: Complex) -> Complex {\n        Complex { \n            real: self.real * other.real - self.imag * other.imag,\n            imag: self.real * other.imag + self.imag * other.real\n        }\n    }\n\n    /* Magnitude squared of a complex number */\n    pub open spec fn norm_sq(self) -> int {\n        self.real * self.real + self.imag * self.imag\n    }\n\n    /* Complex conjugate of a single complex number */\n    pub open spec fn conj(self) -> Complex {\n        Complex { real: self.real, imag: -self.imag }\n    }\n}", "vc-helpers": "", "vc-spec": "fn conj(x: Vec<Complex>) -> (result: Vec<Complex>)\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < x.len() ==> \n            result[i].real == x[i].real && result[i].imag == -x[i].imag,\n        forall|i: int| 0 <= i < x.len() ==> \n            x[i].imag == 0 ==> result[i] == x[i],\n        forall|i: int| 0 <= i < x.len() ==> \n            result[i].conj() == x[i],\n        forall|i: int| 0 <= i < x.len() ==> \n            x[i].norm_sq() == result[i].norm_sq(),\n        forall|i: int, y: Complex| 0 <= i < x.len() ==> \n            x[i].add(y).conj() == result[i].add(y.conj()),\n        forall|i: int, y: Complex| 0 <= i < x.len() ==> \n            x[i].mul(y).conj() == result[i].mul(y.conj())", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "mathematical_functions_convolve", "vc-description": "numpy.convolve: Returns the discrete, linear convolution of two one-dimensional arrays.\n\nThe discrete convolution operation is defined as:\n(a * v)[n] = sum(a[m] * v[n - m], m = -∞ to ∞)\n\nFor finite arrays, the convolution is computed over the valid range where\nboth arrays have elements. This implementation follows the 'full' mode\nwhich returns a convolution of length (M + N - 1) where M and N are\nthe lengths of the input arrays.\n\nSpecification: numpy.convolve returns the discrete convolution of two vectors.\n\nPrecondition: Both input vectors must be non-empty (enforced by types)\nPostcondition: The result vector contains the discrete convolution values\n\nThe convolution at position k is computed as:\nresult[k] = sum(a[i] * v[k - i] for all valid i)\n\nMathematical properties:\n1. Result length is m + n - 1 (enforced by return type)\n2. Each element follows the convolution definition\n3. Boundary conditions: zero-padding is implicitly assumed outside array bounds", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn convolution_element_sum(a: Seq<i32>, v: Seq<i32>, k: int) -> int\n    decreases a.len()\n{\n    if a.len() == 0 {\n        0\n    } else {\n        let i = 0;\n        let contribution = if k >= i && k - i < v.len() {\n            a[i] * v[k - i]\n        } else {\n            0\n        };\n        contribution + convolution_element_sum(a.skip(1), v, k)\n    }\n}\n\nfn numpy_convolve(a: Vec<i32>, v: Vec<i32>) -> (result: Vec<i32>)\n    requires a.len() > 0 && v.len() > 0,\n    ensures \n        result.len() == a.len() + v.len() - 1,\n        forall|k: int| 0 <= k < result.len() ==> result[k] == convolution_element_sum(a@, v@, k),\n        result[0] == a[0] * v[0],\n        result[result.len() - 1] == a[a.len() - 1] * v[v.len() - 1],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "mathematical_functions_copysign", "vc-description": "numpy.copysign: Change the sign of x1 to that of x2, element-wise.\n\nReturns an array where each element has the magnitude of x1 but the sign of x2.\nThis function is useful for combining the absolute value of one array with \nthe sign pattern of another.\n\nFor each element:\n- If x2 >= 0, returns |x1|\n- If x2 < 0, returns -|x1|\n\nSpecial cases:\n- copysign(x, 0) returns |x| (positive sign)\n- copysign(0, y) returns 0 with the sign of y\n\nSpecification: numpy.copysign returns a vector where each element has\nthe magnitude of the corresponding element in x1 but the sign of the\ncorresponding element in x2.\n\nPrecondition: True (no special preconditions for copysign)\nPostcondition: For all indices i:\n  - If x2[i] >= 0, then result[i] = |x1[i]|\n  - If x2[i] < 0, then result[i] = -|x1[i]|\n\nMathematical properties:\n  1. result[i] = |x1[i]| * sign(x2[i]) where sign(x) = 1 if x >= 0, -1 if x < 0\n  2. |result[i]| = |x1[i]| (magnitude preservation)\n  3. sign(result[i]) = sign(x2[i]) (sign copying)\n  4. copysign(x1, x2) = copysign(|x1|, x2) (idempotence on magnitude)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn copysign(x1: Vec<i32>, x2: Vec<i32>) -> (result: Vec<i32>)\n    requires x1.len() == x2.len(),\n    ensures \n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> {\n            /* Basic behavior: sign copying with magnitude preservation */\n            (x2[i] >= 0 ==> result[i] as int == if x1[i] >= 0 { x1[i] as int } else { -(x1[i] as int) }) &&\n            (x2[i] < 0 ==> result[i] as int == if x1[i] >= 0 { -(x1[i] as int) } else { x1[i] as int }) &&\n            /* Magnitude preservation property: |result[i]| = |x1[i]| */\n            (if result[i] >= 0 { result[i] as int } else { -(result[i] as int) }) == \n            (if x1[i] >= 0 { x1[i] as int } else { -(x1[i] as int) }) &&\n            /* Sign copying property: result has same sign as x2 */\n            (x2[i] >= 0 ==> result[i] >= 0) &&\n            (x2[i] < 0 ==> result[i] < 0)\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "mathematical_functions_cos", "vc-description": "numpy.cos: Cosine element-wise.\n\nComputes the cosine of each element in the input array.\nThe cosine is one of the fundamental functions of trigonometry.\nFor a real number x interpreted as an angle in radians, cos(x)\ngives the x-coordinate of the point on the unit circle.\n\nReturns an array of the same shape as x, containing the cosine of each element.\n\nSpecification: numpy.cos returns a vector where each element is the cosine\nof the corresponding element in x (interpreted as radians).\n\nPrecondition: True (no special preconditions for cosine)\nPostcondition: For all indices i, result[i] = Float.cos x[i]\n              and result[i] is bounded between -1 and 1\n              with cos(0) = 1", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_cos(x: Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> {\n            -1 <= result[i] <= 1 &&\n            (x[i] == 0 ==> result[i] == 1)\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "mathematical_functions_cumprod", "vc-description": "numpy.cumprod: Return the cumulative product of elements along a given axis.\n\nFor a vector [a₁, a₂, a₃, ..., aₙ], returns [a₁, a₁*a₂, a₁*a₂*a₃, ..., a₁*a₂*...*aₙ].\n\nThis function computes the cumulative product by applying successive multiplications\nfrom left to right, producing a result vector of the same length as the input.\n\nThe cumulative product is computed as: result[i] = ∏(k=0 to i) input[k]\n\nFor empty vectors, returns an empty vector.\n\nSpecification: cumprod returns the cumulative product of elements.\n\nPrecondition: True (works for any vector, including empty)\nPostcondition: \n- Result has same length as input\n- For any index i, result[i] = product of all elements from a[0] to a[i] inclusive\n- Equivalently: result[i] = a[0] * a[1] * ... * a[i]\n- For empty vectors, returns empty vector (vacuous condition holds)\n\nMathematical Properties:\n- result[0] = a[0] (when n > 0)\n- result[i+1] = result[i] * a[i+1] (cumulative property)\n- Each element is the product of all preceding elements (including itself)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn product_prefix(a: Seq<int>, end: int) -> int\n    decreases end\n{\n    if end <= 0 {\n        1\n    } else if end == 1 {\n        a[0]\n    } else {\n        product_prefix(a, end - 1) * a[end - 1]\n    }\n}\n\nfn cumprod(a: Vec<int>) -> (result: Vec<int>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> result[i] == product_prefix(a@, i + 1),\n        forall|i: int, j: int| 0 <= i < a.len() && j == i + 1 && j < a.len() ==> \n            result[j] == result[i] * a[j]", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "mathematical_functions_cumsum", "vc-description": "numpy.cumsum: Return the cumulative sum of the elements along a given axis.\n\nFor a 1D array, cumsum computes the cumulative sum where each element\nis the sum of all previous elements plus itself. For example:\n[1, 2, 3, 4] becomes [1, 3, 6, 10]\n\nThe cumulative sum is defined as:\n- result[0] = a[0]\n- result[i] = result[i-1] + a[i] for i > 0\n\nSpecification: numpy.cumsum returns a vector where each element is the\ncumulative sum up to that position.\n\nPrecondition: True (no special preconditions)\nPostcondition: \n- For non-empty vectors, the first element equals the first element of the input\n- Each subsequent element equals the previous cumulative sum plus the current element\n- The cumulative sum has the property that result[i] = sum of a[0] through a[i]", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn prefix_sum(a: Seq<i32>, i: int) -> int\n    decreases i\n{\n    if i < 0 || i >= a.len() {\n        0\n    } else if i == 0 {\n        a[0] as int\n    } else {\n        prefix_sum(a, i - 1) + (a[i] as int)\n    }\n}\n\nfn numpy_cumsum(a: Vec<i32>) -> (result: Vec<i32>)\n    ensures \n        result.len() == a.len(),\n        a.len() > 0 ==> result[0] == a[0],\n        forall|i: int| 0 < i < a.len() ==> result[i] == result[i - 1] + a[i],\n        forall|i: int| 0 <= i < a.len() ==> result[i] as int == prefix_sum(a@, i)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "mathematical_functions_deg2rad", "vc-description": "Convert angles from degrees to radians\n\nConvert angles from degrees to radians by multiplying by π/180.\nThis function performs the standard mathematical conversion from degrees to radians\nwhere π radians = 180 degrees.\n\nSpecification: deg2rad converts each degree value to radians using the formula radians = degrees * π/180", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn deg2rad(degrees: Vec<i32>) -> (radians: Vec<i32>)\n    ensures \n        radians.len() == degrees.len(),\n        forall|i: int| 0 <= i < degrees.len() ==> #[trigger] radians[i] == degrees[i] * 314 / 18000", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "mathematical_functions_diff", "vc-description": "numpy.diff: Calculate the n-th discrete difference along the given axis.\n\nThe first difference is given by out[i] = a[i+1] - a[i] along the given axis.\nHigher differences are calculated by using diff recursively.\n\nFor a 1D array, the first difference computes the difference between \nconsecutive elements, producing an array with one less element.\n\nThe function is particularly useful for numerical analyses where \nunderstanding incremental changes within data is crucial.\n\nSpecification: numpy.diff returns a vector where each element is the difference\nof consecutive elements from the input array.\n\nPrecondition: Input array must be non-empty (at least 2 elements for first difference)\nPostcondition: For all indices i, result[i] = a[i+1] - a[i]\n\nMathematical Properties:\n1. Length property: |result| = |input| - 1\n2. Difference property: Each element represents the discrete difference\n3. Type preservation: Result maintains the same numeric type as input\n4. Monotonicity: If input is monotonic, result has consistent sign", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_diff(a: Vec<i32>) -> (result: Vec<i32>)\n    requires a.len() >= 2,\n    ensures \n        result.len() == a.len() - 1,\n        forall|i: int| 0 <= i < result.len() ==> result[i] == a[i + 1] - a[i],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "mathematical_functions_ediff1d", "vc-description": "numpy.ediff1d: The differences between consecutive elements of an array.\n\nComputes the differences between consecutive elements of an array.\nFor an input array [a, b, c, d], returns [b-a, c-b, d-c].\n\nThe function always returns a 1D array, and if necessary, the input\nwill be flattened before the differences are taken.\n\nThis is equivalent to ary.flat[1:] - ary.flat[:-1] in NumPy.\n\nSpecification: numpy.ediff1d returns a vector of differences between consecutive elements.\n\nPrecondition: The input vector must have at least one element (enforced by type)\nPostcondition: For all indices i, result[i] = ary[i+1] - ary[i]\n\nKey properties:\n1. The result has length n for input of length n+1\n2. Each element represents the difference between consecutive elements\n3. The result is always 1D regardless of input shape\n4. Mathematically: result[i] = ary[i+1] - ary[i] for all valid i", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_ediff1d(ary: Vec<i32>) -> (result: Vec<i32>)\n    requires ary.len() > 0,\n    ensures \n        result.len() == ary.len() - 1,\n        forall|i: int| 0 <= i < result.len() ==> result[i] == ary[i + 1] - ary[i],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "mathematical_functions_exp2", "vc-description": "Calculate 2**p for all p in the input array. numpy.exp2: Calculate 2 raised to the power of each element in the input vector.\n\nComputes 2^p for all p in the input vector, element-wise.\nThis is equivalent to applying the exponential function with base 2\nto each element of the input vector.\n\nFrom NumPy documentation:\n- Parameters: x (array_like) - Input values\n- Returns: y (ndarray) - 2**x, element-wise\n\nThe function is implemented as a universal function (ufunc) that\noperates element-wise on arrays and supports broadcasting.\nFor finite input values, the result is always positive.\n\nSpecification: numpy.exp2 computes 2 raised to the power of each element \nin the input vector.\n\nMathematical Properties:\n1. Element-wise correctness: result[i] = 2^x[i] for all i\n2. Fundamental exponential identity: exp2(0) = 1\n3. Base property: exp2(1) = 2\n4. Negative powers: exp2(-1) = 0.5\n5. Positivity: exp2(x) > 0 for all finite x\n6. Monotonicity: if x[i] < x[j], then exp2(x)[i] < exp2(x)[j]\n7. Exponential addition rule: exp2(a + b) = exp2(a) * exp2(b)\n8. Preservation of vector length: result.size = x.size\n9. Handles IEEE 754 floating-point arithmetic\n\nPrecondition: True (no special preconditions for exp2)\nPostcondition: For all indices i, result[i] = 2^x[i] and result[i] > 0", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn exp2(x: Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() == x.len(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "mathematical_functions_expm1", "vc-description": "Calculate exp(x) - 1 for all elements in the vector.\nThis function provides greater precision than exp(x) - 1 for small values of x.\n\nSpecification: expm1 computes exp(x) - 1 element-wise with enhanced numerical precision", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn expm1(x: Vec<f32>) -> (result: Vec<f32>)\n    requires x.len() > 0,\n    ensures \n        result.len() == x.len(),\n        forall|i: int| 0 <= i < x.len() ==> {\n            /* Basic mathematical property: result equals exp(x) - 1 */\n            true &&\n            /* Identity property: expm1(0) = 0 */\n            (x[i] == 0.0f32 ==> result[i] == 0.0f32) &&\n            /* Sign preservation and bounds properties */\n            true\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "mathematical_functions_fabs", "vc-description": "Compute the absolute values element-wise for floating-point numbers\n\nSpecification: fabs computes the absolute value of each element", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn fabs(x: Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() == x.len()", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "mathematical_functions_float_power", "vc-description": "Element-wise power operation with float promotion. \nRaises each element of the base vector to the corresponding power in the exponent vector.\nAll values are promoted to Float (minimum precision of Float64).\n\nSpecification: float_power computes element-wise exponentiation with appropriate constraints.\n- For positive bases: result is always well-defined\n- For zero bases: only non-negative exponents are valid\n- For negative bases: only integer exponents are mathematically valid (though NumPy allows all)\n- The result preserves the mathematical power relationship element-wise", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn float_pow(base: f64, exponent: f64) -> f64;\n\nfn float_power(base: Vec<f64>, exponent: Vec<f64>) -> (result: Vec<f64>)\n    requires \n        base.len() == exponent.len()\n    ensures \n        result.len() == base.len(),\n        forall|i: int| 0 <= i < result.len() ==> \n            result[i] == float_pow(base[i], exponent[i])", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "mathematical_functions_fmax", "vc-description": "Element-wise maximum of array elements.\n\nCompare two arrays and returns a new array containing the element-wise maxima. If one of the elements being compared is a NaN, then the non-nan element is returned.\n\nElement-wise maximum of two vectors, with special NaN handling.\nIf one element is NaN, returns the non-NaN element.\n\nSpecification: fmax returns element-wise maximum with NaN handling.\nFor each position i:\n- If both elements are non-NaN, returns the maximum\n- If x[i] is NaN and y[i] is not, returns y[i]  \n- If y[i] is NaN and x[i] is not, returns x[i]\n- If both are NaN, returns NaN\nAdditional mathematical properties:\n- Commutative when both values are non-NaN\n- Associative when all values are non-NaN\n- Idempotent when values are non-NaN", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn is_nan(f: f32) -> bool;\n\nspec fn float_max(x: f32, y: f32) -> f32;", "vc-helpers": "", "vc-spec": "fn fmax(x: Vec<f32>, y: Vec<f32>) -> (result: Vec<f32>)\n    requires x.len() == y.len(),\n    ensures \n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> {\n            /* Core NaN handling behavior */\n            (!is_nan(x[i]) && !is_nan(y[i])) ==> \n                (result[i] == float_max(x[i], y[i])) &&\n            (is_nan(x[i]) && !is_nan(y[i])) ==> \n                (result[i] == y[i]) &&\n            (!is_nan(x[i]) && is_nan(y[i])) ==> \n                (result[i] == x[i]) &&\n            (is_nan(x[i]) && is_nan(y[i])) ==> \n                is_nan(result[i]) &&\n            /* Mathematical properties for non-NaN cases */\n            (!is_nan(x[i]) && !is_nan(y[i])) ==> \n                (result[i] == x[i] || result[i] == y[i]) &&\n            /* NaN preservation: result is NaN iff both inputs are NaN */\n            is_nan(result[i]) <==> (is_nan(x[i]) && is_nan(y[i]))\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "mathematical_functions_hypot", "vc-description": "numpy.hypot: Given the 'legs' of a right triangle, return its hypotenuse.\n\nComputes the hypotenuse of a right triangle given the lengths of its two legs.\nThis is equivalent to sqrt(x1^2 + x2^2), but is implemented in a way that\navoids overflow for large values.\n\nThe function operates element-wise on the input vectors, computing the\nhypotenuse for each pair of corresponding elements.\n\nSpecification: numpy.hypot returns a vector where each element is the\nhypotenuse computed from the corresponding elements of x1 and x2.\n\nPrecondition: True (no special preconditions)\nPostcondition: For all indices i, result[i] = sqrt(x1[i]² + x2[i]²)\n\nMathematical properties:\n1. The result is always non-negative\n2. The result follows the Pythagorean theorem\n3. The result is symmetric: hypot(a, b) = hypot(b, a)\n4. For positive inputs, hypot(a, b) ≥ max(Float.abs(a), Float.abs(b))\n5. hypot(0, a) = Float.abs(a) and hypot(a, 0) = Float.abs(a)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_hypot(x1: Vec<f32>, x2: Vec<f32>) -> (result: Vec<f32>)\n    requires x1.len() == x2.len(),\n    ensures \n        result.len() == x1.len(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "mathematical_functions_i0", "vc-description": "Modified Bessel function of the first kind, order 0.\n\nComputes the Modified Bessel function of the first kind, order 0, element-wise.\nThis is a special function that arises in many mathematical contexts including\nsolutions to differential equations and probability theory.\n\nThe function is defined by the infinite series:\ni0(x) = sum((x/2)^(2k) / (k!)^2, k=0..inf)\n\nReturns an array of the same shape as x, containing the i0 values of each element.\n\nSpecification: numpy.i0 returns a vector where each element is the Modified\nBessel function of the first kind, order 0, of the corresponding element in x.\n\nMathematical properties:\n1. i0(0) = 1 (by definition, the series starts with 1)\n2. i0(x) > 0 for all real x (positive function)\n3. i0(x) = i0(-x) (even function)\n4. i0(x) is monotonically increasing for x ≥ 0\n5. For large x, i0(x) ≈ exp(|x|) / sqrt(2π|x|) (asymptotic behavior)\n\nPrecondition: True (no special preconditions for i0)\nPostcondition: For all indices i, result[i] = i0(x[i]) with the mathematical properties above", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn i0(x: Vec<i32>) -> (result: Vec<i32>)\n    requires true,\n    ensures \n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> {\n            /* Basic function evaluation - i0(x) > 0 for all x (positive function) */\n            result[i] > 0 &&\n            /* Zero case: i0(0) = 1 */\n            (x[i] == 0 ==> result[i] == 1) &&\n            /* Even function: i0(x) = i0(-x) */\n            (forall|j: int| 0 <= j < x.len() && x[j] == -x[i] ==> result[j] == result[i]) &&\n            /* Monotonicity for non-negative values */\n            (forall|j: int| 0 <= j < x.len() && x[i] >= 0 && x[j] >= 0 && x[i] <= x[j] ==> result[i] <= result[j])\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "mathematical_functions_log10", "vc-description": "numpy.log10: Return the base 10 logarithm of the input array, element-wise.\n\nThe base 10 logarithm log10 is the logarithm to the base 10.\nIt is the inverse of the exponential function with base 10,\nso that log10(10^x) = x.\n\nReturns an array of the same shape as x, containing the base 10 logarithm\nof each element in x.\n\nSpecification: numpy.log10 returns a vector where each element is the base 10\nlogarithm of the corresponding element in x.\n\nPrecondition: All elements must be positive (x[i] > 0)\nPostcondition: For all indices i, result[i] = Float.log10 x[i]\n\nMathematical properties:\n1. log10(10^a) = a for positive a\n2. log10(a * b) = log10(a) + log10(b) for positive a, b  \n3. log10(1) = 0\n4. log10(10) = 1\n5. Monotonic: a < b implies log10(a) < log10(b) for positive a, b", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_log10(x: Vec<f32>) -> (result: Vec<f32>)\n    requires \n        x.len() > 0,\n    ensures \n        result.len() == x.len(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "mathematical_functions_log1p", "vc-description": "numpy.log1p: Return the natural logarithm of one plus the input array, element-wise.\n\nCalculates log(1 + x). This function provides greater precision than log(1 + x) \nfor small values of x near zero, where the naive computation would suffer from \nfloating-point precision loss.\n\nReturns an array of the same shape as x, containing log(1 + x) for each element.\n\nNote: The domain is x > -1 (since log(1 + x) requires 1 + x > 0).\nFor x = -1, the result is -∞ (negative infinity).\nFor x < -1, the result is NaN (not a number).\n\nSpecification: log1p returns a vector where each element is the natural\nlogarithm of one plus the corresponding element in x.\n\nPrecondition: All elements must be greater than -1 (x[i] > -1)\nPostcondition: For all indices i, result[i] = log(1 + x[i])\n\nMathematical properties:\n- log1p(0) = log(1) = 0\n- log1p(e - 1) = 1\n- log1p provides better precision than log(1 + x) for small x\n- log1p is strictly increasing on (-1, ∞)\n- log1p(x) = log(1 + x) for all valid x\n- For small x, log1p(x) ≈ x - x²/2 + x³/3 - ...", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn log1p(x: Vec<i32>) -> (result: Vec<i32>)\n    requires \n        x.len() > 0,\n        forall|i: int| 0 <= i < x.len() ==> x[i] > -1,\n    ensures \n        result.len() == x.len(),\n        forall|i: int| 0 <= i < x.len() && x[i] == 0 ==> result[i] == 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "mathematical_functions_maximum", "vc-description": "numpy.maximum: Element-wise maximum of array elements.\n\nCompares two arrays element-wise and returns a new array containing\nthe element-wise maxima. If one of the elements being compared is NaN,\nthen that element is returned.\n\nThis is a universal function (ufunc) that operates element-wise on arrays\nand supports broadcasting. For 1D arrays, it computes the maximum of\ncorresponding elements.\n\nSpecification: numpy.maximum returns a vector where each element is the maximum\nof the corresponding elements from x1 and x2.\n\nMathematical properties:\n1. Commutativity: maximum(x1, x2) = maximum(x2, x1)\n2. Associativity: maximum(maximum(x1, x2), x3) = maximum(x1, maximum(x2, x3))\n3. Idempotence: maximum(x, x) = x\n4. Monotonicity: if x1[i] ≤ y1[i] and x2[i] ≤ y2[i], then maximum(x1, x2)[i] ≤ maximum(y1, y2)[i]\n5. Identity: maximum(x, -∞) = x (where -∞ is negative infinity)\n\nPrecondition: True (no special preconditions for element-wise maximum)\nPostcondition: For all indices i, result[i] = max(x1[i], x2[i])", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn maximum(x1: Vec<i32>, x2: Vec<i32>) -> (result: Vec<i32>)\n    requires x1.len() == x2.len(),\n    ensures \n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> \n            result[i] == if x1[i] >= x2[i] { x1[i] } else { x2[i] },\n        forall|i: int| 0 <= i < result.len() ==> \n            result[i] >= x1[i] && result[i] >= x2[i],\n        forall|i: int| 0 <= i < result.len() ==> \n            result[i] == x1[i] || result[i] == x2[i],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "mathematical_functions_minimum", "vc-description": "numpy.minimum: Element-wise minimum of array elements.\n\nCompare two arrays and returns a new array containing the element-wise minima.\nIf one of the elements being compared is NaN, then that element is returned.\n\nThis is different from numpy.min which returns a single minimum value.\nThis function performs element-wise comparison and returns a new array.\n\nBinary universal function: minimum(x1, x2)\n\nParameters:\n- x1, x2: Vector Float n - Input vectors of the same size\n\nReturns:\n- Vector Float n - The element-wise minimum of x1 and x2\n\nSpecification: numpy.minimum returns a vector where each element is the minimum\nof the corresponding elements from x1 and x2.\n\nMathematical properties:\n1. Commutativity: min(a, b) = min(b, a)\n2. Associativity: min(min(a, b), c) = min(a, min(b, c))\n3. Idempotency: min(a, a) = a\n4. Element-wise operation: result[i] = min(x1[i], x2[i]) for all i\n5. NaN propagation: if either x1[i] or x2[i] is NaN, result[i] is NaN\n\nPrecondition: True (no special preconditions for element-wise minimum)\nPostcondition: For all indices i, result[i] = min(x1[i], x2[i])", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn minimum(x1: Vec<f32>, x2: Vec<f32>) -> (result: Vec<f32>)\n    requires x1.len() == x2.len(),\n    ensures \n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> \n            (result[i] == x1[i] || result[i] == x2[i]),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "mathematical_functions_mod", "vc-description": "numpy.mod: Returns the element-wise remainder of division.\n\nComputes the remainder complementary to the floor_divide function.\nThis is equivalent to x1 % x2 in terms of array broadcasting.\n\nThe result has the same sign as the divisor x2.\nFor two arguments of floating point type, the result is:\nx1 - floor(x1/x2) * x2\n\nSpecification: numpy.mod returns a vector where each element is the remainder\nof the corresponding elements from x1 and x2.\n\nPrecondition: All elements in x2 must be non-zero\nPostcondition: For all indices i, result[i] = x1[i] % x2[i]\n\nMathematical properties:\n1. The result has the same sign as x2[i] (when x2[i] ≠ 0)\n2. The absolute value of result[i] is less than the absolute value of x2[i]\n3. x1[i] = floor(x1[i] / x2[i]) * x2[i] + result[i]", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_mod(x1: Vec<i32>, x2: Vec<i32>) -> (result: Vec<i32>)\n    requires \n        x1.len() == x2.len(),\n        forall|i: int| 0 <= i < x2.len() ==> x2[i] != 0,\n    ensures\n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> \n            #[trigger] result[i] == x1[i] % x2[i],\n        forall|i: int| 0 <= i < result.len() ==> {\n            let r = #[trigger] result[i];\n            let a = x1[i];\n            let b = x2[i];\n            /* Basic remainder property: a = floor_div(a, b) * b + r */\n            a == (a / b) * b + r &&\n            /* Result has same sign as divisor (when divisor is non-zero) */\n            (b > 0 ==> r >= 0 && r < b) &&\n            (b < 0 ==> r <= 0 && r > b)\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "mathematical_functions_multiply", "vc-description": "numpy.multiply: Multiply arguments element-wise.\n\nMultiplies two vectors element-wise. If the vectors have the same shape,\neach element of the result is the product of the corresponding elements\nfrom the input vectors.\n\nThis is equivalent to x1 * x2 in terms of array broadcasting.\nThe function supports all numeric types and handles overflow according\nto the IEEE 754 standard for floating-point arithmetic.\n\nFrom NumPy documentation:\n- Parameters: x1, x2 (array_like) - The arrays to be multiplied\n- Returns: multiply (ndarray) - The product of x1 and x2, element-wise\n- The function is a universal function (ufunc) implemented in C\n- Uses optimized C loops for different data types\n\nSpecification: numpy.multiply returns a vector where each element is the product\nof the corresponding elements from x1 and x2.\n\nMathematical Properties:\n1. Element-wise correctness: result[i] = x1[i] * x2[i]\n2. Commutativity: multiply(x1, x2) = multiply(x2, x1)\n3. Associativity: multiply(multiply(x1, x2), x3) = multiply(x1, multiply(x2, x3))\n4. Identity: multiply(x, ones) = x\n5. Zero property: multiply(x, zeros) = zeros\n6. Preserves vector length: result.size = x1.size = x2.size\n7. Handles finite arithmetic: supports IEEE 754 floating-point multiplication\n8. Distributivity over addition: multiply(x1, add(x2, x3)) = add(multiply(x1, x2), multiply(x1, x3))\n\nPrecondition: True (no special preconditions for basic multiplication)\nPostcondition: For all indices i, result[i] = x1[i] * x2[i]", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn multiply(x1: Vec<i32>, x2: Vec<i32>) -> (result: Vec<i32>)\n    requires x1.len() == x2.len(),\n    ensures \n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == x1[i] * x2[i]", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "mathematical_functions_nancumsum", "vc-description": "numpy.nancumsum: Return the cumulative sum of array elements treating NaN as zero.\n\nFor a 1D array, nancumsum computes the cumulative sum where NaN values are treated as zero.\nUnlike regular cumsum, NaN values do not propagate and are replaced with zero during computation.\n\nExamples:\n- [1, NaN, 3] becomes [1, 1, 4] (NaN treated as 0)\n- [NaN, 2, 3] becomes [0, 2, 5] (leading NaN becomes 0)\n- [1, 2, NaN, 4] becomes [1, 3, 3, 7] (NaN contributes 0 to sum)\n\nThe cumulative sum with NaN handling is defined as:\n- result[0] = if a[0].isNaN then 0 else a[0]\n- result[i] = result[i-1] + (if a[i].isNaN then 0 else a[i]) for i > 0\n\nSpecification: nancumsum returns a vector where each element is the cumulative sum\nup to that position with NaN values treated as zero.\n\nPrecondition: True (no special preconditions)\nPostcondition:\n- Result has the same length as input\n- NaN values are treated as zero in the cumulative sum computation\n- For non-empty vectors, first element is either a[0] or 0 if a[0] is NaN\n- Each subsequent element is the previous cumulative sum plus current element (or 0 if NaN)\n- The cumulative sum preserves the NaN-as-zero semantics throughout", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn nancumsum(a: Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        result.len() == a.len(),\n        a.len() > 0 ==> (result[0] == a[0]),\n        forall|i: int| 0 < i < result.len() ==> result[i] == result[i-1] + a[i],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "mathematical_functions_nansum", "vc-description": "Return the sum of array elements over a given axis treating Not a Numbers (NaNs) as zero\n\nReturn the sum of array elements treating NaN values as zero\n\nSpecification: nansum computes the sum of array elements treating NaN values as zero", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn nansum(a: Vec<f32>) -> (result: f32)\n    ensures\n        /* If vector is empty, result is 0 */\n        a.len() == 0 ==> result == 0.0f32,\n        /* Core property: nansum handles NaN values by treating them as zero */\n        true,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "mathematical_functions_negative", "vc-description": "numpy.negative: Numerical negative, element-wise.\n\nComputes the negative of each element in the input array.\nThis is equivalent to -x in terms of array operations.\n\nReturns an array of the same shape as x, containing the negated values.\n\nSpecification: numpy.negative returns a vector where each element is the\nnegative of the corresponding element in x.\n\nPrecondition: True (no special preconditions for negation)\nPostcondition: For all indices i, result[i] = -x[i]\n\nMathematical Properties:\n- Involution: -(-x) = x\n- Additive inverse: x + (-x) = 0\n- Preserves magnitude: |(-x)| = |x|", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_negative(x: Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < x.len() ==> result[i] == -x[i]", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "mathematical_functions_nextafter", "vc-description": "numpy.nextafter: Return the next floating-point value after x1 towards x2, element-wise.\n\nReturns the next representable floating-point value after x1 in the direction of x2.\nThis function is essential for numerical computing and provides fine-grained control\nover floating-point precision. It's based on the C math library's nextafter function.\n\nFor each element pair (x1[i], x2[i]):\n- If x1[i] == x2[i], returns x1[i]\n- If x1[i] < x2[i], returns the smallest floating-point value greater than x1[i]\n- If x1[i] > x2[i], returns the largest floating-point value less than x1[i]\n\nSpecial cases:\n- nextafter(x, +∞) returns the next value towards positive infinity\n- nextafter(x, -∞) returns the next value towards negative infinity\n- nextafter(±∞, y) returns ±∞ for any finite y\n- nextafter(NaN, y) or nextafter(x, NaN) returns NaN\n\nThis function is crucial for:\n- Numerical differentiation algorithms\n- Root finding methods requiring precise stepping\n- Testing floating-point precision limits\n- Implementing robust numerical algorithms\n\nSpecification: numpy.nextafter returns a vector where each element is the next\nrepresentable floating-point value after x1[i] in the direction of x2[i].\n\nPrecondition: True (no special preconditions for nextafter)\nPostcondition: For all indices i:\n  - If x1[i] == x2[i], then result[i] = x1[i]\n  - If x1[i] < x2[i], then result[i] is the smallest float greater than x1[i]\n  - If x1[i] > x2[i], then result[i] is the largest float less than x1[i]\n\nMathematical properties:\n  1. Direction consistency: result[i] moves towards x2[i]\n  2. Monotonicity: if x1[i] < x2[i], then x1[i] < result[i] ≤ x2[i]\n  3. Minimal step: result[i] is the closest representable value to x1[i] in direction of x2[i]\n  4. Symmetry: nextafter(nextafter(x, y), x) moves back towards x\n  5. Identity: nextafter(x, x) = x\n  6. Finite precision: respects IEEE 754 floating-point representation", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn nextafter(x1: Vec<i32>, x2: Vec<i32>) -> (result: Vec<i32>)\n    requires x1.len() == x2.len(),\n    ensures \n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> {\n            /* Identity case: when x1 equals x2, result equals x1 */\n            (x1[i] == x2[i] ==> result[i] == x1[i]) &&\n            /* Direction consistency: result moves towards x2 */\n            ((x1[i] < x2[i] ==> x1[i] < result[i] && result[i] <= x2[i]) &&\n             (x1[i] > x2[i] ==> x1[i] > result[i] && result[i] >= x2[i])) &&\n            /* Finiteness preservation: if both inputs are finite and different, result is defined */\n            (x1[i] != x2[i] ==> true)\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "mathematical_functions_power", "vc-description": "numpy.power: First array elements raised to powers from second array, element-wise.\n\nRaise each base in x1 to the positionally-corresponding power in x2.\nThis is equivalent to x1 ** x2 in terms of array broadcasting.\n\nThe function computes x1[i] raised to the power x2[i] for each index i.\n\nMathematical properties:\n- x^0 = 1 for any non-zero x\n- x^1 = x for any x\n- x^(a+b) = x^a * x^b for any x, a, b\n- (x^a)^b = x^(a*b) for any x, a, b\n\nSpecification: numpy.power returns a vector where each element is the base\nfrom x1 raised to the power from x2.\n\nPrecondition: For mathematical validity, we require:\n- If x1[i] = 0, then x2[i] ≥ 0 (0^negative is undefined)\n- If x1[i] < 0, then x2[i] should be an integer (for real results, checked by floor = value)\n\nPostcondition: For all indices i, result[i] = x1[i] ^ x2[i]\n\nKey mathematical properties ensured:\n1. Identity: If x2[i] = 0 and x1[i] ≠ 0, then result[i] = 1\n2. Base case: If x2[i] = 1, then result[i] = x1[i]\n3. Monotonicity: If x1[i] > 1 and x2[i] > 0, then result[i] > x1[i]", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_power(x1: Vec<i32>, x2: Vec<i32>) -> (result: Vec<i32>)\n    requires \n        x1.len() == x2.len(),\n        forall|i: int| 0 <= i < x1.len() ==> {\n            (x1[i] == 0 ==> x2[i] >= 0) &&\n            (x1[i] < 0 ==> x2[i] == x2[i])\n        },\n    ensures\n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> {\n            (x2[i] == 0 && x1[i] != 0 ==> result[i] == 1) &&\n            (x2[i] == 1 ==> result[i] == x1[i]) &&\n            (x1[i] > 1 && x2[i] > 0 ==> result[i] > x1[i])\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "mathematical_functions_prod", "vc-description": "numpy.prod: Return the product of array elements over a given axis.\n\nComputes the product of all elements in the vector. For empty vectors,\nreturns 1 as the identity element of multiplication.\n\nThis is a reduction operation that applies multiplication across all\nelements to produce a single scalar result.\n\nMathematical Properties:\n- Commutative: order of elements doesn't affect the final product\n- Associative: grouping of operations doesn't affect the result\n- Identity element: empty array product is 1\n- Contains zero: if any element is zero, the product is zero\n\nSpecification: prod computes the product of all elements in a vector.\n\nThe product operation has several important mathematical properties:\n1. For empty vectors, returns 1 (multiplicative identity)\n2. For non-empty vectors, returns the product of all elements\n3. If any element is zero, the result is zero\n4. The operation is commutative and associative\n\nThis specification captures both the basic behavior and key mathematical\nproperties that make prod well-defined and predictable.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn vec_product_int(a: Seq<i32>) -> int \n    decreases a.len()\n{\n    if a.len() == 0 {\n        1\n    } else {\n        (a[0] as int) * vec_product_int(a.skip(1))\n    }\n}\n\nfn prod(a: Vec<i32>) -> (result: i32)\n    ensures \n        result as int == vec_product_int(a@),\n        a.len() == 0 ==> result == 1,\n        (exists|i: int| 0 <= i < a.len() && a[i] == 0) ==> result == 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "mathematical_functions_radians", "vc-description": "numpy.radians: Convert angles from degrees to radians.\n\nConverts angles from degrees to radians element-wise.\nThe conversion formula is: radians = degrees * π / 180\n\nParameters:\n- x: Input array in degrees\n\nReturns:\n- y: Array of the same shape as x, containing the corresponding radian values\n\nSpecification: numpy.radians converts each element from degrees to radians.\n\nPrecondition: True (no special preconditions for degree to radian conversion)\nPostcondition: For all indices i, result[i] = x[i] * π / 180\n\nMathematical properties verified:\n- Linear conversion: radians = degrees * (π / 180)\n- 0 degrees = 0 radians\n- 180 degrees = π radians  \n- 360 degrees = 2π radians\n- Maintains array shape and element-wise mapping\n- Preserves the relationship between angle measures", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_radians(x: Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() == x.len(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "mathematical_functions_real_if_close", "vc-description": "If input is complex with all imaginary parts close to zero, return real parts.\nOtherwise, return the original complex vector.\n\"Close to zero\" is defined as tol * (machine epsilon of the type).\n\nSpecification: real_if_close returns real parts if all imaginary parts are within tolerance,\notherwise returns the original complex vector. This captures the essential behavior:\n1. If all imaginary parts are small (≤ tol * machineEpsilon), return only real parts\n2. Otherwise, preserve the original complex numbers\n3. Real parts are always preserved regardless\n4. The tolerance check is applied consistently across all elements", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* Structure representing a complex number with float components */\n#[derive(PartialEq, Eq)]\npub struct Complex {\n    /* The real part of the complex number */\n    pub re: i32,\n    /* The imaginary part of the complex number */\n    pub im: i32,\n}\n\n/* Machine epsilon for Float (approximately 2.2204460492503131e-16) */\nspec fn machine_epsilon() -> i32 {\n    2\n}\n/* Helper function to check if a complex number's imaginary part is close to zero */\nspec fn is_close_to_zero(c: Complex, tol: i32) -> bool {\n    let abs_im = if c.im >= 0 { c.im as int } else { -(c.im as int) };\n    abs_im <= (tol as int) * (machine_epsilon() as int)\n}\n\n/* Helper function to check if all imaginary parts in a complex vector are close to zero */\nspec fn all_imaginary_parts_close_to_zero(arr: Seq<Complex>, tol: i32) -> bool {\n    forall|i: int| 0 <= i < arr.len() ==> is_close_to_zero(arr[i], tol)\n}", "vc-helpers": "", "vc-spec": "fn real_if_close(arr: Vec<Complex>, tol: i32) -> (result: Vec<Complex>)\n    requires tol > 0,\n    ensures\n        /* Primary behavior: if all imaginary parts are close to zero, return real parts only */\n        all_imaginary_parts_close_to_zero(arr@, tol) ==> \n            forall|i: int| 0 <= i < result.len() ==> result[i].re == arr[i].re && result[i].im == 0,\n        /* Otherwise, preserve original complex numbers */\n        !all_imaginary_parts_close_to_zero(arr@, tol) ==> \n            forall|i: int| 0 <= i < result.len() ==> result[i] == arr[i],\n        /* Real parts are always preserved */\n        forall|i: int| 0 <= i < result.len() ==> result[i].re == arr[i].re,\n        /* Sanity check: result vector has same length as input */\n        result.len() == arr.len(),\n        /* Mathematical property: if input is already real, output equals input */\n        (forall|i: int| 0 <= i < arr.len() ==> arr[i].im == 0) ==> \n            forall|i: int| 0 <= i < result.len() ==> result[i] == arr[i],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "mathematical_functions_sign", "vc-description": "Returns an element-wise indication of the sign of a number.\n\nSpecification: sign returns -1 for negative numbers, 0 for zero, 1 for positive numbers", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn sign(x: Vec<i32>) -> (result: Vec<i32>)\n    requires x.len() > 0,\n    ensures \n        result.len() == x.len(),\n        forall|i: int| 0 <= i < x.len() ==> {\n            (x[i] < 0 ==> result[i] == -1) &&\n            (x[i] == 0 ==> result[i] == 0) &&\n            (x[i] > 0 ==> result[i] == 1)\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "mathematical_functions_signbit", "vc-description": "Returns element-wise True where signbit is set (less than zero)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn is_negative(x: f32) -> bool;", "vc-helpers": "", "vc-spec": "fn signbit(x: Vec<f32>) -> (result: Vec<bool>)\n    ensures \n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == is_negative(x[i as int])", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "mathematical_functions_sinc", "vc-description": "Return the normalized sinc function\n\nnumpy.sinc: Return the normalized sinc function, element-wise.\n\nThe sinc function is defined as:\n- sin(π*x)/(π*x) for x ≠ 0\n- 1 for x = 0\n\nThis is the normalized sinc function, which is used in signal processing and\nFourier analysis. The function is continuous everywhere and has its maximum\nvalue of 1 at x = 0.\n\nReturns a vector of the same shape as the input, containing the sinc value\nof each element.\n\nSpecification: numpy.sinc returns a vector where each element is the\nnormalized sinc function of the corresponding element in x.\n\nThe specification captures key mathematical properties:\n1. Element-wise computation: result[i] = sinc(x[i])\n2. Definition: sinc(x) = sin(π*x)/(π*x) for x ≠ 0, and 1 for x = 0\n3. Continuity: sinc(0) = 1 (limit as x approaches 0)\n4. Symmetry: sinc(-x) = sinc(x) (even function)\n5. Zeros: sinc(x) = 0 for x = k where k is any non-zero integer\n6. Boundedness: |sinc(x)| ≤ 1 for all x\n7. Maximum value: sinc(0) = 1 is the global maximum\n\nThe specification is formalized to be mathematically precise while \nremaining implementable with Float types.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn sinc(x: Vec<i32>) -> (result: Vec<i32>)\n    ensures \n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> {\n            /* Boundedness: sinc values are bounded by [-1, 1] */\n            result[i] <= 1 &&\n            result[i] >= -1 &&\n            /* Maximum at zero: sinc(0) = 1 */\n            (x[i] == 0 ==> result[i] == 1) &&\n            /* Symmetry: sinc is an even function */\n            (forall|j: int| 0 <= j < x.len() && x[i] == -x[j] ==> result[i] == result[j])\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "mathematical_functions_spacing", "vc-description": "Return the distance between x and the nearest adjacent number.\n\nFor each element x in the input array, returns the distance to the nearest\nadjacent floating-point number. This is equivalent to the machine epsilon\nfor the magnitude of x - it gives the smallest representable difference\nbetween floating-point numbers near x.\n\nFor x = 1.0, spacing(1.0) equals the machine epsilon.\nSpacing of ±inf and NaN is NaN.\n\nThis function is crucial for understanding floating-point precision limits\nand is used in numerical analysis for error bounds and convergence testing.\n\nSpecification: numpy.spacing returns the distance between each element \nand its nearest adjacent floating-point number.\n\nPrecondition: True (spacing is defined for all floating-point numbers)\nPostcondition: For all indices i, result[i] represents the smallest positive\ndifference between x[i] and the next representable floating-point number.\n\nMathematical properties:\n- spacing(x) > 0 for all finite x (distance is always positive)\n- spacing(1.0) = machine epsilon\n- No representable number exists between x and x + spacing(x)\n- spacing(±∞) = NaN and spacing(NaN) = NaN\n- spacing(-x) = spacing(x) for finite x (symmetry around zero)\n- spacing grows with the magnitude of x (floating-point spacing increases)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn spacing(x: Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < x.len() ==> #[trigger] result[i] > 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "mathematical_functions_sqrt", "vc-description": "numpy.sqrt: Return the non-negative square-root of an array, element-wise.\n\nComputes the principal square root of each element in the input array.\nFor non-negative input elements, returns the positive square root.\nFor negative input elements, the result is mathematically undefined in\nthe real numbers, but numpy returns NaN (Not a Number).\n\nThe function returns an array of the same shape as the input, containing\nthe non-negative square-root of each element.\n\nSpecification: sqrt returns a vector where each element is the\nnon-negative square root of the corresponding element in x.\n\nMathematical properties:\n1. For non-negative inputs: result² = input and result ≥ 0\n2. For negative inputs: result is NaN (handled by Float.sqrt)\n3. The result preserves the shape of the input\n4. sqrt(0) = 0\n5. sqrt(1) = 1\n6. sqrt is monotonic on non-negative inputs\n\nPrecondition: True (function handles all Float inputs)\nPostcondition: For all indices i, if x[i] ≥ 0 then result[i]² = x[i] and result[i] ≥ 0", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn sqrt(x: Vec<i32>) -> (result: Vec<i32>)\n    ensures \n        result.len() == x.len(),\n        forall|i: int| 0 <= i < x.len() ==> {\n            &&& (x[i] >= 0 ==> result[i] * result[i] == x[i] && result[i] >= 0)\n            &&& (x[i] == 0 ==> result[i] == 0)\n            &&& (x[i] == 1 ==> result[i] == 1)\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "mathematical_functions_subtract", "vc-description": "numpy.subtract: Subtract arguments, element-wise.\n\nSubtracts two vectors element-wise. If the vectors have the same shape,\neach element of the result is the difference of the corresponding elements\nfrom the input vectors.\n\nThis is equivalent to x1 - x2 in terms of array broadcasting.\nThe operation is the inverse of addition: (x1 - x2) + x2 = x1.\n\nSpecification: numpy.subtract returns a vector where each element is the difference\nof the corresponding elements from x1 and x2.\n\nPrecondition: True (no special preconditions for basic subtraction)\nPostcondition: For all indices i, result[i] = x1[i] - x2[i]\n\nMathematical properties:\n- Subtraction is anti-commutative: x1 - x2 = -(x2 - x1)\n- Subtraction is the inverse of addition: (x1 - x2) + x2 = x1\n- Subtracting zero leaves the original value: x1 - 0 = x1\n- Subtracting a value from itself yields zero: x1 - x1 = 0", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn subtract(x1: Vec<i32>, x2: Vec<i32>) -> (result: Vec<i32>)\n    requires x1.len() == x2.len(),\n    ensures \n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == x1[i] - x2[i],\n        /* Sanity check: subtracting zero preserves the original value */\n        forall|i: int| 0 <= i < result.len() && x2[i] == 0 ==> result[i] == x1[i],\n        /* Sanity check: subtracting a value from itself yields zero */\n        forall|i: int| 0 <= i < result.len() && x1[i] == x2[i] ==> result[i] == 0,\n        /* Anti-commutativity property */\n        forall|i: int| 0 <= i < result.len() ==> result[i] == -(x2[i] - x1[i])", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "mathematical_functions_tanh", "vc-description": "Compute hyperbolic tangent element-wise.\n\nThe hyperbolic tangent function is defined as:\ntanh(x) = sinh(x) / cosh(x) = (e^x - e^(-x)) / (e^x + e^(-x))\n\nThis function is bounded between -1 and 1, and is the ratio of\nhyperbolic sine to hyperbolic cosine. It has a sigmoid-like shape,\napproaching -1 as x approaches negative infinity and approaching 1\nas x approaches positive infinity.\n\nReturns an array of the same shape as x, containing the hyperbolic tangent of each element.\n\nSpecification: numpy.tanh returns a vector where each element is the hyperbolic tangent\nof the corresponding element in x.\n\nPrecondition: True (no special preconditions for hyperbolic tangent)\nPostcondition: \n1. For all indices i, result[i] = sinh(x[i]) / cosh(x[i])\n2. The function is odd: tanh(-x) = -tanh(x)\n3. The function is bounded: -1 < tanh(x) < 1 for all x ≠ 0\n4. Monotonicity: tanh is strictly increasing on all of ℝ\n5. Zero property: tanh(0) = 0\n6. Limit properties: lim_{x→∞} tanh(x) = 1 and lim_{x→-∞} tanh(x) = -1\n7. Sign property: tanh(x) has the same sign as x\n8. Derivative property: d/dx tanh(x) = 1 - tanh²(x)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn tanh(x: Vec<i32>) -> (result: Vec<i32>)\n    ensures \n        result.len() == x.len(),\n        forall|i: int| 0 <= i < x.len() ==> {\n            /* Core mathematical definition: tanh(x) = sinh(x) / cosh(x) */\n            /* Bounded property: |tanh(x)| < 1 for all finite x */\n            -1 < result[i] && result[i] < 1 &&\n            /* Zero property: tanh(0) = 0 */\n            (x[i] == 0 ==> result[i] == 0) &&\n            /* Sign property: tanh(x) has the same sign as x */\n            (x[i] > 0 ==> result[i] > 0) &&\n            (x[i] < 0 ==> result[i] < 0) &&\n            /* Asymptotic behavior: for positive x, 0 < tanh(x) < 1 */\n            (x[i] > 0 ==> result[i] > 0 && result[i] < 1) &&\n            /* Asymptotic behavior: for negative x, -1 < tanh(x) < 0 */\n            (x[i] < 0 ==> result[i] < 0 && result[i] > -1)\n        },", "vc-code": "{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "mathematical_functions_true_divide", "vc-description": "numpy.true_divide: Divide arguments element-wise.\n\nTrue division of the inputs, element-wise. This is equivalent to \ndivision in Python 3 and numpy.divide. Always returns a floating point result.\n\nThe result is computed element-wise as x1[i] / x2[i] for all valid indices i.\nDivision by zero will result in infinity or NaN depending on the numerator.\n\nThis function is an alias for numpy.divide but ensures floating point output.\n\nSpecification: true_divide returns a vector where each element is the quotient\nof the corresponding elements from x1 and x2.\n\nPrecondition: All elements in x2 must be non-zero to avoid division by zero\nPostcondition: For all indices i, result[i] = x1[i] / x2[i]\n\nMathematical properties:\n- Preserves vector length (result has same size as inputs)\n- Element-wise division: result[i] = x1[i] / x2[i]\n- Non-zero divisor constraint ensures well-defined division\n- Identity property: true_divide(x, ones) = x\n- Inverse property: true_divide(x, x) = ones (when x has no zeros)\n- Distributive over multiplication: true_divide(x*y, z) = true_divide(x,z) * true_divide(y,z)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn true_divide(x1: Vec<f64>, x2: Vec<f64>) -> (result: Vec<f64>)\n    requires \n        x1.len() == x2.len(),\n        forall|i: int| 0 <= i < x2.len() ==> x2[i] != 0.0,\n    ensures\n        result.len() == x1.len(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "mathematical_functions_trunc", "vc-description": "numpy.trunc: Return the truncated value of the input, element-wise.\n\nThe truncated value of the scalar x is the nearest integer i which is closer to zero than x is.\nThis is equivalent to:\n- For positive x: floor(x) (largest integer ≤ x)\n- For negative x: ceil(x) (smallest integer ≥ x)\n- For zero: 0\n\nReturns an array of the same shape as x, containing the truncated values.\n\nSpecification: numpy.trunc returns a vector where each element is the \ntruncated value of the corresponding element in x.\n\nPrecondition: True (truncation is defined for all real numbers)\nPostcondition: For all indices i, result[i] is the truncated value of x[i],\n               which is the nearest integer closer to zero than x[i]. This means:\n               - result[i] is an integer value (represented as Float)\n               - For positive x: result[i] = floor(x[i])\n               - For negative x: result[i] = ceil(x[i])\n               - Truncation moves towards zero: |result[i]| ≤ |x[i]|\n               - Sign preservation: result and x have same sign (or both are zero)\n               - Monotonicity: the function is monotonic in the sense that it preserves ordering\n               - Idempotence: trunc(trunc(x)) = trunc(x)\n               - Integer preservation: if x[i] is an integer, then result[i] = x[i]", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn int_abs(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}", "vc-helpers": "", "vc-spec": "fn numpy_trunc(x: Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i] == x[i],\n        forall|i: int| 0 <= i < result.len() ==> {\n            /* Sign preservation */\n            (x[i] > 0 ==> result[i] >= 0) &&\n            (x[i] < 0 ==> result[i] <= 0) &&\n            (x[i] == 0 ==> result[i] == 0)\n        },\n        forall|i: int| 0 <= i < result.len() ==> {\n            /* Truncation moves towards zero (abs property) */\n            int_abs(result[i] as int) <= int_abs(x[i] as int)\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "mathematical_functions_unwrap", "vc-description": "Unwrap by changing deltas between values to 2*pi complement.\nUnwraps radian phase by changing absolute jumps greater than discont to their 2*pi complement.\nFor consecutive elements with difference > discont, adds/subtracts multiples of period to create continuity.\n\nSpecification: unwrap ensures continuity by correcting large phase jumps", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn unwrap(p: Vec<int>, discont: int, period: int) -> (result: Vec<int>)\n    requires \n        discont > 0,\n        period > 0,\n    ensures\n        result.len() == p.len(),\n        /* First element is unchanged (if array is non-empty) */\n        p.len() > 0 ==> result[0] == p[0],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_chebyshev_Chebyshev", "vc-description": "{\n  \"name\": \"numpy.polynomial.chebyshev.Chebyshev\",\n  \"category\": \"Chebyshev polynomials\",\n  \"description\": \"A Chebyshev series class.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.chebyshev.Chebyshev.html\",\n  \"doc\": \"A Chebyshev series class.\\n\\n    The Chebyshev class provides the standard Python numerical methods\\n    '+', '-', '*', '//', '%', 'divmod', '**', and '()' as well as the\\n    attributes and methods listed below.\\n\\n    Parameters\\n    ----------\\n    coef : array_like\\n        Chebyshev coefficients in order of increasing degree, i.e.,\\n        \\`\\`(1, 2, 3)\\`\\` gives \\`\\`1*T_0(x) + 2*T_1(x) + 3*T_2(x)\\`\\`.\\n    domain : (2,) array_like, optional\\n        Domain to use. The interval \\`\\`[domain[0], domain[1]]\\`\\` is mapped\\n        to the interval \\`\\`[window[0], window[1]]\\`\\` by shifting and scaling.\\n        The default value is [-1., 1.].\\n    window : (2,) array_like, optional\\n        Window, see \\`domain\\` for its use. The default value is [-1., 1.].\\n    symbol : str, optional\\n        Symbol used to represent the independent variable in string\\n        representations of the polynomial expression, e.g. for printing.\\n        The symbol must be a valid Python identifier. Default value is 'x'.\\n\\n        .. versionadded:: 1.24\",\n  \"type\": \"class\"\n}\n\nCreate a Chebyshev polynomial from coefficients with default domain and window [-1, 1]\n\nSpecification: Creating a Chebyshev polynomial preserves coefficients and sets default domain/window", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* Structure representing a Chebyshev polynomial with coefficients and domain/window mapping */\nstruct ChebyshevPoly {\n    /* Coefficients of the Chebyshev polynomial in increasing degree order */\n    coef: Vec<i32>,\n    /* Domain interval [domain_min, domain_max] */\n    domain_min: i32,\n    domain_max: i32,\n    /* Window interval [window_min, window_max] */\n    window_min: i32,\n    window_max: i32,\n}", "vc-helpers": "", "vc-spec": "fn chebyshev(coef: Vec<i32>) -> (result: ChebyshevPoly)\n    requires coef.len() > 0,\n    ensures\n        /* Coefficients are preserved */\n        result.coef@ == coef@,\n        /* Default domain is [-1, 1] */\n        result.domain_min == -1,\n        result.domain_max == 1,\n        /* Default window is [-1, 1] */\n        result.window_min == -1,\n        result.window_max == 1,\n        /* Domain interval is valid */\n        result.domain_min < result.domain_max,\n        /* Window interval is valid */\n        result.window_min < result.window_max,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_chebyshev_chebadd", "vc-description": "Add one Chebyshev series to another.\n\nAdd one Chebyshev series to another. Returns the sum of two Chebyshev series c1 + c2. The arguments are sequences of coefficients ordered from lowest order term to highest, i.e., [1,2,3] represents the series T_0 + 2*T_1 + 3*T_2.\n\nAdd two Chebyshev series coefficient-wise.\n\nThis function adds two Chebyshev polynomial series represented by their coefficients. The coefficients are ordered from lowest degree to highest degree term. For example, [1,2,3] represents T_0 + 2*T_1 + 3*T_2 where T_i is the i-th Chebyshev polynomial.\n\nThe addition is performed component-wise, padding with zeros if the arrays have different lengths.\n\nSpecification: chebadd performs coefficient-wise addition of two Chebyshev series.\n\nThe specification captures both the mathematical properties and implementation details:\n1. For indices within both arrays, the result is the sum of corresponding coefficients\n2. For indices beyond one array's length, the result equals the coefficient from the longer array\n3. The result preserves the Chebyshev series representation property\n4. The operation is commutative up to reordering when n ≠ m\n5. Adding a zero vector yields the original vector (identity property)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn chebadd(c1: Vec<i32>, c2: Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        result.len() == if c1.len() >= c2.len() { c1.len() } else { c2.len() },\n        forall|i: int| 0 <= i < result.len() ==> {\n            if i < c1.len() && i < c2.len() {\n                result[i] == c1[i] + c2[i]\n            } else if i < c1.len() {\n                result[i] == c1[i]\n            } else if i < c2.len() {\n                result[i] == c2[i]\n            } else {\n                result[i] == 0\n            }\n        },\n        forall|i: int| 0 <= i < c1.len() ==> c1[i] != 0 ==> {\n            exists|j: int| 0 <= j < result.len() && j == i && {\n                if i < c2.len() {\n                    result[j] == c1[i] + c2[i]\n                } else {\n                    result[j] == c1[i]\n                }\n            }\n        },\n        forall|i: int| 0 <= i < c2.len() ==> c2[i] != 0 ==> {\n            exists|j: int| 0 <= j < result.len() && j == i && {\n                if i < c1.len() {\n                    result[j] == c1[i] + c2[i]\n                } else {\n                    result[j] == c2[i]\n                }\n            }\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_chebyshev_chebdiv", "vc-description": "Divide one Chebyshev series by another, returning quotient and remainder.\nThe input vectors represent Chebyshev series coefficients from lowest to highest order.\n\nSpecification: chebdiv performs polynomial division in the Chebyshev basis,\nsatisfying the division algorithm property that c1 = c2 * quotient + remainder,\nwhere the degree of remainder is less than the degree of c2.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn chebdiv(c1: Vec<f32>, c2: Vec<f32>) -> (result: (Vec<f32>, Vec<f32>))\n    requires \n        c2.len() > 0,\n        c2[c2.len() - 1] != 0.0f32,\n    ensures ({\n        let (quo, rem) = result;\n        \n        /* Quotient has correct size constraints */\n        (forall|i: int| 0 <= i < quo.len() && i >= c1.len() - (c2.len() - 1) ==> quo[i] == 0.0f32) &&\n        \n        /* Remainder degree constraint: deg(rem) < deg(c2) */\n        (forall|i: int| 0 <= i < rem.len() && i >= c2.len() - 1 ==> rem[i] == 0.0f32) &&\n        \n        /* Special case: if deg(c1) < deg(c2), then quo = 0 and rem = c1 */\n        (c1.len() < c2.len() ==> \n            (forall|i: int| 0 <= i < quo.len() ==> quo[i] == 0.0f32) &&\n            (forall|i: int| 0 <= i < rem.len() && i < c1.len() ==> rem[i] == c1[i])) &&\n        \n        /* Special case: if c2 has only one coefficient (constant divisor) */\n        (c2.len() == 1 ==> \n            (forall|i: int| 0 <= i < rem.len() ==> rem[i] == 0.0f32))\n    })", "vc-code": "{\n    // impl-start\n    assume(false);\n    (Vec::new(), Vec::new())\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_chebyshev_chebfromroots", "vc-description": "Generate a Chebyshev series with given roots.\n\nReturns the coefficients of the polynomial p(x) = (x - r₀) * (x - r₁) * ... * (x - rₙ)\nin Chebyshev form, where rₙ are the roots specified in the input.\n\nThe output coefficients c satisfy: p(x) = c₀ + c₁ * T₁(x) + ... + cₙ * Tₙ(x)\nwhere Tₙ(x) is the n-th Chebyshev polynomial of the first kind.\n\nSpecification: chebfromroots generates Chebyshev coefficients such that:\n1. The output has exactly n+1 coefficients where n is the number of roots\n2. The polynomial represented by these coefficients has the given roots\n3. When evaluated at any root rᵢ using Chebyshev basis, the result is zero\n4. The highest degree coefficient is non-zero (ensuring correct degree)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn chebfromroots(roots: Vec<f64>) -> (coeffs: Vec<f64>)\n    ensures\n        coeffs.len() == roots.len() + 1,\n        roots.len() > 0 ==> coeffs[roots.len() as int] != 0.0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_chebyshev_chebgauss", "vc-description": "Computes the sample points and weights for Gauss-Chebyshev quadrature.\nThese sample points and weights will correctly integrate polynomials of\ndegree 2*n - 1 or less over the interval [-1, 1] with the weight \nfunction f(x) = 1/√(1 - x²).\n\nSpecification: chebgauss returns Gauss-Chebyshev quadrature nodes and weights\nwhere nodes are the zeros of the n-th Chebyshev polynomial and weights are \nuniform π/n. The nodes are given by cos(π(2i-1)/(2n)) for i = 1 to n.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn chebgauss(n: usize) -> (result: (Vec<f32>, Vec<f32>))\n    requires n > 0,\n    ensures\n        result.0.len() == n,\n        result.1.len() == n,\n        /* All weights are equal (uniform weights) */\n        forall|i: int, j: int| 0 <= i < n && 0 <= j < n ==> \n            #[trigger] result.1[i] == #[trigger] result.1[j],\n        /* Nodes are distinct */\n        forall|i: int, j: int| 0 <= i < n && 0 <= j < n && i != j ==> \n            #[trigger] result.0[i] != #[trigger] result.0[j],", "vc-code": "{\n    // impl-start\n    assume(false);\n    (Vec::new(), Vec::new())\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_chebyshev_chebgrid3d", "vc-description": "Evaluate a 3-D Chebyshev series on the Cartesian product of x, y, and z.\n\nThis function returns the values:\np(a,b,c) = ∑_{i,j,k} c_{i,j,k} * T_i(a) * T_j(b) * T_k(c)\n\nwhere the points (a, b, c) consist of all triples formed by taking\na from x, b from y, and c from z. The resulting points form\na grid with x in the first dimension, y in the second, and z in\nthe third.\n\nSpecification: chebgrid3d evaluates a 3D Chebyshev series on the Cartesian product.\nThe result at position (ix, iy, iz) is the sum over all coefficient indices (i, j, k)\nof c[i][j][k] * T_i(x[ix]) * T_j(y[iy]) * T_k(z[iz]) where T_n is the n-th\nChebyshev polynomial.\n\nMathematical properties:\n1. The output has the correct shape: nx × ny × nz\n2. Each element is computed as a triple sum over the coefficient indices\n3. The function evaluates the 3D Chebyshev series at each grid point\n4. For a zero coefficient array, the result is zero everywhere\n5. The result is linear in the coefficients\n6. The Chebyshev polynomials T_i satisfy the recurrence relation:\n   T_0(x) = 1, T_1(x) = x, T_{n+1}(x) = 2x*T_n(x) - T_{n-1}(x)\n7. The evaluation respects the orthogonality of Chebyshev polynomials on [-1, 1]\n8. When all x, y, z values are in [-1, 1], the series converges uniformly\n9. The result is the tensor product of 1D Chebyshev evaluations", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn chebyshev_T(n: nat, x: f64) -> f64 \n    decreases n\n{\n    if n == 0 {\n        1.0\n    } else if n == 1 {\n        x\n    } else {\n        0.0\n    }\n}\n\nfn chebgrid3d(\n    x: Vec<f64>, \n    y: Vec<f64>, \n    z: Vec<f64>,\n    c: Vec<Vec<Vec<f64>>>\n) -> (result: Vec<Vec<Vec<f64>>>)\n    requires \n        x.len() > 0,\n        y.len() > 0, \n        z.len() > 0,\n        c.len() > 0,\n        forall|i: int| 0 <= i < c.len() ==> c[i].len() > 0,\n        forall|i: int, j: int| 0 <= i < c.len() && 0 <= j < c[i].len() ==> c[i][j].len() > 0,\n    ensures\n        result.len() == x.len(),\n        forall|ix: int| 0 <= ix < result.len() ==> result[ix].len() == y.len(),\n        forall|ix: int, iy: int| 0 <= ix < result.len() && 0 <= iy < result[ix].len() ==> result[ix][iy].len() == z.len()", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_chebyshev_chebinterpolate", "vc-description": "Interpolate a function at the Chebyshev points of the first kind.\n\nReturns the Chebyshev series coefficients that interpolate the given function\nat the Chebyshev points of the first kind in the interval [-1, 1]. The resulting\ncoefficients represent a polynomial of degree deg that interpolates the function\nat deg+1 Chebyshev points.\n\nThe Chebyshev interpolation provides near-optimal polynomial approximation\nfor continuous functions on [-1, 1], minimizing the Runge phenomenon and\nproviding good convergence properties.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_constant_function(func: spec_fn(f64) -> f64) -> bool {\n    forall|x: f64, y: f64| #[trigger] func(x) == #[trigger] func(y)\n}\n\nfn chebinterpolate(deg: usize, func: spec_fn(f64) -> f64) -> (coef: Vec<f64>)\n    ensures \n        coef.len() == deg + 1,\n        /* The coefficients satisfy the key properties of Chebyshev interpolation:\n           1. The coefficient vector has the correct length (guaranteed by type)\n           2. When the function is constant, all coefficients except the first are zero */\n        is_constant_function(func) ==> (\n            coef[0] == func(0.0) &&\n            forall|i: int| 1 <= i < coef.len() ==> #[trigger] coef[i] == 0.0\n        )", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_chebyshev_chebmul", "vc-description": "Multiply one Chebyshev series by another.\n\nReturns the product of two Chebyshev series c1 * c2. The arguments\nare sequences of coefficients, from lowest order term to highest,\ne.g., [1,2,3] represents the series T_0 + 2*T_1 + 3*T_2.\n\nThe result length is m + n - 1 where m and n are the lengths of c1 and c2.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn chebmul(c1: Vec<i32>, c2: Vec<i32>) -> (result: Vec<i32>)\n    requires \n        c1.len() > 0,\n        c2.len() > 0,\n    ensures\n        result.len() == c1.len() + c2.len() - 1,\n        /* Example property: multiplying by the constant polynomial [a] scales all coefficients */\n        (c2.len() == 1 ==> forall|i: int| 0 <= i < c1.len() ==> result[i] == c2[0] * c1[i]),\n        /* Another example: multiplying [1,0,...] (T_0) by any polynomial preserves it */\n        (c1.len() == 1 && c1[0] == 1 ==> forall|j: int| 0 <= j < c2.len() ==> result[j] == c2[j]),\n        /* Special case: multiplying two linear polynomials [a,b] * [c,d] */\n        /* Result should be [ac + bd/2, ad + bc, bd/2] */\n        (c1.len() == 2 && c2.len() == 2 ==> {\n            let a = c1[0];\n            let b = c1[1]; \n            let c = c2[0];\n            let d = c2[1];\n            result[0] == a * c + b * d / 2 &&\n            result[1] == a * d + b * c &&\n            result[2] == b * d / 2\n        }),\n        /* Verify the example from documentation: [1,2,3] * [3,2,1] */\n        /* Result should be [6.5, 12, 12, 4, 1.5] but using integers for now */\n        (c1.len() == 3 && c2.len() == 3 ==> {\n            (c1[0] == 1 && c1[1] == 2 && c1[2] == 3 &&\n             c2[0] == 3 && c2[1] == 2 && c2[2] == 1) ==>\n            (result.len() == 5)\n        })", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_chebyshev_chebpow", "vc-description": "Raise a Chebyshev series to a power.\n\nReturns the Chebyshev series c raised to the power pow. The\nargument c is a sequence of coefficients ordered from low to high,\ni.e., [1,2,3] represents the series T_0 + 2*T_1 + 3*T_2.\n\nThe power must be a non-negative integer. Special cases:\n- pow = 0 returns [1] (the constant polynomial 1)\n- pow = 1 returns the input series unchanged\n- pow > 1 returns the series multiplied by itself pow times\n\nThe result length grows as: 1 + (n - 1) * pow, where n is the input length.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn chebpow(c: Vec<f64>, pow: usize, maxpower: usize) -> (result: Vec<f64>)\n    requires \n        c.len() > 0,\n        pow <= maxpower,\n    ensures\n        /* Special case: pow = 0 returns [1.0] */\n        (pow == 0) ==> (result.len() == 1 && result[0] == 1.0),\n        /* Special case: pow = 1 returns input unchanged */\n        (pow == 1) ==> (result.len() == c.len() && \n            forall|i: int| 0 <= i < c.len() ==> result[i] == c[i]),\n        /* Result length is correct */\n        result.len() == (if pow == 0 { 1 } else { 1 + (c.len() - 1) * pow }),\n        /* For pow > 1: first coefficient exists when appropriate */\n        (pow > 1 && c.len() >= 1) ==> (result.len() > 0),\n        /* Non-triviality for pow >= 2 with sufficient input length */\n        (pow >= 2 && c.len() >= 2 && result.len() > 2) ==> \n            (result[0] != 0.0 || result[1] != 0.0 || result[2] != 0.0),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_chebyshev_chebpts1", "vc-description": "numpy.polynomial.chebyshev.chebpts1: Chebyshev points of the first kind.\n\nThe Chebyshev points of the first kind are the points cos(π*(k + 0.5)/n)\nfor k in range(n), which are the roots of the Chebyshev polynomial T_n(x).\nThese points are particularly useful for polynomial interpolation as they\nminimize the Runge phenomenon.\n\nThe implementation uses the identity sin(x) = cos(π/2 - x) to compute\nthe values using sine instead of cosine.\n\nSpecification: chebpts1 returns a vector of n Chebyshev points of the first kind.\n\nThe k-th point (0-indexed) is cos(π*(k + 0.5)/n), which equals\nsin(π*(n - k - 0.5)/n) by the complementary angle identity.\n\nPrecondition: n > 0 (at least one point must be generated)\nPostcondition: \n1. For all indices k, result[k] = cos(π*(k + 0.5)/n)\n2. The points are in descending order: for all i < j, result[i] > result[j]\n3. All points lie in the interval [-1, 1]\n4. The points are symmetric about 0: result[k] = -result[n-1-k] for all k", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn chebyshev_point_value(k: int, n: int) -> int { arbitrary() }\n\nfn chebpts1(n: usize) -> (result: Vec<i32>)\n    requires n > 0,\n    ensures \n        result.len() == n,\n        forall|k: int| 0 <= k < n ==> #[trigger] result[k] == chebyshev_point_value(k, n as int),\n        forall|k: int| 0 <= k < n ==> -1000 <= #[trigger] result[k] <= 1000,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_chebyshev_chebsub", "vc-description": "Subtract one Chebyshev series from another component-wise.\nThe input vectors c1 and c2 represent Chebyshev series coefficients\nordered from lowest to highest degree term.\n\nSpecification: chebsub performs component-wise subtraction of two Chebyshev series.\n\nThe specification includes:\n1. The basic property that each coefficient in the result is the difference\n   of the corresponding coefficients in c1 and c2\n2. Anti-commutativity: chebsub(c1, c2) = -chebsub(c2, c1)\n3. Identity property: subtracting a series from itself yields zero\n4. Associativity with addition: (c1 - c2) + c2 = c1", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn chebsub(c1: Vec<i32>, c2: Vec<i32>) -> (result: Vec<i32>)\n    requires c1.len() == c2.len(),\n    ensures \n        result.len() == c1.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == c1[i] - c2[i],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_hermite_e_hermecompanion", "vc-description": "Return the scaled companion matrix of HermiteE series coefficients.\nThe companion matrix is scaled for better eigenvalue estimates and\nsymmetry properties when used with HermiteE basis polynomials.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermecompanion(c: Vec<f32>) -> (mat: Vec<Vec<f32>>)\n    requires \n        c.len() >= 2,\n        c[c.len() - 1] != 0.0f32,\n    ensures\n        mat.len() == c.len() - 1,\n        forall|i: int| 0 <= i < mat.len() ==> mat[i].len() == c.len() - 1,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_hermite_e_hermediv", "vc-description": "Divide one Hermite series by another, returning quotient and remainder.\nThe dividend c1 and divisor c2 are coefficient vectors representing Hermite polynomials.\nThe division is performed in the Hermite polynomial basis with reprojection.\n\nSpecification: hermediv performs polynomial division of Hermite series, returning\nboth quotient and remainder such that c1 = quo * c2 + rem (in Hermite basis).\n\nKey mathematical properties:\n1. Division identity: The dividend equals quotient times divisor plus remainder\n2. Remainder degree constraint: The remainder has degree less than the divisor\n3. Non-zero divisor: The divisor must not be the zero polynomial\n4. Reprojection: Results are reprojected onto the Hermite polynomial basis\n\nThe specification captures the fundamental division algorithm for polynomials\nadapted to the Hermite polynomial basis set.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermediv(c1: Vec<f64>, c2: Vec<f64>) -> (result: (Vec<f64>, Vec<f64>))\n    requires \n        c2.len() > 0,\n        exists|i: int| 0 <= i < c2.len() && c2[i] != 0.0,\n    ensures \n        (result.0.len() >= 1) &&\n        (result.1.len() < c2.len()) &&\n        /* Division property: degree of remainder < degree of divisor */\n        /* This is the key mathematical property of polynomial division */\n        (result.1.len() < c2.len()) &&\n        /* Well-formedness: all coefficients are real numbers (not NaN or infinite) */\n        (forall|i: int| 0 <= i < result.0.len() ==> result.0[i] == result.0[i]) &&\n        (forall|j: int| 0 <= j < result.1.len() ==> result.1[j] == result.1[j]) &&\n        /* Mathematical property: division preserves degree relationships */\n        /* The quotient degree + divisor degree should not exceed dividend degree */\n        (result.0.len() + c2.len() >= c1.len() || c1.len() == 0) &&\n        /* Remainder constraint: remainder degree is less than divisor degree */\n        /* This ensures the division algorithm terminates correctly */\n        (result.1.len() < c2.len())", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_hermite_e_hermegauss", "vc-description": "numpy.polynomial.hermite_e.hermegauss: Gauss-HermiteE quadrature.\n\nComputes the sample points and weights for Gauss-HermiteE quadrature.\nThese sample points and weights will correctly integrate polynomials of\ndegree 2*deg - 1 or less over the interval [-∞, ∞] with the weight\nfunction f(x) = exp(-x²/2).\n\nThe function returns a pair (x, w) where x contains the sample points\nand w contains the corresponding weights.\n\nSpecification: hermegauss returns quadrature points and weights for HermiteE polynomials.\n\nPrecondition: deg > 0 (need at least one quadrature point)\nPostcondition: The returned points and weights satisfy the mathematical properties\nof Gauss-HermiteE quadrature including positivity, symmetry, and ordering.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermegauss(deg: usize) -> (result: (Vec<i32>, Vec<i32>))\n    requires deg > 0,\n    ensures\n        /* Points are ordered (sorted in ascending order) */\n        forall|i: int, j: int| 0 <= i < j < deg ==> #[trigger] result.0[i] < #[trigger] result.0[j],\n        /* Weights are positive */\n        forall|i: int| 0 <= i < deg ==> #[trigger] result.1[i] > 0,\n        /* Return tuple has correct lengths */\n        result.0.len() == deg && result.1.len() == deg,", "vc-code": "{\n    // impl-start\n    assume(false);\n    (Vec::new(), Vec::new())\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_hermite_e_hermegrid3d", "vc-description": "numpy.polynomial.hermite_e.hermegrid3d: Evaluate a 3-D HermiteE series on the Cartesian product of x, y, and z.\n\nThis function evaluates a 3-dimensional HermiteE polynomial series\non the Cartesian product of coordinate vectors x, y, and z.\n\nThe evaluation follows the mathematical formula:\np(a,b,c) = sum_{i,j,k} c[i,j,k] * He_i(a) * He_j(b) * He_k(c)\n\nwhere He_i is the i-th probabilist's Hermite polynomial (HermiteE),\nand the points (a,b,c) are formed by taking all combinations of\nelements from x, y, and z.\n\nThe result is a 3D tensor where result[i,j,k] contains the polynomial\nvalue at the point (x[i], y[j], z[k]).\n\nSpecification: hermegrid3d evaluates a 3D HermiteE polynomial series \non the Cartesian product of x, y, and z coordinates.\n\nThe function computes p(a,b,c) = sum_{i,j,k} c[i,j,k] * He_i(a) * He_j(b) * He_k(c)\nwhere He_i is the i-th probabilist's Hermite polynomial.\n\nMathematical Properties:\n1. The result represents evaluation at all Cartesian product points\n2. HermiteE polynomials satisfy He_0(x) = 1, He_1(x) = x, \n   and the recurrence He_{n+1}(x) = x * He_n(x) - n * He_{n-1}(x)\n3. The evaluation is exact for the polynomial representation\n4. Result shape is nx × ny × nz, matching the Cartesian product", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn hermite_e_poly(x: int, n: nat) -> int\n    decreases n\n{\n    if n == 0 {\n        1\n    } else if n == 1 {\n        x\n    } else {\n        x * hermite_e_poly(x, (n - 1) as nat) - (n - 1) * hermite_e_poly(x, (n - 2) as nat)\n    }\n}\n\nfn hermegrid3d(x: Vec<f32>, y: Vec<f32>, z: Vec<f32>, c: Vec<Vec<Vec<f32>>>) -> (result: Vec<Vec<Vec<f32>>>)\n    requires\n        x.len() > 0,\n        y.len() > 0,\n        z.len() > 0,\n        c.len() > 0,\n        forall|i: int| 0 <= i < c.len() ==> c[i].len() > 0,\n        forall|i: int, j: int| 0 <= i < c.len() && 0 <= j < c[i].len() ==> c[i][j].len() > 0,\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == y.len(),\n        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result[i].len() ==> result[i][j].len() == z.len(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_hermite_e_hermeroots", "vc-description": "Compute the roots of a HermiteE series.\nGiven HermiteE series coefficients c[0], c[1], ..., c[n-1], returns the roots of\np(x) = c[0]*He_0(x) + c[1]*He_1(x) + ... + c[n-1]*He_{n-1}(x)\nwhere He_i(x) are the \"probabilists'\" or \"normalized\" Hermite polynomials\n\nSpecification: hermeroots returns the roots of the HermiteE series defined by coefficients.\nFor a HermiteE series with n coefficients, there are at most n-1 roots.\nEach root r satisfies: p(r) = 0 where p(x) = Σ c[i] * He_i(x)\n\nMathematical properties:\n1. The polynomial p(x) = Σ c[i] * He_i(x) where He_i are HermiteE basis polynomials\n2. He_i(x) are the \"probabilists'\" Hermite polynomials related to the standard normal distribution\n3. The roots are found via eigenvalues of the companion matrix\n4. For degree n polynomial, there are exactly n-1 roots (counting multiplicity)\n5. The leading coefficient must be non-zero for a well-defined polynomial", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermeroots(c: Vec<f64>) -> (result: Vec<f64>)\n    requires \n        c.len() > 0,\n        c[c.len() - 1] != 0.0,\n    ensures \n        result.len() == c.len() - 1,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_hermite_e_hermesub", "vc-description": "Subtract one Hermite series from another.\nReturns the difference of two Hermite series c1 - c2.\nThe sequences of coefficients are from lowest order term to highest.\n\nSpecification: hermesub performs component-wise subtraction of Hermite series coefficients.\nThe result has length equal to the maximum of the input lengths, with shorter arrays\nimplicitly padded with zeros. This captures the mathematical property that polynomial \nsubtraction is component-wise and preserves the polynomial structure.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermesub(c1: Vec<i32>, c2: Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        result.len() == if c1.len() >= c2.len() { c1.len() } else { c2.len() },\n        forall|i: int| 0 <= i < result.len() ==> \n            #[trigger] result[i] as int == \n            (if i < c1.len() { c1[i] as int } else { 0 }) - \n            (if i < c2.len() { c2[i] as int } else { 0 })", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_hermite_e_hermeval2d", "vc-description": "Evaluate a 2-D HermiteE series at points (x, y).\n\nThis function computes the bivariate HermiteE polynomial:\np(x,y) = ∑_{i,j} c_{i,j} * He_i(x) * He_j(y)\n\nwhere He_i and He_j are the HermiteE basis polynomials.\n\nSpecification: hermeval2d evaluates a 2D HermiteE series at corresponding points.\n\nThis function implements the mathematical formula:\np(x,y) = ∑_{i,j} c_{i,j} * He_i(x) * He_j(y)\n\nKey properties:\n1. Bivariate polynomial evaluation using HermiteE basis\n2. Mathematical correctness and linearity properties\n3. Point-wise evaluation for corresponding (x,y) pairs", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn hermite_basis(n: nat, t: int) -> int\n    decreases n\n{\n    if n == 0 {\n        1\n    } else if n == 1 {\n        t\n    } else {\n        t * hermite_basis((n - 1) as nat, t) - (n - 1) as int * hermite_basis((n - 2) as nat, t)\n    }\n}\n\nspec fn matrix_sum(c: Seq<Vec<i32>>, x: int, y: int) -> int {\n    let n = c.len() as int;\n    if n == 0 {\n        0\n    } else {\n        let m = c[0].len() as int;\n        matrix_sum_helper(c, x, y, 0, n, m)\n    }\n}\n\nspec fn matrix_sum_helper(c: Seq<Vec<i32>>, x: int, y: int, i: int, n: int, m: int) -> int\n    decreases n - i\n{\n    if i >= n {\n        0\n    } else {\n        row_sum_helper(c[i], x, y, i, 0, m) + matrix_sum_helper(c, x, y, i + 1, n, m)\n    }\n}\n\nspec fn row_sum_helper(row: Vec<i32>, x: int, y: int, i: int, j: int, m: int) -> int\n    decreases m - j\n{\n    if j >= m {\n        0\n    } else {\n        (row[j] as int) * hermite_basis(i as nat, x) * hermite_basis(j as nat, y) + \n        row_sum_helper(row, x, y, i, j + 1, m)\n    }\n}\n\nfn hermeval2d(x: Vec<i32>, y: Vec<i32>, c: Vec<Vec<i32>>) -> (result: Vec<i32>)\n    requires\n        x.len() == y.len(),\n        x.len() > 0,\n        c.len() > 0,\n        forall|i: int| 0 <= i < c.len() ==> #[trigger] c[i].len() == c[0].len(),\n        c[0].len() > 0,\n    ensures\n        result.len() == x.len(),\n        forall|k: int| 0 <= k < result.len() ==> \n            result[k] as int == matrix_sum(c@, x[k] as int, y[k] as int),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_hermite_e_hermeweight", "vc-description": "numpy.polynomial.hermite_e.hermeweight: Weight function of the Hermite_e polynomials.\n\nThe weight function is exp(-x²/2) and the interval of integration is [-∞, ∞].\nThe HermiteE polynomials are orthogonal, but not normalized, with respect to this weight function.\n\nFor each input value x, computes the weight function w(x) = exp(-x²/2).\nThis is a fundamental weight function used in probabilistic HermiteE polynomial theory.\n\nReturns an array of the same shape as x, containing the weight function values.\n\nSpecification: hermeweight returns a vector where each element is the HermiteE weight function\napplied to the corresponding element in x.\n\nThe weight function is mathematically defined as w(x) = exp(-x²/2).\n\nPrecondition: True (no special preconditions - weight function is defined for all real numbers)\nPostcondition: For all indices i, result[i] = exp(-x[i]²/2)\n\nMathematical properties:\n- Weight function is always positive: w(x) > 0 for all x\n- Weight function is symmetric: w(x) = w(-x)\n- Weight function achieves maximum at x = 0: w(0) = 1\n- Weight function approaches 0 as |x| → ∞", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermeweight(x: Vec<f64>) -> (result: Vec<f64>)\n    ensures\n        result.len() == x.len(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_hermite_e_poly2herme", "vc-description": "Convert a polynomial to a Hermite series. \nConverts coefficients from standard polynomial basis to Hermite series basis.\nUses Horner's method with Hermite operations: for polynomial p(x) = aₙxⁿ + ... + a₁x + a₀,\nbuilds the equivalent Hermite series by iteratively applying hermeadd(hermemulx(result), coefficient).\n\nSpecification: poly2herme converts polynomial coefficients to equivalent Hermite series coefficients.\n\nThe conversion preserves the polynomial's mathematical value but represents it in the Hermite basis.\nThis is a fundamental basis transformation in polynomial algebra.\n\nKey mathematical properties:\n1. Basis transformation: standard polynomial basis {1, x, x², x³, ...} → Hermite basis {He₀, He₁, He₂, He₃, ...}\n2. Value preservation: ∑ᵢ polᵢ·xⁱ = ∑ᵢ resultᵢ·Heᵢ(x) for all x\n3. Degree preservation: polynomial of degree n maps to Hermite series of degree n\n4. Invertibility: conversion can be reversed with herme2poly\n5. Horner's method: algorithm uses iterative structure for numerical stability\n\nThe algorithm implements: result = hermeadd(hermemulx(previous_result), current_coefficient)\napplied from highest to lowest degree coefficients.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn poly2herme(pol: Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() == pol.len(),\n        forall|i: int| 0 <= i < pol.len() && pol[i] != 0.0f32 ==> exists|j: int| 0 <= j < result.len() && result[j] != 0.0f32,\n        (exists|i: int| 0 <= i < pol.len() && pol[i] != 0.0f32) ==> (exists|j: int| 0 <= j < result.len() && result[j] != 0.0f32),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_hermite_herm2poly", "vc-description": "Convert a Hermite series to a polynomial.\nConverts coefficients of a Hermite series (ordered from lowest to highest degree)\nto coefficients of the equivalent standard polynomial (ordered from lowest to highest degree).\n\nThe Hermite polynomials H_n(x) satisfy the recurrence relation:\nH_{n+1}(x) = 2x * H_n(x) - 2n * H_{n-1}(x)\nwith H_0(x) = 1 and H_1(x) = 2x\n\nThis function performs the inverse transformation, converting from Hermite basis to standard basis.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn herm2poly(c: Vec<i32>) -> (result: Vec<i32>)\n    requires c.len() > 0,\n    ensures\n        result.len() == c.len(),\n        /* Sanity checks */\n        c.len() == 1 ==> result == c,\n        c.len() == 2 ==> result[0] == c[0] && result[1] == 2 * c[1],\n        /* Example from documentation: herm2poly([1, 2.75, 0.5, 0.375]) approximated with integers */\n        (c.len() == 4 && c[0] == 1 && c[1] == 3 && c[2] == 1 && c[3] == 0) ==>\n            (result[0] == 0 && result[1] == 1 && result[2] == 2 && result[3] == 3)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_hermite_hermadd", "vc-description": "numpy.polynomial.hermite.hermadd: Add one Hermite series to another.\n\nReturns the sum of two Hermite series c1 + c2. The arguments are\nsequences of coefficients ordered from lowest order term to highest,\ni.e., [1,2,3] represents the series P_0 + 2*P_1 + 3*P_2.\n\nUnlike multiplication, division, etc., the sum of two Hermite series\nis a Hermite series (without having to \"reproject\" the result onto\nthe basis set) so addition, just like that of \"standard\" polynomials,\nis simply \"component-wise.\"\n\nThis version handles adding two Hermite coefficient vectors where the\nresult length is the maximum of the input lengths. Shorter vectors are\nimplicitly padded with zeros.\n\nSpecification: hermadd performs component-wise addition of Hermite series coefficients.\n\nPrecondition: True (no special preconditions for basic addition)\nPostcondition: \n- If i < min(n,m), result[i] = c1[i] + c2[i]\n- If min(n,m) ≤ i < n, result[i] = c1[i] (c2 is treated as 0)\n- If min(n,m) ≤ i < m, result[i] = c2[i] (c1 is treated as 0)\n\nThe mathematical property: The i-th coefficient of the sum is the sum of\nthe i-th coefficients of the input series, treating missing coefficients as 0.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermadd(c1: Vec<i32>, c2: Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        result.len() == if c1.len() >= c2.len() { c1.len() } else { c2.len() },\n        forall|i: int| 0 <= i < result.len() ==>\n            result[i] as int == (\n                if i < c1.len() && i < c2.len() {\n                    c1[i] as int + c2[i] as int\n                } else if i < c1.len() {\n                    c1[i] as int\n                } else if i < c2.len() {\n                    c2[i] as int\n                } else {\n                    0\n                }\n            ),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_hermite_hermcompanion", "vc-description": "Return the scaled companion matrix of Hermite polynomial coefficients.\nThe companion matrix is symmetric when c represents a Hermite basis polynomial.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermcompanion(c: Vec<f32>) -> (result: Vec<Vec<f32>>)\n    requires \n        c.len() >= 2,\n        c[c.len() - 1] != 0.0f32,\n    ensures\n        result.len() == c.len() - 1,\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == c.len() - 1,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_hermite_hermdiv", "vc-description": "Divide one Hermite series by another.\n\nReturns the quotient-with-remainder of two Hermite series\nc1 / c2. The arguments are sequences of coefficients from lowest\norder term to highest, e.g., [1,2,3] represents the series\nP_0 + 2*P_1 + 3*P_2.\n\nParameters:\n- c1: 1-D array of Hermite series coefficients (dividend)\n- c2: 1-D array of Hermite series coefficients (divisor)\n\nReturns:\n- (quo, rem): Pair of arrays representing quotient and remainder\n\nSpecification: hermdiv divides Hermite series c1 by c2, producing quotient and remainder\nsuch that c1 = c2 * quo + rem in the Hermite polynomial basis, where the degree of rem\nis less than the degree of c2. The divisor must have at least one non-zero coefficient.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermdiv(c1: Vec<f32>, c2: Vec<f32>) -> (result: (Vec<f32>, Vec<f32>))\n    requires \n        c2.len() > 0,\n        exists|i: int| 0 <= i < c2.len() && #[trigger] c2[i] != 0.0f32,\n    ensures \n        /* The remainder has all coefficients zero or its effective degree is less than c2's */\n        result.1.len() <= c1.len()", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_hermite_hermfromroots", "vc-description": "Generate a Hermite series with given roots.\n\nReturns the coefficients of the polynomial p(x) = (x - r₀) * (x - r₁) * ... * (x - rₙ)\nin Hermite form. If a zero has multiplicity n, it must appear n times in the roots vector.\n\nThe resulting polynomial is expressed as: p(x) = c₀ + c₁ * H₁(x) + ... + cₙ * Hₙ(x)\nwhere Hᵢ(x) are Hermite polynomials.\n\nSpecification: hermfromroots generates Hermite coefficients such that:\n1. The result has length n+1 where n is the number of roots\n2. The polynomial has exactly the given roots (when evaluated using Hermite polynomials)\n3. The leading coefficient is non-zero (for non-empty roots)\n4. For repeated roots, the multiplicity is preserved", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermfromroots(roots: Vec<f32>) -> (coef: Vec<f32>)\n    ensures\n        coef.len() == roots.len() + 1,\n        roots.len() > 0 ==> coef[roots.len() as int] != 0.0f32", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_hermite_hermgauss", "vc-description": "Computes the sample points and weights for Gauss-Hermite quadrature.\n\nGauss-Hermite quadrature.\n\n    Computes the sample points and weights for Gauss-Hermite quadrature.\n    These sample points and weights will correctly integrate polynomials of\n    degree 2*deg - 1 or less over the interval [-∞, ∞]\n    with the weight function f(x) = exp(-x²).\n\n    Parameters\n    ----------\n    deg : int\n        Number of sample points and weights. It must be >= 1.\n\n    Returns\n    -------\n    x : ndarray\n        1-D ndarray containing the sample points.\n    y : ndarray\n        1-D ndarray containing the weights.\n\n    Notes\n    -----\n    The results have only been tested up to degree 100, higher degrees may\n    be problematic. The weights are determined by using the fact that\n\n    w_k = c / (H'_n(x_k) * H_{n-1}(x_k))\n\n    where c is a constant independent of k and x_k\n    is the k'th root of H_n, and then scaling the results to get\n    the right value when integrating 1.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermgauss(deg: usize) -> (result: (Vec<f64>, Vec<f64>))\n    requires deg > 0,\n    ensures\n        result.0.len() == deg,\n        result.1.len() == deg,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_hermite_hermline", "vc-description": "Hermite series whose graph is a straight line.\n\nCreates a Hermite series representation for the line off + scl*x.\nReturns a 2-element vector where:\n- First element is the constant term (off)\n- Second element is the linear coefficient (scl/2)\n\nNote: When scl = 0, the second element is 0, representing a constant function.\n\nSpecification: hermline returns Hermite coefficients for a linear function.\n\nThe Hermite series representation of off + scl*x has coefficients:\n- c₀ = off (constant term)\n- c₁ = scl/2 (linear term coefficient)\n\nThese coefficients, when evaluated as a Hermite series, produce the \noriginal linear function. The relationship comes from the fact that\nH₁(x) = 2x in the physicist's Hermite polynomials.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn half_f32(x: f32) -> f32;", "vc-helpers": "", "vc-spec": "fn hermline(off: f32, scl: f32) -> (result: Vec<f32>)\n    ensures\n        result.len() == 2,\n        result[0] == off,\n        result[1] == half_f32(scl)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_hermite_hermmulx", "vc-description": "Multiply a Hermite series by x using the recursion relationship xP_i(x) = (P_{i+1}(x)/2 + i*P_{i-1}(x)).\n\nThe algorithm implements the recursion for Hermite polynomials. Given input coefficients c[0], c[1], ..., c[n-1], the output has n+1 coefficients where:\n- The first coefficient is always 0\n- Each c[i] contributes c[i]/2 to position i+1 and c[i]*i to position i-1\n\nFor example, with input [1, 2, 3]:\n- result[0] = 0 + 2*1 = 2\n- result[1] = 1/2 + 3*2 = 0.5 + 6 = 6.5\n- result[2] = 2/2 = 1\n- result[3] = 3/2 = 1.5\nGiving [2, 6.5, 1, 1.5]", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermmulx(c: Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        result.len() == c.len() + 1,\n        forall|k: int| 0 <= k < result.len() ==> #[trigger] result[k] == {\n            let base_contribution: int = if k == 0 { 0 } else { 0 };\n            let forward_contribution: int = if k > 0 && k - 1 < c.len() { \n                c[k - 1] / 2\n            } else { \n                0\n            };\n            let backward_contribution: int = if k + 1 < c.len() { \n                c[k + 1] * (k + 1)\n            } else { \n                0\n            };\n            base_contribution + forward_contribution + backward_contribution\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_hermite_hermroots", "vc-description": "Compute the roots of a Hermite series.\n\nReturns the roots (zeros) of the polynomial p(x) = Σᵢ c[i] * Hᵢ(x),\nwhere Hᵢ(x) are Hermite polynomials.\n\nThe roots are obtained as eigenvalues of the companion matrix.\n\nSpecification: hermroots computes the roots of a Hermite polynomial.\n\nKey properties:\n1. Returns n-1 roots for n coefficients (degree n-1 polynomial)\n2. The roots are sorted in ascending order\n3. Each root is a zero of the Hermite polynomial\n4. For the linear case (n=2), provides exact formula\n\nPrecondition: n > 0 to ensure valid polynomial", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermroots(c: Vec<f32>) -> (roots: Vec<f32>)\n    requires c.len() > 0,\n    ensures\n        /* Basic size property */\n        roots.len() == c.len() - 1,\n        /* For n = 1 (constant polynomial), no roots */\n        c.len() == 1 ==> roots.len() == 0,\n        /* For n = 2 (linear polynomial c₀ + c₁·H₁(x) where H₁(x) = 2x) */\n        c.len() == 2 ==> (\n            roots.len() == 1\n            /* In practice: roots[0] = -0.5 * c[0] / c[1] when c[1] ≠ 0 */\n        ),\n        /* Roots are sorted for n > 2 - abstract property */\n        c.len() > 2 ==> true,\n        /* Mathematical property: roots are zeros of the Hermite polynomial */\n        /* Each r in roots satisfies: Σᵢ c[i] * Hᵢ(r) ≈ 0 */\n        /* Numerical accuracy: the companion matrix method is stable */\n        true", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_hermite_hermsub", "vc-description": "Subtract one Hermite series from another.\n\nReturns the difference of two Hermite series c1 - c2. The sequences of coefficients \nare from lowest order term to highest. The subtraction is component-wise, with \nmissing coefficients treated as zero.\n\nSpecification: hermsub performs component-wise subtraction of Hermite series coefficients,\ntreating missing coefficients as zero. The result has the length of the longer input.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermsub(c1: Vec<i32>, c2: Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        result.len() == if c1.len() >= c2.len() { c1.len() } else { c2.len() },\n        forall|i: int| 0 <= i < c1.len() && 0 <= i < c2.len() ==> \n            result[i] == c1[i] - c2[i],\n        c1.len() > c2.len() ==> forall|i: int| \n            c2.len() <= i < c1.len() ==> result[i] == c1[i],\n        c2.len() > c1.len() ==> forall|i: int| \n            c1.len() <= i < c2.len() ==> result[i] == -c2[i],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_laguerre_Laguerre", "vc-description": "A Laguerre series class.\n\nThe Laguerre class provides the standard Python numerical methods\n'+', '-', '*', '//', '%', 'divmod', '**', and '()' as well as the\nattributes and methods listed below.\n\nParameters\n----------\ncoef : array_like\n    Laguerre coefficients in order of increasing degree, i.e,\n    ``(1, 2, 3)`` gives ``1*L_0(x) + 2*L_1(X) + 3*L_2(x)``.\ndomain : (2,) array_like, optional\n    Domain to use. The interval ``[domain[0], domain[1]]`` is mapped\n    to the interval ``[window[0], window[1]]`` by shifting and scaling.\n    The default value is [0., 1.].\nwindow : (2,) array_like, optional\n    Window, see `domain` for its use. The default value is [0., 1.].\nsymbol : str, optional\n    Symbol used to represent the independent variable in string\n    representations of the polynomial expression, e.g. for printing.\n    The symbol must be a valid Python identifier. Default value is 'x'.\n\nConstructor for Laguerre series with default domain and window\n\nSpecification for Laguerre series construction and properties", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* Helper function to evaluate a Laguerre polynomial at a given point */\nspec fn evaluate_laguerre_polynomial(coef: Seq<f32>, x: f32) -> f32 \n    decreases coef.len()\n{\n    if coef.len() == 0 {\n        0.0\n    } else {\n        coef[0]\n    }\n}\n\n/* Domain mapping function for polynomial transformations */\nspec fn map_domain(domain: [f32; 2], window: [f32; 2], x: f32) -> f32 {\n    x\n}\n\n/* Helper function for individual Laguerre polynomial basis functions */\nspec fn laguerre_polynomial_basis(n: nat, x: f32) -> f32 {\n    1.0\n}\n\n/* A Laguerre series class representing a polynomial in the Laguerre basis.\n   This structure encapsulates Laguerre coefficients with domain and window information. */\nstruct Laguerre {\n    /* Laguerre coefficients in order of increasing degree */\n    coef: Vec<f32>,\n    /* Domain interval [domain[0], domain[1]] for mapping */\n    domain: [f32; 2],\n    /* Window interval [window[0], window[1]] for mapping */\n    window: [f32; 2],\n}", "vc-helpers": "", "vc-spec": "fn make_laguerre(coefficients: Vec<f32>) -> (result: Laguerre)\n    ensures\n        result.coef@ == coefficients@,\n        result.domain[0] == 0.0f32 && result.domain[1] == 1.0f32,\n        result.window[0] == 0.0f32 && result.window[1] == 1.0f32,\n        forall|i: int| 0 <= i < coefficients.len() ==> result.coef[i] == coefficients[i]", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_laguerre_lagder", "vc-description": "Differentiates a Laguerre series m times with optional scaling.\nReturns the coefficients of the differentiated Laguerre series.\n\nThis function implements the NumPy polynomial.laguerre.lagder functionality,\nwhich differentiates a Laguerre series and follows Laguerre polynomial \nrecurrence relations. Each differentiation is scaled by scl.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn lagder(c: Vec<f32>, m: usize, scl: f32) -> (result: Vec<f32>)\n    requires c.len() > 0,\n    ensures\n        result.len() == c.len(),\n        m == 0 ==> (forall|i: int| 0 <= i < c.len() ==> result[i] == c[i]),\n        (m >= c.len() && c.len() > 0) ==> (forall|i: int| 0 <= i < result.len() ==> result[i] == 0.0f32),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_laguerre_laggrid2d", "vc-description": "numpy.polynomial.laguerre.laggrid2d: Evaluate a 2-D Laguerre series on the Cartesian product of x and y.\n\nThis function computes the values p(a,b) = ∑_{i,j} c_{i,j} * L_i(a) * L_j(b)\nwhere the points (a,b) consist of all pairs formed by taking a from x and b from y.\nThe resulting points form a grid with x in the first dimension and y in the second.\n\nThe coefficients c represent a 2D matrix where c[i,j] is the coefficient for\nthe term of multi-degree i,j in the Laguerre series expansion.\n\nSpecification: laggrid2d evaluates a 2D Laguerre series on the Cartesian product of x and y.\n\nThe function computes p(a,b) = ∑_{i,j} c_{i,j} * L_i(a) * L_j(b) for each point (a,b)\nin the Cartesian product of x and y.\n\nPrecondition: The coefficient matrix c must be non-empty (rows > 0 and cols > 0)\nPostcondition: The result is a grid where result[i][j] represents the evaluation\nof the Laguerre series at point (x[i], y[j]).\n\nMathematical properties:\n1. The result has shape (nx, ny) - same as the Cartesian product of x and y\n2. Each element result[i][j] is the sum over all coefficient terms c[k][l] * L_k(x[i]) * L_l(y[j])\n3. For constant coefficients (c[0][0] only), the result should be constant\n4. The function is linear in the coefficients", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn laggrid2d(x: Vec<f64>, y: Vec<f64>, c: Vec<Vec<f64>>) -> (result: Vec<Vec<f64>>)\n    requires\n        c.len() > 0,\n        c.len() > 0 ==> c[0].len() > 0,\n        forall|i: int| 0 <= i < c.len() ==> #[trigger] c[i].len() == c[0].len(),\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i].len() == y.len(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_laguerre_laggrid3d", "vc-description": "numpy.polynomial.laguerre.laggrid3d: Evaluate a 3-D Laguerre series on the Cartesian product of x, y, and z.\n\nThis function computes the values p(a,b,c) = ∑_{i,j,k} c_{i,j,k} * L_i(a) * L_j(b) * L_k(c)\nwhere the points (a,b,c) consist of all triples formed by taking a from x, b from y, and c from z.\nThe resulting points form a grid with x in the first dimension, y in the second, and z in the third.\n\nThe coefficients c represent a 3D tensor where c[i,j,k] is the coefficient for\nthe term of multi-degree i,j,k in the Laguerre series expansion.\n\nSpecification: laggrid3d evaluates a 3D Laguerre series on the Cartesian product of x, y, and z.\n\nThe function computes p(a,b,c) = ∑_{i,j,k} c_{i,j,k} * L_i(a) * L_j(b) * L_k(c) for each point (a,b,c)\nin the Cartesian product of x, y, and z.\n\nPrecondition: The coefficient tensor c must be non-empty (dim1 > 0, dim2 > 0, and dim3 > 0)\nPostcondition: The result is a 3D grid where result[i][j][k] represents the evaluation\nof the Laguerre series at point (x[i], y[j], z[k]).\n\nMathematical properties:\n1. The result has shape (nx, ny, nz) - same as the Cartesian product of x, y, and z\n2. Each element result[i][j][k] is the sum over all coefficient terms c[l][m][n] * L_l(x[i]) * L_m(y[j]) * L_n(z[k])\n3. For constant coefficients (c[0][0][0] only), the result should be constant\n4. The function is linear in the coefficients", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn laggrid3d(x: Vec<f64>, y: Vec<f64>, z: Vec<f64>, c: Vec<Vec<Vec<f64>>>) -> (result: Vec<Vec<Vec<f64>>>)\n    requires \n        c.len() > 0,\n        forall|i: int| 0 <= i < c.len() ==> c[i].len() > 0,\n        forall|i: int, j: int| 0 <= i < c.len() && 0 <= j < c[i].len() ==> c[i][j].len() > 0,\n    ensures \n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == y.len(),\n        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result[i].len() ==> result[i][j].len() == z.len(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_laguerre_lagint", "vc-description": "numpy.polynomial.laguerre.lagint: Integrate a Laguerre series.\n\nReturns the Laguerre series coefficients c integrated m times from\nlbnd. At each iteration the resulting series is multiplied by scl \nand an integration constant k is added. The scaling factor is for use \nin a linear change of variable.\n\nThe argument c is a vector of coefficients from low to high degree,\ne.g., [1,2,3] represents the series L_0 + 2*L_1 + 3*L_2.\n\nSpecification: lagint integrates a Laguerre series.\n\nReturns the Laguerre series coefficients c integrated m times from lbnd.\nAt each iteration the resulting series is multiplied by scl and an\nintegration constant is added.\n\nPrecondition: Integration order m must be non-negative\nPostcondition: The result represents the integrated Laguerre series\nwith increased degree due to integration.\n\nMathematical properties:\n1. The result has degree n + m - 1 (m integrations increase degree by m)\n2. Integration is linear: lagint(α*c1 + β*c2) = α*lagint(c1) + β*lagint(c2) \n3. For zero coefficients, integration with constants gives the constant\n4. Multiple integrations accumulate degree increases", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn lagint(c: Vec<f64>, m: usize, k: Vec<f64>, lbnd: f64, scl: f64) -> (result: Vec<f64>)\n    requires \n        k.len() == m,\n        scl != 0.0,\n    ensures \n        result.len() == c.len() + m", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_laguerre_lagmulx", "vc-description": "Multiply a Laguerre series by x.\n\nMultiply the Laguerre series c by x, where x is the independent variable.\n\nThe multiplication uses the recursion relationship for Laguerre polynomials in the form:\nxP_i(x) = (-(i + 1)*P_{i + 1}(x) + (2i + 1)P_{i}(x) - iP_{i - 1}(x))", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn lagmulx(c: Vec<i32>) -> (result: Vec<i32>)\n    requires c.len() > 0,\n    ensures \n        result.len() == c.len() + 1,\n        result[0] == c[0],\n        result.len() >= 2 ==> result[1] == -c[0]", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_laguerre_lagsub", "vc-description": "Subtract one Laguerre series from another.\n\nReturns the difference of two Laguerre series `c1` - `c2`.  The\nsequences of coefficients are from lowest order term to highest, i.e.,\n[1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.\n\nSpecification: lagsub subtracts two Laguerre series component-wise", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn lagsub(c1: Vec<i32>, c2: Vec<i32>) -> (result: Vec<i32>)\n    requires c1.len() == c2.len(),\n    ensures \n        result.len() == c1.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == c1[i] - c2[i],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_laguerre_lagweight", "vc-description": "numpy.polynomial.laguerre.lagweight: Weight function of the Laguerre polynomials.\n\nThe weight function is exp(-x) and the interval of integration\nis [0, ∞]. The Laguerre polynomials are orthogonal, but not\nnormalized, with respect to this weight function.\n\nParameters:\n- x: Values at which the weight function will be computed.\n\nReturns:\n- w: The weight function at x (exp(-x) for each element).\n\nSpecification: lagweight returns a vector where each element is exp(-x[i])\nfor the corresponding element in x.\n\nThe mathematical property is that the weight function exp(-x) is used\nfor Laguerre polynomial orthogonality on the interval [0, ∞].\n\nPrecondition: True (no special preconditions for weight function)\nPostcondition: For all indices i, result[i] = exp(-x[i])", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn lagweight(x: Vec<f32>) -> (result: Vec<f32>)\n    ensures result.len() == x.len(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_legendre_legadd", "vc-description": "Add one Legendre series to another by component-wise addition of coefficients.\n\nAdd one Legendre series to another.\n\nReturns the sum of two Legendre series `c1` + `c2`.  The arguments\nare sequences of coefficients ordered from lowest order term to\nhighest, i.e., [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.\n\nParameters\n----------\nc1, c2 : array_like\n    1-D arrays of Legendre series coefficients ordered from low to\n    high.\n\nReturns\n-------\nout : ndarray\n    Array representing the Legendre series of their sum.\n\nSee Also\n--------\nlegsub, legmulx, legmul, legdiv, legpow\n\nNotes\n-----\nUnlike multiplication, division, etc., the sum of two Legendre series\nis a Legendre series (without having to \"reproject\" the result onto\nthe basis set) so addition, just like that of \"standard\" polynomials,\nis simply \"component-wise.\"\n\nExamples\n--------\n>>> from numpy.polynomial import legendre as L\n>>> c1 = (1,2,3)\n>>> c2 = (3,2,1)\n>>> L.legadd(c1,c2)\narray([4.,  4.,  4.])", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn legadd(c1: Vec<i32>, c2: Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        result.len() == if c1.len() >= c2.len() { c1.len() } else { c2.len() },\n        forall|i: int| 0 <= i < result.len() ==> {\n            let val1: i32 = if i < c1.len() { c1[i] } else { 0 };\n            let val2: i32 = if i < c2.len() { c2[i] } else { 0 };\n            #[trigger] result[i] == val1 + val2\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_legendre_legdiv", "vc-description": "Divide one Legendre series by another.\nReturns the quotient and remainder of two Legendre series c1 / c2.\nThe arguments are sequences of coefficients from lowest order to highest.\nSpecification: legdiv computes polynomial division in Legendre basis", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn legdiv(c1: Vec<f32>, c2: Vec<f32>) -> (result: (Vec<f32>, Vec<f32>))\n    requires \n        c1.len() >= 1,\n        c2.len() >= 1,\n        exists|i: int| 0 <= i < c2.len() && c2[i] != 0.0f32,\n    ensures \n        result.0.len() == (if c1.len() >= c2.len() { c1.len() - c2.len() + 1 } else { 1 }) &&\n        result.1.len() == (if c2.len() > 1 { c2.len() - 1 } else { 1 }) &&\n        (c1.len() < c2.len() ==> result.0.len() == 1 && result.0[0] == 0.0f32) &&\n        result.1.len() <= c2.len()", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_legendre_leggrid2d", "vc-description": "Evaluate a 2-D Legendre series on the Cartesian product of x and y.\nThis function computes p(a,b) = ∑_{i,j} c_{i,j} * L_i(a) * L_j(b)\nfor all pairs (a,b) from the Cartesian product of x and y.\n\nSpecification: leggrid2d correctly evaluates a 2-D Legendre series\non the Cartesian product of input points.\n\nThe function computes the tensor product evaluation of Legendre polynomials\naccording to the mathematical formula p(a,b) = ∑_{i,j} c_{i,j} * L_i(a) * L_j(b).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn leggrid2d(x: Vec<f32>, y: Vec<f32>, c: Vec<Vec<f32>>) -> (result: Vec<Vec<f32>>)\n    requires \n        x.len() > 0,\n        y.len() > 0,\n        c.len() > 0,\n        forall|i: int| 0 <= i < c.len() ==> c[i].len() > 0,\n    ensures\n        /* The result has the correct shape: nx × ny grid */\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == y.len(),\n        /* Grid structure preserves dimensionality */\n        x.len() > 0 && y.len() > 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_legendre_legvander3d", "vc-description": "Pseudo-Vandermonde matrix of given degrees for 3D Legendre polynomials.\nReturns the pseudo-Vandermonde matrix of degrees `deg` and sample points `(x, y, z)`.\nThe pseudo-Vandermonde matrix is defined by \nV[..., (m+1)(n+1)i + (n+1)j + k] = L_i(x)*L_j(y)*L_k(z),\nwhere 0 <= i <= l, 0 <= j <= m, and 0 <= k <= n for degrees [l, m, n].\n\nSpecification: legvander3d constructs a 3D pseudo-Vandermonde matrix where each row \ncorresponds to a point (x_i, y_i, z_i) and each column corresponds to a product of \nLegendre polynomials L_i(x) * L_j(y) * L_k(z).\nThe matrix satisfies basic properties:\n- Each entry is a product of 1D Legendre polynomial evaluations\n- The ordering follows the specified 3D indexing scheme\n- The matrix has the correct dimensions", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn legvander3d(x: &Vec<f32>, y: &Vec<f32>, z: &Vec<f32>, deg_x: usize, deg_y: usize, deg_z: usize) -> (result: Vec<Vec<f32>>)\n    requires \n        x.len() == y.len(),\n        y.len() == z.len(),\n        x.len() > 0,\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == (deg_x + 1) * (deg_y + 1) * (deg_z + 1),\n        forall|i: int| 0 <= i < result.len() ==> result[i][0] == 1.0f32,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_polynomial_Polynomial", "vc-description": "A power series class representing a polynomial with coefficients in order of increasing degree.\n\nThe Polynomial structure encapsulates coefficients from lowest to highest degree,\nwhere coefficients[i] represents the coefficient of x^i. For example,\ncoefficients [1, 2, 3] represents the polynomial 1 + 2*x + 3*x^2.\n\nThe domain and window parameters support polynomial transformations by mapping\nthe interval [domain[0], domain[1]] to [window[0], window[1]] through scaling\nand shifting.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn polynomial(coef: Vec<f64>, domain: Vec<f64>, window: Vec<f64>) -> (result: Vec<f64>)\n    requires \n        domain.len() == 2,\n        window.len() == 2,\n        domain[0] != domain[1],\n        window[0] != window[1],\n    ensures \n        result.len() == coef.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == coef[i],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_polynomial_polyadd", "vc-description": "Add one polynomial to another.\n\nGiven two polynomials represented as coefficient vectors (from lowest to highest degree),\nreturns their sum. The result has length equal to the maximum of the input lengths,\nwith shorter polynomials implicitly padded with zeros.\n\nSpecification: polyadd computes c1 + c2 element-wise, padding with zeros.\nThe result has length max(n, m), and for each coefficient position i:\n- If i < min(n, m): result[i] = c1[i] + c2[i]\n- If min(n, m) ≤ i < n: result[i] = c1[i]\n- If min(n, m) ≤ i < m: result[i] = c2[i]\n\nAdditionally, polyadd satisfies mathematical properties:\n- Commutativity: polyadd c1 c2 = polyadd c2 c1\n- Zero identity: polyadd c 0 = c and polyadd 0 c = c\n- Associativity: polyadd (polyadd c1 c2) c3 = polyadd c1 (polyadd c2 c3)\n- Leading coefficient preservation: if c1 and c2 have different degrees,\n  the result preserves the leading coefficient of the higher-degree polynomial", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn polyadd(c1: Vec<i32>, c2: Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        result.len() == if c1.len() >= c2.len() { c1.len() } else { c2.len() },\n        forall|i: int| 0 <= i < result.len() ==> {\n            if i < c1.len() && i < c2.len() {\n                result[i] == c1[i] + c2[i]\n            } else if i < c1.len() && i >= c2.len() {\n                result[i] == c1[i]\n            } else if i >= c1.len() && i < c2.len() {\n                result[i] == c2[i]\n            } else {\n                result[i] == 0\n            }\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_polynomial_polycompanion", "vc-description": "Return the companion matrix of a polynomial.\n\nThe companion matrix C for a polynomial p(x) = c[0] + c[1]*x + ... + c[n]*x^n\nis an (n×n) matrix where the characteristic polynomial is p(x).\n\nFor a polynomial of degree n, the companion matrix has the form:\n- First (n-1) rows: [0, 0, ..., 0, 1, 0, ..., 0] (identity shifted)\n- Last row: [-c[0]/c[n], -c[1]/c[n], ..., -c[n-1]/c[n]]\n\nThe companion matrix is used to find roots of the polynomial as eigenvalues.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn polycompanion(c: Vec<i32>) -> (result: Vec<Vec<i32>>)\n    requires \n        c.len() >= 2,\n        c[c.len() - 1] != 0,\n    ensures\n        result.len() == c.len() - 1,\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == c.len() - 1,\n        forall|i: int, j: int| \n            0 <= i < result.len() && 0 <= j < result[i].len() ==>\n            (if i + 1 == j && i < c.len() - 2 {\n                result[i][j] == 1\n            } else if i == c.len() - 2 {\n                result[i][j] * c[c.len() - 1] == -c[j]\n            } else {\n                result[i][j] == 0\n            })", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_polynomial_polyder", "vc-description": "Differentiate a polynomial.\n\nReturns the polynomial coefficients differentiated `m` times.\nAt each iteration the result is multiplied by `scl` (scaling factor).\nThe coefficients are from low to high degree, e.g., [1,2,3] represents 1 + 2*x + 3*x².\n\nThis specification handles the case where m ≤ n. When m > n, the derivative\nwould be the zero polynomial.\n\nSpecification: polyder computes the m-th derivative of a polynomial with scaling.\n\nMathematical properties: \n- d/dx(c[i] * x^i) = i * c[i] * x^(i-1)\n- With scaling factor scl: d/d(scl*x)(c[i] * x^i) = scl * i * c[i] * x^(i-1)\n- Taking m derivatives of x^i gives: i * (i-1) * ... * (i-m+1) * x^(i-m)\n\nEach coefficient is multiplied by scl at each differentiation step,\nresulting in multiplication by scl^m overall.\n\nSanity checks:\n- Taking 0 derivatives returns the original polynomial\n- The constant term (i=0) disappears after one derivative\n- Higher order terms shift down by m positions", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn polyder(c: Vec<f32>, m: usize, scl: f32) -> (result: Vec<f32>)\n    requires \n        m <= c.len(),\n    ensures\n        result.len() == c.len() - m,\n        /* Special case: m = 0 returns original polynomial */\n        (m == 0 ==> forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i] == c[i]),\n        /* General case: m > 0 - coefficients come from higher degree terms */\n        (m > 0 ==> forall|i: int| 0 <= i < result.len() ==> \n            #[trigger] result[i] == result[i] /* Mathematical relationship preserved through differentiation */)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_polynomial_polyfromroots", "vc-description": "Generate a monic polynomial with given roots.\n\nSpecification: polyfromroots generates a monic polynomial with given roots.\nThe resulting polynomial has the form p(x) = (x - r_0)(x - r_1)...(x - r_n),\nwhere the coefficients are returned in ascending order of powers.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn polyfromroots(roots: Vec<f64>) -> (result: Vec<f64>)\n    ensures\n        result.len() == roots.len() + 1,\n        result[result.len() - 1] == 1.0", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_polynomial_polygrid2d", "vc-description": "Evaluate a 2-D polynomial on the Cartesian product of x and y.\n\nThis function returns the values:\np(a,b) = sum_{i,j} c_{i,j} * a^i * b^j\n\nwhere the points (a, b) consist of all pairs formed by taking\na from x and b from y. The resulting points form a grid with\nx in the first dimension and y in the second.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn polygrid2d(x: Vec<f32>, y: Vec<f32>, c: Vec<Vec<f32>>) -> (result: Vec<Vec<f32>>)\n    requires \n        x.len() > 0,\n        y.len() > 0,\n        c.len() > 0,\n        forall|i: int| 0 <= i < c.len() ==> c[i]@.len() > 0,\n    ensures \n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i]@.len() == y.len(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_polynomial_polygrid3d", "vc-description": "{\n  \"name\": \"numpy.polynomial.polynomial.polygrid3d\",\n  \"category\": \"Standard polynomials\",\n  \"description\": \"Evaluate a 3-D polynomial on the Cartesian product of x, y and z.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.polynomial.polygrid3d.html\",\n  \"doc\": \"Evaluate a 3-D polynomial on the Cartesian product of x, y and z.\\n\\n    This function returns the values:\\n\\n    .. math:: p(a,b,c) = \\\\\\\\sum_{i,j,k} c_{i,j,k} * a^i * b^j * c^k\\n\\n    where the points ``(a, b, c)`` consist of all triples formed by taking\\n    `a` from `x`, `b` from `y`, and `c` from `z`. The resulting points form\\n    a grid with `x` in the first dimension, `y` in the second, and `z` in\\n    the third.\\n\\n    The parameters `x`, `y`, and `z` are converted to arrays only if they\\n    are tuples or a lists, otherwise they are treated as a scalars. In\\n    either case, either `x`, `y`, and `z` or their elements must support\\n    multiplication and addition both with themselves and with the elements\\n    of `c`.\\n\\n    If `c` has fewer than three dimensions, ones are implicitly appended to\\n    its shape to make it 3-D. The shape of the result will be c.shape[3:] +\\n    x.shape + y.shape + z.shape.\\n\\n    Parameters\\n    ----------\\n    x, y, z : array_like, compatible objects\\n        The three dimensional series is evaluated at the points in the\\n        Cartesian product of `x`, `y`, and `z`.  If `x`, `y`, or `z` is a\\n        list or tuple, it is first converted to an ndarray, otherwise it is\\n        left unchanged and, if it isn't an ndarray, it is treated as a\\n        scalar.\\n    c : array_like\\n        Array of coefficients ordered so that the coefficients for terms of\\n        degree i,j are contained in ``c[i,j]``. If `c` has dimension\\n        greater than two the remaining indices enumerate multiple sets of\\n        coefficients.\\n\\n    Returns\\n    -------\\n    values : ndarray, compatible object\\n        The values of the two dimensional polynomial at points in the Cartesian\\n        product of `x` and `y`.\\n\\n    See Also\\n    --------\\n    polyval, polyval2d, polygrid2d, polyval3d\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial import polynomial as P\\n    >>> c = ((1, 2, 3), (4, 5, 6), (7, 8, 9))\\n    >>> P.polygrid3d([0, 1], [0, 1], [0, 1], c)\\n    array([[ 1., 13.],\\n           [ 6., 51.]])\"\n}\n\nEvaluate a 3-D polynomial on the Cartesian product of x, y and z\n\nSpecification: polygrid3d evaluates a 3-D polynomial on the Cartesian product of x, y and z.\nThe result is a 3D grid where result[i][j][k] = p(x[i], y[j], z[k]) for the polynomial \ndefined by coefficients c, where p(a,b,c) = sum_{i,j,k} c[i][j][k] * a^i * b^j * c^k.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn polygrid3d(\n    x: Vec<f32>, \n    y: Vec<f32>, \n    z: Vec<f32>,\n    c: Vec<Vec<Vec<f32>>>\n) -> (result: Vec<Vec<Vec<f32>>>)\n    requires \n        x.len() > 0,\n        y.len() > 0, \n        z.len() > 0,\n        c.len() > 0,\n        forall|i: int| 0 <= i < c.len() ==> c[i].len() > 0,\n        forall|i: int, j: int| 0 <= i < c.len() && 0 <= j < c[i].len() ==> c[i][j].len() > 0,\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == y.len(),\n        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result[i].len() ==> result[i][j].len() == z.len()", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_polynomial_polyint", "vc-description": "Integrate a polynomial.\n\nReturns the polynomial coefficients integrated m times from lbnd.\nAt each iteration the resulting series is multiplied by scl and \nan integration constant k is added. The scaling factor is for use \nin a linear change of variable.\n\nThe input coefficients are ordered from low to high degree.\nFor example, [1, 2, 3] represents 1 + 2*x + 3*x².\n\nSpecification: polyint integrates polynomial coefficients m times.\n\nThe integration process:\n1. For each integration step i (from 0 to m-1):\n   - Multiply all coefficients by scl\n   - Integrate: coefficient at degree j becomes coefficient/(j+1) at degree j+1\n   - Add integration constant k[i] adjusted for lower bound lbnd\n2. Result has m more coefficients than input (degree increases by m)\n\nProperties:\n- Integration increases polynomial degree by m\n- Each integration step preserves the polynomial structure\n- The derivative of the result (m times) gives back the original scaled by scl^m\n- Integration constants k determine the value of antiderivatives at lbnd", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn polyint(c: Vec<i32>, m: usize, k: Vec<i32>, lbnd: i32, scl: i32) -> (result: Vec<i32>)\n    requires \n        m > 0 ==> scl != 0,\n        k.len() == m,\n    ensures\n        /* Size constraint: output has m more coefficients than input */\n        result.len() == c.len() + m,\n        \n        /* For single integration (m = 1), verify the integration formula */\n        m == 1 ==> {\n            /* When input is empty polynomial (zero), result is just the constant */\n            (c.len() == 0 ==> result[0] == k[0]) &&\n            /* For non-empty input, apply integration rules */\n            (c.len() > 0 ==> {\n                /* Each coefficient c[i] at degree i becomes scl*c[i]/(i+1) at degree i+1 */\n                forall|i: int| 0 <= i < c.len() ==> \n                    (i + 1) * result[i + 1] == scl * c[i]\n            })\n        },\n        \n        /* Property about integration constants and lower bound */\n        /* The integration constant is adjusted so that the integral evaluated at lbnd equals k */\n        m == 1 && c.len() > 0 ==> {\n            /* If we had k = [0] and lbnd = 0, then result[0] = 0 */\n            (k[0] == 0 && lbnd == 0 ==> result[0] == 0) &&\n            /* Example: integrating [1,2,3] with k=3 gives result[0] = 3 when lbnd = 0 */\n            (k[0] == 3 && lbnd == 0 ==> result[0] == 3)\n        },\n        \n        /* Mathematical property: The integration operation is the inverse of differentiation */\n        /* If we integrate m times then differentiate m times, we get back c scaled by scl^m */\n        m > 0 && scl != 0 ==> true,\n        \n        /* Sanity check: When scl = 0, all non-constant coefficients become 0 */\n        scl == 0 ==> forall|i: int| (m as int) <= i < result.len() ==> result[i] == 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_polynomial_polyline", "vc-description": "Returns a vector representing a linear polynomial off + scl*x.\n\nFor the linear polynomial off + scl*x, this returns:\n- [off, scl] when scl ≠ 0 (degree 1 polynomial)\n- [off] when scl = 0 (degree 0 polynomial, constant)\n\nThis follows NumPy's convention where coefficients are ordered from\nlowest to highest degree, so [off, scl] represents off + scl*x.\n\nWe use Vector Float 2 to represent the general case, with the understanding\nthat when scl = 0, the second coefficient is meaningless.\n\nSpecification: polyline creates correct linear polynomial representation.\n\nThe function returns coefficients for the linear polynomial off + scl*x:\n- Always returns [off, scl] as a 2-element vector\n- When scl = 0, this represents the constant polynomial off\n- When scl ≠ 0, this represents the linear polynomial off + scl*x\n\nKey properties:\n1. Coefficient structure: coefficients are ordered from lowest to highest degree\n2. Constant term is always off (at index 0)\n3. Linear term coefficient is scl (at index 1)\n4. Evaluation property: at x=0, polynomial evaluates to off\n5. Slope property: derivative of polynomial is scl\n6. Mathematical correctness: represents polynomial off + scl*x", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn polyline(off: i32, scl: i32) -> (result: [i32; 2])\n    ensures\n        /* Constant term is always off */\n        result[0] == off,\n        /* Linear coefficient is always scl */\n        result[1] == scl,\n        /* Size is always 2 (representing up to degree 1 polynomial) */\n        result.len() == 2,\n        /* Example evaluation: if we evaluate at x=1, we get off + scl */\n        result[0] + result[1] == off + scl", "vc-code": "{\n    // impl-start\n    assume(false);\n    [0; 2]\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_polynomial_polyroots", "vc-description": "Compute the roots of a polynomial.\nGiven polynomial coefficients c[0], c[1], ..., c[n-1], returns the roots of\np(x) = c[0] + c[1]*x + c[2]*x^2 + ... + c[n-1]*x^(n-1).\nFor a polynomial of degree n, there are exactly n roots (counting multiplicity).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn polyroots(c: Vec<f64>) -> (result: Vec<f64>)\n    requires \n        c.len() > 1,\n        c[c.len() - 1] != 0.0,\n    ensures\n        result.len() == c.len() - 1,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_polynomial_polysub", "vc-description": "Subtract one polynomial from another.\nReturns the difference of two polynomials c1 - c2, where polynomials are\nrepresented as coefficient vectors from lowest order term to highest.\n\nSpecification: polysub computes c1 - c2 element-wise, padding with zeros.\nThe result has length max(n, m), and for each coefficient position i:\n- If i < min(n, m): result[i] = c1[i] - c2[i]\n- If min(n, m) ≤ i < n: result[i] = c1[i]\n- If min(n, m) ≤ i < m: result[i] = -c2[i]\n\nAdditionally, polysub satisfies mathematical properties:\n- Anti-commutativity: polysub c1 c2 = -(polysub c2 c1)\n- Zero identity: polysub c 0 = c and polysub 0 c = -c", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn polysub(c1: Vec<i32>, c2: Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        result.len() == if c1.len() >= c2.len() { c1.len() } else { c2.len() },\n        forall|i: int| 0 <= i < result.len() ==> {\n            if i < c1.len() && i < c2.len() {\n                result[i] == c1[i] - c2[i]\n            } else if i < c1.len() && i >= c2.len() {\n                result[i] == c1[i]\n            } else if i >= c1.len() && i < c2.len() {\n                result[i] == 0 - c2[i]\n            } else {\n                result[i] == 0\n            }\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_polynomial_polyval3d", "vc-description": "Evaluate a 3-D polynomial at points (x, y, z).\nThis function evaluates the polynomial p(x,y,z) = Σ_{i,j,k} c[i,j,k] * x^i * y^j * z^k\nwhere the sum is over all valid indices of the coefficient tensor c.\n\nSpecification: polyval3d evaluates a 3-dimensional polynomial at each point (x[i], y[i], z[i]).\nThe polynomial is defined as the sum of c[i,j,k] * x^i * y^j * z^k over all coefficient indices.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn polyval3d(\n    x: Vec<f32>, \n    y: Vec<f32>, \n    z: Vec<f32>, \n    c: Vec<Vec<Vec<f32>>>\n) -> (result: Vec<f32>)\n    requires \n        x.len() == y.len(),\n        y.len() == z.len(),\n        c.len() > 0,\n        forall|i: int| 0 <= i < c.len() ==> c[i].len() > 0,\n        forall|i: int, j: int| 0 <= i < c.len() && 0 <= j < c[i].len() ==> c[i][j].len() > 0,\n    ensures \n        result.len() == x.len(),\n        forall|p: int| 0 <= p < result.len() ==> \n            #[trigger] result[p] == result[p] &&\n            (c.len() == 1 && c[0].len() == 1 && c[0][0].len() == 1 ==> \n             result[p] == c[0][0][0])", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_polynomial_polyvander", "vc-description": "Vandermonde matrix of given degree.\nReturns the Vandermonde matrix of degree `deg` and sample points `x`.\nThe Vandermonde matrix is defined by V[i,j] = x[i]^j for 0 <= j <= deg.\n\nSpecification: polyvander generates a Vandermonde matrix where each row corresponds to\npowers of the corresponding element in x, from degree 0 to deg.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn polyvander(x: Vec<f32>, deg: usize) -> (result: Vec<Vec<f32>>)\n    requires x.len() > 0,\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == deg + 1,\n        forall|i: int| 0 <= i < result.len() ==> result[i][0] == 1.0f32,\n        deg > 0 ==> forall|i: int| 0 <= i < result.len() ==> result[i][1] == x[i]", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_polyutils_format_float", "vc-description": "Format a floating-point number into a string representation.\nThis function takes a floating-point value and converts it to a human-readable \nstring format, handling special cases like NaN and infinity, and choosing \nbetween scientific and positional notation based on the magnitude of the number.\n\nSpecification: format_float produces a valid string representation of a float.\nThe function handles special cases (NaN, infinity) and chooses appropriate \nnotation based on the magnitude of the input. The output string should be \nparseable back to a float representation and preserve the essential value \ncharacteristics.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn format_float(x: f64, parens: bool) -> (result: String)\n    ensures\n        result@.len() > 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "polynomial_polyutils_getdomain", "vc-description": "Return a domain suitable for given abscissae (real numbers).\nFor real inputs, returns the minimum and maximum values as a 2-element vector.\nThis represents the smallest interval containing all points in the input vector.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn getdomain(x: Vec<i32>) -> (result: Vec<i32>)\n    requires x.len() > 0,\n    ensures\n        result.len() == 2,\n        result[0] <= result[1],\n        forall|i: int| 0 <= i < x.len() ==> result[0] <= x[i] && x[i] <= result[1],\n        exists|i: int| 0 <= i < x.len() && x[i] == result[0],\n        exists|j: int| 0 <= j < x.len() && x[j] == result[1],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "random_MT19937", "vc-description": "MT19937 BitGenerator for the Mersenne Twister pseudo-random number generator\n\nMT19937 provides a capsule containing function pointers that produce doubles, \nand unsigned 32 and 64-bit integers. This implementation focuses on the core\nstate initialization and next value generation.\n\nThe Mersenne Twister is a pseudorandom number generator that maintains an\ninternal state and produces a sequence of 32-bit integers with a period of 2^19937 - 1.\n\nParameters:\n- seed : u32 optional seed value to initialize the generator\n\nThe generator produces uniformly distributed values in [0, 2^32 - 1]\n\nSpecification: MT19937 initializes the generator state with proper seeding\n\nThe MT19937 generator maintains a state vector of 624 32-bit integers.\nWhen initialized with a seed, it produces a deterministic sequence.\n\nPrecondition: None (any seed value is valid)\nPostcondition: \n1. The state vector has exactly 624 elements\n2. The state is deterministically initialized based on the seed\n3. The first element of the state equals the seed\n4. The generator produces deterministic values based on the seed\n5. All state values are 32-bit unsigned integers", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn mt19937(seed: u32) -> (state: Vec<u32>)\n    ensures\n        /* The state vector has the correct size (624 elements) */\n        state.len() == 624,\n        /* The first element equals the seed */\n        state[0] == seed,\n        /* State initialization follows MT19937 recurrence relation */\n        forall|i: int| 0 <= i < 623 ==> #[trigger] state[i] == state[i] && {\n            let k = i + 1;\n            let prev_state = state[i];\n            let shifted = prev_state >> 30;\n            let xor_result = prev_state ^ shifted;\n            let mult_result = 1812433253u32.wrapping_mul(xor_result);\n            let next_val = mult_result.wrapping_add(k as u32);\n            state[k] == next_val\n        },", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "random_Philox", "vc-description": "Philox (4x64) pseudo-random number generator.\n\nPhilox is a counter-based RNG that generates pseudo-random numbers\nusing a counter and key. It provides high-quality random numbers\nwith a large period (2^256 - 1) and supports parallel generation.\n\nThe core operation takes a seed and generates a vector of random\nnumbers in the range [0, 1).\n\nSpecification: Philox generates pseudo-random numbers with deterministic behavior.\n\nThe Philox algorithm has several key mathematical properties:\n1. Deterministic: same seed produces same sequence\n2. Uniform distribution: values are uniformly distributed in [0, 1)\n3. Range constraint: all values are in the half-open interval [0, 1)\n4. Reproducibility: identical seeds produce identical sequences\n\nPrecondition: True (no special preconditions)\nPostcondition: All values are in [0, 1) and sequence is deterministic based on seed", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn philox_spec_fn(n: nat, seed: nat) -> Seq<int>;", "vc-helpers": "", "vc-spec": "fn philox(n: usize, seed: u64) -> (result: Vec<i32>)\n    ensures\n        result.len() == n,\n        forall|i: int| 0 <= i < result.len() ==> 0 <= result[i] && result[i] < 1000000,\n        forall|seed1: u64, seed2: u64| seed1 == seed2 ==> \n            philox_spec_fn(n as nat, seed1 as nat) == philox_spec_fn(n as nat, seed2 as nat)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "random_RandomState", "vc-description": "Container for the slow Mersenne Twister pseudo-random number generator\n\nGenerate a random float in the range [0, 1) using the RandomState\nThis models the RandomState.random() method which is the most fundamental\noperation for generating uniformly distributed random numbers.\n\nSpecification: random generates a float in the range [0, 1)\n\nThe random function should satisfy:\n1. The result is always in the range [0, 1)\n2. The result is deterministic given the same seed\n3. The result follows uniform distribution properties", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* A simple random state container that can generate random numbers\n   This models the core functionality of numpy.random.RandomState.\n   We focus on the random() method which generates random floats in [0, 1). */\nstruct RandomState {\n    /* The seed value used to initialize the random number generator */\n    seed: nat,\n}", "vc-helpers": "", "vc-spec": "fn random(state: RandomState) -> (result: f32)", "vc-code": "{\n    // impl-start\n    assume(false);\n    0.0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "random_SFC64", "vc-description": "SFC64 pseudo-random number generator with 256-bit state.\n\nBitGenerator for the SFC64 pseudo-random number generator.\n\nSFC64 is a chaotic RNG that uses a 256-bit state. It is very fast and appears to be very robust to statistical tests.\n\nParameters:\n- seed : None, int, array_like[ints], SeedSequence, BitGenerator, Generator\n    A seed to initialize the BitGenerator\n\nSpecification: SFC64 initializes a 256-bit state from seed", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* SFC64 state containing 256 bits split into four 64-bit words */\nstruct SFC64State {\n    a: u64,\n    b: u64,\n    c: u64,\n    counter: u64,\n}", "vc-helpers": "", "vc-spec": "fn sfc64(seed: Option<u64>) -> (state: SFC64State)\n    ensures\n        seed.is_none() ==> (state.a == 0 && state.b == 0 && state.c == 0 && state.counter == 0),\n        seed.is_some() ==> (state.a != 0 || state.b != 0 || state.c != 0 || state.counter != 0),", "vc-code": "{\n    // impl-start\n    assume(false);\n    SFC64State { a: 0, b: 0, c: 0, counter: 0 }\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "random_SeedSequence", "vc-description": "numpy.random.SeedSequence: Mixes sources of entropy in a reproducible way\nto set the initial state for independent and very probably non-overlapping\nBitGenerators.\n\nSeedSequence takes entropy sources (integers) and mixes them using\ncryptographic hash functions to produce high-quality seed states.\nThe mixing algorithm ensures that even low-quality entropy sources\nproduce high-quality, uniformly distributed output.\n\nKey properties:\n- Reproducible: Same entropy input always produces same output\n- Avalanche effect: Single bit changes affect all output bits\n- Independence: Spawned sequences are non-overlapping\n- Uniform distribution: Output is uniformly distributed over the state space\n\nSpecification: SeedSequence produces a seed state from entropy sources\nwith reproducibility and non-degeneracy properties.\n\nPrecondition: True (accepts any entropy input, including empty)\nPostcondition: \n1. Reproducibility: Same entropy always produces same output\n2. Non-degeneracy: Output depends on input entropy\n3. Deterministic: Function is deterministic for fixed inputs\n4. Well-defined: Always produces valid output within expected bounds", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn seed_sequence_spec(entropy: Seq<u32>, spawn_key: Seq<u32>, pool_size: usize) -> Seq<u32>;\n\nfn seed_sequence(entropy: Vec<u32>, spawn_key: Vec<u32>, pool_size: usize) -> (result: Vec<u32>)\n    requires spawn_key.len() == 0,\n    ensures \n        /* Reproducibility property: same inputs produce same outputs */\n        forall|entropy2: Seq<u32>, spawn_key2: Seq<u32>| \n            entropy@ == entropy2 && spawn_key@ == spawn_key2 ==> \n            seed_sequence_spec(entropy2, spawn_key2, pool_size) == result@,\n        /* Non-degeneracy: output depends on input when entropy is present */\n        entropy.len() > 0 ==> \n            exists|modified_entropy: Seq<u32>| \n                modified_entropy != entropy@ &&\n                seed_sequence_spec(modified_entropy, spawn_key@, pool_size) != result@,\n        /* Well-defined output: result has the correct size */\n        result.len() == pool_size,\n        /* Result specification matches */\n        result@ == seed_sequence_spec(entropy@, spawn_key@, pool_size)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "set_operations_intersect1d", "vc-description": "Find the intersection of two arrays.\nReturns the sorted, unique values that are in both input arrays.\n\nSpecification: intersect1d returns a sorted array of unique values \nthat exist in both input arrays", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn intersect1d(ar1: &Vec<i32>, ar2: &Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        /* Result contains only values that exist in both arrays */\n        forall|i: int| 0 <= i < result.len() ==> \n            (exists|j: int| 0 <= j < ar1.len() && #[trigger] result[i] == ar1[j]) &&\n            (exists|l: int| 0 <= l < ar2.len() && result[i] == ar2[l]),\n        /* Result is sorted in ascending order */\n        forall|i: int, j: int| 0 <= i < j < result.len() ==> \n            #[trigger] result[i] <= #[trigger] result[j],\n        /* Result contains unique values (no duplicates) */\n        forall|i: int, j: int| 0 <= i < j < result.len() ==> \n            #[trigger] result[i] != #[trigger] result[j]", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "set_operations_setdiff1d", "vc-description": "Find the set difference of two arrays.\nReturn the unique values in ar1 that are not in ar2.\n\nSpecification: setdiff1d returns unique values from ar1 that are not in ar2.\nThe result contains no duplicates and is sorted.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn setdiff1d(ar1: Vec<i32>, ar2: Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        /* Each element in result is from ar1 and not in ar2 */\n        forall|i: int| 0 <= i < result.len() ==> \n            exists|j: int| #[trigger] result[i] == ar1[j] && 0 <= j < ar1.len() &&\n            forall|l: int| 0 <= l < ar2.len() ==> result[i] != ar2[l],\n        /* No duplicates in result */\n        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result.len() && i != j ==> \n            result[i] != result[j],\n        /* Result is sorted */\n        forall|i: int, j: int| 0 <= i < j < result.len() ==> result[i] <= result[j]", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "set_operations_setxor1d", "vc-description": "numpy.setxor1d: Find the set exclusive-or of two arrays.\n\nReturn the sorted, unique values that are in only one (not both) of the\ninput arrays. This is equivalent to the symmetric difference of two sets.\n\nThe result contains elements that appear in ar1 but not in ar2, or in ar2 \nbut not in ar1, sorted in ascending order.\n\nSpecification: numpy.setxor1d returns the symmetric difference of two arrays.\n\nPrecondition: True (no special preconditions)\nPostcondition: \n1. The result contains only elements that appear in exactly one of the input arrays\n2. The result is sorted in ascending order\n3. The result contains no duplicates\n4. Every element in the result comes from either ar1 or ar2 (but not both)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn contains_element(arr: Seq<i32>, elem: i32) -> bool {\n    exists|i: int| 0 <= i < arr.len() && arr[i] == elem\n}\n\nspec fn is_sorted(arr: Seq<i32>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < arr.len() ==> arr[i] <= arr[j]\n}\n\nspec fn has_no_duplicates(arr: Seq<i32>) -> bool {\n    forall|i: int, j: int| 0 <= i < arr.len() && 0 <= j < arr.len() && i != j ==> arr[i] != arr[j]\n}\n\nspec fn in_exactly_one(ar1: Seq<i32>, ar2: Seq<i32>, elem: i32) -> bool {\n    (contains_element(ar1, elem) && !contains_element(ar2, elem)) ||\n    (contains_element(ar2, elem) && !contains_element(ar1, elem))\n}", "vc-helpers": "", "vc-spec": "fn numpy_setxor1d(ar1: &Vec<i32>, ar2: &Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        /* Result is sorted */\n        is_sorted(result@),\n        /* Result has no duplicates */\n        has_no_duplicates(result@),\n        /* Every element in result is from exactly one input array */\n        forall|i: int| 0 <= i < result.len() ==> #[trigger] in_exactly_one(ar1@, ar2@, result[i]),\n        /* Every element that appears in exactly one input array is in the result */\n        forall|x: i32| in_exactly_one(ar1@, ar2@, x) ==> contains_element(result@, x)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "set_operations_union1d", "vc-description": "numpy.union1d: Find the union of two arrays.\n\nReturns the unique, sorted array of values that are in either of the two\ninput arrays. The function is equivalent to unique(concatenate(ar1, ar2)).\n\nThe input arrays are flattened if they are not already 1D, and the result\nis always a 1D array containing the union of all elements from both arrays,\nwith duplicates removed and elements sorted in ascending order.\n\nSpecification: numpy.union1d returns the sorted union of two arrays.\n\nPrecondition: True (no special preconditions needed)\nPostcondition: The result contains:\n1. All elements from ar1 and ar2 (union property)\n2. Elements are sorted in ascending order  \n3. No duplicate elements (uniqueness property)\n4. Every element in the result comes from one of the input arrays\n5. Every element from input arrays appears in the result", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn union1d(ar1: Vec<i32>, ar2: Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        /* Union property: every element from either input array is in result */\n        forall|i: int| 0 <= i < ar1.len() ==> \n            #[trigger] result@.contains(ar1[i]),\n        forall|i: int| 0 <= i < ar2.len() ==> \n            #[trigger] result@.contains(ar2[i]),\n        /* Completeness: every element in result comes from one of the input arrays */\n        forall|j: int| 0 <= j < result.len() ==> \n            ar1@.contains(result[j]) || ar2@.contains(result[j]),\n        /* Sorted property: result is sorted in ascending order */\n        forall|i: int, j: int| 0 <= i < j < result.len() ==> \n            #[trigger] result[i] <= #[trigger] result[j],\n        /* Uniqueness property: no duplicate elements */\n        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result.len() && i != j ==> \n            #[trigger] result[i] != #[trigger] result[j],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "sorting_searching_argmin", "vc-description": "numpy.argmin: Returns the index of the minimum value.\n\nReturns the index of the minimum value among all elements in the array.\nRequires a non-empty array since there is no minimum of an empty set.\n\nThis function returns the position of the smallest element in the array.\nIn case of multiple occurrences of the minimum values, the indices\ncorresponding to the first occurrence are returned.\n\nSpecification: numpy.argmin returns the index of the minimum element.\n\nPrecondition: True (non-empty constraint is in the type)\nPostcondition: The element at the returned index is the minimum value,\nand for ties, it returns the first occurrence.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_argmin(a: Vec<i32>) -> (result: usize)\n    requires a.len() > 0,\n    ensures \n        result < a.len(),\n        forall|j: int| 0 <= j < a.len() ==> a[result as int] <= a[j],\n        forall|j: int| 0 <= j < a.len() && a[j] == a[result as int] ==> (result as int) <= j,", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "sorting_searching_argpartition", "vc-description": "Perform an indirect partition along the given axis.\nReturns an array of indices that partition the input array such that\nthe kth element is in its final sorted position and all smaller\nelements are moved before it and all larger elements behind it.\n\nSpecification: argpartition returns indices that correctly partition the array.\nThe kth element is in its final sorted position, with all smaller elements\nbefore it and all larger elements after it.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn argpartition(a: Vec<i32>, kth: usize) -> (indices: Vec<usize>)\n    requires \n        a.len() > 0,\n        kth < a.len(),\n    ensures\n        /* The indices form a valid permutation of 0..n-1 */\n        indices.len() == a.len(),\n        /* Partition property: all elements before kth position are ≤ kth element */\n        forall|i: int| 0 <= i < kth ==> a[#[trigger] indices[i] as int] <= a[#[trigger] indices[kth as int] as int],\n        /* Partition property: all elements after kth position are ≥ kth element */\n        forall|i: int| kth < i && i < indices.len() ==> a[#[trigger] indices[kth as int] as int] <= a[#[trigger] indices[i] as int],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "sorting_searching_bincount", "vc-description": "numpy.bincount: Count number of occurrences of each value in array of non-negative ints.\n\nCount number of occurrences of each value in array of non-negative ints.\nThe number of bins (of size 1) is one larger than the largest value in x.\nEach bin gives the number of occurrences of its index value in x.\n\nThis function takes a 1D array of non-negative integers and returns\nan array where the i-th element is the count of how many times the\nvalue i appears in the input array.\n\nSpecification: numpy.bincount returns count of occurrences of each value.\n\nPrecondition: All values in x are non-negative and ≤ max_val\nPostcondition: result[i] = count of occurrences of value i in x", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn count_occurrences(x: Seq<nat>, val: nat) -> nat {\n    x.filter(|v: nat| v == val).len()\n}\n\nfn numpy_bincount(x: Vec<nat>, max_val: nat) -> (result: Vec<nat>)\n    requires \n        forall|i: int| 0 <= i < x.len() ==> x[i] <= max_val,\n    ensures\n        result.len() == max_val + 1,\n        forall|val: int| 0 <= val <= max_val ==> \n            result[val] == count_occurrences(x@, val as nat),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "sorting_searching_extract", "vc-description": "Return the elements of an array that satisfy some condition.\nThe result size is the number of True entries in the condition array.\n\nSpecification: extract returns elements from arr where condition is True.\nThe result contains exactly those elements from arr at positions where condition is True,\npreserving their original order. The result size m equals the number of True values in condition.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn extract(condition: &Vec<bool>, arr: &Vec<i32>) -> (result: Vec<i32>)\n    requires condition.len() == arr.len(),\n    ensures\n        /* Each element in result comes from arr at a position where condition is true */\n        forall|k: int| 0 <= k < result.len() ==>\n            exists|i: int| 0 <= i < arr.len() && condition[i] == true && #[trigger] result[k] == arr[i],\n        /* Every True position in condition contributes exactly one element to the result */\n        forall|i: int| 0 <= i < condition.len() && condition[i] == true ==>\n            exists|k: int| 0 <= k < result.len() && #[trigger] result[k] == arr[i],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "sorting_searching_lexsort", "vc-description": "Perform an indirect stable sort using a sequence of keys.\nGiven multiple sorting keys, lexsort returns an array of integer indices that \ndescribes the sort order by multiple columns. The last key in the sequence is used\nfor the primary sort order, ties are broken by the second-to-last key, and so on.\n\nSpecification: lexsort returns indices that lexicographically sort the keys.\nThe result is a permutation of indices where for any two positions i, j:\n- If primary key differs, sort by primary key\n- If primary key is equal, sort by second-to-last key, etc.\n- The sort is stable (preserves relative order of equal elements)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn lexsort(keys: Vec<Vec<i32>>) -> (indices: Vec<usize>)\n    requires \n        keys.len() > 0,\n        keys.len() > 0 ==> keys[0].len() > 0,\n        forall|i: int| 0 <= i < keys.len() ==> #[trigger] keys[i as int].len() == keys[0].len(),\n    ensures\n        indices.len() == keys[0].len(),\n        /* indices contains all values from 0 to n-1 exactly once */\n        forall|i: int| 0 <= i < keys[0].len() ==> #[trigger] indices@.contains(i as usize),\n        forall|i: int, j: int| 0 <= i < indices.len() && 0 <= j < indices.len() && i != j ==> indices[i as int] != indices[j as int]", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "sorting_searching_nanargmax", "vc-description": "numpy.nanargmax: Returns the index of the maximum value in a vector, ignoring NaN values.\n\nReturns the index of the maximum value among all non-NaN elements in the array.\nRequires that at least one element is not NaN, otherwise it would raise an error.\n\nIn case of multiple occurrences of the maximum values, the indices\ncorresponding to the first occurrence are returned.\n\nThis function returns the position of the largest non-NaN element in the array.\n\nSpecification: numpy.nanargmax returns the index of the maximum non-NaN element.\n\nPrecondition: At least one element is not NaN\nPostcondition: The element at the returned index is not NaN, is the maximum \namong all non-NaN values, and is the first occurrence of such maximum value.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn nanargmax(a: Vec<i32>) -> (idx: usize)\n    requires \n        a.len() > 0,\n    ensures \n        idx < a.len(),\n        forall|j: int| 0 <= j < a.len() ==> a[j] <= a[idx as int],\n        forall|j: int| 0 <= j < a.len() && a[j] == a[idx as int] ==> (idx as int) <= j,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "sorting_searching_nanargmin", "vc-description": "numpy.nanargmin: Return the indices of the minimum values in the specified axis ignoring NaNs.\n\nFor all-NaN slices ValueError is raised. Warning: the results cannot be trusted \nif a slice contains only NaNs and Infs.\n\nThis function finds the index of the minimum value in a vector, ignoring NaN values.\nIf all values are NaN, it should raise an error (represented as a precondition).\n\nParameters:\n- a : Vector Float n - Input data vector\n\nReturns:\n- Fin n - Index of the minimum non-NaN value\n\nSpecification: nanargmin returns the index of the minimum non-NaN value.\n\nPrecondition: At least one element in the vector is not NaN\nPostcondition: \n1. The returned index points to a non-NaN value\n2. All non-NaN values at other indices are greater than or equal to the value at the returned index\n3. If there are ties, returns the first occurrence (smallest index)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn nanargmin(a: Vec<i32>) -> (result: usize)\n    requires \n        a.len() > 0,\n    ensures\n        result < a.len(),\n        forall|j: int| 0 <= j < a.len() ==> a[result as int] <= a[j],\n        forall|j: int| 0 <= j < result ==> a[j] > a[result as int],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "sorting_searching_partition", "vc-description": "Return a partitioned copy of an array around the k-th element.\n\nSpecification: partition rearranges elements so that the k-th element is in its sorted position,\nwith smaller elements before it and equal/greater elements after it.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_sorted(arr: Seq<i32>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < arr.len() ==> arr[i] <= arr[j]\n}\n\nspec fn count_occurrences(arr: Seq<i32>, x: i32) -> nat \n    decreases arr.len()\n{\n    if arr.len() == 0 {\n        0nat\n    } else {\n        let first_count: nat = if arr[0] == x { 1nat } else { 0nat };\n        first_count + count_occurrences(arr.skip(1), x)\n    }\n}\n\nspec fn multiset_equal(arr1: Seq<i32>, arr2: Seq<i32>) -> bool {\n    arr1.len() == arr2.len() &&\n    forall|x: i32| count_occurrences(arr1, x) == count_occurrences(arr2, x)\n}\n\nfn partition(arr: Vec<i32>, kth: usize) -> (result: Vec<i32>)\n    requires kth < arr.len(),\n    ensures\n        result.len() == arr.len(),\n        /* All elements before kth are <= the kth element */\n        forall|i: int| 0 <= i < kth ==> result[i] <= result[kth as int],\n        /* All elements after kth are >= the kth element */\n        forall|i: int| kth < i < result.len() ==> result[i] >= result[kth as int],\n        /* The k-th element is in its correct sorted position relative to the original array */\n        exists|sorted: Seq<i32>| \n            is_sorted(sorted) &&\n            multiset_equal(sorted, arr@) &&\n            result[kth as int] == sorted[kth as int],\n        /* The result contains the same elements as the original (multiset equality) */\n        multiset_equal(result@, arr@)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "sorting_searching_searchsorted", "vc-description": "numpy.searchsorted: Find indices where elements should be inserted to maintain order.\n\nGiven a sorted array `a` and values `v`, returns indices such that inserting \neach element of `v` at the corresponding index would preserve the sorted order of `a`.\n\nThis implementation focuses on the 'left' side behavior where for each value v[i],\nit returns the leftmost suitable insertion position. The returned indices are\nin the range [0, n] where n is the length of the sorted array.\n\nSpecification: numpy.searchsorted returns indices for sorted insertion.\n\nPrecondition: The input array `a` must be sorted in ascending order\nPostcondition: For each element v[i], the returned index idx satisfies:\n- All elements before idx are strictly less than v[i] (left insertion property)\n- All elements at or after idx are greater than or equal to v[i] (sorted property)\n- The index is valid for insertion (between 0 and n inclusive)\n- Inserting v[i] at idx preserves the sorted order of the array", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_searchsorted(a: Vec<i32>, v: Vec<i32>) -> (result: Vec<usize>)\n    requires \n        forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j],\n    ensures \n        result.len() == v.len()", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "sorting_searching_sort", "vc-description": "numpy.sort: Return a sorted copy of an array.\n\nReturns a new array with the same elements sorted in ascending order.\nThe original array is not modified. This function performs a stable sort \non the array elements, meaning that when multiple records have the same key,\ntheir original order is preserved.\n\nParameters:\n- a : array_like - Array to be sorted\n\nReturns:\n- sorted_array : ndarray - Array of the same type and shape as a, with elements sorted\n\nSpecification: numpy.sort returns a sorted permutation of the input array.\n\nThe specification captures three key properties:\n1. Sorting property: Elements are in non-decreasing order\n2. Permutation property: The result contains exactly the same elements as the input\n3. Stability property: Relative order of equal elements is preserved (implicit in permutation)\n\nPrecondition: True (works for any vector)\nPostcondition: Result is sorted and is a permutation of the input", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn count_occurrences(seq: Seq<i32>, x: i32) -> int\n    decreases seq.len()\n{\n    if seq.len() == 0 {\n        0int\n    } else {\n        (if seq[0] == x { 1int } else { 0int }) + count_occurrences(seq.skip(1), x)\n    }\n}\n\nfn sort(a: Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int, j: int| 0 <= i < j < result.len() ==> result[i] <= result[j],\n        forall|x: i32| count_occurrences(result@, x) == count_occurrences(a@, x)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "statistics_corrcoef", "vc-description": "numpy.corrcoef: Return Pearson product-moment correlation coefficients.\n\nThe correlation coefficient measures the linear relationship between two variables.\nFor two vectors x and y, the correlation coefficient is computed as:\n\ncorr(x, y) = cov(x, y) / (std(x) * std(y))\n\nWhere:\n- cov(x, y) is the covariance between x and y\n- std(x) and std(y) are the standard deviations of x and y\n\nThis function computes the correlation coefficient between two vectors of observations.\nThe result is bounded between -1 and 1, where:\n- 1 indicates perfect positive correlation\n- -1 indicates perfect negative correlation  \n- 0 indicates no linear correlation\n\nRequires non-empty vectors and non-zero variance in both variables.\n\nSpecification: corrcoef computes the Pearson correlation coefficient between two vectors.\n\nThe correlation coefficient satisfies several mathematical properties:\n1. Symmetry: corr(x, y) = corr(y, x)\n2. Bounded: -1 ≤ corr(x, y) ≤ 1\n3. Self-correlation: corr(x, x) = 1 (if x has non-zero variance)\n4. Scale invariance: correlation is preserved under linear transformations\n\nPrecondition: Both vectors have non-zero variance (not all elements equal)\nPostcondition: Result is bounded between -1 and 1, and captures linear relationship", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn corrcoef(x: Vec<i32>, y: Vec<i32>) -> (result: i32)\n    requires \n        x.len() == y.len(),\n        x.len() > 0,\n        exists|i: int, j: int| 0 <= i < x.len() && 0 <= j < x.len() && x[i] != x[j],\n        exists|i: int, j: int| 0 <= i < y.len() && 0 <= j < y.len() && y[i] != y[j],\n    ensures\n        -1000 <= result && result <= 1000", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "statistics_correlate", "vc-description": "Cross-correlation of two 1-dimensional sequences in 'valid' mode.\nComputes c_k = sum_i a_{k+i} * v_i for positions where both sequences fully overlap.\n\nSpecification: correlate computes cross-correlation with valid mode overlap.\nEach output element is the sum of products of overlapping elements from the input sequences.\n\nMathematical properties:\n1. The result has size (m + 1 - n) for valid mode\n2. Each output element k is computed as: sum_i a[k+i] * v[i] for i in [0, n-1]\n3. Only positions where both sequences fully overlap are computed\n4. The correlation preserves the mathematical definition of cross-correlation", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn correlation_sum(a: Seq<i32>, v: Seq<i32>, k: int) -> int\n    decreases v.len()\n{\n    if v.len() == 0 {\n        0\n    } else {\n        a[k] * v[0] + correlation_sum(a, v.skip(1), k + 1)\n    }\n}\n\nfn correlate(a: Vec<i32>, v: Vec<i32>) -> (result: Vec<i32>)\n    requires \n        v.len() > 0,\n        v.len() <= a.len(),\n    ensures\n        result.len() == a.len() + 1 - v.len(),\n        forall|k: int| 0 <= k < result.len() ==> \n            result[k] == correlation_sum(a@, v@, k),", "vc-code": "{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "statistics_cov", "vc-description": "numpy.cov: Estimate a covariance matrix, given data and weights.\n\nCovariance indicates the level to which two variables vary together. \nIf we examine N-dimensional samples, X = [x_1, x_2, ... x_N]^T, \nthen the covariance matrix element C_{ij} is the covariance of x_i and x_j. \nThe element C_{ii} is the variance of x_i.\n\nFor a matrix with `vars` variables and `obs` observations:\n- Each row represents a variable\n- Each column represents an observation\n- Returns a vars × vars covariance matrix\n\nThis implementation focuses on the basic unweighted case without bias correction.\n\nSpecification: numpy.cov computes the covariance matrix from data matrix m.\n\nGiven a data matrix m where each row is a variable and each column is an observation,\nthe covariance matrix C has the following mathematical properties:\n\n1. Symmetry: C[i,j] = C[j,i] for all i,j\n2. Diagonal elements are variances: C[i,i] = Var(X_i)\n3. Off-diagonal elements are covariances: C[i,j] = Cov(X_i, X_j)\n4. Positive semi-definite: all eigenvalues ≥ 0\n\nThe covariance between variables i and j is computed as:\nCov(X_i, X_j) = E[(X_i - μ_i)(X_j - μ_j)]\nwhere μ_i is the mean of variable i.\n\nPrecondition: At least one observation (obs > 0)\nPostcondition: Returns a symmetric positive semi-definite covariance matrix", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn seq_sum(s: Seq<i32>) -> int {\n    s.fold_left(0, |acc: int, x: i32| acc + x)\n}\n\nspec fn variable_mean(var_data: Seq<i32>) -> int {\n    if var_data.len() == 0 {\n        0\n    } else {\n        seq_sum(var_data) / (var_data.len() as int)\n    }\n}\n\nfn numpy_cov(m: Vec<Vec<i32>>) -> (cov_matrix: Vec<Vec<i32>>)\n    requires \n        m.len() > 0,\n        forall|i: int| 0 <= i < m.len() ==> m[i].len() > 0,\n        forall|i: int, j: int| 0 <= i < m.len() && 0 <= j < m.len() ==> m[i].len() == m[j].len(),\n    ensures \n        cov_matrix.len() == m.len(),\n        forall|i: int| 0 <= i < cov_matrix.len() ==> cov_matrix[i].len() == m.len(),\n        forall|i: int, j: int| 0 <= i < m.len() && 0 <= j < m.len() ==> \n            cov_matrix[i][j] == cov_matrix[j][i],\n        forall|i: int| 0 <= i < m.len() ==> cov_matrix[i][i] >= 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "statistics_histogram_bin_edges", "vc-description": "Function to calculate only the edges of the bins used by the histogram function.\nCalculate the bin edges for histogram computation with equal-width bins.\nTakes non-empty data and number of bins, returns bin edges.\nSpecification: histogram_bin_edges computes equal-width bin edges from data range.\nThis comprehensive specification captures:\n1. The number of returned edges equals num_bins + 1\n2. The edges are monotonically increasing (strictly ordered)\n3. The first edge is at or below the minimum data value\n4. The last edge is at or above the maximum data value\n5. The edges are evenly spaced (equal width bins)\n6. All data values fall within the range [first_edge, last_edge]\n7. The bin width is consistent across all bins\n8. The function handles non-empty data correctly", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn histogram_bin_edges(data: Vec<i32>, num_bins: usize) -> (edges: Vec<i32>)\n    requires \n        data.len() > 0,\n        num_bins > 0,\n    ensures\n        edges.len() == num_bins + 1,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "statistics_max", "vc-description": "Returns the maximum value of all elements in a non-empty vector.\nThis is an alias for numpy.amax that returns the maximum value among all elements in the array.\n\nMathematical Properties:\n- Returns an element that exists in the vector\n- No element in the vector is greater than the returned value\n- For constant vectors, returns the constant value\n- Handles non-empty vectors only (n + 1 elements)\n\nSpecification: max returns the maximum value in the vector.\nThis specification delegates to amax_spec since max is an alias for amax.\n\nMathematical properties:\n1. The result is an element that exists in the vector\n2. No element in the vector is greater than the result\n3. The result is unique (first occurrence if there are duplicates)\n4. For constant vectors, max equals the constant value\n5. Sanity check: the maximum exists in the vector", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn max(a: Vec<i32>) -> (result: i32)\n    requires a.len() > 0,\n    ensures\n        /* Core property: result is the maximum element in the vector */\n        exists|max_idx: int| 0 <= max_idx < a.len() &&\n            result == a[max_idx] &&\n            forall|i: int| 0 <= i < a.len() ==> a[i] <= result,\n        /* Uniqueness: result is the first occurrence of the maximum */\n        exists|first_max_idx: int| 0 <= first_max_idx < a.len() &&\n            result == a[first_max_idx] &&\n            (forall|i: int| 0 <= i < a.len() && a[i] == result ==> first_max_idx <= i) &&\n            (forall|i: int| 0 <= i < a.len() ==> a[i] <= result),\n        /* For constant vectors, max equals the constant */\n        (forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() ==> a[i] == a[j]) ==>\n            result == a[0],\n        /* Sanity check: the maximum exists in the vector */\n        exists|witness: int| 0 <= witness < a.len() && result == a[witness],", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "statistics_mean", "vc-description": "Computes the arithmetic mean of all elements in a non-empty vector.\nSpecification: mean computes the arithmetic average of all elements.\nMathematical properties:\n1. The result is the sum of all elements divided by the count\n2. The mean lies between the minimum and maximum values\n3. For constant vectors, mean equals the constant value", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn vec_sum(a: Seq<i32>) -> int \n    decreases a.len()\n{\n    if a.len() == 0 {\n        0\n    } else {\n        a[0] as int + vec_sum(a.skip(1))\n    }\n}\n\nspec fn all_equal(a: Seq<i32>) -> bool {\n    forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() ==> a[i] == a[j]\n}\n\nfn mean(a: Vec<i32>) -> (result: i32)\n    requires a.len() > 0,\n    ensures \n        /* Core property: mean * count == sum */\n        (result as int) * (a.len() as int) == vec_sum(a@),\n        /* For constant vectors, mean equals the constant */\n        all_equal(a@) ==> result == a[0]", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "statistics_median", "vc-description": "Compute the median along the specified axis.\n\nCompute the median of a vector.\nFor odd-length vectors, returns the middle value of the sorted array.\nFor even-length vectors, returns the average of the two middle values.\n\nSpecification: median returns the middle value(s) of a sorted vector.\n- For odd length (n+1), the median is the middle element when sorted\n- For even length (n+1), the median is the average of the two middle elements when sorted\n- The median divides the data such that approximately half the values are ≤ it,\n  and approximately half are ≥ it", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_sorted(a: Seq<i32>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j]\n}\n\nfn median(a: Vec<i32>) -> (result: i32)\n    requires a.len() > 0,\n    ensures \n        exists|sorted: Seq<i32>| #[trigger] sorted.len() == a.len() &&\n            is_sorted(sorted) &&\n            (if a.len() % 2 == 1 {\n                result == sorted[((a.len() - 1) / 2) as int]\n            } else {\n                result == (sorted[(a.len() / 2 - 1) as int] + sorted[(a.len() / 2) as int]) / 2\n            })", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "statistics_min", "vc-description": "numpy.min: Return the minimum of an array or minimum along an axis.\n\nThis function is an alias for numpy.amin that returns the minimum value \namong all elements in the array. Requires a non-empty array since there \nis no minimum of an empty set.\n\nThis is a reduction operation that finds the smallest value in the array.\nNaN values are propagated - if any element is NaN, the result will be NaN.\n\nBeing an alias, it has identical behavior to amin but provides a more\nintuitive name for the operation.\n\nSpecification: min returns the minimum element in the vector.\n\nPrecondition: True (non-empty constraint is enforced by type Vector Float (n + 1))\nPostcondition: result is the minimum value and is an element of the vector\n\nProperties:\n1. The result is actually an element of the input vector\n2. The result is less than or equal to all elements in the vector\n3. This captures the mathematical definition of minimum\n4. As an alias for amin, it has identical mathematical properties", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn min(a: Vec<i32>) -> (result: i32)\n    requires a.len() > 0,\n    ensures\n        exists|i: int| 0 <= i < a.len() && a[i as int] == result,\n        forall|i: int| 0 <= i < a.len() ==> result <= a[i as int],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "statistics_nanmax", "vc-description": "Returns the maximum value of all elements in a non-empty vector, ignoring NaN values.\nWhen all elements are NaN, returns NaN.\n\nMathematical Properties:\n- Ignores NaN values in the computation\n- Returns the maximum of all non-NaN elements\n- If all elements are NaN, returns NaN\n- If at least one element is not NaN, returns the maximum non-NaN value\n- For vectors with no NaN values, behaves identically to regular max\n\nSpecification: nanmax returns the maximum value in the vector, ignoring NaN values.\n\nMathematical properties:\n1. If there exists at least one non-NaN element, the result is the maximum among non-NaN elements\n2. If all elements are NaN, the result is NaN\n3. The result is either a non-NaN element from the vector or NaN\n4. For vectors without NaN values, nanmax behaves identically to regular max\n5. NaN values are completely ignored during the maximum computation\n6. Sanity check: result is either NaN or exists in the vector", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn nanmax(a: Vec<i32>) -> (result: i32)\n    requires a.len() > 0,\n    ensures\n        /* Case 1: If there exists at least one element, the result is from the vector */\n        (exists|max_idx: int| \n            0 <= max_idx < a.len() &&\n            result == a[max_idx]) &&\n        /* Case 2: Result is maximum among all elements */\n        (forall|j: int| 0 <= j < a.len() ==> a[j] <= result) &&\n        /* Case 3: Result exists in the vector */\n        (exists|witness: int| 0 <= witness < a.len() && result == a[witness])", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "statistics_nanmin", "vc-description": "Returns the minimum value of all elements in a non-empty vector, ignoring NaN values.\nWhen all elements are NaN, returns NaN.\n\nMathematical Properties:\n- Ignores NaN values in the computation\n- Returns the minimum of all non-NaN elements\n- If all elements are NaN, returns NaN\n- If at least one element is not NaN, returns the minimum non-NaN value\n- For vectors with no NaN values, behaves identically to regular min\n\nSpecification: nanmin returns the minimum value in the vector, ignoring NaN values.\n\nMathematical properties:\n1. If there exists at least one non-NaN element, the result is the minimum among non-NaN elements\n2. If all elements are NaN, the result is NaN\n3. The result is either a non-NaN element from the vector or NaN\n4. For vectors without NaN values, nanmin behaves identically to regular min\n5. NaN values are completely ignored during the minimum computation\n6. Sanity check: result is either NaN or exists in the vector", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn all_nan(a: Seq<i32>) -> bool \n    decreases a.len()\n{\n    false  /* integers can't be NaN */\n}\n\nspec fn has_non_nan(a: Seq<i32>) -> bool \n    decreases a.len()\n{\n    a.len() > 0  /* all integers are non-NaN */\n}\n\nspec fn is_min_of_all(result: i32, a: Seq<i32>) -> bool {\n    exists|witness: int| 0 <= witness < a.len() &&\n        result == a[witness] &&\n        forall|j: int| 0 <= j < a.len() ==> result <= a[j]\n}\n\nfn nanmin(a: Vec<i32>) -> (result: i32)\n    requires a.len() > 0,\n    ensures is_min_of_all(result, a@)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "statistics_nanpercentile", "vc-description": "Compute the q-th percentile of the data along the specified axis, ignoring NaN values.\nReturns the q-th percentile of the array elements.\nIf all values are NaN, returns NaN.\nThe percentile q must be between 0 and 100 inclusive.\n\nSpecification: nanpercentile computes the q-th percentile of non-NaN values in the array.\nThe result is NaN if all values are NaN, otherwise it's the q-th percentile of the finite values.\nThe percentile is computed by sorting the non-NaN values and finding the value at the position\ncorresponding to the percentile q (between 0 and 100).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn vec_sum(a: Seq<i32>) -> int \n    decreases a.len()\n{\n    if a.len() == 0 {\n        0\n    } else {\n        a[0] + vec_sum(a.skip(1))\n    }\n}\n\nfn nanpercentile(a: Vec<i32>, q: i32) -> (result: i32)\n    requires 0 <= q <= 100,\n    ensures\n        /* Case 1: Empty array returns 0 */\n        a.len() == 0 ==> result == 0,\n        /* Case 2: Non-empty array */\n        a.len() > 0 ==> {\n            /* Result is within bounds of input values */\n            (forall|i: int| 0 <= i < a.len() ==> a[i] <= result || result <= a[i]) &&\n            /* For single element, result equals that element */\n            (a.len() == 1 ==> result == a[0])\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "statistics_nanquantile", "vc-description": "Compute the q-th quantile of the data in a vector, ignoring NaN values.\nWhen all elements are NaN, returns NaN.\n\nMathematical Properties:\n- Ignores NaN values in the computation\n- Returns the q-th quantile of all non-NaN elements \n- If all elements are NaN, returns NaN\n- If at least one element is not NaN, returns the quantile of non-NaN values\n- For q=0, returns the minimum of non-NaN elements\n- For q=1, returns the maximum of non-NaN elements\n- For vectors with no NaN values, behaves identically to regular quantile\n\nSpecification: nanquantile returns the q-th quantile of non-NaN values in the vector.\n\nMathematical properties:\n1. The quantile parameter q must be between 0 and 1 inclusive\n2. If there exists at least one non-NaN element, the result is the q-th quantile among non-NaN elements\n3. If all elements are NaN, the result is NaN\n4. For q=0, result is the minimum of non-NaN elements\n5. For q=1, result is the maximum of non-NaN elements\n6. The result is bounded by the range of non-NaN elements\n7. NaN values are completely ignored during the quantile computation\n8. For vectors without NaN values, nanquantile behaves identically to regular quantile", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn nanquantile(a: Vec<i32>, q: i32) -> (result: i32)\n    requires \n        a.len() > 0,\n        0 <= q <= 100,\n    ensures\n        /* Result is bounded by the elements */\n        (forall|min_idx: int| 0 <= min_idx < a.len() ==> \n         (forall|j: int| 0 <= j < a.len() ==> a[min_idx] <= a[j]) ==> a[min_idx] <= result),\n        (forall|max_idx: int| 0 <= max_idx < a.len() ==>\n         (forall|j: int| 0 <= j < a.len() ==> a[j] <= a[max_idx]) ==> result <= a[max_idx]),\n        /* For q=0, result is the minimum element */\n        (q == 0) ==> \n            (forall|min_idx: int| 0 <= min_idx < a.len() ==>\n             (forall|j: int| 0 <= j < a.len() ==> a[min_idx] <= a[j]) ==>\n             result == a[min_idx]),\n        /* For q=100, result is the maximum element */\n        (q == 100) ==>\n            (forall|max_idx: int| 0 <= max_idx < a.len() ==>\n             (forall|j: int| 0 <= j < a.len() ==> a[j] <= a[max_idx]) ==>\n             result == a[max_idx])", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "statistics_nanstd", "vc-description": "Compute the standard deviation along the specified axis, ignoring NaNs.\nReturns the standard deviation, a measure of the spread of a distribution,\nof the non-NaN array elements. The standard deviation is the square root\nof the variance computed from non-NaN values.\n\nFor all-NaN slices, NaN is returned.\n\nSpecification: nanstd computes the standard deviation while ignoring NaN values.\nMathematical properties:\n1. If vector contains valid (non-NaN) values and ddof < valid_count, \n   result is the square root of the variance of valid values\n2. If all values are NaN, result is NaN\n3. If ddof >= valid_count, result is NaN\n4. Result is always non-negative when valid\n\nThe standard deviation is computed as:\n1. Filter out NaN values to get valid values\n2. Calculate the mean of valid values\n3. Calculate squared deviations from the mean for valid values\n4. Sum the squared deviations\n5. Divide by (valid_count - ddof)\n6. Take the square root of the result", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn count_valid_values(a: Seq<i32>) -> int {\n    a.filter(|x: i32| x != 0).len() as int\n}\n\nspec fn sum_valid_values(a: Seq<i32>) -> int \n    decreases a.len()\n{\n    if a.len() == 0 {\n        0\n    } else {\n        let x = a[0];\n        if x == 0 {\n            sum_valid_values(a.skip(1))\n        } else {\n            x + sum_valid_values(a.skip(1))\n        }\n    }\n}\n\nspec fn mean_of_valid(a: Seq<i32>) -> int {\n    let valid_count = count_valid_values(a);\n    if valid_count > 0 {\n        sum_valid_values(a) / valid_count\n    } else {\n        0\n    }\n}\n\nspec fn sum_squared_deviations_spec(a: Seq<i32>, mean: int) -> int \n    decreases a.len()\n{\n    if a.len() == 0 {\n        0\n    } else {\n        let x = a[0];\n        if x == 0 {\n            sum_squared_deviations_spec(a.skip(1), mean)\n        } else {\n            let deviation = x - mean;\n            deviation * deviation + sum_squared_deviations_spec(a.skip(1), mean)\n        }\n    }\n}\n\nspec fn variance_of_valid(a: Seq<i32>, ddof: int) -> int {\n    let valid_count = count_valid_values(a);\n    if valid_count > 0 && ddof < valid_count {\n        let mean = mean_of_valid(a);\n        let sum_squared_deviations = sum_squared_deviations_spec(a, mean);\n        sum_squared_deviations / (valid_count - ddof)\n    } else {\n        0\n    }\n}\n\nfn nanstd(a: Vec<i32>, ddof: usize) -> (result: i32)\n    ensures ({\n        let valid_count = count_valid_values(a@);\n        let ddof_int = ddof as int;\n        if valid_count > 0 && ddof_int < valid_count {\n            let variance = variance_of_valid(a@, ddof_int);\n            result >= 0\n        } else {\n            result == 0\n        }\n    })", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "statistics_quantile", "vc-description": "Compute the q-th quantile of the data in a vector\n\nSpecification: quantile returns a value that has the property that \napproximately q proportion of the data is less than or equal to it", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn quantile(a: Vec<i32>, q: i32) -> (result: i32)\n    requires \n        a.len() > 0,\n        0 <= q && q <= 100,\n    ensures\n        /* The result is within the range of the input data */\n        (exists|i: int| 0 <= i < a.len() && a[i] <= result) &&\n        (exists|i: int| 0 <= i < a.len() && result <= a[i]) &&\n        /* For 0-quantile, result should be <= minimum */\n        (q == 0 ==> forall|i: int| 0 <= i < a.len() ==> result <= a[i]) &&\n        /* For 100-quantile, result should be >= maximum */\n        (q == 100 ==> forall|i: int| 0 <= i < a.len() ==> a[i] <= result)", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "strings_decode", "vc-description": "numpy.strings.decode: Decode byte strings using the codec\n\nCalls bytes.decode element-wise on a vector of byte strings.\nConverts bytes to strings using the specified encoding.\n\nThis function takes a vector of byte strings and returns a vector\nof decoded strings. The decoding process depends on the encoding\nparameter, with UTF-8 being the default.\n\nSpecification: numpy.strings.decode returns a vector where each element is the decoded string\nfrom the corresponding byte array in the input vector.\n\nMathematical Properties:\n1. Element-wise decoding: result[i] = decode(a[i]) for all i\n2. Deterministic behavior: same input produces same output\n3. Empty byte arrays decode to empty strings\n4. Identity property: decoding is consistent with the specified encoding\n5. Length preservation: decoding preserves structural properties\n6. Error handling: behavior depends on error mode when invalid sequences are encountered\n\nPrecondition: ByteArray elements are well-formed\nPostcondition: Each element is the decoded string using the specified encoding with proper error handling", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn decode(a: Vec<Vec<u8>>, encoding: &str, errors: &str) -> (result: Vec<String>)\n    requires \n        encoding == \"utf-8\" || encoding == \"ascii\",\n        errors == \"strict\" || errors == \"ignore\" || errors == \"replace\",\n        forall|i: int| 0 <= i < a.len() ==> a[i].len() >= 0,\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> (\n            /* Basic well-formedness: decoded strings are valid */\n            result[i]@.len() >= 0 &&\n            \n            /* Deterministic behavior: identical inputs produce identical outputs */\n            (forall|j: int| 0 <= j < a.len() && a[i]@ == a[j]@ ==> result[i]@ == result[j]@) &&\n            \n            /* Empty byte arrays decode to empty strings */\n            (a[i].len() == 0 ==> result[i]@.len() == 0) &&\n            \n            /* Identity property: encoding then decoding with same parameters is identity for valid strings */\n            (encoding == \"utf-8\" ==> true) &&\n            \n            /* Error handling consistency: strict mode fails on invalid sequences */\n            (errors == \"strict\" ==> true) &&\n            \n            /* Length relationship: non-empty valid byte arrays produce strings */\n            (a[i].len() > 0 && encoding == \"utf-8\" ==> (\n                result[i]@.len() > 0 || errors != \"strict\"\n            ))\n        )", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "strings_encode", "vc-description": "numpy.strings.encode: Encode strings using the codec\n\nCalls str.encode element-wise on a vector of strings.\nConverts strings to byte arrays using the specified encoding.\n\nThis function takes a vector of strings and returns a vector\nof encoded byte arrays. The encoding process depends on the encoding\nparameter, with UTF-8 being the default.\n\nSpecification: numpy.strings.encode returns a vector where each element is the encoded byte array\nfrom the corresponding string in the input vector.\n\nKey properties:\n1. Deterministic encoding: same input produces same output\n2. Empty strings encode to empty byte arrays\n3. Encoding preserves string order and length\n4. For UTF-8 encoding, ASCII characters are preserved with same byte length", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn encode(a: Seq<Seq<char>>, encoding: Seq<char>, errors: Seq<char>) -> (result: Seq<Seq<u8>>)\n    ensures\n        result.len() == a.len(),\n        /* Deterministic encoding: same input produces same output */\n        forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() && a[i] == a[j] ==> result[i] == result[j],\n        /* Empty strings encode to empty byte arrays */\n        forall|i: int| 0 <= i < a.len() && a[i].len() == 0 ==> result[i].len() == 0,\n        /* Non-empty strings produce non-empty byte arrays */\n        forall|i: int| 0 <= i < a.len() && a[i].len() > 0 ==> result[i].len() > 0,\n        /* For UTF-8 encoding, encoded size is at least the string length */\n        forall|i: int| 0 <= i < a.len() ==> result[i].len() >= a[i].len(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "strings_endswith", "vc-description": "Check if strings in array end with given suffixes\n\nSpecification: endswith returns boolean array indicating which strings end with corresponding suffixes", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn string_ends_with(s: Seq<char>, suffix: Seq<char>) -> bool {\n    if suffix.len() > s.len() {\n        false\n    } else {\n        s.subrange(s.len() - suffix.len(), s.len() as int) == suffix\n    }\n}\n\nfn endswith(a: Vec<String>, suffix: Vec<String>) -> (result: Vec<bool>)\n    requires a.len() == suffix.len(),\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> {\n            /* Main specification: result matches string_ends_with for each pair */\n            result[i] == string_ends_with(a[i]@, suffix[i]@) &&\n            /* Mathematical property: if result is true, suffix appears at the end */\n            (result[i] ==> {\n                suffix[i]@.len() <= a[i]@.len() &&\n                a[i]@.subrange(a[i]@.len() - suffix[i]@.len(), a[i]@.len() as int) == suffix[i]@\n            }) &&\n            /* Mathematical property: if result is false, suffix does not appear at the end */\n            (!result[i] ==> {\n                suffix[i]@.len() > a[i]@.len() ||\n                a[i]@.subrange(a[i]@.len() - suffix[i]@.len(), a[i]@.len() as int) != suffix[i]@\n            })\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "strings_greater_equal", "vc-description": "numpy.strings.greater_equal: Return the truth value of (x1 >= x2) element-wise for string arrays.\n\nPerforms element-wise string comparison between two vectors of strings.\nReturns a boolean vector indicating whether each string in x1 is greater than or equal \nto the corresponding string in x2 using lexicographic ordering.\n\nThis function compares strings lexicographically and returns True for each\nposition where x1[i] >= x2[i], False otherwise.\n\nExamples:\n- greater_equal [\"apple\", \"banana\"] [\"apple\", \"banana\"] = [true, true]\n- greater_equal [\"zebra\", \"apple\"] [\"apple\", \"banana\"] = [true, false]\n- greater_equal [\"a\", \"bb\"] [\"aa\", \"b\"] = [false, true]\n\nSpecification: numpy.strings.greater_equal returns element-wise greater-than-or-equal comparison.\n\nThis specification captures the mathematical properties of lexicographic string comparison:\n\n1. Core Property: Each position compares strings lexicographically\n2. Reflexive Property: Every string is >= itself\n3. Antisymmetric Property: If s1 >= s2 and s2 >= s1, then s1 = s2\n4. Transitive Property: If s1 >= s2 and s2 >= s3, then s1 >= s3\n5. Total Ordering: For any two strings, either s1 >= s2 or s2 >= s1 (or both)\n6. Consistency: Result is deterministic for same inputs\n\nPrecondition: True (no special preconditions for string comparison)\nPostcondition: Element-wise lexicographic greater-than-or-equal comparison", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn string_lex_ge(s1: Seq<char>, s2: Seq<char>) -> bool\n    decreases s1.len() + s2.len()\n{\n    if s1.len() == 0 {\n        true\n    } else if s2.len() == 0 {\n        true\n    } else if s1[0] == s2[0] {\n        string_lex_ge(s1.skip(1), s2.skip(1))\n    } else {\n        s1[0] >= s2[0]\n    }\n}\n\nfn greater_equal(x1: Vec<String>, x2: Vec<String>) -> (result: Vec<bool>)\n    requires x1.len() == x2.len(),\n    ensures \n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == string_lex_ge(x1[i]@, x2[i]@),\n        /* Reflexive property: every string is >= itself */\n        forall|i: int| 0 <= i < result.len() && x1[i] == x2[i] ==> result[i] == true,\n        /* Empty string properties */\n        forall|i: int| 0 <= i < result.len() && x1[i]@ == Seq::<char>::empty() && x2[i]@ == Seq::<char>::empty() ==> result[i] == true,\n        forall|i: int| 0 <= i < result.len() && x1[i]@ != Seq::<char>::empty() && x2[i]@ == Seq::<char>::empty() ==> result[i] == true,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "strings_isalpha", "vc-description": "numpy.strings.isalpha: Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise.\n\nTests whether all characters in each string are alphabetic letters.\nA string is considered alphabetic if:\n1. It contains at least one character\n2. All characters are alphabetic (a-z, A-Z)\n\nEmpty strings return false.\nStrings with numbers, symbols, or whitespace return false.\n\nSpecification: numpy.strings.isalpha returns a vector where each element indicates\nwhether the corresponding string element contains only alphabetic characters\nand has at least one character.\n\nKey properties:\n1. Empty strings always return false\n2. Non-empty strings return true iff all characters are alphabetic\n3. Alphabetic characters are those satisfying Char.isAlpha (a-z, A-Z)\n4. Strings with digits, whitespace, or symbols return false\n5. The function is applied element-wise to each string in the vector\n\nMathematical properties:\n- Monotonicity: removing non-alphabetic characters from a string cannot make isalpha false\n- Compositionality: isalpha(s) = (s.length > 0) ∧ (∀ c ∈ s, Char.isAlpha c)\n- Deterministic: same input always produces same output", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_alpha_char(c: char) -> bool {\n    ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')\n}\n\nspec fn all_chars_alpha(s: Seq<char>) -> bool \n    decreases s.len()\n{\n    if s.len() == 0 {\n        true\n    } else {\n        is_alpha_char(s[0]) && all_chars_alpha(s.skip(1))\n    }\n}\n\nfn isalpha(a: Vec<String>) -> (result: Vec<bool>)\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> \n            result[i] == (a[i]@.len() > 0 && all_chars_alpha(a[i]@)),\n        forall|i: int| 0 <= i < a.len() ==> \n            (a[i]@.len() == 0 ==> result[i] == false),\n        forall|i: int| 0 <= i < a.len() ==> \n            (a[i]@.len() > 0 ==> (result[i] <==> all_chars_alpha(a[i]@))),\n        forall|i: int| 0 <= i < a.len() ==> \n            (result[i] == true ==> a[i]@.len() > 0),\n        forall|i: int| 0 <= i < a.len() ==> \n            (result[i] == true ==> all_chars_alpha(a[i]@))", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "strings_isdecimal", "vc-description": "For each element, return True if there are only decimal characters in the element.\n\nFor each element, return True if there are only decimal characters in the element\n\nSpecification: isdecimal returns True for each element if all characters in the string \nare decimal characters (including digit characters and all characters that can be used \nto form decimal-radix numbers), and False otherwise.\n\nA decimal character is one that can be used to form decimal-radix numbers. This includes:\n- ASCII digits (0-9)  \n- Unicode decimal characters (e.g., Arabic-Indic digits like U+0660)\n- Does NOT include superscript/subscript digits or other numeric characters\n\nNote: For simplicity, we use c.isDigit which covers decimal characters in most practical cases.\n\nKey properties:\n- Empty strings return False\n- Strings with only decimal characters return True\n- Strings with non-decimal characters return False\n- Mixed decimal/non-decimal characters return False", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_decimal_char(c: char) -> bool {\n    ('0' <= c && c <= '9')\n}\n\nspec fn all_chars_decimal(s: Seq<char>) -> bool\n    decreases s.len()\n{\n    if s.len() == 0 {\n        true\n    } else {\n        is_decimal_char(s[0]) && all_chars_decimal(s.skip(1))\n    }\n}\n\nfn isdecimal(a: Vec<String>) -> (result: Vec<bool>)\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> {\n            &&& (result[i] == true <==> (a[i]@.len() > 0 && all_chars_decimal(a[i]@)))\n            &&& (a[i]@ == Seq::<char>::empty() ==> result[i] == false)\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "strings_islower", "vc-description": "numpy.strings.islower: Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise.\n\nTests whether all cased characters in each string are lowercase.\nA string is considered to satisfy islower if:\n1. It contains at least one cased character (letters that have uppercase/lowercase versions)\n2. All cased characters are lowercase\n3. Non-cased characters (numbers, symbols, whitespace) are ignored for the check\n\nExamples:\n- Empty string \"\" → false (no cased characters)\n- \"123\" → false (no cased characters)\n- \"abc\" → true (all lowercase, has cased characters)\n- \"ABC\" → false (has uppercase)\n- \"aBc\" → false (has uppercase)\n- \"abc123\" → true (has lowercase, no uppercase)\n- \"   \" → false (no cased characters)\n\nSpecification: numpy.strings.islower returns a vector where each element indicates\nwhether the corresponding string element has all cased characters in lowercase\nand contains at least one cased character.\n\nMathematical Properties:\n1. A string is considered \"islower\" if it has at least one cased character AND\n   all cased characters are lowercase\n2. Empty strings return false (no cased characters)\n3. Strings with only non-cased characters (digits, symbols, whitespace) return false\n4. Strings with any uppercase letters return false\n5. Strings with at least one lowercase letter and no uppercase letters return true\n\nEdge Cases:\n- Empty string: false (no cased characters)\n- \"123\": false (no cased characters) \n- \"abc\": true (all lowercase, has cased characters)\n- \"ABC\": false (has uppercase)\n- \"aBc\": false (has uppercase)\n- \"abc123\": true (has lowercase, no uppercase)\n- \"   \": false (no cased characters)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_alpha_char(c: char) -> bool {\n    ('a' <= c <= 'z') || ('A' <= c <= 'Z')\n}\n\nspec fn is_lower_char(c: char) -> bool {\n    'a' <= c <= 'z'\n}\n\nspec fn string_has_cased_char(s: Seq<char>) -> bool {\n    exists|i: int| 0 <= i < s.len() && is_alpha_char(s[i])\n}\n\nspec fn string_all_cased_are_lowercase(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() && is_alpha_char(s[i]) ==> is_lower_char(s[i])\n}\n\nfn islower(a: Vec<String>) -> (result: Vec<bool>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> \n            result[i] == (string_has_cased_char(a[i]@) && string_all_cased_are_lowercase(a[i]@))", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "strings_isupper", "vc-description": "Checks if all cased characters in each string are uppercase and there is at least one character.\n\nSpecification: isupper returns true for each element if all cased characters \nin the string are uppercase and there is at least one character, false otherwise.\nMathematical properties:\n1. Empty strings return false\n2. Strings with no cased characters return false  \n3. Strings with mixed case return false\n4. Strings with all cased characters uppercase return true", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_alpha_char(c: char) -> bool;\n\nspec fn is_upper_char(c: char) -> bool;\n\nspec fn has_alpha_chars(s: Seq<char>) -> bool {\n    exists|i: int| 0 <= i < s.len() && is_alpha_char(s[i])\n}\n\nspec fn all_alpha_are_upper(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() && is_alpha_char(s[i]) ==> is_upper_char(s[i])\n}\n\nfn isupper(a: Vec<String>) -> (result: Vec<bool>)\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> #[trigger] result[i] == {\n            let s = a[i]@;\n            s.len() > 0 && has_alpha_chars(s) && all_alpha_are_upper(s)\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "strings_ljust", "vc-description": "numpy.strings.ljust: Return an array with the elements left-justified in a string of length width.\n\nLeft-justifies each string in the input array by padding it with the specified\nfill character (default is space) to reach the specified width. If the original\nstring is longer than or equal to the width, it remains unchanged.\n\nParameters:\n- a: Input array of strings\n- width: Target width for each string\n- fillchar: Character to use for padding (must be exactly one character)\n\nReturns:\n- Array where each string is left-justified to the specified width\n\nSpecification: ljust returns a vector where each string is left-justified\nto the specified width using the given fill character.\n\nMathematical Properties:\n- Length preservation: Result length is max(original_length, width)\n- Identity: Strings already >= width remain unchanged\n- Left-justification: Original content preserved as prefix, padding on right\n- Minimality: No unnecessary padding beyond required width\n- Fillchar constraint: Padding uses specified fill character", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn ljust(a: Vec<String>, width: usize, fillchar: char) -> (result: Vec<String>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> #[trigger] result[i]@.len() == if a[i]@.len() >= width as nat { a[i]@.len() } else { width as nat },\n        forall|i: int| 0 <= i < a.len() && a[i]@.len() >= width as nat ==> #[trigger] result[i]@ == a[i]@,\n        forall|i: int| 0 <= i < a.len() && a[i]@.len() < width as nat ==> {\n            &&& #[trigger] result[i]@.len() == width as nat\n            &&& result[i]@.subrange(0, a[i]@.len() as int) == a[i]@\n        },\n        forall|i: int| 0 <= i < a.len() && a[i]@.len() == 0 ==> #[trigger] result[i]@.len() == width as nat", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "strings_lower", "vc-description": "numpy.strings.lower: Return an array with the elements converted to lowercase.\n\nConverts each string element in the input vector to lowercase. This transformation\napplies to all alphabetic characters while preserving non-alphabetic characters\n(digits, punctuation, whitespace) unchanged.\n\nThe function preserves the shape of the input array and handles empty strings\nappropriately by returning them unchanged.\n\nFrom NumPy documentation:\n- Parameters: a (array_like) - Input array with string dtype\n- Returns: out (ndarray) - Output array with elements converted to lowercase\n\nMathematical Properties:\n1. Element-wise transformation: result[i] = lower(a[i]) for all i\n2. Length preservation: result[i].length = a[i].length for all i\n3. Case transformation: uppercase letters become lowercase, others unchanged\n4. Idempotent: lower(lower(x)) = lower(x)\n5. Preserves vector length: result.size = a.size", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn char_to_lower(c: char) -> char;\n\nspec fn string_to_lower(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        seq![]\n    } else {\n        seq![char_to_lower(s[0])] + string_to_lower(s.skip(1))\n    }\n}\n\nfn lower(a: Vec<Vec<char>>) -> (result: Vec<Vec<char>>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> #[trigger] result[i]@ == string_to_lower(a[i]@),\n        forall|i: int| 0 <= i < a.len() ==> result[i].len() == a[i].len(),\n        forall|i: int| 0 <= i < a.len() ==> (a[i].len() == 0 ==> result[i].len() == 0),\n        forall|i: int| 0 <= i < a.len() ==> string_to_lower(result[i]@) == result[i]@,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "strings_multiply", "vc-description": "Return (a * i), that is string multiple concatenation, element-wise.\nValues in i of less than 0 are treated as 0 (which yields an empty string).\n\nSpecification: multiply performs element-wise string repetition.\nEach output string is the corresponding input string repeated the specified number of times.\nNegative repetition counts produce empty strings. This comprehensive specification\ncaptures the core mathematical properties of string multiplication in NumPy.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn repeat_string_spec(s: Seq<char>, n: int) -> Seq<char> \n    decreases (if n <= 0 { 0 } else { n }) as nat\n{\n    if n <= 0 {\n        Seq::<char>::empty()\n    } else if n == 1 {\n        s\n    } else {\n        s + repeat_string_spec(s, n - 1)\n    }\n}", "vc-helpers": "", "vc-spec": "fn multiply(a: Vec<String>, i: Vec<i32>) -> (result: Vec<String>)\n    requires a.len() == i.len(),\n    ensures \n        result.len() == a.len(),\n        /* Core property: Element-wise string repetition */\n        forall|j: int| 0 <= j < a.len() ==> \n            result[j]@ == repeat_string_spec(a[j]@, i[j] as int),\n        /* Zero/negative repetition property: Always yields empty string */\n        forall|j: int| 0 <= j < a.len() && i[j] <= 0 ==> \n            result[j]@ == Seq::<char>::empty(),\n        /* Identity property: Multiplying by 1 yields the original string */\n        forall|j: int| 0 <= j < a.len() && i[j] == 1 ==> \n            result[j] == a[j],\n        /* Zero property: Multiplying by 0 yields empty string */\n        forall|j: int| 0 <= j < a.len() && i[j] == 0 ==> \n            result[j]@ == Seq::<char>::empty(),\n        /* Empty string property: Empty strings remain empty regardless of repetition */\n        forall|j: int| 0 <= j < a.len() && a[j]@ == Seq::<char>::empty() ==> \n            result[j]@ == Seq::<char>::empty(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "strings_rfind", "vc-description": "For each element, return the highest index in the string where substring is found, such that sub is contained within [start, end]. Returns -1 if sub is not found.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn string_starts_with(s: Seq<char>, prefix: Seq<char>, start_pos: int) -> bool {\n    start_pos >= 0 && start_pos + prefix.len() <= s.len() &&\n    forall|i: int| 0 <= i < prefix.len() ==> s[start_pos + i] == prefix[i]\n}\n\nfn rfind(a: Vec<String>, sub: Vec<String>, start: Vec<i32>, end_pos: Vec<i32>) -> (result: Vec<i32>)\n    requires \n        a.len() == sub.len() && sub.len() == start.len() && start.len() == end_pos.len(),\n        forall|i: int| 0 <= i < start.len() ==> 0 <= start[i] && start[i] <= end_pos[i],\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> (\n            /* Basic range constraint: result is -1 or within string bounds */\n            (result[i] == -1 || (0 <= result[i] && result[i] < a[i]@.len())) &&\n            /* If result is -1, no occurrence of substring within the specified range */\n            (result[i] == -1 ==> \n                forall|j: int| start[i] <= j && j + sub[i]@.len() <= end_pos[i] + 1 && \n                               j + sub[i]@.len() <= a[i]@.len() ==> \n                    !string_starts_with(a[i]@, sub[i]@, j)) &&\n            /* If result is non-negative, it's the rightmost valid occurrence */\n            (result[i] >= 0 ==> \n                /* The result is within the search range */\n                start[i] <= result[i] && \n                result[i] + sub[i]@.len() <= end_pos[i] + 1 &&\n                /* The substring matches at this position */\n                string_starts_with(a[i]@, sub[i]@, result[i] as int) &&\n                /* This is the rightmost occurrence within the range */\n                (forall|j: int| result[i] < j && j + sub[i]@.len() <= end_pos[i] + 1 && \n                                start[i] <= j && j + sub[i]@.len() <= a[i]@.len() ==> \n                    !string_starts_with(a[i]@, sub[i]@, j)))\n        ),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "strings_rindex", "vc-description": "numpy.strings.rindex - String information\nLike rfind, but raises ValueError when the substring is not found\n\nFor each element, return the highest index in the string where substring is found.\nUnlike rfind, this function requires that the substring be found in each string,\nensuring all results are non-negative indices.\n\nSpecification: rindex returns the highest index where substring is found within range.\nThe key difference from rfind is that rindex has a stronger precondition:\nthe substring must exist in each string within the specified range.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn rindex(a: Vec<String>, sub: Vec<String>, start: Vec<usize>, end_pos: Vec<usize>) -> (result: Vec<usize>)\n    requires \n        a.len() == sub.len() && sub.len() == start.len() && start.len() == end_pos.len(),\n        forall|i: int| 0 <= i < a.len() ==> {\n            start[i] <= end_pos[i] &&\n            end_pos[i] <= 1000 &&\n            start[i] <= end_pos[i]\n        },\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> {\n            start[i] <= result[i] && \n            result[i] <= end_pos[i]\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "strings_rpartition", "vc-description": "numpy.strings.rpartition: Partition each element in a around the right-most separator.\n\nPartitions each string in the input vector at the last occurrence of the separator.\nReturns a 3-tuple of vectors: (before_separator, separator, after_separator).\n\nFor each element in the input array, splits the element at the last occurrence\nof the separator, and returns three vectors containing the part before the separator,\nthe separator itself, and the part after the separator. If the separator is not found,\nthe third vector contains the whole string, and the first and second vectors contain\nempty strings.\n\nFrom NumPy documentation:\n- Parameters: a (array_like with StringDType), sep (array_like with StringDType)\n- Returns: 3-tuple of ndarrays with StringDType\n\nMathematical Properties:\n1. Right partition semantics: For each string s, if sep occurs at position i (rightmost), then:\n   - before = s[0:i]\n   - separator = sep (if found) or \"\" (if not found)\n   - after = s[i+len(sep):] (if found) or \"\" (if not found)\n2. Completeness: before ++ separator ++ after = original string (when sep is found)\n3. Last occurrence: Only splits at the last occurrence of sep\n4. Not found case: If sep not in string, returns (\"\", \"\", original_string)\n5. Preserves vector length: All three result vectors have the same length as input", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn rpartition(a: Vec<String>, sep: String) -> (result: (Vec<String>, Vec<String>, Vec<String>))\n    requires true,\n    ensures \n        result.0.len() == a.len(),\n        result.1.len() == a.len(),\n        result.2.len() == a.len()", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "strings_rsplit", "vc-description": "For each element in a vector, return a list of the words in the string, using sep as the delimiter string.\nSplits from the right, meaning that splits are made from the right side of the string.\n\nSpecification: rsplit splits each string in the vector from the right using the given separator.\nThe resulting vector contains lists of strings where each list represents the split parts\nof the corresponding input string.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn rsplit(a: Vec<String>, sep: String, maxsplit: usize) -> (result: Vec<Vec<String>>)\n    requires \n        sep@.len() > 0,\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() > 0,\n        maxsplit == 0 ==> forall|i: int| 0 <= i < result.len() ==> \n            result[i].len() == 1 && result[i][0]@ == a[i]@,\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() <= maxsplit + 1,\n        forall|i: int| 0 <= i < result.len() ==> \n            (a[i]@.len() == 0 ==> result[i].len() == 1 && result[i][0]@.len() == 0),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "strings_split", "vc-description": "For each element in a vector of strings, return a list of the words in the string, using sep as the delimiter string.\nSpecification: split returns a vector where each string is split into a list of substrings based on the separator, with proper handling of maxsplit constraints and reconstruction properties.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn split(a: Vec<String>, sep: String, maxsplit: Option<usize>) -> (result: Vec<Vec<String>>)\n    requires\n        sep@ != Seq::<char>::empty(),\n        a.len() > 0,\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> {\n            let parts = #[trigger] result[i]@;\n            let original = #[trigger] a[i]@;\n            (forall|j: int| 0 <= j < parts.len() ==> parts[j]@ != sep@) &&\n            (match maxsplit {\n                None => true,\n                Some(limit) => parts.len() <= limit + 1,\n            }) &&\n            parts.len() >= 1 &&\n            (original.len() == 0 ==> parts.len() == 1 && parts[0]@.len() == 0) &&\n            (original == sep@ ==> parts.len() == 2 && parts[0]@.len() == 0 && parts[1]@.len() == 0)\n        },", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "strings_startswith", "vc-description": "Check if strings in array start with given prefixes\n\nSpecification: startswith returns boolean array indicating which strings start with corresponding prefixes", "vc-preamble": "use vstd::prelude::*;\nuse vstd::string::*;\n\nverus! {\nspec fn string_starts_with(s: Seq<char>, prefix: Seq<char>) -> bool {\n    prefix.len() <= s.len() && s.subrange(0, prefix.len() as int) == prefix\n}", "vc-helpers": "", "vc-spec": "fn startswith(a: Vec<String>, prefixes: Vec<String>) -> (result: Vec<bool>)\n    requires a.len() == prefixes.len(),\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> {\n            &&& (result[i] == string_starts_with(a[i]@, prefixes[i]@))\n            &&& (result[i] ==> prefixes[i]@.len() <= a[i]@.len())\n            &&& (result[i] ==> a[i]@.subrange(0, prefixes[i]@.len() as int) == prefixes[i]@)\n            &&& (!result[i] ==> (prefixes[i]@.len() > a[i]@.len() || a[i]@.subrange(0, prefixes[i]@.len() as int) != prefixes[i]@))\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "strings_upper", "vc-description": "numpy.strings.upper: Return an array with the elements converted to uppercase.\n\nConverts each string element in the input vector to uppercase. This transformation\napplies to all alphabetic characters while preserving non-alphabetic characters\n(digits, punctuation, whitespace) unchanged.\n\nThe function preserves the shape of the input array and handles empty strings\nappropriately by returning them unchanged.\n\nFrom NumPy documentation:\n- Parameters: a (array_like) - Input array with string dtype\n- Returns: out (ndarray) - Output array with elements converted to uppercase\n\nMathematical Properties:\n1. Element-wise transformation: result[i] = upper(a[i]) for all i\n2. Length preservation: result[i].length = a[i].length for all i\n3. Case transformation: lowercase letters become uppercase, others unchanged\n4. Idempotent: upper(upper(x)) = upper(x)\n5. Preserves vector length: result.size = a.size\n\nSpecification: numpy.strings.upper returns a vector where each string element\nis converted to uppercase.\n\nMathematical Properties:\n1. Element-wise correctness: Each element is correctly converted to uppercase\n2. Length preservation: Each transformed string has the same length as the original\n3. Case transformation: Lowercase letters become uppercase, others unchanged\n4. Idempotent property: Applying upper twice gives the same result as applying it once\n5. Empty string handling: Empty strings remain empty\n6. Character-level correctness: Each character is correctly transformed\n\nPrecondition: True (no special preconditions for uppercase conversion)\nPostcondition: For all indices i, result[i] is the uppercase version of a[i]", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn string_to_upper(s: Seq<char>) -> Seq<char> {\n    s\n}", "vc-helpers": "", "vc-spec": "fn upper(a: Vec<String>) -> (result: Vec<String>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==>\n            result[i]@ == string_to_upper(a[i]@) &&\n            result[i]@.len() == a[i]@.len()", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "strings_zfill", "vc-description": "numpy.strings.zfill: Return the numeric string left-filled with zeros.\n\nZero-fills each string in the input array by padding it with leading zeros\nto reach the specified width. If the original string is longer than or equal\nto the width, it remains unchanged. This function is specifically designed\nfor numeric strings and handles sign prefixes appropriately.\n\nThe function behaves like Python's str.zfill() method:\n- Pads strings with leading zeros to reach the target width\n- Preserves sign characters ('+' or '-') at the beginning\n- Returns original string if it's already >= target width\n\nFrom NumPy documentation:\n- Parameters: a (array_like) - Input array with string dtype\n              width (int) - Target width for zero-filling\n- Returns: out (ndarray) - Output array with zero-filled strings\n\nMathematical Properties:\n1. Length invariant: result length is max(original_length, width)\n2. Identity: strings already >= width remain unchanged\n3. Zero-padding: shorter strings get leading zeros\n4. Sign preservation: leading '+' or '-' characters are preserved\n5. Minimality: no over-padding beyond required width", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_sign_char(c: char) -> bool {\n    c == '+' || c == '-'\n}\n\nspec fn all_zeros(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nspec fn max_usize(a: usize, b: usize) -> usize {\n    if a >= b { a } else { b }\n}\n\nfn zfill(a: Vec<Vec<char>>, width: usize) -> (result: Vec<Vec<char>>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> \n            #[trigger] result[i].len() == max_usize(a[i].len(), width),\n        forall|i: int| 0 <= i < result.len() && a[i].len() >= width ==> \n            #[trigger] result[i]@ == a[i]@,\n        forall|i: int| 0 <= i < result.len() && a[i].len() < width && a[i].len() > 0 && \n            !is_sign_char(a[i]@[0]) ==> \n            #[trigger] all_zeros(result[i]@.take((width - a[i].len()) as int)) &&\n            result[i]@.skip((width - a[i].len()) as int) == a[i]@,\n        forall|i: int| 0 <= i < result.len() && a[i].len() < width && a[i].len() > 0 && \n            is_sign_char(a[i]@[0]) ==> \n            #[trigger] result[i]@[0] == a[i]@[0] &&\n            result[i]@.skip(width as int) == a[i]@.skip(1),\n        forall|i: int| 0 <= i < result.len() && a[i].len() == 0 ==> \n            #[trigger] result[i].len() == width && \n            all_zeros(result[i]@),\n        forall|i: int| 0 <= i < result.len() && a[i].len() < width ==> \n            #[trigger] result[i].len() == width,\n        forall|i: int| 0 <= i < result.len() && a[i].len() < width ==> \n            #[trigger] all_zeros(result[i]@.take((width - a[i].len()) as int))", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "ufunc_accumulate", "vc-description": "Universal function accumulate method: Accumulate the result of applying a binary operator\nto all elements in a vector.\n\nFor a binary operation `op` and input vector [a₁, a₂, a₃, ..., aₙ], returns:\n[a₁, op(a₁, a₂), op(op(a₁, a₂), a₃), ..., op(op(...op(a₁, a₂), a₃), ..., aₙ)]\n\nThis generalizes cumulative operations:\n- When op = (+), this becomes cumsum: [a₁, a₁+a₂, a₁+a₂+a₃, ...]\n- When op = (*), this becomes cumprod: [a₁, a₁*a₂, a₁*a₂*a₃, ...]\n\nThe result has the same shape as the input array.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn accumulate(a: Vec<f64>) -> (result: Vec<f64>)\n    ensures\n        result.len() == a.len(),\n        a.len() > 0 ==> result[0] == a[0],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "ufunc_outer", "vc-description": "Universal function outer method: Apply a binary operator to all pairs (a, b) \nwith a in A and b in B.\n\nFor two 1-D vectors A = [a₁, a₂, ..., aₘ] and B = [b₁, b₂, ..., bₙ], \nthe outer product produces an m×n matrix where result[i,j] = op(A[i], B[j]).\n\nThis generalizes the concept of outer product beyond just multiplication:\n- When op = (*), this becomes the traditional outer product\n- When op = (+), this becomes the sum of all pairs\n- When op = (^), this becomes the power of all pairs\n\nThe result has shape (m, n) where m is the length of A and n is the length of B.\n\nSpecification: outer applies a binary operator to all pairs of elements\nfrom two input vectors, producing a matrix result.\n\nPrecondition: True (works for any two vectors and binary operation)\nPostcondition:\n- Result has dimensions m × n (outer dimensions of input vectors)\n- Each element result[i][j] equals op(a[i], b[j])\n- The result preserves the structure of the Cartesian product of the inputs\n- All pairs (i,j) with i ∈ [0..m-1] and j ∈ [0..n-1] are covered exactly once\n\nMathematical Properties:\n- result[i][j] = op(a[i], b[j]) for all valid i, j\n- The result matrix has the same number of rows as the first input vector\n- The result matrix has the same number of columns as the second input vector\n- For commutative operations: outer(op, a, b)[i][j] = outer(op, b, a)[j][i]\n- For associative operations: outer preserves the algebraic structure", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn outer(op: spec_fn(f64, f64) -> f64, a: Vec<f64>, b: Vec<f64>) -> (result: Vec<Vec<f64>>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == b.len(),\n        forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < b.len() ==> \n            result[i][j] == op(a[i], b[j])", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "ufunc_reduceat", "vc-description": "Universal function reduceat method: Performs reductions on specified slices of an array.\n\nFor each index pair (indices[i], indices[i+1]), applies the reduction operation \nto the slice array[indices[i]:indices[i+1]].\n\nSpecial behavior:\n- For the last index, reduces from indices[i] to the end of the array\n- If indices[i] >= indices[i+1], uses only the element at indices[i]\n- Output length equals the number of indices provided\n\nExample: np.add.reduceat([1,2,3,4,5,6,7,8], [0,4,1,5]) applies addition to slices:\n- [1,2,3,4] -> 10\n- [2,3,4,5] -> 14  \n- [5,6,7,8] -> 26\nResult: [10, 14, 26]", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn slice_sum(arr: Seq<i32>, start: int, end: int) -> int\n    decreases (end - start)\n{\n    if start >= end || start < 0 || end > arr.len() {\n        0\n    } else if start + 1 == end {\n        arr[start] as int\n    } else {\n        (arr[start] as int) + slice_sum(arr, start + 1, end)\n    }\n}\n\nfn reduceat_add(arr: Vec<i32>, indices: Vec<usize>) -> (result: Vec<i32>)\n    requires \n        arr.len() > 0,\n        indices.len() > 0,\n        forall|i: int| 0 <= i < indices.len() ==> #[trigger] (indices[i] as int) < arr.len(),\n    ensures\n        result.len() == indices.len(),\n        forall|i: int| 0 <= i < indices.len() ==> {\n            let start_idx = indices[i] as int;\n            if i < indices.len() - 1 {\n                let end_idx = indices[(i + 1) as int] as int;\n                if start_idx < end_idx {\n                    /* Normal forward slice case */\n                    #[trigger] (result[i] as int) == slice_sum(arr@, start_idx, end_idx)\n                } else {\n                    /* Single element case when indices are non-increasing */\n                    #[trigger] result[i] == arr[start_idx]\n                }\n            } else {\n                /* Last index case - reduce to end of array */\n                #[trigger] (result[i] as int) == slice_sum(arr@, start_idx, arr.len() as int)\n            }\n        },", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "ufuncs_identity", "vc-description": "{\n  \"name\": \"identity\",\n  \"description\": \"The identity value for the ufunc\",\n  \"details\": \"Value such that func(x, identity) == x for all x\",\n  \"examples\": {\n    \"add.identity\": \"0\",\n    \"multiply.identity\": \"1\",\n    \"logical_and.identity\": \"True\",\n    \"logical_or.identity\": \"False\"\n  }\n}\n\nufunc.identity: Get the identity element for a ufunc operation.\n\nReturns the identity element for a given binary operation, which is the value\nthat when combined with any other value using that operation, leaves the other\nvalue unchanged. For example:\n- Addition: identity is 0 (x + 0 = x)\n- Multiplication: identity is 1 (x * 1 = x)\n- Logical AND: identity is True (x ∧ True = x)\n- Logical OR: identity is False (x ∨ False = x)\n\nSome operations may have no identity element, in which case None is returned.\n\nSpecification: ufunc_identity returns the identity element if it exists.\n\nPrecondition: The operation is a valid binary function\nPostcondition: If an identity element exists, applying the operation with\n               that element leaves any other element unchanged", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nenum OpType {\n    Add,\n    Multiply,\n    LogicalAnd,\n    LogicalOr,\n}\n\nspec fn apply_op(op: OpType, x: int, y: int) -> int {\n    match op {\n        OpType::Add => x + y,\n        OpType::Multiply => x * y,\n        OpType::LogicalAnd => if x != 0 && y != 0 { 1 } else { 0 },\n        OpType::LogicalOr => if x != 0 || y != 0 { 1 } else { 0 },\n    }\n}\n\nspec fn has_identity(op: OpType, id: int) -> bool {\n    forall|x: int| apply_op(op, x, id) == x && apply_op(op, id, x) == x\n}", "vc-helpers": "", "vc-spec": "fn ufunc_identity(op: OpType) -> (result: Option<int>)\n    ensures\n        match result {\n            Some(id) => has_identity(op, id),\n            None => forall|id: int| !has_identity(op, id)\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    None\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "ufuncs_nargs", "vc-description": "The number of arguments the ufunc accepts. Equal to nin + nout.\n\nnumpy.ufunc.nargs: Returns the total number of arguments the ufunc accepts.\n\nThis attribute represents the sum of input and output arguments for a ufunc.\nFor example, np.add has nin=2, nout=1, so nargs=3.\n\nThis is a read-only attribute that provides metadata about the ufunc's signature.\n\nSpecification: numpy.ufunc.nargs returns nin + nout\n\nPrecondition: True (no special preconditions for reading metadata)\nPostcondition: The result equals the sum of input and output arguments", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* Structure representing a NumPy universal function (ufunc) with its metadata */\nstruct Ufunc {\n    /* Number of input arguments the ufunc accepts */\n    nin: nat,\n    /* Number of output arguments the ufunc produces */\n    nout: nat,\n}", "vc-helpers": "", "vc-spec": "fn numpy_nargs(ufunc: Ufunc) -> (result: nat)\n    ensures result == ufunc.nin + ufunc.nout", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "ufuncs_nout", "vc-description": "The number of output arguments\n\nReturns the number of output arguments for a given ufunc.\nThis corresponds to the nout attribute of NumPy ufuncs.\n\nSpecification: nout returns the number of output arguments of the ufunc.\n\nThis specification captures the essential mathematical properties of the nout attribute:\n\n1. **Correctness**: The function returns exactly the nout_val field from the ufunc structure\n2. **Lower bound**: The result is always ≥ 1, since all ufuncs can produce at least one output\n3. **Type safety**: The result is a natural number representing a count\n4. **Determinism**: Given the same ufunc, nout always returns the same value\n\nMathematical properties:\n- ∀ ufunc : UFunc, nout(ufunc) = ufunc.nout_val  \n- ∀ ufunc : UFunc, nout(ufunc) ≥ 1\n- nout is a pure function (no side effects)\n\nExamples from NumPy documentation:\n- add.nout = 1 (binary operation with single output)\n- modf.nout = 2 (returns fractional and integral parts)\n- divmod.nout = 2 (returns quotient and remainder)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* Represents a universal function (ufunc) type that captures basic metadata about \n   the number of inputs and outputs. In NumPy, this would be the ufunc object itself. */\nstruct UFunc {\n    /* Number of input arguments the ufunc accepts */\n    nin: nat,\n    /* Number of output arguments the ufunc produces */\n    nout_val: nat,\n}", "vc-helpers": "", "vc-spec": "fn nout(ufunc: UFunc) -> (result: nat)\n    requires ufunc.nout_val >= 1,\n    ensures \n        result == ufunc.nout_val,\n        result >= 1", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "ufuncs_signature", "vc-description": "Core signature for generalized ufuncs. Defines core dimensionality of inputs and outputs. Parse a ufunc signature string into a structured representation. Specification: parseSignature correctly parses ufunc signature strings.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* A signature represents the core dimensionality pattern for a generalized ufunc */\npub struct UfuncSignature {\n    /* Input dimension patterns as list of dimension lists */\n    pub inputs: Vec<Vec<String>>,\n    /* Output dimension patterns as list of dimension lists */\n    pub outputs: Vec<Vec<String>>,\n    /* All unique dimension names used in the signature */\n    pub dimension_names: Vec<String>,\n}", "vc-helpers": "", "vc-spec": "fn parse_signature(sig: Vec<String>) -> (result: UfuncSignature)\n    requires sig.len() > 0,\n    ensures\n        result.inputs.len() > 0 || result.outputs.len() > 0,\n        result.inputs.len() + result.outputs.len() > 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
{"id": "ufuncs_types", "vc-description": "List of supported data type signatures\nShows input->output type mappings for universal functions\nReturns formatted type signatures as strings", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n/* Data type character codes used in NumPy ufunc type signatures */\n#[derive(PartialEq, Eq)]\nenum TypeCode {\n    Bool,       // '?'\n    Byte,       // 'b' \n    UByte,      // 'B'\n    Short,      // 'h'\n    UShort,     // 'H'\n    Int,        // 'i'\n    UInt,       // 'I'\n    Long,       // 'l'\n    ULong,      // 'L'\n    LongLong,   // 'q'\n    ULongLong,  // 'Q'\n    Float32,    // 'f'\n    Float64,    // 'd'\n    LongDouble, // 'g'\n    Complex64,  // 'F'\n    Complex128, // 'D'\n    CLongDouble,// 'G'\n    Object,     // 'O'\n}\n\n/* Type signature representing input->output mapping for ufuncs */\nstruct TypeSignature {\n    input_types: Vec<TypeCode>,\n    output_type: TypeCode,\n}\n\n/* Convert TypeCode to character representation */\nspec fn type_code_to_char(tc: TypeCode) -> char {\n    match tc {\n        TypeCode::Bool => '?',\n        TypeCode::Byte => 'b',\n        TypeCode::UByte => 'B',\n        TypeCode::Short => 'h',\n        TypeCode::UShort => 'H',\n        TypeCode::Int => 'i',\n        TypeCode::UInt => 'I',\n        TypeCode::Long => 'l',\n        TypeCode::ULong => 'L',\n        TypeCode::LongLong => 'q',\n        TypeCode::ULongLong => 'Q',\n        TypeCode::Float32 => 'f',\n        TypeCode::Float64 => 'd',\n        TypeCode::LongDouble => 'g',\n        TypeCode::Complex64 => 'F',\n        TypeCode::Complex128 => 'D',\n        TypeCode::CLongDouble => 'G',\n        TypeCode::Object => 'O',\n    }\n}\n\n/* Format a type signature as a string (input1input2...->output) */\nspec fn format_type_signature(sig: TypeSignature) -> Seq<char> {\n    let input_chars = sig.input_types@.map(|i: int, tc: TypeCode| type_code_to_char(tc));\n    let arrow_chars = seq!['-', '>'];\n    let output_char = seq![type_code_to_char(sig.output_type)];\n    input_chars + arrow_chars + output_char\n}", "vc-helpers": "", "vc-spec": "fn types(ufunc_signatures: Vec<TypeSignature>) -> (result: Vec<String>)\n    ensures\n        result.len() == ufunc_signatures.len(),\n        forall|i: int| 0 <= i < result.len() ==>\n            result[i]@ == format_type_signature(ufunc_signatures[i]) &&\n            ufunc_signatures[i].input_types.len() > 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}"}
