vc-description: |-
  numpy.tensordot: Compute tensor dot product along specified axes.
  
  Given two tensors a and b, and axes, sums the products of a's and b's 
  elements over the axes specified. For 1-D arrays (vectors) with axes=1,
  this computes the inner product of vectors.
  
  This specification focuses on the 1-D case with axes=1, which is equivalent
  to the dot product operation.
  
  Specification: tensordot computes the tensor dot product along specified axes.
  
  For 1-D vectors with axes=1, this is equivalent to the inner product:
  result = sum(a[i] * b[i] for i in 0..n-1)
  
  Mathematical properties:
  - Commutative: tensordot(a, b, 1) = tensordot(b, a, 1)
  - Bilinear: tensordot(α*a + β*c, b, 1) = α*tensordot(a, b, 1) + β*tensordot(c, b, 1)
  - Zero vector: tensordot(zeros, b, 1) = 0
  - Self-product: tensordot(a, a, 1) = ||a||²
  
  Precondition: axes = 1 (for 1-D vector case)
  Postcondition: result equals the sum of element-wise products

vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {

vc-helpers: |-

vc-spec: |-
  spec fn dot_product_recursive(a: Seq<i32>, b: Seq<i32>, i: nat) -> int
      decreases a.len() - i
  {
      if i >= a.len() {
          0
      } else {
          a[i as int] * b[i as int] + dot_product_recursive(a, b, i + 1)
      }
  }
  
  spec fn dot_product(a: Seq<i32>, b: Seq<i32>) -> int {
      dot_product_recursive(a, b, 0)
  }
  
  fn tensordot(a: Vec<i32>, b: Vec<i32>, axes: usize) -> (result: i32)
      requires 
          a.len() == b.len(),
          axes == 1,
      ensures result == dot_product(a@, b@)

vc-code: |-
  {
      assume(false);
      unreached()
  }

vc-postamble: |-
  }
  fn main() {}