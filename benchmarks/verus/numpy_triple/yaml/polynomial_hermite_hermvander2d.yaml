vc-description: |-
  Pseudo-Vandermonde matrix of given degrees for 2D Hermite polynomials.
  
  Returns a matrix where each row corresponds to a sample point (x[i], y[i]),
  and columns represent products of Hermite polynomials H_i(x) * H_j(y).
  The column at index (ydeg + 1)*i + j contains H_i(x) * H_j(y).
  
  This creates the design matrix for fitting 2D Hermite polynomial surfaces,
  where coefficients are arranged in row-major order: c_00, c_01, ..., c_10, c_11, ...
  
  Specification: hermvander2d creates a 2D Vandermonde matrix where each element
  V[k][(ydeg + 1)*i + j] equals H_i(x[k]) * H_j(y[k]), where H_i denotes the 
  i-th Hermite polynomial. The Hermite polynomials follow the recurrence:
  H_0(t) = 1, H_1(t) = 2t, H_n(t) = 2t * H_{n-1}(t) - 2(n-1) * H_{n-2}(t)

vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {

vc-helpers: |-

vc-spec: |-
  spec fn hermite_polynomial(n: nat, t: int) -> int
      decreases n
  {
      if n == 0 {
          1
      } else if n == 1 {
          2 * t
      } else {
          2 * t * hermite_polynomial((n - 1) as nat, t) - 2 * (n - 1) * hermite_polynomial((n - 2) as nat, t)
      }
  }
  
  fn hermvander2d(x: Vec<i32>, y: Vec<i32>, xdeg: usize, ydeg: usize) -> (result: Vec<Vec<i32>>)
      requires x.len() == y.len(),
      ensures 
          result.len() == x.len(),
          forall|k: int| 0 <= k < result.len() ==> #[trigger] result[k].len() == (xdeg + 1) * (ydeg + 1),
          forall|k: int| 0 <= k < result.len() ==> #[trigger] result[k][0] == 1

vc-code: |-
  {
      // impl-start
      assume(false);
      Vec::new()
      // impl-end
  }

vc-postamble: |-
  }
  fn main() {}

