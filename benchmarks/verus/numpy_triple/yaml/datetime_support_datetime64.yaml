vc-description: |-
  Create a datetime64 object representing an offset from 1970-01-01T00:00:00
  
  {
    "name": "numpy.datetime64",
    "category": "Datetime types", 
    "description": "Create a datetime64 object representing an offset from 1970-01-01T00:00:00",
    "url": "https://numpy.org/doc/stable/reference/arrays.datetime.html#numpy.datetime64",
    "doc": "If created from a 64-bit integer, it represents an offset from ``1970-01-01T00:00:00``. If created from string, the string can be in ISO 8601 date or datetime format.\n\nWhen parsing a string to create a datetime object, if the string contains a trailing timezone (A 'Z' or a timezone offset), the timezone will be dropped and a User Warning is given.\n\nDatetime64 objects should be considered to be UTC and therefore have an offset of +0000.\n\n>>> np.datetime64(10, 'Y')\nnp.datetime64('1980')\n>>> np.datetime64('1980', 'Y')\nnp.datetime64('1980')\n>>> np.datetime64(10, 'D')\nnp.datetime64('1970-01-11')\n\nSee :ref:`arrays.datetime` for more information.\n\n:Character code: ``'M'``"
  }
  
  Create a datetime64 object from an integer offset and time unit
  
  Specification: datetime64 creates a UTC datetime object with the specified offset and unit.
  The datetime64 object represents a specific moment in time as an offset from the Unix epoch
  (1970-01-01T00:00:00 UTC) in the specified time unit. The function preserves the input
  parameters and ensures the result is always in UTC timezone.
  
  /* Time unit for datetime64 */
  
  /* Years unit ('Y') */
  
  /* Days unit ('D') */
  
  /* Hours unit ('h') */
  
  /* Minutes unit ('m') */
  
  /* Seconds unit ('s') */
  
  /* Milliseconds unit ('ms') */
  
  /* Microseconds unit ('us') */
  
  /* Nanoseconds unit ('ns') */
  
  /* DateTime64 structure representing offset from Unix epoch */
  
  /* Offset value from 1970-01-01T00:00:00 */
  
  /* Time unit of the offset */
  
  /* Always UTC with +0000 offset */
  
  /* Unit-specific validity constraints based on NumPy datetime64 limits */
  
  /* Valid year range */
  
  /* Days since epoch */
  
  /* Hours since epoch */
  
  /* Minutes since epoch */
  
  /* Seconds since epoch */
  
  /* Milliseconds can use full Int range */
  
  /* Microseconds can use full Int range */
  
  /* Nanoseconds can use full Int range */

vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  pub enum TimeUnit {
  
      Years,
  
      Days,
  
      Hours,
  
      Minutes,
  
      Seconds,
  
      Milliseconds,
  
      Microseconds,
  
      Nanoseconds,
  }
  
  pub struct DateTime64 {
  
      pub offset: i64,
  
      pub unit: TimeUnit,
  
      pub is_utc: bool,
  }

vc-helpers: |-

vc-spec: |-
  fn datetime64(offset: i64, unit: TimeUnit) -> (result: DateTime64)
      ensures 
          result.offset == offset,
          result.unit == unit,
          result.is_utc == true,
  
          match unit {
              TimeUnit::Years => result.offset + 1970 >= 1 && result.offset + 1970 <= 9999,
              TimeUnit::Days => result.offset >= -2147483648 && result.offset <= 2147483647,
              TimeUnit::Hours => result.offset >= -2147483648 && result.offset <= 2147483647,
              TimeUnit::Minutes => result.offset >= -2147483648 && result.offset <= 2147483647,
              TimeUnit::Seconds => result.offset >= -2147483648 && result.offset <= 2147483647,
              TimeUnit::Milliseconds => true,
              TimeUnit::Microseconds => true,
              TimeUnit::Nanoseconds => true,
          }

vc-code: |-
  {
      assume(false);
      unreached()
  }

vc-postamble: |-
  }
  fn main() {}

