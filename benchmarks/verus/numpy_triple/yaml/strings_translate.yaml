vc-description: |-
  numpy.strings.translate: For each element in a, return a copy of the string where 
  all characters occurring in deletechars are removed, and the remaining characters 
  have been mapped through the given translation table.
  
  This function performs character-level transformation on byte strings by first
  removing characters specified in deletechars, then translating each remaining
  character using a 256-byte translation table.
  
  Specification for numpy.strings.translate: Returns a vector where each element is 
  the result of character deletion followed by character translation.
  
  Mathematical Properties:
  1. Element-wise transformation: Each result element is derived from the corresponding input
  2. Two-stage process: First deletion, then translation
  3. Deletion completeness: All occurrences of characters in deletechars are removed
  4. Translation mapping: Each remaining byte is mapped through the translation table
  5. Order preservation: Relative order of non-deleted characters is maintained
  6. Empty string handling: Empty strings remain empty after transformation

vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {

vc-helpers: |-

vc-spec: |-
  fn translate(a: Vec<Vec<u8>>, table: Vec<u8>, deletechars: Vec<u8>) -> (result: Vec<Vec<u8>>)
      requires
          table.len() == 256,
      ensures
          result.len() == a.len(),
          forall|i: int| 0 <= i < a.len() ==> {
              // Length property: result length <= original length (due to deletion)
              result[i].len() <= a[i].len() &&
  
              // Deletion property: no character from deletechars appears in result
              (forall|c: u8| #[trigger] result[i]@.contains(c) ==> {
                  forall|j: int| 0 <= j < deletechars.len() ==> c != deletechars[j]
              }) &&
  
              // Translation property: each byte in result comes from table translation
              (forall|k: int| 0 <= k < result[i].len() ==> {
                  exists|orig_char: u8, table_idx: int|
                      0 <= table_idx < 256 &&
                      orig_char == table_idx as u8 &&
                      #[trigger] result[i][k] == table[table_idx as int] &&
                      // The original character existed in input and wasn't deleted
                      a[i]@.contains(orig_char) &&
                      (forall|j: int| 0 <= j < deletechars.len() ==> orig_char != deletechars[j])
              }) &&
  
              // Completeness property: all non-deleted characters are translated and included  
              (forall|orig_char: u8| #[trigger] a[i]@.contains(orig_char) ==> {
                  (forall|j: int| 0 <= j < deletechars.len() ==> orig_char != deletechars[j]) ==> {
                      exists|translated_char: u8| result[i]@.contains(translated_char) &&
                          exists|table_idx: int|
                              0 <= table_idx < 256 &&
                              orig_char as int == table_idx &&
                              translated_char == table[table_idx as int]
                  }
              }) &&
  
              // Identity on empty deletechars
              (deletechars.len() == 0 ==> {
                  result[i].len() == a[i].len() &&
                  (forall|k: int| 0 <= k < a[i].len() ==> {
                      exists|table_idx: int|
                          0 <= table_idx < 256 &&
                          a[i][k] as int == table_idx &&
                          #[trigger] result[i][k] == table[table_idx as int]
                  })
              }) &&
  
              // Empty string preservation
              (a[i].len() == 0 ==> result[i].len() == 0)
          }

vc-code: |-
  {
      // impl-start
      assume(false);
      Vec::new()
      // impl-end
  }

vc-postamble: |-
  }
  fn main() {}

