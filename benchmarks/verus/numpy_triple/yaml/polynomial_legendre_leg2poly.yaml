vc-description: |-
  Convert a Legendre series to a polynomial.
  
  Convert a Legendre series to a polynomial.
  
      Convert an array representing the coefficients of a Legendre series,
      ordered from lowest degree to highest, to an array of the coefficients
      of the equivalent polynomial (relative to the "standard" basis) ordered
      from lowest to highest degree.
  
      Parameters
      ----------
      c : array_like
          1-D array containing the Legendre series coefficients, ordered
          from lowest order term to highest.
  
      Returns
      -------
      pol : ndarray
          1-D array containing the coefficients of the equivalent polynomial
          (relative to the "standard" basis) ordered from lowest order term
          to highest.
  
      See Also
      --------
      poly2leg
  
      Notes
      -----
      The easy way to do conversions between polynomial basis sets
      is to use the convert method of a class instance.
  
      Examples
      --------
      >>> from numpy import polynomial as P
      >>> c = P.Legendre(range(4))
      >>> c
      Legendre([0., 1., 2., 3.], domain=[-1.,  1.], window=[-1.,  1.], symbol='x')
      >>> p = c.convert(kind=P.Polynomial)
      >>> p
      Polynomial([-1. , -3.5,  3. ,  7.5], domain=[-1.,  1.], window=[-1., ...
      >>> P.legendre.leg2poly(range(4))
      array([-1. , -3.5,  3. ,  7.5])
  
  Convert a Legendre series to a polynomial (monomial basis)
  
  Specification: leg2poly converts Legendre series coefficients to polynomial coefficients
  
  /* For small cases (n < 3), the conversion is identity */
  
  /* The conversion transforms Legendre basis to monomial basis */
  
  /* The mathematical property is that ∑ cᵢ Pᵢ(x) = ∑ result[i] xⁱ */
  
  /* where Pᵢ are the Legendre polynomials */
  
  /* The transformation is well-defined and preserves polynomial degree */

vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {

vc-helpers: |-

vc-spec: |-
  fn leg2poly(c: Vec<f32>) -> (result: Vec<f32>)
      ensures
          result.len() == c.len(),
  
          c.len() < 3 ==> forall|i: int| 0 <= i < c.len() ==> result[i] == c[i],
  
          forall|i: int| 0 <= i < result.len() ==> exists|val: f32| result[i] == val,
  
          c.len() > 0 ==> exists|lead: f32| result[c.len() - 1] == lead,

vc-code: |-
  {
      assume(false);
      unreached()
  }

vc-postamble: |-
  }
  fn main() {}

