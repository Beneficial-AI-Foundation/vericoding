vc-description: |-
  numpy.cov: Estimate a covariance matrix, given data and weights.

  Covariance indicates the level to which two variables vary together. 
  If we examine N-dimensional samples, X = [x_1, x_2, ... x_N]^T, 
  then the covariance matrix element C_{ij} is the covariance of x_i and x_j. 
  The element C_{ii} is the variance of x_i.

  For a matrix with `vars` variables and `obs` observations:
  - Each row represents a variable
  - Each column represents an observation
  - Returns a vars × vars covariance matrix

  This implementation focuses on the basic unweighted case without bias correction.

  Specification: numpy.cov computes the covariance matrix from data matrix m.

  Given a data matrix m where each row is a variable and each column is an observation,
  the covariance matrix C has the following mathematical properties:

  1. Symmetry: C[i,j] = C[j,i] for all i,j
  2. Diagonal elements are variances: C[i,i] = Var(X_i)
  3. Off-diagonal elements are covariances: C[i,j] = Cov(X_i, X_j)
  4. Positive semi-definite: all eigenvalues ≥ 0

  The covariance between variables i and j is computed as:
  Cov(X_i, X_j) = E[(X_i - μ_i)(X_j - μ_j)]
  where μ_i is the mean of variable i.

  Precondition: At least one observation (obs > 0)
  Postcondition: Returns a symmetric positive semi-definite covariance matrix

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-

vc-spec: |-
  spec fn seq_sum(s: Seq<i32>) -> int {
      s.fold_left(0, |acc: int, x: i32| acc + x)
  }

  spec fn variable_mean(var_data: Seq<i32>) -> int {
      if var_data.len() == 0 {
          0
      } else {
          seq_sum(var_data) / (var_data.len() as int)
      }
  }

  fn numpy_cov(m: Vec<Vec<i8>>) -> (cov_matrix: Vec<Vec<i8>>)
      requires 
          m.len() > 0,
          forall|i: int| 0 <= i < m.len() ==> m[i]@.len() > 0,
          forall|i: int, j: int| 0 <= i < m.len() && 0 <= j < m.len() ==> m[i]@.len() == m[j]@.len(),
      ensures 
          cov_matrix@.len() == m@.len(),
          forall|i: int| 0 <= i < cov_matrix@.len() ==> cov_matrix[i]@.len() == m@.len(),
          forall|i: int, j: int| 0 <= i < m@.len() && 0 <= j < m@.len() ==> 
              cov_matrix[i][j] as int == cov_matrix[j][i] as int,
          forall|i: int| 0 <= i < m@.len() ==> cov_matrix[i][i] as int >= 0,

vc-code: |-
  {
      // impl-start
      assume(false);
      unreached()
      // impl-end
  }

vc-postamble: |-

  }
  fn main() {}