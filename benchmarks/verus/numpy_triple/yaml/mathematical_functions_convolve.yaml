vc-description: |-
  numpy.convolve: Returns the discrete, linear convolution of two one-dimensional arrays.

  The discrete convolution operation is defined as:
  (a * v)[n] = sum(a[m] * v[n - m], m = -∞ to ∞)

  For finite arrays, the convolution is computed over the valid range where
  both arrays have elements. This implementation follows the 'full' mode
  which returns a convolution of length (M + N - 1) where M and N are
  the lengths of the input arrays.

  Specification: numpy.convolve returns the discrete convolution of two vectors.

  Precondition: Both input vectors must be non-empty (enforced by types)
  Postcondition: The result vector contains the discrete convolution values

  The convolution at position k is computed as:
  result[k] = sum(a[i] * v[k - i] for all valid i)

  Mathematical properties:
  1. Result length is m + n - 1 (enforced by return type)
  2. Each element follows the convolution definition
  3. Boundary conditions: zero-padding is implicitly assumed outside array bounds

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-

vc-spec: |-
  spec fn convolution_element_sum(a: Seq<i32>, v: Seq<i32>, k: int) -> int
      decreases a.len()
  {
      if a.len() == 0 {
          0
      } else {
          let i = 0;
          let contribution = if k >= i && k - i < v.len() {
              a[i] * v[k - i]
          } else {
              0
          };
          contribution + convolution_element_sum(a.skip(1), v, k)
      }
  }

  fn numpy_convolve(a: Vec<i32>, v: Vec<i32>) -> (result: Vec<i32>)
      requires a.len() > 0 && v.len() > 0,
      ensures 
          result.len() == a.len() + v.len() - 1,
          forall|k: int| 0 <= k < result.len() ==> result[k] == convolution_element_sum(a@, v@, k),
          result[0] == a[0] * v[0],
          result[result.len() - 1] == a[a.len() - 1] * v[v.len() - 1],

vc-code: |-
  {
      // impl-start
      assume(false);
      unreached()
      // impl-end
  }

vc-postamble: |-

  }
  fn main() {}