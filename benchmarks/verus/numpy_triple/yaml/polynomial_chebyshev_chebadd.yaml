vc-description: |-
  Add one Chebyshev series to another.

  Add one Chebyshev series to another. Returns the sum of two Chebyshev series c1 + c2. The arguments are sequences of coefficients ordered from lowest order term to highest, i.e., [1,2,3] represents the series T_0 + 2*T_1 + 3*T_2.

  Add two Chebyshev series coefficient-wise.

  This function adds two Chebyshev polynomial series represented by their coefficients. The coefficients are ordered from lowest degree to highest degree term. For example, [1,2,3] represents T_0 + 2*T_1 + 3*T_2 where T_i is the i-th Chebyshev polynomial.

  The addition is performed component-wise, padding with zeros if the arrays have different lengths.

  Specification: chebadd performs coefficient-wise addition of two Chebyshev series.

  The specification captures both the mathematical properties and implementation details:
  1. For indices within both arrays, the result is the sum of corresponding coefficients
  2. For indices beyond one array's length, the result equals the coefficient from the longer array
  3. The result preserves the Chebyshev series representation property
  4. The operation is commutative up to reordering when n â‰  m
  5. Adding a zero vector yields the original vector (identity property)

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-

vc-spec: |-
  fn chebadd(c1: Vec<i8>, c2: Vec<i8>) -> (result: Vec<i8>)
      ensures
          result.len() == if c1.len() >= c2.len() { c1.len() } else { c2.len() },
          forall|i: int| 0 <= i < result.len() ==> {
              if i < c1.len() && i < c2.len() {
                  result[i] as int == c1[i] as int + c2[i] as int
              } else if i < c1.len() {
                  result[i] as int == c1[i] as int
              } else if i < c2.len() {
                  result[i] as int == c2[i] as int
              } else {
                  result[i] as int == 0
              }
          },
          forall|i: int| 0 <= i < c1@.len() ==> c1[i] != 0 ==> {
              exists|j: int| 0 <= j < result@.len() && j == i && {
                  if i < c2@.len() {
                      result[j] as int == c1[i] as int + c2[i] as int
                  } else {
                      result[j] as int == c1[i] as int
                  }
              }
          },
          forall|i: int| 0 <= i < c2@.len() ==> c2[i] != 0 ==> {
              exists|j: int| 0 <= j < result@.len() && j == i && {
                  if i < c1@.len() {
                      result[j] as int == c1[i] as int + c2[i] as int
                  } else {
                      result[j] as int == c2[i] as int
                  }
              }
          }

vc-code: |-
  {
      // impl-start
      assume(false);
      unreached()
      // impl-end
  }

vc-postamble: |-

  }
  fn main() {}