vc-description: |-
  Evaluate a 2D polynomial at points (x, y).
  Given a coefficient matrix c and evaluation points (x, y),
  computes p(x,y) = Σᵢⱼ cᵢⱼ·xⁱ·yʲ for each point pair
  
  Specification: polyval2d evaluates a 2D polynomial with coefficient matrix c at point pairs (x, y).
  The result at each point (xᵢ, yᵢ) is the polynomial value p(xᵢ, yᵢ) = Σᵢⱼ cᵢⱼ·xᵢⁱ·yᵢʲ
  
  Mathematical properties:
  - For coefficient matrix c[i][j], evaluates p(x,y) = Σᵢⱼ c[i][j]·xⁱ·yʲ
  - Reduces to 1D polyval when one variable is zero: p(x,0) uses first column c[*][0]
  - Bilinear in coefficients: p(x,y, αc₁ + βc₂) = α·p(x,y,c₁) + β·p(x,y,c₂)  
  - Constant term: p(0,0) = c[0][0]
  - Degree-0 in both variables gives constant: c = [[c₀₀]] → p(x,y) = c₀₀ for all (x,y)
  
  /* Constant term property: when both degrees are 0 */
  
  /* Zero coefficient property: if all coefficients are zero, result is zero */
  
  /* Evaluation at origin gives constant term */

vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {

vc-helpers: |-

vc-spec: |-
  fn polyval2d(x: Vec<f32>, y: Vec<f32>, c: Vec<Vec<f32>>) -> (result: Vec<f32>)
      requires 
          x@.len() == y@.len(),
          x@.len() > 0,
          c@.len() > 0,
          forall|i: int| 0 <= i < c@.len() ==> #[trigger] c@[i].len() > 0,
          forall|i: int| 0 <= i < c@.len() ==> #[trigger] c@[i].len() == c@[0].len(),
      ensures
          result@.len() == x@.len(),
  
          (c@.len() == 1 && c@[0].len() == 1) ==> 
              (forall|k: int| 0 <= k < result@.len() ==> #[trigger] result@[k] == c@[0][0]),
  
          (forall|i: int, j: int| 0 <= i < c@.len() && 0 <= j < c@[i].len() ==> #[trigger] c@[i][j] == 0.0f32) ==> 
              (forall|k: int| 0 <= k < result@.len() ==> #[trigger] result@[k] == 0.0f32),
  
          forall|k: int| 0 <= k < result@.len() && x@[k] == 0.0f32 && y@[k] == 0.0f32 ==> 
              #[trigger] result@[k] == c@[0][0],

vc-code: |-
  {
      assume(false);
      unreached()
  }

vc-postamble: |-
  }
  fn main() {}