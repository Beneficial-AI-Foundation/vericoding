vc-description: |-
  numpy.power: First array elements raised to powers from second array, element-wise.
  
  Raise each base in x1 to the positionally-corresponding power in x2.
  This is equivalent to x1 ** x2 in terms of array broadcasting.
  
  The function computes x1[i] raised to the power x2[i] for each index i.
  
  Mathematical properties:
  - x^0 = 1 for any non-zero x
  - x^1 = x for any x
  - x^(a+b) = x^a * x^b for any x, a, b
  - (x^a)^b = x^(a*b) for any x, a, b
  
  Specification: numpy.power returns a vector where each element is the base
  from x1 raised to the power from x2.
  
  Precondition: For mathematical validity, we require:
  - If x1[i] = 0, then x2[i] ≥ 0 (0^negative is undefined)
  - If x1[i] < 0, then x2[i] should be an integer (for real results, checked by floor = value)
  
  Postcondition: For all indices i, result[i] = x1[i] ^ x2[i]
  
  Key mathematical properties ensured:
  1. Identity: If x2[i] = 0 and x1[i] ≠ 0, then result[i] = 1
  2. Base case: If x2[i] = 1, then result[i] = x1[i]
  3. Monotonicity: If x1[i] > 1 and x2[i] > 0, then result[i] > x1[i]

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-

vc-spec: |-
  fn numpy_power(x1: Vec<i8>, x2: Vec<i8>) -> (result: Vec<i8>)
      requires 
          x1.len() == x2.len(),
          forall|i: int| 0 <= i < x1@.len() ==> {
              (x1[i] as int == 0 ==> x2[i] as int >= 0)
          },
      ensures
          result.len() == x1.len(),
          forall|i: int| 0 <= i < result@.len() ==> {
              (x2[i] as int == 0 && x1[i] as int != 0 ==> result[i] as int == 1) &&
              (x2[i] as int == 1 ==> result[i] as int == x1[i] as int) &&
              (x1[i] as int > 1 && x2[i] as int > 0 ==> result[i] as int > x1[i] as int)
          }

vc-code: |-
  {
      // impl-start
      assume(false);
      unreached()
      // impl-end
  }

vc-postamble: |-

  }
  fn main() {}