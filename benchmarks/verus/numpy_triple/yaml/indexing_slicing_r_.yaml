vc-description: |-
  numpy.r_: Translates slice objects to concatenation along the first axis.
  
  This is a simple way to build up arrays quickly. There are two main use cases:
  1. If the index expression contains comma separated arrays, then stack them along their first axis
  2. If the index expression contains slice notation or scalars then create a 1-D array with a range
  
  This implementation focuses on the first use case - concatenating two 1D arrays along the first axis.
  The r_ object provides a convenient way to concatenate arrays by using index notation.
  
  For example, numpy.r_[array1, array2] concatenates array1 and array2.
  
  Specification: numpy.r_ concatenates arrays along the first axis.
  
  Precondition: True (no special preconditions for basic concatenation)
  Postcondition: The result contains all elements from the first array followed by all elements from the second array.
  This comprehensive specification captures:
  1. First n elements come from array a (preserving order and values)
  2. Next m elements come from array b (preserving order and values)
  3. Total length is n + m (enforced by type system)
  4. No elements are duplicated or lost (bijective mapping)
  5. The concatenation preserves all original values exactly
  6. Order is preserved within each original array

vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {

vc-helpers: |-

vc-spec: |-
  fn r_(a: Vec<f32>, b: Vec<f32>) -> (result: Vec<f32>)
      ensures
          result.len() == a.len() + b.len(),
          forall|i: int| 0 <= i < a.len() ==> result[i] == a[i],
          forall|j: int| 0 <= j < b.len() ==> result[a.len() + j] == b[j]

vc-code: |-
  {
      // impl-start
      assume(false);
      Vec::new()
      // impl-end
  }

vc-postamble: |-
  }
  fn main() {}

