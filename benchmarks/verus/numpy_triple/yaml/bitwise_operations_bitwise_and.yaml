vc-description: |-
  numpy.bitwise_and: Compute the bit-wise AND of two arrays element-wise.
  
  Computes the bit-wise AND of the underlying binary representation of 
  the integers in the input arrays. This ufunc implements the C/Python 
  operator &.
  
  For each pair of corresponding elements in x1 and x2, the result contains
  the bitwise AND of their binary representations. Each bit position in the
  result is 1 only if both corresponding bits in x1 and x2 are 1.
  
  Examples:
  - 13 & 17 = 1 (binary: 01101 & 10001 = 00001)
  - 14 & 13 = 12 (binary: 01110 & 01101 = 01100)
  
  Note: This specification currently handles only non-negative integers.
  For negative integers, NumPy uses two's complement representation,
  which requires a more complex formalization in Lean.
  
  Specification: bitwise_and returns a vector where each element is the 
  bitwise AND of the corresponding elements from x1 and x2.
  
  Precondition: All elements are non-negative (to simplify the specification)
  
  Postcondition: 
  1. For non-negative integers, each element of the result is the bitwise AND 
     of corresponding inputs
  2. The result preserves the mathematical properties of bitwise AND:
     - Commutativity: x & y = y & x
     - Associativity: (x & y) & z = x & (y & z)
     - Identity: x & (2^k - 1) = x for x < 2^k (all 1s acts as identity)
     - Annihilator: x & 0 = 0
     - Idempotence: x & x = x
  3. The result is always less than or equal to both inputs (for non-negative integers)
  4. Each bit in the result is 1 iff both corresponding bits in the inputs are 1

vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {

vc-helpers: |-

vc-spec: |-
  fn bitwise_and(x1: Vec<i32>, x2: Vec<i32>) -> (result: Vec<i32>)
      requires 
          x1.len() == x2.len(),
          forall|i: int| 0 <= i < x1.len() ==> x1[i] >= 0,
          forall|i: int| 0 <= i < x2.len() ==> x2[i] >= 0,
      ensures
          result.len() == x1.len(),
          forall|i: int| 0 <= i < result.len() ==> result[i] == (x1[i] & x2[i]),
          forall|i: int| 0 <= i < result.len() ==> result[i] >= 0,
          forall|i: int| 0 <= i < result.len() ==> result[i] <= x1[i],
          forall|i: int| 0 <= i < result.len() ==> result[i] <= x2[i],
          forall|i: int| 0 <= i < result.len() ==> (result[i] == 0 <==> (x1[i] == 0 || x2[i] == 0)),
          forall|i: int| 0 <= i < result.len() ==> (x1[i] == x2[i] ==> result[i] == x1[i]),

vc-code: |-
  {
      assume(false);
      unreached();
  }

vc-postamble: |-
  }
  fn main() {}

