vc-description: |-
  numpy.linalg.pinv: Compute the (Moore-Penrose) pseudo-inverse of a matrix.

  Calculate the generalized inverse of a matrix using its
  singular-value decomposition (SVD) and including all
  large singular values.

  For a matrix A, the pseudo-inverse A+ is defined as the matrix that
  'solves' the least-squares problem Ax = b. If A is invertible,
  then pinv(A) == inv(A).

  The pseudo-inverse has the property that A * A+ * A = A and
  A+ * A * A+ = A+ (Moore-Penrose conditions).

  Specification: pinv computes the Moore-Penrose pseudo-inverse of a matrix.

  The pseudo-inverse satisfies the fundamental Moore-Penrose conditions:
  1. A * A+ * A = A  (the pseudo-inverse is a generalized inverse)
  2. A+ * A * A+ = A+  (the pseudo-inverse is reflexive)
  3. (A * A+)† = A * A+  (A * A+ is Hermitian)
  4. (A+ * A)† = A+ * A  (A+ * A is Hermitian)

  For practical purposes, we focus on the first two conditions and
  the dimensional correctness.

  Precondition: True (pinv is defined for any matrix)
  Postcondition: The result is the pseudo-inverse with correct dimensions
  and satisfies the Moore-Penrose conditions.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-

vc-spec: |-
  fn pinv(a: Vec<Vec<f32>>) -> (result: Vec<Vec<f32>>)
      requires 
          a.len() > 0,
          forall|i: int| 0 <= i < a.len() ==> a@[i].len() > 0,
      ensures 
          result.len() > 0,
          forall|i: int| 0 <= i < result.len() ==> result@[i].len() == a@.len(),
          (forall|i: int, j: int| (0 <= i < a.len() && 0 <= j < a@[i].len()) ==> a@[i][j] == 0.0f32) ==> 
              (forall|i: int, j: int| (0 <= i < result.len() && 0 <= j < result@[i].len()) ==> result@[i][j] == 0.0f32)

vc-code: |-
  {
      // impl-start
      assume(false);
      unreached()
      // impl-end
  }

vc-postamble: |-

  }
  fn main() {}