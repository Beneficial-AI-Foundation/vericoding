vc-description: |-
  numpy.obj2sctype: Return the scalar dtype or NumPy equivalent of Python type of an object.
  
  Takes any object and returns its corresponding NumPy scalar data type.
  If the object's type cannot be determined, returns the default value if provided,
  otherwise returns none.
  
  This function performs type introspection to determine the appropriate NumPy
  scalar type for any given object, including arrays, scalars, and generic objects.
  
  Specification: obj2sctype returns the appropriate NumPy scalar type for the input object.
  
  The function correctly identifies:
  1. Scalar types from their corresponding objects
  2. Array element types from array objects
  3. Generic object types
  4. Returns default for unrecognized types
  5. Returns none when no default is provided for unrecognized types
  
  Precondition: True (works with any object)
  Postcondition: The result correctly represents the scalar type of the input object
  
  /* NumPy scalar data types represented as an enum */
  
  /* Object representation for type introspection */
  
  /* Helper predicate: Check if object matches given scalar type */
  
  /* Helper predicate: Check if object is an array with given element type */
  
  /* Helper predicate: Check if object is a generic object */

vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  #[derive(PartialEq, Eq)]
  pub enum NumpyScalarType {
      Int32,
      Int64,
      Float32,
      Float64,
      Complex64,
      Complex128,
      Object,
      String,
      Bool,
  }
  
  pub enum NumpyObject {
      IntVal(i64),
      FloatVal(f64),
      ArrayInt(Vec<i64>),
      ArrayFloat(Vec<f64>),
      ArrayComplex(Vec<(f64, f64)>),
      GenericObj,
      StringVal(String),
      BoolVal(bool),
  }
  
  pub open spec fn matches_scalar_type(obj: NumpyObject, dtype: NumpyScalarType) -> bool {
      match (obj, dtype) {
          (NumpyObject::IntVal(_), NumpyScalarType::Int64) => true,
          (NumpyObject::FloatVal(_), NumpyScalarType::Float64) => true,
          (NumpyObject::StringVal(_), NumpyScalarType::String) => true,
          (NumpyObject::BoolVal(_), NumpyScalarType::Bool) => true,
          _ => false,
      }
  }
  
  pub open spec fn is_array_with_element_type(obj: NumpyObject, dtype: NumpyScalarType) -> bool {
      match (obj, dtype) {
          (NumpyObject::ArrayInt(_), NumpyScalarType::Int64) => true,
          (NumpyObject::ArrayFloat(_), NumpyScalarType::Float64) => true,
          (NumpyObject::ArrayComplex(_), NumpyScalarType::Complex128) => true,
          _ => false,
      }
  }
  
  pub open spec fn is_generic_object(obj: NumpyObject) -> bool {
      match obj {
          NumpyObject::GenericObj => true,
          _ => false,
      }
  }

vc-helpers: |-

vc-spec: |-
  fn obj2sctype(rep: NumpyObject, default: Option<NumpyScalarType>) -> (result: Option<NumpyScalarType>)
      ensures
          match rep {
              NumpyObject::IntVal(_) => result == Some(NumpyScalarType::Int64),
              NumpyObject::FloatVal(_) => result == Some(NumpyScalarType::Float64),
              NumpyObject::ArrayInt(_) => result == Some(NumpyScalarType::Int64),
              NumpyObject::ArrayFloat(_) => result == Some(NumpyScalarType::Float64),
              NumpyObject::ArrayComplex(_) => result == Some(NumpyScalarType::Complex128),
              NumpyObject::StringVal(_) => result == Some(NumpyScalarType::String),
              NumpyObject::BoolVal(_) => result == Some(NumpyScalarType::Bool),
              NumpyObject::GenericObj => result == default,
          },
          match result {
              Some(dtype) => 
                  matches_scalar_type(rep, dtype) || 
                  is_array_with_element_type(rep, dtype) ||
                  (is_generic_object(rep) && result == default),
              None => is_generic_object(rep) && default.is_None(),
          }

vc-code: |-
  {
      assume(false);
      unreached()
  }

vc-postamble: |-
  }
  fn main() {}

