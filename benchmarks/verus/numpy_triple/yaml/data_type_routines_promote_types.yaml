vc-description: |-
  numpy.promote_types: Returns the data type with the smallest size and smallest scalar kind to which both type1 and type2 may be safely cast. This function is symmetric but rarely associative. It returns a "canonical" dtype. Examples from NumPy documentation: promote_types('f4', 'f8') = 'f8' (float64), promote_types('i8', 'f4') = 'f8' (float64), promote_types('i4', 'S8') = 'S11' (string, but we focus on numeric types). Specification: promote_types returns the smallest safe common type for two dtypes. Key properties based on NumPy's type promotion rules: 1. Symmetry: promote_types(a, b) = promote_types(b, a), 2. Safety: Both input types can be safely cast to the result type, 3. Minimality: The result is the smallest type that satisfies the safety requirement, 4. Type promotion hierarchy: If either input is complex, result is complex; If either input is float, result is float (unless both are complex); Signed integers promote to larger signed integers; Unsigned integers promote to larger unsigned integers; Mixed signed/unsigned promote to signed of sufficient size, 5. Size consideration: Result has size >= max(size(type1), size(type2)), 6. Specific examples: Float32 + Float64 → Float64 (larger precision); Int64 + Float32 → Float64 (float with sufficient precision); Complex64 + Float32 → Complex64 (complex dominates).
  
  /* Symmetry property - function is commutative */
  
  /* Type promotion hierarchy rules */
  
  /* If either input is complex, result must be complex */
  
  /* If either input is float (and not complex), result is float or complex */
  
  /* Size constraint: result size >= max of input sizes */
  
  /* Promotion hierarchy: result rank >= max of input ranks */
  
  /* Same types promote to themselves (reflexivity) */
  
  /* Float precision promotion */

vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  #[derive(Copy, Clone, PartialEq, Eq)]
  pub enum NumpyDType {
      UInt8,
      UInt16,
      UInt32,
      UInt64,
      Int8,
      Int16,
      Int32,
      Int64,
      Float16,
      Float32,
      Float64,
      Complex64,
      Complex128,
  }
  
  spec fn dtype_size(dt: NumpyDType) -> nat {
      match dt {
          NumpyDType::UInt8 => 8,
          NumpyDType::UInt16 => 16,
          NumpyDType::UInt32 => 32,
          NumpyDType::UInt64 => 64,
          NumpyDType::Int8 => 8,
          NumpyDType::Int16 => 16,
          NumpyDType::Int32 => 32,
          NumpyDType::Int64 => 64,
          NumpyDType::Float16 => 16,
          NumpyDType::Float32 => 32,
          NumpyDType::Float64 => 64,
          NumpyDType::Complex64 => 64,
          NumpyDType::Complex128 => 128,
      }
  }
  
  spec fn promotion_hierarchy(dt: NumpyDType) -> nat {
      match dt {
          NumpyDType::UInt8 => 0,
          NumpyDType::UInt16 => 1,
          NumpyDType::UInt32 => 2,
          NumpyDType::UInt64 => 3,
          NumpyDType::Int8 => 4,
          NumpyDType::Int16 => 5,
          NumpyDType::Int32 => 6,
          NumpyDType::Int64 => 7,
          NumpyDType::Float16 => 8,
          NumpyDType::Float32 => 9,
          NumpyDType::Float64 => 10,
          NumpyDType::Complex64 => 11,
          NumpyDType::Complex128 => 12,
      }
  }
  
  spec fn is_signed_integer(dt: NumpyDType) -> bool {
      match dt {
          NumpyDType::Int8 | NumpyDType::Int16 | NumpyDType::Int32 | NumpyDType::Int64 => true,
          _ => false,
      }
  }
  
  spec fn is_unsigned_integer(dt: NumpyDType) -> bool {
      match dt {
          NumpyDType::UInt8 | NumpyDType::UInt16 | NumpyDType::UInt32 | NumpyDType::UInt64 => true,
          _ => false,
      }
  }
  
  spec fn is_float(dt: NumpyDType) -> bool {
      match dt {
          NumpyDType::Float16 | NumpyDType::Float32 | NumpyDType::Float64 => true,
          _ => false,
      }
  }
  
  spec fn is_complex(dt: NumpyDType) -> bool {
      match dt {
          NumpyDType::Complex64 | NumpyDType::Complex128 => true,
          _ => false,
      }
  }

vc-helpers: |-

vc-spec: |-
  spec fn promote_types_spec(type1: NumpyDType, type2: NumpyDType) -> NumpyDType;
  
  fn promote_types(type1: NumpyDType, type2: NumpyDType) -> (result: NumpyDType)
      ensures
          result == promote_types_spec(type1, type2),
  
          promote_types_spec(type1, type2) == promote_types_spec(type2, type1),
  
          (is_complex(type1) || is_complex(type2)) ==> is_complex(result),
  
          (is_float(type1) || is_float(type2)) ==> (is_float(result) || is_complex(result)),
  
          dtype_size(result) >= if dtype_size(type1) >= dtype_size(type2) { dtype_size(type1) } else { dtype_size(type2) },
  
          promotion_hierarchy(result) >= if promotion_hierarchy(type1) >= promotion_hierarchy(type2) { promotion_hierarchy(type1) } else { promotion_hierarchy(type2) },
  
          (type1 == type2) ==> (result == type1),
  
          (is_float(type1) && is_float(type2)) ==> (
              is_float(result) && dtype_size(result) >= if dtype_size(type1) >= dtype_size(type2) { dtype_size(type1) } else { dtype_size(type2) }
          ),

vc-code: |-
  {
      assume(false);
      unreached()
  }

vc-postamble: |-
  }
  fn main() {}