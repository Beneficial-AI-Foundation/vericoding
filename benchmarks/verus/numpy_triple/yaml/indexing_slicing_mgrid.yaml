vc-description: |-
  numpy.mgrid: Dense multi-dimensional "meshgrid" creation for 2D case.
  
  Creates a dense mesh-grid from two 1D coordinate arrays, returning a pair of 2D arrays
  where each output array has the same shape (rows Ã— cols). The first array contains
  row coordinates repeated across columns, and the second array contains column
  coordinates repeated across rows.
  
  This is the 2D case of numpy.mgrid[start_r:stop_r, start_c:stop_c] which creates
  coordinate arrays suitable for evaluating functions over a 2D grid.
  
  For 2D case with rows and cols dimensions, this returns a tuple of two matrices:
  - First matrix: row coordinates repeated across columns
  - Second matrix: column coordinates repeated across rows

vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {

vc-helpers: |-

vc-spec: |-
  type Matrix = Vec<Vec<f32>>;
  
  fn mgrid(rows: u8, cols: u8, start_r: f32, stop_r: f32, start_c: f32, stop_c: f32) -> (result: (Matrix, Matrix))
      requires rows > 0 && cols > 0,
      ensures 
          result.0.len() == rows as nat && result.1.len() == rows as nat,
          forall|i: int| 0 <= i < rows as int ==> result.0[i].len() == cols as nat && result.1[i].len() == cols as nat,
          forall|i: int, j: int, k: int| 0 <= i < rows as int && 0 <= j < cols as int && 0 <= k < cols as int ==> 
              result.0[i][j] == result.0[i][k],
          forall|j: int, i: int, k: int| 0 <= j < cols as int && 0 <= i < rows as int && 0 <= k < rows as int ==> 
              result.1[i][j] == result.1[k][j],

vc-code: |-
  {
      assume(false);
      unreached()
  }

vc-postamble: |-
  }
  fn main() {}