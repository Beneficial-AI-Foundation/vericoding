vc-description: |-
  numpy.format_parser: Class to convert formats, names, titles description to a dtype.

  This function takes format descriptions, field names, and optional titles
  and produces a structured data type specification. It validates that the
  formats are well-formed and that the number of names matches the number
  of format descriptors.

  The function handles common NumPy format strings like 'f8' (float64),
  'i4' (int32), 'S5' (string of length 5), etc.

  Specification: numpy.format_parser creates a structured data type from format descriptions.

  Precondition: All format strings in formats are valid NumPy format descriptors
  Postcondition: 
  1. The result has the same number of fields as input vectors
  2. Each field has the correct name from the names vector
  3. Each field has the correct format descriptor parsed from the formats vector
  4. If titles are provided, each field has the corresponding title
  5. The alignment setting is preserved

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

  /* A format descriptor for structured data types */
  #[derive(Eq, PartialEq)]
  pub enum FormatDescriptor {
      /* 64-bit floating point ('f8') */
      Float64,
      /* 32-bit integer ('i4') */
      Int32,
      /* Variable length string ('S5' for string of length 5) */
      String(nat),
      /* 64-bit integer ('i8') */
      Int64,
      /* 32-bit floating point ('f4') */
      Float32,
  }

  /* A field in a structured data type */
  #[derive(Eq, PartialEq)]
  pub struct Field {
      /* Field name */
      pub name: String,
      /* Format descriptor */
      pub format: FormatDescriptor,
      /* Optional title for the field */
      pub title: Option<String>,
  }

  /* A structured data type specification */
  #[derive(Eq, PartialEq)]
  pub struct DType {
      /* Vector of fields */
      pub fields: Vec<Field>,
      /* Whether fields are aligned as C-compiler would */
      pub aligned: bool,
  }

vc-helpers: |-

vc-spec: |-
  spec fn is_valid_format(format: String) -> bool {
      format@ == "f8".view() || format@ == "f4".view() || format@ == "i4".view() || format@ == "i8".view() || 
      (format@.len() > 1 && format@.index(0) == 'S')
  }

  spec fn parse_format_descriptor(format: String) -> FormatDescriptor {
      if format@ == "f8".view() {
          FormatDescriptor::Float64
      } else if format@ == "f4".view() {
          FormatDescriptor::Float32
      } else if format@ == "i4".view() {
          FormatDescriptor::Int32
      } else if format@ == "i8".view() {
          FormatDescriptor::Int64
      } else {
          FormatDescriptor::String(5) // simplified for spec
      }
  }

  fn numpy_format_parser(
      formats: Vec<String>,
      names: Vec<String>,
      titles: Option<Vec<String>>,
      aligned: bool
  ) -> (result: DType)
      requires 
          formats.len() == names.len(),
          titles.is_some() ==> titles.unwrap().len() == names.len(),
          forall|i: int| 0 <= i < formats.len() ==> is_valid_format(formats@[i]),
      ensures
          result.fields.len() == formats.len(),
          forall|i: int| 0 <= i < result.fields.len() ==> result.fields@[i].name == names@[i],
          forall|i: int| 0 <= i < result.fields.len() ==> 
              result.fields@[i].format == parse_format_descriptor(formats@[i]),
          match titles {
              Some(title_vec) => forall|i: int| 0 <= i < result.fields.len() ==> 
                  result.fields@[i].title == Some(title_vec@[i]),
              None => forall|i: int| 0 <= i < result.fields.len() ==> 
                  result.fields@[i].title.is_none(),
          },
          result.aligned == aligned,

vc-code: |-
  {
      // impl-start
      assume(false);
      DType {
          fields: Vec::new(),
          aligned: false,
      }
      // impl-end
  }

vc-postamble: |-

  }
  fn main() {}