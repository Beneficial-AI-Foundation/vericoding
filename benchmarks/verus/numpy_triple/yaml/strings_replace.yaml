vc-description: |-
  numpy.strings.replace: For each element in a, return a copy of the string with 
  occurrences of substring old replaced by new.
  
  Replaces occurrences of the substring 'old' with 'new' in each string element.
  The replacement is done from left to right, and if count is specified, only
  the first 'count' occurrences are replaced. If count is -1 or negative,
  all occurrences are replaced.
  
  Specification for numpy.strings.replace: Returns a vector where each element is the
  result of replacing occurrences of old substring with new substring.
  
  Mathematical Properties:
  1. Element-wise replacement: Each result element is the original string with replacements
  2. Count limiting: If count[i] >= 0, at most count[i] replacements are made
  3. Complete replacement: If count[i] < 0, all occurrences are replaced
  4. Identity preservation: If old[i] doesn't occur in a[i], result[i] = a[i]
  5. Zero count behavior: If count[i] = 0, no replacements occur
  
  /* Zero count behavior: if count is 0, no replacements occur */
  
  /* Identity property: if old doesn't occur in string, result equals original */

vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {

vc-helpers: |-

vc-spec: |-
  fn replace(a: Vec<String>, old: Vec<String>, new: Vec<String>, count: Vec<i32>) -> (result: Vec<String>)
      requires 
          a.len() == old.len() && old.len() == new.len() && new.len() == count.len(),
          forall|i: int| 0 <= i < count.len() ==> (count[i] == 0 || old[i]@.len() > 0),
      ensures
          result.len() == a.len(),
          forall|i: int| 0 <= i < result.len() ==> {
  
              (count[i] == 0 ==> result[i] == a[i]) &&
  
              (old[i]@.len() == 0 ==> result[i] == a[i])
          },

vc-code: |-
  {
      assume(false);
      unreached()
  }

vc-postamble: |-
  }
  fn main() {}