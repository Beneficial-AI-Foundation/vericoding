vc-description: |-
  Multiply a Hermite series by x using the recursion relationship xP_i(x) = (P_{i+1}(x)/2 + i*P_{i-1}(x)).
  
  The algorithm implements the recursion for Hermite polynomials. Given input coefficients c[0], c[1], ..., c[n-1], the output has n+1 coefficients where:
  - The first coefficient is always 0
  - Each c[i] contributes c[i]/2 to position i+1 and c[i]*i to position i-1
  
  For example, with input [1, 2, 3]:
  - result[0] = 0 + 2*1 = 2
  - result[1] = 1/2 + 3*2 = 0.5 + 6 = 6.5
  - result[2] = 2/2 = 1
  - result[3] = 3/2 = 1.5
  Giving [2, 6.5, 1, 1.5]
vc-preamble: |-
  use vstd::prelude::*;

  verus! {
vc-helpers: |-

vc-spec: |-
  fn hermmulx(c: Vec<i8>) -> (result: Vec<i8>)
      ensures
          result.len() == c.len() + 1,
          forall|k: int| 0 <= k < result.len() ==> #[trigger] result[k] as int == {
              let base_contribution: int = if k == 0 { 0 } else { 0 };
              let forward_contribution: int = if k > 0 && k - 1 < c.len() { 
                  c[k - 1] as int / 2
              } else { 
                  0
              };
              let backward_contribution: int = if k + 1 < c.len() { 
                  c[k + 1] as int * (k + 1)
              } else { 
                  0
              };
              base_contribution + forward_contribution + backward_contribution
          }
vc-code: |-
  {
      // impl-start
      assume(false);
      unreached()
      // impl-end
  }
vc-postamble: |-

  }
  fn main() {}