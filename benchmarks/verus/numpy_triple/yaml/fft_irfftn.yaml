vc-description: |-
  Computes the inverse of rfftn. This function performs the inverse N-dimensional discrete Fourier Transform for real input using the Fast Fourier Transform (FFT).

  For simplicity, we model this as a 1D version of irfftn, taking complex frequency domain input and producing real time-domain output. The function computes the inverse of rfftn, transforming N-dimensional frequency domain data back to real-valued time domain.

  This is the inverse operation to rfftn, where the input is expected to be Hermitian-symmetric complex data representing the frequency domain, and the output is real-valued time domain data.

  Specification: irfftn computes the inverse N-dimensional discrete Fourier Transform for real output.

  The irfftn function is the inverse of rfftn, satisfying the property that irfftn(rfftn(x), x.shape) ≈ x within numerical accuracy.

  Mathematical properties:
  1. Inverse relationship: irfftn(rfftn(x)) ≈ x for real input x
  2. The input should be Hermitian-symmetric to produce real output
  3. Output length is determined by the shape parameter or derived from input
  4. Energy conservation (Parseval's theorem) holds with proper normalization
  5. The transform preserves the mathematical structure of the inverse DFT

  The function implements the inverse N-dimensional DFT formula:
  x[j] = (1/N) * Σ(k) a[k] * exp(2πi*k*j/N)

  Sanity checks:
  - For DC-only input (single non-zero frequency), output is constant
  - Transform is linear: irfftn(α*a + β*b) = α*irfftn(a) + β*irfftn(b)
  - Output is real-valued when input satisfies Hermitian symmetry
  - Proper length relationship between input and output dimensions

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

  /* Complex number type for FFT operations */
  pub struct Complex {
      /* Real part */
      pub re: f32,
      /* Imaginary part */
      pub im: f32,
  }

  impl Complex {
      pub closed spec fn new(re: f32, im: f32) -> Complex {
          Complex { re, im }
      }
  }

vc-helpers: |-

vc-spec: |-
  fn irfftn(a: Vec<Complex>, n: u8) -> (result: Vec<f32>)
      requires 
          a.len() > 0,
          n > 0,
          a[0].im == 0.0f32,
      ensures
          result.len() == n as usize,

vc-code: |-
  {
      // impl-start
      assume(false);
      unreached()
      // impl-end
  }

vc-postamble: |-

  }
  fn main() {}