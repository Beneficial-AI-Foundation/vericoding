vc-description: |-
  numpy.strings.zfill: Return the numeric string left-filled with zeros.

  Zero-fills each string in the input array by padding it with leading zeros
  to reach the specified width. If the original string is longer than or equal
  to the width, it remains unchanged. This function is specifically designed
  for numeric strings and handles sign prefixes appropriately.

  The function behaves like Python's str.zfill() method:
  - Pads strings with leading zeros to reach the target width
  - Preserves sign characters ('+' or '-') at the beginning
  - Returns original string if it's already >= target width

  From NumPy documentation:
  - Parameters: a (array_like) - Input array with string dtype
                width (int) - Target width for zero-filling
  - Returns: out (ndarray) - Output array with zero-filled strings

  Mathematical Properties:
  1. Length invariant: result length is max(original_length, width)
  2. Identity: strings already >= width remain unchanged
  3. Zero-padding: shorter strings get leading zeros
  4. Sign preservation: leading '+' or '-' characters are preserved
  5. Minimality: no over-padding beyond required width
vc-preamble: |-
  use vstd::prelude::*;

  verus! {
vc-helpers: |-

vc-spec: |-
  spec fn is_sign_char(c: char) -> bool {
      c == '+' || c == '-'
  }

  spec fn all_zeros(s: Seq<char>) -> bool {
      forall|i: int| 0 <= i < s.len() ==> s[i] == '0'
  }

  spec fn max_usize(a: usize, b: usize) -> usize {
      if a >= b { a } else { b }
  }

  fn zfill(a: Vec<Vec<char>>, width: usize) -> (result: Vec<Vec<char>>)
      ensures
          result.len() == a.len(),
          forall|i: int| 0 <= i < result.len() ==> 
              #[trigger] result[i].len() == max_usize(a[i].len(), width),
          forall|i: int| 0 <= i < result.len() && a[i].len() >= width ==> 
              #[trigger] result[i]@ == a[i]@,
          forall|i: int| 0 <= i < result.len() && a[i].len() < width && a[i].len() > 0 && 
              !is_sign_char(a[i]@[0]) ==> 
              #[trigger] all_zeros(result[i]@.take((width - a[i].len()) as int)) &&
              result[i]@.skip((width - a[i].len()) as int) == a[i]@,
          forall|i: int| 0 <= i < result.len() && a[i].len() < width && a[i].len() > 0 && 
              is_sign_char(a[i]@[0]) ==> 
              #[trigger] result[i]@[0] == a[i]@[0] &&
              result[i]@.skip(width as int) == a[i]@.skip(1),
          forall|i: int| 0 <= i < result.len() && a[i].len() == 0 ==> 
              #[trigger] result[i].len() == width && 
              all_zeros(result[i]@),
          forall|i: int| 0 <= i < result.len() && a[i].len() < width ==> 
              #[trigger] result[i].len() == width,
          forall|i: int| 0 <= i < result.len() && a[i].len() < width ==> 
              #[trigger] all_zeros(result[i]@.take((width - a[i].len()) as int))
vc-code: |-
  {
      // impl-start
      assume(false);
      unreached()
      // impl-end
  }
vc-postamble: |-

  }
  fn main() {}