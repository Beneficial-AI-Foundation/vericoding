vc-description: |-
  Convert a Chebyshev series to a polynomial.
  
  Convert an array representing the coefficients of a Chebyshev series,
  ordered from lowest degree to highest, to an array of the coefficients
  of the equivalent polynomial (relative to the "standard" basis) ordered
  from lowest to highest degree.
  
  Specification: cheb2poly converts Chebyshev coefficients to polynomial coefficients.
  
  The conversion satisfies the mathematical property that if we have Chebyshev series
  ∑_{k=0}^{n-1} c[k] * T_k(x) where T_k is the k-th Chebyshev polynomial,
  then the output polynomial coefficients p satisfy:
  ∑_{k=0}^{n-1} c[k] * T_k(x) = ∑_{k=0}^{n-1} p[k] * x^k
  
  Key properties:
  1. Length preservation: output has same length as input
  2. Identity cases: for n ≤ 2, the output equals the input (since T₀(x) = 1, T₁(x) = x)
  3. Correctness: The polynomial form evaluates to the same value as the Chebyshev series
  4. Example verification: [0, 1, 2, 3] → [-2, -8, 4, 12]
  
  The algorithm uses the recurrence relation of Chebyshev polynomials:
  T₀(x) = 1, T₁(x) = x, T_{n+1}(x) = 2xT_n(x) - T_{n-1}(x)

vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {

vc-helpers: |-

vc-spec: |-
  fn cheb2poly(c: Vec<f64>) -> (p: Vec<f64>)
      ensures
          /* Basic properties */
          /* 1. Length preservation */
          p.len() == c.len(),
          /* 2. Identity for small cases */
          (c.len() == 0 ==> p@ == c@),
          (c.len() == 1 ==> p@ == c@),
          (c.len() == 2 ==> p@ == c@),
          /* 3. Mathematical correctness: The core property is that
             evaluating the polynomial with coefficients p at any point x
             gives the same result as evaluating the Chebyshev series
             with coefficients c at that point.
             This is the fundamental correctness property of the conversion. */
          (forall|x: f64|
              /* For clarity, we state this property abstractly:
                 polyEval(p, x) = chebEval(c, x)
                 where polyEval computes p₀ + p₁x + p₂x² + ... + p_{n-1}x^{n-1}
                 and chebEval computes c₀T₀(x) + c₁T₁(x) + ... + c_{n-1}T_{n-1}(x) */
              true),
          /* 4. Concrete example from NumPy documentation
             When c = [0, 1, 2, 3], then p = [-2, -8, 4, 12]
             This verifies: 0*T₀ + 1*T₁ + 2*T₂ + 3*T₃ = -2 - 8x + 4x² + 12x³ */
          (c.len() == 4 ==>
              (c[0] == 0.0 && c[1] == 1.0 && c[2] == 2.0 && c[3] == 3.0) ==>
              (p[0] == -2.0 && p[1] == -8.0 && p[2] == 4.0 && p[3] == 12.0)),
          /* 5. Additional mathematical properties
             The conversion is linear: cheb2poly(αc + βd) = α*cheb2poly(c) + β*cheb2poly(d) */
          (forall|d: Vec<f64>, alpha: f64, beta: f64|
              d.len() == c.len() ==> true),
          /* 6. Stability: small changes in input lead to small changes in output
             This is important for numerical applications */
          (forall|epsilon: f64, d: Vec<f64>|
              d.len() == c.len() ==> true)

vc-code: |-
  {
      assume(false);
      unreached();
  }

vc-postamble: |-
  }
  fn main() {}

