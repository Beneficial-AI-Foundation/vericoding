vc-description: |-
  numpy.polynomial.hermite.hermadd: Add one Hermite series to another.

  Returns the sum of two Hermite series c1 + c2. The arguments are
  sequences of coefficients ordered from lowest order term to highest,
  i.e., [1,2,3] represents the series P_0 + 2*P_1 + 3*P_2.

  Unlike multiplication, division, etc., the sum of two Hermite series
  is a Hermite series (without having to "reproject" the result onto
  the basis set) so addition, just like that of "standard" polynomials,
  is simply "component-wise."

  This version handles adding two Hermite coefficient vectors where the
  result length is the maximum of the input lengths. Shorter vectors are
  implicitly padded with zeros.

  Specification: hermadd performs component-wise addition of Hermite series coefficients.

  Precondition: True (no special preconditions for basic addition)
  Postcondition: 
  - If i < min(n,m), result[i] = c1[i] + c2[i]
  - If min(n,m) ≤ i < n, result[i] = c1[i] (c2 is treated as 0)
  - If min(n,m) ≤ i < m, result[i] = c2[i] (c1 is treated as 0)
  
  The mathematical property: The i-th coefficient of the sum is the sum of
  the i-th coefficients of the input series, treating missing coefficients as 0.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-

vc-spec: |-
  fn hermadd(c1: Vec<f32>, c2: Vec<f32>) -> (result: Vec<f32>)
      ensures
          result.len() == std::cmp::max(c1.len(), c2.len()),
          forall|i: int| 0 <= i < result.len() ==> {
              if i < c1.len() && i < c2.len() {
                  result[i] == c1[i] + c2[i]
              } else if i < c1.len() {
                  result[i] == c1[i]
              } else if i < c2.len() {
                  result[i] == c2[i]
              } else {
                  result[i] == 0.0
              }
          }

vc-code: |-
  {
      // impl-start
      assume(false);
      Vec::new()
      // impl-end
  }

vc-postamble: |-

  }
  fn main() {}