vc-description: |-
  /*
  numpy.minimum: Element-wise minimum of array elements.
  
  Compare two arrays and returns a new array containing the element-wise minima.
  If one of the elements being compared is NaN, then that element is returned.
  
  This is different from numpy.min which returns a single minimum value.
  This function performs element-wise comparison and returns a new array.
  
  Binary universal function: minimum(x1, x2)
  
  Parameters:
  - x1, x2: Vector Float n - Input vectors of the same size
  
  Returns:
  - Vector Float n - The element-wise minimum of x1 and x2
  
  Specification: numpy.minimum returns a vector where each element is the minimum
  of the corresponding elements from x1 and x2.
  
  Mathematical properties:
  1. Commutativity: min(a, b) = min(b, a)
  2. Associativity: min(min(a, b), c) = min(a, min(b, c))
  3. Idempotency: min(a, a) = a
  4. Element-wise operation: result[i] = min(x1[i], x2[i]) for all i
  5. NaN propagation: if either x1[i] or x2[i] is NaN, result[i] is NaN
  
  Precondition: True (no special preconditions for element-wise minimum)
  Postcondition: For all indices i, result[i] = min(x1[i], x2[i])
  */
vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-

vc-spec: |-
  fn minimum(x1: Vec<f32>, x2: Vec<f32>) -> (result: Vec<f32>)
      requires 
          x1.len() == x2.len(),
      ensures
          result.len() == x1.len(),
          forall|i: int| 0 <= i < result.len() ==> {
              let min_val = if x1[i] < x2[i] { x1[i] } else { x2[i] };
              result[i] == min_val &&
              result[i] <= x1[i] &&
              result[i] <= x2[i] &&
              (result[i] == x1[i] || result[i] == x2[i])
          },

vc-code: |-
  {
      // impl-start
      assume(false);
      Vec::new()
      // impl-end
  }

vc-postamble: |-

  }
  fn main() {}