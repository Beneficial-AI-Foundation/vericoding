vc-description: |-
  /*
  numpy.cov: Estimate a covariance matrix, given data and weights.
  
  Covariance indicates the level to which two variables vary together. 
  If we examine N-dimensional samples, X = [x_1, x_2, ... x_N]^T, 
  then the covariance matrix element C_{ij} is the covariance of x_i and x_j. 
  The element C_{ii} is the variance of x_i.
  
  For a matrix with `vars` variables and `obs` observations:
  - Each row represents a variable
  - Each column represents an observation
  - Returns a vars × vars covariance matrix
  
  This implementation focuses on the basic unweighted case without bias correction.
  
  Specification: numpy.cov computes the covariance matrix from data matrix m.
  
  Given a data matrix m where each row is a variable and each column is an observation,
  the covariance matrix C has the following mathematical properties:
  
  1. Symmetry: C[i,j] = C[j,i] for all i,j
  2. Diagonal elements are variances: C[i,i] = Var(X_i)
  3. Off-diagonal elements are covariances: C[i,j] = Cov(X_i, X_j)
  4. Positive semi-definite: all eigenvalues ≥ 0
  
  The covariance between variables i and j is computed as:
  Cov(X_i, X_j) = E[(X_i - μ_i)(X_j - μ_j)]
  where μ_i is the mean of variable i.
  
  Precondition: At least one observation (obs > 0)
  Postcondition: Returns a symmetric positive semi-definite covariance matrix
  */
vc-preamble: |-
  use vstd::prelude::*;

  verus! {
vc-helpers: |-

vc-spec: |-
  spec fn vec_mean(v: Seq<f32>) -> f32 
      requires v.len() > 0
  {
      v.fold_left(0.0, |acc, x| acc + x) / (v.len() as f32)
  }

  spec fn covariance_element(var_i: Seq<f32>, var_j: Seq<f32>) -> f32
      requires var_i.len() > 0,
      requires var_i.len() == var_j.len()
  {
      let mean_i = vec_mean(var_i);
      let mean_j = vec_mean(var_j);
      let n = var_i.len() as f32;
      var_i.zip_with(var_j).fold_left(0.0, |acc, (xi, xj)| acc + (xi - mean_i) * (xj - mean_j)) / (n - 1.0)
  }

  fn numpy_cov(m: Vec<Vec<f32>>) -> (result: Vec<Vec<f32>>)
      requires m.len() > 0,
      requires forall|i: int| 0 <= i < m.len() ==> m[i].len() > 0,
      requires forall|i: int, j: int| 0 <= i < m.len() && 0 <= j < m.len() ==> m[i].len() == m[j].len(),
      ensures result.len() == m.len(),
      ensures forall|i: int| 0 <= i < result.len() ==> result[i].len() == m.len(),
      ensures forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result[i].len() ==> 
          result[i][j] == result[j][i],
      ensures forall|i: int| 0 <= i < result.len() ==> result[i][i] >= 0.0,
vc-code: |-
  {
      // impl-start
      assume(false);
      Vec::new()
      // impl-end
  }
vc-postamble: |-

  }
  fn main() {}