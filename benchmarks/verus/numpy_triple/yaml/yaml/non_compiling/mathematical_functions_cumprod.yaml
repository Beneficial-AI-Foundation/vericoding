vc-description: |-
  /*
  Return the cumulative product of elements along a given axis.
  
  For a vector [a₁, a₂, a₃, ..., aₙ], returns [a₁, a₁*a₂, a₁*a₂*a₃, ..., a₁*a₂*...*aₙ].
  
  This function computes the cumulative product by applying successive multiplications
  from left to right, producing a result vector of the same length as the input.
  
  The cumulative product is computed as: result[i] = ∏(k=0 to i) input[k]
  
  For empty vectors, returns an empty vector.
  
  Specification: cumprod returns the cumulative product of elements.
  
  Precondition: True (works for any vector, including empty)
  Postcondition: 
  - Result has same length as input
  - For any index i, result[i] = product of all elements from a[0] to a[i] inclusive
  - Equivalently: result[i] = a[0] * a[1] * ... * a[i]
  - For empty vectors, returns empty vector (vacuous condition holds)
  
  Mathematical Properties:
  - result[0] = a[0] (when n > 0)
  - result[i+1] = result[i] * a[i+1] (cumulative property)
  - Each element is the product of all preceding elements (including itself)
  */
vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-
  spec fn cumulative_product(a: Seq<f32>, len: nat) -> f32
      decreases len
  {
      if len == 0 {
          1.0
      } else {
          cumulative_product(a, len - 1) * (a[len - 1] as f32)
      }
  }

vc-spec: |-
  fn cumprod(a: Vec<f32>) -> (result: Vec<f32>)
      ensures 
          result.len() == a.len(),
          forall|i: int| 0 <= i < a.len() ==> result[i] == cumulative_product(a@, (i + 1) as nat),
          forall|i: int, j: int| 0 <= i < j < a.len() ==> result[j] == result[i] * cumulative_product(a@.skip(i + 1), (j - i) as nat)

vc-code: |-
  {
      // impl-start
      assume(false);
      Vec::new()
      // impl-end
  }

vc-postamble: |-

  }
  fn main() {}