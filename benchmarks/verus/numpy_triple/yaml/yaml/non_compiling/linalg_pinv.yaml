vc-description: |-
  numpy.linalg.pinv: Compute the (Moore-Penrose) pseudo-inverse of a matrix.

  Calculate the generalized inverse of a matrix using its
  singular-value decomposition (SVD) and including all
  large singular values.

  For a matrix A, the pseudo-inverse A+ is defined as the matrix that
  'solves' the least-squares problem Ax = b. If A is invertible,
  then pinv(A) == inv(A).

  The pseudo-inverse has the property that A * A+ * A = A and
  A+ * A * A+ = A+ (Moore-Penrose conditions).

  Specification: pinv computes the Moore-Penrose pseudo-inverse of a matrix.

  The pseudo-inverse satisfies the fundamental Moore-Penrose conditions:
  1. A * A+ * A = A  (the pseudo-inverse is a generalized inverse)
  2. A+ * A * A+ = A+  (the pseudo-inverse is reflexive)
  3. (A * A+)† = A * A+  (A * A+ is Hermitian)
  4. (A+ * A)† = A+ * A  (A+ * A is Hermitian)

  For practical purposes, we focus on the first two conditions and
  the dimensional correctness.

  Precondition: True (pinv is defined for any matrix)
  Postcondition: The result is the pseudo-inverse with correct dimensions
  and satisfies the Moore-Penrose conditions.
vc-preamble: |-
  use vstd::prelude::*;

  verus! {
vc-helpers: |-

vc-spec: |-
  fn pinv(a: Vec<Vec<f32>>) -> (result: Vec<Vec<f32>>)
      requires
          a.len() > 0,
          forall|i: int| 0 <= i < a.len() ==> a[i as int].len() > 0,
          forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() ==> a[i as int].len() == a[j as int].len(),
      ensures
          result.len() > 0,
          forall|i: int| 0 <= i < result.len() ==> result[i as int].len() > 0,
          forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result.len() ==> result[i as int].len() == result[j as int].len(),
          /* Sanity check: All elements are finite (no NaN or infinity) */
          forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result[i as int].len() ==> result[i as int][j as int].is_finite(),
          /* Boundedness property: pseudo-inverse elements should be bounded */
          forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result[i as int].len() ==> result[i as int][j as int].abs() <= 1000.0f32,
vc-code: |-
  {
      // impl-start
      assume(false);
      Vec::new()
      // impl-end
  }
vc-postamble: |-

  }
  fn main() {}