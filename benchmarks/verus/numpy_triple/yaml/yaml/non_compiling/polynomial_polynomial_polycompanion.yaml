vc-description: |-
  /*
  Return the companion matrix of c.
  
  The companion matrix for power series cannot be made symmetric by
  scaling the basis, so this function differs from those for the
  orthogonal polynomials.
  
  Parameters
  ----------
  c : array_like
      1-D array of polynomial coefficients ordered from low to high
      degree.
  
  Returns
  -------
  mat : ndarray
      Companion matrix of dimensions (deg, deg).
  
  Return the companion matrix of a polynomial.
  
  The companion matrix C for a polynomial p(x) = c[0] + c[1]*x + ... + c[n]*x^n
  is an (n×n) matrix where the characteristic polynomial is p(x).
  
  For a polynomial of degree n, the companion matrix has the form:
  - First (n-1) rows: [0, 0, ..., 0, 1, 0, ..., 0] (identity shifted)
  - Last row: [-c[0]/c[n], -c[1]/c[n], ..., -c[n-1]/c[n]]
  
  The companion matrix is used to find roots of the polynomial as eigenvalues.
  
  Specification: polycompanion constructs the companion matrix of a polynomial.
  
  The companion matrix satisfies the following properties:
  1. Dimension: Returns an (n+1)×(n+1) matrix for polynomial of degree n+1
  2. Structure: First n rows form shifted identity matrix pattern  
  3. Last row: Contains normalized negative coefficients [-c[0]/c[n+1], -c[1]/c[n+1], ..., -c[n]/c[n+1]]
  4. Leading coefficient: c[n+1] ≠ 0 (required for well-defined companion matrix)
  5. Eigenvalue property: The eigenvalues of the companion matrix are the roots of the polynomial
  
  Mathematical properties:
  - Characteristic polynomial: det(λI - C) = c[0] + c[1]*λ + ... + c[n+1]*λ^(n+1)
  - Rank: The matrix has full rank n+1 when c[n+1] ≠ 0
  - Structure: C[i,j] = 1 if j = i+1 and i < n, C[n,j] = -c[j]/c[n+1], 0 otherwise
  */
vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-

vc-spec: |-
  fn polycompanion(c: Vec<f32>) -> (result: Vec<Vec<f32>>)
      requires 
          c.len() >= 2,
          c[c.len() - 1] != 0.0,
      ensures
          result.len() == c.len() - 1,
          forall|i: int| 0 <= i < result.len() ==> result[i].len() == c.len() - 1,
          forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result[i].len() ==>
              result[i][j] == 
                  if i + 1 == j && i < (c.len() - 2) as int then 
                      1.0
                  else if i == (c.len() - 2) as int then 
                      -c[j] / c[c.len() - 1]
                  else 
                      0.0,

vc-code: |-
  {
      // impl-start
      assume(false);
      Vec::new()
      // impl-end
  }

vc-postamble: |-

  }
  fn main() {}