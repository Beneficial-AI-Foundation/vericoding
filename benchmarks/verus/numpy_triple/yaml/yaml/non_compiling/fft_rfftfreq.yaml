vc-description: |-
  numpy.fft.rfftfreq: Return the Discrete Fourier Transform sample frequencies for rfft.
  
  The function generates frequency bin centers in cycles per unit of sample spacing,
  with zero at the start. This is specifically designed for use with rfft and irfft.
  
  Parameters:
  - n: Window length (input size)
  - d: Sample spacing (defaults to 1.0)
  
  Returns:
  - f: Array of length n//2 + 1 containing sample frequencies
  
  The frequency calculation follows:
  - For any n: f = [0, 1, ..., n//2] / (d*n)
  - The result length is always n//2 + 1 (for both even and odd n)
  
  Specification: numpy.fft.rfftfreq generates frequency sample points for rfft.
  
  The function returns a vector of frequencies from 0 to the Nyquist frequency.
  
  Precondition: n > 0 and d > 0 (positive sample spacing)
  Postcondition: 
  1. The result has length n//2 + 1
  2. The first element is always 0
  3. Each element i represents frequency i / (d * n)
  4. The last element is (n//2) / (d * n) (Nyquist frequency)
vc-preamble: |-
  use vstd::prelude::*;

  verus! {
vc-helpers: |-

vc-spec: |-
  fn numpy_rfftfreq(n: usize, d: f64) -> (result: Vec<f64>)
      requires 
          n > 0,
          d > 0.0,
      ensures
          result.len() == n / 2 + 1,
          result[0] == 0.0,
          forall|i: int| 0 <= i < result.len() ==> {
              let freq = (i as f64) / (d * (n as f64));
              result[i] == freq
          },
          {
              let nyquist_idx = (n / 2) as int;
              let nyquist_freq = (nyquist_idx as f64) / (d * (n as f64));
              result[nyquist_idx] == nyquist_freq
          },
          forall|i: int, j: int| 0 <= i <= j < result.len() ==> result[i] <= result[j],
vc-code: |-
  {
      // impl-start
      assume(false);
      Vec::new()
      // impl-end
  }
vc-postamble: |-

  }
  fn main() {}