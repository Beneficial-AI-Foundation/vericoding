vc-description: |-
  Computes the inverse of rfft (real-valued inverse FFT). This function performs the inverse of the one-dimensional discrete Fourier Transform for real input, such that irfft(rfft(a), len(a)) == a within numerical accuracy.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

  /* Complex number type for FFT operations */
  struct Complex {
      /* Real part of the complex number */
      re: f64,
      /* Imaginary part of the complex number */
      im: f64,
  }

  /* Helper function to check if a vector is Hermitian-symmetric */
  spec fn is_hermitian_symmetric(a: Seq<Complex>) -> bool {
      forall|i: int, j: int| 
          0 <= i < a.len() && 0 <= j < a.len() && i + j == a.len() - 1 ==>
              a[i].re == a[j].re && a[i].im == -a[j].im
  }

vc-helpers: |-

vc-spec: |-
  fn irfft(a: Vec<Complex>, n: usize) -> (result: Vec<f64>)
      requires 
          a.len() > 0,
          n == 2 * (a.len() - 1),
          is_hermitian_symmetric(a@),
      ensures
          result.len() == n,
          a@[0].im == 0.0 ==> exists|i: int| 0 <= i < result.len() && result[i] == a@[0].re,
          forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result.len() && i + j == n ==> result[i] == result[j],
          is_hermitian_symmetric(a@),
          n == 2 * (a.len() - 1),

vc-code: |-
  {
      // impl-start
      assume(false);
      Vec::new()
      // impl-end
  }

vc-postamble: |-

  }
  fn main() {}