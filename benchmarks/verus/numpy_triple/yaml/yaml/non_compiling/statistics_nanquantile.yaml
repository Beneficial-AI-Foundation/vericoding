vc-description: |-
  Compute the q-th quantile of the data in a vector, ignoring NaN values.
  When all elements are NaN, returns NaN.
  
  Mathematical Properties:
  - Ignores NaN values in the computation
  - Returns the q-th quantile of all non-NaN elements 
  - If all elements are NaN, returns NaN
  - If at least one element is not NaN, returns the quantile of non-NaN values
  - For q=0, returns the minimum of non-NaN elements
  - For q=1, returns the maximum of non-NaN elements
  - For vectors with no NaN values, behaves identically to regular quantile

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-

vc-spec: |-
  fn nanquantile(a: Vec<f32>, q: f32) -> (result: f32)
      requires 0.0 <= q && q <= 1.0,
      requires a.len() > 0,
      ensures
          /* Case 1: If there exists at least one non-NaN element */
          (exists|i: int| 0 <= i < a.len() && !a[i].is_nan()) ==>
              (!result.is_nan() &&
               /* Result is bounded by the non-NaN elements */
               (exists|min_idx: int| 0 <= min_idx < a.len() && 
                   !a[min_idx].is_nan() &&
                   (forall|j: int| 0 <= j < a.len() && !a[j].is_nan() ==> a[min_idx] <= a[j]) &&
                   a[min_idx] <= result) &&
               (exists|max_idx: int| 0 <= max_idx < a.len() && 
                   !a[max_idx].is_nan() &&
                   (forall|j: int| 0 <= j < a.len() && !a[j].is_nan() ==> a[j] <= a[max_idx]) &&
                   result <= a[max_idx])),
          /* Case 2: If all elements are NaN, result is NaN */
          (forall|i: int| 0 <= i < a.len() ==> a[i].is_nan()) ==> result.is_nan(),
          /* Case 3: For q=0, result is the minimum of non-NaN elements */
          (q == 0.0 && (exists|i: int| 0 <= i < a.len() && !a[i].is_nan())) ==>
              (exists|min_idx: int| 0 <= min_idx < a.len() && 
                  result == a[min_idx] && 
                  !a[min_idx].is_nan() &&
                  (forall|j: int| 0 <= j < a.len() && !a[j].is_nan() ==> result <= a[j])),
          /* Case 4: For q=1, result is the maximum of non-NaN elements */
          (q == 1.0 && (exists|i: int| 0 <= i < a.len() && !a[i].is_nan())) ==>
              (exists|max_idx: int| 0 <= max_idx < a.len() && 
                  result == a[max_idx] && 
                  !a[max_idx].is_nan() &&
                  (forall|j: int| 0 <= j < a.len() && !a[j].is_nan() ==> a[j] <= result)),
          /* Case 5: For vectors without NaN, behaves like regular quantile */
          (forall|i: int| 0 <= i < a.len() ==> !a[i].is_nan()) ==>
              (!result.is_nan() &&
               (exists|lower_idx: int, upper_idx: int| 
                   0 <= lower_idx < a.len() && 0 <= upper_idx < a.len() &&
                   a[lower_idx] <= result && result <= a[upper_idx])),

vc-code: |-
  {
      // impl-start
      assume(false);
      0.0
      // impl-end
  }

vc-postamble: |-

  }
  fn main() {}