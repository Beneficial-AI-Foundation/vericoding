vc-description: |-
  /*
  numpy.find_common_type: Determine common type following standard coercion rules.
      
  This function determines the common data type by following NumPy's type promotion rules.
  It returns the maximum of array_types ignoring scalar_types, unless the maximum of 
  scalar_types is of a different kind (dtype.kind).
      
  Note: This function is deprecated in NumPy 1.25.0 in favor of numpy.result_type.
  
  Specification: find_common_type implements NumPy's type promotion rules correctly.
      
  The function should:
  1. Return the maximum precedence type from array_types if scalar_types is empty
  2. Return the maximum precedence type from scalar_types if array_types is empty  
  3. If both are non-empty, return the maximum from array_types unless the maximum
     from scalar_types has a different kind, in which case return the scalar maximum
  4. Handle the case where type promotion results in a valid common type
      
  Precondition: At least one of the input vectors is non-empty
  Postcondition: The result follows NumPy's documented type promotion rules
  */
vc-preamble: |-
  use vstd::prelude::*;

  verus! {

  /* Data type representation for NumPy types */
  #[derive(PartialEq, Eq, Clone, Copy)]
  pub enum DType {
      /* 8-bit signed integer */
      Int8,
      /* 16-bit signed integer */
      Int16,
      /* 32-bit signed integer */
      Int32,
      /* 64-bit signed integer */
      Int64,
      /* 8-bit unsigned integer */
      UInt8,
      /* 16-bit unsigned integer */
      UInt16,
      /* 32-bit unsigned integer */
      UInt32,
      /* 64-bit unsigned integer */
      UInt64,
      /* 32-bit floating point */
      Float32,
      /* 64-bit floating point */
      Float64,
      /* 64-bit complex number */
      Complex64,
      /* 128-bit complex number */
      Complex128,
      /* Boolean type */
      Bool,
      /* Object type */
      Object,
  }

  impl DType {
      /* Type hierarchy for promotion rules */
      pub spec fn kind(self) -> char {
          match self {
              DType::Bool => 'b',
              DType::Int8 | DType::Int16 | DType::Int32 | DType::Int64 => 'i',
              DType::UInt8 | DType::UInt16 | DType::UInt32 | DType::UInt64 => 'u',
              DType::Float32 | DType::Float64 => 'f',
              DType::Complex64 | DType::Complex128 => 'c',
              DType::Object => 'O',
          }
      }

      /* Type precedence for promotion (higher values have higher precedence) */
      pub spec fn precedence(self) -> nat {
          match self {
              DType::Bool => 0,
              DType::Int8 => 1,
              DType::Int16 => 2,
              DType::Int32 => 3,
              DType::Int64 => 4,
              DType::UInt8 => 5,
              DType::UInt16 => 6,
              DType::UInt32 => 7,
              DType::UInt64 => 8,
              DType::Float32 => 9,
              DType::Float64 => 10,
              DType::Complex64 => 11,
              DType::Complex128 => 12,
              DType::Object => 13,
          }
      }
  }

vc-helpers: |-

vc-spec: |-
  spec fn max_precedence_type(types: Seq<DType>) -> Option<DType> {
      if types.len() == 0 {
          None
      } else {
          let max_type = types[0];
          let max_prec = max_type.precedence();
          Some(types.fold_left(max_type, |acc: DType, t: DType| {
              if t.precedence() > acc.precedence() { t } else { acc }
          }))
      }
  }

  fn find_common_type(array_types: Vec<DType>, scalar_types: Vec<DType>) -> (result: Option<DType>)
      requires array_types.len() > 0 || scalar_types.len() > 0,
      ensures
          /* Case 1: Only array types provided */
          (scalar_types.len() == 0 && array_types.len() > 0) ==> {
              exists|dt: DType| result == Some(dt) &&
              array_types@.contains(dt) &&
              forall|other: DType| array_types@.contains(other) ==> other.precedence() <= dt.precedence()
          },
          /* Case 2: Only scalar types provided */
          (array_types.len() == 0 && scalar_types.len() > 0) ==> {
              exists|dt: DType| result == Some(dt) &&
              scalar_types@.contains(dt) &&
              forall|other: DType| scalar_types@.contains(other) ==> other.precedence() <= dt.precedence()
          },
          /* Case 3: Both array and scalar types provided */
          (array_types.len() > 0 && scalar_types.len() > 0) ==> {
              exists|max_array: DType, max_scalar: DType| {
                  array_types@.contains(max_array) &&
                  scalar_types@.contains(max_scalar) &&
                  (forall|dt: DType| array_types@.contains(dt) ==> dt.precedence() <= max_array.precedence()) &&
                  (forall|dt: DType| scalar_types@.contains(dt) ==> dt.precedence() <= max_scalar.precedence()) &&
                  ((max_array.kind() == max_scalar.kind()) ==> (result == Some(max_array))) &&
                  ((max_array.kind() != max_scalar.kind()) ==> (result == Some(max_scalar)))
              }
          }

vc-code: |-
  {
      // impl-start
      assume(false);
      None
      // impl-end
  }

vc-postamble: |-

  }
  fn main() {}