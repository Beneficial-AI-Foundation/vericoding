vc-description: |-
  /*
  Compute the one-dimensional discrete Fourier Transform for real input.
  Returns only the non-negative frequency terms, exploiting Hermitian symmetry.
  The output length is (n/2)+1 for even n, or (n+1)/2 for odd n.
  */
vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-
  /* Complex number type for FFT results */
  #[derive(PartialEq, Eq, Structural)]
  pub struct Complex {
      pub re: f64,
      pub im: f64,
  }

  impl Complex {
      pub open spec fn add(self, other: Self) -> Self {
          Complex { re: self.re + other.re, im: self.im + other.im }
      }

      pub open spec fn mul(self, other: Self) -> Self {
          Complex { 
              re: self.re * other.re - self.im * other.im, 
              im: self.re * other.im + self.im * other.re 
          }
      }

      pub open spec fn zero() -> Self {
          Complex { re: 0.0, im: 0.0 }
      }
  }

  /* Complex exponential function */
  pub open spec fn cexp(theta: f64) -> Complex {
      Complex { re: theta.cos(), im: theta.sin() }
  }

  /* Convert f64 to Complex */
  pub open spec fn to_complex(x: f64) -> Complex {
      Complex { re: x, im: 0.0 }
  }

  /* Sum of complex numbers over finite range */
  pub open spec fn complex_sum(n: nat, f: spec_fn(nat) -> Complex) -> Complex
      decreases n
  {
      if n == 0 {
          Complex::zero()
      } else {
          f(n - 1).add(complex_sum((n - 1) as nat, f))
      }
  }

vc-spec: |-
  fn rfft(a: Vec<f64>) -> (result: Vec<Complex>)
      requires a.len() > 0,
      ensures 
          result.len() == (a.len() / 2) + 1,
          forall |k: nat| k < result.len() ==> 
              result[k as int] == complex_sum(a.len() as nat, |j: nat| 
                  to_complex(a[j as int]).mul(
                      cexp(-2.0 * 3.14159265358979323846 * (k as f64) * (j as f64) / (a.len() as f64))
                  )),
          result[0].im == 0.0,
          a.len() % 2 == 0 ==> result[a.len() / 2].im == 0.0

vc-code: |-
  {
      // impl-start
      assume(false);
      Vec::new()
      // impl-end
  }

vc-postamble: |-

  }

  fn main() {}