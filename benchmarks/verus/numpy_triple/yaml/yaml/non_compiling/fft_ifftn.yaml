I need to output just the YAML content without the verification block:

vc-description: |-
  Compute the N-dimensional inverse discrete Fourier Transform (IFFTN).
  
  The IFFTN extends the 1D inverse FFT to multiple dimensions, computing
  the inverse of the N-dimensional DFT. For a 2D array, this applies the
  inverse transform along both dimensions.
  
  For a 2D array of size m by n, the (i,j)-th output element is computed as:
  X[i,j] = (1/(m*n)) * Sum(k=0 to m-1) Sum(l=0 to n-1) a[k,l] * exp(2*pi*i*(i*k/m + j*l/n))
  
  This is the mathematical inverse of the N-dimensional FFT.
vc-preamble: |-
  use vstd::prelude::*;

  verus! {
vc-helpers: |-

vc-spec: |-
  /* Complex number type for IFFTN operations */
  #[derive(PartialEq, Clone)]
  pub struct Complex {
      pub re: f64,
      pub im: f64,
  }

  impl Complex {
      pub fn zero() -> Self {
          Complex { re: 0.0, im: 0.0 }
      }

      pub fn add(self, other: Complex) -> Complex {
          Complex {
              re: self.re + other.re,
              im: self.im + other.im,
          }
      }

      pub fn mul(self, other: Complex) -> Complex {
          Complex {
              re: self.re * other.re - self.im * other.im,
              im: self.re * other.im + self.im * other.re,
          }
      }

      pub fn scale(self, s: f64) -> Complex {
          Complex {
              re: s * self.re,
              im: s * self.im,
          }
      }
  }

  /* Complex exponential function e^(i*theta) */
  spec fn cexp(theta: f64) -> Complex {
      Complex {
          re: theta.cos(),
          im: theta.sin(),
      }
  }

  /* Sum of complex numbers over indices 0 to n-1 */
  spec fn complex_sum(n: nat, f: spec_fn(nat) -> Complex) -> Complex 
      decreases n
  {
      if n == 0 {
          Complex::zero()
      } else {
          f(n - 1).add(complex_sum(n - 1, f))
      }
  }

  fn ifftn(a: Vec<Vec<Complex>>) -> (result: Vec<Vec<Complex>>)
      requires 
          a.len() > 0,
          a[0].len() > 0,
          forall|i: int| 0 <= i < a.len() ==> a[i].len() == a[0].len(),
      ensures
          result.len() == a.len(),
          result[0].len() == a[0].len(),
          forall|i: int| 0 <= i < result.len() ==> result[i].len() == a[0].len(),
vc-code: |-
  {
      // impl-start
      assume(false);
      vec![vec![Complex::zero(); a[0].len()]; a.len()]
      // impl-end
  }
vc-postamble: |-

  }
  fn main() {}