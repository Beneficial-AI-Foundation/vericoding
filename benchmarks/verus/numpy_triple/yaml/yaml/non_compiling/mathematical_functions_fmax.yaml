vc-description: |-
  /*
  Element-wise maximum of array elements.
  
  Compare two arrays and returns a new array containing the element-wise maxima. If one of the elements being compared is a NaN, then the non-nan element is returned.
  
  Element-wise maximum of two vectors, with special NaN handling.
  If one element is NaN, returns the non-NaN element.
  
  Specification: fmax returns element-wise maximum with NaN handling.
  For each position i:
  - If both elements are non-NaN, returns the maximum
  - If x[i] is NaN and y[i] is not, returns y[i]  
  - If y[i] is NaN and x[i] is not, returns x[i]
  - If both are NaN, returns NaN
  Additional mathematical properties:
  - Commutative when both values are non-NaN
  - Associative when all values are non-NaN
  - Idempotent when values are non-NaN
  */
vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-

vc-spec: |-
  fn fmax(x: Vec<f32>, y: Vec<f32>) -> (result: Vec<f32>)
      requires x.len() == y.len(),
      ensures 
          result.len() == x.len(),
          forall|i: int| 0 <= i < x.len() ==> {
              let x_val = x[i];
              let y_val = y[i];
              let result_val = result[i];
              (
                  /* Core NaN handling behavior */
                  (!x_val.is_nan() && !y_val.is_nan() ==> 
                      result_val == if x_val >= y_val { x_val } else { y_val }) &&
                  (x_val.is_nan() && !y_val.is_nan() ==> 
                      result_val == y_val) &&
                  (!x_val.is_nan() && y_val.is_nan() ==> 
                      result_val == x_val) &&
                  (x_val.is_nan() && y_val.is_nan() ==> 
                      result_val.is_nan()) &&
                  /* Mathematical properties for non-NaN cases */
                  (!x_val.is_nan() && !y_val.is_nan() ==> 
                      result_val >= x_val && result_val >= y_val) &&
                  (!x_val.is_nan() && !y_val.is_nan() ==> 
                      (result_val == x_val || result_val == y_val)) &&
                  /* NaN preservation: result is NaN iff both inputs are NaN */
                  (result_val.is_nan() <==> (x_val.is_nan() && y_val.is_nan()))
              )
          }

vc-code: |-
  {
      // impl-start
      assume(false);
      Vec::new()
      // impl-end
  }

vc-postamble: |-

  }
  fn main() {}