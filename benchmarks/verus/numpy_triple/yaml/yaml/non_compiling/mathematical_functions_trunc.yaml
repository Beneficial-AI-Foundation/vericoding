vc-description: |-
  /*
  numpy.trunc: Return the truncated value of the input, element-wise.
  
  The truncated value of the scalar x is the nearest integer i which is closer to zero than x is.
  This is equivalent to:
  - For positive x: floor(x) (largest integer ≤ x)
  - For negative x: ceil(x) (smallest integer ≥ x)
  - For zero: 0
  
  Returns an array of the same shape as x, containing the truncated values.
  
  Specification: numpy.trunc returns a vector where each element is the 
  truncated value of the corresponding element in x.
  
  Precondition: True (truncation is defined for all real numbers)
  Postcondition: For all indices i, result[i] is the truncated value of x[i],
                 which is the nearest integer closer to zero than x[i]. This means:
                 - result[i] is an integer value (represented as Float)
                 - For positive x: result[i] = floor(x[i])
                 - For negative x: result[i] = ceil(x[i])
                 - Truncation moves towards zero: |result[i]| ≤ |x[i]|
                 - Sign preservation: result and x have same sign (or both are zero)
                 - Monotonicity: the function is monotonic in the sense that it preserves ordering
                 - Idempotence: trunc(trunc(x)) = trunc(x)
                 - Integer preservation: if x[i] is an integer, then result[i] = x[i]
  */
vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-

vc-spec: |-
  fn numpy_trunc(x: Vec<f32>) -> (result: Vec<f32>)
      ensures
          result.len() == x.len(),
          forall|i: int| 0 <= i < result.len() ==>
              /* Result is an integer (represented as f32) */
              (exists|k: int| result[i] == k as f32)
              /* For positive or zero inputs: result = floor(x) */
              && (x[i] >= 0.0 ==> result[i] == x[i].floor())
              /* For negative inputs: result = ceil(x) */
              && (x[i] < 0.0 ==> result[i] == x[i].ceil())
              /* Truncation moves towards zero (abs property) */
              && (result[i].abs() <= x[i].abs())
              /* Sign preservation */
              && ((x[i] > 0.0 ==> result[i] >= 0.0) && (x[i] < 0.0 ==> result[i] <= 0.0) && (x[i] == 0.0 ==> result[i] == 0.0))
              /* Idempotence: trunc(trunc(x)) = trunc(x) */
              && (result[i] == result[i].floor())
              /* Integer preservation */
              && ((exists|k: int| x[i] == k as f32) ==> result[i] == x[i])
              /* Bounded property: result is between 0 and x */
              && ((x[i] >= 0.0 ==> result[i] <= x[i]) && (x[i] <= 0.0 ==> result[i] >= x[i]))

vc-code: |-
  {
      /* impl-start */
      assume(false);
      Vec::new()
      /* impl-end */
  }

vc-postamble: |-

  }
  fn main() {}