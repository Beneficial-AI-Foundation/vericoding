vc-description: |-
  numpy.random.SeedSequence: Mixes sources of entropy in a reproducible way
  to set the initial state for independent and very probably non-overlapping
  BitGenerators.

  SeedSequence takes entropy sources (integers) and mixes them using
  cryptographic hash functions to produce high-quality seed states.
  The mixing algorithm ensures that even low-quality entropy sources
  produce high-quality, uniformly distributed output.

  Key properties:
  - Reproducible: Same entropy input always produces same output
  - Avalanche effect: Single bit changes affect all output bits
  - Independence: Spawned sequences are non-overlapping
  - Uniform distribution: Output is uniformly distributed over the state space

  Specification: SeedSequence produces a seed state from entropy sources
  with reproducibility and non-degeneracy properties.

  Precondition: True (accepts any entropy input, including empty)
  Postcondition: 
  1. Reproducibility: Same entropy always produces same output
  2. Non-degeneracy: Output depends on input entropy
  3. Deterministic: Function is deterministic for fixed inputs
  4. Well-defined: Always produces valid output within expected bounds

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-

vc-spec: |-
  spec fn seed_sequence_spec(entropy: Seq<u32>, spawn_key: Seq<u32>, pool_size: nat) -> Seq<u32>;

  fn seed_sequence(entropy: Vec<u32>, spawn_key: Vec<u32>, pool_size: usize) -> (result: Vec<u32>)
      requires pool_size >= 1,
      ensures
          /* Reproducibility property: same inputs produce same outputs */
          forall|entropy2: Vec<u32>, spawn_key2: Vec<u32>| 
              entropy@ == entropy2@ && spawn_key@ == spawn_key2@ ==> 
              result@ == seed_sequence_spec(entropy2@, spawn_key2@, pool_size as nat),
          /* Well-defined output: result has the correct size */
          result.len() == pool_size,
          /* Deterministic: function produces consistent output */
          result@ == seed_sequence_spec(entropy@, spawn_key@, pool_size as nat)

vc-code: |-
  {
      // impl-start
      assume(false);
      vec![0u32; pool_size]
      // impl-end
  }

vc-postamble: |-

  }
  fn main() {}