vc-description: |-
  numpy.linalg.svd: Singular Value Decomposition.
  
  Computes the singular value decomposition of a matrix, factorizing it as
  A = U @ diag(S) @ Vh, where U and Vh are unitary matrices and S is a 
  vector of singular values sorted in descending order.
  
  This specification focuses on the 2D case with full_matrices=False
  and compute_uv=True (the most common use case).
  
  The decomposition satisfies: A = U @ diag(S) @ Vh
  where U has orthonormal columns, Vh has orthonormal rows,
  and S contains non-negative singular values in descending order.
  
  Specification: numpy.linalg.svd returns matrices U, S, Vh such that:
  
  1. Matrix reconstruction: A = U @ diag(S) @ Vh
  2. U has orthonormal columns (U^T @ U = I)
  3. Vh has orthonormal rows (Vh @ Vh^T = I)  
  4. S contains non-negative singular values in descending order
  
  This captures the essential mathematical properties of SVD as implemented in NumPy.
  
  Precondition: True (SVD is defined for any real matrix)
  Postcondition: The returned decomposition satisfies all SVD properties

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-

vc-spec: |-
  fn numpy_svd(a: Vec<Vec<f64>>) -> (result: (Vec<Vec<f64>>, Vec<f64>, Vec<Vec<f64>>))
      requires 
          a.len() > 0,
          forall|i: int| 0 <= i < a.len() ==> a[i].len() > 0,
          forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() ==> a[i].len() == a[j].len(),
      ensures
          {
              let (u, s, vh) = result;
              let m = a.len();
              let n = a[0].len();
              let min_mn = if m < n { m } else { n };
              
              /* Matrix reconstruction property */
              (forall|i: int, j: int| 0 <= i < m && 0 <= j < n ==> {
                  let sum_val = 0.0; /* TODO: Implement matrix multiplication sum */
                  a[i][j] == sum_val
              }) &&
              
              /* U has orthonormal columns */
              (forall|i: int, j: int| 0 <= i < min_mn && 0 <= j < min_mn ==> {
                  let dot_product = 0.0; /* TODO: Implement column dot product */
                  dot_product == if i == j { 1.0 } else { 0.0 }
              }) &&
              
              /* Vh has orthonormal rows */
              (forall|i: int, j: int| 0 <= i < min_mn && 0 <= j < min_mn ==> {
                  let dot_product = 0.0; /* TODO: Implement row dot product */
                  dot_product == if i == j { 1.0 } else { 0.0 }
              }) &&
              
              /* Non-negative singular values */
              (forall|i: int| 0 <= i < min_mn ==> s[i] >= 0.0) &&
              
              /* Descending order of singular values */
              (forall|i: int| 0 <= i < min_mn - 1 ==> s[i] >= s[i + 1])
          }

vc-code: |-
  {
      // impl-start
      assume(false);
      (Vec::new(), Vec::new(), Vec::new())
      // impl-end
  }

vc-postamble: |-

  }
  fn main() {}