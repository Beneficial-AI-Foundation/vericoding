vc-description: |-
  Evaluate a polynomial at points x using Horner's method.
  Given coefficients c = [c₀, c₁, ..., cₙ] and evaluation points x,
  computes p(x) = c₀ + c₁·x + c₂·x² + ... + cₙ·xⁿ for each x
  
  Specification: polyval evaluates a polynomial with coefficients c at points x.
  The result at each point xᵢ is the polynomial value p(xᵢ) = c₀ + c₁·xᵢ + c₂·xᵢ² + ... + cₙ·xᵢⁿ
  
  Mathematical properties:
  - For coefficient vector c = [c₀, c₁, ..., cₙ], evaluates polynomial p(x) = Σⱼ cⱼ·xʲ
  - Uses Horner's method for numerical stability: p(x) = c₀ + x·(c₁ + x·(c₂ + x·(...)))
  - Linear in coefficients: p(x, αc₁ + βc₂) = α·p(x, c₁) + β·p(x, c₂)
  - Polynomial evaluation at zero gives constant term: p(0) = c₀
  - For degree-0 polynomial [c₀], result is constant c₀ for all x

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-

vc-spec: |-
  fn polyval(x: Vec<f64>, c: Vec<f64>) -> (result: Vec<f64>)
      requires 
          x.len() > 0,
          c.len() > 0,
      ensures
          result.len() == x.len(),
          forall|i: int| 0 <= i < result.len() ==> 
              exists|poly_val: f64| result[i] == poly_val &&
              (c.len() == 1 ==> poly_val == c[0]) &&
              (forall|j: int| 0 <= j < c.len() && c[j] == 0.0 ==> poly_val == 0.0)

vc-code: |-
  {
      // impl-start
      assume(false);
      Vec::new()
      // impl-end
  }

vc-postamble: |-

  }
  fn main() {}