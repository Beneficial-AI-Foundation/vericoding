vc-description: |-
  Create a datetime64 object representing an offset from 1970-01-01T00:00:00

  {
    "name": "numpy.datetime64",
    "category": "Datetime types", 
    "description": "Create a datetime64 object representing an offset from 1970-01-01T00:00:00",
    "url": "https://numpy.org/doc/stable/reference/arrays.datetime.html#numpy.datetime64",
    "doc": "If created from a 64-bit integer, it represents an offset from ``1970-01-01T00:00:00``. If created from string, the string can be in ISO 8601 date or datetime format.\n\nWhen parsing a string to create a datetime object, if the string contains a trailing timezone (A 'Z' or a timezone offset), the timezone will be dropped and a User Warning is given.\n\nDatetime64 objects should be considered to be UTC and therefore have an offset of +0000.\n\n>>> np.datetime64(10, 'Y')\nnp.datetime64('1980')\n>>> np.datetime64('1980', 'Y')\nnp.datetime64('1980')\n>>> np.datetime64(10, 'D')\nnp.datetime64('1970-01-11')\n\nSee :ref:`arrays.datetime` for more information.\n\n:Character code: ``'M'``"
  }

  Create a datetime64 object from an integer offset and time unit

  Specification: datetime64 creates a UTC datetime object with the specified offset and unit.
  The datetime64 object represents a specific moment in time as an offset from the Unix epoch
  (1970-01-01T00:00:00 UTC) in the specified time unit. The function preserves the input
  parameters and ensures the result is always in UTC timezone.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

  /* Time unit for datetime64 */
  pub enum TimeUnit {
      /* Years unit ('Y') */
      Years,
      /* Days unit ('D') */
      Days,
      /* Hours unit ('h') */
      Hours,
      /* Minutes unit ('m') */
      Minutes,
      /* Seconds unit ('s') */
      Seconds,
      /* Milliseconds unit ('ms') */
      Milliseconds,
      /* Microseconds unit ('us') */
      Microseconds,
      /* Nanoseconds unit ('ns') */
      Nanoseconds,
  }

  /* DateTime64 structure representing offset from Unix epoch */
  pub struct DateTime64 {
      /* Offset value from 1970-01-01T00:00:00 */
      pub offset: i64,
      /* Time unit of the offset */
      pub unit: TimeUnit,
      /* Always UTC with +0000 offset */
      pub is_utc: bool,
  }

vc-helpers: |-

vc-spec: |-
  fn datetime64(offset: i64, unit: TimeUnit) -> (result: DateTime64)
      ensures 
          result.offset == offset,
          result.unit == unit,
          result.is_utc == true,
          /* Unit-specific validity constraints based on NumPy datetime64 limits */
          match unit {
              TimeUnit::Years => result.offset + 1970 >= 1 && result.offset + 1970 <= 9999,  /* Valid year range */
              TimeUnit::Days => result.offset >= -2147483648 && result.offset <= 2147483647,    /* Days since epoch */
              TimeUnit::Hours => result.offset >= -2147483648 && result.offset <= 2147483647,   /* Hours since epoch */
              TimeUnit::Minutes => result.offset >= -2147483648 && result.offset <= 2147483647, /* Minutes since epoch */
              TimeUnit::Seconds => result.offset >= -2147483648 && result.offset <= 2147483647, /* Seconds since epoch */
              TimeUnit::Milliseconds => true,  /* Milliseconds can use full Int range */
              TimeUnit::Microseconds => true,  /* Microseconds can use full Int range */
              TimeUnit::Nanoseconds => true,   /* Nanoseconds can use full Int range */
          }

vc-code: |-
  {
      // impl-start
      assume(false);
      DateTime64 {
          offset: 0,
          unit: TimeUnit::Seconds,
          is_utc: true,
      }
      // impl-end
  }

vc-postamble: |-

  }
  fn main() {}