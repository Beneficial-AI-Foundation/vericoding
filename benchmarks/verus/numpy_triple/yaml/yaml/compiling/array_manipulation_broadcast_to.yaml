vc-description: |-
  Broadcast a 1D vector to a 2D matrix by repeating it along rows.
  This implements the most common broadcasting pattern: (n,) -> (m, n)
  
  Specification: broadcast_to creates a 2D matrix where each row is a copy of the input vector.
  
  Mathematical properties:
  1. Shape property: The result has shape (m, n) where n is the original vector length
  2. Value property: Each row in the result equals the original vector
  3. Broadcasting rule: A 1D array of shape (n,) can be broadcast to (m, n) by repeating
  4. Row consistency: All rows in the result are identical to the input vector
  5. Element preservation: Each element in the input appears m times in each column
  
  Sanity checks:
  - The output shape is exactly (m, n)
  - Every row contains the same values as the input vector
  - Broadcasting preserves element values without modification
  - The result behaves as if v was copied m times along a new axis
  
  Example behavior:
  - Input: [1, 2, 3] with target shape (2, 3)
  - Output: [[1, 2, 3], [1, 2, 3]]
  
  Additional properties:
  - Memory efficiency: In NumPy, this creates a view, not a copy
  - Column-wise view: Column j contains m copies of v[j]
  - Broadcasting compatibility: The result can be used in element-wise operations with other (m, n) arrays
  
  Mathematical formulation:
  - For input vector v ∈ ℝⁿ and target shape (m, n)
  - Output matrix M ∈ ℝᵐˣⁿ where M[i,j] = v[j] for all i ∈ {0,...,m-1}, j ∈ {0,...,n-1}

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-

vc-spec: |-
  fn broadcast_to(v: Vec<f32>, m: usize) -> (result: Vec<Vec<f32>>)
      requires v.len() > 0,
      ensures
          result.len() == m,
          /* Primary property: each element (i,j) equals v[j] */
          forall|i: int, j: int| 0 <= i < m && 0 <= j < v.len() ==> result[i][j] == v[j],
          /* Row identity: each row is exactly the input vector */
          forall|i: int| 0 <= i < m ==> result[i]@ == v@,
          /* Column uniformity: each column contains a single repeated value */
          forall|j: int, i1: int, i2: int| 0 <= j < v.len() && 0 <= i1 < m && 0 <= i2 < m ==> result[i1][j] == result[i2][j],
          /* Value preservation: no new values are introduced */
          forall|i: int, j: int| 0 <= i < m && 0 <= j < v.len() ==> exists|k: int| 0 <= k < v.len() && result[i][j] == v[k] && k == j,
          /* Broadcast invariant: the operation is idempotent on rows */
          forall|i1: int, i2: int| 0 <= i1 < m && 0 <= i2 < m ==> result[i1]@ == result[i2]@

vc-code: |-
  {
      // impl-start
      assume(false);
      Vec::new()
      // impl-end
  }

vc-postamble: |-

  }
  fn main() {}