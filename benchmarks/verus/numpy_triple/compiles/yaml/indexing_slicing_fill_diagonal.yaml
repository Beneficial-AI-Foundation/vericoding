vc-description: |-
  /*
  {
    "name": "numpy.fill_diagonal",
    "category": "Diagonal operations", 
    "description": "Fill the main diagonal of the given array of any dimensionality",
    "url": "https://numpy.org/doc/stable/reference/generated/numpy.fill_diagonal.html",
    "doc": "Fill the main diagonal of the given array of any dimensionality.\n\nFor an array `a` with ``a.ndim >= 2``, the diagonal is the list of locations with indices ``a[i, ..., i]`` all identical. This function modifies the input array in-place, it does not return a value.\n\nParameters\n----------\na : array, at least 2-D.\n    Array whose diagonal is to be filled, it gets modified in-place.\nval : scalar or array_like\n    Value(s) to write on the diagonal. If `val` is scalar, the value is written along the diagonal. If array-like, the flattened `val` is written along the diagonal, repeating if necessary to fill all diagonal entries.\nwrap : bool\n    For tall matrices in NumPy version up to 1.6.2, the diagonal \"wrapped\" after N columns. You can have this behavior with this option. This affects only tall matrices.",
  }
  */
  
  /* Fill the main diagonal of a 2D matrix with a specified value */
  
  /* Specification: fill_diagonal modifies the diagonal entries to the specified value */

vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {

vc-helpers: |-
  // <vc-helpers>
  // </vc-helpers>

vc-signature: |-
  fn fill_diagonal<T: Copy>(mat: Vec<Vec<T>>, val: T) -> (result: Vec<Vec<T>>)
      requires 
          mat.len() > 0,
          forall|i: int| 0 <= i < mat.len() ==> #[trigger] mat[i].len() == mat[0].len(),
      ensures
          result.len() == mat.len(),
          forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i].len() == mat[0].len(),
          /* Diagonal elements are filled with val */
          forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result[i].len() && i == j ==> 
              #[trigger] result[i][j] == val,
          /* Non-diagonal elements remain unchanged */
          forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result[i].len() && i != j ==> 
              #[trigger] result[i][j] == mat[i][j],

vc-implementation: |-
  // <vc-implementation>
      {
          assume(false);
          return mat; // TODO: Remove this line and implement the function body
      }
  // </vc-implementation>

vc-condition: |-
  proof fn fill_diagonal_spec<T: Copy>(mat: Vec<Vec<T>>, val: T) 
      requires 
          mat.len() > 0,
          forall|i: int| 0 <= i < mat.len() ==> #[trigger] mat[i].len() == mat[0].len(),

vc-proof: |-
  // <vc-proof>
      {
          assume(false); // TODO: Remove this line and implement the proof
      }
  // </vc-proof>

vc-postamble: |-
  fn main() {}
  
  }