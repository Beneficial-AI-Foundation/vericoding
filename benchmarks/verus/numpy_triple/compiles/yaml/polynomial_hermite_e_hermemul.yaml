vc-description: |-
  /*
  {
    "name": "numpy.polynomial.hermite_e.hermemul",
    "category": "HermiteE polynomials",
    "description": "Multiply one Hermite series by another.",
    "url": "https://numpy.org/doc/stable/reference/generated/numpy.polynomial.hermite_e.hermemul.html",
    "doc": "Multiply one Hermite series by another.\n\n    Returns the product of two Hermite series `c1` * `c2`.  The arguments\n    are sequences of coefficients, from lowest order \"term\" to highest,\n    e.g., [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.\n\n    Parameters\n    ----------\n    c1, c2 : array_like\n        1-D arrays of Hermite series coefficients ordered from low to\n        high.\n\n    Returns\n    -------\n    out : ndarray\n        Of Hermite series coefficients representing their product.\n\n    See Also\n    --------\n    hermeadd, hermesub, hermemulx, hermediv, hermepow\n\n    Notes\n    -----\n    In general, the (polynomial) product of two C-series results in terms\n    that are not in the Hermite polynomial basis set.  Thus, to express\n    the product as a Hermite series, it is necessary to \"reproject\" the\n    product onto said basis set, which may produce \"unintuitive\" (but\n    correct) results; see Examples section below.\n\n    Examples\n    --------\n    >>> from numpy.polynomial.hermite_e import hermemul\n    >>> hermemul([1, 2, 3], [0, 1, 2])\n    array([14.,  15.,  28.,   7.,   6.])",
  }
  */
  
  /* Multiply one Hermite series by another. Returns the product of two Hermite polynomials 
     represented as coefficient vectors. The multiplication involves reprojection onto 
     the Hermite polynomial basis set. */
  
  /* Specification: hermemul computes the product of two Hermite series.
     
     Mathematical background: For Hermite polynomials, multiplication is not component-wise
     but requires reprojection onto the Hermite polynomial basis. Given two Hermite series:
     - P₁(x) = c1[0]H₀(x) + c1[1]H₁(x) + ... + c1[n-1]Hₙ₋₁(x)
     - P₂(x) = c2[0]H₀(x) + c2[1]H₁(x) + ... + c2[m-1]Hₘ₋₁(x)
     
     The product P₁(x) * P₂(x) must be expressed as a linear combination of Hermite polynomials.
     
     Properties verified:
     1. Commutativity: hermemul c1 c2 = hermemul c2 c1 (when extended to same size)
     2. Bilinearity: multiplication distributes over addition
     3. Zero preservation: if all coefficients of c1 or c2 are zero, then result is zero
     4. Degree bound: the result has at most n + m - 1 coefficients
     5. Non-degeneracy: non-zero inputs produce non-zero output
     */

vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {

vc-helpers: |-
  /* <vc-helpers> */
  /* </vc-helpers> */

vc-signature: |-
  fn hermemul(c1: Vec<f64>, c2: Vec<f64>) -> (result: Vec<f64>)
      requires
          c1.len() > 0,
          c2.len() > 0,
          c1.len() <= 1000000,
          c2.len() <= 1000000,
      ensures
          result.len() == c1.len() + c2.len() - 1,
          (forall|i: int| 0 <= i < c1.len() ==> c1[i] == 0.0) || 
          (forall|j: int| 0 <= j < c2.len() ==> c2[j] == 0.0) ==>
          (forall|k: int| 0 <= k < result.len() ==> result[k] == 0.0),

vc-implementation: |-
  /* <vc-implementation> */
      {
          let result_len = (c1.len() + c2.len()) - 1;
          let mut result = Vec::new();
          
          let mut i = 0;
          while i < result_len
              invariant 
                  i <= result_len,
                  result.len() == i,
                  result_len == c1.len() + c2.len() - 1,
                  forall|j: int| 0 <= j < i ==> result[j] == 0.0,
              decreases result_len - i,
          {
              result.push(0.0);
              i += 1;
          }
          
          return result; // TODO: Remove this line and implement the function body
      }
  /* </vc-implementation> */

vc-condition: |-
  proof fn hermemul_spec(c1: Vec<f64>, c2: Vec<f64>) 
      requires 
          c1.len() > 0,
          c2.len() > 0,
      /* (forall|i: int| 0 <= i < c1.len() ==> c1[i] == 0.0) || 
         (forall|j: int| 0 <= j < c2.len() ==> c2[j] == 0.0) ==>
         (forall|k: int| 0 <= k < hermemul(c1, c2).len() ==> hermemul(c1, c2)[k] == 0.0) */

vc-proof: |-
  /* <vc-proof> */
      {
          assume(false); // TODO: Remove this line and implement the proof
      }
  /* </vc-proof> */

vc-postamble: |-
  
  fn main() {}
  
  }