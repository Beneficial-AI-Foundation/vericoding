vc-description: |-
  /*
  {
    "name": "numpy.nanprod",
    "description": "Return the product of array elements over a given axis treating Not a Numbers (NaNs) as ones",
    "url": "https://numpy.org/doc/stable/reference/generated/numpy.nanprod.html",
    "doc": "Return the product of array elements over a given axis treating Not a Numbers (NaNs) as ones.",
  }
  */
  
  /*  numpy.nanprod: Return the product of array elements treating NaNs as ones.
      
      Computes the product of all elements in the array, treating NaN values as 1.
      This is useful for computing products while ignoring missing or invalid data
      represented as NaN.
      
      For empty arrays, returns 1 as the identity element of multiplication.
      For arrays containing only NaN values, returns 1.
      For arrays with mixed NaN and non-NaN values, returns the product of the non-NaN values.
  */
  
  /*  Specification: numpy.nanprod returns the product of all non-NaN elements in the vector.
      
      Precondition: True (works for any vector, including empty)
      Postcondition: result equals the product of all non-NaN elements, satisfying:
      1. NaN values are treated as 1 (multiplicative identity)
      2. Empty vectors return 1
      3. Vectors with only NaN values return 1
      4. The result is mathematically equivalent to filtering out NaN values and taking the product
      5. The result is never NaN (since NaN values are ignored)
      6. If no NaN values exist, this behaves identically to regular product
  */

vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {

vc-helpers: |-
  /* <vc-helpers> */
  /* </vc-helpers> */

vc-signature: |-
  fn nanprod(a: Vec<f64>) -> f64

vc-implementation: |-
  /* <vc-implementation> */
  {
      return 1.0; // TODO: Remove this line and implement the function body
  }
  /* </vc-implementation> */

vc-condition: |-
  proof fn nanprod_spec(a: Vec<f64>)
      ensures
          true /* result equals the product of all non-NaN elements */
          /* && !result.is_nan() */
          /* && forall i: int, 0 <= i < a.len() && !a[i].is_nan() ==> */
          /*    exists filtered: Seq<f64>, filtered == a@.filter(|x: f64| !x.is_nan()) */
          /*    && result == filtered.fold_left(1.0, |acc, x| acc * x) */

vc-proof: |-
  /* <vc-proof> */
  {
      assume(false); // TODO: Remove this line and implement the proof
  }
  /* </vc-proof> */

vc-postamble: |-
  fn main() {}
  
  }