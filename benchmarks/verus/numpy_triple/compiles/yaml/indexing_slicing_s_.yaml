vc-description: |-
  /*
  {
    "name": "numpy.s_",
    "category": "Advanced indexing",
    "description": "A nicer way to build up index tuples for arrays",
    "url": "https://numpy.org/doc/stable/reference/generated/numpy.s_.html",
    "doc": "A nicer way to build up index tuples for arrays.\n\nUse one of the two predefined instances \`index_exp\` or \`s_\` rather than directly using IndexExpression.\n\nFor any index combination, including slicing and axis insertion, \`\`a[indices]\`\` is the same as \`\`a[np.index_exp[indices]]\`\` for any array \`a\`. However, \`\``np.index_exp[indices]\`\`` can be used anywhere in Python code and returns a tuple of slice objects that can be used in the construction of complex index expressions.",
  }
  */
  
  /*  Index expression builder that creates slice objects for array indexing.
      This is a simplified version of numpy.s_ that creates slice objects
      for use in array indexing operations. */
  
  /*  Specification: s_ creates a well-formed slice object
      This comprehensive specification captures:
      1. The slice object contains the provided start, stop, and step values
      2. If step is provided, it must be positive (non-zero)
      3. If start and stop are both provided, start should be less than or equal to stop
      4. The resulting slice is valid for array indexing operations
      5. The slice preserves the ordering constraints (start â‰¤ stop when both present)
      6. The step value, if present, is positive for forward slicing
  */

vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  /* A slice object representing a range of indices for array slicing.
     Contains start, stop, and step parameters for creating slices. */
  pub struct Slice {
      /* The starting index of the slice (inclusive). If None, starts from the beginning. */
      pub start: Option<nat>,
      /* The stopping index of the slice (exclusive). If None, goes to the end. */
      pub stop: Option<nat>,
      /* The step size for the slice. If None, defaults to 1. */
      pub step: Option<nat>,
  }

vc-helpers: |-
  // <vc-helpers>
  // </vc-helpers>

vc-signature: |-
  fn s_(start: Option<nat>, stop: Option<nat>, step: Option<nat>) -> (result: Slice)
      requires
          step.is_some() ==> step->Some_0 > 0,
          (start.is_some() && stop.is_some()) ==> start->Some_0 <= stop->Some_0,
      ensures
          result.start == start,
          result.stop == stop,
          result.step == step,
          result.step.is_some() ==> result.step->Some_0 > 0,
          (result.start.is_some() && result.stop.is_some()) ==> result.start->Some_0 <= result.stop->Some_0,

vc-implementation: |-
  // <vc-implementation>
  {
      return Slice { start, stop, step }; // TODO: Remove this line and implement the function body
  }
  // </vc-implementation>

vc-condition: |-
  proof fn s_spec_theorem(start: Option<nat>, stop: Option<nat>, step: Option<nat>)
      requires
          step.is_some() ==> step->Some_0 > 0,
          (start.is_some() && stop.is_some()) ==> start->Some_0 <= stop->Some_0,

vc-proof: |-
  // <vc-proof>
  {
      assume(false); // TODO: Remove this line and implement the proof
  }
  // </vc-proof>

vc-postamble: |-
  
  fn main() {}
  
  }