vc-description: |-
  Raise a Hermite series to a power.

  Returns the Hermite series `c` raised to the power `pow`. The
  argument `c` is a sequence of coefficients ordered from low to high.
  i.e., [1,2,3] is the series  ``P_0 + 2*P_1 + 3*P_2.``

  Parameters
  ----------
  c : array_like
      1-D array of Hermite series coefficients ordered from low to
      high.
  pow : integer
      Power to which the series will be raised
  maxpower : integer, optional
      Maximum power allowed. This is mainly to limit growth of the series
      to unmanageable size. Default is 16

  Returns
  -------
  coef : ndarray
      Hermite series of power.

  See Also
  --------
  hermadd, hermsub, hermmulx, hermmul, hermdiv

  Examples
  --------
  >>> from numpy.polynomial.hermite import hermpow
  >>> hermpow([1, 2, 3], 2)
  array([81.,  52.,  82.,  12.,   9.])

  Raise a Hermite polynomial series to a power.
  Given coefficients `c` representing a Hermite series (ordered from low to high degree),
  returns the coefficients of the series raised to the power `pow`.
  The `maxpower` parameter limits the maximum degree of the result.

  Specification: hermpow raises a Hermite series to a power by repeated multiplication.
  Key properties:
  1. For pow = 0, the result is the constant polynomial [1]
  2. For pow = 1, the result equals the input polynomial
  3. For pow > 1, the result is obtained by repeated Hermite multiplication
  4. The result degree is bounded by min(n + (n-1)*pow - 1, maxpower)
  5. The operation respects the algebraic properties of polynomial exponentiation

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-

vc-spec: |-
  fn hermpow(c: Vec<f32>, pow: nat, maxpower: nat) -> (result: Vec<f32>)
      requires 
          c.len() > 0,
          maxpower >= 0,
      ensures
          result.len() <= maxpower + 1,
          result.len() == if (c.len() + (c.len() - 1) * pow) <= (maxpower + 1) {
              c.len() + (c.len() - 1) * pow
          } else {
              (maxpower + 1) as int
          },
          pow == 0 ==> result.len() == 1 && result[0] == 1.0f32,
          (pow == 1 && c.len() <= maxpower + 1) ==> 
              result.len() == c.len() && 
              forall|i: int| 0 <= i < c.len() ==> result[i] == c[i],
          (exists|i: int| 0 <= i < c.len() && c[i] != 0.0f32) && pow > 0 ==> 
              exists|j: int| 0 <= j < result.len() && result[j] != 0.0f32,

vc-code: |-
  {
      // impl-start
      assume(false);
      Vec::new()
      // impl-end
  }

vc-postamble: |-

  }
  fn main() {}