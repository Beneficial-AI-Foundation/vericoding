vc-description: |-
  Return the binary representation of the input number as a string.
  For negative numbers, if width is not given, a minus sign is added to the front.
  If width is given, the two's complement of the number is returned.
  
  Specification: binary_repr correctly converts integers to binary strings with proper
  handling of negative numbers (signed representation without width, two's complement with width)
vc-preamble: |-
  use vstd::prelude::*;

  verus! {

  spec fn nat_to_binary_string(n: nat) -> Seq<char>
  {
      arbitrary()
  }

  spec fn is_valid_binary(s: Seq<char>) -> bool
  {
      arbitrary()
  }

  spec fn is_valid_signed_binary(s: Seq<char>) -> bool
  {
      arbitrary()
  }
vc-helpers: |-

vc-spec: |-
  fn binary_repr(num: i64, width: Option<usize>) -> (result: Vec<char>)
      requires width.is_some() ==> width.unwrap() >= 1,
      ensures
          // Result is a valid binary string (possibly with sign)
          width.is_none() ==> is_valid_signed_binary(result@),
          width.is_some() ==> is_valid_binary(result@),
          
          // Length constraints
          width.is_some() ==> result@.len() == width.unwrap(),
          
          // Positive numbers: standard binary representation
          num >= 0 && width.is_none() ==> 
              result@ == nat_to_binary_string((num as nat)),
          
          // Positive numbers with width: padded with zeros
          num >= 0 && width.is_some() ==> {
              let binary = nat_to_binary_string((num as nat));
              let w = width.unwrap() as nat;
              let padding = (w - binary.len()) as nat;
              result@ == Seq::new(padding, |i: int| '0') + binary
          },
          
          // Negative numbers without width: signed representation  
          num < 0 && width.is_none() ==> 
              result@ == seq!['-'] + nat_to_binary_string(((-num) as nat)),
          
          // Negative numbers with width: two's complement
          num < 0 && width.is_some() ==> {
              let w = width.unwrap();
              let two_comp = (1i64 << w as i64) + num;
              // Two's complement is in valid range
              0 <= two_comp && two_comp < (1i64 << w as i64) &&
              // Result represents the two's complement
              result@ == nat_to_binary_string((two_comp as nat)) &&
              // Padded if needed
              result@.len() == w
          }
vc-code: |-
  {
      // impl-start
      assume(false);
      Vec::new()
      // impl-end
  }
vc-postamble: |-

  }

  fn main() {}