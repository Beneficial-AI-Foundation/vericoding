vc-description: |-
  /* 
  {
    "name": "numpy.concatenate",
    "category": "Joining Arrays",
    "description": "Join a sequence of arrays along an existing axis",
    "url": "https://numpy.org/doc/stable/reference/generated/numpy.concatenate.html",
    "doc": "Join a sequence of arrays along an existing axis.\n\nParameters\n----------\na1, a2, ... : sequence of array_like\n    The arrays must have the same shape, except in the dimension\n    corresponding to `axis` (the first, by default).\naxis : int, optional\n    The axis along which the arrays will be joined. If axis is None,\n    arrays are flattened before use. Default is 0.\nout : ndarray, optional\n    If provided, the destination to place the result. The shape must be\n    correct, matching that of what concatenate would have returned if no\n    out argument were specified.\ndtype : str or dtype\n    If provided, the destination array will have this dtype. Cannot be\n    provided together with `out`.\ncasting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional\n    Controls what kind of data casting may occur. Defaults to 'same_kind'.\n\nReturns\n-------\nres : ndarray\n    The concatenated array.\n\nExamples\n--------\n>>> a = np.array([[1, 2], [3, 4]])\n>>> b = np.array([[5, 6]])\n>>> np.concatenate((a, b), axis=0)\narray([[1, 2],\n       [3, 4],\n       [5, 6]])\n>>> np.concatenate((a, b.T), axis=1)\narray([[1, 2, 5],\n       [3, 4, 6]])\n>>> np.concatenate((a, b), axis=None)\narray([1, 2, 3, 4, 5, 6])",
    "signature": "numpy.concatenate((a1, a2, ...), axis=0, out=None, dtype=None, casting='same_kind')",
    "source_location": "C implementation in numpy/_core/src/multiarray/multiarraymodule.c"
  }
  */
  
  /* numpy.concatenate: Join a sequence of arrays along an existing axis.

     For 1D arrays, concatenates two vectors end-to-end to produce a single 
     vector containing all elements from both input vectors in order.
     
     The result vector has size n + m where n and m are the sizes of the 
     input vectors.
  */
  
  /* Specification: concatenate joins two vectors preserving all elements in order.

     Precondition: True (no special preconditions for concatenation)
     Postcondition: 
     - First n elements of result are from vector a
     - Next m elements of result are from vector b  
     - Result has size n + m
  */

vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {

vc-helpers: |-
  // <vc-helpers>
  // </vc-helpers>

vc-signature: |-
  fn concatenate(a: Vec<f32>, b: Vec<f32>) -> (result: Vec<f32>)
      ensures
          result.len() == a.len() + b.len(),
          forall|i: int| 0 <= i < a.len() ==> result[i] == a[i],
          forall|j: int| 0 <= j < b.len() ==> result[a.len() + j] == b[j],

vc-implementation: |-
  // <vc-implementation>
  {
      assume(false); // TODO: Remove this line and implement the function body
      Vec::new()
  }
  // </vc-implementation>

vc-condition: |-
  proof fn concatenate_spec(a: Vec<f32>, b: Vec<f32>)
      requires true
      ensures
          forall|result: Vec<f32>| 
              #[trigger] result.len() == a.len() + b.len() &&
              (forall|i: int| 0 <= i < a.len() ==> result[i] == a[i]) &&
              (forall|j: int| 0 <= j < b.len() ==> result[a.len() + j] == b[j]) ==>
              result.len() == a.len() + b.len()

vc-proof: |-
  // <vc-proof>
  {
      assume(false); // TODO: Remove this line and implement the proof
  }
  // </vc-proof>

vc-postamble: |-
  
  fn main() {}
  
  }