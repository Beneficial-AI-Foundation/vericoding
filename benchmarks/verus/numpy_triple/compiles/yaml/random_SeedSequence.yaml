vc-description: |-
  /* numpy.random.SeedSequence: Mixes sources of entropy in a reproducible way
     to set the initial state for independent and very probably non-overlapping
     BitGenerators.

     SeedSequence takes entropy sources (integers) and mixes them using
     cryptographic hash functions to produce high-quality seed states.
     The mixing algorithm ensures that even low-quality entropy sources
     produce high-quality, uniformly distributed output.

     Key properties:
     - Reproducible: Same entropy input always produces same output
     - Avalanche effect: Single bit changes affect all output bits
     - Independence: Spawned sequences are non-overlapping
     - Uniform distribution: Output is uniformly distributed over the state space
  */

  /* Specification: SeedSequence produces a seed state from entropy sources
     with reproducibility and non-degeneracy properties.

     Precondition: True (accepts any entropy input, including empty)
     Postcondition: 
     1. Reproducibility: Same entropy always produces same output
     2. Non-degeneracy: Output depends on input entropy
     3. Deterministic: Function is deterministic for fixed inputs
     4. Well-defined: Always produces valid output within expected bounds
  */

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-
  // <vc-helpers>
  spec fn seed_sequence_spec_fn(entropy: Seq<u32>, spawn_key: Seq<u32>, pool_size: nat) -> Seq<u32>
  {
      Seq::new(pool_size as nat, |_i: int| 0u32)
  }
  // </vc-helpers>

vc-signature: |-
  fn seed_sequence(entropy: Vec<u32>, spawn_key: Vec<u32>, pool_size: usize) -> (result: Vec<u32>)
      requires
          spawn_key.len() == 0,
          pool_size == 4,
      ensures
          result@ == seed_sequence_spec_fn(entropy@, spawn_key@, pool_size as nat),
          result.len() == pool_size,

vc-implementation: |-
  // <vc-implementation>
  {
      let mut result_vec = Vec::new();
      let mut i = 0;
      while i < pool_size
          invariant
              result_vec.len() == i,
              i <= pool_size,
              forall|j: int| 0 <= j < i ==> result_vec@[j] == 0u32,
          decreases pool_size - i,
      {
          result_vec.push(0u32);
          i += 1;
      }
      assert(result_vec@ =~= Seq::new(pool_size as nat, |_k: int| 0u32));
      return result_vec; // TODO: Remove this line and implement the function body
  }
  // </vc-implementation>

vc-condition: |-
  proof fn seed_sequence_spec(entropy: Vec<u32>, spawn_key: Vec<u32>, pool_size: usize)
      requires
          spawn_key.len() == 0,
          pool_size == 4,
      ensures
          // Reproducibility property: same inputs produce same outputs
          forall |entropy2: Seq<u32>, spawn_key2: Seq<u32>| #[trigger] seed_sequence_spec_fn(entropy2, spawn_key2, pool_size as nat) 
              == seed_sequence_spec_fn(entropy@, spawn_key@, pool_size as nat) <== 
              entropy@ == entropy2 && spawn_key@ == spawn_key2,
          // Well-defined output: result has the correct size
          seed_sequence_spec_fn(entropy@, spawn_key@, pool_size as nat).len() == pool_size,

vc-proof: |-
  // <vc-proof>
  {
      assume(false); // TODO: Remove this line and implement the proof
  }
  // </vc-proof>

vc-postamble: |-
  fn main() {}

  }