vc-description: |-
  /*
  {
    "name": "numpy.triu",
    "category": "Diagonal operations",
    "description": "Upper triangle of an array",
    "url": "https://numpy.org/doc/stable/reference/generated/numpy.triu.html",
    "doc": "Upper triangle of an array.\n\nReturn a copy of an array with the elements below the `k`-th diagonal zeroed. For arrays with ``ndim`` exceeding 2, `triu` will apply to the final two axes.\n\nParameters\n----------\nm : array_like, shape (..., M, N)\n    Input array.\nk : int, optional\n    Diagonal below which to zero elements. `k = 0` (the default) is the main diagonal, `k < 0` is below it and `k > 0` is above.\n\nReturns\n-------\ntriu : ndarray, shape (..., M, N)\n    Upper triangle of `m`, of same shape and data-type as `m`.",
  }
  */
  
  /* Upper triangle of a matrix. Returns a copy of the matrix with elements below the k-th diagonal zeroed.
      
      Given a matrix m and an integer k, this function returns a new matrix where:
      - Elements at position (i,j) where i+k <= j are preserved (upper triangle including k-th diagonal)
      - Elements at position (i,j) where i+k > j are set to zero (below k-th diagonal)
      
      The diagonal offset k works as follows:
      - k = 0: main diagonal (default)
      - k > 0: diagonal above the main diagonal
      - k < 0: diagonal below the main diagonal */
  
  /* Specification: triu returns the upper triangle of a matrix with elements below the k-th diagonal set to zero.
      
      Mathematical properties:
      1. Elements on and above the k-th diagonal are preserved: if i+k <= j, then result[i][j] = m[i][j]
      2. Elements below the k-th diagonal are zeroed: if i+k > j, then result[i][j] = 0
      3. The result matrix has the same dimensions as the input matrix
      
      The k-th diagonal is defined as positions (i,j) where i+k = j:
      - When k=0: main diagonal (i=j)
      - When k>0: diagonal above main diagonal 
      - When k<0: diagonal below main diagonal
      
      This captures the essential behavior of numpy.triu which extracts the upper triangular part
      of a matrix relative to the k-th diagonal. */

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-
  // <vc-helpers>
  // </vc-helpers>

vc-signature: |-
  fn triu(m: &Vec<Vec<f32>>, k: i32) -> (result: Vec<Vec<f32>>)
      requires m.len() > 0,
               forall|i: int| 0 <= i < m.len() ==> #[trigger] m[i].len() == m[0].len()
      ensures result.len() == m.len(),
              forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i].len() == m[0].len(),
              forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result[i].len() && (i as i32) + k <= (j as i32) ==> #[trigger] result[i][j] == m[i][j],
              forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result[i].len() && (i as i32) + k > (j as i32) ==> #[trigger] result[i][j] == 0.0f32

vc-implementation: |-
  // <vc-implementation>
  {
      assume(false);
      return m.clone(); // TODO: Remove this line and implement the function body
  }
  // </vc-implementation>

vc-condition: |-
  proof fn triu_spec_proof(m: &Vec<Vec<f32>>, k: i32)
      requires m.len() > 0,
               forall|i: int| 0 <= i < m.len() ==> #[trigger] m[i].len() == m[0].len()

vc-proof: |-
  // <vc-proof>
  {
      assume(false); // TODO: Remove this line and implement the proof
  }
  // </vc-proof>

vc-postamble: |-

  fn main() {}

  }