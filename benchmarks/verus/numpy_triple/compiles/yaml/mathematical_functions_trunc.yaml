vc-description: |-
  numpy.trunc: Return the truncated value of the input, element-wise.

  The truncated value of the scalar x is the nearest integer i which is closer to zero than x is.
  This is equivalent to:
  - For positive x: floor(x) (largest integer ≤ x)
  - For negative x: ceil(x) (smallest integer ≥ x)
  - For zero: 0

  Returns an array of the same shape as x, containing the truncated values.

  Specification: numpy.trunc returns a vector where each element is the 
  truncated value of the corresponding element in x.

  Precondition: True (truncation is defined for all real numbers)
  Postcondition: For all indices i, result[i] is the truncated value of x[i],
                 which is the nearest integer closer to zero than x[i]. This means:
                 - result[i] is an integer value (represented as Float)
                 - For positive x: result[i] = floor(x[i])
                 - For negative x: result[i] = ceil(x[i])
                 - Truncation moves towards zero: |result[i]| ≤ |x[i]|
                 - Sign preservation: result and x have same sign (or both are zero)
                 - Monotonicity: the function is monotonic in the sense that it preserves ordering
                 - Idempotence: trunc(trunc(x)) = trunc(x)
                 - Integer preservation: if x[i] is an integer, then result[i] = x[i]
vc-preamble: |-
  use vstd::prelude::*;

  verus! {
vc-helpers: |-

vc-spec: |-
  fn numpy_trunc(x: &Vec<i32>) -> (result: Vec<i32>)
      ensures
          result.len() == x.len(),
          forall|i: int| 0 <= i < x.len() ==> {
              /* For positive or zero inputs: floor behavior (no change for integers) */
              (x[i] >= 0 ==> result[i] == x[i]) &&
              /* For negative inputs: ceil behavior (no change for integers) */
              (x[i] < 0 ==> result[i] == x[i]) &&
              /* Sign preservation */
              (x[i] > 0 ==> result[i] >= 0) &&
              (x[i] < 0 ==> result[i] <= 0) &&
              /* Bounded property */
              (x[i] >= 0 ==> result[i] <= x[i]) &&
              (x[i] <= 0 ==> result[i] >= x[i])
          },
vc-code: |-
  {
      // impl-start
      assume(false);
      Vec::new()
      // impl-end
  }
vc-postamble: |-

  }
  fn main() {}