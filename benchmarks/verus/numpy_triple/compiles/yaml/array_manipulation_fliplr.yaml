vc-description: |-
  /* 
  {
    "name": "numpy.fliplr",
    "category": "Rearranging Elements",
    "description": "Reverse the order of elements along axis 1 (left/right)",
    "url": "https://numpy.org/doc/stable/reference/generated/numpy.fliplr.html",
    "doc": "Reverse the order of elements along axis 1 (left/right).\n\nFor a 2-D array, this flips the entries in each row in the left/right\ndirection. Columns are preserved, but appear in a different order than\nbefore.\n\nParameters\n----------\nm : array_like\n    Input array, must be at least 2-D.\n\nReturns\n-------\nf : ndarray\n    A view of `m` with the columns reversed. Since a view\n    is returned, this operation is :math:`\\mathcal O(1)`.\n\nExamples\n--------\n>>> A = np.diag([1.,2.,3.])\n>>> A\narray([[1.,  0.,  0.],\n       [0.,  2.,  0.],\n       [0.,  0.,  3.]])\n>>> np.fliplr(A)\narray([[0.,  0.,  1.],\n       [0.,  2.,  0.],\n       [3.,  0.,  0.]])\n\n>>> A = np.random.randn(2,3,5)\n>>> np.all(np.fliplr(A) == A[:,::-1,...])\nTrue",
    "source_location": "numpy/lib/_twodim_base_impl.py",
    "signature": "numpy.fliplr(m)"
  }
  */
  
  /* Reverses the order of columns in a 2D matrix (left/right flip).
     For a matrix with shape (rows Ã— cols), this operation reverses the order 
     of elements along each row, effectively flipping the matrix horizontally. */
  
  /* Specification: fliplr reverses the column order in each row of the matrix.
     The element at position (i, j) in the input matrix appears at position 
     (i, cols-1-j) in the output matrix. This captures the mathematical property
     that columns are reversed while rows remain in the same order.
     
     Sanity checks:
     1. The output has the same dimensions as the input (enforced by type)
     2. Each row contains the same elements, just in reversed order
     3. For matrices with odd number of columns, the middle column stays in place
     
     Mathematical properties:
     1. Element mapping: For all valid indices i and j, there exists a corresponding
        index j' such that output[i,j] = input[i,j'] where j' = cols-1-j
     2. Row preservation: Each row contains exactly the same elements as the input
     3. Column reversal: The first column becomes the last, second becomes second-to-last, etc. */

vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {

vc-helpers: |-
  // <vc-helpers>
  // </vc-helpers>

vc-signature: |-
  fn fliplr(rows: usize, cols: usize, m: Vec<Vec<f32>>) -> (result: Vec<Vec<f32>>)
      requires
          rows > 0,
          cols > 0,
          m.len() == rows,
          forall|i: int| 0 <= i < rows ==> #[trigger] m[i].len() == cols,

vc-implementation: |-
  // <vc-implementation>
      {
          return Vec::new(); // TODO: Remove this line and implement the function body
      }
  // </vc-implementation>

vc-condition: |-
  proof fn fliplr_spec(rows: usize, cols: usize, m: Vec<Vec<f32>>)
      requires
          rows > 0,
          cols > 0,
          m.len() == rows,
          forall|i: int| 0 <= i < rows ==> #[trigger] m[i].len() == cols,
      ensures
          /* For all valid indices i and j, there exists a corresponding index k
             such that result[i][j] = m[i][k] and j + k = cols - 1 */
          /* Each row contains the same elements as the input, just in reversed order */
          /* For matrices with odd number of columns, the middle column stays in place */
          true, /* TODO: Add proper postconditions */

vc-proof: |-
  // <vc-proof>
      {
          assume(false); // TODO: Remove this line and implement the proof
      }
  // </vc-proof>

vc-postamble: |-
  
  fn main() {}
  
  }