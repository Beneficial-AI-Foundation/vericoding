{"id": "VT0004", "language": "verus", "source": "numpy_triple", "source_id": "array_creation_ascontiguousarray", "vc-description": "Return a contiguous array (ndim >= 1) in memory (C order).\nThis function ensures the input array is contiguous in C order and guarantees\nminimum dimensionality of 1. For non-empty input, preserves all elements.\n\nSpecification: ascontiguousarray returns a contiguous array with same content,\nensuring minimum dimensionality of 1. For non-empty arrays, elements are preserved\nexactly. For empty arrays, returns a 1-dimensional array with 1 element.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn ascontiguousarray(a: Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() >= 1,\n        a.len() > 0 ==> result.len() == a.len(),\n        a.len() == 0 ==> result.len() == 1,\n        a.len() > 0 ==> forall|i: int| 0 <= i < a.len() ==> exists|j: int| 0 <= j < result.len() && result[j] == a[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling"}
{"id": "VT0009", "language": "verus", "source": "numpy_triple", "source_id": "array_creation_diagflat", "vc-description": "numpy.diagflat: Create a two-dimensional array with the flattened input as a diagonal.\n\nTakes an input vector (representing flattened data) and creates a square matrix\nwhere the input values appear along the k-th diagonal. The parameter k determines\nwhich diagonal to use: k=0 for main diagonal, k>0 for super-diagonals,\nand k<0 for sub-diagonals.\n\nFor simplicity, we focus on the main diagonal case (k=0) and return a 1D flattened\nrepresentation of the square matrix.\n\nSpecification: diagflat creates a square matrix with input values on the main diagonal.\n\nPrecondition: True (no special preconditions)\nPostcondition: The result is a flattened square matrix where:\n1. The input vector v appears along the main diagonal\n2. All other elements are zero\n3. The matrix has dimensions n × n (flattened to n² elements)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn diagflat(v: Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() == v.len() * v.len(),\n        forall|i: int| 0 <= i < v.len() ==> result[i * v.len() + i] == v[i],\n        forall|i: int, j: int| 0 <= i < v.len() && 0 <= j < v.len() && i != j ==> result[i * v.len() + j] == 0.0f32", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling"}
{"id": "VT0011", "language": "verus", "source": "numpy_triple", "source_id": "array_creation_empty_like", "vc-description": "numpy.empty_like: Return a new array with the same shape and type as a given array.\n\nCreates a new array with the same shape and type as the prototype array,\nbut with uninitialized (arbitrary) data. This is useful for creating\narrays that will be filled with values later, avoiding the overhead\nof initialization.\n\nThe returned array has the same dimensions as the prototype but does not\ncopy the values - the contents are undefined and may contain any values.\n\nSpecification: numpy.empty_like returns a vector with the same size as the prototype\nbut with uninitialized values.\n\nPrecondition: True (no special preconditions needed)\nPostcondition: \n1. The result has the same size as the prototype array\n2. The result vector is well-formed with proper indexing\n3. The result is independent of the prototype's values (shape invariant)\n\nMathematical Properties:\n- Size preservation: |result| = |prototype| = n\n- Index validity: all valid indices for prototype are valid for result\n- Type preservation: result has same element type as prototype\n\nNote: We cannot specify the actual values since they are uninitialized,\nbut we can specify structural and size properties that must hold.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_empty_like(prototype: &Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() == prototype.len(),\n        forall|i: int| 0 <= i < prototype.len() ==> 0 <= i < result.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling"}
{"id": "VT0012", "language": "verus", "source": "numpy_triple", "source_id": "array_creation_eye", "vc-description": "numpy.eye: Return a 2-D array with ones on the diagonal and zeros elsewhere.\n\nReturns the identity matrix of size n x n. For simplicity, we implement \nthe square matrix case (N=M) with diagonal offset k=0.\n\nThis function creates an n x n matrix where all elements are zero except\nfor the main diagonal, which contains ones.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn eye(n: usize) -> (result: Vec<Vec<f32>>)\n    ensures\n        result.len() == n,\n        forall|i: int| 0 <= i < n ==> result[i].len() == n,\n        forall|i: int, j: int| 0 <= i < n && 0 <= j < n ==> \n            result[i][j] == if i == j { 1.0f32 } else { 0.0f32 },\n        forall|i: int, j: int| 0 <= i < n && 0 <= j < n ==> \n            result[i][j] == result[j][i],\n        forall|i: int| 0 <= i < n ==> exists|j: int| 0 <= j < n && \n            result[i][j] == 1.0f32 && forall|k: int| 0 <= k < n && result[i][k] == 1.0f32 ==> k == j,\n        forall|j: int| 0 <= j < n ==> exists|i: int| 0 <= i < n && \n            result[i][j] == 1.0f32 && forall|k: int| 0 <= k < n && result[k][j] == 1.0f32 ==> k == i,\n        forall|i: int, j: int| 0 <= i < n && 0 <= j < n && i != j ==> \n            result[i][j] == 0.0f32,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling"}
{"id": "VT0035", "language": "verus", "source": "numpy_triple", "source_id": "array_creation_zeros", "vc-description": "Return a new vector of given size, filled with zeros\n\nSpecification: zeros returns a vector where all elements are zero\nThis comprehensive specification captures:\n1. All elements equal to zero (basic property)\n2. The result is the additive identity for vector addition\n3. The sum of all elements is zero (for numeric types)\n4. Scalar multiplication by any value preserves the zero property\n5. The dot product with any vector is zero\n6. The norm/magnitude is zero (for types with norm)\n7. Element-wise operations preserve zero structure", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn zeros(n: usize) -> (result: Vec<i32>)\n    ensures\n        result.len() == n,\n        forall|i: int| 0 <= i < n ==> result[i] == 0,\n        forall|v: Vec<i32>, i: int| \n            v.len() == n && 0 <= i < n ==> \n            result[i] + v[i] == v[i] && v[i] + result[i] == v[i],\n        forall|scalar: i32, i: int| \n            0 <= i < n ==> scalar * result[i] == 0,\n        forall|v: Vec<i32>, i: int| \n            v.len() == n && 0 <= i < n ==> result[i] * v[i] == 0,\n        n > 0 ==> result[0] == 0", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling"}
{"id": "VT0041", "language": "verus", "source": "numpy_triple", "source_id": "array_manipulation_atleast_3d", "vc-description": "numpy.atleast_3d: View a 1D vector as a 3D array with shape (1, n, 1).\n\nThis is a specialization of numpy.atleast_3d for 1D input.\nThe function reshapes a 1D array of shape (n,) into a 3D array \nof shape (1, n, 1) while preserving all elements.\n\nSpecification: atleast_3d transforms a 1D vector into a 3D array where:\n- The output has shape (1, n, 1)\n- Each element arr[i] is accessible at position [0][i][0] in the result\n- All elements are preserved without modification\n- The transformation is injective (different inputs produce different outputs)\n\nMathematical properties:\n1. Element preservation: Every element from the input appears exactly once in the output\n2. Shape expansion: A 1D shape (n,) becomes 3D shape (1, n, 1)\n3. Order preservation: Elements maintain their relative ordering\n4. The output contains exactly n elements total", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn atleast_3d(arr: Vec<f32>) -> (result: Vec<Vec<Vec<f32>>>)\n    ensures \n        result.len() == 1,\n        forall|j: int| 0 <= j < 1 ==> result[j].len() == arr.len(),\n        forall|j: int, k: int| 0 <= j < 1 && 0 <= k < arr.len() ==> result[j][k].len() == 1,\n        forall|i: int| 0 <= i < arr.len() ==> {\n            let outer = &result[0];\n            let middle = &outer[i];\n            let value = middle[0];\n            value == arr[i]\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling"}
{"id": "VT0042", "language": "verus", "source": "numpy_triple", "source_id": "array_manipulation_block", "vc-description": "Assemble a 2D matrix from a 2x2 block structure.\nThis is a simplified version focusing on the common case of assembling \na matrix from four blocks arranged in a 2x2 pattern.\n\nSpecification: block assembles a matrix from four submatrices in a 2x2 pattern.\nThe result has dimensions (r1 + r2) × (c1 + c2) where:\n- Top-left block occupies rows [0, r1) and columns [0, c1)\n- Top-right block occupies rows [0, r1) and columns [c1, c1 + c2)\n- Bottom-left block occupies rows [r1, r1 + r2) and columns [0, c1)\n- Bottom-right block occupies rows [r1, r1 + r2) and columns [c1, c1 + c2)\n\n/* Top-left block elements */\n\n/* Top-right block elements */\n\n/* Bottom-left block elements */\n\n/* Bottom-right block elements */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn block(\n    top_left: Vec<Vec<f32>>,\n    top_right: Vec<Vec<f32>>,\n    bottom_left: Vec<Vec<f32>>,\n    bottom_right: Vec<Vec<f32>>\n) -> (result: Vec<Vec<f32>>)\n    requires\n        top_left.len() > 0,\n        top_right.len() > 0,\n        bottom_left.len() > 0,\n        bottom_right.len() > 0,\n        top_left.len() == top_right.len(),\n        bottom_left.len() == bottom_right.len(),\n        top_left[0].len() == bottom_left[0].len(),\n        top_right[0].len() == bottom_right[0].len(),\n        forall|i: int| 0 <= i < top_left.len() ==> top_left[i].len() == top_left[0].len(),\n        forall|i: int| 0 <= i < top_right.len() ==> top_right[i].len() == top_right[0].len(),\n        forall|i: int| 0 <= i < bottom_left.len() ==> bottom_left[i].len() == bottom_left[0].len(),\n        forall|i: int| 0 <= i < bottom_right.len() ==> bottom_right[i].len() == bottom_right[0].len(),\n    ensures\n        result.len() == top_left.len() + bottom_left.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == top_left[0].len() + top_right[0].len(),\n\n        forall|i: int, j: int| \n            0 <= i < top_left.len() && 0 <= j < top_left[0].len() ==> \n            result[i][j] == top_left[i][j],\n\n        forall|i: int, j: int|\n            0 <= i < top_right.len() && 0 <= j < top_right[0].len() ==>\n            result[i][top_left[0].len() + j] == top_right[i][j],\n\n        forall|i: int, j: int|\n            0 <= i < bottom_left.len() && 0 <= j < bottom_left[0].len() ==>\n            result[top_left.len() + i][j] == bottom_left[i][j],\n\n        forall|i: int, j: int|\n            0 <= i < bottom_right.len() && 0 <= j < bottom_right[0].len() ==>\n            result[top_left.len() + i][top_left[0].len() + j] == bottom_right[i][j],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling"}
{"id": "VT0045", "language": "verus", "source": "numpy_triple", "source_id": "array_manipulation_broadcast_to", "vc-description": "Broadcast a 1D vector to a 2D matrix by repeating it along rows.\nThis implements the most common broadcasting pattern: (n,) -> (m, n)\n\nSpecification: broadcast_to creates a 2D matrix where each row is a copy of the input vector.\n\nMathematical properties:\n1. Shape property: The result has shape (m, n) where n is the original vector length\n2. Value property: Each row in the result equals the original vector\n3. Broadcasting rule: A 1D array of shape (n,) can be broadcast to (m, n) by repeating\n4. Row consistency: All rows in the result are identical to the input vector\n5. Element preservation: Each element in the input appears m times in each column\n\nSanity checks:\n- The output shape is exactly (m, n)\n- Every row contains the same values as the input vector\n- Broadcasting preserves element values without modification\n- The result behaves as if v was copied m times along a new axis\n\nExample behavior:\n- Input: [1, 2, 3] with target shape (2, 3)\n- Output: [[1, 2, 3], [1, 2, 3]]\n\nAdditional properties:\n- Memory efficiency: In NumPy, this creates a view, not a copy\n- Column-wise view: Column j contains m copies of v[j]\n- Broadcasting compatibility: The result can be used in element-wise operations with other (m, n) arrays\n\nMathematical formulation:\n- For input vector v ∈ ℝⁿ and target shape (m, n)\n- Output matrix M ∈ ℝᵐˣⁿ where M[i,j] = v[j] for all i ∈ {0,...,m-1}, j ∈ {0,...,n-1}\n\n/* Primary property: each element (i,j) equals v[j] */\n\n/* Row identity: each row is exactly the input vector */\n\n/* Column uniformity: each column contains a single repeated value */\n\n/* Value preservation: no new values are introduced */\n\n/* Broadcast invariant: the operation is idempotent on rows */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn broadcast_to(v: Vec<f32>, m: usize) -> (result: Vec<Vec<f32>>)\n    requires v.len() > 0,\n    ensures\n        result.len() == m,\n\n        forall|i: int, j: int| 0 <= i < m && 0 <= j < v.len() ==> result[i][j] == v[j],\n\n        forall|i: int| 0 <= i < m ==> result[i]@ == v@,\n\n        forall|j: int, i1: int, i2: int| 0 <= j < v.len() && 0 <= i1 < m && 0 <= i2 < m ==> result[i1][j] == result[i2][j],\n\n        forall|i: int, j: int| 0 <= i < m && 0 <= j < v.len() ==> exists|k: int| 0 <= k < v.len() && result[i][j] == v[k] && k == j,\n\n        forall|i1: int, i2: int| 0 <= i1 < m && 0 <= i2 < m ==> result[i1]@ == result[i2]@", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling"}
{"id": "VT0046", "language": "verus", "source": "numpy_triple", "source_id": "array_manipulation_column_stack", "vc-description": "numpy.column_stack: Stack 1-D arrays as columns into a 2-D array.\n\nTakes a sequence of 1-D arrays and stacks them as columns to make a \nsingle 2-D array. All input arrays must have the same length (number \nof rows in the output).\n\nThe result is represented as a flattened vector in column-major order,\nwhere elements from the same column are contiguous. For a result with\n'rows' rows and 'cols' columns, element at position (i, j) is stored\nat index j * rows + i in the flattened vector.\n\nThis is a fundamental array manipulation operation that combines multiple\n1D arrays into a single 2D structure, useful for constructing matrices\nfrom column vectors.\n\nSpecification: column_stack creates a 2D array (as flattened vector) where\neach input array becomes a column.\n\nPrecondition: cols > 0 (at least one input array)\nPostcondition: \n- The result contains all elements from the input arrays\n- Elements are arranged in column-major order\n- The j-th column of the result contains all elements from arrays[j]\n- For 0 ≤ i < rows and 0 ≤ j < cols, the element at position (i,j)\n  in the 2D view equals arrays[j][i] and is stored at index j*rows + i", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn column_stack(arrays: Vec<Vec<f32>>) -> (result: Vec<f32>)\n    requires\n        arrays.len() > 0,\n        forall|i: int| 0 <= i < arrays.len() ==> arrays[i].len() == arrays[0].len(),\n    ensures\n        result.len() == arrays.len() * arrays[0].len(),\n        forall|i: int, j: int| \n            0 <= i < arrays[0].len() && 0 <= j < arrays.len() ==>\n            result[j * arrays[0].len() + i] == arrays[j][i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling"}
{"id": "VT0049", "language": "verus", "source": "numpy_triple", "source_id": "array_manipulation_delete", "vc-description": "numpy.delete: Return a new array with sub-arrays along an axis deleted.\n\nFor a one dimensional array, this returns those entries not returned by\narr[obj]. The function removes elements at the specified index and\nreturns a new array with the remaining elements.\n\nThis specification handles the 1D case where we delete a single element\nat a specified index from a vector.\n\nSpecification: numpy.delete removes the element at the specified index and returns\na new vector containing all other elements in their original order.\n\nThe specification ensures:\n1. The result has size n (one less than the input)\n2. Elements before the deleted index maintain their positions\n3. Elements after the deleted index are shifted left by one position\n\nMathematical properties:\n- Order preservation: Elements maintain their relative order\n- Deletion correctness: The element at the specified index is removed\n- Shift property: Elements after the deleted index have their indices decreased by 1\n\nSanity checks:\n- The result size is exactly one less than the input size\n- No elements are duplicated or lost (except the deleted one)\n- The deleted element does not appear in the result\n\nPrecondition: The array must have at least one element (enforced by type)\n\nPostcondition:\n- For indices i < index: result[i] = arr[i]\n- For indices i ≥ index: result[i] = arr[i+1]\n- The element arr[index] does not appear in the result (unless duplicated elsewhere)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn delete(arr: Vec<f32>, index: usize) -> (result: Vec<f32>)\n    requires \n        arr.len() > 0,\n        index < arr.len(),\n    ensures \n        result.len() == arr.len() - 1,\n        forall|i: int| 0 <= i < index ==> result[i] == arr[i],\n        forall|i: int| index <= i < result.len() ==> result[i] == arr[i + 1],\n        forall|i: int| 0 <= i < arr.len() && i != index ==> \n            exists|j: int| 0 <= j < result.len() && result[j] == arr[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling"}
{"id": "VT0051", "language": "verus", "source": "numpy_triple", "source_id": "array_manipulation_dstack", "vc-description": "numpy.dstack: Stack arrays in sequence depth wise (along third axis).\n\nFor a sequence of 1D arrays (vectors), this function stacks them along a new third axis,\ncreating a 3D array. Each input vector becomes a \"slice\" in the depth dimension.\n\nFor 1D inputs of length n, the output shape is (1, n, k) where k is the number of arrays.\nThis is because 1D arrays are first reshaped to (1, n) then stacked along axis 2.\n\nThe result is always at least 3-dimensional.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_dstack(arrays: Vec<Vec<f32>>) -> (result: Vec<Vec<Vec<f32>>>)\n    requires \n        arrays.len() > 0,\n        forall|i: int| 0 <= i < arrays.len() ==> \n            forall|j: int| 0 <= j < arrays.len() ==> arrays[i].len() == arrays[j].len(),\n    ensures\n        result.len() == 1,\n        result[0].len() == if arrays.len() > 0 { arrays[0].len() } else { 0 },\n        forall|i: int| 0 <= i < result[0].len() ==> result[0][i].len() == arrays.len(),\n        forall|i: int, j: int| \n            0 <= i < result[0].len() && 0 <= j < arrays.len() ==>\n            result[0][i][j] == arrays[j][i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling"}
{"id": "VT0054", "language": "verus", "source": "numpy_triple", "source_id": "array_manipulation_fliplr", "vc-description": "Reverses the order of columns in a 2D matrix (left/right flip).\nFor a matrix with shape (rows × cols), this operation reverses the order \nof elements along each row, effectively flipping the matrix horizontally.\n\nSpecification: fliplr reverses the column order in each row of the matrix.\nThe element at position (i, j) in the input matrix appears at position \n(i, cols-1-j) in the output matrix. This captures the mathematical property\nthat columns are reversed while rows remain in the same order.\n\nSanity checks:\n1. The output has the same dimensions as the input (enforced by type)\n2. Each row contains the same elements, just in reversed order\n3. For matrices with odd number of columns, the middle column stays in place\n\nMathematical properties:\n1. Element mapping: For all valid indices i and j, there exists a corresponding\n   index j' such that output[i,j] = input[i,j'] where j' = cols-1-j\n2. Row preservation: Each row contains exactly the same elements as the input\n3. Column reversal: The first column becomes the last, second becomes second-to-last, etc.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn fliplr(m: Vec<Vec<f32>>) -> (result: Vec<Vec<f32>>)\n    requires \n        m.len() > 0,\n        forall|i: int| 0 <= i < m.len() ==> m[i].len() > 0,\n        forall|i: int, j: int| 0 <= i < m.len() && 0 <= j < m.len() ==> m[i].len() == m[j].len(),\n    ensures\n        result.len() == m.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == m[i].len(),\n        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result[i].len() ==>\n            exists|k: int| 0 <= k < m[i].len() && \n                           result[i][j] == m[i][k] && \n                           j + k == (m[i].len() - 1) as int,\n        forall|i: int, x: f32| 0 <= i < result.len() ==>\n            ((exists|j: int| 0 <= j < m[i].len() && m[i][j] == x) <==> \n             (exists|j: int| 0 <= j < result[i].len() && result[i][j] == x)),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling"}
{"id": "VT0059", "language": "verus", "source": "numpy_triple", "source_id": "array_manipulation_matrix_transpose", "vc-description": "Transposes a matrix by swapping rows and columns.\nFor a matrix with shape (m, n), returns a matrix with shape (n, m)\nwhere result[i, j] = input[j, i]\n\nSpecification: matrix_transpose swaps rows and columns, producing a transposed matrix\nwhere the element at position (i, j) in the result equals the element at position (j, i)\nin the input. The result has dimensions swapped: an m×n matrix becomes n×m.\n\n/* Dimension check: result is n×m when input is m×n */\n\n/* Transpose property: result[i][j] = mat[j][i] */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn matrix_transpose(mat: &Vec<Vec<f32>>) -> (result: Vec<Vec<f32>>)\n    requires \n        mat.len() > 0,\n        forall|i: int| 0 <= i < mat.len() ==> mat[i].len() == mat[0].len(),\n    ensures\n\n        result.len() == mat[0].len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == mat.len(),\n\n        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result[i].len() ==> \n            result[i][j] == mat[j][i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling"}
{"id": "VT0063", "language": "verus", "source": "numpy_triple", "source_id": "array_manipulation_repeat", "vc-description": "Repeat elements of a vector a specified number of times.\nEach element is repeated consecutively.\n\nSpecification: repeat creates a vector where each element from the input \nappears consecutively 'repeats' times. The resulting vector has size n * repeats.\n\nFor a vector [a₀, a₁, ..., aₙ₋₁] and repeats = r, the result is:\n[a₀, a₀, ..., a₀, a₁, a₁, ..., a₁, ..., aₙ₋₁, aₙ₋₁, ..., aₙ₋₁]\n \\___r times___/  \\___r times___/       \\______r times______/\n\nMathematical properties:\n1. Each element appears exactly 'repeats' times consecutively\n2. The total size is n * repeats\n3. Element at index i comes from input element at index ⌊i/repeats⌋\n4. Elements are grouped: positions [k*repeats, (k+1)*repeats) contain a[k]", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn repeat<T: Copy>(a: Vec<T>, repeats: usize) -> (result: Vec<T>)\n    requires repeats > 0,\n    ensures\n        result.len() == a.len() * repeats,\n        forall|i: int| 0 <= i < result.len() ==> {\n            let k = i / (repeats as int);\n            0 <= k < a.len() && result[i] == a[k]\n        },\n        forall|k: int| 0 <= k < a.len() ==> forall|j: int| 0 <= j < repeats ==> {\n            let idx = k * (repeats as int) + j;\n            0 <= idx < result.len() && result[idx] == a[k]\n        },", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling"}
{"id": "VT0075", "language": "verus", "source": "numpy_triple", "source_id": "array_manipulation_swapaxes", "vc-description": "Numpy swapaxes function: Interchange two axes of an array.\n\nThis function interchanges two axes of an array. For 2D arrays, swapaxes with axis1=0 and axis2=1 is equivalent to transpose. This specification focuses on 2D arrays where axis1=0 and axis2=1.\n\nSpecification: swapaxes with axes 0 and 1 transposes a 2D array.\nThe element at position (i,j) in the original becomes (j,i) in the result.\n\nMathematical properties:\n1. Dimension swap: rows become columns and vice versa\n2. Element preservation: mat[i][j] = result[j][i]\n3. Idempotence: swapping twice returns to original\n4. Commutativity: swapaxes(a, i, j) = swapaxes(a, j, i)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn swapaxes(mat: Vec<Vec<f32>>, axis1: usize, axis2: usize) -> (result: Vec<Vec<f32>>)\n    requires\n        mat.len() > 0,\n        mat[0].len() > 0,\n        forall|i: int| 0 <= i < mat.len() ==> mat[i].len() == mat[0].len(),\n        axis1 < 2,\n        axis2 < 2,\n    ensures\n        result.len() == mat[0].len(),\n        result.len() > 0 ==> result[0].len() == mat.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == mat.len(),\n        forall|i: int, j: int| \n            0 <= i < mat.len() && 0 <= j < mat[0].len() \n            ==> mat[i][j] == result[j][i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling"}
{"id": "VT0077", "language": "verus", "source": "numpy_triple", "source_id": "array_manipulation_transpose", "vc-description": "numpy.transpose: Returns a matrix with rows and columns swapped.\n\nFor 2D arrays (matrices), transpose swaps the rows and columns.\nThis means that element at position (i,j) in the original matrix\nappears at position (j,i) in the transposed matrix.\n\nThis simplified version handles 2D matrix transpose only.\n\nSpecification: numpy.transpose returns a matrix where rows and columns are swapped.\n\nPrecondition: True (no special preconditions for basic transpose)\nPostcondition: For all valid indices (i,j), result[j][i] = a[i][j]\n\nMathematical properties:\n- Transpose is an involution: (A^T)^T = A\n- For square matrices: trace(A^T) = trace(A)\n- (A^T)[j,i] = A[i,j] for all valid indices", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_transpose(a: Vec<Vec<f32>>) -> (result: Vec<Vec<f32>>)\n    requires \n        a.len() > 0,\n        forall|i: int| 0 <= i < a.len() ==> a[i].len() == a[0].len(),\n        a[0].len() > 0,\n    ensures\n        result.len() == a[0].len(),\n        forall|j: int| 0 <= j < result.len() ==> result[j].len() == a.len(),\n        forall|i: int, j: int| \n            0 <= i < a.len() && 0 <= j < a[0].len() ==> \n            result[j][i] == a[i][j],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling"}
{"id": "VT0080", "language": "verus", "source": "numpy_triple", "source_id": "array_manipulation_vsplit", "vc-description": "Split a 2D vector into multiple sub-vectors vertically (row-wise).\nThis is a simplified version that handles splitting into equal parts.\n\nSpecification: vsplit divides a matrix into k equal parts row-wise, \nwhere each part contains consecutive rows from the original matrix", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn vsplit(mat: Vec<Vec<f32>>, k: usize) -> (result: Vec<Vec<Vec<f32>>>)\n    requires \n        k > 0,\n        mat.len() > 0,\n        mat.len() % k == 0,\n        forall|i: int| 0 <= i < mat.len() ==> mat[i].len() == mat[0].len(),\n    ensures\n        result.len() == k,\n        forall|split_idx: int| 0 <= split_idx < k ==> result[split_idx].len() == mat.len() / k,\n        forall|split_idx: int, row_idx: int, col_idx: int| \n            0 <= split_idx < k && 0 <= row_idx < mat.len() / k && 0 <= col_idx < mat[0].len() ==>\n            exists|global_row: int| \n                global_row == split_idx * (mat.len() / k) + row_idx &&\n                0 <= global_row < mat.len() &&\n                result[split_idx][row_idx][col_idx] == mat[global_row][col_idx],\n        forall|orig_row: int| 0 <= orig_row < mat.len() ==>\n            exists|split_idx: int, row_idx: int|\n                0 <= split_idx < k && 0 <= row_idx < mat.len() / k &&\n                orig_row == split_idx * (mat.len() / k) + row_idx,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling"}
{"id": "VT0089", "language": "verus", "source": "numpy_triple", "source_id": "bitwise_operations_packbits", "vc-description": "Packs binary-valued elements into bits in a UInt8 array.\nEach group of 8 binary values is packed into one UInt8.\nThe result is padded with zeros if needed.\n\nSpecification: packbits correctly packs binary values into UInt8 bytes according to bitorder.\nFor big-endian: first element goes to MSB (bit 7)\nFor little-endian: first element goes to LSB (bit 0)\n\n/* Enumeration for bit ordering in packbits */\n\n// MSB first (default): bit 7 is first element\n\n// LSB first: bit 0 is first element\n\n// Big-endian: bit 7 is first, bit 0 is last\n\n// Little-endian: bit 0 is first, bit 7 is last", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n#[derive(PartialEq, Eq)]\nenum BitOrder {\n    Big,\n    Little\n}", "vc-helpers": "", "vc-spec": "fn packbits(a: Vec<bool>, bitorder: BitOrder) -> (result: Vec<u8>)\n    requires a.len() > 0,\n    ensures \n        result.len() == (a.len() + 7) / 8,\n        forall|byte_idx: int| 0 <= byte_idx < result.len() ==> {\n            let start_idx = byte_idx * 8;\n            let bits_in_byte = if start_idx + 8 <= a.len() { 8 } else { a.len() - start_idx };\n            match bitorder {\n                BitOrder::Big => {\n\n                    forall|bit_pos: int| 0 <= bit_pos < bits_in_byte ==> {\n                        let bit_value = if start_idx + bit_pos < a.len() && a[start_idx + bit_pos] { 1u8 } else { 0u8 };\n                        (result[byte_idx] & (1u8 << (7 - bit_pos))) == (bit_value << (7 - bit_pos))\n                    }\n                },\n                BitOrder::Little => {\n\n                    forall|bit_pos: int| 0 <= bit_pos < bits_in_byte ==> {\n                        let bit_value = if start_idx + bit_pos < a.len() && a[start_idx + bit_pos] { 1u8 } else { 0u8 };\n                        (result[byte_idx] & (1u8 << bit_pos)) == (bit_value << bit_pos)\n                    }\n                }\n            }\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling"}
{"id": "VT0092", "language": "verus", "source": "numpy_triple", "source_id": "constants_False_", "vc-description": "NumPy's boolean False value, used in comparison operations and boolean arrays.\n\nSpecification: False_ represents the boolean false value with properties:\n1. It equals false\n2. It is the identity for logical OR\n3. It is the absorbing element for logical AND\n4. It is the negation of True_", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn false_() -> (result: bool)\n    ensures \n        result == false,\n        forall|b: bool| (result || b) == b,\n        forall|b: bool| (result && b) == false,\n        result == !true", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling"}
{"id": "VT0183", "language": "verus", "source": "numpy_triple", "source_id": "indexing_slicing_ndindex", "vc-description": "Generate N-dimensional indices for an array with given shape.\nReturns a vector of index tuples, where each tuple represents a valid\nN-dimensional index for an array with the specified dimensions.\n\nFor a 2D array with shape (m, n), this generates all index pairs\n(i, j) where 0 ≤ i < m and 0 ≤ j < n, in C-order (row-major).\n\nExample: For shape (2, 3), generates [(0,0), (0,1), (0,2), (1,0), (1,1), (1,2)]", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn ndindex(shape: (usize, usize)) -> (indices: Vec<(usize, usize)>)\n    requires shape.0 > 0 && shape.1 > 0,\n    ensures \n        indices.len() == shape.0 * shape.1,\n        forall|k: int| 0 <= k < indices.len() ==> {\n            let (i, j) = indices[k];\n            i < shape.0 && j < shape.1\n        },\n        forall|i: usize, j: usize| i < shape.0 && j < shape.1 ==> {\n            exists|k: int| 0 <= k < indices.len() && indices[k] == (i, j)\n        },\n        forall|k: int| 0 <= k < indices.len() ==> {\n            let (i, j) = indices[k];\n            k == i * shape.1 + j\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling"}
{"id": "VT0210", "language": "verus", "source": "numpy_triple", "source_id": "io_operations_load", "vc-description": "numpy.load: Load arrays or pickled objects from .npy, .npz or pickled files.\n\nLoads array data from a binary file. This operation reads serialized array data\nfrom disk storage and reconstructs it as a Vector. The function supports:\n- .npy files: Single array format\n- .npz files: Archive format with multiple arrays (simplified to single array here)\n- Pickled files: Python pickle format (when allow_pickle is True)\n\nThe file parameter represents the path to the file to be loaded.\nFor security reasons, pickled files should be avoided unless explicitly allowed.\n\nMemory mapping is not considered in this simplified specification.\n\nSpecification: numpy.load returns a vector containing the data from the file.\n\nThis specification captures the essential properties of the load operation:\n\n1. Data Preservation: The loaded vector contains exactly the data that was stored\n2. Size Consistency: The vector length matches the stored array dimensions\n3. Type Compatibility: Data is correctly interpreted as Float values\n4. Security Constraint: Object arrays are only loaded when explicitly allowed\n\nMathematical Properties:\n- Idempotence: Loading the same file multiple times yields identical results\n- Determinism: For a given file, load always returns the same vector\n- Injectivity: Different valid files produce different vectors (when they differ)\n\nPrecondition: The file exists, is readable, and contains valid array data\nPostcondition: The returned vector faithfully represents the stored data", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn load_ghost(file: String, allow_pickle: bool, n: nat) -> Vec<f64>;\n\nfn load(file: String, allow_pickle: bool, n: usize) -> (result: Vec<f64>)\n    ensures \n        result.len() == n,\n        forall|i: int| 0 <= i < n ==> exists|stored_val: f64| result[i] == stored_val,\n        forall|second_load: Vec<f64>| (#[trigger] second_load == load_ghost(file, allow_pickle, n as nat)) ==>\n            forall|i: int| 0 <= i < n ==> result[i] == second_load[i]", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling"}
{"id": "VT0624", "language": "verus", "source": "numpy_triple", "source_id": "strings_join", "vc-description": "Return a string which is the concatenation of the strings in the sequence seq.\n\nnumpy.strings.join: Return a string which is the concatenation of the strings in the sequence seq.\n\nFor each pair of separator and sequence, join the elements of the sequence using the separator.\nThis function operates element-wise on vectors, where each element of the result is obtained\nby joining the corresponding elements of the sequence vector using the corresponding separator.\n\nThe function treats each string in the sequence as a sequence of characters, and joins them\nwith the separator string. For example, join('-', 'abc') produces 'a-b-c'.\n\nFrom NumPy documentation:\n- Parameters: sep (array_like) - Separator string(s), seq (array_like) - Sequence(s) to join\n- Returns: out (ndarray) - Output array with joined strings\n- Examples: join('-', 'osd') → 'o-s-d', join(['-', '.'], ['ghc', 'osd']) → ['g-h-c', 'o.s.d']\n\nMathematical Properties:\n1. Element-wise operation: result[i] = join(sep[i], seq[i])\n2. Character separation: joins individual characters of each string in seq\n3. Empty separator handling: join('', s) = s (no separation)\n4. Empty sequence handling: join(sep, '') = '' (empty result)\n5. Single character sequences: join(sep, 'a') = 'a' (no separator needed)\n\n/* Core correctness property */\n\n/* Length property for non-trivial cases */\n\n/* Empty string preservation */\n\n/* Single character preservation */\n\n/* Non-empty result for non-empty input */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn join_chars(separator: Seq<char>, chars: Seq<char>) -> Seq<char>\n    decreases chars.len()\n{\n    if chars.len() <= 1 {\n        chars\n    } else {\n        chars.take(1) + separator + join_chars(separator, chars.skip(1))\n    }\n}\n\nspec fn string_to_chars(s: Seq<char>) -> Seq<char> {\n    s\n}\n\nspec fn chars_to_string_len(chars: Seq<char>) -> nat {\n    chars.len()\n}\n\nfn join(sep: Vec<String>, seq: Vec<String>) -> (result: Vec<String>)\n    requires sep.len() == seq.len(),\n    ensures\n        result.len() == sep.len(),\n        forall|i: int| 0 <= i < result.len() ==> {\n            let s = seq[i]@;\n            let separator = sep[i]@;\n\n            (s.len() <= 1 ==> result[i]@ == s) &&\n            (s.len() > 1 ==> result[i]@ == join_chars(separator, s)) &&\n\n            (s.len() > 1 ==> result[i]@.len() == s.len() + (s.len() - 1) * separator.len()) &&\n\n            (s.len() == 0 ==> result[i]@.len() == 0) &&\n\n            (s.len() == 1 ==> result[i]@ == s) &&\n\n            (s.len() > 0 ==> result[i]@.len() > 0)\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling"}
