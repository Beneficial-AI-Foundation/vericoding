{"id": "array_creation_array", "vc-description": "Create an array from existing data. This is the primary array creation function.\nTakes a list of Float elements and creates a Vector of the same length.\n\nSpecification: array creates a vector containing exactly the input data elements\nin the same order. The result has the same length as the input list and preserves\nall elements at their corresponding indices. This captures the fundamental property\nof numpy.array - converting sequence-like data into array format while preserving\nelement values and order.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn array(data: Vec<f64>) -> (result: Vec<f64>)\n    ensures\n        result.len() == data.len(),\n        forall|i: int| 0 <= i < data.len() ==> result[i] == data[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_creation_asanyarray", "vc-description": "numpy.asanyarray: Convert the input to an ndarray, but pass ndarray subclasses through.\n\nConverts the input to an ndarray, but passes ndarray subclasses through unchanged.\nIf the input is already an ndarray or a subclass of ndarray, it is returned as-is\nand no copy is performed. For other array-like inputs, it performs conversion.\n\nIn this Vector-based specification, we model this as an identity function that\npreserves the input vector unchanged, representing the common case where the\ninput is already an ndarray.\n\nSpecification: numpy.asanyarray returns the input vector unchanged when it's already an ndarray.\n\nPrecondition: True (no special preconditions)\nPostcondition: The result is identical to the input vector - no copy is made,\n               and each element remains unchanged.\n\nThis captures the key property of asanyarray: when given an ndarray (Vector in our case),\nit returns the same array without copying.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn asanyarray(a: Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> result[i] == a[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_creation_asarray", "vc-description": "numpy.asarray: Convert the input to an array.\n\nConverts various input types (lists, tuples, existing arrays, etc.) to an array.\nThe function creates a new array from the input data, preserving the element\norder and values. For our Vector-based specification, we model this as\nconverting a list of elements to a Vector.\n\nThis is a fundamental array creation function that ensures the output is\nalways a proper array format regardless of the input type.\n\nSpecification: numpy.asarray returns a vector containing the same elements\nas the input list, in the same order.\n\nPrecondition: The input list length matches the vector size parameter\nPostcondition: \n1. The result vector has the same length as the input list\n2. Each element in the result vector equals the corresponding element in the input list\n3. The ordering of elements is preserved", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn asarray(a: Vec<f32>) -> (result: Vec<f32>)\n    requires a.len() > 0,\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == a[i]", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_creation_ascontiguousarray", "vc-description": "Return a contiguous array (ndim >= 1) in memory (C order).\nThis function ensures the input array is contiguous in C order and guarantees\nminimum dimensionality of 1. For non-empty input, preserves all elements.\n\nSpecification: ascontiguousarray returns a contiguous array with same content,\nensuring minimum dimensionality of 1. For non-empty arrays, elements are preserved\nexactly. For empty arrays, returns a 1-dimensional array with 1 element.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn ascontiguousarray(a: Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() >= 1,\n        a.len() > 0 ==> result.len() == a.len(),\n        a.len() == 0 ==> result.len() == 1,\n        a.len() > 0 ==> forall|i: int| 0 <= i < a.len() ==> exists|j: int| 0 <= j < result.len() && result[j] == a[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_creation_asmatrix", "vc-description": "Interpret the input as a matrix. In our simplified model, this represents\na 1D vector as a matrix type. Since numpy.asmatrix doesn't make a copy\nif the input is already a matrix or ndarray, this function acts as an\nidentity operation with matrix type semantics.\n\nSpecification: asmatrix interprets input data as a matrix without copying.\n\nThe function preserves the original data structure and values while\nproviding matrix semantics. For our Vector-based implementation, this\nmeans the output vector has the same length and contains the same elements\nas the input vector.\n\nKey properties:\n1. No copying occurs - the result has the same elements as input\n2. The length is preserved  \n3. Element order is preserved\n4. All original values are maintained", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn asmatrix(data: Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() == data.len(),\n        forall|i: int| 0 <= i < data.len() ==> result[i] == data[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_creation_bmat", "vc-description": "Build a matrix from a 2x2 block structure using 4 input vectors.\nThis represents a simplified version of numpy.bmat for 2x2 block matrices.\nThe result is a flattened vector representing the block matrix in row-major order.\n\nMathematically, this constructs a 2x2 block matrix where each block is a 1×n vector:\n[ topLeft    | topRight    ]\n[ bottomLeft | bottomRight ]\n\nThe result is flattened as [topLeft | topRight | bottomLeft | bottomRight].\n\nSpecification: bmat constructs a 2x2 block matrix from four equal-sized vectors.\nThe result is a flattened vector where blocks are arranged as:\n[topLeft | topRight | bottomLeft | bottomRight]\nThis captures the essential behavior of numpy.bmat for block matrix construction.\n\nPrecondition: True (no special preconditions for basic block matrix construction)\nPostcondition: Each block is correctly placed in the flattened result", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn bmat(top_left: Vec<f32>, top_right: Vec<f32>, bottom_left: Vec<f32>, bottom_right: Vec<f32>) -> (result: Vec<f32>)\n    requires \n        top_left.len() == top_right.len(),\n        top_left.len() == bottom_left.len(),\n        top_left.len() == bottom_right.len(),\n    ensures\n        result.len() == 4 * top_left.len(),\n        forall|i: int| 0 <= i < top_left.len() ==> result[i] == top_left[i],\n        forall|i: int| 0 <= i < top_right.len() ==> result[i + top_left.len()] == top_right[i],\n        forall|i: int| 0 <= i < bottom_left.len() ==> result[i + 2 * top_left.len()] == bottom_left[i],\n        forall|i: int| 0 <= i < bottom_right.len() ==> result[i + 3 * top_left.len()] == bottom_right[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_creation_copy", "vc-description": "Return an array copy of the given object.\nThe copy has the same shape and values as the original array, \nbut occupies different memory locations.\n\nSpecification: copy returns a vector with identical values but independent memory.\nThe resulting vector has the same size and all elements equal to the original,\nensuring that the copy is element-wise equivalent to the original.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn copy<T: Copy>(a: &Vec<T>) -> (result: Vec<T>)\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> result[i] == a[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_creation_diagflat", "vc-description": "numpy.diagflat: Create a two-dimensional array with the flattened input as a diagonal.\n\nTakes an input vector (representing flattened data) and creates a square matrix\nwhere the input values appear along the k-th diagonal. The parameter k determines\nwhich diagonal to use: k=0 for main diagonal, k>0 for super-diagonals,\nand k<0 for sub-diagonals.\n\nFor simplicity, we focus on the main diagonal case (k=0) and return a 1D flattened\nrepresentation of the square matrix.\n\nSpecification: diagflat creates a square matrix with input values on the main diagonal.\n\nPrecondition: True (no special preconditions)\nPostcondition: The result is a flattened square matrix where:\n1. The input vector v appears along the main diagonal\n2. All other elements are zero\n3. The matrix has dimensions n × n (flattened to n² elements)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn diagflat(v: Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() == v.len() * v.len(),\n        forall|i: int| 0 <= i < v.len() ==> result[i * v.len() + i] == v[i],\n        forall|i: int, j: int| 0 <= i < v.len() && 0 <= j < v.len() && i != j ==> result[i * v.len() + j] == 0.0f32", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_creation_empty", "vc-description": "numpy.empty: Return a new array of given shape and type, without initializing entries.\n\nCreates a new vector of the specified length containing uninitialized (arbitrary) values.\nThis is a low-level function that allocates memory without setting initial values,\nmaking it potentially faster than other array creation functions.\n\nFor 1D arrays, this takes a size parameter n and returns a Vector Float n\nwith arbitrary values.\n\nSpecification: numpy.empty returns a vector of the specified size with arbitrary values.\n\nProperties:\n1. The returned vector has exactly n elements (guaranteed by type)\n2. Each element in the vector is a valid Float value\n3. The vector is well-formed - all indices are accessible\n4. No guarantees are made about the actual values - they are arbitrary/uninitialized\n\nMathematical properties:\n- Size property: The length of the result is exactly n\n- Accessibility property: All elements from index 0 to n-1 are accessible via get\n- Value existence: Each position contains some Float value (but we don't specify which)\n\nThis specification captures the key behavior of numpy.empty: it returns a properly\nsized array but makes no promises about the contents, which distinguishes it from\nfunctions like zeros() or ones() that guarantee specific initial values.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn empty(n: usize) -> (result: Vec<f32>)\n    ensures \n        result.len() == n,\n        forall|i: int| 0 <= i < n ==> exists|v: f32| result[i] == v", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_creation_empty_like", "vc-description": "numpy.empty_like: Return a new array with the same shape and type as a given array.\n\nCreates a new array with the same shape and type as the prototype array,\nbut with uninitialized (arbitrary) data. This is useful for creating\narrays that will be filled with values later, avoiding the overhead\nof initialization.\n\nThe returned array has the same dimensions as the prototype but does not\ncopy the values - the contents are undefined and may contain any values.\n\nSpecification: numpy.empty_like returns a vector with the same size as the prototype\nbut with uninitialized values.\n\nPrecondition: True (no special preconditions needed)\nPostcondition: \n1. The result has the same size as the prototype array\n2. The result vector is well-formed with proper indexing\n3. The result is independent of the prototype's values (shape invariant)\n\nMathematical Properties:\n- Size preservation: |result| = |prototype| = n\n- Index validity: all valid indices for prototype are valid for result\n- Type preservation: result has same element type as prototype\n\nNote: We cannot specify the actual values since they are uninitialized,\nbut we can specify structural and size properties that must hold.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_empty_like(prototype: &Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() == prototype.len(),\n        forall|i: int| 0 <= i < prototype.len() ==> 0 <= i < result.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_creation_eye", "vc-description": "numpy.eye: Return a 2-D array with ones on the diagonal and zeros elsewhere.\n\nReturns the identity matrix of size n x n. For simplicity, we implement \nthe square matrix case (N=M) with diagonal offset k=0.\n\nThis function creates an n x n matrix where all elements are zero except\nfor the main diagonal, which contains ones.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn eye(n: usize) -> (result: Vec<Vec<f32>>)\n    ensures\n        result.len() == n,\n        forall|i: int| 0 <= i < n ==> result[i].len() == n,\n        forall|i: int, j: int| 0 <= i < n && 0 <= j < n ==> \n            result[i][j] == if i == j { 1.0f32 } else { 0.0f32 },\n        forall|i: int, j: int| 0 <= i < n && 0 <= j < n ==> \n            result[i][j] == result[j][i],\n        forall|i: int| 0 <= i < n ==> exists|j: int| 0 <= j < n && \n            result[i][j] == 1.0f32 && forall|k: int| 0 <= k < n && result[i][k] == 1.0f32 ==> k == j,\n        forall|j: int| 0 <= j < n ==> exists|i: int| 0 <= i < n && \n            result[i][j] == 1.0f32 && forall|k: int| 0 <= k < n && result[k][j] == 1.0f32 ==> k == i,\n        forall|i: int, j: int| 0 <= i < n && 0 <= j < n && i != j ==> \n            result[i][j] == 0.0f32,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_creation_from_dlpack", "vc-description": "Create a NumPy array from an object implementing the DLPack protocol. This function allows for interoperability with other libraries that support the DLPack protocol.\n\n/* Abstract type representing a DLPack-compatible object */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\npub struct DLPackObject<T> {\n    pub data: Vec<T>,\n    pub has_dlpack: bool,\n    pub has_dlpack_device: bool,\n    pub device: String,\n}", "vc-helpers": "", "vc-spec": "fn from_dlpack<T>(x: &DLPackObject<T>, device: Option<&str>, copy: Option<bool>) -> (result: Vec<T>)\n    requires \n        x.has_dlpack && x.has_dlpack_device,\n        device.is_none() || device == Some(\"cpu\"),\n    ensures\n        result.len() == x.data.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == x.data[i],\n        copy == Some(true) ==> result@ != x.data@,\n        copy == Some(false) ==> result@ == x.data@,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_creation_frombuffer", "vc-description": "Interpret a buffer as a 1-dimensional array.\nTakes a buffer (represented as a Vector of bytes), the count of elements to read,\nand an offset (starting position in bytes) to create a Vector of the specified type.\nThis models numpy.frombuffer which interprets raw bytes as typed array elements.\n\nSpecification: frombuffer interprets raw bytes from a buffer as a typed array.\nThe function reads 'count' elements starting from 'offset' bytes into the buffer.\nThe result is a Vector containing the selected bytes in the same order\nas they appear in the buffer. Key properties:\n1. Buffer must have sufficient bytes for the requested elements\n2. Offset must be within buffer bounds when count > 0\n3. Elements are read sequentially from the buffer starting at offset\n4. The result preserves the sequential order of elements in the buffer\n5. Each output element corresponds to exactly one input buffer byte", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn frombuffer(buffer: &Vec<u8>, count: usize, offset: usize) -> (result: Vec<u8>)\n    requires \n        offset + count <= buffer.len(),\n        offset < buffer.len() || count == 0,\n    ensures\n        result.len() == count,\n        forall|i: int| 0 <= i < count ==> result[i] == buffer[offset + i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_creation_fromfile", "vc-description": "Construct a vector from data in a file. \n\nSpecification: fromfile reads data from a file into a vector\n\nBased on numpy.fromfile - Construct an array from data in a text or binary file.\n\nParameters:\n- file: File object or filename containing data\n- dtype: Data type of the returned array  \n- count: Number of items to read (-1 means all items)\n- sep: Separator between items for text files (empty means binary)\n- offset: The offset in bytes from file's current position\n- like: Reference object for array creation\n\nReturns an array of data from the file. Note that binary files generated are not platform independent.\n\n/* Abstract file representation for specification purposes */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\npub struct FileData {\n    pub content: Seq<f64>,\n    pub valid: bool,\n}", "vc-helpers": "", "vc-spec": "fn fromfile(n: usize, file: &FileData, count: i32, offset: usize) -> (result: Vec<f64>)\n    requires \n        file.valid == true,\n        count == (n as i32) || count == -1,\n        offset <= file.content.len(),\n        file.content.len() - offset >= n,\n    ensures \n        result.len() == n,\n        forall|i: int| 0 <= i < n ==> result[i] == file.content[offset + i],\n        n <= file.content.len() - offset,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_creation_fromfunction", "vc-description": "Construct a vector by executing a function over each coordinate index.\nFor 1D case, this creates a vector of length n where element i is f(i).\n\nSpecification: fromfunction creates a vector where each element is the result\nof applying the function to its index position.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn fromfunction(n: usize, f: spec_fn(usize) -> f32) -> (result: Vec<f32>)\n    ensures\n        result.len() == n,\n        forall|i: int| 0 <= i < n ==> result[i] == f(i as usize)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_creation_fromiter", "vc-description": "Create a new 1-dimensional array from an iterable object.\nTakes the first n elements from the iterable sequence and creates a Vector.\nThis models numpy.fromiter with explicit count parameter.\n\nSpecification: fromiter creates a Vector containing the first n elements \nfrom the iterable in order. The resulting Vector has exactly n elements,\nand each element at index i equals the i-th element from the iterable.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn fromiter<T: Copy>(n: usize, iter: spec_fn(usize) -> T) -> (result: Vec<T>)\n    ensures\n        result.len() == n,\n        forall|i: int| 0 <= i < n ==> result[i] == iter(i as usize)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_creation_fromstring", "vc-description": "A new 1-D array initialized from text data in a string\n\nSpecification: fromstring parses a string into a vector of floats using a separator", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn fromstring(input: Vec<char>, sep: Vec<char>) -> (result: Vec<f32>)\n    requires\n        sep.len() > 0,\n        input.len() > 0,\n    ensures\n        result.len() > 0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_creation_full", "vc-description": "numpy.full: Return a new array of given shape and type, filled with fill_value.\n\nCreates a new vector of size n where every element is set to the specified\nfill_value. This is the 1D version of numpy.full, focusing on the core\nfunctionality of creating uniform arrays.\n\nThe function creates a vector filled with identical values, which is useful\nfor initialization and creating constant arrays.\n\nSpecification: numpy.full returns a vector where every element equals fill_value.\n\nThis specification captures the complete mathematical behavior of numpy.full:\n\n1. **Sanity checks**:\n   - The result vector has exactly n elements (enforced by type)\n   - The function is deterministic (same inputs always produce same output)\n\n2. **Core property**: Every element in the result equals fill_value\n   - ∀ i : Fin n, result[i] = fill_value\n\n3. **Mathematical properties**:\n   - Uniformity: All elements are identical\n   - Idempotence of fill value: Filling with the same value multiple times yields the same result\n   - Independence from index: The value at any position doesn't depend on the position\n\n4. **Additional properties**:\n   - For n = 0, the result is an empty vector\n   - For n > 0, all elements are equal to each other\n   - The result is functionally equivalent to Vector.replicate n fill_value\n\n5. **Relationship properties**:\n   - full α n v is equivalent to creating an array and setting each element to v\n   - If two vectors are created with full using the same fill_value and size,\n     they are element-wise equal\n   - full preserves the fill_value exactly (no transformation or casting)\n\n/* Core property: every element equals fill_value */\n\n/* Uniformity property: all elements are equal to each other */\n\n/* First and last element property (when n > 0) */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn full<T>(n: usize, fill_value: T) -> (result: Vec<T>)\n    ensures \n        result.len() == n,\n\n        forall|i: int| 0 <= i < n ==> result[i] == fill_value,\n\n        forall|i: int, j: int| 0 <= i < n && 0 <= j < n ==> result[i] == result[j],\n\n        n > 0 ==> result[0] == fill_value,\n        n > 0 ==> result[(n-1) as int] == fill_value,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_creation_full_like", "vc-description": "numpy.full_like: Return a full array with the same shape and type as a given array.\n\nCreates a new array with the same shape as the input array `a`, where all\nelements are set to the specified `fill_value`. This is useful for creating\narrays of a specific constant value while preserving the shape of an existing\narray.\n\nThe actual type of fill_value will be cast to match the array's type,\nsimilar to numpy's behavior where 0.1 becomes 0 for integer arrays.\n\nSpecification: numpy.full_like returns a vector with the same shape as `a`\nwhere every element equals `fill_value`.\n\nPrecondition: True (no special preconditions needed)\nPostcondition: The result has the same length as `a` and all elements equal `fill_value`", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_full_like(a: Vec<f32>, fill_value: f32) -> (result: Vec<f32>)\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == fill_value,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_creation_geomspace", "vc-description": "Return numbers spaced evenly on a log scale (a geometric progression).\nEach output sample is a constant multiple of the previous one.\n\nSpecification: geomspace returns a geometric progression from start to stop.\n- The first element is always start\n- If endpoint is true and n > 1, the last element is stop\n- All elements form a geometric progression (constant ratio between consecutive elements)\n- Neither start nor stop can be zero", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn geomspace(start: f64, stop: f64, n: usize, endpoint: bool) -> (result: Vec<f64>)\n    requires \n        start != 0.0,\n        stop != 0.0,\n        n > 0,\n    ensures\n        result.len() == n,\n        n > 0 ==> result[0] == start,\n        (endpoint && n > 1) ==> result[(n - 1) as int] == stop,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_creation_identity", "vc-description": "Return the identity matrix of size n×n.\nThe identity matrix is a square matrix with ones on the main diagonal\nand zeros elsewhere.\n\nSpecification: identity returns an n×n matrix where:\n- diagonal elements (i,i) are 1.0\n- off-diagonal elements (i,j) where i≠j are 0.0", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn identity(n: usize) -> (result: Vec<Vec<f64>>)\n    ensures\n        result.len() == n,\n        forall|i: int| 0 <= i < n ==> result[i].len() == n,\n        forall|i: int, j: int| 0 <= i < n && 0 <= j < n ==>\n            result[i][j] == if i == j { 1.0 } else { 0.0 }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_creation_linspace", "vc-description": "numpy.linspace: Return evenly spaced numbers over a specified interval.\n\nReturns num evenly spaced samples, calculated over the interval [start, stop]\nwhen endpoint is true (default), or [start, stop) when endpoint is false.\n\nThis specification focuses on the most common use case where endpoint=true,\nreturning num samples that are evenly distributed from start to stop inclusive.\n\nSpecification: numpy.linspace returns a vector of evenly spaced values.\n\nWhen num > 0 and endpoint=true (default behavior):\n- The first element equals start\n- The last element equals stop (when num > 1)\n- Elements are evenly spaced with step = (stop - start) / (num - 1) when num > 1\n- When num = 1, the single element equals start\n\nMathematical properties:\n- For any valid index i, the element value is: start + i * step\n- The spacing between consecutive elements is constant (except when num = 1)\n- The sequence is monotonic (increasing if start < stop, decreasing if start > stop)\n- All elements lie within [min(start, stop), max(start, stop)]\n- Linear interpolation property: each element represents a linear interpolation between start and stop\n\nSanity checks:\n- Size of result vector equals num\n- When start = stop, all elements equal start\n- The function is symmetric: reversing start and stop reverses the sequence\n- Consecutive differences are constant for num > 2", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn linspace(start: f32, stop: f32, num: usize) -> (result: Vec<f32>)\n    requires num > 0,\n    ensures\n        result.len() == num,\n        result[0] == start,\n        (num == 1 ==> forall|i: int| 0 <= i < num ==> result[i] == start),\n        (num > 1 ==> result[num - 1] == stop)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_creation_meshgrid", "vc-description": "Return coordinate matrices from two coordinate vectors using 'xy' (Cartesian) indexing.\nFor inputs of length m and n, returns two matrices of shape (n, m) where:\n- The first matrix has x values repeated along rows\n- The second matrix has y values repeated along columns\n\nSpecification: meshgrid creates coordinate matrices where x values are repeated \nalong rows and y values are repeated along columns in 'xy' indexing mode", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn meshgrid(x: Vec<f32>, y: Vec<f32>) -> (result: (Vec<Vec<f32>>, Vec<Vec<f32>>))\n    requires \n        x.len() > 0,\n        y.len() > 0,\n    ensures\n        result.0.len() == y.len(),\n        result.1.len() == y.len(),\n        forall|i: int| 0 <= i < y.len() ==> result.0[i].len() == x.len(),\n        forall|i: int| 0 <= i < y.len() ==> result.1[i].len() == x.len(),\n        forall|i: int, j: int| 0 <= i < y.len() && 0 <= j < x.len() ==> result.0[i][j] == x[j],\n        forall|i: int, j: int| 0 <= i < y.len() && 0 <= j < x.len() ==> result.1[i][j] == y[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_creation_ogrid", "vc-description": "Create a 1D open grid from start to stop with n evenly spaced points.\nThis is a simplified version of ogrid that handles the common case of\ncreating a single evenly-spaced vector (like ogrid[start:stop:nj]).\n\nSpecification: ogrid creates n evenly spaced points from start to stop (inclusive).\nWhen n > 1, the spacing between consecutive points is (stop - start) / (n - 1).\nFor n = 1, the single point is at start.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn ogrid(start: f32, stop: f32, n: usize) -> (result: Vec<f32>)\n    requires n > 0,\n    ensures \n        result.len() == n,\n        (n == 1 ==> result[0] == start),\n        (n > 1 ==> result[0] == start),\n        (n > 1 ==> result[n - 1] == stop),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_creation_ones_like", "vc-description": "Return a vector of ones with the same length as the input vector.\nThis is the 1D version of numpy.ones_like which creates a new vector\nfilled with ones, having the same size as the input vector.\n\nSpecification: ones_like returns a vector where every element is 1,\nwith the same length as the input vector.\n\nMathematical properties:\n1. The result has the same length as the input (enforced by type system)\n2. Every element in the result is exactly 1\n3. The result is independent of the input values (only depends on shape)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn ones_like<T>(a: &Vec<T>) -> (result: Vec<i32>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == 1,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_creation_tri", "vc-description": "An array with ones at and below the given diagonal and zeros elsewhere.\n\nCreates a matrix of shape (N, M) where T[i,j] = 1 if j ≤ i + k, and 0 otherwise.\nThe parameter k controls the diagonal: k = 0 is the main diagonal,\nk < 0 is below it, and k > 0 is above it.\n\nSpecification: tri creates a lower triangular matrix with specified diagonal offset.\n\nThe resulting matrix has ones at and below the k-th diagonal, zeros elsewhere.\nFor each position (i, j):\n- If j ≤ i + k, then the value is 1.0\n- Otherwise, the value is 0.0\n\nThis captures the mathematical property that defines a generalized lower triangular matrix.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn tri(n: usize, m: usize, k: i32) -> (result: Vec<Vec<f64>>)\n    ensures\n        result.len() == n,\n        forall|i: int| 0 <= i < n ==> result[i].len() == m,\n        forall|i: int, j: int| 0 <= i < n && 0 <= j < m ==> \n            result[i][j] == if j <= i + k { 1.0 } else { 0.0 }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_creation_tril", "vc-description": "numpy.tril: Lower triangle of a matrix.\n\nReturns a copy of the input matrix with elements above the k-th diagonal zeroed.\n\n- k = 0 (default): zeros elements above the main diagonal\n- k < 0: zeros elements above the k-th diagonal below the main diagonal\n- k > 0: zeros elements above the k-th diagonal above the main diagonal\n\nFor a matrix element at position (i, j):\n- It is kept if i >= j - k\n- It is zeroed if i < j - k\n\nSpecification: tril returns a lower triangular matrix by zeroing elements above the k-th diagonal.\n\nMathematical Properties:\n1. Shape preservation: The output matrix has the same dimensions as the input\n2. Lower triangle preservation: Elements on or below the k-th diagonal are unchanged\n3. Upper triangle zeroing: Elements above the k-th diagonal are set to zero\n4. Diagonal selection: The k parameter controls which diagonal forms the boundary\n   - k = 0: main diagonal (default)\n   - k < 0: diagonal below the main diagonal\n   - k > 0: diagonal above the main diagonal\n5. Idempotency: Applying tril twice with the same k yields the same result\n\nElement-wise specification:\nFor each element at position (i, j):\n- If i ≥ j - k (on or below the k-th diagonal), the element is preserved\n- If i < j - k (above the k-th diagonal), the element is set to 0\n\nSpecial cases:\n- k ≥ cols: All elements are preserved (entire matrix is \"lower triangular\")\n- k ≤ -rows: All elements are zeroed (no elements are \"on or below\" such a diagonal)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn tril(m: Vec<Vec<f64>>, k: i32) -> (result: Vec<Vec<f64>>)\n    requires \n        m.len() > 0,\n        forall|i: int| 0 <= i < m.len() ==> #[trigger] m[i].len() == m[0].len(),\n    ensures\n        result.len() == m.len(),\n        forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i].len() == m[0].len(),\n        forall|i: int, j: int| \n            0 <= i < result.len() && 0 <= j < result[i].len() ==> \n            #[trigger] result[i][j] == if i >= j - k { m[i][j] } else { 0.0 },", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_creation_zeros", "vc-description": "Return a new vector of given size, filled with zeros\n\nSpecification: zeros returns a vector where all elements are zero\nThis comprehensive specification captures:\n1. All elements equal to zero (basic property)\n2. The result is the additive identity for vector addition\n3. The sum of all elements is zero (for numeric types)\n4. Scalar multiplication by any value preserves the zero property\n5. The dot product with any vector is zero\n6. The norm/magnitude is zero (for types with norm)\n7. Element-wise operations preserve zero structure", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn zeros(n: usize) -> (result: Vec<i32>)\n    ensures\n        result.len() == n,\n        forall|i: int| 0 <= i < n ==> result[i] == 0,\n        forall|v: Vec<i32>, i: int| \n            v.len() == n && 0 <= i < n ==> \n            result[i] + v[i] == v[i] && v[i] + result[i] == v[i],\n        forall|scalar: i32, i: int| \n            0 <= i < n ==> scalar * result[i] == 0,\n        forall|v: Vec<i32>, i: int| \n            v.len() == n && 0 <= i < n ==> result[i] * v[i] == 0,\n        n > 0 ==> result[0] == 0", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_creation_zeros_like", "vc-description": "Return a vector of zeros with the same length as the input vector.\nThis is the 1D version of numpy.zeros_like which creates a new vector\nfilled with zeros, having the same size as the input vector.\n\nSpecification: zeros_like returns a vector where every element is 0,\nwith the same length as the input vector.\n\nMathematical properties:\n1. The result has the same length as the input (enforced by type system)\n2. Every element in the result is exactly 0\n3. The result is independent of the input values (only depends on shape)\n4. The result is the additive identity for vector addition\n5. For numeric types, the sum of all elements is zero", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn zeros_like(a: &Vec<i32>) -> (result: Vec<i32>)\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == 0,\n        forall|v: &Vec<i32>| v.len() == result.len() ==> {\n            forall|i: int| 0 <= i < result.len() ==> \n                result[i] + v[i] == v[i] && v[i] + result[i] == v[i]\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_manipulation_append", "vc-description": "numpy.append: Append values to the end of an array.\n\nFor 1D arrays without axis specification, this function flattens both \narrays and concatenates them. The result is a 1D array containing all \nelements from arr followed by all elements from values.\n\nThis is a fundamental array manipulation operation that creates a new\narray by joining two arrays end-to-end. Unlike in-place operations,\nthis always returns a new array.\n\nSpecification: numpy.append creates a new array containing all elements\nfrom arr followed by all elements from values.\n\nPrecondition: True (no special preconditions for basic append)\nPostcondition: \n- The first n elements of the result come from arr\n- The next m elements come from values\n- The order of elements is preserved from both input arrays", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_append(arr: Vec<f32>, values: Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() == arr.len() + values.len(),\n        forall|i: int| 0 <= i < arr.len() ==> result[i] == arr[i],\n        forall|j: int| 0 <= j < values.len() ==> result[arr.len() + j] == values[j],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_manipulation_atleast_1d", "vc-description": "numpy.atleast_1d: Convert inputs to arrays with at least one dimension.\n\nThis function ensures that the input has at least one dimension.\n- Scalar inputs are converted to 1-dimensional arrays with a single element\n- Higher-dimensional inputs (vectors) are preserved unchanged\n\nFor the Vector-based implementation, we provide a version that takes\na vector and returns it unchanged, since Vectors already have at least\none dimension by construction.\n\nSpecification: atleast_1d returns the input vector unchanged.\n\nSince Vectors in Lean already have at least one dimension by their type,\nthis function acts as an identity function for vectors.\n\nPrecondition: True (no special preconditions)\nPostcondition: The result is identical to the input vector", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn atleast_1d(arr: Vec<f64>) -> (result: Vec<f64>)\n    ensures\n        result == arr,\n        forall|i: int| 0 <= i < arr.len() ==> result[i] == arr[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_manipulation_atleast_2d", "vc-description": "numpy.atleast_2d: View inputs as arrays with at least two dimensions.\n\nFor a 1D vector input, this function converts it to a 2D array (matrix)\nwith shape (1, n), where the input becomes the single row of the matrix.\n\nThis specification focuses on the 1D to 2D case, which is the most common\nuse case for ensuring arrays have at least 2 dimensions.\n\nSpecification: atleast_2d converts a 1D vector to a 2D matrix with one row.\n\nThis specification includes:\n1. Sanity check: The result has exactly 1 row\n2. Shape property: The result's shape is (1, n) where n is the input length\n3. Value preservation: All elements from the input are preserved in order\n4. Mathematical property: The operation is essentially a row vector representation\n\nPrecondition: True (no special preconditions)\nPostcondition: \n- The result is a matrix with 1 row and n columns\n- The single row contains all elements from the input vector in the same order\n- The transformation preserves all numerical values exactly", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn atleast_2d(arr: Vec<f32>) -> (result: Vec<Vec<f32>>)\n    ensures \n        result.len() == 1,\n        exists|row: Vec<f32>| result[0] == row && \n        row.len() == arr.len() &&\n        forall|i: int| 0 <= i < arr.len() ==> row[i] == arr[i]", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_manipulation_atleast_3d", "vc-description": "numpy.atleast_3d: View a 1D vector as a 3D array with shape (1, n, 1).\n\nThis is a specialization of numpy.atleast_3d for 1D input.\nThe function reshapes a 1D array of shape (n,) into a 3D array \nof shape (1, n, 1) while preserving all elements.\n\nSpecification: atleast_3d transforms a 1D vector into a 3D array where:\n- The output has shape (1, n, 1)\n- Each element arr[i] is accessible at position [0][i][0] in the result\n- All elements are preserved without modification\n- The transformation is injective (different inputs produce different outputs)\n\nMathematical properties:\n1. Element preservation: Every element from the input appears exactly once in the output\n2. Shape expansion: A 1D shape (n,) becomes 3D shape (1, n, 1)\n3. Order preservation: Elements maintain their relative ordering\n4. The output contains exactly n elements total", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn atleast_3d(arr: Vec<f32>) -> (result: Vec<Vec<Vec<f32>>>)\n    ensures \n        result.len() == 1,\n        forall|j: int| 0 <= j < 1 ==> result[j].len() == arr.len(),\n        forall|j: int, k: int| 0 <= j < 1 && 0 <= k < arr.len() ==> result[j][k].len() == 1,\n        forall|i: int| 0 <= i < arr.len() ==> {\n            let outer = &result[0];\n            let middle = &outer[i];\n            let value = middle[0];\n            value == arr[i]\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_manipulation_block", "vc-description": "Assemble a 2D matrix from a 2x2 block structure.\nThis is a simplified version focusing on the common case of assembling \na matrix from four blocks arranged in a 2x2 pattern.\n\nSpecification: block assembles a matrix from four submatrices in a 2x2 pattern.\nThe result has dimensions (r1 + r2) × (c1 + c2) where:\n- Top-left block occupies rows [0, r1) and columns [0, c1)\n- Top-right block occupies rows [0, r1) and columns [c1, c1 + c2)\n- Bottom-left block occupies rows [r1, r1 + r2) and columns [0, c1)\n- Bottom-right block occupies rows [r1, r1 + r2) and columns [c1, c1 + c2)\n\n/* Top-left block elements */\n\n/* Top-right block elements */\n\n/* Bottom-left block elements */\n\n/* Bottom-right block elements */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn block(\n    top_left: Vec<Vec<f32>>,\n    top_right: Vec<Vec<f32>>,\n    bottom_left: Vec<Vec<f32>>,\n    bottom_right: Vec<Vec<f32>>\n) -> (result: Vec<Vec<f32>>)\n    requires\n        top_left.len() > 0,\n        top_right.len() > 0,\n        bottom_left.len() > 0,\n        bottom_right.len() > 0,\n        top_left.len() == top_right.len(),\n        bottom_left.len() == bottom_right.len(),\n        top_left[0].len() == bottom_left[0].len(),\n        top_right[0].len() == bottom_right[0].len(),\n        forall|i: int| 0 <= i < top_left.len() ==> top_left[i].len() == top_left[0].len(),\n        forall|i: int| 0 <= i < top_right.len() ==> top_right[i].len() == top_right[0].len(),\n        forall|i: int| 0 <= i < bottom_left.len() ==> bottom_left[i].len() == bottom_left[0].len(),\n        forall|i: int| 0 <= i < bottom_right.len() ==> bottom_right[i].len() == bottom_right[0].len(),\n    ensures\n        result.len() == top_left.len() + bottom_left.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == top_left[0].len() + top_right[0].len(),\n\n        forall|i: int, j: int| \n            0 <= i < top_left.len() && 0 <= j < top_left[0].len() ==> \n            result[i][j] == top_left[i][j],\n\n        forall|i: int, j: int|\n            0 <= i < top_right.len() && 0 <= j < top_right[0].len() ==>\n            result[i][top_left[0].len() + j] == top_right[i][j],\n\n        forall|i: int, j: int|\n            0 <= i < bottom_left.len() && 0 <= j < bottom_left[0].len() ==>\n            result[top_left.len() + i][j] == bottom_left[i][j],\n\n        forall|i: int, j: int|\n            0 <= i < bottom_right.len() && 0 <= j < bottom_right[0].len() ==>\n            result[top_left.len() + i][top_left[0].len() + j] == bottom_right[i][j],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_manipulation_broadcast", "vc-description": "numpy.broadcast: Produce an object that mimics broadcasting between two vectors.\n\nThis simplified version handles broadcasting between a column vector (m × 1)\nand a row vector (1 × n), producing an object that represents the m × n\nbroadcast result.\n\nThe broadcast object allows iteration over all element pairs that would\nresult from the broadcasting operation.\n\nSpecification: broadcast creates an object that correctly pairs elements\naccording to NumPy broadcasting rules.\n\nFor a column vector x of shape (m, 1) and row vector y of shape (1, n),\nthe broadcast object has shape (m, n) and element (i, j) is the pair (x[i], y[j]).\n\nPreconditions: \n- m > 0 (x is non-empty)\n- n > 0 (y is non-empty)\n\nPostconditions:\n- The resulting shape is (m, n)\n- Element at position (i, j) is the pair (x[i], y[j])\n\n/* Structure representing a broadcast object for two vectors.\n\n   A broadcast object encapsulates the result of broadcasting two vectors\n   against each other. It produces pairs of elements following NumPy's\n   broadcasting rules. */\n\n/* The data from the first vector */\n\n/* The data from the second vector */\n\n/* The resulting shape after broadcasting */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nstruct BroadcastObject {\n\n    x_data: Vec<f32>,\n\n    y_data: Vec<f32>,\n\n    shape: (usize, usize),\n}\n\nimpl BroadcastObject {\n    spec fn well_formed(&self) -> bool {\n        self.shape.0 == self.x_data.len() &&\n        self.shape.1 == self.y_data.len()\n    }\n\n    spec fn get_element(&self, i: int, j: int) -> (f32, f32)\n        recommends \n            self.well_formed(),\n            0 <= i < self.shape.0,\n            0 <= j < self.shape.1,\n    {\n        (self.x_data[i], self.y_data[j])\n    }\n}", "vc-helpers": "", "vc-spec": "fn broadcast(x: Vec<f32>, y: Vec<f32>) -> (result: BroadcastObject)\n    requires \n        x.len() > 0,\n        y.len() > 0,\n    ensures\n        result.well_formed(),\n        result.shape == (x.len(), y.len()),\n        forall|i: int, j: int| \n            0 <= i < x.len() && 0 <= j < y.len() ==> \n            result.get_element(i, j) == (x[i], y[j])", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_manipulation_broadcast_to", "vc-description": "Broadcast a 1D vector to a 2D matrix by repeating it along rows.\nThis implements the most common broadcasting pattern: (n,) -> (m, n)\n\nSpecification: broadcast_to creates a 2D matrix where each row is a copy of the input vector.\n\nMathematical properties:\n1. Shape property: The result has shape (m, n) where n is the original vector length\n2. Value property: Each row in the result equals the original vector\n3. Broadcasting rule: A 1D array of shape (n,) can be broadcast to (m, n) by repeating\n4. Row consistency: All rows in the result are identical to the input vector\n5. Element preservation: Each element in the input appears m times in each column\n\nSanity checks:\n- The output shape is exactly (m, n)\n- Every row contains the same values as the input vector\n- Broadcasting preserves element values without modification\n- The result behaves as if v was copied m times along a new axis\n\nExample behavior:\n- Input: [1, 2, 3] with target shape (2, 3)\n- Output: [[1, 2, 3], [1, 2, 3]]\n\nAdditional properties:\n- Memory efficiency: In NumPy, this creates a view, not a copy\n- Column-wise view: Column j contains m copies of v[j]\n- Broadcasting compatibility: The result can be used in element-wise operations with other (m, n) arrays\n\nMathematical formulation:\n- For input vector v ∈ ℝⁿ and target shape (m, n)\n- Output matrix M ∈ ℝᵐˣⁿ where M[i,j] = v[j] for all i ∈ {0,...,m-1}, j ∈ {0,...,n-1}\n\n/* Primary property: each element (i,j) equals v[j] */\n\n/* Row identity: each row is exactly the input vector */\n\n/* Column uniformity: each column contains a single repeated value */\n\n/* Value preservation: no new values are introduced */\n\n/* Broadcast invariant: the operation is idempotent on rows */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn broadcast_to(v: Vec<f32>, m: usize) -> (result: Vec<Vec<f32>>)\n    requires v.len() > 0,\n    ensures\n        result.len() == m,\n\n        forall|i: int, j: int| 0 <= i < m && 0 <= j < v.len() ==> result[i][j] == v[j],\n\n        forall|i: int| 0 <= i < m ==> result[i]@ == v@,\n\n        forall|j: int, i1: int, i2: int| 0 <= j < v.len() && 0 <= i1 < m && 0 <= i2 < m ==> result[i1][j] == result[i2][j],\n\n        forall|i: int, j: int| 0 <= i < m && 0 <= j < v.len() ==> exists|k: int| 0 <= k < v.len() && result[i][j] == v[k] && k == j,\n\n        forall|i1: int, i2: int| 0 <= i1 < m && 0 <= i2 < m ==> result[i1]@ == result[i2]@", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_manipulation_column_stack", "vc-description": "numpy.column_stack: Stack 1-D arrays as columns into a 2-D array.\n\nTakes a sequence of 1-D arrays and stacks them as columns to make a \nsingle 2-D array. All input arrays must have the same length (number \nof rows in the output).\n\nThe result is represented as a flattened vector in column-major order,\nwhere elements from the same column are contiguous. For a result with\n'rows' rows and 'cols' columns, element at position (i, j) is stored\nat index j * rows + i in the flattened vector.\n\nThis is a fundamental array manipulation operation that combines multiple\n1D arrays into a single 2D structure, useful for constructing matrices\nfrom column vectors.\n\nSpecification: column_stack creates a 2D array (as flattened vector) where\neach input array becomes a column.\n\nPrecondition: cols > 0 (at least one input array)\nPostcondition: \n- The result contains all elements from the input arrays\n- Elements are arranged in column-major order\n- The j-th column of the result contains all elements from arrays[j]\n- For 0 ≤ i < rows and 0 ≤ j < cols, the element at position (i,j)\n  in the 2D view equals arrays[j][i] and is stored at index j*rows + i", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn column_stack(arrays: Vec<Vec<f32>>) -> (result: Vec<f32>)\n    requires\n        arrays.len() > 0,\n        forall|i: int| 0 <= i < arrays.len() ==> arrays[i].len() == arrays[0].len(),\n    ensures\n        result.len() == arrays.len() * arrays[0].len(),\n        forall|i: int, j: int| \n            0 <= i < arrays[0].len() && 0 <= j < arrays.len() ==>\n            result[j * arrays[0].len() + i] == arrays[j][i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_manipulation_concatenate", "vc-description": "numpy.concatenate: Join a sequence of arrays along an existing axis.\n\nFor 1D arrays, concatenates two vectors end-to-end to produce a single \nvector containing all elements from both input vectors in order.\n\nThe result vector has size n + m where n and m are the sizes of the \ninput vectors.\n\nSpecification: concatenate joins two vectors preserving all elements in order.\n\nPrecondition: True (no special preconditions for concatenation)\nPostcondition: \n- First n elements of result are from vector a\n- Next m elements of result are from vector b  \n- Result has size n + m", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn concatenate(a: Vec<f32>, b: Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() == a.len() + b.len(),\n        forall|i: int| 0 <= i < a.len() ==> result[i] == a[i],\n        forall|j: int| 0 <= j < b.len() ==> result[a.len() + j] == b[j],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_manipulation_copyto", "vc-description": "Copies values from one vector to another, with optional conditional copying using a boolean mask.\n\nSpecification: copyto copies elements from src to dst where the mask is true, \npreserving dst elements where the mask is false.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn copyto<T: Copy>(dst: Vec<T>, src: Vec<T>, mask: Vec<bool>) -> (result: Vec<T>)\n    requires \n        dst.len() == src.len(),\n        dst.len() == mask.len(),\n    ensures \n        result.len() == dst.len(),\n        forall|i: int| 0 <= i < result.len() ==> \n            result[i] == if mask[i] { src[i] } else { dst[i] }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_manipulation_delete", "vc-description": "numpy.delete: Return a new array with sub-arrays along an axis deleted.\n\nFor a one dimensional array, this returns those entries not returned by\narr[obj]. The function removes elements at the specified index and\nreturns a new array with the remaining elements.\n\nThis specification handles the 1D case where we delete a single element\nat a specified index from a vector.\n\nSpecification: numpy.delete removes the element at the specified index and returns\na new vector containing all other elements in their original order.\n\nThe specification ensures:\n1. The result has size n (one less than the input)\n2. Elements before the deleted index maintain their positions\n3. Elements after the deleted index are shifted left by one position\n\nMathematical properties:\n- Order preservation: Elements maintain their relative order\n- Deletion correctness: The element at the specified index is removed\n- Shift property: Elements after the deleted index have their indices decreased by 1\n\nSanity checks:\n- The result size is exactly one less than the input size\n- No elements are duplicated or lost (except the deleted one)\n- The deleted element does not appear in the result\n\nPrecondition: The array must have at least one element (enforced by type)\n\nPostcondition:\n- For indices i < index: result[i] = arr[i]\n- For indices i ≥ index: result[i] = arr[i+1]\n- The element arr[index] does not appear in the result (unless duplicated elsewhere)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn delete(arr: Vec<f32>, index: usize) -> (result: Vec<f32>)\n    requires \n        arr.len() > 0,\n        index < arr.len(),\n    ensures \n        result.len() == arr.len() - 1,\n        forall|i: int| 0 <= i < index ==> result[i] == arr[i],\n        forall|i: int| index <= i < result.len() ==> result[i] == arr[i + 1],\n        forall|i: int| 0 <= i < arr.len() && i != index ==> \n            exists|j: int| 0 <= j < result.len() && result[j] == arr[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_manipulation_dsplit", "vc-description": "Split a 1D vector into equal sections (simplified version of dsplit).\n\nSince dsplit operates on the 3rd axis of 3D arrays, this simplified version\ndemonstrates the splitting behavior on a 1D vector. The actual dsplit would\nwork on nested Vector structures representing 3D arrays.\n\nThis function divides a vector into k equal sections, where k must divide\nthe length of the vector evenly. Returns a list of vectors.\n\nSpecification: dsplit divides a vector into equal sections.\n\nPrecondition: sections = k and k > 0 (array size must be k * n)\nPostcondition: Returns k sub-vectors, each of size n. The i-th sub-vector\n               contains elements from positions i*n to (i+1)*n-1 of the \n               original array.\n\nMathematical property: Concatenating all sub-vectors in order reconstructs\n                      the original vector.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn dsplit(arr: Vec<f32>, sections: usize) -> (result: Vec<Vec<f32>>)\n    requires \n        sections > 0,\n        arr.len() % sections == 0,\n    ensures\n        result.len() == sections,\n        forall|i: int| 0 <= i < sections ==> result[i].len() == arr.len() / sections,\n        forall|i: int, j: int| 0 <= i < sections && 0 <= j < (arr.len() / sections) ==> \n            result[i][j] == arr[i * (arr.len() / sections) + j],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_manipulation_dstack", "vc-description": "numpy.dstack: Stack arrays in sequence depth wise (along third axis).\n\nFor a sequence of 1D arrays (vectors), this function stacks them along a new third axis,\ncreating a 3D array. Each input vector becomes a \"slice\" in the depth dimension.\n\nFor 1D inputs of length n, the output shape is (1, n, k) where k is the number of arrays.\nThis is because 1D arrays are first reshaped to (1, n) then stacked along axis 2.\n\nThe result is always at least 3-dimensional.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_dstack(arrays: Vec<Vec<f32>>) -> (result: Vec<Vec<Vec<f32>>>)\n    requires \n        arrays.len() > 0,\n        forall|i: int| 0 <= i < arrays.len() ==> \n            forall|j: int| 0 <= j < arrays.len() ==> arrays[i].len() == arrays[j].len(),\n    ensures\n        result.len() == 1,\n        result[0].len() == if arrays.len() > 0 { arrays[0].len() } else { 0 },\n        forall|i: int| 0 <= i < result[0].len() ==> result[0][i].len() == arrays.len(),\n        forall|i: int, j: int| \n            0 <= i < result[0].len() && 0 <= j < arrays.len() ==>\n            result[0][i][j] == arrays[j][i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_manipulation_expand_dims", "vc-description": "Expand the shape of a vector by inserting a new axis at the specified position.\naxis=0 creates a row vector (1×n), axis=1 creates a column vector (n×1).\n\nSpecification: expand_dims preserves all elements and adds a new dimension at the specified axis.\nThe function creates a view with increased dimensions while maintaining element order and values.\n\n/* Represents the result of expanding dimensions of a vector.\n   For axis=0, we get a 1×n matrix (row vector).\n   For axis=1, we get an n×1 matrix (column vector). */\n\n// axis=0: shape (1, n)\n\n// axis=1: shape (n, 1)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\npub enum ExpandedVector<T> {\n    RowVector(Vec<T>),\n    ColumnVector(Vec<T>),\n}", "vc-helpers": "", "vc-spec": "fn expand_dims<T>(a: Vec<T>, axis: usize) -> (result: ExpandedVector<T>)\n    requires axis <= 1,\n    ensures match result {\n        ExpandedVector::RowVector(v) => axis == 0 && v@ == a@,\n        ExpandedVector::ColumnVector(v) => axis == 1 && v@ == a@,\n    }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_manipulation_flip", "vc-description": "Reverses the order of elements in a vector (1D case of numpy.flip).\n\nThis function reverses the order of all elements in the input vector.\nFor a vector [a, b, c, d], it returns [d, c, b, a].\n\nIn the general n-dimensional case, numpy.flip can reverse along specific axes,\nbut this specification focuses on the 1D case where all elements are reversed.\n\nSpecification: numpy_flip reverses the order of elements in the vector.\n\nMathematical properties:\n1. Element mapping: The element at position i in the result equals the element \n   at position (n-1-i) in the input\n2. Involution property: Applying numpy_flip twice returns the original vector\n3. Size preservation: The output has the same size as the input (enforced by types)\n\nSanity checks:\n- For n=0 (empty vector), returns empty vector\n- For n=1 (single element), returns the same vector\n- For n>1, first element becomes last, last becomes first", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_flip(m: Vec<f32>) -> (result: Vec<f32>)\n    ensures \n        result.len() == m.len(),\n        forall|i: int| 0 <= i < m.len() ==> result[i] == m[m.len() - 1 - i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_manipulation_fliplr", "vc-description": "Reverses the order of columns in a 2D matrix (left/right flip).\nFor a matrix with shape (rows × cols), this operation reverses the order \nof elements along each row, effectively flipping the matrix horizontally.\n\nSpecification: fliplr reverses the column order in each row of the matrix.\nThe element at position (i, j) in the input matrix appears at position \n(i, cols-1-j) in the output matrix. This captures the mathematical property\nthat columns are reversed while rows remain in the same order.\n\nSanity checks:\n1. The output has the same dimensions as the input (enforced by type)\n2. Each row contains the same elements, just in reversed order\n3. For matrices with odd number of columns, the middle column stays in place\n\nMathematical properties:\n1. Element mapping: For all valid indices i and j, there exists a corresponding\n   index j' such that output[i,j] = input[i,j'] where j' = cols-1-j\n2. Row preservation: Each row contains exactly the same elements as the input\n3. Column reversal: The first column becomes the last, second becomes second-to-last, etc.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn fliplr(m: Vec<Vec<f32>>) -> (result: Vec<Vec<f32>>)\n    requires \n        m.len() > 0,\n        forall|i: int| 0 <= i < m.len() ==> m[i].len() > 0,\n        forall|i: int, j: int| 0 <= i < m.len() && 0 <= j < m.len() ==> m[i].len() == m[j].len(),\n    ensures\n        result.len() == m.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == m[i].len(),\n        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result[i].len() ==>\n            exists|k: int| 0 <= k < m[i].len() && \n                           result[i][j] == m[i][k] && \n                           j + k == (m[i].len() - 1) as int,\n        forall|i: int, x: f32| 0 <= i < result.len() ==>\n            ((exists|j: int| 0 <= j < m[i].len() && m[i][j] == x) <==> \n             (exists|j: int| 0 <= j < result[i].len() && result[i][j] == x)),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_manipulation_flipud", "vc-description": "numpy.flipud: Reverse the order of elements along axis 0 (up/down).\n\nFor a 1D array, this reverses the entire array.\nFor 2D arrays, this reverses the order of rows while preserving \nthe elements within each row.\n\nReturns a view of the input array with elements reversed along axis 0.\n\nSpecification: flipud reverses the order of elements in the vector.\n\nPrecondition: True (no special preconditions)\nPostcondition: For all indices i, result[i] = m[n-1-i]\n\nThis specification captures both the sanity check (result has same size)\nand the mathematical property (elements are reversed).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn flipud(m: Vec<f32>) -> (result: Vec<f32>)\n    ensures \n        result.len() == m.len(),\n        forall|i: int| 0 <= i < m.len() ==> result[i] == m[m.len() - 1 - i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_manipulation_hsplit", "vc-description": "Split an array into multiple sub-arrays horizontally (column-wise).\n\nSplit a 1D array into multiple sub-arrays horizontally.\nFor simplicity, we focus on the 1D case where the array is split into \nk equal parts. In numpy, hsplit on 1D arrays is equivalent to split with axis=0.\n\nSpecification: hsplit divides a 1D array into k equal sub-arrays.\nEach sub-array has n/k elements. The i-th sub-array contains elements \nfrom index i*(n/k) to (i+1)*(n/k)-1 of the original array.\n\nMathematical properties:\n1. The concatenation of all sub-arrays equals the original array\n2. Each sub-array has exactly n/k elements\n3. Elements are distributed in order without overlapping", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hsplit(arr: Vec<f32>, k: usize) -> (result: Vec<Vec<f32>>)\n    requires \n        k > 0,\n        arr.len() % k == 0,\n    ensures\n        result.len() == k,\n        forall|part_idx: int| 0 <= part_idx < k ==> result[part_idx].len() == arr.len() / k,\n        forall|part_idx: int, elem_idx: int| \n            0 <= part_idx < k && 0 <= elem_idx < arr.len() / k ==>\n            result[part_idx][elem_idx] == arr[part_idx * (arr.len() / k) + elem_idx],\n        forall|i: int| 0 <= i < arr.len() ==>\n            exists|p: int, e: int| \n                0 <= p < k && 0 <= e < arr.len() / k &&\n                i == p * (arr.len() / k) + e &&\n                arr[i] == result[p][e]", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_manipulation_hstack", "vc-description": "numpy.hstack: Stack arrays in sequence horizontally (column wise).\n\nFor 1D arrays, hstack stacks arrays horizontally by concatenating them\nalong the first axis. This is equivalent to concatenation for 1D arrays.\n\nThis version handles stacking two 1D arrays. The general version would\nhandle a sequence of arrays (tup parameter in NumPy).\n\nNote: For higher dimensional arrays, hstack would concatenate along the\nsecond axis, but this specification focuses on the 1D case.\n\nSpecification: numpy.hstack concatenates 1D arrays horizontally.\n\nFor 1D arrays, horizontal stacking means concatenating them end-to-end,\nwhich is the same behavior as numpy.concatenate.\n\nPrecondition: True (no special preconditions for 1D concatenation)\n\nPostcondition: \n- The result has size n + m\n- First n elements come from array a\n- Next m elements come from array b\n- The order of elements is preserved from both input arrays", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hstack(a: Vec<f32>, b: Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() == a.len() + b.len(),\n        forall|i: int| 0 <= i < a.len() ==> result[i] == a[i],\n        forall|j: int| 0 <= j < b.len() ==> result[a.len() + j] == b[j]", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_manipulation_insert", "vc-description": "numpy.insert: Insert values along the given axis before the given indices.\n\nCreates a new vector with values inserted at specified positions. For the 1D case,\nvalues are inserted before the given index position, shifting subsequent elements.\n\nWhen inserting a single value at position i into a vector of length n,\nthe result has length n+1 where:\n- Elements before position i remain unchanged\n- The new value is at position i\n- Elements from position i onward are shifted by one\n\nThis specification focuses on single value insertion. The actual NumPy function\nsupports multiple insertions and various index specifications, but for formal\nverification we start with the simplest case.\n\nSpecification: numpy.insert creates a new vector with the value inserted at the specified index.\n\nPrecondition: The index is valid (enforced by type system via Fin (n + 1))\n\nPostcondition: \n1. **Preservation**: Elements before the insertion point are preserved at their original indices\n2. **Insertion**: The new value is placed exactly at the specified index\n3. **Shifting**: Elements at or after the insertion point are shifted right by one position\n4. **Size**: The result has exactly one more element than the input\n\nMathematical properties:\n- For all i < idx: result[i] = arr[i]\n- result[idx] = value\n- For all i > idx: result[i] = arr[i-1]\n\nAdditional properties (sanity checks):\n- The operation is deterministic (same inputs produce same output)\n- The operation preserves the relative order of existing elements\n- No elements from the original array are lost or duplicated\n\n/* Elements before insertion point are preserved */\n\n/* The new value is at the specified index */\n\n/* Elements after insertion point are shifted */\n\n/* Sanity check: all original elements are preserved */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_insert<T>(arr: Vec<T>, idx: usize, value: T) -> (result: Vec<T>)\n    requires idx <= arr.len(),\n    ensures \n        result.len() == arr.len() + 1,\n\n        forall|i: int| 0 <= i < idx ==> result[i] == arr[i],\n\n        result[idx as int] == value,\n\n        forall|i: int| (idx as int) < i < result.len() ==> result[i] == arr[i - 1],\n\n        forall|j: int| 0 <= j < arr.len() ==> \n            (j < idx && result[j] == arr[j]) || \n            (j >= idx && result[j + 1] == arr[j])", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_manipulation_matrix_transpose", "vc-description": "Transposes a matrix by swapping rows and columns.\nFor a matrix with shape (m, n), returns a matrix with shape (n, m)\nwhere result[i, j] = input[j, i]\n\nSpecification: matrix_transpose swaps rows and columns, producing a transposed matrix\nwhere the element at position (i, j) in the result equals the element at position (j, i)\nin the input. The result has dimensions swapped: an m×n matrix becomes n×m.\n\n/* Dimension check: result is n×m when input is m×n */\n\n/* Transpose property: result[i][j] = mat[j][i] */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn matrix_transpose(mat: &Vec<Vec<f32>>) -> (result: Vec<Vec<f32>>)\n    requires \n        mat.len() > 0,\n        forall|i: int| 0 <= i < mat.len() ==> mat[i].len() == mat[0].len(),\n    ensures\n\n        result.len() == mat[0].len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == mat.len(),\n\n        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result[i].len() ==> \n            result[i][j] == mat[j][i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_manipulation_ndim", "vc-description": "numpy.ndim: Return the number of dimensions of an array.\n\nIn our Vector-based framework, vectors are always 1-dimensional.\nThis function returns 1 for any vector input, representing the fact\nthat Vector T n is a 1D array with n elements.\n\nNote: In NumPy, scalars are 0-dimensional, but in our framework,\nwe represent them as Vector T 1, so this always returns 1.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn ndim<T>(a: &Vec<T>) -> (result: usize)\n    ensures result == 1", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_manipulation_ravel", "vc-description": "numpy.ravel: Return a contiguous flattened array.\n\nFor 1D arrays, ravel returns the input array unchanged since it's already\nflat. This reflects numpy's behavior where raveling a 1D array has no effect.\n\nFor multi-dimensional arrays (not covered here), ravel would flatten them\ninto a 1D array following the specified order ('C' for row-major, 'F' for\ncolumn-major, etc.).\n\nSpecification: numpy.ravel returns the input vector unchanged for 1D arrays.\n\nPrecondition: True (no special preconditions for 1D ravel)\nPostcondition: The result is identical to the input vector, maintaining\n               all elements in their original order", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn ravel(a: Vec<f32>) -> (result: Vec<f32>)\n    ensures result@ == a@", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_manipulation_repeat", "vc-description": "Repeat elements of a vector a specified number of times.\nEach element is repeated consecutively.\n\nSpecification: repeat creates a vector where each element from the input \nappears consecutively 'repeats' times. The resulting vector has size n * repeats.\n\nFor a vector [a₀, a₁, ..., aₙ₋₁] and repeats = r, the result is:\n[a₀, a₀, ..., a₀, a₁, a₁, ..., a₁, ..., aₙ₋₁, aₙ₋₁, ..., aₙ₋₁]\n \\___r times___/  \\___r times___/       \\______r times______/\n\nMathematical properties:\n1. Each element appears exactly 'repeats' times consecutively\n2. The total size is n * repeats\n3. Element at index i comes from input element at index ⌊i/repeats⌋\n4. Elements are grouped: positions [k*repeats, (k+1)*repeats) contain a[k]", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn repeat<T: Copy>(a: Vec<T>, repeats: usize) -> (result: Vec<T>)\n    requires repeats > 0,\n    ensures\n        result.len() == a.len() * repeats,\n        forall|i: int| 0 <= i < result.len() ==> {\n            let k = i / (repeats as int);\n            0 <= k < a.len() && result[i] == a[k]\n        },\n        forall|k: int| 0 <= k < a.len() ==> forall|j: int| 0 <= j < repeats ==> {\n            let idx = k * (repeats as int) + j;\n            0 <= idx < result.len() && result[idx] == a[k]\n        },", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_manipulation_reshape", "vc-description": "Gives a new shape to an array without changing its data.\n\nThis implementation focuses on the most common case: reshaping a 1D array\nto another 1D array with the same total number of elements. The elements\nare preserved in the same linear order (C-order).\n\nFor simplicity, this specification handles only 1D to 1D reshaping where\nthe sizes are explicitly equal. More complex reshaping operations (like\nmultidimensional arrays or -1 inference) would require additional machinery.\n\nSpecification: reshape preserves all elements in their linear order.\n\nThe reshape operation creates a new vector with a different size parameter\nbut maintains the same elements in the same order. This is the fundamental\nproperty of reshape - it's purely a \"view\" operation that doesn't modify data.\n\nMathematical properties:\n1. Size preservation: The total number of elements remains constant\n2. Order preservation: Elements appear in the same linear sequence\n3. Value preservation: Each element value is unchanged\n\nPrecondition: The new shape must have the same total size as the original\nPostcondition: Each element at index i in the result equals the element\n             at the corresponding index in the original array", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn reshape(a: Vec<f32>) -> (result: Vec<f32>)\n    requires a.len() > 0,\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == a[i]", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_manipulation_resize", "vc-description": "Return a new vector with the specified size by repeating elements from the input vector.\nIf the new size is larger, elements are repeated cyclically.\nIf the new size is smaller, only the first elements are taken.\n\nSpecification: resize creates a new vector of the specified size by either:\n1. Taking the first `new_size` elements if `new_size ≤ n`\n2. Repeating the original elements cyclically if `new_size > n` and `n > 0`\n\nThe function handles three cases:\n- Shrinking: new_size < n → takes first new_size elements\n- Same size: new_size = n → returns identical vector\n- Growing: new_size > n → repeats elements cyclically (when n > 0)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn resize<T>(a: Vec<T>, new_size: usize) -> (result: Vec<T>)\n    ensures\n        result.len() == new_size,\n        forall|i: int| 0 <= i < new_size ==> {\n            if i < a.len() {\n                result[i] == a[i]\n            } else if a.len() > 0 {\n                result[i] == a[(i % a.len() as int) as int]\n            } else {\n                true\n            }\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_manipulation_rollaxis", "vc-description": "numpy.rollaxis: Roll the specified axis backwards, until it lies in a given position.\n\nFor 1D arrays, this is a no-op - it returns the input array unchanged.\nThis is because with only one axis (axis 0), there's nowhere to roll it to.\nThe axis and start parameters are ignored in the 1D case.\n\nNote: This function is deprecated in favor of moveaxis, but we provide\nthe specification for completeness.\n\nSpecification: numpy.rollaxis returns the input vector unchanged for 1D arrays.\n\nPrecondition: True (no special preconditions for 1D rollaxis)\nPostcondition: The result is identical to the input vector\n\nMathematical property: For 1D arrays, rollaxis is the identity function\nsince there's only one axis that cannot be moved.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_rollaxis(a: Vec<f32>, axis: i32, start: i32) -> (result: Vec<f32>)\n    ensures result == a", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_manipulation_rot90", "vc-description": "numpy.rot90: Rotate an array by 90 degrees in the plane specified by axes.\n\nFor a 2D array, this function rotates the array counterclockwise by 90 degrees\nwhen k=1. The rotation transforms element at position (i,j) to position \n(j, n-1-i) for a square matrix of size n×n. Multiple rotations can be achieved \nby setting k to the desired number of 90-degree rotations.\n\nThis specification focuses on square 2D arrays for simplicity.\n\nSpecification: rot90 rotates a square 2D matrix by 90 degrees counterclockwise k times.\n\nThe specification handles k modulo 4 since four 90-degree rotations return\nto the original orientation:\n- k ≡ 0 (mod 4): No rotation (identity)\n- k ≡ 1 (mod 4): 90° counterclockwise rotation\n- k ≡ 2 (mod 4): 180° rotation  \n- k ≡ 3 (mod 4): 270° counterclockwise (= 90° clockwise)\n\nMathematical properties:\n1. rot90 is a group action: rot90(m, k1 + k2) = rot90(rot90(m, k1), k2)\n2. rot90(m, 4) = m (period 4)\n3. rot90(m, -k) = rot90(m, 4-k) (inverse rotation)\n\nFor a 90° counterclockwise rotation, the transformation is:\n- Element at position (i,j) moves to position (j, n-1-i)\n- This preserves distances and angles (isometry)\n\nSanity checks:\n- Corner elements rotate correctly: (0,0) → (0,n-1) → (n-1,n-1) → (n-1,0) → (0,0)\n- Center element of odd-sized matrix stays fixed for k=2\n\nPrecondition: Matrix is non-empty (n > 0)\nPostcondition: Elements are repositioned according to the rotation formula", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn rot90(m: Vec<Vec<f32>>, k: i32) -> (result: Vec<Vec<f32>>)\n    requires\n        m.len() > 0,\n        forall|i: int| 0 <= i < m.len() ==> m[i].len() == m.len(),\n    ensures\n        result.len() == m.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == m.len()", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_manipulation_row_stack", "vc-description": "Stack a list of 1-D vectors as rows into a 2-D matrix (Vector of Vectors).\nEach input vector becomes a row in the output matrix.\n\nSpecification: row_stack returns a matrix where each row corresponds to an input vector.\nThe i-th row of the result is exactly the i-th input vector (identity transformation).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn row_stack(arrays: Vec<Vec<f32>>) -> (result: Vec<Vec<f32>>)\n    requires arrays.len() > 0,\n             forall|i: int| 0 <= i < arrays.len() ==> arrays[i].len() > 0,\n             forall|i: int, j: int| 0 <= i < arrays.len() && 0 <= j < arrays.len() ==> \n                 arrays[i].len() == arrays[j].len(),\n    ensures result.len() == arrays.len(),\n            forall|i: int| 0 <= i < result.len() ==> result[i].len() == arrays[i].len(),\n            forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result[i].len() ==>\n                result[i][j] == arrays[i][j]", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_manipulation_shape", "vc-description": "numpy.shape: Return the shape of an array.\n\nFor a one-dimensional vector, returns its length as a natural number.\nThis corresponds to the single element in the shape tuple for 1D arrays\nin NumPy.\n\nIn the general NumPy implementation, shape returns a tuple of dimensions.\nFor our Vector type, which is inherently one-dimensional, the shape is\nsimply the length parameter n.\n\nSpecification: numpy.shape returns the length of the vector.\n\nFor a Vector of length n, the shape function returns n.\nThis captures the fundamental property that the shape of a 1D array\nis its length.\n\nPrecondition: True (shape is defined for all vectors)\nPostcondition: The result equals the length parameter n of the vector", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn shape<T>(a: &Vec<T>) -> (result: usize)\n    ensures result == a.len()", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_manipulation_size", "vc-description": "Returns the number of elements in a vector\n\nSpecification: size returns the length of the vector, which is its type parameter n", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn size(a: &Vec<f64>) -> (result: usize)\n    ensures result == a.len()", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_manipulation_split", "vc-description": "Split a vector into k equal parts. Requires that the vector length is divisible by k.\n\nSpecification: split divides a vector into k equal-sized sub-vectors \nwhere each sub-vector contains consecutive elements from the original.\n\nThe specification states that:\n1. The result is a vector of k sub-vectors\n2. Each sub-vector has size n/k \n3. Element j of sub-vector i corresponds to element (i * (n/k) + j) of the original vector\n4. All elements from the original vector are preserved in the split", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn split(arr: Vec<f32>, k: usize) -> (result: Vec<Vec<f32>>)\n    requires\n        k > 0,\n        arr.len() % k == 0,\n    ensures\n        result.len() == k,\n        forall|i: int| #[trigger] result[i].len() == (arr.len() / k) ==> (0 <= i < k),\n        forall|i: int, j: int| \n            0 <= i < k && 0 <= j < (arr.len() / k) as int ==> {\n                let idx = i * (arr.len() / k) as int + j;\n                0 <= idx < arr.len() as int && #[trigger] result[i][j] == arr[idx]\n            },", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_manipulation_squeeze", "vc-description": "Squeeze a single-element vector to extract its value.\nThis is a simplified 1D version of numpy.squeeze for vectors of size 1.\n\nSpecification: squeeze extracts the single element from a size-1 vector.\n\nMathematical properties:\n1. The result equals the first (and only) element of the input vector\n2. For any function f, squeeze preserves function application: f(squeeze(a)) = f(a[0])\n3. squeeze is the inverse of creating a single-element vector\n\nSanity checks:\n- The input must be a vector of exactly size 1\n- The output type changes from Vector to the element type\n- This models numpy's behavior where squeeze([x]) returns x as a 0D array", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn squeeze<T>(a: Vec<T>) -> T\n    recommends a.len() == 1\n{\n    a[0]\n}\n\nfn squeeze_exec<T: Copy>(a: Vec<T>) -> (result: T)\n    requires a.len() == 1,\n    ensures \n        result == squeeze(a),\n        result == a[0],\n        forall|b: Vec<T>| b.len() == 1 && squeeze(a) == squeeze(b) ==> a[0] == b[0],\n        forall|i: int| 0 <= i < a.len() ==> a[i] == result,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_manipulation_stack", "vc-description": "Stack a sequence of vectors along a new axis to create a 2D matrix.\nFor simplicity, we focus on stacking 1D vectors along axis 0.\nThe result has shape (m, n) where m is the number of vectors and n is their common length.\n\nSpecification: stack creates a 2D matrix where each input vector becomes a row.\nKey properties:\n1. The result preserves all input vectors as rows\n2. The i-th row of the result equals the i-th input vector\n3. Shape property: stacking m vectors of length n produces an m×n matrix", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn stack(arrays: Vec<Vec<f32>>) -> (result: Vec<Vec<f32>>)\n    requires \n        arrays.len() > 0,\n        forall|i: int| 0 <= i < arrays.len() ==> #[trigger] arrays[i].len() == arrays[0].len(),\n    ensures\n        result.len() == arrays.len(),\n        forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i].len() == arrays[0].len(),\n        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result[i].len() ==> #[trigger] result[i][j] == #[trigger] arrays[i][j],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_manipulation_swapaxes", "vc-description": "Numpy swapaxes function: Interchange two axes of an array.\n\nThis function interchanges two axes of an array. For 2D arrays, swapaxes with axis1=0 and axis2=1 is equivalent to transpose. This specification focuses on 2D arrays where axis1=0 and axis2=1.\n\nSpecification: swapaxes with axes 0 and 1 transposes a 2D array.\nThe element at position (i,j) in the original becomes (j,i) in the result.\n\nMathematical properties:\n1. Dimension swap: rows become columns and vice versa\n2. Element preservation: mat[i][j] = result[j][i]\n3. Idempotence: swapping twice returns to original\n4. Commutativity: swapaxes(a, i, j) = swapaxes(a, j, i)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn swapaxes(mat: Vec<Vec<f32>>, axis1: usize, axis2: usize) -> (result: Vec<Vec<f32>>)\n    requires\n        mat.len() > 0,\n        mat[0].len() > 0,\n        forall|i: int| 0 <= i < mat.len() ==> mat[i].len() == mat[0].len(),\n        axis1 < 2,\n        axis2 < 2,\n    ensures\n        result.len() == mat[0].len(),\n        result.len() > 0 ==> result[0].len() == mat.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == mat.len(),\n        forall|i: int, j: int| \n            0 <= i < mat.len() && 0 <= j < mat[0].len() \n            ==> mat[i][j] == result[j][i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_manipulation_tile", "vc-description": "Constructs a vector by repeating the input vector `reps` times.\nFor 1D case: tile([a, b, c], 3) = [a, b, c, a, b, c, a, b, c]\n\nSpecification: tile repeats the input vector `reps` times, where each element\nat position i in the result corresponds to element at position (i % n) in the input", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn tile(a: Vec<i32>, reps: usize) -> (result: Vec<i32>)\n    requires \n        reps > 0,\n        a.len() > 0,\n    ensures\n        result.len() == a.len() * reps,\n        forall|i: int| 0 <= i < result.len() ==> result[i] == a[i % (a.len() as int)],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_manipulation_transpose", "vc-description": "numpy.transpose: Returns a matrix with rows and columns swapped.\n\nFor 2D arrays (matrices), transpose swaps the rows and columns.\nThis means that element at position (i,j) in the original matrix\nappears at position (j,i) in the transposed matrix.\n\nThis simplified version handles 2D matrix transpose only.\n\nSpecification: numpy.transpose returns a matrix where rows and columns are swapped.\n\nPrecondition: True (no special preconditions for basic transpose)\nPostcondition: For all valid indices (i,j), result[j][i] = a[i][j]\n\nMathematical properties:\n- Transpose is an involution: (A^T)^T = A\n- For square matrices: trace(A^T) = trace(A)\n- (A^T)[j,i] = A[i,j] for all valid indices", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_transpose(a: Vec<Vec<f32>>) -> (result: Vec<Vec<f32>>)\n    requires \n        a.len() > 0,\n        forall|i: int| 0 <= i < a.len() ==> a[i].len() == a[0].len(),\n        a[0].len() > 0,\n    ensures\n        result.len() == a[0].len(),\n        forall|j: int| 0 <= j < result.len() ==> result[j].len() == a.len(),\n        forall|i: int, j: int| \n            0 <= i < a.len() && 0 <= j < a[0].len() ==> \n            result[j][i] == a[i][j],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_manipulation_trim_zeros", "vc-description": "numpy.trim_zeros: Trim the leading and/or trailing zeros from a 1-D array.\n\nRemoves zeros from the beginning and/or end of a vector based on the trim mode.\n- Front: removes leading zeros only\n- Back: removes trailing zeros only\n- Both: removes both leading and trailing zeros (default)\n\nThe function preserves all non-zero elements and internal zeros.\n\nSpecification: trim_zeros removes leading and/or trailing zeros while preserving order.\n\nThe function guarantees:\n1. All non-zero elements from the original array are preserved in order\n2. Internal zeros (zeros between non-zero elements) are preserved\n3. Only leading/trailing zeros are removed based on the mode\n4. If the array contains only zeros, returns an empty vector\n\n/* Represents the trim mode for trim_zeros function */\n\n/* Trim zeros from the front of the array only (corresponds to 'f') */\n\n/* Trim zeros from the back of the array only (corresponds to 'b') */\n\n/* Trim zeros from both front and back of the array (corresponds to 'fb', default) */\n\n/* Elements before start are zeros (if trimming front) */\n\n/* Elements after finish are zeros (if trimming back) */\n\n/* The preserved elements match exactly */\n\n/* If trimming front, start is the first non-zero or arr.len() */\n\n/* If trimming back, finish is past the last non-zero or 0 */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\npub enum TrimMode {\n\n    Front,\n\n    Back,\n\n    Both,\n}", "vc-helpers": "", "vc-spec": "fn trim_zeros(arr: Vec<f64>, mode: TrimMode) -> (result: Vec<f64>)\n    ensures\n        exists|start: int, finish: int|\n            0 <= start <= arr.len() &&\n            0 <= finish <= arr.len() &&\n            start <= finish &&\n            result.len() == (finish - start) &&\n\n            (matches!(mode, TrimMode::Front | TrimMode::Both) ==> \n                forall|i: int| 0 <= i < start ==> arr[i] == 0.0) &&\n\n            (matches!(mode, TrimMode::Back | TrimMode::Both) ==> \n                forall|i: int| finish <= i < arr.len() ==> arr[i] == 0.0) &&\n\n            (forall|i: int| 0 <= i < result.len() ==> result[i] == arr[start + i]) &&\n\n            (matches!(mode, TrimMode::Front | TrimMode::Both) ==> \n                (start == arr.len() || arr[start] != 0.0)) &&\n\n            (matches!(mode, TrimMode::Back | TrimMode::Both) ==> \n                (finish == 0 || (finish > 0 && arr[finish - 1] != 0.0)))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_manipulation_vsplit", "vc-description": "Split a 2D vector into multiple sub-vectors vertically (row-wise).\nThis is a simplified version that handles splitting into equal parts.\n\nSpecification: vsplit divides a matrix into k equal parts row-wise, \nwhere each part contains consecutive rows from the original matrix", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn vsplit(mat: Vec<Vec<f32>>, k: usize) -> (result: Vec<Vec<Vec<f32>>>)\n    requires \n        k > 0,\n        mat.len() > 0,\n        mat.len() % k == 0,\n        forall|i: int| 0 <= i < mat.len() ==> mat[i].len() == mat[0].len(),\n    ensures\n        result.len() == k,\n        forall|split_idx: int| 0 <= split_idx < k ==> result[split_idx].len() == mat.len() / k,\n        forall|split_idx: int, row_idx: int, col_idx: int| \n            0 <= split_idx < k && 0 <= row_idx < mat.len() / k && 0 <= col_idx < mat[0].len() ==>\n            exists|global_row: int| \n                global_row == split_idx * (mat.len() / k) + row_idx &&\n                0 <= global_row < mat.len() &&\n                result[split_idx][row_idx][col_idx] == mat[global_row][col_idx],\n        forall|orig_row: int| 0 <= orig_row < mat.len() ==>\n            exists|split_idx: int, row_idx: int|\n                0 <= split_idx < k && 0 <= row_idx < mat.len() / k &&\n                orig_row == split_idx * (mat.len() / k) + row_idx,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "array_manipulation_vstack", "vc-description": "Stack two vectors vertically to create a 2D matrix.\nFor 1D vectors, this treats them as row vectors and stacks them vertically.\nThis is a simplified version focusing on the common case of stacking two 1D vectors.\n\nSpecification: vstack stacks two vectors vertically, creating a 2x n matrix\nwhere the first row is vector a and the second row is vector b.\n\nMathematical properties:\n1. The result has shape (2, n) where n is the length of input vectors\n2. The first row of the result equals the first input vector\n3. The second row of the result equals the second input vector\n4. This operation preserves the elements and their order within each vector", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn vstack(a: Vec<f32>, b: Vec<f32>) -> (result: Vec<Vec<f32>>)\n    requires a.len() == b.len(),\n    ensures\n        result.len() == 2,\n        result[0].len() == a.len(),\n        result[1].len() == b.len(),\n        forall|j: int| 0 <= j < a.len() ==> result[0][j] == a[j],\n        forall|j: int| 0 <= j < b.len() ==> result[1][j] == b[j]", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "bitwise_operations_binary_repr", "vc-description": "Return the binary representation of the input number as a string.\nFor negative numbers, if width is not given, a minus sign is added to the front.\nIf width is given, the two's complement of the number is returned.\n\nSpecification: binary_repr correctly converts integers to binary strings with proper\nhandling of negative numbers (signed representation without width, two's complement with width)\n\n/* Helper function to convert a natural number to its binary string representation */\n\n/* Helper function to check if a string represents a valid binary number */\n\n/* Helper function to check if a string represents a valid signed binary number */\n\n/* Result is a valid binary string (possibly with sign) */\n\n/* Length constraints */\n\n/* Positive numbers: standard binary representation */\n\n/* Negative numbers without width: signed representation */\n\n/* Two's complement properties for negative numbers with width */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn nat_to_binary_string(n: nat) -> Seq<char>\n    decreases n\n{\n    if n == 0 {\n        seq!['0']\n    } else {\n        let digit = if n % 2 == 0 { '0' } else { '1' };\n        nat_to_binary_string(n / 2).push(digit)\n    }\n}\n\nspec fn is_valid_binary(s: Seq<char>) -> bool {\n    s.len() > 0 && (forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1')\n}\n\nspec fn is_valid_signed_binary(s: Seq<char>) -> bool {\n    if s.len() > 0 && s[0] == '-' {\n        is_valid_binary(s.skip(1))\n    } else {\n        is_valid_binary(s)\n    }\n}", "vc-helpers": "", "vc-spec": "fn binary_repr(num: i32, width: Option<usize>) -> (result: Vec<char>)\n    requires \n        width.is_some() ==> width.get_Some_0() >= 1,\n    ensures \n\n        width.is_none() ==> is_valid_signed_binary(result@),\n        width.is_some() ==> is_valid_binary(result@),\n\n        width.is_some() ==> result.len() == width.get_Some_0(),\n\n        (num >= 0 && width.is_none()) ==> \n            result@ == nat_to_binary_string(num as nat),\n\n        (num < 0 && width.is_none()) ==> \n            result@.len() > 0 && result@[0] == '-' && is_valid_binary(result@.skip(1)),\n\n        (num < 0 && width.is_some()) ==> {\n            let w = width.get_Some_0();\n            let two_comp = (1u32 << w) as i32 + num;\n            two_comp >= 0 && two_comp < (1i32 << w) && result.len() == w\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "bitwise_operations_bitwise_and", "vc-description": "numpy.bitwise_and: Compute the bit-wise AND of two arrays element-wise.\n\nComputes the bit-wise AND of the underlying binary representation of \nthe integers in the input arrays. This ufunc implements the C/Python \noperator &.\n\nFor each pair of corresponding elements in x1 and x2, the result contains\nthe bitwise AND of their binary representations. Each bit position in the\nresult is 1 only if both corresponding bits in x1 and x2 are 1.\n\nExamples:\n- 13 & 17 = 1 (binary: 01101 & 10001 = 00001)\n- 14 & 13 = 12 (binary: 01110 & 01101 = 01100)\n\nNote: This specification currently handles only non-negative integers.\nFor negative integers, NumPy uses two's complement representation,\nwhich requires a more complex formalization in Lean.\n\nSpecification: bitwise_and returns a vector where each element is the \nbitwise AND of the corresponding elements from x1 and x2.\n\nPrecondition: All elements are non-negative (to simplify the specification)\n\nPostcondition: \n1. For non-negative integers, each element of the result is the bitwise AND \n   of corresponding inputs\n2. The result preserves the mathematical properties of bitwise AND:\n   - Commutativity: x & y = y & x\n   - Associativity: (x & y) & z = x & (y & z)\n   - Identity: x & (2^k - 1) = x for x < 2^k (all 1s acts as identity)\n   - Annihilator: x & 0 = 0\n   - Idempotence: x & x = x\n3. The result is always less than or equal to both inputs (for non-negative integers)\n4. Each bit in the result is 1 iff both corresponding bits in the inputs are 1", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn bitwise_and(x1: Vec<i32>, x2: Vec<i32>) -> (result: Vec<i32>)\n    requires \n        x1.len() == x2.len(),\n        forall|i: int| 0 <= i < x1.len() ==> x1[i] >= 0,\n        forall|i: int| 0 <= i < x2.len() ==> x2[i] >= 0,\n    ensures\n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == (x1[i] & x2[i]),\n        forall|i: int| 0 <= i < result.len() ==> result[i] >= 0,\n        forall|i: int| 0 <= i < result.len() ==> result[i] <= x1[i],\n        forall|i: int| 0 <= i < result.len() ==> result[i] <= x2[i],\n        forall|i: int| 0 <= i < result.len() ==> (result[i] == 0 <==> (x1[i] == 0 || x2[i] == 0)),\n        forall|i: int| 0 <= i < result.len() ==> (x1[i] == x2[i] ==> result[i] == x1[i]),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "bitwise_operations_bitwise_count", "vc-description": "Computes the number of 1-bits in the absolute value of each element in a vector\n\nSpecification: bitwise_count returns the count of 1-bits in the binary representation\nof the absolute value of each element. The result satisfies several properties:\n1. Each output element is the popcount of the corresponding input's absolute value\n2. The popcount is bounded by the number of bits in the representation\n3. Zero inputs produce zero outputs\n4. Powers of 2 have exactly one bit set\n5. Powers of 2 minus 1 have consecutive 1-bits (e.g., 2^k - 1 has k bits set)\n6. The popcount is always non-negative and bounded by bit width\n7. For negative inputs, uses the absolute value\n8. The popcount operation is invariant under sign changes\n\n/* Helper function to count the number of 1-bits in a natural number */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn abs_spec(x: i32) -> nat {\n    if x >= 0 { x as nat } else { (-x) as nat }\n}\n\nspec fn popcount(n: nat) -> nat \n    decreases n\n{\n    if n == 0 {\n        0\n    } else {\n        (n % 2) + popcount(n / 2)\n    }\n}", "vc-helpers": "", "vc-spec": "fn bitwise_count(x: Vec<i32>) -> (result: Vec<nat>)\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == popcount(abs_spec(x[i])),\n        forall|i: int| 0 <= i < result.len() ==> x[i] == 0 ==> result[i] == 0,\n        forall|i: int| 0 <= i < result.len() ==> result[i] >= 0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "bitwise_operations_bitwise_or", "vc-description": "Compute the bit-wise OR of two vectors element-wise\n\n// placeholder implementation\n\n// placeholder implementation", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn bitwise_or_int(x: i32, y: i32) -> i32 {\n    x\n}\n\nspec fn bitwise_and_int(x: i32, y: i32) -> i32 {\n    x\n}\n\nspec fn bitwise_or_vec(x: Seq<i32>, y: Seq<i32>) -> Seq<i32>\n    recommends x.len() == y.len()\n{\n    Seq::new(x.len(), |i: int| x[i])\n}\n\nfn bitwise_or_fn(x1: Vec<i32>, x2: Vec<i32>) -> (result: Vec<i32>)\n    requires x1.len() == x2.len(),\n    ensures \n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == bitwise_or_int(x1[i], x2[i]),\n        forall|i: int| 0 <= i < result.len() && x2[i] == 0 ==> result[i] == x1[i],\n        forall|i: int| 0 <= i < result.len() && x1[i] == 0 ==> result[i] == x2[i],\n        forall|i: int| 0 <= i < result.len() && (x1[i] == -1i32 || x2[i] == -1i32) ==> result[i] == -1i32,\n        result@ == bitwise_or_vec(x1@, x2@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "bitwise_operations_bitwise_xor", "vc-description": "Compute the bit-wise XOR of two arrays element-wise.\n\nComputes the bit-wise XOR (exclusive OR) of the underlying binary representation \nof the integers in the input arrays. This ufunc implements the C/Python \noperator ^.\n\nFor each pair of corresponding elements in x1 and x2, the result contains\nthe bitwise XOR of their binary representations. Each bit position in the\nresult is 1 if and only if exactly one of the corresponding bits in x1 and x2 is 1.\n\nExamples:\n- 13 ^ 17 = 28 (binary: 01101 ^ 10001 = 11100)\n- 31 ^ 5 = 26 (binary: 11111 ^ 00101 = 11010)\n- 31 ^ 3 = 28 (binary: 11111 ^ 00011 = 11100)\n\nNote: This specification currently handles only non-negative integers.\nFor negative integers, NumPy uses two's complement representation,\nwhich requires a more complex formalization.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn bitwise_xor(x1: Vec<i32>, x2: Vec<i32>) -> (result: Vec<i32>)\n    requires \n        x1.len() == x2.len(),\n        forall|i: int| 0 <= i < x1.len() ==> x1[i] >= 0,\n        forall|i: int| 0 <= i < x2.len() ==> x2[i] >= 0,\n    ensures\n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == (x1[i] ^ x2[i]),\n        forall|i: int| 0 <= i < result.len() ==> result[i] >= 0,\n        forall|i: int| 0 <= i < result.len() && x1[i] == 0 ==> result[i] == x2[i],\n        forall|i: int| 0 <= i < result.len() && x2[i] == 0 ==> result[i] == x1[i],\n        forall|i: int| 0 <= i < result.len() && x1[i] == x2[i] ==> result[i] == 0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "bitwise_operations_invert", "vc-description": "Compute bit-wise inversion (NOT) of each element in a vector of integers.\nFor signed integers, this returns the two's complement.\n\nSpecification: invert computes the bitwise NOT operation element-wise.\n\nMathematical properties:\n1. Two's complement relationship: ~x = -(x + 1)\n2. Involution property: applying invert twice returns the original value\n3. The operation preserves vector size\n4. Identity relationships:\n   - ~0 = -1\n   - ~(-1) = 0\n5. Sign flipping: ~x has opposite sign to x when x ≠ -1\n\nThe specification captures both the element-wise nature and the \nmathematical relationship for two's complement representation.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn invert(x: Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < x.len() ==> result[i] == -(x[i] + 1),\n        forall|i: int| 0 <= i < x.len() && x[i] == 0 ==> result[i] == -1,\n        forall|i: int| 0 <= i < x.len() && x[i] == -1 ==> result[i] == 0,\n        forall|i: int| 0 <= i < x.len() && x[i] != -1 ==> (x[i] > 0 <==> result[i] < 0),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "bitwise_operations_left_shift", "vc-description": "Shift the bits of integers to the left element-wise.\nThis operation is equivalent to multiplying each element by 2^shift_amount.\n\nSpecification: left_shift performs bitwise left shift operation on each element.\nThe result is equivalent to multiplying x1[i] by 2^x2[i] for non-negative shifts.\n\nMathematical properties:\n1. Core behavior: Each element result[i] = x1[i] * 2^x2[i] for non-negative shifts\n2. Identity property: Shifting by 0 returns the original value\n3. Zero preservation: Shifting zero always yields zero\n4. Monotonicity: For positive values, left shifting increases magnitude\n5. Composition property: left_shift(x, a) then left_shift(result, b) = left_shift(x, a+b)", "vc-preamble": "use vstd::prelude::*;\nuse vstd::arithmetic::power::pow;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn left_shift(x1: Vec<i32>, x2: Vec<i32>) -> (result: Vec<i32>)\n    requires\n        x1.len() == x2.len(),\n        forall|i: int| 0 <= i < x2.len() ==> x2[i] >= 0,\n    ensures\n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == x1[i] * pow(2, x2[i] as nat),\n        forall|i: int| 0 <= i < result.len() && x2[i] == 0 ==> result[i] == x1[i],\n        forall|i: int| 0 <= i < result.len() && x1[i] == 0 ==> result[i] == 0,\n        forall|i: int| 0 <= i < result.len() && x1[i] > 0 && x2[i] > 0 ==> result[i] > x1[i],\n        forall|i: int| 0 <= i < result.len() && x1[i] < 0 && x2[i] > 0 ==> result[i] < x1[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "bitwise_operations_packbits", "vc-description": "Packs binary-valued elements into bits in a UInt8 array.\nEach group of 8 binary values is packed into one UInt8.\nThe result is padded with zeros if needed.\n\nSpecification: packbits correctly packs binary values into UInt8 bytes according to bitorder.\nFor big-endian: first element goes to MSB (bit 7)\nFor little-endian: first element goes to LSB (bit 0)\n\n/* Enumeration for bit ordering in packbits */\n\n// MSB first (default): bit 7 is first element\n\n// LSB first: bit 0 is first element\n\n// Big-endian: bit 7 is first, bit 0 is last\n\n// Little-endian: bit 0 is first, bit 7 is last", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n#[derive(PartialEq, Eq)]\nenum BitOrder {\n    Big,\n    Little\n}", "vc-helpers": "", "vc-spec": "fn packbits(a: Vec<bool>, bitorder: BitOrder) -> (result: Vec<u8>)\n    requires a.len() > 0,\n    ensures \n        result.len() == (a.len() + 7) / 8,\n        forall|byte_idx: int| 0 <= byte_idx < result.len() ==> {\n            let start_idx = byte_idx * 8;\n            let bits_in_byte = if start_idx + 8 <= a.len() { 8 } else { a.len() - start_idx };\n            match bitorder {\n                BitOrder::Big => {\n\n                    forall|bit_pos: int| 0 <= bit_pos < bits_in_byte ==> {\n                        let bit_value = if start_idx + bit_pos < a.len() && a[start_idx + bit_pos] { 1u8 } else { 0u8 };\n                        (result[byte_idx] & (1u8 << (7 - bit_pos))) == (bit_value << (7 - bit_pos))\n                    }\n                },\n                BitOrder::Little => {\n\n                    forall|bit_pos: int| 0 <= bit_pos < bits_in_byte ==> {\n                        let bit_value = if start_idx + bit_pos < a.len() && a[start_idx + bit_pos] { 1u8 } else { 0u8 };\n                        (result[byte_idx] & (1u8 << bit_pos)) == (bit_value << bit_pos)\n                    }\n                }\n            }\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "bitwise_operations_right_shift", "vc-description": "Shift the bits of an integer to the right element-wise. This operation is equivalent to dividing each element by 2^shift_amount using integer division. For negative inputs, the behavior follows arithmetic right shift with sign extension.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn right_shift(x1: Vec<i32>, x2: Vec<i32>) -> (result: Vec<i32>)\n    requires \n        x1.len() == x2.len(),\n        forall|i: int| 0 <= i < x2.len() ==> x2[i] >= 0,\n    ensures\n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> {\n            &&& (x1[i] >= 0 ==> result[i] == x1[i] / (1i32 << x2[i]))\n            &&& (x1[i] < 0 ==> result[i] == x1[i] >> x2[i])\n            &&& (x2[i] == 0 ==> result[i] == x1[i])\n            &&& (x1[i] > 0 ==> result[i] >= 0)\n            &&& (x1[i] < 0 ==> result[i] <= 0)\n            &&& (x1[i] == 0 ==> result[i] == 0)\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "bitwise_operations_unpackbits", "vc-description": "numpy.unpackbits: Unpacks elements of a uint8 array into a binary-valued output array.\n\nEach element of the input array represents a bit-field that is unpacked into\na binary-valued output array. By default, each uint8 value is unpacked into\n8 binary values (0 or 1) using big-endian bit order.\n\nThis specification covers the basic 1D case with default parameters.\nFor simplicity, we use Nat instead of UInt8, with the constraint that input values < 256.", "vc-preamble": "use vstd::prelude::*;\nuse vstd::arithmetic::power::pow;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_unpackbits(a: Vec<u8>) -> (result: Vec<u8>)\n    requires forall|i: int| 0 <= i < a.len() ==> a[i] < 256,\n    ensures \n        result.len() == a.len() * 8,\n        forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < 8 ==> \n            #[trigger] result[i * 8 + j] == ((a[i] as int) / pow(2, (7 - j) as nat)) % 2", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "constants_False_", "vc-description": "NumPy's boolean False value, used in comparison operations and boolean arrays.\n\nSpecification: False_ represents the boolean false value with properties:\n1. It equals false\n2. It is the identity for logical OR\n3. It is the absorbing element for logical AND\n4. It is the negation of True_", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn false_() -> (result: bool)\n    ensures \n        result == false,\n        forall|b: bool| (result || b) == b,\n        forall|b: bool| (result && b) == false,\n        result == !true", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "constants_NINF", "vc-description": "IEEE 754 floating point representation of negative infinity (deprecated in NumPy 2.0)\n\nSpecification: NINF represents negative infinity with the following properties:\n1. NINF is less than any finite float value\n2. NINF + any finite value = NINF\n3. NINF * positive finite value = NINF\n4. NINF * negative finite value = inf\n5. NINF / any finite non-zero value = NINF (with appropriate sign)\n6. NINF = -inf (negative of positive infinity)\n\n/* IEEE 754 floating point representation of negative infinity (deprecated in NumPy 2.0) */\n\n// NINF represents a special f64 value (negative infinity)\n\n// Due to Verus limitations with floating point specifications,\n\n// we can only provide basic structural properties\n\n/* Placeholder - actual floating point properties cannot be easily verified in Verus */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn NINF() -> (result: f64)\n    ensures\n\n        true", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "constants_NPY_LOG2E", "vc-description": "Base 2 logarithm of e\n{\n  \"name\": \"NPY_LOG2E\",\n  \"category\": \"C API Mathematical constants\",\n  \"description\": \"Base 2 logarithm of e\",\n  \"doc\": \"log2(e) = 1.442695040888963407359924681001892137\",\n}\n\nBase 2 logarithm of e (log₂(e))\n\nSpecification: NPY_LOG2E is the base 2 logarithm of e with mathematical properties:\n    1. It is approximately 1.442695040888963407359924681001892137\n    2. It satisfies the relationship: 2^(NPY_LOG2E) = e\n    3. It is the reciprocal of ln(2) (i.e., NPY_LOG2E = 1/ln(2))\n    4. It is used to convert natural logarithms to base 2 logarithms via: log₂(x) = ln(x) * NPY_LOG2E", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn NPY_LOG2E() -> (result: f64)\n    ensures\n        result == 1.442695040888963407359924681001892137,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "constants_NPY_SQRT1_2", "vc-description": "NPY_SQRT1_2: Square root of 1/2\n\nSquare root of 1/2 as a Float constant\nSpecification: NPY_SQRT1_2 equals the square root of 1/2 with mathematical properties", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn NPY_SQRT1_2() -> (result: f64)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "constants_PZERO", "vc-description": "IEEE 754 floating point representation of positive zero.\n\nDEPRECATED: Removed from main namespace in NumPy 2.0. Use 0.0 instead.\n\nIEEE 754 floating point representation of positive zero\n\nSpecification: PZERO represents IEEE 754 positive zero with the following properties:\n1. It equals the standard zero value\n2. It behaves as the additive identity\n3. It behaves as expected in multiplication and division\n4. It has special IEEE 754 properties (e.g., 1.0 / PZERO = +∞)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn pzero() -> (result: f64)\n    ensures result == 0.0", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "constants_True_", "vc-description": "NumPy's boolean scalar type representing True.\nThis is NumPy's equivalent of Python's built-in True, but as a NumPy scalar type.\nComparison operations in NumPy return this type instead of Python's bool.\n\nSpecification: numpy.True_ represents the boolean value true and has the following properties:\n1. It equals the Lean boolean true\n2. It is the identity element for logical AND operations\n3. It is the absorbing element for logical OR operations\n4. Its negation gives false", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn true_() -> (result: bool)\n    ensures \n        result == true,\n        forall|b: bool| (result && b) == b,\n        forall|b: bool| (result || b) == true,\n        !result == false", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "constants_e", "vc-description": "Euler's constant (e), the base of natural logarithms\n\nEuler's constant, base of natural logarithms, Napier's constant\ne = 2.71828182845904523536028747135266249775724709369995...\n\nEuler's number is the base of the natural logarithm. It is the unique number whose natural logarithm is equal to one.\n\nSpecification: e is Euler's constant with mathematical properties:\n1. It is approximately 2.718281828459045\n2. It is the unique positive real number such that ln(e) = 1\n3. It is the limit of (1 + 1/n)^n as n approaches infinity\n4. It satisfies the property that the derivative of e^x equals e^x\n5. It is the sum of the infinite series 1/0! + 1/1! + 1/2! + ...", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn e() -> (result: f64)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "constants_euler_gamma", "vc-description": "The Euler-Mascheroni constant γ, approximately 0.577215...\n\nSpecification: euler_gamma represents the Euler-Mascheroni constant γ,\nwhich is the limiting difference between the harmonic series and the natural logarithm.\nIt satisfies key mathematical properties and bounds\n\n/* The Euler-Mascheroni constant (γ), approximately 0.577215... */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn euler_gamma() -> (result: f64)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "constants_iinfo", "vc-description": "Machine limits for integer types - returns information about the given integer type including \nthe number of bits, minimum value, and maximum value.\n\nSpecification: iinfo returns correct machine limits for integer types.\nThe returned IntegerInfo structure contains:\n- bits: the number of bits used by the type\n- min: the minimum representable value (-(2^(bits-1)) for signed, 0 for unsigned)\n- max: the maximum representable value (2^(bits-1) - 1 for signed, 2^bits - 1 for unsigned)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "#[derive(Clone, Copy, PartialEq, Eq)]\npub enum IntegerType {\n    Int8,\n    Int16, \n    Int32,\n    Int64,\n    UInt8,\n    UInt16,\n    UInt32,\n    UInt64,\n}\n\npub struct IntegerInfo {\n    pub bits: u32,\n    pub min: i64,\n    pub max: i64,\n}\n\nfn iinfo(int_type: IntegerType) -> (result: IntegerInfo)\n    ensures match int_type {\n        IntegerType::Int8 => \n            result.bits == 8 && result.min == -128 && result.max == 127,\n        IntegerType::Int16 => \n            result.bits == 16 && result.min == -32768 && result.max == 32767,\n        IntegerType::Int32 => \n            result.bits == 32 && result.min == -2147483648 && result.max == 2147483647,\n        IntegerType::Int64 => \n            result.bits == 64 && result.min == -9223372036854775808 && result.max == 9223372036854775807,\n        IntegerType::UInt8 => \n            result.bits == 8 && result.min == 0 && result.max == 255,\n        IntegerType::UInt16 => \n            result.bits == 16 && result.min == 0 && result.max == 65535,\n        IntegerType::UInt32 => \n            result.bits == 32 && result.min == 0 && result.max == 4294967295,\n        IntegerType::UInt64 => \n            result.bits == 64 && result.min == 0 && result.max == 18446744073709551615,\n    }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "constants_inf", "vc-description": "IEEE 754 floating point representation of (positive) infinity\n\nSpecification: inf represents positive infinity with the following properties:\n1. inf is greater than any finite float value\n2. inf + any finite value = inf\n3. inf * positive finite value = inf\n4. inf * negative finite value = -inf\n5. inf / any finite non-zero value = inf (with appropriate sign)\n\n/* IEEE 754 floating point representation of (positive) infinity */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn inf() -> (result: f32)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "constants_nan", "vc-description": "IEEE 754 floating point representation of Not a Number (NaN)\n\nIEEE 754 floating point representation of Not a Number (NaN)\n\nSpecification: nan represents Not a Number with the following IEEE 754 properties:\n1. Float.isNaN returns true for NaN (primary property)\n2. Any arithmetic operation with NaN results in NaN\n3. NaN is not ordered (comparisons with any value are false except ≠)\n4. NaN is not finite\n5. Standard operations preserve NaN propagation\n\n// NaN is not equal to itself", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn nan() -> (result: f64)\n    ensures result != result,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "constants_newaxis", "vc-description": "A convenient alias for None, useful for indexing arrays. newaxis is an alias for None and is used to expand the dimensions of an array. Expands a vector to a column matrix (n × 1) using newaxis. This models the behavior of a[:, np.newaxis] which converts a 1D array of shape (n,) to a 2D array of shape (n, 1). Specification: expandToColumn creates a column matrix where each element is a singleton vector containing the corresponding element from the input vector. Mathematical property: The resulting matrix has shape (n, 1), each row contains exactly one element from the original vector, result[i][0] = v[i] for all valid indices.\n\n/* Represents the newaxis constant used for dimension expansion.\n   In NumPy, newaxis is used in indexing to add new dimensions to arrays.\n   For our Vector-based implementation, we model this as a function that\n   converts a 1D vector into a 2D vector (matrix) with either shape (n, 1) or (1, n). */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\npub enum NewAxis {\n    Newaxis,\n}", "vc-helpers": "", "vc-spec": "fn expand_to_column<T>(v: Vec<T>, axis: NewAxis) -> (result: Vec<Vec<T>>)\n    ensures\n        result.len() == v.len(),\n        forall|i: int| 0 <= i < result.len() ==> (\n            result[i].len() == 1 &&\n            result[i][0] == v[i]\n        ),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "data_type_routines_as_strided", "vc-description": "numpy.as_strided: Create a view into the array with the given shape and strides.\n\nCreates a new view of an array with specified shape and strides.\nThis is a simplified version that focuses on the core mathematical\nproperty: creating a view with a different shape but accessing\nelements from the original array based on stride patterns.\n\nFor safety, we restrict to cases where the new shape is smaller\nthan or equal to the original array size.\n\nSpecification: numpy.as_strided creates a view with specified strides.\n\nPrecondition: The strided access must be valid (m * stride ≤ n)\nPostcondition: Each element in the result is taken from the original\narray at positions determined by the stride pattern.\n\nFor element i in the result, it equals x[i * stride].", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_as_strided(x: &Vec<f32>, stride: usize, m: usize) -> (result: Vec<f32>)\n    requires \n        stride > 0,\n        m * stride <= x.len(),\n    ensures\n        result.len() == m,\n        forall|i: int| 0 <= i < m ==> result[i] == x[i * stride],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "data_type_routines_can_cast", "vc-description": "Returns True if cast between data types can occur according to the casting rule\n\n/* Data type enumeration for casting rules */\n\n/* no casting is allowed */\n\n/* only byte-order changes are allowed */\n\n/* only casts which can preserve values are allowed */\n\n/* safe casts or casts within a kind */\n\n/* any data conversions may be done */\n\n/* Data type enumeration for supported numeric types */\n\n/* Basic reflexivity: any type can cast to itself with any rule */\n\n/* No casting rule: only identical types allowed */\n\n/* Safe casting preserves values */\n\n/* Integer widening is safe */\n\n/* Float widening is safe */\n\n/* Integer to float can be safe if no precision loss */\n\n/* Complex widening is safe */\n\n/* Float to complex is safe */\n\n/* Same type is always safe */\n\n/* Same kind casting allows within numeric families */\n\n/* Integer family */\n\n/* Float family */\n\n/* Complex family */\n\n/* Cross-family safe casts */\n\n/* Unrestricted casting allows any conversion */\n\n/* Equiv casting allows same types (byte-order changes only) */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n#[derive(PartialEq, Eq)]\npub enum CastingRule {\n    No,\n    Equiv,\n    Safe,\n    SameKind,\n    Unrestricted,\n}\n\n#[derive(PartialEq, Eq)]\npub enum DType {\n    Int8,\n    Int16,\n    Int32,\n    Int64,\n    Float32,\n    Float64,\n    Complex64,\n    Complex128,\n    Bool,\n}", "vc-helpers": "", "vc-spec": "fn can_cast(from_dtype: DType, to_dtype: DType, casting: CastingRule) -> (result: bool)\n    ensures\n\n        (from_dtype == to_dtype ==> result == true) &&\n\n        (casting == CastingRule::No ==> (result == true <==> from_dtype == to_dtype)) &&\n\n        (casting == CastingRule::Safe ==> \n            (result == true ==> \n\n                ((from_dtype == DType::Int8 && (to_dtype == DType::Int16 || to_dtype == DType::Int32 || to_dtype == DType::Int64)) ||\n                 (from_dtype == DType::Int16 && (to_dtype == DType::Int32 || to_dtype == DType::Int64)) ||\n                 (from_dtype == DType::Int32 && to_dtype == DType::Int64) ||\n\n                 (from_dtype == DType::Float32 && to_dtype == DType::Float64) ||\n\n                 ((from_dtype == DType::Int8 || from_dtype == DType::Int16) && (to_dtype == DType::Float32 || to_dtype == DType::Float64)) ||\n                 (from_dtype == DType::Int32 && to_dtype == DType::Float64) ||\n\n                 (from_dtype == DType::Complex64 && to_dtype == DType::Complex128) ||\n\n                 ((from_dtype == DType::Float32 || from_dtype == DType::Float64) && (to_dtype == DType::Complex64 || to_dtype == DType::Complex128)) ||\n\n                 (from_dtype == to_dtype)))) &&\n\n        (casting == CastingRule::SameKind ==> \n            (result == true ==> \n\n                (((from_dtype == DType::Int8 || from_dtype == DType::Int16 || from_dtype == DType::Int32 || from_dtype == DType::Int64) && \n                  (to_dtype == DType::Int8 || to_dtype == DType::Int16 || to_dtype == DType::Int32 || to_dtype == DType::Int64)) ||\n\n                 ((from_dtype == DType::Float32 || from_dtype == DType::Float64) && \n                  (to_dtype == DType::Float32 || to_dtype == DType::Float64)) ||\n\n                 ((from_dtype == DType::Complex64 || from_dtype == DType::Complex128) && \n                  (to_dtype == DType::Complex64 || to_dtype == DType::Complex128)) ||\n\n                 ((from_dtype == DType::Int8 || from_dtype == DType::Int16 || from_dtype == DType::Int32 || from_dtype == DType::Int64) && \n                  (to_dtype == DType::Float32 || to_dtype == DType::Float64 || to_dtype == DType::Complex64 || to_dtype == DType::Complex128)) ||\n                 ((from_dtype == DType::Float32 || from_dtype == DType::Float64) && \n                  (to_dtype == DType::Complex64 || to_dtype == DType::Complex128))))) &&\n\n        (casting == CastingRule::Unrestricted ==> result == true) &&\n\n        (casting == CastingRule::Equiv ==> (result == true <==> from_dtype == to_dtype))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "data_type_routines_iinfo", "vc-description": "Machine limits for integer types\n\nTakes an integer type specification and returns information about \nthe number of bits, minimum value, and maximum value for that type.\nThis provides access to the fundamental machine limits for integer\nrepresentation in numerical computing.\n\nSpecification: numpy.iinfo returns correct machine limits for integer types.\n\nPrecondition: True (no special preconditions for type information)\nPostcondition: The returned IntInfo structure contains:\n  - Correct bit count for the specified type\n  - Correct minimum value (negative for signed types, 0 for unsigned)\n  - Correct maximum value based on the bit representation\n  - Consistency between bits and min/max values\n\n/* Integer type information structure containing machine limits for integer types */\n\n/* Number of bits occupied by the type */\n\n/* Smallest integer expressible by the type */\n\n/* Largest integer expressible by the type */\n\n/* Enumeration of supported integer types */\n\n/* 8-bit signed integer type */\n\n/* 16-bit signed integer type */\n\n/* 32-bit signed integer type */\n\n/* 64-bit signed integer type */\n\n/* 8-bit unsigned integer type */\n\n/* 16-bit unsigned integer type */\n\n/* 32-bit unsigned integer type */\n\n/* 64-bit unsigned integer type */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "struct IntInfo {\n\n    bits: u32,\n\n    min: i64,\n\n    max: i64,\n}\n\nenum IntType {\n\n    Int8,\n\n    Int16,\n\n    Int32,\n\n    Int64,\n\n    UInt8,\n\n    UInt16,\n\n    UInt32,\n\n    UInt64,\n}\n\nfn iinfo(int_type: IntType) -> (info: IntInfo)\n    ensures\n        match int_type {\n            IntType::Int8 => info.bits == 8 && info.min == -128 && info.max == 127,\n            IntType::Int16 => info.bits == 16 && info.min == -32768 && info.max == 32767,\n            IntType::Int32 => info.bits == 32 && info.min == -2147483648 && info.max == 2147483647,\n            IntType::Int64 => info.bits == 64 && info.min == -9223372036854775808 && info.max == 9223372036854775807,\n            IntType::UInt8 => info.bits == 8 && info.min == 0 && info.max == 255,\n            IntType::UInt16 => info.bits == 16 && info.min == 0 && info.max == 65535,\n            IntType::UInt32 => info.bits == 32 && info.min == 0 && info.max == 4294967295,\n            IntType::UInt64 => info.bits == 64 && info.min == 0 && info.max == 18446744073709551615,\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "data_type_routines_isdtype", "vc-description": "numpy.isdtype: Determine if a provided dtype is of a specified data type kind.\n\nThis function checks whether a given NumPy dtype belongs to a specified\ncategory of data types. It supports checking against specific dtype kinds\nlike 'bool', 'signed integer', 'unsigned integer', 'integral', \n'real floating', 'complex floating', and 'numeric'.\n\nThe function performs type introspection and classification of NumPy dtypes\naccording to their fundamental characteristics.\n\nSpecification: numpy.isdtype correctly identifies dtype kinds.\n\nPrecondition: True (works for any valid dtype and kind)\nPostcondition: Returns true iff the dtype belongs to the specified kind category.\n\nThe function implements the following classification rules:\n- Bool: dtype is boolean\n- SignedInteger: dtype is signed integer (int8, int16, int32, int64)\n- UnsignedInteger: dtype is unsigned integer (uint8, uint16, uint32, uint64)\n- Integral: dtype is any integer type (signed or unsigned)\n- RealFloating: dtype is real floating point (float16, float32, float64)\n- ComplexFloating: dtype is complex floating point (complex64, complex128)\n- Numeric: dtype is any numeric type (bool, integers, floats, complex)\n\n/* NumPy data type representation */\n\n/* Boolean data type */\n\n/* 8-bit signed integer */\n\n/* 16-bit signed integer */\n\n/* 32-bit signed integer */\n\n/* 64-bit signed integer */\n\n/* 8-bit unsigned integer */\n\n/* 16-bit unsigned integer */\n\n/* 32-bit unsigned integer */\n\n/* 64-bit unsigned integer */\n\n/* 16-bit floating point */\n\n/* 32-bit floating point */\n\n/* 64-bit floating point */\n\n/* 64-bit complex number */\n\n/* 128-bit complex number */\n\n/* NumPy data type kind categories */\n\n/* Boolean kind */\n\n/* Signed integer kind */\n\n/* Unsigned integer kind */\n\n/* Any integer kind (signed or unsigned) */\n\n/* Real floating point kind */\n\n/* Complex floating point kind */\n\n/* Any numeric kind */\n\n/* Get the fundamental kind of a NumPy dtype */\n\n/* Check if a NumPy dtype belongs to a specific kind category */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n#[derive(PartialEq, Eq)]\npub enum NumpyDType {\n\n    Bool,\n\n    Int8,\n\n    Int16,\n\n    Int32,\n\n    Int64,\n\n    UInt8,\n\n    UInt16,\n\n    UInt32,\n\n    UInt64,\n\n    Float16,\n\n    Float32,\n\n    Float64,\n\n    Complex64,\n\n    Complex128,\n}\n\n#[derive(PartialEq, Eq)]\npub enum DTypeKind {\n\n    Bool,\n\n    SignedInteger,\n\n    UnsignedInteger,\n\n    Integral,\n\n    RealFloating,\n\n    ComplexFloating,\n\n    Numeric,\n}\n\nspec fn get_dtype_kind(dtype: NumpyDType) -> DTypeKind {\n    match dtype {\n        NumpyDType::Bool => DTypeKind::Bool,\n        NumpyDType::Int8 | NumpyDType::Int16 | NumpyDType::Int32 | NumpyDType::Int64 => DTypeKind::SignedInteger,\n        NumpyDType::UInt8 | NumpyDType::UInt16 | NumpyDType::UInt32 | NumpyDType::UInt64 => DTypeKind::UnsignedInteger,\n        NumpyDType::Float16 | NumpyDType::Float32 | NumpyDType::Float64 => DTypeKind::RealFloating,\n        NumpyDType::Complex64 | NumpyDType::Complex128 => DTypeKind::ComplexFloating,\n    }\n}\n\nspec fn is_of_kind(dtype: NumpyDType, kind: DTypeKind) -> bool {\n    match kind {\n        DTypeKind::Bool => get_dtype_kind(dtype) == DTypeKind::Bool,\n        DTypeKind::SignedInteger => get_dtype_kind(dtype) == DTypeKind::SignedInteger,\n        DTypeKind::UnsignedInteger => get_dtype_kind(dtype) == DTypeKind::UnsignedInteger,\n        DTypeKind::Integral => get_dtype_kind(dtype) == DTypeKind::SignedInteger || get_dtype_kind(dtype) == DTypeKind::UnsignedInteger,\n        DTypeKind::RealFloating => get_dtype_kind(dtype) == DTypeKind::RealFloating,\n        DTypeKind::ComplexFloating => get_dtype_kind(dtype) == DTypeKind::ComplexFloating,\n        DTypeKind::Numeric => get_dtype_kind(dtype) == DTypeKind::Bool || \n                             get_dtype_kind(dtype) == DTypeKind::SignedInteger || \n                             get_dtype_kind(dtype) == DTypeKind::UnsignedInteger || \n                             get_dtype_kind(dtype) == DTypeKind::RealFloating || \n                             get_dtype_kind(dtype) == DTypeKind::ComplexFloating,\n    }\n}", "vc-helpers": "", "vc-spec": "fn numpy_isdtype(dtype: NumpyDType, kind: DTypeKind) -> (result: bool)\n    ensures result == is_of_kind(dtype, kind)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "data_type_routines_issctype", "vc-description": "Determines whether the given object represents a scalar data-type\n\n/* Represents different kinds of data types that can be tested */\n\n/* Scalar integer type */\n\n/* Scalar floating point type */\n\n/* Scalar complex number type */\n\n/* Scalar boolean type */\n\n/* Scalar string type */\n\n/* Array type */\n\n/* Composite type */\n\n/* Unknown type */\n\n/* Helper function to check if a DataType is a scalar type */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nenum DataType {\n\n    ScalarInt,\n\n    ScalarFloat,\n\n    ScalarComplex,\n\n    ScalarBool,\n\n    ScalarString,\n\n    ArrayType,\n\n    CompositeType,\n\n    UnknownType,\n}\n\nspec fn is_scalar_type(dt: DataType) -> bool {\n    match dt {\n        DataType::ScalarInt => true,\n        DataType::ScalarFloat => true,\n        DataType::ScalarComplex => true,\n        DataType::ScalarBool => true,\n        DataType::ScalarString => true,\n        DataType::ArrayType => false,\n        DataType::CompositeType => false,\n        DataType::UnknownType => false,\n    }\n}", "vc-helpers": "", "vc-spec": "fn issctype(rep: DataType) -> (result: bool)\n    ensures result == (rep == DataType::ScalarInt || \n                      rep == DataType::ScalarFloat || \n                      rep == DataType::ScalarComplex || \n                      rep == DataType::ScalarBool || \n                      rep == DataType::ScalarString)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "data_type_routines_issubclass_", "vc-description": "numpy.issubclass_: Determine if a class is a subclass of a second class.\n\nThis function is equivalent to the Python built-in issubclass, except that it returns \nFalse instead of raising a TypeError if one of the arguments is not a class.\n\nIn the context of NumPy, this tests relationships between NumPy data type classes\nsuch as whether int32 is a subclass of integer, or whether float64 is a subclass of float.\n\nSpecification: issubclass_ correctly determines class hierarchy relationships.\n\nThis function tests whether arg1 is a subclass of arg2 according to NumPy's type\nhierarchy. The specification ensures that:\n1. The function respects the established type hierarchy (e.g., int32 ⊆ integer ⊆ number ⊆ scalar)\n2. It handles reflexivity correctly (every class is a subclass of itself)\n3. It returns False for unrelated classes\n4. It never raises exceptions (returns False instead of error for invalid inputs)\n\nPrecondition: True (no special preconditions, handles all inputs gracefully)\nPostcondition: Returns True if arg1 is a subclass of arg2, False otherwise\n\n/* Represents a NumPy type class for hierarchy testing */\n\n/* Integer types */\n\n/* Floating point types */\n\n/* Complex number types */\n\n/* Boolean type */\n\n/* Scalar types (superclass of all numeric types) */\n\n/* Number types (excludes boolean) */\n\n/* Inexact types (floating and complex) */\n\n/* 8-bit signed integer type */\n\n/* 16-bit signed integer type */\n\n/* 32-bit signed integer type */\n\n/* 64-bit signed integer type */\n\n/* 8-bit unsigned integer type */\n\n/* 16-bit unsigned integer type */\n\n/* 32-bit unsigned integer type */\n\n/* 64-bit unsigned integer type */\n\n/* 32-bit floating point type */\n\n/* 64-bit floating point type */\n\n/* 64-bit complex number type */\n\n/* 128-bit complex number type */\n\n/* Generic object type */\n\n/* Defines the class hierarchy relationships for NumPy types */\n\n/* Reflexivity: every class is a subclass of itself */\n\n/* Concrete integer types are subclasses of IntegerType */\n\n/* Concrete floating types are subclasses of FloatingType */\n\n/* Concrete complex types are subclasses of ComplexType */\n\n/* Integer types are subclasses of NumberType */\n\n/* Floating types are subclasses of InexactType and NumberType */\n\n/* Complex types are subclasses of InexactType and NumberType */\n\n/* All numeric types are subclasses of ScalarType */\n\n/* Default case */\n\n/* Result matches the defined hierarchy */\n\n/* Reflexivity: every class is a subclass of itself */\n\n/* Concrete examples from NumPy documentation */\n\n/* Transitivity: int32 → integer → number → scalar */\n\n/* All numeric types are subclasses of ScalarType */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n#[derive(PartialEq, Eq)]\nenum NumpyTypeClass {\n\n    IntegerType,\n\n    FloatingType,\n\n    ComplexType,\n\n    BooleanType,\n\n    ScalarType,\n\n    NumberType,\n\n    InexactType,\n\n    Int8Type,\n\n    Int16Type,\n\n    Int32Type,\n\n    Int64Type,\n\n    UInt8Type,\n\n    UInt16Type,\n\n    UInt32Type,\n\n    UInt64Type,\n\n    Float32Type,\n\n    Float64Type,\n\n    Complex64Type,\n\n    Complex128Type,\n\n    ObjectType,\n}\n\nspec fn is_subclass_spec(t: NumpyTypeClass, t_prime: NumpyTypeClass) -> bool {\n\n    if t == t_prime {\n        true\n    } else {\n        match (t, t_prime) {\n\n            (NumpyTypeClass::Int8Type, NumpyTypeClass::IntegerType) => true,\n            (NumpyTypeClass::Int16Type, NumpyTypeClass::IntegerType) => true,\n            (NumpyTypeClass::Int32Type, NumpyTypeClass::IntegerType) => true,\n            (NumpyTypeClass::Int64Type, NumpyTypeClass::IntegerType) => true,\n            (NumpyTypeClass::UInt8Type, NumpyTypeClass::IntegerType) => true,\n            (NumpyTypeClass::UInt16Type, NumpyTypeClass::IntegerType) => true,\n            (NumpyTypeClass::UInt32Type, NumpyTypeClass::IntegerType) => true,\n            (NumpyTypeClass::UInt64Type, NumpyTypeClass::IntegerType) => true,\n\n            (NumpyTypeClass::Float32Type, NumpyTypeClass::FloatingType) => true,\n            (NumpyTypeClass::Float64Type, NumpyTypeClass::FloatingType) => true,\n\n            (NumpyTypeClass::Complex64Type, NumpyTypeClass::ComplexType) => true,\n            (NumpyTypeClass::Complex128Type, NumpyTypeClass::ComplexType) => true,\n\n            (NumpyTypeClass::IntegerType, NumpyTypeClass::NumberType) => true,\n\n            (NumpyTypeClass::FloatingType, NumpyTypeClass::InexactType) => true,\n            (NumpyTypeClass::FloatingType, NumpyTypeClass::NumberType) => true,\n\n            (NumpyTypeClass::ComplexType, NumpyTypeClass::InexactType) => true,\n            (NumpyTypeClass::ComplexType, NumpyTypeClass::NumberType) => true,\n\n            (NumpyTypeClass::NumberType, NumpyTypeClass::ScalarType) => true,\n            (NumpyTypeClass::BooleanType, NumpyTypeClass::ScalarType) => true,\n            (NumpyTypeClass::IntegerType, NumpyTypeClass::ScalarType) => true,\n            (NumpyTypeClass::FloatingType, NumpyTypeClass::ScalarType) => true,\n            (NumpyTypeClass::ComplexType, NumpyTypeClass::ScalarType) => true,\n            (NumpyTypeClass::InexactType, NumpyTypeClass::ScalarType) => true,\n\n            _ => false,\n        }\n    }\n}", "vc-helpers": "", "vc-spec": "fn issubclass_(arg1: NumpyTypeClass, arg2: NumpyTypeClass) -> (result: bool)\n    ensures\n\n        result == is_subclass_spec(arg1, arg2),\n\n        (arg1 == arg2) ==> (result == true),\n\n        (arg1 == NumpyTypeClass::Int32Type && arg2 == NumpyTypeClass::IntegerType) ==> (result == true),\n        (arg1 == NumpyTypeClass::Float64Type && arg2 == NumpyTypeClass::FloatingType) ==> (result == true),\n        (arg1 == NumpyTypeClass::Int32Type && arg2 == NumpyTypeClass::FloatingType) ==> (result == false),\n\n        (arg1 == NumpyTypeClass::Int32Type && arg2 == NumpyTypeClass::NumberType) ==> \n         (is_subclass_spec(NumpyTypeClass::Int32Type, NumpyTypeClass::IntegerType) &&\n          is_subclass_spec(NumpyTypeClass::IntegerType, NumpyTypeClass::NumberType)),\n\n        (arg1 == NumpyTypeClass::IntegerType && arg2 == NumpyTypeClass::ScalarType) ==> (result == true),\n        (arg1 == NumpyTypeClass::FloatingType && arg2 == NumpyTypeClass::ScalarType) ==> (result == true),\n        (arg1 == NumpyTypeClass::ComplexType && arg2 == NumpyTypeClass::ScalarType) ==> (result == true)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "data_type_routines_issubdtype", "vc-description": "numpy.issubdtype: Returns True if first argument is a typecode lower/equal in type hierarchy.\n\nThis function checks if the first data type is a subtype of the second data type\nin the NumPy type hierarchy. It's similar to Python's built-in issubclass but\noperates on NumPy data types.\n\nThe function implements the NumPy type hierarchy where types are organized\nin a tree structure with 'generic' at the root.\n\nSpecification: issubdtype returns True if arg1 is a subtype of arg2 in the NumPy type hierarchy.\n\nPrecondition: True (works with any valid NumPy data types)\nPostcondition: The result is True if and only if arg1 is a subtype of arg2 \naccording to the NumPy type hierarchy rules.\n\nKey properties:\n1. Reflexivity: Every type is a subtype of itself\n2. Transitivity: If A is subtype of B and B is subtype of C, then A is subtype of C\n3. Hierarchy rules: Specific types are subtypes of their parent categories\n4. Root type: All types are subtypes of 'generic'\n\n/* Define a NumPy-like type hierarchy representing the data type system in NumPy */\n\n/* Generic root type */\n\n/* Inexact numeric type */\n\n/* Floating point type */\n\n/* 32-bit floating point */\n\n/* 64-bit floating point */\n\n/* Numeric type */\n\n/* Integer type */\n\n/* Signed integer type */\n\n/* 8-bit signed integer */\n\n/* 16-bit signed integer */\n\n/* 32-bit signed integer */\n\n/* 64-bit signed integer */\n\n/* Unsigned integer type */\n\n/* 8-bit unsigned integer */\n\n/* 16-bit unsigned integer */\n\n/* 32-bit unsigned integer */\n\n/* 64-bit unsigned integer */\n\n/* Character type */\n\n/* Bytes type */\n\n/* String type */\n\n/* Boolean type */\n\n/* Define the subtype relation for NumPy types */\n\n/* Float hierarchy */\n\n/* Integer hierarchy */\n\n/* Character hierarchy */\n\n/* Boolean hierarchy */\n\n/* Number hierarchy */\n\n/* Reflexivity property */\n\n/* Generic is supertype of all types */\n\n/* Specific hierarchy rules */\n\n/* Non-subtype examples */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\npub enum NumpyDType {\n\n    Generic,\n\n    Inexact(Box<NumpyDType>),\n\n    Floating(Box<NumpyDType>),\n\n    Float32,\n\n    Float64,\n\n    Number(Box<NumpyDType>),\n\n    Integer(Box<NumpyDType>),\n\n    SignedInteger(Box<NumpyDType>),\n\n    Int8,\n\n    Int16,\n\n    Int32,\n\n    Int64,\n\n    UnsignedInteger(Box<NumpyDType>),\n\n    UInt8,\n\n    UInt16,\n\n    UInt32,\n\n    UInt64,\n\n    Character(Box<NumpyDType>),\n\n    Bytes_,\n\n    Str_,\n\n    Bool_,\n}\n\nspec fn is_sub_dtype_spec(dtype1: NumpyDType, dtype2: NumpyDType) -> bool {\n    if dtype1 == dtype2 {\n        true\n    } else {\n        match (dtype1, dtype2) {\n\n            (NumpyDType::Float32, NumpyDType::Floating(_)) => true,\n            (NumpyDType::Float64, NumpyDType::Floating(_)) => true,\n            (NumpyDType::Floating(_), NumpyDType::Inexact(_)) => true,\n            (NumpyDType::Floating(_), NumpyDType::Number(_)) => true,\n            (NumpyDType::Floating(_), NumpyDType::Generic) => true,\n\n            (NumpyDType::Int8, NumpyDType::SignedInteger(_)) => true,\n            (NumpyDType::Int16, NumpyDType::SignedInteger(_)) => true,\n            (NumpyDType::Int32, NumpyDType::SignedInteger(_)) => true,\n            (NumpyDType::Int64, NumpyDType::SignedInteger(_)) => true,\n            (NumpyDType::UInt8, NumpyDType::UnsignedInteger(_)) => true,\n            (NumpyDType::UInt16, NumpyDType::UnsignedInteger(_)) => true,\n            (NumpyDType::UInt32, NumpyDType::UnsignedInteger(_)) => true,\n            (NumpyDType::UInt64, NumpyDType::UnsignedInteger(_)) => true,\n            (NumpyDType::SignedInteger(_), NumpyDType::Integer(_)) => true,\n            (NumpyDType::UnsignedInteger(_), NumpyDType::Integer(_)) => true,\n            (NumpyDType::Integer(_), NumpyDType::Number(_)) => true,\n            (NumpyDType::Integer(_), NumpyDType::Generic) => true,\n\n            (NumpyDType::Str_, NumpyDType::Character(_)) => true,\n            (NumpyDType::Bytes_, NumpyDType::Character(_)) => true,\n            (NumpyDType::Character(_), NumpyDType::Generic) => true,\n\n            (NumpyDType::Bool_, NumpyDType::Generic) => true,\n\n            (NumpyDType::Number(_), NumpyDType::Generic) => true,\n            (NumpyDType::Inexact(_), NumpyDType::Generic) => true,\n            _ => false,\n        }\n    }\n}", "vc-helpers": "", "vc-spec": "fn issubdtype(arg1: NumpyDType, arg2: NumpyDType) -> (result: bool)\n    ensures \n        result == is_sub_dtype_spec(arg1, arg2) &&\n\n        (arg1 == arg2 ==> result == true) &&\n\n        (arg2 == NumpyDType::Generic ==> result == true) &&\n\n        (arg1 == NumpyDType::Float32 && matches!(arg2, NumpyDType::Floating(_)) ==> result == true) &&\n        (arg1 == NumpyDType::Float64 && matches!(arg2, NumpyDType::Floating(_)) ==> result == true) &&\n        (arg1 == NumpyDType::Int32 && matches!(arg2, NumpyDType::SignedInteger(_)) ==> result == true) &&\n        (arg1 == NumpyDType::UInt32 && matches!(arg2, NumpyDType::UnsignedInteger(_)) ==> result == true) &&\n\n        (arg1 == NumpyDType::Float32 && arg2 == NumpyDType::Float64 ==> result == false) &&\n        (arg1 == NumpyDType::Float64 && arg2 == NumpyDType::Float32 ==> result == false) &&\n        (arg1 == NumpyDType::Int32 && matches!(arg2, NumpyDType::Floating(_)) ==> result == false)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "data_type_routines_maximum_sctype", "vc-description": "Return the scalar type of highest precision of the same kind as the input.\n\nThis function implements numpy.maximum_sctype functionality, which takes a numeric type\nand returns the highest precision type of the same kind. For example, int8 becomes int64,\nfloat32 becomes float128, complex64 becomes complex256.\n\n/* Define a type hierarchy for numeric types */\n\n/* Signed integer types */\n\n/* Unsigned integer types */\n\n/* Floating point types */\n\n/* Complex number types */\n\n/* String types */\n\n/* Boolean types */\n\n/* Define precision levels for each kind */\n\n/* 8-bit precision */\n\n/* 16-bit precision */\n\n/* 32-bit precision */\n\n/* 64-bit precision */\n\n/* 128-bit precision */\n\n/* 256-bit precision */\n\n/* A numeric type representation */\n\n/* The kind of numeric type */\n\n/* The precision level */\n\n/* Define the maximum precision for each kind */\n\n// Represents max string length handling\n\n/* Define precision ordering */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n#[derive(PartialEq, Eq, Structural)]\nenum NumericKind {\n\n    Integer,\n\n    UnsignedInteger,\n\n    Float,\n\n    Complex,\n\n    String,\n\n    Boolean,\n}\n\n#[derive(PartialEq, Eq, Structural)]\nenum Precision {\n\n    P8,\n\n    P16,\n\n    P32,\n\n    P64,\n\n    P128,\n\n    P256,\n}\n\n#[derive(PartialEq, Eq, Structural)]\nstruct NumericType {\n\n    kind: NumericKind,\n\n    precision: Precision,\n}\n\nspec fn max_precision_for(kind: NumericKind) -> Precision {\n    match kind {\n        NumericKind::Integer => Precision::P64,\n        NumericKind::UnsignedInteger => Precision::P64,\n        NumericKind::Float => Precision::P128,\n        NumericKind::Complex => Precision::P256,\n        NumericKind::String => Precision::P64,\n        NumericKind::Boolean => Precision::P8,\n    }\n}\n\nspec fn precision_le(p1: Precision, p2: Precision) -> bool {\n    match (p1, p2) {\n        (Precision::P8, _) => true,\n        (Precision::P16, Precision::P8) => false,\n        (Precision::P16, _) => true,\n        (Precision::P32, Precision::P8) => false,\n        (Precision::P32, Precision::P16) => false,\n        (Precision::P32, _) => true,\n        (Precision::P64, Precision::P8) => false,\n        (Precision::P64, Precision::P16) => false,\n        (Precision::P64, Precision::P32) => false,\n        (Precision::P64, _) => true,\n        (Precision::P128, Precision::P256) => true,\n        (Precision::P128, _) => false,\n        (Precision::P256, _) => false,\n    }\n}", "vc-helpers": "", "vc-spec": "fn maximum_sctype(t: NumericType) -> (result: NumericType)\n    ensures \n        result.kind == t.kind &&\n        result.precision == max_precision_for(t.kind) &&\n        precision_le(t.precision, result.precision)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "data_type_routines_may_share_memory", "vc-description": "numpy.may_share_memory: Determine if two arrays might share memory.\n\nThis function conservatively checks if two arrays might share memory.\nA return of True does not necessarily mean that the two arrays share any element.\nIt just means that they might.\n\nOnly the memory bounds of a and b are checked by default.\n\nSpecification: may_share_memory returns a boolean indicating whether two arrays might share memory.\n\nPrecondition: True (no special preconditions needed)\nPostcondition: The function returns a boolean value. If the arrays are identical references,\nit must return True. For independent arrays, it may return False.\nThe function is conservative - it can return True even when arrays don't actually share memory.\n\n/* Basic sanity check: result is a boolean */\n\n/* Conservative property: function is sound - may return True even when arrays don't share memory */\n\n/* but will detect potential memory overlap based on bounds analysis */\n\n/* Deterministic property: same inputs always produce same output */\n\n/* Reflexive property: an array compared with itself would return consistent result */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn may_share_memory(a: &Vec<f32>, b: &Vec<f32>) -> (result: bool)\n    ensures\n\n        (result == true || result == false) &&\n\n        (result == true ==> true) &&\n\n        true &&\n\n        true", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "data_type_routines_mintypecode", "vc-description": "Return the character for the minimum-size type to which given types can be safely cast\n\n/* NumPy type character to precedence mapping based on the default typeset 'GDFgdf'\n   Lower values indicate higher precedence (smaller/more restrictive types) */\n\n// longdouble (most restrictive in numerical sense)\n\n// double\n\n// float\n\n// csingle (complex float)\n\n// cdouble (complex double)\n\n// clongdouble (complex long double)\n\n// other types (lowest precedence)\n\n/* Check if a type character is in the given typeset */\n\n/* Filter characters that are in the typeset */\n\n/* Find minimum precedence character in a sequence */\n\n// default fallback\n\n// Case 1: No input types in typeset - return default\n\n// Case 2 & 3: When intersection is non-empty\n\n// Special rule - if both 'F' and 'd' are in intersection, return 'D'\n\n// Normal case - return minimum precedence type from intersection\n\n// Validity: result is either from intersection or default", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn typechar_precedence(c: char) -> nat {\n    match c {\n        'g' => 0,\n        'd' => 1,\n        'f' => 2,\n        'F' => 3,\n        'D' => 4,\n        'G' => 5,\n        _   => 6,\n    }\n}\n\nspec fn char_in_typeset(c: char, typeset: Seq<char>) -> bool {\n    typeset.contains(c)\n}\n\nspec fn filter_chars_in_typeset(typechars: Seq<char>, typeset: Seq<char>) -> Seq<char> {\n    typechars.filter(|c: char| char_in_typeset(c, typeset))\n}\n\nspec fn min_precedence_char(chars: Seq<char>) -> char\n    decreases chars.len()\n{\n    if chars.len() == 0 {\n        'G'\n    } else if chars.len() == 1 {\n        chars[0]\n    } else {\n        let first = chars[0];\n        let rest_min = min_precedence_char(chars.skip(1));\n        if typechar_precedence(first) <= typechar_precedence(rest_min) {\n            first\n        } else {\n            rest_min\n        }\n    }\n}", "vc-helpers": "", "vc-spec": "fn mintypecode(typechars: Vec<char>, typeset: Vec<char>, default: char) -> (result: char)\n    requires typeset@ == seq!['G', 'D', 'F', 'g', 'd', 'f'],\n    ensures ({\n        let intersection = filter_chars_in_typeset(typechars@, typeset@);\n\n        (intersection.len() == 0 ==> result == default) &&\n\n        (intersection.len() > 0 ==> {\n\n            if intersection.contains('F') && intersection.contains('d') {\n                result == 'D'\n            } else {\n\n                intersection.contains(result) &&\n                (forall|c: char| intersection.contains(c) ==> typechar_precedence(result) <= typechar_precedence(c))\n            }\n        }) &&\n\n        (intersection.contains(result) || result == default)\n    })", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "data_type_routines_obj2sctype", "vc-description": "numpy.obj2sctype: Return the scalar dtype or NumPy equivalent of Python type of an object.\n\nTakes any object and returns its corresponding NumPy scalar data type.\nIf the object's type cannot be determined, returns the default value if provided,\notherwise returns none.\n\nThis function performs type introspection to determine the appropriate NumPy\nscalar type for any given object, including arrays, scalars, and generic objects.\n\nSpecification: obj2sctype returns the appropriate NumPy scalar type for the input object.\n\nThe function correctly identifies:\n1. Scalar types from their corresponding objects\n2. Array element types from array objects\n3. Generic object types\n4. Returns default for unrecognized types\n5. Returns none when no default is provided for unrecognized types\n\nPrecondition: True (works with any object)\nPostcondition: The result correctly represents the scalar type of the input object\n\n/* NumPy scalar data types represented as an enum */\n\n/* Object representation for type introspection */\n\n/* Helper predicate: Check if object matches given scalar type */\n\n/* Helper predicate: Check if object is an array with given element type */\n\n/* Helper predicate: Check if object is a generic object */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n#[derive(PartialEq, Eq)]\npub enum NumpyScalarType {\n    Int32,\n    Int64,\n    Float32,\n    Float64,\n    Complex64,\n    Complex128,\n    Object,\n    String,\n    Bool,\n}\n\npub enum NumpyObject {\n    IntVal(i64),\n    FloatVal(f64),\n    ArrayInt(Vec<i64>),\n    ArrayFloat(Vec<f64>),\n    ArrayComplex(Vec<(f64, f64)>),\n    GenericObj,\n    StringVal(String),\n    BoolVal(bool),\n}\n\npub open spec fn matches_scalar_type(obj: NumpyObject, dtype: NumpyScalarType) -> bool {\n    match (obj, dtype) {\n        (NumpyObject::IntVal(_), NumpyScalarType::Int64) => true,\n        (NumpyObject::FloatVal(_), NumpyScalarType::Float64) => true,\n        (NumpyObject::StringVal(_), NumpyScalarType::String) => true,\n        (NumpyObject::BoolVal(_), NumpyScalarType::Bool) => true,\n        _ => false,\n    }\n}\n\npub open spec fn is_array_with_element_type(obj: NumpyObject, dtype: NumpyScalarType) -> bool {\n    match (obj, dtype) {\n        (NumpyObject::ArrayInt(_), NumpyScalarType::Int64) => true,\n        (NumpyObject::ArrayFloat(_), NumpyScalarType::Float64) => true,\n        (NumpyObject::ArrayComplex(_), NumpyScalarType::Complex128) => true,\n        _ => false,\n    }\n}\n\npub open spec fn is_generic_object(obj: NumpyObject) -> bool {\n    match obj {\n        NumpyObject::GenericObj => true,\n        _ => false,\n    }\n}", "vc-helpers": "", "vc-spec": "fn obj2sctype(rep: NumpyObject, default: Option<NumpyScalarType>) -> (result: Option<NumpyScalarType>)\n    ensures\n        match rep {\n            NumpyObject::IntVal(_) => result == Some(NumpyScalarType::Int64),\n            NumpyObject::FloatVal(_) => result == Some(NumpyScalarType::Float64),\n            NumpyObject::ArrayInt(_) => result == Some(NumpyScalarType::Int64),\n            NumpyObject::ArrayFloat(_) => result == Some(NumpyScalarType::Float64),\n            NumpyObject::ArrayComplex(_) => result == Some(NumpyScalarType::Complex128),\n            NumpyObject::StringVal(_) => result == Some(NumpyScalarType::String),\n            NumpyObject::BoolVal(_) => result == Some(NumpyScalarType::Bool),\n            NumpyObject::GenericObj => result == default,\n        },\n        match result {\n            Some(dtype) => \n                matches_scalar_type(rep, dtype) || \n                is_array_with_element_type(rep, dtype) ||\n                (is_generic_object(rep) && result == default),\n            None => is_generic_object(rep) && default.is_None(),\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "data_type_routines_promote_types", "vc-description": "numpy.promote_types: Returns the data type with the smallest size and smallest scalar kind to which both type1 and type2 may be safely cast. This function is symmetric but rarely associative. It returns a \"canonical\" dtype. Examples from NumPy documentation: promote_types('f4', 'f8') = 'f8' (float64), promote_types('i8', 'f4') = 'f8' (float64), promote_types('i4', 'S8') = 'S11' (string, but we focus on numeric types). Specification: promote_types returns the smallest safe common type for two dtypes. Key properties based on NumPy's type promotion rules: 1. Symmetry: promote_types(a, b) = promote_types(b, a), 2. Safety: Both input types can be safely cast to the result type, 3. Minimality: The result is the smallest type that satisfies the safety requirement, 4. Type promotion hierarchy: If either input is complex, result is complex; If either input is float, result is float (unless both are complex); Signed integers promote to larger signed integers; Unsigned integers promote to larger unsigned integers; Mixed signed/unsigned promote to signed of sufficient size, 5. Size consideration: Result has size >= max(size(type1), size(type2)), 6. Specific examples: Float32 + Float64 → Float64 (larger precision); Int64 + Float32 → Float64 (float with sufficient precision); Complex64 + Float32 → Complex64 (complex dominates).\n\n/* Symmetry property - function is commutative */\n\n/* Type promotion hierarchy rules */\n\n/* If either input is complex, result must be complex */\n\n/* If either input is float (and not complex), result is float or complex */\n\n/* Size constraint: result size >= max of input sizes */\n\n/* Promotion hierarchy: result rank >= max of input ranks */\n\n/* Same types promote to themselves (reflexivity) */\n\n/* Float precision promotion */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n#[derive(Copy, Clone, PartialEq, Eq)]\npub enum NumpyDType {\n    UInt8,\n    UInt16,\n    UInt32,\n    UInt64,\n    Int8,\n    Int16,\n    Int32,\n    Int64,\n    Float16,\n    Float32,\n    Float64,\n    Complex64,\n    Complex128,\n}\n\nspec fn dtype_size(dt: NumpyDType) -> nat {\n    match dt {\n        NumpyDType::UInt8 => 8,\n        NumpyDType::UInt16 => 16,\n        NumpyDType::UInt32 => 32,\n        NumpyDType::UInt64 => 64,\n        NumpyDType::Int8 => 8,\n        NumpyDType::Int16 => 16,\n        NumpyDType::Int32 => 32,\n        NumpyDType::Int64 => 64,\n        NumpyDType::Float16 => 16,\n        NumpyDType::Float32 => 32,\n        NumpyDType::Float64 => 64,\n        NumpyDType::Complex64 => 64,\n        NumpyDType::Complex128 => 128,\n    }\n}\n\nspec fn promotion_hierarchy(dt: NumpyDType) -> nat {\n    match dt {\n        NumpyDType::UInt8 => 0,\n        NumpyDType::UInt16 => 1,\n        NumpyDType::UInt32 => 2,\n        NumpyDType::UInt64 => 3,\n        NumpyDType::Int8 => 4,\n        NumpyDType::Int16 => 5,\n        NumpyDType::Int32 => 6,\n        NumpyDType::Int64 => 7,\n        NumpyDType::Float16 => 8,\n        NumpyDType::Float32 => 9,\n        NumpyDType::Float64 => 10,\n        NumpyDType::Complex64 => 11,\n        NumpyDType::Complex128 => 12,\n    }\n}\n\nspec fn is_signed_integer(dt: NumpyDType) -> bool {\n    match dt {\n        NumpyDType::Int8 | NumpyDType::Int16 | NumpyDType::Int32 | NumpyDType::Int64 => true,\n        _ => false,\n    }\n}\n\nspec fn is_unsigned_integer(dt: NumpyDType) -> bool {\n    match dt {\n        NumpyDType::UInt8 | NumpyDType::UInt16 | NumpyDType::UInt32 | NumpyDType::UInt64 => true,\n        _ => false,\n    }\n}\n\nspec fn is_float(dt: NumpyDType) -> bool {\n    match dt {\n        NumpyDType::Float16 | NumpyDType::Float32 | NumpyDType::Float64 => true,\n        _ => false,\n    }\n}\n\nspec fn is_complex(dt: NumpyDType) -> bool {\n    match dt {\n        NumpyDType::Complex64 | NumpyDType::Complex128 => true,\n        _ => false,\n    }\n}", "vc-helpers": "", "vc-spec": "spec fn promote_types_spec(type1: NumpyDType, type2: NumpyDType) -> NumpyDType;\n\nfn promote_types(type1: NumpyDType, type2: NumpyDType) -> (result: NumpyDType)\n    ensures\n        result == promote_types_spec(type1, type2),\n\n        promote_types_spec(type1, type2) == promote_types_spec(type2, type1),\n\n        (is_complex(type1) || is_complex(type2)) ==> is_complex(result),\n\n        (is_float(type1) || is_float(type2)) ==> (is_float(result) || is_complex(result)),\n\n        dtype_size(result) >= if dtype_size(type1) >= dtype_size(type2) { dtype_size(type1) } else { dtype_size(type2) },\n\n        promotion_hierarchy(result) >= if promotion_hierarchy(type1) >= promotion_hierarchy(type2) { promotion_hierarchy(type1) } else { promotion_hierarchy(type2) },\n\n        (type1 == type2) ==> (result == type1),\n\n        (is_float(type1) && is_float(type2)) ==> (\n            is_float(result) && dtype_size(result) >= if dtype_size(type1) >= dtype_size(type2) { dtype_size(type1) } else { dtype_size(type2) }\n        ),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "data_type_routines_result_type", "vc-description": "Returns the data type that results from applying NumPy type promotion rules to the arguments. \n\nType promotion in NumPy works similarly to the rules in languages like C++, with some differences. When both scalars and arrays are used, the array's type takes precedence and the scalar's actual value is considered.\n\nThe function takes operands of some operation and returns the result type according to NumPy's type promotion hierarchy.\n\n/* Define NumPy data types for type promotion */\n\n/* 8-bit signed integer */\n\n/* 16-bit signed integer */\n\n/* 32-bit signed integer */\n\n/* 64-bit signed integer */\n\n/* 32-bit floating point */\n\n/* 64-bit floating point */\n\n/* 64-bit complex number */\n\n/* 128-bit complex number */\n\n/* Boolean type */\n\n/* Define type promotion hierarchy (higher number = higher precedence) */\n\n/* Define operand types (either scalar or array) */\n\n/* Scalar value with data type */\n\n/* Array with data type and vector of values */\n\n/* Extract the data type from an operand */\n\n/* Type promotion function for two types */\n\n/* The result type is at least as high in the hierarchy as any input type */\n\n/* The result type is the minimum type that can represent all inputs */\n\n/* Type promotion follows the standard hierarchy */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n#[derive(PartialEq, Eq, Structural)]\npub enum NumpyDType {\n\n    Int8,\n\n    Int16,\n\n    Int32,\n\n    Int64,\n\n    Float32,\n\n    Float64,\n\n    Complex64,\n\n    Complex128,\n\n    Bool,\n}\n\nspec fn type_rank(dtype: NumpyDType) -> nat {\n    match dtype {\n        NumpyDType::Bool => 0,\n        NumpyDType::Int8 => 1,\n        NumpyDType::Int16 => 2,\n        NumpyDType::Int32 => 3,\n        NumpyDType::Int64 => 4,\n        NumpyDType::Float32 => 5,\n        NumpyDType::Float64 => 6,\n        NumpyDType::Complex64 => 7,\n        NumpyDType::Complex128 => 8,\n    }\n}\n\npub enum NumpyOperand {\n\n    Scalar(NumpyDType),\n\n    Array(NumpyDType, Vec<i32>),\n}\n\nspec fn operand_type(operand: NumpyOperand) -> NumpyDType {\n    match operand {\n        NumpyOperand::Scalar(dtype) => dtype,\n        NumpyOperand::Array(dtype, _) => dtype,\n    }\n}\n\nspec fn promote_types(t1: NumpyDType, t2: NumpyDType) -> NumpyDType {\n    if type_rank(t1) >= type_rank(t2) { t1 } else { t2 }\n}", "vc-helpers": "", "vc-spec": "fn result_type(operands: Vec<NumpyOperand>) -> (result: NumpyDType)\n    requires operands.len() > 0,\n    ensures\n\n        forall|i: int| 0 <= i < operands.len() ==> \n            type_rank(result) >= type_rank(operand_type(operands[i])),\n\n        exists|i: int| 0 <= i < operands.len() && \n            type_rank(result) == type_rank(operand_type(operands[i])),\n\n        forall|i: int, j: int| 0 <= i < operands.len() && 0 <= j < operands.len() ==>\n            type_rank(result) >= type_rank(promote_types(operand_type(operands[i]), operand_type(operands[j]))),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "data_type_routines_shares_memory", "vc-description": "Determine if two arrays share memory.\n\nThis function determines if two arrays share memory by checking\nif they reference the same underlying memory locations.\n\nUnlike may_share_memory, this function provides a definitive answer\nabout memory sharing rather than a conservative estimate.\n\nThe function can be exponentially slow for some inputs due to the\ncomplexity of the overlap detection algorithm.\n\nSpecification: shares_memory returns a boolean indicating whether two arrays actually share memory.\n\nPrecondition: True (no special preconditions needed)\nPostcondition: The function returns a boolean value that accurately reflects memory sharing.\nIf the arrays are identical references, it must return True.\nIf the arrays are independent (non-overlapping memory), it must return False.\nThe function is precise - it returns True if and only if the arrays share memory.\n\n// Basic sanity check: result is a boolean - always true\n\n// Reflexive property: an array shares memory with itself when identical\n\n// Independence property: different arrays with different contents don't share memory\n\n// Precision property: the function provides definitive answers about memory sharing\n\n// Basic sanity check: result is a boolean\n\n// Reflexive property: an array shares memory with itself when identical\n\n// Precision property: the function provides definitive answers about memory sharing", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn shares_memory(a: Vec<f32>, b: Vec<f32>) -> bool\n{\n\n    true &&\n\n    (a.len() == b.len() && a@ == b@) &&\n\n    true &&\n\n    true\n}\n\nfn shares_memory_fn(a: Vec<f32>, b: Vec<f32>) -> (result: bool)\n    ensures\n\n        (result == true || result == false) &&\n\n        (a.len() == b.len() && a@ == b@ ==> result == true) &&\n\n        true", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "data_type_routines_typecodes", "vc-description": "Dictionary mapping strings to corresponding type character codes\n\nA dictionary with string keys that represent NumPy dtype categories and string values that contain type codes for the NumPy data types in each category.\n\nKeys include:\n- 'Character': 'S1'\n- 'Integer': 'bhilqnp'\n- 'UnsignedInteger': 'BHILQNP'\n- 'Float': 'fdg'\n- 'Complex': 'FDG'\n- 'AllInteger': 'bBhHiIlLqQnNpP'\n- 'AllFloat': 'fdgFDG'\n- 'Datetime': 'Mm'\n- 'All': '?bhilqnpBHILQNPfdgFDGSUVOMm'\n\nThis is useful for iterating over all dtypes of a certain kind.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn typecodes(category: &str) -> (result: Option<&str>)\n    ensures\n        (category == \"Character\") ==> (result == Some(\"S1\")),\n        (category == \"Integer\") ==> (result == Some(\"bhilqnp\")),\n        (category == \"UnsignedInteger\") ==> (result == Some(\"BHILQNP\")),\n        (category == \"Float\") ==> (result == Some(\"fdg\")),\n        (category == \"Complex\") ==> (result == Some(\"FDG\")),\n        (category == \"AllInteger\") ==> (result == Some(\"bBhHiIlLqQnNpP\")),\n        (category == \"AllFloat\") ==> (result == Some(\"fdgFDG\")),\n        (category == \"Datetime\") ==> (result == Some(\"Mm\")),\n        (category == \"All\") ==> (result == Some(\"?bhilqnpBHILQNPfdgFDGSUVOMm\")),\n        (category != \"Character\" && category != \"Integer\" && category != \"UnsignedInteger\" && \n         category != \"Float\" && category != \"Complex\" && category != \"AllInteger\" && \n         category != \"AllFloat\" && category != \"Datetime\" && category != \"All\") ==> (result == None::<&str>)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "datetime_support_datetime64", "vc-description": "Create a datetime64 object representing an offset from 1970-01-01T00:00:00\n\n{\n  \"name\": \"numpy.datetime64\",\n  \"category\": \"Datetime types\", \n  \"description\": \"Create a datetime64 object representing an offset from 1970-01-01T00:00:00\",\n  \"url\": \"https://numpy.org/doc/stable/reference/arrays.datetime.html#numpy.datetime64\",\n  \"doc\": \"If created from a 64-bit integer, it represents an offset from ``1970-01-01T00:00:00``. If created from string, the string can be in ISO 8601 date or datetime format.\\n\\nWhen parsing a string to create a datetime object, if the string contains a trailing timezone (A 'Z' or a timezone offset), the timezone will be dropped and a User Warning is given.\\n\\nDatetime64 objects should be considered to be UTC and therefore have an offset of +0000.\\n\\n>>> np.datetime64(10, 'Y')\\nnp.datetime64('1980')\\n>>> np.datetime64('1980', 'Y')\\nnp.datetime64('1980')\\n>>> np.datetime64(10, 'D')\\nnp.datetime64('1970-01-11')\\n\\nSee :ref:`arrays.datetime` for more information.\\n\\n:Character code: ``'M'``\"\n}\n\nCreate a datetime64 object from an integer offset and time unit\n\nSpecification: datetime64 creates a UTC datetime object with the specified offset and unit.\nThe datetime64 object represents a specific moment in time as an offset from the Unix epoch\n(1970-01-01T00:00:00 UTC) in the specified time unit. The function preserves the input\nparameters and ensures the result is always in UTC timezone.\n\n/* Time unit for datetime64 */\n\n/* Years unit ('Y') */\n\n/* Days unit ('D') */\n\n/* Hours unit ('h') */\n\n/* Minutes unit ('m') */\n\n/* Seconds unit ('s') */\n\n/* Milliseconds unit ('ms') */\n\n/* Microseconds unit ('us') */\n\n/* Nanoseconds unit ('ns') */\n\n/* DateTime64 structure representing offset from Unix epoch */\n\n/* Offset value from 1970-01-01T00:00:00 */\n\n/* Time unit of the offset */\n\n/* Always UTC with +0000 offset */\n\n/* Unit-specific validity constraints based on NumPy datetime64 limits */\n\n/* Valid year range */\n\n/* Days since epoch */\n\n/* Hours since epoch */\n\n/* Minutes since epoch */\n\n/* Seconds since epoch */\n\n/* Milliseconds can use full Int range */\n\n/* Microseconds can use full Int range */\n\n/* Nanoseconds can use full Int range */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\npub enum TimeUnit {\n\n    Years,\n\n    Days,\n\n    Hours,\n\n    Minutes,\n\n    Seconds,\n\n    Milliseconds,\n\n    Microseconds,\n\n    Nanoseconds,\n}\n\npub struct DateTime64 {\n\n    pub offset: i64,\n\n    pub unit: TimeUnit,\n\n    pub is_utc: bool,\n}", "vc-helpers": "", "vc-spec": "fn datetime64(offset: i64, unit: TimeUnit) -> (result: DateTime64)\n    ensures \n        result.offset == offset,\n        result.unit == unit,\n        result.is_utc == true,\n\n        match unit {\n            TimeUnit::Years => result.offset + 1970 >= 1 && result.offset + 1970 <= 9999,\n            TimeUnit::Days => result.offset >= -2147483648 && result.offset <= 2147483647,\n            TimeUnit::Hours => result.offset >= -2147483648 && result.offset <= 2147483647,\n            TimeUnit::Minutes => result.offset >= -2147483648 && result.offset <= 2147483647,\n            TimeUnit::Seconds => result.offset >= -2147483648 && result.offset <= 2147483647,\n            TimeUnit::Milliseconds => true,\n            TimeUnit::Microseconds => true,\n            TimeUnit::Nanoseconds => true,\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "datetime_support_datetime_as_string", "vc-description": "Convert an array of datetime64 values to an array of strings.\n\nConverts each datetime64 value in the input vector to its string representation.\nThe format depends on the timezone option: 'naive' produces no suffix,\n'UTC' adds 'Z' suffix, and 'local' would add timezone offset.\n\nFor simplicity, we focus on the core conversion from datetime64 to ISO format strings.\n\nSpecification: datetime_as_string converts each datetime64 to its string representation.\n\nPrecondition: True (no special preconditions)\nPostcondition: Each datetime64 is converted to a properly formatted ISO 8601 string\n\n/* Time unit for datetime64 */\n\n/* Years unit ('Y') */\n\n/* Days unit ('D') */\n\n/* Hours unit ('h') */\n\n/* Minutes unit ('m') */\n\n/* Seconds unit ('s') */\n\n/* Milliseconds unit ('ms') */\n\n/* Microseconds unit ('us') */\n\n/* Nanoseconds unit ('ns') */\n\n/* DateTime64 structure representing offset from Unix epoch */\n\n/* Offset value from 1970-01-01T00:00:00 */\n\n/* Time unit of the offset */\n\n/* Always UTC with +0000 offset */\n\n/* Timezone formatting options */\n\n/* No timezone suffix */\n\n/* Add 'Z' suffix for UTC */\n\n/* Add local timezone offset */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n#[derive(PartialEq, Eq)]\nenum TimeUnit {\n\n    Years,\n\n    Days,\n\n    Hours,\n\n    Minutes,\n\n    Seconds,\n\n    Milliseconds,\n\n    Microseconds,\n\n    Nanoseconds,\n}\n\n#[derive(PartialEq, Eq)]\nstruct DateTime64 {\n\n    offset: i64,\n\n    unit: TimeUnit,\n\n    is_utc: bool,\n}\n\n#[derive(PartialEq, Eq)]\nenum TimezoneOption {\n\n    Naive,\n\n    UTC,\n\n    Local,\n}", "vc-helpers": "", "vc-spec": "fn datetime_as_string(arr: Vec<DateTime64>, timezone: TimezoneOption) -> (result: Vec<String>)\n    requires arr.len() > 0,\n    ensures \n        result.len() == arr.len(),\n        forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i]@.len() > 0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "datetime_support_timedelta64", "vc-description": "A timedelta stored as a 64-bit integer.\n\nSee arrays.datetime for more information.\n\nCharacter code: 'm'\n\nCreate a timedelta64 object from a numeric value and time unit\n\nSpecification: timedelta64 creates a time duration object with given value and unit\n\n/* Time unit codes for timedelta64 */\n\n/* Year unit ('Y') */\n\n/* Month unit ('M') */\n\n/* Week unit ('W') */\n\n/* Day unit ('D') */\n\n/* Hour unit ('h') */\n\n/* Minute unit ('m') */\n\n/* Second unit ('s') */\n\n/* Millisecond unit ('ms') */\n\n/* Microsecond unit ('us') */\n\n/* Nanosecond unit ('ns') */\n\n/* Picosecond unit ('ps') */\n\n/* Femtosecond unit ('fs') */\n\n/* Attosecond unit ('as') */\n\n/* Represents a time duration value */\n\n/* The numeric value of the time duration */\n\n/* The time unit for the duration */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n#[derive(PartialEq, Eq, Structural)]\npub enum TimeUnit {\n\n    Year,\n\n    Month,\n\n    Week,\n\n    Day,\n\n    Hour,\n\n    Minute,\n\n    Second,\n\n    Millisecond,\n\n    Microsecond,\n\n    Nanosecond,\n\n    Picosecond,\n\n    Femtosecond,\n\n    Attosecond,\n}\n\n#[derive(PartialEq, Eq, Structural)]\npub struct TimeDelta64 {\n\n    pub value: i64,\n\n    pub unit: TimeUnit,\n}", "vc-helpers": "", "vc-spec": "fn timedelta64(value: i64, unit: TimeUnit) -> (result: TimeDelta64)\n    ensures \n        result.value == value,\n        result.unit == unit,\n        result.value >= -9223372036854775808i64,\n        result.value <= 9223372036854775807i64,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "fft_fft", "vc-description": "Compute the one-dimensional discrete Fourier Transform\n\nThe FFT computes the DFT defined as:\nX[k] = Σ(n=0 to N-1) x[n] * exp(-2πi*k*n/N)\n\nwhere:\n- x is the input vector\n- X is the output vector\n- N is the length of the vector\n- i is the imaginary unit\n\nSpecification: FFT computes the discrete Fourier transform\n\nThe FFT satisfies the DFT equation and has the following properties:\n1. Each output element is the sum of input elements weighted by complex exponentials\n2. The transform is linear\n3. Parseval's theorem: energy is preserved (with proper normalization)\n4. FFT(FFT^(-1)(x)) = x (inverse property when combined with IFFT)\n\nThe specification captures the fundamental DFT formula where each output\nelement k is computed as the sum over all input elements j, multiplied\nby the complex exponential exp(-2πi*k*j/n).\n\n/* placeholder for cos(theta) */\n\n/* placeholder for sin(theta) */\n\n/* placeholder for complex multiplication real part */\n\n/* placeholder for complex multiplication imaginary part */\n\n/* placeholder for complex addition real part */\n\n/* placeholder for complex addition imaginary part */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\npub struct Complex {\n    pub re: f64,\n    pub im: f64,\n}\n\npub open spec fn cexp(theta: f64) -> Complex {\n    Complex {\n        re: 1.0,\n        im: 0.0,\n    }\n}\n\npub open spec fn complex_mul(z: Complex, w: Complex) -> Complex {\n    Complex {\n        re: 0.0,\n        im: 0.0,\n    }\n}\n\npub open spec fn complex_add(z: Complex, w: Complex) -> Complex {\n    Complex {\n        re: 0.0,\n        im: 0.0,\n    }\n}\n\npub open spec fn complex_zero() -> Complex {\n    Complex { re: 0.0, im: 0.0 }\n}\n\npub open spec fn f64_to_complex(x: f64) -> Complex {\n    Complex { re: x, im: 0.0 }\n}\n\npub open spec fn complex_sum(n: nat, f: spec_fn(nat) -> Complex) -> Complex\n    decreases n\n{\n    if n == 0 {\n        complex_zero()\n    } else {\n        complex_add(f((n - 1) as nat), complex_sum((n - 1) as nat, f))\n    }\n}", "vc-helpers": "", "vc-spec": "pub fn fft(a: Vec<Complex>) -> (result: Vec<Complex>)\n    requires a.len() > 0,\n    ensures \n        result.len() == a.len(),\n        forall|k: usize| k < result.len() ==> \n            result[k as int] == complex_sum(a.len() as nat, |j: nat| \n                if j < a.len() {\n                    complex_mul(a[j as int], cexp(0.0))\n                } else {\n                    complex_zero()\n                }\n            ),\n        result.len() > 0 ==> result[0] == complex_sum(a.len() as nat, |j: nat|\n            if j < a.len() { a[j as int] } else { complex_zero() }\n        ),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "fft_fftshift", "vc-description": "Shift the zero-frequency component to the center of the spectrum.\n\nThis function rearranges the FFT output such that the zero-frequency \ncomponent is moved from the beginning to the center of the array.\nFor even-length arrays, it performs a circular shift by n/2.\nFor odd-length arrays, it performs a circular shift by (n-1)/2.\n\nSpecification: fftshift performs a circular shift that moves the zero-frequency \ncomponent to the center of the array.\n\nThe function rearranges elements by performing a circular shift:\n- Each element at position i in the result comes from position (i + n - n/2) % n in the input\n- This is equivalent to swapping the first and second halves of the array\n- The zero-frequency component (originally at index 0) moves to the center\n\nKey mathematical properties:\n1. Bijective mapping: every element is preserved and appears exactly once\n2. Circular shift property: implements a specific permutation\n3. Involution property: for even n, fftshift(fftshift(x)) = x\n4. Sum preservation: the sum of all elements remains unchanged", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn fftshift(x: Vec<f32>) -> (result: Vec<f32>)\n    requires x.len() > 0,\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> \n            result[i] == x[((i + x.len() as int - x.len() as int / 2) % x.len() as int) as int],\n        forall|j: int| 0 <= j < x.len() ==> \n            exists|k: int| 0 <= k < result.len() && result[k] == x[j],\n        forall|val: f32| \n            (exists|j: int| 0 <= j < x.len() && x[j] == val) <==>\n            (exists|k: int| 0 <= k < result.len() && result[k] == val)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "fft_hfft", "vc-description": "numpy.fft.hfft: Compute the FFT of a signal that has Hermitian symmetry.\n\nThe Hermitian FFT assumes that the input signal has Hermitian symmetry,\nwhich means that the signal in the frequency domain is real-valued.\nThis is the inverse operation of rfft.\n\nFor a signal with Hermitian symmetry, the output will be real-valued\nand the length of the transform is determined by the input length.\nIf input has length m, the output has length 2*(m-1).\n\nThe function essentially computes the inverse of rfft by taking\nthe conjugate of the input and then computing the inverse real FFT.\n\nSpecification: numpy.fft.hfft computes the FFT of a signal with Hermitian symmetry.\n\nPrecondition: The input vector represents a Hermitian symmetric signal\nPostcondition: The output is a real-valued vector of length 2*m where\nthe input had length m+1, and the transformation preserves certain mathematical \nproperties of the Hermitian FFT including:\n1. The output is real-valued (no imaginary parts)\n2. The length relationship: if input has m+1 elements, output has 2*m elements\n3. Hermitian symmetry properties are preserved in the transform\n4. The conjugate relationship: this is effectively the inverse of an rfft operation", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n#[derive(PartialEq)]\npub struct Complex {\n    pub real: f32,\n    pub imag: f32,\n}", "vc-helpers": "", "vc-spec": "fn hfft(a: Vec<Complex>, m: usize) -> (result: Vec<f32>)\n    requires \n        m > 0,\n        a.len() == m + 1,\n    ensures\n        result.len() == 2 * m,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "fft_ifft", "vc-description": "Compute the one-dimensional inverse discrete Fourier Transform (IFFT).\n\nThe IFFT transforms frequency domain data back to the time domain,\ncomputing the inverse of the DFT such that ifft(fft(x)) ≈ x.\n\nFor a vector of length n, the k-th coefficient is computed as:\nX[k] = (1/n) * Σ(j=0 to n-1) a[j] * exp(2πi*j*k/n)\n\nSpecification: The inverse FFT correctly computes the inverse discrete Fourier transform.\n\nThe IFFT satisfies the inverse DFT equation where each output element k is \ncomputed as (1/n) times the sum over all input elements j, multiplied by the \ncomplex exponential exp(2πi*k*j/n).\n\nThis is the mathematical inverse of the FFT operation, with a positive sign \nin the exponential and a normalization factor of 1/n.\n\n/* Simplified for spec purposes */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "#[derive(PartialEq, Eq, Structural)]\npub struct Complex {\n    pub re: int,\n    pub im: int,\n}\n\nimpl Complex {\n    pub open spec fn add(self, other: Complex) -> Complex {\n        Complex { re: self.re + other.re, im: self.im + other.im }\n    }\n\n    pub open spec fn mul(self, other: Complex) -> Complex {\n        Complex { \n            re: self.re * other.re - self.im * other.im, \n            im: self.re * other.im + self.im * other.re \n        }\n    }\n\n    pub open spec fn scalar_mul(self, s: int) -> Complex {\n        Complex { re: s * self.re, im: s * self.im }\n    }\n}\n\npub open spec fn cexp(theta: int) -> Complex {\n    Complex { re: 1, im: 0 }\n}\n\npub open spec fn complex_sum(n: nat, f: spec_fn(nat) -> Complex) -> Complex\n    decreases n\n{\n    if n == 0 {\n        Complex { re: 0, im: 0 }\n    } else {\n        f((n - 1) as nat).add(complex_sum((n - 1) as nat, f))\n    }\n}\n\nfn ifft(a: Vec<Complex>) -> (result: Vec<Complex>)\n    requires a.len() > 0,\n    ensures\n        result.len() == a.len(),\n        forall|k: int| #[trigger] result[k] == result[k] && 0 <= k < result.len() ==> {\n            let n = a.len() as nat;\n            let expected = complex_sum(n, |j: nat| {\n                if j < n {\n                    a[j as int].mul(cexp(2 * k * (j as int)))\n                } else {\n                    Complex { re: 0, im: 0 }\n                }\n            }).scalar_mul(1);\n            result[k] == expected\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "indexing_slicing_argmax", "vc-description": "Returns the index of the maximum value in a non-empty vector (first occurrence)\n\nSpecification: argmax returns the index of the first maximum element\nThis comprehensive specification captures:\n1. The returned index points to a maximum element\n2. All elements to the left of the returned index are strictly less than the maximum\n3. All elements to the right of the returned index are less than or equal to the maximum\n4. The function returns the first occurrence of the maximum value\n5. The returned index is valid (type-safe with Fin)\n6. The result is deterministic for the same input", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn argmax(arr: &Vec<i32>) -> (result: usize)\n    requires arr.len() > 0,\n    ensures \n        result < arr.len(),\n        forall|i: int| 0 <= i && i < arr.len() ==> arr@[i] <= arr@[result as int],\n        forall|i: int| 0 <= i && i < result as int ==> arr@[i] < arr@[result as int],\n        forall|i: int| (result as int) < i && i < arr.len() ==> arr@[i] <= arr@[result as int],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "indexing_slicing_argwhere", "vc-description": "Find the indices of array elements that are non-zero, grouped by element.\n\nFor a 1D vector, returns a list of indices where elements are non-zero.\nEach index corresponds to a position in the original vector where the element is non-zero.\nThe returned indices are in the same order as they appear in the original vector.\n\nThis function is equivalent to finding all positions i such that a[i] ≠ 0.\nThe result is a list of indices, not suitable for direct array indexing but useful\nfor analysis and conditional processing.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn argwhere(a: &Vec<f64>) -> (indices: Vec<usize>)\n    ensures\n        forall|i: int| 0 <= i < indices.len() ==> (#[trigger] indices[i]) < a.len(),\n        forall|i: int| 0 <= i < indices.len() ==> a[indices[i] as int] != 0.0,\n        forall|i: int| 0 <= i < a.len() && a[i] != 0.0 ==> exists|j: int| 0 <= j < indices.len() && indices[j] == i,\n        forall|i: int, j: int| 0 <= i < indices.len() && 0 <= j < indices.len() && i != j ==> indices[i] != indices[j],\n        forall|i: int, j: int| 0 <= i < indices.len() && 0 <= j < indices.len() && (indices[i] as int) < (indices[j] as int) ==> i < j,\n        (indices.len() == 0) == (forall|i: int| 0 <= i < a.len() ==> a[i] == 0.0),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "indexing_slicing_c_", "vc-description": "numpy.c_: Translates slice objects to concatenation along the second axis.\n\nThis function takes two vectors and stacks them as columns to create a 2-D array.\nEach input vector becomes a column in the resulting matrix.\n\nThis is equivalent to column_stack([arr1, arr2]) for 1-D arrays.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn c_(arr1: Vec<f32>, arr2: Vec<f32>) -> (result: Vec<Vec<f32>>)\n    requires arr1.len() == arr2.len(),\n    ensures \n        result.len() == arr1.len(),\n        forall|i: int| 0 <= i < result.len() ==> \n            result[i].len() == 2 &&\n            result[i][0] == arr1[i] &&\n            result[i][1] == arr2[i]", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "indexing_slicing_choose", "vc-description": "Construct an array from an index array and a set of arrays to choose from.\nGiven an index vector 'indices' and a vector of choice vectors 'choices',\nconstructs a result vector where each element is selected from the corresponding\nchoice vector based on the index value at that position.\n\nFor each position i in the result, result[i] = choices[indices[i]][i]\n\nThis is a simplified version focusing on the core functionality with 'raise' mode,\nwhere all indices must be valid (in range [0, num_choices-1]).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn choose(indices: Vec<usize>, choices: Vec<Vec<f64>>) -> (result: Vec<f64>)\n    requires \n        indices.len() > 0,\n        choices.len() > 0,\n        forall|i: int| 0 <= i < indices.len() ==> indices[i] < choices.len(),\n        forall|j: int| 0 <= j < choices.len() ==> choices[j].len() == indices.len(),\n    ensures \n        result.len() == indices.len(),\n        forall|i: int| 0 <= i < indices.len() ==> result[i] == choices[indices[i] as int][i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "indexing_slicing_compress", "vc-description": "Compresses a vector by selecting only elements where the corresponding \ncondition is true. Returns a new vector containing only the selected elements.\nThe result size is the number of true values in the condition vector.\n\nSpecification: compress returns a new vector containing only the elements \nfrom the input vector where the corresponding condition element is true.\n\nMathematical properties:\n1. The result size equals the number of true values in the condition\n2. The result preserves the order of elements from the original vector\n3. Each element in the result corresponds to a true condition at the same index\n4. The result is empty if and only if all condition elements are false\n\nThis function implements array compression/masking, a fundamental operation\nin array programming that allows selective extraction of elements based on\na boolean mask. It's equivalent to boolean indexing in NumPy.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn count_true(condition: Seq<bool>) -> int\n    decreases condition.len()\n{\n    if condition.len() == 0 {\n        0\n    } else {\n        (if condition[0] { 1int } else { 0int }) + count_true(condition.skip(1))\n    }\n}\n\nfn compress(condition: Vec<bool>, a: Vec<f32>) -> (result: Vec<f32>)\n    requires condition.len() == a.len(),\n    ensures\n        result.len() == count_true(condition@),\n        exists|mapping: Seq<int>|\n            mapping.len() == result.len() &&\n            (forall|i: int| 0 <= i < mapping.len() ==> \n                0 <= mapping[i] < condition.len() &&\n                condition@[mapping[i]] == true) &&\n            (forall|i: int| 0 <= i < result.len() ==> \n                result@[i] == a@[mapping[i]]) &&\n            (forall|i: int, j: int| 0 <= i < j < mapping.len() ==> \n                mapping[i] < mapping[j]),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "indexing_slicing_diag", "vc-description": "Extract a diagonal or construct a diagonal array.\n\nnumpy.diag: Extract a diagonal or construct a diagonal array.\n\nFor simplicity, this specification focuses on extracting the diagonal\nfrom a square matrix represented as a flattened vector.\nGiven a flattened n×n matrix, returns the diagonal elements.\n\nThis specification captures the essential mathematical property of\ndiagonal extraction in a type-safe manner using Vector types.\n\nSpecification: diag extracts diagonal elements from a flattened matrix.\n\nMathematical Properties:\n1. Diagonal Extraction: For a flattened n×n matrix stored in row-major order,\n   the diagonal elements are located at positions i*n + i for i ∈ [0, n).\n\n2. Type Safety: The function maintains type safety by using Vector types\n   that encode the size information at the type level.\n\n3. Correctness: Each element in the result vector corresponds to a diagonal\n   element from the original matrix, preserving the mathematical structure.\n\nThis specification provides a foundation for formal verification of diagonal\noperations in numerical computing.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn diag(matrix: Vec<f32>, n: usize) -> (result: Vec<f32>)\n    requires \n        matrix.len() == n * n,\n        n > 0,\n    ensures\n        result.len() == n,\n        forall|i: int| 0 <= i < n ==> result[i] == matrix[i * n + i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "indexing_slicing_diagonal", "vc-description": "Extract diagonal elements from a 2D matrix with optional offset.\n\nTakes a 2D matrix and returns a 1D vector containing the diagonal elements.\nFor offset=0, returns main diagonal elements [a[0,0], a[1,1], ...].\nFor offset>0, returns elements above main diagonal [a[0,offset], a[1,offset+1], ...].\nFor offset<0, returns elements below main diagonal [a[-offset,0], a[-offset+1,1], ...].", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn diagonal(a: Vec<Vec<f64>>, offset: i32) -> (result: Vec<f64>)\n    requires \n        a.len() > 0,\n        a.len() > 0 ==> a[0].len() > 0,\n        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i].len() == a[0].len(),\n        if offset >= 0 { \n            offset as int <= a[0].len() as int\n        } else { \n            (-offset) as int <= a.len() as int\n        },\n    ensures\n        result.len() == (if offset >= 0 { \n            if a.len() as int <= (a[0].len() as int - offset as int) { a.len() as int } else { a[0].len() as int - offset as int }\n        } else { \n            if (a.len() as int + (-offset) as int) <= a[0].len() as int { a.len() as int + (-offset) as int } else { a[0].len() as int }\n        }) as usize,\n        forall|i: int| 0 <= i < result.len() ==> {\n            if offset >= 0 {\n                #[trigger] result[i] == a[i][i + offset as int]\n            } else {\n                #[trigger] result[i] == a[i + (-offset) as int][i]\n            }\n        },", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "indexing_slicing_extract", "vc-description": "numpy.extract: Return the elements of an array that satisfy some condition.\n\nExtracts elements from an array where the corresponding condition is True.\nBoth arrays must have the same size, and the result contains only the elements\nfrom `arr` where `condition` is True, in the same order they appear in `arr`.\n\nThe result size `k` must equal the number of True elements in the condition array.\n\nSpecification: numpy.extract returns elements where condition is True.\n\nPrecondition: k equals the count of True elements in condition\nPostcondition: The result contains exactly the elements from arr where condition is True,\n              in the same order they appear in arr.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn count_true(condition: Seq<bool>) -> int \n    decreases condition.len()\n{\n    if condition.len() == 0 {\n        0int\n    } else {\n        (if condition[0] { 1int } else { 0int }) + count_true(condition.skip(1))\n    }\n}\n\nfn extract(condition: Vec<bool>, arr: Vec<f32>) -> (result: Vec<f32>)\n    requires \n        condition.len() == arr.len(),\n        count_true(condition@) >= 0,\n    ensures\n        result.len() == count_true(condition@),\n        forall|i: int| 0 <= i < result.len() ==> \n            #[trigger] result[i] == arr[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "indexing_slicing_fill_diagonal", "vc-description": "Fill the main diagonal of a 2D matrix with a specified value\n\n/* Diagonal elements are filled with val */\n\n/* Non-diagonal elements remain unchanged */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn fill_diagonal<T: Copy>(mat: Vec<Vec<T>>, val: T) -> (result: Vec<Vec<T>>)\n    requires \n        mat.len() > 0,\n        forall|i: int| 0 <= i < mat.len() ==> mat[i].len() == mat[0].len(),\n    ensures\n        result.len() == mat.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == mat[i].len(),\n\n        forall|i: int, j: int| \n            0 <= i < result.len() && 0 <= j < result[i].len() && i == j \n            ==> result[i][j] == val,\n\n        forall|i: int, j: int| \n            0 <= i < result.len() && 0 <= j < result[i].len() && i != j \n            ==> result[i][j] == mat[i][j]", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "indexing_slicing_flatiter", "vc-description": "numpy.flatiter: Flat iterator object to iterate over arrays.\n\nA flatiter iterator provides a flattened view of an array for iteration purposes.\nIt allows accessing elements of a multi-dimensional array as if it were 1-dimensional,\nfollowing row-major (C-style) order where the last index varies fastest.\n\nThe iterator supports indexing and provides sequential access to all elements\nin the array following the memory layout order.\n\nSpecification: numpy.flatiter creates a flat iterator over the array.\n\nPrecondition: True (no special preconditions for creating a flat iterator)\nPostcondition: The result preserves all elements in row-major order,\n               providing sequential access to the flattened array elements", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_flatiter(a: Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == a[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "indexing_slicing_indices", "vc-description": "Generate indices for a 1D grid of given size.\nReturns a 2D array where the first dimension has size 1 and contains \nthe indices [0, 1, 2, ..., n-1]\n\nSpecification: indices generates a grid of index values\nThis comprehensive specification captures:\n1. The output has the correct shape: (1, n) for 1D case\n2. The single row contains exactly the indices [0, 1, 2, ..., n-1]\n3. Each position i contains the value i\n4. The indices are in ascending order\n5. The result covers all valid indices for the given dimension", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn indices(n: usize) -> (grid: Vec<Vec<usize>>)\n    ensures \n        grid.len() == 1,\n        grid[0].len() == n,\n        forall|i: int| 0 <= i < n ==> grid[0][i] == i,\n        forall|i: int, j: int| 0 <= i < j < n ==> grid[0][i] < grid[0][j],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "indexing_slicing_ix_", "vc-description": "Construct an open mesh from multiple sequences\n\nConstruct an open mesh from two 1-D sequences. \nThis simplified version handles the case of two input sequences,\nreturning two 2D arrays that form an open mesh for indexing operations.\nThe first array has shape (m, 1) containing values from the first sequence,\nand the second array has shape (1, n) containing values from the second sequence.\n\nSpecification: ix_ creates an open mesh from two sequences\nThis comprehensive specification captures:\n1. The function takes two 1-D sequences of integers\n2. Returns a pair of 2D arrays (represented as vectors of vectors)\n3. First array has shape (m, 1) - m rows, 1 column\n4. Second array has shape (1, n) - 1 row, n columns\n5. First array contains values from seq1 repeated in column format\n6. Second array contains values from seq2 repeated in row format\n7. Together they form an open mesh for advanced indexing operations\n8. Each element of the first array's i-th row equals seq1[i]\n9. Each element of the second array's single row equals the corresponding seq2 element\n10. The mesh property: for any indices (i,j), the pair (first[i][0], second[0][j]) \n    represents a coordinate in the mesh grid\n\n/* First array has correct shape and values */\n\n/* Second array has correct shape and values */\n\n/* Mesh property: coordinates are preserved */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn ix_(seq1: Vec<i32>, seq2: Vec<i32>) -> (result: (Vec<Vec<i32>>, Vec<Vec<i32>>))\n    requires \n        seq1.len() > 0,\n        seq2.len() > 0,\n    ensures \n\n        result.0.len() == seq1.len(),\n        forall|i: int| 0 <= i < seq1.len() ==> result.0[i].len() == 1,\n        forall|i: int| 0 <= i < seq1.len() ==> result.0[i][0] == seq1[i],\n\n        result.1.len() == 1,\n        result.1[0].len() == seq2.len(),\n        forall|j: int| 0 <= j < seq2.len() ==> result.1[0][j] == seq2[j],\n\n        forall|i: int, j: int| 0 <= i < seq1.len() && 0 <= j < seq2.len() ==> \n            result.0[i][0] == seq1[i] && result.1[0][j] == seq2[j],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "indexing_slicing_mgrid", "vc-description": "numpy.mgrid: Dense multi-dimensional \"meshgrid\" creation for 2D case.\n\nCreates a dense mesh-grid from two 1D coordinate arrays, returning a pair of 2D arrays\nwhere each output array has the same shape (rows × cols). The first array contains\nrow coordinates repeated across columns, and the second array contains column\ncoordinates repeated across rows.\n\nThis is the 2D case of numpy.mgrid[start_r:stop_r, start_c:stop_c] which creates\ncoordinate arrays suitable for evaluating functions over a 2D grid.\n\nFor 2D case with rows and cols dimensions, this returns a tuple of two matrices:\n- First matrix: row coordinates repeated across columns\n- Second matrix: column coordinates repeated across rows", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "type Matrix = Vec<Vec<f32>>;\n\nfn mgrid(rows: usize, cols: usize, start_r: f32, stop_r: f32, start_c: f32, stop_c: f32) -> (result: (Matrix, Matrix))\n    requires rows > 0 && cols > 0,\n    ensures \n        result.0.len() == rows && result.1.len() == rows,\n        forall|i: int| 0 <= i < rows ==> result.0[i].len() == cols && result.1[i].len() == cols,\n        forall|i: int, j: int, k: int| 0 <= i < rows && 0 <= j < cols && 0 <= k < cols ==> \n            result.0[i][j] == result.0[i][k],\n        forall|j: int, i: int, k: int| 0 <= j < cols && 0 <= i < rows && 0 <= k < rows ==> \n            result.1[i][j] == result.1[k][j],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "indexing_slicing_nanargmax", "vc-description": "Returns the index of the maximum value in a non-empty vector, ignoring NaN values.\n\nThis function finds the index of the maximum value among all non-NaN elements in the vector.\nRequires that at least one element is not NaN, otherwise it would raise an error.\n\nIn case of multiple occurrences of the maximum values, the indices\ncorresponding to the first occurrence are returned.\n\nSpecification: nanargmax returns the index of the first maximum element among non-NaN values.\n\nThis comprehensive specification captures:\n1. The returned index points to an element that is not NaN\n2. The element at the returned index is the maximum among all non-NaN elements\n3. The function returns the first occurrence of the maximum value (among non-NaN elements)\n4. The returned index is valid (type-safe with Fin)\n5. The precondition ensures at least one element is not NaN\n6. All non-NaN elements are less than or equal to the maximum\n7. Among elements with the same maximum value, the first index is returned\n\n/* Maximum property: all finite values are <= max value */\n\n/* First occurrence property: returns earliest index among ties */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_finite(x: f32) -> bool;\n\nfn nanargmax(a: Vec<f32>) -> (result: usize)\n    requires\n        a.len() > 0,\n        exists|i: int| 0 <= i < a.len() && is_finite(a[i]),\n    ensures\n        result < a.len(),\n        is_finite(a[result as int]),\n\n        forall|j: int| 0 <= j < a.len() && is_finite(a[j]) ==> true,\n\n        forall|j: int| 0 <= j < a.len() && is_finite(a[j]) ==> (result as int) <= j || true,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "indexing_slicing_nanargmin", "vc-description": "Returns the index of the minimum value in a non-empty vector, ignoring NaN values.\n\nThis function finds the index of the minimum value among all non-NaN elements in the vector.\nRequires that at least one element is not NaN, otherwise it would raise an error.\n\nIn case of multiple occurrences of the minimum values, the indices\ncorresponding to the first occurrence are returned.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn f32_is_nan(x: f32) -> bool;\nspec fn f32_le(a: f32, b: f32) -> bool;", "vc-helpers": "", "vc-spec": "fn nanargmin(a: Vec<f32>) -> (result: usize)\n    requires \n        a.len() > 0,\n        exists|i: int| 0 <= i < a.len() && !f32_is_nan(a[i]),\n    ensures\n        result < a.len(),\n        !f32_is_nan(a[result as int]),\n        forall|j: int| 0 <= j < a.len() && !f32_is_nan(a[j]) ==> f32_le(a[result as int], a[j]),\n        forall|j: int| 0 <= j < a.len() && !f32_is_nan(a[j]) && f32_le(a[j], a[result as int]) && f32_le(a[result as int], a[j]) ==> result as int <= j,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "indexing_slicing_ndenumerate", "vc-description": "numpy.ndenumerate: Multidimensional index iterator that yields pairs of array coordinates and values.\n\nFor a 1D array, this creates a vector of tuples where each tuple contains\nthe index and the corresponding value from the input array.\n\nThe function essentially enumerates through the array, providing both\nthe position (index) and the value at that position.\n\nSpecification: ndenumerate returns a vector of index-value pairs.\n\nFor each position i in the input array, the result contains a tuple\n(i, arr[i]) where i is the index and arr[i] is the value at that index.\n\nPrecondition: True (no special preconditions needed)\nPostcondition: For all indices i, result[i] = (i, arr[i])", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn ndenumerate(arr: Vec<f32>) -> (result: Vec<(usize, f32)>)\n    ensures \n        result.len() == arr.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].0 == i && result[i].1 == arr[i]", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "indexing_slicing_ndindex", "vc-description": "Generate N-dimensional indices for an array with given shape.\nReturns a vector of index tuples, where each tuple represents a valid\nN-dimensional index for an array with the specified dimensions.\n\nFor a 2D array with shape (m, n), this generates all index pairs\n(i, j) where 0 ≤ i < m and 0 ≤ j < n, in C-order (row-major).\n\nExample: For shape (2, 3), generates [(0,0), (0,1), (0,2), (1,0), (1,1), (1,2)]", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn ndindex(shape: (usize, usize)) -> (indices: Vec<(usize, usize)>)\n    requires shape.0 > 0 && shape.1 > 0,\n    ensures \n        indices.len() == shape.0 * shape.1,\n        forall|k: int| 0 <= k < indices.len() ==> {\n            let (i, j) = indices[k];\n            i < shape.0 && j < shape.1\n        },\n        forall|i: usize, j: usize| i < shape.0 && j < shape.1 ==> {\n            exists|k: int| 0 <= k < indices.len() && indices[k] == (i, j)\n        },\n        forall|k: int| 0 <= k < indices.len() ==> {\n            let (i, j) = indices[k];\n            k == i * shape.1 + j\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "indexing_slicing_nditer", "vc-description": "numpy.nditer: Creates an iterator for a vector that provides position and element access.\n\nThis is a simplified 1D version of numpy's nditer functionality.\nReturns an iterator that starts at position 0 and holds the original data.\nThe iterator can be used to traverse the vector elements sequentially.\n\nIn numpy, nditer is a powerful multi-dimensional iterator, but for our\nVector-based specification, we simplify it to basic position tracking.\n\nSpecification: nditer creates a valid iterator that starts at position 0.\n\nThis comprehensive specification captures:\n1. The iterator starts at position 0\n2. The iterator contains the original data unchanged\n3. The iterator position is valid (within bounds)\n4. The iterator provides access to all elements of the original vector\n5. The iterator follows numpy's iteration semantics\n6. The iterator state is consistent and predictable", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn nditer(arr: Vec<f32>) -> (iter: (usize, Vec<f32>))\n    ensures\n        iter.0 == 0,\n        iter.1@ == arr@,\n        iter.0 <= arr.len(),\n        forall|i: int| 0 <= i < arr.len() ==> iter.1[i] == arr[i]", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "indexing_slicing_place", "vc-description": "numpy.place: Change elements of an array based on conditional and input values.\n\nModifies elements of an array where the corresponding mask is True, using values \nfrom the vals array. The function uses the first N elements of vals, where N is \nthe number of True values in mask. If vals is smaller than N, it will be repeated.\n\nThe parameter `k` must equal the number of True elements in the mask array.\nThe parameter `v` is the size of the vals array, which must be non-empty.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn count_true(mask: Seq<bool>) -> nat\n    decreases mask.len()\n{\n    if mask.len() == 0 {\n        0\n    } else {\n        (if mask[0] { 1nat } else { 0nat }) + count_true(mask.skip(1))\n    }\n}\n\nfn place(arr: Vec<f32>, mask: Vec<bool>, vals: Vec<f32>) -> (result: Vec<f32>)\n    requires \n        arr.len() == mask.len(),\n        vals.len() > 0,\n    ensures \n        result.len() == arr.len(),\n        forall|i: int| 0 <= i < arr.len() ==> !mask[i] ==> result[i] == arr[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "indexing_slicing_put", "vc-description": "numpy.put: Replaces specified elements of an array with given values.\n\nThe indexing works on the flattened target array. This operation mutates the input array\nin-place by placing values from `v` at the positions specified by `ind`.\n\nFor simplicity, we ignore the `mode` parameter and assume all indices are valid.\n\nSpecification: numpy.put modifies specific elements of the input array.\n\nThis theorem captures the core mathematical properties:\n1. Elements at specified indices are replaced with corresponding values from `v`\n2. All other elements remain unchanged\n3. The result vector has the same length as the input vector\n4. Index bounds are respected (enforced by precondition)\n\nPrecondition: All indices in `ind` must be valid (less than array length)\nPostcondition: Elements at specified indices are replaced with corresponding values from `v`,\n              while all other elements remain unchanged.\n\nThis specification handles the case where indices may be duplicated - in such cases,\nthe later occurrence in the index vector takes precedence.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn put(a: Vec<f64>, ind: Vec<usize>, v: Vec<f64>) -> (result: Vec<f64>)\n    requires \n        ind.len() == v.len(),\n        forall|i: int| 0 <= i < ind.len() ==> ind[i] < a.len(),\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < ind.len() ==> result[ind[i] as int] == v[i],\n        forall|j: int| 0 <= j < result.len() ==> \n            (forall|i: int| 0 <= i < ind.len() ==> j != ind[i]) ==> result[j] == a[j],\n        ind.len() == 0 ==> result@ == a@,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "indexing_slicing_putmask", "vc-description": "Changes elements of an array based on conditional and input values.\n\nThis function modifies the target array in-place, setting elements to values\nfrom the values array where the corresponding mask element is True.\nIf values is smaller than the target array, it will repeat cyclically.\n\nParameters:\n- a: Target array to modify\n- mask: Boolean mask array with same shape as a\n- values: Values to put into a where mask is True\n- m: Size of values array (must be positive for repetition)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn putmask(a: Vec<f32>, mask: Vec<bool>, values: Vec<f32>) -> (result: Vec<f32>)\n    requires \n        a.len() == mask.len(),\n        values.len() > 0,\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> (\n            mask[i] ==> exists|j: int| 0 <= j < values.len() && result[i] == values[j]\n        ),\n        forall|i: int| 0 <= i < a.len() ==> (\n            mask[i] ==> result[i] == values[(i as int) % (values.len() as int)]\n        ),\n        forall|i: int| 0 <= i < a.len() ==> (\n            !mask[i] ==> result[i] == a[i]\n        ),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "indexing_slicing_r_", "vc-description": "numpy.r_: Translates slice objects to concatenation along the first axis.\n\nThis is a simple way to build up arrays quickly. There are two main use cases:\n1. If the index expression contains comma separated arrays, then stack them along their first axis\n2. If the index expression contains slice notation or scalars then create a 1-D array with a range\n\nThis implementation focuses on the first use case - concatenating two 1D arrays along the first axis.\nThe r_ object provides a convenient way to concatenate arrays by using index notation.\n\nFor example, numpy.r_[array1, array2] concatenates array1 and array2.\n\nSpecification: numpy.r_ concatenates arrays along the first axis.\n\nPrecondition: True (no special preconditions for basic concatenation)\nPostcondition: The result contains all elements from the first array followed by all elements from the second array.\nThis comprehensive specification captures:\n1. First n elements come from array a (preserving order and values)\n2. Next m elements come from array b (preserving order and values)\n3. Total length is n + m (enforced by type system)\n4. No elements are duplicated or lost (bijective mapping)\n5. The concatenation preserves all original values exactly\n6. Order is preserved within each original array", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn r_(a: Vec<f32>, b: Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() == a.len() + b.len(),\n        forall|i: int| 0 <= i < a.len() ==> result[i] == a[i],\n        forall|j: int| 0 <= j < b.len() ==> result[a.len() + j] == b[j]", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "indexing_slicing_ravel_multi_index", "vc-description": "Converts a tuple of index arrays into an array of flat indices, applying boundary modes to the multi-index.\n\nConvert 2D multi-indices to flat indices using C-style (row-major) ordering.\n\nTakes arrays of row and column indices and converts them to flat indices\nfor an array with given dimensions. The conversion uses row-major ordering\nwhere flat_index = row_index * cols + col_index.\n\nThe function requires that all indices are within bounds of the specified dimensions.\n\nSpecification: ravel_multi_index converts 2D indices to flat indices using row-major ordering.\n\nPrecondition: All row and column indices must be within bounds\nPostcondition: Each flat index is computed as row_index * cols + col_index\n\nMathematical properties:\n1. The flat index correctly represents the 2D position in a flattened array\n2. All resulting indices are within bounds of the flattened array\n3. The conversion preserves the ordering relationship between multi-indices\n\nThis specification captures the essential behavior of NumPy's ravel_multi_index\nfor the 2D case with C-style ordering. The function maps 2D coordinates to\ntheir corresponding positions in a flattened representation of the array.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn ravel_multi_index(row_indices: &Vec<usize>, col_indices: &Vec<usize>, rows: usize, cols: usize) -> (result: Vec<usize>)\n    requires \n        row_indices.len() == col_indices.len(),\n        forall|i: int| 0 <= i < row_indices.len() ==> row_indices[i] < rows,\n        forall|i: int| 0 <= i < col_indices.len() ==> col_indices[i] < cols,\n    ensures \n        result.len() == row_indices.len(),\n        forall|i: int| 0 <= i < result.len() ==> \n            result[i] == row_indices[i] * cols + col_indices[i] && \n            result[i] < rows * cols,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "indexing_slicing_s_", "vc-description": "Index expression builder that creates slice objects for array indexing.\nThis is a simplified version of numpy.s_ that creates slice objects\nfor use in array indexing operations.\n\nSpecification: s_ creates a well-formed slice object\nThis comprehensive specification captures:\n1. The slice object contains the provided start, stop, and step values\n2. If step is provided, it must be positive (non-zero)\n3. If start and stop are both provided, start should be less than or equal to stop\n4. The resulting slice is valid for array indexing operations\n5. The slice preserves the ordering constraints (start ≤ stop when both present)\n6. The step value, if present, is positive for forward slicing\n\n/* A slice object representing a range of indices for array slicing.\n   Contains start, stop, and step parameters for creating slices. */\n\n/* The starting index of the slice (inclusive). If None, starts from the beginning. */\n\n/* The stopping index of the slice (exclusive). If None, goes to the end. */\n\n/* The step size for the slice. If None, defaults to 1. */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\npub struct Slice {\n\n    pub start: Option<usize>,\n\n    pub stop: Option<usize>,\n\n    pub step: Option<usize>,\n}", "vc-helpers": "", "vc-spec": "fn s_(start: Option<usize>, stop: Option<usize>, step: Option<usize>) -> (slice: Slice)\n    requires \n        step.is_some() ==> step.unwrap() > 0,\n        (start.is_some() && stop.is_some()) ==> start.unwrap() <= stop.unwrap(),\n    ensures \n        slice.start == start,\n        slice.stop == stop,\n        slice.step == step,\n        slice.step.is_some() ==> slice.step.unwrap() > 0,\n        (slice.start.is_some() && slice.stop.is_some()) ==> slice.start.unwrap() <= slice.stop.unwrap(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "indexing_slicing_select", "vc-description": "numpy.select: Return an array drawn from elements in choicelist, depending on conditions.\n\nFor each element position, returns the element from the first choice array\nwhere the corresponding condition is True. If no conditions are True,\nreturns the default value.\n\nThis function enables multi-way conditional selection between arrays.\n\nSpecification: numpy.select performs element-wise multi-conditional selection.\n\nPrecondition: condlist and choicelist have the same length\nPostcondition: Each element is selected from the first matching choice array,\n               or default if no conditions match", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn select(condlist: Vec<Vec<bool>>, choicelist: Vec<Vec<f32>>, default: f32) -> (result: Vec<f32>)\n    requires \n        condlist.len() == choicelist.len(),\n        condlist.len() > 0 ==> (forall|i: int| 0 <= i < condlist.len() ==> condlist[i].len() == condlist[0].len()),\n        choicelist.len() > 0 ==> (forall|i: int| 0 <= i < choicelist.len() ==> choicelist[i].len() == choicelist[0].len()),\n        condlist.len() > 0 && choicelist.len() > 0 ==> condlist[0].len() == choicelist[0].len(),\n    ensures\n        condlist.len() == 0 ==> result.len() == 0,\n        condlist.len() > 0 ==> result.len() == condlist[0].len(),\n        forall|i: int| 0 <= i < result.len() ==> {\n            (exists|j: int| 0 <= j < condlist.len() && condlist[j][i] == true && \n                result[i] == choicelist[j][i] &&\n                (forall|j_prime: int| 0 <= j_prime < j ==> condlist[j_prime][i] == false)) ||\n            (forall|j: int| 0 <= j < condlist.len() ==> condlist[j][i] == false && result[i] == default)\n        },", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "indexing_slicing_take", "vc-description": "Take elements from a source array at specified indices.\nGiven a source array 'arr' and a vector of indices 'indices',\nreturns a new array containing the elements from 'arr' at the positions\nspecified by 'indices'. The indices must be valid positions in the source array.\n\nThis is a simplified 1D version of numpy.take with 'raise' mode,\nwhere all indices must be valid (in range [0, n-1]).\n\nSpecification: take extracts elements from a source array at specified indices.\n\nMathematical properties:\n1. The result has the same length as the indices array\n2. For each position i in the result, result[i] = arr[indices[i]]\n3. All indices must be valid (enforced by Fin type)\n4. The order of elements in the result follows the order of indices\n5. The same index can appear multiple times, resulting in duplicated elements\n\nThe function implements: result[i] = arr.get (indices.get i)\n\nThis captures the core behavior of numpy.take in 'raise' mode where indices\nmust be in valid range. The use of Fin type ensures type safety and eliminates\nthe need for runtime bounds checking. The result preserves the element type\nof the source array.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn take(arr: Vec<f32>, indices: Vec<usize>) -> (result: Vec<f32>)\n    requires\n        forall|i: int| 0 <= i < indices.len() ==> indices[i] < arr.len(),\n    ensures\n        result.len() == indices.len(),\n        forall|i: int| 0 <= i < indices.len() ==> result[i] == arr[indices[i] as int],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "indexing_slicing_tril", "vc-description": "numpy.tril: Lower triangle of an array.\n\nReturn a copy of an array with elements above the k-th diagonal zeroed.\nFor simplicity, this specification focuses on square matrices and k=0 (main diagonal).\n\nGiven a flattened square matrix (stored in row-major order), returns a copy\nwhere elements above the main diagonal are set to zero.\n\nThis captures the essential mathematical property of extracting the lower\ntriangular part of a matrix.\n\nSpecification: tril returns the lower triangle of a matrix with elements above the main diagonal zeroed.\n\nMathematical Properties:\n1. Shape Preservation: The output has the same shape as the input\n2. Lower Triangle Preservation: Elements at or below the main diagonal are unchanged\n3. Upper Triangle Zeroing: Elements above the main diagonal are set to zero\n4. Diagonal Definition: For a square matrix stored in row-major order,\n   element at position (i,j) corresponds to index i*n + j in the flattened vector\n\nThe main diagonal consists of elements where i = j.\nLower triangle consists of elements where i ≥ j.\nUpper triangle consists of elements where i < j.\n\nThis specification provides a foundation for formal verification of\ntriangular matrix operations in numerical computing.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn tril(matrix: Vec<f32>, n: usize) -> (result: Vec<f32>)\n    requires \n        n > 0,\n        matrix.len() == n * n,\n    ensures\n        result.len() == matrix.len(),\n        forall|i: usize, j: usize| #[trigger] result[i * n + j] == matrix[i * n + j] <==\n            i < n && j < n && i >= j,\n        forall|i: usize, j: usize| #[trigger] result[i * n + j] == 0.0f32 <==\n            i < n && j < n && i < j,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "indexing_slicing_triu", "vc-description": "Upper triangle of a matrix. Returns a copy of the matrix with elements below the k-th diagonal zeroed.\n\nGiven a matrix m and an integer k, this function returns a new matrix where:\n- Elements at position (i,j) where i+k <= j are preserved (upper triangle including k-th diagonal)\n- Elements at position (i,j) where i+k > j are set to zero (below k-th diagonal)\n\nThe diagonal offset k works as follows:\n- k = 0: main diagonal (default)\n- k > 0: diagonal above the main diagonal\n- k < 0: diagonal below the main diagonal\n\nSpecification: triu returns the upper triangle of a matrix with elements below the k-th diagonal set to zero.\n\nMathematical properties:\n1. Elements on and above the k-th diagonal are preserved: if i+k <= j, then result[i][j] = m[i][j]\n2. Elements below the k-th diagonal are zeroed: if i+k > j, then result[i][j] = 0\n3. The result matrix has the same dimensions as the input matrix\n\nThe k-th diagonal is defined as positions (i,j) where i+k = j:\n- When k=0: main diagonal (i=j)\n- When k>0: diagonal above main diagonal \n- When k<0: diagonal below main diagonal\n\nThis captures the essential behavior of numpy.triu which extracts the upper triangular part\nof a matrix relative to the k-th diagonal.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn triu(m: Vec<Vec<f64>>, k: i32) -> (result: Vec<Vec<f64>>)\n    requires \n        m.len() > 0,\n        forall|i: int| 0 <= i < m.len() ==> #[trigger] m[i].len() == m[0].len(),\n    ensures\n        result.len() == m.len(),\n        forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i].len() == m[0].len(),\n        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result[i].len() && (i as i32) + k <= (j as i32) ==> #[trigger] result[i][j] == m[i][j],\n        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result[i].len() && (i as i32) + k > (j as i32) ==> #[trigger] result[i][j] == 0.0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "indexing_slicing_unravel_index", "vc-description": "Converts a flat index or array of flat indices into a tuple of coordinate arrays.\nThis is the inverse operation of ravel_multi_index.\nSpecification: unravel_index converts flat indices to multi-dimensional coordinates\nsuch that the coordinates are valid for the given shape and represent the correct\npositions in the multi-dimensional array.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn vec_product(shape: Seq<usize>) -> nat\n    decreases shape.len()\n{\n    if shape.len() == 0 {\n        1nat\n    } else {\n        (shape[0] as nat) * vec_product(shape.skip(1))\n    }\n}", "vc-helpers": "", "vc-spec": "fn unravel_index(indices: Vec<usize>, shape: Vec<usize>) -> (result: Vec<Vec<usize>>)\n    requires \n        shape.len() > 0,\n        forall|i: int| 0 <= i < shape.len() ==> shape[i] > 0,\n        forall|i: int| 0 <= i < indices.len() ==> (indices[i] as nat) < vec_product(shape@),\n    ensures\n        result.len() == indices.len(),\n        forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i].len() == shape.len(),\n        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < shape.len() ==> \n            #[trigger] result[i][j] < shape[j],\n        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result.len() && i != j ==> \n            (indices[i] != indices[j] ==> result[i] != result[j])", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "indexing_slicing_where", "vc-description": "Return elements chosen from x or y depending on condition.\nGiven vectors of equal length for condition, x, and y, constructs a result vector\nwhere each element is selected from x if the corresponding condition is true,\notherwise from y.\n\nThis implements the core ternary conditional operation:\nresult[i] = condition[i] ? x[i] : y[i]\n\nThe function requires all three input vectors to have the same length, which\nis enforced by the type system using Vector types.\n\nSpecification: where returns elements chosen from x or y based on condition.\nThis captures the essential behavior of numpy.where function:\n\nMathematical properties:\n1. The result has the same length as all input vectors\n2. For each position i, if condition[i] is true, then result[i] = x[i]\n3. For each position i, if condition[i] is false, then result[i] = y[i]\n4. The function is deterministic - same inputs always produce same output\n5. The result is well-defined for all inputs (no partial functions)\n\nThis specification captures the core ternary conditional semantics:\nresult[i] = if condition.get i then x.get i else y.get i\n\nThe use of Vector types ensures type safety and eliminates the need for\nsize compatibility checks at runtime. All vectors must have the same length\nby construction.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn where_fn(condition: Vec<bool>, x: Vec<f32>, y: Vec<f32>) -> (result: Vec<f32>)\n    requires \n        condition.len() == x.len(),\n        x.len() == y.len(),\n    ensures \n        result.len() == condition.len(),\n        forall|i: int| 0 <= i < condition.len() ==> \n            result[i] == if condition[i] { x[i] } else { y[i] }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "io_operations_array2string", "vc-description": "numpy.array2string: Return a string representation of an array\n\nConverts an array to its string representation with customizable separator.\nThis function provides a way to format arrays for display purposes.\n\nThe separator parameter controls how elements are separated in the output.\n\nSpecification: array2string returns a string representation of the array\n\nPrecondition: True (no special preconditions)\nPostcondition: result is non-empty string that starts with '[' and ends with ']'", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn array2string(arr: Vec<f32>, separator: &str) -> (result: Vec<char>)\n    ensures\n        result@.len() > 0,\n        result@[0] == '[',\n        result@[result@.len() - 1] == ']'", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "io_operations_array_str", "vc-description": "Return a string representation of the data in a vector\n\nSpecification: array_str returns a formatted string representation of the vector data", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn array_str(a: Vec<f32>) -> (result: String)\n    ensures \n        result@.len() > 0,\n        a.len() == 0 ==> result@ == \"[]\"@,\n        a.len() > 0 ==> result@[0] == '[' && result@[(result@.len() - 1) as int] == ']',", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "io_operations_fromfile", "vc-description": "Construct an array from data in a text or binary file\n\nThis function provides a highly efficient way of reading binary data with a known data-type, \nas well as parsing simply formatted text files. Data written using the tofile method can be \nread using this function.\n\nConstruct a vector from data in a text or binary file\nParameters:\n- file: File handle for the input file\n- dtype: Data type of the returned array\n- count: Number of items to read (-1 means entire file)\n- sep: Separator between items (empty string means binary file)\n- offset: Byte offset from file's current position (binary files only)\n\nSpecification: fromfile reads data from a file and constructs a vector\nProperties:\n1. For binary files (sep = \"\"), reads exactly count items if count > 0\n2. For text files (sep ≠ \"\"), parses items separated by sep\n3. If count = -1, reads all available data\n4. Binary files respect the offset parameter\n5. The resulting vector has the correct size and data type\n6. Data is read sequentially from the file\n\n/* File handle abstraction for I/O operations */\n\n/* Path to the file */\n\n/* Whether the file is opened in binary mode */\n\n/* Current position in the file (in bytes) */\n\n/* Represents different data types that can be read from files */\n\n/* 32-bit floating point */\n\n/* 64-bit floating point */\n\n/* 32-bit signed integer */\n\n/* 64-bit signed integer */\n\n/* 8-bit unsigned integer */\n\n/* Get the size in bytes for each data type */\n\n/* For binary files, data is read sequentially from offset */\n\n/* Sequential reading property: elements maintain file order preserved */\n\n/* placeholder for ordering properties */\n\n/* Type consistency: all elements are well-typed */\n\n/* placeholder for type consistency */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nstruct FileHandle {\n\n    path: String,\n\n    is_binary: bool,\n\n    position: nat,\n}\n\nenum DType {\n\n    Float32,\n\n    Float64,\n\n    Int32,\n\n    Int64,\n\n    UInt8,\n}\n\nspec fn dtype_size_bytes(dtype: DType) -> nat {\n    match dtype {\n        DType::Float32 => 4,\n        DType::Float64 => 8,\n        DType::Int32 => 4,\n        DType::Int64 => 8,\n        DType::UInt8 => 1,\n    }\n}", "vc-helpers": "", "vc-spec": "fn fromfile(file: FileHandle, dtype: DType, count: i32, sep: &str, offset: nat) -> (result: Vec<i32>)\n    requires\n        count == -1 || count > 0,\n        sep == \"\" ==> file.is_binary == true,\n        file.is_binary == true ==> sep == \"\",\n    ensures\n        count > 0 ==> result.len() == count as usize,\n\n        file.is_binary == true ==> (\n            #[trigger] (result.len() * dtype_size_bytes(dtype))\n            >= 0\n        ),\n\n        true,\n\n        true,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "io_operations_fromstring", "vc-description": "Create a 1-D array from text data in a string.\nParses a string containing numeric data separated by a specified separator\nand returns a vector of the parsed values.\nSpecification: fromstring creates a vector by parsing numeric values from a string.\nThe function parses the input string using the given separator and converts\nthe resulting substrings to floating-point numbers.\n\n/* All parsed elements are valid */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn fromstring(input: &str, sep: &str, n: usize) -> (result: Vec<f64>)\n    requires n > 0,\n    ensures \n        result.len() <= n,\n        forall|i: int| 0 <= i < result.len() ==> true,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "io_operations_genfromtxt", "vc-description": "Load data from a text file, with missing values handled as specified. Load data from a text file with missing value handling. This is a simplified version focusing on numeric data parsing from delimited text. Specification: genfromtxt parses delimited text data into a matrix structure, handling missing values by filling them with the specified default value. The function skips the specified number of header lines and parses the remaining lines into a structured matrix.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn genfromtxt(input: Vec<String>, delimiter: String, fill_value: f32, skip_header: usize) -> (result: Vec<Vec<f32>>)\n    requires \n        skip_header < input.len(),\n    ensures\n        result.len() == input.len() - skip_header,\n        forall|i: int| 0 <= i < result.len() ==> {\n            let line_idx = (i + skip_header as int) as usize;\n            line_idx < input.len()\n        },", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "io_operations_load", "vc-description": "numpy.load: Load arrays or pickled objects from .npy, .npz or pickled files.\n\nLoads array data from a binary file. This operation reads serialized array data\nfrom disk storage and reconstructs it as a Vector. The function supports:\n- .npy files: Single array format\n- .npz files: Archive format with multiple arrays (simplified to single array here)\n- Pickled files: Python pickle format (when allow_pickle is True)\n\nThe file parameter represents the path to the file to be loaded.\nFor security reasons, pickled files should be avoided unless explicitly allowed.\n\nMemory mapping is not considered in this simplified specification.\n\nSpecification: numpy.load returns a vector containing the data from the file.\n\nThis specification captures the essential properties of the load operation:\n\n1. Data Preservation: The loaded vector contains exactly the data that was stored\n2. Size Consistency: The vector length matches the stored array dimensions\n3. Type Compatibility: Data is correctly interpreted as Float values\n4. Security Constraint: Object arrays are only loaded when explicitly allowed\n\nMathematical Properties:\n- Idempotence: Loading the same file multiple times yields identical results\n- Determinism: For a given file, load always returns the same vector\n- Injectivity: Different valid files produce different vectors (when they differ)\n\nPrecondition: The file exists, is readable, and contains valid array data\nPostcondition: The returned vector faithfully represents the stored data", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn load_ghost(file: String, allow_pickle: bool, n: nat) -> Vec<f64>;\n\nfn load(file: String, allow_pickle: bool, n: usize) -> (result: Vec<f64>)\n    ensures \n        result.len() == n,\n        forall|i: int| 0 <= i < n ==> exists|stored_val: f64| result[i] == stored_val,\n        forall|second_load: Vec<f64>| (#[trigger] second_load == load_ghost(file, allow_pickle, n as nat)) ==>\n            forall|i: int| 0 <= i < n ==> result[i] == second_load[i]", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "io_operations_loadtxt", "vc-description": "Load data from a text file into a 2D array.\nFor simplicity, this specification focuses on loading a rectangular matrix of floats.\n\nSpecification: loadtxt reads numeric data from a text file into a well-formed 2D array.\nThe function preserves the structure of the input data and handles parsing correctly.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn loadtxt(filename: Seq<char>, delimiter: Seq<char>, skiprows: usize, rows: usize, cols: usize) -> (result: Vec<Vec<f64>>)\n    requires \n        rows > 0,\n        cols > 0,\n        filename.len() > 0,\n    ensures\n        result.len() == rows,\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == cols,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "io_operations_save", "vc-description": "numpy.save: Save an array to a binary file in NumPy .npy format.\n\nSaves Vector data to a binary file in NumPy .npy format. This operation serializes \nthe array data and writes it to disk storage. The function supports:\n- Automatic .npy extension appending if not present\n- Binary format writing for efficient storage and loading\n- Security control via allow_pickle parameter\n\nThe file parameter represents the path where the data should be saved.\nFor security reasons, object arrays with pickled data should be avoided \nunless explicitly allowed.\n\nThis is a file output operation that creates or overwrites the target file.\n\nSpecification: numpy.save persists vector data to disk in a recoverable format.\n\nThis specification captures the essential properties of the save operation:\n\n1. Data Persistence: The vector data is written to the specified file\n2. Format Consistency: Data is saved in .npy format for later loading\n3. File Creation: The target file is created or overwritten\n4. Extension Management: .npy extension is added if not present\n5. Security Control: Object arrays are only saved when explicitly allowed\n\nMathematical Properties:\n- Determinism: Saving the same vector to the same file produces identical results\n- Completeness: All vector elements are preserved in the saved format\n- Recoverability: The saved data can be loaded back to reconstruct the original vector\n- Idempotence: Multiple saves of the same data to the same file yield identical files\n\nPrecondition: The file path is valid and writable\nPostcondition: The file exists and contains the serialized vector data", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn save(file: String, arr: Vec<f32>, allow_pickle: bool) -> (result: ())\n    ensures result == (),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "io_operations_savez", "vc-description": "numpy.savez: Save several arrays into a single file in uncompressed .npz format.\n\nSaves multiple Vector arrays to a single .npz archive file. This operation\nserializes multiple arrays into a single compressed archive, where each array\nis stored as a separate .npy file within the archive.\n\nKey functionality:\n- Multiple arrays can be saved in a single operation\n- Each array is stored with an associated name within the archive\n- The resulting .npz file can be loaded later to recover the arrays\n- Arrays are stored in uncompressed .npy format within the archive\n\nThe function takes a file path and multiple arrays to save. For simplicity,\nthis specification focuses on saving exactly two arrays (commonly used case).\n\nSecurity considerations:\n- Pickle support is controlled by allow_pickle parameter\n- Invalid file paths or write permissions can cause failures\n- The archive format ensures data integrity through checksums\n\nSpecification: numpy.savez creates a .npz archive containing multiple arrays.\n\nThis specification captures the essential properties of the savez operation:\n\n1. Data Persistence: Arrays are written to disk in a retrievable format\n2. Archive Structure: Multiple arrays are bundled into a single .npz file\n3. Data Integrity: Saved arrays can be loaded with identical values\n4. Name Association: Arrays are stored with identifiable names in the archive\n5. Format Compliance: Output follows .npz format specification\n\nMathematical Properties:\n- Bijection: There exists a one-to-one correspondence between saved and loaded arrays\n- Preservation: All array values are preserved exactly in the archive\n- Atomicity: Either all arrays are saved successfully or none are saved\n- Idempotence: Saving the same arrays multiple times produces identical files\n\nSecurity Properties:\n- Pickle safety: Object arrays are only saved when explicitly allowed\n- File system safety: Operation respects file system permissions\n\nPrecondition: File path is writable and arrays are valid\nPostcondition: Archive file exists and contains both arrays with recoverable data\n\n/* h_writable and h_valid_path assumptions */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn savez(file: String, arr1: Vec<f32>, arr2: Vec<f32>, allow_pickle: bool) -> (result: ())\n    requires \n        true,\n    ensures \n        result == (),\n        exists|archive_exists: bool| archive_exists == true,\n        exists|recoverable_arr1: Vec<f32>| \n            recoverable_arr1.len() == arr1.len() &&\n            forall|i: int| 0 <= i < arr1.len() ==> recoverable_arr1[i] == arr1[i],\n        exists|recoverable_arr2: Vec<f32>| \n            recoverable_arr2.len() == arr2.len() &&\n            forall|i: int| 0 <= i < arr2.len() ==> recoverable_arr2[i] == arr2[i],\n        exists|file_size: nat| file_size > 0", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "linalg_LinAlgError", "vc-description": "Generic Python-exception-derived object raised by linalg functions.\nError checking predicate for linear algebra operations.\nSpecification: Linear algebra error detection correctly identifies error conditions.\n\n/* Linear algebra error type representing conditions that prevent correct execution of linalg functions */\n\n/* Error when numerical algorithm fails to converge */\n\n/* Error when matrix is singular (non-invertible) */\n\n/* Error when operation requires square matrix but input is not square */\n\n/* Error when matrix dimensions are incompatible for the operation */\n\n/* Error when input parameters are invalid */\n\n/* Error when numerical computation becomes unstable */\n\n/* Generic error for other linear algebra failures */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\npub enum LinAlgError {\n\n    NonConvergence(String),\n\n    SingularMatrix(String),\n\n    NonSquareMatrix(String),\n\n    IncompatibleDimensions(String),\n\n    InvalidInput(String),\n\n    NumericalInstability(String),\n\n    Other(String),\n}", "vc-helpers": "", "vc-spec": "fn check_lin_alg_error(condition: bool, error_type: spec_fn(String) -> LinAlgError, message: String) -> (result: Option<LinAlgError>)\n    ensures \n        condition == true ==> result == Some(error_type(message)),\n        condition == false ==> result == None::<LinAlgError>,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "linalg_diagonal", "vc-description": "numpy.linalg.diagonal: Returns specified diagonals of a matrix.\n\nExtracts the diagonal elements from a matrix. The offset parameter\ncontrols which diagonal to extract:\n- offset = 0: main diagonal (elements at position [i,i])\n- offset > 0: diagonals above the main diagonal (elements at [i,i+offset])\n- offset < 0: diagonals below the main diagonal (elements at [i-offset,i])\n\nFor simplicity, we return a vector of size min(m,n) which is valid for offset=0.\nThe actual diagonal length depends on the offset value and matrix dimensions.\n\nSpecification: numpy.linalg.diagonal returns the diagonal elements of a matrix.\n\nPrecondition: The matrix must be non-empty (both dimensions > 0)\nPostcondition: The result contains the diagonal elements extracted from the matrix.\n               - For offset = 0: result[i] = x[i][i] (main diagonal)\n               - The result vector has the same type as the input matrix elements\n               - The extraction respects the mathematical definition of matrix diagonals", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn spec_min(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n\nfn numpy_diagonal(x: Vec<Vec<f32>>, offset: i32) -> (result: Vec<f32>)\n    requires \n        x.len() > 0,\n        x.len() < usize::MAX,\n        forall|i: int| 0 <= i < x.len() ==> x[i].len() > 0,\n        forall|i: int| 0 <= i < x.len() ==> x[i].len() == x[0].len(),\n    ensures\n        result.len() == spec_min(x.len() as int, x[0].len() as int),\n        offset == 0 ==> forall|i: int| 0 <= i < result.len() ==> \n            result[i] == x[i][i],\n        forall|i: int| 0 <= i < result.len() ==> \n            exists|r: int, c: int| \n                0 <= r < x.len() && 0 <= c < x[0].len() &&\n                result[i] == x[r][c],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "linalg_eig", "vc-description": "Compute the eigenvalues and right eigenvectors of a square matrix.\n\nFor a square matrix A, this function computes vectors v and scalars λ such that:\nA * v = λ * v\n\nReturns a pair (eigenvalues, eigenvectors) where:\n- eigenvalues: Vector of eigenvalues λ_i\n- eigenvectors: Matrix where column i is the eigenvector corresponding to eigenvalue λ_i\n\nSpecification: eig computes the eigenvalues and right eigenvectors of a square matrix.\n\nThe fundamental eigenvalue equation is: A * v = λ * v, where:\n- A is the input matrix\n- v is an eigenvector (non-zero vector)\n- λ is the corresponding eigenvalue\n\nThis specification captures the mathematical properties of eigenvalues and eigenvectors:\n1. The eigenvalue equation holds for each eigenvalue-eigenvector pair\n2. Eigenvectors are normalized (unit length) \n3. For diagonal matrices, eigenvalues are the diagonal elements\n4. Identity matrix has eigenvalue 1 with multiplicity n\n\n/* Main eigenvalue equation: A * v = λ * v (simplified specification) */\n\n/* Placeholder for eigenvalue equation */\n\n/* For diagonal matrices, eigenvalues are diagonal elements */\n\n/* Eigenvectors are non-zero */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn eig(a: Vec<Vec<f32>>) -> (result: (Vec<f32>, Vec<Vec<f32>>))\n    requires \n        a.len() > 0,\n        forall|i: int| 0 <= i < a.len() ==> a[i].len() == a.len(),\n    ensures\n        result.0.len() == a.len() && result.1.len() == a.len(),\n        forall|i: int| 0 <= i < result.1.len() ==> result.1[i].len() == a.len(),\n\n        true,\n\n        (forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() && i != j ==> a[i][j] == 0.0f32) ==> \n        (forall|i: int| #![trigger a[i]] 0 <= i < a.len() ==> \n            exists|j: int| 0 <= j < result.0.len() && result.0[j] == a[i][i]),\n\n        forall|col: int| #![trigger result.1[col]] 0 <= col < a.len() ==> \n            exists|row: int| 0 <= row < a.len() && result.1[row][col] != 0.0f32,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "linalg_eigh", "vc-description": "Compute eigenvalues and eigenvectors of a Hermitian or symmetric matrix.\n\nReturns the eigenvalues and eigenvectors of a complex Hermitian or symmetric matrix.\nThe function takes a Hermitian or symmetric matrix and returns eigenvalues in ascending order\nand the normalized eigenvectors satisfying the eigenvalue equation.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "struct EighResult {\n    eigenvalues: Vec<f32>,\n    eigenvectors: Vec<Vec<f32>>,\n}\n\nfn eigh(a: Vec<Vec<f32>>) -> (result: EighResult)\n    requires \n        a.len() > 0,\n        forall|i: int| 0 <= i < a.len() ==> a[i]@.len() == a.len(),\n        forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() ==> a[i][j] == a[j][i],\n    ensures\n        result.eigenvalues.len() == a.len(),\n        result.eigenvectors.len() == a.len(),\n        forall|i: int| 0 <= i < result.eigenvectors.len() ==> result.eigenvectors[i]@.len() == a.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "linalg_eigvals", "vc-description": "Compute the eigenvalues of a general matrix\n\nCompute the eigenvalues of a general matrix.\n\nMain difference from eig: Does not compute eigenvectors.\n\nParameters:\n- a: Square array\n\nReturns:\n- w: The eigenvalues, not necessarily ordered\n\nCompute the eigenvalues of a general square matrix\n\nSpecification: eigvals computes eigenvalues of a square matrix\n\n/* Complex number type for eigenvalues */\n\n/* For diagonal matrices, eigenvalues are the diagonal elements */\n\n/* This captures the key mathematical property from the numpy documentation */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nstruct Complex {\n    re: f32,\n    im: f32,\n}", "vc-helpers": "", "vc-spec": "fn eigvals(a: Vec<Vec<f32>>) -> (result: Vec<Complex>)\n    requires \n        a.len() > 0,\n        forall|i: int| 0 <= i < a.len() ==> (#[trigger] a[i]).len() == a.len(),\n    ensures \n        result.len() == a.len(),\n\n        (forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() && i != j ==> #[trigger] a[i][j] == 0.0f32) ==>\n        (forall|i: int| #![auto] 0 <= i < a.len() ==> \n            exists|j: int| 0 <= j < result.len() && \n                result[j].re == a[i][i] && result[j].im == 0.0f32),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "linalg_matmul", "vc-description": "Matrix multiplication for 2D matrices. Computes the matrix product of two 2D arrays following standard matrix multiplication rules. The result matrix C has dimensions (m x p) where A is (m x n) and B is (n x p).\n\nSpecification: Matrix multiplication produces a result where each element is the dot product of the corresponding row from the first matrix and column from the second matrix.\n\nMathematical properties:\n1. Dimensions are compatible: A is m×n, B is n×p, result is m×p\n2. Each element C[i][j] = sum of A[i][k] * B[k][j] for k from 0 to n-1\n3. The operation preserves the fundamental matrix multiplication identity\n4. Non-commutativity: A*B ≠ B*A in general (handled by type system)\n5. Associativity: (A*B)*C = A*(B*C) when dimensions are compatible", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn matmul(A: Vec<Vec<f32>>, B: Vec<Vec<f32>>) -> (result: Vec<Vec<f32>>)\n    requires\n        A.len() > 0,\n        B.len() > 0,\n        A@[0].len() == B.len(),\n        forall|i: int| 0 <= i < A.len() ==> #[trigger] A@[i].len() == A@[0].len(),\n        forall|i: int| 0 <= i < B.len() ==> #[trigger] B@[i].len() == B@[0].len(),\n    ensures\n        result.len() == A.len(),\n        result.len() > 0 ==> result@[0].len() == B@[0].len(),\n        forall|i: int| 0 <= i < result.len() ==> #[trigger] result@[i].len() == B@[0].len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "linalg_matrix_power", "vc-description": "numpy.linalg.matrix_power: Raise a square matrix to the (integer) power n.\n\nFor positive integers n, the power is computed by repeated matrix squarings and \nmatrix multiplications. If n == 0, the identity matrix is returned. \nIf n < 0, the inverse is computed and raised to abs(n).\n\nThis implements the mathematical operation A^n for square matrices A.\nThe operation follows the standard mathematical definition:\n- A^0 = I (identity matrix)\n- A^1 = A\n- A^n = A * A^(n-1) for n > 1\n- A^(-n) = (A^(-1))^n for n < 0\n\nSpecification: matrix_power raises a square matrix to an integer power.\n\nPrecondition: The matrix A must be square (n×n). For negative powers,\nthe matrix must be invertible (non-singular).\n\nPostcondition: The result satisfies the mathematical definition of matrix exponentiation:\n1. For exp = 0: result is the identity matrix\n2. For exp = 1: result equals the input matrix A\n3. For exp > 1: result = A * A^(exp-1) (recursive definition)\n4. For exp < 0: result = (A^(-1))^|exp| (inverse raised to absolute value)\n\nMathematical properties:\n- A^0 = I (identity matrix) for any square matrix A\n- A^1 = A for any square matrix A\n- A^m * A^n = A^(m+n) for any integers m, n (when A is invertible for negative powers)\n- (A^m)^n = A^(m*n) for any integers m, n (when A is invertible for negative powers)\n- If A is invertible, then A^(-1) * A = A * A^(-1) = I\n- Matrix power preserves the dimension: n×n input produces n×n output\n\nThis captures the complete mathematical characterization of matrix exponentiation.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn matrix_power(a: Vec<Vec<f32>>) -> (result: Vec<Vec<f32>>)\n    requires \n        a.len() > 0,\n        forall|i: int| 0 <= i < a.len() ==> a[i].len() == a.len(),\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == a.len(),\n        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result[i].len() ==> exists|val: f32| result[i][j] == val,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "linalg_matrix_rank", "vc-description": "numpy.linalg.matrix_rank: Return matrix rank of array using SVD method.\n\nThe rank of a matrix is the number of linearly independent columns\n(or rows). For numerical computation, this is determined by counting\nthe number of singular values greater than a threshold.\n\nThis implementation focuses on the core mathematical behavior for\nsquare matrices, using default tolerance.\n\nSpecification: matrix_rank computes the rank of a matrix using SVD method.\n\nThe rank is the number of singular values greater than a numerical threshold.\nThis corresponds to the number of linearly independent columns (or rows).\n\nMathematical definition:\n- For a matrix A, rank(A) = number of non-zero singular values\n- In numerical computation, \"non-zero\" means above a threshold\n\nKey properties verified:\n1. Bounds: 0 ≤ rank(A) ≤ min(m, n) for m×n matrix\n2. Zero matrix: rank(0) = 0 (all elements zero)\n3. Identity matrix: rank(I) = n for n×n identity matrix\n4. Rank deficiency: If a row/column is all zeros, rank < full rank\n5. Linear dependence: If rows/columns are linearly dependent, rank < full rank\n\nThe threshold behavior ensures numerical stability but is not explicitly\nspecified here for simplicity.\n\n/* Zero matrix has rank 0 */\n\n/* Identity matrix has full rank */\n\n/* For 1x1 matrices */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn min_usize(a: usize, b: usize) -> usize {\n    if a <= b { a } else { b }\n}\n\nfn matrix_rank(A: Vec<Vec<f32>>) -> (result: usize)\n    requires \n        A.len() > 0,\n        A[0].len() > 0,\n        forall|i: int| 0 <= i < A.len() ==> #[trigger] A[i].len() == A[0].len(),\n    ensures\n        result <= min_usize(A.len(), A[0].len()),\n\n        (forall|i: int, j: int| 0 <= i < A.len() && 0 <= j < A[0].len() ==> #[trigger] A[i][j] == 0.0f32) ==> result == 0,\n\n        (A.len() == A[0].len() && forall|i: int, j: int| 0 <= i < A.len() && 0 <= j < A[0].len() ==> #[trigger] A[i][j] == (if i == j { 1.0f32 } else { 0.0f32 })) ==> result == A.len(),\n\n        (A.len() == 1 && A[0].len() == 1) ==> ((result == 1) <==> (A[0][0] != 0.0f32)),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "linalg_matrix_transpose", "vc-description": "numpy.linalg.matrix_transpose: Transposes a matrix (or a stack of matrices).\n\nFor a 2D matrix, this operation swaps the rows and columns.\nThe element at position (i, j) in the input matrix becomes the element\nat position (j, i) in the output matrix.\n\nInput: A matrix with rows × cols dimensions\nOutput: A matrix with cols × rows dimensions (transposed)\n\nSpecification: numpy.linalg.matrix_transpose returns the transpose of the input matrix.\n\nFor a matrix x with dimensions rows × cols, the transpose x_T has dimensions cols × rows.\nThe element at position (i, j) in the original matrix x becomes the element at position (j, i) in x_T.\n\nPrecondition: True (no special preconditions for matrix transpose)\nPostcondition: For all valid indices i and j, x_T[j][i] = x[i][j]", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_matrix_transpose(x: Vec<Vec<f32>>) -> (result: Vec<Vec<f32>>)\n    requires \n        x.len() > 0,\n        forall|i: int| 0 <= i < x.len() ==> x[i].len() > 0,\n        forall|i: int, j: int| 0 <= i < x.len() && 0 <= j < x.len() ==> x[i].len() == x[j].len(),\n    ensures\n        result.len() == (if x.len() > 0 { x[0].len() } else { 0 }),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == x.len(),\n        forall|i: int, j: int| 0 <= i < x.len() && 0 <= j < x[0].len() ==> result[j][i] == x[i][j],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "linalg_multi_dot", "vc-description": "Multi-dot product: compute the dot product of multiple matrices in a single function call\nwith optimal parenthesization. This function performs a chain of matrix multiplications\nA₁ × A₂ × ... × Aₙ where the parenthesization is chosen to minimize computational cost.\n\nFor three matrices A, B, C, this computes A × B × C with the optimal evaluation order.\nThe result is independent of parenthesization due to associativity of matrix multiplication.\n\nSpecification: Multi-dot performs a chain of matrix multiplications with optimal parenthesization.\n\nMathematical properties:\n1. Associativity: (A × B) × C = A × (B × C) - the result is independent of parenthesization\n2. Dimension compatibility: A is n₁×n₂, B is n₂×n₃, C is n₃×n₄, result is n₁×n₄\n3. Element-wise computation: result[i][j] equals the triple sum over intermediate indices\n4. Optimal evaluation order: the implementation chooses the parenthesization that minimizes \n   the total number of scalar multiplications needed\n5. Correctness: the result equals the sequential application of matrix multiplications\n6. Non-empty constraint: at least two matrices are required (enforced by signature)\n\nThis specification captures the essential mathematical behavior while abstracting away \nthe optimization details. The key insight is that matrix multiplication is associative,\nso different parenthesizations yield the same mathematical result.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn multi_dot(A: Vec<Vec<f64>>, B: Vec<Vec<f64>>, C: Vec<Vec<f64>>) -> (result: Vec<Vec<f64>>)\n    requires \n        A.len() > 0,\n        B.len() > 0, \n        C.len() > 0,\n        forall|i: int| 0 <= i < A.len() ==> A[i].len() == B.len(),\n        forall|i: int| 0 <= i < B.len() ==> B[i].len() == C.len(),\n        forall|i: int| 0 <= i < C.len() ==> C[i].len() > 0,\n    ensures\n        result.len() == A.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == C[0].len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "linalg_norm", "vc-description": "numpy.linalg.norm: Compute the 2-norm (Euclidean norm) of a vector.\n\nThis is the default vector norm when ord=None. For a vector x,\nthe 2-norm is defined as: ||x||_2 = sqrt(sum(x[i]^2))\n\nThis implementation focuses on the most common use case: computing\nthe Euclidean norm of a 1D vector.\n\nSpecification: norm computes the Euclidean norm (2-norm) of a vector.\n\nThe 2-norm is defined as the square root of the sum of squares of all elements.\nThis is the most common vector norm used in numerical computing and is the\ndefault norm in NumPy when ord=None.\n\nMathematical definition:\n- For a vector x = [x₁, x₂, ..., xₙ], the 2-norm is: ||x||₂ = √(Σᵢ xᵢ²)\n\nKey properties verified:\n1. Definition: result equals sqrt of sum of squared elements\n2. Non-negativity: norm(x) ≥ 0 for all x\n3. Definiteness: norm(x) = 0 if and only if x is the zero vector\n4. Empty vector: norm of empty vector is 0\n\nNote: Properties like triangle inequality and homogeneity follow from\nthe definition but are not explicitly stated in this specification.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn norm(x: Vec<f32>) -> (result: f32)\n    requires true,\n    ensures true,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "linalg_outer", "vc-description": "Compute the outer product of two vectors.\nGiven vectors a of size m and b of size n, produces an m×n matrix\nwhere element (i,j) equals a[i] * b[j].\n\nSpecification: The outer product produces a matrix where each element (i,j)\nis the product of the i-th element of the first vector and the j-th element\nof the second vector. This captures the fundamental mathematical property\nthat outer(a,b)[i,j] = a[i] * b[j].\n\nThe specification includes:\n1. Core property: Each matrix element equals the product of corresponding vector elements\n2. Row structure: Each row i is the vector b scaled by a[i]\n3. Column structure: Each column j is the vector a scaled by b[j]\n4. Bilinearity: The outer product is linear in both arguments\n\nThis captures the essential mathematical behavior of the outer product operation,\nwhich is fundamental in linear algebra and tensor analysis.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn outer_i32(a: Vec<i32>, b: Vec<i32>) -> (result: Vec<Vec<i32>>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == b.len(),\n        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result[i].len() ==> \n            result[i][j] == a[i] * b[j],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "linalg_slogdet", "vc-description": "Compute the sign and (natural) logarithm of the determinant of a square matrix.\n\nThis function is more numerically stable than computing log(det(a)) directly,\nespecially for very small or very large determinants.\n\nFor real matrices, the sign is -1, 0, or 1.\nFor complex matrices, the sign has absolute value 1 (on the unit circle) or 0.\n\nThe determinant can be recovered as: det = sign * exp(logabsdet)\n\nSpecification: slogdet computes the sign and natural logarithm of the determinant\n\nThe function returns a tuple (sign, logabsdet) where:\n- sign is -1, 0, or 1 for real matrices\n- logabsdet is the natural log of the absolute value of the determinant\n- The original determinant can be recovered as: det = sign * exp(logabsdet)\n- The function provides a numerically stable way to compute logarithms of determinants", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn slogdet(a: Vec<Vec<f32>>) -> (result: (f32, f32))\n    requires \n        a.len() > 0,\n        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i].len() == a.len(),\n    ensures ({\n        let (sign, logabsdet) = result;\n        (sign == -1.0f32 || sign == 0.0f32 || sign == 1.0f32)\n    }),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "linalg_tensordot", "vc-description": "numpy.tensordot: Compute tensor dot product along specified axes.\n\nGiven two tensors a and b, and axes, sums the products of a's and b's \nelements over the axes specified. For 1-D arrays (vectors) with axes=1,\nthis computes the inner product of vectors.\n\nThis specification focuses on the 1-D case with axes=1, which is equivalent\nto the dot product operation.\n\nSpecification: tensordot computes the tensor dot product along specified axes.\n\nFor 1-D vectors with axes=1, this is equivalent to the inner product:\nresult = sum(a[i] * b[i] for i in 0..n-1)\n\nMathematical properties:\n- Commutative: tensordot(a, b, 1) = tensordot(b, a, 1)\n- Bilinear: tensordot(α*a + β*c, b, 1) = α*tensordot(a, b, 1) + β*tensordot(c, b, 1)\n- Zero vector: tensordot(zeros, b, 1) = 0\n- Self-product: tensordot(a, a, 1) = ||a||²\n\nPrecondition: axes = 1 (for 1-D vector case)\nPostcondition: result equals the sum of element-wise products", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn dot_product_recursive(a: Seq<i32>, b: Seq<i32>, i: nat) -> int\n    decreases a.len() - i\n{\n    if i >= a.len() {\n        0\n    } else {\n        a[i as int] * b[i as int] + dot_product_recursive(a, b, i + 1)\n    }\n}\n\nspec fn dot_product(a: Seq<i32>, b: Seq<i32>) -> int {\n    dot_product_recursive(a, b, 0)\n}\n\nfn tensordot(a: Vec<i32>, b: Vec<i32>, axes: usize) -> (result: i32)\n    requires \n        a.len() == b.len(),\n        axes == 1,\n    ensures result == dot_product(a@, b@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "linalg_tensorinv", "vc-description": "Compute the 'inverse' of an N-dimensional array\n\nThe result is an inverse for a relative to the tensordot operation tensordot(a, b, ind), i.e., up to floating-point accuracy, tensordot(tensorinv(a), a, ind) is the identity tensor.\n\nCompute the 'inverse' of an N-dimensional array.\nFor simplicity, we implement the case where the tensor is represented as a 2D matrix\n(viewed as a flattened N-dimensional array) and we compute its matrix inverse.\nThe result should be the inverse for the tensordot operation.\n\nSpecification: tensorinv computes the tensor inverse such that when composed\nwith the original tensor via tensordot operation, it yields the identity tensor.\nThe key properties are:\n1. The result has the same square dimensions as the input\n2. The tensor inverse, when applied via tensordot, acts as a left inverse\n3. The tensor must be 'square' (equal first and last dimensions products)\n4. The index parameter must be positive", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn tensorinv(a: Vec<Vec<f32>>, ind: usize) -> (result: Vec<Vec<f32>>)\n    requires \n        a.len() > 0,\n        ind > 0,\n        forall|i: int| 0 <= i < a.len() ==> a[i].len() == a.len(),\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == a.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "linalg_tensorsolve", "vc-description": "Solve the tensor equation a x = b for x.\n\nThis function solves for x in the tensor equation a x = b, where:\n- a is a coefficient tensor that can be reshaped to a square matrix\n- b is the right-hand tensor  \n- x is the solution tensor\n\nFor simplicity, we model this as solving a square linear system where the \ncoefficient matrix a is reshaped from tensor form to a 2D matrix, and the \nsolution is reshaped back to tensor form.\n\nSpecification: tensorsolve solves the tensor equation a x = b for x.\n\nThis specification captures the mathematical properties of tensor equation solving:\n\n1. **Correctness**: The solution x satisfies the matrix equation a x = b\n2. **Invertibility**: The coefficient matrix a must be invertible\n3. **Uniqueness**: The solution is unique when a is invertible\n\nThe specification handles the basic case where:\n- a is an n×n coefficient matrix (representing a reshaped tensor)\n- b is an n-dimensional right-hand vector\n- x is the n-dimensional solution vector", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_square_matrix(a: Seq<Seq<f64>>) -> bool {\n    a.len() > 0 && forall|i: int| 0 <= i < a.len() ==> a[i].len() == a.len()\n}\n\nspec fn is_invertible_matrix(a: Seq<Seq<f64>>) -> bool {\n    is_square_matrix(a) &&\n    exists|a_inv: Seq<Seq<f64>>| \n        is_square_matrix(a_inv) && \n        a_inv.len() == a.len() &&\n        forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() ==> #[trigger] a[i][j] == a[i][j]\n}\n\nfn tensorsolve(a: Vec<Vec<f64>>, b: Vec<f64>) -> (result: Vec<f64>)\n    requires\n        a.len() > 0,\n        forall|i: int| 0 <= i < a.len() ==> a[i].len() == a.len(),\n        b.len() == a.len(),\n        is_square_matrix(a@.map(|i, row: Vec<f64>| row@)),\n        is_invertible_matrix(a@.map(|i, row: Vec<f64>| row@)),\n    ensures\n        result.len() == b.len(),\n        forall|i: int| 0 <= i < a.len() ==> #[trigger] b[i] == b[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "linalg_vecdot", "vc-description": "Compute the vector dot product of two vectors\n\nSpecification: vecdot computes the mathematical dot product as the sum of element-wise products.\nThis captures the mathematical definition: a · b = Σ(i=0 to n-1) a_i * b_i.\n\nKey properties:\n- Commutativity: vecdot(x1, x2) = vecdot(x2, x1)\n- Linearity: vecdot(c*x1, x2) = c * vecdot(x1, x2)\n- Zero vector: vecdot(0, x) = 0\n- Self-dot gives sum of squares: vecdot(x, x) = Σ(x_i²)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn dot_product_spec(x1: Seq<i32>, x2: Seq<i32>) -> int\n    decreases x1.len()\n{\n    if x1.len() == 0 || x1.len() != x2.len() {\n        0\n    } else {\n        x1[0] * x2[0] + dot_product_spec(x1.skip(1), x2.skip(1))\n    }\n}\n\nfn vecdot(x1: Vec<i32>, x2: Vec<i32>) -> (result: i32)\n    requires x1.len() == x2.len(),\n    ensures \n        result as int == dot_product_spec(x1@, x2@),\n        result as int == dot_product_spec(x2@, x1@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "linalg_vector_norm", "vc-description": "numpy.linalg.vector_norm: Compute the p-norm of a vector for a given order p.\n\nThis function computes vector norms of different orders (p-norms).\nFor a vector x and order p, the p-norm is defined as:\n||x||_p = (sum(|x[i]|^p))^(1/p) for p ≥ 1\n\nSpecial cases:\n- p = 1: Manhattan norm (sum of absolute values)\n- p = 2: Euclidean norm (square root of sum of squares)\n- p = ∞: Maximum norm (largest absolute value)\n- p = -∞: Minimum norm (smallest absolute value)\n- p = 0: Zero norm (count of non-zero elements)\n\nThis implementation focuses on the most common p-norm cases for 1D vectors.\n\nSpecification: vector_norm computes the p-norm of a vector for various values of p.\n\nThe p-norm is a generalization of the common vector norms used in numerical computing.\nThis specification covers the mathematical definition and key properties of p-norms.\n\nMathematical definition:\n- For p ≥ 1: ||x||_p = (Σᵢ |xᵢ|^p)^(1/p)\n- For p = 1: ||x||_1 = Σᵢ |xᵢ| (Manhattan norm)\n- For p = 2: ||x||_2 = √(Σᵢ xᵢ²) (Euclidean norm)\n- For p = 0: ||x||_0 = count of non-zero elements\n\nKey properties verified:\n1. Definition: For p ≥ 1, result equals (sum of |xi|^p)^(1/p)\n2. Non-negativity: norm(x, p) ≥ 0 for all x and valid p\n3. Definiteness: norm(x, p) = 0 iff x is zero vector (for p > 0)\n4. Special cases: p=1 (Manhattan), p=2 (Euclidean), p=0 (zero norm)\n5. Empty vector: norm of empty vector is 0\n\nPreconditions:\n- p must be a non-negative real number\n- For p = 0, it counts non-zero elements (special case)\n- For p ≥ 1, it computes the standard p-norm", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn vector_norm(x: Vec<i32>, p: i32) -> (result: i32)\n    requires p >= 0,\n    ensures \n        result >= 0,\n        x@.len() == 0 ==> result == 0,\n        result >= 0", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "logic_functions_all", "vc-description": "Test whether all array elements evaluate to True.\nElements are considered True if they are non-zero.\nNaN, positive infinity and negative infinity evaluate to True.\n\nSpecification: all returns True if and only if all elements are non-zero.\nThis includes proper handling of special float values:\n- NaN evaluates to True (it is not equal to zero)\n- Positive and negative infinity evaluate to True (they are not equal to zero)\n- Only 0.0 and -0.0 evaluate to False\n\nMathematical properties:\n- Empty vector returns True (vacuous truth)\n- all is monotonic: if all(a) is True and b has same non-zero elements, then all(b) is True\n- all(a) = not(any(map(λx. x = 0, a))) - equivalent to checking no element is zero\n\nSanity checks:\n- For empty vector (n = 0), the result is True by vacuous truth\n- For single element [x], result is True iff x ≠ 0\n- For vector with all non-zero elements, result is True\n- For vector with at least one zero element, result is False\n\nAdditional properties:\n- Idempotent: all(all(a)) = all(a) (when treating Bool as numeric)\n- Distributive over logical AND: all(a) ∧ all(b) → all(pointwise_and(a, b))\n- Relationship to logical AND reduction: all(a) = fold(∧, true, map(≠ 0, a))", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn all(a: Vec<f32>) -> (result: bool)\n    ensures\n        result == (forall|i: int| 0 <= i < a.len() ==> a[i] != 0.0f32),\n        (a.len() == 0 ==> result == true),\n        ((exists|i: int| 0 <= i < a.len() && a[i] == 0.0f32) ==> result == false),\n        ((forall|i: int| 0 <= i < a.len() ==> a[i] != 0.0f32) ==> result == true),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "logic_functions_allclose", "vc-description": "numpy.allclose: Returns True if two arrays are element-wise equal within a tolerance.\n\nThe tolerance values are positive, typically very small numbers. The\nrelative difference (rtol * abs(b)) and the absolute difference\natol are added together to compare against the absolute difference\nbetween a and b.\n\nFor each element, the condition is:\nabsolute(a - b) <= (atol + rtol * absolute(b))\n\nThis function returns True if ALL elements satisfy this condition,\nFalse otherwise.\n\nSpecification: allclose returns true iff all elements are within tolerance.\n\nPrecondition: rtol >= 0 and atol >= 0 (tolerance values must be non-negative)\nPostcondition: result = true iff all elements satisfy the tolerance condition\n               abs(a[i] - b[i]) <= atol + rtol * abs(b[i]) for all i", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn int_abs(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}", "vc-helpers": "", "vc-spec": "fn allclose(a: Vec<i32>, b: Vec<i32>, rtol: i32, atol: i32) -> (result: bool)\n    requires \n        a.len() == b.len(),\n        rtol >= 0,\n        atol >= 0,\n    ensures \n        result == (forall|i: int| 0 <= i < a.len() ==> \n            int_abs((a[i] - b[i]) as int) <= (atol + rtol * int_abs(b[i] as int)) as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "logic_functions_any", "vc-description": "Test whether any element in a vector evaluates to True.\n\nFor numeric types, returns true if any element is non-zero.\nSpecial values like NaN, positive/negative infinity are considered True.\nThis follows NumPy's convention where non-zero values are truthy.\n\nThis is a reduction operation that performs logical OR across all elements,\ntreating non-zero values as True and zero as False.\n\nSpecification: `any` returns true if and only if at least one element in the vector is non-zero.\n\nThe specification captures comprehensive mathematical properties:\n1. Logical equivalence: result is true iff there exists a non-zero element\n2. Completeness: result is false iff all elements are zero\n3. Empty vector behavior: returns false for empty vectors\n4. Monotonicity: adding more elements can only increase the chance of being true\n\nThis matches NumPy's behavior where:\n- Non-zero values (including NaN, ±∞) evaluate to True\n- Only zero evaluates to False\n- Empty arrays return False", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn any(v: Vec<f32>) -> (result: bool)\n    ensures \n        (result == true <==> exists|i: int| 0 <= i < v.len() && v[i] != 0.0f32) &&\n        (result == false <==> forall|i: int| 0 <= i < v.len() ==> v[i] == 0.0f32) &&\n        (v.len() == 0 ==> result == false) &&\n        (forall|i: int| 0 <= i < v.len() ==> v[i] == 0.0f32 ==> result == false) &&\n        (exists|i: int| 0 <= i < v.len() && v[i] != 0.0f32 ==> result == true) &&\n        (result == true || result == false) &&\n        !(result == true && result == false)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "logic_functions_array_equal", "vc-description": "numpy.array_equal: True if two arrays have the same shape and elements, False otherwise.\n\nCompares two arrays element-wise and returns a single boolean value indicating\nwhether the arrays are completely equal. Unlike element-wise comparison functions,\nthis returns a single boolean result for the entire comparison.\n\nThe function returns True if and only if:\n1. The arrays have the same shape (enforced by Vector type system)\n2. All corresponding elements are equal\n\nFor Vector types, the shape constraint is automatically satisfied by the type system,\nso we only need to check element-wise equality.\n\nSpecification: numpy.array_equal returns True if and only if all corresponding \nelements in the two vectors are equal.\n\nPrecondition: True (vectors have the same length by the type system)\nPostcondition: The result is True if and only if all corresponding elements are equal\n\nMathematical properties:\n- Array equality is reflexive: arrayEqual(a, a) = True for any array a\n- Array equality is symmetric: arrayEqual(a, b) = arrayEqual(b, a)\n- Array equality is transitive: if arrayEqual(a, b) and arrayEqual(b, c), then arrayEqual(a, c)\n- Empty arrays are equal: arrayEqual([], []) = True (vacuous truth)\n- arrayEqual(a, b) = all(elementwise_equal(a, b)) - equivalent to checking all elements are equal\n\nSanity checks:\n- For empty vectors (n = 0), the result is True by vacuous truth\n- For single element vectors [x] and [y], result is True iff x == y\n- For identical vectors, result is True\n- For vectors differing in any element, result is False\n- arrayEqual is the logical AND of all element-wise comparisons", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn array_equal<T>(a1: &Vec<T>, a2: &Vec<T>) -> (result: bool)\n    where T: PartialEq<T>,\n    requires a1.len() == a2.len(),\n    ensures \n        result == true <==> (forall|i: int| 0 <= i < a1.len() ==> a1[i] == a2[i]) &&\n        (a1.len() == 0 ==> result == true) &&\n        (exists|i: int| 0 <= i < a1.len() && !(a1[i] == a2[i]) ==> result == false)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "logic_functions_array_equiv", "vc-description": "numpy.array_equiv: Returns True if input arrays are shape consistent and all elements equal.\n\nShape consistent means they are either the same shape, or one input array\ncan be broadcasted to create the same shape as the other one.\n\nFor 1D arrays of the same size, this means element-wise comparison.\nThe function returns True if all corresponding elements are equal.\n\nSpecification: array_equiv returns true iff all corresponding elements are equal.\n\nPrecondition: True (works for any two vectors of the same size)\nPostcondition: result = true iff all elements at corresponding indices are equal\n\nMathematical properties satisfied:\n- Reflexivity: array_equiv a a = true (any array is equivalent to itself)\n- Symmetry: array_equiv a b = array_equiv b a (equivalence is symmetric)\n- Element-wise equality: result = true iff ∀ i, a1[i] = a2[i]\n- Empty array handling: for n=0, the result is vacuously true\n- Finite precision: uses Float equality (may have precision limitations)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn array_equiv(a1: Vec<f32>, a2: Vec<f32>) -> (result: bool)\n    requires a1.len() == a2.len(),\n    ensures result == (forall|i: int| 0 <= i < a1.len() ==> a1[i] == a2[i])", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "logic_functions_bitwise_and", "vc-description": "Compute the bit-wise AND of two vectors element-wise.\nComputes the bit-wise AND of the underlying binary representation of\nthe natural numbers in the input vectors.\n\nSpecification: bitwise_and computes element-wise bitwise AND operation \n\nThis specification captures the mathematical properties of bitwise AND:\n- Commutativity: a & b = b & a\n- Associativity: (a & b) & c = a & (b & c)\n- Identity with all bits set: a & (-1) = a (but using max value for Nat)\n- Absorption with zero: a & 0 = 0\n- Idempotent: a & a = a\n- Monotonicity: if a ≤ b, then a & c ≤ b & c\n\n/* Commutativity property */\n\n/* Absorption with zero */\n\n/* Idempotent property */\n\n/* Result is bounded by both operands */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn bitwise_and(x1: &Vec<u32>, x2: &Vec<u32>) -> (result: Vec<u32>)\n    requires x1.len() == x2.len(),\n    ensures \n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> \n            result[i] == (x1[i] & x2[i]) &&\n\n            (x1[i] & x2[i]) == (x2[i] & x1[i]) &&\n\n            (x1[i] & 0) == 0 &&\n\n            (x1[i] & x1[i]) == x1[i] &&\n\n            result[i] <= x1[i] && result[i] <= x2[i]", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "logic_functions_bitwise_not", "vc-description": "Compute bit-wise inversion, or bit-wise NOT, element-wise.\n\nComputes the bit-wise NOT of the underlying binary representation of\nthe integers in the input arrays. This ufunc implements the C/Python\noperator ~.\n\nFor signed integer inputs, the bit-wise NOT of the absolute value is\nreturned. In a two's-complement system, this operation effectively flips\nall the bits, which results in -(x + 1). This is the most common method\nof representing signed integers on computers.\n\nReturns an array of the same shape as x, containing the bitwise NOT values.\n\nSpecification: numpy.bitwise_not returns a vector where each element is the\nbitwise NOT of the corresponding element in x.\n\nPrecondition: True (no special preconditions for bitwise NOT)\nPostcondition: For all indices i, result[i] = -(x[i] + 1)\n\nThis specification captures the mathematical property that bitwise NOT\nof an integer x in two's complement representation equals -(x + 1).\n\nKey properties:\n- Bitwise NOT is its own inverse: ~~x = x\n- For any integer x: ~x = -(x + 1)\n- The operation is element-wise for arrays", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_bitwise_not(x: Vec<i32>) -> (result: Vec<i32>)\n    ensures \n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == -(x[i] + 1)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "logic_functions_bitwise_or", "vc-description": "numpy.bitwise_or: Compute the bit-wise OR of two arrays element-wise.\n\nComputes the bit-wise OR of the underlying binary representation of\nthe integers in the input arrays. This ufunc implements the C/Python\noperator |.\n\nFor integer inputs, the result is the bitwise OR of the binary\nrepresentations. For boolean inputs, it performs logical OR.\n\nSpecification: numpy.bitwise_or returns a vector where each element is the \nbitwise OR of the corresponding elements from x1 and x2.\n\nPrecondition: True (no special preconditions for bitwise OR)\nPostcondition: For all indices i, result[i] = bitwise_or(x1[i], x2[i])\n\nMathematical properties:\n- Commutative: bitwise_or(x1[i], x2[i]) = bitwise_or(x2[i], x1[i])\n- Identity: bitwise_or(x[i], 0) = x[i]\n- Idempotent: bitwise_or(x[i], x[i]) = x[i]\n\n/* Axiomatically define bitwise OR operation for integers */\n\n/* Bitwise OR is commutative */\n\n/* Bitwise OR with zero is identity */\n\n/* Bitwise OR is idempotent */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn bitwise_or(x: i32, y: i32) -> i32;\n\nproof fn bitwise_or_comm(x: i32, y: i32)\n    ensures bitwise_or(x, y) == bitwise_or(y, x)\n{\n    assume(false);\n}\n\nproof fn bitwise_or_zero(x: i32)\n    ensures bitwise_or(x, 0) == x\n{\n    assume(false);\n}\n\nproof fn bitwise_or_idempotent(x: i32)\n    ensures bitwise_or(x, x) == x\n{\n    assume(false);\n}\n\nfn numpy_bitwise_or(x1: Vec<i32>, x2: Vec<i32>) -> (result: Vec<i32>)\n    requires x1.len() == x2.len(),\n    ensures\n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == bitwise_or(x1[i], x2[i]),\n        forall|i: int| 0 <= i < result.len() ==> bitwise_or(x1[i], x2[i]) == bitwise_or(x2[i], x1[i]),\n        forall|i: int| 0 <= i < result.len() ==> bitwise_or(x1[i], 0) == x1[i],\n        forall|i: int| 0 <= i < result.len() ==> bitwise_or(x1[i], x1[i]) == x1[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "logic_functions_bitwise_xor", "vc-description": "numpy.bitwise_xor: Compute the bit-wise XOR of two arrays element-wise.\n\nComputes the bit-wise XOR of the underlying binary representation of\nthe integers in the input arrays. This ufunc implements the C/Python\noperator ^.\n\nThe function works on integer and boolean types, computing the XOR\nof corresponding elements from two input vectors.\n\nSpecification: numpy.bitwise_xor returns a vector where each element is the \nbitwise XOR of the corresponding elements from x1 and x2.\n\nPrecondition: All elements are non-negative (to use well-defined bitwise operations)\nPostcondition: For all indices i, result[i] = x1[i] XOR x2[i]\n\nMathematical properties:\n- XOR is commutative: x1[i] XOR x2[i] = x2[i] XOR x1[i]\n- XOR is associative: (a XOR b) XOR c = a XOR (b XOR c)\n- XOR with zero is identity: x XOR 0 = x\n- XOR is self-inverse: x XOR x = 0", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn bitwise_xor(x1: Vec<u32>, x2: Vec<u32>) -> (result: Vec<u32>)\n    requires \n        x1.len() == x2.len(),\n    ensures\n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == (x1[i] ^ x2[i]),\n        forall|i: int| 0 <= i < result.len() && x1[i] == 0 ==> result[i] == x2[i],\n        forall|i: int| 0 <= i < result.len() && x2[i] == 0 ==> result[i] == x1[i],\n        forall|i: int| 0 <= i < result.len() && x1[i] == x2[i] ==> result[i] == 0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "logic_functions_equal", "vc-description": "numpy.equal: Return (x1 == x2) element-wise.\n\nPerforms element-wise comparison of two arrays and returns a boolean array\nof the same shape indicating where the corresponding elements are equal.\n\nFor scalar inputs, returns a single boolean value. For array inputs of the\nsame shape, returns an array of booleans. This function is the basis for\nthe == operator when used with numpy arrays.\n\nSpecification: numpy.equal returns a boolean vector where each element indicates\nwhether the corresponding elements in x1 and x2 are equal.\n\nPrecondition: True (arrays have the same shape by the type system)\nPostcondition: For all indices i, result[i] = (x1[i] == x2[i])\n\nThis specification captures both the element-wise behavior and the mathematical\nproperty that equality comparison is performed at each position.\n\nKey Properties:\n1. Element-wise comparison: Each position is compared independently\n2. Boolean result: Returns true/false for each position \n3. Reflexivity: equal(x, x) returns all true\n4. Symmetry: equal(x, y) = equal(y, x)\n5. Result shape matches input shape", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_equal<T>(x1: Vec<T>, x2: Vec<T>) -> (result: Vec<bool>)\n    requires \n        x1.len() == x2.len(),\n    ensures\n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == (x1[i] == x2[i]),\n        forall|i: int| 0 <= i < result.len() ==> (result[i] == true || result[i] == false),\n        x1@ == x2@ ==> forall|i: int| 0 <= i < result.len() ==> result[i] == true", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "logic_functions_greater_equal", "vc-description": "numpy.greater_equal: Return the truth value of (x1 >= x2) element-wise.\n\nReturns a boolean vector where each element indicates whether the\ncorresponding element in x1 is greater than or equal to the corresponding \nelement in x2.\n\nThis is equivalent to x1 >= x2 in terms of array broadcasting.\n\nSpecification: numpy.greater_equal returns a boolean vector where each element\nis true if and only if the corresponding element in x1 is greater than or equal\nto the corresponding element in x2.\n\nPrecondition: True (no special preconditions for comparison)\nPostcondition: For all indices i, result[i] = true ↔ x1[i] >= x2[i]\n\nAdditional properties:\n- The result is the element-wise negation of less(x1, x2)\n- Reflexivity: greater_equal(x, x) returns all true\n- Antisymmetry: If greater_equal(x1, x2)[i] = true and greater_equal(x2, x1)[i] = true,\n                then x1[i] = x2[i]\n- Transitivity: If greater_equal(x1, x2)[i] = true and greater_equal(x2, x3)[i] = true,\n                then greater_equal(x1, x3)[i] = true\n- For NaN values: comparison with NaN always returns false\n\n/* Reflexivity: comparing vector with itself yields all true */\n\n/* Antisymmetry with equality */\n\n/* Boolean result: each element is either true or false */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_greater_equal(x1: Vec<i32>, x2: Vec<i32>) -> (result: Vec<bool>)\n    requires x1.len() == x2.len(),\n    ensures \n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> (result[i] <==> x1@[i] >= x2@[i]),\n\n        x1@ == x2@ ==> forall|i: int| 0 <= i < result.len() ==> result[i] == true,\n\n        forall|i: int| 0 <= i < result.len() ==> \n            (result[i] == true && x2@[i] >= x1@[i]) ==> x1@[i] == x2@[i],\n\n        forall|i: int| 0 <= i < result.len() ==> (result[i] == true || result[i] == false),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "logic_functions_iscomplex", "vc-description": "Returns a bool array, where True if input element is complex.\nReturns a bool array, where True if input element has non-zero imaginary part.\nFor complex numbers, checks if imaginary part is non-zero.\nFor real numbers, returns false for all elements.\nSpecification: iscomplex returns true for elements with non-zero imaginary parts,\nfalse for elements with zero imaginary parts, with the following properties:\n1. Basic definition: returns true iff imaginary part is non-zero\n2. Real number detection: pure real numbers (imag = 0) return false\n3. Complex number detection: numbers with non-zero imaginary part return true\n4. Idempotent on boolean interpretation: the mathematical meaning is preserved\n5. Element-wise operation: each element is tested independently\n\n/* Structure representing a complex number with float components */\n\n/* The real part of the complex number */\n\n/* The imaginary part of the complex number */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nstruct Complex {\n\n    real: f64,\n\n    imag: f64,\n}", "vc-helpers": "", "vc-spec": "fn is_complex(x: &Vec<Complex>) -> (result: Vec<bool>)\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < x.len() ==> result[i] == (x[i].imag != 0.0),\n        forall|i: int| 0 <= i < x.len() ==> (x[i].imag == 0.0 ==> result[i] == false),\n        forall|i: int| 0 <= i < x.len() ==> (x[i].imag != 0.0 ==> result[i] == true),\n        forall|i: int| 0 <= i < x.len() ==> (result[i] == true ==> x[i].imag != 0.0),\n        forall|i: int| 0 <= i < x.len() ==> (result[i] == false ==> x[i].imag == 0.0)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "logic_functions_isinf", "vc-description": "numpy.isinf: Test element-wise for positive or negative infinity\nReturns a boolean array of the same shape as x, True where x == +/-inf, otherwise False.\nURL: https://numpy.org/doc/stable/reference/generated/numpy.isinf.html\nCategory: Array contents testing\n\nTest element-wise for positive or negative infinity in a vector\n\nSpecification: isinf returns true for positive or negative infinity, false otherwise.\n\n    This function tests each element according to IEEE 754 floating-point standard:\n    - Returns true if the element is positive infinity or negative infinity\n    - Returns false for all other values including NaN, finite numbers, and zero\n\n    Mathematical properties:\n    1. Infinity detection: result[i] = true iff x[i] is infinite\n    2. Distinction from NaN: infinity and NaN are mutually exclusive\n    3. Result preserves shape: output vector has same length as input\n    4. Finite values: All normal, subnormal, and zero values return false\n    5. Specific infinities: Both positive and negative infinity are correctly identified\n\n/* Ghost specification function to represent IEEE 754 infinity test */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_infinite(x: f64) -> bool;", "vc-helpers": "", "vc-spec": "fn isinf(x: Vec<f64>) -> (result: Vec<bool>)\n    requires x.len() < usize::MAX,\n    ensures \n        result.len() == x.len(),\n        forall|i: int| 0 <= i < x.len() ==> {\n            result[i] == is_infinite(x[i])\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "logic_functions_isnan", "vc-description": "Test element-wise for NaN and return result as a boolean array.\n\nSpecification: isnan returns true for NaN values and false otherwise.\nThe function correctly identifies NaN values according to IEEE 754 standard.\n\nMathematical properties:\n1. NaN detection: result[i] = true iff x[i] is NaN\n2. NaN ≠ NaN property: if x[i].isNaN then x[i] ≠ x[i]\n3. Result preserves shape: output vector has same length as input\n4. Non-NaN values: For all finite values, the result is false\n5. Complement property: isnan is the complement of (isfinite ∨ isinfinite)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn isnan(x: Vec<f64>) -> (result: Vec<bool>)\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < x.len() ==> (result[i] == true <==> x[i] != x[i]),\n        forall|i: int| 0 <= i < x.len() ==> (result[i] == true ==> x[i] != x[i]),\n        forall|i: int| 0 <= i < x.len() ==> (x[i] == x[i] ==> result[i] == false),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "logic_functions_isnat", "vc-description": "Test element-wise for NaT (not a time) and return result as a boolean array.\n\nThis function checks each element of a datetime64 array to determine if it\nrepresents NaT (Not a Time), which is the datetime equivalent of NaN.\n\nReturns true for NaT values and false for all valid datetime values.\nThe function is the datetime analog of isnan for floating point values.\n\nSpecification: isnat returns true for NaT values and false otherwise.\nThe function correctly identifies NaT values in datetime64 arrays.\n\nMathematical properties:\n1. NaT detection: result[i] = true iff x[i] is NaT\n2. Valid datetime detection: result[i] = false iff x[i] is a valid datetime\n3. Result preserves shape: output vector has same length as input\n4. Exhaustive coverage: every element is either NaT or a valid datetime\n\nThis is the datetime analog of isnan for floating point NaN values.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n#[derive(PartialEq, Eq, Clone, Copy)]\npub enum DateTime64 {\n    Valid(i64),\n    Nat,\n}", "vc-helpers": "", "vc-spec": "fn isnat(x: Vec<DateTime64>) -> (result: Vec<bool>)\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < x.len() ==> \n            (result@.index(i) == true <==> x@.index(i) == DateTime64::Nat),\n        forall|i: int| 0 <= i < x.len() ==> \n            (result@.index(i) == false <==> exists|val: i64| x@.index(i) == DateTime64::Valid(val)),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "logic_functions_isneginf", "vc-description": "Test element-wise for negative infinity, return result as bool array.\n\nThis function tests each element according to IEEE 754 floating-point standard:\n- Returns true if the element is negative infinity (-∞)\n- Returns false for all other values including positive infinity, NaN, finite numbers, and zero\n\nMathematical properties:\n1. Negative infinity detection: result[i] = true iff x[i] is negative infinity\n2. Distinction from positive infinity: only negative infinity returns true\n3. Distinction from NaN: negative infinity and NaN are mutually exclusive\n4. Result preserves shape: output vector has same length as input\n5. Finite values: All normal, subnormal, and zero values return false", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_neg_infinity(x: f32) -> bool;\n\nfn isneginf(x: Vec<f32>) -> (result: Vec<bool>)\n    requires x.len() > 0,\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < x.len() ==> {\n            &&& (result[i] == is_neg_infinity(x[i]))\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "logic_functions_isreal", "vc-description": "Returns a bool array, where True if input element is real.\nFor complex numbers, checks if imaginary part is zero.\nFor numbers with zero imaginary part, returns true for all elements.\n\nSpecification: isreal returns true for elements with zero imaginary parts,\nfalse for elements with non-zero imaginary parts, with the following properties:\n1. Basic definition: returns true iff imaginary part is zero\n2. Real number detection: pure real numbers (imag = 0) return true\n3. Complex number detection: numbers with non-zero imaginary part return false\n4. Complementary to iscomplex: isreal(x) = not iscomplex(x)\n5. Element-wise operation: each element is tested independently\n6. Mathematical property: real numbers form a subset of complex numbers\n7. Consistency: if real, then can be represented as a + 0i\n\n/* Structure representing a complex number with float components */\n\n/* The real part of the complex number */\n\n/* The imaginary part of the complex number */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nstruct Complex {\n\n    real: f64,\n\n    imag: f64,\n}", "vc-helpers": "", "vc-spec": "fn isreal(x: &Vec<Complex>) -> (result: Vec<bool>)\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < x.len() ==> result[i] == (x[i].imag == 0.0),\n        forall|i: int| 0 <= i < x.len() ==> (x[i].imag == 0.0 ==> result[i] == true),\n        forall|i: int| 0 <= i < x.len() ==> (x[i].imag != 0.0 ==> result[i] == false),\n        forall|i: int| 0 <= i < x.len() ==> (result[i] == true ==> x[i].imag == 0.0),\n        forall|i: int| 0 <= i < x.len() ==> (result[i] == false ==> x[i].imag != 0.0),\n        forall|i: int| 0 <= i < x.len() ==> (result[i] == true ==> x[i].real == x[i].real),\n        forall|i: int| 0 <= i < x.len() ==> result[i] == !(x[i].imag != 0.0),\n        forall|i: int| 0 <= i < x.len() ==> (result[i] == true <==> x[i].imag == 0.0),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "logic_functions_logical_and", "vc-description": "numpy.logical_and: Compute the truth value of x1 AND x2 element-wise.\n\nComputes the logical AND of two boolean arrays element-wise.\nEach element of the result is the logical AND of the corresponding\nelements from the input arrays.\n\nExamples from NumPy:\n- logical_and(True, False) = False\n- logical_and([True, False], [False, False]) = [False, False]\n- logical_and([True, True], [True, False]) = [True, False]\n\nThis is a binary element-wise operation equivalent to x1 & x2.\n\nSpecification: numpy.logical_and returns a vector where each element\nis the logical AND of the corresponding elements from x1 and x2.\n\nPrecondition: True (no special preconditions for logical AND)\nPostcondition: For all indices i, result[i] = x1[i] ∧ x2[i]\n\nKey properties:\n- Commutative: logical_and(x1, x2) = logical_and(x2, x1)\n- Associative: logical_and(logical_and(x1, x2), x3) = logical_and(x1, logical_and(x2, x3))\n- Identity: logical_and(x, true_vector) = x\n- Zero: logical_and(x, false_vector) = false_vector\n- Idempotent: logical_and(x, x) = x", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_logical_and(x1: Vec<bool>, x2: Vec<bool>) -> (result: Vec<bool>)\n    requires x1.len() == x2.len(),\n    ensures \n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == (x1[i] && x2[i])", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "logic_functions_logical_not", "vc-description": "numpy.logical_not: Compute the truth value of NOT x element-wise.\n\nFor each element in the input array, applies logical NOT operation.\nIn NumPy's interpretation: any non-zero numeric value is considered True \n(so NOT returns False), zero is considered False (so NOT returns True).\n\nReturns a boolean array of the same shape as the input.\n\nSpecification: numpy.logical_not returns a vector where each element is the\nlogical NOT of the corresponding element in x, following NumPy's truthiness rules.\n\nPrecondition: True (logical NOT is defined for all numeric values)\nPostcondition: For all indices i, result[i] = true iff x[i] = 0.0\n\nMathematical properties:\n- Exactly implements NumPy's truthiness rules: 0.0 → true, non-zero → false\n- Element-wise operation preserves array shape and size (enforced by type)\n- Idempotent when composed with itself and appropriate conversion\n- For special float values: logical_not(NaN) = false, logical_not(∞) = false\n- Boundary case: logical_not(-0.0) = true (since -0.0 = 0.0)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn logical_not(x: Vec<f64>) -> (result: Vec<bool>)\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == (x[i] == 0.0)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "logic_functions_logical_or", "vc-description": "Compute the truth value of x1 OR x2 element-wise.\n\nPerforms logical OR operation on corresponding elements of two boolean vectors.\nThe function returns a vector where each element is the logical OR of the \ncorresponding elements from the input vectors.\n\nSpecification: logical_or computes element-wise logical OR operation\n\nThis specification captures the mathematical properties of logical OR:\n- Commutativity: a ∨ b = b ∨ a\n- Associativity: (a ∨ b) ∨ c = a ∨ (b ∨ c)\n- Identity with false: a ∨ false = a\n- Absorption with true: a ∨ true = true\n- Idempotent: a ∨ a = a\n- De Morgan's law: ¬(a ∨ b) = (¬a) ∧ (¬b)\n\nSanity checks:\n- For empty vectors (n = 0), the result is empty by vacuous truth\n- logical_or([true, false], [false, false]) = [true, false]\n- logical_or([false, false], [false, false]) = [false, false]\n- logical_or([true, true], [false, true]) = [true, true]\n- The result is false only when both operands are false\n\n/* Commutativity property */\n\n/* Identity with false */\n\n/* Absorption with true */\n\n/* Idempotent property */\n\n/* Result is true if either operand is true */\n\n/* Result is false only when both operands are false */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn logical_or(x1: Vec<bool>, x2: Vec<bool>) -> (result: Vec<bool>)\n    requires x1.len() == x2.len(),\n    ensures \n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == (x1[i] || x2[i]),\n\n        forall|i: int| 0 <= i < result.len() ==> (x1[i] || x2[i]) == (x2[i] || x1[i]),\n\n        forall|i: int| 0 <= i < result.len() ==> (x1[i] || false) == x1[i],\n\n        forall|i: int| 0 <= i < result.len() ==> (x1[i] || true) == true,\n\n        forall|i: int| 0 <= i < result.len() ==> (x1[i] || x1[i]) == x1[i],\n\n        forall|i: int| 0 <= i < result.len() ==> (x1[i] == true || x2[i] == true) ==> result[i] == true,\n\n        forall|i: int| 0 <= i < result.len() ==> (x1[i] == false && x2[i] == false) ==> result[i] == false,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "logic_functions_logical_xor", "vc-description": "numpy.logical_xor: Compute the truth value of x1 XOR x2 element-wise.\n\nComputes the logical XOR of two boolean arrays element-wise.\nEach element of the result is the logical XOR of the corresponding\nelements from the input arrays.\n\nExamples from NumPy:\n- logical_xor(True, False) = True\n- logical_xor([True, True, False, False], [True, False, True, False]) = [False, True, True, False]\n- logical_xor(False, False) = False\n- logical_xor(True, True) = False\n\nThis is a binary element-wise operation equivalent to x1 ⊕ x2.\n\nSpecification: numpy.logical_xor returns a vector where each element\nis the logical XOR of the corresponding elements from x1 and x2.\n\nPrecondition: True (no special preconditions for logical XOR)\nPostcondition: For all indices i, result[i] = x1[i] ⊕ x2[i]\n\nKey properties:\n- Commutative: logical_xor(x1, x2) = logical_xor(x2, x1)\n- Associative: logical_xor(logical_xor(x1, x2), x3) = logical_xor(x1, logical_xor(x2, x3))\n- Identity: logical_xor(x, false_vector) = x\n- Self-inverse: logical_xor(x, x) = false_vector\n- Double negation: logical_xor(logical_xor(x, y), y) = x\n- Relationship to other operations: logical_xor(x, y) = logical_and(logical_or(x, y), logical_not(logical_and(x, y)))", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_logical_xor(x1: Vec<bool>, x2: Vec<bool>) -> (result: Vec<bool>)\n    requires x1.len() == x2.len(),\n    ensures \n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == (x1[i] != x2[i])", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "logic_functions_not_equal", "vc-description": "numpy.not_equal: Return (x1 != x2) element-wise.\n\nPerforms element-wise inequality comparison of two arrays and returns a boolean array\nof the same shape indicating where the corresponding elements are not equal.\n\nFor scalar inputs, returns a single boolean value. For array inputs of the\nsame shape, returns an array of booleans. This function is the basis for\nthe != operator when used with numpy arrays.\n\nThis is the logical negation of numpy.equal.\n\nSpecification: numpy.not_equal returns a boolean vector where each element indicates\nwhether the corresponding elements in x1 and x2 are not equal.\n\nPrecondition: True (arrays have the same shape by the type system)\nPostcondition: For all indices i, result[i] = (x1[i] != x2[i])\n\nThis specification captures both the element-wise behavior and the mathematical\nproperty that inequality comparison is performed at each position.\n\nKey Properties:\n1. Element-wise comparison: Each position is compared independently\n2. Boolean result: Returns true/false for each position \n3. Irreflexivity: not_equal(x, x) returns all false\n4. Symmetry: not_equal(x, y) = not_equal(y, x)\n5. Logical negation of equality: not_equal(x, y) = ¬equal(x, y)\n6. Result shape matches input shape\n\n/* Irreflexivity: comparing vector with itself yields all false */\n\n/* Symmetry: inequality comparison is commutative */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_not_equal<T: PartialEq>(x1: Vec<T>, x2: Vec<T>) -> (result: Vec<bool>)\n    requires x1.len() == x2.len(),\n    ensures\n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == (x1[i] != x2[i]),\n\n        (x1@ == x2@) ==> (forall|i: int| 0 <= i < result.len() ==> result[i] == false),\n\n        forall|i: int| 0 <= i < result.len() ==> result[i] == (x2[i] != x1[i]),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "mathematical_functions_arccosh", "vc-description": "Inverse hyperbolic cosine, element-wise. \nReturns the inverse hyperbolic cosine of each element in the input vector.\nThe inverse hyperbolic cosine is defined as: arccosh(x) = log(x + sqrt(x² - 1)) for x ≥ 1\n\nSpecification: arccosh computes the inverse hyperbolic cosine element-wise.\n\nMathematical properties:\n1. Domain constraint: All input values must be ≥ 1\n2. Range: All output values are non-negative (arccosh(x) ≥ 0)\n3. Special value: arccosh(1) = 0\n4. The function is strictly increasing: x₁ < x₂ implies arccosh(x₁) < arccosh(x₂)\n5. Mathematical definition: arccosh(x) = log(x + sqrt(x² - 1))\n\nThe inverse hyperbolic cosine function reverses the action of cosh on [0, ∞),\nwhere cosh(y) = (e^y + e^(-y))/2. These properties ensure correctness.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn arccosh(x: Vec<f32>) -> (result: Vec<f32>)\n    requires \n        x.len() > 0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "mathematical_functions_arcsin", "vc-description": "numpy.arcsin: Inverse sine, element-wise.\n\nComputes the inverse sine (arcsine) of each element in the input array.\nThe result is the angle in radians whose sine is the input value.\n\nFor real arguments, the domain is [-1, 1] and the range is [-π/2, π/2].\nValues outside [-1, 1] will result in NaN.\n\nReturns an array of the same shape as x, containing the inverse sine values in radians.\n\nSpecification: numpy.arcsin returns a vector where each element is the\ninverse sine of the corresponding element in x.\n\nPrecondition: All elements of x must be in the domain [-1, 1] for real results\nPostcondition: For all indices i where x[i] is in [-1, 1]:\n- result[i] = arcsin(x[i])\n- result[i] is in the range [-π/2, π/2]\n- sin(result[i]) = x[i] (inverse relationship holds)\n- arcsin is monotonic: if x[i] ≤ x[j] then result[i] ≤ result[j]\n- Special values: arcsin(0) = 0, arcsin(1) = π/2, arcsin(-1) = -π/2", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_arcsin(x: Vec<i32>) -> (result: Vec<i32>)\n    requires \n        x.len() > 0,\n        forall|i: int| 0 <= i < x.len() ==> -1 <= x[i as int] && x[i as int] <= 1,\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> {\n            -2 <= result[i] && result[i] <= 2 &&\n            (x[i] == 0 ==> result[i] == 0) &&\n            (x[i] == 1 ==> result[i] == 2) &&\n            (x[i] == -1 ==> result[i] == -2)\n        },\n        forall|i: int, j: int| 0 <= i < x.len() && 0 <= j < x.len() && x[i] <= x[j] ==> result[i] <= result[j]", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "mathematical_functions_arctan2", "vc-description": "numpy.arctan2: Element-wise arc tangent of x1/x2 choosing the quadrant correctly.\n\nComputes the arc tangent of x1/x2 for each pair of corresponding elements,\nusing the signs of both arguments to determine the quadrant of the result.\nThis gives the signed angle in radians between the positive x-axis and the\npoint (x2, x1).\n\nThe result is in the range [-π, π].\n\nSpecial cases:\n- arctan2(+0, +0) = +0\n- arctan2(+0, -0) = +π\n- arctan2(-0, +0) = -0\n- arctan2(-0, -0) = -π\n- arctan2(y, +∞) = +0 for finite y > 0\n- arctan2(y, -∞) = +π for finite y > 0\n- arctan2(y, +∞) = -0 for finite y < 0\n- arctan2(y, -∞) = -π for finite y < 0", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_arctan2(x1: &Vec<f64>, x2: &Vec<f64>) -> (result: Vec<f64>)\n    requires x1.len() == x2.len(),\n    ensures result.len() == x1.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "mathematical_functions_around", "vc-description": "numpy.around: Evenly round to the given number of decimals (alias for numpy.round).\nUses banker's rounding (round half to even) for values exactly halfway between rounded decimal values.\nFor example: 1.5 and 2.5 both round to 2.0, -0.5 and 0.5 both round to 0.0\n\nSpecification: around rounds each element to the given number of decimals with the following properties:\n1. Basic rounding: rounds to nearest representable value at the specified decimal precision\n2. Banker's rounding: for values exactly halfway between rounded decimal values, rounds to nearest even\n3. Zero preservation: rounding zero always produces zero\n4. Order preservation: maintains relative ordering of elements\n5. Bounded difference: the rounded value is close to the original value\n6. Idempotency: rounding an already-rounded value doesn't change it\n\n/* Simplified to focus on the basic case */\n\n/* Zero preservation: rounding zero gives zero */\n\n/* Order preservation: maintains ordering */\n\n/* Boundedness: rounded values are close to original values */\n\n/* Symmetry: rounding non-negative values gives non-negative results */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn around(a: Vec<i32>, decimals: i32) -> (result: Vec<i32>)\n    requires decimals == 0,\n    ensures\n        result.len() == a.len(),\n\n        forall|i: int| 0 <= i < a.len() && a[i] == 0 ==> result[i] == 0,\n\n        forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() && a[i] <= a[j] ==> result[i] <= result[j],\n\n        forall|i: int| 0 <= i < a.len() ==>\n            result[i] - 1 <= a[i] && a[i] <= result[i] + 1,\n\n        forall|i: int| 0 <= i < a.len() && a[i] >= 0 ==> result[i] >= 0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "mathematical_functions_cbrt", "vc-description": "Return the cube-root of an array, element-wise\n\nnumpy.cbrt: Return the cube-root of an array, element-wise.\n\nComputes the cube root of each element in the input array.\nThe cube root function is defined for all real numbers, including negative numbers.\nFor any real number x, cbrt(x) = y such that y³ = x.\n\nReturns an array of the same shape as x, containing the cube roots.\n\nSpecification: numpy.cbrt returns a vector where each element is the\ncube root of the corresponding element in x.\n\nPrecondition: True (cube root is defined for all real numbers)\nPostcondition: For all indices i, (result[i])³ = x[i]\n\nMathematical properties:\n- cbrt(x³) = x for all x\n- cbrt(-x) = -cbrt(x) (odd function)\n- cbrt(0) = 0\n- cbrt(1) = 1\n- cbrt(8) = 2\n- cbrt(-8) = -2", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn cbrt(x: Vec<f32>) -> (result: Vec<f32>)\n    requires x.len() > 0,\n    ensures \n        result.len() == x.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "mathematical_functions_ceil", "vc-description": "numpy.ceil: Return the ceiling of the input, element-wise.\n\nThe ceiling of each element x is the smallest integer i, such that i >= x.\nThis is a fundamental mathematical operation that rounds up to the\nnearest integer.\n\nReturns an array of the same shape as x, containing the ceiling of each element.\n\nSpecification: numpy.ceil returns a vector where each element is the\nceiling (smallest integer greater than or equal to) the corresponding element in x.\n\nPrecondition: True (ceiling is defined for all real numbers)\nPostcondition: For all indices i, result[i] is the ceiling of x[i], meaning:\n- result[i] is an integer value (represented as Float)\n- result[i] ≥ x[i]\n- result[i] < x[i] + 1\n- There is no integer k such that x[i] ≤ k < result[i]\n- Monotonicity: if x[i] ≤ x[j] then result[i] ≤ result[j]\n- Relationship with floor: result[i] = -((-x[i]).floor)\n\n/* Each element in result is the ceiling of corresponding element in x */\n\n/* Ceiling properties: integer value, >= x[i], < x[i] + 1, minimal such integer */\n\n/* Monotonicity: if x[i] <= x[j] then result[i] <= result[j] */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_ceil(x: Vec<f64>) -> (result: Vec<f64>)\n    requires x.len() > 0,\n    ensures\n        result.len() == x.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "mathematical_functions_cosh", "vc-description": "numpy.cosh: Hyperbolic cosine, element-wise.\n\nThe hyperbolic cosine function is defined as:\ncosh(x) = (e^x + e^(-x)) / 2\n\nIt represents the x-coordinate of a point on the unit hyperbola,\nanalogous to how cosine represents the x-coordinate on the unit circle.\n\nReturns an array of the same shape as x, containing the hyperbolic cosine of each element.\n\n/* Core mathematical definition placeholder */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_cosh(x: Vec<f32>) -> (result: Vec<f32>)\n    requires x.len() > 0,\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> {\n            result[i] == result[i]\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "mathematical_functions_cross", "vc-description": "numpy.cross: Return the cross product of two (arrays of) vectors.\n\nThe cross product of a and b in R^3 is a vector perpendicular to both a and b.\nFor 3D vectors a = [a0, a1, a2] and b = [b0, b1, b2], the cross product is:\nc = [a1*b2 - a2*b1, a2*b0 - a0*b2, a0*b1 - a1*b0]\n\nThis implementation focuses on the 3D case, which is the most common usage.\nThe result vector is perpendicular to both input vectors according to the\nright-hand rule.\n\nSpecification: numpy.cross returns the cross product of two 3D vectors.\n\nPrecondition: True (vectors must be 3D, enforced by type)\nPostcondition: \n1. The result components follow the cross product formula\n2. The result is perpendicular to both input vectors (dot product is zero)\n3. Anti-commutativity: a × b = -(b × a)\n4. Bilinearity properties\n5. Zero property: if a and b are parallel, then a × b = 0", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn cross(a: Vec<f32>, b: Vec<f32>) -> (result: Vec<f32>)\n    requires \n        a.len() == 3,\n        b.len() == 3,\n    ensures \n        result.len() == 3,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "mathematical_functions_divide", "vc-description": "numpy.divide: Divide arguments element-wise.\n\nDivides two vectors element-wise. If the vectors have the same shape,\neach element of the result is the quotient of the corresponding elements\nfrom the input vectors.\n\nThis is equivalent to x1 / x2 in terms of array broadcasting.\nDivision by zero results in infinity or NaN according to IEEE 754 standard.\n\nSpecification: numpy.divide returns a vector where each element is the quotient\nof the corresponding elements from x1 and x2.\n\nPrecondition: True (handles division by zero according to IEEE 754)\nPostcondition: For all indices i, result[i] = x1[i] / x2[i]\n\nAdditional properties:\n- When x2[i] ≠ 0, result[i] * x2[i] = x1[i] (within floating point precision)\n- When x2[i] = 0 and x1[i] ≠ 0, result[i] is infinite\n- When x2[i] = 0 and x1[i] = 0, result[i] is NaN", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_divide(x1: Vec<f32>, x2: Vec<f32>) -> (result: Vec<f32>)\n    requires \n        x1.len() == x2.len(),\n    ensures \n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < x1.len() ==> x2[i] != 0.0f32,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "mathematical_functions_divmod", "vc-description": "numpy.divmod: Return element-wise quotient and remainder simultaneously.\n\nPerforms element-wise division returning both the quotient and remainder.\nFor each pair of elements (x, y), returns (x // y, x % y) where:\n- x // y is the floor division (largest integer ≤ x/y)\n- x % y is the remainder such that x = y * (x // y) + (x % y)\n\nThis is equivalent to (x // y, x % y) but faster because it avoids\nredundant work by computing both values in a single operation.\n\nFrom NumPy documentation:\n- Parameters: x1, x2 (array_like) - The dividend and divisor arrays\n- Returns: (quotient, remainder) - tuple of ndarrays with element-wise results\n\nMathematical properties:\n1. Division identity: x1[i] = x2[i] * quotient[i] + remainder[i]\n2. Remainder bounds: 0 ≤ |remainder[i]| < |x2[i]| (for positive divisors)\n3. Sign consistency: remainder has same sign as divisor (Python % semantics)\n\nSpecification: numpy.divmod returns a tuple of vectors containing the quotient \nand remainder of element-wise division.\n\nMathematical Properties:\n1. Division identity: For all i, x1[i] = x2[i] * quotient[i] + remainder[i]\n2. Quotient correctness: quotient[i] = floor(x1[i] / x2[i])\n3. Remainder correctness: remainder[i] = x1[i] - x2[i] * quotient[i]\n4. Remainder bounds: |remainder[i]| < |x2[i]| (when x2[i] ≠ 0)\n5. Sign consistency: remainder[i] has same sign as x2[i] (Python % semantics)\n6. Equivalence: divmod(x1, x2) = (floor_divide(x1, x2), mod(x1, x2))\n\nPrecondition: All elements in x2 must be non-zero\nPostcondition: Returns (quotient, remainder) where the mathematical properties hold", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn divmod(x1: Vec<i32>, x2: Vec<i32>) -> (result: (Vec<i32>, Vec<i32>))\n    requires \n        x1.len() == x2.len(),\n        forall|i: int| 0 <= i < x2.len() ==> x2[i] != 0,\n    ensures ({\n        let (quotient, remainder) = result;\n        quotient.len() == x1.len() &&\n        remainder.len() == x1.len() &&\n        forall|i: int| 0 <= i < x1.len() ==> {\n            x1[i] == x2[i] * quotient[i] + remainder[i] &&\n            (x2[i] > 0 ==> 0 <= remainder[i] && remainder[i] < x2[i]) &&\n            (x2[i] < 0 ==> x2[i] < remainder[i] && remainder[i] <= 0)\n        }\n    })", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "mathematical_functions_exp", "vc-description": "numpy.exp: Calculate the exponential of all elements in the input array.\n\nComputes the exponential function (e^x) element-wise. This is the inverse\nof the natural logarithm function. For each element x in the input array,\nthe result contains e^x where e is Euler's number (approximately 2.71828).\n\nThe exponential function has the mathematical property that exp(x + y) = exp(x) * exp(y)\nand exp(0) = 1.\n\nReturns an array of the same shape as x, containing the exponential values.\n\nSpecification: numpy.exp returns a vector where each element is the\nexponential (e^x) of the corresponding element in x.\n\nPrecondition: True (exponential function is defined for all real numbers)\nPostcondition: For all indices i, result[i] = e^(x[i])\n\nMathematical properties:\n- exp(0) = 1 for any zero elements\n- exp(x) > 0 for all x (exponential is always positive)\n- exp is monotonically increasing\n- exp(x + y) = exp(x) * exp(y) (for addition in the input)\n\n/* Mathematical specification: For all indices i, result[i] = exp(x[i])\n           Note: Verus doesn't have built-in exp function for f32,\n           so we provide a simplified specification that maintains array length */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_exp(x: Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() == x.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "mathematical_functions_fix", "vc-description": "Round to nearest integer towards zero, element-wise.\n\nThe fix (truncation) of each element x is the integer part of x,\nobtained by discarding the fractional part. This is equivalent to\nrounding towards zero.\n\nFor positive numbers: fix(x) = floor(x)\nFor negative numbers: fix(x) = ceil(x)\n\nReturns an array of the same shape as x, containing the fix of each element.\n\nSpecification: numpy.fix returns a vector where each element is the\nfix (truncation towards zero) of the corresponding element in x.\n\nPrecondition: True (fix is defined for all real numbers)\nPostcondition: For all indices i, result[i] is the fix of x[i], meaning:\n- result[i] is an integer value (represented as Float)\n- |result[i]| ≤ |x[i]| (magnitude is reduced or equal)\n- result[i] has the same sign as x[i] (or zero if x[i] is zero)\n- |x[i] - result[i]| < 1 (difference is less than 1)\n- For positive x[i]: result[i] = floor(x[i])\n- For negative x[i]: result[i] = ceil(x[i])\n- For zero x[i]: result[i] = 0\n- Monotonicity: if x[i] ≤ x[j] then result[i] ≤ result[j]\n- Truncation property: result[i] truncates towards zero\n\n/* Round to nearest integer towards zero, element-wise.\n\n   The fix (truncation) of each element x is the integer part of x,\n   obtained by discarding the fractional part. This is equivalent to\n   rounding towards zero.\n\n   For positive numbers: fix(x) = floor(x)\n   For negative numbers: fix(x) = ceil(x)\n\n   Returns an array of the same shape as x, containing the fix of each element.\n*/", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_fix(x: Vec<f64>) -> (result: Vec<f64>)\n    ensures result.len() == x.len()", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "mathematical_functions_floor", "vc-description": "Return the floor of the input, element-wise.\n\nThe floor of each element x is the largest integer i, such that i <= x.\nThis is a fundamental mathematical operation that rounds down to the\nnearest integer.\n\nReturns an array of the same shape as x, containing the floor of each element.\n\nSpecification: numpy.floor returns a vector where each element is the\nfloor (largest integer less than or equal to) the corresponding element in x.\n\nPrecondition: True (floor is defined for all real numbers)\nPostcondition: For all indices i, result[i] is the floor of x[i], meaning:\n- result[i] is an integer value (represented as Float)\n- result[i] ≤ x[i]\n- x[i] < result[i] + 1\n- There is no integer k such that result[i] < k ≤ x[i]\n- Monotonicity: if x[i] ≤ x[j] then result[i] ≤ result[j]\n- Idempotence: floor(floor(x)) = floor(x)\n- Relationship with ceiling: result[i] = -((-x[i]).ceil) when x[i] is not an integer\n- Integer preservation: if x[i] is an integer, then result[i] = x[i]", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_floor(x: Vec<i32>) -> (result: Vec<i32>)\n    requires x.len() > 0,\n    ensures \n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] <= x[i],\n        forall|i: int| 0 <= i < result.len() ==> x[i] < result[i] + 1,\n        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result.len() && x[i] <= x[j] ==> result[i] <= result[j],\n        forall|i: int| 0 <= i < result.len() ==> result[i] == x[i]", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "mathematical_functions_floor_divide", "vc-description": "numpy.floor_divide: Return the largest integer smaller or equal to the division of the inputs.\n\nPerforms element-wise floor division of two vectors. For each pair of elements,\nreturns the largest integer less than or equal to their division.\n\nThis is equivalent to the Python // operator and pairs with the modulo operation\nsuch that a = a % b + b * (a // b) up to roundoff.\n\nSpecification: numpy.floor_divide returns a vector where each element is the floor\nof the division of the corresponding elements from x1 and x2.\n\nThis function implements Python's // operator behavior for element-wise operations.\n\nPrecondition: All elements in x2 must be non-zero\nPostcondition: \n1. For all indices i, result[i] = floor(x1[i] / x2[i])\n2. For all indices i, result[i] is the largest integer ≤ x1[i] / x2[i]\n3. The fundamental floor division property: result[i] ≤ x1[i] / x2[i] < result[i] + 1\n4. This pairs with modulo such that: x1[i] = x2[i] * result[i] + remainder\n\n/* Floor division properties:\n             * 1. result[i] is the floor of x1[i] / x2[i]\n             * 2. result[i] <= x1[i] / x2[i] \n             * 3. x1[i] / x2[i] < result[i] + 1.0\n             */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn floor_div_prop(x: f64, y: f64) -> bool {\n    y != 0.0\n}\n\nfn numpy_floor_divide(x1: Vec<f64>, x2: Vec<f64>) -> (result: Vec<f64>)\n    requires \n        x1.len() == x2.len(),\n        forall|i: int| 0 <= i < x2.len() ==> x2[i] != 0.0,\n    ensures\n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> {\n\n            floor_div_prop(x1[i], x2[i])\n        },", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "mathematical_functions_fmin", "vc-description": "Element-wise minimum of array elements.\n\nCompare two arrays and returns a new array containing the element-wise minima. If one of the elements being compared is a NaN, then the non-nan element is returned.\n\nElement-wise minimum of two vectors, with special NaN handling.\nIf one element is NaN, returns the non-NaN element.\n\nSpecification: fmin returns element-wise minimum with NaN handling.\nFor each position i:\n- If both elements are non-NaN, returns the minimum\n- If x[i] is NaN and y[i] is not, returns y[i]  \n- If y[i] is NaN and x[i] is not, returns x[i]\n- If both are NaN, returns NaN\n- Mathematical properties: commutativity (ignoring NaN order), \n  idempotence for non-NaN values, and boundedness", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn fmin(x: Vec<f32>, y: Vec<f32>) -> (result: Vec<f32>)\n    requires x.len() == y.len(),\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < x.len() ==> #[trigger] result[i] == x[i] || #[trigger] result[i] == y[i]", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "mathematical_functions_fmod", "vc-description": "Returns the element-wise remainder of division where the remainder has the same sign as the dividend", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn fmod(x1: &Vec<f32>, x2: &Vec<f32>) -> (result: Vec<f32>)\n    requires x1.len() == x2.len(),\n    ensures result.len() == x1.len()", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "mathematical_functions_frexp", "vc-description": "numpy.frexp: Decompose the elements of x into mantissa and twos exponent.\n\nReturns (mantissa, exponent), where x = mantissa * 2**exponent.\nThe mantissa is in the range [0.5, 1) for positive numbers, (-1, -0.5] for negative numbers,\nor 0 if x is 0. The exponent is an integer.\n\nFor special values:\n- If x is 0, returns (0.0, 0)\n- If x is infinity, returns (infinity, 0)\n- If x is NaN, returns (NaN, 0)\n\nSpecification: frexp decomposes each element into mantissa and exponent such that\nx = mantissa * 2^exponent, where the mantissa is normalized to be in [0.5, 1) for\npositive values or (-1, -0.5] for negative values.\n\nPrecondition: True (no special preconditions)\nPostcondition: For all indices i:\n- If x[i] = 0, then mantissa[i] = 0 and exponent[i] = 0\n- If x[i] is finite and non-zero, then:\n  - x[i] = mantissa[i] * 2^exponent[i] (reconstruction property)\n  - 0.5 ≤ |mantissa[i]| < 1.0 (normalization property)\n  - mantissa[i] has same sign as x[i] (sign preservation)\n- If x[i] is infinity or NaN, then mantissa[i] = x[i] and exponent[i] = 0\n- Result vectors have same length as input (length preservation)\n\n/* Zero case: if input is zero, mantissa is zero and exponent is zero */\n\n/* Note: More complex properties like reconstruction (x = mantissa * 2^exponent),\n               normalization bounds, and sign preservation would require additional\n               floating-point operations that are not readily available in Verus specs */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn frexp(x: Vec<f32>) -> (result: (Vec<f32>, Vec<i32>))\n    ensures\n        result.0.len() == x.len(),\n        result.1.len() == x.len(),\n        forall|i: int| 0 <= i < x.len() ==> {\n\n            x[i] == 0.0f32 ==> result.0[i] == 0.0f32 && result.1[i] == 0\n\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "mathematical_functions_gcd", "vc-description": "numpy.gcd: Returns the greatest common divisor of |x1| and |x2|, element-wise.\n\nThe GCD is computed on the absolute values of the inputs. For two integers a and b,\ngcd(a, b) is the largest positive integer that divides both |a| and |b|.\n\nSpecial cases:\n- gcd(0, 0) = 0\n- gcd(a, 0) = |a| for any non-zero a\n- gcd(0, b) = |b| for any non-zero b\n\nReturns an array of the same shape as the broadcasted x1 and x2.\n\nSpecification: numpy.gcd returns a vector where each element is the\ngreatest common divisor of the absolute values of the corresponding elements in x1 and x2.\n\nMathematical properties verified:\n1. Correctness: result[i] = gcd(x1[i], x2[i])\n2. Non-negativity: result[i] ≥ 0 (GCD is always non-negative)\n3. Equivalence to absolute values: gcd(a, b) = gcd(|a|, |b|)\n4. Special cases: gcd(0,0)=0, gcd(a,0)=|a|, gcd(0,b)=|b|\n5. Divisibility: gcd(a,b) divides both a and b\n6. Greatest property: any common divisor of a and b also divides gcd(a,b)\n7. Commutativity: gcd(a,b) = gcd(b,a)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn gcd(a: int, b: int) -> int;\n\nspec fn int_abs(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\nfn numpy_gcd(x1: Vec<i32>, x2: Vec<i32>) -> (result: Vec<i32>)\n    requires x1.len() == x2.len(),\n    ensures\n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] as int == gcd(x1[i] as int, x2[i] as int),\n        forall|i: int| 0 <= i < result.len() ==> result[i] >= 0,\n        forall|i: int| 0 <= i < result.len() ==> gcd(x1[i] as int, x2[i] as int) == gcd(int_abs(x1[i] as int), int_abs(x2[i] as int)),\n        forall|i: int| 0 <= i < result.len() ==> (x1[i] == 0 && x2[i] == 0) ==> result[i] == 0,\n        forall|i: int| 0 <= i < result.len() ==> (x1[i] != 0 && x2[i] == 0) ==> result[i] as int == int_abs(x1[i] as int),\n        forall|i: int| 0 <= i < result.len() ==> (x1[i] == 0 && x2[i] != 0) ==> result[i] as int == int_abs(x2[i] as int),\n        forall|i: int| 0 <= i < result.len() ==> (result[i] as int) % (x1[i] as int) == 0 && (result[i] as int) % (x2[i] as int) == 0,\n        forall|i: int, d: int| 0 <= i < result.len() ==> (d % (x1[i] as int) == 0 && d % (x2[i] as int) == 0) ==> d % (result[i] as int) == 0,\n        forall|i: int| 0 <= i < result.len() ==> gcd(x2[i] as int, x1[i] as int) == gcd(x1[i] as int, x2[i] as int),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "mathematical_functions_gradient", "vc-description": "numpy.gradient: Return the gradient of an N-dimensional array.\n\nThe gradient is computed using second order accurate central differences \nin the interior points and either first or second order accurate one-sided \n(forward or backwards) differences at the boundaries.\n\nFor a 1D array, the gradient is a vector of the same size where:\n- At the boundaries, one-sided differences are used\n- In the interior, central differences are used\n\nThis captures the rate of change of the function represented by the array.\n\nSpecification: numpy.gradient computes the numerical gradient using finite differences.\n\nThe gradient satisfies these mathematical properties:\n1. For a single point array (n = 0), the gradient is 0\n2. For arrays with multiple points (n > 0):\n   - At the first boundary (i = 0): uses forward difference grad[0] = f[1] - f[0]\n   - At the last boundary (i = n): uses backward difference grad[n] = f[n] - f[n-1]\n   - For interior points (0 < i < n): uses central difference grad[i] = (f[i+1] - f[i-1]) / 2\n3. The gradient has the same size as the input array\n4. The gradient approximates the derivative at each point\n\nThis specification assumes unit spacing between points. The actual numpy \nfunction can handle custom spacing, but we focus on the core mathematical behavior.\n\nMathematical properties:\n- For linear functions f(x) = ax + b, the gradient is constant and equal to a\n- For constant functions, the gradient is 0 everywhere\n- The gradient operation is linear: grad(f + g) = grad(f) + grad(g)\n\nPrecondition: True (non-empty constraint is in the type Vector Float (n + 1))\nPostcondition: The gradient is computed using appropriate finite difference formulas", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_gradient(f: Vec<f64>) -> (grad: Vec<f64>)\n    requires f.len() > 0,\n    ensures\n        grad.len() == f.len(),\n        f.len() == 1 ==> grad[0] == 0.0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "mathematical_functions_heaviside", "vc-description": "Compute the Heaviside step function.\n\nThe Heaviside step function is defined as:\n  0 if x1 < 0\n  x2 if x1 == 0\n  1 if x1 > 0\n\nCompute the Heaviside step function element-wise.\nReturns 0 if x < 0, x2 if x == 0, and 1 if x > 0.\n\nSpecification: The Heaviside function returns values based on the sign of x1 elements.\nFor each element:\n- If x1[i] < 0, result[i] = 0\n- If x1[i] = 0, result[i] = x2[i]\n- If x1[i] > 0, result[i] = 1\n\nThis specification captures the complete behavior of the heaviside step function\nincluding the crucial property that it's completely determined by the sign of x1\nand uses x2 as the value at the discontinuity point.\n\n// uninterpreted function representing x == 0.0\n\n// uninterpreted function representing x > 0.0\n\n// uninterpreted function representing x < 0.0", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_zero(x: f32) -> bool {\n    true\n}\n\nspec fn is_positive(x: f32) -> bool {\n    true\n}\n\nspec fn is_negative(x: f32) -> bool {\n    true\n}\n\nfn heaviside(x1: Vec<f32>, x2: Vec<f32>) -> (result: Vec<f32>)\n    requires x1.len() == x2.len(),\n    ensures \n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < x1.len() ==> {\n            (is_negative(x1[i]) ==> result[i] == 0.0f32) &&\n            (is_zero(x1[i]) ==> result[i] == x2[i]) &&\n            (is_positive(x1[i]) ==> result[i] == 1.0f32) &&\n            (result[i] == 0.0f32 || result[i] == 1.0f32 || result[i] == x2[i])\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "mathematical_functions_imag", "vc-description": "Return the imaginary part of the complex argument. For a vector where each element is represented as a pair (real, imaginary), extracts the imaginary component of each element. For real numbers (where imaginary part is 0), returns 0.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn imag(val: Vec<(f64, f64)>) -> (result: Vec<f64>)\n    ensures\n        result.len() == val.len(),\n        forall|i: int| 0 <= i < val.len() ==> result[i] == val[i].1,\n        forall|i: int| 0 <= i < val.len() ==> (val[i].1 == 0.0 ==> result[i] == 0.0),\n        forall|i: int| 0 <= i < val.len() ==> (val[i].0 != 0.0 || val[i].1 != 0.0 ==> result[i] == val[i].1),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "mathematical_functions_interp", "vc-description": "One-dimensional linear interpolation for monotonically increasing sample points.\nReturns the one-dimensional piecewise linear interpolant to a function with given\ndiscrete data points (xp, fp), evaluated at x.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn interp(x: Vec<i32>, xp: Vec<i32>, fp: Vec<i32>) -> (result: Vec<i32>)\n    requires \n        xp.len() > 0,\n        fp.len() == xp.len(),\n        x.len() > 0,\n        forall|i: int, j: int| 0 <= i < j < xp.len() ==> xp[i] < xp[j],\n    ensures \n        result.len() == x.len(),\n        forall|k: int| 0 <= k < x.len() ==> (\n            (x[k] <= xp[0] ==> result[k] == fp[0]) &&\n            (x[k] >= xp[xp.len() - 1] ==> result[k] == fp[fp.len() - 1])\n        )", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "mathematical_functions_lcm", "vc-description": "Returns the lowest common multiple of |x1| and |x2| element-wise.\n\nComputes the lowest common multiple (LCM) of the absolute values of \nthe elements in x1 and x2. The LCM is the smallest non-negative integer \nthat is a multiple of both |x1| and |x2|.\n\nMathematical Properties:\n- lcm(a, b) = lcm(b, a) (commutativity)\n- lcm(a, b) * gcd(a, b) = |a * b| (fundamental relationship)\n- lcm(0, b) = lcm(a, 0) = 0 (zero property)\n- lcm(a, b) ≥ 0 (non-negativity)\n- |a| divides lcm(a, b) and |b| divides lcm(a, b) (divisibility)\n- lcm(a, b) is minimal among all positive integers divisible by both |a| and |b|\n\n/* Basic correctness: each element is the LCM of corresponding elements */\n\n/* Non-negativity: LCM is always non-negative */\n\n/* Zero property: LCM with zero is zero */\n\n/* Special case: when both are non-zero, LCM is positive */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn gcd_spec(a: int, b: int) -> nat;\n\nspec fn lcm_spec(a: int, b: int) -> nat;\n\nfn lcm(x1: Vec<i32>, x2: Vec<i32>) -> (result: Vec<i32>)\n    requires x1.len() == x2.len(),\n    ensures \n        result.len() == x1.len(),\n\n        forall|i: int| 0 <= i < result.len() ==> result[i] >= 0,\n\n        forall|i: int| 0 <= i < result.len() ==> result[i] >= 0,\n\n        forall|i: int| 0 <= i < result.len() ==> \n            (x1[i] == 0 || x2[i] == 0) ==> result[i] == 0,\n\n        forall|i: int| 0 <= i < result.len() ==> \n            (x1[i] != 0 && x2[i] != 0) ==> result[i] > 0", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "mathematical_functions_ldexp", "vc-description": "Returns x1 * 2**x2, element-wise.\nThe mantissas x1 and twos exponents x2 are used to construct floating point numbers x1 * 2**x2.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn ldexp_value(x1: f32, x2: i32) -> f32;\n\nfn ldexp(x1: Vec<f32>, x2: Vec<i32>) -> (result: Vec<f32>)\n    requires x1.len() == x2.len(),\n    ensures\n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == ldexp_value(x1[i], x2[i])", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "mathematical_functions_log", "vc-description": "numpy.log: Natural logarithm, element-wise.\n\nThe natural logarithm log is the inverse of the exponential function,\nso that log(exp(x)) = x. The natural logarithm is logarithm base e.\n\nReturns an array of the same shape as x, containing the natural logarithm\nof each element in x.\n\nNote: The domain of the natural logarithm is the positive real numbers.\nMathematically, log(x) is undefined for x ≤ 0.\n\nSpecification: log returns a vector where each element is the natural\nlogarithm of the corresponding element in x.\n\nPrecondition: All elements must be positive (x[i] > 0)\nPostcondition: For all indices i, result[i] = log(x[i])\n\nMathematical properties:\n- log is the inverse of exp: log(exp(x)) = x\n- log(1) = 0\n- log(e) = 1\n- log(x*y) = log(x) + log(y) for positive x, y\n- log is strictly increasing on (0, ∞)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn log(x: Vec<i32>) -> (result: Vec<i32>)\n    requires \n        x.len() > 0,\n        forall|i: int| 0 <= i < x.len() ==> x[i as int] > 0,\n    ensures \n        result.len() == x.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "mathematical_functions_log2", "vc-description": "numpy.log2: Base-2 logarithm of x, element-wise.\n\nThe base-2 logarithm is the inverse of the exponential function with base 2,\nso that log2(2^x) = x. This is useful for computing the number of bits needed\nto represent a number or for operations involving powers of 2.\n\nReturns an array of the same shape as x, containing the base-2 logarithm\nof each element in x.\n\nSpecification: log2 returns a vector where each element is the base-2\nlogarithm of the corresponding element in x.\n\nPrecondition: All elements must be positive (x[i] > 0) since the logarithm\nis only defined for positive real numbers.\n\nPostcondition: For all indices i, result[i] = Float.log2 x[i]\n\nMathematical properties:\n- log2(2^x) = x for any x\n- log2(x * y) = log2(x) + log2(y) for positive x, y\n- log2(x / y) = log2(x) - log2(y) for positive x, y\n- log2(1) = 0\n- log2(2) = 1", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn log2(x: Vec<f32>) -> (result: Vec<f32>)\n    requires x.len() > 0,\n    ensures result.len() == x.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "mathematical_functions_logaddexp", "vc-description": "numpy.logaddexp: Logarithm of the sum of exponentiations of the inputs.\n\nCalculates log(exp(x1) + exp(x2)) element-wise. This function is useful \nin statistics where the calculated probabilities of events may be so small \nas to exceed the range of normal floating point numbers.\n\nThe logaddexp function provides a numerically stable way to compute\nlog(exp(x1) + exp(x2)) without intermediate overflow or underflow.\n\nMathematical properties:\n- logaddexp(x, x) = x + log(2)\n- logaddexp(x, -∞) = x\n- logaddexp(-∞, x) = x\n- logaddexp is symmetric: logaddexp(x, y) = logaddexp(y, x)\n- logaddexp is associative in the sense that it satisfies the log-sum-exp properties\n- logaddexp(x, y) ≥ max(x, y) for all x, y\n\nFrom NumPy documentation:\n- Parameters: x1, x2 (array_like) - Input arrays\n- Returns: ndarray - The element-wise logaddexp of the inputs\n\nSpecification: numpy.logaddexp returns a vector where each element is the\nlogarithm of the sum of exponentiations of the corresponding elements.\n\nMathematical Properties:\n1. Element-wise correctness: result[i] = log(exp(x1[i]) + exp(x2[i]))\n2. Commutativity: logaddexp(x1, x2) = logaddexp(x2, x1)\n3. Numerical stability: avoids intermediate overflow/underflow\n4. Bounds: logaddexp(x, y) ≥ max(x, y) for all x, y\n5. Special cases: \n   - logaddexp(x, x) = x + log(2)\n   - logaddexp(x, -∞) = x (when x is finite)\n   - logaddexp(-∞, x) = x (when x is finite)\n6. Monotonicity: logaddexp is monotonically increasing in both arguments\n7. Associativity property: satisfies log-sum-exp algebraic relations\n\nPrecondition: True (logaddexp is defined for all real numbers)\nPostcondition: For all indices i, result[i] = log(exp(x1[i]) + exp(x2[i]))\n               and result[i] ≥ max(x1[i], x2[i])", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n#[verifier::external_body]\nspec fn logaddexp_value(x1: f64, x2: f64) -> f64;", "vc-helpers": "", "vc-spec": "fn logaddexp(x1: Vec<f64>, x2: Vec<f64>) -> (result: Vec<f64>)\n    requires x1.len() == x2.len(),\n    ensures \n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> {\n            result[i] == logaddexp_value(x1[i], x2[i])\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "mathematical_functions_logaddexp2", "vc-description": "numpy.logaddexp2: Logarithm of the sum of exponentiations of the inputs in base-2.\n\nCalculates log2(2^x1 + 2^x2) element-wise. This function is mathematically equivalent to\nlog2(2^x1 + 2^x2) but is computed in a numerically stable way that avoids overflow for\nlarge input values.\n\nThe function is useful for numerical computations where you need to add exponentials\nwithout causing overflow, particularly in machine learning and statistical applications.\n\nReturns an array of the same shape as the input arrays, containing the base-2 logarithm\nof the sum of exponentiations of corresponding elements.\n\nSpecification: numpy.logaddexp2 returns a vector where each element is the base-2\nlogarithm of the sum of exponentiations of the corresponding elements in x1 and x2.\n\nPrecondition: True (no special preconditions - numerically stable for all finite values)\nPostcondition: For all indices i, result[i] = log2(2^x1[i] + 2^x2[i])\n\nMathematical properties:\n- Commutativity: logaddexp2(x1, x2) = logaddexp2(x2, x1)\n- Monotonicity: If x1 ≤ y1 and x2 ≤ y2, then logaddexp2(x1, x2) ≤ logaddexp2(y1, y2)\n- Bounds: max(x1, x2) ≤ logaddexp2(x1, x2) ≤ max(x1, x2) + 1", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_logaddexp2(x1: Vec<f32>, x2: Vec<f32>) -> (result: Vec<f32>)\n    requires x1.len() == x2.len(),\n    ensures result.len() == x1.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "mathematical_functions_modf", "vc-description": "numpy.modf: Return the fractional and integral parts of an array, element-wise.\n\nReturns a tuple (fractional_parts, integral_parts) where both parts\nhave the same sign as the input. The fractional and integral parts\nare negative if the given number is negative.\n\nSpecification: numpy.modf returns fractional and integral parts where:\n1. The fractional and integral parts sum to the original value\n2. The fractional part has absolute value less than 1\n3. Both parts have the same sign as the original number (or zero)\n4. The integral part is the truncated integer part\n\nPrecondition: True (no special preconditions for modf)\nPostcondition: For all indices i, the fractional and integral parts satisfy mathematical properties", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_modf(x: Vec<f32>) -> (result: (Vec<f32>, Vec<f32>))\n    ensures\n        result.0.len() == x.len(),\n        result.1.len() == x.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "mathematical_functions_nan_to_num", "vc-description": "Replace NaN with zero and infinity with large finite numbers element-wise\n\nSpecification: nan_to_num replaces non-finite floating-point values with finite alternatives:\n1. NaN replacement: All NaN values are replaced with 0.0\n2. Positive infinity replacement: All positive infinity values are replaced with a large finite value  \n3. Negative infinity replacement: All negative infinity values are replaced with a large negative finite value\n4. Finite value preservation: All finite values remain unchanged\n5. All results are finite: The output contains only finite floating-point numbers", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn nan_to_num(x: Vec<f64>) -> (result: Vec<f64>)\n    ensures \n        result.len() == x.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "mathematical_functions_nancumprod", "vc-description": "Return the cumulative product of array elements over a given axis treating Not a Numbers (NaNs) as one.\n\nReturn the cumulative product of array elements treating NaNs as 1.\nThe cumulative product does not change when NaNs are encountered and leading NaNs are replaced by ones.\n\nSpecification: nancumprod returns the cumulative product while treating NaN values as 1.\nThis means:\n1. The resulting array has the same size as the input\n2. Each element is the product of all non-NaN elements from the start up to that position\n3. NaN values are treated as 1 in the product calculation\n4. Leading NaNs are replaced by ones\n5. The cumulative product property holds for non-NaN values\n\n/* Complex mathematical properties involving cumulative products and NaN handling\n           would require additional specification functions for float arithmetic */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn nancumprod(arr: Vec<f32>) -> (result: Vec<f32>)\n    ensures \n        result.len() == arr.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "mathematical_functions_nanprod", "vc-description": "Return the product of array elements over a given axis treating Not a Numbers (NaNs) as ones.\n\nnumpy.nanprod: Return the product of array elements treating NaNs as ones.\n\nComputes the product of all elements in the array, treating NaN values as 1.\nThis is useful for computing products while ignoring missing or invalid data\nrepresented as NaN.\n\nFor empty arrays, returns 1 as the identity element of multiplication.\nFor arrays containing only NaN values, returns 1.\nFor arrays with mixed NaN and non-NaN values, returns the product of the non-NaN values.\n\nSpecification: numpy.nanprod returns the product of all non-NaN elements in the vector.\n\nPrecondition: True (works for any vector, including empty)\nPostcondition: result equals the product of all non-NaN elements, satisfying:\n1. NaN values are treated as 1 (multiplicative identity)\n2. Empty vectors return 1\n3. Vectors with only NaN values return 1\n4. The result is mathematically equivalent to filtering out NaN values and taking the product\n5. The result is never NaN (since NaN values are ignored)\n6. If no NaN values exist, this behaves identically to regular product", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn product_of_non_nan_elements(a: Seq<f32>) -> f32 {\n    arbitrary()\n}\n\nfn nanprod(a: Vec<f32>) -> (result: f32)\n    ensures result == product_of_non_nan_elements(a@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "mathematical_functions_positive", "vc-description": "numpy.positive: Numerical positive, element-wise.\n\nReturns a copy of the input array with the same values.\nThis is equivalent to the unary plus operator (+x) and \nis only defined for types that support arithmetic operations.\n\nThe function performs element-wise positive operation, which\nfor real numbers simply returns the same value.\n\nSpecification: numpy.positive returns a vector where each element is\nthe positive of the corresponding element in x (which is the same value).\n\nPrecondition: True (no special preconditions for positive operation)\nPostcondition: For all indices i, result[i] = +x[i] = x[i]\n\nMathematical Properties:\n- Identity operation: positive(x) = x\n- Idempotence: positive(positive(x)) = positive(x)\n- Preserves sign: sign(positive(x)) = sign(x)\n- Preserves magnitude: |positive(x)| = |x|\n- Distributivity with multiplication: positive(x) * y = x * y", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn positive(x: Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == x[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "mathematical_functions_reciprocal", "vc-description": "numpy.reciprocal: Return the reciprocal of the argument, element-wise.\n\nCalculates 1/x for each element in the input array.\nThis is equivalent to raising each element to the power of -1.\n\nThe function requires that all elements are non-zero to avoid division by zero.\nFor floating-point inputs, the reciprocal of zero would be infinity.\n\nReturns an array of the same shape as x, containing the reciprocals.\n\nSpecification: numpy.reciprocal returns a vector where each element is the\nreciprocal (1/x) of the corresponding element in x.\n\nPrecondition: All elements in x must be non-zero to avoid division by zero\nPostcondition: For all indices i, result[i] = 1 / x[i]\n\nMathematical properties captured in the specification:\n- Basic reciprocal property: result[i] = 1 / x[i]\n- Domain restriction: x[i] ≠ 0 for all i\n- Sign preservation: sign(result[i]) = sign(x[i])\n- Magnitude inversion: |result[i]| = 1 / |x[i]|\n\nAdditional mathematical properties (provable from the spec):\n- reciprocal(reciprocal(x)) = x for all non-zero x\n- reciprocal(x * y) = reciprocal(x) * reciprocal(y) for non-zero x, y\n- reciprocal(1) = 1\n- reciprocal(-1) = -1\n- For x > 0: reciprocal(x) > 0\n- For x < 0: reciprocal(x) < 0", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_reciprocal(x: Vec<f32>) -> (result: Vec<f32>)\n    requires \n        x.len() > 0,\n        forall|i: int| 0 <= i < x.len() ==> x[i] != 0.0_f32,\n    ensures\n        result.len() == x.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "mathematical_functions_remainder", "vc-description": "numpy.remainder: Returns the element-wise remainder of division.\n\nComputes the remainder complementary to the floor_divide function.\nThis is equivalent to x1 % x2 in terms of array broadcasting.\n\nThe result has the same sign as the divisor x2.\nFor floating point inputs, the result is mathematically defined as:\nx1 - floor(x1/x2) * x2\n\nFrom NumPy documentation:\n- Parameters: x1, x2 (array_like) - The dividend and divisor arrays\n- Returns: remainder (ndarray) - The element-wise remainder of x1 divided by x2\n- This is a universal function (ufunc) implemented in C\n- Uses optimized C loops for different data types\n\nSpecification: numpy.remainder returns a vector where each element is the remainder\nof the corresponding elements from x1 and x2.\n\nMathematical Properties:\n1. Element-wise correctness: result[i] = x1[i] % x2[i]\n2. Complementary to floor division: x1[i] = floor(x1[i]/x2[i]) * x2[i] + result[i]\n3. Sign follows divisor: result[i] has the same sign as x2[i] (when x2[i] ≠ 0)\n4. Magnitude bound: |result[i]| < |x2[i]| (when x2[i] ≠ 0)\n5. Mathematical definition: result[i] = x1[i] - floor(x1[i]/x2[i]) * x2[i]\n6. Preserves vector length: result.size = x1.size = x2.size\n7. Handles IEEE 754 floating-point arithmetic\n\nPrecondition: All elements in x2 must be non-zero\nPostcondition: For all indices i, result[i] satisfies the remainder properties", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn remainder(x1: Vec<f64>, x2: Vec<f64>) -> (result: Vec<f64>)\n    requires \n        x1.len() == x2.len(),\n        forall|i: int| 0 <= i < x2.len() ==> x2[i] != 0.0,\n    ensures\n        result.len() == x1.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "mathematical_functions_rint", "vc-description": "numpy.rint: Round elements of the array to the nearest integer.\n\nRounds each element in the input array to the nearest integer using\nIEEE 754 rounding rules (round half to even). The result is returned\nas a floating-point array of the same shape as the input.\n\nThis function uses the C math library's rint function which rounds\nto the nearest integer, with ties (halves) rounded to the nearest even number.\n\nReturns an array of the same shape as x, containing the rounded values.\n\nSpecification: numpy.rint returns a vector where each element is\nrounded to the nearest integer using IEEE 754 rounding rules.\n\nPrecondition: True (no special preconditions for rint)\nPostcondition: For all indices i:\n  - result[i] is the nearest integer to x[i]\n  - for ties (half-integers), result[i] is the nearest even integer\n  - result[i] is a floating-point representation of the integer\n  - |result[i] - x[i]| ≤ 0.5 for all i\n  - if x[i] is already an integer, result[i] = x[i]", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_rint(x: Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() == x.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "mathematical_functions_round", "vc-description": "Evenly round to the given number of decimals.\n\nnumpy.round: Evenly round to the given number of decimals.\n\nRounds each element of the input array to the given number of decimal places.\nUses \"banker's rounding\" (round half to even) for ties.\n\nFor decimals=0: rounds to nearest integer\nFor decimals>0: rounds to that many decimal places\nFor decimals<0: rounds to nearest 10^(-decimals)\n\nReturns an array of the same shape as input, containing the rounded values.\n\nSpecification: numpy.round rounds each element to the specified number of decimal places.\n\nPrecondition: True (rounding is defined for all real numbers and decimal places)\nPostcondition: For all indices i, result[i] is the rounded value of a[i] to 'decimals' places:\n- For decimals = 0: result[i] is the nearest integer to a[i]\n- For decimals > 0: result[i] is rounded to that many decimal places\n- For decimals < 0: result[i] is rounded to nearest multiple of 10^(-decimals)\n- Uses banker's rounding (round half to even) for ties\n- Monotonicity: if a[i] ≤ a[j] then result[i] ≤ result[j]\n- For decimals=0: result[i] is an integer value\n- Approximation property: result[i] is close to a[i] within rounding precision", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_round(a: Vec<f64>, decimals: i32) -> (result: Vec<f64>)\n    requires a.len() > 0,\n    ensures \n        result.len() == a.len()", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "mathematical_functions_sin", "vc-description": "numpy.sin: Trigonometric sine, element-wise.\n\nComputes the sine of each element in the input vector, where each element \nis interpreted as an angle in radians. The sine function is one of the \nfundamental trigonometric functions.\n\nFor a real number x interpreted as an angle in radians, sin(x) gives the \ny-coordinate of the point on the unit circle at angle x from the positive x-axis.\n\nReturns a vector of the same shape as the input, containing the sine of each element.\n\nSpecification: numpy.sin returns a vector where each element is the sine\nof the corresponding element in x (interpreted as radians).\n\nThe specification captures key mathematical properties:\n1. Element-wise computation: result[i] = sin(x[i])\n2. Range bounds: sine values are always in [-1, 1]\n3. Fundamental trigonometric identities:\n   - sin(0) = 0\n   - sin(π/2) = 1\n   - sin(π) = 0 (approximately, within floating-point precision)\n   - sin(3π/2) = -1\n   - sin(2π) = 0 (approximately, within floating-point precision)\n4. Periodicity: sin(x + 2π) = sin(x)\n5. Odd function property: sin(-x) = -sin(x)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn sin(x: Vec<f32>) -> (result: Vec<f32>)\n    requires x.len() > 0,\n    ensures result.len() == x.len()", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "mathematical_functions_sinh", "vc-description": "numpy.sinh: Hyperbolic sine, element-wise.\n\nThe hyperbolic sine function is defined as:\nsinh(x) = (e^x - e^(-x)) / 2\n\nIt represents the y-coordinate of a point on the unit hyperbola,\nanalogous to how sine represents the y-coordinate on the unit circle.\nUnlike the regular sine function, sinh is unbounded and monotonic.\n\nReturns an array of the same shape as x, containing the hyperbolic sine of each element.\n\nSpecification: numpy.sinh returns a vector where each element is the hyperbolic sine\nof the corresponding element in x.\n\nPrecondition: True (no special preconditions for hyperbolic sine)\nPostcondition: \n1. For all indices i, result[i] = (e^x[i] - e^(-x[i])) / 2\n2. The function is odd: sinh(-x) = -sinh(x)\n3. Monotonicity: sinh is strictly increasing on all of ℝ\n4. Zero property: sinh(0) = 0\n5. Range property: sinh(x) ∈ (-∞, ∞) for all x ∈ ℝ\n6. Sign property: sinh(x) has the same sign as x\n7. Symmetry property: sinh(-x) = -sinh(x)\n\n// Simplified specification without direct floating point arithmetic in spec\n\n// Placeholder for mathematical properties\n\n/* Simplified properties without floating point spec operations */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn sinh_property(x: f64, result: f64) -> bool {\n\n    true\n}\n\nfn sinh(x: Vec<f64>) -> (result: Vec<f64>)\n    requires x.len() > 0,\n    ensures \n        result.len() == x.len(),\n\n        forall|i: int| 0 <= i < x.len() ==> sinh_property(x[i], result[i])", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "mathematical_functions_square", "vc-description": "numpy.square: Return the element-wise square of the input.\n\nComputes x^2 element-wise. This is equivalent to x * x but may be\nmore efficient for certain data types. The function squares each element\nof the input array and returns an array of the same shape.\n\nThis is a universal function (ufunc) that operates element-wise on arrays.\n\nSpecification: numpy.square returns a vector where each element is the\nsquare of the corresponding element in x.\n\nPrecondition: True (no special preconditions for squaring)\nPostcondition: For all indices i, result[i] = x[i]^2\n\nMathematical Properties:\n- Result is always non-negative: ∀ i, result[i] ≥ 0\n- Preserves zeros: x[i] = 0 → result[i] = 0\n- Monotonic for non-negative inputs: 0 ≤ x[i] ≤ x[j] → result[i] ≤ result[j]", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn square_f64(x: f64) -> f64;", "vc-helpers": "", "vc-spec": "fn numpy_square(x: Vec<f64>) -> (result: Vec<f64>)\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == square_f64(x[i])", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "mathematical_functions_sum", "vc-description": "numpy.sum: Sum of array elements over a given axis.\n\nComputes the sum of all elements in the vector. For empty vectors,\nreturns 0 as the identity element of addition.\n\nThis is a reduction operation that applies addition across all\nelements to produce a single scalar result.\n\nMathematical Properties:\n- Commutative: order of elements doesn't affect the final sum\n- Associative: grouping of operations doesn't affect the result\n- Identity element: empty array sum is 0\n- Distributive: sum(a * c) = c * sum(a) for scalar c\n\nFrom NumPy documentation:\n- Parameters: a (array_like) - Elements to sum\n- Returns: sum_along_axis (ndarray) - Sum of array elements\n- The function handles axis parameter (ignored in 1D case)\n- Supports optional dtype, initial value, and where condition\n\nSpecification: sum computes the sum of all elements in a vector.\n\nThe sum operation has several important mathematical properties:\n1. For empty vectors, returns 0 (additive identity)\n2. For non-empty vectors, returns the sum of all elements\n3. The operation is commutative and associative\n4. Linearity: sum(a + b) = sum(a) + sum(b) (element-wise addition)\n5. Scalar multiplication: sum(c * a) = c * sum(a) for scalar c\n\nThis specification captures both the basic behavior and key mathematical\nproperties that make sum well-defined and predictable.\n\nPrecondition: True (works for any vector, including empty)\nPostcondition: Result equals the sum of all elements using fold operation", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn vec_sum(a: Seq<f32>) -> f32;\n\nfn sum(a: Vec<f32>) -> (result: f32)\n    ensures \n        result == vec_sum(a@),\n        a.len() == 0 ==> result == 0.0f32,\n        (forall|i: int| 0 <= i < a.len() ==> a[i] == 0.0f32) ==> result == 0.0f32,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "mathematical_functions_tan", "vc-description": "Compute tangent element-wise. Equivalent to sin(x)/cos(x) element-wise.\n\nSpecification: tan computes the tangent of each element, equivalent to sin(x)/cos(x),\nand is undefined when cos(x) = 0 (i.e., x = π/2 + kπ for integer k)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn tan(x: Vec<f32>) -> (result: Vec<f32>)\n    requires \n        x.len() > 0,\n    ensures\n        result.len() == x.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "mathematical_functions_trapezoid", "vc-description": "Integrate along the given axis using the composite trapezoidal rule. The composite trapezoidal rule approximates definite integrals using trapezoidal approximations between sample points.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn trapezoid(y: Vec<i32>, dx: i32) -> (result: i32)\n    requires \n        y.len() > 0,\n        dx > 0,\n    ensures\n        (forall|i: int| 0 <= i < y.len() ==> #[trigger] y[i] == y[0]) ==> \n            result == dx * (y.len() - 1) as i32 * y[0],\n        (forall|i: int| 0 <= i < y.len() ==> #[trigger] y[i] >= 0) ==> result >= 0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "ndarray_flat", "vc-description": "numpy.ndarray.flat: A 1-D iterator over the array.\n\nThis operation provides a flattened view of the array, allowing access\nto elements as if the array were 1-dimensional. For 1D arrays, this is\nessentially an identity operation that provides indexed access to elements.\n\nThe flat iterator acts as a view into the underlying array data, preserving\nthe order of elements as they appear in memory (row-major order).\n\nSpecification: numpy.ndarray.flat returns a flattened view of the array.\n\nPrecondition: True (no special preconditions for flattening)\nPostcondition: The result contains the same elements in the same order,\n               providing a 1D view of the input array", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_flat(a: Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> result[i] == a[i]", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "ndarray_flatten", "vc-description": "numpy.ndarray.flatten: Return a copy of the array collapsed into one dimension.\n\nFlattens a 2D matrix into a 1D vector using row-major (C-style) order.\nEach row is placed sequentially in the output vector.\n\nParameters:\n- mat: 2D matrix represented as Vector of Vectors\n\nReturns:\n- 1D vector containing all elements in row-major order\n\nExample: [[1,2], [3,4]] becomes [1, 2, 3, 4]\n\nSpecification: flatten returns a 1D vector containing all elements of the 2D matrix\nin row-major order.\n\nPrecondition: True (no special preconditions)\nPostcondition: \n- The result has size rows * cols\n- Each element at position (row * cols + col) equals the original element at (row, col)\n- Elements are ordered by row-major traversal (row 0 first, then row 1, etc.)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn flatten(mat: Vec<Vec<f32>>) -> (result: Vec<f32>)\n    requires \n        mat.len() > 0,\n        forall|i: int| 0 <= i < mat.len() ==> mat[i].len() > 0,\n        forall|i: int, j: int| 0 <= i < mat.len() && 0 <= j < mat.len() ==> mat[i].len() == mat[j].len(),\n    ensures \n        result.len() == mat.len() * mat[0].len(),\n        forall|r: int, c: int| \n            0 <= r < mat.len() && 0 <= c < mat[0].len() ==>\n            result[r * mat[0].len() + c] == mat[r][c]", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "ndarray_tofile", "vc-description": "numpy.ndarray.tofile: Write array to a file as text or binary data.\n\nWrites the array data to a file in 'C' order (row-major), independent of the\noriginal array order. The data can be recovered using numpy.fromfile().\n\nThis operation converts the array elements to their binary or text representation\nand writes them sequentially to the specified file.\n\nSpecification: numpy.ndarray.tofile writes array data to a file in a format\nthat preserves all original data and can be recovered by fromfile.\n\nPrecondition: True (no special preconditions for file writing)\nPostcondition: The operation succeeds (returns unit) and the file contains\na faithful representation of the array data in 'C' order, preserving:\n1. The number of elements (file_data.length = n)\n2. The exact values in sequential order\n3. All elements are written without loss of precision\n\nThis ensures the fundamental property that tofile and fromfile are inverses\nwhen used with the same data format.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_tofile(arr: Vec<f32>, filename: String) -> (result: ())\n    requires true,\n    ensures result == ()", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_chebyshev_cheb2poly", "vc-description": "Convert a Chebyshev series to a polynomial.\n\nConvert an array representing the coefficients of a Chebyshev series,\nordered from lowest degree to highest, to an array of the coefficients\nof the equivalent polynomial (relative to the \"standard\" basis) ordered\nfrom lowest to highest degree.\n\nSpecification: cheb2poly converts Chebyshev coefficients to polynomial coefficients.\n\nThe conversion satisfies the mathematical property that if we have Chebyshev series\n∑_{k=0}^{n-1} c[k] * T_k(x) where T_k is the k-th Chebyshev polynomial,\nthen the output polynomial coefficients p satisfy:\n∑_{k=0}^{n-1} c[k] * T_k(x) = ∑_{k=0}^{n-1} p[k] * x^k\n\nKey properties:\n1. Length preservation: output has same length as input\n2. Identity cases: for n ≤ 2, the output equals the input (since T₀(x) = 1, T₁(x) = x)\n3. Correctness: The polynomial form evaluates to the same value as the Chebyshev series\n4. Example verification: [0, 1, 2, 3] → [-2, -8, 4, 12]\n\nThe algorithm uses the recurrence relation of Chebyshev polynomials:\nT₀(x) = 1, T₁(x) = x, T_{n+1}(x) = 2xT_n(x) - T_{n-1}(x)\n\n/* Basic properties */\n\n/* 1. Length preservation */\n\n/* 2. Identity for small cases */\n\n/* 3. Mathematical correctness: The core property is that\n           evaluating the polynomial with coefficients p at any point x\n           gives the same result as evaluating the Chebyshev series\n           with coefficients c at that point.\n           This is the fundamental correctness property of the conversion. */\n\n/* For clarity, we state this property abstractly:\n               polyEval(p, x) = chebEval(c, x)\n               where polyEval computes p₀ + p₁x + p₂x² + ... + p_{n-1}x^{n-1}\n               and chebEval computes c₀T₀(x) + c₁T₁(x) + ... + c_{n-1}T_{n-1}(x) */\n\n/* 4. Concrete example from NumPy documentation\n           When c = [0, 1, 2, 3], then p = [-2, -8, 4, 12]\n           This verifies: 0*T₀ + 1*T₁ + 2*T₂ + 3*T₃ = -2 - 8x + 4x² + 12x³ */\n\n/* 5. Additional mathematical properties\n           The conversion is linear: cheb2poly(αc + βd) = α*cheb2poly(c) + β*cheb2poly(d) */\n\n/* 6. Stability: small changes in input lead to small changes in output\n           This is important for numerical applications */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn cheb2poly(c: Vec<f64>) -> (p: Vec<f64>)\n    ensures\n\n        p.len() == c.len(),\n\n        (c.len() == 0 ==> p@ == c@),\n        (c.len() == 1 ==> p@ == c@),\n        (c.len() == 2 ==> p@ == c@),\n\n        (forall|x: f64|\n\n            true),\n\n        (c.len() == 4 ==>\n            (c[0] == 0.0 && c[1] == 1.0 && c[2] == 2.0 && c[3] == 3.0) ==>\n            (p[0] == -2.0 && p[1] == -8.0 && p[2] == 4.0 && p[3] == 12.0)),\n\n        (forall|d: Vec<f64>, alpha: f64, beta: f64|\n            d.len() == c.len() ==> true),\n\n        (forall|epsilon: f64, d: Vec<f64>|\n            d.len() == c.len() ==> true)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_chebyshev_chebcompanion", "vc-description": "numpy.polynomial.chebyshev.chebcompanion: Return the scaled companion matrix of c.\n\nThe basis polynomials are scaled so that the companion matrix is\nsymmetric when c is a Chebyshev basis polynomial. This provides\nbetter eigenvalue estimates than the unscaled case and for basis\npolynomials the eigenvalues are guaranteed to be real if\nnumpy.linalg.eigvalsh is used to obtain them.\n\nParameters:\n- c : 1-D array of Chebyshev series coefficients ordered from low to high degree\n\nReturns:\n- mat : Scaled companion matrix of dimensions (deg, deg) where deg = len(c) - 1\n\nSpecification: chebcompanion returns a scaled companion matrix with specific structure.\n\nPrecondition: The input vector has at least 2 elements (enforced by type)\n\nPostcondition: The result is an (n+1) × (n+1) matrix where:\n1. The superdiagonal and subdiagonal have specific values (0.5 for most entries, sqrt(0.5) for the first)\n2. The last column is adjusted by scaled coefficients\n3. The matrix structure ensures symmetry for Chebyshev basis polynomials", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn chebcompanion(c: Vec<f32>) -> (result: Vec<Vec<f32>>)\n    requires c.len() >= 2,\n    ensures\n        result.len() == c.len() - 1,\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == c.len() - 1,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_chebyshev_chebder", "vc-description": "numpy.polynomial.chebyshev.chebder: Differentiate a Chebyshev series.\n\nReturns the Chebyshev series coefficients differentiated once.\nThe differentiation is based on the recurrence relations for Chebyshev\npolynomials. The derivative is multiplied by a scaling factor.\n\nFor a Chebyshev series c₀T₀ + c₁T₁ + c₂T₂ + ..., the derivative\nfollows specific recurrence relations that differ from standard polynomials.\n\nThe derivative of T_n is n*U_{n-1}, where U_{n-1} can be expressed\nin terms of Chebyshev polynomials T_k using specific recurrence relations.\n\nSpecification: chebder differentiates a Chebyshev series once.\n\nThe Chebyshev derivative algorithm works by:\n1. Creating a working copy of the coefficients\n2. Applying the recurrence relation from high to low order\n3. Scaling the result\n\nThe recurrence relation for Chebyshev derivatives is:\n- For j ≥ 2: der[j] = 2*(j+1)*c[j+1], and c[j-2] += j*c[j]/(j-2)\n- For j = 1: der[1] = 4*c[2]\n- For j = 0: der[0] = c[1]\n\nAll results are then multiplied by the scaling factor.\n\nMathematical property: If p(x) = Σ c[i]*T_i(x), then \np'(x) = Σ der[i]*T_i(x) where der = chebder(c, scl).\n\nPrecondition: True (works for any non-empty vector)\nPostcondition: \n- The result has size n\n- The coefficients follow the Chebyshev derivative recurrence relations\n- The result represents scl times the derivative of the input series", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn chebder(c: Vec<i32>, scl: i32) -> (result: Vec<i32>)\n    requires c.len() > 0,\n    ensures\n        result.len() == c.len() - 1,\n        c.len() > 1 ==> result[0] == scl * c[1],\n        c.len() > 2 ==> result[1] == scl * 4 * c[2],\n        forall|j: int| 2 <= j < result.len() ==>\n            result[j] == scl * (2 * ((j + 1) as i32)) * c[j + 1],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_chebyshev_chebint", "vc-description": "numpy.polynomial.chebyshev.chebint: Integrate a Chebyshev series.\n\nReturns the Chebyshev series coefficients integrated m times from\nlbnd along axis. At each iteration the resulting series is\nmultiplied by scl and an integration constant k is added.\n\nThe integration transforms Chebyshev polynomials according to the\nrecurrence relations for Chebyshev polynomial integrals. For a \nsingle integration (m=1) of coefficients [c₀, c₁, ..., cₙ], the \nresult follows the Chebyshev integration formula.\n\nParameters:\n- c: Vector of Chebyshev series coefficients (low to high degree)\n- m: Order of integration (must be positive)\n- k: Integration constants (defaults to zeros)\n- lbnd: Lower bound of the integral (default: 0)\n- scl: Scaling factor applied after each integration (default: 1)\n\nSpecification: chebint integrates Chebyshev series coefficients m times.\n\nThe function performs m successive integrations of the Chebyshev series,\nwhere each integration:\n1. Multiplies the current coefficients by scl\n2. Applies the Chebyshev integration recurrence relations\n3. Adjusts the constant term to satisfy the boundary condition at lbnd\n4. Adds the corresponding integration constant from k\n\nMathematical properties:\n- The result has m more coefficients than the input (integration increases degree)\n- For m=0, returns the original coefficients unchanged\n- The integration follows Chebyshev polynomial recurrence relations:\n  ∫ Tₙ(x) dx = [Tₙ₊₁(x)/(2(n+1)) - Tₙ₋₁(x)/(2(n-1))] for n ≥ 2\n  ∫ T₁(x) dx = T₂(x)/4\n  ∫ T₀(x) dx = T₁(x)\n- The constant term is adjusted so the integral equals k[i] at x=lbnd\n\nSanity checks:\n- The output vector has exactly n + m coefficients\n- When m = 0, the function should return the input unchanged\n- Integration constants k affect only the constant term of each integration\n- The scaling factor scl is applied before adding integration constants\n\n/* For m=1 case, the function performs Chebyshev integration according to:\n           - T₀ integrates to T₁  \n           - T₁ integrates to T₂/4\n           - Tₙ (n≥2) integrates to [Tₙ₊₁/(2(n+1)) - Tₙ₋₁/(2(n-1))]\n           - The constant term is adjusted for boundary conditions at lbnd\n           - Integration constants from k are added appropriately\n\n           Note: Complex floating-point arithmetic specifications are simplified\n           due to Verus limitations with f32 operations in spec contexts */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn chebint(c: Vec<f32>, m: u32, k: Vec<f32>, lbnd: f32, scl: f32) -> (result: Vec<f32>)\n    requires \n        m > 0,\n        scl != 0.0f32,\n        k.len() == m,\n    ensures\n        result.len() == c.len() + (m as usize),\n\n        result.len() >= c.len(),\n        m == 1 ==> result.len() == c.len() + 1,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_chebyshev_chebline", "vc-description": "Chebyshev series whose graph is a straight line.\nReturns coefficients for the Chebyshev series representing off + scl*x.\nFor simplicity, we always return a 2-element vector where the second element\nmight be zero when scl = 0.\n\nSpecification: chebline returns correct Chebyshev coefficients for a linear function.\nThe key mathematical property is that the Chebyshev series T₀(x) = 1 and T₁(x) = x,\nso the coefficients [off, scl] directly represent off*T₀(x) + scl*T₁(x) = off + scl*x.\n\nThe result is always a 2-element vector [off, scl], even when scl = 0.\nThis represents the Chebyshev series: off * T₀(x) + scl * T₁(x) = off + scl*x\n\nMathematical Properties:\n1. The first coefficient equals the offset parameter\n2. The second coefficient equals the scale parameter\n3. When evaluated as a Chebyshev series, this produces the line off + scl*x\n4. This is the minimal degree Chebyshev representation of a linear function", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn chebline(off: f32, scl: f32) -> (result: [f32; 2])\n    ensures \n        result[0] == off,\n        result[1] == scl", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_chebyshev_chebmulx", "vc-description": "Multiply a Chebyshev series by x.\nThis function multiplies a Chebyshev polynomial represented by its coefficients by x.\nThe operation is based on the recurrence relation:\n- xT₀(x) = T₁(x)\n- xTₙ(x) = (Tₙ₊₁(x) + Tₙ₋₁(x))/2 for n ≥ 1\n\nSpecification: chebmulx correctly multiplies a Chebyshev polynomial by x.\n\nGiven coefficients c = [c₀, c₁, ..., cₙ₋₁] representing the polynomial\nP(x) = c₀T₀(x) + c₁T₁(x) + ... + cₙ₋₁Tₙ₋₁(x),\nthis function computes coefficients for xP(x).\n\nThe implementation follows from the Chebyshev recurrence relations:\n- xT₀(x) = T₁(x)\n- xTₙ(x) = (Tₙ₊₁(x) + Tₙ₋₁(x))/2 for n ≥ 1\n\nThe algorithm redistributes coefficients according to these relations,\nresulting in a polynomial with degree increased by 1.\n\n// Linearity property: chebmulx is a linear operation\n\n// For any scalars alpha, beta and vectors c1, c2 of same length:\n\n// chebmulx(alpha*c1 + beta*c2) = alpha*chebmulx(c1) + beta*chebmulx(c2)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn chebmulx(c: Vec<f64>) -> (result: Vec<f64>)\n    requires c.len() > 0,\n    ensures\n        result.len() == c.len() + 1,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_chebyshev_chebpts2", "vc-description": "Chebyshev points of the second kind.\n\nGenerates n Chebyshev points of the second kind, which are the values\ncos(π*k/(n-1)) for k from 0 to n-1, sorted in ascending order.\nThese points are the extrema and endpoints of the Chebyshev polynomial T_{n-1}.\n\nSpecification: chebpts2 generates Chebyshev points of the second kind\n\nThe function returns n points where:\n1. Each point is cos(π*k/(n-1)) for k from n-1 down to 0\n2. The points are sorted in ascending order\n3. The first point is -1 and the last point is 1\n4. The points are symmetric around 0 for the transformation x ↦ -x\n\n// First point is -1 \n\n// Last point is 1", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn chebpts2(n: usize) -> (result: Vec<f32>)\n    requires n >= 2,\n    ensures\n        result.len() == n,\n\n        result[0] == -1.0f32,\n\n        result[(n-1) as int] == 1.0f32,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_chebyshev_chebvander", "vc-description": "Pseudo-Vandermonde matrix of Chebyshev polynomials of given degree.\n\nGiven a vector of sample points `x` and a degree `deg`, returns a matrix\nwhere each row corresponds to a sample point and each column contains\nthe values of Chebyshev polynomials T_0, T_1, ..., T_deg evaluated at\nthat point.\n\nSpecification: chebvander produces a matrix where entry (i,j) is the j-th Chebyshev \npolynomial T_j evaluated at x[i], following the recurrence relation:\nT_0(x) = 1, T_1(x) = x, T_{k+1}(x) = 2x*T_k(x) - T_{k-1}(x)\n\n/* T_0(x) = 1 for all x */\n\n/* T_1(x) = x when deg >= 1 */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn chebvander(x: Vec<f32>, deg: usize) -> (result: Vec<Vec<f32>>)\n    requires deg >= 0,\n    ensures\n\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == (deg + 1),\n        forall|i: int| 0 <= i < result.len() ==> result[i][0] == 1.0f32,\n\n        deg >= 1 ==> forall|i: int| 0 <= i < result.len() ==> result[i][1] == x[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_chebyshev_chebweight", "vc-description": "The weight function of the Chebyshev polynomials.\nComputes 1/sqrt(1 - x²) for each element.\n\nSpecification: chebweight computes the Chebyshev weight function 1/sqrt(1 - x²).\nThe function is well-defined when all elements are in the open interval (-1, 1).\n\nMathematical properties:\n1. The weight function equals 1/sqrt(1 - x²) for each element\n2. The result is always positive for valid inputs\n3. The function is symmetric: w(-x) = w(x)\n4. The function approaches infinity as x approaches ±1\n5. The implementation uses the factored form 1/(sqrt(1+x) * sqrt(1-x)) for numerical stability", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn chebweight(x: Vec<f32>) -> (result: Vec<f32>)\n    requires \n        x.len() > 0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_chebyshev_poly2cheb", "vc-description": "Convert a polynomial to a Chebyshev series.\n\nConvert coefficients of a polynomial in the standard monomial basis\n(1, x, x², x³, ...) to coefficients in the Chebyshev polynomial basis\n(T₀(x), T₁(x), T₂(x), T₃(x), ...).\n\nThe input polynomial coefficients are ordered from lowest degree to highest:\npol = [a₀, a₁, a₂, ..., aₙ] represents the polynomial a₀ + a₁x + a₂x² + ... + aₙxⁿ\n\nThe output Chebyshev coefficients are also ordered from lowest to highest degree:\nresult = [c₀, c₁, c₂, ..., cₙ] represents c₀T₀(x) + c₁T₁(x) + c₂T₂(x) + ... + cₙTₙ(x)\n\n/* Example from documentation: [0.0, 1.0, 2.0, 3.0] → [1.0, 3.25, 1.0, 0.75] */\n\n/* Quadratic polynomial x²: [0, 0, 1] → [0.5, 0, 0.5] */\n\n/* Cubic polynomial x³: [0, 0, 0, 1] → [0, 0.75, 0, 0.25] */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn poly2cheb(pol: Vec<f64>) -> (result: Vec<f64>)\n    requires pol.len() > 0,\n    ensures \n        result.len() == pol.len(),\n\n        (pol.len() == 4 && pol[0] == 0.0 && pol[1] == 1.0 && pol[2] == 2.0 && pol[3] == 3.0) ==>\n            (result[0] == 1.0 && result[1] == 3.25 && result[2] == 1.0 && result[3] == 0.75),\n\n        (pol.len() == 3 && pol[0] == 0.0 && pol[1] == 0.0 && pol[2] == 1.0) ==>\n            (result[0] == 0.5 && result[1] == 0.0 && result[2] == 0.5),\n\n        (pol.len() == 4 && pol[0] == 0.0 && pol[1] == 0.0 && pol[2] == 0.0 && pol[3] == 1.0) ==>\n            (result[0] == 0.0 && result[1] == 0.75 && result[2] == 0.0 && result[3] == 0.25)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_hermite_Hermite", "vc-description": "Evaluates a Hermite polynomial at a given point.\nGiven coefficients (c₀, c₁, ..., cₙ), evaluates ∑ᵢ cᵢ * Hᵢ(x)\nwhere Hᵢ is the i-th Hermite polynomial.\n\nThe Hermite polynomials satisfy the recurrence:\nH₀(x) = 1\nH₁(x) = 2x\nHₙ₊₁(x) = 2x * Hₙ(x) - 2n * Hₙ₋₁(x)\n\nSpecification: hermiteEval correctly evaluates the Hermite polynomial series.\n\nMathematical properties:\n1. Empty coefficient vector evaluates to 0\n2. Single coefficient [c] evaluates to c * H₀(x) = c * 1 = c\n3. Two coefficients [a, b] evaluates to a + b * 2x\n4. The evaluation follows the Hermite polynomial recurrence relation\n5. Hermite polynomials form an orthogonal basis\n\n/* Complex Hermite polynomial properties */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermite_eval(coef: Vec<f32>, x: f32) -> (result: f32)\n    requires coef.len() > 0,\n    ensures \n        coef.len() == 1 ==> result == coef[0],\n        coef.len() >= 2 ==> true,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_hermite_e_HermiteE", "vc-description": "An HermiteE series class.\n\nThe HermiteE class provides the standard Python numerical methods\n'+', '-', '*', '//', '%', 'divmod', '**', and '()' as well as the\nattributes and methods listed below.\n\nParameters\n----------\ncoef : array_like\n    HermiteE coefficients in order of increasing degree, i.e,\n    ``(1, 2, 3)`` gives ``1*He_0(x) + 2*He_1(X) + 3*He_2(x)``.\ndomain : (2,) array_like, optional\n    Domain to use. The interval ``[domain[0], domain[1]]`` is mapped\n    to the interval ``[window[0], window[1]]`` by shifting and scaling.\n    The default value is [-1., 1.].\nwindow : (2,) array_like, optional\n    Window, see `domain` for its use. The default value is [-1., 1.].\nsymbol : str, optional\n    Symbol used to represent the independent variable in string\n    representations of the polynomial expression, e.g. for printing.\n    The symbol must be a valid Python identifier. Default value is 'x'.\n\n    .. versionadded:: 1.24\n\nCreate a HermiteE polynomial from coefficients with default domain and window [-1, 1]\n\nSpecification: Creating a HermiteE polynomial preserves coefficients and establishes mathematical properties.\n\nHermiteE polynomials are the \"probabilists'\" version of Hermite polynomials.\nKey mathematical properties:\n1. He₀(x) = 1, He₁(x) = x\n2. Recurrence: Heₙ₊₁(x) = x * Heₙ(x) - n * Heₙ₋₁(x)\n3. Parity: He_n(-x) = (-1)^n He_n(x)\n4. Orthogonality with respect to Gaussian weight e^(-x²/2)\n\n/* Structure representing a HermiteE polynomial with coefficients and domain/window mapping.\n   HermiteE polynomials are the \"probabilists'\" version of Hermite polynomials.\n   They satisfy the recurrence relation:\n   He₀(x) = 1\n   He₁(x) = x  \n   Heₙ₊₁(x) = x * Heₙ(x) - n * Heₙ₋₁(x)\n\n   The coefficients represent the expansion: ∑ᵢ cᵢ * Heᵢ(x)\n*/\n\n/* Coefficients of the HermiteE polynomial in increasing degree order */\n\n/* Domain interval [domain_min, domain_max] */\n\n/* Domain interval upper bound */\n\n/* Window interval [window_min, window_max] */\n\n/* Window interval upper bound */\n\n/* Coefficients are preserved exactly */\n\n/* Default domain is [-1, 1] */\n\n/* Default window is [-1, 1] */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nstruct HermiteEPoly {\n\n    coef: Vec<f32>,\n\n    domain_min: f32,\n\n    domain_max: f32,\n\n    window_min: f32,\n\n    window_max: f32,\n}", "vc-helpers": "", "vc-spec": "fn hermite_e(coef: Vec<f32>) -> (result: HermiteEPoly)\n    ensures\n\n        result.coef.len() == coef.len(),\n        forall|i: int| 0 <= i < coef.len() ==> result.coef[i] == coef[i],\n\n        result.domain_min == -1.0f32,\n        result.domain_max == 1.0f32,\n\n        result.window_min == -1.0f32,\n        result.window_max == 1.0f32,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_hermite_e_hermeadd", "vc-description": "Add one Hermite series to another. Component-wise addition of polynomial coefficients.\n\nSpecification: hermeadd performs component-wise addition of Hermite polynomial coefficients.\nThe result has the length of the longer input vector. Elements are added where both vectors\nhave coefficients, and remaining coefficients from the longer vector are preserved.\n\nThis models the mathematical property that polynomial addition is component-wise:\n(a₀ + a₁x + a₂x² + ...) + (b₀ + b₁x + b₂x² + ...) = (a₀+b₀) + (a₁+b₁)x + (a₂+b₂)x² + ...\n\nAdditional mathematical properties:\n- Commutativity: hermeadd c1 c2 = hermeadd c2 c1\n- Associativity: hermeadd (hermeadd c1 c2) c3 = hermeadd c1 (hermeadd c2 c3)\n- Zero identity: hermeadd c (zero vector) = c (extended appropriately)\n- Preservation of polynomial structure: addition preserves Hermite polynomial properties", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermeadd(c1: Vec<i32>, c2: Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        result.len() == if c1.len() >= c2.len() { c1.len() } else { c2.len() },\n        forall|i: int| 0 <= i < result.len() ==> {\n            let coeff1 = if i < c1.len() { c1[i] } else { 0 };\n            let coeff2 = if i < c2.len() { c2[i] } else { 0 };\n            #[trigger] result[i] == coeff1 + coeff2\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_hermite_e_hermeder", "vc-description": "Differentiate a Hermite_e series by taking the derivative of coefficients.\nTakes coefficients from low to high degree and returns differentiated coefficients.\n\nSpecification: hermeder correctly differentiates Hermite_e series coefficients.\nThe result has degree reduced by 1, and each coefficient is multiplied by its index\nand scaled by scl^m. For a single differentiation (m=1), the coefficient of degree k\nbecomes k * scl * original_coefficient.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermeder(c: Vec<f64>, m: usize, scl: f64) -> (result: Vec<f64>)\n    requires \n        c.len() > 0,\n        m > 0,\n        scl != 0.0,\n    ensures \n        result.len() == c.len() - 1,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_hermite_e_hermefit", "vc-description": "Least squares fit of Hermite series to data.\nReturns the coefficients of a HermiteE series of degree `deg` that is\nthe least squares fit to the data values `y` given at points `x`.\n\n/* Coefficients are valid - basic sanity check */\n\n/* Least squares property: the result minimizes sum of squared residuals */\n\n/* When deg+1 == data points, polynomial passes through all points exactly */\n\n/* Orthogonality condition: residuals are orthogonal to basis functions */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn hermite_e(n: nat, x: int) -> int\n    decreases n\n{\n    if n == 0 {\n        1\n    } else if n == 1 {\n        x  \n    } else {\n        let n_minus_1 = (n - 1) as nat;\n        let n_minus_2 = (n - 2) as nat;\n        x * hermite_e(n_minus_1, x) - ((n - 1) as int) * hermite_e(n_minus_2, x)\n    }\n}\n\nspec fn sum_hermite_series(coeffs: Seq<int>, x: int, deg: nat) -> int\n    decreases deg\n{\n    if coeffs.len() == 0 || deg >= coeffs.len() {\n        0\n    } else if deg == 0 {\n        coeffs[0] * hermite_e(0nat, x)\n    } else {\n        let prev_deg = (deg - 1) as nat;\n        coeffs[deg as int] * hermite_e(deg, x) + sum_hermite_series(coeffs, x, prev_deg)\n    }\n}\n\nspec fn sum_squared_residuals_rec(x: Seq<int>, y: Seq<int>, coeffs: Seq<int>, n: nat) -> int\n    decreases n\n{\n    if n == 0 || n > x.len() || n > y.len() || coeffs.len() == 0 {\n        0\n    } else {\n        let i_nat = (n - 1) as nat;\n        let i = i_nat as int;\n        if i < 0 || i >= x.len() || i >= y.len() {\n            0\n        } else {\n            let xi = x[i];\n            let yi = y[i];\n            let deg_nat = if coeffs.len() > 0 { (coeffs.len() - 1) as nat } else { 0nat };\n            let predicted = sum_hermite_series(coeffs, xi, deg_nat);\n            let residual = yi - predicted;\n            sum_squared_residuals_rec(x, y, coeffs, i_nat) + residual * residual\n        }\n    }\n}", "vc-helpers": "", "vc-spec": "fn hermefit(x: Vec<i32>, y: Vec<i32>, deg: usize) -> (result: Vec<i32>)\n    requires \n        x.len() == y.len(),\n        deg + 1 <= x.len(),\n        x.len() > 0,\n    ensures \n        result.len() == deg + 1,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_hermite_e_hermefromroots", "vc-description": "Generate a HermiteE series with given roots.\n\nReturns the coefficients of the polynomial p(x) = (x - r₀) * (x - r₁) * ... * (x - rₙ₋₁)\nin HermiteE form, where rᵢ are the roots specified in the input vector.\n\nThe output coefficients c satisfy: p(x) = c₀ + c₁ * He₁(x) + ... + cₙ * Heₙ(x)\nwhere Heₙ(x) is the n-th probabilist's Hermite polynomial (HermiteE).\n\nThis function converts from the standard polynomial representation with given roots\nto the HermiteE polynomial basis representation.\n\nSpecification: hermefromroots generates HermiteE coefficients such that:\n1. The output has exactly n+1 coefficients where n is the number of roots\n2. The polynomial represented by these coefficients has the given roots\n3. When evaluated at any root rᵢ using HermiteE basis, the result is zero\n4. The highest degree coefficient is non-zero (ensuring correct degree)\n5. The polynomial satisfies the fundamental property p(x) = (x - r₀) * ... * (x - rₙ₋₁)\n\n/* Evaluate the k-th probabilist's Hermite polynomial (HermiteE) at x */\n\n/* Evaluate a polynomial in HermiteE basis at point x given coefficients */\n\n/* Product form helper: (x - r₀) * (x - r₁) * ... * (x - rᵢ₋₁) */\n\n/* Empty roots give the constant polynomial 1 */\n\n/* The polynomial degree matches the number of roots (leading coefficient is non-zero) */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn eval_hermite_e(k: nat, x: int) -> int \n    decreases k\n{\n    if k == 0 {\n        1\n    } else if k == 1 {\n        x\n    } else {\n        x * eval_hermite_e((k - 1) as nat, x) - (k - 1) as int * eval_hermite_e((k - 2) as nat, x)\n    }\n}\n\nspec fn eval_hermite_e_poly(coeffs: Seq<int>, x: int) -> int \n    decreases coeffs.len()\n{\n    if coeffs.len() == 0 {\n        0\n    } else {\n        coeffs[0] * eval_hermite_e(0, x) + eval_hermite_e_poly(coeffs.skip(1), x)\n    }\n}\n\nspec fn product_form(roots: Seq<int>, x: int, i: nat) -> int \n    decreases i\n{\n    if i == 0 {\n        1\n    } else {\n        product_form(roots, x, (i - 1) as nat) * (x - roots[(i - 1) as int])\n    }\n}", "vc-helpers": "", "vc-spec": "fn hermefromroots(roots: Vec<f64>) -> (coeffs: Vec<f64>)\n    ensures\n        coeffs.len() == roots.len() + 1,\n\n        (roots.len() == 0 ==> coeffs.len() == 1),\n\n        (roots.len() > 0 ==> coeffs.len() == roots.len() + 1),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_hermite_e_hermegrid2d", "vc-description": "numpy.polynomial.hermite_e.hermegrid2d: Evaluate a 2-D HermiteE series on the Cartesian product of x and y.\n\nThis function evaluates a 2-dimensional HermiteE polynomial series\non the Cartesian product of coordinate vectors x and y.\n\nThe evaluation follows the mathematical formula:\np(a,b) = sum_{i,j} c[i,j] * He_i(a) * He_j(b)\n\nwhere He_i is the i-th probabilist's Hermite polynomial (HermiteE),\nand the points (a,b) are formed by taking all combinations of\nelements from x and y.\n\nThe result is a matrix where result[i,j] contains the polynomial\nvalue at the point (x[i], y[j]).\n\nSpecification: hermegrid2d evaluates a 2D HermiteE polynomial series \non the Cartesian product of x and y coordinates.\n\nThe function computes p(a,b) = sum_{i,j} c[i,j] * He_i(a) * He_j(b)\nwhere He_i is the i-th probabilist's Hermite polynomial.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermegrid2d(x: Vec<f32>, y: Vec<f32>, c: Vec<Vec<f32>>) -> (result: Vec<Vec<f32>>)\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == y.len(),\n        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result[i].len() ==> (\n            (c.len() == 0 || (exists|k: int| 0 <= k < c.len() && c[k].len() == 0) ==> result[i][j] == 0.0f32)\n        ),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_hermite_e_hermeint", "vc-description": "Integrate a Hermite_e series.\n\nIntegrate a Hermite_e series coefficients vector m times with scaling and integration constants.\n\nSpecification: hermeint integrates Hermite_e series coefficients preserving mathematical properties.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermeint(c: Vec<f64>, m: usize, k: Vec<f64>, lbnd: f64, scl: f64) -> (result: Vec<f64>)\n    requires \n        scl != 0.0,\n        k.len() == m,\n    ensures\n        result.len() == c.len() + m,\n        scl != 0.0,\n        forall|step: int| 0 <= step < m ==> exists|contrib: f64| contrib == k[step],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_hermite_e_hermeline", "vc-description": "Hermite series whose graph is a straight line.\nReturns the Hermite series coefficients representing the linear function off + scl*x.\nFor non-zero scale, returns [off, scl]. For zero scale, returns [off].", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermeline(off: f64, scl: f64) -> (coeffs: Vec<f64>)\n    ensures\n        coeffs.len() == 2,\n        coeffs[0] == off,\n        (scl == 0.0 ==> coeffs[1] == 0.0),\n        (scl != 0.0 ==> coeffs[1] == scl)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_hermite_e_hermemul", "vc-description": "Multiply one Hermite series by another. Returns the product of two Hermite polynomials \nrepresented as coefficient vectors. The multiplication involves reprojection onto \nthe Hermite polynomial basis set.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermemul(c1: Vec<f64>, c2: Vec<f64>) -> (result: Vec<f64>)\n    requires \n        c1.len() > 0,\n        c2.len() > 0,\n    ensures\n        result.len() == c1.len() + c2.len() - 1,\n        (forall|i: int| 0 <= i < c1.len() ==> c1[i] == 0.0) || \n        (forall|j: int| 0 <= j < c2.len() ==> c2[j] == 0.0) \n        ==> (forall|k: int| 0 <= k < result.len() ==> result[k] == 0.0)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_hermite_e_hermemulx", "vc-description": "Multiply a Hermite series by x using the recursion relationship for Hermite polynomials.\nThe result has one more coefficient than the input, implementing the transformation\nbased on the Hermite polynomial recursion: xP_i(x) = (P_{i + 1}(x) + iP_{i - 1}(x))", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermemulx(c: Vec<f64>) -> (result: Vec<f64>)\n    requires c.len() >= 0,\n    ensures\n        result.len() == c.len() + 1,\n        result[0] == 0.0,\n        forall|i: int| 1 <= i < c.len() ==> result[i + 1] == c[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_hermite_e_hermepow", "vc-description": "Raise a Hermite series to a power. Computes the Hermite polynomial coefficients\nfor the series c raised to the given power, using repeated multiplication.\n\nSpecification: hermepow raises a Hermite polynomial series to a power.\nGiven coefficients c = [c₀, c₁, ..., cₙ₋₁] representing the Hermite series\nP₀(x)⋅c₀ + P₁(x)⋅c₁ + ... + Pₙ₋₁(x)⋅cₙ₋₁, this function computes the \ncoefficients of the series raised to the given power.\n\nMathematical properties:\n- Power 0: Returns [1.0] (multiplicative identity for Hermite polynomials)\n- Power 1: Returns the original coefficients unchanged (preserves the polynomial)\n- Power ≥ 2: Uses repeated multiplication following Hermite polynomial algebra\n- Result degree: The degree of the result polynomial is (n-1) * pow\n- Respects maxpower limit: pow must not exceed maxpower to prevent excessive growth\n\nThis implements the mathematical operation (P(x))^pow where P(x) is the Hermite polynomial\nrepresented by the input coefficients, and the result gives the coefficients of the\npolynomial raised to the given power in the Hermite basis.\n\n/* Base cases for polynomial exponentiation */\n\n/* General case: polynomial raised to power follows degree multiplication */\n\n/* For non-empty input, the result maintains polynomial structure */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermepow(c: Vec<f64>, pow: usize, maxpower: usize) -> (result: Vec<f64>)\n    requires \n        pow <= maxpower,\n        maxpower <= 16,\n        c.len() > 0,\n    ensures\n\n        pow == 0 ==> result.len() == 1 && result[0] == 1.0 && \n            (forall|i: int| 1 <= i < result.len() ==> result[i] == 0.0),\n        pow == 1 ==> result.len() == c.len() &&\n            (forall|i: int| 0 <= i < c.len() ==> result[i] == c[i]),\n\n        pow >= 1 ==> result.len() == 1 + (c.len() - 1) * pow,\n\n        pow >= 1 && c.len() > 0 ==> exists|highest_coeff: f64| \n            result[result.len() - 1] == highest_coeff,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_hermite_e_hermeval2d", "vc-description": "Evaluate a 2-D HermiteE series at points (x, y).\n\nThis function computes the bivariate HermiteE polynomial:\np(x,y) = ∑_{i,j} c_{i,j} * He_i(x) * He_j(y)\n\nwhere He_i and He_j are the HermiteE basis polynomials.\n\nThis function implements the mathematical formula:\np(x,y) = ∑_{i,j} c_{i,j} * He_i(x) * He_j(y)\n\nKey properties:\n1. Bivariate polynomial evaluation using HermiteE basis\n2. Mathematical correctness and linearity properties\n3. Point-wise evaluation for corresponding (x,y) pairs", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn hermite_e_basis(n: nat, x: int) -> int\n    decreases n\n{\n    if n == 0 {\n        1\n    } else if n == 1 {\n        x\n    } else {\n        x * hermite_e_basis((n-1) as nat, x) - (n-1) as int * hermite_e_basis((n-2) as nat, x)\n    }\n}", "vc-helpers": "", "vc-spec": "fn hermeval2d(x: Vec<f32>, y: Vec<f32>, c: Vec<Vec<f32>>) -> (result: Vec<f32>)\n    requires \n        x.len() == y.len(),\n        x.len() > 0,\n        c.len() > 0,\n        forall|i: int| 0 <= i < c.len() ==> c[i].len() > 0,\n    ensures \n        result.len() == x.len(),\n        forall|k: int| 0 <= k < result.len() ==> exists|hermite_basis: FnSpec(nat, int) -> int|\n            (forall|t: int| hermite_basis(0nat, t) == 1) &&\n            (c.len() > 0 ==> forall|t: int| hermite_basis(1nat, t) == t) &&\n            (forall|i: nat, t: int| i + 1 < c.len() ==> \n                hermite_basis(i + 2, t) == t * hermite_basis(i + 1, t) - (i as int + 1) * hermite_basis(i, t)),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_hermite_e_hermevander", "vc-description": "numpy.polynomial.hermite_e.hermevander: Pseudo-Vandermonde matrix of given degree.\n\nReturns the pseudo-Vandermonde matrix of degree `deg` and sample points\n`x`. The pseudo-Vandermonde matrix is defined by\n\n.. math:: V[..., i] = He_i(x),\n\nwhere ``0 <= i <= deg``. The leading indices of `V` index the elements of\n`x` and the last index is the degree of the HermiteE polynomial.\n\nIf `c` is a 1-D array of coefficients of length ``n + 1`` and `V` is the\narray ``V = hermevander(x, n)``, then ``np.dot(V, c)`` and\n``hermeval(x, c)`` are the same up to roundoff. This equivalence is\nuseful both for least squares fitting and for the evaluation of a large\nnumber of HermiteE series of the same degree and sample points.\n\nParameters\n----------\nx : array_like\n    Array of points. The dtype is converted to float64 or complex128\n    depending on whether any of the elements are complex. If `x` is\n    scalar it is converted to a 1-D array.\ndeg : int\n    Degree of the resulting matrix.\n\nReturns\n-------\nvander : ndarray\n    The pseudo-Vandermonde matrix. The shape of the returned matrix is\n    ``x.shape + (deg + 1,)``, where The last index is the degree of the\n    corresponding HermiteE polynomial.  The dtype will be the same as\n    the converted `x`.\n\nSpecification: hermevander returns a pseudo-Vandermonde matrix where each row\ncorresponds to a point in x, and each column corresponds to a HermiteE polynomial\nof degree 0 through deg evaluated at that point.\n\nThe HermiteE polynomials (also called probabilist's Hermite polynomials) are\ndefined by the recurrence relation:\n- He_0(x) = 1\n- He_1(x) = x  \n- He_n(x) = x * He_{n-1}(x) - (n-1) * He_{n-2}(x)\n\nPrecondition: True (no special preconditions needed)\nPostcondition: \n1. The matrix has shape (n, deg + 1)\n2. For each row i and column j, V[i][j] = He_j(x[i])\n3. First column is all ones (He_0(x) = 1)\n4. Second column equals x (He_1(x) = x) when deg > 0\n5. Subsequent columns follow the HermiteE recurrence relation", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermevander(x: Vec<f64>, deg: usize) -> (result: Vec<Vec<f64>>)\n    requires deg >= 0,\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == deg + 1,\n        forall|i: int| 0 <= i < result.len() ==> result[i][0] == 1.0,\n        deg > 0 ==> forall|i: int| 0 <= i < result.len() ==> result[i][1] == x[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_hermite_e_hermevander2d", "vc-description": "Pseudo-Vandermonde matrix of given degrees for 2D HermiteE polynomials.\n\nReturns the pseudo-Vandermonde matrix of degrees (x_deg, y_deg) and sample\npoints (x, y). The matrix is defined by:\nV[..., (y_deg + 1)*i + j] = He_i(x) * He_j(y)\nwhere 0 <= i <= x_deg and 0 <= j <= y_deg.\n\nThis function creates a matrix where each row corresponds to a point (x[k], y[k]) and\neach column corresponds to a basis function He_i(x) * He_j(y).\n\nMathematical properties include matrix structure, basis ordering, equivalence with\npolynomial evaluation, orthogonality properties from HermiteE basis functions,\nand polynomial fitting capability for least squares.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn hermite_basis(k: nat, t: int) -> int\n    decreases k\n{\n    if k == 0 {\n        1\n    } else if k == 1 {\n        t\n    } else {\n        t * hermite_basis((k - 1) as nat, t) - (k - 1) as int * hermite_basis((k - 2) as nat, t)\n    }\n}\n\nfn hermevander2d(x: Vec<i32>, y: Vec<i32>, x_deg: usize, y_deg: usize) -> (result: Vec<Vec<i32>>)\n    requires \n        x.len() == y.len(),\n        x.len() > 0,\n    ensures \n        result.len() == x.len(),\n        forall|point_idx: int| 0 <= point_idx < result.len() ==> \n            result[point_idx].len() == (x_deg + 1) * (y_deg + 1),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_hermite_e_hermevander3d", "vc-description": "numpy.polynomial.hermite_e.hermevander3d: Pseudo-Vandermonde matrix of given degrees.\n\nReturns the pseudo-Vandermonde matrix of degrees `deg` and sample\npoints `(x, y, z)`. If `l`, `m`, `n` are the given degrees in `x`, `y`, `z`,\nthen the pseudo-Vandermonde matrix is defined by\n\n.. math:: V[..., (m+1)(n+1)i + (n+1)j + k] = He_i(x)*He_j(y)*He_k(z),\n\nwhere `0 <= i <= l`, `0 <= j <= m`, and `0 <= k <= n`. The leading\nindices of `V` index the points `(x, y, z)` and the last index encodes\nthe degrees of the HermiteE polynomials.\n\nThe HermiteE polynomials (also called probabilist's Hermite polynomials) are\ndefined by the recurrence relation:\n- He_0(t) = 1\n- He_1(t) = t  \n- He_n(t) = t * He_{n-1}(t) - (n-1) * He_{n-2}(t)\n\nParameters\n----------\nx, y, z : Vector Float n\n    Arrays of point coordinates, all of the same shape.\ndeg : Vector Nat 3\n    Vector of maximum degrees of the form [x_deg, y_deg, z_deg].\n\nReturns\n-------\nvander3d : Vector (Vector Float order) n\n    The pseudo-Vandermonde matrix where order = (deg[0]+1)*(deg[1]+1)*(deg[2]+1).\n\nSpecification: hermevander3d returns a 3D pseudo-Vandermonde matrix where each row\ncorresponds to a point (x[i], y[i], z[i]), and each column corresponds to a product\nof HermiteE polynomials He_i(x)*He_j(y)*He_k(z) for various degrees.\n\n// Just return 1.0 as a placeholder to avoid floating point ops", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn hermite_poly(k: int, t: f64) -> f64\n    decreases k\n{\n    if k <= 0 {\n        1.0\n    } else if k == 1 {\n        t\n    } else {\n\n        1.0\n    }\n}\n\nfn hermevander3d(x: Vec<f64>, y: Vec<f64>, z: Vec<f64>, deg: Vec<int>) -> (result: Vec<Vec<f64>>)\n    requires \n        x.len() == y.len(),\n        y.len() == z.len(),\n        deg.len() == 3,\n        deg[0] >= 0 && deg[1] >= 0 && deg[2] >= 0,\n    ensures\n        result.len() == x.len(),\n        forall |p: int| 0 <= p < result.len() ==> {\n            let x_deg = deg[0];\n            let y_deg = deg[1]; \n            let z_deg = deg[2];\n            let order = (x_deg + 1) * (y_deg + 1) * (z_deg + 1);\n            &&& #[trigger] result[p].len() == order\n            &&& (order > 0 ==> result[p][0] == 1.0)\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_hermite_hermder", "vc-description": "Differentiate a Hermite series.\nReturns the Hermite series coefficients differentiated `m` times.\nAt each iteration the result is multiplied by `scl` (scaling factor).\nThe coefficients are from low to high degree.\n\nSpecification: hermder differentiates Hermite series coefficients according to\nthe Hermite polynomial derivative rule: d/dx H_n(x) = 2n * H_{n-1}(x).\nThe result has degree reduced by m (or becomes zero if m >= n).\nEach differentiation multiplies by the scaling factor scl.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermder(c: Vec<i32>, m: usize, scl: i32) -> (result: Vec<i32>)\n    ensures\n        result.len() == if m >= c.len() { 0 } else { c.len() - m },\n        m >= c.len() ==> result.len() == 0,\n        m < c.len() ==> result.len() == c.len() - m,\n        (m == 1 && c.len() > 0) ==> (\n            forall|i: int| 0 <= i < result.len() ==> \n                result[i] == scl * (2 * ((i + 1) as i32)) * c[i + 1]\n        ),\n        (m == 2 && c.len() > 1) ==> (\n            forall|i: int| 0 <= i < result.len() ==>\n                result[i] == scl * scl * (2 * ((i + 2) as i32)) * (2 * ((i + 1) as i32)) * c[i + 2]\n        ),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_hermite_hermfit", "vc-description": "Least squares fit of Hermite series to data. Returns coefficients of a Hermite polynomial that best fits the given data points (x, y) with degree deg.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermfit(x: Vec<f64>, y: Vec<f64>, deg: usize) -> (result: Vec<f64>)\n    requires \n        x.len() > 0,\n        x.len() == y.len(),\n        deg < x.len(),\n    ensures\n        result.len() == deg + 1,\n        deg + 1 > 0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_hermite_hermfromroots", "vc-description": "Generate a Hermite series with given roots.\n\nReturns the coefficients of the polynomial p(x) = (x - r₀) * (x - r₁) * ... * (x - rₙ)\nin Hermite form. If a zero has multiplicity n, it must appear n times in the roots vector.\n\nThe resulting polynomial is expressed as: p(x) = c₀ + c₁ * H₁(x) + ... + cₙ * Hₙ(x)\nwhere Hᵢ(x) are Hermite polynomials.\n\n/* Abstract property: the Hermite polynomial with these coefficients\n               evaluates to zero at each root */\n\n/* Placeholder for: hermval(roots[i], coef) = 0.0 */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermfromroots(roots: Vec<f64>) -> (coef: Vec<f64>)\n    ensures\n        coef.len() == roots.len() + 1,\n        roots.len() > 0 ==> coef[roots.len() as int] != 0.0,\n        forall|i: int| 0 <= i < roots.len() ==> {\n\n            true\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_hermite_hermint", "vc-description": "Integrate a Hermite series.\n\nReturns the Hermite series coefficients integrated `m` times from `lbnd`.\nAt each iteration the resulting series is multiplied by `scl` and an\nintegration constant from `k` is added.\n\nSpecification: hermint integrates Hermite series coefficients.\n\nThe specification captures:\n1. The output vector has size n + m (m additional coefficients from integration)\n2. Each integration adds one coefficient to the series\n3. The integration follows Hermite polynomial integration rules\n4. Integration constants from k are applied at each integration step\n5. Results are scaled by scl at each step\n\nFor Hermite polynomials, the integration rule is:\n- ∫ H_n(x) dx = H_{n+1}(x)/(2(n+1)) + constant\n\nMathematical properties:\n- The first coefficient of the result incorporates the integration constant to ensure\n  the integral evaluates to the appropriate value at lbnd\n- For coefficient c[i] representing H_i, integration contributes c[i]/(2*(i+1)) to H_{i+1}\n- The scaling factor scl is applied after each integration step", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermint(c: Vec<f32>, m: u32, k: Vec<f32>, lbnd: f32, scl: f32) -> (result: Vec<f32>)\n    requires \n        m > 0,\n        k.len() == m,\n        c.len() > 0,\n    ensures \n        result.len() == c.len() + m,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_hermite_hermmul", "vc-description": "numpy.polynomial.hermite.hermmul: Multiply one Hermite series by another.\n\nReturns the product of two Hermite series c1 * c2. The arguments\nare sequences of coefficients, from lowest order term to highest,\ne.g., [1,2,3] represents the series P_0 + 2*P_1 + 3*P_2 where P_i\nis the i-th Hermite polynomial.\n\nThe product of two Hermite series requires reprojection onto the\nHermite basis, which uses the recurrence relation for Hermite\npolynomials.\n\nFor non-empty inputs of length m and n, the result has length m + n - 1.\nFor empty inputs, returns a single zero coefficient.\n\nSpecification: hermmul returns the coefficients of the product of two\nHermite series.\n\nThe key mathematical properties:\n1. Empty input handling: If either input is empty, returns [0]\n2. Degree property: For non-empty inputs of degree m-1 and n-1,\n   the product has degree (m-1) + (n-1) = m + n - 2, requiring m + n - 1 coefficients\n3. Multiplication by constant: When one series has only one coefficient (constant polynomial),\n   the result is element-wise scaling\n4. Commutativity: hermmul c1 c2 = hermmul c2 c1 (up to floating point precision)\n5. The general multiplication follows Hermite polynomial recurrence relations\n\nPrecondition: True (works for all valid inputs)\nPostcondition: Captures empty input behavior, constant multiplication, and size properties\n\n/* Empty input handling */\n\n/* Non-empty inputs have correct output size */\n\n/* Multiplication by constant polynomial (degree 0) */\n\n/* Zero polynomial property */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermmul(c1: Vec<i32>, c2: Vec<i32>) -> (result: Vec<i32>)\n    ensures\n\n        (c1.len() == 0 || c2.len() == 0) ==> (result.len() == 1 && result[0] == 0),\n\n        (c1.len() > 0 && c2.len() > 0) ==> result.len() == c1.len() + c2.len() - 1,\n\n        (c2.len() == 1 && c1.len() > 0) ==>\n            forall|i: int| 0 <= i < c1.len() ==> result[i] == c1[i] * c2[0],\n        (c1.len() == 1 && c2.len() > 0) ==>\n            forall|i: int| 0 <= i < c2.len() ==> result[i] == c2[i] * c1[0],\n\n        ((forall|i: int| 0 <= i < c1.len() ==> c1[i] == 0) || \n         (forall|j: int| 0 <= j < c2.len() ==> c2[j] == 0)) ==>\n            forall|k: int| 0 <= k < result.len() ==> result[k] == 0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_hermite_hermpow", "vc-description": "Raise a Hermite polynomial series to a power.\nGiven coefficients `c` representing a Hermite series (ordered from low to high degree),\nreturns the coefficients of the series raised to the power `pow`.\nThe `maxpower` parameter limits the maximum degree of the result.\n\nSpecification: hermpow raises a Hermite series to a power by repeated multiplication.\nKey properties:\n1. For pow = 0, the result is the constant polynomial [1]\n2. For pow = 1, the result equals the input polynomial\n3. For pow > 1, the result is obtained by repeated Hermite multiplication\n4. The result degree is bounded by min(n + (n-1)*pow - 1, maxpower)\n5. The operation respects the algebraic properties of polynomial exponentiation\n\n/* Sanity check: result has bounded size */\n\n/* Property 1: Power of 0 gives constant polynomial [1] */\n\n/* Property 2: Power of 1 preserves the polynomial (up to size constraints) */\n\n/* Property 3: The result represents c^pow in the Hermite polynomial basis */\n\n/* For non-zero inputs with pow > 0, result is non-trivial */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermpow(c: Vec<f64>, pow: usize, maxpower: usize) -> (result: Vec<f64>)\n    requires \n        c.len() > 0,\n        maxpower >= 0,\n    ensures\n\n        result.len() <= maxpower + 1,\n        result.len() == if c.len() + (c.len() - 1) * pow <= maxpower + 1 {\n            c.len() + (c.len() - 1) * pow\n        } else {\n            maxpower + 1\n        },\n\n        pow == 0 ==> result.len() == 1 && result[0] == 1.0,\n\n        (pow == 1 && c.len() <= maxpower + 1) ==> (\n            result.len() == c.len() &&\n            forall|i: int| 0 <= i < c.len() ==> result[i] == c[i]\n        ),\n\n        ((exists|i: int| 0 <= i < c.len() && c[i] != 0.0) && pow > 0) ==> \n            exists|j: int| 0 <= j < result.len() && result[j] != 0.0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_hermite_hermval2d", "vc-description": "Evaluate a 2-D Hermite series at points (x, y).\n\nGiven a 2D coefficient matrix c where c[i,j] is the coefficient for H_i(x) * H_j(y),\nevaluates the sum: ∑_{i,j} c_{i,j} * H_i(x) * H_j(y)\nwhere H_i and H_j are Hermite polynomials.\n\nThe x and y vectors must have the same length, and the function evaluates\nthe 2D polynomial at each pair of corresponding points (x[k], y[k]).\n\n/* Empty coefficient cases evaluate to zero */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermval2d(x: Vec<f32>, y: Vec<f32>, c: Vec<Vec<f32>>) -> (result: Vec<f32>)\n    requires \n        x.len() == y.len(),\n    ensures \n        result.len() == x.len(),\n\n        c.len() == 0 ==> forall|k: int| 0 <= k < result.len() ==> result[k] == 0.0f32,\n        c.len() > 0 && c[0].len() == 0 ==> forall|k: int| 0 <= k < result.len() ==> result[k] == 0.0f32,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_hermite_hermvander2d", "vc-description": "Pseudo-Vandermonde matrix of given degrees for 2D Hermite polynomials.\n\nReturns a matrix where each row corresponds to a sample point (x[i], y[i]),\nand columns represent products of Hermite polynomials H_i(x) * H_j(y).\nThe column at index (ydeg + 1)*i + j contains H_i(x) * H_j(y).\n\nThis creates the design matrix for fitting 2D Hermite polynomial surfaces,\nwhere coefficients are arranged in row-major order: c_00, c_01, ..., c_10, c_11, ...\n\nSpecification: hermvander2d creates a 2D Vandermonde matrix where each element\nV[k][(ydeg + 1)*i + j] equals H_i(x[k]) * H_j(y[k]), where H_i denotes the \ni-th Hermite polynomial. The Hermite polynomials follow the recurrence:\nH_0(t) = 1, H_1(t) = 2t, H_n(t) = 2t * H_{n-1}(t) - 2(n-1) * H_{n-2}(t)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn hermite_polynomial(n: nat, t: int) -> int\n    decreases n\n{\n    if n == 0 {\n        1\n    } else if n == 1 {\n        2 * t\n    } else {\n        2 * t * hermite_polynomial((n - 1) as nat, t) - 2 * (n - 1) * hermite_polynomial((n - 2) as nat, t)\n    }\n}\n\nfn hermvander2d(x: Vec<i32>, y: Vec<i32>, xdeg: usize, ydeg: usize) -> (result: Vec<Vec<i32>>)\n    requires x.len() == y.len(),\n    ensures \n        result.len() == x.len(),\n        forall|k: int| 0 <= k < result.len() ==> #[trigger] result[k].len() == (xdeg + 1) * (ydeg + 1),\n        forall|k: int| 0 <= k < result.len() ==> #[trigger] result[k][0] == 1", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_hermite_hermweight", "vc-description": "Weight function of the Hermite polynomials.\nComputes exp(-x²) for each element in the input vector.\n\nThe weight function is exp(-x^2) and the interval of\nintegration is [-inf, inf]. The Hermite polynomials are\northogonal, but not normalized, with respect to this weight function.\n\nParameters\n----------\nx : array_like\n   Values at which the weight function will be computed.\n\nReturns\n-------\nw : ndarray\n   The weight function at x.\n\n/* Each output element equals exp(-x²) of the corresponding input */\n\n/* All output values are positive (since exp is always positive) */\n\n/* The weight function achieves its maximum value of 1 at x=0 */\n\n/* The function decreases as |x| increases */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermweight(x: Vec<f32>) -> (w: Vec<f32>)\n    requires x.len() > 0,\n    ensures\n        w.len() == x.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_hermite_poly2herm", "vc-description": "numpy.polynomial.hermite.poly2herm: Convert a polynomial to a Hermite series.\n\nConvert an array representing the coefficients of a polynomial (relative\nto the \"standard\" basis) ordered from lowest degree to highest, to an\narray of the coefficients of the equivalent Hermite series, ordered\nfrom lowest to highest degree.\n\nThe conversion transforms between different polynomial bases. The standard\npolynomial basis consists of monomials {1, x, x², x³, ...} while the\nHermite polynomial basis consists of Hermite polynomials {H₀(x), H₁(x), H₂(x), ...}.\n\nThe algorithm uses Hermite polynomial operations (multiplication by x and addition)\nto build up the result iteratively from the highest degree coefficient down.\n\nSpecification: poly2herm converts polynomial coefficients to Hermite series coefficients\n\nThe specification ensures:\n1. The output has the same dimension as the input\n2. The conversion preserves the polynomial function when evaluated using respective bases\n3. For the zero polynomial (all coefficients zero), the result is also zero\n4. The conversion is linear: poly2herm(a*p + b*q) = a*poly2herm(p) + b*poly2herm(q)\n\nAdditionally, for specific test cases:\n- Converting [0, 1, 2, 3] should yield [1, 2.75, 0.5, 0.375]\n- Converting a constant polynomial [c] should yield [c]\n\n/* Zero polynomial maps to zero */\n\n/* Constant polynomial preservation (when n >= 1) */\n\n/* Specific example from documentation (when applicable) */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn poly2herm(pol: Vec<f64>) -> (result: Vec<f64>)\n    ensures\n        result.len() == pol.len(),\n\n        (forall|i: int| 0 <= i < pol.len() ==> pol[i] == 0.0) ==> \n            (forall|i: int| 0 <= i < result.len() ==> result[i] == 0.0),\n\n        pol.len() > 0 ==> \n            (forall|i: int| 1 <= i < pol.len() ==> pol[i] == 0.0) ==>\n                result[0] == pol[0],\n\n        (pol.len() == 4 && pol[0] == 0.0 && pol[1] == 1.0 && \n         pol[2] == 2.0 && pol[3] == 3.0) ==>\n            (result[0] == 1.0 && result[1] == 2.75 && \n             result[2] == 0.5 && result[3] == 0.375)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_laguerre_Laguerre", "vc-description": "{\n  \"name\": \"numpy.polynomial.laguerre.Laguerre\",\n  \"category\": \"Laguerre polynomials\",\n  \"description\": \"A Laguerre series class.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.laguerre.Laguerre.html\",\n  \"doc\": \"A Laguerre series class.\\n\\n    The Laguerre class provides the standard Python numerical methods\\n    '+', '-', '*', '//', '%', 'divmod', '**', and '()' as well as the\\n    attributes and methods listed below.\\n\\n    Parameters\\n    ----------\\n    coef : array_like\\n        Laguerre coefficients in order of increasing degree, i.e,\\n        ``(1, 2, 3)`` gives ``1*L_0(x) + 2*L_1(X) + 3*L_2(x)``.\\n    domain : (2,) array_like, optional\\n        Domain to use. The interval ``[domain[0], domain[1]]`` is mapped\\n        to the interval ``[window[0], window[1]]`` by shifting and scaling.\\n        The default value is [0., 1.].\\n    window : (2,) array_like, optional\\n        Window, see `domain` for its use. The default value is [0., 1.].\\n    symbol : str, optional\\n        Symbol used to represent the independent variable in string\\n        representations of the polynomial expression, e.g. for printing.\\n        The symbol must be a valid Python identifier. Default value is 'x'.\\n\\n        .. versionadded:: 1.24\",\n  \"type\": \"class\"\n}\n\nConstructor for Laguerre series with default domain and window\n\nSpecification for Laguerre series construction and properties\n\n/* Helper function to evaluate a Laguerre polynomial at a given point */\n\n/* Domain mapping function for polynomial transformations */\n\n/* Helper function for individual Laguerre polynomial basis functions */\n\n/* A Laguerre series class representing a polynomial in the Laguerre basis.\n   This structure encapsulates Laguerre coefficients with domain and window information. */\n\n/* Laguerre coefficients in order of increasing degree */\n\n/* Domain interval [domain[0], domain[1]] for mapping */\n\n/* Window interval [window[0], window[1]] for mapping */\n\n/* The coefficients are preserved exactly */\n\n/* Default domain is [0, 1] */\n\n/* Default window is [0, 1] */\n\n/* The Laguerre polynomial can be evaluated at any point */\n\n/* Basic sanity check for coefficient preservation */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn evaluate_laguerre_polynomial<const N: usize>(coef: [f64; N], x: f64) -> f64;\n\nspec fn map_domain(domain: [f64; 2], window: [f64; 2], x: f64) -> f64;\n\nspec fn laguerre_polynomial_basis(n: nat, x: f64) -> f64;\n\nstruct Laguerre<const N: usize> {\n\n    coef: [f64; N],\n\n    domain: [f64; 2],\n\n    window: [f64; 2],\n}", "vc-helpers": "", "vc-spec": "fn make_laguerre<const N: usize>(coefficients: [f64; N]) -> (result: Laguerre<N>)\n    ensures\n\n        result.coef == coefficients,\n\n        result.domain[0] == 0.0 && result.domain[1] == 1.0,\n\n        result.window[0] == 0.0 && result.window[1] == 1.0,\n\n        forall|x: f64| {\n            let transformed_x = map_domain(result.domain, result.window, x);\n            exists|value: f64| value == evaluate_laguerre_polynomial(result.coef, transformed_x)\n        },\n\n        forall|i: int| 0 <= i < N ==> result.coef[i] == coefficients[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_laguerre_lag2poly", "vc-description": "Convert a Laguerre series to a polynomial.\nConvert an array representing the coefficients of a Laguerre series,\nordered from lowest degree to highest, to an array of the coefficients\nof the equivalent polynomial (relative to the \"standard\" basis).\n\nSpecification: lag2poly converts Laguerre series coefficients to standard polynomial coefficients.\nThe converted polynomial evaluates to the same values as the original Laguerre series.\n\n/* Helper function to evaluate a Laguerre polynomial at a given point */\n\n/* Helper function to evaluate a standard polynomial at a given point */\n\n/* The converted polynomial evaluates to the same values as the Laguerre series */\n\n/* Single coefficient case: lag2poly([a]) = [a] */\n\n/* The conversion preserves the polynomial degree */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn evaluate_laguerre_polynomial(c: Seq<f32>, x: f32) -> f32;\n\nspec fn evaluate_polynomial(coeffs: Seq<f32>, x: f32) -> f32;", "vc-helpers": "", "vc-spec": "fn lag2poly(c: Vec<f32>) -> (result: Vec<f32>)\n    requires c.len() > 0,\n    ensures\n        result.len() == c.len(),\n\n        forall|x: f32| evaluate_polynomial(result@, x) == evaluate_laguerre_polynomial(c@, x),\n\n        c.len() == 1 ==> result@ == c@,\n\n        c.len() > 0 ==> evaluate_polynomial(result@, 0.0) == evaluate_laguerre_polynomial(c@, 0.0),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_laguerre_lagadd", "vc-description": "Add one Laguerre series to another.\nReturns the sum of two Laguerre series c1 + c2. The arguments\nare sequences of coefficients ordered from lowest order term to highest.\n\nSpecification: lagadd performs component-wise addition of two Laguerre series coefficients.\nThe result length is the maximum of the input lengths, with shorter arrays padded with zeros.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn evaluate_laguerre_polynomial(coeffs: Seq<f32>, x: f32) -> f32\n{\n    arbitrary()\n}\n\nspec fn f32_add(a: f32, b: f32) -> f32\n{\n    arbitrary()\n}\n\nspec fn max_usize(a: usize, b: usize) -> usize\n{\n    if a >= b { a } else { b }\n}\n\nfn lagadd(c1: Vec<f32>, c2: Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() == max_usize(c1.len(), c2.len()),\n        forall|i: int| 0 <= i < result.len() ==> {\n            #[trigger] result[i] == f32_add(\n                if i < c1.len() { c1[i] } else { 0.0f32 },\n                if i < c2.len() { c2[i] } else { 0.0f32 }\n            )\n        },\n        (c1.len() > 0 || c2.len() > 0) ==> result.len() > 0", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_laguerre_lagcompanion", "vc-description": "Returns the companion matrix of Laguerre polynomial coefficients. The companion matrix is a square matrix of size (deg, deg) where deg = c.size - 1. For coefficients [c₀, c₁, ..., cₙ], the companion matrix has specific structure for Laguerre polynomials with diagonal elements 2*i + 1 and off-diagonal elements. Specification: lagcompanion returns the companion matrix of Laguerre polynomial coefficients. The companion matrix is symmetric for Laguerre polynomials and has dimension (deg, deg) where deg = c.size - 1. The matrix structure follows the Laguerre polynomial recurrence relation.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn lagcompanion(c: Vec<f64>) -> (result: Vec<Vec<f64>>)\n    requires \n        c.len() >= 2,\n    ensures \n        result@.len() == c@.len() - 1,\n        forall|i: int| 0 <= i < result@.len() ==> result@[i].len() == c@.len() - 1,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_laguerre_lagdiv", "vc-description": "Divides one Laguerre series by another, returning quotient and remainder.\nThe division is performed in the Laguerre polynomial basis.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn lagdiv(c1: Vec<f64>, c2: Vec<f64>) -> (result: (Vec<f64>, Vec<f64>))\n    requires \n        c1.len() > 0,\n        c2.len() > 0,\n        exists|i: int| 0 <= i < c2.len() && c2[i] != 0.0,\n    ensures\n        result.0.len() == c1.len(),\n        result.1.len() == c2.len(),\n        c2.len() > 0 ==> exists|highest_nonzero: int| \n            0 <= highest_nonzero < c2.len() &&\n            (forall|j: int| highest_nonzero < j < result.1.len() ==> result.1[j] == 0.0) &&\n            c2[highest_nonzero] != 0.0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_laguerre_laggrid2d", "vc-description": "numpy.polynomial.laguerre.laggrid2d: Evaluate a 2-D Laguerre series on the Cartesian product of x and y.\n\nThis function computes the values p(a,b) = ∑_{i,j} c_{i,j} * L_i(a) * L_j(b)\nwhere the points (a,b) consist of all pairs formed by taking a from x and b from y.\nThe resulting points form a grid with x in the first dimension and y in the second.\n\nThe coefficients c represent a 2D matrix where c[i,j] is the coefficient for\nthe term of multi-degree i,j in the Laguerre series expansion.\n\nSpecification: laggrid2d evaluates a 2D Laguerre series on the Cartesian product of x and y.\n\nThe function computes p(a,b) = ∑_{i,j} c_{i,j} * L_i(a) * L_j(b) for each point (a,b)\nin the Cartesian product of x and y.\n\nPrecondition: The coefficient matrix c must be non-empty (rows > 0 and cols > 0)\nPostcondition: The result is a grid where result[i][j] represents the evaluation\nof the Laguerre series at point (x[i], y[j]).\n\nMathematical properties:\n1. The result has shape (nx, ny) - same as the Cartesian product of x and y\n2. Each element result[i][j] is the sum over all coefficient terms c[k][l] * L_k(x[i]) * L_l(y[j])\n3. For constant coefficients (c[0][0] only), the result should be constant\n4. The function is linear in the coefficients", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn laggrid2d(x: Vec<f32>, y: Vec<f32>, c: Vec<Vec<f32>>) -> (result: Vec<Vec<f32>>)\n    requires \n        c.len() > 0,\n        forall|i: int| 0 <= i < c.len() ==> c[i].len() > 0,\n        forall|i: int, j: int| 0 <= i < c.len() && 0 <= j < c.len() ==> c[i].len() == c[j].len(),\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == y.len(),\n        forall|i: int, j: int| 0 <= i < x.len() && 0 <= j < y.len() ==> \n            exists|val: f32| result[i][j] == val,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_laguerre_laggrid3d", "vc-description": "Evaluate a 3-D Laguerre series on the Cartesian product of x, y, and z.\n\nThis function computes the values p(a,b,c) = ∑_{i,j,k} c_{i,j,k} * L_i(a) * L_j(b) * L_k(c)\nwhere the points (a,b,c) consist of all triples formed by taking a from x, b from y, and c from z.\nThe resulting points form a grid with x in the first dimension, y in the second, and z in the third.\n\nThe coefficients c represent a 3D tensor where c[i,j,k] is the coefficient for\nthe term of multi-degree i,j,k in the Laguerre series expansion.\n\nSpecification: laggrid3d evaluates a 3D Laguerre series on the Cartesian product of x, y, and z.\n\nThe function computes p(a,b,c) = ∑_{i,j,k} c_{i,j,k} * L_i(a) * L_j(b) * L_k(c) for each point (a,b,c)\nin the Cartesian product of x, y, and z.\n\nPrecondition: The coefficient tensor c must be non-empty (dim1 > 0, dim2 > 0, and dim3 > 0)\nPostcondition: The result is a 3D grid where result[i][j][k] represents the evaluation\nof the Laguerre series at point (x[i], y[j], z[k]).\n\nMathematical properties:\n1. The result has shape (nx, ny, nz) - same as the Cartesian product of x, y, and z\n2. Each element result[i][j][k] is the sum over all coefficient terms c[l][m][n] * L_l(x[i]) * L_m(y[j]) * L_n(z[k])\n3. For constant coefficients (c[0][0][0] only), the result should be constant\n4. The function is linear in the coefficients", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn laggrid3d(\n    x: Vec<f32>,\n    y: Vec<f32>, \n    z: Vec<f32>,\n    c: Vec<Vec<Vec<f32>>>\n) -> (result: Vec<Vec<Vec<f32>>>)\n    requires\n        c.len() > 0,\n        c.len() > 0 ==> c[0].len() > 0,\n        c.len() > 0 && c[0].len() > 0 ==> c[0][0].len() > 0,\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == y.len(),\n        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result[i].len() \n            ==> result[i][j].len() == z.len(),\n        forall|i: int, j: int, k: int| \n            0 <= i < result.len() && 0 <= j < result[i].len() && 0 <= k < result[i][j].len()\n            ==> exists|val: f32| result[i][j][k] == val,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_laguerre_lagline", "vc-description": "Laguerre series whose graph is a straight line off + scl*x. Specification: lagline returns the Laguerre series representation of off + scl*x.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn lagline(off: f32, scl: f32) -> (result: Vec<f32>)\n    ensures result.len() == 2", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_laguerre_lagmul", "vc-description": "Multiply one Laguerre series by another.\n\nThis function multiplies two Laguerre series represented as coefficient arrays.\nReturns the product of two Laguerre series c1 * c2. The arguments are sequences \nof coefficients, from lowest order \"term\" to highest, e.g., [1,2,3] represents \nthe series P_0 + 2*P_1 + 3*P_2.\n\nParameters:\n- c1, c2: 1-D arrays of Laguerre series coefficients ordered from low to high.\n\nReturns:\n- out: Array of Laguerre series coefficients representing their product.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn lagmul(c1: Vec<f64>, c2: Vec<f64>) -> (result: Vec<f64>)\n    requires c1.len() > 0 && c2.len() > 0,\n    ensures \n        result.len() == c1.len() + c2.len() - 1,\n        forall|i: int| 0 <= i < result.len() ==> \n            (result[i] != 0.0 ==> \n                exists|j: int, k: int| \n                    0 <= j < c1.len() && \n                    0 <= k < c2.len() && \n                    j + k == i && \n                    c1[j] != 0.0 && \n                    c2[k] != 0.0)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_laguerre_lagpow", "vc-description": "Raise a Laguerre series to a power.\n\nReturns the Laguerre series `c` raised to the power `pow`. The\nargument `c` is a sequence of coefficients ordered from low to high.\ni.e., [1,2,3] is the series  ``P_0 + 2*P_1 + 3*P_2.``\n\nSpecification: lagpow raises a Laguerre series to a power with proper constraints", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn lagpow(c: Vec<f32>, pow: usize, maxpower: usize) -> (result: Vec<f32>)\n    requires \n        pow > 0,\n        pow <= maxpower,\n        maxpower <= 16,\n        c.len() > 0,\n    ensures \n        result.len() == c.len(),\n        pow == 1 ==> (forall|i: int| 0 <= i < result.len() ==> result[i] == c[i]),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_laguerre_lagroots", "vc-description": "Compute the roots of a Laguerre series.\n\nReturn the roots (a.k.a. \"zeros\") of the polynomial\np(x) = sum_i c[i] * L_i(x).\n\nSpecification: lagroots computes the roots of a Laguerre polynomial", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn lagroots(c: Vec<i32>) -> (roots: Vec<i32>)\n    requires\n        c.len() >= 2,\n        c@[c.len() - 1 as int] != 0,\n    ensures\n        c.len() == 2 ==> roots.len() == 1,\n        c.len() == 2 ==> roots@[0] == 1 + c@[0] / c@[1],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_laguerre_lagval", "vc-description": "Evaluate a Laguerre series at points x using Clenshaw recursion.\nThe mathematical formula for the Laguerre series is:\np(x) = c_0 * L_0(x) + c_1 * L_1(x) + ... + c_n * L_n(x)\nwhere L_i(x) are the Laguerre polynomials.\n\nSpecification for Laguerre series evaluation:\nThe result has the same shape as the input x vector.\nFor a single coefficient, the result is constant.\nFor multiple coefficients, the function evaluates the Laguerre series\nusing Clenshaw recursion, which is numerically stable.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn lagval(x: Vec<f64>, c: Vec<f64>) -> (result: Vec<f64>)\n    requires \n        c.len() > 0,\n        x.len() > 0,\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> {\n            exists|val: f64| result[i] == val\n        },", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_laguerre_lagval2d", "vc-description": "Evaluate a 2-D Laguerre series at points (x, y).\nThe mathematical formula is: p(x,y) = sum_{i,j} c_{i,j} * L_i(x) * L_j(y)\nwhere L_i(x) and L_j(y) are the Laguerre polynomials.\n\nSpecification for 2-D Laguerre series evaluation:\nThe result has the same shape as the input x and y vectors.\nThe function evaluates a bivariate Laguerre polynomial series\nusing the tensor product of 1-D Laguerre polynomials.\n\n/* Base case: single coefficient returns constant */\n\n/* General case: evaluates 2D Laguerre series */\n\n/* Sanity check: result preserves input shape */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn lagval2d(x: Vec<f32>, y: Vec<f32>, c: Vec<Vec<f32>>) -> (result: Vec<f32>)\n    requires \n        x.len() == y.len(),\n        x.len() > 0,\n        c.len() > 0,\n        forall|i: int| 0 <= i < c.len() ==> c[i].len() > 0,\n    ensures\n        result.len() == x.len(),\n\n        (c.len() == 1 && c[0].len() == 1) ==> \n            forall|i: int| 0 <= i < result.len() ==> result[i] == c[0][0],\n\n        forall|i: int| 0 <= i < result.len() ==> \n            exists|val: f32| result[i] == val,\n\n        result.len() == x.len() && result.len() == y.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_laguerre_lagval3d", "vc-description": "Evaluate a 3-D Laguerre series at points (x, y, z).\nThe mathematical formula is: p(x,y,z) = sum_{i,j,k} c_{i,j,k} * L_i(x) * L_j(y) * L_k(z)\nwhere L_i(x), L_j(y) and L_k(z) are the Laguerre polynomials.\n\nSpecification for 3-D Laguerre series evaluation:\nThe result has the same shape as the input x, y, and z vectors.\nThe function evaluates a trivariate Laguerre polynomial series\nusing the tensor product of 1-D Laguerre polynomials.\n\n/* Base case: single coefficient returns constant */\n\n/* General case: evaluates 3D Laguerre series */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn lagval3d(x: Vec<f32>, y: Vec<f32>, z: Vec<f32>, c: Vec<Vec<Vec<f32>>>) -> (result: Vec<f32>)\n    requires \n        x.len() == y.len(),\n        y.len() == z.len(),\n        x.len() > 0,\n        c.len() > 0,\n        c[0].len() > 0,\n        c[0][0].len() > 0,\n    ensures\n        result.len() == x.len(),\n        result.len() == y.len(), \n        result.len() == z.len(),\n\n        (c.len() == 1 && c[0].len() == 1 && c[0][0].len() == 1) ==> \n            forall|i: int| 0 <= i < result.len() ==> result[i] == c[0][0][0],\n\n        forall|i: int| 0 <= i < result.len() ==> \n            exists|val: f32| result[i] == val,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_laguerre_poly2lag", "vc-description": "numpy.polynomial.laguerre.poly2lag: Convert a polynomial to a Laguerre series.\n\nConvert an array representing the coefficients of a polynomial (relative\nto the \"standard\" basis) ordered from lowest degree to highest, to an\narray of the coefficients of the equivalent Laguerre series, ordered\nfrom lowest to highest degree.\n\nParameters:\n- pol: 1-D array containing the polynomial coefficients\n\nReturns:\n- c: 1-D array containing the coefficients of the equivalent Laguerre series.\n\nNote: The conversion maintains the same degree structure but transforms\nthe basis from standard polynomial to Laguerre polynomial basis.\n\nSpecification: poly2lag converts polynomial coefficients to Laguerre series coefficients.\n\nThe mathematical property is that the conversion preserves the polynomial\nbut expresses it in terms of Laguerre polynomials instead of standard monomials.\n\nKey properties:\n1. Same degree: Both input and output have the same number of coefficients\n2. Basis transformation: Standard polynomial → Laguerre polynomial basis\n3. Orthogonality preservation: The resulting Laguerre series represents the\n   same polynomial but in a basis that is orthogonal with respect to exp(-x)\n\nPrecondition: True (no special preconditions for basis conversion)\nPostcondition: The result represents the same polynomial as input but in\n               Laguerre basis, and has the same length as input\n\n/* The coefficients form a valid Laguerre series representation\n           of the same polynomial as the input standard polynomial.\n           Mathematical property: polynomial evaluation equivalence\n           Standard polynomial: Σ(i=0 to n-1) pol[i] * x^i\n           Laguerre polynomial: Σ(i=0 to n-1) result[i] * L_i(x)\n           where L_i(x) is the i-th Laguerre polynomial */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn poly2lag(pol: Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() == pol.len(),\n\n        true,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_legendre_Legendre", "vc-description": "A Legendre series class.\n\n    The Legendre class provides the standard Python numerical methods\n    '+', '-', '*', '//', '%', 'divmod', '**', and '()' as well as the\n    attributes and methods listed below.\n\n    Parameters\n    ----------\n    coef : array_like\n        Legendre coefficients in order of increasing degree, i.e.,\n        ``(1, 2, 3)`` gives ``1*P_0(x) + 2*P_1(x) + 3*P_2(x)``.\n    domain : (2,) array_like, optional\n        Domain to use. The interval ``[domain[0], domain[1]]`` is mapped\n        to the interval ``[window[0], window[1]]`` by shifting and scaling.\n        The default value is [-1., 1.].\n    window : (2,) array_like, optional\n        Window, see `domain` for its use. The default value is [-1., 1.].\n    symbol : str, optional\n        Symbol used to represent the independent variable in string\n        representations of the polynomial expression, e.g. for printing.\n        The symbol must be a valid Python identifier. Default value is 'x'.\n\nCreate a Legendre series from coefficients\n\nSpecification: mkLegendre creates a valid Legendre series representation\n\n/* A Legendre series representation with coefficients, domain, and window */\n\n/* Legendre coefficients in order of increasing degree */\n\n/* Domain interval for polynomial evaluation */\n\n/* Window interval for domain mapping */\n\n/* Symbol name for variable representation */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "struct Legendre {\n\n    coef: Vec<f64>,\n\n    domain: [f64; 2],\n\n    window: [f64; 2],\n\n    symbol: String,\n}\n\nfn mk_legendre(\n    coef: Vec<f64>,\n    domain: [f64; 2],\n    window: [f64; 2],\n    symbol: String\n) -> (result: Legendre)\n    ensures\n        result.coef.len() == coef.len(),\n        forall|i: int| 0 <= i < coef.len() ==> result.coef[i] == coef[i],\n        result.domain == domain,\n        result.window == window,\n        result.symbol == symbol,\n        domain[0] == -1.0 && domain[1] == 1.0 ==> result.domain[0] == -1.0 && result.domain[1] == 1.0,\n        window[0] == -1.0 && window[1] == 1.0 ==> result.window[0] == -1.0 && result.window[1] == 1.0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_legendre_leg2poly", "vc-description": "Convert a Legendre series to a polynomial.\n\nConvert a Legendre series to a polynomial.\n\n    Convert an array representing the coefficients of a Legendre series,\n    ordered from lowest degree to highest, to an array of the coefficients\n    of the equivalent polynomial (relative to the \"standard\" basis) ordered\n    from lowest to highest degree.\n\n    Parameters\n    ----------\n    c : array_like\n        1-D array containing the Legendre series coefficients, ordered\n        from lowest order term to highest.\n\n    Returns\n    -------\n    pol : ndarray\n        1-D array containing the coefficients of the equivalent polynomial\n        (relative to the \"standard\" basis) ordered from lowest order term\n        to highest.\n\n    See Also\n    --------\n    poly2leg\n\n    Notes\n    -----\n    The easy way to do conversions between polynomial basis sets\n    is to use the convert method of a class instance.\n\n    Examples\n    --------\n    >>> from numpy import polynomial as P\n    >>> c = P.Legendre(range(4))\n    >>> c\n    Legendre([0., 1., 2., 3.], domain=[-1.,  1.], window=[-1.,  1.], symbol='x')\n    >>> p = c.convert(kind=P.Polynomial)\n    >>> p\n    Polynomial([-1. , -3.5,  3. ,  7.5], domain=[-1.,  1.], window=[-1., ...\n    >>> P.legendre.leg2poly(range(4))\n    array([-1. , -3.5,  3. ,  7.5])\n\nConvert a Legendre series to a polynomial (monomial basis)\n\nSpecification: leg2poly converts Legendre series coefficients to polynomial coefficients\n\n/* For small cases (n < 3), the conversion is identity */\n\n/* The conversion transforms Legendre basis to monomial basis */\n\n/* The mathematical property is that ∑ cᵢ Pᵢ(x) = ∑ result[i] xⁱ */\n\n/* where Pᵢ are the Legendre polynomials */\n\n/* The transformation is well-defined and preserves polynomial degree */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn leg2poly(c: Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() == c.len(),\n\n        c.len() < 3 ==> forall|i: int| 0 <= i < c.len() ==> result[i] == c[i],\n\n        forall|i: int| 0 <= i < result.len() ==> exists|val: f32| result[i] == val,\n\n        c.len() > 0 ==> exists|lead: f32| result[c.len() - 1] == lead,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_legendre_legcompanion", "vc-description": "Return the scaled companion matrix of Legendre series coefficients.\nThe companion matrix is symmetric when c is a Legendre basis polynomial,\nproviding better eigenvalue estimates.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn legcompanion(c: Vec<f64>) -> (result: Vec<Vec<f64>>)\n    requires \n        c.len() >= 2,\n        c[c.len() - 1] != 0.0,\n    ensures \n        result.len() == c.len() - 1,\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == c.len() - 1,\n        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result.len() ==> \n            result[i][j] == result[j][i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_legendre_legder", "vc-description": "Differentiate a Legendre series.\nReturns the Legendre series coefficients c differentiated m times.\nEach differentiation is multiplied by scl (scaling factor).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn legder(c: Vec<f64>, m: usize, scl: f64) -> (result: Vec<f64>)\n    requires c.len() >= 1,\n    ensures\n        result.len() == if c.len() > m { c.len() - m } else { 1 },\n        m == 0 ==> (result.len() == c.len() && forall|i: int| 0 <= i < c.len() ==> result[i] == c[i]),\n        m >= c.len() ==> result.len() == 1,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_legendre_leggrid2d", "vc-description": "Evaluate a 2-D Legendre series on the Cartesian product of x and y.\nThis function computes p(a,b) = ∑_{i,j} c_{i,j} * L_i(a) * L_j(b)\nfor all pairs (a,b) from the Cartesian product of x and y.\n\nSpecification: leggrid2d correctly evaluates a 2-D Legendre series\non the Cartesian product of input points.\n\nThe function computes the tensor product evaluation of Legendre polynomials\naccording to the mathematical formula p(a,b) = ∑_{i,j} c_{i,j} * L_i(a) * L_j(b).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn leggrid2d(x: Vec<f32>, y: Vec<f32>, c: Vec<Vec<f32>>) -> (result: Vec<Vec<f32>>)\n    requires \n        x.len() > 0,\n        y.len() > 0,\n        c.len() > 0,\n        forall|i: int| 0 <= i < c.len() ==> c[i].len() > 0,\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == y.len(),\n        forall|i: int, j: int| 0 <= i < x.len() && 0 <= j < y.len() ==> \n            exists|val: f32| result[i][j] == val,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_legendre_leggrid3d", "vc-description": "Evaluate a 3-D Legendre series on the Cartesian product of x, y, and z.\nThis function computes p(a,b,c) = ∑_{i,j,k} c_{i,j,k} * L_i(a) * L_j(b) * L_k(c)\nfor all triples (a,b,c) from the Cartesian product of x, y, and z.\n\nSpecification: leggrid3d correctly evaluates a 3-D Legendre series\non the Cartesian product of input points.\n\nThe function computes the tensor product evaluation of Legendre polynomials\naccording to the mathematical formula p(a,b,c) = ∑_{i,j,k} c_{i,j,k} * L_i(a) * L_j(b) * L_k(c).\n\n/* The result has the correct shape: nx × ny × nz grid */\n\n/* Each grid point (i,j,k) contains the evaluation of the 3D Legendre series */\n\n/* Grid structure preserves dimensionality */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn leggrid3d(x: Vec<f64>, y: Vec<f64>, z: Vec<f64>, c: Vec<Vec<Vec<f64>>>) -> (result: Vec<Vec<Vec<f64>>>)\n    requires \n        x.len() > 0,\n        y.len() > 0,\n        z.len() > 0,\n        c.len() > 0,\n        forall|i: int| 0 <= i < c.len() ==> c[i].len() > 0,\n        forall|i: int, j: int| 0 <= i < c.len() && 0 <= j < c[i].len() ==> c[i][j].len() > 0,\n    ensures\n\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == y.len(),\n        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result[i].len() ==> result[i][j].len() == z.len(),\n\n        forall|i: int, j: int, k: int| \n            0 <= i < x.len() && 0 <= j < y.len() && 0 <= k < z.len() ==>\n            exists|val: f64| result[i][j][k] == val,\n\n        forall|i1: int, i2: int, j1: int, j2: int, k1: int, k2: int|\n            0 <= i1 < x.len() && 0 <= i2 < x.len() && \n            0 <= j1 < y.len() && 0 <= j2 < y.len() &&\n            0 <= k1 < z.len() && 0 <= k2 < z.len() ==>\n            ((i1 != i2 || j1 != j2 || k1 != k2) ==> \n             (result[i1][j1][k1] != result[i2][j2][k2] || \n              (x[i1] == x[i2] && y[j1] == y[j2] && z[k1] == z[k2])))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_legendre_legint", "vc-description": "Integrate a Legendre series, returning the coefficients of the integrated series.\nThe function integrates the Legendre series with coefficients c one time,\napplying scaling factor scl and integration constant k.\n\nSpecification: legint correctly integrates Legendre series coefficients\naccording to the mathematical properties of Legendre polynomial integration.\n\nIntegration increases the degree of the polynomial by 1, and the resulting \ncoefficients satisfy the Legendre integration recurrence relations.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn legint(c: Vec<f64>, k: f64, lbnd: f64, scl: f64) -> (result: Vec<f64>)\n    requires scl != 0.0,\n    ensures result.len() == c.len() + 1", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_legendre_legline", "vc-description": "Creates a Legendre series representation of a straight line `off + scl*x`. This function generates the correct Legendre series coefficients for a linear function.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn legline(off: f32, scl: f32) -> (result: Vec<f32>)\n    ensures\n        result.len() == 2,\n        result[0] == off,\n        result[1] == scl", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_legendre_legmul", "vc-description": "Multiply one Legendre series by another, producing coefficients in Legendre basis", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn legmul(c1: Vec<f32>, c2: Vec<f32>) -> (result: Vec<f32>)\n    requires \n        c1.len() > 0,\n        c2.len() > 0,\n    ensures\n        result.len() == c1.len() + c2.len() - 1,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_legendre_legmulx", "vc-description": "Multiply a Legendre series by x using the Legendre recurrence relation.\n\nSpecification: legmulx multiplies a Legendre series by x using the correct recurrence relation.\n\nThis function multiplies the Legendre series c by x, where x is the independent variable.\nThe multiplication uses the recursion relationship for Legendre polynomials in the form:\nxP_i(x) = ((i + 1)*P_{i + 1}(x) + i*P_{i - 1}(x))/(2i + 1)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn legmulx(c: Vec<f32>) -> (result: Vec<f32>)\n    requires c.len() > 0,\n    ensures\n        result.len() == c.len() + 1,\n        result[0] == 0.0f32,\n        result[1] == c[0],\n        forall|i: int| 0 <= i < result.len() ==> exists|coeff: f32| result[i] == coeff,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_legendre_legvander", "vc-description": "Pseudo-Vandermonde matrix of given degree based on Legendre polynomials.\nReturns the pseudo-Vandermonde matrix of degree `deg` and sample points `x`.\nThe pseudo-Vandermonde matrix is defined by V[..., i] = L_i(x) where 0 <= i <= deg.\nL_i represents the i-th Legendre polynomial.\n\nSpecification: legvander constructs a pseudo-Vandermonde matrix where each row \ncorresponds to a point and each column corresponds to a Legendre polynomial evaluation.\nThe matrix satisfies basic properties of Legendre polynomials:\n- L_0(x) = 1 (first column is all ones)\n- L_1(x) = x (second column equals input values when deg > 0)\n- The matrix has the correct dimensions", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn legvander(x: Vec<f32>, deg: usize) -> (result: Vec<Vec<f32>>)\n    requires x.len() > 0,\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == deg + 1,\n        forall|i: int| 0 <= i < result.len() ==> result[i][0] == 1.0f32,\n        deg > 0 ==> forall|i: int| 0 <= i < result.len() ==> result[i][1] == x[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_legendre_legvander2d", "vc-description": "Pseudo-Vandermonde matrix of given degrees for 2D Legendre polynomials.\nReturns the pseudo-Vandermonde matrix of degrees `deg` and sample points `(x, y)`.\nThe pseudo-Vandermonde matrix is defined by V[..., (deg[1] + 1)*i + j] = L_i(x) * L_j(y),\nwhere 0 <= i <= deg[0] and 0 <= j <= deg[1].\n\nSpecification: legvander2d constructs a 2D pseudo-Vandermonde matrix where each row \ncorresponds to a point (x_i, y_i) and each column corresponds to a product of \nLegendre polynomials L_i(x) * L_j(y).\nThe matrix satisfies basic properties:\n- Each entry is a product of 1D Legendre polynomial evaluations\n- The ordering follows the specified indexing scheme\n- The matrix has the correct dimensions", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn legvander2d(x: Vec<f64>, y: Vec<f64>, deg_x: usize, deg_y: usize) -> (result: Vec<Vec<f64>>)\n    requires x.len() == y.len(),\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == (deg_x + 1) * (deg_y + 1),\n        forall|i: int| 0 <= i < result.len() && result[i].len() > 0 ==> result[i][0] == 1.0", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_legendre_legweight", "vc-description": "Weight function of the Legendre polynomials. \nThe weight function is constant 1 for all input values.\n\nSpecification: legweight returns a vector of all ones with the same length as input.\nThis captures the mathematical property that the Legendre weight function is constant 1.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn legweight(x: Vec<f32>) -> (result: Vec<f32>)\n    ensures \n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == 1.0f32", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_legendre_poly2leg", "vc-description": "Convert a polynomial to a Legendre series.\nConverts coefficients from standard polynomial basis to Legendre basis.\n\nSpecification: poly2leg converts polynomial coefficients to Legendre series coefficients.\nThe transformation preserves the polynomial degree and produces valid Legendre coefficients.\nThe result has the same dimension as the input and represents the same polynomial\nexpressed in the Legendre basis instead of the standard monomial basis.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn poly2leg(pol: Vec<f32>) -> (result: Vec<f32>)\n    ensures \n        result.len() == pol.len(),\n        forall|i: int| 0 <= i < result.len() ==> exists|c: f32| result[i] == c", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_polynomial_polydiv", "vc-description": "numpy.polynomial.polynomial.polydiv: Divide one polynomial by another.\n\nReturns the quotient-with-remainder of two polynomials c1 / c2.\nThe arguments are sequences of coefficients, from lowest order term\nto highest, e.g., [1,2,3] represents 1 + 2*x + 3*x**2.\n\nThe function performs polynomial long division, returning both\nthe quotient and remainder such that c1 = c2 * quotient + remainder.\n\nSpecification: polydiv performs polynomial division with remainder.\n\nPrecondition: The leading coefficient of c2 (highest degree term) is non-zero\nPostcondition: \n- The division identity holds: c1 = c2 * quotient + remainder (as polynomials)\n- The remainder has degree less than the divisor (leading coefficients are zero)\n- When the divisor is a constant polynomial, the quotient is c1 scaled by 1/c2[0]\n\n// leading coefficient non-zero\n\n// Division identity: polynomial relationship holds\n\n// Remainder has lower degree than divisor", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn polydiv(c1: Vec<f32>, c2: Vec<f32>) -> (result: (Vec<f32>, Vec<f32>))\n    requires \n        c1.len() > 0,\n        c2.len() > 0,\n        c2[c2.len() - 1] != 0.0f32,\n    ensures ({\n        let (quo, rem) = result;\n\n        quo.len() == c1.len() &&\n        rem.len() == c1.len() &&\n\n        (forall|j: int| j >= (c2.len() - 1) && 0 <= j < rem.len() ==> rem[j] == 0.0f32)\n    })", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_polynomial_polymulx", "vc-description": "Multiply a polynomial by x.\nMultiplies polynomial c by x, where x is the independent variable.\nFor polynomial p(x) = c[0] + c[1]*x + ... + c[n-1]*x^(n-1),\nreturns x*p(x) = 0 + c[0]*x + c[1]*x^2 + ... + c[n-1]*x^n\n\nSpecification: polymulx multiplies a polynomial by x.\nThe result has one more coefficient than the input.\nThe first coefficient is always 0, and subsequent coefficients\nare the original coefficients shifted by one position.\nThis represents multiplying p(x) by x to get x*p(x).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn polymulx(c: Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() == c.len() + 1,\n        result[0] == 0.0f32,\n        forall|i: int| 0 <= i < c.len() ==> result[i + 1] == c[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_polynomial_polypow", "vc-description": "Raise a polynomial to a power.\nReturns the polynomial c raised to the power pow.\nFor polynomial p(x) = c[0] + c[1]*x + ... + c[n-1]*x^(n-1),\nreturns p(x)^pow with appropriate coefficient expansion.\n\nSpecification: polypow raises a polynomial to a non-negative integer power.\nThe result represents the polynomial p(x)^pow where p(x) is defined by coefficients c.\nFor power 0, returns [1] (the constant polynomial 1).\nFor power 1, returns the original polynomial.\nThe degree grows as expected for polynomial multiplication.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn polypow(c: Vec<f32>, pow: nat) -> (result: Vec<f32>)\n    ensures\n        pow == 0 ==> (result.len() == 1 && result[0] == 1.0f32),\n        pow == 1 ==> result.len() == c.len() && (forall|i: int| 0 <= i < c.len() ==> result[i] == c[i]),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_polynomial_polyroots", "vc-description": "Compute the roots of a polynomial.\nGiven polynomial coefficients c[0], c[1], ..., c[n-1], returns the roots of\np(x) = c[0] + c[1]*x + c[2]*x^2 + ... + c[n-1]*x^(n-1).\nFor a polynomial of degree n, there are exactly n roots (counting multiplicity).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn polyroots(c: Vec<f64>) -> (roots: Vec<f64>)\n    requires \n        c.len() > 1,\n        c[c.len() - 1] != 0.0,\n    ensures\n        roots.len() == c.len() - 1,\n        forall|i: int| 0 <= i < c.len() ==> exists|j: int| 0 <= j < c.len() && c[j] != 0.0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_polynomial_polyval", "vc-description": "Evaluate a polynomial at points x using Horner's method.\nGiven coefficients c = [c₀, c₁, ..., cₙ] and evaluation points x,\ncomputes p(x) = c₀ + c₁·x + c₂·x² + ... + cₙ·xⁿ for each x\n\nSpecification: polyval evaluates a polynomial with coefficients c at points x.\nThe result at each point xᵢ is the polynomial value p(xᵢ) = c₀ + c₁·xᵢ + c₂·xᵢ² + ... + cₙ·xᵢⁿ\n\nMathematical properties:\n- For coefficient vector c = [c₀, c₁, ..., cₙ], evaluates polynomial p(x) = Σⱼ cⱼ·xʲ\n- Uses Horner's method for numerical stability: p(x) = c₀ + x·(c₁ + x·(c₂ + x·(...)))\n- Linear in coefficients: p(x, αc₁ + βc₂) = α·p(x, c₁) + β·p(x, c₂)\n- Polynomial evaluation at zero gives constant term: p(0) = c₀\n- For degree-0 polynomial [c₀], result is constant c₀ for all x", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn polyval(x: Vec<f64>, c: Vec<f64>) -> (result: Vec<f64>)\n    requires \n        x.len() > 0,\n        c.len() > 0,\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> \n            exists|poly_val: f64| result[i] == poly_val &&\n            (c.len() == 1 ==> poly_val == c[0]) &&\n            (forall|j: int| 0 <= j < c.len() && c[j] == 0.0 ==> poly_val == 0.0)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_polynomial_polyval2d", "vc-description": "Evaluate a 2D polynomial at points (x, y).\nGiven a coefficient matrix c and evaluation points (x, y),\ncomputes p(x,y) = Σᵢⱼ cᵢⱼ·xⁱ·yʲ for each point pair\n\nSpecification: polyval2d evaluates a 2D polynomial with coefficient matrix c at point pairs (x, y).\nThe result at each point (xᵢ, yᵢ) is the polynomial value p(xᵢ, yᵢ) = Σᵢⱼ cᵢⱼ·xᵢⁱ·yᵢʲ\n\nMathematical properties:\n- For coefficient matrix c[i][j], evaluates p(x,y) = Σᵢⱼ c[i][j]·xⁱ·yʲ\n- Reduces to 1D polyval when one variable is zero: p(x,0) uses first column c[*][0]\n- Bilinear in coefficients: p(x,y, αc₁ + βc₂) = α·p(x,y,c₁) + β·p(x,y,c₂)  \n- Constant term: p(0,0) = c[0][0]\n- Degree-0 in both variables gives constant: c = [[c₀₀]] → p(x,y) = c₀₀ for all (x,y)\n\n/* Constant term property: when both degrees are 0 */\n\n/* Zero coefficient property: if all coefficients are zero, result is zero */\n\n/* Evaluation at origin gives constant term */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn polyval2d(x: Vec<f32>, y: Vec<f32>, c: Vec<Vec<f32>>) -> (result: Vec<f32>)\n    requires \n        x.len() == y.len(),\n        x.len() > 0,\n        c.len() > 0,\n        forall|i: int| 0 <= i < c.len() ==> c[i].len() > 0,\n        forall|i: int| 0 <= i < c.len() ==> c[i].len() == c[0].len(),\n    ensures\n        result.len() == x.len(),\n        forall|k: int| 0 <= k < result.len() ==> exists|poly_val: f32| #[trigger] result[k] == poly_val,\n\n        (c.len() == 1 && c[0].len() == 1) ==> \n            (forall|k: int| 0 <= k < result.len() ==> result[k] == c[0][0]),\n\n        (forall|i: int, j: int| 0 <= i < c.len() && 0 <= j < c[i].len() ==> c[i][j] == 0.0f32) ==> \n            (forall|k: int| 0 <= k < result.len() ==> result[k] == 0.0f32),\n\n        forall|k: int| 0 <= k < result.len() && x[k] == 0.0f32 && y[k] == 0.0f32 ==> \n            result[k] == c[0][0],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_polynomial_polyval3d", "vc-description": "Evaluate a 3-D polynomial at points (x, y, z).\nThis function evaluates the polynomial p(x,y,z) = Σ_{i,j,k} c[i,j,k] * x^i * y^j * z^k\nwhere the sum is over all valid indices of the coefficient tensor c.\n\nSpecification: polyval3d evaluates a 3-dimensional polynomial at each point (x[i], y[i], z[i]).\nThe polynomial is defined as the sum of c[i,j,k] * x^i * y^j * z^k over all coefficient indices.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn polyval3d(\n    x: Vec<f32>, \n    y: Vec<f32>, \n    z: Vec<f32>, \n    c: Vec<Vec<Vec<f32>>>\n) -> (result: Vec<f32>)\n    requires \n        x.len() == y.len(),\n        y.len() == z.len(),\n        c.len() > 0,\n        forall|i: int| 0 <= i < c.len() ==> c[i].len() > 0,\n        forall|i: int, j: int| 0 <= i < c.len() && 0 <= j < c[i].len() ==> c[i][j].len() > 0,\n    ensures \n        result.len() == x.len(),\n        forall|p: int| 0 <= p < x.len() ==> \n            exists|val: f32| result[p] == val &&\n            (c.len() == 1 && c[0].len() == 1 && c[0][0].len() == 1 ==> \n             val == c[0][0][0])", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_polynomial_polyvalfromroots", "vc-description": "Evaluate a polynomial specified by its roots at points x.\nIf `r` is of length `N`, this function returns the value p(x) = ∏(x - r_i)\nwhere the product is over all roots r_i in the roots vector.\n\nSpecification: polyvalfromroots evaluates the polynomial with the given roots\nat each point in x. The polynomial is defined as the product of (x - r_i) for all roots r_i.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn poly_eval_at_point(x_val: int, roots: Seq<int>) -> int\n    decreases roots.len()\n{\n    if roots.len() == 0 {\n        1\n    } else {\n        (x_val - roots[0]) * poly_eval_at_point(x_val, roots.subrange(1, roots.len() as int))\n    }\n}\n\nfn polyvalfromroots(x: Vec<i32>, r: Vec<i32>) -> (result: Vec<i32>)\n    ensures \n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == poly_eval_at_point(x[i] as int, r@.map_values(|v: i32| v as int)),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_polynomial_polyvander2d", "vc-description": "Pseudo-Vandermonde matrix of given degrees for 2D polynomials.\nReturns a matrix where V[k, (yDeg + 1)*i + j] = x[k]^i * y[k]^j\nfor 0 <= i <= xDeg and 0 <= j <= yDeg.\n\nSpecification: polyvander2d creates a pseudo-Vandermonde matrix where each entry\nsatisfies the polynomial power relationship V[k, (yDeg + 1)*i + j] = x[k]^i * y[k]^j.\nThe matrix has dimensions n × ((xDeg + 1) * (yDeg + 1)) and represents all polynomial\nterms x^i * y^j for 0 ≤ i ≤ xDeg and 0 ≤ j ≤ yDeg.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn pow_spec(base: int, exp: nat) -> int\n    decreases exp\n{\n    if exp == 0 {\n        1\n    } else {\n        base * pow_spec(base, (exp - 1) as nat)\n    }\n}", "vc-helpers": "", "vc-spec": "fn polyvander2d(x: Vec<f64>, y: Vec<f64>, x_deg: usize, y_deg: usize) -> (result: Vec<Vec<f64>>)\n    requires \n        x.len() == y.len(),\n        x.len() > 0,\n    ensures\n        result.len() == x.len(),\n        forall|k: int| 0 <= k < result.len() ==> #[trigger] result[k].len() == (x_deg + 1) * (y_deg + 1),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_polynomial_polyvander3d", "vc-description": "Pseudo-Vandermonde matrix of given degrees for 3D polynomials.\nReturns a matrix where V[p, (yDeg + 1)*(zDeg + 1)*i + (zDeg + 1)*j + k] = x[p]^i * y[p]^j * z[p]^k\nfor 0 <= i <= xDeg, 0 <= j <= yDeg and 0 <= k <= zDeg.\n\nSpecification: polyvander3d creates a pseudo-Vandermonde matrix where each entry\nsatisfies the polynomial power relationship V[p, (yDeg + 1)*(zDeg + 1)*i + (zDeg + 1)*j + k] = x[p]^i * y[p]^j * z[p]^k.\nThe matrix has dimensions n × ((xDeg + 1) * (yDeg + 1) * (zDeg + 1)) and represents all polynomial\nterms x^i * y^j * z^k for 0 ≤ i ≤ xDeg, 0 ≤ j ≤ yDeg, and 0 ≤ k ≤ zDeg.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn polyvander3d(x: Vec<f64>, y: Vec<f64>, z: Vec<f64>, x_deg: usize, y_deg: usize, z_deg: usize) -> (result: Vec<Vec<f64>>)\n    requires \n        x.len() == y.len(),\n        y.len() == z.len(),\n        x.len() > 0,\n    ensures\n        result.len() == x.len(),\n        forall|p: int| 0 <= p < result.len() ==> result[p].len() == (x_deg + 1) * (y_deg + 1) * (z_deg + 1)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_polyutils_as_series", "vc-description": "Return argument as a list of 1-d arrays. Takes a 2-d array of shape (M,N)\nand returns M arrays of size N (parsed by row). Optionally trims trailing \nzeros from each array.\n\nSpecification: as_series returns a list of 1-d arrays where each row of the\ninput becomes a separate 1-d array. When trim is false, arrays are unchanged.\nWhen trim is true, trailing zeros are removed from each array.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn as_series(arr: Vec<Vec<f64>>, trim: bool) -> (result: Vec<Vec<f64>>)\n    requires \n        arr.len() > 0,\n        forall|i: int| 0 <= i < arr.len() ==> arr[i].len() > 0,\n    ensures \n        result.len() == arr.len(),\n        forall|i: int| 0 <= i < result.len() ==> {\n            if !trim {\n                result[i].len() == arr[i].len() &&\n                forall|j: int| 0 <= j < arr[i].len() ==> result[i][j] == arr[i][j]\n            } else {\n                forall|j: int| 0 <= j < result[i].len() ==> {\n                    result[i][j] == arr[i][j] || result[i][j] == 0.0\n                }\n            }\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_polyutils_mapdomain", "vc-description": "numpy.polynomial.polyutils.mapdomain: Apply linear map to input points.\n\nThe linear map `offset + scale*x` that maps the domain `old` to\nthe domain `new` is applied to the points `x`.\n\nThis function implements the mathematical transformation:\nx_out = new[0] + m(x - old[0])\nwhere m = (new[1] - new[0]) / (old[1] - old[0])\n\nParameters:\n- x: Points to be mapped (Vector of Float values)\n- old: Two-element vector defining the old domain [old[0], old[1]]\n- new: Two-element vector defining the new domain [new[0], new[1]]\n\nReturns:\n- x_out: Array of points of the same shape as x, after linear transformation\n\nSpecification: mapdomain applies linear transformation to map points from old domain to new domain.\n\nThe function computes a linear transformation that maps the interval [old[0], old[1]] \nto the interval [new[0], new[1]], then applies this transformation to each point in x.\n\nMathematical properties:\n1. The transformation is linear: f(x) = offset + scale * x\n2. The scale factor is: (new[1] - new[0]) / (old[1] - old[0])\n3. The offset is: new[0] - scale * old[0]\n4. Points at old[0] map to new[0], points at old[1] map to new[1]\n\nPrecondition: The old domain must be non-degenerate (old[1] ≠ old[0])\nPostcondition: Each result point follows the linear transformation formula", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn mapdomain(x: Vec<f32>, old: Vec<f32>, new: Vec<f32>) -> (result: Vec<f32>)\n    requires \n        old.len() == 2,\n        new.len() == 2,\n        old[1] != old[0],\n    ensures\n        result.len() == x.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_polyutils_mapparms", "vc-description": "Linear map parameters between domains. \nReturns the parameters of the linear map `offset + scale*x` that maps\n`old` to `new` such that `old[i] -> new[i]`, `i = 0, 1`.\n\nSpecification: mapparms computes linear mapping parameters between domains.\nThe returned offset and scale define a linear map L(x) = offset + scale*x\nthat maps the old domain to the new domain.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn mapparms(old: [i32; 2], new: [i32; 2]) -> (result: (i32, i32))\n    requires old[0] != old[1],\n    ensures ({\n        let (offset, scale) = result;\n        let oldlen = old[1] - old[0];\n        let newlen = new[1] - new[0];\n        offset + scale * old[0] == new[0] &&\n        offset + scale * old[1] == new[1] &&\n        scale == newlen / oldlen &&\n        offset == (old[1] * new[0] - old[0] * new[1]) / oldlen\n    })", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_polyutils_trimcoef", "vc-description": "Remove \"small\" \"trailing\" coefficients from a polynomial.\nSmall means small in absolute value controlled by tolerance parameter.\nTrailing means highest order coefficients.\n\nSpecification: trimcoef removes trailing coefficients with absolute value ≤ tol.\nIf all coefficients are small, returns a single zero.\nThe tolerance must be non-negative.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn trimcoef(c: Vec<f32>, tol: f32) -> (result: Vec<f32>)\n    ensures\n        result.len() >= 1,\n        result.len() <= c.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "polynomial_polyutils_trimseq", "vc-description": "Remove small Poly series coefficients.\n\nRemove trailing zeros from a sequence of polynomial coefficients.\nReturns the sequence with trailing zeros removed. If the sequence would be empty \nafter trimming, returns the first element. Empty sequences are handled.\n\nSpecification: trimseq removes trailing zeros while preserving at least one element.\nFor non-empty sequences, if the last element is non-zero, return the sequence unchanged.\nIf the last element is zero, trim trailing zeros but always keep at least one element.\n\n/* If empty or last element is non-zero, return unchanged */\n\n/* If last element is zero, trim properly */\n\n/* There exists a position k where trimming occurs */\n\n/* All elements after k in original sequence are zero */\n\n/* Result preserves elements up to k, zeros after */\n\n/* Element at k is non-zero unless k = 0 (all zeros case) */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn trimseq(seq: Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() == seq.len(),\n\n        (seq.len() == 0 || (seq.len() > 0 && seq[seq.len() - 1] != 0.0f32)) ==> result@ == seq@,\n\n        (seq.len() > 0 && seq[seq.len() - 1] == 0.0f32) ==>\n\n            exists|k: int| \n                0 <= k < seq.len() &&\n\n                (forall|j: int| k < j < seq.len() ==> seq[j] == 0.0f32) &&\n\n                (forall|i: int| 0 <= i <= k ==> result[i] == seq[i]) &&\n                (forall|i: int| k < i < result.len() ==> result[i] == 0.0f32) &&\n\n                (k > 0 ==> seq[k] != 0.0f32)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "random_BitGenerator", "vc-description": "numpy.random.BitGenerator: Base class for bit generators.\n\nThe BitGenerator manages state and provides functions to produce random doubles \nand random unsigned 32- and 64-bit values. This function initializes a BitGenerator\nwith an optional seed value.\n\nParameters:\n- seed: Optional seed value to initialize the generator (None uses system entropy)\n\nReturns:\n- A BitGeneratorState that can be used to generate random values\n\nSpecification: numpy.random.BitGenerator creates a properly initialized BitGenerator state.\n\nPrecondition: True (any seed value is valid, including None)\nPostcondition: The returned state has the provided seed (or maintains None if no seed given)\n            and has a valid internal state representation.\n\n/* BitGenerator state representing the internal state of a pseudo-random number generator.\n   This is an abstract representation that can be seeded and used to generate random values. */\n\n/* The seed value used to initialize the generator, or None if no seed was provided */\n\n/* The internal state of the generator used for random number generation */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\npub struct BitGeneratorState {\n\n    pub seed: Option<u64>,\n\n    pub internal_state: u64,\n}", "vc-helpers": "", "vc-spec": "fn numpy_random_bit_generator(seed: Option<u64>) -> (result: BitGeneratorState)\n    ensures \n        result.seed == seed,\n        seed.is_Some() ==> result.internal_state != 0,\n        seed.is_None() ==> result.internal_state == 0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "random_MT19937", "vc-description": "MT19937 BitGenerator for the Mersenne Twister pseudo-random number generator\n\nMT19937 provides a capsule containing function pointers that produce doubles, \nand unsigned 32 and 64-bit integers. This implementation focuses on the core\nstate initialization and next value generation.\n\nThe Mersenne Twister is a pseudorandom number generator that maintains an\ninternal state and produces a sequence of 32-bit integers with a period of 2^19937 - 1.\n\nParameters:\n- seed : u32 optional seed value to initialize the generator\n\nThe generator produces uniformly distributed values in [0, 2^32 - 1]\n\nSpecification: MT19937 initializes the generator state with proper seeding\n\nThe MT19937 generator maintains a state vector of 624 32-bit integers.\nWhen initialized with a seed, it produces a deterministic sequence.\n\nPrecondition: None (any seed value is valid)\nPostcondition: \n1. The state vector has exactly 624 elements\n2. The state is deterministically initialized based on the seed\n3. The first element of the state equals the seed\n4. The generator produces deterministic values based on the seed\n5. All state values are 32-bit unsigned integers\n\n/* The state vector has the correct size (624 elements) */\n\n/* The first element equals the seed */\n\n/* All elements are valid 32-bit values (guaranteed by type) */\n\n/* State initialization follows MT19937 recurrence relation */\n\n/* Deterministic: same seed produces same initial state */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn mt19937(seed: u32) -> (state: Vec<u32>)\n    ensures \n\n        state.len() == 624,\n\n        state[0] == seed,\n\n        true,\n\n        forall|i: int| 0 <= i < 623 ==> {\n            let k = i + 1;\n            let prev_state = state[i];\n            let shifted = prev_state >> 30;\n            let xor_result = prev_state ^ shifted;\n            let mult_result = 1812433253u32 * xor_result;\n            let next_val = mult_result + (k as u32);\n            state[k] == next_val\n        },\n\n        forall|seed2: u32, state2: Vec<u32>| \n            seed == seed2 && state2.len() == 624 && state2[0] == seed2 ==>\n            forall|j: int| 0 <= j < 624 ==> state[j] == state2[j]", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "random_PCG64DXSM", "vc-description": "BitGenerator for the PCG-64 DXSM pseudo-random number generator\n\nPCG-64 DXSM is a 128-bit implementation of O'Neill's permutation congruential generator\nwith the DXSM output mixer. It has better statistical properties in parallel contexts\nthan the standard PCG-64.\n\nThe generator uses a linear congruential generator (LCG) to advance the state,\nwith a fixed odd increment. It uses a 64-bit \"cheap multiplier\" in the LCG.\nThe generator has a period of 2^128 and supports advancing an arbitrary number\nof steps as well as 2^127 streams.\n\nThis function generates a sequence of random 64-bit unsigned integers given\na seed value.\n\nSpecification: PCG64DXSM generates a sequence of pseudo-random numbers with specific mathematical properties.\n\nThe PCG64DXSM generator satisfies the following properties:\n1. Deterministic: Same seed produces same sequence\n2. Uniform distribution: All 64-bit values are equally likely over the full period\n3. Full period: The generator has period 2^128\n4. Statistical independence: Generated values appear statistically independent\n5. Non-predictability: Knowledge of some outputs doesn't easily predict others", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn pcg64_dxsm_spec(seed: u64, n: nat) -> Seq<u64>\n{\n    arbitrary()\n}\n\nfn pcg64_dxsm(seed: u64, n: usize) -> (result: Vec<u64>)\n    ensures\n        result.len() == n,\n        seed == seed ==> result@ == pcg64_dxsm_spec(seed, n as nat),\n        n > 0 ==> (exists|i: int| 0 <= i < n && #[trigger] result[i] >= 0),\n        n > 1 ==> true,\n        forall|seed_prime: u64| seed != seed_prime ==> \n            pcg64_dxsm_spec(seed, n as nat) != pcg64_dxsm_spec(seed_prime, n as nat)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "random_default_rng", "vc-description": "numpy.random.default_rng: Construct a new Generator with the default BitGenerator (PCG64).\n\nCreates a new Generator instance using PCG64 as the underlying BitGenerator.\nThis is the recommended way to create random number generators in NumPy.\n\nIf seed is None, the generator will be initialized with fresh entropy from the OS.\nIf seed is provided, the generator will be deterministically initialized with that seed.\n\nSpecification: default_rng returns a properly initialized Generator object.\n\nPrecondition: True (no restrictions on the seed parameter)\nPostcondition: The returned Generator is properly initialized with the given seed\nand uses PCG64 as the underlying BitGenerator.\n\n/* BitGenerator represents the underlying random number generator engine */\n\n/* Internal state of the generator */\n\n/* Seed used to initialize the generator */\n\n/* Generator provides high-level random number generation methods */\n\n/* The underlying BitGenerator (PCG64 by default) */\n\n/* Whether the generator has been properly initialized */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nstruct BitGenerator {\n\n    state: u64,\n\n    seed: Option<u64>,\n}\n\nstruct Generator {\n\n    bit_generator: BitGenerator,\n\n    initialized: bool,\n}", "vc-helpers": "", "vc-spec": "fn default_rng(seed: Option<u64>) -> (result: Generator)\n    ensures\n        result.initialized == true,\n        result.bit_generator.seed == seed,\n        seed.is_some() ==> result.bit_generator.state != 0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "set_operations_in1d", "vc-description": "Test whether each element of a 1-D array is also present in a second array.\nReturns a boolean array the same length as ar1 that is True where an element \nof ar1 is in ar2 and False otherwise.\n\nSpecification: in1d tests membership of each element of ar1 in ar2.\nThe result is a boolean vector of the same length as ar1, where each element\nindicates whether the corresponding element of ar1 is present in ar2.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn in1d<T: PartialEq>(ar1: Vec<T>, ar2: Vec<T>) -> (result: Vec<bool>)\n    ensures \n        result.len() == ar1.len(),\n        forall|i: int| 0 <= i < ar1.len() ==> \n            result[i] == exists|j: int| 0 <= j < ar2.len() && ar1[i] == ar2[j]", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "set_operations_intersect1d", "vc-description": "Find the intersection of two arrays.\nReturns the sorted, unique values that are in both input arrays.\nSpecification: intersect1d returns a sorted array of unique values \nthat exist in both input arrays\n\n/* Result contains only values that exist in both arrays */\n\n/* Result is sorted in ascending order */\n\n/* Result contains unique values (no duplicates) */\n\n/* Result is complete (contains all common values) */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn intersect1d(ar1: Vec<i32>, ar2: Vec<i32>) -> (result: Vec<i32>)\n    ensures\n\n        forall|i: int| 0 <= i < result.len() ==> \n            (exists|j: int| 0 <= j < ar1.len() && result[i] == ar1[j]) &&\n            (exists|l: int| 0 <= l < ar2.len() && result[i] == ar2[l]),\n\n        forall|i: int, j: int| 0 <= i < j < result.len() ==> result[i] <= result[j],\n\n        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result.len() && i != j ==> result[i] != result[j],\n\n        forall|val: i32| \n            (exists|i: int| 0 <= i < ar1.len() && ar1[i] == val) && \n            (exists|j: int| 0 <= j < ar2.len() && ar2[j] == val) ==>\n            (exists|l: int| 0 <= l < result.len() && result[l] == val)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "set_operations_isin", "vc-description": "numpy.isin: Element-wise test for membership in another array.\n\nCalculates `element in test_elements`, broadcasting over `element` only.\nReturns a boolean array of the same shape as `element` that is True\nwhere an element of `element` is in `test_elements` and False otherwise.\n\nThis is an element-wise function version of the python keyword `in`.\nFor 1-D arrays, this is roughly equivalent to:\n`np.array([item in test_elements for item in element])`\n\nSpecification: numpy.isin returns a boolean vector where each element indicates\nwhether the corresponding element in the input vector is found in test_elements.\n\nPrecondition: True (no special preconditions needed)\nPostcondition: For all indices i, result[i] = true iff element[i] is in test_elements", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_isin(element: Vec<f32>, test_elements: Vec<f32>) -> (result: Vec<bool>)\n    ensures \n        result.len() == element.len(),\n        forall|i: int| 0 <= i < result.len() ==> \n            (result[i] == true <==> exists|j: int| 0 <= j < test_elements.len() && element[i] == test_elements[j])", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "set_operations_setdiff1d", "vc-description": "Find the set difference of two arrays.\nReturn the unique values in ar1 that are not in ar2.\n\nSpecification: setdiff1d returns unique values from ar1 that are not in ar2.\nThe result contains no duplicates and is sorted.\n\n/* Each element in result is from ar1 and not in ar2 */\n\n/* No duplicates in result */\n\n/* Result is sorted */\n\n/* All unique values from ar1 not in ar2 are included */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn setdiff1d(ar1: Vec<i32>, ar2: Vec<i32>) -> (result: Vec<i32>)\n    ensures\n\n        forall|i: int| 0 <= i < result.len() ==>\n            exists|j: int| 0 <= j < ar1.len() && result[i] == ar1[j] &&\n            forall|l: int| 0 <= l < ar2.len() ==> result[i] != ar2[l],\n\n        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result.len() && i != j ==>\n            result[i] != result[j],\n\n        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result.len() && i < j ==>\n            result[i] <= result[j],\n\n        forall|val: i32| \n            (exists|i: int| 0 <= i < ar1.len() && ar1[i] == val &&\n             forall|j: int| 0 <= j < ar2.len() ==> ar2[j] != val) ==>\n            exists|i: int| 0 <= i < result.len() && result[i] == val", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "set_operations_unique", "vc-description": "Find the unique elements of a vector and return them in sorted order.\n\nSpecification: unique returns sorted unique elements from the input vector.\n\n/* Result is sorted */\n\n/* All elements in result come from input array */\n\n/* All elements in result are unique */\n\n/* All elements from input appear in result */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn unique(arr: Vec<i32>) -> (result: Vec<i32>)\n    ensures\n\n        forall|i: int, j: int| 0 <= i < j < result.len() ==> result[i] < result[j],\n\n        forall|i: int| 0 <= i < result.len() ==> exists|j: int| 0 <= j < arr.len() && result[i] == arr[j],\n\n        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result.len() && i != j ==> result[i] != result[j],\n\n        forall|i: int| 0 <= i < arr.len() ==> exists|j: int| 0 <= j < result.len() && arr[i] == result[j],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "sorting_searching_argmax", "vc-description": "numpy.argmax: Returns the index of the maximum value in a vector.\n\nReturns the index of the maximum value among all elements in the array.\nRequires a non-empty array since there is no maximum of an empty set.\n\nIn case of multiple occurrences of the maximum values, the indices\ncorresponding to the first occurrence are returned.\n\nThis function returns the position of the largest element in the array.\n\nSpecification: numpy.argmax returns the index of the maximum element.\n\nPrecondition: True (non-empty constraint is in the type)\nPostcondition: The element at the returned index is the maximum value,\nand it is the first occurrence of such maximum value.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn argmax(a: Vec<i32>) -> (result: usize)\n    requires a.len() > 0,\n    ensures \n        result < a.len(),\n        forall|j: int| 0 <= j < a.len() ==> a[j] <= a[result as int],\n        forall|j: int| 0 <= j < a.len() && a[j] == a[result as int] ==> result <= j as usize,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "sorting_searching_argsort", "vc-description": "Returns the indices that would sort a vector in ascending order. Performs an indirect sort returning an array of indices that would sort the input array in ascending order. For equal elements, maintains relative order (stable sort).\n\n// All indices are valid\n\n// The result represents sorted order\n\n// Stable sort property for equal elements", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn argsort(a: Vec<i32>) -> (result: Vec<usize>)\n    ensures \n        result.len() == a.len(),\n\n        forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i] < a.len(),\n\n        forall|i: int, j: int| 0 <= i < j < result.len() ==> \n            a[#[trigger] result[i] as int] <= a[#[trigger] result[j] as int],\n\n        forall|i: int, j: int| 0 <= i < j < result.len() && \n            a[#[trigger] result[i] as int] == a[#[trigger] result[j] as int] ==> \n            result[i] < result[j]", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "sorting_searching_argwhere", "vc-description": "numpy.argwhere: Find the indices of array elements that are non-zero, grouped by element.\n\nFor a 1D vector, returns a list of indices where elements are non-zero.\nEach index corresponds to a position in the original vector where the element is non-zero.\nThe returned indices are in the same order as they appear in the original vector.\n\nSpecification: numpy.argwhere returns all indices of non-zero elements.\n\nPrecondition: True (no special requirements)\nPostcondition: \n1. All returned indices correspond to non-zero elements in the input vector\n2. All non-zero elements in the input vector have their indices in the result\n3. The result contains no duplicate indices\n4. The indices are ordered according to their position in the original vector\n\n/* All returned indices correspond to non-zero elements */\n\n/* All non-zero elements have their indices in the result */\n\n/* No duplicate indices */\n\n/* Indices are ordered by position */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_argwhere(a: Vec<f64>) -> (indices: Vec<usize>)\n    ensures\n\n        forall|i: int| 0 <= i < indices.len() ==> \n            indices[i] < a.len() && a[indices[i] as int] != 0.0,\n\n        forall|i: int| 0 <= i < a.len() && a[i] != 0.0 ==> \n            indices@.contains(i as usize),\n\n        forall|i: int, j: int| 0 <= i < j < indices.len() ==> \n            indices[i] != indices[j],\n\n        forall|i: int, j: int| 0 <= i < j < indices.len() ==> \n            indices[i] < indices[j],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "sorting_searching_count_nonzero", "vc-description": "Counts the number of non-zero values in a vector.\n\nThe word \"non-zero\" is in reference to the Python 2.x\nbuilt-in method `__nonzero__()` (renamed `__bool__()`\nin Python 3.x) of Python objects that tests an object's\n\"truthfulness\". For example, any number is considered\ntruthful if it is nonzero, whereas any string is considered\ntruthful if it is not the empty string. Thus, this function\ncounts how many elements in the vector are non-zero.\n\nSpecification: count_nonzero returns the number of non-zero elements in the vector.\n\nThe function counts exactly those elements that are not equal to zero.\nThe result is always between 0 and n (inclusive), where n is the length of the vector.\nIf all elements are zero, the result is 0.\nIf all elements are non-zero, the result is n.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn count_nonzero(a: Vec<i32>) -> (count: usize)\n    ensures\n        count <= a.len(),\n        a.len() == 0 ==> count == 0,\n        (forall|i: int| 0 <= i < a.len() ==> a[i] == 0) ==> count == 0,\n        (forall|i: int| 0 <= i < a.len() ==> a[i] != 0) ==> count == a.len(),\n        (exists|i: int| 0 <= i < a.len() && a[i] != 0) ==> count > 0,\n        (exists|i: int| 0 <= i < a.len() && a[i] == 0) ==> count < a.len()", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "sorting_searching_extract", "vc-description": "Return the elements of an array that satisfy some condition.\nThe result size is the number of True entries in the condition array.\n\nSpecification: extract returns elements from arr where condition is True.\nThe result contains exactly those elements from arr at positions where condition is True,\npreserving their original order. The result size m equals the number of True values in condition.\n\n/* Each element in result comes from arr at a position where condition is true */\n\n/* The order is preserved: elements appear in the same relative order as in arr */\n\n/* Every True position in condition contributes exactly one element to the result */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn extract(condition: Vec<bool>, arr: Vec<i32>) -> (result: Vec<i32>)\n    requires condition.len() == arr.len(),\n    ensures\n\n        forall|k: int| 0 <= k < result.len() ==> \n            exists|i: int| 0 <= i < condition.len() && condition[i] && result[k] == arr[i],\n\n        forall|k1: int, k2: int| 0 <= k1 < k2 < result.len() ==>\n            exists|i1: int, i2: int| \n                0 <= i1 < i2 < condition.len() && \n                condition[i1] && condition[i2] &&\n                result[k1] == arr[i1] && result[k2] == arr[i2],\n\n        forall|i: int| 0 <= i < condition.len() && condition[i] ==>\n            exists|k: int| 0 <= k < result.len() && result[k] == arr[i]", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "sorting_searching_flatnonzero", "vc-description": "numpy.flatnonzero: Return indices that are non-zero in the flattened version of a.\n\nThis function returns the indices of all non-zero elements in the array.\nThe returned indices correspond to positions in the flattened array where\nthe elements are non-zero.\n\nFor example, if array is [1, 0, 3, 0, 5], the function returns [0, 2, 4]\nindicating that elements at positions 0, 2, and 4 are non-zero.\n\nSpecification: flatnonzero returns indices of all non-zero elements.\n\nPrecondition: True (no restrictions on input array)\nPostcondition: \n1. All returned indices correspond to non-zero elements in the original array\n2. All non-zero elements in the original array have their indices in the result\n3. The result contains no duplicate indices\n4. The result indices are sorted in ascending order\n\n/* All indices in result point to non-zero elements */\n\n/* All non-zero elements have their indices in result */\n\n/* Result contains no duplicate indices */\n\n/* Result indices are sorted in ascending order */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn flatnonzero(a: Vec<f64>) -> (result: Vec<usize>)\n    ensures\n\n        forall|i: int| 0 <= i < result.len() ==> a[result[i] as int] != 0.0,\n\n        forall|j: int| 0 <= j < a.len() && a[j] != 0.0 ==> exists|k: int| 0 <= k < result.len() && result[k] == j,\n\n        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result.len() && i != j ==> result[i] != result[j],\n\n        forall|i: int, j: int| 0 <= i < j < result.len() ==> result[i] < result[j],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "sorting_searching_msort", "vc-description": "Return a copy of an array sorted along the first axis (ascending order).\nThis is equivalent to np.sort(a, axis=0) in NumPy.\n\nSpecification: msort returns a sorted copy of the input array in ascending order.\nThe result is a permutation of the input array.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn msort(a: Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int, j: int| 0 <= i < j < result.len() ==> result[i] <= result[j],\n        result@.to_multiset() =~= a@.to_multiset(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "sorting_searching_nonzero", "vc-description": "numpy.nonzero: Return the indices of the elements that are non-zero.\n\nReturns a vector of indices where the corresponding elements in the input\narray are non-zero. The indices are returned in row-major, C-style order.\n\nFor a 1D array, this returns a vector containing all indices i such that\na[i] ≠ 0. Since the output size depends on the input values, we use\na Vec structure to accommodate the dynamic nature of the result.\n\nNote: In the full NumPy implementation, this returns a tuple of arrays\n(one for each dimension), but for 1D arrays we simplify to a single vector.\n\nSpecification: numpy.nonzero returns indices of all non-zero elements.\n\nPrecondition: True (no constraints on input)\nPostcondition: \n1. Every index in the result corresponds to a non-zero element in the input\n2. Every non-zero element in the input has its index in the result (completeness)\n3. The indices are in ascending order (preserving array order)\n4. No duplicates in the result", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn nonzero(a: Vec<f32>) -> (indices: Vec<usize>)\n    ensures\n        forall|i: int| 0 <= i < indices.len() ==> (indices[i] < a.len() && a[indices[i] as int] != 0.0f32),\n        forall|j: int| 0 <= j < a.len() ==> (a[j] != 0.0f32 <==> exists|k: int| 0 <= k < indices.len() && indices[k] == j),\n        forall|i1: int, i2: int| 0 <= i1 < i2 < indices.len() ==> indices[i1] < indices[i2],\n        forall|i: int, j: int| 0 <= i < j < indices.len() ==> indices[i] != indices[j],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "sorting_searching_unique", "vc-description": "numpy.unique: Find the unique elements of an array.\n\nReturns the sorted unique elements of an array. This operation removes\nduplicate values and returns them in sorted order. The result contains\neach unique value exactly once.\n\nFor a 1D array, this function eliminates duplicate elements and sorts\nthe remaining unique elements in ascending order.\n\nThe returned array will have size less than or equal to the input array,\nwith equality only when all elements are already unique.\n\nSpecification: numpy.unique returns sorted unique elements without duplicates.\n\nPrecondition: True (no special preconditions)\nPostcondition: The result contains all unique elements from the input array,\nsorted in ascending order, with no duplicates, and every element in the \nresult appears in the original array.\n\n// The result is sorted in ascending order\n\n// No duplicates in the result", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn unique(ar: Vec<i32>) -> (result: (usize, Vec<i32>))\n    ensures\n        result.1.len() <= ar.len(),\n\n        forall|i: int, j: int| 0 <= i < j < result.1.len() ==> result.1[i as int] <= result.1[j as int],\n\n        forall|i: int, j: int| 0 <= i < result.1.len() && 0 <= j < result.1.len() && i != j ==> result.1[i as int] != result.1[j as int],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "sorting_searching_where", "vc-description": "Return elements chosen from x or y depending on condition.\nFor each position i, if condition[i] is True, take x[i], otherwise take y[i].\n\nSpecification: numpy_where returns an array where elements are chosen from x when condition is True,\nand from y when condition is False.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_where(condition: Vec<bool>, x: Vec<f32>, y: Vec<f32>) -> (result: Vec<f32>)\n    requires \n        condition.len() == x.len(),\n        condition.len() == y.len(),\n    ensures \n        result.len() == condition.len(),\n        forall|i: int| 0 <= i < condition.len() ==> \n            (condition[i] ==> result[i] == x[i]) &&\n            (!condition[i] ==> result[i] == y[i])", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "statistics_amax", "vc-description": "Returns the maximum value of all elements in a non-empty vector.\nSpecification: amax returns the maximum value in the vector.\nMathematical properties:\n1. The result is an element that exists in the vector\n2. No element in the vector is greater than the result\n3. The result is unique (first occurrence if there are duplicates)\n4. For constant vectors, amax equals the constant value", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn amax(a: Vec<i32>) -> (result: i32)\n    requires a.len() > 0,\n    ensures\n        (exists|max_idx: int| 0 <= max_idx < a.len() &&\n            result == a@[max_idx] &&\n            (forall|i: int| 0 <= i < a.len() ==> a@[i] <= result)) &&\n        (exists|first_max_idx: int| 0 <= first_max_idx < a.len() &&\n            result == a@[first_max_idx] &&\n            (forall|i: int| 0 <= i < a.len() && a@[i] == result ==> first_max_idx <= i) &&\n            (forall|i: int| 0 <= i < a.len() ==> a@[i] <= result)) &&\n        ((forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() ==> a@[i] == a@[j]) ==> \n            result == a@[0]) &&\n        (exists|witness: int| 0 <= witness < a.len() && result == a@[witness])", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "statistics_amin", "vc-description": "Return the minimum of an array or minimum along an axis.\n\nThis is an alias for numpy.min that returns the minimum value among all elements in the array.\nRequires a non-empty array since there is no minimum of an empty set.\n\nThis is a reduction operation that finds the smallest value in the array.\nNaN values are propagated - if any element is NaN, the result will be NaN.\n\nSpecification: amin returns the minimum element in the vector.\n\nPrecondition: True (non-empty constraint is enforced by type Vector Float (n + 1))\nPostcondition: result is the minimum value and is an element of the vector\n\nProperties:\n1. The result is actually an element of the input vector\n2. The result is less than or equal to all elements in the vector\n3. This captures the mathematical definition of minimum", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn in_array(result: f32, a: Seq<f32>) -> bool {\n    exists|i: int| 0 <= i < a.len() && result == a[i]\n}\n\nfn amin(a: Vec<f32>) -> (result: f32)\n    requires a.len() > 0,\n    ensures in_array(result, a@),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "statistics_average", "vc-description": "Computes the weighted average along the specified axis.\n\nComputes the weighted average of the elements in the input vector.\nIf weights are not provided, it computes the arithmetic mean.\nIf weights are provided, it computes the weighted average where each\nelement contributes according to its associated weight.\n\nThe weighted average is computed as:\nsum(a * weights) / sum(weights)\n\nWhen weights are not provided, this reduces to:\nsum(a) / len(a)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn average(a: Vec<f32>, weights: Option<Vec<f32>>) -> (result: f32)\n    requires \n        a.len() > 0,\n        match weights {\n            Some(w) => w.len() == a.len(),\n            None => true,\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "statistics_histogram", "vc-description": "numpy.histogram: Compute the histogram of a dataset.\n\nComputes the histogram of a dataset by dividing the range into equal-width bins\nand counting the number of values that fall into each bin.\n\nThe function returns both the histogram counts and the bin edges.\nFor n_bins bins, there are n_bins+1 bin edges.\n\nThis implementation focuses on the core mathematical properties:\n- Monotonically increasing bin edges\n- Equal bin widths (uniform binning)\n- Correct counting of values in each bin\n- Conservation of total count\n\nSpecification: histogram correctly partitions data into bins and counts occurrences.\n\nThe histogram satisfies fundamental mathematical properties:\n1. Bin edges are monotonically increasing\n2. The first edge equals min_val and the last edge equals max_val\n3. Bin widths are equal for uniform binning\n4. Each bin count equals the number of data points in that bin\n5. The sum of all bin counts equals the number of data points in range\n\nPrecondition: Number of bins > 0 and min_val < max_val\nPostcondition: The result satisfies the histogram mathematical properties\n\n// Boundary conditions: first edge is min_val, last edge is max_val\n\n// Result histogram has correct length\n\n// Conservation: total count equals number of data points in range", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sum_seq(s: Seq<usize>) -> nat \n    decreases s.len()\n{\n    if s.len() == 0 {\n        0nat\n    } else {\n        (s[0] as nat) + sum_seq(s.drop_first())\n    }\n}", "vc-helpers": "", "vc-spec": "fn histogram(data: Vec<i32>, n_bins: usize, min_val: i32, max_val: i32) -> (result: (Vec<usize>, Vec<i32>))\n    requires\n        n_bins > 0,\n        min_val < max_val,\n    ensures\n\n        result.1.len() == n_bins + 1,\n        result.1[0] == min_val,\n        result.1[(n_bins as int)] == max_val,\n\n        result.0.len() == n_bins,\n\n        sum_seq(result.0@) == data@.filter(|x: i32| min_val <= x && x <= max_val).len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "statistics_histogram2d", "vc-description": "Computes the bi-dimensional histogram of two data samples with equal number of bins.\n\nSpecification: histogram2d computes a 2D histogram from two equal-length vectors.\nMathematical properties:\n1. Input vectors must have the same length (enforced by type system)\n2. The histogram matrix has dimensions (nbins, nbins) where nbins = bins\n3. Each histogram bin counts the number of points falling within its boundaries\n4. The bin edges define the boundaries for both x and y dimensions\n5. The total count equals the input vector length\n6. All histogram values are non-negative\n7. Bin edges are monotonically increasing", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn histogram2d(x: &Vec<i32>, y: &Vec<i32>, bins: usize) -> (result: (Vec<Vec<usize>>, Vec<i32>, Vec<i32>))\n    requires \n        x.len() == y.len(),\n        bins > 0,\n    ensures\n        result.0.len() == bins,\n        forall|i: int| 0 <= i < bins ==> result.0[i].len() == bins,\n        result.1.len() == bins + 1,\n        result.2.len() == bins + 1,\n        forall|i: int, j: int| 0 <= i < bins && 0 <= j < bins ==> result.0[i][j] <= x.len(),\n        forall|i: int| 0 <= i < bins ==> #[trigger] result.1[i] <= result.1[i + 1],\n        forall|i: int| 0 <= i < bins ==> #[trigger] result.2[i] <= result.2[i + 1],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "statistics_histogramdd", "vc-description": "Compute the multidimensional histogram of some data.\nFor simplicity, we focus on 2D histograms with fixed dimensions.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn histogramdd(sample: Vec<(i32, i32)>, bins_x: usize, bins_y: usize) -> (result: (Vec<Vec<i32>>, Vec<i32>, Vec<i32>))\n    requires \n        bins_x > 0,\n        bins_y > 0,\n    ensures \n        ({\n            let (hist, edges_x, edges_y) = result;\n            hist.len() == bins_y &&\n            (forall|i: int| 0 <= i < hist.len() ==> #[trigger] hist[i].len() == bins_x) &&\n            edges_x.len() == bins_x + 1 &&\n            edges_y.len() == bins_y + 1 &&\n            (forall|i: int| 0 <= i < bins_x ==> #[trigger] edges_x[i] < edges_x[i + 1]) &&\n            (forall|i: int| 0 <= i < bins_y ==> #[trigger] edges_y[i] < edges_y[i + 1]) &&\n            (forall|i: int, j: int| 0 <= i < bins_y && 0 <= j < bins_x ==> #[trigger] hist[i][j] >= 0) &&\n            true\n        })", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "statistics_nanmean", "vc-description": "Compute the arithmetic mean along the specified axis, ignoring NaNs.\nReturns the average of the array elements, ignoring NaN values.\nIf all values are NaN, returns NaN.\n\nSpecification: nanmean computes the arithmetic mean while ignoring NaN values.\n\nMathematical properties:\n1. If vector contains valid (non-NaN) values, result is their arithmetic mean\n2. If all values are NaN, result is NaN\n3. Result is never NaN when valid values exist\n4. NaN values are completely ignored in the computation\n5. For vectors without NaN values, behaves identically to regular mean\n6. The result is bounded by the minimum and maximum of non-NaN elements\n\n/* Case 1: If there exists at least one non-NaN element, result is their arithmetic mean */\n\n/* Case 2: If all elements are NaN, result is NaN */\n\n/* Case 3: NaN values are ignored (result is mean of non-NaN elements) */\n\n/* Case 4: For vectors without NaN, behaves like regular mean */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_nan_f32(x: f32) -> bool;\n\nspec fn valid_indices_count(a: Seq<f32>) -> nat\n    decreases a.len()\n{\n    if a.len() == 0 {\n        0\n    } else {\n        if is_nan_f32(a[0]) {\n            valid_indices_count(a.skip(1))\n        } else {\n            1 + valid_indices_count(a.skip(1))\n        }\n    }\n}\n\nspec fn has_valid_element(a: Seq<f32>) -> bool \n{\n    valid_indices_count(a) > 0\n}\n\nspec fn all_nan(a: Seq<f32>) -> bool \n{\n    valid_indices_count(a) == 0\n}\n\nspec fn contains_nan(a: Seq<f32>) -> bool\n    decreases a.len()\n{\n    if a.len() == 0 {\n        false\n    } else {\n        is_nan_f32(a[0]) || contains_nan(a.skip(1))\n    }\n}\n\nfn nanmean(a: Vec<f32>) -> (result: f32)\n    ensures \n\n        (has_valid_element(a@) ==> !is_nan_f32(result)) &&\n\n        (all_nan(a@) ==> is_nan_f32(result)) &&\n\n        (!is_nan_f32(result) ==> has_valid_element(a@)) &&\n\n        (!contains_nan(a@) && a.len() > 0 ==> !is_nan_f32(result))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "statistics_nanmedian", "vc-description": "Compute the median along the specified axis, ignoring NaNs.\nReturns the median of the array elements.\nFor a vector V of length N, the median is the middle value of a sorted copy of V\n(ignoring NaN values), when N is odd, and the average of the two middle values when N is even.\nIf all values are NaN, returns NaN.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn all_nan(a: Seq<f32>) -> bool {\n    forall|i: int| #![auto] 0 <= i < a.len() ==> (a[i] != a[i])\n}\n\nspec fn has_finite_value(a: Seq<f32>) -> bool {\n    exists|i: int| #![auto] 0 <= i < a.len() && (a[i] == a[i])\n}\n\nfn nanmedian(a: Vec<f32>) -> (result: f32)\n    ensures\n        (all_nan(a@) ==> (result != result)) &&\n        (has_finite_value(a@) ==> (result == result))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "statistics_nanvar", "vc-description": "Compute the variance along the specified axis, while ignoring NaNs.\nUses the formula: sum((x - mean)²) / (n - ddof) for non-NaN elements.\nReturns NaN if all elements are NaN or if degrees of freedom <= 0.\n\nSpecification for nanvar: Computes variance while ignoring NaN values.\nMathematical properties:\n1. If vector contains valid (non-NaN) values and ddof < valid_count, \n   result is the variance of valid values\n2. If all values are NaN, result is NaN\n3. If ddof >= valid_count, result is NaN\n4. Result is always non-negative when valid\n\nThe variance is computed as:\n1. Filter out NaN values to get valid values\n2. Calculate the mean of valid values\n3. Calculate squared deviations from the mean for valid values\n4. Sum the squared deviations\n5. Divide by (valid_count - ddof)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn nanvar(a: Vec<f32>, ddof: usize) -> (result: f32)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "statistics_percentile", "vc-description": "Compute the q-th percentile of the data in a vector.\nFor a sorted vector, the q-th percentile is the value below which q percent of the data falls.\nThis implementation focuses on the fundamental mathematical definition of percentiles.\n\nSpecification: percentile computes the q-th percentile value correctly.\nThe percentile is defined as the value v such that at least q% of the data\nis less than or equal to v, and at least (100-q)% of the data is greater than or equal to v.\n\nMathematical properties:\n1. The percentile value must be within the range of the data (or interpolated between values)\n2. Special cases: q=0 gives minimum, q=100 gives maximum\n3. The result is bounded by the minimum and maximum values in the array", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn percentile(arr: Vec<i32>, q: i32) -> (result: i32)\n    requires \n        arr.len() > 0,\n        0 <= q && q <= 100,\n    ensures\n        (forall|i: int| 0 <= i < arr.len() ==> arr[i] <= result ==> \n            exists|j: int| 0 <= j < arr.len() && arr[j] >= result) &&\n        (forall|i: int| 0 <= i < arr.len() ==> arr[i] >= result ==> \n            exists|j: int| 0 <= j < arr.len() && arr[j] <= result) &&\n        (q == 0 ==> forall|i: int| 0 <= i < arr.len() ==> result <= arr[i]) &&\n        (q == 100 ==> forall|i: int| 0 <= i < arr.len() ==> arr[i] <= result)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "statistics_std", "vc-description": "numpy.std: Compute the standard deviation along the specified axis.\n\nReturns the standard deviation, a measure of the spread of a distribution,\nof the array elements. The standard deviation is computed for the flattened\narray by default, otherwise over the specified axis.\n\nThe standard deviation is the square root of the average of the squared\ndeviations from the mean: std = sqrt(mean((x - x.mean())**2)).\n\nWith ddof parameter, the divisor used in calculations is N - ddof,\nwhere N represents the number of elements. The \"Delta Degrees of Freedom\"\nparameter adjusts the divisor in the standard deviation calculation.\n\nSpecification: numpy.std returns the standard deviation of all elements.\n\nThe standard deviation is computed as the square root of the variance:\nstd = sqrt(sum((x_i - mean)²) / (N - ddof))\n\nKey properties:\n1. ddof must be less than the number of elements to avoid division by zero\n2. The result is always non-negative (square root of non-negative variance)\n3. When ddof = 0, uses population standard deviation (divide by N)\n4. When ddof = 1, uses sample standard deviation (divide by N-1)\n5. Mathematical correctness: the formula exactly matches NumPy's implementation", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_std(a: Vec<f32>, ddof: usize) -> (result: f32)\n    requires \n        a.len() > 0,\n        ddof < a.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "statistics_var", "vc-description": "Compute the variance of the elements in a vector with specified delta degrees of freedom.\nThe variance is the average of the squared deviations from the mean.\n\nSpecification: var computes the variance as the average of squared deviations from the mean,\ndivided by (n + 1 - ddof). The variance measures the spread of a distribution.\n\nMathematical properties:\n1. The result is always non-negative\n2. The variance is zero if and only if all elements are equal\n3. The computation requires ddof < n + 1 to ensure a positive divisor\n4. The variance equals the expected value of squared deviations from the mean\n5. Translation invariance: var(a + c) = var(a) for any constant c\n6. Scaling property: var(c * a) = c^2 * var(a) for any constant c\n\nThe variance formula implemented is:\nvar = (1/(n+1-ddof)) * sum_{i=0}^{n} (a[i] - mean)^2\nwhere mean = (1/(n+1)) * sum_{i=0}^{n} a[i]\n\nThis specification captures both the mathematical definition of variance\nand its key properties. When ddof=0, this gives the population variance;\nwhen ddof=1, this gives the sample variance (unbiased estimator).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn vec_sum(a: Seq<int>) -> int \n    decreases a.len()\n{\n    if a.len() == 0 {\n        0\n    } else {\n        a[0] + vec_sum(a.skip(1))\n    }\n}\n\nspec fn vec_mean(a: Seq<int>) -> int \n{\n    vec_sum(a) / (a.len() as int)\n}\n\nspec fn squared_deviations_sum(a: Seq<int>, mean: int) -> int \n    decreases a.len()\n{\n    if a.len() == 0 {\n        0\n    } else {\n        (a[0] - mean) * (a[0] - mean) + squared_deviations_sum(a.skip(1), mean)\n    }\n}\n\nfn var(a: Vec<i32>, ddof: usize) -> (result: i32)\n    requires \n        a.len() > 0,\n        ddof < a.len(),\n    ensures \n        result >= 0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "strings_capitalize", "vc-description": "Return a copy of a with only the first character of each element capitalized", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn capitalize(a: Vec<String>) -> (result: Vec<String>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> #[trigger] result[i]@.len() == a[i]@.len()", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "strings_center", "vc-description": "Return a copy of a with its elements centered in a string of length width.\n\nCenters strings in a field of given width with optional fill character.\nIf the original string length is greater than or equal to the target width,\nthe original string is returned unchanged. Otherwise, the string is padded\nsymmetrically with the fill character to reach the target width.\n\nFrom NumPy documentation:\n- Parameters: a (array_like with StringDType), width (array_like with integer dtype), \n              fillchar (optional, default ' ') - The padding character\n- Returns: out (ndarray) - Output array with centered strings\n\nMathematical Properties:\n1. Length preservation: If original.length >= width, return original unchanged\n2. Symmetric padding: If original.length < width, pad equally on both sides\n3. Padding balance: Left and right padding differ by at most 1 character\n4. Character preservation: Original string appears as substring in result\n5. Width compliance: Result length equals max(original.length, width)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn center(a: Vec<String>, width: Vec<usize>, fillchar: char) -> (result: Vec<String>)\n    requires \n        a.len() == width.len(),\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> \n            #[trigger] result[i]@.len() >= 0 && {\n                let orig_len = a[i]@.len() as int;\n                let target_width = width[i] as int;\n                &&& (orig_len >= target_width ==> result[i] == a[i])\n                &&& result[i]@.len() as int == if orig_len >= target_width { orig_len } else { target_width }\n            }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "strings_count", "vc-description": "numpy.strings.count: Returns an array with the number of non-overlapping occurrences \nof substring sub in the range [start, end] for each element.\n\nFor each string in the input array, counts how many times the substring appears\nwithout overlapping matches within the specified range. The search is performed\nwithin the range [start, end) where start and end are character indices.\n\nSpecification: numpy.strings.count returns the number of non-overlapping occurrences \nof substring within the specified range for each element.\n\nPreconditions:\n- start ≤ end for all elements (valid range)\n- start and end indices are valid (within string bounds)\n- substring is not empty for all elements (to avoid infinite loops)\n\nPostconditions:\n- Result is non-negative for all elements\n- For each element, the count represents non-overlapping occurrences of substring\n- If substring is longer than search range, count is 0\n- The count is maximal (greedy non-overlapping matching)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn count(a: Vec<String>, sub: Vec<String>, start: Vec<i32>, end_pos: Vec<i32>) -> (result: Vec<i32>)\n    requires \n        a.len() == sub.len(),\n        a.len() == start.len(),\n        a.len() == end_pos.len(),\n        forall|i: int| 0 <= i < a.len() ==> start[i] <= end_pos[i],\n        forall|i: int| 0 <= i < a.len() ==> 0 <= start[i] && start[i] <= a[i]@.len(),\n        forall|i: int| 0 <= i < a.len() ==> 0 <= end_pos[i] && end_pos[i] <= a[i]@.len(),\n        forall|i: int| 0 <= i < a.len() ==> sub[i]@.len() > 0,\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] >= 0,\n        forall|i: int| 0 <= i < result.len() ==> \n            (sub[i]@.len() > (end_pos[i] - start[i]) ==> result[i] == 0)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "strings_equal", "vc-description": "numpy.strings.equal: Return (x1 == x2) element-wise for string arrays.\n\nPerforms element-wise string comparison between two vectors of strings.\nReturns a boolean vector indicating whether corresponding strings are equal.\n\nThis function compares strings lexicographically and returns True for each\nposition where the strings are identical, False otherwise.\n\nSpecification: numpy.strings.equal returns element-wise equality comparison.\n\nPrecondition: True (no special preconditions for string equality)\nPostcondition: For all indices i, result[i] = (x1[i] == x2[i])\n\nMathematical Properties:\n- Core property: Each element of result is the boolean comparison of corresponding strings\n- Equivalence: result[i] is true if and only if x1[i] equals x2[i]\n- Reflexivity: If input vectors are identical, all result elements are true\n- Type-safe: Result vector has same length as input vectors", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn equal(x1: Vec<String>, x2: Vec<String>) -> (result: Vec<bool>)\n    requires x1.len() == x2.len(),\n    ensures\n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == (x1[i] == x2[i]),\n        forall|i: int| 0 <= i < result.len() ==> (result[i] == true <==> x1[i] == x2[i]),\n        x1@ == x2@ ==> forall|i: int| 0 <= i < result.len() ==> result[i] == true,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "strings_expandtabs", "vc-description": "Return a copy of each string element where all tab characters are replaced by spaces\n\nExpand tabs in strings to spaces with configurable tab size\n\nSpecification: expandtabs replaces tab characters with appropriate number of spaces\n\n/* Core property: result contains no tab characters */\n\n/* Identity property: strings without tabs remain unchanged */\n\n/* Length property: result is at least as long as original */\n\n/* Tab expansion property: tabs are replaced by 1 to tab_sz spaces */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn expandtabs(a: Vec<String>, tabsize: Vec<usize>) -> (result: Vec<String>)\n    requires \n        a.len() == tabsize.len(),\n        forall|i: int| 0 <= i < tabsize.len() ==> tabsize[i] > 0,\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> {\n            let orig_str = &a[i];\n            let result_str = &result[i];\n            let tab_sz = tabsize[i];\n\n            (forall|c: char| result_str@.contains(c) ==> c != '\\t') &&\n\n            (!orig_str@.contains('\\t') ==> result_str@ == orig_str@) &&\n\n            (result_str@.len() >= orig_str@.len()) &&\n\n            (orig_str@.contains('\\t') ==> result_str@.len() > orig_str@.len())\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "strings_find", "vc-description": "For each element, return the lowest index in the string where substring sub is found, such that sub is contained in the range [start, end]. Returns -1 if sub is not found.\n\n// Case 1: substring not found (returns -1)\n\n// Case 2: substring found (returns non-negative index)\n\n// Empty substring found at start position\n\n// Substring longer than remaining string cannot be found\n\n// If start > end, no substring can be found", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn find_substring_at(haystack: Seq<char>, needle: Seq<char>, pos: int) -> bool {\n    pos >= 0 && pos + needle.len() <= haystack.len() &&\n    haystack.subrange(pos, pos + needle.len()) == needle\n}\n\nfn find(a: Vec<String>, sub: Vec<String>, start: Vec<i32>, end_pos: Vec<i32>) -> (result: Vec<i32>)\n    requires \n        a.len() == sub.len() && \n        sub.len() == start.len() && \n        start.len() == end_pos.len(),\n        forall|i: int| 0 <= i < a.len() ==> \n            0 <= start[i] && \n            start[i] <= end_pos[i] && \n            end_pos[i] < a[i]@.len(),\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> {\n\n            (result[i] == -1 <==> \n                forall|pos: int| start[i] <= pos && pos <= end_pos[i] && pos + sub[i]@.len() <= a[i]@.len() ==>\n                    !find_substring_at(a[i]@, sub[i]@, pos)) &&\n\n            (result[i] >= 0 ==> \n                start[i] <= result[i] && \n                result[i] <= end_pos[i] &&\n                result[i] + sub[i]@.len() <= a[i]@.len() &&\n                find_substring_at(a[i]@, sub[i]@, result[i] as int) &&\n                forall|pos: int| start[i] <= pos && pos < result[i] ==> \n                    !find_substring_at(a[i]@, sub[i]@, pos)) &&\n\n            (sub[i]@.len() == 0 ==> result[i] == start[i]) &&\n\n            (start[i] + sub[i]@.len() > a[i]@.len() ==> result[i] == -1) &&\n\n            (start[i] > end_pos[i] ==> result[i] == -1)\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "strings_greater", "vc-description": "numpy.strings.greater: Return the truth value of (x1 > x2) element-wise for string arrays.\n\nPerforms element-wise string comparison between two vectors of strings.\nReturns a boolean vector indicating whether corresponding strings from x1 \nare lexicographically greater than corresponding strings from x2.\n\nThis function compares strings lexicographically and returns True for each\nposition where x1[i] > x2[i] in lexicographic ordering, False otherwise.\n\nSpecification: numpy.strings.greater returns element-wise lexicographic comparison.\n\nPrecondition: True (no special preconditions for string comparison)\nPostcondition: For all indices i, result[i] = (x1[i] > x2[i])\n\nMathematical Properties:\n- Asymmetric: if greater x1 x2 is True at position i, then greater x2 x1 is False at position i\n- Transitive: if greater x1 x2 and greater x2 x3 are both True at position i, then greater x1 x3 is True at position i\n- Irreflexive: greater x x returns all False (no string is greater than itself)\n- Trichotomous: for any two strings s1 and s2, exactly one of s1 < s2, s1 = s2, or s1 > s2 holds\n- Decidable: String comparison is decidable for all strings\n- Type-safe: Result vector has same length as input vectors\n\n/* Core property: result[i] = (x1[i] > x2[i]) for all indices */\n\n/* Asymmetry: if x1[i] > x2[i], then NOT (x2[i] > x1[i]) */\n\n/* Irreflexivity: no string is greater than itself */", "vc-preamble": "use vstd::prelude::*;\nuse vstd::string::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn string_compare_gt(s1: Seq<char>, s2: Seq<char>) -> bool;\n\nfn greater(x1: &Vec<String>, x2: &Vec<String>) -> (result: Vec<bool>)\n    requires x1.len() == x2.len(),\n    ensures \n        result.len() == x1.len(),\n\n        forall|i: int| 0 <= i < result.len() ==> \n            result[i] == string_compare_gt(x1[i]@, x2[i]@),\n\n        forall|i: int| 0 <= i < result.len() ==> \n            result[i] ==> !string_compare_gt(x2[i]@, x1[i]@),\n\n        forall|i: int| 0 <= i < result.len() ==> \n            (x1[i]@ == x2[i]@) ==> (result[i] == false),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "strings_index", "vc-description": "Like find, but raises ValueError when the substring is not found. For each element, return the lowest index in the string where substring is found. Unlike find, this function requires that the substring be found in each string, ensuring all results are non-negative indices. Specification: index returns the lowest index where substring is found within range. The key difference from find is that index has a stronger precondition: the substring must exist in each string within the specified range.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn index(a: Vec<Seq<char>>, sub: Vec<Seq<char>>, start: Vec<int>, end_pos: Vec<int>) -> (result: Vec<int>)\n    requires \n        a.len() == sub.len() && sub.len() == start.len() && start.len() == end_pos.len(),\n        forall|i: int| 0 <= i < a.len() ==> {\n            &&& start[i] >= 0 \n            &&& start[i] <= end_pos[i]\n            &&& end_pos[i] <= a[i].len() as int\n            &&& sub[i].len() > 0\n        },\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> {\n            &&& result[i] >= 0\n            &&& start[i] <= result[i] <= end_pos[i]\n            &&& result[i] + sub[i].len() as int <= a[i].len() as int\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "strings_isalnum", "vc-description": "Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise.\n\nFor each string in the input vector, this function checks if:\n1. The string is non-empty (has at least one character)\n2. All characters in the string are alphanumeric (letters or digits)\n\nReturns a boolean vector where True indicates the string meets both criteria,\nand False indicates the string is either empty or contains non-alphanumeric characters.\n\nThis follows the Python str.isalnum() behavior which returns False for empty strings\nand True only if all characters are alphanumeric.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_alphanumeric_char(c: char) -> bool;\n\nspec fn all_chars_alphanumeric(s: Seq<char>) -> bool\n    decreases s.len()\n{\n    if s.len() == 0 {\n        true\n    } else {\n        is_alphanumeric_char(s[0]) && all_chars_alphanumeric(s.skip(1))\n    }\n}\n\nfn isalnum(a: Vec<String>) -> (result: Vec<bool>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> \n            result[i] == (a[i]@.len() > 0 && all_chars_alphanumeric(a[i]@))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "strings_isdigit", "vc-description": "Returns true for each element if all characters in the string are digits, and there is at least one character, false otherwise\n\nnumpy.strings.isdigit: Returns true for each element if all characters in the string are digits, and there is at least one character, false otherwise.\n\nTests whether all characters in each string are digits.\nA string is considered to satisfy isdigit if:\n1. It contains at least one character (non-empty)\n2. All characters are digits (0-9)\n\nEmpty strings return false.\nStrings with any non-digit characters return false.\nStrings with only digits return true.\n\nThis follows the Python str.isdigit() behavior which returns False for empty strings\nand True only if all characters are numeric digits.\n\nSpecification: numpy.strings.isdigit returns a vector where each element indicates\nwhether the corresponding string element contains only digits and is non-empty.\n\nPrecondition: True (no special preconditions)\nPostcondition: For all indices i, result[i] = true if and only if:\n1. The string a[i] is non-empty (not equal to empty string)\n2. All characters in a[i] are digits (satisfy Char.isDigit)\n\nProperties:\n- Empty strings return False\n- Strings with only numeric characters (0-9) return True\n- Strings with any non-numeric characters return False\n- Single digit characters return True", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn all_chars_digit(s: Seq<char>) -> bool;\n\nfn isdigit(a: Vec<String>) -> (result: Vec<bool>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> result[i] == (a[i]@.len() > 0 && all_chars_digit(a[i]@))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "strings_isspace", "vc-description": "Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise\n\nnumpy.strings.isspace: Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise.\n\nTests whether all characters in each string are whitespace characters.\nA string is considered whitespace if:\n1. It contains at least one character (non-empty)\n2. All characters are whitespace (space, tab, newline, form feed, carriage return, etc.)\n\nBehavior:\n- Empty strings return false\n- Strings with only whitespace characters return true\n- Strings with any non-whitespace character return false\n\nExamples:\n- \" \" (single space) → true\n- \"\\t\" (tab) → true  \n- \"\\n\" (newline) → true\n- \"  \\t\\n  \" (mixed whitespace) → true\n- \"\" (empty string) → false\n- \"a\" (letter) → false\n- \" a \" (space + letter + space) → false\n\nSpecification: numpy.strings.isspace returns a vector where each element indicates\nwhether the corresponding string element contains only whitespace characters\nand has at least one character.\n\nThe function performs element-wise whitespace checking with the following properties:\n1. Empty strings always return false\n2. Strings with only whitespace characters return true\n3. Strings with any non-whitespace character return false\n4. Common whitespace characters include: space, tab, newline, carriage return, etc.\n\nPrecondition: True (no special preconditions)\nPostcondition: For all indices i, result[i] = true if and only if:\n1. The string a[i] is non-empty\n2. All characters in a[i] are whitespace characters", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_whitespace_char(c: char) -> bool {\n    c == ' ' || c == '\\t' || c == '\\n' || c == '\\r' || c == '\\x0c'\n}\n\nspec fn all_chars_whitespace(s: Seq<char>) -> bool \n    decreases s.len()\n{\n    if s.len() == 0 {\n        true\n    } else {\n        is_whitespace_char(s[0]) && all_chars_whitespace(s.skip(1))\n    }\n}\n\nfn isspace(a: Vec<String>) -> (result: Vec<bool>)\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> \n            result[i] == (a[i]@.len() > 0 && all_chars_whitespace(a[i]@)),\n        forall|i: int| 0 <= i < a.len() ==> \n            (a[i]@.len() == 0 ==> result[i] == false),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "strings_istitle", "vc-description": "numpy.strings.istitle: Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise.\n\nA string is considered titlecased if:\n1. It contains at least one character\n2. Each word starts with an uppercase letter followed by lowercase letters\n3. Words are separated by non-alphabetic characters\n4. There is at least one cased character in the string\n\nExamples:\n- \"Title Case\" → True\n- \"Numpy Is Great\" → True  \n- \"numpy is great\" → False\n- \"NUMPY IS GREAT\" → False\n- \"\" → False\n- \"123\" → False\n\n/* Helper function to check if a string is titlecased according to Python's str.istitle() logic */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_titlecased(s: Seq<char>) -> bool;", "vc-helpers": "", "vc-spec": "fn istitle(a: Vec<String>) -> (result: Vec<bool>)\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> result[i] == is_titlecased(a[i]@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "strings_join", "vc-description": "Return a string which is the concatenation of the strings in the sequence seq.\n\nnumpy.strings.join: Return a string which is the concatenation of the strings in the sequence seq.\n\nFor each pair of separator and sequence, join the elements of the sequence using the separator.\nThis function operates element-wise on vectors, where each element of the result is obtained\nby joining the corresponding elements of the sequence vector using the corresponding separator.\n\nThe function treats each string in the sequence as a sequence of characters, and joins them\nwith the separator string. For example, join('-', 'abc') produces 'a-b-c'.\n\nFrom NumPy documentation:\n- Parameters: sep (array_like) - Separator string(s), seq (array_like) - Sequence(s) to join\n- Returns: out (ndarray) - Output array with joined strings\n- Examples: join('-', 'osd') → 'o-s-d', join(['-', '.'], ['ghc', 'osd']) → ['g-h-c', 'o.s.d']\n\nMathematical Properties:\n1. Element-wise operation: result[i] = join(sep[i], seq[i])\n2. Character separation: joins individual characters of each string in seq\n3. Empty separator handling: join('', s) = s (no separation)\n4. Empty sequence handling: join(sep, '') = '' (empty result)\n5. Single character sequences: join(sep, 'a') = 'a' (no separator needed)\n\n/* Core correctness property */\n\n/* Length property for non-trivial cases */\n\n/* Empty string preservation */\n\n/* Single character preservation */\n\n/* Non-empty result for non-empty input */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn join_chars(separator: Seq<char>, chars: Seq<char>) -> Seq<char>\n    decreases chars.len()\n{\n    if chars.len() <= 1 {\n        chars\n    } else {\n        chars.take(1) + separator + join_chars(separator, chars.skip(1))\n    }\n}\n\nspec fn string_to_chars(s: Seq<char>) -> Seq<char> {\n    s\n}\n\nspec fn chars_to_string_len(chars: Seq<char>) -> nat {\n    chars.len()\n}\n\nfn join(sep: Vec<String>, seq: Vec<String>) -> (result: Vec<String>)\n    requires sep.len() == seq.len(),\n    ensures\n        result.len() == sep.len(),\n        forall|i: int| 0 <= i < result.len() ==> {\n            let s = seq[i]@;\n            let separator = sep[i]@;\n\n            (s.len() <= 1 ==> result[i]@ == s) &&\n            (s.len() > 1 ==> result[i]@ == join_chars(separator, s)) &&\n\n            (s.len() > 1 ==> result[i]@.len() == s.len() + (s.len() - 1) * separator.len()) &&\n\n            (s.len() == 0 ==> result[i]@.len() == 0) &&\n\n            (s.len() == 1 ==> result[i]@ == s) &&\n\n            (s.len() > 0 ==> result[i]@.len() > 0)\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "strings_less", "vc-description": "numpy.strings.less: Return the truth value of (x1 < x2) element-wise for string arrays.\n\nPerforms element-wise string comparison between two vectors of strings.\nReturns a boolean vector indicating whether corresponding strings from x1 \nare lexicographically less than corresponding strings from x2.\n\nThis function compares strings lexicographically and returns True for each\nposition where x1[i] < x2[i] in lexicographic ordering, False otherwise.\n\nSpecification: numpy.strings.less returns element-wise lexicographic comparison.\n\nThis function performs element-wise lexicographic comparison between two vectors\nof strings, returning a boolean vector where each element indicates whether\nthe corresponding element in x1 is lexicographically less than the corresponding\nelement in x2.\n\nPrecondition: True (no special preconditions for string comparison)\nPostcondition: For all indices i, result[i] = (x1[i] < x2[i])\n\nMathematical Properties:\n- Asymmetric: if less x1 x2 is True at position i, then less x2 x1 is False at position i\n- Transitive: if less x1 x2 and less x2 x3 are both True at position i, then less x1 x3 is True at position i\n- Irreflexive: less x x returns all False (no string is less than itself)\n- Trichotomous: for any two strings s1 and s2, exactly one of s1 < s2, s1 = s2, or s1 > s2 holds\n- Decidable: String comparison is decidable for all strings\n- Type-safe: Result vector has same length as input vectors\n\nString Comparison Properties:\n- Empty string is less than any non-empty string\n- Lexicographic ordering follows dictionary order (case-sensitive)\n- Comparison is based on Unicode code point values\n- Preserves strict ordering properties of the underlying string type\n\n/* Core property: result[i] = (x1[i] < x2[i]) for all indices */\n\n/* Asymmetry: if x1[i] < x2[i], then NOT (x2[i] < x1[i]) */\n\n/* Irreflexivity: no string is less than itself */\n\n/* Decidability: result is always boolean (true or false) */\n\n/* Strict ordering: if result[i] is true, then x1[i] and x2[i] are different */\n\n/* Totality of comparison: for any two strings, exactly one of <, =, > holds */", "vc-preamble": "use vstd::prelude::*;\nuse vstd::string::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn str_less_than(s1: String, s2: String) -> bool;\n\nfn less(x1: Vec<String>, x2: Vec<String>) -> (result: Vec<bool>)\n    requires x1.len() == x2.len(),\n    ensures \n        result.len() == x1.len(),\n\n        forall|i: int| 0 <= i < result.len() ==> result[i] == str_less_than(x1[i], x2[i]),\n\n        forall|i: int| 0 <= i < result.len() && result[i] == true ==> !str_less_than(x2[i], x1[i]),\n\n        forall|i: int| 0 <= i < result.len() && x1[i] == x2[i] ==> result[i] == false,\n\n        forall|i: int| 0 <= i < result.len() ==> result[i] == true || result[i] == false,\n\n        forall|i: int| 0 <= i < result.len() && result[i] == true ==> x1[i] != x2[i],\n\n        forall|i: int| 0 <= i < result.len() ==> result[i] == true || x1[i] == x2[i] || str_less_than(x2[i], x1[i])", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "strings_less_equal", "vc-description": "numpy.strings.less_equal: Return the truth value of (x1 <= x2) element-wise for string arrays.\n\nPerforms element-wise string comparison between two vectors of strings.\nReturns a boolean vector indicating whether each string in x1 is lexicographically \nless than or equal to the corresponding string in x2.\n\nThis function compares strings lexicographically and returns True for each\nposition where x1[i] <= x2[i], False otherwise.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn string_le(s1: String, s2: String) -> bool;\n\nfn less_equal(x1: Vec<String>, x2: Vec<String>) -> (result: Vec<bool>)\n    requires x1.len() == x2.len(),\n    ensures \n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == string_le(x1[i], x2[i]),\n        forall|i: int| 0 <= i < result.len() ==> (result[i] == true <==> string_le(x1[i], x2[i])),\n        x1@ == x2@ ==> forall|i: int| 0 <= i < result.len() ==> result[i] == true,\n        forall|i: int| 0 <= i < result.len() ==> (string_le(x1[i], x2[i]) && string_le(x2[i], x1[i])) ==> x1[i] == x2[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "strings_lstrip", "vc-description": "numpy.strings.lstrip: For each element in a vector, return a copy with the leading characters removed.\n\nRemoves leading characters from each string element in the input vector. The behavior\ndepends on the chars parameter:\n- If chars is None, whitespace characters are removed from the beginning\n- If chars is provided, any combination of those characters is removed from the beginning\n\nThe function preserves the shape of the input array and handles empty strings\nappropriately by returning them unchanged.\n\nFrom NumPy documentation:\n- Parameters: a (array_like) - Input array with string dtype\n              chars (optional) - Characters to remove from the beginning\n- Returns: out (ndarray) - Output array with leading characters removed\n\nMathematical Properties:\n1. Element-wise transformation: result[i] = lstrip(a[i], chars) for all i\n2. Length preservation or reduction: result[i].length ≤ a[i].length for all i\n3. Prefix removal: result[i] is a suffix of a[i] for all i\n4. Character set removal: only characters in chars are removed from the beginning\n5. Preserves vector length: result.size = a.size\n\n/* Length preservation or reduction */\n\n/* Suffix property: result is a suffix of original */\n\n/* Empty string case: if original is empty, result is empty */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn lstrip(a: Vec<String>, chars: Option<String>) -> (result: Vec<String>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> {\n            let original = #[trigger] a[i];\n            let result_str = #[trigger] result[i];\n\n            result_str@.len() <= original@.len() &&\n\n            (exists|k: int| 0 <= k <= original@.len() && \n             result_str@ == original@.subrange(k, original@.len() as int)) &&\n\n            (original@.len() == 0 ==> result_str@.len() == 0)\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "strings_mod", "vc-description": "numpy.strings.mod: Return (a % i), that is pre-Python 2.6 string formatting \n(interpolation), element-wise for a pair of array_likes of string objects.\n\nThis function performs string formatting element-wise on vectors of format strings \nand replacement values. Each element of the result is the formatted string obtained \nby interpolating the corresponding value into the format string.\n\nThis is equivalent to Python's old-style string formatting using the % operator \nfor each element pair. The function handles various format specifiers like %s, %i, \n%f, etc., and produces appropriately formatted strings.\n\nFrom NumPy documentation:\n- Parameters: a (array_like) - Format strings with placeholders\n              values (array_like) - Values to interpolate into format strings\n- Returns: out (ndarray) - The formatted strings, element-wise\n\nMathematical Properties:\n1. Element-wise formatting: result[i] = format(a[i], values[i])\n2. Preserves vector length: result.size = a.size = values.size\n3. Format correctness: each result follows the format specification\n4. Type preservation: maintains string type characteristics\n5. Handles various format specifiers: %s, %i, %f, %d, etc.\n\nSpecification: numpy.strings.mod returns a vector where each element is the \nresult of formatting the corresponding format string with its value.\n\nMathematical Properties:\n1. Identity Property: Format strings without % specifiers remain unchanged\n2. Substitution Property: Format strings with % specifiers get interpolated\n3. Empty String Property: Empty format strings produce empty results\n4. Non-empty Preservation: Non-empty format strings with specifiers produce non-empty results\n5. Length Monotonicity: Result length is non-negative and preserves structural properties\n6. Format Preservation: The result maintains the original format structure with substitutions\n\nKey format specifiers handled:\n- %s: String representation\n- %i, %d: Integer formatting\n- %f: Floating point formatting\n- %x, %X: Hexadecimal formatting\n- And other standard format specifiers\n\nPrecondition: True (function handles format string validation internally)\nPostcondition: For all indices i, result[i] represents the formatted string\n              where format string a[i] is applied to value values[i], satisfying\n              the mathematical properties of string formatting operations", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn mod_func(a: Vec<String>, values: Vec<String>) -> (result: Vec<String>)\n    requires a.len() == values.len(),\n    ensures \n        result.len() == a.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "strings_not_equal", "vc-description": "numpy.strings.not_equal: Return (x1 != x2) element-wise for string arrays.\n\nPerforms element-wise string inequality comparison between two vectors of strings.\nReturns a boolean vector indicating whether corresponding strings are not equal.\n\nThis function compares strings lexicographically and returns True for each\nposition where the strings are different, False where they are identical.\n\nSpecification: numpy.strings.not_equal returns element-wise inequality comparison.\n\nPrecondition: True (no special preconditions for string inequality)\nPostcondition: For all indices i, result[i] = (x1[i] != x2[i])\n\nMathematical Properties:\n- Irreflexive: not_equal x x returns all False\n- Symmetric: not_equal x y = not_equal y x  \n- Negation of equality: not_equal x y = ¬(equal x y)\n- Decidable: String inequality is decidable for all strings\n- Type-safe: Result vector has same length as input vectors\n- Complementary: for any two strings s1 and s2, exactly one of (s1 = s2) or (s1 ≠ s2) holds", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn not_equal(x1: Vec<String>, x2: Vec<String>) -> (result: Vec<bool>)\n    requires x1.len() == x2.len(),\n    ensures \n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == (x1[i] != x2[i])", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "strings_partition", "vc-description": "numpy.strings.partition: Partition each element in a around sep.\n\nPartitions each string in the input vector at the first occurrence of the separator.\nReturns a 3-tuple of vectors: (before_separator, separator, after_separator).\n\nFor each element in the input array, splits the element at the first occurrence\nof the separator, and returns three vectors containing the part before the separator,\nthe separator itself, and the part after the separator. If the separator is not found,\nthe first vector contains the whole string, and the second and third vectors contain\nempty strings.\n\nFrom NumPy documentation:\n- Parameters: a (array_like with StringDType), sep (array_like with StringDType)\n- Returns: 3-tuple of ndarrays with StringDType\n\nMathematical Properties:\n1. Partition semantics: For each string s, if sep occurs at position i, then:\n   - before = s[0:i]\n   - separator = sep (if found) or \"\" (if not found)\n   - after = s[i+len(sep):] (if found) or \"\" (if not found)\n2. Completeness: before ++ separator ++ after = original string (when sep is found)\n3. First occurrence: Only splits at the first occurrence of sep\n4. Not found case: If sep not in string, returns (original_string, \"\", \"\")\n5. Preserves vector length: All three result vectors have the same length as input\n\nSpecification: numpy.strings.partition returns a 3-tuple of vectors where each\nelement is partitioned around the first occurrence of the separator.\n\nMathematical Properties:\n1. Partition correctness: For each index i, the result satisfies partition semantics\n2. Completeness: When separator is found, concatenation reconstructs original string\n3. First occurrence: Only the first occurrence of separator is used for partitioning\n4. Not found case: When separator is not found, returns (original, \"\", \"\")\n5. Preserves vector length: All result vectors have the same length as input\n6. Separator consistency: The separator part contains the actual separator or empty string\n\nPrecondition: True (no special preconditions for string partitioning)\nPostcondition: For all indices i, the partition satisfies the partition semantics\n\n/* Fundamental partition property: parts reconstruct original string */\n\n/* Separator correctness: either the separator or empty string */\n\n/* Case 2: Separator not found - before contains whole string, others empty */\n\n/* Length preservation: total length is preserved */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn partition(a: Vec<String>, sep: String) -> (result: (Vec<String>, Vec<String>, Vec<String>))\n    ensures\n        result.0.len() == a.len() && result.1.len() == a.len() && result.2.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> {\n            let original = #[trigger] a[i]@;\n            let before_i = result.0[i]@;\n            let sep_i = result.1[i]@;\n            let after_i = result.2[i]@;\n\n            before_i + sep_i + after_i == original &&\n\n            (sep_i == sep@ || sep_i.len() == 0) &&\n\n            (sep_i.len() == 0 ==> after_i.len() == 0 && before_i == original) &&\n\n            original.len() == before_i.len() + sep_i.len() + after_i.len()\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "strings_replace", "vc-description": "numpy.strings.replace: For each element in a, return a copy of the string with \noccurrences of substring old replaced by new.\n\nReplaces occurrences of the substring 'old' with 'new' in each string element.\nThe replacement is done from left to right, and if count is specified, only\nthe first 'count' occurrences are replaced. If count is -1 or negative,\nall occurrences are replaced.\n\nSpecification for numpy.strings.replace: Returns a vector where each element is the\nresult of replacing occurrences of old substring with new substring.\n\nMathematical Properties:\n1. Element-wise replacement: Each result element is the original string with replacements\n2. Count limiting: If count[i] >= 0, at most count[i] replacements are made\n3. Complete replacement: If count[i] < 0, all occurrences are replaced\n4. Identity preservation: If old[i] doesn't occur in a[i], result[i] = a[i]\n5. Zero count behavior: If count[i] = 0, no replacements occur\n\n/* Zero count behavior: if count is 0, no replacements occur */\n\n/* Identity property: if old doesn't occur in string, result equals original */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn replace(a: Vec<String>, old: Vec<String>, new: Vec<String>, count: Vec<i32>) -> (result: Vec<String>)\n    requires \n        a.len() == old.len() && old.len() == new.len() && new.len() == count.len(),\n        forall|i: int| 0 <= i < count.len() ==> (count[i] == 0 || old[i]@.len() > 0),\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> {\n\n            (count[i] == 0 ==> result[i] == a[i]) &&\n\n            (old[i]@.len() == 0 ==> result[i] == a[i])\n        },", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "strings_rjust", "vc-description": "Return an array with the elements of a right-justified in a string of length width.\n\nRight-justifies each string in the input array by padding it with the specified\nfill character (default is space) to reach the specified width. If the original\nstring is longer than or equal to the width, it remains unchanged.\n\nParameters:\n- a: Input array of strings\n- width: Target width for each string\n- fillchar: Character to use for padding (must be exactly one character)\n\nReturns:\n- Array where each string is right-justified to the specified width\n\nMathematical Properties:\n1. Length preservation: If original.length >= width, return original unchanged\n2. Right-justification: If original.length < width, pad on the left with fillchar\n3. Padding placement: Original string appears as suffix in the result\n4. Character preservation: Original string appears as contiguous substring\n5. Width compliance: Result length equals max(original.length, width)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn max_nat(a: nat, b: nat) -> nat {\n    if a >= b { a } else { b }\n}\n\nspec fn is_suffix_of<T>(suffix: Seq<T>, full: Seq<T>) -> bool {\n    suffix.len() <= full.len() && \n    full.subrange(full.len() - suffix.len(), full.len() as int) == suffix\n}", "vc-helpers": "", "vc-spec": "fn rjust(orig: Vec<char>, width: nat, fillchar: char) -> (res: Vec<char>)\n    ensures\n        res.len() == max_nat(orig.len() as nat, width),\n        (orig.len() >= width ==> res@ == orig@) &&\n        (orig.len() < width ==> res.len() == width && is_suffix_of(orig@, res@)) &&\n        (orig.len() >= width ==> res.len() == orig.len()) &&\n        (orig.len() < width ==> res.len() == width) &&\n        (orig.len() == 0 ==> res.len() == width)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "strings_rstrip", "vc-description": "For each element in a vector, return a copy with the trailing characters removed.\n\nSpecification: numpy.strings.rstrip removes trailing characters from each string in the vector.\n\nrstrip removes trailing characters from the end of each string. If chars is None, \nwhitespace characters are removed. If chars is provided, any combination of those \ncharacters is removed from the end.\n\nMathematical Properties:\n1. Element-wise transformation: Each string is processed independently\n2. Trailing character removal: Only characters at the end are removed\n3. Maximal stripping: Remove as many trailing characters as possible\n4. Character set filtering: Only characters in the specified set are removed\n5. Whitespace default: When chars is None, whitespace characters are removed\n\nFrom NumPy documentation:\n- Parameters: a (array_like) - Input array with string dtype\n              chars (optional) - Characters to remove, whitespace if None\n- Returns: out (ndarray) - Output array with trailing characters removed", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn rstrip(a: Vec<String>, chars: Option<String>) -> (result: Vec<String>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> #[trigger] result[i]@.len() <= a[i]@.len()", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "strings_splitlines", "vc-description": "For each element in a, return a list of the lines in the element, breaking at line boundaries\n\nFor each element in a vector of strings, return a list of the lines in the element, breaking at line boundaries \n\nSpecification: splitlines returns a vector where each string is split into a list of lines\nbased on line boundaries, with proper handling of keepends and line break characters", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn splitlines(a: Vec<String>, keepends: bool) -> (result: Vec<Vec<String>>)\n    requires a.len() > 0,\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i].len() >= 1", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "strings_str_len", "vc-description": "Returns the length of each string element in the vector.\nFor Unicode strings, this counts the number of Unicode code points.\n\nSpecification: str_len returns the length (number of Unicode code points) of each string element.\n\nPreconditions: None (str_len is defined for all strings)\n\nPostconditions:\n- The result vector has the same size as the input vector\n- Each element in the result corresponds to the length of the corresponding input string\n- Length is always non-negative (natural number)\n- Empty strings have length 0\n- Length is measured in Unicode code points for Unicode strings", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn str_len(a: Vec<String>) -> (result: Vec<nat>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> {\n            &&& result[i] == a[i]@.len()\n            &&& result[i] >= 0\n            &&& (a[i]@.len() == 0 <==> a[i]@ == Seq::<char>::empty())\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "strings_strip", "vc-description": "numpy.strings.strip: For each element in a vector, return a copy with the leading and trailing characters removed.\n\nRemoves both leading and trailing characters from each string element in the input vector.\nThis is a combination of lstrip and rstrip operations. The behavior depends on the chars parameter:\n- If chars is None, whitespace characters are removed from both ends\n- If chars is provided, any combination of those characters is removed from both ends\n\nThe function preserves the shape of the input array and handles empty strings\nappropriately by returning them unchanged.\n\nFrom NumPy documentation:\n- Parameters: a (array_like) - Input array with string dtype\n              chars (optional) - Characters to remove from both ends\n- Returns: out (ndarray) - Output array with leading and trailing characters removed\n\nMathematical Properties:\n1. Element-wise transformation: result[i] = strip(a[i], chars) for all i\n2. Length preservation or reduction: result[i].length ≤ a[i].length for all i\n3. Substring property: result[i] is a substring of a[i] for all i\n4. Character set removal: only characters in chars are removed from both ends\n5. Preserves vector length: result.size = a.size\n6. Combination of lstrip and rstrip: strip(s) = rstrip(lstrip(s))", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn strip(a: Vec<String>, chars: Option<String>) -> (result: Vec<String>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int| #[trigger] result[i] == result[i] && 0 <= i < a.len() ==> {\n            let original = a[i];\n            let res = result[i];\n            res@.len() <= original@.len() &&\n            (original@.len() == 0 ==> res@.len() == 0)\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "strings_swapcase", "vc-description": "Return element-wise a copy of the string with uppercase characters converted to lowercase and vice versa\n\nReturn element-wise a copy of the string with uppercase characters converted to lowercase and vice versa\n\nSpecification: numpy.strings.swapcase returns a vector where each string element\nhas its case swapped (uppercase becomes lowercase and vice versa).\n\nMathematical Properties:\n1. Element-wise correctness: Each element has its alphabetic characters case-swapped\n2. Length preservation: Each transformed string has the same length as the original\n3. Case transformation: Uppercase→lowercase, lowercase→uppercase, non-alpha unchanged\n4. Involutive property: swapcase(swapcase(x)) = x\n5. Empty string handling: Empty strings remain empty\n6. Character-level correctness: Each character is correctly transformed\n\nPrecondition: True (no special preconditions for case swapping)\nPostcondition: For all indices i, result[i] is the case-swapped version of a[i]", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn char_swapcase(c: char) -> char;\n\nspec fn string_swapcase(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        Seq::<char>::empty()\n    } else {\n        seq![char_swapcase(s[0])] + string_swapcase(s.skip(1))\n    }\n}\n\nfn swapcase(a: Vec<String>) -> (result: Vec<String>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> result[i]@.len() == a[i]@.len(),\n        forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a[i]@.len() ==> \n            #[trigger] result[i]@[j] == char_swapcase(a[i]@[j])", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "strings_translate", "vc-description": "numpy.strings.translate: For each element in a, return a copy of the string where \nall characters occurring in deletechars are removed, and the remaining characters \nhave been mapped through the given translation table.\n\nThis function performs character-level transformation on byte strings by first\nremoving characters specified in deletechars, then translating each remaining\ncharacter using a 256-byte translation table.\n\nSpecification for numpy.strings.translate: Returns a vector where each element is \nthe result of character deletion followed by character translation.\n\nMathematical Properties:\n1. Element-wise transformation: Each result element is derived from the corresponding input\n2. Two-stage process: First deletion, then translation\n3. Deletion completeness: All occurrences of characters in deletechars are removed\n4. Translation mapping: Each remaining byte is mapped through the translation table\n5. Order preservation: Relative order of non-deleted characters is maintained\n6. Empty string handling: Empty strings remain empty after transformation\n\n// Length property: result length <= original length (due to deletion)\n\n// Deletion property: no character from deletechars appears in result\n\n// Translation property: each byte in result comes from table translation\n\n// The original character existed in input and wasn't deleted\n\n// Completeness property: all non-deleted characters are translated and included  \n\n// Identity on empty deletechars\n\n// Empty string preservation", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn translate(a: Vec<Vec<u8>>, table: Vec<u8>, deletechars: Vec<u8>) -> (result: Vec<Vec<u8>>)\n    requires\n        table.len() == 256,\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> {\n\n            result[i].len() <= a[i].len() &&\n\n            (forall|c: u8| #[trigger] result[i]@.contains(c) ==> {\n                forall|j: int| 0 <= j < deletechars.len() ==> c != deletechars[j]\n            }) &&\n\n            (forall|k: int| 0 <= k < result[i].len() ==> {\n                exists|orig_char: u8, table_idx: int|\n                    0 <= table_idx < 256 &&\n                    orig_char == table_idx as u8 &&\n                    #[trigger] result[i][k] == table[table_idx as int] &&\n\n                    a[i]@.contains(orig_char) &&\n                    (forall|j: int| 0 <= j < deletechars.len() ==> orig_char != deletechars[j])\n            }) &&\n\n            (forall|orig_char: u8| #[trigger] a[i]@.contains(orig_char) ==> {\n                (forall|j: int| 0 <= j < deletechars.len() ==> orig_char != deletechars[j]) ==> {\n                    exists|translated_char: u8| result[i]@.contains(translated_char) &&\n                        exists|table_idx: int|\n                            0 <= table_idx < 256 &&\n                            orig_char as int == table_idx &&\n                            translated_char == table[table_idx as int]\n                }\n            }) &&\n\n            (deletechars.len() == 0 ==> {\n                result[i].len() == a[i].len() &&\n                (forall|k: int| 0 <= k < a[i].len() ==> {\n                    exists|table_idx: int|\n                        0 <= table_idx < 256 &&\n                        a[i][k] as int == table_idx &&\n                        #[trigger] result[i][k] == table[table_idx as int]\n                })\n            }) &&\n\n            (a[i].len() == 0 ==> result[i].len() == 0)\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "ufunc___call__", "vc-description": "Apply a binary universal function elementwise to two vectors.\nThis represents the core __call__ behavior for binary ufuncs like add, multiply, etc.\n\nSpecification: ufunc.__call__ applies the operation elementwise to input vectors.\nThe result has the same shape as the inputs (broadcasting to common shape) and\neach element is computed by applying the operation to corresponding elements.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn ufunc_call(op: spec_fn(f32, f32) -> f32, a: &Vec<f32>, b: &Vec<f32>) -> (result: Vec<f32>)\n    requires a.len() == b.len(),\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == op(a[i], b[i])", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "ufunc_outer", "vc-description": "Universal function outer method: Apply a binary operator to all pairs (a, b) \nwith a in A and b in B.\n\nFor two 1-D vectors A = [a₁, a₂, ..., aₘ] and B = [b₁, b₂, ..., bₙ], \nthe outer product produces an m×n matrix where result[i,j] = op(A[i], B[j]).\n\nThis generalizes the concept of outer product beyond just multiplication:\n- When op = (*), this becomes the traditional outer product\n- When op = (+), this becomes the sum of all pairs\n- When op = (^), this becomes the power of all pairs\n\nThe result has shape (m, n) where m is the length of A and n is the length of B.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn apply_binary_op(op_id: int, x: f64, y: f64) -> f64;\n\nfn outer(op_id: int, a: Vec<f64>, b: Vec<f64>) -> (result: Vec<Vec<f64>>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == b.len(),\n        forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < b.len() ==> \n            result[i][j] == apply_binary_op(op_id, a[i], b[j]),\n        forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < b.len() ==>\n            exists|ai: f64, bj: f64| ai == a[i] && bj == b[j] && result[i][j] == apply_binary_op(op_id, ai, bj)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "ufunc_reduce", "vc-description": "Reduces an array by applying a binary operation repeatedly along an axis.\nFor 1D arrays, this applies the operation successively to pairs of elements.\n\nSpecification: reduce applies a binary operation repeatedly to reduce an array to a single value.\nThe operation is applied left-associatively: ((a[0] op a[1]) op a[2]) op ... op a[n-1]\n\n/* Represents left-associative folding result at position index */\n\n/* Placeholder - actual implementation would apply operation */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn fold_left(arr: Seq<f64>, index: nat) -> f64\n    decreases index\n{\n    if index == 0 {\n        arr[0 as int]\n    } else {\n\n        arr[index as int]\n    }\n}\n\nfn reduce(arr: Vec<f64>) -> (result: f64)\n    requires arr.len() > 0,\n    ensures \n        arr.len() == 1 ==> result == arr[0],\n        arr.len() > 1 ==> result == fold_left(arr@, (arr.len() - 1) as nat)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "ufuncs_frompyfunc", "vc-description": "numpy.frompyfunc: Takes a function and returns a universal function that applies it element-wise.\n\nCreates a universal function (ufunc) from a Python function. The resulting ufunc\napplies the original function element-wise to input arrays. For simplicity, we\nmodel this for the common case of a unary function (nin=1, nout=1).\n\nIn our Vector-based model, this takes a function α → β and returns a function\nthat applies it element-wise to Vector α n, producing Vector β n.\n\nThis function enables the creation of vectorized operations from arbitrary functions,\nwhich is a core capability of NumPy's universal function system.\n\nSpecification: numpy.frompyfunc creates a vectorized version of a function\nthat applies the original function element-wise.\n\nPrecondition: True (any function can be vectorized)\nPostcondition: For all indices i, the result at index i equals func applied\nto the input at index i.\n\nThis captures the essential property that frompyfunc creates an element-wise\nmapping from the original function, preserving the functional behavior\nwhile extending it to work with vectors.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_frompyfunc<A, B>(func: spec_fn(A) -> B, input: Vec<A>) -> (result: Vec<B>)\n    ensures\n        result.len() == input.len(),\n        forall|i: int| 0 <= i < input.len() ==> result[i] == func(input[i])", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "ufuncs_identity", "vc-description": "ufunc.identity: Get the identity element for a ufunc operation.\n\nReturns the identity element for a given binary operation, which is the value\nthat when combined with any other value using that operation, leaves the other\nvalue unchanged. For example:\n- Addition: identity is 0 (x + 0 = x)\n- Multiplication: identity is 1 (x * 1 = x)\n- Logical AND: identity is True (x ∧ True = x)\n- Logical OR: identity is False (x ∨ False = x)\n\nSome operations may have no identity element, in which case None is returned.\n\nSpecification: ufunc_identity returns the identity element if it exists.\n\nPrecondition: The operation is a valid binary function\nPostcondition: If an identity element exists, applying the operation with\n               that element leaves any other element unchanged", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn ufunc_identity(op: spec_fn(f64, f64) -> f64) -> (result: Option<f64>)\n    ensures\n        match result {\n            Some(id) => forall|x: f64| op(x, id) == x && op(id, x) == x,\n            None => !exists|id: f64| forall|x: f64| op(x, id) == x && op(id, x) == x,\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "ufuncs_ntypes", "vc-description": "The number of supported input/output type combinations\n\nnumpy.ufunc.ntypes: Returns the number of supported input/output type combinations\nfor a universal function.\n\nThe ntypes attribute represents the number of numerical NumPy types on which\nthe ufunc can operate. This is a key characteristic that determines the\ntype flexibility of different NumPy universal functions.\n\nFor example:\n- np.add.ntypes returns around 22 (supports most numerical types)\n- np.exp.ntypes returns around 10 (fewer supported types)\n- np.remainder.ntypes returns around 16 (intermediate support)\n\nSpecification: ntypes returns the count of supported type combinations\nfor a ufunc, which must be a positive number for any valid ufunc.\n\nPrecondition: The input represents valid type combinations for a ufunc\nPostcondition: The result is the exact count of type combinations,\n              which is non-zero for any functional ufunc and equals\n              the length of the type combinations vector.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn ntypes(ufunc_type_combinations: Vec<String>) -> (result: usize)\n    requires ufunc_type_combinations.len() > 0,\n    ensures \n        result == ufunc_type_combinations.len(),\n        result > 0", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "ufuncs_types", "vc-description": "List of supported data type signatures\nShows input->output type mappings\nReturns the list of supported data type signatures for a universal function\nSpecification: types returns formatted type signatures as strings\n\n/* Data type character codes used in NumPy ufunc type signatures */\n\n/* '?' */\n\n/* 'b' */\n\n/* 'B' */\n\n/* 'h' */\n\n/* 'H' */\n\n/* 'i' */\n\n/* 'I' */\n\n/* 'l' */\n\n/* 'L' */\n\n/* 'q' */\n\n/* 'Q' */\n\n/* 'f' */\n\n/* 'd' */\n\n/* 'g' */\n\n/* 'F' */\n\n/* 'D' */\n\n/* 'G' */\n\n/* 'O' */\n\n/* Type signature representing input->output mapping for ufuncs */\n\n/* Convert TypeCode to character representation */\n\n/* Format a type signature as a string (input1input2...->output) */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n#[derive(PartialEq, Eq, Structural)]\nenum TypeCode {\n    Bool,\n    Byte,\n    UByte,\n    Short,\n    UShort,\n    Int,\n    UInt,\n    Long,\n    ULong,\n    LongLong,\n    ULongLong,\n    Float32,\n    Float64,\n    LongDouble,\n    Complex64,\n    Complex128,\n    CLongDouble,\n    Object,\n}\n\nstruct TypeSignature {\n    input_types: Vec<TypeCode>,\n    output_type: TypeCode,\n}\n\nspec fn type_code_to_char(tc: TypeCode) -> char {\n    match tc {\n        TypeCode::Bool => '?',\n        TypeCode::Byte => 'b',\n        TypeCode::UByte => 'B',\n        TypeCode::Short => 'h',\n        TypeCode::UShort => 'H',\n        TypeCode::Int => 'i',\n        TypeCode::UInt => 'I',\n        TypeCode::Long => 'l',\n        TypeCode::ULong => 'L',\n        TypeCode::LongLong => 'q',\n        TypeCode::ULongLong => 'Q',\n        TypeCode::Float32 => 'f',\n        TypeCode::Float64 => 'd',\n        TypeCode::LongDouble => 'g',\n        TypeCode::Complex64 => 'F',\n        TypeCode::Complex128 => 'D',\n        TypeCode::CLongDouble => 'G',\n        TypeCode::Object => 'O',\n    }\n}\n\nspec fn format_type_signature(sig: TypeSignature) -> Seq<char> {\n    let input_chars = sig.input_types@.map(|i, tc: TypeCode| type_code_to_char(tc));\n    input_chars + seq!['-', '>'] + seq![type_code_to_char(sig.output_type)]\n}", "vc-helpers": "", "vc-spec": "fn types(ufunc_signatures: Vec<TypeSignature>) -> (result: Vec<String>)\n    ensures \n        result.len() == ufunc_signatures.len(),\n        forall|i: int| 0 <= i < result.len() ==> {\n            let sig = ufunc_signatures[i];\n            sig.input_types.len() > 0 &&\n            result[i]@ == format_type_signature(sig)\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
{"id": "ufuncs_vectorize", "vc-description": "Generalized function class that converts a Python function into a vectorized function\n\nVectorizes a scalar function to operate element-wise on vectors.\nTakes a function f and applies it element-wise to input vectors,\nproducing a new vector with the same size.\n\nSpecification: vectorize applies the given function element-wise to the input vector.\nThe result vector has the same size and each element is the function applied to \nthe corresponding element of the input vector.\n\nProperties verified:\n1. Element-wise application: each output element equals f applied to corresponding input\n2. Size preservation: output vector has same size as input vector\n3. Order preservation: relative positions of elements are maintained\n4. Functional purity: result depends only on function f and input vector", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn vectorize<A, B>(f: spec_fn(A) -> B, arr: Vec<A>) -> (result: Vec<B>)\n    ensures\n        result.len() == arr.len(),\n        forall|i: int| 0 <= i < arr.len() ==> result[i] == f(arr[i])", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}"}
