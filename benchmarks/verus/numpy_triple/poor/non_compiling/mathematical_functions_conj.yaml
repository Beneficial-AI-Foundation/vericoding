vc-description: |-
  /*
  Return the complex conjugate of a vector of complex numbers, element-wise
  
  Specification: conj computes the complex conjugate of each element with the following properties:
  1. Basic definition: conj(a + bi) = a - bi for complex numbers
  2. Real preservation: For purely real numbers, conj(x) = x
  3. Involution property: conj(conj(x)) = x (double conjugation returns original)
  4. Magnitude preservation: |conj(x)| = |x| (conjugate preserves magnitude)
  5. Distributive over addition: conj(x + y) = conj(x) + conj(y)
  6. Distributive over multiplication: conj(x * y) = conj(x) * conj(y)
  */
vc-preamble: |-
  use vstd::prelude::*;

  verus! {

  /* Structure representing a complex number with float components */
  pub struct Complex {
      /* The real part of the complex number */
      pub real: f32,
      /* The imaginary part of the complex number */
      pub imag: f32,
  }

  impl Complex {
      /* Addition of complex numbers */
      pub open spec fn add(self, other: Complex) -> Complex {
          Complex {
              real: self.real + other.real,
              imag: self.imag + other.imag,
          }
      }

      /* Multiplication of complex numbers */
      pub open spec fn mul(self, other: Complex) -> Complex {
          Complex {
              real: self.real * other.real - self.imag * other.imag,
              imag: self.real * other.imag + self.imag * other.real,
          }
      }

      /* Magnitude squared of a complex number */
      pub open spec fn norm_sq(self) -> f32 {
          self.real * self.real + self.imag * self.imag
      }

      /* Complex conjugate of a single complex number */
      pub open spec fn conj(self) -> Complex {
          Complex {
              real: self.real,
              imag: -self.imag,
          }
      }
  }

vc-helpers: |-

vc-spec: |-
  fn conj(x: Vec<Complex>) -> (result: Vec<Complex>)
      ensures
          result.len() == x.len(),
          forall|i: int| 0 <= i < result.len() ==> result[i].real == x[i].real && result[i].imag == -x[i].imag,
          forall|i: int| 0 <= i < result.len() ==> x[i].imag == 0.0 ==> result[i] == x[i],
          forall|i: int| 0 <= i < result.len() ==> result[i].conj() == x[i],
          forall|i: int| 0 <= i < result.len() ==> x[i].norm_sq() == result[i].norm_sq(),
          forall|i: int, y: Complex| 0 <= i < result.len() ==> 
              (x[i].add(y)).conj() == result[i].add(y.conj()),
          forall|i: int, y: Complex| 0 <= i < result.len() ==> 
              (x[i].mul(y)).conj() == result[i].mul(y.conj())

vc-code: |-
  {
      // impl-start
      assume(false);
      Vec::new()
      // impl-end
  }

vc-postamble: |-

  }
  fn main() {}