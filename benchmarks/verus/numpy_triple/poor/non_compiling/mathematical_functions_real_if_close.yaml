vc-description: |-
  /*
  If input is complex with all imaginary parts close to zero, return real parts.
  "Close to zero" is defined as tol * (machine epsilon of the type for a).
  
  If input is complex with all imaginary parts close to zero, return real parts.
  Otherwise, return the original complex vector.
  "Close to zero" is defined as tol * (machine epsilon of the type).
  
  Specification: real_if_close returns real parts if all imaginary parts are within tolerance,
  otherwise returns the original complex vector. This captures the essential behavior:
  1. If all imaginary parts are small (â‰¤ tol * machineEpsilon), return only real parts
  2. Otherwise, preserve the original complex numbers
  3. Real parts are always preserved regardless
  4. The tolerance check is applied consistently across all elements
  */
vc-preamble: |-
  use vstd::prelude::*;

  verus! {

vc-helpers: |-
  /* Structure representing a complex number with float components */
  #[derive(PartialEq, Eq)]
  pub struct Complex {
      /* The real part of the complex number */
      pub re: f32,
      /* The imaginary part of the complex number */
      pub im: f32,
  }

  /* Machine epsilon for f32 (approximately 1.1920928955078125e-07) */
  pub const MACHINE_EPSILON: f32 = 1.1920928955078125e-07;

  /* Helper function to check if a complex number's imaginary part is close to zero */
  pub fn is_close_to_zero(c: Complex, tol: f32) -> (result: bool)
  {
      let abs_im = if c.im >= 0.0 { c.im } else { -c.im };
      abs_im <= tol * MACHINE_EPSILON
  }

  /* Helper function to check if all imaginary parts in a complex vector are close to zero */
  pub fn all_imaginary_parts_close_to_zero(arr: &Vec<Complex>, tol: f32) -> (result: bool)
  {
      let mut i = 0;
      while i < arr.len()
      {
          if !is_close_to_zero(arr[i], tol) {
              return false;
          }
          i = i + 1;
      }
      true
  }

vc-spec: |-
  fn real_if_close(arr: Vec<Complex>, tol: f32) -> (result: Vec<Complex>)
      requires tol > 0.0,
      ensures 
          /* Primary behavior: if all imaginary parts are close to zero, return real parts only */
          (all_imaginary_parts_close_to_zero(&arr, tol) ==> 
              forall|i: int| 0 <= i < arr.len() ==> result[i].re == arr[i].re && result[i].im == 0.0) &&
          /* Otherwise, preserve original complex numbers */
          (!all_imaginary_parts_close_to_zero(&arr, tol) ==> 
              forall|i: int| 0 <= i < arr.len() ==> result[i] == arr[i]) &&
          /* Real parts are always preserved */
          (forall|i: int| 0 <= i < arr.len() ==> result[i].re == arr[i].re) &&
          /* Sanity check: result vector has same length as input */
          result.len() == arr.len() &&
          /* Mathematical property: if input is already real, output equals input */
          ((forall|i: int| 0 <= i < arr.len() ==> arr[i].im == 0.0) ==> 
              forall|i: int| 0 <= i < arr.len() ==> result[i] == arr[i])

vc-code: |-
  {
      // impl-start
      assume(false);
      Vec::new()
      // impl-end
  }

vc-postamble: |-

  }
  fn main() {}