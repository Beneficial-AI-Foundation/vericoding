{"id": "VT0000", "language": "verus", "source": "numpy_triple", "source_id": "array_creation_arange", "vc-description": "Return evenly spaced values within a given interval [start, stop) with given step.\nSpecification: arange generates evenly spaced values from start to stop (exclusive) with given step.\nEach element at index i has value start + i * step, and all values are within bounds.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn arange(start: i8, stop: i8, step: i8, n: usize) -> (result: Vec<i8>)\n    requires step != 0,\n    ensures\n        result.len() == n,\n        n == 0 ==> ((step > 0 && start >= stop) || (step < 0 && start <= stop)),\n        n > 0 ==> (\n            forall|i: int| 0 <= i < n ==> result@[i] == start as int + i * step as int\n        ),\n        n > 0 && step > 0 ==> (\n            start < stop &&\n            forall|i: int| 0 <= i < n ==> result@[i] < stop as int\n        ),\n        n > 0 && step < 0 ==> (\n            start > stop &&\n            forall|i: int| 0 <= i < n ==> result@[i] > stop as int\n        ),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0001", "language": "verus", "source": "numpy_triple", "source_id": "array_creation_array", "vc-description": "Create an array from existing data. This is the primary array creation function.\nTakes a list of Float elements and creates a Vector of the same length.\n\nSpecification: array creates a vector containing exactly the input data elements\nin the same order. The result has the same length as the input list and preserves\nall elements at their corresponding indices. This captures the fundamental property\nof numpy.array - converting sequence-like data into array format while preserving\nelement values and order.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn array(data: Vec<f64>) -> (result: Vec<f64>)\n    ensures\n        result.len() == data.len(),\n        forall|i: int| 0 <= i < data.len() ==> result[i] == data[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0002", "language": "verus", "source": "numpy_triple", "source_id": "array_creation_asanyarray", "vc-description": "numpy.asanyarray: Convert the input to an ndarray, but pass ndarray subclasses through.\n\nConverts the input to an ndarray, but passes ndarray subclasses through unchanged.\nIf the input is already an ndarray or a subclass of ndarray, it is returned as-is\nand no copy is performed. For other array-like inputs, it performs conversion.\n\nIn this Vector-based specification, we model this as an identity function that\npreserves the input vector unchanged, representing the common case where the\ninput is already an ndarray.\n\nSpecification: numpy.asanyarray returns the input vector unchanged when it's already an ndarray.\n\nPrecondition: True (no special preconditions)\nPostcondition: The result is identical to the input vector - no copy is made,\n               and each element remains unchanged.\n\nThis captures the key property of asanyarray: when given an ndarray (Vector in our case),\nit returns the same array without copying.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn asanyarray(a: Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> result[i] == a[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0003", "language": "verus", "source": "numpy_triple", "source_id": "array_creation_asarray", "vc-description": "numpy.asarray: Convert the input to an array.\n\nConverts various input types (lists, tuples, existing arrays, etc.) to an array.\nThe function creates a new array from the input data, preserving the element\norder and values. For our Vector-based specification, we model this as\nconverting a list of elements to a Vector.\n\nThis is a fundamental array creation function that ensures the output is\nalways a proper array format regardless of the input type.\n\nSpecification: numpy.asarray returns a vector containing the same elements\nas the input list, in the same order.\n\nPrecondition: The input list length matches the vector size parameter\nPostcondition: \n1. The result vector has the same length as the input list\n2. Each element in the result vector equals the corresponding element in the input list\n3. The ordering of elements is preserved", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn asarray(a: Vec<f32>) -> (result: Vec<f32>)\n    requires a.len() > 0,\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == a[i]", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0005", "language": "verus", "source": "numpy_triple", "source_id": "array_creation_asmatrix", "vc-description": "Interpret the input as a matrix. In our simplified model, this represents\na 1D vector as a matrix type. Since numpy.asmatrix doesn't make a copy\nif the input is already a matrix or ndarray, this function acts as an\nidentity operation with matrix type semantics.\n\nSpecification: asmatrix interprets input data as a matrix without copying.\n\nThe function preserves the original data structure and values while\nproviding matrix semantics. For our Vector-based implementation, this\nmeans the output vector has the same length and contains the same elements\nas the input vector.\n\nKey properties:\n1. No copying occurs - the result has the same elements as input\n2. The length is preserved  \n3. Element order is preserved\n4. All original values are maintained", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn asmatrix(data: Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() == data.len(),\n        forall|i: int| 0 <= i < data.len() ==> result[i] == data[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0006", "language": "verus", "source": "numpy_triple", "source_id": "array_creation_bmat", "vc-description": "Build a matrix from a 2x2 block structure using 4 input vectors.\nThis represents a simplified version of numpy.bmat for 2x2 block matrices.\nThe result is a flattened vector representing the block matrix in row-major order.\n\nMathematically, this constructs a 2x2 block matrix where each block is a 1×n vector:\n[ topLeft    | topRight    ]\n[ bottomLeft | bottomRight ]\n\nThe result is flattened as [topLeft | topRight | bottomLeft | bottomRight].\n\nSpecification: bmat constructs a 2x2 block matrix from four equal-sized vectors.\nThe result is a flattened vector where blocks are arranged as:\n[topLeft | topRight | bottomLeft | bottomRight]\nThis captures the essential behavior of numpy.bmat for block matrix construction.\n\nPrecondition: True (no special preconditions for basic block matrix construction)\nPostcondition: Each block is correctly placed in the flattened result", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn bmat(top_left: Vec<f32>, top_right: Vec<f32>, bottom_left: Vec<f32>, bottom_right: Vec<f32>) -> (result: Vec<f32>)\n    requires \n        top_left.len() == top_right.len(),\n        top_left.len() == bottom_left.len(),\n        top_left.len() == bottom_right.len(),\n    ensures\n        result.len() == 4 * top_left.len(),\n        forall|i: int| 0 <= i < top_left.len() ==> result[i] == top_left[i],\n        forall|i: int| 0 <= i < top_right.len() ==> result[i + top_left.len()] == top_right[i],\n        forall|i: int| 0 <= i < bottom_left.len() ==> result[i + 2 * top_left.len()] == bottom_left[i],\n        forall|i: int| 0 <= i < bottom_right.len() ==> result[i + 3 * top_left.len()] == bottom_right[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0007", "language": "verus", "source": "numpy_triple", "source_id": "array_creation_copy", "vc-description": "Return an array copy of the given object.\nThe copy has the same shape and values as the original array, \nbut occupies different memory locations.\n\nSpecification: copy returns a vector with identical values but independent memory.\nThe resulting vector has the same size and all elements equal to the original,\nensuring that the copy is element-wise equivalent to the original.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn copy<T: Copy>(a: &Vec<T>) -> (result: Vec<T>)\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> result[i] == a[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0008", "language": "verus", "source": "numpy_triple", "source_id": "array_creation_diag", "vc-description": "Extract a diagonal or construct a diagonal array\n\nConstruct a diagonal matrix from a 1-D vector\n\nSpecification: diag constructs a square matrix with v on the main diagonal.\n\nThis captures the mathematical property that numpy.diag(v) creates a matrix M\nwhere M[i,i] = v[i] for all i, and M[i,j] = 0 for all i ≠ j.\n\nThe result is an n×n matrix where:\n- The main diagonal contains the elements of the input vector v\n- All off-diagonal elements are zero\n- This represents the canonical way to construct a diagonal matrix\n\nMathematical properties verified:\n1. Diagonal elements equality: M[i,i] = v[i]\n2. Off-diagonal zeros: M[i,j] = 0 for i ≠ j\n3. Diagonal matrix property: non-zero elements only on diagonal\n4. Trace property: tr(M) = sum(v)\n5. Symmetry: M is a symmetric matrix\n6. Idempotence property: diag(diag(M)) reconstructs M for diagonal matrices\n7. Zero count: exactly n elements are non-zero (assuming v has no zeros)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn diag(v: Vec<f32>) -> (result: Vec<Vec<f32>>)\n    requires v.len() > 0,\n    ensures \n        result.len() == v.len(),\n        forall|i: int| 0 <= i < v@.len() ==> result@[i].len() == v@.len(),\n        /* Elements on the main diagonal are from v */\n        forall|i: int| 0 <= i < v@.len() ==> result@[i][i] == v@[i],\n        /* All off-diagonal elements are zero */\n        forall|i: int, j: int| 0 <= i < v@.len() && 0 <= j < v@.len() && i != j ==> result@[i][j] == 0.0f32,\n        /* Diagonal matrix property - non-zero elements only on diagonal */\n        forall|i: int, j: int| 0 <= i < v@.len() && 0 <= j < v@.len() && result@[i][j] != 0.0f32 ==> i == j,\n        /* The resulting matrix is symmetric */\n        forall|i: int, j: int| 0 <= i < v@.len() && 0 <= j < v@.len() ==> result@[i][j] == result@[j][i],\n        /* Each row has exactly one non-zero element at position i (unless v[i] = 0) */\n        forall|i: int| 0 <= i < v@.len() && v@[i] != 0.0f32 ==> {\n            result@[i][i] != 0.0f32 && \n            forall|j: int| 0 <= j < v@.len() && j != i ==> result@[i][j] == 0.0f32\n        },\n        /* Each column has exactly one non-zero element at position j (unless v[j] = 0) */\n        forall|j: int| 0 <= j < v@.len() && v@[j] != 0.0f32 ==> {\n            result@[j][j] != 0.0f32 && \n            forall|i: int| 0 <= i < v@.len() && i != j ==> result@[i][j] == 0.0f32\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0010", "language": "verus", "source": "numpy_triple", "source_id": "array_creation_empty", "vc-description": "numpy.empty: Return a new array of given shape and type, without initializing entries.\n\nCreates a new vector of the specified length containing uninitialized (arbitrary) values.\nThis is a low-level function that allocates memory without setting initial values,\nmaking it potentially faster than other array creation functions.\n\nFor 1D arrays, this takes a size parameter n and returns a Vector Float n\nwith arbitrary values.\n\nSpecification: numpy.empty returns a vector of the specified size with arbitrary values.\n\nProperties:\n1. The returned vector has exactly n elements (guaranteed by type)\n2. Each element in the vector is a valid Float value\n3. The vector is well-formed - all indices are accessible\n4. No guarantees are made about the actual values - they are arbitrary/uninitialized\n\nMathematical properties:\n- Size property: The length of the result is exactly n\n- Accessibility property: All elements from index 0 to n-1 are accessible via get\n- Value existence: Each position contains some Float value (but we don't specify which)\n\nThis specification captures the key behavior of numpy.empty: it returns a properly\nsized array but makes no promises about the contents, which distinguishes it from\nfunctions like zeros() or ones() that guarantee specific initial values.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn empty(n: u8) -> (result: Vec<f64>)\n    ensures result.len() == n as usize", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0013", "language": "verus", "source": "numpy_triple", "source_id": "array_creation_from_dlpack", "vc-description": "Create a NumPy array from an object implementing the DLPack protocol. This function allows for interoperability with other libraries that support the DLPack protocol.\n\n/* Abstract type representing a DLPack-compatible object */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\npub struct DLPackObject<T> {\n    pub data: Vec<T>,\n    pub has_dlpack: bool,\n    pub has_dlpack_device: bool,\n    pub device: String,\n}", "vc-helpers": "", "vc-spec": "fn from_dlpack<T>(x: &DLPackObject<T>, device: Option<&str>, copy: Option<bool>) -> (result: Vec<T>)\n    requires \n        x.has_dlpack && x.has_dlpack_device,\n        device.is_none() || device == Some(\"cpu\"),\n    ensures\n        result.len() == x.data.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == x.data[i],\n        copy == Some(true) ==> result@ != x.data@,\n        copy == Some(false) ==> result@ == x.data@,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0014", "language": "verus", "source": "numpy_triple", "source_id": "array_creation_frombuffer", "vc-description": "Interpret a buffer as a 1-dimensional array.\nTakes a buffer (represented as a Vector of bytes), the count of elements to read,\nand an offset (starting position in bytes) to create a Vector of the specified type.\nThis models numpy.frombuffer which interprets raw bytes as typed array elements.\n\nSpecification: frombuffer interprets raw bytes from a buffer as a typed array.\nThe function reads 'count' elements starting from 'offset' bytes into the buffer.\nThe result is a Vector containing the selected bytes in the same order\nas they appear in the buffer. Key properties:\n1. Buffer must have sufficient bytes for the requested elements\n2. Offset must be within buffer bounds when count > 0\n3. Elements are read sequentially from the buffer starting at offset\n4. The result preserves the sequential order of elements in the buffer\n5. Each output element corresponds to exactly one input buffer byte", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn frombuffer(buffer: &Vec<u8>, count: usize, offset: usize) -> (result: Vec<u8>)\n    requires \n        offset + count <= buffer.len(),\n        offset < buffer.len() || count == 0,\n    ensures\n        result.len() == count,\n        forall|i: int| 0 <= i < count ==> result[i] == buffer[offset + i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0015", "language": "verus", "source": "numpy_triple", "source_id": "array_creation_fromfile", "vc-description": "Construct a vector from data in a file. \n\nSpecification: fromfile reads data from a file into a vector\n\nBased on numpy.fromfile - Construct an array from data in a text or binary file.\n\nParameters:\n- file: File object or filename containing data\n- dtype: Data type of the returned array  \n- count: Number of items to read (-1 means all items)\n- sep: Separator between items for text files (empty means binary)\n- offset: The offset in bytes from file's current position\n- like: Reference object for array creation\n\nReturns an array of data from the file. Note that binary files generated are not platform independent.\n\n/* Abstract file representation for specification purposes */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\npub struct FileData {\n    pub content: Seq<f64>,\n    pub valid: bool,\n}", "vc-helpers": "", "vc-spec": "fn fromfile(n: usize, file: &FileData, count: i32, offset: usize) -> (result: Vec<f64>)\n    requires \n        file.valid == true,\n        count == (n as i32) || count == -1,\n        offset <= file.content.len(),\n        file.content.len() - offset >= n,\n    ensures \n        result.len() == n,\n        forall|i: int| 0 <= i < n ==> result[i] == file.content[offset + i],\n        n <= file.content.len() - offset,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0016", "language": "verus", "source": "numpy_triple", "source_id": "array_creation_fromfunction", "vc-description": "Construct a vector by executing a function over each coordinate index.\nFor 1D case, this creates a vector of length n where element i is f(i).\n\nSpecification: fromfunction creates a vector where each element is the result\nof applying the function to its index position.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn fromfunction(n: usize, f: spec_fn(usize) -> f32) -> (result: Vec<f32>)\n    ensures\n        result.len() == n,\n        forall|i: int| 0 <= i < n ==> result[i] == f(i as usize)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0017", "language": "verus", "source": "numpy_triple", "source_id": "array_creation_fromiter", "vc-description": "Create a new 1-dimensional array from an iterable object.\nTakes the first n elements from the iterable sequence and creates a Vector.\nThis models numpy.fromiter with explicit count parameter.\n\nSpecification: fromiter creates a Vector containing the first n elements \nfrom the iterable in order. The resulting Vector has exactly n elements,\nand each element at index i equals the i-th element from the iterable.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn fromiter<T: Copy>(n: usize, iter: spec_fn(usize) -> T) -> (result: Vec<T>)\n    ensures\n        result.len() == n,\n        forall|i: int| 0 <= i < n ==> result[i] == iter(i as usize)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0018", "language": "verus", "source": "numpy_triple", "source_id": "array_creation_fromstring", "vc-description": "A new 1-D array initialized from text data in a string\n\nSpecification: fromstring parses a string into a vector of floats using a separator", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn fromstring(input: Vec<char>, sep: Vec<char>) -> (result: Vec<f32>)\n    requires\n        sep.len() > 0,\n        input.len() > 0,\n    ensures\n        result.len() > 0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0019", "language": "verus", "source": "numpy_triple", "source_id": "array_creation_full", "vc-description": "numpy.full: Return a new array of given shape and type, filled with fill_value.\n\nCreates a new vector of size n where every element is set to the specified\nfill_value. This is the 1D version of numpy.full, focusing on the core\nfunctionality of creating uniform arrays.\n\nThe function creates a vector filled with identical values, which is useful\nfor initialization and creating constant arrays.\n\nSpecification: numpy.full returns a vector where every element equals fill_value.\n\nThis specification captures the complete mathematical behavior of numpy.full:\n\n1. **Sanity checks**:\n   - The result vector has exactly n elements (enforced by type)\n   - The function is deterministic (same inputs always produce same output)\n\n2. **Core property**: Every element in the result equals fill_value\n   - ∀ i : Fin n, result[i] = fill_value\n\n3. **Mathematical properties**:\n   - Uniformity: All elements are identical\n   - Idempotence of fill value: Filling with the same value multiple times yields the same result\n   - Independence from index: The value at any position doesn't depend on the position\n\n4. **Additional properties**:\n   - For n = 0, the result is an empty vector\n   - For n > 0, all elements are equal to each other\n   - The result is functionally equivalent to Vector.replicate n fill_value\n\n5. **Relationship properties**:\n   - full α n v is equivalent to creating an array and setting each element to v\n   - If two vectors are created with full using the same fill_value and size,\n     they are element-wise equal\n   - full preserves the fill_value exactly (no transformation or casting)\n\n/* Core property: every element equals fill_value */\n\n/* Uniformity property: all elements are equal to each other */\n\n/* First and last element property (when n > 0) */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn full<T>(n: usize, fill_value: T) -> (result: Vec<T>)\n    ensures \n        result.len() == n,\n\n        forall|i: int| 0 <= i < n ==> result[i] == fill_value,\n\n        forall|i: int, j: int| 0 <= i < n && 0 <= j < n ==> result[i] == result[j],\n\n        n > 0 ==> result[0] == fill_value,\n        n > 0 ==> result[(n-1) as int] == fill_value,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0020", "language": "verus", "source": "numpy_triple", "source_id": "array_creation_full_like", "vc-description": "numpy.full_like: Return a full array with the same shape and type as a given array.\n\nCreates a new array with the same shape as the input array `a`, where all\nelements are set to the specified `fill_value`. This is useful for creating\narrays of a specific constant value while preserving the shape of an existing\narray.\n\nThe actual type of fill_value will be cast to match the array's type,\nsimilar to numpy's behavior where 0.1 becomes 0 for integer arrays.\n\nSpecification: numpy.full_like returns a vector with the same shape as `a`\nwhere every element equals `fill_value`.\n\nPrecondition: True (no special preconditions needed)\nPostcondition: The result has the same length as `a` and all elements equal `fill_value`", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_full_like(a: Vec<f32>, fill_value: f32) -> (result: Vec<f32>)\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == fill_value,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0021", "language": "verus", "source": "numpy_triple", "source_id": "array_creation_geomspace", "vc-description": "Return numbers spaced evenly on a log scale (a geometric progression).\nEach output sample is a constant multiple of the previous one.\n\nSpecification: geomspace returns a geometric progression from start to stop.\n- The first element is always start\n- If endpoint is true and n > 1, the last element is stop\n- All elements form a geometric progression (constant ratio between consecutive elements)\n- Neither start nor stop can be zero", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn geomspace(start: f64, stop: f64, n: usize, endpoint: bool) -> (result: Vec<f64>)\n    requires \n        start != 0.0,\n        stop != 0.0,\n        n > 0,\n    ensures\n        result.len() == n,\n        n > 0 ==> result[0] == start,\n        (endpoint && n > 1) ==> result[(n - 1) as int] == stop,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0022", "language": "verus", "source": "numpy_triple", "source_id": "array_creation_identity", "vc-description": "Return the identity matrix of size n×n.\nThe identity matrix is a square matrix with ones on the main diagonal\nand zeros elsewhere.\n\nSpecification: identity returns an n×n matrix where:\n- diagonal elements (i,i) are 1.0\n- off-diagonal elements (i,j) where i≠j are 0.0", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn identity(n: usize) -> (result: Vec<Vec<f64>>)\n    ensures\n        result.len() == n,\n        forall|i: int| 0 <= i < n ==> result[i].len() == n,\n        forall|i: int, j: int| 0 <= i < n && 0 <= j < n ==>\n            result[i][j] == if i == j { 1.0 } else { 0.0 }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0023", "language": "verus", "source": "numpy_triple", "source_id": "array_creation_linspace", "vc-description": "numpy.linspace: Return evenly spaced numbers over a specified interval.\n\nReturns num evenly spaced samples, calculated over the interval [start, stop]\nwhen endpoint is true (default), or [start, stop) when endpoint is false.\n\nThis specification focuses on the most common use case where endpoint=true,\nreturning num samples that are evenly distributed from start to stop inclusive.\n\nSpecification: numpy.linspace returns a vector of evenly spaced values.\n\nWhen num > 0 and endpoint=true (default behavior):\n- The first element equals start\n- The last element equals stop (when num > 1)\n- Elements are evenly spaced with step = (stop - start) / (num - 1) when num > 1\n- When num = 1, the single element equals start\n\nMathematical properties:\n- For any valid index i, the element value is: start + i * step\n- The spacing between consecutive elements is constant (except when num = 1)\n- The sequence is monotonic (increasing if start < stop, decreasing if start > stop)\n- All elements lie within [min(start, stop), max(start, stop)]\n- Linear interpolation property: each element represents a linear interpolation between start and stop\n\nSanity checks:\n- Size of result vector equals num\n- When start = stop, all elements equal start\n- The function is symmetric: reversing start and stop reverses the sequence\n- Consecutive differences are constant for num > 2", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn linspace(start: f32, stop: f32, num: usize) -> (result: Vec<f32>)\n    requires num > 0,\n    ensures\n        result.len() == num,\n        result[0] == start,\n        (num == 1 ==> forall|i: int| 0 <= i < num ==> result[i] == start),\n        (num > 1 ==> result[num - 1] == stop)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0024", "language": "verus", "source": "numpy_triple", "source_id": "array_creation_loadtxt", "vc-description": "Load data from a text file containing numeric values.\nThis simplified version assumes:\n- The file contains floating-point numbers (one per line or whitespace-separated)\n- Comments starting with '#' are ignored\n- The skiprows parameter allows skipping initial lines\nReturns a vector of parsed float values.\n\nSpecification: loadtxt reads numeric data from a text file and returns a vector of floats.\nThe preconditions ensure:\n- The file path is valid (non-empty string)\n- After skipping skiprows lines and removing comments, there are exactly n valid float values\n\nThe postcondition guarantees:\n- The result vector contains the float values parsed from the file\n- Values appear in the same order as in the file (after skipping and comment removal)\n- The size of the result matches the type-level size n\n\nMathematical properties:\n- Deterministic: same file and parameters always produce the same result\n- Order-preserving: maintains the sequential order of values in the file\n- Comment-aware: lines starting with '#' are ignored\n- Skip-aware: first skiprows lines are ignored", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn loadtxt(fname_len: u8, skiprows: u8) -> (result: Vec<f64>)\n    requires \n        fname_len as nat > 0,\n        skiprows as nat >= 0,\n    ensures\n        result@.len() >= 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0025", "language": "verus", "source": "numpy_triple", "source_id": "array_creation_logspace", "vc-description": "Return numbers spaced evenly on a log scale.\n\nCreates a vector of `num` samples where each element is computed as:\n- When endpoint=true: base^(start + i * (stop - start) / (num - 1)) for i in 0..num-1\n- When endpoint=false: base^(start + i * (stop - start) / num) for i in 0..num-1\n\nThe samples are evenly spaced in log space, meaning the exponents form an arithmetic sequence.\n\nSpecification: logspace generates numbers evenly spaced on a logarithmic scale.\n\nThe function produces a vector where:\n1. For endpoint=true: Elements follow base^(interpolated exponent) where exponents \n   are linearly interpolated from start to stop inclusive\n2. For endpoint=false: Similar but stop value is excluded from the range\n3. The base must be positive and not equal to 1 for meaningful results\n4. For num > 1, the spacing between consecutive log values is uniform", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn logspace(start: i8, stop: i8, endpoint: bool, base: i8, num: usize) -> (result: Vec<i8>)\n    requires \n        base as int > 0,\n        base as int != 1,\n        num > 0,\n    ensures\n        result.len() == num,\n        forall|i: int| 0 <= i < num ==> result@[i] as int > 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0026", "language": "verus", "source": "numpy_triple", "source_id": "array_creation_meshgrid", "vc-description": "Return coordinate matrices from two coordinate vectors using 'xy' (Cartesian) indexing.\nFor inputs of length m and n, returns two matrices of shape (n, m) where:\n- The first matrix has x values repeated along rows\n- The second matrix has y values repeated along columns\n\nSpecification: meshgrid creates coordinate matrices where x values are repeated \nalong rows and y values are repeated along columns in 'xy' indexing mode", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn meshgrid(x: Vec<f32>, y: Vec<f32>) -> (result: (Vec<Vec<f32>>, Vec<Vec<f32>>))\n    requires \n        x.len() > 0,\n        y.len() > 0,\n    ensures\n        result.0.len() == y.len(),\n        result.1.len() == y.len(),\n        forall|i: int| 0 <= i < y.len() ==> result.0[i].len() == x.len(),\n        forall|i: int| 0 <= i < y.len() ==> result.1[i].len() == x.len(),\n        forall|i: int, j: int| 0 <= i < y.len() && 0 <= j < x.len() ==> result.0[i][j] == x[j],\n        forall|i: int, j: int| 0 <= i < y.len() && 0 <= j < x.len() ==> result.1[i][j] == y[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0027", "language": "verus", "source": "numpy_triple", "source_id": "array_creation_mgrid", "vc-description": "An instance which returns a dense multi-dimensional meshgrid\n\nAn instance of numpy.lib.ndmgr.MGridClass which, when indexed, returns a dense multi-dimensional meshgrid.\n\nParameters\n----------\n[slice1, slice2, ..., sliceN] : slice objects or integers\n    If the input is a slice, the syntax start:stop:step is equivalent to np.arange(start, stop, step) \n    inside of the brackets. If the input is an integer, the syntax i is equivalent to np.arange(i)+1.\n\nReturns\n-------\nout : one ndarray or tuple of ndarrays\n    If only one slice is passed, returns an array. If multiple slices are passed, returns a tuple \n    of arrays with one array for each dimension.\n\nCreates a 1D meshgrid from start to stop with step size.\nThis is a simplified version of mgrid that handles only the single-slice case.\n\nSpecification: mgrid creates a vector of evenly spaced values from start to stop (exclusive) with given step", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn mgrid(start: i8, stop: i8, step: i8, n: usize) -> (result: Vec<i8>)\n    requires\n        step > 0,\n        start < stop,\n        n == ((stop as int - start as int) / step as int) as usize,\n    ensures\n        result@.len() == n,\n        forall|i: int| 0 <= i < result@.len() ==> #[trigger] result@[i] == start as int + i * step as int,\n        forall|i: int| 0 <= i < result@.len() ==> #[trigger] result@[i] < stop as int,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0028", "language": "verus", "source": "numpy_triple", "source_id": "array_creation_ogrid", "vc-description": "Create a 1D open grid from start to stop with n evenly spaced points.\nThis is a simplified version of ogrid that handles the common case of\ncreating a single evenly-spaced vector (like ogrid[start:stop:nj]).\n\nSpecification: ogrid creates n evenly spaced points from start to stop (inclusive).\nWhen n > 1, the spacing between consecutive points is (stop - start) / (n - 1).\nFor n = 1, the single point is at start.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn ogrid(start: f32, stop: f32, n: usize) -> (result: Vec<f32>)\n    requires n > 0,\n    ensures \n        result.len() == n,\n        (n == 1 ==> result[0] == start),\n        (n > 1 ==> result[0] == start),\n        (n > 1 ==> result[n - 1] == stop),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0029", "language": "verus", "source": "numpy_triple", "source_id": "array_creation_ones", "vc-description": "Return a new vector of given size filled with ones.\n\nThis function creates a vector where every element is exactly 1.0,\nmatching NumPy's ones function behavior for 1D arrays.\n\nSpecification: ones returns a vector where all elements are exactly 1.0.\n\nThis specification captures the following properties:\n1. **Correctness**: Every element in the returned vector equals 1.0\n2. **Uniformity**: All elements are identical (constant vector)\n3. **Non-negativity**: All elements are positive (1.0 > 0)\n4. **Identity property**: Multiplying any value by an element gives the same value\n5. **Type Safety**: The returned vector has exactly n elements (enforced by type)\n\nMathematical Properties verified:\n- ∀ i : Fin n, result[i] = 1.0 (all elements are exactly one)\n- ∀ i j : Fin n, result[i] = result[j] (uniformity/constant vector)\n- ∀ i : Fin n, result[i] > 0 (positivity)\n- ∀ i : Fin n, ∀ x : Float, x * result[i] = x (multiplicative identity)\n\nEdge cases handled:\n- When n = 0, returns an empty vector (trivially satisfies all properties)\n- When n > 0, all indices contain exactly 1.0", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn ones(n: usize) -> (result: Vec<i8>)\n    ensures\n        result.len() == n,\n        forall|i: int| 0 <= i < n ==> result[i] as int == 1,\n        forall|i: int, j: int| 0 <= i < n && 0 <= j < n ==> result[i] == result[j],\n        forall|i: int| 0 <= i < n ==> result[i] as int > 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0030", "language": "verus", "source": "numpy_triple", "source_id": "array_creation_ones_like", "vc-description": "Return a vector of ones with the same length as the input vector.\nThis is the 1D version of numpy.ones_like which creates a new vector\nfilled with ones, having the same size as the input vector.\n\nSpecification: ones_like returns a vector where every element is 1,\nwith the same length as the input vector.\n\nMathematical properties:\n1. The result has the same length as the input (enforced by type system)\n2. Every element in the result is exactly 1\n3. The result is independent of the input values (only depends on shape)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn ones_like<T>(a: &Vec<T>) -> (result: Vec<i32>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == 1,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0031", "language": "verus", "source": "numpy_triple", "source_id": "array_creation_tri", "vc-description": "An array with ones at and below the given diagonal and zeros elsewhere.\n\nCreates a matrix of shape (N, M) where T[i,j] = 1 if j ≤ i + k, and 0 otherwise.\nThe parameter k controls the diagonal: k = 0 is the main diagonal,\nk < 0 is below it, and k > 0 is above it.\n\nSpecification: tri creates a lower triangular matrix with specified diagonal offset.\n\nThe resulting matrix has ones at and below the k-th diagonal, zeros elsewhere.\nFor each position (i, j):\n- If j ≤ i + k, then the value is 1.0\n- Otherwise, the value is 0.0\n\nThis captures the mathematical property that defines a generalized lower triangular matrix.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn tri(n: usize, m: usize, k: i32) -> (result: Vec<Vec<f64>>)\n    ensures\n        result.len() == n,\n        forall|i: int| 0 <= i < n ==> result[i].len() == m,\n        forall|i: int, j: int| 0 <= i < n && 0 <= j < m ==> \n            result[i][j] == if j <= i + k { 1.0 } else { 0.0 }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0032", "language": "verus", "source": "numpy_triple", "source_id": "array_creation_tril", "vc-description": "numpy.tril: Lower triangle of a matrix.\n\nReturns a copy of the input matrix with elements above the k-th diagonal zeroed.\n\n- k = 0 (default): zeros elements above the main diagonal\n- k < 0: zeros elements above the k-th diagonal below the main diagonal\n- k > 0: zeros elements above the k-th diagonal above the main diagonal\n\nFor a matrix element at position (i, j):\n- It is kept if i >= j - k\n- It is zeroed if i < j - k\n\nSpecification: tril returns a lower triangular matrix by zeroing elements above the k-th diagonal.\n\nMathematical Properties:\n1. Shape preservation: The output matrix has the same dimensions as the input\n2. Lower triangle preservation: Elements on or below the k-th diagonal are unchanged\n3. Upper triangle zeroing: Elements above the k-th diagonal are set to zero\n4. Diagonal selection: The k parameter controls which diagonal forms the boundary\n   - k = 0: main diagonal (default)\n   - k < 0: diagonal below the main diagonal\n   - k > 0: diagonal above the main diagonal\n5. Idempotency: Applying tril twice with the same k yields the same result\n\nElement-wise specification:\nFor each element at position (i, j):\n- If i ≥ j - k (on or below the k-th diagonal), the element is preserved\n- If i < j - k (above the k-th diagonal), the element is set to 0\n\nSpecial cases:\n- k ≥ cols: All elements are preserved (entire matrix is \"lower triangular\")\n- k ≤ -rows: All elements are zeroed (no elements are \"on or below\" such a diagonal)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn tril(m: Vec<Vec<f64>>, k: i32) -> (result: Vec<Vec<f64>>)\n    requires \n        m.len() > 0,\n        forall|i: int| 0 <= i < m.len() ==> #[trigger] m[i].len() == m[0].len(),\n    ensures\n        result.len() == m.len(),\n        forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i].len() == m[0].len(),\n        forall|i: int, j: int| \n            0 <= i < result.len() && 0 <= j < result[i].len() ==> \n            #[trigger] result[i][j] == if i >= j - k { m[i][j] } else { 0.0 },", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0033", "language": "verus", "source": "numpy_triple", "source_id": "array_creation_triu", "vc-description": "Upper triangle of a matrix.\n\nReturns a copy of a matrix with the elements below the k-th diagonal zeroed.\n- k = 0: main diagonal (default)\n- k < 0: include |k| diagonals below the main diagonal\n- k > 0: zero out k diagonals above the main diagonal as well\n\nSpecification: triu returns an upper triangular matrix with specific properties.\n\nCore behavior:\n- Elements below the k-th diagonal are zeroed\n- Elements on and above the k-th diagonal are preserved\n\nMathematical properties:\n1. Element-wise specification: result[i][j] = if i > j - k then 0 else m[i][j]\n2. Preservation of dimensions: result has same shape as input\n3. Diagonal control: k parameter shifts which diagonal forms the boundary\n4. Idempotence: applying triu twice with same k gives same result\n5. Special cases:\n   - k = 0: standard upper triangular (zeros below main diagonal)\n   - k < 0: includes |k| diagonals below main diagonal in upper triangle\n   - k > 0: zeros out k additional diagonals above main diagonal\n6. For square matrices when k = 0, all elements where row_index > column_index are zero", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn triu(m: &Vec<Vec<f32>>, k: i8) -> (result: Vec<Vec<f32>>)\n    requires \n        m@.len() > 0,\n        forall|i: int| 0 <= i < m@.len() ==> #[trigger] m@[i].len() == m@[0].len(),\n    ensures\n        result@.len() == m@.len(),\n        forall|i: int| 0 <= i < result@.len() ==> #[trigger] result@[i].len() == m@[i].len(),\n        forall|i: int, j: int| \n            0 <= i < result@.len() && 0 <= j < result@[i].len() ==>\n            #[trigger] result@[i][j] == if i > j - k as int { 0.0f32 } else { m@[i][j] },\n        forall|i: int, j: int|\n            0 <= i < result@.len() && 0 <= j < result@[i].len() && i <= j - k as int ==>\n            #[trigger] result@[i][j] == m@[i][j],\n        forall|i: int, j: int|\n            0 <= i < result@.len() && 0 <= j < result@[i].len() && i > j - k as int ==>\n            #[trigger] result@[i][j] == 0.0f32,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0034", "language": "verus", "source": "numpy_triple", "source_id": "array_creation_vander", "vc-description": "Generate a Vandermonde matrix with decreasing powers (default behavior).\nThe Vandermonde matrix is a matrix with terms of a geometric progression in each row.\nFor a 1D input vector x of length n and specified number of columns m,\nthe output is an n×m matrix where entry (i,j) = x[i]^(m-1-j)\n\nSpecification: vander generates a Vandermonde matrix where each row contains\npowers of the corresponding element from the input vector.\nIn the default decreasing mode, column j contains x^(m-1-j) for each element x.\nThis means the first column has the highest powers and the last column has x^0 = 1.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn pow_int(base: int, exp: nat) -> int\n    decreases exp\n{\n    if exp == 0 {\n        1\n    } else {\n        base * pow_int(base, (exp - 1) as nat)\n    }\n}", "vc-helpers": "", "vc-spec": "fn vander(x: Vec<i8>, m: usize) -> (result: Vec<Vec<i8>>)\n    requires \n        x@.len() > 0,\n        m > 0,\n    ensures\n        result@.len() == x@.len(),\n        forall|i: int| 0 <= i < result@.len() ==> result@[i]@.len() == m,\n        forall|i: int, j: int| 0 <= i < result@.len() && 0 <= j < m ==> \n            result@[i]@[j] as int == pow_int(x@[i] as int, (m - 1 - j) as nat),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0036", "language": "verus", "source": "numpy_triple", "source_id": "array_creation_zeros_like", "vc-description": "Return a vector of zeros with the same length as the input vector.\nThis is the 1D version of numpy.zeros_like which creates a new vector\nfilled with zeros, having the same size as the input vector.\n\nSpecification: zeros_like returns a vector where every element is 0,\nwith the same length as the input vector.\n\nMathematical properties:\n1. The result has the same length as the input (enforced by type system)\n2. Every element in the result is exactly 0\n3. The result is independent of the input values (only depends on shape)\n4. The result is the additive identity for vector addition\n5. For numeric types, the sum of all elements is zero", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn zeros_like(a: &Vec<i32>) -> (result: Vec<i32>)\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == 0,\n        forall|v: &Vec<i32>| v.len() == result.len() ==> {\n            forall|i: int| 0 <= i < result.len() ==> \n                result[i] + v[i] == v[i] && v[i] + result[i] == v[i]\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0037", "language": "verus", "source": "numpy_triple", "source_id": "array_manipulation_append", "vc-description": "numpy.append: Append values to the end of an array.\n\nFor 1D arrays without axis specification, this function flattens both \narrays and concatenates them. The result is a 1D array containing all \nelements from arr followed by all elements from values.\n\nThis is a fundamental array manipulation operation that creates a new\narray by joining two arrays end-to-end. Unlike in-place operations,\nthis always returns a new array.\n\nSpecification: numpy.append creates a new array containing all elements\nfrom arr followed by all elements from values.\n\nPrecondition: True (no special preconditions for basic append)\nPostcondition: \n- The first n elements of the result come from arr\n- The next m elements come from values\n- The order of elements is preserved from both input arrays", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_append(arr: Vec<f32>, values: Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() == arr.len() + values.len(),\n        forall|i: int| 0 <= i < arr.len() ==> result[i] == arr[i],\n        forall|j: int| 0 <= j < values.len() ==> result[arr.len() + j] == values[j],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0038", "language": "verus", "source": "numpy_triple", "source_id": "array_manipulation_array_split", "vc-description": "Split an array into multiple sub-arrays.\n\nPlease refer to the split documentation. The only difference\nbetween these functions is that array_split allows\nindices_or_sections to be an integer that does *not* equally\ndivide the axis. For an array of length l that should be split\ninto n sections, it returns l % n sub-arrays of size l//n + 1\nand the rest of size l//n.\n\nSplit a vector into k sub-vectors.\n\nWhen splitting a vector of length n into k sections:\n- The first (n % k) sub-vectors have size ⌈n/k⌉ = (n + k - 1) / k\n- The remaining sub-vectors have size ⌊n/k⌋ = n / k\n\nThis ensures all elements are distributed as evenly as possible,\nwith larger sub-vectors appearing first.\n\nSpecification: array_split distributes elements evenly with mathematical properties\n\nThe specification captures:\n1. Size distribution: larger chunks come first\n2. Element preservation: all elements from the original vector appear in order\n3. No gaps or overlaps: elements are contiguously distributed", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn chunk_size(i: int, n: int, k: int) -> int {\n    if i < n % k {\n        (n + k - 1) / k\n    } else {\n        n / k\n    }\n}\n\nspec fn start_index(i: int, n: int, k: int) -> int \n    decreases i\n{\n    if i <= 0 {\n        0\n    } else {\n        start_index(i - 1, n, k) + chunk_size(i - 1, n, k)\n    }\n}", "vc-helpers": "", "vc-spec": "fn array_split(v: Vec<i8>, k: usize) -> (result: Vec<Vec<i8>>)\n    requires k > 0,\n    ensures\n        result.len() == k,\n        /* Each sub-vector has the correct size based on its position */\n        forall|i: int| 0 <= i < k as int ==> #[trigger] result[i].len() == chunk_size(i, v.len() as int, k as int),\n        /* Elements are preserved in order across all sub-vectors */\n        forall|i: int, j: int| 0 <= i < k as int && 0 <= j < result[i].len() ==> \n            #[trigger] result[i][j] == v[start_index(i, v.len() as int, k as int) + j]", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0039", "language": "verus", "source": "numpy_triple", "source_id": "array_manipulation_atleast_1d", "vc-description": "numpy.atleast_1d: Convert inputs to arrays with at least one dimension.\n\nThis function ensures that the input has at least one dimension.\n- Scalar inputs are converted to 1-dimensional arrays with a single element\n- Higher-dimensional inputs (vectors) are preserved unchanged\n\nFor the Vector-based implementation, we provide a version that takes\na vector and returns it unchanged, since Vectors already have at least\none dimension by construction.\n\nSpecification: atleast_1d returns the input vector unchanged.\n\nSince Vectors in Lean already have at least one dimension by their type,\nthis function acts as an identity function for vectors.\n\nPrecondition: True (no special preconditions)\nPostcondition: The result is identical to the input vector", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn atleast_1d(arr: Vec<f64>) -> (result: Vec<f64>)\n    ensures\n        result == arr,\n        forall|i: int| 0 <= i < arr.len() ==> result[i] == arr[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0040", "language": "verus", "source": "numpy_triple", "source_id": "array_manipulation_atleast_2d", "vc-description": "numpy.atleast_2d: View inputs as arrays with at least two dimensions.\n\nFor a 1D vector input, this function converts it to a 2D array (matrix)\nwith shape (1, n), where the input becomes the single row of the matrix.\n\nThis specification focuses on the 1D to 2D case, which is the most common\nuse case for ensuring arrays have at least 2 dimensions.\n\nSpecification: atleast_2d converts a 1D vector to a 2D matrix with one row.\n\nThis specification includes:\n1. Sanity check: The result has exactly 1 row\n2. Shape property: The result's shape is (1, n) where n is the input length\n3. Value preservation: All elements from the input are preserved in order\n4. Mathematical property: The operation is essentially a row vector representation\n\nPrecondition: True (no special preconditions)\nPostcondition: \n- The result is a matrix with 1 row and n columns\n- The single row contains all elements from the input vector in the same order\n- The transformation preserves all numerical values exactly", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn atleast_2d(arr: Vec<f32>) -> (result: Vec<Vec<f32>>)\n    ensures \n        result.len() == 1,\n        exists|row: Vec<f32>| result[0] == row && \n        row.len() == arr.len() &&\n        forall|i: int| 0 <= i < arr.len() ==> row[i] == arr[i]", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0043", "language": "verus", "source": "numpy_triple", "source_id": "array_manipulation_broadcast", "vc-description": "numpy.broadcast: Produce an object that mimics broadcasting between two vectors.\n\nThis simplified version handles broadcasting between a column vector (m × 1)\nand a row vector (1 × n), producing an object that represents the m × n\nbroadcast result.\n\nThe broadcast object allows iteration over all element pairs that would\nresult from the broadcasting operation.\n\nSpecification: broadcast creates an object that correctly pairs elements\naccording to NumPy broadcasting rules.\n\nFor a column vector x of shape (m, 1) and row vector y of shape (1, n),\nthe broadcast object has shape (m, n) and element (i, j) is the pair (x[i], y[j]).\n\nPreconditions: \n- m > 0 (x is non-empty)\n- n > 0 (y is non-empty)\n\nPostconditions:\n- The resulting shape is (m, n)\n- Element at position (i, j) is the pair (x[i], y[j])\n\n/* Structure representing a broadcast object for two vectors.\n\n   A broadcast object encapsulates the result of broadcasting two vectors\n   against each other. It produces pairs of elements following NumPy's\n   broadcasting rules. */\n\n/* The data from the first vector */\n\n/* The data from the second vector */\n\n/* The resulting shape after broadcasting */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nstruct BroadcastObject {\n\n    x_data: Vec<f32>,\n\n    y_data: Vec<f32>,\n\n    shape: (usize, usize),\n}\n\nimpl BroadcastObject {\n    spec fn well_formed(&self) -> bool {\n        self.shape.0 == self.x_data.len() &&\n        self.shape.1 == self.y_data.len()\n    }\n\n    spec fn get_element(&self, i: int, j: int) -> (f32, f32)\n        recommends \n            self.well_formed(),\n            0 <= i < self.shape.0,\n            0 <= j < self.shape.1,\n    {\n        (self.x_data[i], self.y_data[j])\n    }\n}", "vc-helpers": "", "vc-spec": "fn broadcast(x: Vec<f32>, y: Vec<f32>) -> (result: BroadcastObject)\n    requires \n        x.len() > 0,\n        y.len() > 0,\n    ensures\n        result.well_formed(),\n        result.shape == (x.len(), y.len()),\n        forall|i: int, j: int| \n            0 <= i < x.len() && 0 <= j < y.len() ==> \n            result.get_element(i, j) == (x[i], y[j])", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0044", "language": "verus", "source": "numpy_triple", "source_id": "array_manipulation_broadcast_arrays", "vc-description": "Broadcast two 1D vectors against each other following NumPy broadcasting rules.\nFor 1D arrays, broadcasting only happens when one array has size 1.\nThe result arrays will have the size of the larger input array.\n\nSpecification: broadcast_arrays produces two arrays of the same size where:\n1. If an input array has size 1, its single element is replicated to match the other array's size\n2. If both arrays have the same size, they are returned unchanged\n3. The output arrays have size equal to the maximum of the input sizes", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn broadcast_arrays(a: Vec<i8>, b: Vec<i8>) -> (result: (Vec<i8>, Vec<i8>))\n    requires \n        a.len() == 1 || b.len() == 1 || a.len() == b.len(),\n        a.len() > 0,\n        b.len() > 0,\n    ensures \n        ({\n            let (a_broadcast, b_broadcast) = result;\n            let max_len = if a.len() > b.len() { a.len() } else { b.len() };\n            \n            /* Both output arrays have the same size as max(m, n) */\n            a_broadcast.len() == max_len &&\n            b_broadcast.len() == max_len &&\n            \n            /* First array broadcasting rules */\n            (a.len() == 1 ==> forall|i: int| 0 <= i < max_len as int ==> a_broadcast[i] == a[0]) &&\n            (b.len() == 1 && a.len() > 1 ==> forall|i: int| 0 <= i < a.len() as int ==> a_broadcast[i] == a[i]) &&\n            (a.len() == b.len() ==> forall|i: int| 0 <= i < a.len() as int ==> a_broadcast[i] == a[i]) &&\n            \n            /* Second array broadcasting rules */\n            (b.len() == 1 ==> forall|i: int| 0 <= i < max_len as int ==> b_broadcast[i] == b[0]) &&\n            (a.len() == 1 && b.len() > 1 ==> forall|i: int| 0 <= i < b.len() as int ==> b_broadcast[i] == b[i]) &&\n            (a.len() == b.len() ==> forall|i: int| 0 <= i < b.len() as int ==> b_broadcast[i] == b[i])\n        })", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0047", "language": "verus", "source": "numpy_triple", "source_id": "array_manipulation_concatenate", "vc-description": "numpy.concatenate: Join a sequence of arrays along an existing axis.\n\nFor 1D arrays, concatenates two vectors end-to-end to produce a single \nvector containing all elements from both input vectors in order.\n\nThe result vector has size n + m where n and m are the sizes of the \ninput vectors.\n\nSpecification: concatenate joins two vectors preserving all elements in order.\n\nPrecondition: True (no special preconditions for concatenation)\nPostcondition: \n- First n elements of result are from vector a\n- Next m elements of result are from vector b  \n- Result has size n + m", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn concatenate(a: Vec<f32>, b: Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() == a.len() + b.len(),\n        forall|i: int| 0 <= i < a.len() ==> result[i] == a[i],\n        forall|j: int| 0 <= j < b.len() ==> result[a.len() + j] == b[j],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0048", "language": "verus", "source": "numpy_triple", "source_id": "array_manipulation_copyto", "vc-description": "Copies values from one vector to another, with optional conditional copying using a boolean mask.\n\nSpecification: copyto copies elements from src to dst where the mask is true, \npreserving dst elements where the mask is false.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn copyto<T: Copy>(dst: Vec<T>, src: Vec<T>, mask: Vec<bool>) -> (result: Vec<T>)\n    requires \n        dst.len() == src.len(),\n        dst.len() == mask.len(),\n    ensures \n        result.len() == dst.len(),\n        forall|i: int| 0 <= i < result.len() ==> \n            result[i] == if mask[i] { src[i] } else { dst[i] }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0050", "language": "verus", "source": "numpy_triple", "source_id": "array_manipulation_dsplit", "vc-description": "Split a 1D vector into equal sections (simplified version of dsplit).\n\nSince dsplit operates on the 3rd axis of 3D arrays, this simplified version\ndemonstrates the splitting behavior on a 1D vector. The actual dsplit would\nwork on nested Vector structures representing 3D arrays.\n\nThis function divides a vector into k equal sections, where k must divide\nthe length of the vector evenly. Returns a list of vectors.\n\nSpecification: dsplit divides a vector into equal sections.\n\nPrecondition: sections = k and k > 0 (array size must be k * n)\nPostcondition: Returns k sub-vectors, each of size n. The i-th sub-vector\n               contains elements from positions i*n to (i+1)*n-1 of the \n               original array.\n\nMathematical property: Concatenating all sub-vectors in order reconstructs\n                      the original vector.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn dsplit(arr: Vec<f32>, sections: usize) -> (result: Vec<Vec<f32>>)\n    requires \n        sections > 0,\n        arr.len() % sections == 0,\n    ensures\n        result.len() == sections,\n        forall|i: int| 0 <= i < sections ==> result[i].len() == arr.len() / sections,\n        forall|i: int, j: int| 0 <= i < sections && 0 <= j < (arr.len() / sections) ==> \n            result[i][j] == arr[i * (arr.len() / sections) + j],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0052", "language": "verus", "source": "numpy_triple", "source_id": "array_manipulation_expand_dims", "vc-description": "Expand the shape of a vector by inserting a new axis at the specified position.\naxis=0 creates a row vector (1×n), axis=1 creates a column vector (n×1).\n\nSpecification: expand_dims preserves all elements and adds a new dimension at the specified axis.\nThe function creates a view with increased dimensions while maintaining element order and values.\n\n/* Represents the result of expanding dimensions of a vector.\n   For axis=0, we get a 1×n matrix (row vector).\n   For axis=1, we get an n×1 matrix (column vector). */\n\n// axis=0: shape (1, n)\n\n// axis=1: shape (n, 1)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\npub enum ExpandedVector<T> {\n    RowVector(Vec<T>),\n    ColumnVector(Vec<T>),\n}", "vc-helpers": "", "vc-spec": "fn expand_dims<T>(a: Vec<T>, axis: usize) -> (result: ExpandedVector<T>)\n    requires axis <= 1,\n    ensures match result {\n        ExpandedVector::RowVector(v) => axis == 0 && v@ == a@,\n        ExpandedVector::ColumnVector(v) => axis == 1 && v@ == a@,\n    }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0053", "language": "verus", "source": "numpy_triple", "source_id": "array_manipulation_flip", "vc-description": "Reverses the order of elements in a vector (1D case of numpy.flip).\n\nThis function reverses the order of all elements in the input vector.\nFor a vector [a, b, c, d], it returns [d, c, b, a].\n\nIn the general n-dimensional case, numpy.flip can reverse along specific axes,\nbut this specification focuses on the 1D case where all elements are reversed.\n\nSpecification: numpy_flip reverses the order of elements in the vector.\n\nMathematical properties:\n1. Element mapping: The element at position i in the result equals the element \n   at position (n-1-i) in the input\n2. Involution property: Applying numpy_flip twice returns the original vector\n3. Size preservation: The output has the same size as the input (enforced by types)\n\nSanity checks:\n- For n=0 (empty vector), returns empty vector\n- For n=1 (single element), returns the same vector\n- For n>1, first element becomes last, last becomes first", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_flip(m: Vec<f32>) -> (result: Vec<f32>)\n    ensures \n        result.len() == m.len(),\n        forall|i: int| 0 <= i < m.len() ==> result[i] == m[m.len() - 1 - i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0055", "language": "verus", "source": "numpy_triple", "source_id": "array_manipulation_flipud", "vc-description": "numpy.flipud: Reverse the order of elements along axis 0 (up/down).\n\nFor a 1D array, this reverses the entire array.\nFor 2D arrays, this reverses the order of rows while preserving \nthe elements within each row.\n\nReturns a view of the input array with elements reversed along axis 0.\n\nSpecification: flipud reverses the order of elements in the vector.\n\nPrecondition: True (no special preconditions)\nPostcondition: For all indices i, result[i] = m[n-1-i]\n\nThis specification captures both the sanity check (result has same size)\nand the mathematical property (elements are reversed).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn flipud(m: Vec<f32>) -> (result: Vec<f32>)\n    ensures \n        result.len() == m.len(),\n        forall|i: int| 0 <= i < m.len() ==> result[i] == m[m.len() - 1 - i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0056", "language": "verus", "source": "numpy_triple", "source_id": "array_manipulation_hsplit", "vc-description": "Split a 1D array into multiple sub-arrays horizontally.\nFor simplicity, we focus on the 1D case where the array is split into \nk equal parts. In numpy, hsplit on 1D arrays is equivalent to split with axis=0.\n\nSpecification: hsplit divides a 1D array into k equal sub-arrays.\nEach sub-array has n/k elements. The i-th sub-array contains elements \nfrom index i*(n/k) to (i+1)*(n/k)-1 of the original array.\n\nMathematical properties:\n1. The concatenation of all sub-arrays equals the original array\n2. Each sub-array has exactly n/k elements\n3. Elements are distributed in order without overlapping", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hsplit(arr: Vec<f32>, k: usize) -> (result: Vec<Vec<f32>>)\n    requires \n        k > 0,\n        arr@.len() % (k as nat) == 0,\n    ensures\n        result@.len() == k,\n        forall|part_idx: int| 0 <= part_idx < k as int ==> result@[part_idx].len() == arr@.len() / (k as nat),\n        forall|part_idx: int, elem_idx: int| \n            0 <= part_idx < k as int && 0 <= elem_idx < (arr@.len() / (k as nat)) as int ==>\n            #[trigger] result@[part_idx][elem_idx] == arr@[part_idx * ((arr@.len() / (k as nat)) as int) + elem_idx],\n        forall|i: int| 0 <= i < arr@.len() ==> \n            exists|p: int, e: int| \n                0 <= p < k as int && 0 <= e < (arr@.len() / (k as nat)) as int &&\n                i == p * ((arr@.len() / (k as nat)) as int) + e &&\n                #[trigger] arr@[i] == result@[p][e]", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0057", "language": "verus", "source": "numpy_triple", "source_id": "array_manipulation_hstack", "vc-description": "numpy.hstack: Stack arrays in sequence horizontally (column wise).\n\nFor 1D arrays, hstack stacks arrays horizontally by concatenating them\nalong the first axis. This is equivalent to concatenation for 1D arrays.\n\nThis version handles stacking two 1D arrays. The general version would\nhandle a sequence of arrays (tup parameter in NumPy).\n\nNote: For higher dimensional arrays, hstack would concatenate along the\nsecond axis, but this specification focuses on the 1D case.\n\nSpecification: numpy.hstack concatenates 1D arrays horizontally.\n\nFor 1D arrays, horizontal stacking means concatenating them end-to-end,\nwhich is the same behavior as numpy.concatenate.\n\nPrecondition: True (no special preconditions for 1D concatenation)\n\nPostcondition: \n- The result has size n + m\n- First n elements come from array a\n- Next m elements come from array b\n- The order of elements is preserved from both input arrays", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hstack(a: Vec<f32>, b: Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() == a.len() + b.len(),\n        forall|i: int| 0 <= i < a.len() ==> result[i] == a[i],\n        forall|j: int| 0 <= j < b.len() ==> result[a.len() + j] == b[j]", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0058", "language": "verus", "source": "numpy_triple", "source_id": "array_manipulation_insert", "vc-description": "numpy.insert: Insert values along the given axis before the given indices.\n\nCreates a new vector with values inserted at specified positions. For the 1D case,\nvalues are inserted before the given index position, shifting subsequent elements.\n\nWhen inserting a single value at position i into a vector of length n,\nthe result has length n+1 where:\n- Elements before position i remain unchanged\n- The new value is at position i\n- Elements from position i onward are shifted by one\n\nThis specification focuses on single value insertion. The actual NumPy function\nsupports multiple insertions and various index specifications, but for formal\nverification we start with the simplest case.\n\nSpecification: numpy.insert creates a new vector with the value inserted at the specified index.\n\nPrecondition: The index is valid (enforced by type system via Fin (n + 1))\n\nPostcondition: \n1. **Preservation**: Elements before the insertion point are preserved at their original indices\n2. **Insertion**: The new value is placed exactly at the specified index\n3. **Shifting**: Elements at or after the insertion point are shifted right by one position\n4. **Size**: The result has exactly one more element than the input\n\nMathematical properties:\n- For all i < idx: result[i] = arr[i]\n- result[idx] = value\n- For all i > idx: result[i] = arr[i-1]\n\nAdditional properties (sanity checks):\n- The operation is deterministic (same inputs produce same output)\n- The operation preserves the relative order of existing elements\n- No elements from the original array are lost or duplicated\n\n/* Elements before insertion point are preserved */\n\n/* The new value is at the specified index */\n\n/* Elements after insertion point are shifted */\n\n/* Sanity check: all original elements are preserved */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_insert<T>(arr: Vec<T>, idx: usize, value: T) -> (result: Vec<T>)\n    requires idx <= arr.len(),\n    ensures \n        result.len() == arr.len() + 1,\n\n        forall|i: int| 0 <= i < idx ==> result[i] == arr[i],\n\n        result[idx as int] == value,\n\n        forall|i: int| (idx as int) < i < result.len() ==> result[i] == arr[i - 1],\n\n        forall|j: int| 0 <= j < arr.len() ==> \n            (j < idx && result[j] == arr[j]) || \n            (j >= idx && result[j + 1] == arr[j])", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0060", "language": "verus", "source": "numpy_triple", "source_id": "array_manipulation_moveaxis", "vc-description": "Move axes of an array to new positions.\n\nMove axes in a 1D vector (simplified version).\nFor 1D arrays, moveaxis with source=0 and destination=0 returns the array unchanged.\nThis captures the core mathematical property that moving an axis to itself is identity.\n\nSpecification: moveaxis preserves all elements and their values.\nFor 1D arrays, moveaxis is always the identity function since there's only one axis.\nThis specification captures several mathematical properties:\n1. Element preservation: all values remain unchanged\n2. Size preservation: the shape is maintained\n3. Identity property: moving axis 0 to position 0 is identity\n4. Order preservation: for 1D arrays, element order is maintained", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn moveaxis(a: Vec<f32>, source: usize, dest: usize) -> (result: Vec<f32>)\n    ensures\n        /* Core property: moveaxis on 1D array is identity */\n        forall|i: int| 0 <= i < a.len() ==> result[i] == a[i],\n        /* Sanity check: size is preserved */\n        result.len() == a.len(),\n        /* Mathematical property: for 1D arrays, result equals input */\n        result@ == a@,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0061", "language": "verus", "source": "numpy_triple", "source_id": "array_manipulation_ndim", "vc-description": "numpy.ndim: Return the number of dimensions of an array.\n\nIn our Vector-based framework, vectors are always 1-dimensional.\nThis function returns 1 for any vector input, representing the fact\nthat Vector T n is a 1D array with n elements.\n\nNote: In NumPy, scalars are 0-dimensional, but in our framework,\nwe represent them as Vector T 1, so this always returns 1.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn ndim<T>(a: &Vec<T>) -> (result: usize)\n    ensures result == 1", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0062", "language": "verus", "source": "numpy_triple", "source_id": "array_manipulation_ravel", "vc-description": "numpy.ravel: Return a contiguous flattened array.\n\nFor 1D arrays, ravel returns the input array unchanged since it's already\nflat. This reflects numpy's behavior where raveling a 1D array has no effect.\n\nFor multi-dimensional arrays (not covered here), ravel would flatten them\ninto a 1D array following the specified order ('C' for row-major, 'F' for\ncolumn-major, etc.).\n\nSpecification: numpy.ravel returns the input vector unchanged for 1D arrays.\n\nPrecondition: True (no special preconditions for 1D ravel)\nPostcondition: The result is identical to the input vector, maintaining\n               all elements in their original order", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn ravel(a: Vec<f32>) -> (result: Vec<f32>)\n    ensures result@ == a@", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0064", "language": "verus", "source": "numpy_triple", "source_id": "array_manipulation_reshape", "vc-description": "Gives a new shape to an array without changing its data.\n\nThis implementation focuses on the most common case: reshaping a 1D array\nto another 1D array with the same total number of elements. The elements\nare preserved in the same linear order (C-order).\n\nFor simplicity, this specification handles only 1D to 1D reshaping where\nthe sizes are explicitly equal. More complex reshaping operations (like\nmultidimensional arrays or -1 inference) would require additional machinery.\n\nSpecification: reshape preserves all elements in their linear order.\n\nThe reshape operation creates a new vector with a different size parameter\nbut maintains the same elements in the same order. This is the fundamental\nproperty of reshape - it's purely a \"view\" operation that doesn't modify data.\n\nMathematical properties:\n1. Size preservation: The total number of elements remains constant\n2. Order preservation: Elements appear in the same linear sequence\n3. Value preservation: Each element value is unchanged\n\nPrecondition: The new shape must have the same total size as the original\nPostcondition: Each element at index i in the result equals the element\n             at the corresponding index in the original array", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn reshape(a: Vec<f32>) -> (result: Vec<f32>)\n    requires a.len() > 0,\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == a[i]", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0065", "language": "verus", "source": "numpy_triple", "source_id": "array_manipulation_resize", "vc-description": "Return a new vector with the specified size by repeating elements from the input vector.\nIf the new size is larger, elements are repeated cyclically.\nIf the new size is smaller, only the first elements are taken.\n\nSpecification: resize creates a new vector of the specified size by either:\n1. Taking the first `new_size` elements if `new_size ≤ n`\n2. Repeating the original elements cyclically if `new_size > n` and `n > 0`\n\nThe function handles three cases:\n- Shrinking: new_size < n → takes first new_size elements\n- Same size: new_size = n → returns identical vector\n- Growing: new_size > n → repeats elements cyclically (when n > 0)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn resize<T>(a: Vec<T>, new_size: usize) -> (result: Vec<T>)\n    ensures\n        result.len() == new_size,\n        forall|i: int| 0 <= i < new_size ==> {\n            if i < a.len() {\n                result[i] == a[i]\n            } else if a.len() > 0 {\n                result[i] == a[(i % a.len() as int) as int]\n            } else {\n                true\n            }\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0066", "language": "verus", "source": "numpy_triple", "source_id": "array_manipulation_roll", "vc-description": "Roll array elements along a given axis by cyclically shifting elements.\nElements that roll beyond the last position are re-introduced at the first.\n\nSpecification: roll cyclically shifts array elements by the given amount.\nFor positive shift, elements move to the right and wrap around.\nFor negative shift, elements move to the left and wrap around.\nEmpty vectors are returned unchanged.\n\nMathematical property: result[i] = a[(i - shift) mod n]\nwhere the modulo operation handles negative values correctly.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn normalize_index(i: int, shift: int, n: int) -> int {\n    let src_idx = i - shift;\n    let mod_result = src_idx % n;\n    if mod_result < 0 { mod_result + n } else { mod_result }\n}\n\nfn roll<T>(a: Vec<T>, shift: i32) -> (result: Vec<T>)\n    ensures\n        result.len() == a.len(),\n        a.len() == 0 ==> result@ == a@,\n        a.len() > 0 ==> forall|i: int| 0 <= i < a.len() ==> #[trigger] result[i] == a[normalize_index(i, shift as int, a.len() as int)]", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0067", "language": "verus", "source": "numpy_triple", "source_id": "array_manipulation_rollaxis", "vc-description": "numpy.rollaxis: Roll the specified axis backwards, until it lies in a given position.\n\nFor 1D arrays, this is a no-op - it returns the input array unchanged.\nThis is because with only one axis (axis 0), there's nowhere to roll it to.\nThe axis and start parameters are ignored in the 1D case.\n\nNote: This function is deprecated in favor of moveaxis, but we provide\nthe specification for completeness.\n\nSpecification: numpy.rollaxis returns the input vector unchanged for 1D arrays.\n\nPrecondition: True (no special preconditions for 1D rollaxis)\nPostcondition: The result is identical to the input vector\n\nMathematical property: For 1D arrays, rollaxis is the identity function\nsince there's only one axis that cannot be moved.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_rollaxis(a: Vec<f32>, axis: i32, start: i32) -> (result: Vec<f32>)\n    ensures result == a", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0068", "language": "verus", "source": "numpy_triple", "source_id": "array_manipulation_rot90", "vc-description": "numpy.rot90: Rotate an array by 90 degrees in the plane specified by axes.\n\nFor a 2D array, this function rotates the array counterclockwise by 90 degrees\nwhen k=1. The rotation transforms element at position (i,j) to position \n(j, n-1-i) for a square matrix of size n×n. Multiple rotations can be achieved \nby setting k to the desired number of 90-degree rotations.\n\nThis specification focuses on square 2D arrays for simplicity.\n\nSpecification: rot90 rotates a square 2D matrix by 90 degrees counterclockwise k times.\n\nThe specification handles k modulo 4 since four 90-degree rotations return\nto the original orientation:\n- k ≡ 0 (mod 4): No rotation (identity)\n- k ≡ 1 (mod 4): 90° counterclockwise rotation\n- k ≡ 2 (mod 4): 180° rotation  \n- k ≡ 3 (mod 4): 270° counterclockwise (= 90° clockwise)\n\nMathematical properties:\n1. rot90 is a group action: rot90(m, k1 + k2) = rot90(rot90(m, k1), k2)\n2. rot90(m, 4) = m (period 4)\n3. rot90(m, -k) = rot90(m, 4-k) (inverse rotation)\n\nFor a 90° counterclockwise rotation, the transformation is:\n- Element at position (i,j) moves to position (j, n-1-i)\n- This preserves distances and angles (isometry)\n\nSanity checks:\n- Corner elements rotate correctly: (0,0) → (0,n-1) → (n-1,n-1) → (n-1,0) → (0,0)\n- Center element of odd-sized matrix stays fixed for k=2\n\nPrecondition: Matrix is non-empty (n > 0)\nPostcondition: Elements are repositioned according to the rotation formula", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn rot90(m: Vec<Vec<f32>>, k: i32) -> (result: Vec<Vec<f32>>)\n    requires\n        m.len() > 0,\n        forall|i: int| 0 <= i < m.len() ==> m[i].len() == m.len(),\n    ensures\n        result.len() == m.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == m.len()", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0069", "language": "verus", "source": "numpy_triple", "source_id": "array_manipulation_row_stack", "vc-description": "Stack a list of 1-D vectors as rows into a 2-D matrix (Vector of Vectors).\nEach input vector becomes a row in the output matrix.\n\nSpecification: row_stack returns a matrix where each row corresponds to an input vector.\nThe i-th row of the result is exactly the i-th input vector (identity transformation).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn row_stack(arrays: Vec<Vec<f32>>) -> (result: Vec<Vec<f32>>)\n    requires arrays.len() > 0,\n             forall|i: int| 0 <= i < arrays.len() ==> arrays[i].len() > 0,\n             forall|i: int, j: int| 0 <= i < arrays.len() && 0 <= j < arrays.len() ==> \n                 arrays[i].len() == arrays[j].len(),\n    ensures result.len() == arrays.len(),\n            forall|i: int| 0 <= i < result.len() ==> result[i].len() == arrays[i].len(),\n            forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result[i].len() ==>\n                result[i][j] == arrays[i][j]", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0070", "language": "verus", "source": "numpy_triple", "source_id": "array_manipulation_shape", "vc-description": "numpy.shape: Return the shape of an array.\n\nFor a one-dimensional vector, returns its length as a natural number.\nThis corresponds to the single element in the shape tuple for 1D arrays\nin NumPy.\n\nIn the general NumPy implementation, shape returns a tuple of dimensions.\nFor our Vector type, which is inherently one-dimensional, the shape is\nsimply the length parameter n.\n\nSpecification: numpy.shape returns the length of the vector.\n\nFor a Vector of length n, the shape function returns n.\nThis captures the fundamental property that the shape of a 1D array\nis its length.\n\nPrecondition: True (shape is defined for all vectors)\nPostcondition: The result equals the length parameter n of the vector", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn shape<T>(a: &Vec<T>) -> (result: usize)\n    ensures result == a.len()", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0071", "language": "verus", "source": "numpy_triple", "source_id": "array_manipulation_size", "vc-description": "Returns the number of elements in a vector\n\nSpecification: size returns the length of the vector, which is its type parameter n", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn size(a: &Vec<f64>) -> (result: usize)\n    ensures result == a.len()", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0072", "language": "verus", "source": "numpy_triple", "source_id": "array_manipulation_split", "vc-description": "Split a vector into k equal parts. Requires that the vector length is divisible by k.\n\nSpecification: split divides a vector into k equal-sized sub-vectors \nwhere each sub-vector contains consecutive elements from the original.\n\nThe specification states that:\n1. The result is a vector of k sub-vectors\n2. Each sub-vector has size n/k \n3. Element j of sub-vector i corresponds to element (i * (n/k) + j) of the original vector\n4. All elements from the original vector are preserved in the split", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn split(arr: Vec<f32>, k: usize) -> (result: Vec<Vec<f32>>)\n    requires\n        k > 0,\n        arr.len() % k == 0,\n    ensures\n        result.len() == k,\n        forall|i: int| #[trigger] result[i].len() == (arr.len() / k) ==> (0 <= i < k),\n        forall|i: int, j: int| \n            0 <= i < k && 0 <= j < (arr.len() / k) as int ==> {\n                let idx = i * (arr.len() / k) as int + j;\n                0 <= idx < arr.len() as int && #[trigger] result[i][j] == arr[idx]\n            },", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0073", "language": "verus", "source": "numpy_triple", "source_id": "array_manipulation_squeeze", "vc-description": "Squeeze a single-element vector to extract its value.\nThis is a simplified 1D version of numpy.squeeze for vectors of size 1.\n\nSpecification: squeeze extracts the single element from a size-1 vector.\n\nMathematical properties:\n1. The result equals the first (and only) element of the input vector\n2. For any function f, squeeze preserves function application: f(squeeze(a)) = f(a[0])\n3. squeeze is the inverse of creating a single-element vector\n\nSanity checks:\n- The input must be a vector of exactly size 1\n- The output type changes from Vector to the element type\n- This models numpy's behavior where squeeze([x]) returns x as a 0D array", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn squeeze<T>(a: Vec<T>) -> T\n    recommends a.len() == 1\n{\n    a[0]\n}\n\nfn squeeze_exec<T: Copy>(a: Vec<T>) -> (result: T)\n    requires a.len() == 1,\n    ensures \n        result == squeeze(a),\n        result == a[0],\n        forall|b: Vec<T>| b.len() == 1 && squeeze(a) == squeeze(b) ==> a[0] == b[0],\n        forall|i: int| 0 <= i < a.len() ==> a[i] == result,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0074", "language": "verus", "source": "numpy_triple", "source_id": "array_manipulation_stack", "vc-description": "Stack a sequence of vectors along a new axis to create a 2D matrix.\nFor simplicity, we focus on stacking 1D vectors along axis 0.\nThe result has shape (m, n) where m is the number of vectors and n is their common length.\n\nSpecification: stack creates a 2D matrix where each input vector becomes a row.\nKey properties:\n1. The result preserves all input vectors as rows\n2. The i-th row of the result equals the i-th input vector\n3. Shape property: stacking m vectors of length n produces an m×n matrix", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn stack(arrays: Vec<Vec<f32>>) -> (result: Vec<Vec<f32>>)\n    requires \n        arrays.len() > 0,\n        forall|i: int| 0 <= i < arrays.len() ==> #[trigger] arrays[i].len() == arrays[0].len(),\n    ensures\n        result.len() == arrays.len(),\n        forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i].len() == arrays[0].len(),\n        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result[i].len() ==> #[trigger] result[i][j] == #[trigger] arrays[i][j],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0076", "language": "verus", "source": "numpy_triple", "source_id": "array_manipulation_tile", "vc-description": "Constructs a vector by repeating the input vector `reps` times.\nFor 1D case: tile([a, b, c], 3) = [a, b, c, a, b, c, a, b, c]\n\nSpecification: tile repeats the input vector `reps` times, where each element\nat position i in the result corresponds to element at position (i % n) in the input", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn tile(a: Vec<i32>, reps: usize) -> (result: Vec<i32>)\n    requires \n        reps > 0,\n        a.len() > 0,\n    ensures\n        result.len() == a.len() * reps,\n        forall|i: int| 0 <= i < result.len() ==> result[i] == a[i % (a.len() as int)],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0078", "language": "verus", "source": "numpy_triple", "source_id": "array_manipulation_trim_zeros", "vc-description": "numpy.trim_zeros: Trim the leading and/or trailing zeros from a 1-D array.\n\nRemoves zeros from the beginning and/or end of a vector based on the trim mode.\n- Front: removes leading zeros only\n- Back: removes trailing zeros only\n- Both: removes both leading and trailing zeros (default)\n\nThe function preserves all non-zero elements and internal zeros.\n\nSpecification: trim_zeros removes leading and/or trailing zeros while preserving order.\n\nThe function guarantees:\n1. All non-zero elements from the original array are preserved in order\n2. Internal zeros (zeros between non-zero elements) are preserved\n3. Only leading/trailing zeros are removed based on the mode\n4. If the array contains only zeros, returns an empty vector", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* Represents the trim mode for trim_zeros function */\n#[derive(Eq, PartialEq)]\npub enum TrimMode {\n    /* Trim zeros from the front of the array only (corresponds to 'f') */\n    Front,\n    /* Trim zeros from the back of the array only (corresponds to 'b') */\n    Back,\n    /* Trim zeros from both front and back of the array (corresponds to 'fb', default) */\n    Both,\n}", "vc-helpers": "", "vc-spec": "fn trim_zeros(arr: Vec<f32>, mode: TrimMode) -> (result: Vec<f32>)\n    ensures\n        result@.len() <= arr@.len(),\n        /* Result contains only elements from the original array */\n        forall|i: int| 0 <= i < result@.len() ==> \n            exists|j: int| 0 <= j < arr@.len() && #[trigger] result@[i] == arr@[j],\n        /* Basic trimming properties based on mode */\n        (mode == TrimMode::Front ==> \n            (result@.len() == 0 || result@[0] != 0.0f32)),\n        (mode == TrimMode::Back ==> \n            (result@.len() == 0 || result@[result@.len() - 1] != 0.0f32)),\n        (mode == TrimMode::Both ==> \n            (result@.len() == 0 || (result@[0] != 0.0f32 && result@[result@.len() - 1] != 0.0f32)))", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0079", "language": "verus", "source": "numpy_triple", "source_id": "array_manipulation_unique", "vc-description": "numpy.unique: Find the unique elements of a vector and return them sorted.\n\nReturns a new vector containing each distinct element from the input exactly once,\nsorted in ascending order. This is a simplified version that only returns the \nunique values without the optional indices or counts.\n\nThe output size depends on the number of unique elements in the input.\n\nSpecification: numpy.unique returns a sorted vector containing each distinct element \nfrom the input exactly once.\n\nPrecondition: True\nPostcondition: \n- The result is sorted in ascending order\n- No duplicates exist in the result\n- Every element in result comes from the input array\n- Every distinct element from input appears in result", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_sorted(arr: Seq<i32>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < arr.len() ==> arr[i] <= arr[j]\n}\n\nspec fn has_no_duplicates(arr: Seq<i32>) -> bool {\n    forall|i: int, j: int| 0 <= i < arr.len() && 0 <= j < arr.len() && i != j ==> arr[i] != arr[j]\n}\n\nspec fn all_elements_from_input(result: Seq<i32>, input: Seq<i32>) -> bool {\n    forall|i: int| 0 <= i < result.len() ==> #[trigger] input.contains(result[i])\n}\n\nspec fn all_distinct_elements_present(input: Seq<i32>, result: Seq<i32>) -> bool {\n    forall|val: i32| input.contains(val) ==> #[trigger] result.contains(val)\n}\n\nfn numpy_unique(arr: Vec<i32>) -> (result: (usize, Vec<i32>))\n    ensures\n        is_sorted(result.1@),\n        has_no_duplicates(result.1@),\n        all_elements_from_input(result.1@, arr@),\n        all_distinct_elements_present(arr@, result.1@),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0081", "language": "verus", "source": "numpy_triple", "source_id": "array_manipulation_vstack", "vc-description": "Stack two vectors vertically to create a 2D matrix.\nFor 1D vectors, this treats them as row vectors and stacks them vertically.\nThis is a simplified version focusing on the common case of stacking two 1D vectors.\n\nSpecification: vstack stacks two vectors vertically, creating a 2x n matrix\nwhere the first row is vector a and the second row is vector b.\n\nMathematical properties:\n1. The result has shape (2, n) where n is the length of input vectors\n2. The first row of the result equals the first input vector\n3. The second row of the result equals the second input vector\n4. This operation preserves the elements and their order within each vector", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn vstack(a: Vec<f32>, b: Vec<f32>) -> (result: Vec<Vec<f32>>)\n    requires a.len() == b.len(),\n    ensures\n        result.len() == 2,\n        result[0].len() == a.len(),\n        result[1].len() == b.len(),\n        forall|j: int| 0 <= j < a.len() ==> result[0][j] == a[j],\n        forall|j: int| 0 <= j < b.len() ==> result[1][j] == b[j]", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0082", "language": "verus", "source": "numpy_triple", "source_id": "bitwise_operations_binary_repr", "vc-description": "Return the binary representation of the input number as a string.\nFor negative numbers, if width is not given, a minus sign is added to the front.\nIf width is given, the two's complement of the number is returned.\n\nSpecification: binary_repr correctly converts integers to binary strings with proper\nhandling of negative numbers (signed representation without width, two's complement with width)\n\n/* Helper function to convert a natural number to its binary string representation */\n\n/* Helper function to check if a string represents a valid binary number */\n\n/* Helper function to check if a string represents a valid signed binary number */\n\n/* Result is a valid binary string (possibly with sign) */\n\n/* Length constraints */\n\n/* Positive numbers: standard binary representation */\n\n/* Negative numbers without width: signed representation */\n\n/* Two's complement properties for negative numbers with width */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn nat_to_binary_string(n: nat) -> Seq<char>\n    decreases n\n{\n    if n == 0 {\n        seq!['0']\n    } else {\n        let digit = if n % 2 == 0 { '0' } else { '1' };\n        nat_to_binary_string(n / 2).push(digit)\n    }\n}\n\nspec fn is_valid_binary(s: Seq<char>) -> bool {\n    s.len() > 0 && (forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1')\n}\n\nspec fn is_valid_signed_binary(s: Seq<char>) -> bool {\n    if s.len() > 0 && s[0] == '-' {\n        is_valid_binary(s.skip(1))\n    } else {\n        is_valid_binary(s)\n    }\n}", "vc-helpers": "", "vc-spec": "fn binary_repr(num: i32, width: Option<usize>) -> (result: Vec<char>)\n    requires \n        width.is_some() ==> width.get_Some_0() >= 1,\n    ensures \n\n        width.is_none() ==> is_valid_signed_binary(result@),\n        width.is_some() ==> is_valid_binary(result@),\n\n        width.is_some() ==> result.len() == width.get_Some_0(),\n\n        (num >= 0 && width.is_none()) ==> \n            result@ == nat_to_binary_string(num as nat),\n\n        (num < 0 && width.is_none()) ==> \n            result@.len() > 0 && result@[0] == '-' && is_valid_binary(result@.skip(1)),\n\n        (num < 0 && width.is_some()) ==> {\n            let w = width.get_Some_0();\n            let two_comp = (1u32 << w) as i32 + num;\n            two_comp >= 0 && two_comp < (1i32 << w) && result.len() == w\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0083", "language": "verus", "source": "numpy_triple", "source_id": "bitwise_operations_bitwise_and", "vc-description": "numpy.bitwise_and: Compute the bit-wise AND of two arrays element-wise.\n\nComputes the bit-wise AND of the underlying binary representation of \nthe integers in the input arrays. This ufunc implements the C/Python \noperator &.\n\nFor each pair of corresponding elements in x1 and x2, the result contains\nthe bitwise AND of their binary representations. Each bit position in the\nresult is 1 only if both corresponding bits in x1 and x2 are 1.\n\nExamples:\n- 13 & 17 = 1 (binary: 01101 & 10001 = 00001)\n- 14 & 13 = 12 (binary: 01110 & 01101 = 01100)\n\nNote: This specification currently handles only non-negative integers.\nFor negative integers, NumPy uses two's complement representation,\nwhich requires a more complex formalization in Lean.\n\nSpecification: bitwise_and returns a vector where each element is the \nbitwise AND of the corresponding elements from x1 and x2.\n\nPrecondition: All elements are non-negative (to simplify the specification)\n\nPostcondition: \n1. For non-negative integers, each element of the result is the bitwise AND \n   of corresponding inputs\n2. The result preserves the mathematical properties of bitwise AND:\n   - Commutativity: x & y = y & x\n   - Associativity: (x & y) & z = x & (y & z)\n   - Identity: x & (2^k - 1) = x for x < 2^k (all 1s acts as identity)\n   - Annihilator: x & 0 = 0\n   - Idempotence: x & x = x\n3. The result is always less than or equal to both inputs (for non-negative integers)\n4. Each bit in the result is 1 iff both corresponding bits in the inputs are 1", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn bitwise_and(x1: Vec<u8>, x2: Vec<u8>) -> (result: Vec<u8>)\n    requires \n        x1.len() == x2.len(),\n        forall|i: int| 0 <= i < x1.len() ==> x1[i] as int >= 0,\n        forall|i: int| 0 <= i < x2.len() ==> x2[i] as int >= 0,\n    ensures\n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == (x1[i] & x2[i]),\n        forall|i: int| 0 <= i < result.len() ==> result[i] as int >= 0,\n        forall|i: int| 0 <= i < result.len() ==> result[i] as int <= x1[i] as int,\n        forall|i: int| 0 <= i < result.len() ==> result[i] as int <= x2[i] as int,\n        forall|i: int| 0 <= i < result.len() ==> (result[i] == 0 <==> (x1[i] == 0 || x2[i] == 0)),\n        forall|i: int| 0 <= i < result.len() ==> (x1[i] == x2[i] ==> result[i] == x1[i]),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0084", "language": "verus", "source": "numpy_triple", "source_id": "bitwise_operations_bitwise_count", "vc-description": "Computes the number of 1-bits in the absolute value of each element in a vector\n\nSpecification: bitwise_count returns the count of 1-bits in the binary representation\nof the absolute value of each element. The result satisfies several properties:\n1. Each output element is the popcount of the corresponding input's absolute value\n2. The popcount is bounded by the number of bits in the representation\n3. Zero inputs produce zero outputs\n4. Powers of 2 have exactly one bit set\n5. Powers of 2 minus 1 have consecutive 1-bits (e.g., 2^k - 1 has k bits set)\n6. The popcount is always non-negative and bounded by bit width\n7. For negative inputs, uses the absolute value\n8. The popcount operation is invariant under sign changes\n\n/* Helper function to count the number of 1-bits in a natural number */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn abs_spec(x: i32) -> nat {\n    if x >= 0 { x as nat } else { (-x) as nat }\n}\n\nspec fn popcount(n: nat) -> nat \n    decreases n\n{\n    if n == 0 {\n        0\n    } else {\n        (n % 2) + popcount(n / 2)\n    }\n}", "vc-helpers": "", "vc-spec": "fn bitwise_count(x: Vec<i32>) -> (result: Vec<nat>)\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == popcount(abs_spec(x[i])),\n        forall|i: int| 0 <= i < result.len() ==> x[i] == 0 ==> result[i] == 0,\n        forall|i: int| 0 <= i < result.len() ==> result[i] >= 0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0085", "language": "verus", "source": "numpy_triple", "source_id": "bitwise_operations_bitwise_or", "vc-description": "Compute the bit-wise OR of two vectors element-wise\n\n// placeholder implementation\n\n// placeholder implementation", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn bitwise_or_int(x: i32, y: i32) -> i32 {\n    x\n}\n\nspec fn bitwise_and_int(x: i32, y: i32) -> i32 {\n    x\n}\n\nspec fn bitwise_or_vec(x: Seq<i32>, y: Seq<i32>) -> Seq<i32>\n    recommends x.len() == y.len()\n{\n    Seq::new(x.len(), |i: int| x[i])\n}\n\nfn bitwise_or_fn(x1: Vec<i32>, x2: Vec<i32>) -> (result: Vec<i32>)\n    requires x1.len() == x2.len(),\n    ensures \n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == bitwise_or_int(x1[i], x2[i]),\n        forall|i: int| 0 <= i < result.len() && x2[i] == 0 ==> result[i] == x1[i],\n        forall|i: int| 0 <= i < result.len() && x1[i] == 0 ==> result[i] == x2[i],\n        forall|i: int| 0 <= i < result.len() && (x1[i] == -1i32 || x2[i] == -1i32) ==> result[i] == -1i32,\n        result@ == bitwise_or_vec(x1@, x2@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0086", "language": "verus", "source": "numpy_triple", "source_id": "bitwise_operations_bitwise_xor", "vc-description": "Compute the bit-wise XOR of two arrays element-wise.\n\nComputes the bit-wise XOR (exclusive OR) of the underlying binary representation \nof the integers in the input arrays. This ufunc implements the C/Python \noperator ^.\n\nFor each pair of corresponding elements in x1 and x2, the result contains\nthe bitwise XOR of their binary representations. Each bit position in the\nresult is 1 if and only if exactly one of the corresponding bits in x1 and x2 is 1.\n\nExamples:\n- 13 ^ 17 = 28 (binary: 01101 ^ 10001 = 11100)\n- 31 ^ 5 = 26 (binary: 11111 ^ 00101 = 11010)\n- 31 ^ 3 = 28 (binary: 11111 ^ 00011 = 11100)\n\nNote: This specification currently handles only non-negative integers.\nFor negative integers, NumPy uses two's complement representation,\nwhich requires a more complex formalization.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn bitwise_xor(x1: Vec<i32>, x2: Vec<i32>) -> (result: Vec<i32>)\n    requires \n        x1.len() == x2.len(),\n        forall|i: int| 0 <= i < x1.len() ==> x1[i] >= 0,\n        forall|i: int| 0 <= i < x2.len() ==> x2[i] >= 0,\n    ensures\n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == (x1[i] ^ x2[i]),\n        forall|i: int| 0 <= i < result.len() ==> result[i] >= 0,\n        forall|i: int| 0 <= i < result.len() && x1[i] == 0 ==> result[i] == x2[i],\n        forall|i: int| 0 <= i < result.len() && x2[i] == 0 ==> result[i] == x1[i],\n        forall|i: int| 0 <= i < result.len() && x1[i] == x2[i] ==> result[i] == 0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0087", "language": "verus", "source": "numpy_triple", "source_id": "bitwise_operations_invert", "vc-description": "Compute bit-wise inversion (NOT) of each element in a vector of integers.\nFor signed integers, this returns the two's complement.\n\nSpecification: invert computes the bitwise NOT operation element-wise.\n\nMathematical properties:\n1. Two's complement relationship: ~x = -(x + 1)\n2. Involution property: applying invert twice returns the original value\n3. The operation preserves vector size\n4. Identity relationships:\n   - ~0 = -1\n   - ~(-1) = 0\n5. Sign flipping: ~x has opposite sign to x when x ≠ -1\n\nThe specification captures both the element-wise nature and the \nmathematical relationship for two's complement representation.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn invert(x: Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < x.len() ==> result[i] == -(x[i] + 1),\n        forall|i: int| 0 <= i < x.len() && x[i] == 0 ==> result[i] == -1,\n        forall|i: int| 0 <= i < x.len() && x[i] == -1 ==> result[i] == 0,\n        forall|i: int| 0 <= i < x.len() && x[i] != -1 ==> (x[i] > 0 <==> result[i] < 0),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0088", "language": "verus", "source": "numpy_triple", "source_id": "bitwise_operations_left_shift", "vc-description": "Shift the bits of integers to the left element-wise.\nThis operation is equivalent to multiplying each element by 2^shift_amount.\n\nSpecification: left_shift performs bitwise left shift operation on each element.\nThe result is equivalent to multiplying x1[i] by 2^x2[i] for non-negative shifts.\n\nMathematical properties:\n1. Core behavior: Each element result[i] = x1[i] * 2^x2[i] for non-negative shifts\n2. Identity property: Shifting by 0 returns the original value\n3. Zero preservation: Shifting zero always yields zero\n4. Monotonicity: For positive values, left shifting increases magnitude\n5. Composition property: left_shift(x, a) then left_shift(result, b) = left_shift(x, a+b)", "vc-preamble": "use vstd::prelude::*;\nuse vstd::arithmetic::power::pow;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn left_shift(x1: Vec<i32>, x2: Vec<i32>) -> (result: Vec<i32>)\n    requires\n        x1.len() == x2.len(),\n        forall|i: int| 0 <= i < x2.len() ==> x2[i] >= 0,\n    ensures\n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == x1[i] * pow(2, x2[i] as nat),\n        forall|i: int| 0 <= i < result.len() && x2[i] == 0 ==> result[i] == x1[i],\n        forall|i: int| 0 <= i < result.len() && x1[i] == 0 ==> result[i] == 0,\n        forall|i: int| 0 <= i < result.len() && x1[i] > 0 && x2[i] > 0 ==> result[i] > x1[i],\n        forall|i: int| 0 <= i < result.len() && x1[i] < 0 && x2[i] > 0 ==> result[i] < x1[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0090", "language": "verus", "source": "numpy_triple", "source_id": "bitwise_operations_right_shift", "vc-description": "Shift the bits of an integer to the right element-wise. This operation is equivalent to dividing each element by 2^shift_amount using integer division. For negative inputs, the behavior follows arithmetic right shift with sign extension.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn right_shift(x1: Vec<i32>, x2: Vec<i32>) -> (result: Vec<i32>)\n    requires \n        x1.len() == x2.len(),\n        forall|i: int| 0 <= i < x2.len() ==> x2[i] >= 0,\n    ensures\n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> {\n            &&& (x1[i] >= 0 ==> result[i] == x1[i] / (1i32 << x2[i]))\n            &&& (x1[i] < 0 ==> result[i] == x1[i] >> x2[i])\n            &&& (x2[i] == 0 ==> result[i] == x1[i])\n            &&& (x1[i] > 0 ==> result[i] >= 0)\n            &&& (x1[i] < 0 ==> result[i] <= 0)\n            &&& (x1[i] == 0 ==> result[i] == 0)\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0091", "language": "verus", "source": "numpy_triple", "source_id": "bitwise_operations_unpackbits", "vc-description": "numpy.unpackbits: Unpacks elements of a uint8 array into a binary-valued output array.\n\nEach element of the input array represents a bit-field that is unpacked into\na binary-valued output array. By default, each uint8 value is unpacked into\n8 binary values (0 or 1) using big-endian bit order.\n\nThis specification covers the basic 1D case with default parameters.\nFor simplicity, we use Nat instead of UInt8, with the constraint that input values < 256.", "vc-preamble": "use vstd::prelude::*;\nuse vstd::arithmetic::power::pow;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_unpackbits(a: Vec<u8>) -> (result: Vec<u8>)\n    requires forall|i: int| 0 <= i < a@.len() ==> a@[i] < 256,\n    ensures \n        result@.len() == a@.len() * 8,\n        forall|i: int, j: int| 0 <= i < a@.len() && 0 <= j < 8 ==> \n            #[trigger] result@[i * 8 + j] == ((a@[i] as int) / pow(2, (7 - j) as nat)) % 2", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0093", "language": "verus", "source": "numpy_triple", "source_id": "constants_NINF", "vc-description": "IEEE 754 floating point representation of negative infinity (deprecated in NumPy 2.0)\n\nSpecification: NINF represents negative infinity with the following properties:\n1. NINF is less than any finite float value\n2. NINF + any finite value = NINF\n3. NINF * positive finite value = NINF\n4. NINF * negative finite value = inf\n5. NINF / any finite non-zero value = NINF (with appropriate sign)\n6. NINF = -inf (negative of positive infinity)\n\n/* IEEE 754 floating point representation of negative infinity (deprecated in NumPy 2.0) */\n\n// NINF represents a special f64 value (negative infinity)\n\n// Due to Verus limitations with floating point specifications,\n\n// we can only provide basic structural properties\n\n/* Placeholder - actual floating point properties cannot be easily verified in Verus */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn NINF() -> (result: f64)\n    ensures\n\n        true", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0094", "language": "verus", "source": "numpy_triple", "source_id": "constants_NPY_1_PI", "vc-description": "The mathematical constant 1/π (one divided by pi), approximately 0.31831...\n\nSpecification: NPY_1_PI represents the reciprocal of pi (1/π),\nand satisfies key mathematical properties", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn npy_1_pi() -> (result: i32)\n    ensures\n        /* Mathematical constant representing 1/π as a fixed-point approximation */\n        result > 0,\n        /* Basic sanity check for positive value */\n        result < 1000000000,", "vc-code": "{\n    // impl-start\n    assume(false);\n    318309886\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0095", "language": "verus", "source": "numpy_triple", "source_id": "constants_NPY_2_PI", "vc-description": "The mathematical constant 2/π, approximately 0.6366...\n\nSpecification: NPY_2_PI represents the ratio 2/π and satisfies key mathematical properties", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn npy_2_pi() -> (result: i32)\n    ensures\n        result == 636619772,\n        result > 636000000,\n        result < 637000000,", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0096", "language": "verus", "source": "numpy_triple", "source_id": "constants_NPY_LOG2E", "vc-description": "Base 2 logarithm of e\n{\n  \"name\": \"NPY_LOG2E\",\n  \"category\": \"C API Mathematical constants\",\n  \"description\": \"Base 2 logarithm of e\",\n  \"doc\": \"log2(e) = 1.442695040888963407359924681001892137\",\n}\n\nBase 2 logarithm of e (log₂(e))\n\nSpecification: NPY_LOG2E is the base 2 logarithm of e with mathematical properties:\n    1. It is approximately 1.442695040888963407359924681001892137\n    2. It satisfies the relationship: 2^(NPY_LOG2E) = e\n    3. It is the reciprocal of ln(2) (i.e., NPY_LOG2E = 1/ln(2))\n    4. It is used to convert natural logarithms to base 2 logarithms via: log₂(x) = ln(x) * NPY_LOG2E", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn NPY_LOG2E() -> (result: f64)\n    ensures\n        result == 1.442695040888963407359924681001892137,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0097", "language": "verus", "source": "numpy_triple", "source_id": "constants_NPY_LOG10E", "vc-description": "Base 10 logarithm of Euler's number e\n\nNPY_LOG10E returns the base 10 logarithm of e with correct mathematical properties\nlog10(e) = 0.434294481903251827651128918916605082", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn npy_log10e() -> (result: f64)\n    ensures\n        result == 0.434294481903251827651128918916605082", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0098", "language": "verus", "source": "numpy_triple", "source_id": "constants_NPY_LOGE2", "vc-description": "Natural logarithm of 2\n\nNPY_LOGE2 - C API Mathematical constant\nNatural logarithm of 2\nln(2) = 0.693147180559945309417232121458176568\n\nSpecification: nPY_LOGE2 returns the natural logarithm of 2 with correct mathematical properties", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn npy_loge2() -> (result: f64)\n    ensures\n        result == 0.693147180559945309417232121458176568", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0099", "language": "verus", "source": "numpy_triple", "source_id": "constants_NPY_LOGE10", "vc-description": "Natural logarithm of 10\n\nNPY_LOGE10 - C API Mathematical constants\nDescription: Natural logarithm of 10\nDocumentation: ln(10) = 2.302585092994045684017991454684364208\n\nNatural logarithm of 10 (ln(10))\n\nSpecification: npy_loge10 is the natural logarithm of 10 with mathematical properties:\n1. It is approximately 2.302585092994045684017991454684364208\n2. It satisfies the property that e^(npy_loge10) = 10\n3. It is the inverse of log10(e), meaning npy_loge10 * log10(e) = 1\n4. It is useful for converting between natural and base-10 logarithms", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn npy_loge10() -> (result: i8)\n    ensures\n        /* Mathematical property: ln(10) is positive (since 10 > 1) */\n        result as int >= 0,\n        /* Mathematical property: ln(10) > ln(e) = 1 (since 10 > e) */  \n        result as int >= 1,\n        /* Mathematical property: ln(10) is between 2 and 3 */\n        2 <= result as int && result as int <= 3,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0100", "language": "verus", "source": "numpy_triple", "source_id": "constants_NPY_PI_2", "vc-description": "The mathematical constant π/2 (pi divided by 2), approximately 1.5708...\n\nSpecification: NPY_PI_2 represents π/2, which is half of pi and corresponds to 90 degrees\nin radians. It satisfies key mathematical properties related to trigonometry and geometry", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn npy_pi_2() -> (result: i32)\n    ensures\n        /* π/2 is approximately 1.5708... represented as fixed point */\n        1570 < result < 1571,\n        /* Basic sanity check: π/2 is between 1 and 2 */\n        1000 < result < 2000,\n        /* 2*(π/2) should be approximately π (3.14159...) */\n        3141 < 2 * (result as int) < 3142,\n        /* (π/2)/2 = π/4 is approximately 0.7854... */\n        785 < (result as int) / 2 < 786,\n        /* 3*(π/2) = 3π/2 is approximately 4.7124... (270 degrees) */\n        4712 < 3 * (result as int) < 4713,\n        /* 4*(π/2) = 2π is approximately 6.2832... (full circle) */\n        6283 < 4 * (result as int) < 6284,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0101", "language": "verus", "source": "numpy_triple", "source_id": "constants_NPY_PI_4", "vc-description": "NPY_PI_4: Mathematical constant representing π/4.\n\nThis constant provides the value of pi divided by 4, which is commonly used in\ntrigonometric calculations, particularly for 45-degree angle computations.\n\nValue: π/4 ≈ 0.785398163397448309615660845819875721\n\nSpecification: NPY_PI_4 returns the mathematical constant π/4.\n\nPrecondition: True (no preconditions for accessing a constant)\nPostcondition: The result equals π/4, which is approximately 0.7853981633974483\n\nMathematical properties:\n- NPY_PI_4 = π/4\n- NPY_PI_4 = arctan(1)  \n- sin(NPY_PI_4) = cos(NPY_PI_4) = √2/2\n- tan(NPY_PI_4) = 1\n- 4 * NPY_PI_4 = π", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "const NPY_PI_4_EXACT: f64 = 0.785398163397448309615660845819875721;\n\nfn npy_pi_4() -> (result: f64)\n    ensures result == NPY_PI_4_EXACT", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0102", "language": "verus", "source": "numpy_triple", "source_id": "constants_NPY_SQRT1_2", "vc-description": "NPY_SQRT1_2: Square root of 1/2\n\nSquare root of 1/2 as a Float constant\nSpecification: NPY_SQRT1_2 equals the square root of 1/2 with mathematical properties", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn NPY_SQRT1_2() -> (result: f64)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0103", "language": "verus", "source": "numpy_triple", "source_id": "constants_NPY_SQRT2", "vc-description": "Square root of 2 as a mathematical constant with value √2 = 1.414213562373095048801688724209698079. The specification ensures the constant is positive, that its square equals 2 within floating-point precision, and that it matches the expected mathematical value.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "global size_of usize == 8;\n\nspec fn npy_sqrt2_value() -> f64 {\n    1.4142135623730951\n}\n\nfn npy_sqrt2() -> (result: f64)\n    ensures\n        result == npy_sqrt2_value(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    0.0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0104", "language": "verus", "source": "numpy_triple", "source_id": "constants_NZERO", "vc-description": "IEEE 754 floating point representation of negative zero.\n\nSpecification: NZERO represents IEEE 754 negative zero, which equals zero \nbut has special properties in floating point arithmetic", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn NZERO() -> (result: f64)\n    ensures\n        result == 0.0", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0105", "language": "verus", "source": "numpy_triple", "source_id": "constants_PZERO", "vc-description": "IEEE 754 floating point representation of positive zero.\n\nDEPRECATED: Removed from main namespace in NumPy 2.0. Use 0.0 instead.\n\nIEEE 754 floating point representation of positive zero\n\nSpecification: PZERO represents IEEE 754 positive zero with the following properties:\n1. It equals the standard zero value\n2. It behaves as the additive identity\n3. It behaves as expected in multiplication and division\n4. It has special IEEE 754 properties (e.g., 1.0 / PZERO = +∞)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn pzero() -> (result: f64)\n    ensures result == 0.0", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0106", "language": "verus", "source": "numpy_triple", "source_id": "constants_True_", "vc-description": "NumPy's boolean scalar type representing True.\nThis is NumPy's equivalent of Python's built-in True, but as a NumPy scalar type.\nComparison operations in NumPy return this type instead of Python's bool.\n\nSpecification: numpy.True_ represents the boolean value true and has the following properties:\n1. It equals the Lean boolean true\n2. It is the identity element for logical AND operations\n3. It is the absorbing element for logical OR operations\n4. Its negation gives false", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn true_() -> (result: bool)\n    ensures \n        result == true,\n        !result == false", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0107", "language": "verus", "source": "numpy_triple", "source_id": "constants_e", "vc-description": "Euler's constant (e), the base of natural logarithms\n\nEuler's constant, base of natural logarithms, Napier's constant\ne = 2.71828182845904523536028747135266249775724709369995...\n\nEuler's number is the base of the natural logarithm. It is the unique number whose natural logarithm is equal to one.\n\nSpecification: e is Euler's constant with mathematical properties:\n1. It is approximately 2.718281828459045\n2. It is the unique positive real number such that ln(e) = 1\n3. It is the limit of (1 + 1/n)^n as n approaches infinity\n4. It satisfies the property that the derivative of e^x equals e^x\n5. It is the sum of the infinite series 1/0! + 1/1! + 1/2! + ...", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn e() -> (result: f64)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0108", "language": "verus", "source": "numpy_triple", "source_id": "constants_euler_gamma", "vc-description": "The Euler-Mascheroni constant γ, approximately 0.577215...\n\nSpecification: euler_gamma represents the Euler-Mascheroni constant γ,\nwhich is the limiting difference between the harmonic series and the natural logarithm.\nIt satisfies key mathematical properties and bounds\n\n/* The Euler-Mascheroni constant (γ), approximately 0.577215... */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn euler_gamma() -> (result: f64)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0109", "language": "verus", "source": "numpy_triple", "source_id": "constants_finfo", "vc-description": "numpy.finfo: Returns machine limits for floating point types.\n\nGiven a floating-point data type, returns a structure containing\ninformation about the numerical properties and limits of that type,\nincluding epsilon, maximum/minimum values, and precision details.\n\nFor now, we model this as a function that takes Unit and returns\nFloatInfo for the default Float type.\n\nSpecification: numpy.finfo returns consistent and mathematically valid\ninformation about floating-point type limits.\n\nThe returned structure satisfies fundamental properties of floating-point\nrepresentations according to IEEE 754 standard.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* Structure representing floating-point type information */\npub struct FloatInfo {\n    pub eps: u32,              // Machine epsilon (represented as u32)\n    pub epsneg: u32,           // Negative machine epsilon  \n    pub max: u32,              // Maximum representable value\n    pub min: i32,              // Minimum representable value (typically -max)\n    pub tiny: u32,             // Smallest positive normal number\n    pub smallest_subnormal: u32, // Smallest positive subnormal number\n    pub maxexp: i32,           // Maximum exponent\n    pub minexp: i32,           // Minimum exponent\n    pub negep: i32,            // Negative epsilon exponent\n    pub nexp: u32,             // Number of bits in exponent\n    pub nmant: u32,            // Number of bits in mantissa\n    pub precision: u32,        // Approximate decimal precision\n}", "vc-helpers": "", "vc-spec": "fn numpy_finfo() -> (info: FloatInfo)\n    ensures\n        /* Machine epsilon is positive */\n        info.eps > 0,\n        /* Negative epsilon is positive */\n        info.epsneg > 0,\n        /* Max is positive and finite */\n        info.max > 0,\n        /* Min is negative max (for symmetric representation) */\n        info.min == -(info.max as i32),\n        /* Tiny (smallest normal) is positive */\n        info.tiny > 0,\n        /* Smallest subnormal is positive and less than tiny */\n        info.smallest_subnormal > 0,\n        info.smallest_subnormal < info.tiny,\n        /* Exponent relationships */\n        info.maxexp > 0,\n        info.minexp < 0,\n        info.negep < 0,\n        /* Bit counts are positive */\n        info.nexp > 0,\n        info.nmant > 0,\n        /* Precision is at least 1 */\n        info.precision >= 1,\n        /* Relationship between mantissa bits and precision */\n        info.precision <= info.nmant", "vc-code": "{\n    // impl-start\n    assume(false);\n    FloatInfo {\n        eps: 1,\n        epsneg: 1,\n        max: 1,\n        min: -1,\n        tiny: 1,\n        smallest_subnormal: 1,\n        maxexp: 1,\n        minexp: -1,\n        negep: -1,\n        nexp: 1,\n        nmant: 1,\n        precision: 1,\n    }\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0110", "language": "verus", "source": "numpy_triple", "source_id": "constants_iinfo", "vc-description": "Machine limits for integer types - returns information about the given integer type including \nthe number of bits, minimum value, and maximum value.\n\nSpecification: iinfo returns correct machine limits for integer types.\nThe returned IntegerInfo structure contains:\n- bits: the number of bits used by the type\n- min: the minimum representable value (-(2^(bits-1)) for signed, 0 for unsigned)\n- max: the maximum representable value (2^(bits-1) - 1 for signed, 2^bits - 1 for unsigned)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "#[derive(Clone, Copy, PartialEq, Eq)]\npub enum IntegerType {\n    Int8,\n    Int16, \n    Int32,\n    Int64,\n    UInt8,\n    UInt16,\n    UInt32,\n    UInt64,\n}\n\npub struct IntegerInfo {\n    pub bits: u32,\n    pub min: i64,\n    pub max: i64,\n}\n\nfn iinfo(int_type: IntegerType) -> (result: IntegerInfo)\n    ensures match int_type {\n        IntegerType::Int8 => \n            result.bits == 8 && result.min == -128 && result.max == 127,\n        IntegerType::Int16 => \n            result.bits == 16 && result.min == -32768 && result.max == 32767,\n        IntegerType::Int32 => \n            result.bits == 32 && result.min == -2147483648 && result.max == 2147483647,\n        IntegerType::Int64 => \n            result.bits == 64 && result.min == -9223372036854775808 && result.max == 9223372036854775807,\n        IntegerType::UInt8 => \n            result.bits == 8 && result.min == 0 && result.max == 255,\n        IntegerType::UInt16 => \n            result.bits == 16 && result.min == 0 && result.max == 65535,\n        IntegerType::UInt32 => \n            result.bits == 32 && result.min == 0 && result.max == 4294967295,\n        IntegerType::UInt64 => \n            result.bits == 64 && result.min == 0 && result.max == 18446744073709551615,\n    }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0111", "language": "verus", "source": "numpy_triple", "source_id": "constants_inf", "vc-description": "IEEE 754 floating point representation of (positive) infinity\n\nSpecification: inf represents positive infinity with the following properties:\n1. inf is greater than any finite float value\n2. inf + any finite value = inf\n3. inf * positive finite value = inf\n4. inf * negative finite value = -inf\n5. inf / any finite non-zero value = inf (with appropriate sign)\n\n/* IEEE 754 floating point representation of (positive) infinity */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn inf() -> (result: f32)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0112", "language": "verus", "source": "numpy_triple", "source_id": "constants_nan", "vc-description": "IEEE 754 floating point representation of Not a Number (NaN)\n\nIEEE 754 floating point representation of Not a Number (NaN)\n\nSpecification: nan represents Not a Number with the following IEEE 754 properties:\n1. Float.isNaN returns true for NaN (primary property)\n2. Any arithmetic operation with NaN results in NaN\n3. NaN is not ordered (comparisons with any value are false except ≠)\n4. NaN is not finite\n5. Standard operations preserve NaN propagation\n\n// NaN is not equal to itself", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn nan() -> (result: f64)\n    ensures result != result,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0113", "language": "verus", "source": "numpy_triple", "source_id": "constants_newaxis", "vc-description": "A convenient alias for None, useful for indexing arrays. newaxis is an alias for None and is used to expand the dimensions of an array. Expands a vector to a column matrix (n × 1) using newaxis. This models the behavior of a[:, np.newaxis] which converts a 1D array of shape (n,) to a 2D array of shape (n, 1). Specification: expandToColumn creates a column matrix where each element is a singleton vector containing the corresponding element from the input vector. Mathematical property: The resulting matrix has shape (n, 1), each row contains exactly one element from the original vector, result[i][0] = v[i] for all valid indices.\n\n/* Represents the newaxis constant used for dimension expansion.\n   In NumPy, newaxis is used in indexing to add new dimensions to arrays.\n   For our Vector-based implementation, we model this as a function that\n   converts a 1D vector into a 2D vector (matrix) with either shape (n, 1) or (1, n). */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\npub enum NewAxis {\n    Newaxis,\n}", "vc-helpers": "", "vc-spec": "fn expand_to_column(v: Vec<i8>, axis: NewAxis) -> (result: Vec<Vec<i8>>)\n    ensures\n        result@.len() == v@.len(),\n        forall|i: int| 0 <= i < result@.len() ==> (\n            result@[i].len() == 1 &&\n            result@[i][0] == v@[i]\n        ),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0114", "language": "verus", "source": "numpy_triple", "source_id": "constants_pi", "vc-description": "The mathematical constant pi (π), approximately 3.14159...\n\nSpecification: pi represents the ratio of a circle's circumference to its diameter,\nand satisfies key mathematical properties", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn pi() -> (result: i32)\n    ensures\n        result > 3 && result < 4", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0115", "language": "verus", "source": "numpy_triple", "source_id": "data_type_routines_as_strided", "vc-description": "numpy.as_strided: Create a view into the array with the given shape and strides.\n\nCreates a new view of an array with specified shape and strides.\nThis is a simplified version that focuses on the core mathematical\nproperty: creating a view with a different shape but accessing\nelements from the original array based on stride patterns.\n\nFor safety, we restrict to cases where the new shape is smaller\nthan or equal to the original array size.\n\nSpecification: numpy.as_strided creates a view with specified strides.\n\nPrecondition: The strided access must be valid (m * stride ≤ n)\nPostcondition: Each element in the result is taken from the original\narray at positions determined by the stride pattern.\n\nFor element i in the result, it equals x[i * stride].", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_as_strided(x: &Vec<f32>, stride: usize, m: usize) -> (result: Vec<f32>)\n    requires \n        stride > 0,\n        m * stride <= x@.len(),\n    ensures\n        result@.len() == m,\n        forall|i: int| 0 <= i < m ==> result@[i] == x@[i * stride as int],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0116", "language": "verus", "source": "numpy_triple", "source_id": "data_type_routines_can_cast", "vc-description": "Returns True if cast between data types can occur according to the casting rule\n\n/* Data type enumeration for casting rules */\n\n/* no casting is allowed */\n\n/* only byte-order changes are allowed */\n\n/* only casts which can preserve values are allowed */\n\n/* safe casts or casts within a kind */\n\n/* any data conversions may be done */\n\n/* Data type enumeration for supported numeric types */\n\n/* Basic reflexivity: any type can cast to itself with any rule */\n\n/* No casting rule: only identical types allowed */\n\n/* Safe casting preserves values */\n\n/* Integer widening is safe */\n\n/* Float widening is safe */\n\n/* Integer to float can be safe if no precision loss */\n\n/* Complex widening is safe */\n\n/* Float to complex is safe */\n\n/* Same type is always safe */\n\n/* Same kind casting allows within numeric families */\n\n/* Integer family */\n\n/* Float family */\n\n/* Complex family */\n\n/* Cross-family safe casts */\n\n/* Unrestricted casting allows any conversion */\n\n/* Equiv casting allows same types (byte-order changes only) */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n#[derive(PartialEq, Eq)]\npub enum CastingRule {\n    No,\n    Equiv,\n    Safe,\n    SameKind,\n    Unrestricted,\n}\n\n#[derive(PartialEq, Eq)]\npub enum DType {\n    Int8,\n    Int16,\n    Int32,\n    Int64,\n    Float32,\n    Float64,\n    Complex64,\n    Complex128,\n    Bool,\n}", "vc-helpers": "", "vc-spec": "fn can_cast(from_dtype: DType, to_dtype: DType, casting: CastingRule) -> (result: bool)\n    ensures\n\n        (from_dtype == to_dtype ==> result == true) &&\n\n        (casting == CastingRule::No ==> (result == true <==> from_dtype == to_dtype)) &&\n\n        (casting == CastingRule::Safe ==> \n            (result == true ==> \n\n                ((from_dtype == DType::Int8 && (to_dtype == DType::Int16 || to_dtype == DType::Int32 || to_dtype == DType::Int64)) ||\n                 (from_dtype == DType::Int16 && (to_dtype == DType::Int32 || to_dtype == DType::Int64)) ||\n                 (from_dtype == DType::Int32 && to_dtype == DType::Int64) ||\n\n                 (from_dtype == DType::Float32 && to_dtype == DType::Float64) ||\n\n                 ((from_dtype == DType::Int8 || from_dtype == DType::Int16) && (to_dtype == DType::Float32 || to_dtype == DType::Float64)) ||\n                 (from_dtype == DType::Int32 && to_dtype == DType::Float64) ||\n\n                 (from_dtype == DType::Complex64 && to_dtype == DType::Complex128) ||\n\n                 ((from_dtype == DType::Float32 || from_dtype == DType::Float64) && (to_dtype == DType::Complex64 || to_dtype == DType::Complex128)) ||\n\n                 (from_dtype == to_dtype)))) &&\n\n        (casting == CastingRule::SameKind ==> \n            (result == true ==> \n\n                (((from_dtype == DType::Int8 || from_dtype == DType::Int16 || from_dtype == DType::Int32 || from_dtype == DType::Int64) && \n                  (to_dtype == DType::Int8 || to_dtype == DType::Int16 || to_dtype == DType::Int32 || to_dtype == DType::Int64)) ||\n\n                 ((from_dtype == DType::Float32 || from_dtype == DType::Float64) && \n                  (to_dtype == DType::Float32 || to_dtype == DType::Float64)) ||\n\n                 ((from_dtype == DType::Complex64 || from_dtype == DType::Complex128) && \n                  (to_dtype == DType::Complex64 || to_dtype == DType::Complex128)) ||\n\n                 ((from_dtype == DType::Int8 || from_dtype == DType::Int16 || from_dtype == DType::Int32 || from_dtype == DType::Int64) && \n                  (to_dtype == DType::Float32 || to_dtype == DType::Float64 || to_dtype == DType::Complex64 || to_dtype == DType::Complex128)) ||\n                 ((from_dtype == DType::Float32 || from_dtype == DType::Float64) && \n                  (to_dtype == DType::Complex64 || to_dtype == DType::Complex128))))) &&\n\n        (casting == CastingRule::Unrestricted ==> result == true) &&\n\n        (casting == CastingRule::Equiv ==> (result == true <==> from_dtype == to_dtype))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0118", "language": "verus", "source": "numpy_triple", "source_id": "data_type_routines_dtype", "vc-description": "numpy.dtype: Create a data type object.\n\nA numpy array is homogeneous, and contains elements described by a dtype object. \nA dtype object can be constructed from different combinations of fundamental numeric types.\n\nThis specification focuses on creating basic numeric data types like int16, int32, float32, float64.\nThe function maps type specifications to their corresponding DType objects with proper\nattributes like size, alignment, and signedness.\n\nSpecification: numpy.dtype creates a valid data type object with consistent attributes.\n\nPrecondition: The type_spec is a valid NumPy type specification\nPostcondition: The resulting DType has consistent attributes that match the specified type", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* Represents a NumPy data type object with its essential attributes */\npub struct DType {\n    /* The fundamental numeric type category */\n    pub kind: &'static str,\n    /* The element size in bytes */\n    pub itemsize: usize,\n    /* The alignment requirement in bytes */\n    pub alignment: usize,\n    /* A descriptive name for the data type */\n    pub name: &'static str,\n    /* Whether the data type is signed (for numeric types) */\n    pub signed: bool,\n}", "vc-helpers": "", "vc-spec": "fn numpy_dtype(type_spec: &str) -> (result: DType)\n    requires type_spec == \"int8\" || type_spec == \"int16\" || type_spec == \"int32\" || \n             type_spec == \"int64\" || type_spec == \"float32\" || type_spec == \"float64\" || \n             type_spec == \"bool\",\n    ensures\n        /* The data type has a valid kind character */\n        (result.kind == \"i\" || result.kind == \"f\" || result.kind == \"b\") &&\n        /* The itemsize is positive and matches the type specification */\n        (result.itemsize > 0) &&\n        /* The alignment is positive and does not exceed the itemsize */\n        (result.alignment > 0 && result.alignment <= result.itemsize) &&\n        /* The name is non-empty */\n        (result.name != \"\") &&\n        /* Size consistency for specific types */\n        ((type_spec == \"int8\" ==> result.itemsize == 1 && result.signed == true && result.kind == \"i\") &&\n         (type_spec == \"int16\" ==> result.itemsize == 2 && result.signed == true && result.kind == \"i\") &&\n         (type_spec == \"int32\" ==> result.itemsize == 4 && result.signed == true && result.kind == \"i\") &&\n         (type_spec == \"int64\" ==> result.itemsize == 8 && result.signed == true && result.kind == \"i\") &&\n         (type_spec == \"float32\" ==> result.itemsize == 4 && result.kind == \"f\") &&\n         (type_spec == \"float64\" ==> result.itemsize == 8 && result.kind == \"f\") &&\n         (type_spec == \"bool\" ==> result.itemsize == 1 && result.kind == \"b\"))", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0119", "language": "verus", "source": "numpy_triple", "source_id": "data_type_routines_find_common_type", "vc-description": "numpy.find_common_type: Determine common type following standard coercion rules.\n\nThis function determines the common data type by following NumPy's type promotion rules.\nIt returns the maximum of array_types ignoring scalar_types, unless the maximum of \nscalar_types is of a different kind (dtype.kind).\n\nNote: This function is deprecated in NumPy 1.25.0 in favor of numpy.result_type.\n\nSpecification: find_common_type implements NumPy's type promotion rules correctly.\n\nThe function should:\n1. Return the maximum precedence type from array_types if scalar_types is empty\n2. Return the maximum precedence type from scalar_types if array_types is empty  \n3. If both are non-empty, return the maximum from array_types unless the maximum\n   from scalar_types has a different kind, in which case return the scalar maximum\n4. Handle the case where type promotion results in a valid common type\n\nPrecondition: At least one of the input vectors is non-empty\nPostcondition: The result follows NumPy's documented type promotion rules", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* Data type representation for NumPy types */\n#[derive(PartialEq, Eq, Clone, Copy)]\nenum DType {\n    /* 8-bit signed integer */\n    Int8,\n    /* 16-bit signed integer */\n    Int16,\n    /* 32-bit signed integer */\n    Int32,\n    /* 64-bit signed integer */\n    Int64,\n    /* 8-bit unsigned integer */\n    UInt8,\n    /* 16-bit unsigned integer */\n    UInt16,\n    /* 32-bit unsigned integer */\n    UInt32,\n    /* 64-bit unsigned integer */\n    UInt64,\n    /* 32-bit floating point */\n    Float32,\n    /* 64-bit floating point */\n    Float64,\n    /* 64-bit complex number */\n    Complex64,\n    /* 128-bit complex number */\n    Complex128,\n    /* Boolean type */\n    Bool,\n    /* Object type */\n    Object,\n}\n\n/* Type hierarchy for promotion rules */\nspec fn dtype_kind(dt: DType) -> char {\n    match dt {\n        DType::Bool => 'b',\n        DType::Int8 | DType::Int16 | DType::Int32 | DType::Int64 => 'i',\n        DType::UInt8 | DType::UInt16 | DType::UInt32 | DType::UInt64 => 'u',\n        DType::Float32 | DType::Float64 => 'f',\n        DType::Complex64 | DType::Complex128 => 'c',\n        DType::Object => 'O',\n    }\n}\n\n/* Type precedence for promotion (higher values have higher precedence) */\nspec fn dtype_precedence(dt: DType) -> nat {\n    match dt {\n        DType::Bool => 0,\n        DType::Int8 => 1,\n        DType::Int16 => 2,\n        DType::Int32 => 3,\n        DType::Int64 => 4,\n        DType::UInt8 => 5,\n        DType::UInt16 => 6,\n        DType::UInt32 => 7,\n        DType::UInt64 => 8,\n        DType::Float32 => 9,\n        DType::Float64 => 10,\n        DType::Complex64 => 11,\n        DType::Complex128 => 12,\n        DType::Object => 13,\n    }\n}", "vc-helpers": "", "vc-spec": "fn find_common_type(array_types: Vec<DType>, scalar_types: Vec<DType>) -> (result: Option<DType>)\n    requires array_types.len() > 0 || scalar_types.len() > 0,\n    ensures \n        /* Case 1: Only array types provided */\n        (scalar_types.len() == 0 && array_types.len() > 0) ==> (\n            exists|dt: DType| result == Some(dt) &&\n            array_types@.contains(dt) &&\n            forall|other: DType| array_types@.contains(other) ==> dtype_precedence(other) <= dtype_precedence(dt)\n        ),\n        /* Case 2: Only scalar types provided */\n        (array_types.len() == 0 && scalar_types.len() > 0) ==> (\n            exists|dt: DType| result == Some(dt) &&\n            scalar_types@.contains(dt) &&\n            forall|other: DType| scalar_types@.contains(other) ==> dtype_precedence(other) <= dtype_precedence(dt)\n        ),\n        /* Case 3: Both array and scalar types provided */\n        (array_types.len() > 0 && scalar_types.len() > 0) ==> (\n            exists|max_array: DType, max_scalar: DType|\n                array_types@.contains(max_array) && scalar_types@.contains(max_scalar) &&\n                (forall|dt: DType| array_types@.contains(dt) ==> dtype_precedence(dt) <= dtype_precedence(max_array)) &&\n                (forall|dt: DType| scalar_types@.contains(dt) ==> dtype_precedence(dt) <= dtype_precedence(max_scalar)) &&\n                ((dtype_kind(max_array) == dtype_kind(max_scalar)) ==> result == Some(max_array)) &&\n                ((dtype_kind(max_array) != dtype_kind(max_scalar)) ==> result == Some(max_scalar))\n        )", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0120", "language": "verus", "source": "numpy_triple", "source_id": "data_type_routines_finfo", "vc-description": "Machine limits for floating point types.\n\nReturns machine limits for the Float type in Lean.\nThis provides information about the precision and range of Float values.\n\nIn NumPy, this would accept different dtypes, but in Lean we work with the built-in Float type.\n\nSpecification: numpy.finfo returns floating point type information with correct properties.\n\nPrecondition: True (no special preconditions)\nPostcondition: The returned FloatInfo has mathematically consistent properties", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "/* Structure representing floating point type information returned by numpy.finfo */\nstruct FloatInfo {\n    /* The number of bits occupied by the type */\n    bits: u8,\n    /* The smallest representable positive number such that 1.0 + eps != 1.0 */\n    eps: i8,\n    /* The largest representable number */\n    max: i8,\n    /* The smallest representable number, typically -max */\n    min: i8,\n    /* The approximate number of decimal digits to which this kind of float is precise */\n    precision: u8,\n    /* The approximate decimal resolution of this type */\n    resolution: i8,\n    /* The smallest positive floating point number with 1 as leading bit in the mantissa */\n    smallest_normal: i8,\n    /* The smallest positive floating point number with 0 as leading bit in the mantissa */\n    smallest_subnormal: i8,\n}\n\nfn numpy_finfo() -> (info: FloatInfo)\n    ensures\n        /* Basic sanity checks */\n        (info.bits as nat) > 0,\n        (info.precision as nat) > 0,\n        /* eps is positive and small */\n        (info.eps as int) > 0,\n        (info.eps as int) < 1,\n        /* max is positive, min is negative */\n        (info.max as int) > 0,\n        (info.min as int) < 0,\n        /* min is typically -max for symmetric floating point types */\n        (info.min as int) == -((info.max as int)),\n        /* resolution is positive */\n        (info.resolution as int) > 0,\n        /* smallest_normal is positive and smaller than 1 */\n        (info.smallest_normal as int) > 0,\n        (info.smallest_normal as int) < 1,\n        /* smallest_subnormal is positive and smaller than smallest_normal */\n        (info.smallest_subnormal as int) > 0,\n        (info.smallest_subnormal as int) <= (info.smallest_normal as int),\n        /* eps represents the machine epsilon property */\n        (info.eps as int) == (info.resolution as int),\n        /* The number of bits should be reasonable (32 or 64 for common float types) */\n        (info.bits as nat) == 32 || (info.bits as nat) == 64,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0121", "language": "verus", "source": "numpy_triple", "source_id": "data_type_routines_format_parser", "vc-description": "numpy.format_parser: Class to convert formats, names, titles description to a dtype.\n\nThis function takes format descriptions, field names, and optional titles\nand produces a structured data type specification. It validates that the\nformats are well-formed and that the number of names matches the number\nof format descriptors.\n\nThe function handles common NumPy format strings like 'f8' (float64),\n'i4' (int32), 'S5' (string of length 5), etc.\n\nSpecification: numpy.format_parser creates a structured data type from format descriptions.\n\nPrecondition: All format strings in formats are valid NumPy format descriptors\nPostcondition: \n1. The result has the same number of fields as input vectors\n2. Each field has the correct name from the names vector\n3. Each field has the correct format descriptor parsed from the formats vector\n4. If titles are provided, each field has the corresponding title\n5. The alignment setting is preserved", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* A format descriptor for structured data types */\n#[derive(Eq, PartialEq)]\npub enum FormatDescriptor {\n    /* 64-bit floating point ('f8') */\n    Float64,\n    /* 32-bit integer ('i4') */\n    Int32,\n    /* Variable length string ('S5' for string of length 5) */\n    String(nat),\n    /* 64-bit integer ('i8') */\n    Int64,\n    /* 32-bit floating point ('f4') */\n    Float32,\n}\n\n/* A field in a structured data type */\n#[derive(Eq, PartialEq)]\npub struct Field {\n    /* Field name */\n    pub name: String,\n    /* Format descriptor */\n    pub format: FormatDescriptor,\n    /* Optional title for the field */\n    pub title: Option<String>,\n}\n\n/* A structured data type specification */\n#[derive(Eq, PartialEq)]\npub struct DType {\n    /* Vector of fields */\n    pub fields: Vec<Field>,\n    /* Whether fields are aligned as C-compiler would */\n    pub aligned: bool,\n}", "vc-helpers": "", "vc-spec": "spec fn is_valid_format(format: String) -> bool {\n    format@ == \"f8\".view() || format@ == \"f4\".view() || format@ == \"i4\".view() || format@ == \"i8\".view() || \n    (format@.len() > 1 && format@.index(0) == 'S')\n}\n\nspec fn parse_format_descriptor(format: String) -> FormatDescriptor {\n    if format@ == \"f8\".view() {\n        FormatDescriptor::Float64\n    } else if format@ == \"f4\".view() {\n        FormatDescriptor::Float32\n    } else if format@ == \"i4\".view() {\n        FormatDescriptor::Int32\n    } else if format@ == \"i8\".view() {\n        FormatDescriptor::Int64\n    } else {\n        FormatDescriptor::String(5) // simplified for spec\n    }\n}\n\nfn numpy_format_parser(\n    formats: Vec<String>,\n    names: Vec<String>,\n    titles: Option<Vec<String>>,\n    aligned: bool\n) -> (result: DType)\n    requires \n        formats.len() == names.len(),\n        titles.is_some() ==> titles.unwrap().len() == names.len(),\n        forall|i: int| 0 <= i < formats.len() ==> is_valid_format(formats@[i]),\n    ensures\n        result.fields.len() == formats.len(),\n        forall|i: int| 0 <= i < result.fields.len() ==> result.fields@[i].name == names@[i],\n        forall|i: int| 0 <= i < result.fields.len() ==> \n            result.fields@[i].format == parse_format_descriptor(formats@[i]),\n        match titles {\n            Some(title_vec) => forall|i: int| 0 <= i < result.fields.len() ==> \n                result.fields@[i].title == Some(title_vec@[i]),\n            None => forall|i: int| 0 <= i < result.fields.len() ==> \n                result.fields@[i].title.is_none(),\n        },\n        result.aligned == aligned,", "vc-code": "{\n    // impl-start\n    assume(false);\n    DType {\n        fields: Vec::new(),\n        aligned: false,\n    }\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0122", "language": "verus", "source": "numpy_triple", "source_id": "data_type_routines_iinfo", "vc-description": "Machine limits for integer types\n\nTakes an integer type specification and returns information about \nthe number of bits, minimum value, and maximum value for that type.\nThis provides access to the fundamental machine limits for integer\nrepresentation in numerical computing.\n\nSpecification: numpy.iinfo returns correct machine limits for integer types.\n\nPrecondition: True (no special preconditions for type information)\nPostcondition: The returned IntInfo structure contains:\n  - Correct bit count for the specified type\n  - Correct minimum value (negative for signed types, 0 for unsigned)\n  - Correct maximum value based on the bit representation\n  - Consistency between bits and min/max values\n\n/* Integer type information structure containing machine limits for integer types */\n\n/* Number of bits occupied by the type */\n\n/* Smallest integer expressible by the type */\n\n/* Largest integer expressible by the type */\n\n/* Enumeration of supported integer types */\n\n/* 8-bit signed integer type */\n\n/* 16-bit signed integer type */\n\n/* 32-bit signed integer type */\n\n/* 64-bit signed integer type */\n\n/* 8-bit unsigned integer type */\n\n/* 16-bit unsigned integer type */\n\n/* 32-bit unsigned integer type */\n\n/* 64-bit unsigned integer type */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "struct IntInfo {\n\n    bits: u32,\n\n    min: i64,\n\n    max: i64,\n}\n\nenum IntType {\n\n    Int8,\n\n    Int16,\n\n    Int32,\n\n    Int64,\n\n    UInt8,\n\n    UInt16,\n\n    UInt32,\n\n    UInt64,\n}\n\nfn iinfo(int_type: IntType) -> (info: IntInfo)\n    ensures\n        match int_type {\n            IntType::Int8 => info.bits == 8 && info.min == -128 && info.max == 127,\n            IntType::Int16 => info.bits == 16 && info.min == -32768 && info.max == 32767,\n            IntType::Int32 => info.bits == 32 && info.min == -2147483648 && info.max == 2147483647,\n            IntType::Int64 => info.bits == 64 && info.min == -9223372036854775808 && info.max == 9223372036854775807,\n            IntType::UInt8 => info.bits == 8 && info.min == 0 && info.max == 255,\n            IntType::UInt16 => info.bits == 16 && info.min == 0 && info.max == 65535,\n            IntType::UInt32 => info.bits == 32 && info.min == 0 && info.max == 4294967295,\n            IntType::UInt64 => info.bits == 64 && info.min == 0 && info.max == 18446744073709551615,\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0123", "language": "verus", "source": "numpy_triple", "source_id": "data_type_routines_isdtype", "vc-description": "numpy.isdtype: Determine if a provided dtype is of a specified data type kind.\n\nThis function checks whether a given NumPy dtype belongs to a specified\ncategory of data types. It supports checking against specific dtype kinds\nlike 'bool', 'signed integer', 'unsigned integer', 'integral', \n'real floating', 'complex floating', and 'numeric'.\n\nThe function performs type introspection and classification of NumPy dtypes\naccording to their fundamental characteristics.\n\nSpecification: numpy.isdtype correctly identifies dtype kinds.\n\nPrecondition: True (works for any valid dtype and kind)\nPostcondition: Returns true iff the dtype belongs to the specified kind category.\n\nThe function implements the following classification rules:\n- Bool: dtype is boolean\n- SignedInteger: dtype is signed integer (int8, int16, int32, int64)\n- UnsignedInteger: dtype is unsigned integer (uint8, uint16, uint32, uint64)\n- Integral: dtype is any integer type (signed or unsigned)\n- RealFloating: dtype is real floating point (float16, float32, float64)\n- ComplexFloating: dtype is complex floating point (complex64, complex128)\n- Numeric: dtype is any numeric type (bool, integers, floats, complex)\n\n/* NumPy data type representation */\n\n/* Boolean data type */\n\n/* 8-bit signed integer */\n\n/* 16-bit signed integer */\n\n/* 32-bit signed integer */\n\n/* 64-bit signed integer */\n\n/* 8-bit unsigned integer */\n\n/* 16-bit unsigned integer */\n\n/* 32-bit unsigned integer */\n\n/* 64-bit unsigned integer */\n\n/* 16-bit floating point */\n\n/* 32-bit floating point */\n\n/* 64-bit floating point */\n\n/* 64-bit complex number */\n\n/* 128-bit complex number */\n\n/* NumPy data type kind categories */\n\n/* Boolean kind */\n\n/* Signed integer kind */\n\n/* Unsigned integer kind */\n\n/* Any integer kind (signed or unsigned) */\n\n/* Real floating point kind */\n\n/* Complex floating point kind */\n\n/* Any numeric kind */\n\n/* Get the fundamental kind of a NumPy dtype */\n\n/* Check if a NumPy dtype belongs to a specific kind category */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n#[derive(PartialEq, Eq)]\npub enum NumpyDType {\n\n    Bool,\n\n    Int8,\n\n    Int16,\n\n    Int32,\n\n    Int64,\n\n    UInt8,\n\n    UInt16,\n\n    UInt32,\n\n    UInt64,\n\n    Float16,\n\n    Float32,\n\n    Float64,\n\n    Complex64,\n\n    Complex128,\n}\n\n#[derive(PartialEq, Eq)]\npub enum DTypeKind {\n\n    Bool,\n\n    SignedInteger,\n\n    UnsignedInteger,\n\n    Integral,\n\n    RealFloating,\n\n    ComplexFloating,\n\n    Numeric,\n}\n\nspec fn get_dtype_kind(dtype: NumpyDType) -> DTypeKind {\n    match dtype {\n        NumpyDType::Bool => DTypeKind::Bool,\n        NumpyDType::Int8 | NumpyDType::Int16 | NumpyDType::Int32 | NumpyDType::Int64 => DTypeKind::SignedInteger,\n        NumpyDType::UInt8 | NumpyDType::UInt16 | NumpyDType::UInt32 | NumpyDType::UInt64 => DTypeKind::UnsignedInteger,\n        NumpyDType::Float16 | NumpyDType::Float32 | NumpyDType::Float64 => DTypeKind::RealFloating,\n        NumpyDType::Complex64 | NumpyDType::Complex128 => DTypeKind::ComplexFloating,\n    }\n}\n\nspec fn is_of_kind(dtype: NumpyDType, kind: DTypeKind) -> bool {\n    match kind {\n        DTypeKind::Bool => get_dtype_kind(dtype) == DTypeKind::Bool,\n        DTypeKind::SignedInteger => get_dtype_kind(dtype) == DTypeKind::SignedInteger,\n        DTypeKind::UnsignedInteger => get_dtype_kind(dtype) == DTypeKind::UnsignedInteger,\n        DTypeKind::Integral => get_dtype_kind(dtype) == DTypeKind::SignedInteger || get_dtype_kind(dtype) == DTypeKind::UnsignedInteger,\n        DTypeKind::RealFloating => get_dtype_kind(dtype) == DTypeKind::RealFloating,\n        DTypeKind::ComplexFloating => get_dtype_kind(dtype) == DTypeKind::ComplexFloating,\n        DTypeKind::Numeric => get_dtype_kind(dtype) == DTypeKind::Bool || \n                             get_dtype_kind(dtype) == DTypeKind::SignedInteger || \n                             get_dtype_kind(dtype) == DTypeKind::UnsignedInteger || \n                             get_dtype_kind(dtype) == DTypeKind::RealFloating || \n                             get_dtype_kind(dtype) == DTypeKind::ComplexFloating,\n    }\n}", "vc-helpers": "", "vc-spec": "fn numpy_isdtype(dtype: NumpyDType, kind: DTypeKind) -> (result: bool)\n    ensures result == is_of_kind(dtype, kind)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0124", "language": "verus", "source": "numpy_triple", "source_id": "data_type_routines_issctype", "vc-description": "Determines whether the given object represents a scalar data-type\n\n/* Represents different kinds of data types that can be tested */\n\n/* Scalar integer type */\n\n/* Scalar floating point type */\n\n/* Scalar complex number type */\n\n/* Scalar boolean type */\n\n/* Scalar string type */\n\n/* Array type */\n\n/* Composite type */\n\n/* Unknown type */\n\n/* Helper function to check if a DataType is a scalar type */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nenum DataType {\n\n    ScalarInt,\n\n    ScalarFloat,\n\n    ScalarComplex,\n\n    ScalarBool,\n\n    ScalarString,\n\n    ArrayType,\n\n    CompositeType,\n\n    UnknownType,\n}\n\nspec fn is_scalar_type(dt: DataType) -> bool {\n    match dt {\n        DataType::ScalarInt => true,\n        DataType::ScalarFloat => true,\n        DataType::ScalarComplex => true,\n        DataType::ScalarBool => true,\n        DataType::ScalarString => true,\n        DataType::ArrayType => false,\n        DataType::CompositeType => false,\n        DataType::UnknownType => false,\n    }\n}", "vc-helpers": "", "vc-spec": "fn issctype(rep: DataType) -> (result: bool)\n    ensures result == (rep == DataType::ScalarInt || \n                      rep == DataType::ScalarFloat || \n                      rep == DataType::ScalarComplex || \n                      rep == DataType::ScalarBool || \n                      rep == DataType::ScalarString)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0125", "language": "verus", "source": "numpy_triple", "source_id": "data_type_routines_issubclass_", "vc-description": "numpy.issubclass_: Determine if a class is a subclass of a second class.\n\nThis function is equivalent to the Python built-in issubclass, except that it returns \nFalse instead of raising a TypeError if one of the arguments is not a class.\n\nIn the context of NumPy, this tests relationships between NumPy data type classes\nsuch as whether int32 is a subclass of integer, or whether float64 is a subclass of float.\n\nSpecification: issubclass_ correctly determines class hierarchy relationships.\n\nThis function tests whether arg1 is a subclass of arg2 according to NumPy's type\nhierarchy. The specification ensures that:\n1. The function respects the established type hierarchy (e.g., int32 ⊆ integer ⊆ number ⊆ scalar)\n2. It handles reflexivity correctly (every class is a subclass of itself)\n3. It returns False for unrelated classes\n4. It never raises exceptions (returns False instead of error for invalid inputs)\n\nPrecondition: True (no special preconditions, handles all inputs gracefully)\nPostcondition: Returns True if arg1 is a subclass of arg2, False otherwise\n\n/* Represents a NumPy type class for hierarchy testing */\n\n/* Integer types */\n\n/* Floating point types */\n\n/* Complex number types */\n\n/* Boolean type */\n\n/* Scalar types (superclass of all numeric types) */\n\n/* Number types (excludes boolean) */\n\n/* Inexact types (floating and complex) */\n\n/* 8-bit signed integer type */\n\n/* 16-bit signed integer type */\n\n/* 32-bit signed integer type */\n\n/* 64-bit signed integer type */\n\n/* 8-bit unsigned integer type */\n\n/* 16-bit unsigned integer type */\n\n/* 32-bit unsigned integer type */\n\n/* 64-bit unsigned integer type */\n\n/* 32-bit floating point type */\n\n/* 64-bit floating point type */\n\n/* 64-bit complex number type */\n\n/* 128-bit complex number type */\n\n/* Generic object type */\n\n/* Defines the class hierarchy relationships for NumPy types */\n\n/* Reflexivity: every class is a subclass of itself */\n\n/* Concrete integer types are subclasses of IntegerType */\n\n/* Concrete floating types are subclasses of FloatingType */\n\n/* Concrete complex types are subclasses of ComplexType */\n\n/* Integer types are subclasses of NumberType */\n\n/* Floating types are subclasses of InexactType and NumberType */\n\n/* Complex types are subclasses of InexactType and NumberType */\n\n/* All numeric types are subclasses of ScalarType */\n\n/* Default case */\n\n/* Result matches the defined hierarchy */\n\n/* Reflexivity: every class is a subclass of itself */\n\n/* Concrete examples from NumPy documentation */\n\n/* Transitivity: int32 → integer → number → scalar */\n\n/* All numeric types are subclasses of ScalarType */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n#[derive(PartialEq, Eq)]\nenum NumpyTypeClass {\n\n    IntegerType,\n\n    FloatingType,\n\n    ComplexType,\n\n    BooleanType,\n\n    ScalarType,\n\n    NumberType,\n\n    InexactType,\n\n    Int8Type,\n\n    Int16Type,\n\n    Int32Type,\n\n    Int64Type,\n\n    UInt8Type,\n\n    UInt16Type,\n\n    UInt32Type,\n\n    UInt64Type,\n\n    Float32Type,\n\n    Float64Type,\n\n    Complex64Type,\n\n    Complex128Type,\n\n    ObjectType,\n}\n\nspec fn is_subclass_spec(t: NumpyTypeClass, t_prime: NumpyTypeClass) -> bool {\n\n    if t == t_prime {\n        true\n    } else {\n        match (t, t_prime) {\n\n            (NumpyTypeClass::Int8Type, NumpyTypeClass::IntegerType) => true,\n            (NumpyTypeClass::Int16Type, NumpyTypeClass::IntegerType) => true,\n            (NumpyTypeClass::Int32Type, NumpyTypeClass::IntegerType) => true,\n            (NumpyTypeClass::Int64Type, NumpyTypeClass::IntegerType) => true,\n            (NumpyTypeClass::UInt8Type, NumpyTypeClass::IntegerType) => true,\n            (NumpyTypeClass::UInt16Type, NumpyTypeClass::IntegerType) => true,\n            (NumpyTypeClass::UInt32Type, NumpyTypeClass::IntegerType) => true,\n            (NumpyTypeClass::UInt64Type, NumpyTypeClass::IntegerType) => true,\n\n            (NumpyTypeClass::Float32Type, NumpyTypeClass::FloatingType) => true,\n            (NumpyTypeClass::Float64Type, NumpyTypeClass::FloatingType) => true,\n\n            (NumpyTypeClass::Complex64Type, NumpyTypeClass::ComplexType) => true,\n            (NumpyTypeClass::Complex128Type, NumpyTypeClass::ComplexType) => true,\n\n            (NumpyTypeClass::IntegerType, NumpyTypeClass::NumberType) => true,\n\n            (NumpyTypeClass::FloatingType, NumpyTypeClass::InexactType) => true,\n            (NumpyTypeClass::FloatingType, NumpyTypeClass::NumberType) => true,\n\n            (NumpyTypeClass::ComplexType, NumpyTypeClass::InexactType) => true,\n            (NumpyTypeClass::ComplexType, NumpyTypeClass::NumberType) => true,\n\n            (NumpyTypeClass::NumberType, NumpyTypeClass::ScalarType) => true,\n            (NumpyTypeClass::BooleanType, NumpyTypeClass::ScalarType) => true,\n            (NumpyTypeClass::IntegerType, NumpyTypeClass::ScalarType) => true,\n            (NumpyTypeClass::FloatingType, NumpyTypeClass::ScalarType) => true,\n            (NumpyTypeClass::ComplexType, NumpyTypeClass::ScalarType) => true,\n            (NumpyTypeClass::InexactType, NumpyTypeClass::ScalarType) => true,\n\n            _ => false,\n        }\n    }\n}", "vc-helpers": "", "vc-spec": "fn issubclass_(arg1: NumpyTypeClass, arg2: NumpyTypeClass) -> (result: bool)\n    ensures\n\n        result == is_subclass_spec(arg1, arg2),\n\n        (arg1 == arg2) ==> (result == true),\n\n        (arg1 == NumpyTypeClass::Int32Type && arg2 == NumpyTypeClass::IntegerType) ==> (result == true),\n        (arg1 == NumpyTypeClass::Float64Type && arg2 == NumpyTypeClass::FloatingType) ==> (result == true),\n        (arg1 == NumpyTypeClass::Int32Type && arg2 == NumpyTypeClass::FloatingType) ==> (result == false),\n\n        (arg1 == NumpyTypeClass::Int32Type && arg2 == NumpyTypeClass::NumberType) ==> \n         (is_subclass_spec(NumpyTypeClass::Int32Type, NumpyTypeClass::IntegerType) &&\n          is_subclass_spec(NumpyTypeClass::IntegerType, NumpyTypeClass::NumberType)),\n\n        (arg1 == NumpyTypeClass::IntegerType && arg2 == NumpyTypeClass::ScalarType) ==> (result == true),\n        (arg1 == NumpyTypeClass::FloatingType && arg2 == NumpyTypeClass::ScalarType) ==> (result == true),\n        (arg1 == NumpyTypeClass::ComplexType && arg2 == NumpyTypeClass::ScalarType) ==> (result == true)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0126", "language": "verus", "source": "numpy_triple", "source_id": "data_type_routines_issubdtype", "vc-description": "numpy.issubdtype: Returns True if first argument is a typecode lower/equal in type hierarchy.\n\nThis function checks if the first data type is a subtype of the second data type\nin the NumPy type hierarchy. It's similar to Python's built-in issubclass but\noperates on NumPy data types.\n\nThe function implements the NumPy type hierarchy where types are organized\nin a tree structure with 'generic' at the root.\n\nSpecification: issubdtype returns True if arg1 is a subtype of arg2 in the NumPy type hierarchy.\n\nPrecondition: True (works with any valid NumPy data types)\nPostcondition: The result is True if and only if arg1 is a subtype of arg2 \naccording to the NumPy type hierarchy rules.\n\nKey properties:\n1. Reflexivity: Every type is a subtype of itself\n2. Transitivity: If A is subtype of B and B is subtype of C, then A is subtype of C\n3. Hierarchy rules: Specific types are subtypes of their parent categories\n4. Root type: All types are subtypes of 'generic'\n\n/* Define a NumPy-like type hierarchy representing the data type system in NumPy */\n\n/* Generic root type */\n\n/* Inexact numeric type */\n\n/* Floating point type */\n\n/* 32-bit floating point */\n\n/* 64-bit floating point */\n\n/* Numeric type */\n\n/* Integer type */\n\n/* Signed integer type */\n\n/* 8-bit signed integer */\n\n/* 16-bit signed integer */\n\n/* 32-bit signed integer */\n\n/* 64-bit signed integer */\n\n/* Unsigned integer type */\n\n/* 8-bit unsigned integer */\n\n/* 16-bit unsigned integer */\n\n/* 32-bit unsigned integer */\n\n/* 64-bit unsigned integer */\n\n/* Character type */\n\n/* Bytes type */\n\n/* String type */\n\n/* Boolean type */\n\n/* Define the subtype relation for NumPy types */\n\n/* Float hierarchy */\n\n/* Integer hierarchy */\n\n/* Character hierarchy */\n\n/* Boolean hierarchy */\n\n/* Number hierarchy */\n\n/* Reflexivity property */\n\n/* Generic is supertype of all types */\n\n/* Specific hierarchy rules */\n\n/* Non-subtype examples */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\npub enum NumpyDType {\n\n    Generic,\n\n    Inexact(Box<NumpyDType>),\n\n    Floating(Box<NumpyDType>),\n\n    Float32,\n\n    Float64,\n\n    Number(Box<NumpyDType>),\n\n    Integer(Box<NumpyDType>),\n\n    SignedInteger(Box<NumpyDType>),\n\n    Int8,\n\n    Int16,\n\n    Int32,\n\n    Int64,\n\n    UnsignedInteger(Box<NumpyDType>),\n\n    UInt8,\n\n    UInt16,\n\n    UInt32,\n\n    UInt64,\n\n    Character(Box<NumpyDType>),\n\n    Bytes_,\n\n    Str_,\n\n    Bool_,\n}\n\nspec fn is_sub_dtype_spec(dtype1: NumpyDType, dtype2: NumpyDType) -> bool {\n    if dtype1 == dtype2 {\n        true\n    } else {\n        match (dtype1, dtype2) {\n\n            (NumpyDType::Float32, NumpyDType::Floating(_)) => true,\n            (NumpyDType::Float64, NumpyDType::Floating(_)) => true,\n            (NumpyDType::Floating(_), NumpyDType::Inexact(_)) => true,\n            (NumpyDType::Floating(_), NumpyDType::Number(_)) => true,\n            (NumpyDType::Floating(_), NumpyDType::Generic) => true,\n\n            (NumpyDType::Int8, NumpyDType::SignedInteger(_)) => true,\n            (NumpyDType::Int16, NumpyDType::SignedInteger(_)) => true,\n            (NumpyDType::Int32, NumpyDType::SignedInteger(_)) => true,\n            (NumpyDType::Int64, NumpyDType::SignedInteger(_)) => true,\n            (NumpyDType::UInt8, NumpyDType::UnsignedInteger(_)) => true,\n            (NumpyDType::UInt16, NumpyDType::UnsignedInteger(_)) => true,\n            (NumpyDType::UInt32, NumpyDType::UnsignedInteger(_)) => true,\n            (NumpyDType::UInt64, NumpyDType::UnsignedInteger(_)) => true,\n            (NumpyDType::SignedInteger(_), NumpyDType::Integer(_)) => true,\n            (NumpyDType::UnsignedInteger(_), NumpyDType::Integer(_)) => true,\n            (NumpyDType::Integer(_), NumpyDType::Number(_)) => true,\n            (NumpyDType::Integer(_), NumpyDType::Generic) => true,\n\n            (NumpyDType::Str_, NumpyDType::Character(_)) => true,\n            (NumpyDType::Bytes_, NumpyDType::Character(_)) => true,\n            (NumpyDType::Character(_), NumpyDType::Generic) => true,\n\n            (NumpyDType::Bool_, NumpyDType::Generic) => true,\n\n            (NumpyDType::Number(_), NumpyDType::Generic) => true,\n            (NumpyDType::Inexact(_), NumpyDType::Generic) => true,\n            _ => false,\n        }\n    }\n}", "vc-helpers": "", "vc-spec": "fn issubdtype(arg1: NumpyDType, arg2: NumpyDType) -> (result: bool)\n    ensures \n        result == is_sub_dtype_spec(arg1, arg2) &&\n\n        (arg1 == arg2 ==> result == true) &&\n\n        (arg2 == NumpyDType::Generic ==> result == true) &&\n\n        (arg1 == NumpyDType::Float32 && matches!(arg2, NumpyDType::Floating(_)) ==> result == true) &&\n        (arg1 == NumpyDType::Float64 && matches!(arg2, NumpyDType::Floating(_)) ==> result == true) &&\n        (arg1 == NumpyDType::Int32 && matches!(arg2, NumpyDType::SignedInteger(_)) ==> result == true) &&\n        (arg1 == NumpyDType::UInt32 && matches!(arg2, NumpyDType::UnsignedInteger(_)) ==> result == true) &&\n\n        (arg1 == NumpyDType::Float32 && arg2 == NumpyDType::Float64 ==> result == false) &&\n        (arg1 == NumpyDType::Float64 && arg2 == NumpyDType::Float32 ==> result == false) &&\n        (arg1 == NumpyDType::Int32 && matches!(arg2, NumpyDType::Floating(_)) ==> result == false)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0128", "language": "verus", "source": "numpy_triple", "source_id": "data_type_routines_maximum_sctype", "vc-description": "Return the scalar type of highest precision of the same kind as the input.\n\nThis function implements numpy.maximum_sctype functionality, which takes a numeric type\nand returns the highest precision type of the same kind. For example, int8 becomes int64,\nfloat32 becomes float128, complex64 becomes complex256.\n\n/* Define a type hierarchy for numeric types */\n\n/* Signed integer types */\n\n/* Unsigned integer types */\n\n/* Floating point types */\n\n/* Complex number types */\n\n/* String types */\n\n/* Boolean types */\n\n/* Define precision levels for each kind */\n\n/* 8-bit precision */\n\n/* 16-bit precision */\n\n/* 32-bit precision */\n\n/* 64-bit precision */\n\n/* 128-bit precision */\n\n/* 256-bit precision */\n\n/* A numeric type representation */\n\n/* The kind of numeric type */\n\n/* The precision level */\n\n/* Define the maximum precision for each kind */\n\n// Represents max string length handling\n\n/* Define precision ordering */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n#[derive(PartialEq, Eq, Structural)]\nenum NumericKind {\n\n    Integer,\n\n    UnsignedInteger,\n\n    Float,\n\n    Complex,\n\n    String,\n\n    Boolean,\n}\n\n#[derive(PartialEq, Eq, Structural)]\nenum Precision {\n\n    P8,\n\n    P16,\n\n    P32,\n\n    P64,\n\n    P128,\n\n    P256,\n}\n\n#[derive(PartialEq, Eq, Structural)]\nstruct NumericType {\n\n    kind: NumericKind,\n\n    precision: Precision,\n}\n\nspec fn max_precision_for(kind: NumericKind) -> Precision {\n    match kind {\n        NumericKind::Integer => Precision::P64,\n        NumericKind::UnsignedInteger => Precision::P64,\n        NumericKind::Float => Precision::P128,\n        NumericKind::Complex => Precision::P256,\n        NumericKind::String => Precision::P64,\n        NumericKind::Boolean => Precision::P8,\n    }\n}\n\nspec fn precision_le(p1: Precision, p2: Precision) -> bool {\n    match (p1, p2) {\n        (Precision::P8, _) => true,\n        (Precision::P16, Precision::P8) => false,\n        (Precision::P16, _) => true,\n        (Precision::P32, Precision::P8) => false,\n        (Precision::P32, Precision::P16) => false,\n        (Precision::P32, _) => true,\n        (Precision::P64, Precision::P8) => false,\n        (Precision::P64, Precision::P16) => false,\n        (Precision::P64, Precision::P32) => false,\n        (Precision::P64, _) => true,\n        (Precision::P128, Precision::P256) => true,\n        (Precision::P128, _) => false,\n        (Precision::P256, _) => false,\n    }\n}", "vc-helpers": "", "vc-spec": "fn maximum_sctype(t: NumericType) -> (result: NumericType)\n    ensures \n        result.kind == t.kind &&\n        result.precision == max_precision_for(t.kind) &&\n        precision_le(t.precision, result.precision)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0129", "language": "verus", "source": "numpy_triple", "source_id": "data_type_routines_may_share_memory", "vc-description": "numpy.may_share_memory: Determine if two arrays might share memory.\n\nThis function conservatively checks if two arrays might share memory.\nA return of True does not necessarily mean that the two arrays share any element.\nIt just means that they might.\n\nOnly the memory bounds of a and b are checked by default.\n\nSpecification: may_share_memory returns a boolean indicating whether two arrays might share memory.\n\nPrecondition: True (no special preconditions needed)\nPostcondition: The function returns a boolean value. If the arrays are identical references,\nit must return True. For independent arrays, it may return False.\nThe function is conservative - it can return True even when arrays don't actually share memory.\n\n/* Basic sanity check: result is a boolean */\n\n/* Conservative property: function is sound - may return True even when arrays don't share memory */\n\n/* but will detect potential memory overlap based on bounds analysis */\n\n/* Deterministic property: same inputs always produce same output */\n\n/* Reflexive property: an array compared with itself would return consistent result */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn may_share_memory(a: &Vec<i8>, b: &Vec<i8>) -> (result: bool)\n    ensures\n\n        (result == true || result == false) &&\n\n        (result == true ==> true) &&\n\n        true &&\n\n        true", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0130", "language": "verus", "source": "numpy_triple", "source_id": "data_type_routines_min_scalar_type", "vc-description": "numpy.min_scalar_type: For scalar a, returns the data type with the smallest size \nand smallest scalar kind which can hold its value.\n\nThis function determines the minimal NumPy data type that can represent a given scalar value.\nThe function prioritizes:\n1. Smallest possible size (in bits)\n2. Smallest scalar kind (unsigned int < signed int < float < complex)\n\nFor integer values, it finds the smallest integer type that can hold the value.\nFor floating point values, it finds the smallest float type that can represent it.\n\nSpecification: min_scalar_type returns the minimal data type that can hold the given value.\n\nPrecondition: True (works for any scalar value)\nPostcondition: The returned type is the minimal type that can hold the value, meaning:\n1. The type can represent the given value\n2. No type with smaller size can represent the value\n3. Among types of the same size, it has the smallest kind order", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n/* Enumeration for NumPy data types */\n#[derive(PartialEq, Eq, Structural)]\npub enum NumpyDType {\n    UInt8,\n    UInt16,\n    UInt32,\n    UInt64,\n    Int8,\n    Int16,\n    Int32,\n    Int64,\n    Float16,\n    Float32,\n    Float64,\n    Complex64,\n    Complex128,\n}\n\n/* Define type sizes in bits */\nspec fn dtype_size(dt: NumpyDType) -> nat {\n    match dt {\n        NumpyDType::UInt8 => 8,\n        NumpyDType::UInt16 => 16,\n        NumpyDType::UInt32 => 32,\n        NumpyDType::UInt64 => 64,\n        NumpyDType::Int8 => 8,\n        NumpyDType::Int16 => 16,\n        NumpyDType::Int32 => 32,\n        NumpyDType::Int64 => 64,\n        NumpyDType::Float16 => 16,\n        NumpyDType::Float32 => 32,\n        NumpyDType::Float64 => 64,\n        NumpyDType::Complex64 => 64,\n        NumpyDType::Complex128 => 128,\n    }\n}\n\n/* Define type hierarchy (order of preference) */\nspec fn dtype_kind_order(dt: NumpyDType) -> nat {\n    match dt {\n        NumpyDType::UInt8 | NumpyDType::UInt16 | NumpyDType::UInt32 | NumpyDType::UInt64 => 0,\n        NumpyDType::Int8 | NumpyDType::Int16 | NumpyDType::Int32 | NumpyDType::Int64 => 1,\n        NumpyDType::Float16 | NumpyDType::Float32 | NumpyDType::Float64 => 2,\n        NumpyDType::Complex64 | NumpyDType::Complex128 => 3,\n    }\n}\n\n/* Check if a type can represent a given integer value */\nspec fn can_represent_value(dt: NumpyDType, value: int) -> bool {\n    match dt {\n        NumpyDType::UInt8 => 0 <= value <= 255,\n        NumpyDType::UInt16 => 0 <= value <= 65535,\n        NumpyDType::UInt32 => 0 <= value <= 4294967295,\n        NumpyDType::UInt64 => 0 <= value <= 18446744073709551615,\n        NumpyDType::Int8 => -128 <= value <= 127,\n        NumpyDType::Int16 => -32768 <= value <= 32767,\n        NumpyDType::Int32 => -2147483648 <= value <= 2147483647,\n        NumpyDType::Int64 => -9223372036854775808 <= value <= 9223372036854775807,\n        NumpyDType::Float16 | NumpyDType::Float32 | NumpyDType::Float64 | NumpyDType::Complex64 | NumpyDType::Complex128 => true,\n    }\n}", "vc-helpers": "", "vc-spec": "fn min_scalar_type(value: i8) -> (result: NumpyDType)\n    ensures\n        can_represent_value(result, value as int),\n        forall|dt: NumpyDType| dtype_size(dt) < dtype_size(result) ==> !can_represent_value(dt, value as int),\n        forall|dt: NumpyDType| dtype_size(dt) == dtype_size(result) && can_represent_value(dt, value as int) ==> dtype_kind_order(result) <= dtype_kind_order(dt)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0131", "language": "verus", "source": "numpy_triple", "source_id": "data_type_routines_mintypecode", "vc-description": "Return the character for the minimum-size type to which given types can be safely cast\n\n/* NumPy type character to precedence mapping based on the default typeset 'GDFgdf'\n   Lower values indicate higher precedence (smaller/more restrictive types) */\n\n// longdouble (most restrictive in numerical sense)\n\n// double\n\n// float\n\n// csingle (complex float)\n\n// cdouble (complex double)\n\n// clongdouble (complex long double)\n\n// other types (lowest precedence)\n\n/* Check if a type character is in the given typeset */\n\n/* Filter characters that are in the typeset */\n\n/* Find minimum precedence character in a sequence */\n\n// default fallback\n\n// Case 1: No input types in typeset - return default\n\n// Case 2 & 3: When intersection is non-empty\n\n// Special rule - if both 'F' and 'd' are in intersection, return 'D'\n\n// Normal case - return minimum precedence type from intersection\n\n// Validity: result is either from intersection or default", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn typechar_precedence(c: char) -> nat {\n    match c {\n        'g' => 0,\n        'd' => 1,\n        'f' => 2,\n        'F' => 3,\n        'D' => 4,\n        'G' => 5,\n        _   => 6,\n    }\n}\n\nspec fn char_in_typeset(c: char, typeset: Seq<char>) -> bool {\n    typeset.contains(c)\n}\n\nspec fn filter_chars_in_typeset(typechars: Seq<char>, typeset: Seq<char>) -> Seq<char> {\n    typechars.filter(|c: char| char_in_typeset(c, typeset))\n}\n\nspec fn min_precedence_char(chars: Seq<char>) -> char\n    decreases chars.len()\n{\n    if chars.len() == 0 {\n        'G'\n    } else if chars.len() == 1 {\n        chars[0]\n    } else {\n        let first = chars[0];\n        let rest_min = min_precedence_char(chars.skip(1));\n        if typechar_precedence(first) <= typechar_precedence(rest_min) {\n            first\n        } else {\n            rest_min\n        }\n    }\n}", "vc-helpers": "", "vc-spec": "fn mintypecode(typechars: Vec<char>, typeset: Vec<char>, default: char) -> (result: char)\n    requires typeset@ == seq!['G', 'D', 'F', 'g', 'd', 'f'],\n    ensures ({\n        let intersection = filter_chars_in_typeset(typechars@, typeset@);\n\n        (intersection.len() == 0 ==> result == default) &&\n\n        (intersection.len() > 0 ==> {\n\n            if intersection.contains('F') && intersection.contains('d') {\n                result == 'D'\n            } else {\n\n                intersection.contains(result) &&\n                (forall|c: char| intersection.contains(c) ==> typechar_precedence(result) <= typechar_precedence(c))\n            }\n        }) &&\n\n        (intersection.contains(result) || result == default)\n    })", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0132", "language": "verus", "source": "numpy_triple", "source_id": "data_type_routines_obj2sctype", "vc-description": "numpy.obj2sctype: Return the scalar dtype or NumPy equivalent of Python type of an object.\n\nTakes any object and returns its corresponding NumPy scalar data type.\nIf the object's type cannot be determined, returns the default value if provided,\notherwise returns none.\n\nThis function performs type introspection to determine the appropriate NumPy\nscalar type for any given object, including arrays, scalars, and generic objects.\n\nSpecification: obj2sctype returns the appropriate NumPy scalar type for the input object.\n\nThe function correctly identifies:\n1. Scalar types from their corresponding objects\n2. Array element types from array objects\n3. Generic object types\n4. Returns default for unrecognized types\n5. Returns none when no default is provided for unrecognized types\n\nPrecondition: True (works with any object)\nPostcondition: The result correctly represents the scalar type of the input object\n\n/* NumPy scalar data types represented as an enum */\n\n/* Object representation for type introspection */\n\n/* Helper predicate: Check if object matches given scalar type */\n\n/* Helper predicate: Check if object is an array with given element type */\n\n/* Helper predicate: Check if object is a generic object */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n#[derive(PartialEq, Eq)]\npub enum NumpyScalarType {\n    Int32,\n    Int64,\n    Float32,\n    Float64,\n    Complex64,\n    Complex128,\n    Object,\n    String,\n    Bool,\n}\n\npub enum NumpyObject {\n    IntVal(i64),\n    FloatVal(f64),\n    ArrayInt(Vec<i64>),\n    ArrayFloat(Vec<f64>),\n    ArrayComplex(Vec<(f64, f64)>),\n    GenericObj,\n    StringVal(String),\n    BoolVal(bool),\n}\n\npub open spec fn matches_scalar_type(obj: NumpyObject, dtype: NumpyScalarType) -> bool {\n    match (obj, dtype) {\n        (NumpyObject::IntVal(_), NumpyScalarType::Int64) => true,\n        (NumpyObject::FloatVal(_), NumpyScalarType::Float64) => true,\n        (NumpyObject::StringVal(_), NumpyScalarType::String) => true,\n        (NumpyObject::BoolVal(_), NumpyScalarType::Bool) => true,\n        _ => false,\n    }\n}\n\npub open spec fn is_array_with_element_type(obj: NumpyObject, dtype: NumpyScalarType) -> bool {\n    match (obj, dtype) {\n        (NumpyObject::ArrayInt(_), NumpyScalarType::Int64) => true,\n        (NumpyObject::ArrayFloat(_), NumpyScalarType::Float64) => true,\n        (NumpyObject::ArrayComplex(_), NumpyScalarType::Complex128) => true,\n        _ => false,\n    }\n}\n\npub open spec fn is_generic_object(obj: NumpyObject) -> bool {\n    match obj {\n        NumpyObject::GenericObj => true,\n        _ => false,\n    }\n}", "vc-helpers": "", "vc-spec": "fn obj2sctype(rep: NumpyObject, default: Option<NumpyScalarType>) -> (result: Option<NumpyScalarType>)\n    ensures\n        match rep {\n            NumpyObject::IntVal(_) => result == Some(NumpyScalarType::Int64),\n            NumpyObject::FloatVal(_) => result == Some(NumpyScalarType::Float64),\n            NumpyObject::ArrayInt(_) => result == Some(NumpyScalarType::Int64),\n            NumpyObject::ArrayFloat(_) => result == Some(NumpyScalarType::Float64),\n            NumpyObject::ArrayComplex(_) => result == Some(NumpyScalarType::Complex128),\n            NumpyObject::StringVal(_) => result == Some(NumpyScalarType::String),\n            NumpyObject::BoolVal(_) => result == Some(NumpyScalarType::Bool),\n            NumpyObject::GenericObj => result == default,\n        },\n        match result {\n            Some(dtype) => \n                matches_scalar_type(rep, dtype) || \n                is_array_with_element_type(rep, dtype) ||\n                (is_generic_object(rep) && result == default),\n            None => is_generic_object(rep) && default.is_None(),\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0133", "language": "verus", "source": "numpy_triple", "source_id": "data_type_routines_promote_types", "vc-description": "numpy.promote_types: Returns the data type with the smallest size and smallest scalar kind to which both type1 and type2 may be safely cast. This function is symmetric but rarely associative. It returns a \"canonical\" dtype. Examples from NumPy documentation: promote_types('f4', 'f8') = 'f8' (float64), promote_types('i8', 'f4') = 'f8' (float64), promote_types('i4', 'S8') = 'S11' (string, but we focus on numeric types). Specification: promote_types returns the smallest safe common type for two dtypes. Key properties based on NumPy's type promotion rules: 1. Symmetry: promote_types(a, b) = promote_types(b, a), 2. Safety: Both input types can be safely cast to the result type, 3. Minimality: The result is the smallest type that satisfies the safety requirement, 4. Type promotion hierarchy: If either input is complex, result is complex; If either input is float, result is float (unless both are complex); Signed integers promote to larger signed integers; Unsigned integers promote to larger unsigned integers; Mixed signed/unsigned promote to signed of sufficient size, 5. Size consideration: Result has size >= max(size(type1), size(type2)), 6. Specific examples: Float32 + Float64 → Float64 (larger precision); Int64 + Float32 → Float64 (float with sufficient precision); Complex64 + Float32 → Complex64 (complex dominates).\n\n/* Symmetry property - function is commutative */\n\n/* Type promotion hierarchy rules */\n\n/* If either input is complex, result must be complex */\n\n/* If either input is float (and not complex), result is float or complex */\n\n/* Size constraint: result size >= max of input sizes */\n\n/* Promotion hierarchy: result rank >= max of input ranks */\n\n/* Same types promote to themselves (reflexivity) */\n\n/* Float precision promotion */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n#[derive(Copy, Clone, PartialEq, Eq)]\npub enum NumpyDType {\n    UInt8,\n    UInt16,\n    UInt32,\n    UInt64,\n    Int8,\n    Int16,\n    Int32,\n    Int64,\n    Float16,\n    Float32,\n    Float64,\n    Complex64,\n    Complex128,\n}\n\nspec fn dtype_size(dt: NumpyDType) -> nat {\n    match dt {\n        NumpyDType::UInt8 => 8,\n        NumpyDType::UInt16 => 16,\n        NumpyDType::UInt32 => 32,\n        NumpyDType::UInt64 => 64,\n        NumpyDType::Int8 => 8,\n        NumpyDType::Int16 => 16,\n        NumpyDType::Int32 => 32,\n        NumpyDType::Int64 => 64,\n        NumpyDType::Float16 => 16,\n        NumpyDType::Float32 => 32,\n        NumpyDType::Float64 => 64,\n        NumpyDType::Complex64 => 64,\n        NumpyDType::Complex128 => 128,\n    }\n}\n\nspec fn promotion_hierarchy(dt: NumpyDType) -> nat {\n    match dt {\n        NumpyDType::UInt8 => 0,\n        NumpyDType::UInt16 => 1,\n        NumpyDType::UInt32 => 2,\n        NumpyDType::UInt64 => 3,\n        NumpyDType::Int8 => 4,\n        NumpyDType::Int16 => 5,\n        NumpyDType::Int32 => 6,\n        NumpyDType::Int64 => 7,\n        NumpyDType::Float16 => 8,\n        NumpyDType::Float32 => 9,\n        NumpyDType::Float64 => 10,\n        NumpyDType::Complex64 => 11,\n        NumpyDType::Complex128 => 12,\n    }\n}\n\nspec fn is_signed_integer(dt: NumpyDType) -> bool {\n    match dt {\n        NumpyDType::Int8 | NumpyDType::Int16 | NumpyDType::Int32 | NumpyDType::Int64 => true,\n        _ => false,\n    }\n}\n\nspec fn is_unsigned_integer(dt: NumpyDType) -> bool {\n    match dt {\n        NumpyDType::UInt8 | NumpyDType::UInt16 | NumpyDType::UInt32 | NumpyDType::UInt64 => true,\n        _ => false,\n    }\n}\n\nspec fn is_float(dt: NumpyDType) -> bool {\n    match dt {\n        NumpyDType::Float16 | NumpyDType::Float32 | NumpyDType::Float64 => true,\n        _ => false,\n    }\n}\n\nspec fn is_complex(dt: NumpyDType) -> bool {\n    match dt {\n        NumpyDType::Complex64 | NumpyDType::Complex128 => true,\n        _ => false,\n    }\n}", "vc-helpers": "", "vc-spec": "spec fn promote_types_spec(type1: NumpyDType, type2: NumpyDType) -> NumpyDType;\n\nfn promote_types(type1: NumpyDType, type2: NumpyDType) -> (result: NumpyDType)\n    ensures\n        result == promote_types_spec(type1, type2),\n\n        promote_types_spec(type1, type2) == promote_types_spec(type2, type1),\n\n        (is_complex(type1) || is_complex(type2)) ==> is_complex(result),\n\n        (is_float(type1) || is_float(type2)) ==> (is_float(result) || is_complex(result)),\n\n        dtype_size(result) >= if dtype_size(type1) >= dtype_size(type2) { dtype_size(type1) } else { dtype_size(type2) },\n\n        promotion_hierarchy(result) >= if promotion_hierarchy(type1) >= promotion_hierarchy(type2) { promotion_hierarchy(type1) } else { promotion_hierarchy(type2) },\n\n        (type1 == type2) ==> (result == type1),\n\n        (is_float(type1) && is_float(type2)) ==> (\n            is_float(result) && dtype_size(result) >= if dtype_size(type1) >= dtype_size(type2) { dtype_size(type1) } else { dtype_size(type2) }\n        ),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0134", "language": "verus", "source": "numpy_triple", "source_id": "data_type_routines_result_type", "vc-description": "Returns the data type that results from applying NumPy type promotion rules to the arguments. \n\nType promotion in NumPy works similarly to the rules in languages like C++, with some differences. When both scalars and arrays are used, the array's type takes precedence and the scalar's actual value is considered.\n\nThe function takes operands of some operation and returns the result type according to NumPy's type promotion hierarchy.\n\n/* Define NumPy data types for type promotion */\n\n/* 8-bit signed integer */\n\n/* 16-bit signed integer */\n\n/* 32-bit signed integer */\n\n/* 64-bit signed integer */\n\n/* 32-bit floating point */\n\n/* 64-bit floating point */\n\n/* 64-bit complex number */\n\n/* 128-bit complex number */\n\n/* Boolean type */\n\n/* Define type promotion hierarchy (higher number = higher precedence) */\n\n/* Define operand types (either scalar or array) */\n\n/* Scalar value with data type */\n\n/* Array with data type and vector of values */\n\n/* Extract the data type from an operand */\n\n/* Type promotion function for two types */\n\n/* The result type is at least as high in the hierarchy as any input type */\n\n/* The result type is the minimum type that can represent all inputs */\n\n/* Type promotion follows the standard hierarchy */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n#[derive(PartialEq, Eq, Structural)]\npub enum NumpyDType {\n\n    Int8,\n\n    Int16,\n\n    Int32,\n\n    Int64,\n\n    Float32,\n\n    Float64,\n\n    Complex64,\n\n    Complex128,\n\n    Bool,\n}\n\nspec fn type_rank(dtype: NumpyDType) -> nat {\n    match dtype {\n        NumpyDType::Bool => 0,\n        NumpyDType::Int8 => 1,\n        NumpyDType::Int16 => 2,\n        NumpyDType::Int32 => 3,\n        NumpyDType::Int64 => 4,\n        NumpyDType::Float32 => 5,\n        NumpyDType::Float64 => 6,\n        NumpyDType::Complex64 => 7,\n        NumpyDType::Complex128 => 8,\n    }\n}\n\npub enum NumpyOperand {\n\n    Scalar(NumpyDType),\n\n    Array(NumpyDType, Vec<i32>),\n}\n\nspec fn operand_type(operand: NumpyOperand) -> NumpyDType {\n    match operand {\n        NumpyOperand::Scalar(dtype) => dtype,\n        NumpyOperand::Array(dtype, _) => dtype,\n    }\n}\n\nspec fn promote_types(t1: NumpyDType, t2: NumpyDType) -> NumpyDType {\n    if type_rank(t1) >= type_rank(t2) { t1 } else { t2 }\n}", "vc-helpers": "", "vc-spec": "fn result_type(operands: Vec<NumpyOperand>) -> (result: NumpyDType)\n    requires operands.len() > 0,\n    ensures\n\n        forall|i: int| 0 <= i < operands.len() as int ==> \n            type_rank(result) >= type_rank(operand_type(operands@[i])),\n\n        exists|i: int| 0 <= i < operands.len() as int && \n            type_rank(result) == type_rank(operand_type(operands@[i])),\n\n        forall|i: int, j: int| 0 <= i < operands.len() as int && 0 <= j < operands.len() as int ==>\n            type_rank(result) >= type_rank(promote_types(operand_type(operands@[i]), operand_type(operands@[j]))),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0135", "language": "verus", "source": "numpy_triple", "source_id": "data_type_routines_sctype2char", "vc-description": "numpy.sctype2char: Return the string representation of a scalar dtype\n\nConverts a scalar data type to its corresponding single-character string representation.\nThis is used internally by numpy to represent data types in a compact form.\n\nThe mapping follows numpy's dtype.char convention:\n- int32 → 'l'\n- float64 (double) → 'd'  \n- complex128 → 'D'\n- bytes → 'S'\n- object → 'O'\n\nSpecification: sctype2char returns the correct character representation\nfor each scalar type.\n\nPrecondition: Valid scalar type (guaranteed by type system)\nPostcondition: Returns the standard numpy character for the given type", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* Scalar data type enumeration for numpy types */\npub enum ScalarType {\n    /* 32-bit signed integer */\n    Int32,\n    /* 64-bit signed integer */\n    Int64,\n    /* 32-bit floating point */\n    Float32,\n    /* 64-bit floating point */\n    Float64,\n    /* 64-bit complex number */\n    Complex64,\n    /* 128-bit complex number */\n    Complex128,\n    /* Byte string */\n    Bytes,\n    /* Generic object */\n    Object,\n}", "vc-helpers": "", "vc-spec": "fn sctype2char(sctype: ScalarType) -> (result: &'static str)\n    ensures\n        (sctype == ScalarType::Int32) ==> (result == \"l\"),\n        (sctype == ScalarType::Int64) ==> (result == \"q\"),\n        (sctype == ScalarType::Float32) ==> (result == \"f\"),\n        (sctype == ScalarType::Float64) ==> (result == \"d\"),\n        (sctype == ScalarType::Complex64) ==> (result == \"F\"),\n        (sctype == ScalarType::Complex128) ==> (result == \"D\"),\n        (sctype == ScalarType::Bytes) ==> (result == \"S\"),\n        (sctype == ScalarType::Object) ==> (result == \"O\")", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0136", "language": "verus", "source": "numpy_triple", "source_id": "data_type_routines_shares_memory", "vc-description": "Determine if two arrays share memory.\n\nThis function determines if two arrays share memory by checking\nif they reference the same underlying memory locations.\n\nUnlike may_share_memory, this function provides a definitive answer\nabout memory sharing rather than a conservative estimate.\n\nThe function can be exponentially slow for some inputs due to the\ncomplexity of the overlap detection algorithm.\n\nSpecification: shares_memory returns a boolean indicating whether two arrays actually share memory.\n\nPrecondition: True (no special preconditions needed)\nPostcondition: The function returns a boolean value that accurately reflects memory sharing.\nIf the arrays are identical references, it must return True.\nIf the arrays are independent (non-overlapping memory), it must return False.\nThe function is precise - it returns True if and only if the arrays share memory.\n\n// Basic sanity check: result is a boolean - always true\n\n// Reflexive property: an array shares memory with itself when identical\n\n// Independence property: different arrays with different contents don't share memory\n\n// Precision property: the function provides definitive answers about memory sharing\n\n// Basic sanity check: result is a boolean\n\n// Reflexive property: an array shares memory with itself when identical\n\n// Precision property: the function provides definitive answers about memory sharing", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn shares_memory(a: Vec<i8>, b: Vec<i8>) -> bool\n{\n\n    true &&\n\n    (a.len() == b.len() && a@ == b@) &&\n\n    true &&\n\n    true\n}\n\nfn shares_memory_fn(a: Vec<i8>, b: Vec<i8>) -> (result: bool)\n    ensures\n\n        (result == true || result == false) &&\n\n        (a.len() == b.len() && a@ == b@ ==> result == true) &&\n\n        true", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0137", "language": "verus", "source": "numpy_triple", "source_id": "data_type_routines_typecodes", "vc-description": "Dictionary mapping strings to corresponding type character codes\n\nA dictionary with string keys that represent NumPy dtype categories and string values that contain type codes for the NumPy data types in each category.\n\nKeys include:\n- 'Character': 'S1'\n- 'Integer': 'bhilqnp'\n- 'UnsignedInteger': 'BHILQNP'\n- 'Float': 'fdg'\n- 'Complex': 'FDG'\n- 'AllInteger': 'bBhHiIlLqQnNpP'\n- 'AllFloat': 'fdgFDG'\n- 'Datetime': 'Mm'\n- 'All': '?bhilqnpBHILQNPfdgFDGSUVOMm'\n\nThis is useful for iterating over all dtypes of a certain kind.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn typecodes(category: &str) -> (result: Option<&str>)\n    ensures\n        (category@ == \"Character\"@) ==> (result == Some(\"S1\")),\n        (category@ == \"Integer\"@) ==> (result == Some(\"bhilqnp\")),\n        (category@ == \"UnsignedInteger\"@) ==> (result == Some(\"BHILQNP\")),\n        (category@ == \"Float\"@) ==> (result == Some(\"fdg\")),\n        (category@ == \"Complex\"@) ==> (result == Some(\"FDG\")),\n        (category@ == \"AllInteger\"@) ==> (result == Some(\"bBhHiIlLqQnNpP\")),\n        (category@ == \"AllFloat\"@) ==> (result == Some(\"fdgFDG\")),\n        (category@ == \"Datetime\"@) ==> (result == Some(\"Mm\")),\n        (category@ == \"All\"@) ==> (result == Some(\"?bhilqnpBHILQNPfdgFDGSUVOMm\")),\n        (category@ != \"Character\"@ && category@ != \"Integer\"@ && category@ != \"UnsignedInteger\"@ && \n         category@ != \"Float\"@ && category@ != \"Complex\"@ && category@ != \"AllInteger\"@ && \n         category@ != \"AllFloat\"@ && category@ != \"Datetime\"@ && category@ != \"All\"@) ==> (result == None::<&str>)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0138", "language": "verus", "source": "numpy_triple", "source_id": "data_type_routines_typename", "vc-description": "Return a description for the given data type code\n\n{\n  \"name\": \"numpy.typename\",\n  \"category\": \"Miscellaneous Type Utilities\", \n  \"description\": \"Return a description for the given data type code\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.typename.html\",\n  \"doc\": \"Return a description for the given data type code.\\n\\nParameters\\n----------\\nchar : str\\n    Data type code.\\n\\nReturns\\n-------\\nout : str\\n    Description of the input data type code.\\n\\nExamples\\n--------\\n>>> typechars = ['S1', '?', 'B', 'D', 'G', 'F', 'I', 'H', 'L', 'O', 'Q',\\n...              'S', 'U', 'V', 'b', 'd', 'g', 'f', 'i', 'h', 'l', 'q']\\n>>> for typechar in typechars:\\n...     print(typechar, ' : ', np.typename(typechar))\\n...\\nS1  :  character\\n?  :  bool\\nB  :  unsigned char\\nD  :  complex double precision\\nG  :  complex long double precision\\nF  :  complex single precision\\nI  :  unsigned integer\\nH  :  unsigned short\\nL  :  unsigned long integer\\nO  :  object\\nQ  :  unsigned long long integer\\nS  :  character\\nU  :  unicode\\nV  :  void\\nb  :  signed char\\nd  :  double precision\\ng  :  long precision\\nf  :  single precision\\ni  :  integer\\nh  :  short\\nl  :  long integer\\nq  :  long long integer\",\n}\n\nReturn a description for the given data type code\n\nSpecification: typename maps data type codes to their descriptions", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn typename(char: &str) -> (result: String)\n    ensures\n        /* Known type code mappings from NumPy documentation */\n        (char == \"S1\" ==> result@ == seq!['c','h','a','r','a','c','t','e','r']) &&\n        (char == \"?\" ==> result@ == seq!['b','o','o','l']) &&\n        (char == \"B\" ==> result@ == seq!['u','n','s','i','g','n','e','d',' ','c','h','a','r']) &&\n        (char == \"D\" ==> result@ == seq!['c','o','m','p','l','e','x',' ','d','o','u','b','l','e',' ','p','r','e','c','i','s','i','o','n']) &&\n        (char == \"G\" ==> result@ == seq!['c','o','m','p','l','e','x',' ','l','o','n','g',' ','d','o','u','b','l','e',' ','p','r','e','c','i','s','i','o','n']) &&\n        (char == \"F\" ==> result@ == seq!['c','o','m','p','l','e','x',' ','s','i','n','g','l','e',' ','p','r','e','c','i','s','i','o','n']) &&\n        (char == \"I\" ==> result@ == seq!['u','n','s','i','g','n','e','d',' ','i','n','t','e','g','e','r']) &&\n        (char == \"H\" ==> result@ == seq!['u','n','s','i','g','n','e','d',' ','s','h','o','r','t']) &&\n        (char == \"L\" ==> result@ == seq!['u','n','s','i','g','n','e','d',' ','l','o','n','g',' ','i','n','t','e','g','e','r']) &&\n        (char == \"O\" ==> result@ == seq!['o','b','j','e','c','t']) &&\n        (char == \"Q\" ==> result@ == seq!['u','n','s','i','g','n','e','d',' ','l','o','n','g',' ','l','o','n','g',' ','i','n','t','e','g','e','r']) &&\n        (char == \"S\" ==> result@ == seq!['c','h','a','r','a','c','t','e','r']) &&\n        (char == \"U\" ==> result@ == seq!['u','n','i','c','o','d','e']) &&\n        (char == \"V\" ==> result@ == seq!['v','o','i','d']) &&\n        (char == \"b\" ==> result@ == seq!['s','i','g','n','e','d',' ','c','h','a','r']) &&\n        (char == \"d\" ==> result@ == seq!['d','o','u','b','l','e',' ','p','r','e','c','i','s','i','o','n']) &&\n        (char == \"g\" ==> result@ == seq!['l','o','n','g',' ','p','r','e','c','i','s','i','o','n']) &&\n        (char == \"f\" ==> result@ == seq!['s','i','n','g','l','e',' ','p','r','e','c','i','s','i','o','n']) &&\n        (char == \"i\" ==> result@ == seq!['i','n','t','e','g','e','r']) &&\n        (char == \"h\" ==> result@ == seq!['s','h','o','r','t']) &&\n        (char == \"l\" ==> result@ == seq!['l','o','n','g',' ','i','n','t','e','g','e','r']) &&\n        (char == \"q\" ==> result@ == seq!['l','o','n','g',' ','l','o','n','g',' ','i','n','t','e','g','e','r']) &&\n        /* For unknown type codes, return default description */\n        (char != \"S1\" && char != \"?\" && char != \"B\" && char != \"D\" && \n         char != \"G\" && char != \"F\" && char != \"I\" && char != \"H\" && \n         char != \"L\" && char != \"O\" && char != \"Q\" && char != \"S\" && \n         char != \"U\" && char != \"V\" && char != \"b\" && char != \"d\" && \n         char != \"g\" && char != \"f\" && char != \"i\" && char != \"h\" && \n         char != \"l\" && char != \"q\" ==>\n         (result@ == seq!['u','n','k','n','o','w','n',' ','t','y','p','e'] || result@ == char@)),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0142", "language": "verus", "source": "numpy_triple", "source_id": "datetime_support_datetime64", "vc-description": "Create a datetime64 object representing an offset from 1970-01-01T00:00:00\n\n{\n  \"name\": \"numpy.datetime64\",\n  \"category\": \"Datetime types\", \n  \"description\": \"Create a datetime64 object representing an offset from 1970-01-01T00:00:00\",\n  \"url\": \"https://numpy.org/doc/stable/reference/arrays.datetime.html#numpy.datetime64\",\n  \"doc\": \"If created from a 64-bit integer, it represents an offset from ``1970-01-01T00:00:00``. If created from string, the string can be in ISO 8601 date or datetime format.\\n\\nWhen parsing a string to create a datetime object, if the string contains a trailing timezone (A 'Z' or a timezone offset), the timezone will be dropped and a User Warning is given.\\n\\nDatetime64 objects should be considered to be UTC and therefore have an offset of +0000.\\n\\n>>> np.datetime64(10, 'Y')\\nnp.datetime64('1980')\\n>>> np.datetime64('1980', 'Y')\\nnp.datetime64('1980')\\n>>> np.datetime64(10, 'D')\\nnp.datetime64('1970-01-11')\\n\\nSee :ref:`arrays.datetime` for more information.\\n\\n:Character code: ``'M'``\"\n}\n\nCreate a datetime64 object from an integer offset and time unit\n\nSpecification: datetime64 creates a UTC datetime object with the specified offset and unit.\nThe datetime64 object represents a specific moment in time as an offset from the Unix epoch\n(1970-01-01T00:00:00 UTC) in the specified time unit. The function preserves the input\nparameters and ensures the result is always in UTC timezone.\n\n/* Time unit for datetime64 */\n\n/* Years unit ('Y') */\n\n/* Days unit ('D') */\n\n/* Hours unit ('h') */\n\n/* Minutes unit ('m') */\n\n/* Seconds unit ('s') */\n\n/* Milliseconds unit ('ms') */\n\n/* Microseconds unit ('us') */\n\n/* Nanoseconds unit ('ns') */\n\n/* DateTime64 structure representing offset from Unix epoch */\n\n/* Offset value from 1970-01-01T00:00:00 */\n\n/* Time unit of the offset */\n\n/* Always UTC with +0000 offset */\n\n/* Unit-specific validity constraints based on NumPy datetime64 limits */\n\n/* Valid year range */\n\n/* Days since epoch */\n\n/* Hours since epoch */\n\n/* Minutes since epoch */\n\n/* Seconds since epoch */\n\n/* Milliseconds can use full Int range */\n\n/* Microseconds can use full Int range */\n\n/* Nanoseconds can use full Int range */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\npub enum TimeUnit {\n\n    Years,\n\n    Days,\n\n    Hours,\n\n    Minutes,\n\n    Seconds,\n\n    Milliseconds,\n\n    Microseconds,\n\n    Nanoseconds,\n}\n\npub struct DateTime64 {\n\n    pub offset: i64,\n\n    pub unit: TimeUnit,\n\n    pub is_utc: bool,\n}", "vc-helpers": "", "vc-spec": "fn datetime64(offset: i64, unit: TimeUnit) -> (result: DateTime64)\n    ensures \n        result.offset == offset,\n        result.unit == unit,\n        result.is_utc == true,\n\n        match unit {\n            TimeUnit::Years => result.offset + 1970 >= 1 && result.offset + 1970 <= 9999,\n            TimeUnit::Days => result.offset >= -2147483648 && result.offset <= 2147483647,\n            TimeUnit::Hours => result.offset >= -2147483648 && result.offset <= 2147483647,\n            TimeUnit::Minutes => result.offset >= -2147483648 && result.offset <= 2147483647,\n            TimeUnit::Seconds => result.offset >= -2147483648 && result.offset <= 2147483647,\n            TimeUnit::Milliseconds => true,\n            TimeUnit::Microseconds => true,\n            TimeUnit::Nanoseconds => true,\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0143", "language": "verus", "source": "numpy_triple", "source_id": "datetime_support_datetime_as_string", "vc-description": "Convert an array of datetime64 values to an array of strings.\n\nConverts each datetime64 value in the input vector to its string representation.\nThe format depends on the timezone option: 'naive' produces no suffix,\n'UTC' adds 'Z' suffix, and 'local' would add timezone offset.\n\nFor simplicity, we focus on the core conversion from datetime64 to ISO format strings.\n\nSpecification: datetime_as_string converts each datetime64 to its string representation.\n\nPrecondition: True (no special preconditions)\nPostcondition: Each datetime64 is converted to a properly formatted ISO 8601 string\n\n/* Time unit for datetime64 */\n\n/* Years unit ('Y') */\n\n/* Days unit ('D') */\n\n/* Hours unit ('h') */\n\n/* Minutes unit ('m') */\n\n/* Seconds unit ('s') */\n\n/* Milliseconds unit ('ms') */\n\n/* Microseconds unit ('us') */\n\n/* Nanoseconds unit ('ns') */\n\n/* DateTime64 structure representing offset from Unix epoch */\n\n/* Offset value from 1970-01-01T00:00:00 */\n\n/* Time unit of the offset */\n\n/* Always UTC with +0000 offset */\n\n/* Timezone formatting options */\n\n/* No timezone suffix */\n\n/* Add 'Z' suffix for UTC */\n\n/* Add local timezone offset */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n#[derive(PartialEq, Eq)]\nenum TimeUnit {\n\n    Years,\n\n    Days,\n\n    Hours,\n\n    Minutes,\n\n    Seconds,\n\n    Milliseconds,\n\n    Microseconds,\n\n    Nanoseconds,\n}\n\n#[derive(PartialEq, Eq)]\nstruct DateTime64 {\n\n    offset: i64,\n\n    unit: TimeUnit,\n\n    is_utc: bool,\n}\n\n#[derive(PartialEq, Eq)]\nenum TimezoneOption {\n\n    Naive,\n\n    UTC,\n\n    Local,\n}", "vc-helpers": "", "vc-spec": "fn datetime_as_string(arr: Vec<DateTime64>, timezone: TimezoneOption) -> (result: Vec<String>)\n    requires arr@.len() > 0,\n    ensures \n        result@.len() == arr@.len(),\n        forall|i: int| 0 <= i < result@.len() ==> #[trigger] result@[i]@.len() > 0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0144", "language": "verus", "source": "numpy_triple", "source_id": "datetime_support_datetime_data", "vc-description": "Get information about the step size of a date or time type.\n\nReturns a tuple containing the datetime unit and count for the given dtype.\nThis information can be used to construct datetime64 and timedelta64 objects.\n\nFor example, 'timedelta64[25s]' would return ('s', 25).\n\nSpecification: datetime_data extracts the unit and count from a datetime dtype.\n\nPrecondition: The dtype must be a valid datetime64 or timedelta64 type.\nPostcondition: The returned tuple contains the unit and count that define the dtype.\n\nFor datetime64[N unit], returns (unit, N).\nFor timedelta64[N unit], returns (unit, N).\n\nThis ensures that the returned information can be used to reconstruct\nthe original dtype or create compatible datetime objects.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* Datetime unit enumeration representing the time scales used in datetime operations */\n#[derive(PartialEq, Eq, Structural)]\npub enum DatetimeUnit {\n    /* Years */\n    Y,\n    /* Months */\n    M,\n    /* Weeks */\n    W,\n    /* Days */\n    D,\n    /* Hours */\n    H,\n    /* Minutes */\n    Min,\n    /* Seconds */\n    S,\n    /* Milliseconds */\n    Ms,\n    /* Microseconds */\n    Us,\n    /* Nanoseconds */\n    Ns,\n}\n\n/* Structure containing datetime type information including unit and count */\n#[derive(PartialEq, Eq, Structural)]\npub struct DatetimeTypeInfo {\n    /* The time unit (seconds, minutes, hours, etc.) */\n    pub unit: DatetimeUnit,\n    /* The count of base units in a step (e.g., 25 for \"25 seconds\") */\n    pub count: nat,\n}\n\n/* Datetime dtype representing either datetime64 or timedelta64 types */\n#[derive(PartialEq, Eq, Structural)]\npub enum DatetimeDtype {\n    /* A datetime64 type with specified unit and count */\n    Datetime64(DatetimeTypeInfo),\n    /* A timedelta64 type with specified unit and count */\n    Timedelta64(DatetimeTypeInfo),\n}", "vc-helpers": "", "vc-spec": "fn datetime_data(dtype: DatetimeDtype) -> (result: (DatetimeUnit, u8))\n    ensures\n        match dtype {\n            DatetimeDtype::Datetime64(info) => result == (info.unit, info.count as u8) && info.count > 0,\n            DatetimeDtype::Timedelta64(info) => result == (info.unit, info.count as u8) && info.count > 0,\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0146", "language": "verus", "source": "numpy_triple", "source_id": "datetime_support_timedelta64", "vc-description": "A timedelta stored as a 64-bit integer.\n\nSee arrays.datetime for more information.\n\nCharacter code: 'm'\n\nCreate a timedelta64 object from a numeric value and time unit\n\nSpecification: timedelta64 creates a time duration object with given value and unit\n\n/* Time unit codes for timedelta64 */\n\n/* Year unit ('Y') */\n\n/* Month unit ('M') */\n\n/* Week unit ('W') */\n\n/* Day unit ('D') */\n\n/* Hour unit ('h') */\n\n/* Minute unit ('m') */\n\n/* Second unit ('s') */\n\n/* Millisecond unit ('ms') */\n\n/* Microsecond unit ('us') */\n\n/* Nanosecond unit ('ns') */\n\n/* Picosecond unit ('ps') */\n\n/* Femtosecond unit ('fs') */\n\n/* Attosecond unit ('as') */\n\n/* Represents a time duration value */\n\n/* The numeric value of the time duration */\n\n/* The time unit for the duration */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n#[derive(PartialEq, Eq, Structural)]\npub enum TimeUnit {\n\n    Year,\n\n    Month,\n\n    Week,\n\n    Day,\n\n    Hour,\n\n    Minute,\n\n    Second,\n\n    Millisecond,\n\n    Microsecond,\n\n    Nanosecond,\n\n    Picosecond,\n\n    Femtosecond,\n\n    Attosecond,\n}\n\n#[derive(PartialEq, Eq, Structural)]\npub struct TimeDelta64 {\n\n    pub value: i64,\n\n    pub unit: TimeUnit,\n}", "vc-helpers": "", "vc-spec": "fn timedelta64(value: i64, unit: TimeUnit) -> (result: TimeDelta64)\n    ensures \n        result.value == value,\n        result.unit == unit,\n        result.value >= -9223372036854775808i64,\n        result.value <= 9223372036854775807i64,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0147", "language": "verus", "source": "numpy_triple", "source_id": "fft_fft", "vc-description": "Compute the one-dimensional discrete Fourier Transform\n\nThe FFT computes the DFT defined as:\nX[k] = Σ(n=0 to N-1) x[n] * exp(-2πi*k*n/N)\n\nwhere:\n- x is the input vector\n- X is the output vector\n- N is the length of the vector\n- i is the imaginary unit\n\nSpecification: FFT computes the discrete Fourier transform\n\nThe FFT satisfies the DFT equation and has the following properties:\n1. Each output element is the sum of input elements weighted by complex exponentials\n2. The transform is linear\n3. Parseval's theorem: energy is preserved (with proper normalization)\n4. FFT(FFT^(-1)(x)) = x (inverse property when combined with IFFT)\n\nThe specification captures the fundamental DFT formula where each output\nelement k is computed as the sum over all input elements j, multiplied\nby the complex exponential exp(-2πi*k*j/n).\n\n/* placeholder for cos(theta) */\n\n/* placeholder for sin(theta) */\n\n/* placeholder for complex multiplication real part */\n\n/* placeholder for complex multiplication imaginary part */\n\n/* placeholder for complex addition real part */\n\n/* placeholder for complex addition imaginary part */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\npub struct Complex {\n    pub re: f64,\n    pub im: f64,\n}\n\npub open spec fn cexp(theta: f64) -> Complex {\n    Complex {\n        re: 1.0,\n        im: 0.0,\n    }\n}\n\npub open spec fn complex_mul(z: Complex, w: Complex) -> Complex {\n    Complex {\n        re: 0.0,\n        im: 0.0,\n    }\n}\n\npub open spec fn complex_add(z: Complex, w: Complex) -> Complex {\n    Complex {\n        re: 0.0,\n        im: 0.0,\n    }\n}\n\npub open spec fn complex_zero() -> Complex {\n    Complex { re: 0.0, im: 0.0 }\n}\n\npub open spec fn f64_to_complex(x: f64) -> Complex {\n    Complex { re: x, im: 0.0 }\n}\n\npub open spec fn complex_sum(n: nat, f: spec_fn(nat) -> Complex) -> Complex\n    decreases n\n{\n    if n == 0 {\n        complex_zero()\n    } else {\n        complex_add(f((n - 1) as nat), complex_sum((n - 1) as nat, f))\n    }\n}", "vc-helpers": "", "vc-spec": "pub fn fft(a: Vec<Complex>) -> (result: Vec<Complex>)\n    requires a.len() > 0,\n    ensures \n        result.len() == a.len(),\n        forall|k: usize| k < result.len() ==> \n            result@[k as int] == complex_sum(a.len() as nat, |j: nat| \n                if j < a.len() {\n                    complex_mul(a@[j as int], cexp(0.0))\n                } else {\n                    complex_zero()\n                }\n            ),\n        result.len() > 0 ==> result@[0] == complex_sum(a.len() as nat, |j: nat|\n            if j < a.len() { a@[j as int] } else { complex_zero() }\n        ),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0149", "language": "verus", "source": "numpy_triple", "source_id": "fft_fftfreq", "vc-description": "numpy.fft.fftfreq: Return the Discrete Fourier Transform sample frequencies.\n\nThe function returns the discrete Fourier Transform sample frequencies\nwith frequency bin centers in cycles per unit of sample spacing.\n\nFor even n: frequencies are [0, 1, ..., n/2-1, -n/2, ..., -1] / (d*n)\nFor odd n: frequencies are [0, 1, ..., (n-1)/2, -(n-1)/2, ..., -1] / (d*n)\n\nThe frequencies are arranged in standard DFT order: positive frequencies\nfirst, then negative frequencies.\n\nSpecification: fftfreq returns sample frequencies according to the DFT convention.\n\nThe frequencies are arranged so that:\n- The first half contains non-negative frequencies [0, 1, ..., N-1] / (d*n)\n- The second half contains negative frequencies for the remaining indices\n\nwhere N = (n + 1) / 2 is the number of non-negative frequencies.\n\nPreconditions:\n- n > 0 (non-empty frequency array)\n- d ≠ 0 (valid sample spacing)\n\nPostconditions:\n- For indices i < N: result[i] = i / (d*n)\n- For indices i ≥ N: result[i] = (i - n) / (d*n)\n- The DC component (index 0) is always 0\n- The frequencies are symmetric around the Nyquist frequency", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn fft_freq_val(i: int, n: int, d: f64) -> f64;\n\nfn fftfreq(n: usize, d: f64) -> (result: Vec<f64>)\n    requires \n        n > 0,\n        d != 0.0,\n    ensures\n        result.len() == n,\n        forall|i: int| 0 <= i < ((n as int + 1) / 2) ==> \n            result[i as int] == fft_freq_val(i, n as int, d),\n        forall|i: int| ((n as int + 1) / 2) <= i < n as int ==>\n            result[i as int] == fft_freq_val(i, n as int, d),\n        result[0] == 0.0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "VT0151", "language": "verus", "source": "numpy_triple", "source_id": "fft_fftshift", "vc-description": "Shift the zero-frequency component to the center of the spectrum.\n\nThis function rearranges the FFT output such that the zero-frequency \ncomponent is moved from the beginning to the center of the array.\nFor even-length arrays, it performs a circular shift by n/2.\nFor odd-length arrays, it performs a circular shift by (n-1)/2.\n\nSpecification: fftshift performs a circular shift that moves the zero-frequency \ncomponent to the center of the array.\n\nThe function rearranges elements by performing a circular shift:\n- Each element at position i in the result comes from position (i + n - n/2) % n in the input\n- This is equivalent to swapping the first and second halves of the array\n- The zero-frequency component (originally at index 0) moves to the center\n\nKey mathematical properties:\n1. Bijective mapping: every element is preserved and appears exactly once\n2. Circular shift property: implements a specific permutation\n3. Involution property: for even n, fftshift(fftshift(x)) = x\n4. Sum preservation: the sum of all elements remains unchanged", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn fftshift(x: Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() as int ==> \n            result[i as int] == x[((i + (x.len() as int) - (x.len() as int) / 2) % (x.len() as int)) as int]", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0152", "language": "verus", "source": "numpy_triple", "source_id": "fft_hfft", "vc-description": "numpy.fft.hfft: Compute the FFT of a signal that has Hermitian symmetry.\n\nThe Hermitian FFT assumes that the input signal has Hermitian symmetry,\nwhich means that the signal in the frequency domain is real-valued.\nThis is the inverse operation of rfft.\n\nFor a signal with Hermitian symmetry, the output will be real-valued\nand the length of the transform is determined by the input length.\nIf input has length m, the output has length 2*(m-1).\n\nThe function essentially computes the inverse of rfft by taking\nthe conjugate of the input and then computing the inverse real FFT.\n\nSpecification: numpy.fft.hfft computes the FFT of a signal with Hermitian symmetry.\n\nPrecondition: The input vector represents a Hermitian symmetric signal\nPostcondition: The output is a real-valued vector of length 2*m where\nthe input had length m+1, and the transformation preserves certain mathematical \nproperties of the Hermitian FFT including:\n1. The output is real-valued (no imaginary parts)\n2. The length relationship: if input has m+1 elements, output has 2*m elements\n3. Hermitian symmetry properties are preserved in the transform\n4. The conjugate relationship: this is effectively the inverse of an rfft operation", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n#[derive(PartialEq)]\npub struct Complex {\n    pub real: f32,\n    pub imag: f32,\n}", "vc-helpers": "", "vc-spec": "fn hfft(a: Vec<Complex>, m: u8) -> (result: Vec<f32>)\n    requires \n        m > 0,\n        a.len() == m as nat + 1,\n    ensures\n        result.len() == 2 * m as nat,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0153", "language": "verus", "source": "numpy_triple", "source_id": "fft_ifft", "vc-description": "Compute the one-dimensional inverse discrete Fourier Transform (IFFT).\n\nThe IFFT transforms frequency domain data back to the time domain,\ncomputing the inverse of the DFT such that ifft(fft(x)) ≈ x.\n\nFor a vector of length n, the k-th coefficient is computed as:\nX[k] = (1/n) * Σ(j=0 to n-1) a[j] * exp(2πi*j*k/n)\n\nSpecification: The inverse FFT correctly computes the inverse discrete Fourier transform.\n\nThe IFFT satisfies the inverse DFT equation where each output element k is \ncomputed as (1/n) times the sum over all input elements j, multiplied by the \ncomplex exponential exp(2πi*k*j/n).\n\nThis is the mathematical inverse of the FFT operation, with a positive sign \nin the exponential and a normalization factor of 1/n.\n\n/* Simplified for spec purposes */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "#[derive(PartialEq, Eq, Structural)]\npub struct Complex {\n    pub re: int,\n    pub im: int,\n}\n\nimpl Complex {\n    pub open spec fn add(self, other: Complex) -> Complex {\n        Complex { re: self.re + other.re, im: self.im + other.im }\n    }\n\n    pub open spec fn mul(self, other: Complex) -> Complex {\n        Complex { \n            re: self.re * other.re - self.im * other.im, \n            im: self.re * other.im + self.im * other.re \n        }\n    }\n\n    pub open spec fn scalar_mul(self, s: int) -> Complex {\n        Complex { re: s * self.re, im: s * self.im }\n    }\n}\n\npub open spec fn cexp(theta: int) -> Complex {\n    Complex { re: 1, im: 0 }\n}\n\npub open spec fn complex_sum(n: nat, f: spec_fn(nat) -> Complex) -> Complex\n    decreases n\n{\n    if n == 0 {\n        Complex { re: 0, im: 0 }\n    } else {\n        f((n - 1) as nat).add(complex_sum((n - 1) as nat, f))\n    }\n}\n\nfn ifft(a: Vec<Complex>) -> (result: Vec<Complex>)\n    requires a.len() > 0,\n    ensures\n        result.len() == a.len(),\n        forall|k: int| #[trigger] result[k] == result[k] && 0 <= k < result.len() ==> {\n            let n = a.len() as nat;\n            let expected = complex_sum(n, |j: nat| {\n                if j < n {\n                    a[j as int].mul(cexp(2 * k * (j as int)))\n                } else {\n                    Complex { re: 0, im: 0 }\n                }\n            }).scalar_mul(1);\n            result[k] == expected\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0155", "language": "verus", "source": "numpy_triple", "source_id": "fft_ifftn", "vc-description": "Compute the N-dimensional inverse discrete Fourier Transform (IFFTN).\n\nThe IFFTN extends the 1D inverse FFT to multiple dimensions, computing\nthe inverse of the N-dimensional DFT. For a 2D array, this applies the\ninverse transform along both dimensions.\n\nFor a 2D array of size m×n, the (i,j)-th output element is computed as:\nX[i,j] = (1/(m*n)) * Σ(k=0 to m-1) Σ(l=0 to n-1) a[k,l] * exp(2πi*(i*k/m + j*l/n))\n\nThis is the mathematical inverse of the N-dimensional FFT.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* Sum of integers over finite indices */\npub open spec fn int_sum(n: nat, f: spec_fn(int) -> int) -> int\n    decreases n\n{\n    if n == 0 {\n        0\n    } else {\n        f((n - 1) as int) + int_sum((n - 1) as nat, f)\n    }\n}", "vc-helpers": "", "vc-spec": "fn ifftn(a: Vec<Vec<i8>>) -> (result: Vec<Vec<i8>>)\n    requires \n        a.len() > 0,\n        a.len() < usize::MAX,\n        forall|i: int| 0 <= i < a@.len() ==> a@[i].len() > 0,\n        forall|i: int| 0 <= i < a@.len() ==> a@[i].len() < usize::MAX,\n        forall|i: int, j: int| 0 <= i < a@.len() && 0 <= j < a@.len() ==> a@[i].len() == a@[j].len(),\n    ensures \n        result@.len() == a@.len(),\n        forall|i: int| 0 <= i < result@.len() ==> result@[i].len() == a@[0].len(),\n        forall|i: int, j: int| #[trigger] result@[i][j] == 0 || \n            (0 <= i < result@.len() && 0 <= j < result@[i].len()),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0156", "language": "verus", "source": "numpy_triple", "source_id": "fft_ifftshift", "vc-description": "The inverse of fftshift - undoes the frequency domain shifting.\n\nThis function performs the inverse operation of fftshift, moving the \nzero-frequency component from the center back to the beginning of the array.\nFor even-length arrays, it is identical to fftshift.\nFor odd-length arrays, it differs by one sample position.\n\nThe function performs a circular shift by -(n/2) positions.\n\nSpecification: ifftshift performs the inverse of fftshift.\n\nThe function performs a circular shift that undoes the centering of \nthe zero-frequency component:\n- For even n: shifts by -(n/2), identical to fftshift\n- For odd n: shifts by -(n/2), which differs from fftshift by one sample\n\nThis ensures that:\n- Elements from the center move back to the beginning\n- The DC component at the center returns to index 0\n- The function is the left inverse of fftshift\n\nMathematical properties:\n- For even-length arrays: ifftshift(fftshift(x)) = x and fftshift(ifftshift(x)) = x\n- For odd-length arrays: ifftshift(fftshift(x)) = x but fftshift(ifftshift(x)) ≠ x\n- Preserves the total energy/sum of the array\n- Is a bijection (permutation) of array elements\n\nThe specification states that each element at position i in the result\ncomes from position (i + n/2) % n in the input, which is equivalent\nto a circular left shift by n/2 positions (or right shift by n - n/2).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn ifftshift(x: Vec<f32>) -> (result: Vec<f32>)\n    requires x.len() > 0,\n    ensures \n        result.len() == x.len(),\n        forall|i: int| 0 <= i < x@.len() ==> \n            result[i] == x[((i + (x@.len() as int) / 2) % (x@.len() as int)) as int]", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0157", "language": "verus", "source": "numpy_triple", "source_id": "fft_ihfft", "vc-description": "numpy.fft.ihfft: Compute the inverse FFT of a signal that has Hermitian symmetry.\n\nThis function computes the inverse FFT of a signal that has Hermitian symmetry,\nwhich means the signal is real in the frequency domain. The input should be\na complex signal with Hermitian symmetry, and the output is a real signal.\n\nThe function is analogous to rfft/irfft but for signals with Hermitian symmetry.\nAccording to the NumPy documentation and source code, it essentially computes \nthe conjugate of the rfft of the input: conjugate(rfft(a, n, axis, new_norm, out))\n\nUnlike hfft which takes a Hermitian symmetric input and produces a real output,\nihfft takes a general complex input and produces a complex output with the \ninverse Hermitian FFT properties.\n\nSpecification: ihfft computes the inverse FFT of a signal with Hermitian symmetry.\n\nAccording to NumPy documentation:\n- ihfft is analogous to rfft/irfft but for signals with Hermitian symmetry\n- The implementation is conjugate(rfft(a, n, axis, new_norm, out))\n\nKey mathematical properties:\n1. Length preservation: output has same length as input\n2. Conjugate relationship: ihfft is related to rfft by conjugation\n3. Linearity: ihfft preserves linear combinations\n4. Hermitian symmetry handling: if input has Hermitian symmetry, special properties hold", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* Complex number type for FFT operations */\n#[derive(PartialEq, Eq)]\nstruct Complex {\n    /* Real part */\n    re: int,\n    /* Imaginary part */\n    im: int,\n}\n\nimpl Complex {\n    /* Complex conjugate */\n    spec fn conj(self) -> Complex {\n        Complex { re: self.re, im: -self.im }\n    }\n\n    /* Complex addition */\n    spec fn add(self, other: Complex) -> Complex {\n        Complex { re: self.re + other.re, im: self.im + other.im }\n    }\n\n    /* Complex multiplication */\n    spec fn mul(self, other: Complex) -> Complex {\n        Complex { \n            re: self.re * other.re - self.im * other.im, \n            im: self.re * other.im + self.im * other.re \n        }\n    }\n\n    /* Check if complex number is real (imaginary part is zero) */\n    spec fn is_real(self) -> bool {\n        self.im == 0\n    }\n}\n\n/* Convert int to Complex */\nspec fn int_to_complex(x: int) -> Complex {\n    Complex { re: x, im: 0 }\n}\n\n/* Complex scaling */\nspec fn scale_complex(z: Complex, alpha: int) -> Complex {\n    Complex { re: alpha * z.re, im: alpha * z.im }\n}", "vc-helpers": "", "vc-spec": "fn ihfft(a: Vec<Complex>) -> (result: Vec<Complex>)\n    ensures\n        /* Length preservation: output has same length as input */\n        result.len() == a.len(),\n        /* Hermitian symmetry property: if input has Hermitian symmetry,\n           then ihfft should produce a real-valued result */\n        (forall|i: int, j: int| \n            (0 <= i < a@.len() && 0 <= j < a@.len() && i + j + 1 == a@.len()) ==> \n                a@[i] == a@[j].conj()) ==>\n        (forall|i: int| (0 <= i < result@.len()) ==> result@[i].is_real())", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0158", "language": "verus", "source": "numpy_triple", "source_id": "fft_irfft", "vc-description": "Computes the inverse of rfft (real-valued inverse FFT).\nSpecification: irfft computes the inverse of rfft with proper length restoration.\n\nnumpy.fft.irfft computes the inverse of the one-dimensional discrete Fourier Transform for real input, \nsuch that irfft(rfft(a), len(a)) == a within numerical accuracy.\n\nParameters:\n- a: Input array (Hermitian-symmetric complex numbers)\n- n: Length of transformed axis (default calculates based on input)\n- axis: Axis to compute inverse FFT (default is last axis)\n- norm: Normalization mode (\"backward\", \"ortho\", \"forward\")\n- out: Optional output array\n\nReturns:\n- Real-valued array transformed along specified axis\n\nNotes:\n- Handles Hermitian-symmetric input from rfft\n- Requires specifying original data length to avoid information loss\n- Can resample a series via Fourier interpolation", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* Complex number type for FFT operations */\npub struct Complex {\n    /* Real part of the complex number */\n    pub re: f64,\n    /* Imaginary part of the complex number */\n    pub im: f64,\n}\n/* Helper function to check if a vector is Hermitian-symmetric */\nspec fn is_hermitian_symmetric(a: Seq<Complex>) -> bool {\n    a.len() > 0 \n}", "vc-helpers": "", "vc-spec": "fn irfft(a: Vec<Complex>, n: usize) -> (result: Vec<f64>)\n    requires \n        a.len() > 0,\n        n == 2 * (a.len() - 1),\n        is_hermitian_symmetric(a@),\n    ensures\n        /* Length preservation: output length matches specified n */\n        result.len() == n,\n        /* DC component preservation: first element is real when input DC is real */\n        a@[0].im == 0.0 ==> exists|i: int| 0 <= i < result.len() && result[i] == a@[0].re,\n        /* Hermitian input constraint: the input must be Hermitian-symmetric */\n        is_hermitian_symmetric(a@),\n        /* Length relationship: output length is twice the input length minus 2 */\n        n == 2 * (a.len() - 1),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0159", "language": "verus", "source": "numpy_triple", "source_id": "fft_irfft2", "vc-description": "numpy.fft.irfft2: Computes the inverse of rfft2.\n\nPerforms the inverse 2-dimensional discrete Fourier Transform for real input.\nThis function converts a complex frequency domain representation back to the\nreal spatial domain. It is the inverse of rfft2.\n\nThe function takes a complex-valued 2D array (represented as nested vectors)\nand returns a real-valued 2D array. The output shape is determined by the\ninput shape and the original real signal dimensions.\n\nThis is essentially irfftn with axes=(-2, -1) as defaults.\n\nSpecification: numpy.fft.irfft2 returns the inverse 2D real FFT.\n\nPrecondition: True (input is a well-formed 2D array)\nPostcondition: The result is a real-valued 2D array with the same dimensions.\n\nKey properties:\n1. The output preserves the matrix structure and dimensions\n2. The transformation processes all elements of the input\n3. The inverse operation produces finite real values\n4. Shape preservation ensures correct 2D FFT behavior", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_irfft2(a: Vec<Vec<f32>>) -> (result: Vec<Vec<f32>>)\n    requires\n        a@.len() > 0,\n        forall|i: int| 0 <= i < a@.len() ==> a@[i].len() > 0,\n        forall|i: int, j: int| 0 <= i < a@.len() && 0 <= j < a@.len() ==> a@[i].len() == a@[j].len(),\n    ensures\n        /* Preserve matrix dimensions */\n        result@.len() == a@.len(),\n        forall|i: int| 0 <= i < result@.len() ==> result@[i].len() == a@[0].len(),\n        /* Non-trivial transformation: if input is non-zero, result depends on input */\n        (exists|i: int, j: int| 0 <= i < a@.len() && 0 <= j < a@[i].len() && a@[i][j] != 0.0f32) ==>\n        (exists|k: int, l: int| 0 <= k < result@.len() && 0 <= l < result@[k].len() && result@[k][l] != 0.0f32),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0160", "language": "verus", "source": "numpy_triple", "source_id": "fft_irfftn", "vc-description": "Computes the inverse of rfftn. This function performs the inverse N-dimensional discrete Fourier Transform for real input using the Fast Fourier Transform (FFT).\n\nFor simplicity, we model this as a 1D version of irfftn, taking complex frequency domain input and producing real time-domain output. The function computes the inverse of rfftn, transforming N-dimensional frequency domain data back to real-valued time domain.\n\nThis is the inverse operation to rfftn, where the input is expected to be Hermitian-symmetric complex data representing the frequency domain, and the output is real-valued time domain data.\n\nSpecification: irfftn computes the inverse N-dimensional discrete Fourier Transform for real output.\n\nThe irfftn function is the inverse of rfftn, satisfying the property that irfftn(rfftn(x), x.shape) ≈ x within numerical accuracy.\n\nMathematical properties:\n1. Inverse relationship: irfftn(rfftn(x)) ≈ x for real input x\n2. The input should be Hermitian-symmetric to produce real output\n3. Output length is determined by the shape parameter or derived from input\n4. Energy conservation (Parseval's theorem) holds with proper normalization\n5. The transform preserves the mathematical structure of the inverse DFT\n\nThe function implements the inverse N-dimensional DFT formula:\nx[j] = (1/N) * Σ(k) a[k] * exp(2πi*k*j/N)\n\nSanity checks:\n- For DC-only input (single non-zero frequency), output is constant\n- Transform is linear: irfftn(α*a + β*b) = α*irfftn(a) + β*irfftn(b)\n- Output is real-valued when input satisfies Hermitian symmetry\n- Proper length relationship between input and output dimensions", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* Complex number type for FFT operations */\npub struct Complex {\n    /* Real part */\n    pub re: f32,\n    /* Imaginary part */\n    pub im: f32,\n}\n\nimpl Complex {\n    pub closed spec fn new(re: f32, im: f32) -> Complex {\n        Complex { re, im }\n    }\n}", "vc-helpers": "", "vc-spec": "fn irfftn(a: Vec<Complex>, n: u8) -> (result: Vec<f32>)\n    requires \n        a.len() > 0,\n        n > 0,\n        a[0].im == 0.0f32,\n    ensures\n        result.len() == n as nat,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0161", "language": "verus", "source": "numpy_triple", "source_id": "fft_rfft", "vc-description": "Compute the one-dimensional discrete Fourier Transform for real input.\nReturns only the non-negative frequency terms, exploiting Hermitian symmetry.\nThe output length is (n/2)+1 for even n, or (n+1)/2 for odd n.\n\nSpecification for rfft: \nThe real FFT computes the DFT of real-valued input, returning only non-negative frequency components.\n\nMathematical properties:\n1. Output contains (n/2)+1 complex values representing frequencies 0 to n/2\n2. DC component (k=0) is always real (imaginary part is 0)\n3. For even n, Nyquist frequency (k=n/2) is also real\n4. The result represents the Discrete Fourier Transform for k = 0, 1, ..., n/2\n5. Each output[k] = Σ(j=0 to n-1) input[j] * exp(-2πi*k*j/n)\n\nSanity checks:\n- For constant input signals, only the DC component is non-zero\n- The transform is linear: rfft(a + b) = rfft(a) + rfft(b)\n- Energy is preserved according to Parseval's theorem", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* Complex number type for FFT results */\n#[derive(PartialEq, Eq)]\npub struct Complex {\n    pub re: int,\n    pub im: int,\n}\n\nimpl Complex {\n    pub open spec fn zero() -> Complex {\n        Complex { re: 0, im: 0 }\n    }\n\n    pub open spec fn add(self, other: Complex) -> Complex {\n        Complex { re: self.re + other.re, im: self.im + other.im }\n    }\n\n    pub open spec fn mul(self, other: Complex) -> Complex {\n        Complex { \n            re: self.re * other.re - self.im * other.im,\n            im: self.re * other.im + self.im * other.re\n        }\n    }\n\n    pub open spec fn from_real(x: int) -> Complex {\n        Complex { re: x, im: 0 }\n    }\n}\n\npub open spec fn complex_sum(values: Seq<Complex>) -> Complex \n    decreases values.len()\n{\n    if values.len() == 0 {\n        Complex::zero()\n    } else {\n        values[0].add(complex_sum(values.skip(1)))\n    }\n}\n\npub open spec fn dft_coefficient(a: Seq<int>, k: nat, j: nat) -> Complex {\n    Complex::from_real(a[j as int])\n}\n\npub open spec fn compute_dft_sum(a: Seq<int>, k: nat, n: nat) -> Complex \n    decreases n\n{\n    if n == 0 {\n        Complex::zero()\n    } else {\n        dft_coefficient(a, k, (n - 1) as nat).add(compute_dft_sum(a, k, (n - 1) as nat))\n    }\n}\n\nspec fn vec_to_int_seq(v: Seq<i32>) -> Seq<int> \n    decreases v.len()\n{\n    if v.len() == 0 {\n        seq![]\n    } else {\n        seq![v[0] as int] + vec_to_int_seq(v.skip(1))\n    }\n}", "vc-helpers": "", "vc-spec": "fn rfft(a: Vec<i32>) -> (result: Vec<Complex>)\n    requires a.len() > 0,\n    ensures \n        result.len() == (a.len() / 2) + 1,\n        forall|k: int| 0 <= k < result.len() ==> \n            result[k] == compute_dft_sum(vec_to_int_seq(a@), k as nat, a.len() as nat),\n        result[0].im == 0,\n        a.len() % 2 == 0 ==> result[(a.len() / 2) as int].im == 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0162", "language": "verus", "source": "numpy_triple", "source_id": "fft_rfft2", "vc-description": "Compute the 2-dimensional FFT of a real array.\n\nThis function transforms a real 2D array into the frequency domain using\na 2D Fast Fourier Transform. The transformation is performed over the\nlast two axes by default.\n\nThe key difference from fft2 is that this function starts with real input\nand exploits the Hermitian symmetry property to compute only the \nnon-negative frequency components along the last axis, making it more\nefficient for real-valued input data.\n\nOutput dimensions: For input of shape (m+1, n+1), output has shape (m+1, (n+1)/2+1)\nwhere the last dimension is reduced due to Hermitian symmetry.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* Complex number type for FFT results */\n#[derive(PartialEq, Eq)]\npub struct Complex {\n    /* Real part */\n    pub re: int,\n    /* Imaginary part */\n    pub im: int,\n}\n\nimpl Complex {\n    pub open spec fn zero() -> Complex {\n        Complex { re: 0, im: 0 }\n    }\n    \n    pub open spec fn add(self, other: Complex) -> Complex {\n        Complex { re: self.re + other.re, im: self.im + other.im }\n    }\n    \n    pub open spec fn mul(self, other: Complex) -> Complex {\n        Complex { \n            re: self.re * other.re - self.im * other.im, \n            im: self.re * other.im + self.im * other.re \n        }\n    }\n}\n\n/* Convert int to Complex */\nspec fn int_to_complex(x: int) -> Complex {\n    Complex { re: x, im: 0 }\n}", "vc-helpers": "", "vc-spec": "fn rfft2(a: Vec<Vec<i8>>) -> (result: Vec<Vec<Complex>>)\n    requires \n        a.len() > 0,\n        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i]@.len() > 0,\n        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i]@.len() == a[0]@.len(),\n    ensures\n        result.len() == a.len(),\n        forall|k: int| 0 <= k < result.len() ==> \n            #[trigger] result[k]@.len() == (a[0]@.len() / 2) + 1,\n        /* DC component is real (imaginary part is zero) */\n        result[0]@[0].im == 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0163", "language": "verus", "source": "numpy_triple", "source_id": "fft_rfftfreq", "vc-description": "numpy.fft.rfftfreq: Return the Discrete Fourier Transform sample frequencies for rfft.\n\nThe function generates frequency bin centers in cycles per unit of sample spacing,\nwith zero at the start. This is specifically designed for use with rfft and irfft.\n\nParameters:\n- n: Window length (input size)\n- d: Sample spacing (defaults to 1.0)\n\nReturns:\n- f: Array of length n//2 + 1 containing sample frequencies\n\nThe frequency calculation follows:\n- For any n: f = [0, 1, ..., n//2] / (d*n)\n- The result length is always n//2 + 1 (for both even and odd n)\n\nSpecification: numpy.fft.rfftfreq generates frequency sample points for rfft.\n\nThe function returns a vector of frequencies from 0 to the Nyquist frequency.\n\nPrecondition: n > 0 and d > 0 (positive sample spacing)\nPostcondition: \n1. The result has length n//2 + 1\n2. The first element is always 0\n3. Each element i represents frequency i / (d * n)\n4. The last element is (n//2) / (d * n) (Nyquist frequency)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_rfftfreq(n: usize, d: i8) -> (result: Vec<i8>)\n    requires \n        n > 0,\n        d > 0,\n    ensures\n        result.len() == n / 2 + 1,\n        result@[0] == 0,\n        forall|i: int| 0 <= i < result.len() ==> result@[i] == i / ((d as int) * (n as int)),\n        result@[(n / 2) as int] == (n / 2) as int / ((d as int) * (n as int)),\n        forall|i: int, j: int| 0 <= i <= j < result.len() ==> result@[i] <= result@[j],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "VT0165", "language": "verus", "source": "numpy_triple", "source_id": "indexing_slicing_argmax", "vc-description": "Returns the index of the maximum value in a non-empty vector (first occurrence)\n\nSpecification: argmax returns the index of the first maximum element\nThis comprehensive specification captures:\n1. The returned index points to a maximum element\n2. All elements to the left of the returned index are strictly less than the maximum\n3. All elements to the right of the returned index are less than or equal to the maximum\n4. The function returns the first occurrence of the maximum value\n5. The returned index is valid (type-safe with Fin)\n6. The result is deterministic for the same input", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn argmax(arr: &Vec<i8>) -> (result: usize)\n    requires arr.len() > 0,\n    ensures \n        result < arr.len(),\n        forall|i: int| 0 <= i && i < arr.len() ==> arr@[i] <= arr@[result as int],\n        forall|i: int| 0 <= i && i < result as int ==> arr@[i] < arr@[result as int],\n        forall|i: int| (result as int) < i && i < arr.len() ==> arr@[i] <= arr@[result as int],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0166", "language": "verus", "source": "numpy_triple", "source_id": "indexing_slicing_argmin", "vc-description": "numpy.argmin: Returns the index of the minimum value in a vector.\n\nReturns the index of the minimum value among all elements in the array.\nRequires a non-empty array since there is no minimum of an empty set.\n\nThis function returns the position of the smallest element in the array.\nIn case of multiple occurrences of the minimum value, the index of the\nfirst occurrence is returned.\n\nSpecification: argmin returns the index of the minimum element.\n\nPrecondition: True (non-empty constraint is in the type)\nPostcondition: The element at the returned index is the minimum value,\nand it is the first occurrence of this minimum value in the array.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn argmin(a: Vec<i8>) -> (result: usize)\n    requires a.len() > 0,\n    ensures\n        result < a.len(),\n        forall|j: int| 0 <= j < a.len() ==> a[result as int] <= a[j],\n        forall|k: int| 0 <= k < result ==> a[k] > a[result as int],", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0167", "language": "verus", "source": "numpy_triple", "source_id": "indexing_slicing_argwhere", "vc-description": "Find the indices of array elements that are non-zero, grouped by element.\n\nFor a 1D vector, returns a list of indices where elements are non-zero.\nEach index corresponds to a position in the original vector where the element is non-zero.\nThe returned indices are in the same order as they appear in the original vector.\n\nThis function is equivalent to finding all positions i such that a[i] ≠ 0.\nThe result is a list of indices, not suitable for direct array indexing but useful\nfor analysis and conditional processing.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn argwhere(a: &Vec<f64>) -> (indices: Vec<usize>)\n    ensures\n        forall|i: int| 0 <= i < indices@.len() ==> (#[trigger] indices@[i] as int) < a@.len(),\n        forall|i: int| 0 <= i < indices@.len() ==> a@[indices@[i] as int] != 0.0,\n        forall|i: int| 0 <= i < a@.len() && a@[i] != 0.0 ==> exists|j: int| 0 <= j < indices@.len() && indices@[j] as int == i,\n        forall|i: int, j: int| 0 <= i < indices@.len() && 0 <= j < indices@.len() && i != j ==> indices@[i] != indices@[j],\n        forall|i: int, j: int| 0 <= i < indices@.len() && 0 <= j < indices@.len() && (indices@[i] as int) < (indices@[j] as int) ==> i < j,\n        (indices@.len() == 0) == (forall|i: int| 0 <= i < a@.len() ==> a@[i] == 0.0),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0168", "language": "verus", "source": "numpy_triple", "source_id": "indexing_slicing_c_", "vc-description": "numpy.c_: Translates slice objects to concatenation along the second axis.\n\nThis function takes two vectors and stacks them as columns to create a 2-D array.\nEach input vector becomes a column in the resulting matrix.\n\nThis is equivalent to column_stack([arr1, arr2]) for 1-D arrays.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn c_(arr1: Vec<i8>, arr2: Vec<i8>) -> (result: Vec<Vec<i8>>)\n    requires arr1.len() == arr2.len(),\n    ensures \n        result.len() == arr1.len(),\n        forall|i: int| 0 <= i < result.len() ==> \n            result[i]@.len() == 2 &&\n            result[i][0] == arr1[i] &&\n            result[i][1] == arr2[i]", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0169", "language": "verus", "source": "numpy_triple", "source_id": "indexing_slicing_choose", "vc-description": "Construct an array from an index array and a set of arrays to choose from.\nGiven an index vector 'indices' and a vector of choice vectors 'choices',\nconstructs a result vector where each element is selected from the corresponding\nchoice vector based on the index value at that position.\n\nFor each position i in the result, result[i] = choices[indices[i]][i]\n\nThis is a simplified version focusing on the core functionality with 'raise' mode,\nwhere all indices must be valid (in range [0, num_choices-1]).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn choose(indices: Vec<u8>, choices: Vec<Vec<f64>>) -> (result: Vec<f64>)\n    requires \n        indices.len() > 0,\n        choices.len() > 0,\n        forall|i: int| 0 <= i < indices@.len() ==> (indices[i] as int) < (choices@.len() as int),\n        forall|j: int| 0 <= j < choices@.len() ==> choices[j]@.len() == indices@.len(),\n    ensures \n        result@.len() == indices@.len(),\n        forall|i: int| 0 <= i < indices@.len() ==> result[i] == choices[indices[i] as int][i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0170", "language": "verus", "source": "numpy_triple", "source_id": "indexing_slicing_compress", "vc-description": "Compresses a vector by selecting only elements where the corresponding \ncondition is true. Returns a new vector containing only the selected elements.\nThe result size is the number of true values in the condition vector.\n\nSpecification: compress returns a new vector containing only the elements \nfrom the input vector where the corresponding condition element is true.\n\nMathematical properties:\n1. The result size equals the number of true values in the condition\n2. The result preserves the order of elements from the original vector\n3. Each element in the result corresponds to a true condition at the same index\n4. The result is empty if and only if all condition elements are false\n\nThis function implements array compression/masking, a fundamental operation\nin array programming that allows selective extraction of elements based on\na boolean mask. It's equivalent to boolean indexing in NumPy.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn count_true(condition: Seq<bool>) -> int\n    decreases condition.len()\n{\n    if condition.len() == 0 {\n        0\n    } else {\n        (if condition[0] { 1int } else { 0int }) + count_true(condition.skip(1))\n    }\n}\n\nfn compress(condition: Vec<bool>, a: Vec<f32>) -> (result: Vec<f32>)\n    requires condition.len() == a.len(),\n    ensures\n        result.len() == count_true(condition@),\n        exists|mapping: Seq<int>|\n            mapping.len() == result.len() &&\n            (forall|i: int| 0 <= i < mapping.len() ==> \n                0 <= mapping[i] < condition.len() &&\n                condition@[mapping[i]] == true) &&\n            (forall|i: int| 0 <= i < result.len() ==> \n                result@[i] == a@[mapping[i]]) &&\n            (forall|i: int, j: int| 0 <= i < j < mapping.len() ==> \n                mapping[i] < mapping[j]),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0171", "language": "verus", "source": "numpy_triple", "source_id": "indexing_slicing_diag", "vc-description": "Extract a diagonal or construct a diagonal array.\n\nnumpy.diag: Extract a diagonal or construct a diagonal array.\n\nFor simplicity, this specification focuses on extracting the diagonal\nfrom a square matrix represented as a flattened vector.\nGiven a flattened n×n matrix, returns the diagonal elements.\n\nThis specification captures the essential mathematical property of\ndiagonal extraction in a type-safe manner using Vector types.\n\nSpecification: diag extracts diagonal elements from a flattened matrix.\n\nMathematical Properties:\n1. Diagonal Extraction: For a flattened n×n matrix stored in row-major order,\n   the diagonal elements are located at positions i*n + i for i ∈ [0, n).\n\n2. Type Safety: The function maintains type safety by using Vector types\n   that encode the size information at the type level.\n\n3. Correctness: Each element in the result vector corresponds to a diagonal\n   element from the original matrix, preserving the mathematical structure.\n\nThis specification provides a foundation for formal verification of diagonal\noperations in numerical computing.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn diag(matrix: Vec<f32>, n: usize) -> (result: Vec<f32>)\n    requires \n        matrix.len() == n * n,\n        n > 0,\n    ensures\n        result.len() == n,\n        forall|i: int| 0 <= i < n as int ==> result@[i] == matrix@[i * n as int + i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0172", "language": "verus", "source": "numpy_triple", "source_id": "indexing_slicing_diagflat", "vc-description": "numpy.diagflat: Create a two-dimensional array with the flattened input as a diagonal.\n\nCreates a square matrix where the input vector is placed along the main diagonal.\nAll other elements are zero. The resulting matrix has size n×n where n is the\nlength of the input vector.\n\nFor the main diagonal (k=0), the matrix element at position (i,i) contains\nthe i-th element of the input vector.\n\nSpecification: diagflat returns a square matrix where the input vector forms the main diagonal.\n\nProperties:\n1. The result is a square n×n matrix\n2. For all i, j: if i = j then result[i][j] = v[i] (diagonal elements)\n3. For all i, j: if i ≠ j then result[i][j] = 0 (off-diagonal elements are zero)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn diagflat(v: Vec<f32>) -> (result: Vec<Vec<f32>>)\n    requires v@.len() > 0,\n    ensures\n        result@.len() == v@.len(),\n        forall|i: int| 0 <= i < result@.len() ==> result@[i].len() == v@.len(),\n        forall|i: int, j: int| 0 <= i < v@.len() && 0 <= j < v@.len() && i == j ==> result@[i][j] == v@[i],\n        forall|i: int, j: int| 0 <= i < v@.len() && 0 <= j < v@.len() && i != j ==> result@[i][j] == 0.0f32,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0173", "language": "verus", "source": "numpy_triple", "source_id": "indexing_slicing_diagonal", "vc-description": "Extract diagonal elements from a 2D matrix with optional offset.\n\nTakes a 2D matrix and returns a 1D vector containing the diagonal elements.\nFor offset=0, returns main diagonal elements [a[0,0], a[1,1], ...].\nFor offset>0, returns elements above main diagonal [a[0,offset], a[1,offset+1], ...].\nFor offset<0, returns elements below main diagonal [a[-offset,0], a[-offset+1,1], ...].", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn diagonal(a: Vec<Vec<f64>>, offset: i32) -> (result: Vec<f64>)\n    requires \n        a@.len() > 0,\n        a@.len() > 0 ==> a@[0].len() > 0,\n        forall|i: int| 0 <= i < a@.len() ==> #[trigger] a@[i].len() == a@[0].len(),\n        if offset >= 0 { \n            offset as int <= a@[0].len() as int\n        } else { \n            (-offset) as int <= a@.len() as int\n        },\n    ensures\n        result@.len() == (if offset >= 0 { \n            if a@.len() as int <= (a@[0].len() as int - offset as int) { a@.len() as int } else { a@[0].len() as int - offset as int }\n        } else { \n            if (a@.len() as int + (-offset) as int) <= a@[0].len() as int { a@.len() as int + (-offset) as int } else { a@[0].len() as int }\n        }) as usize,\n        forall|i: int| 0 <= i < result@.len() ==> {\n            if offset >= 0 {\n                #[trigger] result@[i] == a@[i][i + offset as int]\n            } else {\n                #[trigger] result@[i] == a@[i + (-offset) as int][i]\n            }\n        },", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0174", "language": "verus", "source": "numpy_triple", "source_id": "indexing_slicing_extract", "vc-description": "numpy.extract: Return the elements of an array that satisfy some condition.\n\nExtracts elements from an array where the corresponding condition is True.\nBoth arrays must have the same size, and the result contains only the elements\nfrom `arr` where `condition` is True, in the same order they appear in `arr`.\n\nThe result size `k` must equal the number of True elements in the condition array.\n\nSpecification: numpy.extract returns elements where condition is True.\n\nPrecondition: k equals the count of True elements in condition\nPostcondition: The result contains exactly the elements from arr where condition is True,\n              in the same order they appear in arr.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn count_true(condition: Seq<bool>) -> int \n    decreases condition.len()\n{\n    if condition.len() == 0 {\n        0int\n    } else {\n        (if condition[0] { 1int } else { 0int }) + count_true(condition.skip(1))\n    }\n}\n\nfn extract(condition: Vec<bool>, arr: Vec<f32>) -> (result: Vec<f32>)\n    requires \n        condition.len() == arr.len(),\n        count_true(condition@) >= 0,\n    ensures\n        result.len() == count_true(condition@),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0175", "language": "verus", "source": "numpy_triple", "source_id": "indexing_slicing_fill_diagonal", "vc-description": "Fill the main diagonal of a 2D matrix with a specified value\n\n/* Diagonal elements are filled with val */\n\n/* Non-diagonal elements remain unchanged */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn fill_diagonal<T: Copy>(mat: Vec<Vec<T>>, val: T) -> (result: Vec<Vec<T>>)\n    requires \n        mat@.len() > 0,\n        forall|i: int| 0 <= i < mat@.len() ==> #[trigger] mat@[i].len() == mat@[0].len(),\n    ensures\n        result@.len() == mat@.len(),\n        forall|i: int| 0 <= i < result@.len() ==> #[trigger] result@[i].len() == mat@[i].len(),\n\n        forall|i: int, j: int| \n            0 <= i < result@.len() && 0 <= j < result@[i].len() && i == j \n            ==> #[trigger] result@[i][j] == val,\n\n        forall|i: int, j: int| \n            0 <= i < result@.len() && 0 <= j < result@[i].len() && i != j \n            ==> #[trigger] result@[i][j] == mat@[i][j]", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0176", "language": "verus", "source": "numpy_triple", "source_id": "indexing_slicing_flatiter", "vc-description": "numpy.flatiter: Flat iterator object to iterate over arrays.\n\nA flatiter iterator provides a flattened view of an array for iteration purposes.\nIt allows accessing elements of a multi-dimensional array as if it were 1-dimensional,\nfollowing row-major (C-style) order where the last index varies fastest.\n\nThe iterator supports indexing and provides sequential access to all elements\nin the array following the memory layout order.\n\nSpecification: numpy.flatiter creates a flat iterator over the array.\n\nPrecondition: True (no special preconditions for creating a flat iterator)\nPostcondition: The result preserves all elements in row-major order,\n               providing sequential access to the flattened array elements", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_flatiter(a: Vec<i8>) -> (result: Vec<i8>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == a[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0177", "language": "verus", "source": "numpy_triple", "source_id": "indexing_slicing_indices", "vc-description": "Generate indices for a 1D grid of given size.\nReturns a 2D array where the first dimension has size 1 and contains \nthe indices [0, 1, 2, ..., n-1]\n\nSpecification: indices generates a grid of index values\nThis comprehensive specification captures:\n1. The output has the correct shape: (1, n) for 1D case\n2. The single row contains exactly the indices [0, 1, 2, ..., n-1]\n3. Each position i contains the value i\n4. The indices are in ascending order\n5. The result covers all valid indices for the given dimension", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn indices(n: u8) -> (grid: Vec<Vec<u8>>)\n    ensures \n        grid.len() == 1,\n        grid@[0].len() == n as nat,\n        forall|i: int| 0 <= i < n as int ==> grid@[0][i] == i as u8,\n        forall|i: int, j: int| 0 <= i < j < n as int ==> grid@[0][i] < grid@[0][j],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0178", "language": "verus", "source": "numpy_triple", "source_id": "indexing_slicing_ix_", "vc-description": "Construct an open mesh from multiple sequences\n\nConstruct an open mesh from two 1-D sequences. \nThis simplified version handles the case of two input sequences,\nreturning two 2D arrays that form an open mesh for indexing operations.\nThe first array has shape (m, 1) containing values from the first sequence,\nand the second array has shape (1, n) containing values from the second sequence.\n\nSpecification: ix_ creates an open mesh from two sequences\nThis comprehensive specification captures:\n1. The function takes two 1-D sequences of integers\n2. Returns a pair of 2D arrays (represented as vectors of vectors)\n3. First array has shape (m, 1) - m rows, 1 column\n4. Second array has shape (1, n) - 1 row, n columns\n5. First array contains values from seq1 repeated in column format\n6. Second array contains values from seq2 repeated in row format\n7. Together they form an open mesh for advanced indexing operations\n8. Each element of the first array's i-th row equals seq1[i]\n9. Each element of the second array's single row equals the corresponding seq2 element\n10. The mesh property: for any indices (i,j), the pair (first[i][0], second[0][j]) \n    represents a coordinate in the mesh grid\n\n/* First array has correct shape and values */\n\n/* Second array has correct shape and values */\n\n/* Mesh property: coordinates are preserved */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn ix_(seq1: Vec<i8>, seq2: Vec<i8>) -> (result: (Vec<Vec<i8>>, Vec<Vec<i8>>))\n    requires \n        seq1.len() > 0,\n        seq2.len() > 0,\n    ensures \n\n        result.0.len() == seq1.len(),\n        forall|i: int| 0 <= i < seq1@.len() ==> result.0@[i].len() == 1,\n        forall|i: int| 0 <= i < seq1@.len() ==> result.0@[i][0] == seq1@[i],\n\n        result.1.len() == 1,\n        result.1@[0].len() == seq2.len(),\n        forall|j: int| 0 <= j < seq2@.len() ==> result.1@[0][j] == seq2@[j],\n\n        forall|i: int, j: int| 0 <= i < seq1@.len() && 0 <= j < seq2@.len() ==> \n            result.0@[i][0] == seq1@[i] && result.1@[0][j] == seq2@[j],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0179", "language": "verus", "source": "numpy_triple", "source_id": "indexing_slicing_mgrid", "vc-description": "numpy.mgrid: Dense multi-dimensional \"meshgrid\" creation for 2D case.\n\nCreates a dense mesh-grid from two 1D coordinate arrays, returning a pair of 2D arrays\nwhere each output array has the same shape (rows × cols). The first array contains\nrow coordinates repeated across columns, and the second array contains column\ncoordinates repeated across rows.\n\nThis is the 2D case of numpy.mgrid[start_r:stop_r, start_c:stop_c] which creates\ncoordinate arrays suitable for evaluating functions over a 2D grid.\n\nFor 2D case with rows and cols dimensions, this returns a tuple of two matrices:\n- First matrix: row coordinates repeated across columns\n- Second matrix: column coordinates repeated across rows", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "type Matrix = Vec<Vec<f32>>;\n\nfn mgrid(rows: u8, cols: u8, start_r: f32, stop_r: f32, start_c: f32, stop_c: f32) -> (result: (Matrix, Matrix))\n    requires rows > 0 && cols > 0,\n    ensures \n        result.0.len() == rows as nat && result.1.len() == rows as nat,\n        forall|i: int| 0 <= i < rows as int ==> result.0[i].len() == cols as nat && result.1[i].len() == cols as nat,\n        forall|i: int, j: int, k: int| 0 <= i < rows as int && 0 <= j < cols as int && 0 <= k < cols as int ==> \n            result.0[i][j] == result.0[i][k],\n        forall|j: int, i: int, k: int| 0 <= j < cols as int && 0 <= i < rows as int && 0 <= k < rows as int ==> \n            result.1[i][j] == result.1[k][j],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0180", "language": "verus", "source": "numpy_triple", "source_id": "indexing_slicing_nanargmax", "vc-description": "Returns the index of the maximum value in a non-empty vector, ignoring NaN values.\n\nThis function finds the index of the maximum value among all non-NaN elements in the vector.\nRequires that at least one element is not NaN, otherwise it would raise an error.\n\nIn case of multiple occurrences of the maximum values, the indices\ncorresponding to the first occurrence are returned.\n\nSpecification: nanargmax returns the index of the first maximum element among non-NaN values.\n\nThis comprehensive specification captures:\n1. The returned index points to an element that is not NaN\n2. The element at the returned index is the maximum among all non-NaN elements\n3. The function returns the first occurrence of the maximum value (among non-NaN elements)\n4. The returned index is valid (type-safe with Fin)\n5. The precondition ensures at least one element is not NaN\n6. All non-NaN elements are less than or equal to the maximum\n7. Among elements with the same maximum value, the first index is returned\n\n/* Maximum property: all finite values are <= max value */\n\n/* First occurrence property: returns earliest index among ties */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_finite(x: f32) -> bool;\n\nfn nanargmax(a: Vec<f32>) -> (result: usize)\n    requires\n        a.len() > 0,\n        exists|i: int| 0 <= i < a@.len() && is_finite(a[i]),\n    ensures\n        result < a.len(),\n        is_finite(a[result as int]),\n\n        forall|j: int| 0 <= j < a@.len() && is_finite(a[j]) ==> true,\n\n        forall|j: int| 0 <= j < a@.len() && is_finite(a[j]) ==> (result as int) <= j || true,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0181", "language": "verus", "source": "numpy_triple", "source_id": "indexing_slicing_nanargmin", "vc-description": "Returns the index of the minimum value in a non-empty vector, ignoring NaN values.\n\nThis function finds the index of the minimum value among all non-NaN elements in the vector.\nRequires that at least one element is not NaN, otherwise it would raise an error.\n\nIn case of multiple occurrences of the minimum values, the indices\ncorresponding to the first occurrence are returned.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn f32_is_nan(x: f32) -> bool;\nspec fn f32_le(a: f32, b: f32) -> bool;", "vc-helpers": "", "vc-spec": "fn nanargmin(a: Vec<f32>) -> (result: usize)\n    requires \n        a.len() > 0,\n        exists|i: int| 0 <= i < a.len() && !f32_is_nan(a[i]),\n    ensures\n        result < a.len(),\n        !f32_is_nan(a[result as int]),\n        forall|j: int| 0 <= j < a.len() && !f32_is_nan(a[j]) ==> f32_le(a[result as int], a[j]),\n        forall|j: int| 0 <= j < a.len() && !f32_is_nan(a[j]) && f32_le(a[j], a[result as int]) && f32_le(a[result as int], a[j]) ==> result as int <= j,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0182", "language": "verus", "source": "numpy_triple", "source_id": "indexing_slicing_ndenumerate", "vc-description": "numpy.ndenumerate: Multidimensional index iterator that yields pairs of array coordinates and values.\n\nFor a 1D array, this creates a vector of tuples where each tuple contains\nthe index and the corresponding value from the input array.\n\nThe function essentially enumerates through the array, providing both\nthe position (index) and the value at that position.\n\nSpecification: ndenumerate returns a vector of index-value pairs.\n\nFor each position i in the input array, the result contains a tuple\n(i, arr[i]) where i is the index and arr[i] is the value at that index.\n\nPrecondition: True (no special preconditions needed)\nPostcondition: For all indices i, result[i] = (i, arr[i])", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn ndenumerate(arr: Vec<f32>) -> (result: Vec<(usize, f32)>)\n    ensures \n        result.len() == arr.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i as int].0 == i && result[i as int].1 == arr[i as int]", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0184", "language": "verus", "source": "numpy_triple", "source_id": "indexing_slicing_nditer", "vc-description": "numpy.nditer: Creates an iterator for a vector that provides position and element access.\n\nThis is a simplified 1D version of numpy's nditer functionality.\nReturns an iterator that starts at position 0 and holds the original data.\nThe iterator can be used to traverse the vector elements sequentially.\n\nIn numpy, nditer is a powerful multi-dimensional iterator, but for our\nVector-based specification, we simplify it to basic position tracking.\n\nSpecification: nditer creates a valid iterator that starts at position 0.\n\nThis comprehensive specification captures:\n1. The iterator starts at position 0\n2. The iterator contains the original data unchanged\n3. The iterator position is valid (within bounds)\n4. The iterator provides access to all elements of the original vector\n5. The iterator follows numpy's iteration semantics\n6. The iterator state is consistent and predictable", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn nditer(arr: Vec<i8>) -> (iter: (usize, Vec<i8>))\n    ensures\n        iter.0 == 0,\n        iter.1@ == arr@,\n        iter.0 <= arr.len(),\n        forall|i: int| 0 <= i < arr.len() ==> iter.1[i] == arr[i]", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0186", "language": "verus", "source": "numpy_triple", "source_id": "indexing_slicing_ogrid", "vc-description": "numpy.ogrid: Open multi-dimensional \"meshgrid\".\n\nReturns an open (i.e. not fleshed out) mesh-grid when indexed, \nso that only one dimension of each returned array is greater than 1.\n\nThis is a simplified 1D version that generates a linear sequence\nsimilar to arange but with the ogrid interface. The dimension and \nnumber of the output arrays are equal to the number of indexing dimensions.\n\nFor the 1D case, it returns a single vector with evenly spaced values\nfrom start to stop (exclusive) with the given step size.\n\nSpecification: ogrid returns a vector of evenly spaced values.\n\nPrecondition: step ≠ 0 and n = ⌊(stop - start) / step⌋\nPostcondition: The result is a vector where each element i satisfies:\n- result[i] = start + i * step\n- All elements are in the range [start, stop)\n- The sequence is arithmetic with common difference step", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn ogrid(start: i8, stop: i8, step: i8, n: usize) -> (result: Vec<i8>)\n    requires \n        step != 0,\n    ensures\n        result.len() == n,\n        forall|i: int| 0 <= i < n ==> result@[i] == start as int + i * (step as int),\n        forall|i: int| 0 <= i < n ==> \n            if step > 0 { \n                (start as int) <= result@[i] && result@[i] < (stop as int)\n            } else {\n                (stop as int) < result@[i] && result@[i] <= (start as int)\n            },", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0187", "language": "verus", "source": "numpy_triple", "source_id": "indexing_slicing_place", "vc-description": "numpy.place: Change elements of an array based on conditional and input values.\n\nModifies elements of an array where the corresponding mask is True, using values \nfrom the vals array. The function uses the first N elements of vals, where N is \nthe number of True values in mask. If vals is smaller than N, it will be repeated.\n\nThe parameter `k` must equal the number of True elements in the mask array.\nThe parameter `v` is the size of the vals array, which must be non-empty.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn count_true(mask: Seq<bool>) -> nat\n    decreases mask.len()\n{\n    if mask.len() == 0 {\n        0\n    } else {\n        (if mask[0] { 1nat } else { 0nat }) + count_true(mask.skip(1))\n    }\n}\n\nfn place(arr: Vec<f32>, mask: Vec<bool>, vals: Vec<f32>) -> (result: Vec<f32>)\n    requires \n        arr.len() == mask.len(),\n        vals.len() > 0,\n    ensures \n        result.len() == arr.len(),\n        forall|i: int| 0 <= i < arr.len() ==> !mask@[i] ==> result@[i] == arr@[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0188", "language": "verus", "source": "numpy_triple", "source_id": "indexing_slicing_put", "vc-description": "numpy.put: Replaces specified elements of an array with given values.\n\nThe indexing works on the flattened target array. This operation mutates the input array\nin-place by placing values from `v` at the positions specified by `ind`.\n\nFor simplicity, we ignore the `mode` parameter and assume all indices are valid.\n\nSpecification: numpy.put modifies specific elements of the input array.\n\nThis theorem captures the core mathematical properties:\n1. Elements at specified indices are replaced with corresponding values from `v`\n2. All other elements remain unchanged\n3. The result vector has the same length as the input vector\n4. Index bounds are respected (enforced by precondition)\n\nPrecondition: All indices in `ind` must be valid (less than array length)\nPostcondition: Elements at specified indices are replaced with corresponding values from `v`,\n              while all other elements remain unchanged.\n\nThis specification handles the case where indices may be duplicated - in such cases,\nthe later occurrence in the index vector takes precedence.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn put(a: Vec<f64>, ind: Vec<usize>, v: Vec<f64>) -> (result: Vec<f64>)\n    requires \n        ind.len() == v.len(),\n        forall|i: int| 0 <= i < ind@.len() ==> (ind[i] as int) < (a@.len() as int),\n    ensures\n        result@.len() == a@.len(),\n        forall|i: int| 0 <= i < ind@.len() ==> result@[ind[i] as int] == v@[i],\n        forall|j: int| 0 <= j < result@.len() ==> \n            (forall|i: int| 0 <= i < ind@.len() ==> j != ind[i] as int) ==> result@[j] == a@[j],\n        ind@.len() == 0 ==> result@ == a@,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0189", "language": "verus", "source": "numpy_triple", "source_id": "indexing_slicing_putmask", "vc-description": "Changes elements of an array based on conditional and input values.\n\nThis function modifies the target array in-place, setting elements to values\nfrom the values array where the corresponding mask element is True.\nIf values is smaller than the target array, it will repeat cyclically.\n\nParameters:\n- a: Target array to modify\n- mask: Boolean mask array with same shape as a\n- values: Values to put into a where mask is True\n- m: Size of values array (must be positive for repetition)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn putmask(a: Vec<f32>, mask: Vec<bool>, values: Vec<f32>) -> (result: Vec<f32>)\n    requires \n        a.len() == mask.len(),\n        values.len() > 0,\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a@.len() ==> (\n            mask@[i] ==> exists|j: int| 0 <= j < values@.len() && result@[i] == values@[j]\n        ),\n        forall|i: int| 0 <= i < a@.len() ==> (\n            mask@[i] ==> result@[i] == values@[(i as int) % (values@.len() as int)]\n        ),\n        forall|i: int| 0 <= i < a@.len() ==> (\n            !mask@[i] ==> result@[i] == a@[i]\n        ),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0190", "language": "verus", "source": "numpy_triple", "source_id": "indexing_slicing_r_", "vc-description": "numpy.r_: Translates slice objects to concatenation along the first axis.\n\nThis is a simple way to build up arrays quickly. There are two main use cases:\n1. If the index expression contains comma separated arrays, then stack them along their first axis\n2. If the index expression contains slice notation or scalars then create a 1-D array with a range\n\nThis implementation focuses on the first use case - concatenating two 1D arrays along the first axis.\nThe r_ object provides a convenient way to concatenate arrays by using index notation.\n\nFor example, numpy.r_[array1, array2] concatenates array1 and array2.\n\nSpecification: numpy.r_ concatenates arrays along the first axis.\n\nPrecondition: True (no special preconditions for basic concatenation)\nPostcondition: The result contains all elements from the first array followed by all elements from the second array.\nThis comprehensive specification captures:\n1. First n elements come from array a (preserving order and values)\n2. Next m elements come from array b (preserving order and values)\n3. Total length is n + m (enforced by type system)\n4. No elements are duplicated or lost (bijective mapping)\n5. The concatenation preserves all original values exactly\n6. Order is preserved within each original array", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn r_(a: Vec<i8>, b: Vec<i8>) -> (result: Vec<i8>)\n    ensures\n        result.len() == a.len() + b.len(),\n        forall|i: int| 0 <= i < a.len() ==> result[i] == a[i],\n        forall|j: int| 0 <= j < b.len() ==> result[a.len() + j] == b[j]", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0191", "language": "verus", "source": "numpy_triple", "source_id": "indexing_slicing_ravel_multi_index", "vc-description": "Converts a tuple of index arrays into an array of flat indices, applying boundary modes to the multi-index.\n\nConvert 2D multi-indices to flat indices using C-style (row-major) ordering.\n\nTakes arrays of row and column indices and converts them to flat indices\nfor an array with given dimensions. The conversion uses row-major ordering\nwhere flat_index = row_index * cols + col_index.\n\nThe function requires that all indices are within bounds of the specified dimensions.\n\nSpecification: ravel_multi_index converts 2D indices to flat indices using row-major ordering.\n\nPrecondition: All row and column indices must be within bounds\nPostcondition: Each flat index is computed as row_index * cols + col_index\n\nMathematical properties:\n1. The flat index correctly represents the 2D position in a flattened array\n2. All resulting indices are within bounds of the flattened array\n3. The conversion preserves the ordering relationship between multi-indices\n\nThis specification captures the essential behavior of NumPy's ravel_multi_index\nfor the 2D case with C-style ordering. The function maps 2D coordinates to\ntheir corresponding positions in a flattened representation of the array.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn ravel_multi_index(row_indices: &Vec<u8>, col_indices: &Vec<u8>, rows: u8, cols: u8) -> (result: Vec<u8>)\n    requires \n        row_indices.len() == col_indices.len(),\n        forall|i: int| 0 <= i < row_indices.len() ==> (row_indices[i] as nat) < (rows as nat),\n        forall|i: int| 0 <= i < col_indices.len() ==> (col_indices[i] as nat) < (cols as nat),\n    ensures \n        result.len() == row_indices.len(),\n        forall|i: int| 0 <= i < result.len() ==> \n            (result[i] as nat) == (row_indices[i] as nat) * (cols as nat) + (col_indices[i] as nat) && \n            (result[i] as nat) < (rows as nat) * (cols as nat),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0192", "language": "verus", "source": "numpy_triple", "source_id": "indexing_slicing_s_", "vc-description": "Index expression builder that creates slice objects for array indexing.\nThis is a simplified version of numpy.s_ that creates slice objects\nfor use in array indexing operations.\n\nSpecification: s_ creates a well-formed slice object\nThis comprehensive specification captures:\n1. The slice object contains the provided start, stop, and step values\n2. If step is provided, it must be positive (non-zero)\n3. If start and stop are both provided, start should be less than or equal to stop\n4. The resulting slice is valid for array indexing operations\n5. The slice preserves the ordering constraints (start ≤ stop when both present)\n6. The step value, if present, is positive for forward slicing\n\n/* A slice object representing a range of indices for array slicing.\n   Contains start, stop, and step parameters for creating slices. */\n\n/* The starting index of the slice (inclusive). If None, starts from the beginning. */\n\n/* The stopping index of the slice (exclusive). If None, goes to the end. */\n\n/* The step size for the slice. If None, defaults to 1. */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\npub struct Slice {\n\n    pub start: Option<usize>,\n\n    pub stop: Option<usize>,\n\n    pub step: Option<usize>,\n}", "vc-helpers": "", "vc-spec": "fn s_(start: Option<usize>, stop: Option<usize>, step: Option<usize>) -> (slice: Slice)\n    requires \n        step.is_some() ==> step.unwrap() > 0,\n        (start.is_some() && stop.is_some()) ==> start.unwrap() <= stop.unwrap(),\n    ensures \n        slice.start == start,\n        slice.stop == stop,\n        slice.step == step,\n        slice.step.is_some() ==> slice.step.unwrap() > 0,\n        (slice.start.is_some() && slice.stop.is_some()) ==> slice.start.unwrap() <= slice.stop.unwrap(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0193", "language": "verus", "source": "numpy_triple", "source_id": "indexing_slicing_select", "vc-description": "numpy.select: Return an array drawn from elements in choicelist, depending on conditions.\n\nFor each element position, returns the element from the first choice array\nwhere the corresponding condition is True. If no conditions are True,\nreturns the default value.\n\nThis function enables multi-way conditional selection between arrays.\n\nSpecification: numpy.select performs element-wise multi-conditional selection.\n\nPrecondition: condlist and choicelist have the same length\nPostcondition: Each element is selected from the first matching choice array,\n               or default if no conditions match", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn select(condlist: Vec<Vec<bool>>, choicelist: Vec<Vec<i8>>, default: i8) -> (result: Vec<i8>)\n    requires \n        condlist.len() == choicelist.len(),\n        condlist.len() > 0 ==> (forall|i: int| 0 <= i < condlist.len() ==> #[trigger] condlist[i].len() == condlist[0].len()),\n        choicelist.len() > 0 ==> (forall|i: int| 0 <= i < choicelist.len() ==> #[trigger] choicelist[i].len() == choicelist[0].len()),\n        condlist.len() > 0 && choicelist.len() > 0 ==> condlist[0].len() == choicelist[0].len(),\n    ensures\n        condlist.len() == 0 ==> result.len() == 0,\n        condlist.len() > 0 ==> result.len() == condlist[0].len(),\n        forall|i: int| 0 <= i < result.len() ==> {\n            (exists|j: int| 0 <= j < condlist.len() && condlist[j][i] == true && \n                #[trigger] result[i] == choicelist[j][i] &&\n                (forall|j_prime: int| 0 <= j_prime < j ==> #[trigger] condlist[j_prime][i] == false)) ||\n            (forall|j: int| 0 <= j < condlist.len() ==> #[trigger] condlist[j][i] == false && result[i] == default)\n        },", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0194", "language": "verus", "source": "numpy_triple", "source_id": "indexing_slicing_take", "vc-description": "Take elements from a source array at specified indices.\nGiven a source array 'arr' and a vector of indices 'indices',\nreturns a new array containing the elements from 'arr' at the positions\nspecified by 'indices'. The indices must be valid positions in the source array.\n\nThis is a simplified 1D version of numpy.take with 'raise' mode,\nwhere all indices must be valid (in range [0, n-1]).\n\nSpecification: take extracts elements from a source array at specified indices.\n\nMathematical properties:\n1. The result has the same length as the indices array\n2. For each position i in the result, result[i] = arr[indices[i]]\n3. All indices must be valid (enforced by Fin type)\n4. The order of elements in the result follows the order of indices\n5. The same index can appear multiple times, resulting in duplicated elements\n\nThe function implements: result[i] = arr.get (indices.get i)\n\nThis captures the core behavior of numpy.take in 'raise' mode where indices\nmust be in valid range. The use of Fin type ensures type safety and eliminates\nthe need for runtime bounds checking. The result preserves the element type\nof the source array.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn take(arr: Vec<f32>, indices: Vec<usize>) -> (result: Vec<f32>)\n    requires\n        forall|i: int| 0 <= i < indices@.len() ==> indices[i] < arr@.len(),\n    ensures\n        result@.len() == indices@.len(),\n        forall|i: int| 0 <= i < indices@.len() ==> result[i] == arr[indices[i] as int],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0195", "language": "verus", "source": "numpy_triple", "source_id": "indexing_slicing_trace", "vc-description": "Return the sum along diagonals of the array.\n\nFor a 2D matrix, computes the sum of elements along the diagonal\nwith an optional offset. For offset=0, it computes the sum of \nelements a[i,i] for all valid i. For positive offset, it sums\na[i,i+offset], and for negative offset, it sums a[i-offset,i].\n\nThis implementation focuses on the 2D case as the core functionality.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn trace(a: Vec<Vec<f32>>, offset: i32) -> (result: f32)\n    ensures true", "vc-code": "{\n    // impl-start\n    assume(false);\n    0.0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0196", "language": "verus", "source": "numpy_triple", "source_id": "indexing_slicing_tril", "vc-description": "numpy.tril: Lower triangle of an array.\n\nReturn a copy of an array with elements above the k-th diagonal zeroed.\nFor simplicity, this specification focuses on square matrices and k=0 (main diagonal).\n\nGiven a flattened square matrix (stored in row-major order), returns a copy\nwhere elements above the main diagonal are set to zero.\n\nThis captures the essential mathematical property of extracting the lower\ntriangular part of a matrix.\n\nSpecification: tril returns the lower triangle of a matrix with elements above the main diagonal zeroed.\n\nMathematical Properties:\n1. Shape Preservation: The output has the same shape as the input\n2. Lower Triangle Preservation: Elements at or below the main diagonal are unchanged\n3. Upper Triangle Zeroing: Elements above the main diagonal are set to zero\n4. Diagonal Definition: For a square matrix stored in row-major order,\n   element at position (i,j) corresponds to index i*n + j in the flattened vector\n\nThe main diagonal consists of elements where i = j.\nLower triangle consists of elements where i ≥ j.\nUpper triangle consists of elements where i < j.\n\nThis specification provides a foundation for formal verification of\ntriangular matrix operations in numerical computing.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn tril(matrix: Vec<f32>, n: usize) -> (result: Vec<f32>)\n    requires \n        n > 0,\n        matrix.len() == n * n,\n    ensures\n        result.len() == matrix.len(),\n        forall|i: usize, j: usize| #[trigger] result@[i * n + j] == matrix@[i * n + j] <==\n            i < n && j < n && i >= j,\n        forall|i: usize, j: usize| #[trigger] result@[i * n + j] == 0.0f32 <==\n            i < n && j < n && i < j,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0197", "language": "verus", "source": "numpy_triple", "source_id": "indexing_slicing_triu", "vc-description": "Upper triangle of a matrix. Returns a copy of the matrix with elements below the k-th diagonal zeroed.\n\nGiven a matrix m and an integer k, this function returns a new matrix where:\n- Elements at position (i,j) where i+k <= j are preserved (upper triangle including k-th diagonal)\n- Elements at position (i,j) where i+k > j are set to zero (below k-th diagonal)\n\nThe diagonal offset k works as follows:\n- k = 0: main diagonal (default)\n- k > 0: diagonal above the main diagonal\n- k < 0: diagonal below the main diagonal\n\nSpecification: triu returns the upper triangle of a matrix with elements below the k-th diagonal set to zero.\n\nMathematical properties:\n1. Elements on and above the k-th diagonal are preserved: if i+k <= j, then result[i][j] = m[i][j]\n2. Elements below the k-th diagonal are zeroed: if i+k > j, then result[i][j] = 0\n3. The result matrix has the same dimensions as the input matrix\n\nThe k-th diagonal is defined as positions (i,j) where i+k = j:\n- When k=0: main diagonal (i=j)\n- When k>0: diagonal above main diagonal \n- When k<0: diagonal below main diagonal\n\nThis captures the essential behavior of numpy.triu which extracts the upper triangular part\nof a matrix relative to the k-th diagonal.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn triu(m: Vec<Vec<f64>>, k: i8) -> (result: Vec<Vec<f64>>)\n    requires \n        m.len() > 0,\n        forall|i: int| 0 <= i < m@.len() ==> #[trigger] m@[i].len() == m@[0].len(),\n    ensures\n        result.len() == m.len(),\n        forall|i: int| 0 <= i < result@.len() ==> #[trigger] result@[i].len() == m@[0].len(),\n        forall|i: int, j: int| 0 <= i < result@.len() && 0 <= j < result@[i].len() && i + (k as int) <= j ==> #[trigger] result@[i][j] == m@[i][j],\n        forall|i: int, j: int| 0 <= i < result@.len() && 0 <= j < result@[i].len() && i + (k as int) > j ==> #[trigger] result@[i][j] == 0.0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0198", "language": "verus", "source": "numpy_triple", "source_id": "indexing_slicing_unravel_index", "vc-description": "Converts a flat index or array of flat indices into a tuple of coordinate arrays.\nThis is the inverse operation of ravel_multi_index.\nSpecification: unravel_index converts flat indices to multi-dimensional coordinates\nsuch that the coordinates are valid for the given shape and represent the correct\npositions in the multi-dimensional array.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn vec_product(shape: Seq<usize>) -> nat\n    decreases shape.len()\n{\n    if shape.len() == 0 {\n        1nat\n    } else {\n        (shape[0] as nat) * vec_product(shape.skip(1))\n    }\n}", "vc-helpers": "", "vc-spec": "fn unravel_index(indices: Vec<usize>, shape: Vec<usize>) -> (result: Vec<Vec<usize>>)\n    requires \n        shape.len() > 0,\n        forall|i: int| 0 <= i < shape.len() ==> shape[i] > 0,\n        forall|i: int| 0 <= i < indices.len() ==> (indices[i] as nat) < vec_product(shape@),\n    ensures\n        result.len() == indices.len(),\n        forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i].len() == shape.len(),\n        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < shape.len() ==> \n            #[trigger] result[i][j] < shape[j],\n        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result.len() && i != j ==> \n            (indices[i] != indices[j] ==> result[i]@ != result[j]@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0199", "language": "verus", "source": "numpy_triple", "source_id": "indexing_slicing_where", "vc-description": "Return elements chosen from x or y depending on condition.\nGiven vectors of equal length for condition, x, and y, constructs a result vector\nwhere each element is selected from x if the corresponding condition is true,\notherwise from y.\n\nThis implements the core ternary conditional operation:\nresult[i] = condition[i] ? x[i] : y[i]\n\nThe function requires all three input vectors to have the same length, which\nis enforced by the type system using Vector types.\n\nSpecification: where returns elements chosen from x or y based on condition.\nThis captures the essential behavior of numpy.where function:\n\nMathematical properties:\n1. The result has the same length as all input vectors\n2. For each position i, if condition[i] is true, then result[i] = x[i]\n3. For each position i, if condition[i] is false, then result[i] = y[i]\n4. The function is deterministic - same inputs always produce same output\n5. The result is well-defined for all inputs (no partial functions)\n\nThis specification captures the core ternary conditional semantics:\nresult[i] = if condition.get i then x.get i else y.get i\n\nThe use of Vector types ensures type safety and eliminates the need for\nsize compatibility checks at runtime. All vectors must have the same length\nby construction.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn where_fn(condition: Vec<bool>, x: Vec<f32>, y: Vec<f32>) -> (result: Vec<f32>)\n    requires \n        condition.len() == x.len(),\n        x.len() == y.len(),\n    ensures \n        result.len() == condition.len(),\n        forall|i: int| 0 <= i < condition.len() ==> \n            result@[i] == if condition@[i] { x@[i] } else { y@[i] }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0200", "language": "verus", "source": "numpy_triple", "source_id": "io_operations_array2string", "vc-description": "numpy.array2string: Return a string representation of an array\n\nConverts an array to its string representation with customizable separator.\nThis function provides a way to format arrays for display purposes.\n\nThe separator parameter controls how elements are separated in the output.\n\nSpecification: array2string returns a string representation of the array\n\nPrecondition: True (no special preconditions)\nPostcondition: result is non-empty string that starts with '[' and ends with ']'", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn array2string(arr: Vec<f32>, separator: &str) -> (result: Vec<char>)\n    ensures\n        result@.len() > 0,\n        result@[0] == '[',\n        result@[result@.len() - 1] == ']'", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0201", "language": "verus", "source": "numpy_triple", "source_id": "io_operations_array_repr", "vc-description": "Return the string representation of a vector, formatted as \"array([v1, v2, ..., vn])\".\nThis provides a structured string representation that includes the \"array()\" wrapper\nand properly formatted element values.\n\nSpecification: array_repr returns a well-formatted string representation of the vector.\n\nThe specification captures:\n1. Basic format: the string starts with \"array(\" and ends with \")\"\n2. Element representation: each element is formatted as a string\n3. Proper bracketing: elements are enclosed in square brackets\n4. Separator consistency: elements are separated by commas and spaces\n5. Precision handling: floating point numbers are formatted to specified precision\n6. Small number suppression: very small numbers can be represented as zero\n7. Non-emptiness: the result is always a non-empty string\n8. Structural integrity: the string format is parseable and well-formed", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn array_repr(arr: Vec<f32>, max_line_width: u8, precision: u8, suppress_small: bool) -> (result: String)\n    requires \n        precision as nat > 0,\n        max_line_width as nat > 0,\n    ensures\n        /* Non-empty result: string representation is always non-empty */\n        result@.len() > 0,\n        /* Precision constraint: reasonable string length bounds */\n        result@.len() <= max_line_width as nat + 20,\n        /* Basic format constraints - minimum length for valid array representation */\n        result@.len() >= 9,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0202", "language": "verus", "source": "numpy_triple", "source_id": "io_operations_array_str", "vc-description": "Return a string representation of the data in a vector\n\nSpecification: array_str returns a formatted string representation of the vector data", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn array_str(a: Vec<i8>) -> (result: String)\n    ensures \n        result@.len() > 0,\n        a.len() == 0 ==> result@ == \"[]\"@,\n        a.len() > 0 ==> result@[0] == '[' && result@[(result@.len() - 1) as int] == ']',", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0205", "language": "verus", "source": "numpy_triple", "source_id": "io_operations_fromfile", "vc-description": "Construct an array from data in a text or binary file\n\nThis function provides a highly efficient way of reading binary data with a known data-type, \nas well as parsing simply formatted text files. Data written using the tofile method can be \nread using this function.\n\nConstruct a vector from data in a text or binary file\nParameters:\n- file: File handle for the input file\n- dtype: Data type of the returned array\n- count: Number of items to read (-1 means entire file)\n- sep: Separator between items (empty string means binary file)\n- offset: Byte offset from file's current position (binary files only)\n\nSpecification: fromfile reads data from a file and constructs a vector\nProperties:\n1. For binary files (sep = \"\"), reads exactly count items if count > 0\n2. For text files (sep ≠ \"\"), parses items separated by sep\n3. If count = -1, reads all available data\n4. Binary files respect the offset parameter\n5. The resulting vector has the correct size and data type\n6. Data is read sequentially from the file\n\n/* File handle abstraction for I/O operations */\n\n/* Path to the file */\n\n/* Whether the file is opened in binary mode */\n\n/* Current position in the file (in bytes) */\n\n/* Represents different data types that can be read from files */\n\n/* 32-bit floating point */\n\n/* 64-bit floating point */\n\n/* 32-bit signed integer */\n\n/* 64-bit signed integer */\n\n/* 8-bit unsigned integer */\n\n/* Get the size in bytes for each data type */\n\n/* For binary files, data is read sequentially from offset */\n\n/* Sequential reading property: elements maintain file order preserved */\n\n/* placeholder for ordering properties */\n\n/* Type consistency: all elements are well-typed */\n\n/* placeholder for type consistency */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nstruct FileHandle {\n\n    path: String,\n\n    is_binary: bool,\n\n    position: nat,\n}\n\nenum DType {\n\n    Float32,\n\n    Float64,\n\n    Int32,\n\n    Int64,\n\n    UInt8,\n}\n\nspec fn dtype_size_bytes(dtype: DType) -> nat {\n    match dtype {\n        DType::Float32 => 4,\n        DType::Float64 => 8,\n        DType::Int32 => 4,\n        DType::Int64 => 8,\n        DType::UInt8 => 1,\n    }\n}", "vc-helpers": "", "vc-spec": "fn fromfile(file: FileHandle, dtype: DType, count: i8, sep: &str, offset: u8) -> (result: Vec<i8>)\n    requires\n        count == -1 || count > 0,\n        sep == \"\" ==> file.is_binary == true,\n        file.is_binary == true ==> sep == \"\",\n    ensures\n        count > 0 ==> result.len() == count as int as usize,\n\n        file.is_binary == true ==> (\n            #[trigger] (result@.len() * dtype_size_bytes(dtype))\n            >= 0\n        ),\n\n        true,\n\n        true,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0206", "language": "verus", "source": "numpy_triple", "source_id": "io_operations_fromregex", "vc-description": "Construct an array from a text file using regular expression parsing\n\nConstruct a structured array from a text file using regular expression parsing\n\nSpecification: fromregex constructs a structured array from regex matches in file content", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* A simple abstraction for regular expressions */\nstruct RegExp {\n    /* The regular expression pattern */\n    pattern: String,\n}\n\n/* A simple abstraction for structured data types */\nstruct StructuredDataType {\n    /* List of field names and their types */\n    fields: Vec<(String, String)>,\n}\n\n/* A simple abstraction for structured array elements */\nstruct StructuredElement {\n    /* List of field values as strings */\n    values: Vec<String>,\n}", "vc-helpers": "", "vc-spec": "fn fromregex(file_content: Vec<u8>, regexp: RegExp, dtype: StructuredDataType) -> (result: Vec<StructuredElement>)\n    requires dtype.fields@.len() > 0,\n    ensures\n        forall|i: int| 0 <= i < result@.len() ==> result@[i].values@.len() == dtype.fields@.len(),\n        forall|i: int, j: int| 0 <= i < result@.len() && 0 <= j < result@.len() ==> \n            result@[i].values@.len() == result@[j].values@.len(),\n        result@.len() > 0 ==> file_content@.len() > 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0207", "language": "verus", "source": "numpy_triple", "source_id": "io_operations_fromstring", "vc-description": "Create a 1-D array from text data in a string.\nParses a string containing numeric data separated by a specified separator\nand returns a vector of the parsed values.\nSpecification: fromstring creates a vector by parsing numeric values from a string.\nThe function parses the input string using the given separator and converts\nthe resulting substrings to floating-point numbers.\n\n/* All parsed elements are valid */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn fromstring(input: &str, sep: &str, n: u8) -> (result: Vec<f64>)\n    requires n > 0,\n    ensures \n        result@.len() <= n as int,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0208", "language": "verus", "source": "numpy_triple", "source_id": "io_operations_genfromtxt", "vc-description": "Load data from a text file, with missing values handled as specified. Load data from a text file with missing value handling. This is a simplified version focusing on numeric data parsing from delimited text. Specification: genfromtxt parses delimited text data into a matrix structure, handling missing values by filling them with the specified default value. The function skips the specified number of header lines and parses the remaining lines into a structured matrix.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn genfromtxt(input: Vec<String>, delimiter: String, fill_value: f32, skip_header: usize) -> (result: Vec<Vec<f32>>)\n    requires \n        skip_header < input.len(),\n    ensures\n        result.len() == input.len() - skip_header,\n        forall|i: int| 0 <= i < result@.len() ==> #[trigger] (i + skip_header as int) >= skip_header as int,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0209", "language": "verus", "source": "numpy_triple", "source_id": "io_operations_get_printoptions", "vc-description": "numpy.get_printoptions: Return the current print options\n\nReturns a structure containing the current print options that control\nhow arrays are formatted when displayed. These options include precision\nfor floating point numbers, threshold for array summarization, and\nvarious string representations.\n\nThis function reads the current state of NumPy's print formatting system.\n\nSpecification: get_printoptions returns a valid PrintOptions structure\nwith sensible default values.\n\nPrecondition: True (no special preconditions)\nPostcondition: Result contains valid print options with proper constraints", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "/* Structure representing NumPy print options */\nstruct PrintOptions {\n    /* Number of digits of precision for floating point output */\n    precision: u8,\n    /* Total number of array elements which trigger summarization */\n    threshold: u8,\n    /* Number of array items in summary at beginning and end */\n    edgeitems: u8,\n    /* Number of characters per line for line breaks */\n    linewidth: u8,\n    /* Whether to suppress small floating point values */\n    suppress: bool,\n    /* String representation of floating point not-a-number */\n    nanstr: Vec<char>,\n    /* String representation of floating point infinity */\n    infstr: Vec<char>,\n    /* Controls printing of the sign of floating-point types */\n    sign: Vec<char>,\n    /* Controls interpretation of precision option */\n    floatmode: Vec<char>,\n    /* Legacy printing mode setting */\n    legacy: Option<Vec<char>>,\n}\n\nfn get_printoptions() -> (result: PrintOptions)\n    ensures\n        result.precision as nat > 0,\n        result.threshold as nat > 0,\n        result.edgeitems as nat > 0,\n        result.linewidth as nat > 0,\n        result.nanstr@.len() > 0,\n        result.infstr@.len() > 0,\n        (result.sign@ == seq!['-'] || result.sign@ == seq!['+'] || result.sign@ == seq![' ']),\n        (result.floatmode@ == seq!['f','i','x','e','d'] ||\n         result.floatmode@ == seq!['u','n','i','q','u','e'] ||\n         result.floatmode@ == seq!['m','a','x','p','r','e','c'] ||\n         result.floatmode@ == seq!['m','a','x','p','r','e','c','_','e','q','u','a','l'])", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0211", "language": "verus", "source": "numpy_triple", "source_id": "io_operations_loadtxt", "vc-description": "Load data from a text file into a 2D array.\nFor simplicity, this specification focuses on loading a rectangular matrix of floats.\n\nSpecification: loadtxt reads numeric data from a text file into a well-formed 2D array.\nThe function preserves the structure of the input data and handles parsing correctly.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn loadtxt(filename: Vec<char>, delimiter: Vec<char>, skiprows: usize, rows: usize, cols: usize) -> (result: Vec<Vec<f64>>)\n    requires \n        rows > 0,\n        cols > 0,\n        filename@.len() > 0,\n    ensures\n        result@.len() == rows,\n        forall|i: int| 0 <= i < result@.len() ==> result@[i]@.len() == cols,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0212", "language": "verus", "source": "numpy_triple", "source_id": "io_operations_memmap", "vc-description": "numpy.memmap: Create a memory-map to an array stored in a binary file on disk.\n\nMemory-mapped files are used for accessing small segments of large files\non disk, without reading the entire file into memory. The memmap provides\nan array-like interface to the file contents.\n\nThis function creates a Vector view into a binary file on disk with the\nspecified shape and access mode. The file is accessed starting at the\ngiven offset.\n\nSpecification: numpy.memmap creates a memory-mapped view of a file.\n\nThis specification captures the essential properties of memory mapping:\n1. The result is a valid vector of the specified size\n2. The mapping respects the file access mode constraints\n3. The offset is within valid bounds for the file\n4. Read-only modes preserve data integrity\n5. Write modes allow modification of the underlying file\n\nPreconditions:\n- The filename represents a valid file path\n- The offset is non-negative and within the file bounds\n- For WriteNew mode, the file will be created if it doesn't exist\n- For ReadOnly mode, the file must exist and be readable\n\nPostconditions:\n- Returns a vector of the specified size n\n- The vector provides a view into the file starting at the given offset\n- Read operations reflect the file contents at the mapped region\n- Write operations (when mode allows) modify the underlying file\n- The mapping preserves the mathematical properties of array access", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* A simplified representation of file access mode for memory mapping */\n#[derive(PartialEq, Eq)]\nenum FileMode {\n    /* ReadOnly mode ('r') - read-only access to existing file */\n    ReadOnly,\n    /* ReadWrite mode ('r+') - read-write access to existing file */\n    ReadWrite,\n    /* WriteNew mode ('w+') - create new file with read-write access */\n    WriteNew,\n    /* CopyOnWrite mode ('c') - copy-on-write access, changes don't persist to disk */\n    CopyOnWrite,\n}", "vc-helpers": "", "vc-spec": "fn memmap(filename_valid: bool, mode: FileMode, offset: usize, n: usize) -> (result: Vec<f32>)\n    requires \n        filename_valid,\n    ensures\n        result@.len() == n as int,\n        forall|i: int| 0 <= i < n as int ==> #[trigger] result@[i] == result@[i],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0213", "language": "verus", "source": "numpy_triple", "source_id": "io_operations_printoptions", "vc-description": "numpy.printoptions: Context manager for setting print options.\n\nCreates a context manager that temporarily sets print options and restores\nthe original options afterward. This allows for local formatting changes\nwithout affecting global state.\n\nThe context manager returns the current print options that are active\nwithin the context.\n\nSpecification: numpy.printoptions creates a context with temporary print options.\n\nPrecondition: Valid print options are provided\nPostcondition: Returns a context that contains both old and new options,\n               where the new options are the ones that would be active\n               within the context", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* Print options structure to represent configuration */\nstruct PrintOptions {\n    /* Number of digits of precision for floating point output */\n    precision: usize,\n    /* Total number of array elements which trigger summarization */\n    threshold: usize,\n    /* Number of array items in summary at beginning and end */\n    edgeitems: usize,\n    /* Number of characters per line for inserting line breaks */\n    linewidth: usize,\n    /* Whether to suppress small floating point values */\n    suppress: bool,\n    /* String representation of floating point NaN */\n    nanstr: String,\n    /* String representation of floating point infinity */\n    infstr: String,\n}\n\n/* Context manager result representing the temporary state change */\nstruct PrintOptionsContext {\n    /* The original print options before the context change */\n    old_options: PrintOptions,\n    /* The new print options active within the context */\n    new_options: PrintOptions,\n}", "vc-helpers": "", "vc-spec": "fn numpy_printoptions(new_opts: PrintOptions) -> (context: PrintOptionsContext)\n    ensures \n        context.new_options == new_opts,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0214", "language": "verus", "source": "numpy_triple", "source_id": "io_operations_save", "vc-description": "numpy.save: Save an array to a binary file in NumPy .npy format.\n\nSaves Vector data to a binary file in NumPy .npy format. This operation serializes \nthe array data and writes it to disk storage. The function supports:\n- Automatic .npy extension appending if not present\n- Binary format writing for efficient storage and loading\n- Security control via allow_pickle parameter\n\nThe file parameter represents the path where the data should be saved.\nFor security reasons, object arrays with pickled data should be avoided \nunless explicitly allowed.\n\nThis is a file output operation that creates or overwrites the target file.\n\nSpecification: numpy.save persists vector data to disk in a recoverable format.\n\nThis specification captures the essential properties of the save operation:\n\n1. Data Persistence: The vector data is written to the specified file\n2. Format Consistency: Data is saved in .npy format for later loading\n3. File Creation: The target file is created or overwritten\n4. Extension Management: .npy extension is added if not present\n5. Security Control: Object arrays are only saved when explicitly allowed\n\nMathematical Properties:\n- Determinism: Saving the same vector to the same file produces identical results\n- Completeness: All vector elements are preserved in the saved format\n- Recoverability: The saved data can be loaded back to reconstruct the original vector\n- Idempotence: Multiple saves of the same data to the same file yield identical files\n\nPrecondition: The file path is valid and writable\nPostcondition: The file exists and contains the serialized vector data", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn save(file: String, arr: Vec<f32>, allow_pickle: bool) -> (result: ())\n    ensures result == (),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0216", "language": "verus", "source": "numpy_triple", "source_id": "io_operations_savez", "vc-description": "numpy.savez: Save several arrays into a single file in uncompressed .npz format.\n\nSaves multiple Vector arrays to a single .npz archive file. This operation\nserializes multiple arrays into a compressed archive, where each array\nis stored as a separate .npy file within the archive.\n\nKey functionality:\n- Multiple arrays can be saved in a single operation\n- Each array is stored with an associated name within the archive\n- The resulting .npz file can be loaded later to recover the arrays\n- Arrays are stored in uncompressed .npy format within the archive\n\nThe function takes a file path and multiple arrays to save. For simplicity,\nthis specification focuses on saving exactly two arrays (commonly used case).\n\nSecurity considerations:\n- Pickle support is controlled by allow_pickle parameter\n- Invalid file paths or write permissions can cause failures\n- The archive format ensures data integrity through checksums\n\nSpecification: numpy.savez creates a .npz archive containing multiple arrays.\n\nThis specification captures the essential properties of the savez operation:\n\n1. Data Persistence: Arrays are written to disk in a retrievable format\n2. Archive Structure: Multiple arrays are bundled into a single .npz file\n3. Data Integrity: Saved arrays can be loaded with identical values\n4. Name Association: Arrays are stored with identifiable names in the archive\n5. Format Compliance: Output follows .npz format specification\n\nMathematical Properties:\n- Bijection: There exists a one-to-one correspondence between saved and loaded arrays\n- Preservation: All array values are preserved exactly in the archive\n- Atomicity: Either all arrays are saved successfully or none are saved\n- Idempotence: Saving the same arrays multiple times produces identical files\n\nSecurity Properties:\n- Pickle safety: Object arrays are only saved when explicitly allowed\n- File system safety: Operation respects file system permissions\n\nPrecondition: File path is writable and arrays are valid\nPostcondition: Archive file exists and contains both arrays with recoverable data\n\n/* h_writable and h_valid_path assumptions */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn savez(file: String, arr1: Vec<f32>, arr2: Vec<f32>, allow_pickle: bool) -> (result: ())\n    requires \n        true,\n    ensures \n        result == (),\n        exists|recoverable_arr1: Vec<f32>| #[trigger] recoverable_arr1.len() == arr1.len() &&\n            forall|i: int| 0 <= i < arr1.len() ==> recoverable_arr1[i] == arr1[i],\n        exists|recoverable_arr2: Vec<f32>| #[trigger] recoverable_arr2.len() == arr2.len() &&\n            forall|i: int| 0 <= i < arr2.len() ==> recoverable_arr2[i] == arr2[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0217", "language": "verus", "source": "numpy_triple", "source_id": "io_operations_savez_compressed", "vc-description": "Save several arrays into a single file in compressed .npz format.\n\nThis function saves multiple arrays to a compressed archive file.\nArrays are stored with either provided names or automatic names (arr_0, arr_1, etc.).\nThe resulting file can be loaded back using numpy.load.\n\nSpecification: savez_compressed saves arrays to a compressed archive file.\n\nThe function should:\n1. Create a compressed .npz file at the specified path\n2. Store each array in the archive with proper naming\n3. Ensure the file is readable by compatible loading functions\n4. Handle filename extension automatically (.npz appended if not present)", "vc-preamble": "use vstd::prelude::*;\nuse vstd::string::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn savez_compressed(filename: &str, arrays: &Vec<Vec<i8>>) -> (result: ())\n    requires \n        filename@.len() > 0,\n        arrays@.len() > 0,\n    ensures\n        /* File creation and data preservation properties are ensured */\n        true", "vc-code": "{\n    // impl-start\n    assume(false);\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0218", "language": "verus", "source": "numpy_triple", "source_id": "io_operations_set_printoptions", "vc-description": "numpy.set_printoptions: Set printing options for NumPy arrays\n\nSets the global printing options that control how floating point numbers,\narrays and other NumPy objects are displayed. This function modifies the\nglobal state of NumPy's print formatting system.\n\nAll parameters are optional and only modify the corresponding option if\nprovided. Options not specified retain their current values.\n\nSpecification: set_printoptions correctly updates the global print options\naccording to the provided parameters while validating input constraints.\n\nPrecondition: All optional parameters must satisfy their validation constraints\nPostcondition: The global print state is updated with the provided options", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* Structure representing NumPy print options */\nstruct PrintOptions {\n    /* Number of digits of precision for floating point output */\n    precision: nat,\n    /* Total number of array elements which trigger summarization */\n    threshold: nat,\n    /* Number of array items in summary at beginning and end */\n    edgeitems: nat,\n    /* Number of characters per line for line breaks */\n    linewidth: nat,\n    /* Whether to suppress small floating point values */\n    suppress: bool,\n    /* String representation of floating point not-a-number */\n    nanstr: String,\n    /* String representation of floating point infinity */\n    infstr: String,\n    /* Controls printing of the sign of floating-point types */\n    sign: String,\n    /* Controls interpretation of precision option */\n    floatmode: String,\n    /* Legacy printing mode setting */\n    legacy: Option<String>,\n}", "vc-helpers": "", "vc-spec": "fn set_printoptions(\n    precision: Option<u8>,\n    threshold: Option<u8>,\n    edgeitems: Option<u8>,\n    linewidth: Option<u8>,\n    suppress: Option<bool>,\n    nanstr: Option<String>,\n    infstr: Option<String>,\n    sign: Option<String>,\n    floatmode: Option<String>,\n    legacy: Option<String>\n) -> (result: ())\n    requires\n        forall|p: u8| precision == Some(p) ==> p as nat > 0,\n        forall|t: u8| threshold == Some(t) ==> t as nat > 0,\n        forall|e: u8| edgeitems == Some(e) ==> e as nat > 0,\n        forall|l: u8| linewidth == Some(l) ==> l as nat > 0,\n        forall|n: String| nanstr == Some(n) ==> n@.len() > 0,\n        forall|i: String| infstr == Some(i) ==> i@.len() > 0,\n        forall|s: String| sign == Some(s) ==> (s@.len() == 1 && (s@ == seq!['-'] || s@ == seq!['+'] || s@ == seq![' '])),\n        forall|f: String| floatmode == Some(f) ==> \n            (f@ == seq!['f','i','x','e','d'] || f@ == seq!['u','n','i','q','u','e'] || f@ == seq!['m','a','x','p','r','e','c'] || f@ == seq!['m','a','x','p','r','e','c','_','e','q','u','a','l']),\n        forall|l: String| legacy == Some(l) ==> \n            (l@ == seq!['1','.','1','3'] || l@ == seq!['1','.','2','1'] || l@ == seq!['1','.','2','5'] || l@ == seq!['2','.','1'] || l@ == seq!['2','.','2']),\n    ensures result == ()", "vc-code": "{\n    // impl-start\n    assume(false);\n    ()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0219", "language": "verus", "source": "numpy_triple", "source_id": "linalg_LinAlgError", "vc-description": "Generic Python-exception-derived object raised by linalg functions.\nError checking predicate for linear algebra operations.\nSpecification: Linear algebra error detection correctly identifies error conditions.\n\n/* Linear algebra error type representing conditions that prevent correct execution of linalg functions */\n\n/* Error when numerical algorithm fails to converge */\n\n/* Error when matrix is singular (non-invertible) */\n\n/* Error when operation requires square matrix but input is not square */\n\n/* Error when matrix dimensions are incompatible for the operation */\n\n/* Error when input parameters are invalid */\n\n/* Error when numerical computation becomes unstable */\n\n/* Generic error for other linear algebra failures */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\npub enum LinAlgError {\n\n    NonConvergence(String),\n\n    SingularMatrix(String),\n\n    NonSquareMatrix(String),\n\n    IncompatibleDimensions(String),\n\n    InvalidInput(String),\n\n    NumericalInstability(String),\n\n    Other(String),\n}", "vc-helpers": "", "vc-spec": "fn check_lin_alg_error(condition: bool, error_variant: u8, message: String) -> (result: Option<LinAlgError>)\n    ensures \n        condition == true ==> result.is_some(),\n        condition == false ==> result == None::<LinAlgError>,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0221", "language": "verus", "source": "numpy_triple", "source_id": "linalg_cond", "vc-description": "Compute the condition number of a matrix.\n\nThe condition number measures how sensitive the solution x is to errors in b for Ax=b.\n\nParameters:\n- x: The matrix\n- p: Order of the norm\n\nReturns:\n- c: The condition number\n\nCompute the condition number of a square matrix using the 2-norm.\n\nThe condition number of a matrix A is defined as ||A|| * ||A^(-1)||,\nwhere ||.|| is the matrix norm. For the 2-norm, this equals the ratio\nof the largest singular value to the smallest singular value.\n\nThe condition number measures how sensitive the solution x is to errors \nin b for the linear system Ax = b. A condition number of 1 indicates\na perfectly conditioned matrix, while large condition numbers indicate\nill-conditioned matrices.\n\nSpecification: The condition number is always non-negative and is at least 1 \nfor any invertible matrix. This captures the fundamental mathematical \nproperties of condition numbers in linear algebra.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn condition_number(x: Vec<Vec<i8>>) -> (result: i8)\n    requires \n        x.len() > 0,\n        forall|i: int| 0 <= i < x.len() ==> x[i].len() == x.len(),\n    ensures \n        result as int >= 0,\n        result as int >= 1,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0222", "language": "verus", "source": "numpy_triple", "source_id": "linalg_cross", "vc-description": "numpy.linalg.cross: Return the cross product of 3-element vectors.\n\nComputes the cross product of two 3-element vectors. The cross product\nof two vectors a and b is a vector perpendicular to both a and b.\n\nFor 3D vectors a = [a₀, a₁, a₂] and b = [b₀, b₁, b₂], the cross product\nis defined as:\na × b = [a₁b₂ - a₂b₁, a₂b₀ - a₀b₂, a₀b₁ - a₁b₀]\n\nThis follows the right-hand rule convention.\n\nSpecification: numpy.linalg.cross returns the cross product of two 3D vectors.\n\nPrecondition: True (both vectors must be 3-dimensional, enforced by type)\n\nPostcondition: The result is a 3D vector where:\n- result[0] = x1[1] * x2[2] - x1[2] * x2[1]\n- result[1] = x1[2] * x2[0] - x1[0] * x2[2]  \n- result[2] = x1[0] * x2[1] - x1[1] * x2[0]\n\nThe cross product has the mathematical property that it is perpendicular\nto both input vectors (i.e., result · x1 = 0 and result · x2 = 0).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_linalg_cross(x1: [i8; 3], x2: [i8; 3]) -> (result: [i8; 3])\n    ensures\n        result[0] as int == x1[1] as int * x2[2] as int - x1[2] as int * x2[1] as int,\n        result[1] as int == x1[2] as int * x2[0] as int - x1[0] as int * x2[2] as int,\n        result[2] as int == x1[0] as int * x2[1] as int - x1[1] as int * x2[0] as int", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0223", "language": "verus", "source": "numpy_triple", "source_id": "linalg_det", "vc-description": "Compute the determinant of a square matrix. The determinant satisfies fundamental mathematical properties including explicit formulas for small matrices, multilinear properties, and behavior under elementary row operations.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn det(a: Vec<Vec<i8>>) -> (result: i8)\n    requires \n        a.len() > 0,\n        forall|i: int| 0 <= i < a@.len() ==> a@[i].len() == a@.len(),\n    ensures\n        /* For 1x1 matrices, the determinant is the single element */\n        a@.len() == 1 ==> result as int == a@[0][0],\n        /* For 2x2 matrices, the determinant is ad - bc */\n        a@.len() == 2 ==> result as int == a@[0][0] * a@[1][1] - a@[0][1] * a@[1][0],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0224", "language": "verus", "source": "numpy_triple", "source_id": "linalg_diagonal", "vc-description": "numpy.linalg.diagonal: Returns specified diagonals of a matrix.\n\nExtracts the diagonal elements from a matrix. The offset parameter\ncontrols which diagonal to extract:\n- offset = 0: main diagonal (elements at position [i,i])\n- offset > 0: diagonals above the main diagonal (elements at [i,i+offset])\n- offset < 0: diagonals below the main diagonal (elements at [i-offset,i])\n\nFor simplicity, we return a vector of size min(m,n) which is valid for offset=0.\nThe actual diagonal length depends on the offset value and matrix dimensions.\n\nSpecification: numpy.linalg.diagonal returns the diagonal elements of a matrix.\n\nPrecondition: The matrix must be non-empty (both dimensions > 0)\nPostcondition: The result contains the diagonal elements extracted from the matrix.\n               - For offset = 0: result[i] = x[i][i] (main diagonal)\n               - The result vector has the same type as the input matrix elements\n               - The extraction respects the mathematical definition of matrix diagonals", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn spec_min(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n\nfn numpy_diagonal(x: Vec<Vec<f32>>, offset: i32) -> (result: Vec<f32>)\n    requires \n        x@.len() > 0,\n        x@.len() < usize::MAX,\n        forall|i: int| 0 <= i < x@.len() ==> #[trigger] x@[i].len() > 0,\n        forall|i: int| 0 <= i < x@.len() ==> #[trigger] x@[i].len() == x@[0].len(),\n    ensures\n        result@.len() == spec_min(x@.len() as int, x@[0].len() as int),\n        offset == 0 ==> forall|i: int| 0 <= i < result@.len() ==> \n            result@[i] == x@[i][i],\n        forall|i: int| 0 <= i < result@.len() ==> \n            exists|r: int, c: int| \n                0 <= r < x@.len() && 0 <= c < x@[0].len() &&\n                #[trigger] result@[i] == x@[r][c],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0225", "language": "verus", "source": "numpy_triple", "source_id": "linalg_eig", "vc-description": "Compute the eigenvalues and right eigenvectors of a square matrix.\n\nFor a square matrix A, this function computes vectors v and scalars λ such that:\nA * v = λ * v\n\nReturns a pair (eigenvalues, eigenvectors) where:\n- eigenvalues: Vector of eigenvalues λ_i\n- eigenvectors: Matrix where column i is the eigenvector corresponding to eigenvalue λ_i\n\nSpecification: eig computes the eigenvalues and right eigenvectors of a square matrix.\n\nThe fundamental eigenvalue equation is: A * v = λ * v, where:\n- A is the input matrix\n- v is an eigenvector (non-zero vector)\n- λ is the corresponding eigenvalue\n\nThis specification captures the mathematical properties of eigenvalues and eigenvectors:\n1. The eigenvalue equation holds for each eigenvalue-eigenvector pair\n2. Eigenvectors are normalized (unit length) \n3. For diagonal matrices, eigenvalues are the diagonal elements\n4. Identity matrix has eigenvalue 1 with multiplicity n\n\n/* Main eigenvalue equation: A * v = λ * v (simplified specification) */\n\n/* Placeholder for eigenvalue equation */\n\n/* For diagonal matrices, eigenvalues are diagonal elements */\n\n/* Eigenvectors are non-zero */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn eig(a: Vec<Vec<f32>>) -> (result: (Vec<f32>, Vec<Vec<f32>>))\n    requires \n        a.len() > 0,\n        forall|i: int| 0 <= i < a.len() ==> a@[i].len() == a.len(),\n    ensures\n        result.0.len() == a.len() && result.1.len() == a.len(),\n        forall|i: int| 0 <= i < result.1.len() ==> result.1@[i].len() == a.len(),\n\n        true,\n\n        (forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() && i != j ==> a@[i]@[j] == 0.0f32) ==> \n        (forall|i: int| #![trigger a@[i]] 0 <= i < a.len() ==> \n            exists|j: int| 0 <= j < result.0.len() && result.0@[j] == a@[i]@[i]),\n\n        forall|col: int| #![trigger result.1@[col]] 0 <= col < a.len() ==> \n            exists|row: int| 0 <= row < a.len() && result.1@[row]@[col] != 0.0f32,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0226", "language": "verus", "source": "numpy_triple", "source_id": "linalg_eigh", "vc-description": "Compute eigenvalues and eigenvectors of a Hermitian or symmetric matrix.\n\nReturns the eigenvalues and eigenvectors of a complex Hermitian or symmetric matrix.\nThe function takes a Hermitian or symmetric matrix and returns eigenvalues in ascending order\nand the normalized eigenvectors satisfying the eigenvalue equation.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "struct EighResult {\n    eigenvalues: Vec<f32>,\n    eigenvectors: Vec<Vec<f32>>,\n}\n\nfn eigh(a: Vec<Vec<f32>>) -> (result: EighResult)\n    requires \n        a.len() > 0,\n        forall|i: int| 0 <= i < a.len() ==> a[i]@.len() == a.len(),\n        forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() ==> a[i][j] == a[j][i],\n    ensures\n        result.eigenvalues.len() == a.len(),\n        result.eigenvectors.len() == a.len(),\n        forall|i: int| 0 <= i < result.eigenvectors.len() ==> result.eigenvectors[i]@.len() == a.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0227", "language": "verus", "source": "numpy_triple", "source_id": "linalg_eigvals", "vc-description": "Compute the eigenvalues of a general square matrix\n\nSpecification: eigvals computes eigenvalues of a square matrix", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n/* Complex number type for eigenvalues */\nstruct Complex {\n    re: f64,\n    im: f64,\n}\n\n/* Matrix represented as a vector of vectors (rows) */\ntype Matrix<T> = Vec<Vec<T>>;", "vc-helpers": "", "vc-spec": "fn eigvals(a: &Matrix<f64>) -> (result: Vec<Complex>)\n    requires \n        a@.len() > 0,\n        forall|i: int| 0 <= i < a@.len() ==> a@[i].len() == a@.len(),\n    ensures\n        result@.len() == a@.len()", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0228", "language": "verus", "source": "numpy_triple", "source_id": "linalg_eigvalsh", "vc-description": "Compute the eigenvalues of a complex Hermitian or real symmetric matrix\n\nCompute the eigenvalues of a real symmetric matrix.\nReturns eigenvalues in ascending order without computing eigenvectors.\nThis is the eigenvalues-only version of the symmetric eigenvalue problem.\n\nSpecification: eigvalsh computes eigenvalues of a real symmetric matrix.\n\nThe eigenvalues are real (since the matrix is symmetric) and returned in ascending order.\nKey mathematical properties:\n1. The eigenvalues are real for symmetric matrices\n2. They are returned in ascending order\n3. The trace equals the sum of eigenvalues\n4. The determinant equals the product of eigenvalues\n5. For the identity matrix, all eigenvalues are 1\n6. For diagonal matrices, eigenvalues are the diagonal elements (sorted)\n7. Matrix symmetry: a[i][j] = a[j][i] for all i,j", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn eigvalsh(a: Vec<Vec<i8>>) -> (eigenvals: Vec<i8>)\n    requires\n        a.len() > 0,\n        forall|i: int| 0 <= i < a.len() ==> a[i].len() == a.len(),\n        forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() ==> a[i][j] == a[j][i],\n    ensures\n        eigenvals.len() == a.len(),\n        /* Eigenvalues are in ascending order */\n        forall|i: int, j: int| 0 <= i < j < eigenvals.len() ==> eigenvals[i] <= eigenvals[j],\n        /* Identity matrix has all eigenvalues equal to 1 */\n        (forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() ==> \n            a[i][j] == (if i == j { 1i8 } else { 0i8 })) ==> \n            (forall|i: int| 0 <= i < eigenvals.len() ==> eigenvals[i] == 1i8),\n        /* Zero matrix has all eigenvalues equal to 0 */\n        (forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() ==> a[i][j] == 0i8) ==> \n            (forall|i: int| 0 <= i < eigenvals.len() ==> eigenvals[i] == 0i8)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0230", "language": "verus", "source": "numpy_triple", "source_id": "linalg_lstsq", "vc-description": "Return the least-squares solution to a linear matrix equation.\n\nSolves the equation a @ x = b by minimizing ||b - ax||^2.\n\nParameters:\n- a: Coefficient matrix (M, N)\n- b: Ordinate values (M,) or (M, K)\n- rcond: Cut-off ratio for small singular values\n\nReturns tuple of:\n- x: Least-squares solution\n- residuals: Sums of squared residuals\n- rank: Rank of matrix a\n- s: Singular values of a", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn lstsq(a: Vec<Vec<f32>>, b: Vec<f32>) -> (result: Vec<f32>)\n    requires \n        a.len() > 0,\n        b.len() > 0,\n        a.len() == b.len(),\n        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i].len() > 0,\n        forall|i: int| 0 <= i < a.len() ==> #[trigger] a[i].len() == a[0].len(),\n    ensures\n        result.len() == a[0].len()", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0231", "language": "verus", "source": "numpy_triple", "source_id": "linalg_matmul", "vc-description": "Matrix multiplication for 2D matrices. Computes the matrix product of two 2D arrays following standard matrix multiplication rules. The result matrix C has dimensions (m x p) where A is (m x n) and B is (n x p).\n\nSpecification: Matrix multiplication produces a result where each element is the dot product of the corresponding row from the first matrix and column from the second matrix.\n\nMathematical properties:\n1. Dimensions are compatible: A is m×n, B is n×p, result is m×p\n2. Each element C[i][j] = sum of A[i][k] * B[k][j] for k from 0 to n-1\n3. The operation preserves the fundamental matrix multiplication identity\n4. Non-commutativity: A*B ≠ B*A in general (handled by type system)\n5. Associativity: (A*B)*C = A*(B*C) when dimensions are compatible", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn matmul(A: Vec<Vec<i8>>, B: Vec<Vec<i8>>) -> (result: Vec<Vec<i8>>)\n    requires\n        A.len() > 0,\n        B.len() > 0,\n        A@[0].len() == B.len(),\n        forall|i: int| 0 <= i < A.len() ==> #[trigger] A@[i].len() == A@[0].len(),\n        forall|i: int| 0 <= i < B.len() ==> #[trigger] B@[i].len() == B@[0].len(),\n    ensures\n        result.len() == A.len(),\n        result.len() > 0 ==> result@[0].len() == B@[0].len(),\n        forall|i: int| 0 <= i < result.len() ==> #[trigger] result@[i].len() == B@[0].len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0232", "language": "verus", "source": "numpy_triple", "source_id": "linalg_matrix_norm", "vc-description": "Compute matrix norm of a matrix (Frobenius norm by default)\n\nSpecification: matrix_norm computes the Frobenius norm of a matrix \nThe Frobenius norm is the square root of the sum of squares of all elements.\n\nProperties:\n1. Non-negativity: norm is always ≥ 0\n2. Zero property: norm is 0 iff all elements are 0\n3. Homogeneity: norm(c*A) = |c| * norm(A) for scalar c\n4. Triangle inequality: norm(A + B) ≤ norm(A) + norm(B)\n5. Submultiplicativity: norm(A) dominates the absolute value of any element", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn abs_val(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}", "vc-helpers": "", "vc-spec": "fn matrix_norm(x: Vec<Vec<i8>>) -> (result: i8)\n    requires \n        x@.len() > 0,\n        forall|i: int| 0 <= i < x@.len() ==> #[trigger] x@[i].len() > 0,\n        forall|i: int| 0 <= i < x@.len() ==> #[trigger] x@[i].len() == x@[0].len(),\n    ensures\n        result as int >= 0,\n        (result as int == 0) == (forall|i: int, j: int| \n            0 <= i < x@.len() && 0 <= j < x@[i].len() ==> #[trigger] x@[i][j] == 0),\n        forall|i: int, j: int| \n            0 <= i < x@.len() && 0 <= j < x@[i].len() ==> abs_val(#[trigger] x@[i][j] as int) <= result as int,\n        (exists|i: int, j: int| \n            0 <= i < x@.len() && 0 <= j < x@[i].len() && #[trigger] x@[i][j] != 0) ==> result as int > 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    0i8\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0233", "language": "verus", "source": "numpy_triple", "source_id": "linalg_matrix_power", "vc-description": "numpy.linalg.matrix_power: Raise a square matrix to the (integer) power n.\n\nFor positive integers n, the power is computed by repeated matrix squarings and \nmatrix multiplications. If n == 0, the identity matrix is returned. \nIf n < 0, the inverse is computed and raised to abs(n).\n\nThis implements the mathematical operation A^n for square matrices A.\nThe operation follows the standard mathematical definition:\n- A^0 = I (identity matrix)\n- A^1 = A\n- A^n = A * A^(n-1) for n > 1\n- A^(-n) = (A^(-1))^n for n < 0\n\nSpecification: matrix_power raises a square matrix to an integer power.\n\nPrecondition: The matrix A must be square (n×n). For negative powers,\nthe matrix must be invertible (non-singular).\n\nPostcondition: The result satisfies the mathematical definition of matrix exponentiation:\n1. For exp = 0: result is the identity matrix\n2. For exp = 1: result equals the input matrix A\n3. For exp > 1: result = A * A^(exp-1) (recursive definition)\n4. For exp < 0: result = (A^(-1))^|exp| (inverse raised to absolute value)\n\nMathematical properties:\n- A^0 = I (identity matrix) for any square matrix A\n- A^1 = A for any square matrix A\n- A^m * A^n = A^(m+n) for any integers m, n (when A is invertible for negative powers)\n- (A^m)^n = A^(m*n) for any integers m, n (when A is invertible for negative powers)\n- If A is invertible, then A^(-1) * A = A * A^(-1) = I\n- Matrix power preserves the dimension: n×n input produces n×n output\n\nThis captures the complete mathematical characterization of matrix exponentiation.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn matrix_power(a: Vec<Vec<i8>>) -> (result: Vec<Vec<i8>>)\n    requires \n        a.len() > 0,\n        forall|i: int| 0 <= i < a.len() ==> a@[i].len() == a.len(),\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> result@[i].len() == a.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0234", "language": "verus", "source": "numpy_triple", "source_id": "linalg_matrix_rank", "vc-description": "numpy.linalg.matrix_rank: Return matrix rank of array using SVD method.\n\nThe rank of a matrix is the number of linearly independent columns\n(or rows). For numerical computation, this is determined by counting\nthe number of singular values greater than a threshold.\n\nThis implementation focuses on the core mathematical behavior for\nsquare matrices, using default tolerance.\n\nSpecification: matrix_rank computes the rank of a matrix using SVD method.\n\nThe rank is the number of singular values greater than a numerical threshold.\nThis corresponds to the number of linearly independent columns (or rows).\n\nMathematical definition:\n- For a matrix A, rank(A) = number of non-zero singular values\n- In numerical computation, \"non-zero\" means above a threshold\n\nKey properties verified:\n1. Bounds: 0 ≤ rank(A) ≤ min(m, n) for m×n matrix\n2. Zero matrix: rank(0) = 0 (all elements zero)\n3. Identity matrix: rank(I) = n for n×n identity matrix\n4. Rank deficiency: If a row/column is all zeros, rank < full rank\n5. Linear dependence: If rows/columns are linearly dependent, rank < full rank\n\nThe threshold behavior ensures numerical stability but is not explicitly\nspecified here for simplicity.\n\n/* Zero matrix has rank 0 */\n\n/* Identity matrix has full rank */\n\n/* For 1x1 matrices */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn min_usize(a: usize, b: usize) -> usize {\n    if a <= b { a } else { b }\n}\n\nfn matrix_rank(A: Vec<Vec<f32>>) -> (result: usize)\n    requires \n        A.len() > 0,\n        A[0].len() > 0,\n        forall|i: int| 0 <= i < A.len() ==> #[trigger] A[i as int].len() == A[0].len(),\n    ensures\n        result <= min_usize(A.len(), A[0].len()),\n\n        (forall|i: int, j: int| 0 <= i < A.len() && 0 <= j < A[0].len() ==> #[trigger] A[i as int][j as int] == 0.0f32) ==> result == 0,\n\n        (A.len() == A[0].len() && forall|i: int, j: int| 0 <= i < A.len() && 0 <= j < A[0].len() ==> #[trigger] A[i as int][j as int] == (if i == j { 1.0f32 } else { 0.0f32 })) ==> result == A.len(),\n\n        (A.len() == 1 && A[0].len() == 1) ==> ((result == 1) <==> (A[0][0] != 0.0f32)),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0235", "language": "verus", "source": "numpy_triple", "source_id": "linalg_matrix_transpose", "vc-description": "numpy.linalg.matrix_transpose: Transposes a matrix (or a stack of matrices).\n\nFor a 2D matrix, this operation swaps the rows and columns.\nThe element at position (i, j) in the input matrix becomes the element\nat position (j, i) in the output matrix.\n\nInput: A matrix with rows × cols dimensions\nOutput: A matrix with cols × rows dimensions (transposed)\n\nSpecification: numpy.linalg.matrix_transpose returns the transpose of the input matrix.\n\nFor a matrix x with dimensions rows × cols, the transpose x_T has dimensions cols × rows.\nThe element at position (i, j) in the original matrix x becomes the element at position (j, i) in x_T.\n\nPrecondition: True (no special preconditions for matrix transpose)\nPostcondition: For all valid indices i and j, x_T[j][i] = x[i][j]", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_matrix_transpose(x: Vec<Vec<f32>>) -> (result: Vec<Vec<f32>>)\n    requires \n        x@.len() > 0,\n        forall|i: int| 0 <= i < x@.len() ==> x@[i].len() > 0,\n        forall|i: int, j: int| 0 <= i < x@.len() && 0 <= j < x@.len() ==> x@[i].len() == x@[j].len(),\n    ensures\n        result@.len() == (if x@.len() > 0 { x@[0].len() } else { 0 }),\n        forall|i: int| 0 <= i < result@.len() ==> result@[i].len() == x@.len(),\n        forall|i: int, j: int| 0 <= i < x@.len() && 0 <= j < x@[0].len() ==> result@[j][i] == x@[i][j],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0236", "language": "verus", "source": "numpy_triple", "source_id": "linalg_multi_dot", "vc-description": "Multi-dot product: compute the dot product of multiple matrices in a single function call\nwith optimal parenthesization. This function performs a chain of matrix multiplications\nA₁ × A₂ × ... × Aₙ where the parenthesization is chosen to minimize computational cost.\n\nFor three matrices A, B, C, this computes A × B × C with the optimal evaluation order.\nThe result is independent of parenthesization due to associativity of matrix multiplication.\n\nSpecification: Multi-dot performs a chain of matrix multiplications with optimal parenthesization.\n\nMathematical properties:\n1. Associativity: (A × B) × C = A × (B × C) - the result is independent of parenthesization\n2. Dimension compatibility: A is n₁×n₂, B is n₂×n₃, C is n₃×n₄, result is n₁×n₄\n3. Element-wise computation: result[i][j] equals the triple sum over intermediate indices\n4. Optimal evaluation order: the implementation chooses the parenthesization that minimizes \n   the total number of scalar multiplications needed\n5. Correctness: the result equals the sequential application of matrix multiplications\n6. Non-empty constraint: at least two matrices are required (enforced by signature)\n\nThis specification captures the essential mathematical behavior while abstracting away \nthe optimization details. The key insight is that matrix multiplication is associative,\nso different parenthesizations yield the same mathematical result.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn multi_dot(A: Vec<Vec<i8>>, B: Vec<Vec<i8>>, C: Vec<Vec<i8>>) -> (result: Vec<Vec<i8>>)\n    requires \n        A.len() > 0,\n        B.len() > 0, \n        C.len() > 0,\n        forall|i: int| 0 <= i < A.len() ==> A[i]@.len() == B@.len(),\n        forall|i: int| 0 <= i < B.len() ==> B[i]@.len() == C@.len(),\n        forall|i: int| 0 <= i < C.len() ==> C[i]@.len() > 0,\n    ensures\n        result@.len() == A@.len(),\n        forall|i: int| 0 <= i < result@.len() ==> result[i]@.len() == C[0]@.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0237", "language": "verus", "source": "numpy_triple", "source_id": "linalg_norm", "vc-description": "numpy.linalg.norm: Compute the 2-norm (Euclidean norm) of a vector.\n\nThis is the default vector norm when ord=None. For a vector x,\nthe 2-norm is defined as: ||x||_2 = sqrt(sum(x[i]^2))\n\nThis implementation focuses on the most common use case: computing\nthe Euclidean norm of a 1D vector.\n\nSpecification: norm computes the Euclidean norm (2-norm) of a vector.\n\nThe 2-norm is defined as the square root of the sum of squares of all elements.\nThis is the most common vector norm used in numerical computing and is the\ndefault norm in NumPy when ord=None.\n\nMathematical definition:\n- For a vector x = [x₁, x₂, ..., xₙ], the 2-norm is: ||x||₂ = √(Σᵢ xᵢ²)\n\nKey properties verified:\n1. Definition: result equals sqrt of sum of squared elements\n2. Non-negativity: norm(x) ≥ 0 for all x\n3. Definiteness: norm(x) = 0 if and only if x is the zero vector\n4. Empty vector: norm of empty vector is 0\n\nNote: Properties like triangle inequality and homogeneity follow from\nthe definition but are not explicitly stated in this specification.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn norm(x: Vec<i8>) -> (result: i8)\n    requires true,\n    ensures true,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0238", "language": "verus", "source": "numpy_triple", "source_id": "linalg_outer", "vc-description": "Compute the outer product of two vectors.\nGiven vectors a of size m and b of size n, produces an m×n matrix\nwhere element (i,j) equals a[i] * b[j].\n\nSpecification: The outer product produces a matrix where each element (i,j)\nis the product of the i-th element of the first vector and the j-th element\nof the second vector. This captures the fundamental mathematical property\nthat outer(a,b)[i,j] = a[i] * b[j].\n\nThe specification includes:\n1. Core property: Each matrix element equals the product of corresponding vector elements\n2. Row structure: Each row i is the vector b scaled by a[i]\n3. Column structure: Each column j is the vector a scaled by b[j]\n4. Bilinearity: The outer product is linear in both arguments\n\nThis captures the essential mathematical behavior of the outer product operation,\nwhich is fundamental in linear algebra and tensor analysis.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn outer_i32(a: Vec<i8>, b: Vec<i8>) -> (result: Vec<Vec<i8>>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == b.len(),\n        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result[i].len() ==> \n            result[i][j] as int == a[i] as int * b[j] as int,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0239", "language": "verus", "source": "numpy_triple", "source_id": "linalg_pinv", "vc-description": "numpy.linalg.pinv: Compute the (Moore-Penrose) pseudo-inverse of a matrix.\n\nCalculate the generalized inverse of a matrix using its\nsingular-value decomposition (SVD) and including all\nlarge singular values.\n\nFor a matrix A, the pseudo-inverse A+ is defined as the matrix that\n'solves' the least-squares problem Ax = b. If A is invertible,\nthen pinv(A) == inv(A).\n\nThe pseudo-inverse has the property that A * A+ * A = A and\nA+ * A * A+ = A+ (Moore-Penrose conditions).\n\nSpecification: pinv computes the Moore-Penrose pseudo-inverse of a matrix.\n\nThe pseudo-inverse satisfies the fundamental Moore-Penrose conditions:\n1. A * A+ * A = A  (the pseudo-inverse is a generalized inverse)\n2. A+ * A * A+ = A+  (the pseudo-inverse is reflexive)\n3. (A * A+)† = A * A+  (A * A+ is Hermitian)\n4. (A+ * A)† = A+ * A  (A+ * A is Hermitian)\n\nFor practical purposes, we focus on the first two conditions and\nthe dimensional correctness.\n\nPrecondition: True (pinv is defined for any matrix)\nPostcondition: The result is the pseudo-inverse with correct dimensions\nand satisfies the Moore-Penrose conditions.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn pinv(a: Vec<Vec<f32>>) -> (result: Vec<Vec<f32>>)\n    requires \n        a@.len() > 0,\n        forall|i: int| 0 <= i < a@.len() ==> a@[i].len() > 0,\n    ensures \n        result@.len() > 0,\n        forall|i: int| 0 <= i < result@.len() ==> result@[i].len() == a@.len(),\n        (forall|i: int, j: int| (0 <= i < a@.len() && 0 <= j < a@[i].len()) ==> a@[i][j] == 0.0f32) ==> \n            (forall|i: int, j: int| (0 <= i < result@.len() && 0 <= j < result@[i].len()) ==> result@[i][j] == 0.0f32)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0241", "language": "verus", "source": "numpy_triple", "source_id": "linalg_slogdet", "vc-description": "Compute the sign and (natural) logarithm of the determinant of a square matrix.\n\nThis function is more numerically stable than computing log(det(a)) directly,\nespecially for very small or very large determinants.\n\nFor real matrices, the sign is -1, 0, or 1.\nFor complex matrices, the sign has absolute value 1 (on the unit circle) or 0.\n\nThe determinant can be recovered as: det = sign * exp(logabsdet)\n\nSpecification: slogdet computes the sign and natural logarithm of the determinant\n\nThe function returns a tuple (sign, logabsdet) where:\n- sign is -1, 0, or 1 for real matrices\n- logabsdet is the natural log of the absolute value of the determinant\n- The original determinant can be recovered as: det = sign * exp(logabsdet)\n- The function provides a numerically stable way to compute logarithms of determinants", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn slogdet(a: Vec<Vec<f32>>) -> (result: (f32, f32))\n    requires \n        a@.len() > 0,\n        forall|i: int| 0 <= i < a@.len() ==> #[trigger] a@[i].len() == a@.len(),\n    ensures ({\n        let (sign, logabsdet) = result;\n        (sign == -1.0f32 || sign == 0.0f32 || sign == 1.0f32)\n    }),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0242", "language": "verus", "source": "numpy_triple", "source_id": "linalg_solve", "vc-description": "Solve a linear matrix equation ax = b, where a is an n×n matrix and b is a vector.\nReturns the solution vector x such that ax = b.\nFor non-empty matrices (n > 0), the solution exists and is unique when a is invertible.\n\nSpecification: solve returns a vector x such that ax = b when a is invertible.\nThis specification captures the mathematical properties of linear system solving:\n\n1. **Correctness**: The solution satisfies the matrix equation ax = b\n2. **Invertibility requirement**: Matrix a must be invertible (non-singular)\n3. **Uniqueness**: The solution is unique when it exists\n4. **Mathematical consistency**: The solution preserves linear algebra properties\n\nThe specification handles the general case where:\n- a is an n×n square matrix (represented as Vector of Vector Float)\n- b is an n-dimensional vector\n- The solution x is unique when a is invertible", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn solve(a: Vec<Vec<f64>>, b: Vec<f64>) -> (result: Vec<f64>)\n    requires \n        a.len() > 0,\n        a.len() == b.len(),\n        forall|i: int| 0 <= i < a.len() ==> a[i].len() == a.len(),\n        /* Matrix a is invertible - there exists an inverse matrix a_inv such that a * a_inv = I and a_inv * a = I */\n        exists|a_inv: Seq<Seq<f64>>| \n            a_inv.len() == a.len() &&\n            forall|k: int| 0 <= k < a_inv.len() ==> a_inv[k].len() == a.len(),\n    ensures\n        result.len() == a.len(),\n        /* Primary property: The solution satisfies ax = b */\n        /* For each row i, the sum of products a[i][j] * result[j] equals b[i] */\n        true, /* Placeholder for matrix equation ax = b */\n        /* Uniqueness: The solution is unique */\n        /* If any other vector y also satisfies ay = b, then y = result */\n        true, /* Placeholder for uniqueness property */\n        /* Mathematical consistency: The solution can be expressed as x = a^(-1)b */\n        true /* Placeholder for inverse relationship */", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0243", "language": "verus", "source": "numpy_triple", "source_id": "linalg_svd", "vc-description": "numpy.linalg.svd: Singular Value Decomposition.\n\nComputes the singular value decomposition of a matrix, factorizing it as\nA = U @ diag(S) @ Vh, where U and Vh are unitary matrices and S is a \nvector of singular values sorted in descending order.\n\nThis specification focuses on the 2D case with full_matrices=False\nand compute_uv=True (the most common use case).\n\nThe decomposition satisfies: A = U @ diag(S) @ Vh\nwhere U has orthonormal columns, Vh has orthonormal rows,\nand S contains non-negative singular values in descending order.\n\nSpecification: numpy.linalg.svd returns matrices U, S, Vh such that:\n\n1. Matrix reconstruction: A = U @ diag(S) @ Vh\n2. U has orthonormal columns (U^T @ U = I)\n3. Vh has orthonormal rows (Vh @ Vh^T = I)  \n4. S contains non-negative singular values in descending order\n\nThis captures the essential mathematical properties of SVD as implemented in NumPy.\n\nPrecondition: True (SVD is defined for any real matrix)\nPostcondition: The returned decomposition satisfies all SVD properties", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_svd(a: Vec<Vec<f32>>) -> (result: (Vec<Vec<f32>>, Vec<f32>, Vec<Vec<f32>>))\n    requires\n        a.len() > 0,\n        forall|i: int| 0 <= i < a.len() ==> a@[i].len() > 0,\n        forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() ==> a@[i].len() == a@[j].len(),\n    ensures\n        ({\n            let (u, s, vh) = result;\n            let m = a.len() as int;\n            let n = a@[0].len() as int;\n            let min_mn = if m <= n { m } else { n };\n            \n            /* Basic structural properties */\n            (u.len() == m) &&\n            (s.len() == min_mn) &&\n            (vh.len() == min_mn) &&\n            (forall|i: int| 0 <= i < u.len() ==> u@[i].len() == min_mn) &&\n            (forall|i: int| 0 <= i < vh.len() ==> vh@[i].len() == n)\n        })", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0244", "language": "verus", "source": "numpy_triple", "source_id": "linalg_svdvals", "vc-description": "numpy.linalg.svdvals: Compute singular values of a matrix.\n\nComputes the singular values of a matrix without computing the U and V matrices.\nThe singular values are the square roots of the eigenvalues of A^T @ A (or A @ A^T),\nreturned in descending order.\n\nThis is equivalent to calling numpy.linalg.svd(x, compute_uv=False).\nFor an m×n matrix, this returns min(m,n) singular values.\n\nSpecification: svdvals returns the singular values of the input matrix.\n\nThe singular values are:\n1. Non-negative real numbers\n2. Sorted in descending order\n3. Square roots of eigenvalues of x^T @ x\n4. Measure the \"magnitude\" of the matrix in each singular direction\n\nPrecondition: True (singular values are defined for any matrix)\nPostcondition: Returns singular values in descending order with mathematical properties", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn min_nat(a: nat, b: nat) -> nat {\n    if a <= b { a } else { b }\n}\n\nfn svdvals(x: Vec<Vec<i8>>) -> (result: Vec<i8>)\n    requires \n        x@.len() > 0,\n        x@.len() < usize::MAX,\n        x@[0].len() > 0,\n    ensures \n        result@.len() == min_nat(x@.len() as nat, x@[0].len() as nat),\n        /* Property 1: All singular values are non-negative */\n        forall|i: int| 0 <= i < result@.len() ==> #[trigger] result@[i] >= 0,\n        /* Property 2: Singular values are sorted in descending order */\n        forall|i: int, j: int| 0 <= i <= j < result@.len() ==> #[trigger] result@[i] >= #[trigger] result@[j],\n        /* Property 4: If the matrix is zero, all singular values are zero */\n        (forall|i: int, j: int| 0 <= i < x@.len() && 0 <= j < x@[i].len() ==> #[trigger] x@[i][j] == 0) ==>\n            (forall|i: int| 0 <= i < result@.len() ==> #[trigger] result@[i] == 0)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0245", "language": "verus", "source": "numpy_triple", "source_id": "linalg_tensordot", "vc-description": "numpy.tensordot: Compute tensor dot product along specified axes.\n\nGiven two tensors a and b, and axes, sums the products of a's and b's \nelements over the axes specified. For 1-D arrays (vectors) with axes=1,\nthis computes the inner product of vectors.\n\nThis specification focuses on the 1-D case with axes=1, which is equivalent\nto the dot product operation.\n\nSpecification: tensordot computes the tensor dot product along specified axes.\n\nFor 1-D vectors with axes=1, this is equivalent to the inner product:\nresult = sum(a[i] * b[i] for i in 0..n-1)\n\nMathematical properties:\n- Commutative: tensordot(a, b, 1) = tensordot(b, a, 1)\n- Bilinear: tensordot(α*a + β*c, b, 1) = α*tensordot(a, b, 1) + β*tensordot(c, b, 1)\n- Zero vector: tensordot(zeros, b, 1) = 0\n- Self-product: tensordot(a, a, 1) = ||a||²\n\nPrecondition: axes = 1 (for 1-D vector case)\nPostcondition: result equals the sum of element-wise products", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn dot_product_recursive(a: Seq<i32>, b: Seq<i32>, i: nat) -> int\n    decreases a.len() - i\n{\n    if i >= a.len() {\n        0\n    } else {\n        a[i as int] * b[i as int] + dot_product_recursive(a, b, i + 1)\n    }\n}\n\nspec fn dot_product(a: Seq<i32>, b: Seq<i32>) -> int {\n    dot_product_recursive(a, b, 0)\n}\n\nfn tensordot(a: Vec<i32>, b: Vec<i32>, axes: usize) -> (result: i32)\n    requires \n        a.len() == b.len(),\n        axes == 1,\n    ensures result == dot_product(a@, b@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0246", "language": "verus", "source": "numpy_triple", "source_id": "linalg_tensorinv", "vc-description": "Compute the 'inverse' of an N-dimensional array\n\nThe result is an inverse for a relative to the tensordot operation tensordot(a, b, ind), i.e., up to floating-point accuracy, tensordot(tensorinv(a), a, ind) is the identity tensor.\n\nCompute the 'inverse' of an N-dimensional array.\nFor simplicity, we implement the case where the tensor is represented as a 2D matrix\n(viewed as a flattened N-dimensional array) and we compute its matrix inverse.\nThe result should be the inverse for the tensordot operation.\n\nSpecification: tensorinv computes the tensor inverse such that when composed\nwith the original tensor via tensordot operation, it yields the identity tensor.\nThe key properties are:\n1. The result has the same square dimensions as the input\n2. The tensor inverse, when applied via tensordot, acts as a left inverse\n3. The tensor must be 'square' (equal first and last dimensions products)\n4. The index parameter must be positive", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn tensorinv(a: Vec<Vec<f32>>, ind: usize) -> (result: Vec<Vec<f32>>)\n    requires \n        a.len() > 0,\n        ind > 0,\n        forall|i: int| 0 <= i < a@.len() ==> a[i].len() == a.len(),\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result@.len() ==> result[i].len() == a.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0247", "language": "verus", "source": "numpy_triple", "source_id": "linalg_tensorsolve", "vc-description": "Solve the tensor equation a x = b for x.\n\nThis function solves for x in the tensor equation a x = b, where:\n- a is a coefficient tensor that can be reshaped to a square matrix\n- b is the right-hand tensor  \n- x is the solution tensor\n\nFor simplicity, we model this as solving a square linear system where the \ncoefficient matrix a is reshaped from tensor form to a 2D matrix, and the \nsolution is reshaped back to tensor form.\n\nSpecification: tensorsolve solves the tensor equation a x = b for x.\n\nThis specification captures the mathematical properties of tensor equation solving:\n\n1. **Correctness**: The solution x satisfies the matrix equation a x = b\n2. **Invertibility**: The coefficient matrix a must be invertible\n3. **Uniqueness**: The solution is unique when a is invertible\n\nThe specification handles the basic case where:\n- a is an n×n coefficient matrix (representing a reshaped tensor)\n- b is an n-dimensional right-hand vector\n- x is the n-dimensional solution vector", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_square_matrix(a: Seq<Seq<f64>>) -> bool {\n    a.len() > 0 && forall|i: int| 0 <= i < a.len() ==> a[i].len() == a.len()\n}\n\nspec fn is_invertible_matrix(a: Seq<Seq<f64>>) -> bool {\n    is_square_matrix(a) &&\n    exists|a_inv: Seq<Seq<f64>>| \n        is_square_matrix(a_inv) && \n        a_inv.len() == a.len() &&\n        forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() ==> #[trigger] a[i][j] == a[i][j]\n}\n\nfn tensorsolve(a: Vec<Vec<f64>>, b: Vec<f64>) -> (result: Vec<f64>)\n    requires\n        a.len() > 0,\n        forall|i: int| 0 <= i < a@.len() ==> a@[i].len() == a@.len(),\n        b@.len() == a@.len(),\n        is_square_matrix(a@.map(|i, row: Vec<f64>| row@)),\n        is_invertible_matrix(a@.map(|i, row: Vec<f64>| row@)),\n    ensures\n        result@.len() == b@.len(),\n        forall|i: int| 0 <= i < a@.len() ==> #[trigger] b@[i] == b@[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0248", "language": "verus", "source": "numpy_triple", "source_id": "linalg_trace", "vc-description": "Return the sum along diagonals of the array\n\nIf a is 2-D, returns the sum along the diagonal. If a has more dimensions, then axes along which the trace is taken can be specified.\n\nReturns the sum along the main diagonal of a square matrix.\nThe trace is the sum of diagonal elements at positions (i, i) for i = 0 to n-1.\n\nSpecification: trace computes the sum of the main diagonal elements of a square matrix.\nThe trace is mathematically defined as the sum of elements x[i][i] for i from 0 to n-1.\nThis is a fundamental operation in linear algebra with important mathematical properties:\n- trace(A + B) = trace(A) + trace(B) (linearity)\n- trace(cA) = c * trace(A) (scalar multiplication)\n- trace(A) = trace(A^T) (transpose invariance)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn trace(x: Vec<Vec<f32>>) -> (result: f32)\n    requires \n        x@.len() > 0,\n        forall|i: int| 0 <= i < x@.len() ==> x@[i].len() == x@.len(),\n    ensures \n        true, /* The trace equals the sum of diagonal elements matrix[i][i] for i in 0..n-1 */\n        forall|i: int| 0 <= i < x@.len() ==> x@[i][i] != 0.0f32 ==> result != 0.0f32,", "vc-code": "{\n    // impl-start\n    assume(false);\n    0.0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0249", "language": "verus", "source": "numpy_triple", "source_id": "linalg_vecdot", "vc-description": "Compute the vector dot product of two vectors\n\nSpecification: vecdot computes the mathematical dot product as the sum of element-wise products.\nThis captures the mathematical definition: a · b = Σ(i=0 to n-1) a_i * b_i.\n\nKey properties:\n- Commutativity: vecdot(x1, x2) = vecdot(x2, x1)\n- Linearity: vecdot(c*x1, x2) = c * vecdot(x1, x2)\n- Zero vector: vecdot(0, x) = 0\n- Self-dot gives sum of squares: vecdot(x, x) = Σ(x_i²)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn dot_product_spec(x1: Seq<i32>, x2: Seq<i32>) -> int\n    decreases x1.len()\n{\n    if x1.len() == 0 || x1.len() != x2.len() {\n        0\n    } else {\n        x1[0] * x2[0] + dot_product_spec(x1.skip(1), x2.skip(1))\n    }\n}\n\nfn vecdot(x1: Vec<i32>, x2: Vec<i32>) -> (result: i32)\n    requires x1.len() == x2.len(),\n    ensures \n        result as int == dot_product_spec(x1@, x2@),\n        result as int == dot_product_spec(x2@, x1@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0250", "language": "verus", "source": "numpy_triple", "source_id": "linalg_vector_norm", "vc-description": "numpy.linalg.vector_norm: Compute the p-norm of a vector for a given order p.\n\nThis function computes vector norms of different orders (p-norms).\nFor a vector x and order p, the p-norm is defined as:\n||x||_p = (sum(|x[i]|^p))^(1/p) for p ≥ 1\n\nSpecial cases:\n- p = 1: Manhattan norm (sum of absolute values)\n- p = 2: Euclidean norm (square root of sum of squares)\n- p = ∞: Maximum norm (largest absolute value)\n- p = -∞: Minimum norm (smallest absolute value)\n- p = 0: Zero norm (count of non-zero elements)\n\nThis implementation focuses on the most common p-norm cases for 1D vectors.\n\nSpecification: vector_norm computes the p-norm of a vector for various values of p.\n\nThe p-norm is a generalization of the common vector norms used in numerical computing.\nThis specification covers the mathematical definition and key properties of p-norms.\n\nMathematical definition:\n- For p ≥ 1: ||x||_p = (Σᵢ |xᵢ|^p)^(1/p)\n- For p = 1: ||x||_1 = Σᵢ |xᵢ| (Manhattan norm)\n- For p = 2: ||x||_2 = √(Σᵢ xᵢ²) (Euclidean norm)\n- For p = 0: ||x||_0 = count of non-zero elements\n\nKey properties verified:\n1. Definition: For p ≥ 1, result equals (sum of |xi|^p)^(1/p)\n2. Non-negativity: norm(x, p) ≥ 0 for all x and valid p\n3. Definiteness: norm(x, p) = 0 iff x is zero vector (for p > 0)\n4. Special cases: p=1 (Manhattan), p=2 (Euclidean), p=0 (zero norm)\n5. Empty vector: norm of empty vector is 0\n\nPreconditions:\n- p must be a non-negative real number\n- For p = 0, it counts non-zero elements (special case)\n- For p ≥ 1, it computes the standard p-norm", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn vector_norm(x: Vec<i8>, p: i8) -> (result: i8)\n    requires p as int >= 0,\n    ensures \n        result as int >= 0,\n        x@.len() == 0 ==> result as int == 0,\n        result as int >= 0", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0251", "language": "verus", "source": "numpy_triple", "source_id": "logic_functions_all", "vc-description": "Test whether all array elements evaluate to True.\nElements are considered True if they are non-zero.\nNaN, positive infinity and negative infinity evaluate to True.\n\nSpecification: all returns True if and only if all elements are non-zero.\nThis includes proper handling of special float values:\n- NaN evaluates to True (it is not equal to zero)\n- Positive and negative infinity evaluate to True (they are not equal to zero)\n- Only 0.0 and -0.0 evaluate to False\n\nMathematical properties:\n- Empty vector returns True (vacuous truth)\n- all is monotonic: if all(a) is True and b has same non-zero elements, then all(b) is True\n- all(a) = not(any(map(λx. x = 0, a))) - equivalent to checking no element is zero\n\nSanity checks:\n- For empty vector (n = 0), the result is True by vacuous truth\n- For single element [x], result is True iff x ≠ 0\n- For vector with all non-zero elements, result is True\n- For vector with at least one zero element, result is False\n\nAdditional properties:\n- Idempotent: all(all(a)) = all(a) (when treating Bool as numeric)\n- Distributive over logical AND: all(a) ∧ all(b) → all(pointwise_and(a, b))\n- Relationship to logical AND reduction: all(a) = fold(∧, true, map(≠ 0, a))", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn all(a: Vec<f32>) -> (result: bool)\n    ensures\n        result == (forall|i: int| 0 <= i < a@.len() ==> a@[i] != 0.0f32),\n        (a@.len() == 0 ==> result == true),\n        ((exists|i: int| 0 <= i < a@.len() && a@[i] == 0.0f32) ==> result == false),\n        ((forall|i: int| 0 <= i < a@.len() ==> a@[i] != 0.0f32) ==> result == true),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0252", "language": "verus", "source": "numpy_triple", "source_id": "logic_functions_allclose", "vc-description": "numpy.allclose: Returns True if two arrays are element-wise equal within a tolerance.\n\nThe tolerance values are positive, typically very small numbers. The\nrelative difference (rtol * abs(b)) and the absolute difference\natol are added together to compare against the absolute difference\nbetween a and b.\n\nFor each element, the condition is:\nabsolute(a - b) <= (atol + rtol * absolute(b))\n\nThis function returns True if ALL elements satisfy this condition,\nFalse otherwise.\n\nSpecification: allclose returns true iff all elements are within tolerance.\n\nPrecondition: rtol >= 0 and atol >= 0 (tolerance values must be non-negative)\nPostcondition: result = true iff all elements satisfy the tolerance condition\n               abs(a[i] - b[i]) <= atol + rtol * abs(b[i]) for all i", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn int_abs(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}", "vc-helpers": "", "vc-spec": "fn allclose(a: Vec<i8>, b: Vec<i8>, rtol: i8, atol: i8) -> (result: bool)\n    requires \n        a.len() == b.len(),\n        rtol >= 0,\n        atol >= 0,\n    ensures \n        result == (forall|i: int| 0 <= i < a@.len() ==> \n            int_abs((a[i] - b[i]) as int) <= (atol as int + rtol as int * int_abs(b[i] as int)))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0253", "language": "verus", "source": "numpy_triple", "source_id": "logic_functions_any", "vc-description": "Test whether any element in a vector evaluates to True.\n\nFor numeric types, returns true if any element is non-zero.\nSpecial values like NaN, positive/negative infinity are considered True.\nThis follows NumPy's convention where non-zero values are truthy.\n\nThis is a reduction operation that performs logical OR across all elements,\ntreating non-zero values as True and zero as False.\n\nSpecification: `any` returns true if and only if at least one element in the vector is non-zero.\n\nThe specification captures comprehensive mathematical properties:\n1. Logical equivalence: result is true iff there exists a non-zero element\n2. Completeness: result is false iff all elements are zero\n3. Empty vector behavior: returns false for empty vectors\n4. Monotonicity: adding more elements can only increase the chance of being true\n\nThis matches NumPy's behavior where:\n- Non-zero values (including NaN, ±∞) evaluate to True\n- Only zero evaluates to False\n- Empty arrays return False", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn any(v: Vec<f32>) -> (result: bool)\n    ensures \n        (result == true <==> exists|i: int| 0 <= i < v@.len() && v@[i] != 0.0f32) &&\n        (result == false <==> forall|i: int| 0 <= i < v@.len() ==> v@[i] == 0.0f32) &&\n        (v@.len() == 0 ==> result == false) &&\n        (forall|i: int| 0 <= i < v@.len() ==> v@[i] == 0.0f32 ==> result == false) &&\n        (exists|i: int| 0 <= i < v@.len() && v@[i] != 0.0f32 ==> result == true) &&\n        (result == true || result == false) &&\n        !(result == true && result == false)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0254", "language": "verus", "source": "numpy_triple", "source_id": "logic_functions_array_equal", "vc-description": "numpy.array_equal: True if two arrays have the same shape and elements, False otherwise.\n\nCompares two arrays element-wise and returns a single boolean value indicating\nwhether the arrays are completely equal. Unlike element-wise comparison functions,\nthis returns a single boolean result for the entire comparison.\n\nThe function returns True if and only if:\n1. The arrays have the same shape (enforced by Vector type system)\n2. All corresponding elements are equal\n\nFor Vector types, the shape constraint is automatically satisfied by the type system,\nso we only need to check element-wise equality.\n\nSpecification: numpy.array_equal returns True if and only if all corresponding \nelements in the two vectors are equal.\n\nPrecondition: True (vectors have the same length by the type system)\nPostcondition: The result is True if and only if all corresponding elements are equal\n\nMathematical properties:\n- Array equality is reflexive: arrayEqual(a, a) = True for any array a\n- Array equality is symmetric: arrayEqual(a, b) = arrayEqual(b, a)\n- Array equality is transitive: if arrayEqual(a, b) and arrayEqual(b, c), then arrayEqual(a, c)\n- Empty arrays are equal: arrayEqual([], []) = True (vacuous truth)\n- arrayEqual(a, b) = all(elementwise_equal(a, b)) - equivalent to checking all elements are equal\n\nSanity checks:\n- For empty vectors (n = 0), the result is True by vacuous truth\n- For single element vectors [x] and [y], result is True iff x == y\n- For identical vectors, result is True\n- For vectors differing in any element, result is False\n- arrayEqual is the logical AND of all element-wise comparisons", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn array_equal<T>(a1: &Vec<T>, a2: &Vec<T>) -> (result: bool)\n    where T: PartialEq<T>,\n    requires a1.len() == a2.len(),\n    ensures \n        result == true <==> (forall|i: int| 0 <= i < a1.len() as int ==> a1@[i] == a2@[i]) &&\n        (a1.len() == 0 ==> result == true) &&\n        (exists|i: int| 0 <= i < a1.len() as int && !(a1@[i] == a2@[i]) ==> result == false)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0255", "language": "verus", "source": "numpy_triple", "source_id": "logic_functions_array_equiv", "vc-description": "numpy.array_equiv: Returns True if input arrays are shape consistent and all elements equal.\n\nShape consistent means they are either the same shape, or one input array\ncan be broadcasted to create the same shape as the other one.\n\nFor 1D arrays of the same size, this means element-wise comparison.\nThe function returns True if all corresponding elements are equal.\n\nSpecification: array_equiv returns true iff all corresponding elements are equal.\n\nPrecondition: True (works for any two vectors of the same size)\nPostcondition: result = true iff all elements at corresponding indices are equal\n\nMathematical properties satisfied:\n- Reflexivity: array_equiv a a = true (any array is equivalent to itself)\n- Symmetry: array_equiv a b = array_equiv b a (equivalence is symmetric)\n- Element-wise equality: result = true iff ∀ i, a1[i] = a2[i]\n- Empty array handling: for n=0, the result is vacuously true\n- Finite precision: uses Float equality (may have precision limitations)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn array_equiv(a1: Vec<f32>, a2: Vec<f32>) -> (result: bool)\n    requires a1.len() == a2.len(),\n    ensures result == (forall|i: int| 0 <= i < a1@.len() ==> a1@[i] == a2@[i])", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0256", "language": "verus", "source": "numpy_triple", "source_id": "logic_functions_bitwise_and", "vc-description": "Compute the bit-wise AND of two vectors element-wise.\nComputes the bit-wise AND of the underlying binary representation of\nthe natural numbers in the input vectors.\n\nSpecification: bitwise_and computes element-wise bitwise AND operation \n\nThis specification captures the mathematical properties of bitwise AND:\n- Commutativity: a & b = b & a\n- Associativity: (a & b) & c = a & (b & c)\n- Identity with all bits set: a & (-1) = a (but using max value for Nat)\n- Absorption with zero: a & 0 = 0\n- Idempotent: a & a = a\n- Monotonicity: if a ≤ b, then a & c ≤ b & c\n\n/* Commutativity property */\n\n/* Absorption with zero */\n\n/* Idempotent property */\n\n/* Result is bounded by both operands */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn bitwise_and(x1: &Vec<u8>, x2: &Vec<u8>) -> (result: Vec<u8>)\n    requires x1@.len() == x2@.len(),\n    ensures \n        result@.len() == x1@.len(),\n        forall|i: int| 0 <= i < result@.len() ==> \n            result@[i] == (x1@[i] & x2@[i]) &&\n\n            (x1@[i] & x2@[i]) == (x2@[i] & x1@[i]) &&\n\n            (x1@[i] & 0) == 0 &&\n\n            (x1@[i] & x1@[i]) == x1@[i] &&\n\n            result@[i] <= x1@[i] && result@[i] <= x2@[i]", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0257", "language": "verus", "source": "numpy_triple", "source_id": "logic_functions_bitwise_not", "vc-description": "Compute bit-wise inversion, or bit-wise NOT, element-wise.\n\nComputes the bit-wise NOT of the underlying binary representation of\nthe integers in the input arrays. This ufunc implements the C/Python\noperator ~.\n\nFor signed integer inputs, the bit-wise NOT of the absolute value is\nreturned. In a two's-complement system, this operation effectively flips\nall the bits, which results in -(x + 1). This is the most common method\nof representing signed integers on computers.\n\nReturns an array of the same shape as x, containing the bitwise NOT values.\n\nSpecification: numpy.bitwise_not returns a vector where each element is the\nbitwise NOT of the corresponding element in x.\n\nPrecondition: True (no special preconditions for bitwise NOT)\nPostcondition: For all indices i, result[i] = -(x[i] + 1)\n\nThis specification captures the mathematical property that bitwise NOT\nof an integer x in two's complement representation equals -(x + 1).\n\nKey properties:\n- Bitwise NOT is its own inverse: ~~x = x\n- For any integer x: ~x = -(x + 1)\n- The operation is element-wise for arrays", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_bitwise_not(x: Vec<i8>) -> (result: Vec<i8>)\n    ensures \n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] as int == -(x[i] as int + 1)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0258", "language": "verus", "source": "numpy_triple", "source_id": "logic_functions_bitwise_or", "vc-description": "numpy.bitwise_or: Compute the bit-wise OR of two arrays element-wise.\n\nComputes the bit-wise OR of the underlying binary representation of\nthe integers in the input arrays. This ufunc implements the C/Python\noperator |.\n\nFor integer inputs, the result is the bitwise OR of the binary\nrepresentations. For boolean inputs, it performs logical OR.\n\nSpecification: numpy.bitwise_or returns a vector where each element is the \nbitwise OR of the corresponding elements from x1 and x2.\n\nPrecondition: True (no special preconditions for bitwise OR)\nPostcondition: For all indices i, result[i] = bitwise_or(x1[i], x2[i])\n\nMathematical properties:\n- Commutative: bitwise_or(x1[i], x2[i]) = bitwise_or(x2[i], x1[i])\n- Identity: bitwise_or(x[i], 0) = x[i]\n- Idempotent: bitwise_or(x[i], x[i]) = x[i]\n\n/* Axiomatically define bitwise OR operation for integers */\n\n/* Bitwise OR is commutative */\n\n/* Bitwise OR with zero is identity */\n\n/* Bitwise OR is idempotent */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn bitwise_or(x: i32, y: i32) -> i32;\n\nproof fn bitwise_or_comm(x: i32, y: i32)\n    ensures bitwise_or(x, y) == bitwise_or(y, x)\n{\n    assume(false);\n}\n\nproof fn bitwise_or_zero(x: i32)\n    ensures bitwise_or(x, 0) == x\n{\n    assume(false);\n}\n\nproof fn bitwise_or_idempotent(x: i32)\n    ensures bitwise_or(x, x) == x\n{\n    assume(false);\n}\n\nfn numpy_bitwise_or(x1: Vec<i8>, x2: Vec<i8>) -> (result: Vec<i8>)\n    requires x1.len() == x2.len(),\n    ensures\n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] as i32 == bitwise_or(x1[i] as i32, x2[i] as i32),\n        forall|i: int| 0 <= i < result.len() ==> bitwise_or(x1[i] as i32, x2[i] as i32) == bitwise_or(x2[i] as i32, x1[i] as i32),\n        forall|i: int| 0 <= i < result.len() ==> bitwise_or(x1[i] as i32, 0) == x1[i] as i32,\n        forall|i: int| 0 <= i < result.len() ==> bitwise_or(x1[i] as i32, x1[i] as i32) == x1[i] as i32,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0259", "language": "verus", "source": "numpy_triple", "source_id": "logic_functions_bitwise_xor", "vc-description": "numpy.bitwise_xor: Compute the bit-wise XOR of two arrays element-wise.\n\nComputes the bit-wise XOR of the underlying binary representation of\nthe integers in the input arrays. This ufunc implements the C/Python\noperator ^.\n\nThe function works on integer and boolean types, computing the XOR\nof corresponding elements from two input vectors.\n\nSpecification: numpy.bitwise_xor returns a vector where each element is the \nbitwise XOR of the corresponding elements from x1 and x2.\n\nPrecondition: All elements are non-negative (to use well-defined bitwise operations)\nPostcondition: For all indices i, result[i] = x1[i] XOR x2[i]\n\nMathematical properties:\n- XOR is commutative: x1[i] XOR x2[i] = x2[i] XOR x1[i]\n- XOR is associative: (a XOR b) XOR c = a XOR (b XOR c)\n- XOR with zero is identity: x XOR 0 = x\n- XOR is self-inverse: x XOR x = 0", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn bitwise_xor(x1: Vec<u8>, x2: Vec<u8>) -> (result: Vec<u8>)\n    requires \n        x1.len() == x2.len(),\n    ensures\n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> result@[i] == (x1@[i] ^ x2@[i]),\n        forall|i: int| 0 <= i < result.len() && x1@[i] == 0 ==> result@[i] == x2@[i],\n        forall|i: int| 0 <= i < result.len() && x2@[i] == 0 ==> result@[i] == x1@[i],\n        forall|i: int| 0 <= i < result.len() && x1@[i] == x2@[i] ==> result@[i] == 0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0260", "language": "verus", "source": "numpy_triple", "source_id": "logic_functions_equal", "vc-description": "numpy.equal: Return (x1 == x2) element-wise.\n\nPerforms element-wise comparison of two arrays and returns a boolean array\nof the same shape indicating where the corresponding elements are equal.\n\nFor scalar inputs, returns a single boolean value. For array inputs of the\nsame shape, returns an array of booleans. This function is the basis for\nthe == operator when used with numpy arrays.\n\nSpecification: numpy.equal returns a boolean vector where each element indicates\nwhether the corresponding elements in x1 and x2 are equal.\n\nPrecondition: True (arrays have the same shape by the type system)\nPostcondition: For all indices i, result[i] = (x1[i] == x2[i])\n\nThis specification captures both the element-wise behavior and the mathematical\nproperty that equality comparison is performed at each position.\n\nKey Properties:\n1. Element-wise comparison: Each position is compared independently\n2. Boolean result: Returns true/false for each position \n3. Reflexivity: equal(x, x) returns all true\n4. Symmetry: equal(x, y) = equal(y, x)\n5. Result shape matches input shape", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_equal<T>(x1: Vec<T>, x2: Vec<T>) -> (result: Vec<bool>)\n    requires \n        x1.len() == x2.len(),\n    ensures\n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == (x1[i] == x2[i]),\n        forall|i: int| 0 <= i < result.len() ==> (result[i] == true || result[i] == false),\n        x1@ == x2@ ==> forall|i: int| 0 <= i < result.len() ==> result[i] == true", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0261", "language": "verus", "source": "numpy_triple", "source_id": "logic_functions_greater", "vc-description": "numpy.greater: Return the truth value of (x1 > x2) element-wise.\n\nReturns a boolean vector where each element indicates whether the\ncorresponding element in x1 is greater than the corresponding element in x2.\n\nThis is equivalent to x1 > x2 in terms of array broadcasting.\n\nFollows IEEE 754 standard for floating point comparisons:\n- Comparisons with NaN always return false\n- Returns boolean array of same shape as inputs\n\nSpecification: numpy.greater returns a boolean vector where each element\nis true if and only if the corresponding element in x1 is greater than\nthe corresponding element in x2.\n\nThis specification captures:\n1. Basic element-wise comparison semantics\n2. Antisymmetry property of greater-than relation\n3. Transitivity when combined with other comparisons\n4. IEEE 754 compliant NaN handling\n5. Consistency with standard mathematical ordering", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_greater(x1: &Vec<i8>, x2: &Vec<i8>) -> (result: Vec<bool>)\n    requires x1.len() == x2.len(),\n    ensures \n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> \n            (result[i] == (x1[i] as int > x2[i] as int)) &&\n            (result[i] == true ==> !(x2[i] as int > x1[i] as int)) &&\n            (result[i] == true || result[i] == false)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0262", "language": "verus", "source": "numpy_triple", "source_id": "logic_functions_greater_equal", "vc-description": "numpy.greater_equal: Return the truth value of (x1 >= x2) element-wise.\n\nReturns a boolean vector where each element indicates whether the\ncorresponding element in x1 is greater than or equal to the corresponding \nelement in x2.\n\nThis is equivalent to x1 >= x2 in terms of array broadcasting.\n\nSpecification: numpy.greater_equal returns a boolean vector where each element\nis true if and only if the corresponding element in x1 is greater than or equal\nto the corresponding element in x2.\n\nPrecondition: True (no special preconditions for comparison)\nPostcondition: For all indices i, result[i] = true ↔ x1[i] >= x2[i]\n\nAdditional properties:\n- The result is the element-wise negation of less(x1, x2)\n- Reflexivity: greater_equal(x, x) returns all true\n- Antisymmetry: If greater_equal(x1, x2)[i] = true and greater_equal(x2, x1)[i] = true,\n                then x1[i] = x2[i]\n- Transitivity: If greater_equal(x1, x2)[i] = true and greater_equal(x2, x3)[i] = true,\n                then greater_equal(x1, x3)[i] = true\n- For NaN values: comparison with NaN always returns false\n\n/* Reflexivity: comparing vector with itself yields all true */\n\n/* Antisymmetry with equality */\n\n/* Boolean result: each element is either true or false */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_greater_equal(x1: Vec<i8>, x2: Vec<i8>) -> (result: Vec<bool>)\n    requires x1.len() == x2.len(),\n    ensures \n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> (result[i] <==> x1@[i] as int >= x2@[i] as int),\n\n        x1@ == x2@ ==> forall|i: int| 0 <= i < result.len() ==> result[i] == true,\n\n        forall|i: int| 0 <= i < result.len() ==> \n            (result[i] == true && x2@[i] as int >= x1@[i] as int) ==> x1@[i] as int == x2@[i] as int,\n\n        forall|i: int| 0 <= i < result.len() ==> (result[i] == true || result[i] == false),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0263", "language": "verus", "source": "numpy_triple", "source_id": "logic_functions_isclose", "vc-description": "Returns a boolean array where two arrays are element-wise equal within a tolerance.\nFor finite values, isclose uses the equation: absolute(a - b) <= (atol + rtol * absolute(b))\nwhere `b` is treated as the reference value.\n\nSpecification: isclose returns a boolean array indicating element-wise closeness within tolerance", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn isclose(a: Vec<f32>, b: Vec<f32>, rtol: f32, atol: f32, equal_nan: bool) -> (result: Vec<bool>)\n    requires \n        a@.len() == b@.len(),\n    ensures\n        result@.len() == a@.len(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0264", "language": "verus", "source": "numpy_triple", "source_id": "logic_functions_iscomplex", "vc-description": "Returns a bool array, where True if input element is complex.\nReturns a bool array, where True if input element has non-zero imaginary part.\nFor complex numbers, checks if imaginary part is non-zero.\nFor real numbers, returns false for all elements.\nSpecification: iscomplex returns true for elements with non-zero imaginary parts,\nfalse for elements with zero imaginary parts, with the following properties:\n1. Basic definition: returns true iff imaginary part is non-zero\n2. Real number detection: pure real numbers (imag = 0) return false\n3. Complex number detection: numbers with non-zero imaginary part return true\n4. Idempotent on boolean interpretation: the mathematical meaning is preserved\n5. Element-wise operation: each element is tested independently\n\n/* Structure representing a complex number with float components */\n\n/* The real part of the complex number */\n\n/* The imaginary part of the complex number */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nstruct Complex {\n\n    real: f64,\n\n    imag: f64,\n}", "vc-helpers": "", "vc-spec": "fn is_complex(x: &Vec<Complex>) -> (result: Vec<bool>)\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < x@.len() ==> result@[i] == (x@[i].imag != 0.0),\n        forall|i: int| 0 <= i < x@.len() ==> (x@[i].imag == 0.0 ==> result@[i] == false),\n        forall|i: int| 0 <= i < x@.len() ==> (x@[i].imag != 0.0 ==> result@[i] == true),\n        forall|i: int| 0 <= i < x@.len() ==> (result@[i] == true ==> x@[i].imag != 0.0),\n        forall|i: int| 0 <= i < x@.len() ==> (result@[i] == false ==> x@[i].imag == 0.0)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0265", "language": "verus", "source": "numpy_triple", "source_id": "logic_functions_iscomplexobj", "vc-description": "Check for a complex type or an array of complex numbers\n\nThe type of the input is checked, not the value. Even if the input\nhas an imaginary part equal to zero, iscomplexobj evaluates to True.\n\nParameters\n----------\nx : any\n    The input can be of any type and shape.\n\nReturns\n-------\niscomplexobj : bool\n    The return value, True if x is of a complex type or has at least\n    one complex element.\n\nCheck if a vector contains complex numbers\n\nSpecification: iscomplexobj returns True for complex type vectors.\nThis function checks the type, not the values - even complex numbers\nwith zero imaginary part are considered complex objects.\n\nKey properties:\n- Always returns true for vectors of complex numbers\n- Type-based checking: independent of actual values\n- Zero complex numbers (0+0i) are still complex objects\n- Complex vectors with any values are complex objects\n\nMathematical properties:\n- Type consistency: all Complex vectors are complex objects\n- Value independence: result depends only on type, not values\n- Idempotent: checking complex vectors always yields true", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* Complex number with real and imaginary parts */\n#[derive(PartialEq, Structural)]\npub struct Complex {\n    pub re: i32,\n    pub im: i32,\n}", "vc-helpers": "", "vc-spec": "fn iscomplexobj(x: Vec<Complex>) -> (result: bool)\n    ensures \n        result == true", "vc-code": "{\n    // impl-start\n    assume(false);\n    true\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0266", "language": "verus", "source": "numpy_triple", "source_id": "logic_functions_isfinite", "vc-description": "Test element-wise for finiteness (not infinity and not NaN)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn is_finite_f32(x: f32) -> bool;\nspec fn is_infinite_f32(x: f32) -> bool;\nspec fn is_nan_f32(x: f32) -> bool;", "vc-helpers": "", "vc-spec": "fn isfinite(x: Vec<f32>) -> (result: Vec<bool>)\n    requires x@.len() > 0,\n    ensures \n        result@.len() == x@.len(),\n        forall|i: int| 0 <= i < x@.len() ==> {\n            &&& (result@[i] == (!is_infinite_f32(x@[i]) && !is_nan_f32(x@[i])))\n            &&& (result@[i] == true <==> is_finite_f32(x@[i]))\n            &&& (result@[i] == false <==> (is_nan_f32(x@[i]) || is_infinite_f32(x@[i])))\n            &&& (x@[i] == 0.0f32 ==> result@[i] == true)\n            &&& (result@[i] == false ==> (is_nan_f32(x@[i]) || is_infinite_f32(x@[i])))\n            &&& (result@[i] == true ==> !is_nan_f32(x@[i]) && !is_infinite_f32(x@[i]))\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0267", "language": "verus", "source": "numpy_triple", "source_id": "logic_functions_isinf", "vc-description": "numpy.isinf: Test element-wise for positive or negative infinity\nReturns a boolean array of the same shape as x, True where x == +/-inf, otherwise False.\nURL: https://numpy.org/doc/stable/reference/generated/numpy.isinf.html\nCategory: Array contents testing\n\nTest element-wise for positive or negative infinity in a vector\n\nSpecification: isinf returns true for positive or negative infinity, false otherwise.\n\n    This function tests each element according to IEEE 754 floating-point standard:\n    - Returns true if the element is positive infinity or negative infinity\n    - Returns false for all other values including NaN, finite numbers, and zero\n\n    Mathematical properties:\n    1. Infinity detection: result[i] = true iff x[i] is infinite\n    2. Distinction from NaN: infinity and NaN are mutually exclusive\n    3. Result preserves shape: output vector has same length as input\n    4. Finite values: All normal, subnormal, and zero values return false\n    5. Specific infinities: Both positive and negative infinity are correctly identified\n\n/* Ghost specification function to represent IEEE 754 infinity test */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_infinite(x: f64) -> bool;", "vc-helpers": "", "vc-spec": "fn isinf(x: Vec<f64>) -> (result: Vec<bool>)\n    requires x.len() < usize::MAX,\n    ensures \n        result.len() == x.len(),\n        forall|i: int| 0 <= i < x.len() ==> {\n            result[i] == is_infinite(x@[i])\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0268", "language": "verus", "source": "numpy_triple", "source_id": "logic_functions_isnan", "vc-description": "Test element-wise for NaN and return result as a boolean array.\n\nSpecification: isnan returns true for NaN values and false otherwise.\nThe function correctly identifies NaN values according to IEEE 754 standard.\n\nMathematical properties:\n1. NaN detection: result[i] = true iff x[i] is NaN\n2. NaN ≠ NaN property: if x[i].isNaN then x[i] ≠ x[i]\n3. Result preserves shape: output vector has same length as input\n4. Non-NaN values: For all finite values, the result is false\n5. Complement property: isnan is the complement of (isfinite ∨ isinfinite)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn isnan(x: Vec<f64>) -> (result: Vec<bool>)\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < x@.len() ==> (result[i] == true <==> x[i] != x[i]),\n        forall|i: int| 0 <= i < x@.len() ==> (result[i] == true ==> x[i] != x[i]),\n        forall|i: int| 0 <= i < x@.len() ==> (x[i] == x[i] ==> result[i] == false),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0269", "language": "verus", "source": "numpy_triple", "source_id": "logic_functions_isnat", "vc-description": "Test element-wise for NaT (not a time) and return result as a boolean array.\n\nThis function checks each element of a datetime64 array to determine if it\nrepresents NaT (Not a Time), which is the datetime equivalent of NaN.\n\nReturns true for NaT values and false for all valid datetime values.\nThe function is the datetime analog of isnan for floating point values.\n\nSpecification: isnat returns true for NaT values and false otherwise.\nThe function correctly identifies NaT values in datetime64 arrays.\n\nMathematical properties:\n1. NaT detection: result[i] = true iff x[i] is NaT\n2. Valid datetime detection: result[i] = false iff x[i] is a valid datetime\n3. Result preserves shape: output vector has same length as input\n4. Exhaustive coverage: every element is either NaT or a valid datetime\n\nThis is the datetime analog of isnan for floating point NaN values.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n#[derive(PartialEq, Eq, Clone, Copy)]\npub enum DateTime64 {\n    Valid(i64),\n    Nat,\n}", "vc-helpers": "", "vc-spec": "fn isnat(x: Vec<DateTime64>) -> (result: Vec<bool>)\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < x.len() ==> \n            (result@.index(i) == true <==> x@.index(i) == DateTime64::Nat),\n        forall|i: int| 0 <= i < x.len() ==> \n            (result@.index(i) == false <==> exists|val: i64| x@.index(i) == DateTime64::Valid(val)),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0270", "language": "verus", "source": "numpy_triple", "source_id": "logic_functions_isneginf", "vc-description": "Test element-wise for negative infinity, return result as bool array.\n\nThis function tests each element according to IEEE 754 floating-point standard:\n- Returns true if the element is negative infinity (-∞)\n- Returns false for all other values including positive infinity, NaN, finite numbers, and zero\n\nMathematical properties:\n1. Negative infinity detection: result[i] = true iff x[i] is negative infinity\n2. Distinction from positive infinity: only negative infinity returns true\n3. Distinction from NaN: negative infinity and NaN are mutually exclusive\n4. Result preserves shape: output vector has same length as input\n5. Finite values: All normal, subnormal, and zero values return false", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_neg_infinity(x: f32) -> bool;\n\nfn isneginf(x: Vec<f32>) -> (result: Vec<bool>)\n    requires x@.len() > 0,\n    ensures\n        result@.len() == x@.len(),\n        forall|i: int| 0 <= i < x@.len() ==> {\n            &&& (result@[i] == is_neg_infinity(x@[i]))\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0271", "language": "verus", "source": "numpy_triple", "source_id": "logic_functions_isposinf", "vc-description": "Test element-wise for positive infinity, return result as bool array.\n\nThis function tests each element according to IEEE 754 floating-point standard:\n- Returns true if the element is positive infinity (+∞)\n- Returns false for all other values including negative infinity, NaN, finite numbers, and zero\n\nMathematical properties:\n1. Positive infinity detection: result[i] = true iff x[i] is positive infinity\n2. Distinction from negative infinity: only positive infinity returns true\n3. Distinction from NaN: positive infinity and NaN are mutually exclusive\n4. Result preserves shape: output vector has same length as input\n5. Finite values: All normal, subnormal, and zero values return false", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_pos_inf(x: i32) -> bool {\n    x == 0x7f800000i32\n}\n\nspec fn is_neg_inf(x: i32) -> bool {\n    x == 0xff800000u32 as i32\n}\n\nspec fn is_nan(x: i32) -> bool {\n    (x & 0x7f800000i32) == 0x7f800000i32 && (x & 0x7fffffi32) != 0\n}\n\nspec fn is_finite(x: i32) -> bool {\n    (x & 0x7f800000i32) != 0x7f800000i32\n}\n\nfn isposinf(x: Vec<i32>) -> (result: Vec<bool>)\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < x.len() ==> {\n            /* Primary property: result is true iff input is positive infinity */\n            result[i] == is_pos_inf(x[i]) &&\n            /* Sanity checks: finite values return false */\n            (is_finite(x[i]) ==> result[i] == false) &&\n            /* Negative infinity returns false */\n            (is_neg_inf(x[i]) ==> result[i] == false) &&\n            /* NaN is not positive infinity */\n            (is_nan(x[i]) ==> result[i] == false) &&\n            /* Zero is not positive infinity */\n            (x[i] == 0 ==> result[i] == false) &&\n            /* Mathematical property: if result is true, then x is positive infinity */\n            (result[i] == true ==> is_pos_inf(x[i])) &&\n            /* Exclusivity: cannot be both positive infinity and NaN */\n            (result[i] == true ==> !is_nan(x[i]))\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0272", "language": "verus", "source": "numpy_triple", "source_id": "logic_functions_isreal", "vc-description": "Returns a bool array, where True if input element is real.\nFor complex numbers, checks if imaginary part is zero.\nFor numbers with zero imaginary part, returns true for all elements.\n\nSpecification: isreal returns true for elements with zero imaginary parts,\nfalse for elements with non-zero imaginary parts, with the following properties:\n1. Basic definition: returns true iff imaginary part is zero\n2. Real number detection: pure real numbers (imag = 0) return true\n3. Complex number detection: numbers with non-zero imaginary part return false\n4. Complementary to iscomplex: isreal(x) = not iscomplex(x)\n5. Element-wise operation: each element is tested independently\n6. Mathematical property: real numbers form a subset of complex numbers\n7. Consistency: if real, then can be represented as a + 0i\n\n/* Structure representing a complex number with float components */\n\n/* The real part of the complex number */\n\n/* The imaginary part of the complex number */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nstruct Complex {\n\n    real: f64,\n\n    imag: f64,\n}", "vc-helpers": "", "vc-spec": "fn isreal(x: &Vec<Complex>) -> (result: Vec<bool>)\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < x@.len() ==> result@[i] == (x@[i].imag == 0.0),\n        forall|i: int| 0 <= i < x@.len() ==> (x@[i].imag == 0.0 ==> result@[i] == true),\n        forall|i: int| 0 <= i < x@.len() ==> (x@[i].imag != 0.0 ==> result@[i] == false),\n        forall|i: int| 0 <= i < x@.len() ==> (result@[i] == true ==> x@[i].imag == 0.0),\n        forall|i: int| 0 <= i < x@.len() ==> (result@[i] == false ==> x@[i].imag != 0.0),\n        forall|i: int| 0 <= i < x@.len() ==> (result@[i] == true ==> x@[i].real == x@[i].real),\n        forall|i: int| 0 <= i < x@.len() ==> result@[i] == !(x@[i].imag != 0.0),\n        forall|i: int| 0 <= i < x@.len() ==> (result@[i] == true <==> x@[i].imag == 0.0),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0275", "language": "verus", "source": "numpy_triple", "source_id": "logic_functions_less_equal", "vc-description": "Return the truth value of (x1 <= x2) element-wise\n\nSpecification: less_equal returns element-wise comparison x1[i] <= x2[i] with mathematical properties", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn less_equal(x1: Vec<i8>, x2: Vec<i8>) -> (result: Vec<bool>)\n    requires x1.len() == x2.len(),\n    ensures \n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < x1@.len() ==> result@[i] == (x1@[i] <= x2@[i]),\n        forall|i: int| 0 <= i < x1@.len() ==> (result@[i] == true <==> x1@[i] <= x2@[i]),\n        forall|i: int| 0 <= i < x1@.len() ==> (result@[i] == false <==> x1@[i] > x2@[i]),\n        forall|i: int| 0 <= i < x1@.len() ==> (x1@[i] == x2@[i] ==> result@[i] == true),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0276", "language": "verus", "source": "numpy_triple", "source_id": "logic_functions_logical_and", "vc-description": "numpy.logical_and: Compute the truth value of x1 AND x2 element-wise.\n\nComputes the logical AND of two boolean arrays element-wise.\nEach element of the result is the logical AND of the corresponding\nelements from the input arrays.\n\nExamples from NumPy:\n- logical_and(True, False) = False\n- logical_and([True, False], [False, False]) = [False, False]\n- logical_and([True, True], [True, False]) = [True, False]\n\nThis is a binary element-wise operation equivalent to x1 & x2.\n\nSpecification: numpy.logical_and returns a vector where each element\nis the logical AND of the corresponding elements from x1 and x2.\n\nPrecondition: True (no special preconditions for logical AND)\nPostcondition: For all indices i, result[i] = x1[i] ∧ x2[i]\n\nKey properties:\n- Commutative: logical_and(x1, x2) = logical_and(x2, x1)\n- Associative: logical_and(logical_and(x1, x2), x3) = logical_and(x1, logical_and(x2, x3))\n- Identity: logical_and(x, true_vector) = x\n- Zero: logical_and(x, false_vector) = false_vector\n- Idempotent: logical_and(x, x) = x", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_logical_and(x1: Vec<bool>, x2: Vec<bool>) -> (result: Vec<bool>)\n    requires x1.len() == x2.len(),\n    ensures \n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == (x1[i] && x2[i])", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0277", "language": "verus", "source": "numpy_triple", "source_id": "logic_functions_logical_not", "vc-description": "numpy.logical_not: Compute the truth value of NOT x element-wise.\n\nFor each element in the input array, applies logical NOT operation.\nIn NumPy's interpretation: any non-zero numeric value is considered True \n(so NOT returns False), zero is considered False (so NOT returns True).\n\nReturns a boolean array of the same shape as the input.\n\nSpecification: numpy.logical_not returns a vector where each element is the\nlogical NOT of the corresponding element in x, following NumPy's truthiness rules.\n\nPrecondition: True (logical NOT is defined for all numeric values)\nPostcondition: For all indices i, result[i] = true iff x[i] = 0.0\n\nMathematical properties:\n- Exactly implements NumPy's truthiness rules: 0.0 → true, non-zero → false\n- Element-wise operation preserves array shape and size (enforced by type)\n- Idempotent when composed with itself and appropriate conversion\n- For special float values: logical_not(NaN) = false, logical_not(∞) = false\n- Boundary case: logical_not(-0.0) = true (since -0.0 = 0.0)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn logical_not(x: Vec<f64>) -> (result: Vec<bool>)\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == (x[i] == 0.0)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0278", "language": "verus", "source": "numpy_triple", "source_id": "logic_functions_logical_or", "vc-description": "Compute the truth value of x1 OR x2 element-wise.\n\nPerforms logical OR operation on corresponding elements of two boolean vectors.\nThe function returns a vector where each element is the logical OR of the \ncorresponding elements from the input vectors.\n\nSpecification: logical_or computes element-wise logical OR operation\n\nThis specification captures the mathematical properties of logical OR:\n- Commutativity: a ∨ b = b ∨ a\n- Associativity: (a ∨ b) ∨ c = a ∨ (b ∨ c)\n- Identity with false: a ∨ false = a\n- Absorption with true: a ∨ true = true\n- Idempotent: a ∨ a = a\n- De Morgan's law: ¬(a ∨ b) = (¬a) ∧ (¬b)\n\nSanity checks:\n- For empty vectors (n = 0), the result is empty by vacuous truth\n- logical_or([true, false], [false, false]) = [true, false]\n- logical_or([false, false], [false, false]) = [false, false]\n- logical_or([true, true], [false, true]) = [true, true]\n- The result is false only when both operands are false\n\n/* Commutativity property */\n\n/* Identity with false */\n\n/* Absorption with true */\n\n/* Idempotent property */\n\n/* Result is true if either operand is true */\n\n/* Result is false only when both operands are false */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn logical_or(x1: Vec<bool>, x2: Vec<bool>) -> (result: Vec<bool>)\n    requires x1.len() == x2.len(),\n    ensures \n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == (x1[i] || x2[i]),\n\n        forall|i: int| 0 <= i < result.len() ==> (x1[i] || x2[i]) == (x2[i] || x1[i]),\n\n        forall|i: int| 0 <= i < result.len() ==> (x1[i] || false) == x1[i],\n\n        forall|i: int| 0 <= i < result.len() ==> (x1[i] || true) == true,\n\n        forall|i: int| 0 <= i < result.len() ==> (x1[i] || x1[i]) == x1[i],\n\n        forall|i: int| 0 <= i < result.len() ==> (x1[i] == true || x2[i] == true) ==> result[i] == true,\n\n        forall|i: int| 0 <= i < result.len() ==> (x1[i] == false && x2[i] == false) ==> result[i] == false,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0279", "language": "verus", "source": "numpy_triple", "source_id": "logic_functions_logical_xor", "vc-description": "numpy.logical_xor: Compute the truth value of x1 XOR x2 element-wise.\n\nComputes the logical XOR of two boolean arrays element-wise.\nEach element of the result is the logical XOR of the corresponding\nelements from the input arrays.\n\nExamples from NumPy:\n- logical_xor(True, False) = True\n- logical_xor([True, True, False, False], [True, False, True, False]) = [False, True, True, False]\n- logical_xor(False, False) = False\n- logical_xor(True, True) = False\n\nThis is a binary element-wise operation equivalent to x1 ⊕ x2.\n\nSpecification: numpy.logical_xor returns a vector where each element\nis the logical XOR of the corresponding elements from x1 and x2.\n\nPrecondition: True (no special preconditions for logical XOR)\nPostcondition: For all indices i, result[i] = x1[i] ⊕ x2[i]\n\nKey properties:\n- Commutative: logical_xor(x1, x2) = logical_xor(x2, x1)\n- Associative: logical_xor(logical_xor(x1, x2), x3) = logical_xor(x1, logical_xor(x2, x3))\n- Identity: logical_xor(x, false_vector) = x\n- Self-inverse: logical_xor(x, x) = false_vector\n- Double negation: logical_xor(logical_xor(x, y), y) = x\n- Relationship to other operations: logical_xor(x, y) = logical_and(logical_or(x, y), logical_not(logical_and(x, y)))", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_logical_xor(x1: Vec<bool>, x2: Vec<bool>) -> (result: Vec<bool>)\n    requires x1.len() == x2.len(),\n    ensures \n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == (x1[i] != x2[i])", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0280", "language": "verus", "source": "numpy_triple", "source_id": "logic_functions_not_equal", "vc-description": "numpy.not_equal: Return (x1 != x2) element-wise.\n\nPerforms element-wise inequality comparison of two arrays and returns a boolean array\nof the same shape indicating where the corresponding elements are not equal.\n\nFor scalar inputs, returns a single boolean value. For array inputs of the\nsame shape, returns an array of booleans. This function is the basis for\nthe != operator when used with numpy arrays.\n\nThis is the logical negation of numpy.equal.\n\nSpecification: numpy.not_equal returns a boolean vector where each element indicates\nwhether the corresponding elements in x1 and x2 are not equal.\n\nPrecondition: True (arrays have the same shape by the type system)\nPostcondition: For all indices i, result[i] = (x1[i] != x2[i])\n\nThis specification captures both the element-wise behavior and the mathematical\nproperty that inequality comparison is performed at each position.\n\nKey Properties:\n1. Element-wise comparison: Each position is compared independently\n2. Boolean result: Returns true/false for each position \n3. Irreflexivity: not_equal(x, x) returns all false\n4. Symmetry: not_equal(x, y) = not_equal(y, x)\n5. Logical negation of equality: not_equal(x, y) = ¬equal(x, y)\n6. Result shape matches input shape\n\n/* Irreflexivity: comparing vector with itself yields all false */\n\n/* Symmetry: inequality comparison is commutative */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_not_equal(x1: Vec<i8>, x2: Vec<i8>) -> (result: Vec<bool>)\n    requires x1.len() == x2.len(),\n    ensures\n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == (x1[i] != x2[i]),\n\n        (x1@ == x2@) ==> (forall|i: int| 0 <= i < result.len() ==> result[i] == false),\n\n        forall|i: int| 0 <= i < result.len() ==> result[i] == (x2[i] != x1[i]),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0281", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_absolute", "vc-description": "Calculate the absolute value element-wise for a vector of integers.\n\nSpecification: absolute computes the absolute value of each element with the following mathematical properties:\n1. Basic definition: |x| = x if x ≥ 0, otherwise -x\n2. Non-negativity: |x| ≥ 0 for all x\n3. Zero preservation: |x| = 0 if and only if x = 0\n4. Idempotence: ||x|| = |x|\n5. Multiplicativity: |x * y| = |x| * |y|", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn abs_spec(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\nfn absolute(x: Vec<i8>) -> (result: Vec<i8>)\n    ensures \n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] as int == abs_spec(x[i] as int),\n        forall|i: int| 0 <= i < result.len() ==> result[i] >= 0,\n        forall|i: int| 0 <= i < result.len() ==> (result[i] == 0 <==> x[i] == 0)", "vc-code": "{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0282", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_add", "vc-description": "numpy.add: Add arguments element-wise.\n\nAdds two vectors element-wise. If the vectors have the same shape,\neach element of the result is the sum of the corresponding elements\nfrom the input vectors.\n\nThis is equivalent to x1 + x2 in terms of array broadcasting.\nThe function supports all numeric types and handles overflow according\nto the IEEE 754 standard for floating-point arithmetic.\n\nFrom NumPy documentation:\n- Parameters: x1, x2 (array_like) - The arrays to be added\n- Returns: add (ndarray) - The sum of x1 and x2, element-wise\n\nSpecification: numpy.add returns a vector where each element is the sum\nof the corresponding elements from x1 and x2.\n\nMathematical Properties:\n1. Element-wise correctness: result[i] = x1[i] + x2[i]\n2. Commutativity: add(x1, x2) = add(x2, x1)\n3. Associativity: add(add(x1, x2), x3) = add(x1, add(x2, x3))\n4. Identity: add(x, zeros) = x\n5. Preserves vector length: result.size = x1.size = x2.size\n6. Handles finite arithmetic: supports IEEE 754 floating-point addition\n\nPrecondition: True (no special preconditions for basic addition)\nPostcondition: For all indices i, result[i] = x1[i] + x2[i]", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn add(x1: Vec<i8>, x2: Vec<i8>) -> (result: Vec<i8>)\n    requires x1.len() == x2.len(),\n    ensures \n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] as int == x1[i] as int + x2[i] as int", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0283", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_arccos", "vc-description": "Trigonometric inverse cosine, element-wise.\nReturns the arc cosine of each element in the input vector.\nThe result is in the range [0, π].\n\nSpecification: arccos returns the inverse cosine of each element.\nPrecondition: All elements must be in the range [-1, 1] for valid results.\nPostcondition: The result contains the arc cosine of each input element,\nwith values in the range [0, π], and satisfies cos(arccos(x)) = x for valid inputs.\nAdditionally, arccos is monotonically decreasing on its domain [-1, 1].", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn arccos(x: Vec<i8>) -> (result: Vec<i8>)\n    requires \n        x.len() > 0,\n        forall|i: int| 0 <= i < x.len() ==> -1 <= x[i] as int && x[i] as int <= 1,\n    ensures \n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> (\n            0 <= result[i] as int && \n            result[i] as int <= 3 &&\n            (x[i] as int == -1 ==> result[i] as int == 3) &&\n            (x[i] as int == 1 ==> result[i] as int == 0)\n        ),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0284", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_arccosh", "vc-description": "Inverse hyperbolic cosine, element-wise. \nReturns the inverse hyperbolic cosine of each element in the input vector.\nThe inverse hyperbolic cosine is defined as: arccosh(x) = log(x + sqrt(x² - 1)) for x ≥ 1\n\nSpecification: arccosh computes the inverse hyperbolic cosine element-wise.\n\nMathematical properties:\n1. Domain constraint: All input values must be ≥ 1\n2. Range: All output values are non-negative (arccosh(x) ≥ 0)\n3. Special value: arccosh(1) = 0\n4. The function is strictly increasing: x₁ < x₂ implies arccosh(x₁) < arccosh(x₂)\n5. Mathematical definition: arccosh(x) = log(x + sqrt(x² - 1))\n\nThe inverse hyperbolic cosine function reverses the action of cosh on [0, ∞),\nwhere cosh(y) = (e^y + e^(-y))/2. These properties ensure correctness.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn arccosh(x: Vec<f32>) -> (result: Vec<f32>)\n    requires \n        x.len() > 0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0285", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_arcsin", "vc-description": "numpy.arcsin: Inverse sine, element-wise.\n\nComputes the inverse sine (arcsine) of each element in the input array.\nThe result is the angle in radians whose sine is the input value.\n\nFor real arguments, the domain is [-1, 1] and the range is [-π/2, π/2].\nValues outside [-1, 1] will result in NaN.\n\nReturns an array of the same shape as x, containing the inverse sine values in radians.\n\nSpecification: numpy.arcsin returns a vector where each element is the\ninverse sine of the corresponding element in x.\n\nPrecondition: All elements of x must be in the domain [-1, 1] for real results\nPostcondition: For all indices i where x[i] is in [-1, 1]:\n- result[i] = arcsin(x[i])\n- result[i] is in the range [-π/2, π/2]\n- sin(result[i]) = x[i] (inverse relationship holds)\n- arcsin is monotonic: if x[i] ≤ x[j] then result[i] ≤ result[j]\n- Special values: arcsin(0) = 0, arcsin(1) = π/2, arcsin(-1) = -π/2", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_arcsin(x: Vec<i8>) -> (result: Vec<i8>)\n    requires \n        x@.len() > 0,\n        forall|i: int| 0 <= i < x@.len() ==> -1 <= x[i] as int && x[i] as int <= 1,\n    ensures\n        result@.len() == x@.len(),\n        forall|i: int| 0 <= i < result@.len() ==> {\n            -2 <= result[i] as int && result[i] as int <= 2 &&\n            (x[i] as int == 0 ==> result[i] as int == 0) &&\n            (x[i] as int == 1 ==> result[i] as int == 2) &&\n            (x[i] as int == -1 ==> result[i] as int == -2)\n        },\n        forall|i: int, j: int| 0 <= i < x@.len() && 0 <= j < x@.len() && x[i] as int <= x[j] as int ==> result[i] as int <= result[j] as int", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0286", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_arcsinh", "vc-description": "numpy.arcsinh: Inverse hyperbolic sine element-wise.\n\nComputes the inverse hyperbolic sine of each element in the input vector.\nThe inverse hyperbolic sine is defined as arcsinh(x) = ln(x + sqrt(x² + 1)).\n\nThis function is defined for all real numbers and is the inverse of the\nhyperbolic sine function (sinh).\n\nSpecification: numpy.arcsinh returns a vector where each element is the\ninverse hyperbolic sine of the corresponding element in x.\n\nPrecondition: True (arcsinh is defined for all real numbers)\nPostcondition: For all indices i, result[i] = arcsinh(x[i])\n\nMathematical properties captured:\n1. arcsinh(0) = 0 (sanity check)\n2. arcsinh(-x) = -arcsinh(x) (odd function property)\n3. arcsinh is strictly increasing (monotonicity)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_arcsinh(x: Vec<f32>) -> (result: Vec<f32>)\n    ensures \n        result@.len() == x@.len(),\n        forall|i: int| 0 <= i < result@.len() ==> {\n            /* Sanity check: arcsinh(0) = 0 */\n            x@[i] == 0.0f32 ==> result@[i] == 0.0f32\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0287", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_arctan", "vc-description": "Trigonometric inverse tangent, element-wise.\n\nThe inverse of tan, so that if y = tan(x) then x = arctan(y).\n\nComputes the element-wise inverse tangent of a vector.\n\nSpecification: arctan computes the inverse tangent of each element,\nwith comprehensive mathematical properties including range bounds,\nmonotonicity, and behavior at special values.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn arctan(x: Vec<i32>) -> (result: Vec<i32>)\n    requires x.len() > 0,\n    ensures \n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> {\n            /* Range constraint: arctan(x) ∈ (-π/2, π/2) - simplified for integer domain */\n            result[i] >= -2 && result[i] <= 2 &&\n            /* Sign property: arctan preserves sign */\n            (x[i] > 0 ==> result[i] >= 0) &&\n            (x[i] < 0 ==> result[i] <= 0) &&\n            (x[i] == 0 ==> result[i] == 0) &&\n            /* Monotonicity property for specific cases */\n            (x[i] > 10 ==> result[i] >= 1) &&\n            (x[i] < -10 ==> result[i] <= -1) &&\n            /* Bounded function: |arctan(x)| ≤ 2 for integer approximation */\n            result[i] >= -2 && result[i] <= 2\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0288", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_arctan2", "vc-description": "numpy.arctan2: Element-wise arc tangent of x1/x2 choosing the quadrant correctly.\n\nComputes the arc tangent of x1/x2 for each pair of corresponding elements,\nusing the signs of both arguments to determine the quadrant of the result.\nThis gives the signed angle in radians between the positive x-axis and the\npoint (x2, x1).\n\nThe result is in the range [-π, π].\n\nSpecial cases:\n- arctan2(+0, +0) = +0\n- arctan2(+0, -0) = +π\n- arctan2(-0, +0) = -0\n- arctan2(-0, -0) = -π\n- arctan2(y, +∞) = +0 for finite y > 0\n- arctan2(y, -∞) = +π for finite y > 0\n- arctan2(y, +∞) = -0 for finite y < 0\n- arctan2(y, -∞) = -π for finite y < 0", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_arctan2(x1: &Vec<f64>, x2: &Vec<f64>) -> (result: Vec<f64>)\n    requires x1@.len() == x2@.len(),\n    ensures result@.len() == x1@.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0289", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_arctanh", "vc-description": "numpy.arctanh: Inverse hyperbolic tangent element-wise.\n\nComputes the inverse hyperbolic tangent of each element in the input array.\nThe inverse hyperbolic tangent is defined for values in the open interval (-1, 1).\n\nFor a real number x with |x| < 1, arctanh(x) is the value y such that tanh(y) = x.\nMathematically: arctanh(x) = 0.5 * ln((1 + x) / (1 - x))\n\nReturns an array of the same shape as x, containing the inverse hyperbolic tangent \nof each element.\n\nSpecification: numpy.arctanh returns a vector where each element is the inverse\nhyperbolic tangent of the corresponding element in x.\n\nPrecondition: All elements must be in the open interval (-1, 1) for real-valued results\nPostcondition: For all indices i, result[i] = Float.atanh x[i]\n\nMathematical properties:\n- arctanh(0) = 0 (identity property)\n- arctanh is an odd function: arctanh(-x) = -arctanh(x)\n- For |x| < 1: arctanh(x) = 0.5 * ln((1 + x) / (1 - x))\n- arctanh is strictly increasing on (-1, 1)\n- Domain preservation: all results are finite real numbers\n- Range property: arctanh maps (-1, 1) to (-∞, ∞)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_arctanh(x: Vec<i8>) -> (result: Vec<i8>)\n    requires \n        x@.len() > 0,\n    ensures\n        result@.len() == x@.len(),\n        /* Identity property: arctanh(0) = 0 */\n        forall|i: int| 0 <= i < x@.len() && x@[i] as int == 0 ==> result@[i] as int == 0,\n        /* Range property: result contains finite numbers */\n        result@.len() == x@.len(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0290", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_around", "vc-description": "numpy.around: Evenly round to the given number of decimals (alias for numpy.round).\nUses banker's rounding (round half to even) for values exactly halfway between rounded decimal values.\nFor example: 1.5 and 2.5 both round to 2.0, -0.5 and 0.5 both round to 0.0\n\nSpecification: around rounds each element to the given number of decimals with the following properties:\n1. Basic rounding: rounds to nearest representable value at the specified decimal precision\n2. Banker's rounding: for values exactly halfway between rounded decimal values, rounds to nearest even\n3. Zero preservation: rounding zero always produces zero\n4. Order preservation: maintains relative ordering of elements\n5. Bounded difference: the rounded value is close to the original value\n6. Idempotency: rounding an already-rounded value doesn't change it\n\n/* Simplified to focus on the basic case */\n\n/* Zero preservation: rounding zero gives zero */\n\n/* Order preservation: maintains ordering */\n\n/* Boundedness: rounded values are close to original values */\n\n/* Symmetry: rounding non-negative values gives non-negative results */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn around(a: Vec<i8>, decimals: i8) -> (result: Vec<i8>)\n    requires decimals as int == 0,\n    ensures\n        result.len() == a.len(),\n\n        forall|i: int| 0 <= i < a.len() && a[i] as int == 0 ==> result[i] as int == 0,\n\n        forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() && a[i] as int <= a[j] as int ==> result[i] as int <= result[j] as int,\n\n        forall|i: int| 0 <= i < a.len() ==>\n            result[i] as int - 1 <= a[i] as int && a[i] as int <= result[i] as int + 1,\n\n        forall|i: int| 0 <= i < a.len() && a[i] as int >= 0 ==> result[i] as int >= 0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0291", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_cbrt", "vc-description": "Return the cube-root of an array, element-wise\n\nnumpy.cbrt: Return the cube-root of an array, element-wise.\n\nComputes the cube root of each element in the input array.\nThe cube root function is defined for all real numbers, including negative numbers.\nFor any real number x, cbrt(x) = y such that y³ = x.\n\nReturns an array of the same shape as x, containing the cube roots.\n\nSpecification: numpy.cbrt returns a vector where each element is the\ncube root of the corresponding element in x.\n\nPrecondition: True (cube root is defined for all real numbers)\nPostcondition: For all indices i, (result[i])³ = x[i]\n\nMathematical properties:\n- cbrt(x³) = x for all x\n- cbrt(-x) = -cbrt(x) (odd function)\n- cbrt(0) = 0\n- cbrt(1) = 1\n- cbrt(8) = 2\n- cbrt(-8) = -2", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn cbrt(x: Vec<f32>) -> (result: Vec<f32>)\n    requires x.len() > 0,\n    ensures \n        result.len() == x.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0292", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_ceil", "vc-description": "numpy.ceil: Return the ceiling of the input, element-wise.\n\nThe ceiling of each element x is the smallest integer i, such that i >= x.\nThis is a fundamental mathematical operation that rounds up to the\nnearest integer.\n\nReturns an array of the same shape as x, containing the ceiling of each element.\n\nSpecification: numpy.ceil returns a vector where each element is the\nceiling (smallest integer greater than or equal to) the corresponding element in x.\n\nPrecondition: True (ceiling is defined for all real numbers)\nPostcondition: For all indices i, result[i] is the ceiling of x[i], meaning:\n- result[i] is an integer value (represented as Float)\n- result[i] ≥ x[i]\n- result[i] < x[i] + 1\n- There is no integer k such that x[i] ≤ k < result[i]\n- Monotonicity: if x[i] ≤ x[j] then result[i] ≤ result[j]\n- Relationship with floor: result[i] = -((-x[i]).floor)\n\n/* Each element in result is the ceiling of corresponding element in x */\n\n/* Ceiling properties: integer value, >= x[i], < x[i] + 1, minimal such integer */\n\n/* Monotonicity: if x[i] <= x[j] then result[i] <= result[j] */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_ceil(x: Vec<f64>) -> (result: Vec<f64>)\n    requires x.len() > 0,\n    ensures\n        result.len() == x.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0293", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_clip", "vc-description": "numpy.clip: Clip (limit) the values in an array.\n\nGiven an interval [min_val, max_val], values outside the interval are clipped to the interval edges.\nValues smaller than min_val become min_val, and values larger than max_val become max_val.\n\nThis operation is equivalent to but faster than np.minimum(max_val, np.maximum(arr, min_val)).\nThe function performs element-wise clipping and preserves the shape of the input array.\n\nFrom NumPy documentation:\n- Parameters: \n  - a (array_like) - Array containing elements to clip\n  - a_min (scalar) - Minimum value threshold\n  - a_max (scalar) - Maximum value threshold\n- Returns: clipped array with values limited to [a_min, a_max]\n\nSpecial behavior:\n- If a_min > a_max, all values become a_max\n- No validation is performed to ensure a_min < a_max\n\nSpecification: numpy.clip returns a vector where each element is clipped to the interval [min_val, max_val].\n\nMathematical Properties:\n1. Element-wise correctness: \n   - If arr[i] < min_val, then result[i] = min_val\n   - If arr[i] > max_val, then result[i] = max_val  \n   - If min_val ≤ arr[i] ≤ max_val, then result[i] = arr[i]\n2. Boundary behavior: Values are clamped to the closed interval [min_val, max_val]\n3. Preserves vector length: result.size = arr.size\n4. Idempotency: clip(clip(arr, min_val, max_val), min_val, max_val) = clip(arr, min_val, max_val)\n5. Monotonicity: If min_val ≤ max_val, then min_val ≤ result[i] ≤ max_val for all i\n6. Special case: If min_val > max_val, then result[i] = max_val for all i\n\nPrecondition: True (no special preconditions, handles all real number inputs)\nPostcondition: For all indices i, result[i] is the clipped value of arr[i]", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn clip(arr: &Vec<i8>, min_val: i8, max_val: i8) -> (result: Vec<i8>)\n    ensures\n        result.len() == arr.len(),\n        forall|i: int| 0 <= i < result.len() ==> {\n            if (min_val as int) <= (max_val as int) {\n                if (arr[i] as int) < (min_val as int) {\n                    (result[i] as int) == (min_val as int)\n                } else if (arr[i] as int) > (max_val as int) {\n                    (result[i] as int) == (max_val as int)\n                } else {\n                    (result[i] as int) == (arr[i] as int)\n                }\n            } else {\n                (result[i] as int) == (max_val as int)\n            }\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0294", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_conj", "vc-description": "Return the complex conjugate of a vector of complex numbers, element-wise\n\nSpecification: conj computes the complex conjugate of each element with the following properties:\n    1. Basic definition: conj(a + bi) = a - bi for complex numbers\n    2. Real preservation: For purely real numbers, conj(x) = x\n    3. Involution property: conj(conj(x)) = x (double conjugation returns original)\n    4. Magnitude preservation: |conj(x)| = |x| (conjugate preserves magnitude)\n    5. Distributive over addition: conj(x + y) = conj(x) + conj(y)\n    6. Distributive over multiplication: conj(x * y) = conj(x) * conj(y)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* Structure representing a complex number with integer components */\n#[derive(PartialEq, Eq)]\npub struct Complex {\n    /* The real part of the complex number */\n    pub real: int,\n    /* The imaginary part of the complex number */\n    pub imag: int,\n}\n\nimpl Complex {\n    /* Addition of complex numbers */\n    pub open spec fn add(self, other: Complex) -> Complex {\n        Complex { real: self.real + other.real, imag: self.imag + other.imag }\n    }\n\n    /* Multiplication of complex numbers */\n    pub open spec fn mul(self, other: Complex) -> Complex {\n        Complex { \n            real: self.real * other.real - self.imag * other.imag,\n            imag: self.real * other.imag + self.imag * other.real\n        }\n    }\n\n    /* Magnitude squared of a complex number */\n    pub open spec fn norm_sq(self) -> int {\n        self.real * self.real + self.imag * self.imag\n    }\n\n    /* Complex conjugate of a single complex number */\n    pub open spec fn conj(self) -> Complex {\n        Complex { real: self.real, imag: -self.imag }\n    }\n}", "vc-helpers": "", "vc-spec": "fn conj(x: Vec<Complex>) -> (result: Vec<Complex>)\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < x@.len() ==> \n            result@[i].real == x@[i].real && result@[i].imag == -x@[i].imag,\n        forall|i: int| 0 <= i < x@.len() ==> \n            x@[i].imag == 0 ==> result@[i] == x@[i],\n        forall|i: int| 0 <= i < x@.len() ==> \n            result@[i].conj() == x@[i],\n        forall|i: int| 0 <= i < x@.len() ==> \n            x@[i].norm_sq() == result@[i].norm_sq(),\n        forall|i: int, y: Complex| 0 <= i < x@.len() ==> \n            x@[i].add(y).conj() == result@[i].add(y.conj()),\n        forall|i: int, y: Complex| 0 <= i < x@.len() ==> \n            x@[i].mul(y).conj() == result@[i].mul(y.conj())", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0295", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_convolve", "vc-description": "numpy.convolve: Returns the discrete, linear convolution of two one-dimensional arrays.\n\nThe discrete convolution operation is defined as:\n(a * v)[n] = sum(a[m] * v[n - m], m = -∞ to ∞)\n\nFor finite arrays, the convolution is computed over the valid range where\nboth arrays have elements. This implementation follows the 'full' mode\nwhich returns a convolution of length (M + N - 1) where M and N are\nthe lengths of the input arrays.\n\nSpecification: numpy.convolve returns the discrete convolution of two vectors.\n\nPrecondition: Both input vectors must be non-empty (enforced by types)\nPostcondition: The result vector contains the discrete convolution values\n\nThe convolution at position k is computed as:\nresult[k] = sum(a[i] * v[k - i] for all valid i)\n\nMathematical properties:\n1. Result length is m + n - 1 (enforced by return type)\n2. Each element follows the convolution definition\n3. Boundary conditions: zero-padding is implicitly assumed outside array bounds", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn convolution_element_sum(a: Seq<i32>, v: Seq<i32>, k: int) -> int\n    decreases a.len()\n{\n    if a.len() == 0 {\n        0\n    } else {\n        let i = 0;\n        let contribution = if k >= i && k - i < v.len() {\n            a[i] * v[k - i]\n        } else {\n            0\n        };\n        contribution + convolution_element_sum(a.skip(1), v, k)\n    }\n}\n\nfn numpy_convolve(a: Vec<i32>, v: Vec<i32>) -> (result: Vec<i32>)\n    requires a.len() > 0 && v.len() > 0,\n    ensures \n        result.len() == a.len() + v.len() - 1,\n        forall|k: int| 0 <= k < result.len() ==> result[k] == convolution_element_sum(a@, v@, k),\n        result[0] == a[0] * v[0],\n        result[result.len() - 1] == a[a.len() - 1] * v[v.len() - 1],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0296", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_copysign", "vc-description": "numpy.copysign: Change the sign of x1 to that of x2, element-wise.\n\nReturns an array where each element has the magnitude of x1 but the sign of x2.\nThis function is useful for combining the absolute value of one array with \nthe sign pattern of another.\n\nFor each element:\n- If x2 >= 0, returns |x1|\n- If x2 < 0, returns -|x1|\n\nSpecial cases:\n- copysign(x, 0) returns |x| (positive sign)\n- copysign(0, y) returns 0 with the sign of y\n\nSpecification: numpy.copysign returns a vector where each element has\nthe magnitude of the corresponding element in x1 but the sign of the\ncorresponding element in x2.\n\nPrecondition: True (no special preconditions for copysign)\nPostcondition: For all indices i:\n  - If x2[i] >= 0, then result[i] = |x1[i]|\n  - If x2[i] < 0, then result[i] = -|x1[i]|\n\nMathematical properties:\n  1. result[i] = |x1[i]| * sign(x2[i]) where sign(x) = 1 if x >= 0, -1 if x < 0\n  2. |result[i]| = |x1[i]| (magnitude preservation)\n  3. sign(result[i]) = sign(x2[i]) (sign copying)\n  4. copysign(x1, x2) = copysign(|x1|, x2) (idempotence on magnitude)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn copysign(x1: Vec<i8>, x2: Vec<i8>) -> (result: Vec<i8>)\n    requires x1.len() == x2.len(),\n    ensures \n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> {\n            /* Basic behavior: sign copying with magnitude preservation */\n            (x2@[i] >= 0 ==> result@[i] as int == if x1@[i] >= 0 { x1@[i] as int } else { -(x1@[i] as int) }) &&\n            (x2@[i] < 0 ==> result@[i] as int == if x1@[i] >= 0 { -(x1@[i] as int) } else { x1@[i] as int }) &&\n            /* Magnitude preservation property: |result[i]| = |x1[i]| */\n            (if result@[i] >= 0 { result@[i] as int } else { -(result@[i] as int) }) == \n            (if x1@[i] >= 0 { x1@[i] as int } else { -(x1@[i] as int) }) &&\n            /* Sign copying property: result has same sign as x2 */\n            (x2@[i] >= 0 ==> result@[i] >= 0) &&\n            (x2@[i] < 0 ==> result@[i] < 0)\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0297", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_cos", "vc-description": "numpy.cos: Cosine element-wise.\n\nComputes the cosine of each element in the input array.\nThe cosine is one of the fundamental functions of trigonometry.\nFor a real number x interpreted as an angle in radians, cos(x)\ngives the x-coordinate of the point on the unit circle.\n\nReturns an array of the same shape as x, containing the cosine of each element.\n\nSpecification: numpy.cos returns a vector where each element is the cosine\nof the corresponding element in x (interpreted as radians).\n\nPrecondition: True (no special preconditions for cosine)\nPostcondition: For all indices i, result[i] = Float.cos x[i]\n              and result[i] is bounded between -1 and 1\n              with cos(0) = 1", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_cos(x: Vec<i8>) -> (result: Vec<i8>)\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result@.len() ==> {\n            -1 <= result@[i] as int <= 1 &&\n            (x@[i] as int == 0 ==> result@[i] as int == 1)\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0298", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_cosh", "vc-description": "numpy.cosh: Hyperbolic cosine, element-wise.\n\nThe hyperbolic cosine function is defined as:\ncosh(x) = (e^x + e^(-x)) / 2\n\nIt represents the x-coordinate of a point on the unit hyperbola,\nanalogous to how cosine represents the x-coordinate on the unit circle.\n\nReturns an array of the same shape as x, containing the hyperbolic cosine of each element.\n\n/* Core mathematical definition placeholder */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_cosh(x: Vec<f32>) -> (result: Vec<f32>)\n    requires x@.len() > 0,\n    ensures\n        result@.len() == x@.len(),\n        forall|i: int| 0 <= i < result@.len() ==> {\n            result@[i] == result@[i]\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0299", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_cross", "vc-description": "numpy.cross: Return the cross product of two (arrays of) vectors.\n\nThe cross product of a and b in R^3 is a vector perpendicular to both a and b.\nFor 3D vectors a = [a0, a1, a2] and b = [b0, b1, b2], the cross product is:\nc = [a1*b2 - a2*b1, a2*b0 - a0*b2, a0*b1 - a1*b0]\n\nThis implementation focuses on the 3D case, which is the most common usage.\nThe result vector is perpendicular to both input vectors according to the\nright-hand rule.\n\nSpecification: numpy.cross returns the cross product of two 3D vectors.\n\nPrecondition: True (vectors must be 3D, enforced by type)\nPostcondition: \n1. The result components follow the cross product formula\n2. The result is perpendicular to both input vectors (dot product is zero)\n3. Anti-commutativity: a × b = -(b × a)\n4. Bilinearity properties\n5. Zero property: if a and b are parallel, then a × b = 0", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn cross(a: Vec<i8>, b: Vec<i8>) -> (result: Vec<i8>)\n    requires \n        a.len() == 3,\n        b.len() == 3,\n    ensures \n        result.len() == 3,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0300", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_cumprod", "vc-description": "numpy.cumprod: Return the cumulative product of elements along a given axis.\n\nFor a vector [a₁, a₂, a₃, ..., aₙ], returns [a₁, a₁*a₂, a₁*a₂*a₃, ..., a₁*a₂*...*aₙ].\n\nThis function computes the cumulative product by applying successive multiplications\nfrom left to right, producing a result vector of the same length as the input.\n\nThe cumulative product is computed as: result[i] = ∏(k=0 to i) input[k]\n\nFor empty vectors, returns an empty vector.\n\nSpecification: cumprod returns the cumulative product of elements.\n\nPrecondition: True (works for any vector, including empty)\nPostcondition: \n- Result has same length as input\n- For any index i, result[i] = product of all elements from a[0] to a[i] inclusive\n- Equivalently: result[i] = a[0] * a[1] * ... * a[i]\n- For empty vectors, returns empty vector (vacuous condition holds)\n\nMathematical Properties:\n- result[0] = a[0] (when n > 0)\n- result[i+1] = result[i] * a[i+1] (cumulative property)\n- Each element is the product of all preceding elements (including itself)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn product_prefix(a: Seq<int>, end: int) -> int\n    decreases end\n{\n    if end <= 0 {\n        1\n    } else if end == 1 {\n        a[0]\n    } else {\n        product_prefix(a, end - 1) * a[end - 1]\n    }\n}\n\nfn cumprod(a: Vec<i8>) -> (result: Vec<i8>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> result[i] as int == product_prefix(a@.map(|_index, x: i8| x as int), i + 1),\n        forall|i: int, j: int| 0 <= i < a.len() && j == i + 1 && j < a.len() ==> \n            result[j] as int == (result[i] as int) * (a[j] as int)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0301", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_cumsum", "vc-description": "numpy.cumsum: Return the cumulative sum of the elements along a given axis.\n\nFor a 1D array, cumsum computes the cumulative sum where each element\nis the sum of all previous elements plus itself. For example:\n[1, 2, 3, 4] becomes [1, 3, 6, 10]\n\nThe cumulative sum is defined as:\n- result[0] = a[0]\n- result[i] = result[i-1] + a[i] for i > 0\n\nSpecification: numpy.cumsum returns a vector where each element is the\ncumulative sum up to that position.\n\nPrecondition: True (no special preconditions)\nPostcondition: \n- For non-empty vectors, the first element equals the first element of the input\n- Each subsequent element equals the previous cumulative sum plus the current element\n- The cumulative sum has the property that result[i] = sum of a[0] through a[i]", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn prefix_sum(a: Seq<i32>, i: int) -> int\n    decreases i\n{\n    if i < 0 || i >= a.len() {\n        0\n    } else if i == 0 {\n        a[0] as int\n    } else {\n        prefix_sum(a, i - 1) + (a[i] as int)\n    }\n}\n\nfn numpy_cumsum(a: Vec<i32>) -> (result: Vec<i32>)\n    ensures \n        result.len() == a.len(),\n        a.len() > 0 ==> result[0] == a[0],\n        forall|i: int| 0 < i < a.len() ==> result[i] == result[i - 1] + a[i],\n        forall|i: int| 0 <= i < a.len() ==> result[i] as int == prefix_sum(a@, i)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0302", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_deg2rad", "vc-description": "Convert angles from degrees to radians\n\nConvert angles from degrees to radians by multiplying by π/180.\nThis function performs the standard mathematical conversion from degrees to radians\nwhere π radians = 180 degrees.\n\nSpecification: deg2rad converts each degree value to radians using the formula radians = degrees * π/180", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn deg2rad(degrees: Vec<i8>) -> (radians: Vec<i8>)\n    ensures \n        radians.len() == degrees.len(),\n        forall|i: int| 0 <= i < degrees.len() ==> #[trigger] radians@[i] as int == degrees@[i] as int * 314 / 18000", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0304", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_diff", "vc-description": "numpy.diff: Calculate the n-th discrete difference along the given axis.\n\nThe first difference is given by out[i] = a[i+1] - a[i] along the given axis.\nHigher differences are calculated by using diff recursively.\n\nFor a 1D array, the first difference computes the difference between \nconsecutive elements, producing an array with one less element.\n\nThe function is particularly useful for numerical analyses where \nunderstanding incremental changes within data is crucial.\n\nSpecification: numpy.diff returns a vector where each element is the difference\nof consecutive elements from the input array.\n\nPrecondition: Input array must be non-empty (at least 2 elements for first difference)\nPostcondition: For all indices i, result[i] = a[i+1] - a[i]\n\nMathematical Properties:\n1. Length property: |result| = |input| - 1\n2. Difference property: Each element represents the discrete difference\n3. Type preservation: Result maintains the same numeric type as input\n4. Monotonicity: If input is monotonic, result has consistent sign", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_diff(a: Vec<i8>) -> (result: Vec<i8>)\n    requires a.len() >= 2,\n    ensures \n        result.len() == a.len() - 1,\n        forall|i: int| 0 <= i < result.len() ==> result[i] as int == a[i + 1] as int - a[i] as int,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0305", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_divide", "vc-description": "numpy.divide: Divide arguments element-wise.\n\nDivides two vectors element-wise. If the vectors have the same shape,\neach element of the result is the quotient of the corresponding elements\nfrom the input vectors.\n\nThis is equivalent to x1 / x2 in terms of array broadcasting.\nDivision by zero results in infinity or NaN according to IEEE 754 standard.\n\nSpecification: numpy.divide returns a vector where each element is the quotient\nof the corresponding elements from x1 and x2.\n\nPrecondition: True (handles division by zero according to IEEE 754)\nPostcondition: For all indices i, result[i] = x1[i] / x2[i]\n\nAdditional properties:\n- When x2[i] ≠ 0, result[i] * x2[i] = x1[i] (within floating point precision)\n- When x2[i] = 0 and x1[i] ≠ 0, result[i] is infinite\n- When x2[i] = 0 and x1[i] = 0, result[i] is NaN", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_divide(x1: Vec<f32>, x2: Vec<f32>) -> (result: Vec<f32>)\n    requires \n        x1.len() == x2.len(),\n    ensures \n        result.len() == x1.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0306", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_divmod", "vc-description": "numpy.divmod: Return element-wise quotient and remainder simultaneously.\n\nPerforms element-wise division returning both the quotient and remainder.\nFor each pair of elements (x, y), returns (x // y, x % y) where:\n- x // y is the floor division (largest integer ≤ x/y)\n- x % y is the remainder such that x = y * (x // y) + (x % y)\n\nThis is equivalent to (x // y, x % y) but faster because it avoids\nredundant work by computing both values in a single operation.\n\nFrom NumPy documentation:\n- Parameters: x1, x2 (array_like) - The dividend and divisor arrays\n- Returns: (quotient, remainder) - tuple of ndarrays with element-wise results\n\nMathematical properties:\n1. Division identity: x1[i] = x2[i] * quotient[i] + remainder[i]\n2. Remainder bounds: 0 ≤ |remainder[i]| < |x2[i]| (for positive divisors)\n3. Sign consistency: remainder has same sign as divisor (Python % semantics)\n\nSpecification: numpy.divmod returns a tuple of vectors containing the quotient \nand remainder of element-wise division.\n\nMathematical Properties:\n1. Division identity: For all i, x1[i] = x2[i] * quotient[i] + remainder[i]\n2. Quotient correctness: quotient[i] = floor(x1[i] / x2[i])\n3. Remainder correctness: remainder[i] = x1[i] - x2[i] * quotient[i]\n4. Remainder bounds: |remainder[i]| < |x2[i]| (when x2[i] ≠ 0)\n5. Sign consistency: remainder[i] has same sign as x2[i] (Python % semantics)\n6. Equivalence: divmod(x1, x2) = (floor_divide(x1, x2), mod(x1, x2))\n\nPrecondition: All elements in x2 must be non-zero\nPostcondition: Returns (quotient, remainder) where the mathematical properties hold", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn divmod(x1: Vec<i8>, x2: Vec<i8>) -> (result: (Vec<i8>, Vec<i8>))\n    requires \n        x1.len() == x2.len(),\n        forall|i: int| 0 <= i < x2.len() ==> x2[i] != 0,\n    ensures ({\n        let (quotient, remainder) = result;\n        &&& quotient.len() == x1.len()\n        &&& remainder.len() == x1.len()\n        &&& forall|i: int| 0 <= i < x1.len() ==> \n            x1[i] as int == x2[i] as int * quotient[i] as int + remainder[i] as int\n    })", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0307", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_ediff1d", "vc-description": "numpy.ediff1d: The differences between consecutive elements of an array.\n\nComputes the differences between consecutive elements of an array.\nFor an input array [a, b, c, d], returns [b-a, c-b, d-c].\n\nThe function always returns a 1D array, and if necessary, the input\nwill be flattened before the differences are taken.\n\nThis is equivalent to ary.flat[1:] - ary.flat[:-1] in NumPy.\n\nSpecification: numpy.ediff1d returns a vector of differences between consecutive elements.\n\nPrecondition: The input vector must have at least one element (enforced by type)\nPostcondition: For all indices i, result[i] = ary[i+1] - ary[i]\n\nKey properties:\n1. The result has length n for input of length n+1\n2. Each element represents the difference between consecutive elements\n3. The result is always 1D regardless of input shape\n4. Mathematically: result[i] = ary[i+1] - ary[i] for all valid i", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_ediff1d(ary: Vec<i8>) -> (result: Vec<i8>)\n    requires ary.len() > 0,\n    ensures \n        result.len() == ary.len() - 1,\n        forall|i: int| 0 <= i < result.len() ==> result[i] as int == ary[i + 1] as int - ary[i] as int,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0308", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_exp", "vc-description": "numpy.exp: Calculate the exponential of all elements in the input array.\n\nComputes the exponential function (e^x) element-wise. This is the inverse\nof the natural logarithm function. For each element x in the input array,\nthe result contains e^x where e is Euler's number (approximately 2.71828).\n\nThe exponential function has the mathematical property that exp(x + y) = exp(x) * exp(y)\nand exp(0) = 1.\n\nReturns an array of the same shape as x, containing the exponential values.\n\nSpecification: numpy.exp returns a vector where each element is the\nexponential (e^x) of the corresponding element in x.\n\nPrecondition: True (exponential function is defined for all real numbers)\nPostcondition: For all indices i, result[i] = e^(x[i])\n\nMathematical properties:\n- exp(0) = 1 for any zero elements\n- exp(x) > 0 for all x (exponential is always positive)\n- exp is monotonically increasing\n- exp(x + y) = exp(x) * exp(y) (for addition in the input)\n\n/* Mathematical specification: For all indices i, result[i] = exp(x[i])\n           Note: Verus doesn't have built-in exp function for f32,\n           so we provide a simplified specification that maintains array length */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_exp(x: Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() == x.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0309", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_exp2", "vc-description": "Calculate 2**p for all p in the input array. numpy.exp2: Calculate 2 raised to the power of each element in the input vector.\n\nComputes 2^p for all p in the input vector, element-wise.\nThis is equivalent to applying the exponential function with base 2\nto each element of the input vector.\n\nFrom NumPy documentation:\n- Parameters: x (array_like) - Input values\n- Returns: y (ndarray) - 2**x, element-wise\n\nThe function is implemented as a universal function (ufunc) that\noperates element-wise on arrays and supports broadcasting.\nFor finite input values, the result is always positive.\n\nSpecification: numpy.exp2 computes 2 raised to the power of each element \nin the input vector.\n\nMathematical Properties:\n1. Element-wise correctness: result[i] = 2^x[i] for all i\n2. Fundamental exponential identity: exp2(0) = 1\n3. Base property: exp2(1) = 2\n4. Negative powers: exp2(-1) = 0.5\n5. Positivity: exp2(x) > 0 for all finite x\n6. Monotonicity: if x[i] < x[j], then exp2(x)[i] < exp2(x)[j]\n7. Exponential addition rule: exp2(a + b) = exp2(a) * exp2(b)\n8. Preservation of vector length: result.size = x.size\n9. Handles IEEE 754 floating-point arithmetic\n\nPrecondition: True (no special preconditions for exp2)\nPostcondition: For all indices i, result[i] = 2^x[i] and result[i] > 0", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn exp2(x: Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() == x.len(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0310", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_expm1", "vc-description": "Calculate exp(x) - 1 for all elements in the vector.\nThis function provides greater precision than exp(x) - 1 for small values of x.\n\nSpecification: expm1 computes exp(x) - 1 element-wise with enhanced numerical precision", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn expm1(x: Vec<f32>) -> (result: Vec<f32>)\n    requires x@.len() > 0,\n    ensures \n        result@.len() == x@.len(),\n        forall|i: int| 0 <= i < x@.len() ==> {\n            /* Basic mathematical property: result equals exp(x) - 1 */\n            true &&\n            /* Identity property: expm1(0) = 0 */\n            (x@[i] == 0.0f32 ==> result@[i] == 0.0f32) &&\n            /* Sign preservation and bounds properties */\n            true\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0311", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_fabs", "vc-description": "Compute the absolute values element-wise for floating-point numbers\n\nSpecification: fabs computes the absolute value of each element", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn fabs(x: Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() == x.len()", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0312", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_fix", "vc-description": "Round to nearest integer towards zero, element-wise.\n\nThe fix (truncation) of each element x is the integer part of x,\nobtained by discarding the fractional part. This is equivalent to\nrounding towards zero.\n\nFor positive numbers: fix(x) = floor(x)\nFor negative numbers: fix(x) = ceil(x)\n\nReturns an array of the same shape as x, containing the fix of each element.\n\nSpecification: numpy.fix returns a vector where each element is the\nfix (truncation towards zero) of the corresponding element in x.\n\nPrecondition: True (fix is defined for all real numbers)\nPostcondition: For all indices i, result[i] is the fix of x[i], meaning:\n- result[i] is an integer value (represented as Float)\n- |result[i]| ≤ |x[i]| (magnitude is reduced or equal)\n- result[i] has the same sign as x[i] (or zero if x[i] is zero)\n- |x[i] - result[i]| < 1 (difference is less than 1)\n- For positive x[i]: result[i] = floor(x[i])\n- For negative x[i]: result[i] = ceil(x[i])\n- For zero x[i]: result[i] = 0\n- Monotonicity: if x[i] ≤ x[j] then result[i] ≤ result[j]\n- Truncation property: result[i] truncates towards zero\n\n/* Round to nearest integer towards zero, element-wise.\n\n   The fix (truncation) of each element x is the integer part of x,\n   obtained by discarding the fractional part. This is equivalent to\n   rounding towards zero.\n\n   For positive numbers: fix(x) = floor(x)\n   For negative numbers: fix(x) = ceil(x)\n\n   Returns an array of the same shape as x, containing the fix of each element.\n*/", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_fix(x: Vec<f64>) -> (result: Vec<f64>)\n    ensures result.len() == x.len()", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0313", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_float_power", "vc-description": "Element-wise power operation with float promotion. \nRaises each element of the base vector to the corresponding power in the exponent vector.\nAll values are promoted to Float (minimum precision of Float64).\n\nSpecification: float_power computes element-wise exponentiation with appropriate constraints.\n- For positive bases: result is always well-defined\n- For zero bases: only non-negative exponents are valid\n- For negative bases: only integer exponents are mathematically valid (though NumPy allows all)\n- The result preserves the mathematical power relationship element-wise", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn float_pow(base: f64, exponent: f64) -> f64;", "vc-spec": "fn float_power(base: Vec<f64>, exponent: Vec<f64>) -> (result: Vec<f64>)\n    requires \n        base.len() == exponent.len()\n    ensures \n        result.len() == base.len(),\n        forall|i: int| 0 <= i < result.len() ==> \n            result[i] == float_pow(base[i], exponent[i])", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0314", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_floor", "vc-description": "Return the floor of the input, element-wise.\n\nThe floor of each element x is the largest integer i, such that i <= x.\nThis is a fundamental mathematical operation that rounds down to the\nnearest integer.\n\nReturns an array of the same shape as x, containing the floor of each element.\n\nSpecification: numpy.floor returns a vector where each element is the\nfloor (largest integer less than or equal to) the corresponding element in x.\n\nPrecondition: True (floor is defined for all real numbers)\nPostcondition: For all indices i, result[i] is the floor of x[i], meaning:\n- result[i] is an integer value (represented as Float)\n- result[i] ≤ x[i]\n- x[i] < result[i] + 1\n- There is no integer k such that result[i] < k ≤ x[i]\n- Monotonicity: if x[i] ≤ x[j] then result[i] ≤ result[j]\n- Idempotence: floor(floor(x)) = floor(x)\n- Relationship with ceiling: result[i] = -((-x[i]).ceil) when x[i] is not an integer\n- Integer preservation: if x[i] is an integer, then result[i] = x[i]", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_floor(x: Vec<i32>) -> (result: Vec<i32>)\n    requires x.len() > 0,\n    ensures \n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] <= x[i],\n        forall|i: int| 0 <= i < result.len() ==> x[i] < result[i] + 1,\n        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result.len() && x[i] <= x[j] ==> result[i] <= result[j],\n        forall|i: int| 0 <= i < result.len() ==> result[i] == x[i]", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0315", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_floor_divide", "vc-description": "numpy.floor_divide: Return the largest integer smaller or equal to the division of the inputs.\n\nPerforms element-wise floor division of two vectors. For each pair of elements,\nreturns the largest integer less than or equal to their division.\n\nThis is equivalent to the Python // operator and pairs with the modulo operation\nsuch that a = a % b + b * (a // b) up to roundoff.\n\nSpecification: numpy.floor_divide returns a vector where each element is the floor\nof the division of the corresponding elements from x1 and x2.\n\nThis function implements Python's // operator behavior for element-wise operations.\n\nPrecondition: All elements in x2 must be non-zero\nPostcondition: \n1. For all indices i, result[i] = floor(x1[i] / x2[i])\n2. For all indices i, result[i] is the largest integer ≤ x1[i] / x2[i]\n3. The fundamental floor division property: result[i] ≤ x1[i] / x2[i] < result[i] + 1\n4. This pairs with modulo such that: x1[i] = x2[i] * result[i] + remainder\n\n/* Floor division properties:\n             * 1. result[i] is the floor of x1[i] / x2[i]\n             * 2. result[i] <= x1[i] / x2[i] \n             * 3. x1[i] / x2[i] < result[i] + 1.0\n             */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn floor_div_prop(x: f64, y: f64) -> bool {\n    y != 0.0\n}\n\nfn numpy_floor_divide(x1: Vec<f64>, x2: Vec<f64>) -> (result: Vec<f64>)\n    requires \n        x1.len() == x2.len(),\n        forall|i: int| 0 <= i < x2@.len() ==> x2@[i] != 0.0,\n    ensures\n        result@.len() == x1@.len(),\n        forall|i: int| 0 <= i < result@.len() ==> {\n\n            floor_div_prop(x1@[i], x2@[i])\n        },", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0316", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_fmax", "vc-description": "Element-wise maximum of array elements.\n\nCompare two arrays and returns a new array containing the element-wise maxima. If one of the elements being compared is a NaN, then the non-nan element is returned.\n\nElement-wise maximum of two vectors, with special NaN handling.\nIf one element is NaN, returns the non-NaN element.\n\nSpecification: fmax returns element-wise maximum with NaN handling.\nFor each position i:\n- If both elements are non-NaN, returns the maximum\n- If x[i] is NaN and y[i] is not, returns y[i]  \n- If y[i] is NaN and x[i] is not, returns x[i]\n- If both are NaN, returns NaN\nAdditional mathematical properties:\n- Commutative when both values are non-NaN\n- Associative when all values are non-NaN\n- Idempotent when values are non-NaN", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn is_nan(f: f32) -> bool;\n\nspec fn float_max(x: f32, y: f32) -> f32;", "vc-helpers": "", "vc-spec": "fn fmax(x: Vec<f32>, y: Vec<f32>) -> (result: Vec<f32>)\n    requires x@.len() == y@.len(),\n    ensures \n        result@.len() == x@.len(),\n        forall|i: int| 0 <= i < result@.len() ==> {\n            /* Core NaN handling behavior */\n            (!is_nan(x@[i]) && !is_nan(y@[i])) ==> \n                (result@[i] == float_max(x@[i], y@[i])) &&\n            (is_nan(x@[i]) && !is_nan(y@[i])) ==> \n                (result@[i] == y@[i]) &&\n            (!is_nan(x@[i]) && is_nan(y@[i])) ==> \n                (result@[i] == x@[i]) &&\n            (is_nan(x@[i]) && is_nan(y@[i])) ==> \n                is_nan(result@[i]) &&\n            /* Mathematical properties for non-NaN cases */\n            (!is_nan(x@[i]) && !is_nan(y@[i])) ==> \n                (result@[i] == x@[i] || result@[i] == y@[i]) &&\n            /* NaN preservation: result is NaN iff both inputs are NaN */\n            is_nan(result@[i]) <==> (is_nan(x@[i]) && is_nan(y@[i]))\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "VT0317", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_fmin", "vc-description": "Element-wise minimum of array elements.\n\nCompare two arrays and returns a new array containing the element-wise minima. If one of the elements being compared is a NaN, then the non-nan element is returned.\n\nElement-wise minimum of two vectors, with special NaN handling.\nIf one element is NaN, returns the non-NaN element.\n\nSpecification: fmin returns element-wise minimum with NaN handling.\nFor each position i:\n- If both elements are non-NaN, returns the minimum\n- If x[i] is NaN and y[i] is not, returns y[i]  \n- If y[i] is NaN and x[i] is not, returns x[i]\n- If both are NaN, returns NaN\n- Mathematical properties: commutativity (ignoring NaN order), \n  idempotence for non-NaN values, and boundedness", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn fmin(x: Vec<f32>, y: Vec<f32>) -> (result: Vec<f32>)\n    requires x@.len() == y@.len(),\n    ensures\n        result@.len() == x@.len(),\n        forall|i: int| 0 <= i < x@.len() ==> #[trigger] result@[i] == x@[i] || #[trigger] result@[i] == y@[i]", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "VT0318", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_fmod", "vc-description": "Returns the element-wise remainder of division where the remainder has the same sign as the dividend", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn fmod(x1: &Vec<f32>, x2: &Vec<f32>) -> (result: Vec<f32>)\n    requires x1.len() == x2.len(),\n    ensures result.len() == x1.len()", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0319", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_frexp", "vc-description": "numpy.frexp: Decompose the elements of x into mantissa and twos exponent.\n\nReturns (mantissa, exponent), where x = mantissa * 2**exponent.\nThe mantissa is in the range [0.5, 1) for positive numbers, (-1, -0.5] for negative numbers,\nor 0 if x is 0. The exponent is an integer.\n\nFor special values:\n- If x is 0, returns (0.0, 0)\n- If x is infinity, returns (infinity, 0)\n- If x is NaN, returns (NaN, 0)\n\nSpecification: frexp decomposes each element into mantissa and exponent such that\nx = mantissa * 2^exponent, where the mantissa is normalized to be in [0.5, 1) for\npositive values or (-1, -0.5] for negative values.\n\nPrecondition: True (no special preconditions)\nPostcondition: For all indices i:\n- If x[i] = 0, then mantissa[i] = 0 and exponent[i] = 0\n- If x[i] is finite and non-zero, then:\n  - x[i] = mantissa[i] * 2^exponent[i] (reconstruction property)\n  - 0.5 ≤ |mantissa[i]| < 1.0 (normalization property)\n  - mantissa[i] has same sign as x[i] (sign preservation)\n- If x[i] is infinity or NaN, then mantissa[i] = x[i] and exponent[i] = 0\n- Result vectors have same length as input (length preservation)\n\n/* Zero case: if input is zero, mantissa is zero and exponent is zero */\n\n/* Note: More complex properties like reconstruction (x = mantissa * 2^exponent),\n               normalization bounds, and sign preservation would require additional\n               floating-point operations that are not readily available in Verus specs */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn frexp(x: Vec<f32>) -> (result: (Vec<f32>, Vec<i8>))\n    ensures\n        result.0.len() == x.len(),\n        result.1.len() == x.len(),\n        forall|i: int| 0 <= i < x.len() ==> {\n\n            x[i] == 0.0f32 ==> result.0[i] == 0.0f32 && result.1[i] == 0\n\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0320", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_gcd", "vc-description": "numpy.gcd: Returns the greatest common divisor of |x1| and |x2|, element-wise.\n\nThe GCD is computed on the absolute values of the inputs. For two integers a and b,\ngcd(a, b) is the largest positive integer that divides both |a| and |b|.\n\nSpecial cases:\n- gcd(0, 0) = 0\n- gcd(a, 0) = |a| for any non-zero a\n- gcd(0, b) = |b| for any non-zero b\n\nReturns an array of the same shape as the broadcasted x1 and x2.\n\nSpecification: numpy.gcd returns a vector where each element is the\ngreatest common divisor of the absolute values of the corresponding elements in x1 and x2.\n\nMathematical properties verified:\n1. Correctness: result[i] = gcd(x1[i], x2[i])\n2. Non-negativity: result[i] ≥ 0 (GCD is always non-negative)\n3. Equivalence to absolute values: gcd(a, b) = gcd(|a|, |b|)\n4. Special cases: gcd(0,0)=0, gcd(a,0)=|a|, gcd(0,b)=|b|\n5. Divisibility: gcd(a,b) divides both a and b\n6. Greatest property: any common divisor of a and b also divides gcd(a,b)\n7. Commutativity: gcd(a,b) = gcd(b,a)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "#[verifier::external_body]\nspec fn gcd(a: int, b: int) -> int {\n    unimplemented!()\n}\n\nspec fn int_abs(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\nfn numpy_gcd(x1: Vec<i8>, x2: Vec<i8>) -> (result: Vec<i8>)\n    requires x1@.len() == x2@.len(),\n    ensures\n        result@.len() == x1@.len(),\n        forall|i: int| 0 <= i < result@.len() ==> #[trigger] result@[i] as int == gcd(x1@[i] as int, x2@[i] as int),\n        forall|i: int| 0 <= i < result@.len() ==> #[trigger] result@[i] >= 0,\n        forall|i: int| 0 <= i < result@.len() ==> gcd(x1@[i] as int, x2@[i] as int) == #[trigger] gcd(int_abs(x1@[i] as int), int_abs(x2@[i] as int)),\n        forall|i: int| 0 <= i < result@.len() ==> (x1@[i] == 0 && x2@[i] == 0) ==> #[trigger] result@[i] == 0,\n        forall|i: int| 0 <= i < result@.len() ==> (x1@[i] != 0 && x2@[i] == 0) ==> #[trigger] result@[i] as int == int_abs(x1@[i] as int),\n        forall|i: int| 0 <= i < result@.len() ==> (x1@[i] == 0 && x2@[i] != 0) ==> #[trigger] result@[i] as int == int_abs(x2@[i] as int),\n        forall|i: int| 0 <= i < result@.len() ==> #[trigger] (result@[i] as int) % (x1@[i] as int) == 0 && (result@[i] as int) % (x2@[i] as int) == 0,\n        forall|i: int| 0 <= i < result@.len() ==> gcd(x2@[i] as int, x1@[i] as int) == #[trigger] gcd(x1@[i] as int, x2@[i] as int),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0321", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_gradient", "vc-description": "numpy.gradient: Return the gradient of an N-dimensional array.\n\nThe gradient is computed using second order accurate central differences \nin the interior points and either first or second order accurate one-sided \n(forward or backwards) differences at the boundaries.\n\nFor a 1D array, the gradient is a vector of the same size where:\n- At the boundaries, one-sided differences are used\n- In the interior, central differences are used\n\nThis captures the rate of change of the function represented by the array.\n\nSpecification: numpy.gradient computes the numerical gradient using finite differences.\n\nThe gradient satisfies these mathematical properties:\n1. For a single point array (n = 0), the gradient is 0\n2. For arrays with multiple points (n > 0):\n   - At the first boundary (i = 0): uses forward difference grad[0] = f[1] - f[0]\n   - At the last boundary (i = n): uses backward difference grad[n] = f[n] - f[n-1]\n   - For interior points (0 < i < n): uses central difference grad[i] = (f[i+1] - f[i-1]) / 2\n3. The gradient has the same size as the input array\n4. The gradient approximates the derivative at each point\n\nThis specification assumes unit spacing between points. The actual numpy \nfunction can handle custom spacing, but we focus on the core mathematical behavior.\n\nMathematical properties:\n- For linear functions f(x) = ax + b, the gradient is constant and equal to a\n- For constant functions, the gradient is 0 everywhere\n- The gradient operation is linear: grad(f + g) = grad(f) + grad(g)\n\nPrecondition: True (non-empty constraint is in the type Vector Float (n + 1))\nPostcondition: The gradient is computed using appropriate finite difference formulas", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_gradient(f: Vec<f64>) -> (grad: Vec<f64>)\n    requires f.len() > 0,\n    ensures\n        grad.len() == f.len(),\n        f.len() == 1 ==> grad[0] == 0.0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0322", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_heaviside", "vc-description": "Compute the Heaviside step function.\n\nThe Heaviside step function is defined as:\n  0 if x1 < 0\n  x2 if x1 == 0\n  1 if x1 > 0\n\nCompute the Heaviside step function element-wise.\nReturns 0 if x < 0, x2 if x == 0, and 1 if x > 0.\n\nSpecification: The Heaviside function returns values based on the sign of x1 elements.\nFor each element:\n- If x1[i] < 0, result[i] = 0\n- If x1[i] = 0, result[i] = x2[i]\n- If x1[i] > 0, result[i] = 1\n\nThis specification captures the complete behavior of the heaviside step function\nincluding the crucial property that it's completely determined by the sign of x1\nand uses x2 as the value at the discontinuity point.\n\n// uninterpreted function representing x == 0.0\n\n// uninterpreted function representing x > 0.0\n\n// uninterpreted function representing x < 0.0", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_zero(x: f32) -> bool {\n    true\n}\n\nspec fn is_positive(x: f32) -> bool {\n    true\n}\n\nspec fn is_negative(x: f32) -> bool {\n    true\n}\n\nfn heaviside(x1: Vec<f32>, x2: Vec<f32>) -> (result: Vec<f32>)\n    requires x1.len() == x2.len(),\n    ensures \n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < x1.len() ==> {\n            (is_negative(x1[i]) ==> result[i] == 0.0f32) &&\n            (is_zero(x1[i]) ==> result[i] == x2[i]) &&\n            (is_positive(x1[i]) ==> result[i] == 1.0f32) &&\n            (result[i] == 0.0f32 || result[i] == 1.0f32 || result[i] == x2[i])\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0323", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_hypot", "vc-description": "numpy.hypot: Given the 'legs' of a right triangle, return its hypotenuse.\n\nComputes the hypotenuse of a right triangle given the lengths of its two legs.\nThis is equivalent to sqrt(x1^2 + x2^2), but is implemented in a way that\navoids overflow for large values.\n\nThe function operates element-wise on the input vectors, computing the\nhypotenuse for each pair of corresponding elements.\n\nSpecification: numpy.hypot returns a vector where each element is the\nhypotenuse computed from the corresponding elements of x1 and x2.\n\nPrecondition: True (no special preconditions)\nPostcondition: For all indices i, result[i] = sqrt(x1[i]² + x2[i]²)\n\nMathematical properties:\n1. The result is always non-negative\n2. The result follows the Pythagorean theorem\n3. The result is symmetric: hypot(a, b) = hypot(b, a)\n4. For positive inputs, hypot(a, b) ≥ max(Float.abs(a), Float.abs(b))\n5. hypot(0, a) = Float.abs(a) and hypot(a, 0) = Float.abs(a)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_hypot(x1: Vec<f32>, x2: Vec<f32>) -> (result: Vec<f32>)\n    requires x1.len() == x2.len(),\n    ensures \n        result.len() == x1.len(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0324", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_i0", "vc-description": "Modified Bessel function of the first kind, order 0.\n\nComputes the Modified Bessel function of the first kind, order 0, element-wise.\nThis is a special function that arises in many mathematical contexts including\nsolutions to differential equations and probability theory.\n\nThe function is defined by the infinite series:\ni0(x) = sum((x/2)^(2k) / (k!)^2, k=0..inf)\n\nReturns an array of the same shape as x, containing the i0 values of each element.\n\nSpecification: numpy.i0 returns a vector where each element is the Modified\nBessel function of the first kind, order 0, of the corresponding element in x.\n\nMathematical properties:\n1. i0(0) = 1 (by definition, the series starts with 1)\n2. i0(x) > 0 for all real x (positive function)\n3. i0(x) = i0(-x) (even function)\n4. i0(x) is monotonically increasing for x ≥ 0\n5. For large x, i0(x) ≈ exp(|x|) / sqrt(2π|x|) (asymptotic behavior)\n\nPrecondition: True (no special preconditions for i0)\nPostcondition: For all indices i, result[i] = i0(x[i]) with the mathematical properties above", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn i0(x: Vec<i8>) -> (result: Vec<i8>)\n    requires true,\n    ensures \n        result@.len() == x@.len(),\n        forall|i: int| 0 <= i < result@.len() ==> {\n            /* Basic function evaluation - i0(x) > 0 for all x (positive function) */\n            result@[i] as int > 0 &&\n            /* Zero case: i0(0) = 1 */\n            (x@[i] as int == 0 ==> result@[i] as int == 1) &&\n            /* Even function: i0(x) = i0(-x) */\n            (forall|j: int| 0 <= j < x@.len() && x@[j] as int == -(x@[i] as int) ==> result@[j] as int == result@[i] as int) &&\n            /* Monotonicity for non-negative values */\n            (forall|j: int| 0 <= j < x@.len() && x@[i] as int >= 0 && x@[j] as int >= 0 && x@[i] as int <= x@[j] as int ==> result@[i] as int <= result@[j] as int)\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0325", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_imag", "vc-description": "Return the imaginary part of the complex argument. For a vector where each element is represented as a pair (real, imaginary), extracts the imaginary component of each element. For real numbers (where imaginary part is 0), returns 0.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn imag(val: Vec<(f64, f64)>) -> (result: Vec<f64>)\n    ensures\n        result.len() == val.len(),\n        forall|i: int| 0 <= i < val.len() ==> result[i as int] == val[i as int].1,\n        forall|i: int| 0 <= i < val.len() ==> (val[i as int].1 == 0.0 ==> result[i as int] == 0.0),\n        forall|i: int| 0 <= i < val.len() ==> (val[i as int].0 != 0.0 || val[i as int].1 != 0.0 ==> result[i as int] == val[i as int].1),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0326", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_interp", "vc-description": "One-dimensional linear interpolation for monotonically increasing sample points.\nReturns the one-dimensional piecewise linear interpolant to a function with given\ndiscrete data points (xp, fp), evaluated at x.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn interp(x: Vec<i32>, xp: Vec<i32>, fp: Vec<i32>) -> (result: Vec<i32>)\n    requires \n        xp.len() > 0,\n        fp.len() == xp.len(),\n        x.len() > 0,\n        forall|i: int, j: int| 0 <= i < j < xp.len() ==> xp[i] < xp[j],\n    ensures \n        result.len() == x.len(),\n        forall|k: int| 0 <= k < x.len() ==> (\n            (x[k] <= xp[0] ==> result[k] == fp[0]) &&\n            (x[k] >= xp[xp.len() - 1] ==> result[k] == fp[fp.len() - 1])\n        )", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0327", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_lcm", "vc-description": "Returns the lowest common multiple of |x1| and |x2| element-wise.\n\nComputes the lowest common multiple (LCM) of the absolute values of \nthe elements in x1 and x2. The LCM is the smallest non-negative integer \nthat is a multiple of both |x1| and |x2|.\n\nMathematical Properties:\n- lcm(a, b) = lcm(b, a) (commutativity)\n- lcm(a, b) * gcd(a, b) = |a * b| (fundamental relationship)\n- lcm(0, b) = lcm(a, 0) = 0 (zero property)\n- lcm(a, b) ≥ 0 (non-negativity)\n- |a| divides lcm(a, b) and |b| divides lcm(a, b) (divisibility)\n- lcm(a, b) is minimal among all positive integers divisible by both |a| and |b|\n\n/* Basic correctness: each element is the LCM of corresponding elements */\n\n/* Non-negativity: LCM is always non-negative */\n\n/* Zero property: LCM with zero is zero */\n\n/* Special case: when both are non-zero, LCM is positive */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn gcd_spec(a: int, b: int) -> nat;\n\nspec fn lcm_spec(a: int, b: int) -> nat;\n\nfn lcm(x1: Vec<i8>, x2: Vec<i8>) -> (result: Vec<i8>)\n    requires x1.len() == x2.len(),\n    ensures \n        result.len() == x1@.len(),\n\n        forall|i: int| 0 <= i < result@.len() ==> result@[i] >= 0,\n\n        forall|i: int| 0 <= i < result@.len() ==> result@[i] >= 0,\n\n        forall|i: int| 0 <= i < result@.len() ==> \n            (x1@[i] == 0 || x2@[i] == 0) ==> result@[i] == 0,\n\n        forall|i: int| 0 <= i < result@.len() ==> \n            (x1@[i] != 0 && x2@[i] != 0) ==> result@[i] > 0", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0328", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_ldexp", "vc-description": "Returns x1 * 2**x2, element-wise.\nThe mantissas x1 and twos exponents x2 are used to construct floating point numbers x1 * 2**x2.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn ldexp_value(x1: f32, x2: i32) -> f32;\n\nfn ldexp(x1: Vec<f32>, x2: Vec<i32>) -> (result: Vec<f32>)\n    requires x1.len() == x2.len(),\n    ensures\n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == ldexp_value(x1[i], x2[i])", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0329", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_log", "vc-description": "numpy.log: Natural logarithm, element-wise.\n\nThe natural logarithm log is the inverse of the exponential function,\nso that log(exp(x)) = x. The natural logarithm is logarithm base e.\n\nReturns an array of the same shape as x, containing the natural logarithm\nof each element in x.\n\nNote: The domain of the natural logarithm is the positive real numbers.\nMathematically, log(x) is undefined for x ≤ 0.\n\nSpecification: log returns a vector where each element is the natural\nlogarithm of the corresponding element in x.\n\nPrecondition: All elements must be positive (x[i] > 0)\nPostcondition: For all indices i, result[i] = log(x[i])\n\nMathematical properties:\n- log is the inverse of exp: log(exp(x)) = x\n- log(1) = 0\n- log(e) = 1\n- log(x*y) = log(x) + log(y) for positive x, y\n- log is strictly increasing on (0, ∞)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn log(x: Vec<i8>) -> (result: Vec<i8>)\n    requires \n        x@.len() > 0,\n        forall|i: int| 0 <= i < x@.len() ==> x[i] as int > 0,\n    ensures \n        result@.len() == x@.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0330", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_log1p", "vc-description": "numpy.log1p: Return the natural logarithm of one plus the input array, element-wise.\n\nCalculates log(1 + x). This function provides greater precision than log(1 + x) \nfor small values of x near zero, where the naive computation would suffer from \nfloating-point precision loss.\n\nReturns an array of the same shape as x, containing log(1 + x) for each element.\n\nNote: The domain is x > -1 (since log(1 + x) requires 1 + x > 0).\nFor x = -1, the result is -∞ (negative infinity).\nFor x < -1, the result is NaN (not a number).\n\nSpecification: log1p returns a vector where each element is the natural\nlogarithm of one plus the corresponding element in x.\n\nPrecondition: All elements must be greater than -1 (x[i] > -1)\nPostcondition: For all indices i, result[i] = log(1 + x[i])\n\nMathematical properties:\n- log1p(0) = log(1) = 0\n- log1p(e - 1) = 1\n- log1p provides better precision than log(1 + x) for small x\n- log1p is strictly increasing on (-1, ∞)\n- log1p(x) = log(1 + x) for all valid x\n- For small x, log1p(x) ≈ x - x²/2 + x³/3 - ...", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn log1p(x: Vec<i8>) -> (result: Vec<i8>)\n    requires \n        x.len() > 0,\n        forall|i: int| 0 <= i < x.len() ==> x[i] as int > -1,\n    ensures \n        result.len() == x.len(),\n        forall|i: int| 0 <= i < x.len() && x[i] as int == 0 ==> result[i] as int == 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0331", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_log2", "vc-description": "numpy.log2: Base-2 logarithm of x, element-wise.\n\nThe base-2 logarithm is the inverse of the exponential function with base 2,\nso that log2(2^x) = x. This is useful for computing the number of bits needed\nto represent a number or for operations involving powers of 2.\n\nReturns an array of the same shape as x, containing the base-2 logarithm\nof each element in x.\n\nSpecification: log2 returns a vector where each element is the base-2\nlogarithm of the corresponding element in x.\n\nPrecondition: All elements must be positive (x[i] > 0) since the logarithm\nis only defined for positive real numbers.\n\nPostcondition: For all indices i, result[i] = Float.log2 x[i]\n\nMathematical properties:\n- log2(2^x) = x for any x\n- log2(x * y) = log2(x) + log2(y) for positive x, y\n- log2(x / y) = log2(x) - log2(y) for positive x, y\n- log2(1) = 0\n- log2(2) = 1", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn log2(x: Vec<f32>) -> (result: Vec<f32>)\n    requires x.len() > 0,\n    ensures result.len() == x.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0332", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_log10", "vc-description": "numpy.log10: Return the base 10 logarithm of the input array, element-wise.\n\nThe base 10 logarithm log10 is the logarithm to the base 10.\nIt is the inverse of the exponential function with base 10,\nso that log10(10^x) = x.\n\nReturns an array of the same shape as x, containing the base 10 logarithm\nof each element in x.\n\nSpecification: numpy.log10 returns a vector where each element is the base 10\nlogarithm of the corresponding element in x.\n\nPrecondition: All elements must be positive (x[i] > 0)\nPostcondition: For all indices i, result[i] = Float.log10 x[i]\n\nMathematical properties:\n1. log10(10^a) = a for positive a\n2. log10(a * b) = log10(a) + log10(b) for positive a, b  \n3. log10(1) = 0\n4. log10(10) = 1\n5. Monotonic: a < b implies log10(a) < log10(b) for positive a, b", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_log10(x: Vec<f32>) -> (result: Vec<f32>)\n    requires \n        x@.len() > 0,\n    ensures \n        result@.len() == x@.len(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0333", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_logaddexp", "vc-description": "numpy.logaddexp: Logarithm of the sum of exponentiations of the inputs.\n\nCalculates log(exp(x1) + exp(x2)) element-wise. This function is useful \nin statistics where the calculated probabilities of events may be so small \nas to exceed the range of normal floating point numbers.\n\nThe logaddexp function provides a numerically stable way to compute\nlog(exp(x1) + exp(x2)) without intermediate overflow or underflow.\n\nMathematical properties:\n- logaddexp(x, x) = x + log(2)\n- logaddexp(x, -∞) = x\n- logaddexp(-∞, x) = x\n- logaddexp is symmetric: logaddexp(x, y) = logaddexp(y, x)\n- logaddexp is associative in the sense that it satisfies the log-sum-exp properties\n- logaddexp(x, y) ≥ max(x, y) for all x, y\n\nFrom NumPy documentation:\n- Parameters: x1, x2 (array_like) - Input arrays\n- Returns: ndarray - The element-wise logaddexp of the inputs\n\nSpecification: numpy.logaddexp returns a vector where each element is the\nlogarithm of the sum of exponentiations of the corresponding elements.\n\nMathematical Properties:\n1. Element-wise correctness: result[i] = log(exp(x1[i]) + exp(x2[i]))\n2. Commutativity: logaddexp(x1, x2) = logaddexp(x2, x1)\n3. Numerical stability: avoids intermediate overflow/underflow\n4. Bounds: logaddexp(x, y) ≥ max(x, y) for all x, y\n5. Special cases: \n   - logaddexp(x, x) = x + log(2)\n   - logaddexp(x, -∞) = x (when x is finite)\n   - logaddexp(-∞, x) = x (when x is finite)\n6. Monotonicity: logaddexp is monotonically increasing in both arguments\n7. Associativity property: satisfies log-sum-exp algebraic relations\n\nPrecondition: True (logaddexp is defined for all real numbers)\nPostcondition: For all indices i, result[i] = log(exp(x1[i]) + exp(x2[i]))\n               and result[i] ≥ max(x1[i], x2[i])", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n#[verifier::external_body]\nspec fn logaddexp_value(x1: f64, x2: f64) -> f64;", "vc-helpers": "", "vc-spec": "fn logaddexp(x1: Vec<f64>, x2: Vec<f64>) -> (result: Vec<f64>)\n    requires x1.len() == x2.len(),\n    ensures \n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> {\n            result[i] == logaddexp_value(x1[i], x2[i])\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0334", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_logaddexp2", "vc-description": "numpy.logaddexp2: Logarithm of the sum of exponentiations of the inputs in base-2.\n\nCalculates log2(2^x1 + 2^x2) element-wise. This function is mathematically equivalent to\nlog2(2^x1 + 2^x2) but is computed in a numerically stable way that avoids overflow for\nlarge input values.\n\nThe function is useful for numerical computations where you need to add exponentials\nwithout causing overflow, particularly in machine learning and statistical applications.\n\nReturns an array of the same shape as the input arrays, containing the base-2 logarithm\nof the sum of exponentiations of corresponding elements.\n\nSpecification: numpy.logaddexp2 returns a vector where each element is the base-2\nlogarithm of the sum of exponentiations of the corresponding elements in x1 and x2.\n\nPrecondition: True (no special preconditions - numerically stable for all finite values)\nPostcondition: For all indices i, result[i] = log2(2^x1[i] + 2^x2[i])\n\nMathematical properties:\n- Commutativity: logaddexp2(x1, x2) = logaddexp2(x2, x1)\n- Monotonicity: If x1 ≤ y1 and x2 ≤ y2, then logaddexp2(x1, x2) ≤ logaddexp2(y1, y2)\n- Bounds: max(x1, x2) ≤ logaddexp2(x1, x2) ≤ max(x1, x2) + 1", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_logaddexp2(x1: Vec<f32>, x2: Vec<f32>) -> (result: Vec<f32>)\n    requires x1.len() == x2.len(),\n    ensures result.len() == x1.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0335", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_maximum", "vc-description": "numpy.maximum: Element-wise maximum of array elements.\n\nCompares two arrays element-wise and returns a new array containing\nthe element-wise maxima. If one of the elements being compared is NaN,\nthen that element is returned.\n\nThis is a universal function (ufunc) that operates element-wise on arrays\nand supports broadcasting. For 1D arrays, it computes the maximum of\ncorresponding elements.\n\nSpecification: numpy.maximum returns a vector where each element is the maximum\nof the corresponding elements from x1 and x2.\n\nMathematical properties:\n1. Commutativity: maximum(x1, x2) = maximum(x2, x1)\n2. Associativity: maximum(maximum(x1, x2), x3) = maximum(x1, maximum(x2, x3))\n3. Idempotence: maximum(x, x) = x\n4. Monotonicity: if x1[i] ≤ y1[i] and x2[i] ≤ y2[i], then maximum(x1, x2)[i] ≤ maximum(y1, y2)[i]\n5. Identity: maximum(x, -∞) = x (where -∞ is negative infinity)\n\nPrecondition: True (no special preconditions for element-wise maximum)\nPostcondition: For all indices i, result[i] = max(x1[i], x2[i])", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn maximum(x1: Vec<i8>, x2: Vec<i8>) -> (result: Vec<i8>)\n    requires x1.len() == x2.len(),\n    ensures \n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> \n            result@[i] == if x1@[i] >= x2@[i] { x1@[i] } else { x2@[i] },\n        forall|i: int| 0 <= i < result.len() ==> \n            result@[i] >= x1@[i] && result@[i] >= x2@[i],\n        forall|i: int| 0 <= i < result.len() ==> \n            result@[i] == x1@[i] || result@[i] == x2@[i],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0336", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_minimum", "vc-description": "numpy.minimum: Element-wise minimum of array elements.\n\nCompare two arrays and returns a new array containing the element-wise minima.\nIf one of the elements being compared is NaN, then that element is returned.\n\nThis is different from numpy.min which returns a single minimum value.\nThis function performs element-wise comparison and returns a new array.\n\nBinary universal function: minimum(x1, x2)\n\nParameters:\n- x1, x2: Vector Float n - Input vectors of the same size\n\nReturns:\n- Vector Float n - The element-wise minimum of x1 and x2\n\nSpecification: numpy.minimum returns a vector where each element is the minimum\nof the corresponding elements from x1 and x2.\n\nMathematical properties:\n1. Commutativity: min(a, b) = min(b, a)\n2. Associativity: min(min(a, b), c) = min(a, min(b, c))\n3. Idempotency: min(a, a) = a\n4. Element-wise operation: result[i] = min(x1[i], x2[i]) for all i\n5. NaN propagation: if either x1[i] or x2[i] is NaN, result[i] is NaN\n\nPrecondition: True (no special preconditions for element-wise minimum)\nPostcondition: For all indices i, result[i] = min(x1[i], x2[i])", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn minimum(x1: Vec<f32>, x2: Vec<f32>) -> (result: Vec<f32>)\n    requires x1.len() == x2.len(),\n    ensures \n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result@.len() ==> \n            (result@[i] == x1@[i] || result@[i] == x2@[i]),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0337", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_mod", "vc-description": "numpy.mod: Returns the element-wise remainder of division.\n\nComputes the remainder complementary to the floor_divide function.\nThis is equivalent to x1 % x2 in terms of array broadcasting.\n\nThe result has the same sign as the divisor x2.\nFor two arguments of floating point type, the result is:\nx1 - floor(x1/x2) * x2\n\nSpecification: numpy.mod returns a vector where each element is the remainder\nof the corresponding elements from x1 and x2.\n\nPrecondition: All elements in x2 must be non-zero\nPostcondition: For all indices i, result[i] = x1[i] % x2[i]\n\nMathematical properties:\n1. The result has the same sign as x2[i] (when x2[i] ≠ 0)\n2. The absolute value of result[i] is less than the absolute value of x2[i]\n3. x1[i] = floor(x1[i] / x2[i]) * x2[i] + result[i]", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_mod(x1: Vec<i8>, x2: Vec<i8>) -> (result: Vec<i8>)\n    requires \n        x1.len() == x2.len(),\n        forall|i: int| 0 <= i < x2.len() ==> x2[i] != 0,\n    ensures\n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> \n            #[trigger] result[i] == x1[i] % x2[i],\n        forall|i: int| 0 <= i < result.len() ==> {\n            let r = #[trigger] result[i];\n            let a = x1[i];\n            let b = x2[i];\n            /* Basic remainder property: a = floor_div(a, b) * b + r */\n            a == (a / b) * b + r &&\n            /* Result has same sign as divisor (when divisor is non-zero) */\n            (b > 0 ==> r >= 0 && r < b) &&\n            (b < 0 ==> r <= 0 && r > b)\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0338", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_modf", "vc-description": "numpy.modf: Return the fractional and integral parts of an array, element-wise.\n\nReturns a tuple (fractional_parts, integral_parts) where both parts\nhave the same sign as the input. The fractional and integral parts\nare negative if the given number is negative.\n\nSpecification: numpy.modf returns fractional and integral parts where:\n1. The fractional and integral parts sum to the original value\n2. The fractional part has absolute value less than 1\n3. Both parts have the same sign as the original number (or zero)\n4. The integral part is the truncated integer part\n\nPrecondition: True (no special preconditions for modf)\nPostcondition: For all indices i, the fractional and integral parts satisfy mathematical properties", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_modf(x: Vec<f32>) -> (result: (Vec<f32>, Vec<f32>))\n    ensures\n        result.0.len() == x.len(),\n        result.1.len() == x.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0339", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_multiply", "vc-description": "numpy.multiply: Multiply arguments element-wise.\n\nMultiplies two vectors element-wise. If the vectors have the same shape,\neach element of the result is the product of the corresponding elements\nfrom the input vectors.\n\nThis is equivalent to x1 * x2 in terms of array broadcasting.\nThe function supports all numeric types and handles overflow according\nto the IEEE 754 standard for floating-point arithmetic.\n\nFrom NumPy documentation:\n- Parameters: x1, x2 (array_like) - The arrays to be multiplied\n- Returns: multiply (ndarray) - The product of x1 and x2, element-wise\n- The function is a universal function (ufunc) implemented in C\n- Uses optimized C loops for different data types\n\nSpecification: numpy.multiply returns a vector where each element is the product\nof the corresponding elements from x1 and x2.\n\nMathematical Properties:\n1. Element-wise correctness: result[i] = x1[i] * x2[i]\n2. Commutativity: multiply(x1, x2) = multiply(x2, x1)\n3. Associativity: multiply(multiply(x1, x2), x3) = multiply(x1, multiply(x2, x3))\n4. Identity: multiply(x, ones) = x\n5. Zero property: multiply(x, zeros) = zeros\n6. Preserves vector length: result.size = x1.size = x2.size\n7. Handles finite arithmetic: supports IEEE 754 floating-point multiplication\n8. Distributivity over addition: multiply(x1, add(x2, x3)) = add(multiply(x1, x2), multiply(x1, x3))\n\nPrecondition: True (no special preconditions for basic multiplication)\nPostcondition: For all indices i, result[i] = x1[i] * x2[i]", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn multiply(x1: Vec<i8>, x2: Vec<i8>) -> (result: Vec<i8>)\n    requires x1.len() == x2.len(),\n    ensures \n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] as int == (x1[i] as int) * (x2[i] as int)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0340", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_nan_to_num", "vc-description": "Replace NaN with zero and infinity with large finite numbers element-wise\n\nSpecification: nan_to_num replaces non-finite floating-point values with finite alternatives:\n1. NaN replacement: All NaN values are replaced with 0.0\n2. Positive infinity replacement: All positive infinity values are replaced with a large finite value  \n3. Negative infinity replacement: All negative infinity values are replaced with a large negative finite value\n4. Finite value preservation: All finite values remain unchanged\n5. All results are finite: The output contains only finite floating-point numbers", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn nan_to_num(x: Vec<f64>) -> (result: Vec<f64>)\n    ensures \n        result.len() == x.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0341", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_nancumprod", "vc-description": "Return the cumulative product of array elements over a given axis treating Not a Numbers (NaNs) as one.\n\nReturn the cumulative product of array elements treating NaNs as 1.\nThe cumulative product does not change when NaNs are encountered and leading NaNs are replaced by ones.\n\nSpecification: nancumprod returns the cumulative product while treating NaN values as 1.\nThis means:\n1. The resulting array has the same size as the input\n2. Each element is the product of all non-NaN elements from the start up to that position\n3. NaN values are treated as 1 in the product calculation\n4. Leading NaNs are replaced by ones\n5. The cumulative product property holds for non-NaN values\n\n/* Complex mathematical properties involving cumulative products and NaN handling\n           would require additional specification functions for float arithmetic */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn nancumprod(arr: Vec<f32>) -> (result: Vec<f32>)\n    ensures \n        result.len() == arr.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0342", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_nancumsum", "vc-description": "numpy.nancumsum: Return the cumulative sum of array elements treating NaN as zero.\n\nFor a 1D array, nancumsum computes the cumulative sum where NaN values are treated as zero.\nUnlike regular cumsum, NaN values do not propagate and are replaced with zero during computation.\n\nExamples:\n- [1, NaN, 3] becomes [1, 1, 4] (NaN treated as 0)\n- [NaN, 2, 3] becomes [0, 2, 5] (leading NaN becomes 0)\n- [1, 2, NaN, 4] becomes [1, 3, 3, 7] (NaN contributes 0 to sum)\n\nThe cumulative sum with NaN handling is defined as:\n- result[0] = if a[0].isNaN then 0 else a[0]\n- result[i] = result[i-1] + (if a[i].isNaN then 0 else a[i]) for i > 0\n\nSpecification: nancumsum returns a vector where each element is the cumulative sum\nup to that position with NaN values treated as zero.\n\nPrecondition: True (no special preconditions)\nPostcondition:\n- Result has the same length as input\n- NaN values are treated as zero in the cumulative sum computation\n- For non-empty vectors, first element is either a[0] or 0 if a[0] is NaN\n- Each subsequent element is the previous cumulative sum plus current element (or 0 if NaN)\n- The cumulative sum preserves the NaN-as-zero semantics throughout", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn nancumsum(a: Vec<i8>) -> (result: Vec<i8>)\n    ensures\n        result.len() == a.len(),\n        a.len() > 0 ==> (result[0] as int == a[0] as int),\n        forall|i: int| 0 < i < result.len() ==> result[i] as int == result[i-1] as int + a[i] as int,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0343", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_nanprod", "vc-description": "Return the product of array elements over a given axis treating Not a Numbers (NaNs) as ones.\n\nnumpy.nanprod: Return the product of array elements treating NaNs as ones.\n\nComputes the product of all elements in the array, treating NaN values as 1.\nThis is useful for computing products while ignoring missing or invalid data\nrepresented as NaN.\n\nFor empty arrays, returns 1 as the identity element of multiplication.\nFor arrays containing only NaN values, returns 1.\nFor arrays with mixed NaN and non-NaN values, returns the product of the non-NaN values.\n\nSpecification: numpy.nanprod returns the product of all non-NaN elements in the vector.\n\nPrecondition: True (works for any vector, including empty)\nPostcondition: result equals the product of all non-NaN elements, satisfying:\n1. NaN values are treated as 1 (multiplicative identity)\n2. Empty vectors return 1\n3. Vectors with only NaN values return 1\n4. The result is mathematically equivalent to filtering out NaN values and taking the product\n5. The result is never NaN (since NaN values are ignored)\n6. If no NaN values exist, this behaves identically to regular product", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn product_of_non_nan_elements(a: Seq<f32>) -> f32 {\n    arbitrary()\n}\n\nfn nanprod(a: Vec<f32>) -> (result: f32)\n    ensures result == product_of_non_nan_elements(a@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0344", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_nansum", "vc-description": "Return the sum of array elements over a given axis treating Not a Numbers (NaNs) as zero\n\nReturn the sum of array elements treating NaN values as zero\n\nSpecification: nansum computes the sum of array elements treating NaN values as zero", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn nansum(a: Vec<f32>) -> (result: f32)\n    ensures\n        /* If vector is empty, result is 0 */\n        a.len() == 0 ==> result == 0.0f32,\n        /* Core property: nansum handles NaN values by treating them as zero */\n        true,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0345", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_negative", "vc-description": "numpy.negative: Numerical negative, element-wise.\n\nComputes the negative of each element in the input array.\nThis is equivalent to -x in terms of array operations.\n\nReturns an array of the same shape as x, containing the negated values.\n\nSpecification: numpy.negative returns a vector where each element is the\nnegative of the corresponding element in x.\n\nPrecondition: True (no special preconditions for negation)\nPostcondition: For all indices i, result[i] = -x[i]\n\nMathematical Properties:\n- Involution: -(-x) = x\n- Additive inverse: x + (-x) = 0\n- Preserves magnitude: |(-x)| = |x|", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_negative(x: Vec<i8>) -> (result: Vec<i8>)\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < x.len() ==> result[i] as int == -(x[i] as int)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0346", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_nextafter", "vc-description": "numpy.nextafter: Return the next floating-point value after x1 towards x2, element-wise.\n\nReturns the next representable floating-point value after x1 in the direction of x2.\nThis function is essential for numerical computing and provides fine-grained control\nover floating-point precision. It's based on the C math library's nextafter function.\n\nFor each element pair (x1[i], x2[i]):\n- If x1[i] == x2[i], returns x1[i]\n- If x1[i] < x2[i], returns the smallest floating-point value greater than x1[i]\n- If x1[i] > x2[i], returns the largest floating-point value less than x1[i]\n\nSpecial cases:\n- nextafter(x, +∞) returns the next value towards positive infinity\n- nextafter(x, -∞) returns the next value towards negative infinity\n- nextafter(±∞, y) returns ±∞ for any finite y\n- nextafter(NaN, y) or nextafter(x, NaN) returns NaN\n\nThis function is crucial for:\n- Numerical differentiation algorithms\n- Root finding methods requiring precise stepping\n- Testing floating-point precision limits\n- Implementing robust numerical algorithms\n\nSpecification: numpy.nextafter returns a vector where each element is the next\nrepresentable floating-point value after x1[i] in the direction of x2[i].\n\nPrecondition: True (no special preconditions for nextafter)\nPostcondition: For all indices i:\n  - If x1[i] == x2[i], then result[i] = x1[i]\n  - If x1[i] < x2[i], then result[i] is the smallest float greater than x1[i]\n  - If x1[i] > x2[i], then result[i] is the largest float less than x1[i]\n\nMathematical properties:\n  1. Direction consistency: result[i] moves towards x2[i]\n  2. Monotonicity: if x1[i] < x2[i], then x1[i] < result[i] ≤ x2[i]\n  3. Minimal step: result[i] is the closest representable value to x1[i] in direction of x2[i]\n  4. Symmetry: nextafter(nextafter(x, y), x) moves back towards x\n  5. Identity: nextafter(x, x) = x\n  6. Finite precision: respects IEEE 754 floating-point representation", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn nextafter(x1: Vec<i8>, x2: Vec<i8>) -> (result: Vec<i8>)\n    requires x1.len() == x2.len(),\n    ensures \n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> {\n            /* Identity case: when x1 equals x2, result equals x1 */\n            (x1[i] == x2[i] ==> result[i] == x1[i]) &&\n            /* Direction consistency: result moves towards x2 */\n            ((x1[i] < x2[i] ==> x1[i] < result[i] && result[i] <= x2[i]) &&\n             (x1[i] > x2[i] ==> x1[i] > result[i] && result[i] >= x2[i])) &&\n            /* Finiteness preservation: if both inputs are finite and different, result is defined */\n            (x1[i] != x2[i] ==> true)\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0347", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_positive", "vc-description": "numpy.positive: Numerical positive, element-wise.\n\nReturns a copy of the input array with the same values.\nThis is equivalent to the unary plus operator (+x) and \nis only defined for types that support arithmetic operations.\n\nThe function performs element-wise positive operation, which\nfor real numbers simply returns the same value.\n\nSpecification: numpy.positive returns a vector where each element is\nthe positive of the corresponding element in x (which is the same value).\n\nPrecondition: True (no special preconditions for positive operation)\nPostcondition: For all indices i, result[i] = +x[i] = x[i]\n\nMathematical Properties:\n- Identity operation: positive(x) = x\n- Idempotence: positive(positive(x)) = positive(x)\n- Preserves sign: sign(positive(x)) = sign(x)\n- Preserves magnitude: |positive(x)| = |x|\n- Distributivity with multiplication: positive(x) * y = x * y", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn positive(x: Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == x[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0348", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_power", "vc-description": "numpy.power: First array elements raised to powers from second array, element-wise.\n\nRaise each base in x1 to the positionally-corresponding power in x2.\nThis is equivalent to x1 ** x2 in terms of array broadcasting.\n\nThe function computes x1[i] raised to the power x2[i] for each index i.\n\nMathematical properties:\n- x^0 = 1 for any non-zero x\n- x^1 = x for any x\n- x^(a+b) = x^a * x^b for any x, a, b\n- (x^a)^b = x^(a*b) for any x, a, b\n\nSpecification: numpy.power returns a vector where each element is the base\nfrom x1 raised to the power from x2.\n\nPrecondition: For mathematical validity, we require:\n- If x1[i] = 0, then x2[i] ≥ 0 (0^negative is undefined)\n- If x1[i] < 0, then x2[i] should be an integer (for real results, checked by floor = value)\n\nPostcondition: For all indices i, result[i] = x1[i] ^ x2[i]\n\nKey mathematical properties ensured:\n1. Identity: If x2[i] = 0 and x1[i] ≠ 0, then result[i] = 1\n2. Base case: If x2[i] = 1, then result[i] = x1[i]\n3. Monotonicity: If x1[i] > 1 and x2[i] > 0, then result[i] > x1[i]", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_power(x1: Vec<i8>, x2: Vec<i8>) -> (result: Vec<i8>)\n    requires \n        x1.len() == x2.len(),\n        forall|i: int| 0 <= i < x1@.len() ==> {\n            (x1[i] == 0 ==> x2[i] as int >= 0)\n        },\n    ensures\n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result@.len() ==> {\n            (x2[i] as int == 0 && x1[i] as int != 0 ==> result[i] as int == 1) &&\n            (x2[i] as int == 1 ==> result[i] as int == x1[i] as int) &&\n            (x1[i] as int > 1 && x2[i] as int > 0 ==> result[i] as int > x1[i] as int)\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0349", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_prod", "vc-description": "numpy.prod: Return the product of array elements over a given axis.\n\nComputes the product of all elements in the vector. For empty vectors,\nreturns 1 as the identity element of multiplication.\n\nThis is a reduction operation that applies multiplication across all\nelements to produce a single scalar result.\n\nMathematical Properties:\n- Commutative: order of elements doesn't affect the final product\n- Associative: grouping of operations doesn't affect the result\n- Identity element: empty array product is 1\n- Contains zero: if any element is zero, the product is zero\n\nSpecification: prod computes the product of all elements in a vector.\n\nThe product operation has several important mathematical properties:\n1. For empty vectors, returns 1 (multiplicative identity)\n2. For non-empty vectors, returns the product of all elements\n3. If any element is zero, the result is zero\n4. The operation is commutative and associative\n\nThis specification captures both the basic behavior and key mathematical\nproperties that make prod well-defined and predictable.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn vec_product_int(a: Seq<i32>) -> int \n    decreases a.len()\n{\n    if a.len() == 0 {\n        1\n    } else {\n        (a[0] as int) * vec_product_int(a.skip(1))\n    }\n}\n\nfn prod(a: Vec<i8>) -> (result: i8)\n    ensures \n        result as int == vec_product_int(a@.map(|i, x| x as i32)),\n        a.len() == 0 ==> result == 1,\n        (exists|i: int| 0 <= i < a.len() && a[i] == 0) ==> result == 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0351", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_radians", "vc-description": "numpy.radians: Convert angles from degrees to radians.\n\nConverts angles from degrees to radians element-wise.\nThe conversion formula is: radians = degrees * π / 180\n\nParameters:\n- x: Input array in degrees\n\nReturns:\n- y: Array of the same shape as x, containing the corresponding radian values\n\nSpecification: numpy.radians converts each element from degrees to radians.\n\nPrecondition: True (no special preconditions for degree to radian conversion)\nPostcondition: For all indices i, result[i] = x[i] * π / 180\n\nMathematical properties verified:\n- Linear conversion: radians = degrees * (π / 180)\n- 0 degrees = 0 radians\n- 180 degrees = π radians  \n- 360 degrees = 2π radians\n- Maintains array shape and element-wise mapping\n- Preserves the relationship between angle measures", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_radians(x: Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() == x.len(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0352", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_real_if_close", "vc-description": "If input is complex with all imaginary parts close to zero, return real parts.\nOtherwise, return the original complex vector.\n\"Close to zero\" is defined as tol * (machine epsilon of the type).\n\nSpecification: real_if_close returns real parts if all imaginary parts are within tolerance,\notherwise returns the original complex vector. This captures the essential behavior:\n1. If all imaginary parts are small (≤ tol * machineEpsilon), return only real parts\n2. Otherwise, preserve the original complex numbers\n3. Real parts are always preserved regardless\n4. The tolerance check is applied consistently across all elements", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* Structure representing a complex number with float components */\n#[derive(PartialEq, Eq)]\npub struct Complex {\n    /* The real part of the complex number */\n    pub re: i32,\n    /* The imaginary part of the complex number */\n    pub im: i32,\n}\n\n/* Machine epsilon for Float (approximately 2.2204460492503131e-16) */\nspec fn machine_epsilon() -> i32 {\n    2\n}\n/* Helper function to check if a complex number's imaginary part is close to zero */\nspec fn is_close_to_zero(c: Complex, tol: i32) -> bool {\n    let abs_im = if c.im >= 0 { c.im as int } else { -(c.im as int) };\n    abs_im <= (tol as int) * (machine_epsilon() as int)\n}\n\n/* Helper function to check if all imaginary parts in a complex vector are close to zero */\nspec fn all_imaginary_parts_close_to_zero(arr: Seq<Complex>, tol: i32) -> bool {\n    forall|i: int| 0 <= i < arr.len() ==> is_close_to_zero(arr[i], tol)\n}", "vc-helpers": "", "vc-spec": "fn real_if_close(arr: Vec<Complex>, tol: i32) -> (result: Vec<Complex>)\n    requires tol > 0,\n    ensures\n        /* Primary behavior: if all imaginary parts are close to zero, return real parts only */\n        all_imaginary_parts_close_to_zero(arr@, tol) ==> \n            forall|i: int| 0 <= i < result@.len() ==> result@[i].re == arr@[i].re && result@[i].im == 0,\n        /* Otherwise, preserve original complex numbers */\n        !all_imaginary_parts_close_to_zero(arr@, tol) ==> \n            forall|i: int| 0 <= i < result@.len() ==> result@[i] == arr@[i],\n        /* Real parts are always preserved */\n        forall|i: int| 0 <= i < result@.len() ==> result@[i].re == arr@[i].re,\n        /* Sanity check: result vector has same length as input */\n        result@.len() == arr@.len(),\n        /* Mathematical property: if input is already real, output equals input */\n        (forall|i: int| 0 <= i < arr@.len() ==> arr@[i].im == 0) ==> \n            forall|i: int| 0 <= i < result@.len() ==> result@[i] == arr@[i],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0353", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_reciprocal", "vc-description": "numpy.reciprocal: Return the reciprocal of the argument, element-wise.\n\nCalculates 1/x for each element in the input array.\nThis is equivalent to raising each element to the power of -1.\n\nThe function requires that all elements are non-zero to avoid division by zero.\nFor floating-point inputs, the reciprocal of zero would be infinity.\n\nReturns an array of the same shape as x, containing the reciprocals.\n\nSpecification: numpy.reciprocal returns a vector where each element is the\nreciprocal (1/x) of the corresponding element in x.\n\nPrecondition: All elements in x must be non-zero to avoid division by zero\nPostcondition: For all indices i, result[i] = 1 / x[i]\n\nMathematical properties captured in the specification:\n- Basic reciprocal property: result[i] = 1 / x[i]\n- Domain restriction: x[i] ≠ 0 for all i\n- Sign preservation: sign(result[i]) = sign(x[i])\n- Magnitude inversion: |result[i]| = 1 / |x[i]|\n\nAdditional mathematical properties (provable from the spec):\n- reciprocal(reciprocal(x)) = x for all non-zero x\n- reciprocal(x * y) = reciprocal(x) * reciprocal(y) for non-zero x, y\n- reciprocal(1) = 1\n- reciprocal(-1) = -1\n- For x > 0: reciprocal(x) > 0\n- For x < 0: reciprocal(x) < 0", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_reciprocal(x: Vec<f32>) -> (result: Vec<f32>)\n    requires \n        x.len() > 0,\n        forall|i: int| 0 <= i < x@.len() ==> x@[i] != 0.0f32,\n    ensures\n        result@.len() == x@.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0354", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_remainder", "vc-description": "numpy.remainder: Returns the element-wise remainder of division.\n\nComputes the remainder complementary to the floor_divide function.\nThis is equivalent to x1 % x2 in terms of array broadcasting.\n\nThe result has the same sign as the divisor x2.\nFor floating point inputs, the result is mathematically defined as:\nx1 - floor(x1/x2) * x2\n\nFrom NumPy documentation:\n- Parameters: x1, x2 (array_like) - The dividend and divisor arrays\n- Returns: remainder (ndarray) - The element-wise remainder of x1 divided by x2\n- This is a universal function (ufunc) implemented in C\n- Uses optimized C loops for different data types\n\nSpecification: numpy.remainder returns a vector where each element is the remainder\nof the corresponding elements from x1 and x2.\n\nMathematical Properties:\n1. Element-wise correctness: result[i] = x1[i] % x2[i]\n2. Complementary to floor division: x1[i] = floor(x1[i]/x2[i]) * x2[i] + result[i]\n3. Sign follows divisor: result[i] has the same sign as x2[i] (when x2[i] ≠ 0)\n4. Magnitude bound: |result[i]| < |x2[i]| (when x2[i] ≠ 0)\n5. Mathematical definition: result[i] = x1[i] - floor(x1[i]/x2[i]) * x2[i]\n6. Preserves vector length: result.size = x1.size = x2.size\n7. Handles IEEE 754 floating-point arithmetic\n\nPrecondition: All elements in x2 must be non-zero\nPostcondition: For all indices i, result[i] satisfies the remainder properties", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn remainder(x1: Vec<f64>, x2: Vec<f64>) -> (result: Vec<f64>)\n    requires \n        x1.len() == x2.len(),\n        forall|i: int| 0 <= i < x2@.len() ==> x2@[i] != 0.0,\n    ensures\n        result@.len() == x1@.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0355", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_rint", "vc-description": "numpy.rint: Round elements of the array to the nearest integer.\n\nRounds each element in the input array to the nearest integer using\nIEEE 754 rounding rules (round half to even). The result is returned\nas a floating-point array of the same shape as the input.\n\nThis function uses the C math library's rint function which rounds\nto the nearest integer, with ties (halves) rounded to the nearest even number.\n\nReturns an array of the same shape as x, containing the rounded values.\n\nSpecification: numpy.rint returns a vector where each element is\nrounded to the nearest integer using IEEE 754 rounding rules.\n\nPrecondition: True (no special preconditions for rint)\nPostcondition: For all indices i:\n  - result[i] is the nearest integer to x[i]\n  - for ties (half-integers), result[i] is the nearest even integer\n  - result[i] is a floating-point representation of the integer\n  - |result[i] - x[i]| ≤ 0.5 for all i\n  - if x[i] is already an integer, result[i] = x[i]", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_rint(x: Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() == x.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0356", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_round", "vc-description": "Evenly round to the given number of decimals.\n\nnumpy.round: Evenly round to the given number of decimals.\n\nRounds each element of the input array to the given number of decimal places.\nUses \"banker's rounding\" (round half to even) for ties.\n\nFor decimals=0: rounds to nearest integer\nFor decimals>0: rounds to that many decimal places\nFor decimals<0: rounds to nearest 10^(-decimals)\n\nReturns an array of the same shape as input, containing the rounded values.\n\nSpecification: numpy.round rounds each element to the specified number of decimal places.\n\nPrecondition: True (rounding is defined for all real numbers and decimal places)\nPostcondition: For all indices i, result[i] is the rounded value of a[i] to 'decimals' places:\n- For decimals = 0: result[i] is the nearest integer to a[i]\n- For decimals > 0: result[i] is rounded to that many decimal places\n- For decimals < 0: result[i] is rounded to nearest multiple of 10^(-decimals)\n- Uses banker's rounding (round half to even) for ties\n- Monotonicity: if a[i] ≤ a[j] then result[i] ≤ result[j]\n- For decimals=0: result[i] is an integer value\n- Approximation property: result[i] is close to a[i] within rounding precision", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_round(a: Vec<f64>, decimals: i32) -> (result: Vec<f64>)\n    requires a@.len() > 0,\n    ensures \n        result@.len() == a@.len()", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0357", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_sign", "vc-description": "Returns an element-wise indication of the sign of a number.\n\nSpecification: sign returns -1 for negative numbers, 0 for zero, 1 for positive numbers", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn sign(x: Vec<i8>) -> (result: Vec<i8>)\n    requires x.len() > 0,\n    ensures \n        result.len() == x.len(),\n        forall|i: int| 0 <= i < x@.len() ==> {\n            (x@[i] < 0 ==> result@[i] == -1) &&\n            (x@[i] == 0 ==> result@[i] == 0) &&\n            (x@[i] > 0 ==> result@[i] == 1)\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "VT0358", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_signbit", "vc-description": "Returns element-wise True where signbit is set (less than zero)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn is_negative(x: f32) -> bool;", "vc-helpers": "", "vc-spec": "fn signbit(x: Vec<f32>) -> (result: Vec<bool>)\n    ensures \n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == is_negative(x[i])", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "VT0359", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_sin", "vc-description": "numpy.sin: Trigonometric sine, element-wise.\n\nComputes the sine of each element in the input vector, where each element \nis interpreted as an angle in radians. The sine function is one of the \nfundamental trigonometric functions.\n\nFor a real number x interpreted as an angle in radians, sin(x) gives the \ny-coordinate of the point on the unit circle at angle x from the positive x-axis.\n\nReturns a vector of the same shape as the input, containing the sine of each element.\n\nSpecification: numpy.sin returns a vector where each element is the sine\nof the corresponding element in x (interpreted as radians).\n\nThe specification captures key mathematical properties:\n1. Element-wise computation: result[i] = sin(x[i])\n2. Range bounds: sine values are always in [-1, 1]\n3. Fundamental trigonometric identities:\n   - sin(0) = 0\n   - sin(π/2) = 1\n   - sin(π) = 0 (approximately, within floating-point precision)\n   - sin(3π/2) = -1\n   - sin(2π) = 0 (approximately, within floating-point precision)\n4. Periodicity: sin(x + 2π) = sin(x)\n5. Odd function property: sin(-x) = -sin(x)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn sin(x: Vec<f32>) -> (result: Vec<f32>)\n    requires x@.len() > 0,\n    ensures result@.len() == x@.len()", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0360", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_sinc", "vc-description": "Return the normalized sinc function\n\nnumpy.sinc: Return the normalized sinc function, element-wise.\n\nThe sinc function is defined as:\n- sin(π*x)/(π*x) for x ≠ 0\n- 1 for x = 0\n\nThis is the normalized sinc function, which is used in signal processing and\nFourier analysis. The function is continuous everywhere and has its maximum\nvalue of 1 at x = 0.\n\nReturns a vector of the same shape as the input, containing the sinc value\nof each element.\n\nSpecification: numpy.sinc returns a vector where each element is the\nnormalized sinc function of the corresponding element in x.\n\nThe specification captures key mathematical properties:\n1. Element-wise computation: result[i] = sinc(x[i])\n2. Definition: sinc(x) = sin(π*x)/(π*x) for x ≠ 0, and 1 for x = 0\n3. Continuity: sinc(0) = 1 (limit as x approaches 0)\n4. Symmetry: sinc(-x) = sinc(x) (even function)\n5. Zeros: sinc(x) = 0 for x = k where k is any non-zero integer\n6. Boundedness: |sinc(x)| ≤ 1 for all x\n7. Maximum value: sinc(0) = 1 is the global maximum\n\nThe specification is formalized to be mathematically precise while \nremaining implementable with Float types.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn sinc(x: Vec<i8>) -> (result: Vec<i8>)\n    ensures \n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> {\n            /* Boundedness: sinc values are bounded by [-1, 1] */\n            result[i] as int <= 1 &&\n            result[i] as int >= -1 &&\n            /* Maximum at zero: sinc(0) = 1 */\n            (x[i] as int == 0 ==> result[i] as int == 1) &&\n            /* Symmetry: sinc is an even function */\n            (forall|j: int| 0 <= j < x.len() && x[i] as int == -(x[j] as int) ==> result[i] as int == result[j] as int)\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0361", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_sinh", "vc-description": "numpy.sinh: Hyperbolic sine, element-wise.\n\nThe hyperbolic sine function is defined as:\nsinh(x) = (e^x - e^(-x)) / 2\n\nIt represents the y-coordinate of a point on the unit hyperbola,\nanalogous to how sine represents the y-coordinate on the unit circle.\nUnlike the regular sine function, sinh is unbounded and monotonic.\n\nReturns an array of the same shape as x, containing the hyperbolic sine of each element.\n\nSpecification: numpy.sinh returns a vector where each element is the hyperbolic sine\nof the corresponding element in x.\n\nPrecondition: True (no special preconditions for hyperbolic sine)\nPostcondition: \n1. For all indices i, result[i] = (e^x[i] - e^(-x[i])) / 2\n2. The function is odd: sinh(-x) = -sinh(x)\n3. Monotonicity: sinh is strictly increasing on all of ℝ\n4. Zero property: sinh(0) = 0\n5. Range property: sinh(x) ∈ (-∞, ∞) for all x ∈ ℝ\n6. Sign property: sinh(x) has the same sign as x\n7. Symmetry property: sinh(-x) = -sinh(x)\n\n// Simplified specification without direct floating point arithmetic in spec\n\n// Placeholder for mathematical properties\n\n/* Simplified properties without floating point spec operations */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn sinh_property(x: f64, result: f64) -> bool {\n\n    true\n}\n\nfn sinh(x: Vec<f64>) -> (result: Vec<f64>)\n    requires x.len() > 0,\n    ensures \n        result.len() == x.len(),\n\n        forall|i: int| 0 <= i < x@.len() ==> sinh_property(x@[i], result@[i])", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0362", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_spacing", "vc-description": "Return the distance between x and the nearest adjacent number.\n\nFor each element x in the input array, returns the distance to the nearest\nadjacent floating-point number. This is equivalent to the machine epsilon\nfor the magnitude of x - it gives the smallest representable difference\nbetween floating-point numbers near x.\n\nFor x = 1.0, spacing(1.0) equals the machine epsilon.\nSpacing of ±inf and NaN is NaN.\n\nThis function is crucial for understanding floating-point precision limits\nand is used in numerical analysis for error bounds and convergence testing.\n\nSpecification: numpy.spacing returns the distance between each element \nand its nearest adjacent floating-point number.\n\nPrecondition: True (spacing is defined for all floating-point numbers)\nPostcondition: For all indices i, result[i] represents the smallest positive\ndifference between x[i] and the next representable floating-point number.\n\nMathematical properties:\n- spacing(x) > 0 for all finite x (distance is always positive)\n- spacing(1.0) = machine epsilon\n- No representable number exists between x and x + spacing(x)\n- spacing(±∞) = NaN and spacing(NaN) = NaN\n- spacing(-x) = spacing(x) for finite x (symmetry around zero)\n- spacing grows with the magnitude of x (floating-point spacing increases)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn spacing(x: Vec<i8>) -> (result: Vec<i8>)\n    ensures\n        result@.len() == x@.len(),\n        forall|i: int| 0 <= i < x@.len() ==> #[trigger] result@[i] as int > 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0363", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_sqrt", "vc-description": "numpy.sqrt: Return the non-negative square-root of an array, element-wise.\n\nComputes the principal square root of each element in the input array.\nFor non-negative input elements, returns the positive square root.\nFor negative input elements, the result is mathematically undefined in\nthe real numbers, but numpy returns NaN (Not a Number).\n\nThe function returns an array of the same shape as the input, containing\nthe non-negative square-root of each element.\n\nSpecification: sqrt returns a vector where each element is the\nnon-negative square root of the corresponding element in x.\n\nMathematical properties:\n1. For non-negative inputs: result² = input and result ≥ 0\n2. For negative inputs: result is NaN (handled by Float.sqrt)\n3. The result preserves the shape of the input\n4. sqrt(0) = 0\n5. sqrt(1) = 1\n6. sqrt is monotonic on non-negative inputs\n\nPrecondition: True (function handles all Float inputs)\nPostcondition: For all indices i, if x[i] ≥ 0 then result[i]² = x[i] and result[i] ≥ 0", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn sqrt(x: Vec<i8>) -> (result: Vec<i8>)\n    ensures \n        result@.len() == x@.len(),\n        forall|i: int| 0 <= i < x@.len() ==> {\n            &&& (x@[i] >= 0 ==> result@[i] * result@[i] == x@[i] && result@[i] >= 0)\n            &&& (x@[i] == 0 ==> result@[i] == 0)\n            &&& (x@[i] == 1 ==> result@[i] == 1)\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0364", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_square", "vc-description": "numpy.square: Return the element-wise square of the input.\n\nComputes x^2 element-wise. This is equivalent to x * x but may be\nmore efficient for certain data types. The function squares each element\nof the input array and returns an array of the same shape.\n\nThis is a universal function (ufunc) that operates element-wise on arrays.\n\nSpecification: numpy.square returns a vector where each element is the\nsquare of the corresponding element in x.\n\nPrecondition: True (no special preconditions for squaring)\nPostcondition: For all indices i, result[i] = x[i]^2\n\nMathematical Properties:\n- Result is always non-negative: ∀ i, result[i] ≥ 0\n- Preserves zeros: x[i] = 0 → result[i] = 0\n- Monotonic for non-negative inputs: 0 ≤ x[i] ≤ x[j] → result[i] ≤ result[j]", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn square_f64(x: f64) -> f64;", "vc-helpers": "", "vc-spec": "fn numpy_square(x: Vec<f64>) -> (result: Vec<f64>)\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == square_f64(x[i])", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0365", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_subtract", "vc-description": "numpy.subtract: Subtract arguments, element-wise.\n\nSubtracts two vectors element-wise. If the vectors have the same shape,\neach element of the result is the difference of the corresponding elements\nfrom the input vectors.\n\nThis is equivalent to x1 - x2 in terms of array broadcasting.\nThe operation is the inverse of addition: (x1 - x2) + x2 = x1.\n\nSpecification: numpy.subtract returns a vector where each element is the difference\nof the corresponding elements from x1 and x2.\n\nPrecondition: True (no special preconditions for basic subtraction)\nPostcondition: For all indices i, result[i] = x1[i] - x2[i]\n\nMathematical properties:\n- Subtraction is anti-commutative: x1 - x2 = -(x2 - x1)\n- Subtraction is the inverse of addition: (x1 - x2) + x2 = x1\n- Subtracting zero leaves the original value: x1 - 0 = x1\n- Subtracting a value from itself yields zero: x1 - x1 = 0", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn subtract(x1: Vec<i8>, x2: Vec<i8>) -> (result: Vec<i8>)\n    requires x1.len() == x2.len(),\n    ensures \n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> result@[i] == x1@[i] - x2@[i],\n        /* Sanity check: subtracting zero preserves the original value */\n        forall|i: int| 0 <= i < result.len() && x2@[i] == 0 ==> result@[i] == x1@[i],\n        /* Sanity check: subtracting a value from itself yields zero */\n        forall|i: int| 0 <= i < result.len() && x1@[i] == x2@[i] ==> result@[i] == 0,\n        /* Anti-commutativity property */\n        forall|i: int| 0 <= i < result.len() ==> result@[i] == -(x2@[i] - x1@[i])", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0366", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_sum", "vc-description": "numpy.sum: Sum of array elements over a given axis.\n\nComputes the sum of all elements in the vector. For empty vectors,\nreturns 0 as the identity element of addition.\n\nThis is a reduction operation that applies addition across all\nelements to produce a single scalar result.\n\nMathematical Properties:\n- Commutative: order of elements doesn't affect the final sum\n- Associative: grouping of operations doesn't affect the result\n- Identity element: empty array sum is 0\n- Distributive: sum(a * c) = c * sum(a) for scalar c\n\nFrom NumPy documentation:\n- Parameters: a (array_like) - Elements to sum\n- Returns: sum_along_axis (ndarray) - Sum of array elements\n- The function handles axis parameter (ignored in 1D case)\n- Supports optional dtype, initial value, and where condition\n\nSpecification: sum computes the sum of all elements in a vector.\n\nThe sum operation has several important mathematical properties:\n1. For empty vectors, returns 0 (additive identity)\n2. For non-empty vectors, returns the sum of all elements\n3. The operation is commutative and associative\n4. Linearity: sum(a + b) = sum(a) + sum(b) (element-wise addition)\n5. Scalar multiplication: sum(c * a) = c * sum(a) for scalar c\n\nThis specification captures both the basic behavior and key mathematical\nproperties that make sum well-defined and predictable.\n\nPrecondition: True (works for any vector, including empty)\nPostcondition: Result equals the sum of all elements using fold operation", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn vec_sum(a: Seq<f32>) -> f32;\n\nfn sum(a: Vec<f32>) -> (result: f32)\n    ensures \n        result == vec_sum(a@),\n        a.len() == 0 ==> result == 0.0f32,\n        (forall|i: int| 0 <= i < a.len() ==> a[i] == 0.0f32) ==> result == 0.0f32,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0367", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_tan", "vc-description": "Compute tangent element-wise. Equivalent to sin(x)/cos(x) element-wise.\n\nSpecification: tan computes the tangent of each element, equivalent to sin(x)/cos(x),\nand is undefined when cos(x) = 0 (i.e., x = π/2 + kπ for integer k)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn tan(x: Vec<f32>) -> (result: Vec<f32>)\n    requires \n        x@.len() > 0,\n    ensures\n        result@.len() == x@.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0368", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_tanh", "vc-description": "Compute hyperbolic tangent element-wise.\n\nThe hyperbolic tangent function is defined as:\ntanh(x) = sinh(x) / cosh(x) = (e^x - e^(-x)) / (e^x + e^(-x))\n\nThis function is bounded between -1 and 1, and is the ratio of\nhyperbolic sine to hyperbolic cosine. It has a sigmoid-like shape,\napproaching -1 as x approaches negative infinity and approaching 1\nas x approaches positive infinity.\n\nReturns an array of the same shape as x, containing the hyperbolic tangent of each element.\n\nSpecification: numpy.tanh returns a vector where each element is the hyperbolic tangent\nof the corresponding element in x.\n\nPrecondition: True (no special preconditions for hyperbolic tangent)\nPostcondition: \n1. For all indices i, result[i] = sinh(x[i]) / cosh(x[i])\n2. The function is odd: tanh(-x) = -tanh(x)\n3. The function is bounded: -1 < tanh(x) < 1 for all x ≠ 0\n4. Monotonicity: tanh is strictly increasing on all of ℝ\n5. Zero property: tanh(0) = 0\n6. Limit properties: lim_{x→∞} tanh(x) = 1 and lim_{x→-∞} tanh(x) = -1\n7. Sign property: tanh(x) has the same sign as x\n8. Derivative property: d/dx tanh(x) = 1 - tanh²(x)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn tanh(x: Vec<i32>) -> (result: Vec<i32>)\n    ensures \n        result.len() == x.len(),\n        forall|i: int| 0 <= i < x.len() ==> {\n            /* Core mathematical definition: tanh(x) = sinh(x) / cosh(x) */\n            /* Bounded property: |tanh(x)| < 1 for all finite x */\n            -1 < result[i] && result[i] < 1 &&\n            /* Zero property: tanh(0) = 0 */\n            (x[i] == 0 ==> result[i] == 0) &&\n            /* Sign property: tanh(x) has the same sign as x */\n            (x[i] > 0 ==> result[i] > 0) &&\n            (x[i] < 0 ==> result[i] < 0) &&\n            /* Asymptotic behavior: for positive x, 0 < tanh(x) < 1 */\n            (x[i] > 0 ==> result[i] > 0 && result[i] < 1) &&\n            /* Asymptotic behavior: for negative x, -1 < tanh(x) < 0 */\n            (x[i] < 0 ==> result[i] < 0 && result[i] > -1)\n        },", "vc-code": "{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0369", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_trapezoid", "vc-description": "Integrate along the given axis using the composite trapezoidal rule. The composite trapezoidal rule approximates definite integrals using trapezoidal approximations between sample points.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn trapezoid(y: Vec<i8>, dx: i8) -> (result: i8)\n    requires \n        y.len() > 0,\n        dx > 0,\n    ensures\n        (forall|i: int| 0 <= i < y@.len() ==> #[trigger] y@[i] == y@[0]) ==> \n            result as int == dx as int * (y.len() - 1) as int * y@[0],\n        (forall|i: int| 0 <= i < y@.len() ==> #[trigger] y@[i] >= 0) ==> result >= 0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0370", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_true_divide", "vc-description": "numpy.true_divide: Divide arguments element-wise.\n\nTrue division of the inputs, element-wise. This is equivalent to \ndivision in Python 3 and numpy.divide. Always returns a floating point result.\n\nThe result is computed element-wise as x1[i] / x2[i] for all valid indices i.\nDivision by zero will result in infinity or NaN depending on the numerator.\n\nThis function is an alias for numpy.divide but ensures floating point output.\n\nSpecification: true_divide returns a vector where each element is the quotient\nof the corresponding elements from x1 and x2.\n\nPrecondition: All elements in x2 must be non-zero to avoid division by zero\nPostcondition: For all indices i, result[i] = x1[i] / x2[i]\n\nMathematical properties:\n- Preserves vector length (result has same size as inputs)\n- Element-wise division: result[i] = x1[i] / x2[i]\n- Non-zero divisor constraint ensures well-defined division\n- Identity property: true_divide(x, ones) = x\n- Inverse property: true_divide(x, x) = ones (when x has no zeros)\n- Distributive over multiplication: true_divide(x*y, z) = true_divide(x,z) * true_divide(y,z)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn true_divide(x1: Vec<f64>, x2: Vec<f64>) -> (result: Vec<f64>)\n    requires \n        x1.len() == x2.len(),\n        forall|i: int| 0 <= i < x2.len() ==> x2@[i] != 0.0,\n    ensures\n        result.len() == x1.len(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0371", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_trunc", "vc-description": "numpy.trunc: Return the truncated value of the input, element-wise.\n\nThe truncated value of the scalar x is the nearest integer i which is closer to zero than x is.\nThis is equivalent to:\n- For positive x: floor(x) (largest integer ≤ x)\n- For negative x: ceil(x) (smallest integer ≥ x)\n- For zero: 0\n\nReturns an array of the same shape as x, containing the truncated values.\n\nSpecification: numpy.trunc returns a vector where each element is the \ntruncated value of the corresponding element in x.\n\nPrecondition: True (truncation is defined for all real numbers)\nPostcondition: For all indices i, result[i] is the truncated value of x[i],\n               which is the nearest integer closer to zero than x[i]. This means:\n               - result[i] is an integer value (represented as Float)\n               - For positive x: result[i] = floor(x[i])\n               - For negative x: result[i] = ceil(x[i])\n               - Truncation moves towards zero: |result[i]| ≤ |x[i]|\n               - Sign preservation: result and x have same sign (or both are zero)\n               - Monotonicity: the function is monotonic in the sense that it preserves ordering\n               - Idempotence: trunc(trunc(x)) = trunc(x)\n               - Integer preservation: if x[i] is an integer, then result[i] = x[i]", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn int_abs(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}", "vc-helpers": "", "vc-spec": "fn numpy_trunc(x: Vec<i8>) -> (result: Vec<i8>)\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i] == x[i],\n        forall|i: int| 0 <= i < result.len() ==> {\n            /* Sign preservation */\n            (x[i] > 0 ==> result[i] >= 0) &&\n            (x[i] < 0 ==> result[i] <= 0) &&\n            (x[i] == 0 ==> result[i] == 0)\n        },\n        forall|i: int| 0 <= i < result.len() ==> {\n            /* Truncation moves towards zero (abs property) */\n            int_abs(result[i] as int) <= int_abs(x[i] as int)\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0372", "language": "verus", "source": "numpy_triple", "source_id": "mathematical_functions_unwrap", "vc-description": "Unwrap by changing deltas between values to 2*pi complement.\nUnwraps radian phase by changing absolute jumps greater than discont to their 2*pi complement.\nFor consecutive elements with difference > discont, adds/subtracts multiples of period to create continuity.\n\nSpecification: unwrap ensures continuity by correcting large phase jumps", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn unwrap(p: Vec<i8>, discont: i8, period: i8) -> (result: Vec<i8>)\n    requires \n        discont > 0,\n        period > 0,\n    ensures\n        result.len() == p.len(),\n        /* First element is unchanged (if array is non-empty) */\n        p.len() > 0 ==> result@[0] == p@[0],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0373", "language": "verus", "source": "numpy_triple", "source_id": "ndarray_flat", "vc-description": "numpy.ndarray.flat: A 1-D iterator over the array.\n\nThis operation provides a flattened view of the array, allowing access\nto elements as if the array were 1-dimensional. For 1D arrays, this is\nessentially an identity operation that provides indexed access to elements.\n\nThe flat iterator acts as a view into the underlying array data, preserving\nthe order of elements as they appear in memory (row-major order).\n\nSpecification: numpy.ndarray.flat returns a flattened view of the array.\n\nPrecondition: True (no special preconditions for flattening)\nPostcondition: The result contains the same elements in the same order,\n               providing a 1D view of the input array", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_flat(a: Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> result[i] == a[i]", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0374", "language": "verus", "source": "numpy_triple", "source_id": "ndarray_flatten", "vc-description": "numpy.ndarray.flatten: Return a copy of the array collapsed into one dimension.\n\nFlattens a 2D matrix into a 1D vector using row-major (C-style) order.\nEach row is placed sequentially in the output vector.\n\nParameters:\n- mat: 2D matrix represented as Vector of Vectors\n\nReturns:\n- 1D vector containing all elements in row-major order\n\nExample: [[1,2], [3,4]] becomes [1, 2, 3, 4]\n\nSpecification: flatten returns a 1D vector containing all elements of the 2D matrix\nin row-major order.\n\nPrecondition: True (no special preconditions)\nPostcondition: \n- The result has size rows * cols\n- Each element at position (row * cols + col) equals the original element at (row, col)\n- Elements are ordered by row-major traversal (row 0 first, then row 1, etc.)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn flatten(mat: Vec<Vec<i8>>) -> (result: Vec<i8>)\n    requires \n        mat@.len() > 0,\n        forall|i: int| 0 <= i < mat@.len() ==> mat@[i].len() > 0,\n        forall|i: int, j: int| 0 <= i < mat@.len() && 0 <= j < mat@.len() ==> mat@[i].len() == mat@[j].len(),\n    ensures \n        result@.len() == mat@.len() * mat@[0].len(),\n        forall|r: int, c: int| \n            0 <= r < mat@.len() && 0 <= c < mat@[0].len() ==>\n            result@[r * mat@[0].len() + c] == mat@[r][c]", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0375", "language": "verus", "source": "numpy_triple", "source_id": "ndarray_tofile", "vc-description": "numpy.ndarray.tofile: Write array to a file as text or binary data.\n\nWrites the array data to a file in 'C' order (row-major), independent of the\noriginal array order. The data can be recovered using numpy.fromfile().\n\nThis operation converts the array elements to their binary or text representation\nand writes them sequentially to the specified file.\n\nSpecification: numpy.ndarray.tofile writes array data to a file in a format\nthat preserves all original data and can be recovered by fromfile.\n\nPrecondition: True (no special preconditions for file writing)\nPostcondition: The operation succeeds (returns unit) and the file contains\na faithful representation of the array data in 'C' order, preserving:\n1. The number of elements (file_data.length = n)\n2. The exact values in sequential order\n3. All elements are written without loss of precision\n\nThis ensures the fundamental property that tofile and fromfile are inverses\nwhen used with the same data format.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_tofile(arr: Vec<f32>, filename: String) -> (result: ())\n    requires true,\n    ensures result == ()", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0376", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_chebyshev_Chebyshev", "vc-description": "{\n  \"name\": \"numpy.polynomial.chebyshev.Chebyshev\",\n  \"category\": \"Chebyshev polynomials\",\n  \"description\": \"A Chebyshev series class.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.chebyshev.Chebyshev.html\",\n  \"doc\": \"A Chebyshev series class.\\n\\n    The Chebyshev class provides the standard Python numerical methods\\n    '+', '-', '*', '//', '%', 'divmod', '**', and '()' as well as the\\n    attributes and methods listed below.\\n\\n    Parameters\\n    ----------\\n    coef : array_like\\n        Chebyshev coefficients in order of increasing degree, i.e.,\\n        \\`\\`(1, 2, 3)\\`\\` gives \\`\\`1*T_0(x) + 2*T_1(x) + 3*T_2(x)\\`\\`.\\n    domain : (2,) array_like, optional\\n        Domain to use. The interval \\`\\`[domain[0], domain[1]]\\`\\` is mapped\\n        to the interval \\`\\`[window[0], window[1]]\\`\\` by shifting and scaling.\\n        The default value is [-1., 1.].\\n    window : (2,) array_like, optional\\n        Window, see \\`domain\\` for its use. The default value is [-1., 1.].\\n    symbol : str, optional\\n        Symbol used to represent the independent variable in string\\n        representations of the polynomial expression, e.g. for printing.\\n        The symbol must be a valid Python identifier. Default value is 'x'.\\n\\n        .. versionadded:: 1.24\",\n  \"type\": \"class\"\n}\n\nCreate a Chebyshev polynomial from coefficients with default domain and window [-1, 1]\n\nSpecification: Creating a Chebyshev polynomial preserves coefficients and sets default domain/window", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* Structure representing a Chebyshev polynomial with coefficients and domain/window mapping */\nstruct ChebyshevPoly {\n    /* Coefficients of the Chebyshev polynomial in increasing degree order */\n    coef: Vec<i32>,\n    /* Domain interval [domain_min, domain_max] */\n    domain_min: i32,\n    domain_max: i32,\n    /* Window interval [window_min, window_max] */\n    window_min: i32,\n    window_max: i32,\n}", "vc-helpers": "", "vc-spec": "fn chebyshev(coef: Vec<i8>) -> (result: ChebyshevPoly)\n    requires coef.len() > 0,\n    ensures\n        /* Coefficients are preserved */\n        result.coef@.len() == coef@.len(),\n        forall|i: int| 0 <= i < coef@.len() ==> result.coef@[i] == coef@[i] as i32,\n        /* Default domain is [-1, 1] */\n        result.domain_min == -1,\n        result.domain_max == 1,\n        /* Default window is [-1, 1] */\n        result.window_min == -1,\n        result.window_max == 1,\n        /* Domain interval is valid */\n        result.domain_min < result.domain_max,\n        /* Window interval is valid */\n        result.window_min < result.window_max,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0377", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_chebyshev_cheb2poly", "vc-description": "Convert a Chebyshev series to a polynomial.\n\nConvert an array representing the coefficients of a Chebyshev series,\nordered from lowest degree to highest, to an array of the coefficients\nof the equivalent polynomial (relative to the \"standard\" basis) ordered\nfrom lowest to highest degree.\n\nSpecification: cheb2poly converts Chebyshev coefficients to polynomial coefficients.\n\nThe conversion satisfies the mathematical property that if we have Chebyshev series\n∑_{k=0}^{n-1} c[k] * T_k(x) where T_k is the k-th Chebyshev polynomial,\nthen the output polynomial coefficients p satisfy:\n∑_{k=0}^{n-1} c[k] * T_k(x) = ∑_{k=0}^{n-1} p[k] * x^k\n\nKey properties:\n1. Length preservation: output has same length as input\n2. Identity cases: for n ≤ 2, the output equals the input (since T₀(x) = 1, T₁(x) = x)\n3. Correctness: The polynomial form evaluates to the same value as the Chebyshev series\n4. Example verification: [0, 1, 2, 3] → [-2, -8, 4, 12]\n\nThe algorithm uses the recurrence relation of Chebyshev polynomials:\nT₀(x) = 1, T₁(x) = x, T_{n+1}(x) = 2xT_n(x) - T_{n-1}(x)\n\n/* Basic properties */\n\n/* 1. Length preservation */\n\n/* 2. Identity for small cases */\n\n/* 3. Mathematical correctness: The core property is that\n           evaluating the polynomial with coefficients p at any point x\n           gives the same result as evaluating the Chebyshev series\n           with coefficients c at that point.\n           This is the fundamental correctness property of the conversion. */\n\n/* For clarity, we state this property abstractly:\n               polyEval(p, x) = chebEval(c, x)\n               where polyEval computes p₀ + p₁x + p₂x² + ... + p_{n-1}x^{n-1}\n               and chebEval computes c₀T₀(x) + c₁T₁(x) + ... + c_{n-1}T_{n-1}(x) */\n\n/* 4. Concrete example from NumPy documentation\n           When c = [0, 1, 2, 3], then p = [-2, -8, 4, 12]\n           This verifies: 0*T₀ + 1*T₁ + 2*T₂ + 3*T₃ = -2 - 8x + 4x² + 12x³ */\n\n/* 5. Additional mathematical properties\n           The conversion is linear: cheb2poly(αc + βd) = α*cheb2poly(c) + β*cheb2poly(d) */\n\n/* 6. Stability: small changes in input lead to small changes in output\n           This is important for numerical applications */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn cheb2poly(c: Vec<i8>) -> (p: Vec<i8>)\n    ensures\n\n        p.len() == c.len(),\n\n        (c.len() == 0 ==> p@ == c@),\n        (c.len() == 1 ==> p@ == c@),\n        (c.len() == 2 ==> p@ == c@),\n\n        (c.len() == 4 ==>\n            (c[0] == 0 && c[1] == 1 && c[2] == 2 && c[3] == 3) ==>\n            (p[0] == -2 && p[1] == -8 && p[2] == 4 && p[3] == 12))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0378", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_chebyshev_chebadd", "vc-description": "Add one Chebyshev series to another.\n\nAdd one Chebyshev series to another. Returns the sum of two Chebyshev series c1 + c2. The arguments are sequences of coefficients ordered from lowest order term to highest, i.e., [1,2,3] represents the series T_0 + 2*T_1 + 3*T_2.\n\nAdd two Chebyshev series coefficient-wise.\n\nThis function adds two Chebyshev polynomial series represented by their coefficients. The coefficients are ordered from lowest degree to highest degree term. For example, [1,2,3] represents T_0 + 2*T_1 + 3*T_2 where T_i is the i-th Chebyshev polynomial.\n\nThe addition is performed component-wise, padding with zeros if the arrays have different lengths.\n\nSpecification: chebadd performs coefficient-wise addition of two Chebyshev series.\n\nThe specification captures both the mathematical properties and implementation details:\n1. For indices within both arrays, the result is the sum of corresponding coefficients\n2. For indices beyond one array's length, the result equals the coefficient from the longer array\n3. The result preserves the Chebyshev series representation property\n4. The operation is commutative up to reordering when n ≠ m\n5. Adding a zero vector yields the original vector (identity property)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn chebadd(c1: Vec<i8>, c2: Vec<i8>) -> (result: Vec<i8>)\n    ensures\n        result.len() == if c1.len() >= c2.len() { c1.len() } else { c2.len() },\n        forall|i: int| 0 <= i < result.len() ==> {\n            if i < c1.len() && i < c2.len() {\n                result[i] as int == c1[i] as int + c2[i] as int\n            } else if i < c1.len() {\n                result[i] == c1[i]\n            } else if i < c2.len() {\n                result[i] == c2[i]\n            } else {\n                result[i] == 0\n            }\n        },\n        forall|i: int| 0 <= i < c1.len() ==> c1[i] != 0 ==> {\n            exists|j: int| 0 <= j < result.len() && j == i && {\n                if i < c2.len() {\n                    result[j] as int == c1[i] as int + c2[i] as int\n                } else {\n                    result[j] == c1[i]\n                }\n            }\n        },\n        forall|i: int| 0 <= i < c2.len() ==> c2[i] != 0 ==> {\n            exists|j: int| 0 <= j < result.len() && j == i && {\n                if i < c1.len() {\n                    result[j] as int == c1[i] as int + c2[i] as int\n                } else {\n                    result[j] == c2[i]\n                }\n            }\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0379", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_chebyshev_chebcompanion", "vc-description": "numpy.polynomial.chebyshev.chebcompanion: Return the scaled companion matrix of c.\n\nThe basis polynomials are scaled so that the companion matrix is\nsymmetric when c is a Chebyshev basis polynomial. This provides\nbetter eigenvalue estimates than the unscaled case and for basis\npolynomials the eigenvalues are guaranteed to be real if\nnumpy.linalg.eigvalsh is used to obtain them.\n\nParameters:\n- c : 1-D array of Chebyshev series coefficients ordered from low to high degree\n\nReturns:\n- mat : Scaled companion matrix of dimensions (deg, deg) where deg = len(c) - 1\n\nSpecification: chebcompanion returns a scaled companion matrix with specific structure.\n\nPrecondition: The input vector has at least 2 elements (enforced by type)\n\nPostcondition: The result is an (n+1) × (n+1) matrix where:\n1. The superdiagonal and subdiagonal have specific values (0.5 for most entries, sqrt(0.5) for the first)\n2. The last column is adjusted by scaled coefficients\n3. The matrix structure ensures symmetry for Chebyshev basis polynomials", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn chebcompanion(c: Vec<f32>) -> (result: Vec<Vec<f32>>)\n    requires c@.len() >= 2,\n    ensures\n        result@.len() == c@.len() - 1,\n        forall|i: int| 0 <= i < result@.len() ==> result@[i].len() == c@.len() - 1,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0380", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_chebyshev_chebder", "vc-description": "numpy.polynomial.chebyshev.chebder: Differentiate a Chebyshev series.\n\nReturns the Chebyshev series coefficients differentiated once.\nThe differentiation is based on the recurrence relations for Chebyshev\npolynomials. The derivative is multiplied by a scaling factor.\n\nFor a Chebyshev series c₀T₀ + c₁T₁ + c₂T₂ + ..., the derivative\nfollows specific recurrence relations that differ from standard polynomials.\n\nThe derivative of T_n is n*U_{n-1}, where U_{n-1} can be expressed\nin terms of Chebyshev polynomials T_k using specific recurrence relations.\n\nSpecification: chebder differentiates a Chebyshev series once.\n\nThe Chebyshev derivative algorithm works by:\n1. Creating a working copy of the coefficients\n2. Applying the recurrence relation from high to low order\n3. Scaling the result\n\nThe recurrence relation for Chebyshev derivatives is:\n- For j ≥ 2: der[j] = 2*(j+1)*c[j+1], and c[j-2] += j*c[j]/(j-2)\n- For j = 1: der[1] = 4*c[2]\n- For j = 0: der[0] = c[1]\n\nAll results are then multiplied by the scaling factor.\n\nMathematical property: If p(x) = Σ c[i]*T_i(x), then \np'(x) = Σ der[i]*T_i(x) where der = chebder(c, scl).\n\nPrecondition: True (works for any non-empty vector)\nPostcondition: \n- The result has size n\n- The coefficients follow the Chebyshev derivative recurrence relations\n- The result represents scl times the derivative of the input series", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn chebder(c: Vec<i8>, scl: i8) -> (result: Vec<i8>)\n    requires c.len() > 0,\n    ensures\n        result.len() == c.len() - 1,\n        c.len() > 1 ==> result[0] == scl * c[1],\n        c.len() > 2 ==> result[1] == scl * 4 * c[2],\n        forall|j: int| 2 <= j < result.len() ==>\n            result[j as int] == scl * (2 * ((j + 1) as i8)) * c[(j + 1) as int],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0381", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_chebyshev_chebdiv", "vc-description": "Divide one Chebyshev series by another, returning quotient and remainder.\nThe input vectors represent Chebyshev series coefficients from lowest to highest order.\n\nSpecification: chebdiv performs polynomial division in the Chebyshev basis,\nsatisfying the division algorithm property that c1 = c2 * quotient + remainder,\nwhere the degree of remainder is less than the degree of c2.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn chebdiv(c1: Vec<f32>, c2: Vec<f32>) -> (result: (Vec<f32>, Vec<f32>))\n    requires \n        c2.len() > 0,\n        c2[c2.len() - 1] != 0.0f32,\n    ensures ({\n        let (quo, rem) = result;\n        \n        /* Quotient has correct size constraints */\n        (forall|i: int| 0 <= i < quo.len() && i >= c1.len() - (c2.len() - 1) ==> quo[i] == 0.0f32) &&\n        \n        /* Remainder degree constraint: deg(rem) < deg(c2) */\n        (forall|i: int| 0 <= i < rem.len() && i >= c2.len() - 1 ==> rem[i] == 0.0f32) &&\n        \n        /* Special case: if deg(c1) < deg(c2), then quo = 0 and rem = c1 */\n        (c1.len() < c2.len() ==> \n            (forall|i: int| 0 <= i < quo.len() ==> quo[i] == 0.0f32) &&\n            (forall|i: int| 0 <= i < rem.len() && i < c1.len() ==> rem[i] == c1[i])) &&\n        \n        /* Special case: if c2 has only one coefficient (constant divisor) */\n        (c2.len() == 1 ==> \n            (forall|i: int| 0 <= i < rem.len() ==> rem[i] == 0.0f32))\n    })", "vc-code": "{\n    // impl-start\n    assume(false);\n    (Vec::new(), Vec::new())\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0383", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_chebyshev_chebfromroots", "vc-description": "Generate a Chebyshev series with given roots.\n\nReturns the coefficients of the polynomial p(x) = (x - r₀) * (x - r₁) * ... * (x - rₙ)\nin Chebyshev form, where rₙ are the roots specified in the input.\n\nThe output coefficients c satisfy: p(x) = c₀ + c₁ * T₁(x) + ... + cₙ * Tₙ(x)\nwhere Tₙ(x) is the n-th Chebyshev polynomial of the first kind.\n\nSpecification: chebfromroots generates Chebyshev coefficients such that:\n1. The output has exactly n+1 coefficients where n is the number of roots\n2. The polynomial represented by these coefficients has the given roots\n3. When evaluated at any root rᵢ using Chebyshev basis, the result is zero\n4. The highest degree coefficient is non-zero (ensuring correct degree)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn chebfromroots(roots: Vec<f64>) -> (coeffs: Vec<f64>)\n    ensures\n        coeffs@.len() == roots@.len() + 1,\n        roots@.len() > 0 ==> coeffs@[roots@.len() as int] != 0.0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0384", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_chebyshev_chebgauss", "vc-description": "Computes the sample points and weights for Gauss-Chebyshev quadrature.\nThese sample points and weights will correctly integrate polynomials of\ndegree 2*n - 1 or less over the interval [-1, 1] with the weight \nfunction f(x) = 1/√(1 - x²).\n\nSpecification: chebgauss returns Gauss-Chebyshev quadrature nodes and weights\nwhere nodes are the zeros of the n-th Chebyshev polynomial and weights are \nuniform π/n. The nodes are given by cos(π(2i-1)/(2n)) for i = 1 to n.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn chebgauss(n: u8) -> (result: (Vec<f32>, Vec<f32>))\n    requires n > 0,\n    ensures\n        result.0.len() == n as usize,\n        result.1.len() == n as usize,\n        /* All weights are equal (uniform weights) */\n        forall|i: int, j: int| 0 <= i < n as int && 0 <= j < n as int ==> \n            #[trigger] result.1[i] == #[trigger] result.1[j],\n        /* Nodes are distinct */\n        forall|i: int, j: int| 0 <= i < n as int && 0 <= j < n as int && i != j ==> \n            #[trigger] result.0[i] != #[trigger] result.0[j],", "vc-code": "{\n    // impl-start\n    assume(false);\n    (Vec::new(), Vec::new())\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0386", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_chebyshev_chebgrid3d", "vc-description": "Evaluate a 3-D Chebyshev series on the Cartesian product of x, y, and z.\n\nThis function returns the values:\np(a,b,c) = ∑_{i,j,k} c_{i,j,k} * T_i(a) * T_j(b) * T_k(c)\n\nwhere the points (a, b, c) consist of all triples formed by taking\na from x, b from y, and c from z. The resulting points form\na grid with x in the first dimension, y in the second, and z in\nthe third.\n\nSpecification: chebgrid3d evaluates a 3D Chebyshev series on the Cartesian product.\nThe result at position (ix, iy, iz) is the sum over all coefficient indices (i, j, k)\nof c[i][j][k] * T_i(x[ix]) * T_j(y[iy]) * T_k(z[iz]) where T_n is the n-th\nChebyshev polynomial.\n\nMathematical properties:\n1. The output has the correct shape: nx × ny × nz\n2. Each element is computed as a triple sum over the coefficient indices\n3. The function evaluates the 3D Chebyshev series at each grid point\n4. For a zero coefficient array, the result is zero everywhere\n5. The result is linear in the coefficients\n6. The Chebyshev polynomials T_i satisfy the recurrence relation:\n   T_0(x) = 1, T_1(x) = x, T_{n+1}(x) = 2x*T_n(x) - T_{n-1}(x)\n7. The evaluation respects the orthogonality of Chebyshev polynomials on [-1, 1]\n8. When all x, y, z values are in [-1, 1], the series converges uniformly\n9. The result is the tensor product of 1D Chebyshev evaluations", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn chebyshev_T(n: nat, x: f64) -> f64 \n    decreases n\n{\n    if n == 0 {\n        1.0\n    } else if n == 1 {\n        x\n    } else {\n        0.0\n    }\n}\n\nfn chebgrid3d(\n    x: Vec<f64>, \n    y: Vec<f64>, \n    z: Vec<f64>,\n    c: Vec<Vec<Vec<f64>>>\n) -> (result: Vec<Vec<Vec<f64>>>)\n    requires \n        x.len() > 0,\n        y.len() > 0, \n        z.len() > 0,\n        c.len() > 0,\n        forall|i: int| 0 <= i < c.len() ==> c[i].len() > 0,\n        forall|i: int, j: int| 0 <= i < c.len() && 0 <= j < c[i].len() ==> c[i][j].len() > 0,\n    ensures\n        result.len() == x.len(),\n        forall|ix: int| 0 <= ix < result.len() ==> result[ix].len() == y.len(),\n        forall|ix: int, iy: int| 0 <= ix < result.len() && 0 <= iy < result[ix].len() ==> result[ix][iy].len() == z.len()", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0387", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_chebyshev_chebint", "vc-description": "numpy.polynomial.chebyshev.chebint: Integrate a Chebyshev series.\n\nReturns the Chebyshev series coefficients integrated m times from\nlbnd along axis. At each iteration the resulting series is\nmultiplied by scl and an integration constant k is added.\n\nThe integration transforms Chebyshev polynomials according to the\nrecurrence relations for Chebyshev polynomial integrals. For a \nsingle integration (m=1) of coefficients [c₀, c₁, ..., cₙ], the \nresult follows the Chebyshev integration formula.\n\nParameters:\n- c: Vector of Chebyshev series coefficients (low to high degree)\n- m: Order of integration (must be positive)\n- k: Integration constants (defaults to zeros)\n- lbnd: Lower bound of the integral (default: 0)\n- scl: Scaling factor applied after each integration (default: 1)\n\nSpecification: chebint integrates Chebyshev series coefficients m times.\n\nThe function performs m successive integrations of the Chebyshev series,\nwhere each integration:\n1. Multiplies the current coefficients by scl\n2. Applies the Chebyshev integration recurrence relations\n3. Adjusts the constant term to satisfy the boundary condition at lbnd\n4. Adds the corresponding integration constant from k\n\nMathematical properties:\n- The result has m more coefficients than the input (integration increases degree)\n- For m=0, returns the original coefficients unchanged\n- The integration follows Chebyshev polynomial recurrence relations:\n  ∫ Tₙ(x) dx = [Tₙ₊₁(x)/(2(n+1)) - Tₙ₋₁(x)/(2(n-1))] for n ≥ 2\n  ∫ T₁(x) dx = T₂(x)/4\n  ∫ T₀(x) dx = T₁(x)\n- The constant term is adjusted so the integral equals k[i] at x=lbnd\n\nSanity checks:\n- The output vector has exactly n + m coefficients\n- When m = 0, the function should return the input unchanged\n- Integration constants k affect only the constant term of each integration\n- The scaling factor scl is applied before adding integration constants\n\n/* For m=1 case, the function performs Chebyshev integration according to:\n           - T₀ integrates to T₁  \n           - T₁ integrates to T₂/4\n           - Tₙ (n≥2) integrates to [Tₙ₊₁/(2(n+1)) - Tₙ₋₁/(2(n-1))]\n           - The constant term is adjusted for boundary conditions at lbnd\n           - Integration constants from k are added appropriately\n\n           Note: Complex floating-point arithmetic specifications are simplified\n           due to Verus limitations with f32 operations in spec contexts */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn chebint(c: Vec<f32>, m: u8, k: Vec<f32>, lbnd: f32, scl: f32) -> (result: Vec<f32>)\n    requires \n        m > 0,\n        scl != 0.0f32,\n        k.len() == m as usize,\n    ensures\n        result.len() == c.len() + (m as usize),\n\n        result.len() >= c.len(),\n        m == 1 ==> result.len() == c.len() + 1,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0388", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_chebyshev_chebinterpolate", "vc-description": "Interpolate a function at the Chebyshev points of the first kind.\n\nReturns the Chebyshev series coefficients that interpolate the given function\nat the Chebyshev points of the first kind in the interval [-1, 1]. The resulting\ncoefficients represent a polynomial of degree deg that interpolates the function\nat deg+1 Chebyshev points.\n\nThe Chebyshev interpolation provides near-optimal polynomial approximation\nfor continuous functions on [-1, 1], minimizing the Runge phenomenon and\nproviding good convergence properties.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_constant_function(func: spec_fn(f64) -> f64) -> bool {\n    forall|x: f64, y: f64| #[trigger] func(x) == #[trigger] func(y)\n}\n\nfn chebinterpolate(deg: usize, func: spec_fn(f64) -> f64) -> (coef: Vec<f64>)\n    ensures \n        coef.len() == deg + 1,\n        /* The coefficients satisfy the key properties of Chebyshev interpolation:\n           1. The coefficient vector has the correct length (guaranteed by type)\n           2. When the function is constant, all coefficients except the first are zero */\n        is_constant_function(func) ==> (\n            coef[0] == func(0.0) &&\n            forall|i: int| 1 <= i < coef.len() ==> #[trigger] coef[i] == 0.0\n        )", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0389", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_chebyshev_chebline", "vc-description": "Chebyshev series whose graph is a straight line.\nReturns coefficients for the Chebyshev series representing off + scl*x.\nFor simplicity, we always return a 2-element vector where the second element\nmight be zero when scl = 0.\n\nSpecification: chebline returns correct Chebyshev coefficients for a linear function.\nThe key mathematical property is that the Chebyshev series T₀(x) = 1 and T₁(x) = x,\nso the coefficients [off, scl] directly represent off*T₀(x) + scl*T₁(x) = off + scl*x.\n\nThe result is always a 2-element vector [off, scl], even when scl = 0.\nThis represents the Chebyshev series: off * T₀(x) + scl * T₁(x) = off + scl*x\n\nMathematical Properties:\n1. The first coefficient equals the offset parameter\n2. The second coefficient equals the scale parameter\n3. When evaluated as a Chebyshev series, this produces the line off + scl*x\n4. This is the minimal degree Chebyshev representation of a linear function", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn chebline(off: f32, scl: f32) -> (result: [f32; 2])\n    ensures \n        result[0] == off,\n        result[1] == scl", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0390", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_chebyshev_chebmul", "vc-description": "Multiply one Chebyshev series by another.\n\nReturns the product of two Chebyshev series c1 * c2. The arguments\nare sequences of coefficients, from lowest order term to highest,\ne.g., [1,2,3] represents the series T_0 + 2*T_1 + 3*T_2.\n\nThe result length is m + n - 1 where m and n are the lengths of c1 and c2.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn chebmul(c1: Vec<i8>, c2: Vec<i8>) -> (result: Vec<i8>)\n    requires \n        c1.len() > 0,\n        c2.len() > 0,\n    ensures\n        result.len() == c1.len() + c2.len() - 1,\n        /* Example property: multiplying by the constant polynomial [a] scales all coefficients */\n        (c2.len() == 1 ==> forall|i: int| 0 <= i < c1.len() ==> result[i] as int == c2[0] as int * c1[i] as int),\n        /* Another example: multiplying [1,0,...] (T_0) by any polynomial preserves it */\n        (c1.len() == 1 && c1[0] as int == 1 ==> forall|j: int| 0 <= j < c2.len() ==> result[j] as int == c2[j] as int),\n        /* Special case: multiplying two linear polynomials [a,b] * [c,d] */\n        /* Result should be [ac + bd/2, ad + bc, bd/2] */\n        (c1.len() == 2 && c2.len() == 2 ==> {\n            let a = c1[0] as int;\n            let b = c1[1] as int; \n            let c = c2[0] as int;\n            let d = c2[1] as int;\n            result[0] as int == a * c + b * d / 2 &&\n            result[1] as int == a * d + b * c &&\n            result[2] as int == b * d / 2\n        }),\n        /* Verify the example from documentation: [1,2,3] * [3,2,1] */\n        /* Result should be [6.5, 12, 12, 4, 1.5] but using integers for now */\n        (c1.len() == 3 && c2.len() == 3 ==> {\n            (c1[0] as int == 1 && c1[1] as int == 2 && c1[2] as int == 3 &&\n             c2[0] as int == 3 && c2[1] as int == 2 && c2[2] as int == 1) ==>\n            (result.len() == 5)\n        })", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0391", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_chebyshev_chebmulx", "vc-description": "Multiply a Chebyshev series by x.\nThis function multiplies a Chebyshev polynomial represented by its coefficients by x.\nThe operation is based on the recurrence relation:\n- xT₀(x) = T₁(x)\n- xTₙ(x) = (Tₙ₊₁(x) + Tₙ₋₁(x))/2 for n ≥ 1\n\nSpecification: chebmulx correctly multiplies a Chebyshev polynomial by x.\n\nGiven coefficients c = [c₀, c₁, ..., cₙ₋₁] representing the polynomial\nP(x) = c₀T₀(x) + c₁T₁(x) + ... + cₙ₋₁Tₙ₋₁(x),\nthis function computes coefficients for xP(x).\n\nThe implementation follows from the Chebyshev recurrence relations:\n- xT₀(x) = T₁(x)\n- xTₙ(x) = (Tₙ₊₁(x) + Tₙ₋₁(x))/2 for n ≥ 1\n\nThe algorithm redistributes coefficients according to these relations,\nresulting in a polynomial with degree increased by 1.\n\n// Linearity property: chebmulx is a linear operation\n\n// For any scalars alpha, beta and vectors c1, c2 of same length:\n\n// chebmulx(alpha*c1 + beta*c2) = alpha*chebmulx(c1) + beta*chebmulx(c2)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn chebmulx(c: Vec<i8>) -> (result: Vec<i8>)\n    requires c.len() > 0,\n    ensures\n        result.len() == c.len() + 1,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0392", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_chebyshev_chebpow", "vc-description": "Raise a Chebyshev series to a power.\n\nReturns the Chebyshev series c raised to the power pow. The\nargument c is a sequence of coefficients ordered from low to high,\ni.e., [1,2,3] represents the series T_0 + 2*T_1 + 3*T_2.\n\nThe power must be a non-negative integer. Special cases:\n- pow = 0 returns [1] (the constant polynomial 1)\n- pow = 1 returns the input series unchanged\n- pow > 1 returns the series multiplied by itself pow times\n\nThe result length grows as: 1 + (n - 1) * pow, where n is the input length.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn chebpow(c: Vec<f64>, pow: u8, maxpower: u8) -> (result: Vec<f64>)\n    requires \n        c.len() > 0,\n        pow <= maxpower,\n    ensures\n        /* Special case: pow = 0 returns [1.0] */\n        (pow as nat == 0) ==> (result.len() == 1 && result[0] == 1.0),\n        /* Special case: pow = 1 returns input unchanged */\n        (pow as nat == 1) ==> (result.len() == c.len() && \n            forall|i: int| 0 <= i < c.len() ==> result[i] == c[i]),\n        /* Result length is correct */\n        result.len() == (if pow as nat == 0 { 1 } else { 1 + (c.len() - 1) * pow as nat }),\n        /* For pow > 1: first coefficient exists when appropriate */\n        (pow as nat > 1 && c.len() >= 1) ==> (result.len() > 0),\n        /* Non-triviality for pow >= 2 with sufficient input length */\n        (pow as nat >= 2 && c.len() >= 2 && result.len() > 2) ==> \n            (result[0] != 0.0 || result[1] != 0.0 || result[2] != 0.0),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0393", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_chebyshev_chebpts1", "vc-description": "numpy.polynomial.chebyshev.chebpts1: Chebyshev points of the first kind.\n\nThe Chebyshev points of the first kind are the points cos(π*(k + 0.5)/n)\nfor k in range(n), which are the roots of the Chebyshev polynomial T_n(x).\nThese points are particularly useful for polynomial interpolation as they\nminimize the Runge phenomenon.\n\nThe implementation uses the identity sin(x) = cos(π/2 - x) to compute\nthe values using sine instead of cosine.\n\nSpecification: chebpts1 returns a vector of n Chebyshev points of the first kind.\n\nThe k-th point (0-indexed) is cos(π*(k + 0.5)/n), which equals\nsin(π*(n - k - 0.5)/n) by the complementary angle identity.\n\nPrecondition: n > 0 (at least one point must be generated)\nPostcondition: \n1. For all indices k, result[k] = cos(π*(k + 0.5)/n)\n2. The points are in descending order: for all i < j, result[i] > result[j]\n3. All points lie in the interval [-1, 1]\n4. The points are symmetric about 0: result[k] = -result[n-1-k] for all k", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn chebyshev_point_value(k: int, n: int) -> int { arbitrary() }\n\nfn chebpts1(n: usize) -> (result: Vec<i32>)\n    requires n > 0,\n    ensures \n        result.len() == n,\n        forall|k: int| 0 <= k < n ==> #[trigger] result@[k] == chebyshev_point_value(k, n as int),\n        forall|k: int| 0 <= k < n ==> -1000 <= #[trigger] result@[k] <= 1000,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0394", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_chebyshev_chebpts2", "vc-description": "Chebyshev points of the second kind.\n\nGenerates n Chebyshev points of the second kind, which are the values\ncos(π*k/(n-1)) for k from 0 to n-1, sorted in ascending order.\nThese points are the extrema and endpoints of the Chebyshev polynomial T_{n-1}.\n\nSpecification: chebpts2 generates Chebyshev points of the second kind\n\nThe function returns n points where:\n1. Each point is cos(π*k/(n-1)) for k from n-1 down to 0\n2. The points are sorted in ascending order\n3. The first point is -1 and the last point is 1\n4. The points are symmetric around 0 for the transformation x ↦ -x\n\n// First point is -1 \n\n// Last point is 1", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn chebpts2(n: usize) -> (result: Vec<f32>)\n    requires n >= 2,\n    ensures\n        result.len() == n,\n\n        result[0] == -1.0f32,\n\n        result[(n-1) as int] == 1.0f32,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0396", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_chebyshev_chebsub", "vc-description": "Subtract one Chebyshev series from another component-wise.\nThe input vectors c1 and c2 represent Chebyshev series coefficients\nordered from lowest to highest degree term.\n\nSpecification: chebsub performs component-wise subtraction of two Chebyshev series.\n\nThe specification includes:\n1. The basic property that each coefficient in the result is the difference\n   of the corresponding coefficients in c1 and c2\n2. Anti-commutativity: chebsub(c1, c2) = -chebsub(c2, c1)\n3. Identity property: subtracting a series from itself yields zero\n4. Associativity with addition: (c1 - c2) + c2 = c1", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn chebsub(c1: Vec<i8>, c2: Vec<i8>) -> (result: Vec<i8>)\n    requires c1.len() == c2.len(),\n    ensures \n        result.len() == c1.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] as int == c1[i] as int - c2[i] as int,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0400", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_chebyshev_chebvander", "vc-description": "Pseudo-Vandermonde matrix of Chebyshev polynomials of given degree.\n\nGiven a vector of sample points `x` and a degree `deg`, returns a matrix\nwhere each row corresponds to a sample point and each column contains\nthe values of Chebyshev polynomials T_0, T_1, ..., T_deg evaluated at\nthat point.\n\nSpecification: chebvander produces a matrix where entry (i,j) is the j-th Chebyshev \npolynomial T_j evaluated at x[i], following the recurrence relation:\nT_0(x) = 1, T_1(x) = x, T_{k+1}(x) = 2x*T_k(x) - T_{k-1}(x)\n\n/* T_0(x) = 1 for all x */\n\n/* T_1(x) = x when deg >= 1 */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn chebvander(x: Vec<f32>, deg: usize) -> (result: Vec<Vec<f32>>)\n    requires deg >= 0,\n    ensures\n\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == (deg + 1),\n        forall|i: int| 0 <= i < result.len() ==> result[i][0] == 1.0f32,\n\n        deg >= 1 ==> forall|i: int| 0 <= i < result.len() ==> result[i][1] == x@[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0403", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_chebyshev_chebweight", "vc-description": "The weight function of the Chebyshev polynomials.\nComputes 1/sqrt(1 - x²) for each element.\n\nSpecification: chebweight computes the Chebyshev weight function 1/sqrt(1 - x²).\nThe function is well-defined when all elements are in the open interval (-1, 1).\n\nMathematical properties:\n1. The weight function equals 1/sqrt(1 - x²) for each element\n2. The result is always positive for valid inputs\n3. The function is symmetric: w(-x) = w(x)\n4. The function approaches infinity as x approaches ±1\n5. The implementation uses the factored form 1/(sqrt(1+x) * sqrt(1-x)) for numerical stability", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn chebweight(x: Vec<f32>) -> (result: Vec<f32>)\n    requires \n        x.len() > 0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0404", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_chebyshev_poly2cheb", "vc-description": "Convert a polynomial to a Chebyshev series.\n\nConvert coefficients of a polynomial in the standard monomial basis\n(1, x, x², x³, ...) to coefficients in the Chebyshev polynomial basis\n(T₀(x), T₁(x), T₂(x), T₃(x), ...).\n\nThe input polynomial coefficients are ordered from lowest degree to highest:\npol = [a₀, a₁, a₂, ..., aₙ] represents the polynomial a₀ + a₁x + a₂x² + ... + aₙxⁿ\n\nThe output Chebyshev coefficients are also ordered from lowest to highest degree:\nresult = [c₀, c₁, c₂, ..., cₙ] represents c₀T₀(x) + c₁T₁(x) + c₂T₂(x) + ... + cₙTₙ(x)\n\n/* Example from documentation: [0.0, 1.0, 2.0, 3.0] → [1.0, 3.25, 1.0, 0.75] */\n\n/* Quadratic polynomial x²: [0, 0, 1] → [0.5, 0, 0.5] */\n\n/* Cubic polynomial x³: [0, 0, 0, 1] → [0, 0.75, 0, 0.25] */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn poly2cheb(pol: Vec<f64>) -> (result: Vec<f64>)\n    requires pol.len() > 0,\n    ensures \n        result.len() == pol.len(),\n\n        (pol.len() == 4 && pol[0] == 0.0 && pol[1] == 1.0 && pol[2] == 2.0 && pol[3] == 3.0) ==>\n            (result[0] == 1.0 && result[1] == 3.25 && result[2] == 1.0 && result[3] == 0.75),\n\n        (pol.len() == 3 && pol[0] == 0.0 && pol[1] == 0.0 && pol[2] == 1.0) ==>\n            (result[0] == 0.5 && result[1] == 0.0 && result[2] == 0.5),\n\n        (pol.len() == 4 && pol[0] == 0.0 && pol[1] == 0.0 && pol[2] == 0.0 && pol[3] == 1.0) ==>\n            (result[0] == 0.0 && result[1] == 0.75 && result[2] == 0.0 && result[3] == 0.25)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0405", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_hermite_Hermite", "vc-description": "Evaluates a Hermite polynomial at a given point.\nGiven coefficients (c₀, c₁, ..., cₙ), evaluates ∑ᵢ cᵢ * Hᵢ(x)\nwhere Hᵢ is the i-th Hermite polynomial.\n\nThe Hermite polynomials satisfy the recurrence:\nH₀(x) = 1\nH₁(x) = 2x\nHₙ₊₁(x) = 2x * Hₙ(x) - 2n * Hₙ₋₁(x)\n\nSpecification: hermiteEval correctly evaluates the Hermite polynomial series.\n\nMathematical properties:\n1. Empty coefficient vector evaluates to 0\n2. Single coefficient [c] evaluates to c * H₀(x) = c * 1 = c\n3. Two coefficients [a, b] evaluates to a + b * 2x\n4. The evaluation follows the Hermite polynomial recurrence relation\n5. Hermite polynomials form an orthogonal basis\n\n/* Complex Hermite polynomial properties */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermite_eval(coef: Vec<f32>, x: f32) -> (result: f32)\n    requires coef.len() > 0,\n    ensures \n        coef.len() == 1 ==> result == coef@[0],\n        coef.len() >= 2 ==> true,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0406", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_hermite_e_HermiteE", "vc-description": "An HermiteE series class.\n\nThe HermiteE class provides the standard Python numerical methods\n'+', '-', '*', '//', '%', 'divmod', '**', and '()' as well as the\nattributes and methods listed below.\n\nParameters\n----------\ncoef : array_like\n    HermiteE coefficients in order of increasing degree, i.e,\n    ``(1, 2, 3)`` gives ``1*He_0(x) + 2*He_1(X) + 3*He_2(x)``.\ndomain : (2,) array_like, optional\n    Domain to use. The interval ``[domain[0], domain[1]]`` is mapped\n    to the interval ``[window[0], window[1]]`` by shifting and scaling.\n    The default value is [-1., 1.].\nwindow : (2,) array_like, optional\n    Window, see `domain` for its use. The default value is [-1., 1.].\nsymbol : str, optional\n    Symbol used to represent the independent variable in string\n    representations of the polynomial expression, e.g. for printing.\n    The symbol must be a valid Python identifier. Default value is 'x'.\n\n    .. versionadded:: 1.24\n\nCreate a HermiteE polynomial from coefficients with default domain and window [-1, 1]\n\nSpecification: Creating a HermiteE polynomial preserves coefficients and establishes mathematical properties.\n\nHermiteE polynomials are the \"probabilists'\" version of Hermite polynomials.\nKey mathematical properties:\n1. He₀(x) = 1, He₁(x) = x\n2. Recurrence: Heₙ₊₁(x) = x * Heₙ(x) - n * Heₙ₋₁(x)\n3. Parity: He_n(-x) = (-1)^n He_n(x)\n4. Orthogonality with respect to Gaussian weight e^(-x²/2)\n\n/* Structure representing a HermiteE polynomial with coefficients and domain/window mapping.\n   HermiteE polynomials are the \"probabilists'\" version of Hermite polynomials.\n   They satisfy the recurrence relation:\n   He₀(x) = 1\n   He₁(x) = x  \n   Heₙ₊₁(x) = x * Heₙ(x) - n * Heₙ₋₁(x)\n\n   The coefficients represent the expansion: ∑ᵢ cᵢ * Heᵢ(x)\n*/\n\n/* Coefficients of the HermiteE polynomial in increasing degree order */\n\n/* Domain interval [domain_min, domain_max] */\n\n/* Domain interval upper bound */\n\n/* Window interval [window_min, window_max] */\n\n/* Window interval upper bound */\n\n/* Coefficients are preserved exactly */\n\n/* Default domain is [-1, 1] */\n\n/* Default window is [-1, 1] */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nstruct HermiteEPoly {\n\n    coef: Vec<f32>,\n\n    domain_min: f32,\n\n    domain_max: f32,\n\n    window_min: f32,\n\n    window_max: f32,\n}", "vc-helpers": "", "vc-spec": "fn hermite_e(coef: Vec<f32>) -> (result: HermiteEPoly)\n    ensures\n\n        result.coef@.len() == coef@.len(),\n        forall|i: int| 0 <= i < coef@.len() ==> result.coef@[i] == coef@[i],\n\n        result.domain_min == -1.0f32,\n        result.domain_max == 1.0f32,\n\n        result.window_min == -1.0f32,\n        result.window_max == 1.0f32,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0408", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_hermite_e_hermeadd", "vc-description": "Add one Hermite series to another. Component-wise addition of polynomial coefficients.\n\nSpecification: hermeadd performs component-wise addition of Hermite polynomial coefficients.\nThe result has the length of the longer input vector. Elements are added where both vectors\nhave coefficients, and remaining coefficients from the longer vector are preserved.\n\nThis models the mathematical property that polynomial addition is component-wise:\n(a₀ + a₁x + a₂x² + ...) + (b₀ + b₁x + b₂x² + ...) = (a₀+b₀) + (a₁+b₁)x + (a₂+b₂)x² + ...\n\nAdditional mathematical properties:\n- Commutativity: hermeadd c1 c2 = hermeadd c2 c1\n- Associativity: hermeadd (hermeadd c1 c2) c3 = hermeadd c1 (hermeadd c2 c3)\n- Zero identity: hermeadd c (zero vector) = c (extended appropriately)\n- Preservation of polynomial structure: addition preserves Hermite polynomial properties", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermeadd(c1: Vec<i8>, c2: Vec<i8>) -> (result: Vec<i8>)\n    ensures\n        result.len() == if c1.len() >= c2.len() { c1.len() } else { c2.len() },\n        forall|i: int| 0 <= i < result@.len() ==> {\n            let coeff1 = if i < c1@.len() { c1@[i] as int } else { 0 };\n            let coeff2 = if i < c2@.len() { c2@[i] as int } else { 0 };\n            #[trigger] result@[i] as int == coeff1 + coeff2\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0409", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_hermite_e_hermecompanion", "vc-description": "Return the scaled companion matrix of HermiteE series coefficients.\nThe companion matrix is scaled for better eigenvalue estimates and\nsymmetry properties when used with HermiteE basis polynomials.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermecompanion(c: Vec<f32>) -> (mat: Vec<Vec<f32>>)\n    requires \n        c@.len() >= 2,\n        c[c@.len() - 1] != 0.0f32,\n    ensures\n        mat@.len() == c@.len() - 1,\n        forall|i: int| 0 <= i < mat@.len() ==> mat@[i].len() == c@.len() - 1,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0410", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_hermite_e_hermeder", "vc-description": "Differentiate a Hermite_e series by taking the derivative of coefficients.\nTakes coefficients from low to high degree and returns differentiated coefficients.\n\nSpecification: hermeder correctly differentiates Hermite_e series coefficients.\nThe result has degree reduced by 1, and each coefficient is multiplied by its index\nand scaled by scl^m. For a single differentiation (m=1), the coefficient of degree k\nbecomes k * scl * original_coefficient.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermeder(c: Vec<f64>, m: u8, scl: f64) -> (result: Vec<f64>)\n    requires \n        c.len() > 0,\n        m as nat > 0,\n        scl != 0.0,\n    ensures \n        result.len() == c.len() - 1,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0411", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_hermite_e_hermediv", "vc-description": "Divide one Hermite series by another, returning quotient and remainder.\nThe dividend c1 and divisor c2 are coefficient vectors representing Hermite polynomials.\nThe division is performed in the Hermite polynomial basis with reprojection.\n\nSpecification: hermediv performs polynomial division of Hermite series, returning\nboth quotient and remainder such that c1 = quo * c2 + rem (in Hermite basis).\n\nKey mathematical properties:\n1. Division identity: The dividend equals quotient times divisor plus remainder\n2. Remainder degree constraint: The remainder has degree less than the divisor\n3. Non-zero divisor: The divisor must not be the zero polynomial\n4. Reprojection: Results are reprojected onto the Hermite polynomial basis\n\nThe specification captures the fundamental division algorithm for polynomials\nadapted to the Hermite polynomial basis set.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermediv(c1: Vec<f64>, c2: Vec<f64>) -> (result: (Vec<f64>, Vec<f64>))\n    requires \n        c2.len() > 0,\n        exists|i: int| 0 <= i < c2@.len() && c2[i] != 0.0,\n    ensures \n        (result.0@.len() >= 1) &&\n        (result.1@.len() < c2@.len()) &&\n        /* Division property: degree of remainder < degree of divisor */\n        /* This is the key mathematical property of polynomial division */\n        (result.1@.len() < c2@.len()) &&\n        /* Well-formedness: all coefficients are real numbers (not NaN or infinite) */\n        (forall|i: int| 0 <= i < result.0@.len() ==> result.0[i] == result.0[i]) &&\n        (forall|j: int| 0 <= j < result.1@.len() ==> result.1[j] == result.1[j]) &&\n        /* Mathematical property: division preserves degree relationships */\n        /* The quotient degree + divisor degree should not exceed dividend degree */\n        (result.0@.len() + c2@.len() >= c1@.len() || c1@.len() == 0) &&\n        /* Remainder constraint: remainder degree is less than divisor degree */\n        /* This ensures the division algorithm terminates correctly */\n        (result.1@.len() < c2@.len())", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0412", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_hermite_e_hermefit", "vc-description": "Least squares fit of Hermite series to data.\nReturns the coefficients of a HermiteE series of degree `deg` that is\nthe least squares fit to the data values `y` given at points `x`.\n\n/* Coefficients are valid - basic sanity check */\n\n/* Least squares property: the result minimizes sum of squared residuals */\n\n/* When deg+1 == data points, polynomial passes through all points exactly */\n\n/* Orthogonality condition: residuals are orthogonal to basis functions */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn hermite_e(n: nat, x: int) -> int\n    decreases n\n{\n    if n == 0 {\n        1\n    } else if n == 1 {\n        x  \n    } else {\n        let n_minus_1 = (n - 1) as nat;\n        let n_minus_2 = (n - 2) as nat;\n        x * hermite_e(n_minus_1, x) - ((n - 1) as int) * hermite_e(n_minus_2, x)\n    }\n}\n\nspec fn sum_hermite_series(coeffs: Seq<int>, x: int, deg: nat) -> int\n    decreases deg\n{\n    if coeffs.len() == 0 || deg >= coeffs.len() {\n        0\n    } else if deg == 0 {\n        coeffs[0] * hermite_e(0nat, x)\n    } else {\n        let prev_deg = (deg - 1) as nat;\n        coeffs[deg as int] * hermite_e(deg, x) + sum_hermite_series(coeffs, x, prev_deg)\n    }\n}\n\nspec fn sum_squared_residuals_rec(x: Seq<int>, y: Seq<int>, coeffs: Seq<int>, n: nat) -> int\n    decreases n\n{\n    if n == 0 || n > x.len() || n > y.len() || coeffs.len() == 0 {\n        0\n    } else {\n        let i_nat = (n - 1) as nat;\n        let i = i_nat as int;\n        if i < 0 || i >= x.len() || i >= y.len() {\n            0\n        } else {\n            let xi = x[i];\n            let yi = y[i];\n            let deg_nat = if coeffs.len() > 0 { (coeffs.len() - 1) as nat } else { 0nat };\n            let predicted = sum_hermite_series(coeffs, xi, deg_nat);\n            let residual = yi - predicted;\n            sum_squared_residuals_rec(x, y, coeffs, i_nat) + residual * residual\n        }\n    }\n}", "vc-helpers": "", "vc-spec": "fn hermefit(x: Vec<i8>, y: Vec<i8>, deg: usize) -> (result: Vec<i8>)\n    requires \n        x.len() == y.len(),\n        deg + 1 <= x.len(),\n        x.len() > 0,\n    ensures \n        result.len() == deg + 1,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "VT0413", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_hermite_e_hermefromroots", "vc-description": "Generate a HermiteE series with given roots.\n\nReturns the coefficients of the polynomial p(x) = (x - r₀) * (x - r₁) * ... * (x - rₙ₋₁)\nin HermiteE form, where rᵢ are the roots specified in the input vector.\n\nThe output coefficients c satisfy: p(x) = c₀ + c₁ * He₁(x) + ... + cₙ * Heₙ(x)\nwhere Heₙ(x) is the n-th probabilist's Hermite polynomial (HermiteE).\n\nThis function converts from the standard polynomial representation with given roots\nto the HermiteE polynomial basis representation.\n\nSpecification: hermefromroots generates HermiteE coefficients such that:\n1. The output has exactly n+1 coefficients where n is the number of roots\n2. The polynomial represented by these coefficients has the given roots\n3. When evaluated at any root rᵢ using HermiteE basis, the result is zero\n4. The highest degree coefficient is non-zero (ensuring correct degree)\n5. The polynomial satisfies the fundamental property p(x) = (x - r₀) * ... * (x - rₙ₋₁)\n\n/* Evaluate the k-th probabilist's Hermite polynomial (HermiteE) at x */\n\n/* Evaluate a polynomial in HermiteE basis at point x given coefficients */\n\n/* Product form helper: (x - r₀) * (x - r₁) * ... * (x - rᵢ₋₁) */\n\n/* Empty roots give the constant polynomial 1 */\n\n/* The polynomial degree matches the number of roots (leading coefficient is non-zero) */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn eval_hermite_e(k: nat, x: int) -> int \n    decreases k\n{\n    if k == 0 {\n        1\n    } else if k == 1 {\n        x\n    } else {\n        x * eval_hermite_e((k - 1) as nat, x) - (k - 1) as int * eval_hermite_e((k - 2) as nat, x)\n    }\n}\n\nspec fn eval_hermite_e_poly(coeffs: Seq<int>, x: int) -> int \n    decreases coeffs.len()\n{\n    if coeffs.len() == 0 {\n        0\n    } else {\n        coeffs[0] * eval_hermite_e(0, x) + eval_hermite_e_poly(coeffs.skip(1), x)\n    }\n}\n\nspec fn product_form(roots: Seq<int>, x: int, i: nat) -> int \n    decreases i\n{\n    if i == 0 {\n        1\n    } else {\n        product_form(roots, x, (i - 1) as nat) * (x - roots[(i - 1) as int])\n    }\n}", "vc-helpers": "", "vc-spec": "fn hermefromroots(roots: Vec<i8>) -> (coeffs: Vec<i8>)\n    ensures\n        coeffs.len() == roots.len() + 1,\n\n        (roots.len() == 0 ==> coeffs.len() == 1),\n\n        (roots.len() > 0 ==> coeffs.len() == roots.len() + 1),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0414", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_hermite_e_hermegauss", "vc-description": "numpy.polynomial.hermite_e.hermegauss: Gauss-HermiteE quadrature.\n\nComputes the sample points and weights for Gauss-HermiteE quadrature.\nThese sample points and weights will correctly integrate polynomials of\ndegree 2*deg - 1 or less over the interval [-∞, ∞] with the weight\nfunction f(x) = exp(-x²/2).\n\nThe function returns a pair (x, w) where x contains the sample points\nand w contains the corresponding weights.\n\nSpecification: hermegauss returns quadrature points and weights for HermiteE polynomials.\n\nPrecondition: deg > 0 (need at least one quadrature point)\nPostcondition: The returned points and weights satisfy the mathematical properties\nof Gauss-HermiteE quadrature including positivity, symmetry, and ordering.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermegauss(deg: usize) -> (result: (Vec<i8>, Vec<i8>))\n    requires deg > 0,\n    ensures\n        /* Points are ordered (sorted in ascending order) */\n        forall|i: int, j: int| 0 <= i < j < deg ==> #[trigger] result.0@[i] < #[trigger] result.0@[j],\n        /* Weights are positive */\n        forall|i: int| 0 <= i < deg ==> #[trigger] result.1@[i] > 0,\n        /* Return tuple has correct lengths */\n        result.0@.len() == deg && result.1@.len() == deg,", "vc-code": "{\n    // impl-start\n    assume(false);\n    (Vec::new(), Vec::new())\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0415", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_hermite_e_hermegrid2d", "vc-description": "numpy.polynomial.hermite_e.hermegrid2d: Evaluate a 2-D HermiteE series on the Cartesian product of x and y.\n\nThis function evaluates a 2-dimensional HermiteE polynomial series\non the Cartesian product of coordinate vectors x and y.\n\nThe evaluation follows the mathematical formula:\np(a,b) = sum_{i,j} c[i,j] * He_i(a) * He_j(b)\n\nwhere He_i is the i-th probabilist's Hermite polynomial (HermiteE),\nand the points (a,b) are formed by taking all combinations of\nelements from x and y.\n\nThe result is a matrix where result[i,j] contains the polynomial\nvalue at the point (x[i], y[j]).\n\nSpecification: hermegrid2d evaluates a 2D HermiteE polynomial series \non the Cartesian product of x and y coordinates.\n\nThe function computes p(a,b) = sum_{i,j} c[i,j] * He_i(a) * He_j(b)\nwhere He_i is the i-th probabilist's Hermite polynomial.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermegrid2d(x: Vec<f32>, y: Vec<f32>, c: Vec<Vec<f32>>) -> (result: Vec<Vec<f32>>)\n    ensures\n        result@.len() == x@.len(),\n        forall|i: int| 0 <= i < result@.len() ==> result@[i].len() == y@.len(),\n        forall|i: int, j: int| 0 <= i < result@.len() && 0 <= j < result@[i].len() ==> (\n            (c@.len() == 0 || (exists|k: int| 0 <= k < c@.len() && c@[k].len() == 0) ==> result@[i][j] == 0.0f32)\n        ),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0416", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_hermite_e_hermegrid3d", "vc-description": "numpy.polynomial.hermite_e.hermegrid3d: Evaluate a 3-D HermiteE series on the Cartesian product of x, y, and z.\n\nThis function evaluates a 3-dimensional HermiteE polynomial series\non the Cartesian product of coordinate vectors x, y, and z.\n\nThe evaluation follows the mathematical formula:\np(a,b,c) = sum_{i,j,k} c[i,j,k] * He_i(a) * He_j(b) * He_k(c)\n\nwhere He_i is the i-th probabilist's Hermite polynomial (HermiteE),\nand the points (a,b,c) are formed by taking all combinations of\nelements from x, y, and z.\n\nThe result is a 3D tensor where result[i,j,k] contains the polynomial\nvalue at the point (x[i], y[j], z[k]).\n\nSpecification: hermegrid3d evaluates a 3D HermiteE polynomial series \non the Cartesian product of x, y, and z coordinates.\n\nThe function computes p(a,b,c) = sum_{i,j,k} c[i,j,k] * He_i(a) * He_j(b) * He_k(c)\nwhere He_i is the i-th probabilist's Hermite polynomial.\n\nMathematical Properties:\n1. The result represents evaluation at all Cartesian product points\n2. HermiteE polynomials satisfy He_0(x) = 1, He_1(x) = x, \n   and the recurrence He_{n+1}(x) = x * He_n(x) - n * He_{n-1}(x)\n3. The evaluation is exact for the polynomial representation\n4. Result shape is nx × ny × nz, matching the Cartesian product", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn hermite_e_poly(x: int, n: nat) -> int\n    decreases n\n{\n    if n == 0 {\n        1\n    } else if n == 1 {\n        x\n    } else {\n        x * hermite_e_poly(x, (n - 1) as nat) - (n - 1) * hermite_e_poly(x, (n - 2) as nat)\n    }\n}\n\nfn hermegrid3d(x: Vec<f32>, y: Vec<f32>, z: Vec<f32>, c: Vec<Vec<Vec<f32>>>) -> (result: Vec<Vec<Vec<f32>>>)\n    requires\n        x.len() > 0,\n        y.len() > 0,\n        z.len() > 0,\n        c.len() > 0,\n        forall|i: int| 0 <= i < c@.len() ==> c@[i].len() > 0,\n        forall|i: int, j: int| 0 <= i < c@.len() && 0 <= j < c@[i].len() ==> c@[i][j].len() > 0,\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result@.len() ==> result@[i].len() == y.len(),\n        forall|i: int, j: int| 0 <= i < result@.len() && 0 <= j < result@[i].len() ==> result@[i][j].len() == z.len(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0417", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_hermite_e_hermeint", "vc-description": "Integrate a Hermite_e series.\n\nIntegrate a Hermite_e series coefficients vector m times with scaling and integration constants.\n\nSpecification: hermeint integrates Hermite_e series coefficients preserving mathematical properties.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermeint(c: Vec<f64>, m: u8, k: Vec<f64>, lbnd: f64, scl: f64) -> (result: Vec<f64>)\n    requires \n        scl != 0.0,\n        k@.len() == m as int,\n    ensures\n        result@.len() == c@.len() + m as int,\n        scl != 0.0,\n        forall|step: int| 0 <= step < m as int ==> #[trigger] k@[step] == k@[step],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0418", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_hermite_e_hermeline", "vc-description": "Hermite series whose graph is a straight line.\nReturns the Hermite series coefficients representing the linear function off + scl*x.\nFor non-zero scale, returns [off, scl]. For zero scale, returns [off].", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermeline(off: f64, scl: f64) -> (coeffs: Vec<f64>)\n    ensures\n        coeffs@.len() == 2,\n        coeffs@[0] == off,\n        (scl == 0.0 ==> coeffs@[1] == 0.0),\n        (scl != 0.0 ==> coeffs@[1] == scl)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0419", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_hermite_e_hermemul", "vc-description": "Multiply one Hermite series by another. Returns the product of two Hermite polynomials \nrepresented as coefficient vectors. The multiplication involves reprojection onto \nthe Hermite polynomial basis set.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermemul(c1: Vec<i8>, c2: Vec<i8>) -> (result: Vec<i8>)\n    requires \n        c1@.len() > 0,\n        c2@.len() > 0,\n    ensures\n        result@.len() == c1@.len() + c2@.len() - 1,\n        (forall|i: int| 0 <= i < c1@.len() ==> c1@[i] as int == 0) || \n        (forall|j: int| 0 <= j < c2@.len() ==> c2@[j] as int == 0) \n        ==> (forall|k: int| 0 <= k < result@.len() ==> result@[k] as int == 0)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0420", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_hermite_e_hermemulx", "vc-description": "Multiply a Hermite series by x using the recursion relationship for Hermite polynomials.\nThe result has one more coefficient than the input, implementing the transformation\nbased on the Hermite polynomial recursion: xP_i(x) = (P_{i + 1}(x) + iP_{i - 1}(x))", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermemulx(c: Vec<f64>) -> (result: Vec<f64>)\n    requires c.len() >= 0,\n    ensures\n        result.len() == c.len() + 1,\n        result[0] == 0.0,\n        forall|i: int| 1 <= i < c.len() as int ==> result[i + 1] == c[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0421", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_hermite_e_hermepow", "vc-description": "Raise a Hermite series to a power. Computes the Hermite polynomial coefficients\nfor the series c raised to the given power, using repeated multiplication.\n\nSpecification: hermepow raises a Hermite polynomial series to a power.\nGiven coefficients c = [c₀, c₁, ..., cₙ₋₁] representing the Hermite series\nP₀(x)⋅c₀ + P₁(x)⋅c₁ + ... + Pₙ₋₁(x)⋅cₙ₋₁, this function computes the \ncoefficients of the series raised to the given power.\n\nMathematical properties:\n- Power 0: Returns [1.0] (multiplicative identity for Hermite polynomials)\n- Power 1: Returns the original coefficients unchanged (preserves the polynomial)\n- Power ≥ 2: Uses repeated multiplication following Hermite polynomial algebra\n- Result degree: The degree of the result polynomial is (n-1) * pow\n- Respects maxpower limit: pow must not exceed maxpower to prevent excessive growth\n\nThis implements the mathematical operation (P(x))^pow where P(x) is the Hermite polynomial\nrepresented by the input coefficients, and the result gives the coefficients of the\npolynomial raised to the given power in the Hermite basis.\n\n/* Base cases for polynomial exponentiation */\n\n/* General case: polynomial raised to power follows degree multiplication */\n\n/* For non-empty input, the result maintains polynomial structure */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermepow(c: Vec<f64>, pow: u8, maxpower: u8) -> (result: Vec<f64>)\n    requires \n        pow <= maxpower,\n        maxpower <= 16,\n        c.len() > 0,\n    ensures\n\n        pow == 0 ==> result.len() == 1 && result[0] == 1.0 && \n            (forall|i: int| 1 <= i < result.len() ==> result[i] == 0.0),\n        pow == 1 ==> result.len() == c.len() &&\n            (forall|i: int| 0 <= i < c.len() ==> result[i] == c[i]),\n\n        pow as int >= 1 ==> result.len() == 1 + (c.len() - 1) * pow as int,\n\n        pow as int >= 1 && c.len() > 0 ==> result.len() > 0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0422", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_hermite_e_hermeroots", "vc-description": "Compute the roots of a HermiteE series.\nGiven HermiteE series coefficients c[0], c[1], ..., c[n-1], returns the roots of\np(x) = c[0]*He_0(x) + c[1]*He_1(x) + ... + c[n-1]*He_{n-1}(x)\nwhere He_i(x) are the \"probabilists'\" or \"normalized\" Hermite polynomials\n\nSpecification: hermeroots returns the roots of the HermiteE series defined by coefficients.\nFor a HermiteE series with n coefficients, there are at most n-1 roots.\nEach root r satisfies: p(r) = 0 where p(x) = Σ c[i] * He_i(x)\n\nMathematical properties:\n1. The polynomial p(x) = Σ c[i] * He_i(x) where He_i are HermiteE basis polynomials\n2. He_i(x) are the \"probabilists'\" Hermite polynomials related to the standard normal distribution\n3. The roots are found via eigenvalues of the companion matrix\n4. For degree n polynomial, there are exactly n-1 roots (counting multiplicity)\n5. The leading coefficient must be non-zero for a well-defined polynomial", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermeroots(c: Vec<f64>) -> (result: Vec<f64>)\n    requires \n        c.len() > 0,\n        c[c.len() - 1] != 0.0,\n    ensures \n        result.len() == c.len() - 1,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0423", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_hermite_e_hermesub", "vc-description": "Subtract one Hermite series from another.\nReturns the difference of two Hermite series c1 - c2.\nThe sequences of coefficients are from lowest order term to highest.\n\nSpecification: hermesub performs component-wise subtraction of Hermite series coefficients.\nThe result has length equal to the maximum of the input lengths, with shorter arrays\nimplicitly padded with zeros. This captures the mathematical property that polynomial \nsubtraction is component-wise and preserves the polynomial structure.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermesub(c1: Vec<i8>, c2: Vec<i8>) -> (result: Vec<i8>)\n    ensures\n        result.len() == if c1.len() >= c2.len() { c1.len() } else { c2.len() },\n        forall|i: int| 0 <= i < result@.len() ==> \n            #[trigger] result@[i] == \n            (if i < c1@.len() { c1@[i] } else { 0 }) - \n            (if i < c2@.len() { c2@[i] } else { 0 })", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0425", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_hermite_e_hermeval2d", "vc-description": "Evaluate a 2-D HermiteE series at points (x, y).\n\nThis function computes the bivariate HermiteE polynomial:\np(x,y) = ∑_{i,j} c_{i,j} * He_i(x) * He_j(y)\n\nwhere He_i and He_j are the HermiteE basis polynomials.\n\nSpecification: hermeval2d evaluates a 2D HermiteE series at corresponding points.\n\nThis function implements the mathematical formula:\np(x,y) = ∑_{i,j} c_{i,j} * He_i(x) * He_j(y)\n\nKey properties:\n1. Bivariate polynomial evaluation using HermiteE basis\n2. Mathematical correctness and linearity properties\n3. Point-wise evaluation for corresponding (x,y) pairs", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn hermite_basis(n: nat, t: int) -> int\n    decreases n\n{\n    if n == 0 {\n        1\n    } else if n == 1 {\n        t\n    } else {\n        t * hermite_basis((n - 1) as nat, t) - (n - 1) as int * hermite_basis((n - 2) as nat, t)\n    }\n}\n\nspec fn matrix_sum(c: Seq<Vec<i8>>, x: int, y: int) -> int {\n    let n = c.len() as int;\n    if n == 0 {\n        0\n    } else {\n        let m = c[0].len() as int;\n        matrix_sum_helper(c, x, y, 0, n, m)\n    }\n}\n\nspec fn matrix_sum_helper(c: Seq<Vec<i8>>, x: int, y: int, i: int, n: int, m: int) -> int\n    decreases n - i\n{\n    if i >= n {\n        0\n    } else {\n        row_sum_helper(c[i], x, y, i, 0, m) + matrix_sum_helper(c, x, y, i + 1, n, m)\n    }\n}\n\nspec fn row_sum_helper(row: Vec<i8>, x: int, y: int, i: int, j: int, m: int) -> int\n    decreases m - j\n{\n    if j >= m {\n        0\n    } else {\n        (row[j] as int) * hermite_basis(i as nat, x) * hermite_basis(j as nat, y) + \n        row_sum_helper(row, x, y, i, j + 1, m)\n    }\n}\n\nfn hermeval2d(x: Vec<i8>, y: Vec<i8>, c: Vec<Vec<i8>>) -> (result: Vec<i8>)\n    requires\n        x.len() == y.len(),\n        x.len() > 0,\n        c.len() > 0,\n        forall|i: int| 0 <= i < c.len() ==> #[trigger] c[i].len() == c[0].len(),\n        c[0].len() > 0,\n    ensures\n        result.len() == x.len(),\n        forall|k: int| 0 <= k < result.len() ==> \n            result[k] as int == matrix_sum(c@, x[k] as int, y[k] as int),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0427", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_hermite_e_hermevander", "vc-description": "numpy.polynomial.hermite_e.hermevander: Pseudo-Vandermonde matrix of given degree.\n\nReturns the pseudo-Vandermonde matrix of degree `deg` and sample points\n`x`. The pseudo-Vandermonde matrix is defined by\n\n.. math:: V[..., i] = He_i(x),\n\nwhere ``0 <= i <= deg``. The leading indices of `V` index the elements of\n`x` and the last index is the degree of the HermiteE polynomial.\n\nIf `c` is a 1-D array of coefficients of length ``n + 1`` and `V` is the\narray ``V = hermevander(x, n)``, then ``np.dot(V, c)`` and\n``hermeval(x, c)`` are the same up to roundoff. This equivalence is\nuseful both for least squares fitting and for the evaluation of a large\nnumber of HermiteE series of the same degree and sample points.\n\nParameters\n----------\nx : array_like\n    Array of points. The dtype is converted to float64 or complex128\n    depending on whether any of the elements are complex. If `x` is\n    scalar it is converted to a 1-D array.\ndeg : int\n    Degree of the resulting matrix.\n\nReturns\n-------\nvander : ndarray\n    The pseudo-Vandermonde matrix. The shape of the returned matrix is\n    ``x.shape + (deg + 1,)``, where The last index is the degree of the\n    corresponding HermiteE polynomial.  The dtype will be the same as\n    the converted `x`.\n\nSpecification: hermevander returns a pseudo-Vandermonde matrix where each row\ncorresponds to a point in x, and each column corresponds to a HermiteE polynomial\nof degree 0 through deg evaluated at that point.\n\nThe HermiteE polynomials (also called probabilist's Hermite polynomials) are\ndefined by the recurrence relation:\n- He_0(x) = 1\n- He_1(x) = x  \n- He_n(x) = x * He_{n-1}(x) - (n-1) * He_{n-2}(x)\n\nPrecondition: True (no special preconditions needed)\nPostcondition: \n1. The matrix has shape (n, deg + 1)\n2. For each row i and column j, V[i][j] = He_j(x[i])\n3. First column is all ones (He_0(x) = 1)\n4. Second column equals x (He_1(x) = x) when deg > 0\n5. Subsequent columns follow the HermiteE recurrence relation", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermevander(x: Vec<f64>, deg: u8) -> (result: Vec<Vec<f64>>)\n    requires deg as nat >= 0,\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result@.len() ==> result@[i].len() == deg as nat + 1,\n        forall|i: int| 0 <= i < result@.len() ==> result@[i][0] == 1.0,\n        deg > 0 ==> forall|i: int| 0 <= i < result@.len() ==> result@[i][1] == x@[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0428", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_hermite_e_hermevander2d", "vc-description": "Pseudo-Vandermonde matrix of given degrees for 2D HermiteE polynomials.\n\nReturns the pseudo-Vandermonde matrix of degrees (x_deg, y_deg) and sample\npoints (x, y). The matrix is defined by:\nV[..., (y_deg + 1)*i + j] = He_i(x) * He_j(y)\nwhere 0 <= i <= x_deg and 0 <= j <= y_deg.\n\nThis function creates a matrix where each row corresponds to a point (x[k], y[k]) and\neach column corresponds to a basis function He_i(x) * He_j(y).\n\nMathematical properties include matrix structure, basis ordering, equivalence with\npolynomial evaluation, orthogonality properties from HermiteE basis functions,\nand polynomial fitting capability for least squares.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn hermite_basis(k: nat, t: int) -> int\n    decreases k\n{\n    if k == 0 {\n        1\n    } else if k == 1 {\n        t\n    } else {\n        t * hermite_basis((k - 1) as nat, t) - (k - 1) as int * hermite_basis((k - 2) as nat, t)\n    }\n}\n\nfn hermevander2d(x: Vec<i8>, y: Vec<i8>, x_deg: usize, y_deg: usize) -> (result: Vec<Vec<i8>>)\n    requires \n        x.len() == y.len(),\n        x.len() > 0,\n    ensures \n        result.len() == x.len(),\n        forall|point_idx: int| 0 <= point_idx < result.len() ==> \n            result[point_idx].len() == (x_deg + 1) * (y_deg + 1),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0429", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_hermite_e_hermevander3d", "vc-description": "numpy.polynomial.hermite_e.hermevander3d: Pseudo-Vandermonde matrix of given degrees.\n\nReturns the pseudo-Vandermonde matrix of degrees `deg` and sample\npoints `(x, y, z)`. If `l`, `m`, `n` are the given degrees in `x`, `y`, `z`,\nthen the pseudo-Vandermonde matrix is defined by\n\n.. math:: V[..., (m+1)(n+1)i + (n+1)j + k] = He_i(x)*He_j(y)*He_k(z),\n\nwhere `0 <= i <= l`, `0 <= j <= m`, and `0 <= k <= n`. The leading\nindices of `V` index the points `(x, y, z)` and the last index encodes\nthe degrees of the HermiteE polynomials.\n\nThe HermiteE polynomials (also called probabilist's Hermite polynomials) are\ndefined by the recurrence relation:\n- He_0(t) = 1\n- He_1(t) = t  \n- He_n(t) = t * He_{n-1}(t) - (n-1) * He_{n-2}(t)\n\nParameters\n----------\nx, y, z : Vector Float n\n    Arrays of point coordinates, all of the same shape.\ndeg : Vector Nat 3\n    Vector of maximum degrees of the form [x_deg, y_deg, z_deg].\n\nReturns\n-------\nvander3d : Vector (Vector Float order) n\n    The pseudo-Vandermonde matrix where order = (deg[0]+1)*(deg[1]+1)*(deg[2]+1).\n\nSpecification: hermevander3d returns a 3D pseudo-Vandermonde matrix where each row\ncorresponds to a point (x[i], y[i], z[i]), and each column corresponds to a product\nof HermiteE polynomials He_i(x)*He_j(y)*He_k(z) for various degrees.\n\n// Just return 1.0 as a placeholder to avoid floating point ops", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn hermite_poly(k: int, t: f64) -> f64\n    decreases k\n{\n    if k <= 0 {\n        1.0\n    } else if k == 1 {\n        t\n    } else {\n\n        1.0\n    }\n}\n\nfn hermevander3d(x: Vec<f64>, y: Vec<f64>, z: Vec<f64>, deg: Vec<u8>) -> (result: Vec<Vec<f64>>)\n    requires \n        x.len() == y.len(),\n        y.len() == z.len(),\n        deg.len() == 3,\n        deg[0] as int >= 0 && deg[1] as int >= 0 && deg[2] as int >= 0,\n    ensures\n        result.len() == x.len(),\n        forall |p: int| 0 <= p < result.len() ==> {\n            let x_deg = deg[0] as int;\n            let y_deg = deg[1] as int; \n            let z_deg = deg[2] as int;\n            let order = (x_deg + 1) * (y_deg + 1) * (z_deg + 1);\n            &&& #[trigger] result[p].len() == order\n            &&& (order > 0 ==> result[p][0] == 1.0)\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0430", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_hermite_e_hermeweight", "vc-description": "numpy.polynomial.hermite_e.hermeweight: Weight function of the Hermite_e polynomials.\n\nThe weight function is exp(-x²/2) and the interval of integration is [-∞, ∞].\nThe HermiteE polynomials are orthogonal, but not normalized, with respect to this weight function.\n\nFor each input value x, computes the weight function w(x) = exp(-x²/2).\nThis is a fundamental weight function used in probabilistic HermiteE polynomial theory.\n\nReturns an array of the same shape as x, containing the weight function values.\n\nSpecification: hermeweight returns a vector where each element is the HermiteE weight function\napplied to the corresponding element in x.\n\nThe weight function is mathematically defined as w(x) = exp(-x²/2).\n\nPrecondition: True (no special preconditions - weight function is defined for all real numbers)\nPostcondition: For all indices i, result[i] = exp(-x[i]²/2)\n\nMathematical properties:\n- Weight function is always positive: w(x) > 0 for all x\n- Weight function is symmetric: w(x) = w(-x)\n- Weight function achieves maximum at x = 0: w(0) = 1\n- Weight function approaches 0 as |x| → ∞", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermeweight(x: Vec<i8>) -> (result: Vec<i8>)\n    ensures\n        result.len() == x.len(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0431", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_hermite_e_poly2herme", "vc-description": "Convert a polynomial to a Hermite series. \nConverts coefficients from standard polynomial basis to Hermite series basis.\nUses Horner's method with Hermite operations: for polynomial p(x) = aₙxⁿ + ... + a₁x + a₀,\nbuilds the equivalent Hermite series by iteratively applying hermeadd(hermemulx(result), coefficient).\n\nSpecification: poly2herme converts polynomial coefficients to equivalent Hermite series coefficients.\n\nThe conversion preserves the polynomial's mathematical value but represents it in the Hermite basis.\nThis is a fundamental basis transformation in polynomial algebra.\n\nKey mathematical properties:\n1. Basis transformation: standard polynomial basis {1, x, x², x³, ...} → Hermite basis {He₀, He₁, He₂, He₃, ...}\n2. Value preservation: ∑ᵢ polᵢ·xⁱ = ∑ᵢ resultᵢ·Heᵢ(x) for all x\n3. Degree preservation: polynomial of degree n maps to Hermite series of degree n\n4. Invertibility: conversion can be reversed with herme2poly\n5. Horner's method: algorithm uses iterative structure for numerical stability\n\nThe algorithm implements: result = hermeadd(hermemulx(previous_result), current_coefficient)\napplied from highest to lowest degree coefficients.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn poly2herme(pol: Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() == pol.len(),\n        forall|i: int| 0 <= i < pol@.len() && pol[i as int] != 0.0f32 ==> exists|j: int| 0 <= j < result@.len() && result[j as int] != 0.0f32,\n        (exists|i: int| 0 <= i < pol@.len() && pol[i as int] != 0.0f32) ==> (exists|j: int| 0 <= j < result@.len() && result[j as int] != 0.0f32),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0432", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_hermite_herm2poly", "vc-description": "Convert a Hermite series to a polynomial.\nConverts coefficients of a Hermite series (ordered from lowest to highest degree)\nto coefficients of the equivalent standard polynomial (ordered from lowest to highest degree).\n\nThe Hermite polynomials H_n(x) satisfy the recurrence relation:\nH_{n+1}(x) = 2x * H_n(x) - 2n * H_{n-1}(x)\nwith H_0(x) = 1 and H_1(x) = 2x\n\nThis function performs the inverse transformation, converting from Hermite basis to standard basis.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn herm2poly(c: Vec<i8>) -> (result: Vec<i8>)\n    requires c.len() > 0,\n    ensures\n        result.len() == c.len(),\n        /* Sanity checks */\n        c.len() == 1 ==> result@ == c@,\n        c.len() == 2 ==> result[0] == c[0] && result[1] as int == 2 * c[1] as int,\n        /* Example from documentation: herm2poly([1, 2.75, 0.5, 0.375]) approximated with integers */\n        (c.len() == 4 && c[0] as int == 1 && c[1] as int == 3 && c[2] as int == 1 && c[3] as int == 0) ==>\n            (result[0] as int == 0 && result[1] as int == 1 && result[2] as int == 2 && result[3] as int == 3)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0433", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_hermite_hermadd", "vc-description": "numpy.polynomial.hermite.hermadd: Add one Hermite series to another.\n\nReturns the sum of two Hermite series c1 + c2. The arguments are\nsequences of coefficients ordered from lowest order term to highest,\ni.e., [1,2,3] represents the series P_0 + 2*P_1 + 3*P_2.\n\nUnlike multiplication, division, etc., the sum of two Hermite series\nis a Hermite series (without having to \"reproject\" the result onto\nthe basis set) so addition, just like that of \"standard\" polynomials,\nis simply \"component-wise.\"\n\nThis version handles adding two Hermite coefficient vectors where the\nresult length is the maximum of the input lengths. Shorter vectors are\nimplicitly padded with zeros.\n\nSpecification: hermadd performs component-wise addition of Hermite series coefficients.\n\nPrecondition: True (no special preconditions for basic addition)\nPostcondition: \n- If i < min(n,m), result[i] = c1[i] + c2[i]\n- If min(n,m) ≤ i < n, result[i] = c1[i] (c2 is treated as 0)\n- If min(n,m) ≤ i < m, result[i] = c2[i] (c1 is treated as 0)\n\nThe mathematical property: The i-th coefficient of the sum is the sum of\nthe i-th coefficients of the input series, treating missing coefficients as 0.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermadd(c1: Vec<i8>, c2: Vec<i8>) -> (result: Vec<i8>)\n    ensures\n        result@.len() == if c1@.len() >= c2@.len() { c1@.len() } else { c2@.len() },\n        forall|i: int| 0 <= i < result@.len() ==>\n            result@[i] as int == (\n                if i < c1@.len() && i < c2@.len() {\n                    c1@[i] as int + c2@[i] as int\n                } else if i < c1@.len() {\n                    c1@[i] as int\n                } else if i < c2@.len() {\n                    c2@[i] as int\n                } else {\n                    0\n                }\n            ),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0434", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_hermite_hermcompanion", "vc-description": "Return the scaled companion matrix of Hermite polynomial coefficients.\nThe companion matrix is symmetric when c represents a Hermite basis polynomial.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermcompanion(c: Vec<i8>) -> (result: Vec<Vec<i8>>)\n    requires \n        c@.len() >= 2,\n        c[c@.len() - 1] as int != 0,\n    ensures\n        result@.len() == c@.len() - 1,\n        forall|i: int| 0 <= i < result@.len() ==> result@[i].len() == c@.len() - 1,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0435", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_hermite_hermder", "vc-description": "Differentiate a Hermite series.\nReturns the Hermite series coefficients differentiated `m` times.\nAt each iteration the result is multiplied by `scl` (scaling factor).\nThe coefficients are from low to high degree.\n\nSpecification: hermder differentiates Hermite series coefficients according to\nthe Hermite polynomial derivative rule: d/dx H_n(x) = 2n * H_{n-1}(x).\nThe result has degree reduced by m (or becomes zero if m >= n).\nEach differentiation multiplies by the scaling factor scl.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermder(c: Vec<i8>, m: usize, scl: i8) -> (result: Vec<i8>)\n    ensures\n        result.len() == if m >= c.len() { 0 } else { c.len() - m },\n        m >= c.len() ==> result.len() == 0,\n        m < c.len() ==> result.len() == c.len() - m,\n        (m == 1 && c.len() > 0) ==> (\n            forall|i: int| 0 <= i < result.len() ==> \n                result[i] as int == (scl as int) * (2 * ((i + 1) as int)) * (c[i + 1] as int)\n        ),\n        (m == 2 && c.len() > 1) ==> (\n            forall|i: int| 0 <= i < result.len() ==>\n                result[i] as int == (scl as int) * (scl as int) * (2 * ((i + 2) as int)) * (2 * ((i + 1) as int)) * (c[i + 2] as int)\n        ),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0436", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_hermite_hermdiv", "vc-description": "Divide one Hermite series by another.\n\nReturns the quotient-with-remainder of two Hermite series\nc1 / c2. The arguments are sequences of coefficients from lowest\norder term to highest, e.g., [1,2,3] represents the series\nP_0 + 2*P_1 + 3*P_2.\n\nParameters:\n- c1: 1-D array of Hermite series coefficients (dividend)\n- c2: 1-D array of Hermite series coefficients (divisor)\n\nReturns:\n- (quo, rem): Pair of arrays representing quotient and remainder\n\nSpecification: hermdiv divides Hermite series c1 by c2, producing quotient and remainder\nsuch that c1 = c2 * quo + rem in the Hermite polynomial basis, where the degree of rem\nis less than the degree of c2. The divisor must have at least one non-zero coefficient.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermdiv(c1: Vec<f32>, c2: Vec<f32>) -> (result: (Vec<f32>, Vec<f32>))\n    requires \n        c2.len() > 0,\n        exists|i: int| 0 <= i < c2.len() && #[trigger] c2[i] != 0.0f32,\n    ensures \n        /* The remainder has all coefficients zero or its effective degree is less than c2's */\n        result.1.len() <= c1.len()", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0437", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_hermite_hermfit", "vc-description": "Least squares fit of Hermite series to data. Returns coefficients of a Hermite polynomial that best fits the given data points (x, y) with degree deg.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermfit(x: Vec<f64>, y: Vec<f64>, deg: usize) -> (result: Vec<f64>)\n    requires \n        x@.len() > 0,\n        x@.len() == y@.len(),\n        deg < x@.len(),\n    ensures\n        result@.len() == deg + 1,\n        deg + 1 > 0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "VT0438", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_hermite_hermfromroots", "vc-description": "Generate a Hermite series with given roots.\n\nReturns the coefficients of the polynomial p(x) = (x - r₀) * (x - r₁) * ... * (x - rₙ)\nin Hermite form. If a zero has multiplicity n, it must appear n times in the roots vector.\n\nThe resulting polynomial is expressed as: p(x) = c₀ + c₁ * H₁(x) + ... + cₙ * Hₙ(x)\nwhere Hᵢ(x) are Hermite polynomials.\n\nSpecification: hermfromroots generates Hermite coefficients such that:\n1. The result has length n+1 where n is the number of roots\n2. The polynomial has exactly the given roots (when evaluated using Hermite polynomials)\n3. The leading coefficient is non-zero (for non-empty roots)\n4. For repeated roots, the multiplicity is preserved", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermfromroots(roots: Vec<f32>) -> (coef: Vec<f32>)\n    ensures\n        coef@.len() == roots@.len() + 1,\n        roots@.len() > 0 ==> coef@[roots@.len() as int] != 0.0f32", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0439", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_hermite_hermgauss", "vc-description": "Computes the sample points and weights for Gauss-Hermite quadrature.\n\nGauss-Hermite quadrature.\n\n    Computes the sample points and weights for Gauss-Hermite quadrature.\n    These sample points and weights will correctly integrate polynomials of\n    degree 2*deg - 1 or less over the interval [-∞, ∞]\n    with the weight function f(x) = exp(-x²).\n\n    Parameters\n    ----------\n    deg : int\n        Number of sample points and weights. It must be >= 1.\n\n    Returns\n    -------\n    x : ndarray\n        1-D ndarray containing the sample points.\n    y : ndarray\n        1-D ndarray containing the weights.\n\n    Notes\n    -----\n    The results have only been tested up to degree 100, higher degrees may\n    be problematic. The weights are determined by using the fact that\n\n    w_k = c / (H'_n(x_k) * H_{n-1}(x_k))\n\n    where c is a constant independent of k and x_k\n    is the k'th root of H_n, and then scaling the results to get\n    the right value when integrating 1.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermgauss(deg: usize) -> (result: (Vec<f64>, Vec<f64>))\n    requires deg > 0,\n    ensures\n        result.0.len() == deg,\n        result.1.len() == deg,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0442", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_hermite_hermint", "vc-description": "Integrate a Hermite series.\n\nReturns the Hermite series coefficients integrated `m` times from `lbnd`.\nAt each iteration the resulting series is multiplied by `scl` and an\nintegration constant from `k` is added.\n\nSpecification: hermint integrates Hermite series coefficients.\n\nThe specification captures:\n1. The output vector has size n + m (m additional coefficients from integration)\n2. Each integration adds one coefficient to the series\n3. The integration follows Hermite polynomial integration rules\n4. Integration constants from k are applied at each integration step\n5. Results are scaled by scl at each step\n\nFor Hermite polynomials, the integration rule is:\n- ∫ H_n(x) dx = H_{n+1}(x)/(2(n+1)) + constant\n\nMathematical properties:\n- The first coefficient of the result incorporates the integration constant to ensure\n  the integral evaluates to the appropriate value at lbnd\n- For coefficient c[i] representing H_i, integration contributes c[i]/(2*(i+1)) to H_{i+1}\n- The scaling factor scl is applied after each integration step", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermint(c: Vec<f32>, m: u8, k: Vec<f32>, lbnd: f32, scl: f32) -> (result: Vec<f32>)\n    requires \n        m > 0,\n        k.len() == m as nat,\n        c.len() > 0,\n    ensures \n        result.len() == c.len() + m as nat,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0443", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_hermite_hermline", "vc-description": "Hermite series whose graph is a straight line.\n\nCreates a Hermite series representation for the line off + scl*x.\nReturns a 2-element vector where:\n- First element is the constant term (off)\n- Second element is the linear coefficient (scl/2)\n\nNote: When scl = 0, the second element is 0, representing a constant function.\n\nSpecification: hermline returns Hermite coefficients for a linear function.\n\nThe Hermite series representation of off + scl*x has coefficients:\n- c₀ = off (constant term)\n- c₁ = scl/2 (linear term coefficient)\n\nThese coefficients, when evaluated as a Hermite series, produce the \noriginal linear function. The relationship comes from the fact that\nH₁(x) = 2x in the physicist's Hermite polynomials.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn half_f32(x: f32) -> f32;", "vc-helpers": "", "vc-spec": "fn hermline(off: f32, scl: f32) -> (result: Vec<f32>)\n    ensures\n        result.len() == 2,\n        result[0] == off,\n        result[1] == half_f32(scl)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0444", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_hermite_hermmul", "vc-description": "numpy.polynomial.hermite.hermmul: Multiply one Hermite series by another.\n\nReturns the product of two Hermite series c1 * c2. The arguments\nare sequences of coefficients, from lowest order term to highest,\ne.g., [1,2,3] represents the series P_0 + 2*P_1 + 3*P_2 where P_i\nis the i-th Hermite polynomial.\n\nThe product of two Hermite series requires reprojection onto the\nHermite basis, which uses the recurrence relation for Hermite\npolynomials.\n\nFor non-empty inputs of length m and n, the result has length m + n - 1.\nFor empty inputs, returns a single zero coefficient.\n\nSpecification: hermmul returns the coefficients of the product of two\nHermite series.\n\nThe key mathematical properties:\n1. Empty input handling: If either input is empty, returns [0]\n2. Degree property: For non-empty inputs of degree m-1 and n-1,\n   the product has degree (m-1) + (n-1) = m + n - 2, requiring m + n - 1 coefficients\n3. Multiplication by constant: When one series has only one coefficient (constant polynomial),\n   the result is element-wise scaling\n4. Commutativity: hermmul c1 c2 = hermmul c2 c1 (up to floating point precision)\n5. The general multiplication follows Hermite polynomial recurrence relations\n\nPrecondition: True (works for all valid inputs)\nPostcondition: Captures empty input behavior, constant multiplication, and size properties\n\n/* Empty input handling */\n\n/* Non-empty inputs have correct output size */\n\n/* Multiplication by constant polynomial (degree 0) */\n\n/* Zero polynomial property */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermmul(c1: Vec<i8>, c2: Vec<i8>) -> (result: Vec<i8>)\n    ensures\n\n        (c1.len() == 0 || c2.len() == 0) ==> (result.len() == 1 && result[0] == 0),\n\n        (c1.len() > 0 && c2.len() > 0) ==> result.len() == c1.len() + c2.len() - 1,\n\n        (c2.len() == 1 && c1.len() > 0) ==>\n            forall|i: int| 0 <= i < c1.len() ==> result[i] as int == c1[i] as int * c2[0] as int,\n        (c1.len() == 1 && c2.len() > 0) ==>\n            forall|i: int| 0 <= i < c2.len() ==> result[i] as int == c2[i] as int * c1[0] as int,\n\n        ((forall|i: int| 0 <= i < c1.len() ==> c1[i] == 0) || \n         (forall|j: int| 0 <= j < c2.len() ==> c2[j] == 0)) ==>\n            forall|k: int| 0 <= k < result.len() ==> result[k] == 0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0445", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_hermite_hermmulx", "vc-description": "Multiply a Hermite series by x using the recursion relationship xP_i(x) = (P_{i+1}(x)/2 + i*P_{i-1}(x)).\n\nThe algorithm implements the recursion for Hermite polynomials. Given input coefficients c[0], c[1], ..., c[n-1], the output has n+1 coefficients where:\n- The first coefficient is always 0\n- Each c[i] contributes c[i]/2 to position i+1 and c[i]*i to position i-1\n\nFor example, with input [1, 2, 3]:\n- result[0] = 0 + 2*1 = 2\n- result[1] = 1/2 + 3*2 = 0.5 + 6 = 6.5\n- result[2] = 2/2 = 1\n- result[3] = 3/2 = 1.5\nGiving [2, 6.5, 1, 1.5]", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermmulx(c: Vec<i8>) -> (result: Vec<i8>)\n    ensures\n        result.len() == c.len() + 1,\n        forall|k: int| 0 <= k < result.len() ==> #[trigger] result[k] as int == {\n            let base_contribution: int = if k == 0 { 0 } else { 0 };\n            let forward_contribution: int = if k > 0 && k - 1 < c.len() { \n                c[k - 1] as int / 2\n            } else { \n                0\n            };\n            let backward_contribution: int = if k + 1 < c.len() { \n                c[k + 1] as int * (k + 1)\n            } else { \n                0\n            };\n            base_contribution + forward_contribution + backward_contribution\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0446", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_hermite_hermpow", "vc-description": "Raise a Hermite polynomial series to a power.\nGiven coefficients `c` representing a Hermite series (ordered from low to high degree),\nreturns the coefficients of the series raised to the power `pow`.\nThe `maxpower` parameter limits the maximum degree of the result.\n\nSpecification: hermpow raises a Hermite series to a power by repeated multiplication.\nKey properties:\n1. For pow = 0, the result is the constant polynomial [1]\n2. For pow = 1, the result equals the input polynomial\n3. For pow > 1, the result is obtained by repeated Hermite multiplication\n4. The result degree is bounded by min(n + (n-1)*pow - 1, maxpower)\n5. The operation respects the algebraic properties of polynomial exponentiation\n\n/* Sanity check: result has bounded size */\n\n/* Property 1: Power of 0 gives constant polynomial [1] */\n\n/* Property 2: Power of 1 preserves the polynomial (up to size constraints) */\n\n/* Property 3: The result represents c^pow in the Hermite polynomial basis */\n\n/* For non-zero inputs with pow > 0, result is non-trivial */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermpow(c: Vec<f64>, pow: usize, maxpower: usize) -> (result: Vec<f64>)\n    requires \n        c.len() > 0,\n    ensures\n\n        result.len() <= maxpower + 1,\n        result.len() == if c.len() + (c.len() - 1) * pow <= maxpower + 1 {\n            c.len() + (c.len() - 1) * pow\n        } else {\n            maxpower + 1\n        },\n\n        pow == 0 ==> result.len() == 1 && result[0] == 1.0,\n\n        (pow == 1 && c.len() <= maxpower + 1) ==> (\n            result.len() == c.len() &&\n            forall|i: int| 0 <= i < c.len() ==> result[i] == c[i]\n        ),\n\n        ((exists|i: int| 0 <= i < c.len() && c[i] != 0.0) && pow > 0) ==> \n            exists|j: int| 0 <= j < result.len() && result[j] != 0.0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0447", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_hermite_hermroots", "vc-description": "Compute the roots of a Hermite series.\n\nReturns the roots (zeros) of the polynomial p(x) = Σᵢ c[i] * Hᵢ(x),\nwhere Hᵢ(x) are Hermite polynomials.\n\nThe roots are obtained as eigenvalues of the companion matrix.\n\nSpecification: hermroots computes the roots of a Hermite polynomial.\n\nKey properties:\n1. Returns n-1 roots for n coefficients (degree n-1 polynomial)\n2. The roots are sorted in ascending order\n3. Each root is a zero of the Hermite polynomial\n4. For the linear case (n=2), provides exact formula\n\nPrecondition: n > 0 to ensure valid polynomial", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermroots(c: Vec<f32>) -> (roots: Vec<f32>)\n    requires c.len() > 0,\n    ensures\n        /* Basic size property */\n        roots.len() == c.len() - 1,\n        /* For n = 1 (constant polynomial), no roots */\n        c.len() == 1 ==> roots.len() == 0,\n        /* For n = 2 (linear polynomial c₀ + c₁·H₁(x) where H₁(x) = 2x) */\n        c.len() == 2 ==> (\n            roots.len() == 1\n            /* In practice: roots[0] = -0.5 * c[0] / c[1] when c[1] ≠ 0 */\n        ),\n        /* Roots are sorted for n > 2 - abstract property */\n        c.len() > 2 ==> true,\n        /* Mathematical property: roots are zeros of the Hermite polynomial */\n        /* Each r in roots satisfies: Σᵢ c[i] * Hᵢ(r) ≈ 0 */\n        /* Numerical accuracy: the companion matrix method is stable */\n        true", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0448", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_hermite_hermsub", "vc-description": "Subtract one Hermite series from another.\n\nReturns the difference of two Hermite series c1 - c2. The sequences of coefficients \nare from lowest order term to highest. The subtraction is component-wise, with \nmissing coefficients treated as zero.\n\nSpecification: hermsub performs component-wise subtraction of Hermite series coefficients,\ntreating missing coefficients as zero. The result has the length of the longer input.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermsub(c1: Vec<i8>, c2: Vec<i8>) -> (result: Vec<i8>)\n    ensures\n        result.len() == if c1.len() >= c2.len() { c1.len() } else { c2.len() },\n        forall|i: int| 0 <= i < c1.len() && 0 <= i < c2.len() ==> \n            result@[i] == c1@[i] - c2@[i],\n        c1.len() > c2.len() ==> forall|i: int| \n            c2.len() <= i < c1.len() ==> result@[i] == c1@[i],\n        c2.len() > c1.len() ==> forall|i: int| \n            c1.len() <= i < c2.len() ==> result@[i] == -c2@[i],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0450", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_hermite_hermval2d", "vc-description": "Evaluate a 2-D Hermite series at points (x, y).\n\nGiven a 2D coefficient matrix c where c[i,j] is the coefficient for H_i(x) * H_j(y),\nevaluates the sum: ∑_{i,j} c_{i,j} * H_i(x) * H_j(y)\nwhere H_i and H_j are Hermite polynomials.\n\nThe x and y vectors must have the same length, and the function evaluates\nthe 2D polynomial at each pair of corresponding points (x[k], y[k]).\n\n/* Empty coefficient cases evaluate to zero */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermval2d(x: Vec<f32>, y: Vec<f32>, c: Vec<Vec<f32>>) -> (result: Vec<f32>)\n    requires \n        x.len() == y.len(),\n    ensures \n        result.len() == x.len(),\n\n        c.len() == 0 ==> forall|k: int| 0 <= k < result.len() ==> result[k] == 0.0f32,\n        c.len() > 0 && c@[0].len() == 0 ==> forall|k: int| 0 <= k < result.len() ==> result[k] == 0.0f32,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0453", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_hermite_hermvander2d", "vc-description": "Pseudo-Vandermonde matrix of given degrees for 2D Hermite polynomials.\n\nReturns a matrix where each row corresponds to a sample point (x[i], y[i]),\nand columns represent products of Hermite polynomials H_i(x) * H_j(y).\nThe column at index (ydeg + 1)*i + j contains H_i(x) * H_j(y).\n\nThis creates the design matrix for fitting 2D Hermite polynomial surfaces,\nwhere coefficients are arranged in row-major order: c_00, c_01, ..., c_10, c_11, ...\n\nSpecification: hermvander2d creates a 2D Vandermonde matrix where each element\nV[k][(ydeg + 1)*i + j] equals H_i(x[k]) * H_j(y[k]), where H_i denotes the \ni-th Hermite polynomial. The Hermite polynomials follow the recurrence:\nH_0(t) = 1, H_1(t) = 2t, H_n(t) = 2t * H_{n-1}(t) - 2(n-1) * H_{n-2}(t)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn hermite_polynomial(n: nat, t: int) -> int\n    decreases n\n{\n    if n == 0 {\n        1\n    } else if n == 1 {\n        2 * t\n    } else {\n        2 * t * hermite_polynomial((n - 1) as nat, t) - 2 * (n - 1) * hermite_polynomial((n - 2) as nat, t)\n    }\n}\n\nfn hermvander2d(x: Vec<i8>, y: Vec<i8>, xdeg: usize, ydeg: usize) -> (result: Vec<Vec<i8>>)\n    requires x.len() == y.len(),\n    ensures \n        result.len() == x.len(),\n        forall|k: int| 0 <= k < result.len() ==> #[trigger] result@[k].len() == (xdeg + 1) * (ydeg + 1),\n        forall|k: int| 0 <= k < result.len() ==> #[trigger] result@[k]@[0] as int == 1", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0455", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_hermite_hermweight", "vc-description": "Weight function of the Hermite polynomials.\nComputes exp(-x²) for each element in the input vector.\n\nThe weight function is exp(-x^2) and the interval of\nintegration is [-inf, inf]. The Hermite polynomials are\northogonal, but not normalized, with respect to this weight function.\n\nParameters\n----------\nx : array_like\n   Values at which the weight function will be computed.\n\nReturns\n-------\nw : ndarray\n   The weight function at x.\n\n/* Each output element equals exp(-x²) of the corresponding input */\n\n/* All output values are positive (since exp is always positive) */\n\n/* The weight function achieves its maximum value of 1 at x=0 */\n\n/* The function decreases as |x| increases */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn hermweight(x: Vec<f32>) -> (w: Vec<f32>)\n    requires x.len() > 0,\n    ensures\n        w.len() == x.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0456", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_hermite_poly2herm", "vc-description": "numpy.polynomial.hermite.poly2herm: Convert a polynomial to a Hermite series.\n\nConvert an array representing the coefficients of a polynomial (relative\nto the \"standard\" basis) ordered from lowest degree to highest, to an\narray of the coefficients of the equivalent Hermite series, ordered\nfrom lowest to highest degree.\n\nThe conversion transforms between different polynomial bases. The standard\npolynomial basis consists of monomials {1, x, x², x³, ...} while the\nHermite polynomial basis consists of Hermite polynomials {H₀(x), H₁(x), H₂(x), ...}.\n\nThe algorithm uses Hermite polynomial operations (multiplication by x and addition)\nto build up the result iteratively from the highest degree coefficient down.\n\nSpecification: poly2herm converts polynomial coefficients to Hermite series coefficients\n\nThe specification ensures:\n1. The output has the same dimension as the input\n2. The conversion preserves the polynomial function when evaluated using respective bases\n3. For the zero polynomial (all coefficients zero), the result is also zero\n4. The conversion is linear: poly2herm(a*p + b*q) = a*poly2herm(p) + b*poly2herm(q)\n\nAdditionally, for specific test cases:\n- Converting [0, 1, 2, 3] should yield [1, 2.75, 0.5, 0.375]\n- Converting a constant polynomial [c] should yield [c]\n\n/* Zero polynomial maps to zero */\n\n/* Constant polynomial preservation (when n >= 1) */\n\n/* Specific example from documentation (when applicable) */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn poly2herm(pol: Vec<f64>) -> (result: Vec<f64>)\n    ensures\n        result.len() == pol.len(),\n\n        (forall|i: int| 0 <= i < pol@.len() ==> pol@[i] == 0.0) ==> \n            (forall|i: int| 0 <= i < result@.len() ==> result@[i] == 0.0),\n\n        pol.len() > 0 ==> \n            (forall|i: int| 1 <= i < pol@.len() ==> pol@[i] == 0.0) ==>\n                result@[0] == pol@[0],\n\n        (pol.len() == 4 && pol@[0] == 0.0 && pol@[1] == 1.0 && \n         pol@[2] == 2.0 && pol@[3] == 3.0) ==>\n            (result@[0] == 1.0 && result@[1] == 2.75 && \n             result@[2] == 0.5 && result@[3] == 0.375)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0457", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_laguerre_Laguerre", "vc-description": "A Laguerre series class.\n\nThe Laguerre class provides the standard Python numerical methods\n'+', '-', '*', '//', '%', 'divmod', '**', and '()' as well as the\nattributes and methods listed below.\n\nParameters\n----------\ncoef : array_like\n    Laguerre coefficients in order of increasing degree, i.e,\n    ``(1, 2, 3)`` gives ``1*L_0(x) + 2*L_1(X) + 3*L_2(x)``.\ndomain : (2,) array_like, optional\n    Domain to use. The interval ``[domain[0], domain[1]]`` is mapped\n    to the interval ``[window[0], window[1]]`` by shifting and scaling.\n    The default value is [0., 1.].\nwindow : (2,) array_like, optional\n    Window, see `domain` for its use. The default value is [0., 1.].\nsymbol : str, optional\n    Symbol used to represent the independent variable in string\n    representations of the polynomial expression, e.g. for printing.\n    The symbol must be a valid Python identifier. Default value is 'x'.\n\nConstructor for Laguerre series with default domain and window\n\nSpecification for Laguerre series construction and properties", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* Helper function to evaluate a Laguerre polynomial at a given point */\nspec fn evaluate_laguerre_polynomial(coef: Seq<f32>, x: f32) -> f32 \n    decreases coef.len()\n{\n    if coef.len() == 0 {\n        0.0\n    } else {\n        coef[0]\n    }\n}\n\n/* Domain mapping function for polynomial transformations */\nspec fn map_domain(domain: [f32; 2], window: [f32; 2], x: f32) -> f32 {\n    x\n}\n\n/* Helper function for individual Laguerre polynomial basis functions */\nspec fn laguerre_polynomial_basis(n: nat, x: f32) -> f32 {\n    1.0\n}\n\n/* A Laguerre series class representing a polynomial in the Laguerre basis.\n   This structure encapsulates Laguerre coefficients with domain and window information. */\nstruct Laguerre {\n    /* Laguerre coefficients in order of increasing degree */\n    coef: Vec<f32>,\n    /* Domain interval [domain[0], domain[1]] for mapping */\n    domain: [f32; 2],\n    /* Window interval [window[0], window[1]] for mapping */\n    window: [f32; 2],\n}", "vc-helpers": "", "vc-spec": "fn make_laguerre(coefficients: Vec<f32>) -> (result: Laguerre)\n    ensures\n        result.coef@ == coefficients@,\n        result.domain[0] == 0.0f32 && result.domain[1] == 1.0f32,\n        result.window[0] == 0.0f32 && result.window[1] == 1.0f32,\n        forall|i: int| 0 <= i < coefficients@.len() ==> result.coef@[i] == coefficients@[i]", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0458", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_laguerre_lag2poly", "vc-description": "Convert a Laguerre series to a polynomial.\nConvert an array representing the coefficients of a Laguerre series,\nordered from lowest degree to highest, to an array of the coefficients\nof the equivalent polynomial (relative to the \"standard\" basis).\n\nSpecification: lag2poly converts Laguerre series coefficients to standard polynomial coefficients.\nThe converted polynomial evaluates to the same values as the original Laguerre series.\n\n/* Helper function to evaluate a Laguerre polynomial at a given point */\n\n/* Helper function to evaluate a standard polynomial at a given point */\n\n/* The converted polynomial evaluates to the same values as the Laguerre series */\n\n/* Single coefficient case: lag2poly([a]) = [a] */\n\n/* The conversion preserves the polynomial degree */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn evaluate_laguerre_polynomial(c: Seq<f32>, x: f32) -> f32;\n\nspec fn evaluate_polynomial(coeffs: Seq<f32>, x: f32) -> f32;", "vc-helpers": "", "vc-spec": "fn lag2poly(c: Vec<f32>) -> (result: Vec<f32>)\n    requires c.len() > 0,\n    ensures\n        result.len() == c.len(),\n\n        forall|x: f32| evaluate_polynomial(result@, x) == evaluate_laguerre_polynomial(c@, x),\n\n        c.len() == 1 ==> result@ == c@,\n\n        c.len() > 0 ==> evaluate_polynomial(result@, 0.0) == evaluate_laguerre_polynomial(c@, 0.0),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0459", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_laguerre_lagadd", "vc-description": "Add one Laguerre series to another.\nReturns the sum of two Laguerre series c1 + c2. The arguments\nare sequences of coefficients ordered from lowest order term to highest.\n\nSpecification: lagadd performs component-wise addition of two Laguerre series coefficients.\nThe result length is the maximum of the input lengths, with shorter arrays padded with zeros.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn evaluate_laguerre_polynomial(coeffs: Seq<f32>, x: f32) -> f32\n{\n    arbitrary()\n}\n\nspec fn f32_add(a: f32, b: f32) -> f32\n{\n    arbitrary()\n}\n\nspec fn max_usize(a: usize, b: usize) -> usize\n{\n    if a >= b { a } else { b }\n}\n\nfn lagadd(c1: Vec<f32>, c2: Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() == max_usize(c1.len(), c2.len()),\n        forall|i: int| 0 <= i < result.len() ==> {\n            #[trigger] result[i] == f32_add(\n                if i < c1.len() { c1[i] } else { 0.0f32 },\n                if i < c2.len() { c2[i] } else { 0.0f32 }\n            )\n        },\n        (c1.len() > 0 || c2.len() > 0) ==> result.len() > 0", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0460", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_laguerre_lagcompanion", "vc-description": "Returns the companion matrix of Laguerre polynomial coefficients. The companion matrix is a square matrix of size (deg, deg) where deg = c.size - 1. For coefficients [c₀, c₁, ..., cₙ], the companion matrix has specific structure for Laguerre polynomials with diagonal elements 2*i + 1 and off-diagonal elements. Specification: lagcompanion returns the companion matrix of Laguerre polynomial coefficients. The companion matrix is symmetric for Laguerre polynomials and has dimension (deg, deg) where deg = c.size - 1. The matrix structure follows the Laguerre polynomial recurrence relation.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn lagcompanion(c: Vec<i8>) -> (result: Vec<Vec<i8>>)\n    requires \n        c.len() >= 2,\n    ensures \n        result@.len() == c@.len() - 1,\n        forall|i: int| 0 <= i < result@.len() ==> result@[i].len() == c@.len() - 1,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0461", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_laguerre_lagder", "vc-description": "Differentiates a Laguerre series m times with optional scaling.\nReturns the coefficients of the differentiated Laguerre series.\n\nThis function implements the NumPy polynomial.laguerre.lagder functionality,\nwhich differentiates a Laguerre series and follows Laguerre polynomial \nrecurrence relations. Each differentiation is scaled by scl.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn lagder(c: Vec<f32>, m: u8, scl: f32) -> (result: Vec<f32>)\n    requires c.len() > 0,\n    ensures\n        result.len() == c.len(),\n        m as nat == 0 ==> (forall|i: int| 0 <= i < c@.len() ==> result@[i] == c@[i]),\n        (m as nat >= c@.len() && c@.len() > 0) ==> (forall|i: int| 0 <= i < result@.len() ==> result@[i] == 0.0f32),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0462", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_laguerre_lagdiv", "vc-description": "Divides one Laguerre series by another, returning quotient and remainder.\nThe division is performed in the Laguerre polynomial basis.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn lagdiv(c1: Vec<f64>, c2: Vec<f64>) -> (result: (Vec<f64>, Vec<f64>))\n    requires \n        c1@.len() > 0,\n        c2@.len() > 0,\n        exists|i: int| 0 <= i < c2@.len() && c2[i] != 0.0,\n    ensures\n        result.0@.len() == c1@.len(),\n        result.1@.len() == c2@.len(),\n        c2@.len() > 0 ==> exists|highest_nonzero: int| \n            0 <= highest_nonzero < c2@.len() &&\n            (forall|j: int| highest_nonzero < j < result.1@.len() ==> result.1[j] == 0.0) &&\n            c2[highest_nonzero] != 0.0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0466", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_laguerre_laggrid2d", "vc-description": "numpy.polynomial.laguerre.laggrid2d: Evaluate a 2-D Laguerre series on the Cartesian product of x and y.\n\nThis function computes the values p(a,b) = ∑_{i,j} c_{i,j} * L_i(a) * L_j(b)\nwhere the points (a,b) consist of all pairs formed by taking a from x and b from y.\nThe resulting points form a grid with x in the first dimension and y in the second.\n\nThe coefficients c represent a 2D matrix where c[i,j] is the coefficient for\nthe term of multi-degree i,j in the Laguerre series expansion.\n\nSpecification: laggrid2d evaluates a 2D Laguerre series on the Cartesian product of x and y.\n\nThe function computes p(a,b) = ∑_{i,j} c_{i,j} * L_i(a) * L_j(b) for each point (a,b)\nin the Cartesian product of x and y.\n\nPrecondition: The coefficient matrix c must be non-empty (rows > 0 and cols > 0)\nPostcondition: The result is a grid where result[i][j] represents the evaluation\nof the Laguerre series at point (x[i], y[j]).\n\nMathematical properties:\n1. The result has shape (nx, ny) - same as the Cartesian product of x and y\n2. Each element result[i][j] is the sum over all coefficient terms c[k][l] * L_k(x[i]) * L_l(y[j])\n3. For constant coefficients (c[0][0] only), the result should be constant\n4. The function is linear in the coefficients", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn laggrid2d(x: Vec<f64>, y: Vec<f64>, c: Vec<Vec<f64>>) -> (result: Vec<Vec<f64>>)\n    requires\n        c@.len() > 0,\n        c@.len() > 0 ==> c@[0].len() > 0,\n        forall|i: int| 0 <= i < c@.len() ==> #[trigger] c@[i].len() == c@[0].len(),\n    ensures\n        result@.len() == x@.len(),\n        forall|i: int| 0 <= i < result@.len() ==> #[trigger] result@[i].len() == y@.len(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0467", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_laguerre_laggrid3d", "vc-description": "numpy.polynomial.laguerre.laggrid3d: Evaluate a 3-D Laguerre series on the Cartesian product of x, y, and z.\n\nThis function computes the values p(a,b,c) = ∑_{i,j,k} c_{i,j,k} * L_i(a) * L_j(b) * L_k(c)\nwhere the points (a,b,c) consist of all triples formed by taking a from x, b from y, and c from z.\nThe resulting points form a grid with x in the first dimension, y in the second, and z in the third.\n\nThe coefficients c represent a 3D tensor where c[i,j,k] is the coefficient for\nthe term of multi-degree i,j,k in the Laguerre series expansion.\n\nSpecification: laggrid3d evaluates a 3D Laguerre series on the Cartesian product of x, y, and z.\n\nThe function computes p(a,b,c) = ∑_{i,j,k} c_{i,j,k} * L_i(a) * L_j(b) * L_k(c) for each point (a,b,c)\nin the Cartesian product of x, y, and z.\n\nPrecondition: The coefficient tensor c must be non-empty (dim1 > 0, dim2 > 0, and dim3 > 0)\nPostcondition: The result is a 3D grid where result[i][j][k] represents the evaluation\nof the Laguerre series at point (x[i], y[j], z[k]).\n\nMathematical properties:\n1. The result has shape (nx, ny, nz) - same as the Cartesian product of x, y, and z\n2. Each element result[i][j][k] is the sum over all coefficient terms c[l][m][n] * L_l(x[i]) * L_m(y[j]) * L_n(z[k])\n3. For constant coefficients (c[0][0][0] only), the result should be constant\n4. The function is linear in the coefficients", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn laggrid3d(x: Vec<f64>, y: Vec<f64>, z: Vec<f64>, c: Vec<Vec<Vec<f64>>>) -> (result: Vec<Vec<Vec<f64>>>)\n    requires \n        c.len() > 0,\n        forall|i: int| 0 <= i < c.len() ==> c@[i].len() > 0,\n        forall|i: int, j: int| 0 <= i < c.len() && 0 <= j < c@[i].len() ==> c@[i]@[j].len() > 0,\n    ensures \n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> result@[i].len() == y.len(),\n        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result@[i].len() ==> result@[i]@[j].len() == z.len(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0468", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_laguerre_lagint", "vc-description": "numpy.polynomial.laguerre.lagint: Integrate a Laguerre series.\n\nReturns the Laguerre series coefficients c integrated m times from\nlbnd. At each iteration the resulting series is multiplied by scl \nand an integration constant k is added. The scaling factor is for use \nin a linear change of variable.\n\nThe argument c is a vector of coefficients from low to high degree,\ne.g., [1,2,3] represents the series L_0 + 2*L_1 + 3*L_2.\n\nSpecification: lagint integrates a Laguerre series.\n\nReturns the Laguerre series coefficients c integrated m times from lbnd.\nAt each iteration the resulting series is multiplied by scl and an\nintegration constant is added.\n\nPrecondition: Integration order m must be non-negative\nPostcondition: The result represents the integrated Laguerre series\nwith increased degree due to integration.\n\nMathematical properties:\n1. The result has degree n + m - 1 (m integrations increase degree by m)\n2. Integration is linear: lagint(α*c1 + β*c2) = α*lagint(c1) + β*lagint(c2) \n3. For zero coefficients, integration with constants gives the constant\n4. Multiple integrations accumulate degree increases", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn lagint(c: Vec<f64>, m: u8, k: Vec<f64>, lbnd: f64, scl: f64) -> (result: Vec<f64>)\n    requires \n        k.len() == m as usize,\n        scl != 0.0,\n    ensures \n        result.len() == c.len() + m as usize", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0469", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_laguerre_lagline", "vc-description": "Laguerre series whose graph is a straight line off + scl*x. Specification: lagline returns the Laguerre series representation of off + scl*x.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn lagline(off: f32, scl: f32) -> (result: Vec<f32>)\n    ensures result.len() == 2", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0470", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_laguerre_lagmul", "vc-description": "Multiply one Laguerre series by another.\n\nThis function multiplies two Laguerre series represented as coefficient arrays.\nReturns the product of two Laguerre series c1 * c2. The arguments are sequences \nof coefficients, from lowest order \"term\" to highest, e.g., [1,2,3] represents \nthe series P_0 + 2*P_1 + 3*P_2.\n\nParameters:\n- c1, c2: 1-D arrays of Laguerre series coefficients ordered from low to high.\n\nReturns:\n- out: Array of Laguerre series coefficients representing their product.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn lagmul(c1: Vec<f64>, c2: Vec<f64>) -> (result: Vec<f64>)\n    requires c1@.len() > 0 && c2@.len() > 0,\n    ensures \n        result@.len() == c1@.len() + c2@.len() - 1,\n        forall|i: int| 0 <= i < result@.len() ==> \n            (result@[i] != 0.0 ==> \n                exists|j: int, k: int| \n                    0 <= j < c1@.len() && \n                    0 <= k < c2@.len() && \n                    j + k == i && \n                    c1@[j] != 0.0 && \n                    c2@[k] != 0.0)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0471", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_laguerre_lagmulx", "vc-description": "Multiply a Laguerre series by x.\n\nMultiply the Laguerre series c by x, where x is the independent variable.\n\nThe multiplication uses the recursion relationship for Laguerre polynomials in the form:\nxP_i(x) = (-(i + 1)*P_{i + 1}(x) + (2i + 1)P_{i}(x) - iP_{i - 1}(x))", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn lagmulx(c: Vec<i8>) -> (result: Vec<i8>)\n    requires c@.len() > 0,\n    ensures \n        result@.len() == c@.len() + 1,\n        result@[0] as int == c@[0] as int,\n        result@.len() >= 2 ==> result@[1] as int == -(c@[0] as int)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0472", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_laguerre_lagpow", "vc-description": "Raise a Laguerre series to a power.\n\nReturns the Laguerre series `c` raised to the power `pow`. The\nargument `c` is a sequence of coefficients ordered from low to high.\ni.e., [1,2,3] is the series  ``P_0 + 2*P_1 + 3*P_2.``\n\nSpecification: lagpow raises a Laguerre series to a power with proper constraints", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn lagpow(c: Vec<f32>, pow: u8, maxpower: u8) -> (result: Vec<f32>)\n    requires \n        pow > 0,\n        pow <= maxpower,\n        maxpower <= 16,\n        c.len() > 0,\n    ensures \n        result.len() == c.len(),\n        pow == 1 ==> (forall|i: int| 0 <= i < result.len() ==> result[i] == c[i]),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0473", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_laguerre_lagroots", "vc-description": "Compute the roots of a Laguerre series.\n\nReturn the roots (a.k.a. \"zeros\") of the polynomial\np(x) = sum_i c[i] * L_i(x).\n\nSpecification: lagroots computes the roots of a Laguerre polynomial", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn lagroots(c: Vec<i8>) -> (roots: Vec<i8>)\n    requires\n        c.len() >= 2,\n        c@[c.len() - 1 as int] != 0,\n    ensures\n        c.len() == 2 ==> roots.len() == 1,\n        c.len() == 2 ==> roots@[0] as int == 1 + c@[0] as int / c@[1] as int,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0474", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_laguerre_lagsub", "vc-description": "Subtract one Laguerre series from another.\n\nReturns the difference of two Laguerre series `c1` - `c2`.  The\nsequences of coefficients are from lowest order term to highest, i.e.,\n[1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.\n\nSpecification: lagsub subtracts two Laguerre series component-wise", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn lagsub(c1: Vec<i8>, c2: Vec<i8>) -> (result: Vec<i8>)\n    requires c1.len() == c2.len(),\n    ensures \n        result.len() == c1.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] as int == c1[i] as int - c2[i] as int,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0475", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_laguerre_lagval", "vc-description": "Evaluate a Laguerre series at points x using Clenshaw recursion.\nThe mathematical formula for the Laguerre series is:\np(x) = c_0 * L_0(x) + c_1 * L_1(x) + ... + c_n * L_n(x)\nwhere L_i(x) are the Laguerre polynomials.\n\nSpecification for Laguerre series evaluation:\nThe result has the same shape as the input x vector.\nFor a single coefficient, the result is constant.\nFor multiple coefficients, the function evaluates the Laguerre series\nusing Clenshaw recursion, which is numerically stable.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn lagval(x: Vec<f64>, c: Vec<f64>) -> (result: Vec<f64>)\n    requires \n        c@.len() > 0,\n        x@.len() > 0,\n    ensures\n        result@.len() == x@.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0476", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_laguerre_lagval2d", "vc-description": "Evaluate a 2-D Laguerre series at points (x, y).\nThe mathematical formula is: p(x,y) = sum_{i,j} c_{i,j} * L_i(x) * L_j(y)\nwhere L_i(x) and L_j(y) are the Laguerre polynomials.\n\nSpecification for 2-D Laguerre series evaluation:\nThe result has the same shape as the input x and y vectors.\nThe function evaluates a bivariate Laguerre polynomial series\nusing the tensor product of 1-D Laguerre polynomials.\n\n/* Base case: single coefficient returns constant */\n\n/* General case: evaluates 2D Laguerre series */\n\n/* Sanity check: result preserves input shape */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn lagval2d(x: Vec<f32>, y: Vec<f32>, c: Vec<Vec<f32>>) -> (result: Vec<f32>)\n    requires \n        x@.len() == y@.len(),\n        x@.len() > 0,\n        c@.len() > 0,\n        forall|i: int| 0 <= i < c@.len() ==> c@[i].len() > 0,\n    ensures\n        result@.len() == x@.len(),\n\n        (c@.len() == 1 && c@[0].len() == 1) ==> \n            forall|i: int| 0 <= i < result@.len() ==> result@[i] == c@[0][0],\n\n        result@.len() == x@.len() && result@.len() == y@.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0477", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_laguerre_lagval3d", "vc-description": "Evaluate a 3-D Laguerre series at points (x, y, z).\nThe mathematical formula is: p(x,y,z) = sum_{i,j,k} c_{i,j,k} * L_i(x) * L_j(y) * L_k(z)\nwhere L_i(x), L_j(y) and L_k(z) are the Laguerre polynomials.\n\nSpecification for 3-D Laguerre series evaluation:\nThe result has the same shape as the input x, y, and z vectors.\nThe function evaluates a trivariate Laguerre polynomial series\nusing the tensor product of 1-D Laguerre polynomials.\n\n/* Base case: single coefficient returns constant */\n\n/* General case: evaluates 3D Laguerre series */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn lagval3d(x: Vec<f32>, y: Vec<f32>, z: Vec<f32>, c: Vec<Vec<Vec<f32>>>) -> (result: Vec<f32>)\n    requires \n        x.len() == y.len(),\n        y.len() == z.len(),\n        x.len() > 0,\n        c.len() > 0,\n        c[0].len() > 0,\n        c[0][0].len() > 0,\n    ensures\n        result.len() == x.len(),\n        result.len() == y.len(), \n        result.len() == z.len(),\n\n        (c.len() == 1 && c[0].len() == 1 && c[0][0].len() == 1) ==> \n            forall|i: int| 0 <= i < result.len() ==> result[i] == c[0][0][0],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0481", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_laguerre_lagweight", "vc-description": "numpy.polynomial.laguerre.lagweight: Weight function of the Laguerre polynomials.\n\nThe weight function is exp(-x) and the interval of integration\nis [0, ∞]. The Laguerre polynomials are orthogonal, but not\nnormalized, with respect to this weight function.\n\nParameters:\n- x: Values at which the weight function will be computed.\n\nReturns:\n- w: The weight function at x (exp(-x) for each element).\n\nSpecification: lagweight returns a vector where each element is exp(-x[i])\nfor the corresponding element in x.\n\nThe mathematical property is that the weight function exp(-x) is used\nfor Laguerre polynomial orthogonality on the interval [0, ∞].\n\nPrecondition: True (no special preconditions for weight function)\nPostcondition: For all indices i, result[i] = exp(-x[i])", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn lagweight(x: Vec<f32>) -> (result: Vec<f32>)\n    ensures result.len() == x.len(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0482", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_laguerre_poly2lag", "vc-description": "numpy.polynomial.laguerre.poly2lag: Convert a polynomial to a Laguerre series.\n\nConvert an array representing the coefficients of a polynomial (relative\nto the \"standard\" basis) ordered from lowest degree to highest, to an\narray of the coefficients of the equivalent Laguerre series, ordered\nfrom lowest to highest degree.\n\nParameters:\n- pol: 1-D array containing the polynomial coefficients\n\nReturns:\n- c: 1-D array containing the coefficients of the equivalent Laguerre series.\n\nNote: The conversion maintains the same degree structure but transforms\nthe basis from standard polynomial to Laguerre polynomial basis.\n\nSpecification: poly2lag converts polynomial coefficients to Laguerre series coefficients.\n\nThe mathematical property is that the conversion preserves the polynomial\nbut expresses it in terms of Laguerre polynomials instead of standard monomials.\n\nKey properties:\n1. Same degree: Both input and output have the same number of coefficients\n2. Basis transformation: Standard polynomial → Laguerre polynomial basis\n3. Orthogonality preservation: The resulting Laguerre series represents the\n   same polynomial but in a basis that is orthogonal with respect to exp(-x)\n\nPrecondition: True (no special preconditions for basis conversion)\nPostcondition: The result represents the same polynomial as input but in\n               Laguerre basis, and has the same length as input\n\n/* The coefficients form a valid Laguerre series representation\n           of the same polynomial as the input standard polynomial.\n           Mathematical property: polynomial evaluation equivalence\n           Standard polynomial: Σ(i=0 to n-1) pol[i] * x^i\n           Laguerre polynomial: Σ(i=0 to n-1) result[i] * L_i(x)\n           where L_i(x) is the i-th Laguerre polynomial */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn poly2lag(pol: Vec<i8>) -> (result: Vec<i8>)\n    ensures\n        result.len() == pol.len(),\n\n        true,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0483", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_legendre_Legendre", "vc-description": "A Legendre series class.\n\n    The Legendre class provides the standard Python numerical methods\n    '+', '-', '*', '//', '%', 'divmod', '**', and '()' as well as the\n    attributes and methods listed below.\n\n    Parameters\n    ----------\n    coef : array_like\n        Legendre coefficients in order of increasing degree, i.e.,\n        ``(1, 2, 3)`` gives ``1*P_0(x) + 2*P_1(x) + 3*P_2(x)``.\n    domain : (2,) array_like, optional\n        Domain to use. The interval ``[domain[0], domain[1]]`` is mapped\n        to the interval ``[window[0], window[1]]`` by shifting and scaling.\n        The default value is [-1., 1.].\n    window : (2,) array_like, optional\n        Window, see `domain` for its use. The default value is [-1., 1.].\n    symbol : str, optional\n        Symbol used to represent the independent variable in string\n        representations of the polynomial expression, e.g. for printing.\n        The symbol must be a valid Python identifier. Default value is 'x'.\n\nCreate a Legendre series from coefficients\n\nSpecification: mkLegendre creates a valid Legendre series representation\n\n/* A Legendre series representation with coefficients, domain, and window */\n\n/* Legendre coefficients in order of increasing degree */\n\n/* Domain interval for polynomial evaluation */\n\n/* Window interval for domain mapping */\n\n/* Symbol name for variable representation */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "struct Legendre {\n\n    coef: Vec<f64>,\n\n    domain: [f64; 2],\n\n    window: [f64; 2],\n\n    symbol: String,\n}\n\nfn mk_legendre(\n    coef: Vec<f64>,\n    domain: [f64; 2],\n    window: [f64; 2],\n    symbol: String\n) -> (result: Legendre)\n    ensures\n        result.coef@ == coef@,\n        result.domain == domain,\n        result.window == window,\n        result.symbol == symbol,\n        domain[0] == -1.0 && domain[1] == 1.0 ==> result.domain[0] == -1.0 && result.domain[1] == 1.0,\n        window[0] == -1.0 && window[1] == 1.0 ==> result.window[0] == -1.0 && result.window[1] == 1.0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0484", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_legendre_leg2poly", "vc-description": "Convert a Legendre series to a polynomial.\n\nConvert a Legendre series to a polynomial.\n\n    Convert an array representing the coefficients of a Legendre series,\n    ordered from lowest degree to highest, to an array of the coefficients\n    of the equivalent polynomial (relative to the \"standard\" basis) ordered\n    from lowest to highest degree.\n\n    Parameters\n    ----------\n    c : array_like\n        1-D array containing the Legendre series coefficients, ordered\n        from lowest order term to highest.\n\n    Returns\n    -------\n    pol : ndarray\n        1-D array containing the coefficients of the equivalent polynomial\n        (relative to the \"standard\" basis) ordered from lowest order term\n        to highest.\n\n    See Also\n    --------\n    poly2leg\n\n    Notes\n    -----\n    The easy way to do conversions between polynomial basis sets\n    is to use the convert method of a class instance.\n\n    Examples\n    --------\n    >>> from numpy import polynomial as P\n    >>> c = P.Legendre(range(4))\n    >>> c\n    Legendre([0., 1., 2., 3.], domain=[-1.,  1.], window=[-1.,  1.], symbol='x')\n    >>> p = c.convert(kind=P.Polynomial)\n    >>> p\n    Polynomial([-1. , -3.5,  3. ,  7.5], domain=[-1.,  1.], window=[-1., ...\n    >>> P.legendre.leg2poly(range(4))\n    array([-1. , -3.5,  3. ,  7.5])\n\nConvert a Legendre series to a polynomial (monomial basis)\n\nSpecification: leg2poly converts Legendre series coefficients to polynomial coefficients\n\n/* For small cases (n < 3), the conversion is identity */\n\n/* The conversion transforms Legendre basis to monomial basis */\n\n/* The mathematical property is that ∑ cᵢ Pᵢ(x) = ∑ result[i] xⁱ */\n\n/* where Pᵢ are the Legendre polynomials */\n\n/* The transformation is well-defined and preserves polynomial degree */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn leg2poly(c: Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() == c.len(),\n\n        (c.len() as int) < 3 ==> forall|i: int| 0 <= i < (c.len() as int) ==> result[i] == c[i],\n\n        (c.len() as int) > 0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0485", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_legendre_legadd", "vc-description": "Add one Legendre series to another by component-wise addition of coefficients.\n\nAdd one Legendre series to another.\n\nReturns the sum of two Legendre series `c1` + `c2`.  The arguments\nare sequences of coefficients ordered from lowest order term to\nhighest, i.e., [1,2,3] represents the series ``P_0 + 2*P_1 + 3*P_2``.\n\nParameters\n----------\nc1, c2 : array_like\n    1-D arrays of Legendre series coefficients ordered from low to\n    high.\n\nReturns\n-------\nout : ndarray\n    Array representing the Legendre series of their sum.\n\nSee Also\n--------\nlegsub, legmulx, legmul, legdiv, legpow\n\nNotes\n-----\nUnlike multiplication, division, etc., the sum of two Legendre series\nis a Legendre series (without having to \"reproject\" the result onto\nthe basis set) so addition, just like that of \"standard\" polynomials,\nis simply \"component-wise.\"\n\nExamples\n--------\n>>> from numpy.polynomial import legendre as L\n>>> c1 = (1,2,3)\n>>> c2 = (3,2,1)\n>>> L.legadd(c1,c2)\narray([4.,  4.,  4.])", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn legadd(c1: Vec<i8>, c2: Vec<i8>) -> (result: Vec<i8>)\n    ensures\n        result@.len() == if c1@.len() >= c2@.len() { c1@.len() } else { c2@.len() },\n        forall|i: int| 0 <= i < result@.len() ==> {\n            let val1: int = if i < c1@.len() { c1@[i] as int } else { 0 };\n            let val2: int = if i < c2@.len() { c2@[i] as int } else { 0 };\n            #[trigger] result@[i] as int == val1 + val2\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0486", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_legendre_legcompanion", "vc-description": "Return the scaled companion matrix of Legendre series coefficients.\nThe companion matrix is symmetric when c is a Legendre basis polynomial,\nproviding better eigenvalue estimates.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn legcompanion(c: Vec<i8>) -> (result: Vec<Vec<i8>>)\n    requires \n        c@.len() >= 2,\n        c[c@.len() - 1] as int != 0,\n    ensures \n        result@.len() == c@.len() - 1,\n        forall|i: int| 0 <= i < result@.len() ==> result@[i]@.len() == c@.len() - 1,\n        forall|i: int, j: int| 0 <= i < result@.len() && 0 <= j < result@.len() ==> \n            result@[i]@[j] == result@[j]@[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0487", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_legendre_legder", "vc-description": "Differentiate a Legendre series.\nReturns the Legendre series coefficients c differentiated m times.\nEach differentiation is multiplied by scl (scaling factor).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn legder(c: Vec<f64>, m: u8, scl: f64) -> (result: Vec<f64>)\n    requires c.len() >= 1,\n    ensures\n        result.len() == if c.len() > m as usize { c.len() - m as usize } else { 1 },\n        m == 0 ==> (result.len() == c.len() && forall|i: int| 0 <= i < c.len() ==> result[i] == c[i]),\n        m as usize >= c.len() ==> result.len() == 1,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0488", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_legendre_legdiv", "vc-description": "Divide one Legendre series by another.\nReturns the quotient and remainder of two Legendre series c1 / c2.\nThe arguments are sequences of coefficients from lowest order to highest.\nSpecification: legdiv computes polynomial division in Legendre basis", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn legdiv(c1: Vec<f32>, c2: Vec<f32>) -> (result: (Vec<f32>, Vec<f32>))\n    requires \n        c1@.len() >= 1,\n        c2@.len() >= 1,\n        exists|i: int| 0 <= i < c2@.len() && c2@[i] != 0.0f32,\n    ensures \n        result.0@.len() == (if c1@.len() >= c2@.len() { c1@.len() - c2@.len() + 1 } else { 1 }) &&\n        result.1@.len() == (if c2@.len() > 1 { c2@.len() - 1 } else { 1 }) &&\n        (c1@.len() < c2@.len() ==> result.0@.len() == 1 && result.0@[0] == 0.0f32) &&\n        result.1@.len() <= c2@.len()", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0492", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_legendre_leggrid2d", "vc-description": "Evaluate a 2-D Legendre series on the Cartesian product of x and y.\nThis function computes p(a,b) = ∑_{i,j} c_{i,j} * L_i(a) * L_j(b)\nfor all pairs (a,b) from the Cartesian product of x and y.\n\nSpecification: leggrid2d correctly evaluates a 2-D Legendre series\non the Cartesian product of input points.\n\nThe function computes the tensor product evaluation of Legendre polynomials\naccording to the mathematical formula p(a,b) = ∑_{i,j} c_{i,j} * L_i(a) * L_j(b).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn leggrid2d(x: Vec<f32>, y: Vec<f32>, c: Vec<Vec<f32>>) -> (result: Vec<Vec<f32>>)\n    requires \n        x@.len() > 0,\n        y@.len() > 0,\n        c@.len() > 0,\n        forall|i: int| 0 <= i < c@.len() ==> c@[i].len() > 0,\n    ensures\n        /* The result has the correct shape: nx × ny grid */\n        result@.len() == x@.len(),\n        forall|i: int| 0 <= i < result@.len() ==> result@[i].len() == y@.len(),\n        /* Grid structure preserves dimensionality */\n        x@.len() > 0 && y@.len() > 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0493", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_legendre_leggrid3d", "vc-description": "Evaluate a 3-D Legendre series on the Cartesian product of x, y, and z.\nThis function computes p(a,b,c) = ∑_{i,j,k} c_{i,j,k} * L_i(a) * L_j(b) * L_k(c)\nfor all triples (a,b,c) from the Cartesian product of x, y, and z.\n\nSpecification: leggrid3d correctly evaluates a 3-D Legendre series\non the Cartesian product of input points.\n\nThe function computes the tensor product evaluation of Legendre polynomials\naccording to the mathematical formula p(a,b,c) = ∑_{i,j,k} c_{i,j,k} * L_i(a) * L_j(b) * L_k(c).\n\n/* The result has the correct shape: nx × ny × nz grid */\n\n/* Each grid point (i,j,k) contains the evaluation of the 3D Legendre series */\n\n/* Grid structure preserves dimensionality */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn leggrid3d(x: Vec<f64>, y: Vec<f64>, z: Vec<f64>, c: Vec<Vec<Vec<f64>>>) -> (result: Vec<Vec<Vec<f64>>>)\n    requires \n        x@.len() > 0,\n        y@.len() > 0,\n        z@.len() > 0,\n        c@.len() > 0,\n        forall|i: int| 0 <= i < c@.len() ==> c@[i].len() > 0,\n        forall|i: int, j: int| 0 <= i < c@.len() && 0 <= j < c@[i].len() ==> c@[i][j].len() > 0,\n    ensures\n\n        result@.len() == x@.len(),\n        forall|i: int| 0 <= i < result@.len() ==> result@[i].len() == y@.len(),\n        forall|i: int, j: int| 0 <= i < result@.len() && 0 <= j < result@[i].len() ==> result@[i][j].len() == z@.len(),\n\n        forall|i1: int, i2: int, j1: int, j2: int, k1: int, k2: int|\n            0 <= i1 < x@.len() && 0 <= i2 < x@.len() && \n            0 <= j1 < y@.len() && 0 <= j2 < y@.len() &&\n            0 <= k1 < z@.len() && 0 <= k2 < z@.len() ==>\n            ((i1 != i2 || j1 != j2 || k1 != k2) ==> \n             (result@[i1][j1][k1] != result@[i2][j2][k2] || \n              (x@[i1] == x@[i2] && y@[j1] == y@[j2] && z@[k1] == z@[k2])))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0494", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_legendre_legint", "vc-description": "Integrate a Legendre series, returning the coefficients of the integrated series.\nThe function integrates the Legendre series with coefficients c one time,\napplying scaling factor scl and integration constant k.\n\nSpecification: legint correctly integrates Legendre series coefficients\naccording to the mathematical properties of Legendre polynomial integration.\n\nIntegration increases the degree of the polynomial by 1, and the resulting \ncoefficients satisfy the Legendre integration recurrence relations.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn legint(c: Vec<f64>, k: f64, lbnd: f64, scl: f64) -> (result: Vec<f64>)\n    requires scl != 0.0,\n    ensures result@.len() == c@.len() + 1", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0495", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_legendre_legline", "vc-description": "Creates a Legendre series representation of a straight line `off + scl*x`. This function generates the correct Legendre series coefficients for a linear function.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn legline(off: f32, scl: f32) -> (result: Vec<f32>)\n    ensures\n        result@.len() == 2,\n        result@[0] == off,\n        result@[1] == scl", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0496", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_legendre_legmul", "vc-description": "Multiply one Legendre series by another, producing coefficients in Legendre basis", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn legmul(c1: Vec<i8>, c2: Vec<i8>) -> (result: Vec<i8>)\n    requires \n        c1.len() > 0,\n        c2.len() > 0,\n    ensures\n        result.len() == c1.len() + c2.len() - 1,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0497", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_legendre_legmulx", "vc-description": "Multiply a Legendre series by x using the Legendre recurrence relation.\n\nSpecification: legmulx multiplies a Legendre series by x using the correct recurrence relation.\n\nThis function multiplies the Legendre series c by x, where x is the independent variable.\nThe multiplication uses the recursion relationship for Legendre polynomials in the form:\nxP_i(x) = ((i + 1)*P_{i + 1}(x) + i*P_{i - 1}(x))/(2i + 1)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn legmulx(c: Vec<f32>) -> (result: Vec<f32>)\n    requires c@.len() > 0,\n    ensures\n        result@.len() == c@.len() + 1,\n        result[0] == 0.0f32,\n        result[1] == c[0],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0504", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_legendre_legvander", "vc-description": "Pseudo-Vandermonde matrix of given degree based on Legendre polynomials.\nReturns the pseudo-Vandermonde matrix of degree `deg` and sample points `x`.\nThe pseudo-Vandermonde matrix is defined by V[..., i] = L_i(x) where 0 <= i <= deg.\nL_i represents the i-th Legendre polynomial.\n\nSpecification: legvander constructs a pseudo-Vandermonde matrix where each row \ncorresponds to a point and each column corresponds to a Legendre polynomial evaluation.\nThe matrix satisfies basic properties of Legendre polynomials:\n- L_0(x) = 1 (first column is all ones)\n- L_1(x) = x (second column equals input values when deg > 0)\n- The matrix has the correct dimensions", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn legvander(x: Vec<f32>, deg: usize) -> (result: Vec<Vec<f32>>)\n    requires x@.len() > 0,\n    ensures\n        result@.len() == x@.len(),\n        forall|i: int| 0 <= i < result@.len() ==> result@[i].len() == deg + 1,\n        forall|i: int| 0 <= i < result@.len() ==> result@[i][0] == 1.0f32,\n        deg > 0 ==> forall|i: int| 0 <= i < result@.len() ==> result@[i][1] == x@[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0505", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_legendre_legvander2d", "vc-description": "Pseudo-Vandermonde matrix of given degrees for 2D Legendre polynomials.\nReturns the pseudo-Vandermonde matrix of degrees `deg` and sample points `(x, y)`.\nThe pseudo-Vandermonde matrix is defined by V[..., (deg[1] + 1)*i + j] = L_i(x) * L_j(y),\nwhere 0 <= i <= deg[0] and 0 <= j <= deg[1].\n\nSpecification: legvander2d constructs a 2D pseudo-Vandermonde matrix where each row \ncorresponds to a point (x_i, y_i) and each column corresponds to a product of \nLegendre polynomials L_i(x) * L_j(y).\nThe matrix satisfies basic properties:\n- Each entry is a product of 1D Legendre polynomial evaluations\n- The ordering follows the specified indexing scheme\n- The matrix has the correct dimensions", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn legvander2d(x: Vec<f64>, y: Vec<f64>, deg_x: u8, deg_y: u8) -> (result: Vec<Vec<f64>>)\n    requires x.len() == y.len(),\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == (deg_x as int + 1) * (deg_y as int + 1),\n        forall|i: int| 0 <= i < result.len() && result[i].len() > 0 ==> result[i][0] == 1.0", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0506", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_legendre_legvander3d", "vc-description": "Pseudo-Vandermonde matrix of given degrees for 3D Legendre polynomials.\nReturns the pseudo-Vandermonde matrix of degrees `deg` and sample points `(x, y, z)`.\nThe pseudo-Vandermonde matrix is defined by \nV[..., (m+1)(n+1)i + (n+1)j + k] = L_i(x)*L_j(y)*L_k(z),\nwhere 0 <= i <= l, 0 <= j <= m, and 0 <= k <= n for degrees [l, m, n].\n\nSpecification: legvander3d constructs a 3D pseudo-Vandermonde matrix where each row \ncorresponds to a point (x_i, y_i, z_i) and each column corresponds to a product of \nLegendre polynomials L_i(x) * L_j(y) * L_k(z).\nThe matrix satisfies basic properties:\n- Each entry is a product of 1D Legendre polynomial evaluations\n- The ordering follows the specified 3D indexing scheme\n- The matrix has the correct dimensions", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn legvander3d(x: &Vec<f32>, y: &Vec<f32>, z: &Vec<f32>, deg_x: usize, deg_y: usize, deg_z: usize) -> (result: Vec<Vec<f32>>)\n    requires \n        x.len() == y.len(),\n        y.len() == z.len(),\n        x.len() > 0,\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == (deg_x + 1) * (deg_y + 1) * (deg_z + 1),\n        forall|i: int| 0 <= i < result.len() ==> result[i][0] == 1.0f32,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0507", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_legendre_legweight", "vc-description": "Weight function of the Legendre polynomials. \nThe weight function is constant 1 for all input values.\n\nSpecification: legweight returns a vector of all ones with the same length as input.\nThis captures the mathematical property that the Legendre weight function is constant 1.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn legweight(x: Vec<f32>) -> (result: Vec<f32>)\n    ensures \n        result@.len() == x@.len(),\n        forall|i: int| 0 <= i < result@.len() ==> result@[i] == 1.0f32", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0508", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_legendre_poly2leg", "vc-description": "Convert a polynomial to a Legendre series.\nConverts coefficients from standard polynomial basis to Legendre basis.\n\nSpecification: poly2leg converts polynomial coefficients to Legendre series coefficients.\nThe transformation preserves the polynomial degree and produces valid Legendre coefficients.\nThe result has the same dimension as the input and represents the same polynomial\nexpressed in the Legendre basis instead of the standard monomial basis.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn poly2leg(pol: Vec<f32>) -> (result: Vec<f32>)\n    ensures \n        result.len() == pol.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0510", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_polynomial_Polynomial", "vc-description": "A power series class representing a polynomial with coefficients in order of increasing degree.\n\nThe Polynomial structure encapsulates coefficients from lowest to highest degree,\nwhere coefficients[i] represents the coefficient of x^i. For example,\ncoefficients [1, 2, 3] represents the polynomial 1 + 2*x + 3*x^2.\n\nThe domain and window parameters support polynomial transformations by mapping\nthe interval [domain[0], domain[1]] to [window[0], window[1]] through scaling\nand shifting.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn polynomial(coef: Vec<f64>, domain: Vec<f64>, window: Vec<f64>) -> (result: Vec<f64>)\n    requires \n        domain.len() == 2,\n        window.len() == 2,\n        domain[0] != domain[1],\n        window[0] != window[1],\n    ensures \n        result.len() == coef.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == coef[i],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0511", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_polynomial_polyadd", "vc-description": "Add one polynomial to another.\n\nGiven two polynomials represented as coefficient vectors (from lowest to highest degree),\nreturns their sum. The result has length equal to the maximum of the input lengths,\nwith shorter polynomials implicitly padded with zeros.\n\nSpecification: polyadd computes c1 + c2 element-wise, padding with zeros.\nThe result has length max(n, m), and for each coefficient position i:\n- If i < min(n, m): result[i] = c1[i] + c2[i]\n- If min(n, m) ≤ i < n: result[i] = c1[i]\n- If min(n, m) ≤ i < m: result[i] = c2[i]\n\nAdditionally, polyadd satisfies mathematical properties:\n- Commutativity: polyadd c1 c2 = polyadd c2 c1\n- Zero identity: polyadd c 0 = c and polyadd 0 c = c\n- Associativity: polyadd (polyadd c1 c2) c3 = polyadd c1 (polyadd c2 c3)\n- Leading coefficient preservation: if c1 and c2 have different degrees,\n  the result preserves the leading coefficient of the higher-degree polynomial", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn polyadd(c1: Vec<i8>, c2: Vec<i8>) -> (result: Vec<i8>)\n    ensures\n        result.len() == if c1.len() >= c2.len() { c1.len() } else { c2.len() },\n        forall|i: int| 0 <= i < result.len() ==> {\n            if i < c1.len() && i < c2.len() {\n                result[i] as int == c1[i] as int + c2[i] as int\n            } else if i < c1.len() && i >= c2.len() {\n                result[i] as int == c1[i] as int\n            } else if i >= c1.len() && i < c2.len() {\n                result[i] as int == c2[i] as int\n            } else {\n                result[i] as int == 0\n            }\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0512", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_polynomial_polycompanion", "vc-description": "Return the companion matrix of a polynomial.\n\nThe companion matrix C for a polynomial p(x) = c[0] + c[1]*x + ... + c[n]*x^n\nis an (n×n) matrix where the characteristic polynomial is p(x).\n\nFor a polynomial of degree n, the companion matrix has the form:\n- First (n-1) rows: [0, 0, ..., 0, 1, 0, ..., 0] (identity shifted)\n- Last row: [-c[0]/c[n], -c[1]/c[n], ..., -c[n-1]/c[n]]\n\nThe companion matrix is used to find roots of the polynomial as eigenvalues.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn polycompanion(c: Vec<i8>) -> (result: Vec<Vec<i8>>)\n    requires \n        c.len() >= 2,\n        c[c.len() - 1] != 0,\n    ensures\n        result.len() == c.len() - 1,\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == c.len() - 1,\n        forall|i: int, j: int| \n            0 <= i < result.len() && 0 <= j < result[i].len() ==>\n            (if i + 1 == j && i < c.len() - 2 {\n                result[i][j] as int == 1\n            } else if i == c.len() - 2 {\n                result[i][j] as int * c[c.len() - 1] as int == -c[j] as int\n            } else {\n                result[i][j] as int == 0\n            })", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0513", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_polynomial_polyder", "vc-description": "Differentiate a polynomial.\n\nReturns the polynomial coefficients differentiated `m` times.\nAt each iteration the result is multiplied by `scl` (scaling factor).\nThe coefficients are from low to high degree, e.g., [1,2,3] represents 1 + 2*x + 3*x².\n\nThis specification handles the case where m ≤ n. When m > n, the derivative\nwould be the zero polynomial.\n\nSpecification: polyder computes the m-th derivative of a polynomial with scaling.\n\nMathematical properties: \n- d/dx(c[i] * x^i) = i * c[i] * x^(i-1)\n- With scaling factor scl: d/d(scl*x)(c[i] * x^i) = scl * i * c[i] * x^(i-1)\n- Taking m derivatives of x^i gives: i * (i-1) * ... * (i-m+1) * x^(i-m)\n\nEach coefficient is multiplied by scl at each differentiation step,\nresulting in multiplication by scl^m overall.\n\nSanity checks:\n- Taking 0 derivatives returns the original polynomial\n- The constant term (i=0) disappears after one derivative\n- Higher order terms shift down by m positions", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn polyder(c: Vec<f32>, m: u8, scl: f32) -> (result: Vec<f32>)\n    requires \n        m as int <= c.len(),\n    ensures\n        result.len() == c.len() - m as int,\n        /* Special case: m = 0 returns original polynomial */\n        (m == 0 ==> forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i] == c[i]),\n        /* General case: m > 0 - coefficients come from higher degree terms */\n        (m > 0 ==> forall|i: int| 0 <= i < result.len() ==> \n            #[trigger] result[i] == result[i] /* Mathematical relationship preserved through differentiation */)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0514", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_polynomial_polydiv", "vc-description": "numpy.polynomial.polynomial.polydiv: Divide one polynomial by another.\n\nReturns the quotient-with-remainder of two polynomials c1 / c2.\nThe arguments are sequences of coefficients, from lowest order term\nto highest, e.g., [1,2,3] represents 1 + 2*x + 3*x**2.\n\nThe function performs polynomial long division, returning both\nthe quotient and remainder such that c1 = c2 * quotient + remainder.\n\nSpecification: polydiv performs polynomial division with remainder.\n\nPrecondition: The leading coefficient of c2 (highest degree term) is non-zero\nPostcondition: \n- The division identity holds: c1 = c2 * quotient + remainder (as polynomials)\n- The remainder has degree less than the divisor (leading coefficients are zero)\n- When the divisor is a constant polynomial, the quotient is c1 scaled by 1/c2[0]\n\n// leading coefficient non-zero\n\n// Division identity: polynomial relationship holds\n\n// Remainder has lower degree than divisor", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn polydiv(c1: Vec<f32>, c2: Vec<f32>) -> (result: (Vec<f32>, Vec<f32>))\n    requires \n        c1.len() > 0,\n        c2.len() > 0,\n        c2[(c2.len() - 1) as int] != 0.0f32,\n    ensures ({\n        let (quo, rem) = result;\n\n        quo.len() == c1.len() &&\n        rem.len() == c1.len() &&\n\n        (forall|j: int| j >= (c2.len() as int - 1) && 0 <= j < rem.len() ==> rem[j] == 0.0f32)\n    })", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0516", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_polynomial_polyfromroots", "vc-description": "Generate a monic polynomial with given roots.\n\nSpecification: polyfromroots generates a monic polynomial with given roots.\nThe resulting polynomial has the form p(x) = (x - r_0)(x - r_1)...(x - r_n),\nwhere the coefficients are returned in ascending order of powers.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn polyfromroots(roots: Vec<f64>) -> (result: Vec<f64>)\n    ensures\n        result@.len() == roots@.len() + 1,\n        result@[result@.len() - 1] == 1.0", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0517", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_polynomial_polygrid2d", "vc-description": "Evaluate a 2-D polynomial on the Cartesian product of x and y.\n\nThis function returns the values:\np(a,b) = sum_{i,j} c_{i,j} * a^i * b^j\n\nwhere the points (a, b) consist of all pairs formed by taking\na from x and b from y. The resulting points form a grid with\nx in the first dimension and y in the second.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn polygrid2d(x: Vec<f32>, y: Vec<f32>, c: Vec<Vec<f32>>) -> (result: Vec<Vec<f32>>)\n    requires \n        x.len() > 0,\n        y.len() > 0,\n        c.len() > 0,\n        forall|i: int| 0 <= i < c.len() ==> c@[i].len() > 0,\n    ensures \n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> result@[i].len() == y.len(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0518", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_polynomial_polygrid3d", "vc-description": "{\n  \"name\": \"numpy.polynomial.polynomial.polygrid3d\",\n  \"category\": \"Standard polynomials\",\n  \"description\": \"Evaluate a 3-D polynomial on the Cartesian product of x, y and z.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.polynomial.polygrid3d.html\",\n  \"doc\": \"Evaluate a 3-D polynomial on the Cartesian product of x, y and z.\\n\\n    This function returns the values:\\n\\n    .. math:: p(a,b,c) = \\\\\\\\sum_{i,j,k} c_{i,j,k} * a^i * b^j * c^k\\n\\n    where the points ``(a, b, c)`` consist of all triples formed by taking\\n    `a` from `x`, `b` from `y`, and `c` from `z`. The resulting points form\\n    a grid with `x` in the first dimension, `y` in the second, and `z` in\\n    the third.\\n\\n    The parameters `x`, `y`, and `z` are converted to arrays only if they\\n    are tuples or a lists, otherwise they are treated as a scalars. In\\n    either case, either `x`, `y`, and `z` or their elements must support\\n    multiplication and addition both with themselves and with the elements\\n    of `c`.\\n\\n    If `c` has fewer than three dimensions, ones are implicitly appended to\\n    its shape to make it 3-D. The shape of the result will be c.shape[3:] +\\n    x.shape + y.shape + z.shape.\\n\\n    Parameters\\n    ----------\\n    x, y, z : array_like, compatible objects\\n        The three dimensional series is evaluated at the points in the\\n        Cartesian product of `x`, `y`, and `z`.  If `x`, `y`, or `z` is a\\n        list or tuple, it is first converted to an ndarray, otherwise it is\\n        left unchanged and, if it isn't an ndarray, it is treated as a\\n        scalar.\\n    c : array_like\\n        Array of coefficients ordered so that the coefficients for terms of\\n        degree i,j are contained in ``c[i,j]``. If `c` has dimension\\n        greater than two the remaining indices enumerate multiple sets of\\n        coefficients.\\n\\n    Returns\\n    -------\\n    values : ndarray, compatible object\\n        The values of the two dimensional polynomial at points in the Cartesian\\n        product of `x` and `y`.\\n\\n    See Also\\n    --------\\n    polyval, polyval2d, polygrid2d, polyval3d\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial import polynomial as P\\n    >>> c = ((1, 2, 3), (4, 5, 6), (7, 8, 9))\\n    >>> P.polygrid3d([0, 1], [0, 1], [0, 1], c)\\n    array([[ 1., 13.],\\n           [ 6., 51.]])\"\n}\n\nEvaluate a 3-D polynomial on the Cartesian product of x, y and z\n\nSpecification: polygrid3d evaluates a 3-D polynomial on the Cartesian product of x, y and z.\nThe result is a 3D grid where result[i][j][k] = p(x[i], y[j], z[k]) for the polynomial \ndefined by coefficients c, where p(a,b,c) = sum_{i,j,k} c[i][j][k] * a^i * b^j * c^k.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn polygrid3d(\n    x: Vec<i8>, \n    y: Vec<i8>, \n    z: Vec<i8>,\n    c: Vec<Vec<Vec<i8>>>\n) -> (result: Vec<Vec<Vec<i8>>>)\n    requires \n        x@.len() > 0,\n        y@.len() > 0, \n        z@.len() > 0,\n        c@.len() > 0,\n        forall|i: int| 0 <= i < c@.len() ==> c@[i].len() > 0,\n        forall|i: int, j: int| 0 <= i < c@.len() && 0 <= j < c@[i].len() ==> c@[i][j].len() > 0,\n    ensures\n        result@.len() == x@.len(),\n        forall|i: int| 0 <= i < result@.len() ==> result@[i].len() == y@.len(),\n        forall|i: int, j: int| 0 <= i < result@.len() && 0 <= j < result@[i].len() ==> result@[i][j].len() == z@.len()", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0519", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_polynomial_polyint", "vc-description": "Integrate a polynomial.\n\nReturns the polynomial coefficients integrated m times from lbnd.\nAt each iteration the resulting series is multiplied by scl and \nan integration constant k is added. The scaling factor is for use \nin a linear change of variable.\n\nThe input coefficients are ordered from low to high degree.\nFor example, [1, 2, 3] represents 1 + 2*x + 3*x².\n\nSpecification: polyint integrates polynomial coefficients m times.\n\nThe integration process:\n1. For each integration step i (from 0 to m-1):\n   - Multiply all coefficients by scl\n   - Integrate: coefficient at degree j becomes coefficient/(j+1) at degree j+1\n   - Add integration constant k[i] adjusted for lower bound lbnd\n2. Result has m more coefficients than input (degree increases by m)\n\nProperties:\n- Integration increases polynomial degree by m\n- Each integration step preserves the polynomial structure\n- The derivative of the result (m times) gives back the original scaled by scl^m\n- Integration constants k determine the value of antiderivatives at lbnd", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn polyint(c: Vec<i8>, m: usize, k: Vec<i8>, lbnd: i8, scl: i8) -> (result: Vec<i8>)\n    requires \n        m > 0 ==> scl as int != 0,\n        k.len() == m,\n    ensures\n        /* Size constraint: output has m more coefficients than input */\n        result.len() == c.len() + m,\n        \n        /* For single integration (m = 1), verify the integration formula */\n        m == 1 ==> {\n            /* When input is empty polynomial (zero), result is just the constant */\n            (c.len() == 0 ==> result@[0] as int == k@[0] as int) &&\n            /* For non-empty input, apply integration rules */\n            (c.len() > 0 ==> {\n                /* Each coefficient c[i] at degree i becomes scl*c[i]/(i+1) at degree i+1 */\n                forall|i: int| 0 <= i < c.len() ==> \n                    (i + 1) * (result@[i + 1] as int) == (scl as int) * (c@[i] as int)\n            })\n        },\n        \n        /* Property about integration constants and lower bound */\n        /* The integration constant is adjusted so that the integral evaluated at lbnd equals k */\n        m == 1 && c.len() > 0 ==> {\n            /* If we had k = [0] and lbnd = 0, then result[0] = 0 */\n            (k@[0] as int == 0 && lbnd as int == 0 ==> result@[0] as int == 0) &&\n            /* Example: integrating [1,2,3] with k=3 gives result[0] = 3 when lbnd = 0 */\n            (k@[0] as int == 3 && lbnd as int == 0 ==> result@[0] as int == 3)\n        },\n        \n        /* Mathematical property: The integration operation is the inverse of differentiation */\n        /* If we integrate m times then differentiate m times, we get back c scaled by scl^m */\n        m > 0 && scl as int != 0 ==> true,\n        \n        /* Sanity check: When scl = 0, all non-constant coefficients become 0 */\n        scl as int == 0 ==> forall|i: int| (m as int) <= i < result.len() ==> result@[i] as int == 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0520", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_polynomial_polyline", "vc-description": "Returns a vector representing a linear polynomial off + scl*x.\n\nFor the linear polynomial off + scl*x, this returns:\n- [off, scl] when scl ≠ 0 (degree 1 polynomial)\n- [off] when scl = 0 (degree 0 polynomial, constant)\n\nThis follows NumPy's convention where coefficients are ordered from\nlowest to highest degree, so [off, scl] represents off + scl*x.\n\nWe use Vector Float 2 to represent the general case, with the understanding\nthat when scl = 0, the second coefficient is meaningless.\n\nSpecification: polyline creates correct linear polynomial representation.\n\nThe function returns coefficients for the linear polynomial off + scl*x:\n- Always returns [off, scl] as a 2-element vector\n- When scl = 0, this represents the constant polynomial off\n- When scl ≠ 0, this represents the linear polynomial off + scl*x\n\nKey properties:\n1. Coefficient structure: coefficients are ordered from lowest to highest degree\n2. Constant term is always off (at index 0)\n3. Linear term coefficient is scl (at index 1)\n4. Evaluation property: at x=0, polynomial evaluates to off\n5. Slope property: derivative of polynomial is scl\n6. Mathematical correctness: represents polynomial off + scl*x", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn polyline(off: i8, scl: i8) -> (result: [i8; 2])\n    ensures\n        /* Constant term is always off */\n        result[0] == off,\n        /* Linear coefficient is always scl */\n        result[1] == scl,\n        /* Size is always 2 (representing up to degree 1 polynomial) */\n        result@.len() == 2,\n        /* Example evaluation: if we evaluate at x=1, we get off + scl */\n        result[0] as int + result[1] as int == off as int + scl as int", "vc-code": "{\n    // impl-start\n    assume(false);\n    [0; 2]\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0522", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_polynomial_polymulx", "vc-description": "Multiply a polynomial by x.\nMultiplies polynomial c by x, where x is the independent variable.\nFor polynomial p(x) = c[0] + c[1]*x + ... + c[n-1]*x^(n-1),\nreturns x*p(x) = 0 + c[0]*x + c[1]*x^2 + ... + c[n-1]*x^n\n\nSpecification: polymulx multiplies a polynomial by x.\nThe result has one more coefficient than the input.\nThe first coefficient is always 0, and subsequent coefficients\nare the original coefficients shifted by one position.\nThis represents multiplying p(x) by x to get x*p(x).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn polymulx(c: Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() == c.len() + 1,\n        result[0] == 0.0f32,\n        forall|i: int| 0 <= i < c@.len() ==> result[i + 1] == c[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0523", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_polynomial_polypow", "vc-description": "Raise a polynomial to a power.\nReturns the polynomial c raised to the power pow.\nFor polynomial p(x) = c[0] + c[1]*x + ... + c[n-1]*x^(n-1),\nreturns p(x)^pow with appropriate coefficient expansion.\n\nSpecification: polypow raises a polynomial to a non-negative integer power.\nThe result represents the polynomial p(x)^pow where p(x) is defined by coefficients c.\nFor power 0, returns [1] (the constant polynomial 1).\nFor power 1, returns the original polynomial.\nThe degree grows as expected for polynomial multiplication.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn polypow(c: Vec<f32>, pow: u8) -> (result: Vec<f32>)\n    ensures\n        pow == 0 ==> (result.len() == 1 && result[0] == 1.0f32),\n        pow == 1 ==> result.len() == c.len() && (forall|i: int| 0 <= i < c.len() ==> result[i] == c[i]),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0524", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_polynomial_polyroots", "vc-description": "Compute the roots of a polynomial.\nGiven polynomial coefficients c[0], c[1], ..., c[n-1], returns the roots of\np(x) = c[0] + c[1]*x + c[2]*x^2 + ... + c[n-1]*x^(n-1).\nFor a polynomial of degree n, there are exactly n roots (counting multiplicity).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn polyroots(c: Vec<f64>) -> (result: Vec<f64>)\n    requires \n        c.len() > 1,\n        c[c.len() - 1] != 0.0,\n    ensures\n        result.len() == c.len() - 1,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0525", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_polynomial_polysub", "vc-description": "Subtract one polynomial from another.\nReturns the difference of two polynomials c1 - c2, where polynomials are\nrepresented as coefficient vectors from lowest order term to highest.\n\nSpecification: polysub computes c1 - c2 element-wise, padding with zeros.\nThe result has length max(n, m), and for each coefficient position i:\n- If i < min(n, m): result[i] = c1[i] - c2[i]\n- If min(n, m) ≤ i < n: result[i] = c1[i]\n- If min(n, m) ≤ i < m: result[i] = -c2[i]\n\nAdditionally, polysub satisfies mathematical properties:\n- Anti-commutativity: polysub c1 c2 = -(polysub c2 c1)\n- Zero identity: polysub c 0 = c and polysub 0 c = -c", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn polysub(c1: Vec<i8>, c2: Vec<i8>) -> (result: Vec<i8>)\n    ensures\n        result.len() == if c1.len() >= c2.len() { c1.len() } else { c2.len() },\n        forall|i: int| 0 <= i < result.len() ==> {\n            if i < c1.len() && i < c2.len() {\n                result[i] as int == c1[i] as int - c2[i] as int\n            } else if i < c1.len() && i >= c2.len() {\n                result[i] == c1[i]\n            } else if i >= c1.len() && i < c2.len() {\n                result[i] as int == 0 - c2[i] as int\n            } else {\n                result[i] == 0\n            }\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0526", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_polynomial_polyval", "vc-description": "Evaluate a polynomial at points x using Horner's method.\nGiven coefficients c = [c₀, c₁, ..., cₙ] and evaluation points x,\ncomputes p(x) = c₀ + c₁·x + c₂·x² + ... + cₙ·xⁿ for each x\n\nSpecification: polyval evaluates a polynomial with coefficients c at points x.\nThe result at each point xᵢ is the polynomial value p(xᵢ) = c₀ + c₁·xᵢ + c₂·xᵢ² + ... + cₙ·xᵢⁿ\n\nMathematical properties:\n- For coefficient vector c = [c₀, c₁, ..., cₙ], evaluates polynomial p(x) = Σⱼ cⱼ·xʲ\n- Uses Horner's method for numerical stability: p(x) = c₀ + x·(c₁ + x·(c₂ + x·(...)))\n- Linear in coefficients: p(x, αc₁ + βc₂) = α·p(x, c₁) + β·p(x, c₂)\n- Polynomial evaluation at zero gives constant term: p(0) = c₀\n- For degree-0 polynomial [c₀], result is constant c₀ for all x", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn polyval(x: Vec<f64>, c: Vec<f64>) -> (result: Vec<f64>)\n    requires \n        x@.len() > 0,\n        c@.len() > 0,\n    ensures\n        result@.len() == x@.len(),\n        forall|i: int| 0 <= i < result@.len() ==> \n            #[trigger] result@[i] == result@[i] &&\n            (c@.len() == 1 ==> result@[i] == c@[0]) &&\n            (forall|j: int| 0 <= j < c@.len() && c@[j] == 0.0 ==> #[trigger] result@[i] == 0.0)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0527", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_polynomial_polyval2d", "vc-description": "Evaluate a 2D polynomial at points (x, y).\nGiven a coefficient matrix c and evaluation points (x, y),\ncomputes p(x,y) = Σᵢⱼ cᵢⱼ·xⁱ·yʲ for each point pair\n\nSpecification: polyval2d evaluates a 2D polynomial with coefficient matrix c at point pairs (x, y).\nThe result at each point (xᵢ, yᵢ) is the polynomial value p(xᵢ, yᵢ) = Σᵢⱼ cᵢⱼ·xᵢⁱ·yᵢʲ\n\nMathematical properties:\n- For coefficient matrix c[i][j], evaluates p(x,y) = Σᵢⱼ c[i][j]·xⁱ·yʲ\n- Reduces to 1D polyval when one variable is zero: p(x,0) uses first column c[*][0]\n- Bilinear in coefficients: p(x,y, αc₁ + βc₂) = α·p(x,y,c₁) + β·p(x,y,c₂)  \n- Constant term: p(0,0) = c[0][0]\n- Degree-0 in both variables gives constant: c = [[c₀₀]] → p(x,y) = c₀₀ for all (x,y)\n\n/* Constant term property: when both degrees are 0 */\n\n/* Zero coefficient property: if all coefficients are zero, result is zero */\n\n/* Evaluation at origin gives constant term */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn polyval2d(x: Vec<f32>, y: Vec<f32>, c: Vec<Vec<f32>>) -> (result: Vec<f32>)\n    requires \n        x@.len() == y@.len(),\n        x@.len() > 0,\n        c@.len() > 0,\n        forall|i: int| 0 <= i < c@.len() ==> #[trigger] c@[i].len() > 0,\n        forall|i: int| 0 <= i < c@.len() ==> #[trigger] c@[i].len() == c@[0].len(),\n    ensures\n        result@.len() == x@.len(),\n\n        (c@.len() == 1 && c@[0].len() == 1) ==> \n            (forall|k: int| 0 <= k < result@.len() ==> #[trigger] result@[k] == c@[0][0]),\n\n        (forall|i: int, j: int| 0 <= i < c@.len() && 0 <= j < c@[i].len() ==> #[trigger] c@[i][j] == 0.0f32) ==> \n            (forall|k: int| 0 <= k < result@.len() ==> #[trigger] result@[k] == 0.0f32),\n\n        forall|k: int| 0 <= k < result@.len() && x@[k] == 0.0f32 && y@[k] == 0.0f32 ==> \n            #[trigger] result@[k] == c@[0][0],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0528", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_polynomial_polyval3d", "vc-description": "Evaluate a 3-D polynomial at points (x, y, z).\nThis function evaluates the polynomial p(x,y,z) = Σ_{i,j,k} c[i,j,k] * x^i * y^j * z^k\nwhere the sum is over all valid indices of the coefficient tensor c.\n\nSpecification: polyval3d evaluates a 3-dimensional polynomial at each point (x[i], y[i], z[i]).\nThe polynomial is defined as the sum of c[i,j,k] * x^i * y^j * z^k over all coefficient indices.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn polyval3d(\n    x: Vec<f32>, \n    y: Vec<f32>, \n    z: Vec<f32>, \n    c: Vec<Vec<Vec<f32>>>\n) -> (result: Vec<f32>)\n    requires \n        x@.len() == y@.len(),\n        y@.len() == z@.len(),\n        c@.len() > 0,\n        forall|i: int| 0 <= i < c@.len() ==> c@[i].len() > 0,\n        forall|i: int, j: int| 0 <= i < c@.len() && 0 <= j < c@[i].len() ==> c@[i][j].len() > 0,\n    ensures \n        result@.len() == x@.len(),\n        forall|p: int| 0 <= p < result@.len() ==> \n            #[trigger] result@[p] == result@[p] &&\n            (c@.len() == 1 && c@[0].len() == 1 && c@[0][0].len() == 1 ==> \n             result@[p] == c@[0][0][0])", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0529", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_polynomial_polyvalfromroots", "vc-description": "Evaluate a polynomial specified by its roots at points x.\nIf `r` is of length `N`, this function returns the value p(x) = ∏(x - r_i)\nwhere the product is over all roots r_i in the roots vector.\n\nSpecification: polyvalfromroots evaluates the polynomial with the given roots\nat each point in x. The polynomial is defined as the product of (x - r_i) for all roots r_i.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn poly_eval_at_point(x_val: int, roots: Seq<int>) -> int\n    decreases roots.len()\n{\n    if roots.len() == 0 {\n        1\n    } else {\n        (x_val - roots[0]) * poly_eval_at_point(x_val, roots.subrange(1, roots.len() as int))\n    }\n}\n\nfn polyvalfromroots(x: Vec<i8>, r: Vec<i8>) -> (result: Vec<i8>)\n    ensures \n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] as int == poly_eval_at_point(x[i] as int, r@.map_values(|v: i8| v as int)),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0530", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_polynomial_polyvander", "vc-description": "Vandermonde matrix of given degree.\nReturns the Vandermonde matrix of degree `deg` and sample points `x`.\nThe Vandermonde matrix is defined by V[i,j] = x[i]^j for 0 <= j <= deg.\n\nSpecification: polyvander generates a Vandermonde matrix where each row corresponds to\npowers of the corresponding element in x, from degree 0 to deg.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn polyvander(x: Vec<f32>, deg: usize) -> (result: Vec<Vec<f32>>)\n    requires x.len() > 0,\n    ensures\n        result.len() == x.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == deg + 1,\n        forall|i: int| 0 <= i < result.len() ==> result[i][0] == 1.0f32,\n        deg > 0 ==> forall|i: int| 0 <= i < result.len() ==> result[i][1] == x[i]", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0531", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_polynomial_polyvander2d", "vc-description": "Pseudo-Vandermonde matrix of given degrees for 2D polynomials.\nReturns a matrix where V[k, (yDeg + 1)*i + j] = x[k]^i * y[k]^j\nfor 0 <= i <= xDeg and 0 <= j <= yDeg.\n\nSpecification: polyvander2d creates a pseudo-Vandermonde matrix where each entry\nsatisfies the polynomial power relationship V[k, (yDeg + 1)*i + j] = x[k]^i * y[k]^j.\nThe matrix has dimensions n × ((xDeg + 1) * (yDeg + 1)) and represents all polynomial\nterms x^i * y^j for 0 ≤ i ≤ xDeg and 0 ≤ j ≤ yDeg.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn pow_spec(base: int, exp: nat) -> int\n    decreases exp\n{\n    if exp == 0 {\n        1\n    } else {\n        base * pow_spec(base, (exp - 1) as nat)\n    }\n}", "vc-helpers": "", "vc-spec": "fn polyvander2d(x: Vec<f64>, y: Vec<f64>, x_deg: u8, y_deg: u8) -> (result: Vec<Vec<f64>>)\n    requires \n        x.len() == y.len(),\n        x.len() > 0,\n    ensures\n        result.len() == x.len(),\n        forall|k: int| 0 <= k < result.len() ==> #[trigger] result[k].len() == (x_deg as int + 1) * (y_deg as int + 1),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0532", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_polynomial_polyvander3d", "vc-description": "Pseudo-Vandermonde matrix of given degrees for 3D polynomials.\nReturns a matrix where V[p, (yDeg + 1)*(zDeg + 1)*i + (zDeg + 1)*j + k] = x[p]^i * y[p]^j * z[p]^k\nfor 0 <= i <= xDeg, 0 <= j <= yDeg and 0 <= k <= zDeg.\n\nSpecification: polyvander3d creates a pseudo-Vandermonde matrix where each entry\nsatisfies the polynomial power relationship V[p, (yDeg + 1)*(zDeg + 1)*i + (zDeg + 1)*j + k] = x[p]^i * y[p]^j * z[p]^k.\nThe matrix has dimensions n × ((xDeg + 1) * (yDeg + 1) * (zDeg + 1)) and represents all polynomial\nterms x^i * y^j * z^k for 0 ≤ i ≤ xDeg, 0 ≤ j ≤ yDeg, and 0 ≤ k ≤ zDeg.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn polyvander3d(x: Vec<f64>, y: Vec<f64>, z: Vec<f64>, x_deg: usize, y_deg: usize, z_deg: usize) -> (result: Vec<Vec<f64>>)\n    requires \n        x@.len() == y@.len(),\n        y@.len() == z@.len(),\n        x@.len() > 0,\n    ensures\n        result@.len() == x@.len(),\n        forall|p: int| 0 <= p < result@.len() ==> result@[p].len() == (x_deg + 1) * (y_deg + 1) * (z_deg + 1)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0533", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_polyutils_as_series", "vc-description": "Return argument as a list of 1-d arrays. Takes a 2-d array of shape (M,N)\nand returns M arrays of size N (parsed by row). Optionally trims trailing \nzeros from each array.\n\nSpecification: as_series returns a list of 1-d arrays where each row of the\ninput becomes a separate 1-d array. When trim is false, arrays are unchanged.\nWhen trim is true, trailing zeros are removed from each array.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn as_series(arr: Vec<Vec<f64>>, trim: bool) -> (result: Vec<Vec<f64>>)\n    requires \n        arr@.len() > 0,\n        forall|i: int| 0 <= i < arr@.len() ==> arr@[i].len() > 0,\n    ensures \n        result@.len() == arr@.len(),\n        forall|i: int| 0 <= i < result@.len() ==> {\n            if !trim {\n                result@[i].len() == arr@[i].len() &&\n                forall|j: int| 0 <= j < arr@[i].len() ==> result@[i][j] == arr@[i][j]\n            } else {\n                forall|j: int| 0 <= j < result@[i].len() ==> {\n                    result@[i][j] == arr@[i][j] || result@[i][j] == 0.0\n                }\n            }\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0534", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_polyutils_format_float", "vc-description": "Format a floating-point number into a string representation.\nThis function takes a floating-point value and converts it to a human-readable \nstring format, handling special cases like NaN and infinity, and choosing \nbetween scientific and positional notation based on the magnitude of the number.\n\nSpecification: format_float produces a valid string representation of a float.\nThe function handles special cases (NaN, infinity) and chooses appropriate \nnotation based on the magnitude of the input. The output string should be \nparseable back to a float representation and preserve the essential value \ncharacteristics.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn format_float(x: f64, parens: bool) -> (result: String)\n    ensures\n        result@.len() > 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0535", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_polyutils_getdomain", "vc-description": "Return a domain suitable for given abscissae (real numbers).\nFor real inputs, returns the minimum and maximum values as a 2-element vector.\nThis represents the smallest interval containing all points in the input vector.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn getdomain(x: Vec<i8>) -> (result: Vec<i8>)\n    requires x@.len() > 0,\n    ensures\n        result@.len() == 2,\n        result@[0] as int <= result@[1] as int,\n        forall|i: int| 0 <= i < x@.len() ==> result@[0] as int <= x@[i] as int && x@[i] as int <= result@[1] as int,\n        exists|i: int| 0 <= i < x@.len() && x@[i] as int == result@[0] as int,\n        exists|j: int| 0 <= j < x@.len() && x@[j] as int == result@[1] as int,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0536", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_polyutils_mapdomain", "vc-description": "numpy.polynomial.polyutils.mapdomain: Apply linear map to input points.\n\nThe linear map `offset + scale*x` that maps the domain `old` to\nthe domain `new` is applied to the points `x`.\n\nThis function implements the mathematical transformation:\nx_out = new[0] + m(x - old[0])\nwhere m = (new[1] - new[0]) / (old[1] - old[0])\n\nParameters:\n- x: Points to be mapped (Vector of Float values)\n- old: Two-element vector defining the old domain [old[0], old[1]]\n- new: Two-element vector defining the new domain [new[0], new[1]]\n\nReturns:\n- x_out: Array of points of the same shape as x, after linear transformation\n\nSpecification: mapdomain applies linear transformation to map points from old domain to new domain.\n\nThe function computes a linear transformation that maps the interval [old[0], old[1]] \nto the interval [new[0], new[1]], then applies this transformation to each point in x.\n\nMathematical properties:\n1. The transformation is linear: f(x) = offset + scale * x\n2. The scale factor is: (new[1] - new[0]) / (old[1] - old[0])\n3. The offset is: new[0] - scale * old[0]\n4. Points at old[0] map to new[0], points at old[1] map to new[1]\n\nPrecondition: The old domain must be non-degenerate (old[1] ≠ old[0])\nPostcondition: Each result point follows the linear transformation formula", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn mapdomain(x: Vec<f32>, old: Vec<f32>, new: Vec<f32>) -> (result: Vec<f32>)\n    requires \n        old.len() == 2,\n        new.len() == 2,\n        old[1] != old[0],\n    ensures\n        result.len() == x.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0537", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_polyutils_mapparms", "vc-description": "Linear map parameters between domains. \nReturns the parameters of the linear map `offset + scale*x` that maps\n`old` to `new` such that `old[i] -> new[i]`, `i = 0, 1`.\n\nSpecification: mapparms computes linear mapping parameters between domains.\nThe returned offset and scale define a linear map L(x) = offset + scale*x\nthat maps the old domain to the new domain.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn mapparms(old: [i8; 2], new: [i8; 2]) -> (result: (i8, i8))\n    requires old[0] != old[1],\n    ensures ({\n        let (offset, scale) = result;\n        let oldlen = old[1] as int - old[0] as int;\n        let newlen = new[1] as int - new[0] as int;\n        offset as int + scale as int * old[0] as int == new[0] as int &&\n        offset as int + scale as int * old[1] as int == new[1] as int &&\n        scale as int == newlen / oldlen &&\n        offset as int == (old[1] as int * new[0] as int - old[0] as int * new[1] as int) / oldlen\n    })", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0538", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_polyutils_trimcoef", "vc-description": "Remove \"small\" \"trailing\" coefficients from a polynomial.\nSmall means small in absolute value controlled by tolerance parameter.\nTrailing means highest order coefficients.\n\nSpecification: trimcoef removes trailing coefficients with absolute value ≤ tol.\nIf all coefficients are small, returns a single zero.\nThe tolerance must be non-negative.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn trimcoef(c: Vec<f32>, tol: f32) -> (result: Vec<f32>)\n    ensures\n        result.len() >= 1,\n        result.len() <= c.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0539", "language": "verus", "source": "numpy_triple", "source_id": "polynomial_polyutils_trimseq", "vc-description": "Remove small Poly series coefficients.\n\nRemove trailing zeros from a sequence of polynomial coefficients.\nReturns the sequence with trailing zeros removed. If the sequence would be empty \nafter trimming, returns the first element. Empty sequences are handled.\n\nSpecification: trimseq removes trailing zeros while preserving at least one element.\nFor non-empty sequences, if the last element is non-zero, return the sequence unchanged.\nIf the last element is zero, trim trailing zeros but always keep at least one element.\n\n/* If empty or last element is non-zero, return unchanged */\n\n/* If last element is zero, trim properly */\n\n/* There exists a position k where trimming occurs */\n\n/* All elements after k in original sequence are zero */\n\n/* Result preserves elements up to k, zeros after */\n\n/* Element at k is non-zero unless k = 0 (all zeros case) */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn trimseq(seq: Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() == seq.len(),\n\n        (seq.len() == 0 || (seq.len() > 0 && seq[seq.len() - 1] != 0.0f32)) ==> result@ == seq@,\n\n        (seq.len() > 0 && seq[seq.len() - 1] == 0.0f32) ==>\n\n            exists|k: int| \n                0 <= k < seq.len() as int &&\n\n                (forall|j: int| k < j < seq.len() as int ==> seq[j] == 0.0f32) &&\n\n                (forall|i: int| 0 <= i <= k ==> result[i] == seq[i]) &&\n                (forall|i: int| k < i < result.len() as int ==> result[i] == 0.0f32) &&\n\n                (k > 0 ==> seq[k] != 0.0f32)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0540", "language": "verus", "source": "numpy_triple", "source_id": "random_BitGenerator", "vc-description": "numpy.random.BitGenerator: Base class for bit generators.\n\nThe BitGenerator manages state and provides functions to produce random doubles \nand random unsigned 32- and 64-bit values. This function initializes a BitGenerator\nwith an optional seed value.\n\nParameters:\n- seed: Optional seed value to initialize the generator (None uses system entropy)\n\nReturns:\n- A BitGeneratorState that can be used to generate random values\n\nSpecification: numpy.random.BitGenerator creates a properly initialized BitGenerator state.\n\nPrecondition: True (any seed value is valid, including None)\nPostcondition: The returned state has the provided seed (or maintains None if no seed given)\n            and has a valid internal state representation.\n\n/* BitGenerator state representing the internal state of a pseudo-random number generator.\n   This is an abstract representation that can be seeded and used to generate random values. */\n\n/* The seed value used to initialize the generator, or None if no seed was provided */\n\n/* The internal state of the generator used for random number generation */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\npub struct BitGeneratorState {\n\n    pub seed: Option<u64>,\n\n    pub internal_state: u64,\n}", "vc-helpers": "", "vc-spec": "fn numpy_random_bit_generator(seed: Option<u64>) -> (result: BitGeneratorState)\n    ensures \n        result.seed == seed,\n        seed.is_Some() ==> result.internal_state != 0,\n        seed.is_None() ==> result.internal_state == 0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0541", "language": "verus", "source": "numpy_triple", "source_id": "random_MT19937", "vc-description": "MT19937 BitGenerator for the Mersenne Twister pseudo-random number generator\n\nMT19937 provides a capsule containing function pointers that produce doubles, \nand unsigned 32 and 64-bit integers. This implementation focuses on the core\nstate initialization and next value generation.\n\nThe Mersenne Twister is a pseudorandom number generator that maintains an\ninternal state and produces a sequence of 32-bit integers with a period of 2^19937 - 1.\n\nParameters:\n- seed : u32 optional seed value to initialize the generator\n\nThe generator produces uniformly distributed values in [0, 2^32 - 1]\n\nSpecification: MT19937 initializes the generator state with proper seeding\n\nThe MT19937 generator maintains a state vector of 624 32-bit integers.\nWhen initialized with a seed, it produces a deterministic sequence.\n\nPrecondition: None (any seed value is valid)\nPostcondition: \n1. The state vector has exactly 624 elements\n2. The state is deterministically initialized based on the seed\n3. The first element of the state equals the seed\n4. The generator produces deterministic values based on the seed\n5. All state values are 32-bit unsigned integers", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn mt19937(seed: u32) -> (state: Vec<u32>)\n    ensures\n        /* The state vector has the correct size (624 elements) */\n        state@.len() == 624,\n        /* The first element equals the seed */\n        state@[0] == seed,\n        /* State initialization follows MT19937 recurrence relation */\n        forall|i: int| 0 <= i < 623 ==> #[trigger] state@[i] == state@[i] && {\n            let k = i + 1;\n            let prev_state = state@[i];\n            let shifted = prev_state >> 30;\n            let xor_result = prev_state ^ shifted;\n            let mult_result = 1812433253u32.wrapping_mul(xor_result);\n            let next_val = mult_result.wrapping_add(k as u32);\n            state@[k] == next_val\n        },", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0543", "language": "verus", "source": "numpy_triple", "source_id": "random_PCG64DXSM", "vc-description": "BitGenerator for the PCG-64 DXSM pseudo-random number generator\n\nPCG-64 DXSM is a 128-bit implementation of O'Neill's permutation congruential generator\nwith the DXSM output mixer. It has better statistical properties in parallel contexts\nthan the standard PCG-64.\n\nThe generator uses a linear congruential generator (LCG) to advance the state,\nwith a fixed odd increment. It uses a 64-bit \"cheap multiplier\" in the LCG.\nThe generator has a period of 2^128 and supports advancing an arbitrary number\nof steps as well as 2^127 streams.\n\nThis function generates a sequence of random 64-bit unsigned integers given\na seed value.\n\nSpecification: PCG64DXSM generates a sequence of pseudo-random numbers with specific mathematical properties.\n\nThe PCG64DXSM generator satisfies the following properties:\n1. Deterministic: Same seed produces same sequence\n2. Uniform distribution: All 64-bit values are equally likely over the full period\n3. Full period: The generator has period 2^128\n4. Statistical independence: Generated values appear statistically independent\n5. Non-predictability: Knowledge of some outputs doesn't easily predict others", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn pcg64_dxsm_spec(seed: u64, n: nat) -> Seq<u64>\n{\n    arbitrary()\n}\n\nfn pcg64_dxsm(seed: u64, n: usize) -> (result: Vec<u64>)\n    ensures\n        result.len() == n,\n        seed == seed ==> result@ == pcg64_dxsm_spec(seed, n as nat),\n        n > 0 ==> (exists|i: int| 0 <= i < n && #[trigger] result[i] >= 0),\n        n > 1 ==> true,\n        forall|seed_prime: u64| seed != seed_prime ==> \n            pcg64_dxsm_spec(seed, n as nat) != pcg64_dxsm_spec(seed_prime, n as nat)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0544", "language": "verus", "source": "numpy_triple", "source_id": "random_Philox", "vc-description": "Philox (4x64) pseudo-random number generator.\n\nPhilox is a counter-based RNG that generates pseudo-random numbers\nusing a counter and key. It provides high-quality random numbers\nwith a large period (2^256 - 1) and supports parallel generation.\n\nThe core operation takes a seed and generates a vector of random\nnumbers in the range [0, 1).\n\nSpecification: Philox generates pseudo-random numbers with deterministic behavior.\n\nThe Philox algorithm has several key mathematical properties:\n1. Deterministic: same seed produces same sequence\n2. Uniform distribution: values are uniformly distributed in [0, 1)\n3. Range constraint: all values are in the half-open interval [0, 1)\n4. Reproducibility: identical seeds produce identical sequences\n\nPrecondition: True (no special preconditions)\nPostcondition: All values are in [0, 1) and sequence is deterministic based on seed", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn philox_spec_fn(n: nat, seed: nat) -> Seq<int>;", "vc-helpers": "", "vc-spec": "fn philox(n: usize, seed: u64) -> (result: Vec<i32>)\n    ensures\n        result.len() == n,\n        forall|i: int| 0 <= i < result.len() ==> 0 <= result[i] && result[i] < 1000000,\n        forall|seed1: u64, seed2: u64| seed1 == seed2 ==> \n            philox_spec_fn(n as nat, seed1 as nat) == philox_spec_fn(n as nat, seed2 as nat)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0545", "language": "verus", "source": "numpy_triple", "source_id": "random_RandomState", "vc-description": "Container for the slow Mersenne Twister pseudo-random number generator\n\nGenerate a random float in the range [0, 1) using the RandomState\nThis models the RandomState.random() method which is the most fundamental\noperation for generating uniformly distributed random numbers.\n\nSpecification: random generates a float in the range [0, 1)\n\nThe random function should satisfy:\n1. The result is always in the range [0, 1)\n2. The result is deterministic given the same seed\n3. The result follows uniform distribution properties", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* A simple random state container that can generate random numbers\n   This models the core functionality of numpy.random.RandomState.\n   We focus on the random() method which generates random floats in [0, 1). */\nstruct RandomState {\n    /* The seed value used to initialize the random number generator */\n    seed: u8,\n}", "vc-helpers": "", "vc-spec": "fn random(state: RandomState) -> (result: f32)", "vc-code": "{\n    // impl-start\n    assume(false);\n    0.0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0546", "language": "verus", "source": "numpy_triple", "source_id": "random_SFC64", "vc-description": "SFC64 pseudo-random number generator with 256-bit state.\n\nBitGenerator for the SFC64 pseudo-random number generator.\n\nSFC64 is a chaotic RNG that uses a 256-bit state. It is very fast and appears to be very robust to statistical tests.\n\nParameters:\n- seed : None, int, array_like[ints], SeedSequence, BitGenerator, Generator\n    A seed to initialize the BitGenerator\n\nSpecification: SFC64 initializes a 256-bit state from seed", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* SFC64 state containing 256 bits split into four 64-bit words */\nstruct SFC64State {\n    a: u64,\n    b: u64,\n    c: u64,\n    counter: u64,\n}", "vc-helpers": "", "vc-spec": "fn sfc64(seed: Option<u64>) -> (state: SFC64State)\n    ensures\n        seed.is_none() ==> (state.a == 0 && state.b == 0 && state.c == 0 && state.counter == 0),\n        seed.is_some() ==> (state.a != 0 || state.b != 0 || state.c != 0 || state.counter != 0),", "vc-code": "{\n    // impl-start\n    assume(false);\n    SFC64State { a: 0, b: 0, c: 0, counter: 0 }\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0547", "language": "verus", "source": "numpy_triple", "source_id": "random_SeedSequence", "vc-description": "numpy.random.SeedSequence: Mixes sources of entropy in a reproducible way\nto set the initial state for independent and very probably non-overlapping\nBitGenerators.\n\nSeedSequence takes entropy sources (integers) and mixes them using\ncryptographic hash functions to produce high-quality seed states.\nThe mixing algorithm ensures that even low-quality entropy sources\nproduce high-quality, uniformly distributed output.\n\nKey properties:\n- Reproducible: Same entropy input always produces same output\n- Avalanche effect: Single bit changes affect all output bits\n- Independence: Spawned sequences are non-overlapping\n- Uniform distribution: Output is uniformly distributed over the state space\n\nSpecification: SeedSequence produces a seed state from entropy sources\nwith reproducibility and non-degeneracy properties.\n\nPrecondition: True (accepts any entropy input, including empty)\nPostcondition: \n1. Reproducibility: Same entropy always produces same output\n2. Non-degeneracy: Output depends on input entropy\n3. Deterministic: Function is deterministic for fixed inputs\n4. Well-defined: Always produces valid output within expected bounds", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn seed_sequence_spec(entropy: Seq<u32>, spawn_key: Seq<u32>, pool_size: usize) -> Seq<u32>;\n\nfn seed_sequence(entropy: Vec<u32>, spawn_key: Vec<u32>, pool_size: usize) -> (result: Vec<u32>)\n    requires spawn_key.len() == 0,\n    ensures \n        /* Reproducibility property: same inputs produce same outputs */\n        forall|entropy2: Seq<u32>, spawn_key2: Seq<u32>| \n            entropy@ == entropy2 && spawn_key@ == spawn_key2 ==> \n            seed_sequence_spec(entropy2, spawn_key2, pool_size) == result@,\n        /* Non-degeneracy: output depends on input when entropy is present */\n        entropy.len() > 0 ==> \n            exists|modified_entropy: Seq<u32>| \n                modified_entropy != entropy@ &&\n                seed_sequence_spec(modified_entropy, spawn_key@, pool_size) != result@,\n        /* Well-defined output: result has the correct size */\n        result.len() == pool_size,\n        /* Result specification matches */\n        result@ == seed_sequence_spec(entropy@, spawn_key@, pool_size)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0548", "language": "verus", "source": "numpy_triple", "source_id": "random_default_rng", "vc-description": "numpy.random.default_rng: Construct a new Generator with the default BitGenerator (PCG64).\n\nCreates a new Generator instance using PCG64 as the underlying BitGenerator.\nThis is the recommended way to create random number generators in NumPy.\n\nIf seed is None, the generator will be initialized with fresh entropy from the OS.\nIf seed is provided, the generator will be deterministically initialized with that seed.\n\nSpecification: default_rng returns a properly initialized Generator object.\n\nPrecondition: True (no restrictions on the seed parameter)\nPostcondition: The returned Generator is properly initialized with the given seed\nand uses PCG64 as the underlying BitGenerator.\n\n/* BitGenerator represents the underlying random number generator engine */\n\n/* Internal state of the generator */\n\n/* Seed used to initialize the generator */\n\n/* Generator provides high-level random number generation methods */\n\n/* The underlying BitGenerator (PCG64 by default) */\n\n/* Whether the generator has been properly initialized */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nstruct BitGenerator {\n\n    state: u64,\n\n    seed: Option<u64>,\n}\n\nstruct Generator {\n\n    bit_generator: BitGenerator,\n\n    initialized: bool,\n}", "vc-helpers": "", "vc-spec": "fn default_rng(seed: Option<u64>) -> (result: Generator)\n    ensures\n        result.initialized == true,\n        result.bit_generator.seed == seed,\n        seed.is_some() ==> result.bit_generator.state != 0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0549", "language": "verus", "source": "numpy_triple", "source_id": "set_operations_in1d", "vc-description": "Test whether each element of a 1-D array is also present in a second array.\nReturns a boolean array the same length as ar1 that is True where an element \nof ar1 is in ar2 and False otherwise.\n\nSpecification: in1d tests membership of each element of ar1 in ar2.\nThe result is a boolean vector of the same length as ar1, where each element\nindicates whether the corresponding element of ar1 is present in ar2.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn in1d<T: PartialEq>(ar1: Vec<T>, ar2: Vec<T>) -> (result: Vec<bool>)\n    ensures \n        result.len() == ar1.len(),\n        forall|i: int| 0 <= i < ar1@.len() ==> \n            result@[i] == exists|j: int| 0 <= j < ar2@.len() && ar1@[i] == ar2@[j]", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0550", "language": "verus", "source": "numpy_triple", "source_id": "set_operations_intersect1d", "vc-description": "Find the intersection of two arrays.\nReturns the sorted, unique values that are in both input arrays.\n\nSpecification: intersect1d returns a sorted array of unique values \nthat exist in both input arrays", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn intersect1d(ar1: &Vec<i8>, ar2: &Vec<i8>) -> (result: Vec<i8>)\n    ensures\n        /* Result contains only values that exist in both arrays */\n        forall|i: int| 0 <= i < result@.len() ==> \n            (exists|j: int| 0 <= j < ar1@.len() && #[trigger] result@[i] == ar1@[j]) &&\n            (exists|l: int| 0 <= l < ar2@.len() && result@[i] == ar2@[l]),\n        /* Result is sorted in ascending order */\n        forall|i: int, j: int| 0 <= i < j < result@.len() ==> \n            #[trigger] result@[i] <= #[trigger] result@[j],\n        /* Result contains unique values (no duplicates) */\n        forall|i: int, j: int| 0 <= i < j < result@.len() ==> \n            #[trigger] result@[i] != #[trigger] result@[j]", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0551", "language": "verus", "source": "numpy_triple", "source_id": "set_operations_isin", "vc-description": "numpy.isin: Element-wise test for membership in another array.\n\nCalculates `element in test_elements`, broadcasting over `element` only.\nReturns a boolean array of the same shape as `element` that is True\nwhere an element of `element` is in `test_elements` and False otherwise.\n\nThis is an element-wise function version of the python keyword `in`.\nFor 1-D arrays, this is roughly equivalent to:\n`np.array([item in test_elements for item in element])`\n\nSpecification: numpy.isin returns a boolean vector where each element indicates\nwhether the corresponding element in the input vector is found in test_elements.\n\nPrecondition: True (no special preconditions needed)\nPostcondition: For all indices i, result[i] = true iff element[i] is in test_elements", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_isin(element: Vec<f32>, test_elements: Vec<f32>) -> (result: Vec<bool>)\n    ensures \n        result.len() == element.len(),\n        forall|i: int| 0 <= i < result.len() ==> \n            (result[i] == true <==> exists|j: int| 0 <= j < test_elements.len() && element[i] == test_elements[j])", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0552", "language": "verus", "source": "numpy_triple", "source_id": "set_operations_setdiff1d", "vc-description": "Find the set difference of two arrays.\nReturn the unique values in ar1 that are not in ar2.\n\nSpecification: setdiff1d returns unique values from ar1 that are not in ar2.\nThe result contains no duplicates and is sorted.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn setdiff1d(ar1: Vec<i8>, ar2: Vec<i8>) -> (result: Vec<i8>)\n    ensures\n        /* Each element in result is from ar1 and not in ar2 */\n        forall|i: int| 0 <= i < result@.len() ==> \n            exists|j: int| #[trigger] result[i] == ar1[j] && 0 <= j < ar1@.len() &&\n            forall|l: int| 0 <= l < ar2@.len() ==> result[i] != ar2[l],\n        /* No duplicates in result */\n        forall|i: int, j: int| 0 <= i < result@.len() && 0 <= j < result@.len() && i != j ==> \n            result[i] != result[j],\n        /* Result is sorted */\n        forall|i: int, j: int| 0 <= i < j < result@.len() ==> result[i] <= result[j]", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0553", "language": "verus", "source": "numpy_triple", "source_id": "set_operations_setxor1d", "vc-description": "numpy.setxor1d: Find the set exclusive-or of two arrays.\n\nReturn the sorted, unique values that are in only one (not both) of the\ninput arrays. This is equivalent to the symmetric difference of two sets.\n\nThe result contains elements that appear in ar1 but not in ar2, or in ar2 \nbut not in ar1, sorted in ascending order.\n\nSpecification: numpy.setxor1d returns the symmetric difference of two arrays.\n\nPrecondition: True (no special preconditions)\nPostcondition: \n1. The result contains only elements that appear in exactly one of the input arrays\n2. The result is sorted in ascending order\n3. The result contains no duplicates\n4. Every element in the result comes from either ar1 or ar2 (but not both)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn contains_element(arr: Seq<i32>, elem: i32) -> bool {\n    exists|i: int| 0 <= i < arr.len() && arr[i] == elem\n}\n\nspec fn is_sorted(arr: Seq<i32>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < arr.len() ==> arr[i] <= arr[j]\n}\n\nspec fn has_no_duplicates(arr: Seq<i32>) -> bool {\n    forall|i: int, j: int| 0 <= i < arr.len() && 0 <= j < arr.len() && i != j ==> arr[i] != arr[j]\n}\n\nspec fn in_exactly_one(ar1: Seq<i32>, ar2: Seq<i32>, elem: i32) -> bool {\n    (contains_element(ar1, elem) && !contains_element(ar2, elem)) ||\n    (contains_element(ar2, elem) && !contains_element(ar1, elem))\n}", "vc-helpers": "", "vc-spec": "fn numpy_setxor1d(ar1: &Vec<i32>, ar2: &Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        /* Result is sorted */\n        is_sorted(result@),\n        /* Result has no duplicates */\n        has_no_duplicates(result@),\n        /* Every element in result is from exactly one input array */\n        forall|i: int| 0 <= i < result.len() ==> #[trigger] in_exactly_one(ar1@, ar2@, result[i]),\n        /* Every element that appears in exactly one input array is in the result */\n        forall|x: i32| in_exactly_one(ar1@, ar2@, x) ==> contains_element(result@, x)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0554", "language": "verus", "source": "numpy_triple", "source_id": "set_operations_union1d", "vc-description": "numpy.union1d: Find the union of two arrays.\n\nReturns the unique, sorted array of values that are in either of the two\ninput arrays. The function is equivalent to unique(concatenate(ar1, ar2)).\n\nThe input arrays are flattened if they are not already 1D, and the result\nis always a 1D array containing the union of all elements from both arrays,\nwith duplicates removed and elements sorted in ascending order.\n\nSpecification: numpy.union1d returns the sorted union of two arrays.\n\nPrecondition: True (no special preconditions needed)\nPostcondition: The result contains:\n1. All elements from ar1 and ar2 (union property)\n2. Elements are sorted in ascending order  \n3. No duplicate elements (uniqueness property)\n4. Every element in the result comes from one of the input arrays\n5. Every element from input arrays appears in the result", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn union1d(ar1: Vec<i8>, ar2: Vec<i8>) -> (result: Vec<i8>)\n    ensures\n        /* Union property: every element from either input array is in result */\n        forall|i: int| 0 <= i < ar1.len() ==> \n            #[trigger] result@.contains(ar1[i]),\n        forall|i: int| 0 <= i < ar2.len() ==> \n            #[trigger] result@.contains(ar2[i]),\n        /* Completeness: every element in result comes from one of the input arrays */\n        forall|j: int| 0 <= j < result.len() ==> \n            ar1@.contains(result[j]) || ar2@.contains(result[j]),\n        /* Sorted property: result is sorted in ascending order */\n        forall|i: int, j: int| 0 <= i < j < result.len() ==> \n            #[trigger] result[i] <= #[trigger] result[j],\n        /* Uniqueness property: no duplicate elements */\n        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result.len() && i != j ==> \n            #[trigger] result[i] != #[trigger] result[j],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0555", "language": "verus", "source": "numpy_triple", "source_id": "set_operations_unique", "vc-description": "Find the unique elements of a vector and return them in sorted order.\n\nSpecification: unique returns sorted unique elements from the input vector.\n\n/* Result is sorted */\n\n/* All elements in result come from input array */\n\n/* All elements in result are unique */\n\n/* All elements from input appear in result */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn unique(arr: Vec<i8>) -> (result: Vec<i8>)\n    ensures\n\n        forall|i: int, j: int| 0 <= i < j < result@.len() ==> #[trigger] result@[i] < #[trigger] result@[j],\n\n        forall|i: int| 0 <= i < result@.len() ==> exists|j: int| 0 <= j < arr@.len() && #[trigger] result@[i] == #[trigger] arr@[j],\n\n        forall|i: int, j: int| 0 <= i < result@.len() && 0 <= j < result@.len() && i != j ==> #[trigger] result@[i] != #[trigger] result@[j],\n\n        forall|i: int| 0 <= i < arr@.len() ==> exists|j: int| 0 <= j < result@.len() && #[trigger] arr@[i] == #[trigger] result@[j],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0556", "language": "verus", "source": "numpy_triple", "source_id": "sorting_searching_argmax", "vc-description": "numpy.argmax: Returns the index of the maximum value in a vector.\n\nReturns the index of the maximum value among all elements in the array.\nRequires a non-empty array since there is no maximum of an empty set.\n\nIn case of multiple occurrences of the maximum values, the indices\ncorresponding to the first occurrence are returned.\n\nThis function returns the position of the largest element in the array.\n\nSpecification: numpy.argmax returns the index of the maximum element.\n\nPrecondition: True (non-empty constraint is in the type)\nPostcondition: The element at the returned index is the maximum value,\nand it is the first occurrence of such maximum value.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn argmax(a: Vec<i8>) -> (result: usize)\n    requires a.len() > 0,\n    ensures \n        result < a.len(),\n        forall|j: int| 0 <= j < a@.len() ==> a@[j] <= a@[result as int],\n        forall|j: int| 0 <= j < a@.len() && a@[j] == a@[result as int] ==> result <= j as usize,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0557", "language": "verus", "source": "numpy_triple", "source_id": "sorting_searching_argmin", "vc-description": "numpy.argmin: Returns the index of the minimum value.\n\nReturns the index of the minimum value among all elements in the array.\nRequires a non-empty array since there is no minimum of an empty set.\n\nThis function returns the position of the smallest element in the array.\nIn case of multiple occurrences of the minimum values, the indices\ncorresponding to the first occurrence are returned.\n\nSpecification: numpy.argmin returns the index of the minimum element.\n\nPrecondition: True (non-empty constraint is in the type)\nPostcondition: The element at the returned index is the minimum value,\nand for ties, it returns the first occurrence.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_argmin(a: Vec<i8>) -> (result: usize)\n    requires a.len() > 0,\n    ensures \n        result < a.len(),\n        forall|j: int| 0 <= j < a@.len() ==> a@[result as int] <= a@[j],\n        forall|j: int| 0 <= j < a@.len() && a@[j] == a@[result as int] ==> (result as int) <= j,", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0558", "language": "verus", "source": "numpy_triple", "source_id": "sorting_searching_argpartition", "vc-description": "Perform an indirect partition along the given axis.\nReturns an array of indices that partition the input array such that\nthe kth element is in its final sorted position and all smaller\nelements are moved before it and all larger elements behind it.\n\nSpecification: argpartition returns indices that correctly partition the array.\nThe kth element is in its final sorted position, with all smaller elements\nbefore it and all larger elements after it.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn argpartition(a: Vec<i8>, kth: usize) -> (indices: Vec<usize>)\n    requires \n        a.len() > 0,\n        kth < a.len(),\n    ensures\n        /* The indices form a valid permutation of 0..n-1 */\n        indices.len() == a.len(),\n        /* Partition property: all elements before kth position are ≤ kth element */\n        forall|i: int| 0 <= i < kth ==> a@[#[trigger] indices@[i] as int] <= a@[#[trigger] indices@[kth as int] as int],\n        /* Partition property: all elements after kth position are ≥ kth element */\n        forall|i: int| kth < i && i < indices.len() ==> a@[#[trigger] indices@[kth as int] as int] <= a@[#[trigger] indices@[i] as int],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0559", "language": "verus", "source": "numpy_triple", "source_id": "sorting_searching_argsort", "vc-description": "Returns the indices that would sort a vector in ascending order. Performs an indirect sort returning an array of indices that would sort the input array in ascending order. For equal elements, maintains relative order (stable sort).\n\n// All indices are valid\n\n// The result represents sorted order\n\n// Stable sort property for equal elements", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn argsort(a: Vec<i8>) -> (result: Vec<usize>)\n    ensures \n        result.len() == a.len(),\n\n        forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i] < a.len(),\n\n        forall|i: int, j: int| 0 <= i < j < result.len() ==> \n            a[#[trigger] result[i] as int] <= a[#[trigger] result[j] as int],\n\n        forall|i: int, j: int| 0 <= i < j < result.len() && \n            a[#[trigger] result[i] as int] == a[#[trigger] result[j] as int] ==> \n            result[i] < result[j]", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0560", "language": "verus", "source": "numpy_triple", "source_id": "sorting_searching_argwhere", "vc-description": "numpy.argwhere: Find the indices of array elements that are non-zero, grouped by element.\n\nFor a 1D vector, returns a list of indices where elements are non-zero.\nEach index corresponds to a position in the original vector where the element is non-zero.\nThe returned indices are in the same order as they appear in the original vector.\n\nSpecification: numpy.argwhere returns all indices of non-zero elements.\n\nPrecondition: True (no special requirements)\nPostcondition: \n1. All returned indices correspond to non-zero elements in the input vector\n2. All non-zero elements in the input vector have their indices in the result\n3. The result contains no duplicate indices\n4. The indices are ordered according to their position in the original vector\n\n/* All returned indices correspond to non-zero elements */\n\n/* All non-zero elements have their indices in the result */\n\n/* No duplicate indices */\n\n/* Indices are ordered by position */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_argwhere(a: Vec<f64>) -> (indices: Vec<usize>)\n    ensures\n\n        forall|i: int| 0 <= i < indices@.len() ==> \n            indices@[i] < a@.len() && a@[indices@[i] as int] != 0.0,\n\n        forall|i: int| 0 <= i < a@.len() && a@[i] != 0.0 ==> \n            indices@.contains(i as usize),\n\n        forall|i: int, j: int| 0 <= i < j < indices@.len() ==> \n            indices@[i] != indices@[j],\n\n        forall|i: int, j: int| 0 <= i < j < indices@.len() ==> \n            indices@[i] < indices@[j],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0561", "language": "verus", "source": "numpy_triple", "source_id": "sorting_searching_bincount", "vc-description": "numpy.bincount: Count number of occurrences of each value in array of non-negative ints.\n\nCount number of occurrences of each value in array of non-negative ints.\nThe number of bins (of size 1) is one larger than the largest value in x.\nEach bin gives the number of occurrences of its index value in x.\n\nThis function takes a 1D array of non-negative integers and returns\nan array where the i-th element is the count of how many times the\nvalue i appears in the input array.\n\nSpecification: numpy.bincount returns count of occurrences of each value.\n\nPrecondition: All values in x are non-negative and ≤ max_val\nPostcondition: result[i] = count of occurrences of value i in x", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn count_occurrences(x: Seq<nat>, val: nat) -> nat {\n    x.filter(|v: nat| v == val).len()\n}\n\nfn numpy_bincount(x: Vec<u8>, max_val: u8) -> (result: Vec<u8>)\n    requires \n        forall|i: int| 0 <= i < x.len() ==> x[i] as nat <= max_val as nat,\n    ensures\n        result.len() == max_val as nat + 1,\n        forall|val: int| 0 <= val <= max_val as int ==> \n            result[val] as nat == count_occurrences(x@.map(|i: int, v: u8| v as nat), val as nat),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0562", "language": "verus", "source": "numpy_triple", "source_id": "sorting_searching_count_nonzero", "vc-description": "Counts the number of non-zero values in a vector.\n\nThe word \"non-zero\" is in reference to the Python 2.x\nbuilt-in method `__nonzero__()` (renamed `__bool__()`\nin Python 3.x) of Python objects that tests an object's\n\"truthfulness\". For example, any number is considered\ntruthful if it is nonzero, whereas any string is considered\ntruthful if it is not the empty string. Thus, this function\ncounts how many elements in the vector are non-zero.\n\nSpecification: count_nonzero returns the number of non-zero elements in the vector.\n\nThe function counts exactly those elements that are not equal to zero.\nThe result is always between 0 and n (inclusive), where n is the length of the vector.\nIf all elements are zero, the result is 0.\nIf all elements are non-zero, the result is n.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn count_nonzero(a: Vec<i8>) -> (count: usize)\n    ensures\n        count <= a.len(),\n        a.len() == 0 ==> count == 0,\n        (forall|i: int| 0 <= i < a@.len() ==> a[i] == 0) ==> count == 0,\n        (forall|i: int| 0 <= i < a@.len() ==> a[i] != 0) ==> count == a.len(),\n        (exists|i: int| 0 <= i < a@.len() && a[i] != 0) ==> count > 0,\n        (exists|i: int| 0 <= i < a@.len() && a[i] == 0) ==> count < a.len()", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0563", "language": "verus", "source": "numpy_triple", "source_id": "sorting_searching_extract", "vc-description": "Return the elements of an array that satisfy some condition.\nThe result size is the number of True entries in the condition array.\n\nSpecification: extract returns elements from arr where condition is True.\nThe result contains exactly those elements from arr at positions where condition is True,\npreserving their original order. The result size m equals the number of True values in condition.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn extract(condition: &Vec<bool>, arr: &Vec<i8>) -> (result: Vec<i8>)\n    requires condition.len() == arr.len(),\n    ensures\n        /* Each element in result comes from arr at a position where condition is true */\n        forall|k: int| 0 <= k < result@.len() ==>\n            exists|i: int| 0 <= i < arr@.len() && condition@[i] == true && #[trigger] result@[k] == arr@[i],\n        /* Every True position in condition contributes exactly one element to the result */\n        forall|i: int| 0 <= i < condition@.len() && condition@[i] == true ==>\n            exists|k: int| 0 <= k < result@.len() && #[trigger] result@[k] == arr@[i],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0564", "language": "verus", "source": "numpy_triple", "source_id": "sorting_searching_flatnonzero", "vc-description": "numpy.flatnonzero: Return indices that are non-zero in the flattened version of a.\n\nThis function returns the indices of all non-zero elements in the array.\nThe returned indices correspond to positions in the flattened array where\nthe elements are non-zero.\n\nFor example, if array is [1, 0, 3, 0, 5], the function returns [0, 2, 4]\nindicating that elements at positions 0, 2, and 4 are non-zero.\n\nSpecification: flatnonzero returns indices of all non-zero elements.\n\nPrecondition: True (no restrictions on input array)\nPostcondition: \n1. All returned indices correspond to non-zero elements in the original array\n2. All non-zero elements in the original array have their indices in the result\n3. The result contains no duplicate indices\n4. The result indices are sorted in ascending order\n\n/* All indices in result point to non-zero elements */\n\n/* All non-zero elements have their indices in result */\n\n/* Result contains no duplicate indices */\n\n/* Result indices are sorted in ascending order */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn flatnonzero(a: Vec<f64>) -> (result: Vec<usize>)\n    ensures\n\n        forall|i: int| 0 <= i < result@.len() ==> a[result@[i] as int] != 0.0,\n\n        forall|j: int| 0 <= j < a@.len() && a@[j] != 0.0 ==> exists|k: int| 0 <= k < result@.len() && result@[k] == j,\n\n        forall|i: int, j: int| 0 <= i < result@.len() && 0 <= j < result@.len() && i != j ==> result@[i] != result@[j],\n\n        forall|i: int, j: int| 0 <= i < j < result@.len() ==> result@[i] < result@[j],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0565", "language": "verus", "source": "numpy_triple", "source_id": "sorting_searching_lexsort", "vc-description": "Perform an indirect stable sort using a sequence of keys.\nGiven multiple sorting keys, lexsort returns an array of integer indices that \ndescribes the sort order by multiple columns. The last key in the sequence is used\nfor the primary sort order, ties are broken by the second-to-last key, and so on.\n\nSpecification: lexsort returns indices that lexicographically sort the keys.\nThe result is a permutation of indices where for any two positions i, j:\n- If primary key differs, sort by primary key\n- If primary key is equal, sort by second-to-last key, etc.\n- The sort is stable (preserves relative order of equal elements)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn lexsort(keys: Vec<Vec<i8>>) -> (indices: Vec<u8>)\n    requires \n        keys.len() > 0,\n        keys.len() > 0 ==> keys[0].len() > 0,\n        forall|i: int| 0 <= i < keys.len() ==> #[trigger] keys[i as int]@.len() == keys[0]@.len(),\n    ensures\n        indices@.len() == keys[0]@.len(),\n        /* indices contains all values from 0 to n-1 exactly once */\n        forall|i: int| 0 <= i < keys[0]@.len() ==> #[trigger] indices@.contains(i as u8),\n        forall|i: int, j: int| 0 <= i < indices@.len() && 0 <= j < indices@.len() && i != j ==> indices[i as int] != indices[j as int]", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0566", "language": "verus", "source": "numpy_triple", "source_id": "sorting_searching_msort", "vc-description": "Return a copy of an array sorted along the first axis (ascending order).\nThis is equivalent to np.sort(a, axis=0) in NumPy.\n\nSpecification: msort returns a sorted copy of the input array in ascending order.\nThe result is a permutation of the input array.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn msort(a: Vec<i8>) -> (result: Vec<i8>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int, j: int| 0 <= i < j < result.len() ==> result[i] as int <= result[j] as int,\n        result@.to_multiset() =~= a@.to_multiset(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0567", "language": "verus", "source": "numpy_triple", "source_id": "sorting_searching_nanargmax", "vc-description": "numpy.nanargmax: Returns the index of the maximum value in a vector, ignoring NaN values.\n\nReturns the index of the maximum value among all non-NaN elements in the array.\nRequires that at least one element is not NaN, otherwise it would raise an error.\n\nIn case of multiple occurrences of the maximum values, the indices\ncorresponding to the first occurrence are returned.\n\nThis function returns the position of the largest non-NaN element in the array.\n\nSpecification: numpy.nanargmax returns the index of the maximum non-NaN element.\n\nPrecondition: At least one element is not NaN\nPostcondition: The element at the returned index is not NaN, is the maximum \namong all non-NaN values, and is the first occurrence of such maximum value.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn nanargmax(a: Vec<i8>) -> (idx: usize)\n    requires \n        a@.len() > 0,\n    ensures \n        idx < a@.len(),\n        forall|j: int| 0 <= j < a@.len() ==> a@[j] <= a@[idx as int],\n        forall|j: int| 0 <= j < a@.len() && a@[j] == a@[idx as int] ==> (idx as int) <= j,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0568", "language": "verus", "source": "numpy_triple", "source_id": "sorting_searching_nanargmin", "vc-description": "numpy.nanargmin: Return the indices of the minimum values in the specified axis ignoring NaNs.\n\nFor all-NaN slices ValueError is raised. Warning: the results cannot be trusted \nif a slice contains only NaNs and Infs.\n\nThis function finds the index of the minimum value in a vector, ignoring NaN values.\nIf all values are NaN, it should raise an error (represented as a precondition).\n\nParameters:\n- a : Vector Float n - Input data vector\n\nReturns:\n- Fin n - Index of the minimum non-NaN value\n\nSpecification: nanargmin returns the index of the minimum non-NaN value.\n\nPrecondition: At least one element in the vector is not NaN\nPostcondition: \n1. The returned index points to a non-NaN value\n2. All non-NaN values at other indices are greater than or equal to the value at the returned index\n3. If there are ties, returns the first occurrence (smallest index)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn nanargmin(a: Vec<i8>) -> (result: usize)\n    requires \n        a.len() > 0,\n    ensures\n        result < a.len(),\n        forall|j: int| 0 <= j < a@.len() ==> a[result as int] <= a[j],\n        forall|j: int| 0 <= j < result ==> a[j] > a[result as int],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0569", "language": "verus", "source": "numpy_triple", "source_id": "sorting_searching_nonzero", "vc-description": "numpy.nonzero: Return the indices of the elements that are non-zero.\n\nReturns a vector of indices where the corresponding elements in the input\narray are non-zero. The indices are returned in row-major, C-style order.\n\nFor a 1D array, this returns a vector containing all indices i such that\na[i] ≠ 0. Since the output size depends on the input values, we use\na Vec structure to accommodate the dynamic nature of the result.\n\nNote: In the full NumPy implementation, this returns a tuple of arrays\n(one for each dimension), but for 1D arrays we simplify to a single vector.\n\nSpecification: numpy.nonzero returns indices of all non-zero elements.\n\nPrecondition: True (no constraints on input)\nPostcondition: \n1. Every index in the result corresponds to a non-zero element in the input\n2. Every non-zero element in the input has its index in the result (completeness)\n3. The indices are in ascending order (preserving array order)\n4. No duplicates in the result", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn nonzero(a: Vec<f32>) -> (indices: Vec<usize>)\n    ensures\n        forall|i: int| 0 <= i < indices.len() ==> (indices[i] < a.len() && a[indices[i] as int] != 0.0f32),\n        forall|j: int| 0 <= j < a.len() ==> (a[j] != 0.0f32 <==> exists|k: int| 0 <= k < indices.len() && indices[k] == j),\n        forall|i1: int, i2: int| 0 <= i1 < i2 < indices.len() ==> indices[i1] < indices[i2],\n        forall|i: int, j: int| 0 <= i < j < indices.len() ==> indices[i] != indices[j],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0570", "language": "verus", "source": "numpy_triple", "source_id": "sorting_searching_partition", "vc-description": "Return a partitioned copy of an array around the k-th element.\n\nSpecification: partition rearranges elements so that the k-th element is in its sorted position,\nwith smaller elements before it and equal/greater elements after it.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_sorted(arr: Seq<i32>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < arr.len() ==> arr[i] <= arr[j]\n}\n\nspec fn count_occurrences(arr: Seq<i32>, x: i32) -> nat \n    decreases arr.len()\n{\n    if arr.len() == 0 {\n        0nat\n    } else {\n        let first_count: nat = if arr[0] == x { 1nat } else { 0nat };\n        first_count + count_occurrences(arr.skip(1), x)\n    }\n}\n\nspec fn multiset_equal(arr1: Seq<i32>, arr2: Seq<i32>) -> bool {\n    arr1.len() == arr2.len() &&\n    forall|x: i32| count_occurrences(arr1, x) == count_occurrences(arr2, x)\n}\n\nfn partition(arr: Vec<i32>, kth: usize) -> (result: Vec<i32>)\n    requires kth < arr.len(),\n    ensures\n        result.len() == arr.len(),\n        /* All elements before kth are <= the kth element */\n        forall|i: int| 0 <= i < kth as int ==> result@[i] <= result@[kth as int],\n        /* All elements after kth are >= the kth element */\n        forall|i: int| (kth as int) < i < (result@.len()) ==> result@[i] >= result@[kth as int],\n        /* The k-th element is in its correct sorted position relative to the original array */\n        exists|sorted: Seq<i32>| \n            is_sorted(sorted) &&\n            multiset_equal(sorted, arr@) &&\n            result@[kth as int] == sorted[kth as int],\n        /* The result contains the same elements as the original (multiset equality) */\n        multiset_equal(result@, arr@)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0571", "language": "verus", "source": "numpy_triple", "source_id": "sorting_searching_searchsorted", "vc-description": "numpy.searchsorted: Find indices where elements should be inserted to maintain order.\n\nGiven a sorted array `a` and values `v`, returns indices such that inserting \neach element of `v` at the corresponding index would preserve the sorted order of `a`.\n\nThis implementation focuses on the 'left' side behavior where for each value v[i],\nit returns the leftmost suitable insertion position. The returned indices are\nin the range [0, n] where n is the length of the sorted array.\n\nSpecification: numpy.searchsorted returns indices for sorted insertion.\n\nPrecondition: The input array `a` must be sorted in ascending order\nPostcondition: For each element v[i], the returned index idx satisfies:\n- All elements before idx are strictly less than v[i] (left insertion property)\n- All elements at or after idx are greater than or equal to v[i] (sorted property)\n- The index is valid for insertion (between 0 and n inclusive)\n- Inserting v[i] at idx preserves the sorted order of the array", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_searchsorted(a: Vec<i8>, v: Vec<i8>) -> (result: Vec<usize>)\n    requires \n        forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] as int <= a[j] as int,\n    ensures \n        result.len() == v.len()", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0572", "language": "verus", "source": "numpy_triple", "source_id": "sorting_searching_sort", "vc-description": "numpy.sort: Return a sorted copy of an array.\n\nReturns a new array with the same elements sorted in ascending order.\nThe original array is not modified. This function performs a stable sort \non the array elements, meaning that when multiple records have the same key,\ntheir original order is preserved.\n\nParameters:\n- a : array_like - Array to be sorted\n\nReturns:\n- sorted_array : ndarray - Array of the same type and shape as a, with elements sorted\n\nSpecification: numpy.sort returns a sorted permutation of the input array.\n\nThe specification captures three key properties:\n1. Sorting property: Elements are in non-decreasing order\n2. Permutation property: The result contains exactly the same elements as the input\n3. Stability property: Relative order of equal elements is preserved (implicit in permutation)\n\nPrecondition: True (works for any vector)\nPostcondition: Result is sorted and is a permutation of the input", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn count_occurrences(seq: Seq<i32>, x: i32) -> int\n    decreases seq.len()\n{\n    if seq.len() == 0 {\n        0int\n    } else {\n        (if seq[0] == x { 1int } else { 0int }) + count_occurrences(seq.skip(1), x)\n    }\n}\n\nfn sort(a: Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int, j: int| 0 <= i < j < result.len() ==> result[i] <= result[j],\n        forall|x: i32| count_occurrences(result@, x) == count_occurrences(a@, x)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0573", "language": "verus", "source": "numpy_triple", "source_id": "sorting_searching_unique", "vc-description": "numpy.unique: Find the unique elements of an array.\n\nReturns the sorted unique elements of an array. This operation removes\nduplicate values and returns them in sorted order. The result contains\neach unique value exactly once.\n\nFor a 1D array, this function eliminates duplicate elements and sorts\nthe remaining unique elements in ascending order.\n\nThe returned array will have size less than or equal to the input array,\nwith equality only when all elements are already unique.\n\nSpecification: numpy.unique returns sorted unique elements without duplicates.\n\nPrecondition: True (no special preconditions)\nPostcondition: The result contains all unique elements from the input array,\nsorted in ascending order, with no duplicates, and every element in the \nresult appears in the original array.\n\n// The result is sorted in ascending order\n\n// No duplicates in the result", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn unique(ar: Vec<i8>) -> (result: (usize, Vec<i8>))\n    ensures\n        result.1.len() <= ar.len(),\n\n        forall|i: int, j: int| 0 <= i < j < result.1.len() ==> result.1[i as int] as int <= result.1[j as int] as int,\n\n        forall|i: int, j: int| 0 <= i < result.1.len() && 0 <= j < result.1.len() && i != j ==> result.1[i as int] != result.1[j as int],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0574", "language": "verus", "source": "numpy_triple", "source_id": "sorting_searching_where", "vc-description": "Return elements chosen from x or y depending on condition.\nFor each position i, if condition[i] is True, take x[i], otherwise take y[i].\n\nSpecification: numpy_where returns an array where elements are chosen from x when condition is True,\nand from y when condition is False.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_where(condition: Vec<bool>, x: Vec<f32>, y: Vec<f32>) -> (result: Vec<f32>)\n    requires \n        condition@.len() == x@.len(),\n        condition@.len() == y@.len(),\n    ensures \n        result@.len() == condition@.len(),\n        forall|i: int| 0 <= i < condition@.len() ==> \n            (condition@[i] ==> result@[i] == x@[i]) &&\n            (!condition@[i] ==> result@[i] == y@[i])", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0575", "language": "verus", "source": "numpy_triple", "source_id": "statistics_amax", "vc-description": "Returns the maximum value of all elements in a non-empty vector.\nSpecification: amax returns the maximum value in the vector.\nMathematical properties:\n1. The result is an element that exists in the vector\n2. No element in the vector is greater than the result\n3. The result is unique (first occurrence if there are duplicates)\n4. For constant vectors, amax equals the constant value", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn amax(a: Vec<i8>) -> (result: i8)\n    requires a.len() > 0,\n    ensures\n        (exists|max_idx: int| 0 <= max_idx < a.len() &&\n            result as int == a@[max_idx] as int &&\n            (forall|i: int| 0 <= i < a.len() ==> a@[i] as int <= result as int)) &&\n        (exists|first_max_idx: int| 0 <= first_max_idx < a.len() &&\n            result as int == a@[first_max_idx] as int &&\n            (forall|i: int| 0 <= i < a.len() && a@[i] as int == result as int ==> first_max_idx <= i) &&\n            (forall|i: int| 0 <= i < a.len() ==> a@[i] as int <= result as int)) &&\n        ((forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() ==> a@[i] as int == a@[j] as int) ==> \n            result as int == a@[0] as int) &&\n        (exists|witness: int| 0 <= witness < a.len() && result as int == a@[witness] as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0576", "language": "verus", "source": "numpy_triple", "source_id": "statistics_amin", "vc-description": "Return the minimum of an array or minimum along an axis.\n\nThis is an alias for numpy.min that returns the minimum value among all elements in the array.\nRequires a non-empty array since there is no minimum of an empty set.\n\nThis is a reduction operation that finds the smallest value in the array.\nNaN values are propagated - if any element is NaN, the result will be NaN.\n\nSpecification: amin returns the minimum element in the vector.\n\nPrecondition: True (non-empty constraint is enforced by type Vector Float (n + 1))\nPostcondition: result is the minimum value and is an element of the vector\n\nProperties:\n1. The result is actually an element of the input vector\n2. The result is less than or equal to all elements in the vector\n3. This captures the mathematical definition of minimum", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn in_array(result: f32, a: Seq<f32>) -> bool {\n    exists|i: int| 0 <= i < a.len() && result == a[i]\n}\n\nfn amin(a: Vec<f32>) -> (result: f32)\n    requires a.len() > 0,\n    ensures in_array(result, a@),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0577", "language": "verus", "source": "numpy_triple", "source_id": "statistics_average", "vc-description": "Computes the weighted average along the specified axis.\n\nComputes the weighted average of the elements in the input vector.\nIf weights are not provided, it computes the arithmetic mean.\nIf weights are provided, it computes the weighted average where each\nelement contributes according to its associated weight.\n\nThe weighted average is computed as:\nsum(a * weights) / sum(weights)\n\nWhen weights are not provided, this reduces to:\nsum(a) / len(a)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn average(a: Vec<i8>, weights: Option<Vec<i8>>) -> (result: i8)\n    requires \n        a.len() > 0,\n        match weights {\n            Some(w) => w.len() == a.len(),\n            None => true,\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0578", "language": "verus", "source": "numpy_triple", "source_id": "statistics_corrcoef", "vc-description": "numpy.corrcoef: Return Pearson product-moment correlation coefficients.\n\nThe correlation coefficient measures the linear relationship between two variables.\nFor two vectors x and y, the correlation coefficient is computed as:\n\ncorr(x, y) = cov(x, y) / (std(x) * std(y))\n\nWhere:\n- cov(x, y) is the covariance between x and y\n- std(x) and std(y) are the standard deviations of x and y\n\nThis function computes the correlation coefficient between two vectors of observations.\nThe result is bounded between -1 and 1, where:\n- 1 indicates perfect positive correlation\n- -1 indicates perfect negative correlation  \n- 0 indicates no linear correlation\n\nRequires non-empty vectors and non-zero variance in both variables.\n\nSpecification: corrcoef computes the Pearson correlation coefficient between two vectors.\n\nThe correlation coefficient satisfies several mathematical properties:\n1. Symmetry: corr(x, y) = corr(y, x)\n2. Bounded: -1 ≤ corr(x, y) ≤ 1\n3. Self-correlation: corr(x, x) = 1 (if x has non-zero variance)\n4. Scale invariance: correlation is preserved under linear transformations\n\nPrecondition: Both vectors have non-zero variance (not all elements equal)\nPostcondition: Result is bounded between -1 and 1, and captures linear relationship", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn corrcoef(x: Vec<i8>, y: Vec<i8>) -> (result: i8)\n    requires \n        x.len() == y.len(),\n        x.len() > 0,\n        exists|i: int, j: int| 0 <= i < x.len() && 0 <= j < x.len() && x[i] != x[j],\n        exists|i: int, j: int| 0 <= i < y.len() && 0 <= j < y.len() && y[i] != y[j],\n    ensures\n        -100 <= result as int && result as int <= 100", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0579", "language": "verus", "source": "numpy_triple", "source_id": "statistics_correlate", "vc-description": "Cross-correlation of two 1-dimensional sequences in 'valid' mode.\nComputes c_k = sum_i a_{k+i} * v_i for positions where both sequences fully overlap.\n\nSpecification: correlate computes cross-correlation with valid mode overlap.\nEach output element is the sum of products of overlapping elements from the input sequences.\n\nMathematical properties:\n1. The result has size (m + 1 - n) for valid mode\n2. Each output element k is computed as: sum_i a[k+i] * v[i] for i in [0, n-1]\n3. Only positions where both sequences fully overlap are computed\n4. The correlation preserves the mathematical definition of cross-correlation", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn correlation_sum(a: Seq<i32>, v: Seq<i32>, k: int) -> int\n    decreases v.len()\n{\n    if v.len() == 0 {\n        0\n    } else {\n        a[k] * v[0] + correlation_sum(a, v.skip(1), k + 1)\n    }\n}\n\nfn correlate(a: Vec<i32>, v: Vec<i32>) -> (result: Vec<i32>)\n    requires \n        v.len() > 0,\n        v.len() <= a.len(),\n    ensures\n        result.len() == a.len() + 1 - v.len(),\n        forall|k: int| 0 <= k < result.len() ==> \n            result[k] == correlation_sum(a@, v@, k),", "vc-code": "{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0580", "language": "verus", "source": "numpy_triple", "source_id": "statistics_cov", "vc-description": "numpy.cov: Estimate a covariance matrix, given data and weights.\n\nCovariance indicates the level to which two variables vary together. \nIf we examine N-dimensional samples, X = [x_1, x_2, ... x_N]^T, \nthen the covariance matrix element C_{ij} is the covariance of x_i and x_j. \nThe element C_{ii} is the variance of x_i.\n\nFor a matrix with `vars` variables and `obs` observations:\n- Each row represents a variable\n- Each column represents an observation\n- Returns a vars × vars covariance matrix\n\nThis implementation focuses on the basic unweighted case without bias correction.\n\nSpecification: numpy.cov computes the covariance matrix from data matrix m.\n\nGiven a data matrix m where each row is a variable and each column is an observation,\nthe covariance matrix C has the following mathematical properties:\n\n1. Symmetry: C[i,j] = C[j,i] for all i,j\n2. Diagonal elements are variances: C[i,i] = Var(X_i)\n3. Off-diagonal elements are covariances: C[i,j] = Cov(X_i, X_j)\n4. Positive semi-definite: all eigenvalues ≥ 0\n\nThe covariance between variables i and j is computed as:\nCov(X_i, X_j) = E[(X_i - μ_i)(X_j - μ_j)]\nwhere μ_i is the mean of variable i.\n\nPrecondition: At least one observation (obs > 0)\nPostcondition: Returns a symmetric positive semi-definite covariance matrix", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn seq_sum(s: Seq<i32>) -> int {\n    s.fold_left(0, |acc: int, x: i32| acc + x)\n}\n\nspec fn variable_mean(var_data: Seq<i32>) -> int {\n    if var_data.len() == 0 {\n        0\n    } else {\n        seq_sum(var_data) / (var_data.len() as int)\n    }\n}", "vc-spec": "fn numpy_cov(m: Vec<Vec<i8>>) -> (cov_matrix: Vec<Vec<i8>>)\n    requires \n        m.len() > 0,\n        forall|i: int| 0 <= i < m.len() ==> m[i].len() > 0,\n        forall|i: int, j: int| 0 <= i < m.len() && 0 <= j < m.len() ==> m[i].len() == m[j].len(),\n    ensures \n        cov_matrix.len() == m.len(),\n        forall|i: int| 0 <= i < cov_matrix.len() ==> cov_matrix[i].len() == m.len(),\n        forall|i: int, j: int| 0 <= i < m.len() && 0 <= j < m.len() ==> \n            cov_matrix[i][j] == cov_matrix[j][i],\n        forall|i: int| 0 <= i < m.len() ==> (cov_matrix[i][i] as int) >= 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0582", "language": "verus", "source": "numpy_triple", "source_id": "statistics_histogram", "vc-description": "numpy.histogram: Compute the histogram of a dataset.\n\nComputes the histogram of a dataset by dividing the range into equal-width bins\nand counting the number of values that fall into each bin.\n\nThe function returns both the histogram counts and the bin edges.\nFor n_bins bins, there are n_bins+1 bin edges.\n\nThis implementation focuses on the core mathematical properties:\n- Monotonically increasing bin edges\n- Equal bin widths (uniform binning)\n- Correct counting of values in each bin\n- Conservation of total count\n\nSpecification: histogram correctly partitions data into bins and counts occurrences.\n\nThe histogram satisfies fundamental mathematical properties:\n1. Bin edges are monotonically increasing\n2. The first edge equals min_val and the last edge equals max_val\n3. Bin widths are equal for uniform binning\n4. Each bin count equals the number of data points in that bin\n5. The sum of all bin counts equals the number of data points in range\n\nPrecondition: Number of bins > 0 and min_val < max_val\nPostcondition: The result satisfies the histogram mathematical properties\n\n// Boundary conditions: first edge is min_val, last edge is max_val\n\n// Result histogram has correct length\n\n// Conservation: total count equals number of data points in range", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sum_seq(s: Seq<usize>) -> nat \n    decreases s.len()\n{\n    if s.len() == 0 {\n        0nat\n    } else {\n        (s[0] as nat) + sum_seq(s.drop_first())\n    }\n}", "vc-helpers": "", "vc-spec": "fn histogram(data: Vec<i8>, n_bins: usize, min_val: i8, max_val: i8) -> (result: (Vec<usize>, Vec<i8>))\n    requires\n        n_bins > 0,\n        (min_val as int) < (max_val as int),\n    ensures\n\n        result.1.len() == n_bins + 1,\n        result.1[0] == min_val,\n        result.1[(n_bins as int)] == max_val,\n\n        result.0.len() == n_bins,\n\n        sum_seq(result.0@) == data@.filter(|x: i8| (min_val as int) <= (x as int) && (x as int) <= (max_val as int)).len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0583", "language": "verus", "source": "numpy_triple", "source_id": "statistics_histogram2d", "vc-description": "Computes the bi-dimensional histogram of two data samples with equal number of bins.\n\nSpecification: histogram2d computes a 2D histogram from two equal-length vectors.\nMathematical properties:\n1. Input vectors must have the same length (enforced by type system)\n2. The histogram matrix has dimensions (nbins, nbins) where nbins = bins\n3. Each histogram bin counts the number of points falling within its boundaries\n4. The bin edges define the boundaries for both x and y dimensions\n5. The total count equals the input vector length\n6. All histogram values are non-negative\n7. Bin edges are monotonically increasing", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn histogram2d(x: &Vec<i8>, y: &Vec<i8>, bins: u8) -> (result: (Vec<Vec<u8>>, Vec<i8>, Vec<i8>))\n    requires \n        x@.len() == y@.len(),\n        bins > 0,\n    ensures\n        result.0@.len() == bins as nat,\n        forall|i: int| 0 <= i < bins as int ==> result.0@[i]@.len() == bins as nat,\n        result.1@.len() == bins as nat + 1,\n        result.2@.len() == bins as nat + 1,\n        forall|i: int, j: int| 0 <= i < bins as int && 0 <= j < bins as int ==> result.0@[i]@[j] as nat <= x@.len(),\n        forall|i: int| 0 <= i < bins as int ==> #[trigger] result.1@[i] as int <= result.1@[i + 1] as int,\n        forall|i: int| 0 <= i < bins as int ==> #[trigger] result.2@[i] as int <= result.2@[i + 1] as int,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0584", "language": "verus", "source": "numpy_triple", "source_id": "statistics_histogram_bin_edges", "vc-description": "Function to calculate only the edges of the bins used by the histogram function.\nCalculate the bin edges for histogram computation with equal-width bins.\nTakes non-empty data and number of bins, returns bin edges.\nSpecification: histogram_bin_edges computes equal-width bin edges from data range.\nThis comprehensive specification captures:\n1. The number of returned edges equals num_bins + 1\n2. The edges are monotonically increasing (strictly ordered)\n3. The first edge is at or below the minimum data value\n4. The last edge is at or above the maximum data value\n5. The edges are evenly spaced (equal width bins)\n6. All data values fall within the range [first_edge, last_edge]\n7. The bin width is consistent across all bins\n8. The function handles non-empty data correctly", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn histogram_bin_edges(data: Vec<i8>, num_bins: usize) -> (edges: Vec<i8>)\n    requires \n        data.len() > 0,\n        num_bins > 0,\n    ensures\n        edges.len() == num_bins + 1,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0585", "language": "verus", "source": "numpy_triple", "source_id": "statistics_histogramdd", "vc-description": "Compute the multidimensional histogram of some data.\nFor simplicity, we focus on 2D histograms with fixed dimensions.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn histogramdd(sample: Vec<(i32, i32)>, bins_x: usize, bins_y: usize) -> (result: (Vec<Vec<i32>>, Vec<i32>, Vec<i32>))\n    requires \n        bins_x > 0,\n        bins_y > 0,\n    ensures \n        ({\n            let (hist, edges_x, edges_y) = result;\n            hist.len() == bins_y &&\n            (forall|i: int| 0 <= i < hist.len() ==> #[trigger] hist[i].len() == bins_x) &&\n            edges_x.len() == bins_x + 1 &&\n            edges_y.len() == bins_y + 1 &&\n            (forall|i: int| 0 <= i < bins_x ==> #[trigger] edges_x[i] < edges_x[i + 1]) &&\n            (forall|i: int| 0 <= i < bins_y ==> #[trigger] edges_y[i] < edges_y[i + 1]) &&\n            (forall|i: int, j: int| 0 <= i < bins_y && 0 <= j < bins_x ==> #[trigger] hist[i][j] >= 0) &&\n            true\n        })", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0586", "language": "verus", "source": "numpy_triple", "source_id": "statistics_max", "vc-description": "Returns the maximum value of all elements in a non-empty vector.\nThis is an alias for numpy.amax that returns the maximum value among all elements in the array.\n\nMathematical Properties:\n- Returns an element that exists in the vector\n- No element in the vector is greater than the returned value\n- For constant vectors, returns the constant value\n- Handles non-empty vectors only (n + 1 elements)\n\nSpecification: max returns the maximum value in the vector.\nThis specification delegates to amax_spec since max is an alias for amax.\n\nMathematical properties:\n1. The result is an element that exists in the vector\n2. No element in the vector is greater than the result\n3. The result is unique (first occurrence if there are duplicates)\n4. For constant vectors, max equals the constant value\n5. Sanity check: the maximum exists in the vector", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn max(a: Vec<i8>) -> (result: i8)\n    requires a.len() > 0,\n    ensures\n        /* Core property: result is the maximum element in the vector */\n        exists|max_idx: int| 0 <= max_idx < a.len() &&\n            result as int == a[max_idx as int] as int &&\n            forall|i: int| 0 <= i < a.len() ==> a[i as int] as int <= result as int,\n        /* Uniqueness: result is the first occurrence of the maximum */\n        exists|first_max_idx: int| 0 <= first_max_idx < a.len() &&\n            result as int == a[first_max_idx as int] as int &&\n            (forall|i: int| 0 <= i < a.len() && a[i as int] as int == result as int ==> first_max_idx <= i) &&\n            (forall|i: int| 0 <= i < a.len() ==> a[i as int] as int <= result as int),\n        /* For constant vectors, max equals the constant */\n        (forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() ==> a[i as int] as int == a[j as int] as int) ==>\n            result as int == a[0] as int,\n        /* Sanity check: the maximum exists in the vector */\n        exists|witness: int| 0 <= witness < a.len() && result as int == a[witness as int] as int,", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0587", "language": "verus", "source": "numpy_triple", "source_id": "statistics_mean", "vc-description": "Computes the arithmetic mean of all elements in a non-empty vector.\nSpecification: mean computes the arithmetic average of all elements.\nMathematical properties:\n1. The result is the sum of all elements divided by the count\n2. The mean lies between the minimum and maximum values\n3. For constant vectors, mean equals the constant value", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn vec_sum(a: Seq<i32>) -> int \n    decreases a.len()\n{\n    if a.len() == 0 {\n        0\n    } else {\n        a[0] as int + vec_sum(a.skip(1))\n    }\n}\n\nspec fn all_equal(a: Seq<i32>) -> bool {\n    forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() ==> a[i] == a[j]\n}\n\nfn mean(a: Vec<i32>) -> (result: i32)\n    requires a.len() > 0,\n    ensures \n        /* Core property: mean * count == sum */\n        (result as int) * (a.len() as int) == vec_sum(a@),\n        /* For constant vectors, mean equals the constant */\n        all_equal(a@) ==> result == a[0]", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0588", "language": "verus", "source": "numpy_triple", "source_id": "statistics_median", "vc-description": "Compute the median along the specified axis.\n\nCompute the median of a vector.\nFor odd-length vectors, returns the middle value of the sorted array.\nFor even-length vectors, returns the average of the two middle values.\n\nSpecification: median returns the middle value(s) of a sorted vector.\n- For odd length (n+1), the median is the middle element when sorted\n- For even length (n+1), the median is the average of the two middle elements when sorted\n- The median divides the data such that approximately half the values are ≤ it,\n  and approximately half are ≥ it", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_sorted(a: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j]\n}\n\nfn median(a: Vec<i8>) -> (result: i8)\n    requires a.len() > 0,\n    ensures \n        exists|sorted: Seq<int>| #[trigger] sorted.len() == a@.len() &&\n            is_sorted(sorted) &&\n            (if a.len() % 2 == 1 {\n                result as int == sorted[((a.len() - 1) / 2) as int]\n            } else {\n                result as int == (sorted[(a.len() / 2 - 1) as int] + sorted[(a.len() / 2) as int]) / 2\n            })", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0589", "language": "verus", "source": "numpy_triple", "source_id": "statistics_min", "vc-description": "numpy.min: Return the minimum of an array or minimum along an axis.\n\nThis function is an alias for numpy.amin that returns the minimum value \namong all elements in the array. Requires a non-empty array since there \nis no minimum of an empty set.\n\nThis is a reduction operation that finds the smallest value in the array.\nNaN values are propagated - if any element is NaN, the result will be NaN.\n\nBeing an alias, it has identical behavior to amin but provides a more\nintuitive name for the operation.\n\nSpecification: min returns the minimum element in the vector.\n\nPrecondition: True (non-empty constraint is enforced by type Vector Float (n + 1))\nPostcondition: result is the minimum value and is an element of the vector\n\nProperties:\n1. The result is actually an element of the input vector\n2. The result is less than or equal to all elements in the vector\n3. This captures the mathematical definition of minimum\n4. As an alias for amin, it has identical mathematical properties", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn min(a: Vec<i8>) -> (result: i8)\n    requires a.len() > 0,\n    ensures\n        exists|i: int| 0 <= i < a@.len() && a@[i] == result as int,\n        forall|i: int| 0 <= i < a@.len() ==> result as int <= a@[i],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0590", "language": "verus", "source": "numpy_triple", "source_id": "statistics_nanmax", "vc-description": "Returns the maximum value of all elements in a non-empty vector, ignoring NaN values.\nWhen all elements are NaN, returns NaN.\n\nMathematical Properties:\n- Ignores NaN values in the computation\n- Returns the maximum of all non-NaN elements\n- If all elements are NaN, returns NaN\n- If at least one element is not NaN, returns the maximum non-NaN value\n- For vectors with no NaN values, behaves identically to regular max\n\nSpecification: nanmax returns the maximum value in the vector, ignoring NaN values.\n\nMathematical properties:\n1. If there exists at least one non-NaN element, the result is the maximum among non-NaN elements\n2. If all elements are NaN, the result is NaN\n3. The result is either a non-NaN element from the vector or NaN\n4. For vectors without NaN values, nanmax behaves identically to regular max\n5. NaN values are completely ignored during the maximum computation\n6. Sanity check: result is either NaN or exists in the vector", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn nanmax(a: Vec<i8>) -> (result: i8)\n    requires a.len() > 0,\n    ensures\n        /* Case 1: If there exists at least one element, the result is from the vector */\n        (exists|max_idx: int| \n            0 <= max_idx < a.len() &&\n            result as int == a[max_idx] as int) &&\n        /* Case 2: Result is maximum among all elements */\n        (forall|j: int| 0 <= j < a.len() ==> a[j] as int <= result as int) &&\n        /* Case 3: Result exists in the vector */\n        (exists|witness: int| 0 <= witness < a.len() && result as int == a[witness] as int)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0591", "language": "verus", "source": "numpy_triple", "source_id": "statistics_nanmean", "vc-description": "Compute the arithmetic mean along the specified axis, ignoring NaNs.\nReturns the average of the array elements, ignoring NaN values.\nIf all values are NaN, returns NaN.\n\nSpecification: nanmean computes the arithmetic mean while ignoring NaN values.\n\nMathematical properties:\n1. If vector contains valid (non-NaN) values, result is their arithmetic mean\n2. If all values are NaN, result is NaN\n3. Result is never NaN when valid values exist\n4. NaN values are completely ignored in the computation\n5. For vectors without NaN values, behaves identically to regular mean\n6. The result is bounded by the minimum and maximum of non-NaN elements\n\n/* Case 1: If there exists at least one non-NaN element, result is their arithmetic mean */\n\n/* Case 2: If all elements are NaN, result is NaN */\n\n/* Case 3: NaN values are ignored (result is mean of non-NaN elements) */\n\n/* Case 4: For vectors without NaN, behaves like regular mean */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_nan_f32(x: f32) -> bool;\n\nspec fn valid_indices_count(a: Seq<f32>) -> nat\n    decreases a.len()\n{\n    if a.len() == 0 {\n        0\n    } else {\n        if is_nan_f32(a[0]) {\n            valid_indices_count(a.skip(1))\n        } else {\n            1 + valid_indices_count(a.skip(1))\n        }\n    }\n}\n\nspec fn has_valid_element(a: Seq<f32>) -> bool \n{\n    valid_indices_count(a) > 0\n}\n\nspec fn all_nan(a: Seq<f32>) -> bool \n{\n    valid_indices_count(a) == 0\n}\n\nspec fn contains_nan(a: Seq<f32>) -> bool\n    decreases a.len()\n{\n    if a.len() == 0 {\n        false\n    } else {\n        is_nan_f32(a[0]) || contains_nan(a.skip(1))\n    }\n}\n\nfn nanmean(a: Vec<f32>) -> (result: f32)\n    ensures \n\n        (has_valid_element(a@) ==> !is_nan_f32(result)) &&\n\n        (all_nan(a@) ==> is_nan_f32(result)) &&\n\n        (!is_nan_f32(result) ==> has_valid_element(a@)) &&\n\n        (!contains_nan(a@) && a.len() > 0 ==> !is_nan_f32(result))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0592", "language": "verus", "source": "numpy_triple", "source_id": "statistics_nanmedian", "vc-description": "Compute the median along the specified axis, ignoring NaNs.\nReturns the median of the array elements.\nFor a vector V of length N, the median is the middle value of a sorted copy of V\n(ignoring NaN values), when N is odd, and the average of the two middle values when N is even.\nIf all values are NaN, returns NaN.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn all_nan(a: Seq<f32>) -> bool {\n    forall|i: int| #![auto] 0 <= i < a.len() ==> (a[i] != a[i])\n}\n\nspec fn has_finite_value(a: Seq<f32>) -> bool {\n    exists|i: int| #![auto] 0 <= i < a.len() && (a[i] == a[i])\n}\n\nfn nanmedian(a: Vec<f32>) -> (result: f32)\n    ensures\n        (all_nan(a@) ==> (result != result)) &&\n        (has_finite_value(a@) ==> (result == result))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0593", "language": "verus", "source": "numpy_triple", "source_id": "statistics_nanmin", "vc-description": "Returns the minimum value of all elements in a non-empty vector, ignoring NaN values.\nWhen all elements are NaN, returns NaN.\n\nMathematical Properties:\n- Ignores NaN values in the computation\n- Returns the minimum of all non-NaN elements\n- If all elements are NaN, returns NaN\n- If at least one element is not NaN, returns the minimum non-NaN value\n- For vectors with no NaN values, behaves identically to regular min\n\nSpecification: nanmin returns the minimum value in the vector, ignoring NaN values.\n\nMathematical properties:\n1. If there exists at least one non-NaN element, the result is the minimum among non-NaN elements\n2. If all elements are NaN, the result is NaN\n3. The result is either a non-NaN element from the vector or NaN\n4. For vectors without NaN values, nanmin behaves identically to regular min\n5. NaN values are completely ignored during the minimum computation\n6. Sanity check: result is either NaN or exists in the vector", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn all_nan(a: Seq<int>) -> bool \n    decreases a.len()\n{\n    false  /* integers can't be NaN */\n}\n\nspec fn has_non_nan(a: Seq<int>) -> bool \n    decreases a.len()\n{\n    a.len() > 0  /* all integers are non-NaN */\n}\n\nspec fn is_min_of_all(result: int, a: Seq<int>) -> bool {\n    exists|witness: int| 0 <= witness < a.len() &&\n        result == a[witness] &&\n        forall|j: int| 0 <= j < a.len() ==> result <= a[j]\n}\n\nfn nanmin(a: Vec<i8>) -> (result: i8)\n    requires a.len() > 0,\n    ensures is_min_of_all(result as int, a@.map(|i, x: i8| x as int))", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0594", "language": "verus", "source": "numpy_triple", "source_id": "statistics_nanpercentile", "vc-description": "Compute the q-th percentile of the data along the specified axis, ignoring NaN values.\nReturns the q-th percentile of the array elements.\nIf all values are NaN, returns NaN.\nThe percentile q must be between 0 and 100 inclusive.\n\nSpecification: nanpercentile computes the q-th percentile of non-NaN values in the array.\nThe result is NaN if all values are NaN, otherwise it's the q-th percentile of the finite values.\nThe percentile is computed by sorting the non-NaN values and finding the value at the position\ncorresponding to the percentile q (between 0 and 100).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn vec_sum(a: Seq<i32>) -> int \n    decreases a.len()\n{\n    if a.len() == 0 {\n        0\n    } else {\n        a[0] + vec_sum(a.skip(1))\n    }\n}\n\nfn nanpercentile(a: Vec<i8>, q: i8) -> (result: i8)\n    requires 0 <= q <= 100,\n    ensures\n        /* Case 1: Empty array returns 0 */\n        a.len() == 0 ==> result == 0,\n        /* Case 2: Non-empty array */\n        a.len() > 0 ==> {\n            /* Result is within bounds of input values */\n            (forall|i: int| 0 <= i < a.len() ==> a[i] as int <= result as int || result as int <= a[i] as int) &&\n            /* For single element, result equals that element */\n            (a.len() == 1 ==> result == a[0])\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0595", "language": "verus", "source": "numpy_triple", "source_id": "statistics_nanquantile", "vc-description": "Compute the q-th quantile of the data in a vector, ignoring NaN values.\nWhen all elements are NaN, returns NaN.\n\nMathematical Properties:\n- Ignores NaN values in the computation\n- Returns the q-th quantile of all non-NaN elements \n- If all elements are NaN, returns NaN\n- If at least one element is not NaN, returns the quantile of non-NaN values\n- For q=0, returns the minimum of non-NaN elements\n- For q=1, returns the maximum of non-NaN elements\n- For vectors with no NaN values, behaves identically to regular quantile\n\nSpecification: nanquantile returns the q-th quantile of non-NaN values in the vector.\n\nMathematical properties:\n1. The quantile parameter q must be between 0 and 1 inclusive\n2. If there exists at least one non-NaN element, the result is the q-th quantile among non-NaN elements\n3. If all elements are NaN, the result is NaN\n4. For q=0, result is the minimum of non-NaN elements\n5. For q=1, result is the maximum of non-NaN elements\n6. The result is bounded by the range of non-NaN elements\n7. NaN values are completely ignored during the quantile computation\n8. For vectors without NaN values, nanquantile behaves identically to regular quantile", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn nanquantile(a: Vec<i8>, q: i8) -> (result: i8)\n    requires \n        a.len() > 0,\n        0 <= q <= 100,\n    ensures\n        /* Result is bounded by the elements */\n        (forall|min_idx: int| 0 <= min_idx < a.len() ==> \n         (forall|j: int| 0 <= j < a.len() ==> a[min_idx] as int <= a[j] as int) ==> a[min_idx] as int <= result as int),\n        (forall|max_idx: int| 0 <= max_idx < a.len() ==>\n         (forall|j: int| 0 <= j < a.len() ==> a[j] as int <= a[max_idx] as int) ==> result as int <= a[max_idx] as int),\n        /* For q=0, result is the minimum element */\n        (q == 0) ==> \n            (forall|min_idx: int| 0 <= min_idx < a.len() ==>\n             (forall|j: int| 0 <= j < a.len() ==> a[min_idx] as int <= a[j] as int) ==>\n             result == a[min_idx]),\n        /* For q=100, result is the maximum element */\n        (q == 100) ==>\n            (forall|max_idx: int| 0 <= max_idx < a.len() ==>\n             (forall|j: int| 0 <= j < a.len() ==> a[j] as int <= a[max_idx] as int) ==>\n             result == a[max_idx])", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0596", "language": "verus", "source": "numpy_triple", "source_id": "statistics_nanstd", "vc-description": "Compute the standard deviation along the specified axis, ignoring NaNs.\nReturns the standard deviation, a measure of the spread of a distribution,\nof the non-NaN array elements. The standard deviation is the square root\nof the variance computed from non-NaN values.\n\nFor all-NaN slices, NaN is returned.\n\nSpecification: nanstd computes the standard deviation while ignoring NaN values.\nMathematical properties:\n1. If vector contains valid (non-NaN) values and ddof < valid_count, \n   result is the square root of the variance of valid values\n2. If all values are NaN, result is NaN\n3. If ddof >= valid_count, result is NaN\n4. Result is always non-negative when valid\n\nThe standard deviation is computed as:\n1. Filter out NaN values to get valid values\n2. Calculate the mean of valid values\n3. Calculate squared deviations from the mean for valid values\n4. Sum the squared deviations\n5. Divide by (valid_count - ddof)\n6. Take the square root of the result", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn count_valid_values(a: Seq<i32>) -> int {\n    a.filter(|x: i32| x != 0).len() as int\n}\n\nspec fn sum_valid_values(a: Seq<i32>) -> int \n    decreases a.len()\n{\n    if a.len() == 0 {\n        0\n    } else {\n        let x = a[0];\n        if x == 0 {\n            sum_valid_values(a.skip(1))\n        } else {\n            x + sum_valid_values(a.skip(1))\n        }\n    }\n}\n\nspec fn mean_of_valid(a: Seq<i32>) -> int {\n    let valid_count = count_valid_values(a);\n    if valid_count > 0 {\n        sum_valid_values(a) / valid_count\n    } else {\n        0\n    }\n}\n\nspec fn sum_squared_deviations_spec(a: Seq<i32>, mean: int) -> int \n    decreases a.len()\n{\n    if a.len() == 0 {\n        0\n    } else {\n        let x = a[0];\n        if x == 0 {\n            sum_squared_deviations_spec(a.skip(1), mean)\n        } else {\n            let deviation = x - mean;\n            deviation * deviation + sum_squared_deviations_spec(a.skip(1), mean)\n        }\n    }\n}\n\nspec fn variance_of_valid(a: Seq<i32>, ddof: int) -> int {\n    let valid_count = count_valid_values(a);\n    if valid_count > 0 && ddof < valid_count {\n        let mean = mean_of_valid(a);\n        let sum_squared_deviations = sum_squared_deviations_spec(a, mean);\n        sum_squared_deviations / (valid_count - ddof)\n    } else {\n        0\n    }\n}\n\nfn nanstd(a: Vec<i32>, ddof: usize) -> (result: i32)\n    ensures ({\n        let valid_count = count_valid_values(a@);\n        let ddof_int = ddof as int;\n        if valid_count > 0 && ddof_int < valid_count {\n            let variance = variance_of_valid(a@, ddof_int);\n            result >= 0\n        } else {\n            result == 0\n        }\n    })", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0597", "language": "verus", "source": "numpy_triple", "source_id": "statistics_nanvar", "vc-description": "Compute the variance along the specified axis, while ignoring NaNs.\nUses the formula: sum((x - mean)²) / (n - ddof) for non-NaN elements.\nReturns NaN if all elements are NaN or if degrees of freedom <= 0.\n\nSpecification for nanvar: Computes variance while ignoring NaN values.\nMathematical properties:\n1. If vector contains valid (non-NaN) values and ddof < valid_count, \n   result is the variance of valid values\n2. If all values are NaN, result is NaN\n3. If ddof >= valid_count, result is NaN\n4. Result is always non-negative when valid\n\nThe variance is computed as:\n1. Filter out NaN values to get valid values\n2. Calculate the mean of valid values\n3. Calculate squared deviations from the mean for valid values\n4. Sum the squared deviations\n5. Divide by (valid_count - ddof)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn nanvar(a: Vec<f32>, ddof: usize) -> (result: f32)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0598", "language": "verus", "source": "numpy_triple", "source_id": "statistics_percentile", "vc-description": "Compute the q-th percentile of the data in a vector.\nFor a sorted vector, the q-th percentile is the value below which q percent of the data falls.\nThis implementation focuses on the fundamental mathematical definition of percentiles.\n\nSpecification: percentile computes the q-th percentile value correctly.\nThe percentile is defined as the value v such that at least q% of the data\nis less than or equal to v, and at least (100-q)% of the data is greater than or equal to v.\n\nMathematical properties:\n1. The percentile value must be within the range of the data (or interpolated between values)\n2. Special cases: q=0 gives minimum, q=100 gives maximum\n3. The result is bounded by the minimum and maximum values in the array", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn percentile(arr: Vec<i8>, q: i8) -> (result: i8)\n    requires \n        arr.len() > 0,\n        0 <= q && q <= 100,\n    ensures\n        (forall|i: int| 0 <= i < arr.len() ==> arr[i] as int <= result as int ==> \n            exists|j: int| 0 <= j < arr.len() && arr[j] as int >= result as int) &&\n        (forall|i: int| 0 <= i < arr.len() ==> arr[i] as int >= result as int ==> \n            exists|j: int| 0 <= j < arr.len() && arr[j] as int <= result as int) &&\n        (q == 0 ==> forall|i: int| 0 <= i < arr.len() ==> result as int <= arr[i] as int) &&\n        (q == 100 ==> forall|i: int| 0 <= i < arr.len() ==> arr[i] as int <= result as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0599", "language": "verus", "source": "numpy_triple", "source_id": "statistics_quantile", "vc-description": "Compute the q-th quantile of the data in a vector\n\nSpecification: quantile returns a value that has the property that \napproximately q proportion of the data is less than or equal to it", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn quantile(a: Vec<i8>, q: i8) -> (result: i8)\n    requires \n        a.len() > 0,\n        0 <= q && q <= 100,\n    ensures\n        /* The result is within the range of the input data */\n        (exists|i: int| 0 <= i < a.len() && a[i] as i8 <= result) &&\n        (exists|i: int| 0 <= i < a.len() && result <= a[i] as i8) &&\n        /* For 0-quantile, result should be <= minimum */\n        (q == 0 ==> forall|i: int| 0 <= i < a.len() ==> result <= a[i] as i8) &&\n        /* For 100-quantile, result should be >= maximum */\n        (q == 100 ==> forall|i: int| 0 <= i < a.len() ==> a[i] as i8 <= result)", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0600", "language": "verus", "source": "numpy_triple", "source_id": "statistics_std", "vc-description": "numpy.std: Compute the standard deviation along the specified axis.\n\nReturns the standard deviation, a measure of the spread of a distribution,\nof the array elements. The standard deviation is computed for the flattened\narray by default, otherwise over the specified axis.\n\nThe standard deviation is the square root of the average of the squared\ndeviations from the mean: std = sqrt(mean((x - x.mean())**2)).\n\nWith ddof parameter, the divisor used in calculations is N - ddof,\nwhere N represents the number of elements. The \"Delta Degrees of Freedom\"\nparameter adjusts the divisor in the standard deviation calculation.\n\nSpecification: numpy.std returns the standard deviation of all elements.\n\nThe standard deviation is computed as the square root of the variance:\nstd = sqrt(sum((x_i - mean)²) / (N - ddof))\n\nKey properties:\n1. ddof must be less than the number of elements to avoid division by zero\n2. The result is always non-negative (square root of non-negative variance)\n3. When ddof = 0, uses population standard deviation (divide by N)\n4. When ddof = 1, uses sample standard deviation (divide by N-1)\n5. Mathematical correctness: the formula exactly matches NumPy's implementation", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_std(a: Vec<f32>, ddof: u8) -> (result: f32)\n    requires \n        a.len() > 0,\n        (ddof as usize) < a.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0601", "language": "verus", "source": "numpy_triple", "source_id": "statistics_var", "vc-description": "Compute the variance of the elements in a vector with specified delta degrees of freedom.\nThe variance is the average of the squared deviations from the mean.\n\nSpecification: var computes the variance as the average of squared deviations from the mean,\ndivided by (n + 1 - ddof). The variance measures the spread of a distribution.\n\nMathematical properties:\n1. The result is always non-negative\n2. The variance is zero if and only if all elements are equal\n3. The computation requires ddof < n + 1 to ensure a positive divisor\n4. The variance equals the expected value of squared deviations from the mean\n5. Translation invariance: var(a + c) = var(a) for any constant c\n6. Scaling property: var(c * a) = c^2 * var(a) for any constant c\n\nThe variance formula implemented is:\nvar = (1/(n+1-ddof)) * sum_{i=0}^{n} (a[i] - mean)^2\nwhere mean = (1/(n+1)) * sum_{i=0}^{n} a[i]\n\nThis specification captures both the mathematical definition of variance\nand its key properties. When ddof=0, this gives the population variance;\nwhen ddof=1, this gives the sample variance (unbiased estimator).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn vec_sum(a: Seq<int>) -> int \n    decreases a.len()\n{\n    if a.len() == 0 {\n        0\n    } else {\n        a[0] + vec_sum(a.skip(1))\n    }\n}\n\nspec fn vec_mean(a: Seq<int>) -> int \n{\n    vec_sum(a) / (a.len() as int)\n}\n\nspec fn squared_deviations_sum(a: Seq<int>, mean: int) -> int \n    decreases a.len()\n{\n    if a.len() == 0 {\n        0\n    } else {\n        (a[0] - mean) * (a[0] - mean) + squared_deviations_sum(a.skip(1), mean)\n    }\n}\n\nfn var(a: Vec<i8>, ddof: usize) -> (result: i8)\n    requires \n        a.len() > 0,\n        ddof < a.len(),\n    ensures \n        result >= 0,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0603", "language": "verus", "source": "numpy_triple", "source_id": "strings_capitalize", "vc-description": "Return a copy of a with only the first character of each element capitalized", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn capitalize(a: Vec<String>) -> (result: Vec<String>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> #[trigger] result[i]@.len() == a[i]@.len()", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0604", "language": "verus", "source": "numpy_triple", "source_id": "strings_center", "vc-description": "Return a copy of a with its elements centered in a string of length width.\n\nCenters strings in a field of given width with optional fill character.\nIf the original string length is greater than or equal to the target width,\nthe original string is returned unchanged. Otherwise, the string is padded\nsymmetrically with the fill character to reach the target width.\n\nFrom NumPy documentation:\n- Parameters: a (array_like with StringDType), width (array_like with integer dtype), \n              fillchar (optional, default ' ') - The padding character\n- Returns: out (ndarray) - Output array with centered strings\n\nMathematical Properties:\n1. Length preservation: If original.length >= width, return original unchanged\n2. Symmetric padding: If original.length < width, pad equally on both sides\n3. Padding balance: Left and right padding differ by at most 1 character\n4. Character preservation: Original string appears as substring in result\n5. Width compliance: Result length equals max(original.length, width)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn center(a: Vec<String>, width: Vec<usize>, fillchar: char) -> (result: Vec<String>)\n    requires \n        a.len() == width.len(),\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> \n            #[trigger] result[i]@.len() >= 0 && {\n                let orig_len = a[i]@.len() as int;\n                let target_width = width[i] as int;\n                &&& (orig_len >= target_width ==> result[i] == a[i])\n                &&& result[i]@.len() as int == if orig_len >= target_width { orig_len } else { target_width }\n            }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0605", "language": "verus", "source": "numpy_triple", "source_id": "strings_count", "vc-description": "numpy.strings.count: Returns an array with the number of non-overlapping occurrences \nof substring sub in the range [start, end] for each element.\n\nFor each string in the input array, counts how many times the substring appears\nwithout overlapping matches within the specified range. The search is performed\nwithin the range [start, end) where start and end are character indices.\n\nSpecification: numpy.strings.count returns the number of non-overlapping occurrences \nof substring within the specified range for each element.\n\nPreconditions:\n- start ≤ end for all elements (valid range)\n- start and end indices are valid (within string bounds)\n- substring is not empty for all elements (to avoid infinite loops)\n\nPostconditions:\n- Result is non-negative for all elements\n- For each element, the count represents non-overlapping occurrences of substring\n- If substring is longer than search range, count is 0\n- The count is maximal (greedy non-overlapping matching)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn count(a: Vec<String>, sub: Vec<String>, start: Vec<i8>, end_pos: Vec<i8>) -> (result: Vec<i8>)\n    requires \n        a.len() == sub.len(),\n        a.len() == start.len(),\n        a.len() == end_pos.len(),\n        forall|i: int| 0 <= i < a.len() ==> start[i] as int <= end_pos[i] as int,\n        forall|i: int| 0 <= i < a.len() ==> 0 <= start[i] as int && start[i] as int <= a[i]@.len(),\n        forall|i: int| 0 <= i < a.len() ==> 0 <= end_pos[i] as int && end_pos[i] as int <= a[i]@.len(),\n        forall|i: int| 0 <= i < a.len() ==> sub[i]@.len() > 0,\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] as int >= 0,\n        forall|i: int| 0 <= i < result.len() ==> \n            (sub[i]@.len() > (end_pos[i] as int - start[i] as int) ==> result[i] as int == 0)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0606", "language": "verus", "source": "numpy_triple", "source_id": "strings_decode", "vc-description": "numpy.strings.decode: Decode byte strings using the codec\n\nCalls bytes.decode element-wise on a vector of byte strings.\nConverts bytes to strings using the specified encoding.\n\nThis function takes a vector of byte strings and returns a vector\nof decoded strings. The decoding process depends on the encoding\nparameter, with UTF-8 being the default.\n\nSpecification: numpy.strings.decode returns a vector where each element is the decoded string\nfrom the corresponding byte array in the input vector.\n\nMathematical Properties:\n1. Element-wise decoding: result[i] = decode(a[i]) for all i\n2. Deterministic behavior: same input produces same output\n3. Empty byte arrays decode to empty strings\n4. Identity property: decoding is consistent with the specified encoding\n5. Length preservation: decoding preserves structural properties\n6. Error handling: behavior depends on error mode when invalid sequences are encountered\n\nPrecondition: ByteArray elements are well-formed\nPostcondition: Each element is the decoded string using the specified encoding with proper error handling", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn decode(a: Vec<Vec<u8>>, encoding: &str, errors: &str) -> (result: Vec<String>)\n    requires \n        encoding == \"utf-8\" || encoding == \"ascii\",\n        errors == \"strict\" || errors == \"ignore\" || errors == \"replace\",\n        forall|i: int| 0 <= i < a.len() as int ==> a[i]@.len() >= 0,\n    ensures\n        result.len() as int == a.len() as int,\n        forall|i: int| 0 <= i < a.len() as int ==> (\n            /* Basic well-formedness: decoded strings are valid */\n            result[i]@.len() >= 0 &&\n            \n            /* Deterministic behavior: identical inputs produce identical outputs */\n            (forall|j: int| 0 <= j < a.len() as int && a[i]@ == a[j]@ ==> result[i]@ == result[j]@) &&\n            \n            /* Empty byte arrays decode to empty strings */\n            (a[i]@.len() == 0 ==> result[i]@.len() == 0) &&\n            \n            /* Identity property: encoding then decoding with same parameters is identity for valid strings */\n            (encoding == \"utf-8\" ==> true) &&\n            \n            /* Error handling consistency: strict mode fails on invalid sequences */\n            (errors == \"strict\" ==> true) &&\n            \n            /* Length relationship: non-empty valid byte arrays produce strings */\n            (a[i]@.len() > 0 && encoding == \"utf-8\" ==> (\n                result[i]@.len() > 0 || errors != \"strict\"\n            ))\n        )", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0607", "language": "verus", "source": "numpy_triple", "source_id": "strings_encode", "vc-description": "numpy.strings.encode: Encode strings using the codec\n\nCalls str.encode element-wise on a vector of strings.\nConverts strings to byte arrays using the specified encoding.\n\nThis function takes a vector of strings and returns a vector\nof encoded byte arrays. The encoding process depends on the encoding\nparameter, with UTF-8 being the default.\n\nSpecification: numpy.strings.encode returns a vector where each element is the encoded byte array\nfrom the corresponding string in the input vector.\n\nKey properties:\n1. Deterministic encoding: same input produces same output\n2. Empty strings encode to empty byte arrays\n3. Encoding preserves string order and length\n4. For UTF-8 encoding, ASCII characters are preserved with same byte length", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn encode(a: Vec<Vec<char>>, encoding: Vec<char>, errors: Vec<char>) -> (result: Vec<Vec<u8>>)\n    ensures\n        result@.len() == a@.len(),\n        /* Deterministic encoding: same input produces same output */\n        forall|i: int, j: int| 0 <= i < a@.len() && 0 <= j < a@.len() && a@[i] == a@[j] ==> result@[i] == result@[j],\n        /* Empty strings encode to empty byte arrays */\n        forall|i: int| 0 <= i < a@.len() && a@[i].len() == 0 ==> result@[i].len() == 0,\n        /* Non-empty strings produce non-empty byte arrays */\n        forall|i: int| 0 <= i < a@.len() && a@[i].len() > 0 ==> result@[i].len() > 0,\n        /* For UTF-8 encoding, encoded size is at least the string length */\n        forall|i: int| 0 <= i < a@.len() ==> result@[i].len() >= a@[i].len(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0608", "language": "verus", "source": "numpy_triple", "source_id": "strings_endswith", "vc-description": "Check if strings in array end with given suffixes\n\nSpecification: endswith returns boolean array indicating which strings end with corresponding suffixes", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn string_ends_with(s: Seq<char>, suffix: Seq<char>) -> bool {\n    if suffix.len() > s.len() {\n        false\n    } else {\n        s.subrange(s.len() - suffix.len(), s.len() as int) == suffix\n    }\n}\n\nfn endswith(a: Vec<String>, suffix: Vec<String>) -> (result: Vec<bool>)\n    requires a.len() == suffix.len(),\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> {\n            /* Main specification: result matches string_ends_with for each pair */\n            result[i] == string_ends_with(a[i]@, suffix[i]@) &&\n            /* Mathematical property: if result is true, suffix appears at the end */\n            (result[i] ==> {\n                suffix[i]@.len() <= a[i]@.len() &&\n                a[i]@.subrange(a[i]@.len() - suffix[i]@.len(), a[i]@.len() as int) == suffix[i]@\n            }) &&\n            /* Mathematical property: if result is false, suffix does not appear at the end */\n            (!result[i] ==> {\n                suffix[i]@.len() > a[i]@.len() ||\n                a[i]@.subrange(a[i]@.len() - suffix[i]@.len(), a[i]@.len() as int) != suffix[i]@\n            })\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0609", "language": "verus", "source": "numpy_triple", "source_id": "strings_equal", "vc-description": "numpy.strings.equal: Return (x1 == x2) element-wise for string arrays.\n\nPerforms element-wise string comparison between two vectors of strings.\nReturns a boolean vector indicating whether corresponding strings are equal.\n\nThis function compares strings lexicographically and returns True for each\nposition where the strings are identical, False otherwise.\n\nSpecification: numpy.strings.equal returns element-wise equality comparison.\n\nPrecondition: True (no special preconditions for string equality)\nPostcondition: For all indices i, result[i] = (x1[i] == x2[i])\n\nMathematical Properties:\n- Core property: Each element of result is the boolean comparison of corresponding strings\n- Equivalence: result[i] is true if and only if x1[i] equals x2[i]\n- Reflexivity: If input vectors are identical, all result elements are true\n- Type-safe: Result vector has same length as input vectors", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn equal(x1: Vec<String>, x2: Vec<String>) -> (result: Vec<bool>)\n    requires x1.len() == x2.len(),\n    ensures\n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i as int] == (x1[i as int] == x2[i as int]),\n        forall|i: int| 0 <= i < result.len() ==> (result[i as int] == true <==> x1[i as int] == x2[i as int]),\n        x1@ == x2@ ==> forall|i: int| 0 <= i < result.len() ==> result[i as int] == true,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0610", "language": "verus", "source": "numpy_triple", "source_id": "strings_expandtabs", "vc-description": "Return a copy of each string element where all tab characters are replaced by spaces\n\nExpand tabs in strings to spaces with configurable tab size\n\nSpecification: expandtabs replaces tab characters with appropriate number of spaces\n\n/* Core property: result contains no tab characters */\n\n/* Identity property: strings without tabs remain unchanged */\n\n/* Length property: result is at least as long as original */\n\n/* Tab expansion property: tabs are replaced by 1 to tab_sz spaces */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn expandtabs(a: Vec<String>, tabsize: Vec<u8>) -> (result: Vec<String>)\n    requires \n        a.len() == tabsize.len(),\n        forall|i: int| 0 <= i < tabsize.len() ==> #[trigger] tabsize[i] > 0,\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> {\n            let orig_str = #[trigger] &a[i];\n            let result_str = &result[i];\n            let tab_sz = tabsize[i] as nat;\n\n            (forall|c: char| #[trigger] result_str@.contains(c) ==> c != '\\t') &&\n\n            (!orig_str@.contains('\\t') ==> result_str@ == orig_str@) &&\n\n            (result_str@.len() >= orig_str@.len()) &&\n\n            (orig_str@.contains('\\t') ==> result_str@.len() > orig_str@.len())\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0611", "language": "verus", "source": "numpy_triple", "source_id": "strings_find", "vc-description": "For each element, return the lowest index in the string where substring sub is found, such that sub is contained in the range [start, end]. Returns -1 if sub is not found.\n\n// Case 1: substring not found (returns -1)\n\n// Case 2: substring found (returns non-negative index)\n\n// Empty substring found at start position\n\n// Substring longer than remaining string cannot be found\n\n// If start > end, no substring can be found", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn find_substring_at(haystack: Seq<char>, needle: Seq<char>, pos: int) -> bool {\n    pos >= 0 && pos + needle.len() <= haystack.len() &&\n    haystack.subrange(pos, pos + needle.len()) == needle\n}\n\nfn find(a: Vec<String>, sub: Vec<String>, start: Vec<i32>, end_pos: Vec<i32>) -> (result: Vec<i32>)\n    requires \n        a.len() == sub.len() && \n        sub.len() == start.len() && \n        start.len() == end_pos.len(),\n        forall|i: int| 0 <= i < a.len() ==> \n            0 <= start[i] && \n            start[i] <= end_pos[i] && \n            end_pos[i] < a[i]@.len(),\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> {\n\n            (result[i] == -1 <==> \n                forall|pos: int| start[i] as int <= pos && pos <= end_pos[i] as int && pos + sub[i]@.len() <= a[i]@.len() ==>\n                    !find_substring_at(a[i]@, sub[i]@, pos)) &&\n\n            (result[i] >= 0 ==> \n                start[i] as int <= result[i] as int && \n                result[i] as int <= end_pos[i] as int &&\n                result[i] as int + sub[i]@.len() <= a[i]@.len() &&\n                find_substring_at(a[i]@, sub[i]@, result[i] as int) &&\n                forall|pos: int| start[i] as int <= pos && pos < result[i] as int ==> \n                    !find_substring_at(a[i]@, sub[i]@, pos)) &&\n\n            (sub[i]@.len() == 0 ==> result[i] == start[i]) &&\n\n            (start[i] as int + sub[i]@.len() > a[i]@.len() ==> result[i] == -1) &&\n\n            (start[i] > end_pos[i] ==> result[i] == -1)\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0612", "language": "verus", "source": "numpy_triple", "source_id": "strings_greater", "vc-description": "numpy.strings.greater: Return the truth value of (x1 > x2) element-wise for string arrays.\n\nPerforms element-wise string comparison between two vectors of strings.\nReturns a boolean vector indicating whether corresponding strings from x1 \nare lexicographically greater than corresponding strings from x2.\n\nThis function compares strings lexicographically and returns True for each\nposition where x1[i] > x2[i] in lexicographic ordering, False otherwise.\n\nSpecification: numpy.strings.greater returns element-wise lexicographic comparison.\n\nPrecondition: True (no special preconditions for string comparison)\nPostcondition: For all indices i, result[i] = (x1[i] > x2[i])\n\nMathematical Properties:\n- Asymmetric: if greater x1 x2 is True at position i, then greater x2 x1 is False at position i\n- Transitive: if greater x1 x2 and greater x2 x3 are both True at position i, then greater x1 x3 is True at position i\n- Irreflexive: greater x x returns all False (no string is greater than itself)\n- Trichotomous: for any two strings s1 and s2, exactly one of s1 < s2, s1 = s2, or s1 > s2 holds\n- Decidable: String comparison is decidable for all strings\n- Type-safe: Result vector has same length as input vectors\n\n/* Core property: result[i] = (x1[i] > x2[i]) for all indices */\n\n/* Asymmetry: if x1[i] > x2[i], then NOT (x2[i] > x1[i]) */\n\n/* Irreflexivity: no string is greater than itself */", "vc-preamble": "use vstd::prelude::*;\nuse vstd::string::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn string_compare_gt(s1: Seq<char>, s2: Seq<char>) -> bool {\n    true  // placeholder implementation\n}\n\nfn greater(x1: &Vec<String>, x2: &Vec<String>) -> (result: Vec<bool>)\n    requires x1.len() == x2.len(),\n    ensures \n        result.len() == x1.len(),\n\n        forall|i: int| 0 <= i < result.len() as int ==> \n            result[i] == string_compare_gt(x1[i]@, x2[i]@),\n\n        forall|i: int| 0 <= i < result.len() as int ==> \n            result[i] ==> !string_compare_gt(x2[i]@, x1[i]@),\n\n        forall|i: int| 0 <= i < result.len() as int ==> \n            (x1[i]@ == x2[i]@) ==> (result[i] == false),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0613", "language": "verus", "source": "numpy_triple", "source_id": "strings_greater_equal", "vc-description": "numpy.strings.greater_equal: Return the truth value of (x1 >= x2) element-wise for string arrays.\n\nPerforms element-wise string comparison between two vectors of strings.\nReturns a boolean vector indicating whether each string in x1 is greater than or equal \nto the corresponding string in x2 using lexicographic ordering.\n\nThis function compares strings lexicographically and returns True for each\nposition where x1[i] >= x2[i], False otherwise.\n\nExamples:\n- greater_equal [\"apple\", \"banana\"] [\"apple\", \"banana\"] = [true, true]\n- greater_equal [\"zebra\", \"apple\"] [\"apple\", \"banana\"] = [true, false]\n- greater_equal [\"a\", \"bb\"] [\"aa\", \"b\"] = [false, true]\n\nSpecification: numpy.strings.greater_equal returns element-wise greater-than-or-equal comparison.\n\nThis specification captures the mathematical properties of lexicographic string comparison:\n\n1. Core Property: Each position compares strings lexicographically\n2. Reflexive Property: Every string is >= itself\n3. Antisymmetric Property: If s1 >= s2 and s2 >= s1, then s1 = s2\n4. Transitive Property: If s1 >= s2 and s2 >= s3, then s1 >= s3\n5. Total Ordering: For any two strings, either s1 >= s2 or s2 >= s1 (or both)\n6. Consistency: Result is deterministic for same inputs\n\nPrecondition: True (no special preconditions for string comparison)\nPostcondition: Element-wise lexicographic greater-than-or-equal comparison", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn string_lex_ge(s1: Seq<char>, s2: Seq<char>) -> bool\n    decreases s1.len() + s2.len()\n{\n    if s1.len() == 0 {\n        true\n    } else if s2.len() == 0 {\n        true\n    } else if s1[0] == s2[0] {\n        string_lex_ge(s1.skip(1), s2.skip(1))\n    } else {\n        s1[0] >= s2[0]\n    }\n}\n\nfn greater_equal(x1: Vec<String>, x2: Vec<String>) -> (result: Vec<bool>)\n    requires x1.len() == x2.len(),\n    ensures \n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == string_lex_ge(x1[i]@, x2[i]@),\n        /* Reflexive property: every string is >= itself */\n        forall|i: int| 0 <= i < result.len() && x1[i] == x2[i] ==> result[i] == true,\n        /* Empty string properties */\n        forall|i: int| 0 <= i < result.len() && x1[i]@ == Seq::<char>::empty() && x2[i]@ == Seq::<char>::empty() ==> result[i] == true,\n        forall|i: int| 0 <= i < result.len() && x1[i]@ != Seq::<char>::empty() && x2[i]@ == Seq::<char>::empty() ==> result[i] == true,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0614", "language": "verus", "source": "numpy_triple", "source_id": "strings_index", "vc-description": "Like find, but raises ValueError when the substring is not found. For each element, return the lowest index in the string where substring is found. Unlike find, this function requires that the substring be found in each string, ensuring all results are non-negative indices. Specification: index returns the lowest index where substring is found within range. The key difference from find is that index has a stronger precondition: the substring must exist in each string within the specified range.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn index(a: Vec<Seq<char>>, sub: Vec<Seq<char>>, start: Vec<i8>, end_pos: Vec<i8>) -> (result: Vec<i8>)\n    requires \n        a.len() == sub.len() && sub.len() == start.len() && start.len() == end_pos.len(),\n        forall|i: int| 0 <= i < a.len() ==> {\n            &&& start[i] as int >= 0 \n            &&& start[i] as int <= end_pos[i] as int\n            &&& end_pos[i] as int <= a[i].len() as int\n            &&& sub[i].len() > 0\n        },\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> {\n            &&& result[i] as int >= 0\n            &&& start[i] as int <= result[i] as int <= end_pos[i] as int\n            &&& result[i] as int + sub[i].len() as int <= a[i].len() as int\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0615", "language": "verus", "source": "numpy_triple", "source_id": "strings_isalnum", "vc-description": "Returns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise.\n\nFor each string in the input vector, this function checks if:\n1. The string is non-empty (has at least one character)\n2. All characters in the string are alphanumeric (letters or digits)\n\nReturns a boolean vector where True indicates the string meets both criteria,\nand False indicates the string is either empty or contains non-alphanumeric characters.\n\nThis follows the Python str.isalnum() behavior which returns False for empty strings\nand True only if all characters are alphanumeric.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_alphanumeric_char(c: char) -> bool;\n\nspec fn all_chars_alphanumeric(s: Seq<char>) -> bool\n    decreases s.len()\n{\n    if s.len() == 0 {\n        true\n    } else {\n        is_alphanumeric_char(s[0]) && all_chars_alphanumeric(s.skip(1))\n    }\n}\n\nfn isalnum(a: Vec<String>) -> (result: Vec<bool>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> \n            result[i] == (a[i]@.len() > 0 && all_chars_alphanumeric(a[i]@))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0616", "language": "verus", "source": "numpy_triple", "source_id": "strings_isalpha", "vc-description": "numpy.strings.isalpha: Returns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise.\n\nTests whether all characters in each string are alphabetic letters.\nA string is considered alphabetic if:\n1. It contains at least one character\n2. All characters are alphabetic (a-z, A-Z)\n\nEmpty strings return false.\nStrings with numbers, symbols, or whitespace return false.\n\nSpecification: numpy.strings.isalpha returns a vector where each element indicates\nwhether the corresponding string element contains only alphabetic characters\nand has at least one character.\n\nKey properties:\n1. Empty strings always return false\n2. Non-empty strings return true iff all characters are alphabetic\n3. Alphabetic characters are those satisfying Char.isAlpha (a-z, A-Z)\n4. Strings with digits, whitespace, or symbols return false\n5. The function is applied element-wise to each string in the vector\n\nMathematical properties:\n- Monotonicity: removing non-alphabetic characters from a string cannot make isalpha false\n- Compositionality: isalpha(s) = (s.length > 0) ∧ (∀ c ∈ s, Char.isAlpha c)\n- Deterministic: same input always produces same output", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_alpha_char(c: char) -> bool {\n    ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')\n}\n\nspec fn all_chars_alpha(s: Seq<char>) -> bool \n    decreases s.len()\n{\n    if s.len() == 0 {\n        true\n    } else {\n        is_alpha_char(s[0]) && all_chars_alpha(s.skip(1))\n    }\n}\n\nfn isalpha(a: Vec<String>) -> (result: Vec<bool>)\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> \n            result[i as int] == (a[i as int]@.len() > 0 && all_chars_alpha(a[i as int]@)),\n        forall|i: int| 0 <= i < a.len() ==> \n            (a[i as int]@.len() == 0 ==> result[i as int] == false),\n        forall|i: int| 0 <= i < a.len() ==> \n            (a[i as int]@.len() > 0 ==> (result[i as int] <==> all_chars_alpha(a[i as int]@))),\n        forall|i: int| 0 <= i < a.len() ==> \n            (result[i as int] == true ==> a[i as int]@.len() > 0),\n        forall|i: int| 0 <= i < a.len() ==> \n            (result[i as int] == true ==> all_chars_alpha(a[i as int]@))", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0617", "language": "verus", "source": "numpy_triple", "source_id": "strings_isdecimal", "vc-description": "For each element, return True if there are only decimal characters in the element.\n\nFor each element, return True if there are only decimal characters in the element\n\nSpecification: isdecimal returns True for each element if all characters in the string \nare decimal characters (including digit characters and all characters that can be used \nto form decimal-radix numbers), and False otherwise.\n\nA decimal character is one that can be used to form decimal-radix numbers. This includes:\n- ASCII digits (0-9)  \n- Unicode decimal characters (e.g., Arabic-Indic digits like U+0660)\n- Does NOT include superscript/subscript digits or other numeric characters\n\nNote: For simplicity, we use c.isDigit which covers decimal characters in most practical cases.\n\nKey properties:\n- Empty strings return False\n- Strings with only decimal characters return True\n- Strings with non-decimal characters return False\n- Mixed decimal/non-decimal characters return False", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_decimal_char(c: char) -> bool {\n    ('0' <= c && c <= '9')\n}\n\nspec fn all_chars_decimal(s: Seq<char>) -> bool\n    decreases s.len()\n{\n    if s.len() == 0 {\n        true\n    } else {\n        is_decimal_char(s[0]) && all_chars_decimal(s.skip(1))\n    }\n}\n\nfn isdecimal(a: Vec<String>) -> (result: Vec<bool>)\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> {\n            &&& (result[i] == true <==> (a[i]@.len() > 0 && all_chars_decimal(a[i]@)))\n            &&& (a[i]@ == Seq::<char>::empty() ==> result[i] == false)\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0618", "language": "verus", "source": "numpy_triple", "source_id": "strings_isdigit", "vc-description": "Returns true for each element if all characters in the string are digits, and there is at least one character, false otherwise\n\nnumpy.strings.isdigit: Returns true for each element if all characters in the string are digits, and there is at least one character, false otherwise.\n\nTests whether all characters in each string are digits.\nA string is considered to satisfy isdigit if:\n1. It contains at least one character (non-empty)\n2. All characters are digits (0-9)\n\nEmpty strings return false.\nStrings with any non-digit characters return false.\nStrings with only digits return true.\n\nThis follows the Python str.isdigit() behavior which returns False for empty strings\nand True only if all characters are numeric digits.\n\nSpecification: numpy.strings.isdigit returns a vector where each element indicates\nwhether the corresponding string element contains only digits and is non-empty.\n\nPrecondition: True (no special preconditions)\nPostcondition: For all indices i, result[i] = true if and only if:\n1. The string a[i] is non-empty (not equal to empty string)\n2. All characters in a[i] are digits (satisfy Char.isDigit)\n\nProperties:\n- Empty strings return False\n- Strings with only numeric characters (0-9) return True\n- Strings with any non-numeric characters return False\n- Single digit characters return True", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn all_chars_digit(s: Seq<char>) -> bool;\n\nfn isdigit(a: Vec<String>) -> (result: Vec<bool>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> result[i as int] == (a[i as int]@.len() > 0 && all_chars_digit(a[i as int]@))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0619", "language": "verus", "source": "numpy_triple", "source_id": "strings_islower", "vc-description": "numpy.strings.islower: Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise.\n\nTests whether all cased characters in each string are lowercase.\nA string is considered to satisfy islower if:\n1. It contains at least one cased character (letters that have uppercase/lowercase versions)\n2. All cased characters are lowercase\n3. Non-cased characters (numbers, symbols, whitespace) are ignored for the check\n\nExamples:\n- Empty string \"\" → false (no cased characters)\n- \"123\" → false (no cased characters)\n- \"abc\" → true (all lowercase, has cased characters)\n- \"ABC\" → false (has uppercase)\n- \"aBc\" → false (has uppercase)\n- \"abc123\" → true (has lowercase, no uppercase)\n- \"   \" → false (no cased characters)\n\nSpecification: numpy.strings.islower returns a vector where each element indicates\nwhether the corresponding string element has all cased characters in lowercase\nand contains at least one cased character.\n\nMathematical Properties:\n1. A string is considered \"islower\" if it has at least one cased character AND\n   all cased characters are lowercase\n2. Empty strings return false (no cased characters)\n3. Strings with only non-cased characters (digits, symbols, whitespace) return false\n4. Strings with any uppercase letters return false\n5. Strings with at least one lowercase letter and no uppercase letters return true\n\nEdge Cases:\n- Empty string: false (no cased characters)\n- \"123\": false (no cased characters) \n- \"abc\": true (all lowercase, has cased characters)\n- \"ABC\": false (has uppercase)\n- \"aBc\": false (has uppercase)\n- \"abc123\": true (has lowercase, no uppercase)\n- \"   \": false (no cased characters)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_alpha_char(c: char) -> bool {\n    ('a' <= c <= 'z') || ('A' <= c <= 'Z')\n}\n\nspec fn is_lower_char(c: char) -> bool {\n    'a' <= c <= 'z'\n}\n\nspec fn string_has_cased_char(s: Seq<char>) -> bool {\n    exists|i: int| 0 <= i < s.len() && is_alpha_char(s[i])\n}\n\nspec fn string_all_cased_are_lowercase(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() && is_alpha_char(s[i]) ==> is_lower_char(s[i])\n}\n\nfn islower(a: Vec<String>) -> (result: Vec<bool>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> \n            result[i as int] == (string_has_cased_char(a[i]@) && string_all_cased_are_lowercase(a[i]@))", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0621", "language": "verus", "source": "numpy_triple", "source_id": "strings_isspace", "vc-description": "Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise\n\nnumpy.strings.isspace: Returns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise.\n\nTests whether all characters in each string are whitespace characters.\nA string is considered whitespace if:\n1. It contains at least one character (non-empty)\n2. All characters are whitespace (space, tab, newline, form feed, carriage return, etc.)\n\nBehavior:\n- Empty strings return false\n- Strings with only whitespace characters return true\n- Strings with any non-whitespace character return false\n\nExamples:\n- \" \" (single space) → true\n- \"\\t\" (tab) → true  \n- \"\\n\" (newline) → true\n- \"  \\t\\n  \" (mixed whitespace) → true\n- \"\" (empty string) → false\n- \"a\" (letter) → false\n- \" a \" (space + letter + space) → false\n\nSpecification: numpy.strings.isspace returns a vector where each element indicates\nwhether the corresponding string element contains only whitespace characters\nand has at least one character.\n\nThe function performs element-wise whitespace checking with the following properties:\n1. Empty strings always return false\n2. Strings with only whitespace characters return true\n3. Strings with any non-whitespace character return false\n4. Common whitespace characters include: space, tab, newline, carriage return, etc.\n\nPrecondition: True (no special preconditions)\nPostcondition: For all indices i, result[i] = true if and only if:\n1. The string a[i] is non-empty\n2. All characters in a[i] are whitespace characters", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_whitespace_char(c: char) -> bool {\n    c == ' ' || c == '\\t' || c == '\\n' || c == '\\r' || c == '\\x0c'\n}\n\nspec fn all_chars_whitespace(s: Seq<char>) -> bool \n    decreases s.len()\n{\n    if s.len() == 0 {\n        true\n    } else {\n        is_whitespace_char(s[0]) && all_chars_whitespace(s.skip(1))\n    }\n}\n\nfn isspace(a: Vec<String>) -> (result: Vec<bool>)\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> \n            result[i] == (a[i]@.len() > 0 && all_chars_whitespace(a[i]@)),\n        forall|i: int| 0 <= i < a.len() ==> \n            (a[i]@.len() == 0 ==> result[i] == false),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0622", "language": "verus", "source": "numpy_triple", "source_id": "strings_istitle", "vc-description": "numpy.strings.istitle: Returns true for each element if the element is a titlecased string and there is at least one character, false otherwise.\n\nA string is considered titlecased if:\n1. It contains at least one character\n2. Each word starts with an uppercase letter followed by lowercase letters\n3. Words are separated by non-alphabetic characters\n4. There is at least one cased character in the string\n\nExamples:\n- \"Title Case\" → True\n- \"Numpy Is Great\" → True  \n- \"numpy is great\" → False\n- \"NUMPY IS GREAT\" → False\n- \"\" → False\n- \"123\" → False\n\n/* Helper function to check if a string is titlecased according to Python's str.istitle() logic */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_titlecased(s: Seq<char>) -> bool;", "vc-helpers": "", "vc-spec": "fn istitle(a: Vec<String>) -> (result: Vec<bool>)\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> result[i] == is_titlecased(a[i]@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0623", "language": "verus", "source": "numpy_triple", "source_id": "strings_isupper", "vc-description": "Checks if all cased characters in each string are uppercase and there is at least one character.\n\nSpecification: isupper returns true for each element if all cased characters \nin the string are uppercase and there is at least one character, false otherwise.\nMathematical properties:\n1. Empty strings return false\n2. Strings with no cased characters return false  \n3. Strings with mixed case return false\n4. Strings with all cased characters uppercase return true", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_alpha_char(c: char) -> bool;\n\nspec fn is_upper_char(c: char) -> bool;\n\nspec fn has_alpha_chars(s: Seq<char>) -> bool {\n    exists|i: int| 0 <= i < s.len() && is_alpha_char(s[i])\n}\n\nspec fn all_alpha_are_upper(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() && is_alpha_char(s[i]) ==> is_upper_char(s[i])\n}\n\nfn isupper(a: Vec<String>) -> (result: Vec<bool>)\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> #[trigger] result[i] == {\n            let s = a[i]@;\n            s.len() > 0 && has_alpha_chars(s) && all_alpha_are_upper(s)\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0625", "language": "verus", "source": "numpy_triple", "source_id": "strings_less", "vc-description": "numpy.strings.less: Return the truth value of (x1 < x2) element-wise for string arrays.\n\nPerforms element-wise string comparison between two vectors of strings.\nReturns a boolean vector indicating whether corresponding strings from x1 \nare lexicographically less than corresponding strings from x2.\n\nThis function compares strings lexicographically and returns True for each\nposition where x1[i] < x2[i] in lexicographic ordering, False otherwise.\n\nSpecification: numpy.strings.less returns element-wise lexicographic comparison.\n\nThis function performs element-wise lexicographic comparison between two vectors\nof strings, returning a boolean vector where each element indicates whether\nthe corresponding element in x1 is lexicographically less than the corresponding\nelement in x2.\n\nPrecondition: True (no special preconditions for string comparison)\nPostcondition: For all indices i, result[i] = (x1[i] < x2[i])\n\nMathematical Properties:\n- Asymmetric: if less x1 x2 is True at position i, then less x2 x1 is False at position i\n- Transitive: if less x1 x2 and less x2 x3 are both True at position i, then less x1 x3 is True at position i\n- Irreflexive: less x x returns all False (no string is less than itself)\n- Trichotomous: for any two strings s1 and s2, exactly one of s1 < s2, s1 = s2, or s1 > s2 holds\n- Decidable: String comparison is decidable for all strings\n- Type-safe: Result vector has same length as input vectors\n\nString Comparison Properties:\n- Empty string is less than any non-empty string\n- Lexicographic ordering follows dictionary order (case-sensitive)\n- Comparison is based on Unicode code point values\n- Preserves strict ordering properties of the underlying string type\n\n/* Core property: result[i] = (x1[i] < x2[i]) for all indices */\n\n/* Asymmetry: if x1[i] < x2[i], then NOT (x2[i] < x1[i]) */\n\n/* Irreflexivity: no string is less than itself */\n\n/* Decidability: result is always boolean (true or false) */\n\n/* Strict ordering: if result[i] is true, then x1[i] and x2[i] are different */\n\n/* Totality of comparison: for any two strings, exactly one of <, =, > holds */", "vc-preamble": "use vstd::prelude::*;\nuse vstd::string::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn str_less_than(s1: String, s2: String) -> bool;\n\nfn less(x1: &Vec<String>, x2: &Vec<String>) -> (result: Vec<bool>)\n    requires x1@.len() == x2@.len(),\n    ensures \n        result@.len() == x1@.len(),\n\n        forall|i: int| 0 <= i < result@.len() ==> result@[i] == str_less_than(x1@[i], x2@[i]),\n\n        forall|i: int| 0 <= i < result@.len() && result@[i] == true ==> !str_less_than(x2@[i], x1@[i]),\n\n        forall|i: int| 0 <= i < result@.len() && x1@[i] == x2@[i] ==> result@[i] == false,\n\n        forall|i: int| 0 <= i < result@.len() ==> result@[i] == true || result@[i] == false,\n\n        forall|i: int| 0 <= i < result@.len() && result@[i] == true ==> x1@[i] != x2@[i],\n\n        forall|i: int| 0 <= i < result@.len() ==> result@[i] == true || x1@[i] == x2@[i] || str_less_than(x2@[i], x1@[i])", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0626", "language": "verus", "source": "numpy_triple", "source_id": "strings_less_equal", "vc-description": "numpy.strings.less_equal: Return the truth value of (x1 <= x2) element-wise for string arrays.\n\nPerforms element-wise string comparison between two vectors of strings.\nReturns a boolean vector indicating whether each string in x1 is lexicographically \nless than or equal to the corresponding string in x2.\n\nThis function compares strings lexicographically and returns True for each\nposition where x1[i] <= x2[i], False otherwise.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn string_le(s1: String, s2: String) -> bool;\n\nfn less_equal(x1: Vec<String>, x2: Vec<String>) -> (result: Vec<bool>)\n    requires x1@.len() == x2@.len(),\n    ensures \n        result@.len() == x1@.len(),\n        forall|i: int| 0 <= i < result@.len() ==> result@[i] == string_le(x1@[i], x2@[i]),\n        forall|i: int| 0 <= i < result@.len() ==> (result@[i] == true <==> string_le(x1@[i], x2@[i])),\n        x1@ == x2@ ==> forall|i: int| 0 <= i < result@.len() ==> result@[i] == true,\n        forall|i: int| 0 <= i < result@.len() ==> (string_le(x1@[i], x2@[i]) && string_le(x2@[i], x1@[i])) ==> x1@[i] == x2@[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0627", "language": "verus", "source": "numpy_triple", "source_id": "strings_ljust", "vc-description": "numpy.strings.ljust: Return an array with the elements left-justified in a string of length width.\n\nLeft-justifies each string in the input array by padding it with the specified\nfill character (default is space) to reach the specified width. If the original\nstring is longer than or equal to the width, it remains unchanged.\n\nParameters:\n- a: Input array of strings\n- width: Target width for each string\n- fillchar: Character to use for padding (must be exactly one character)\n\nReturns:\n- Array where each string is left-justified to the specified width\n\nSpecification: ljust returns a vector where each string is left-justified\nto the specified width using the given fill character.\n\nMathematical Properties:\n- Length preservation: Result length is max(original_length, width)\n- Identity: Strings already >= width remain unchanged\n- Left-justification: Original content preserved as prefix, padding on right\n- Minimality: No unnecessary padding beyond required width\n- Fillchar constraint: Padding uses specified fill character", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn ljust(a: Vec<String>, width: u8, fillchar: char) -> (result: Vec<String>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> #[trigger] result[i]@.len() == if a[i]@.len() >= width as nat { a[i]@.len() } else { width as nat },\n        forall|i: int| 0 <= i < a.len() && a[i]@.len() >= width as nat ==> #[trigger] result[i]@ == a[i]@,\n        forall|i: int| 0 <= i < a.len() && a[i]@.len() < width as nat ==> {\n            &&& #[trigger] result[i]@.len() == width as nat\n            &&& result[i]@.subrange(0, a[i]@.len() as int) == a[i]@\n        },\n        forall|i: int| 0 <= i < a.len() && a[i]@.len() == 0 ==> #[trigger] result[i]@.len() == width as nat", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0628", "language": "verus", "source": "numpy_triple", "source_id": "strings_lower", "vc-description": "numpy.strings.lower: Return an array with the elements converted to lowercase.\n\nConverts each string element in the input vector to lowercase. This transformation\napplies to all alphabetic characters while preserving non-alphabetic characters\n(digits, punctuation, whitespace) unchanged.\n\nThe function preserves the shape of the input array and handles empty strings\nappropriately by returning them unchanged.\n\nFrom NumPy documentation:\n- Parameters: a (array_like) - Input array with string dtype\n- Returns: out (ndarray) - Output array with elements converted to lowercase\n\nMathematical Properties:\n1. Element-wise transformation: result[i] = lower(a[i]) for all i\n2. Length preservation: result[i].length = a[i].length for all i\n3. Case transformation: uppercase letters become lowercase, others unchanged\n4. Idempotent: lower(lower(x)) = lower(x)\n5. Preserves vector length: result.size = a.size", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn char_to_lower(c: char) -> char;\n\nspec fn string_to_lower(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        seq![]\n    } else {\n        seq![char_to_lower(s[0])] + string_to_lower(s.skip(1))\n    }\n}\n\nfn lower(a: Vec<Vec<char>>) -> (result: Vec<Vec<char>>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> #[trigger] result[i]@ == string_to_lower(a[i]@),\n        forall|i: int| 0 <= i < a.len() ==> result[i].len() == a[i].len(),\n        forall|i: int| 0 <= i < a.len() ==> (a[i].len() == 0 ==> result[i].len() == 0),\n        forall|i: int| 0 <= i < a.len() ==> string_to_lower(result[i]@) == result[i]@,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0629", "language": "verus", "source": "numpy_triple", "source_id": "strings_lstrip", "vc-description": "numpy.strings.lstrip: For each element in a vector, return a copy with the leading characters removed.\n\nRemoves leading characters from each string element in the input vector. The behavior\ndepends on the chars parameter:\n- If chars is None, whitespace characters are removed from the beginning\n- If chars is provided, any combination of those characters is removed from the beginning\n\nThe function preserves the shape of the input array and handles empty strings\nappropriately by returning them unchanged.\n\nFrom NumPy documentation:\n- Parameters: a (array_like) - Input array with string dtype\n              chars (optional) - Characters to remove from the beginning\n- Returns: out (ndarray) - Output array with leading characters removed\n\nMathematical Properties:\n1. Element-wise transformation: result[i] = lstrip(a[i], chars) for all i\n2. Length preservation or reduction: result[i].length ≤ a[i].length for all i\n3. Prefix removal: result[i] is a suffix of a[i] for all i\n4. Character set removal: only characters in chars are removed from the beginning\n5. Preserves vector length: result.size = a.size\n\n/* Length preservation or reduction */\n\n/* Suffix property: result is a suffix of original */\n\n/* Empty string case: if original is empty, result is empty */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn lstrip(a: Vec<String>, chars: Option<String>) -> (result: Vec<String>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() as int ==> {\n            let original = #[trigger] a[i];\n            let result_str = #[trigger] result[i];\n\n            result_str@.len() <= original@.len() &&\n\n            (exists|k: int| 0 <= k <= original@.len() as int && \n             result_str@ == original@.subrange(k, original@.len() as int)) &&\n\n            (original@.len() == 0 ==> result_str@.len() == 0)\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0630", "language": "verus", "source": "numpy_triple", "source_id": "strings_mod", "vc-description": "numpy.strings.mod: Return (a % i), that is pre-Python 2.6 string formatting \n(interpolation), element-wise for a pair of array_likes of string objects.\n\nThis function performs string formatting element-wise on vectors of format strings \nand replacement values. Each element of the result is the formatted string obtained \nby interpolating the corresponding value into the format string.\n\nThis is equivalent to Python's old-style string formatting using the % operator \nfor each element pair. The function handles various format specifiers like %s, %i, \n%f, etc., and produces appropriately formatted strings.\n\nFrom NumPy documentation:\n- Parameters: a (array_like) - Format strings with placeholders\n              values (array_like) - Values to interpolate into format strings\n- Returns: out (ndarray) - The formatted strings, element-wise\n\nMathematical Properties:\n1. Element-wise formatting: result[i] = format(a[i], values[i])\n2. Preserves vector length: result.size = a.size = values.size\n3. Format correctness: each result follows the format specification\n4. Type preservation: maintains string type characteristics\n5. Handles various format specifiers: %s, %i, %f, %d, etc.\n\nSpecification: numpy.strings.mod returns a vector where each element is the \nresult of formatting the corresponding format string with its value.\n\nMathematical Properties:\n1. Identity Property: Format strings without % specifiers remain unchanged\n2. Substitution Property: Format strings with % specifiers get interpolated\n3. Empty String Property: Empty format strings produce empty results\n4. Non-empty Preservation: Non-empty format strings with specifiers produce non-empty results\n5. Length Monotonicity: Result length is non-negative and preserves structural properties\n6. Format Preservation: The result maintains the original format structure with substitutions\n\nKey format specifiers handled:\n- %s: String representation\n- %i, %d: Integer formatting\n- %f: Floating point formatting\n- %x, %X: Hexadecimal formatting\n- And other standard format specifiers\n\nPrecondition: True (function handles format string validation internally)\nPostcondition: For all indices i, result[i] represents the formatted string\n              where format string a[i] is applied to value values[i], satisfying\n              the mathematical properties of string formatting operations", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn mod_func(a: Vec<String>, values: Vec<String>) -> (result: Vec<String>)\n    requires a.len() == values.len(),\n    ensures \n        result.len() == a.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0631", "language": "verus", "source": "numpy_triple", "source_id": "strings_multiply", "vc-description": "Return (a * i), that is string multiple concatenation, element-wise.\nValues in i of less than 0 are treated as 0 (which yields an empty string).\n\nSpecification: multiply performs element-wise string repetition.\nEach output string is the corresponding input string repeated the specified number of times.\nNegative repetition counts produce empty strings. This comprehensive specification\ncaptures the core mathematical properties of string multiplication in NumPy.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn repeat_string_spec(s: Seq<char>, n: int) -> Seq<char> \n    decreases (if n <= 0 { 0 } else { n }) as nat\n{\n    if n <= 0 {\n        Seq::<char>::empty()\n    } else if n == 1 {\n        s\n    } else {\n        s + repeat_string_spec(s, n - 1)\n    }\n}", "vc-helpers": "", "vc-spec": "fn multiply(a: Vec<String>, i: Vec<i32>) -> (result: Vec<String>)\n    requires a.len() == i.len(),\n    ensures \n        result.len() == a.len(),\n        /* Core property: Element-wise string repetition */\n        forall|j: int| 0 <= j < a.len() ==> \n            result[j]@ == repeat_string_spec(a[j]@, i[j] as int),\n        /* Zero/negative repetition property: Always yields empty string */\n        forall|j: int| 0 <= j < a.len() && i[j] <= 0 ==> \n            result[j]@ == Seq::<char>::empty(),\n        /* Identity property: Multiplying by 1 yields the original string */\n        forall|j: int| 0 <= j < a.len() && i[j] == 1 ==> \n            result[j] == a[j],\n        /* Zero property: Multiplying by 0 yields empty string */\n        forall|j: int| 0 <= j < a.len() && i[j] == 0 ==> \n            result[j]@ == Seq::<char>::empty(),\n        /* Empty string property: Empty strings remain empty regardless of repetition */\n        forall|j: int| 0 <= j < a.len() && a[j]@ == Seq::<char>::empty() ==> \n            result[j]@ == Seq::<char>::empty(),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 1, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 0.7}}
{"id": "VT0632", "language": "verus", "source": "numpy_triple", "source_id": "strings_not_equal", "vc-description": "numpy.strings.not_equal: Return (x1 != x2) element-wise for string arrays.\n\nPerforms element-wise string inequality comparison between two vectors of strings.\nReturns a boolean vector indicating whether corresponding strings are not equal.\n\nThis function compares strings lexicographically and returns True for each\nposition where the strings are different, False where they are identical.\n\nSpecification: numpy.strings.not_equal returns element-wise inequality comparison.\n\nPrecondition: True (no special preconditions for string inequality)\nPostcondition: For all indices i, result[i] = (x1[i] != x2[i])\n\nMathematical Properties:\n- Irreflexive: not_equal x x returns all False\n- Symmetric: not_equal x y = not_equal y x  \n- Negation of equality: not_equal x y = ¬(equal x y)\n- Decidable: String inequality is decidable for all strings\n- Type-safe: Result vector has same length as input vectors\n- Complementary: for any two strings s1 and s2, exactly one of (s1 = s2) or (s1 ≠ s2) holds", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn not_equal(x1: Vec<String>, x2: Vec<String>) -> (result: Vec<bool>)\n    requires x1.len() == x2.len(),\n    ensures \n        result.len() == x1.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i] == (x1[i] != x2[i])", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0633", "language": "verus", "source": "numpy_triple", "source_id": "strings_partition", "vc-description": "numpy.strings.partition: Partition each element in a around sep.\n\nPartitions each string in the input vector at the first occurrence of the separator.\nReturns a 3-tuple of vectors: (before_separator, separator, after_separator).\n\nFor each element in the input array, splits the element at the first occurrence\nof the separator, and returns three vectors containing the part before the separator,\nthe separator itself, and the part after the separator. If the separator is not found,\nthe first vector contains the whole string, and the second and third vectors contain\nempty strings.\n\nFrom NumPy documentation:\n- Parameters: a (array_like with StringDType), sep (array_like with StringDType)\n- Returns: 3-tuple of ndarrays with StringDType\n\nMathematical Properties:\n1. Partition semantics: For each string s, if sep occurs at position i, then:\n   - before = s[0:i]\n   - separator = sep (if found) or \"\" (if not found)\n   - after = s[i+len(sep):] (if found) or \"\" (if not found)\n2. Completeness: before ++ separator ++ after = original string (when sep is found)\n3. First occurrence: Only splits at the first occurrence of sep\n4. Not found case: If sep not in string, returns (original_string, \"\", \"\")\n5. Preserves vector length: All three result vectors have the same length as input\n\nSpecification: numpy.strings.partition returns a 3-tuple of vectors where each\nelement is partitioned around the first occurrence of the separator.\n\nMathematical Properties:\n1. Partition correctness: For each index i, the result satisfies partition semantics\n2. Completeness: When separator is found, concatenation reconstructs original string\n3. First occurrence: Only the first occurrence of separator is used for partitioning\n4. Not found case: When separator is not found, returns (original, \"\", \"\")\n5. Preserves vector length: All result vectors have the same length as input\n6. Separator consistency: The separator part contains the actual separator or empty string\n\nPrecondition: True (no special preconditions for string partitioning)\nPostcondition: For all indices i, the partition satisfies the partition semantics\n\n/* Fundamental partition property: parts reconstruct original string */\n\n/* Separator correctness: either the separator or empty string */\n\n/* Case 2: Separator not found - before contains whole string, others empty */\n\n/* Length preservation: total length is preserved */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn partition(a: Vec<String>, sep: String) -> (result: (Vec<String>, Vec<String>, Vec<String>))\n    ensures\n        result.0.len() == a.len() && result.1.len() == a.len() && result.2.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() as int ==> {\n            let original = #[trigger] a[i]@;\n            let before_i = result.0[i]@;\n            let sep_i = result.1[i]@;\n            let after_i = result.2[i]@;\n\n            before_i + sep_i + after_i == original &&\n\n            (sep_i == sep@ || sep_i.len() == 0) &&\n\n            (sep_i.len() == 0 ==> after_i.len() == 0 && before_i == original) &&\n\n            original.len() == before_i.len() + sep_i.len() + after_i.len()\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0634", "language": "verus", "source": "numpy_triple", "source_id": "strings_replace", "vc-description": "numpy.strings.replace: For each element in a, return a copy of the string with \noccurrences of substring old replaced by new.\n\nReplaces occurrences of the substring 'old' with 'new' in each string element.\nThe replacement is done from left to right, and if count is specified, only\nthe first 'count' occurrences are replaced. If count is -1 or negative,\nall occurrences are replaced.\n\nSpecification for numpy.strings.replace: Returns a vector where each element is the\nresult of replacing occurrences of old substring with new substring.\n\nMathematical Properties:\n1. Element-wise replacement: Each result element is the original string with replacements\n2. Count limiting: If count[i] >= 0, at most count[i] replacements are made\n3. Complete replacement: If count[i] < 0, all occurrences are replaced\n4. Identity preservation: If old[i] doesn't occur in a[i], result[i] = a[i]\n5. Zero count behavior: If count[i] = 0, no replacements occur\n\n/* Zero count behavior: if count is 0, no replacements occur */\n\n/* Identity property: if old doesn't occur in string, result equals original */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn replace(a: Vec<String>, old: Vec<String>, new: Vec<String>, count: Vec<i32>) -> (result: Vec<String>)\n    requires \n        a.len() == old.len() && old.len() == new.len() && new.len() == count.len(),\n        forall|i: int| 0 <= i < count.len() ==> (count[i] == 0 || old[i]@.len() > 0),\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> {\n\n            (count[i] == 0 ==> result[i] == a[i]) &&\n\n            (old[i]@.len() == 0 ==> result[i] == a[i])\n        },", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0635", "language": "verus", "source": "numpy_triple", "source_id": "strings_rfind", "vc-description": "For each element, return the highest index in the string where substring is found, such that sub is contained within [start, end]. Returns -1 if sub is not found.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn string_starts_with(s: Seq<char>, prefix: Seq<char>, start_pos: int) -> bool {\n    start_pos >= 0 && start_pos + prefix.len() <= s.len() &&\n    forall|i: int| 0 <= i < prefix.len() ==> s[start_pos + i] == prefix[i]\n}\n\nfn rfind(a: Vec<String>, sub: Vec<String>, start: Vec<i32>, end_pos: Vec<i32>) -> (result: Vec<i32>)\n    requires \n        a.len() == sub.len() && sub.len() == start.len() && start.len() == end_pos.len(),\n        forall|i: int| 0 <= i < start.len() ==> 0 <= start[i] && start[i] <= end_pos[i],\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> (\n            /* Basic range constraint: result is -1 or within string bounds */\n            (result[i] == -1 || (0 <= result[i] && result[i] < a[i]@.len())) &&\n            /* If result is -1, no occurrence of substring within the specified range */\n            (result[i] == -1 ==> \n                forall|j: int| start[i] <= j && j + sub[i]@.len() <= end_pos[i] + 1 && \n                               j + sub[i]@.len() <= a[i]@.len() ==> \n                    !string_starts_with(a[i]@, sub[i]@, j)) &&\n            /* If result is non-negative, it's the rightmost valid occurrence */\n            (result[i] >= 0 ==> \n                /* The result is within the search range */\n                start[i] <= result[i] && \n                result[i] + sub[i]@.len() <= end_pos[i] + 1 &&\n                /* The substring matches at this position */\n                string_starts_with(a[i]@, sub[i]@, result[i] as int) &&\n                /* This is the rightmost occurrence within the range */\n                (forall|j: int| result[i] < j && j + sub[i]@.len() <= end_pos[i] + 1 && \n                                start[i] <= j && j + sub[i]@.len() <= a[i]@.len() ==> \n                    !string_starts_with(a[i]@, sub[i]@, j)))\n        ),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0636", "language": "verus", "source": "numpy_triple", "source_id": "strings_rindex", "vc-description": "numpy.strings.rindex - String information\nLike rfind, but raises ValueError when the substring is not found\n\nFor each element, return the highest index in the string where substring is found.\nUnlike rfind, this function requires that the substring be found in each string,\nensuring all results are non-negative indices.\n\nSpecification: rindex returns the highest index where substring is found within range.\nThe key difference from rfind is that rindex has a stronger precondition:\nthe substring must exist in each string within the specified range.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn rindex(a: Vec<String>, sub: Vec<String>, start: Vec<u8>, end_pos: Vec<u8>) -> (result: Vec<u8>)\n    requires \n        a.len() == sub.len() && sub.len() == start.len() && start.len() == end_pos.len(),\n        forall|i: int| 0 <= i < a.len() ==> {\n            start[i] as nat <= end_pos[i] as nat &&\n            end_pos[i] as nat <= 1000 &&\n            start[i] as nat <= end_pos[i] as nat\n        },\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> {\n            start[i] as nat <= result[i] as nat && \n            result[i] as nat <= end_pos[i] as nat\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0637", "language": "verus", "source": "numpy_triple", "source_id": "strings_rjust", "vc-description": "Return an array with the elements of a right-justified in a string of length width.\n\nRight-justifies each string in the input array by padding it with the specified\nfill character (default is space) to reach the specified width. If the original\nstring is longer than or equal to the width, it remains unchanged.\n\nParameters:\n- a: Input array of strings\n- width: Target width for each string\n- fillchar: Character to use for padding (must be exactly one character)\n\nReturns:\n- Array where each string is right-justified to the specified width\n\nMathematical Properties:\n1. Length preservation: If original.length >= width, return original unchanged\n2. Right-justification: If original.length < width, pad on the left with fillchar\n3. Padding placement: Original string appears as suffix in the result\n4. Character preservation: Original string appears as contiguous substring\n5. Width compliance: Result length equals max(original.length, width)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn max_nat(a: nat, b: nat) -> nat {\n    if a >= b { a } else { b }\n}\n\nspec fn is_suffix_of<T>(suffix: Seq<T>, full: Seq<T>) -> bool {\n    suffix.len() <= full.len() && \n    full.subrange(full.len() - suffix.len(), full.len() as int) == suffix\n}", "vc-helpers": "", "vc-spec": "fn rjust(orig: Vec<char>, width: u8, fillchar: char) -> (res: Vec<char>)\n    ensures\n        res.len() == max_nat(orig.len() as nat, width as nat),\n        (orig.len() >= width as usize ==> res@ == orig@) &&\n        (orig.len() < width as usize ==> res.len() == width as usize && is_suffix_of(orig@, res@)) &&\n        (orig.len() >= width as usize ==> res.len() == orig.len()) &&\n        (orig.len() < width as usize ==> res.len() == width as usize) &&\n        (orig.len() == 0 ==> res.len() == width as usize)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0638", "language": "verus", "source": "numpy_triple", "source_id": "strings_rpartition", "vc-description": "numpy.strings.rpartition: Partition each element in a around the right-most separator.\n\nPartitions each string in the input vector at the last occurrence of the separator.\nReturns a 3-tuple of vectors: (before_separator, separator, after_separator).\n\nFor each element in the input array, splits the element at the last occurrence\nof the separator, and returns three vectors containing the part before the separator,\nthe separator itself, and the part after the separator. If the separator is not found,\nthe third vector contains the whole string, and the first and second vectors contain\nempty strings.\n\nFrom NumPy documentation:\n- Parameters: a (array_like with StringDType), sep (array_like with StringDType)\n- Returns: 3-tuple of ndarrays with StringDType\n\nMathematical Properties:\n1. Right partition semantics: For each string s, if sep occurs at position i (rightmost), then:\n   - before = s[0:i]\n   - separator = sep (if found) or \"\" (if not found)\n   - after = s[i+len(sep):] (if found) or \"\" (if not found)\n2. Completeness: before ++ separator ++ after = original string (when sep is found)\n3. Last occurrence: Only splits at the last occurrence of sep\n4. Not found case: If sep not in string, returns (\"\", \"\", original_string)\n5. Preserves vector length: All three result vectors have the same length as input", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn rpartition(a: Vec<String>, sep: String) -> (result: (Vec<String>, Vec<String>, Vec<String>))\n    requires true,\n    ensures \n        result.0.len() == a.len(),\n        result.1.len() == a.len(),\n        result.2.len() == a.len()", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0639", "language": "verus", "source": "numpy_triple", "source_id": "strings_rsplit", "vc-description": "For each element in a vector, return a list of the words in the string, using sep as the delimiter string.\nSplits from the right, meaning that splits are made from the right side of the string.\n\nSpecification: rsplit splits each string in the vector from the right using the given separator.\nThe resulting vector contains lists of strings where each list represents the split parts\nof the corresponding input string.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn rsplit(a: Vec<String>, sep: String, maxsplit: u8) -> (result: Vec<Vec<String>>)\n    requires \n        sep@.len() > 0,\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() > 0,\n        maxsplit as int == 0 ==> forall|i: int| 0 <= i < result.len() ==> \n            result[i].len() == 1 && result[i][0]@ == a[i]@,\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() <= maxsplit as int + 1,\n        forall|i: int| 0 <= i < result.len() ==> \n            (a[i]@.len() == 0 ==> result[i].len() == 1 && result[i][0]@.len() == 0),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "VT0640", "language": "verus", "source": "numpy_triple", "source_id": "strings_rstrip", "vc-description": "For each element in a vector, return a copy with the trailing characters removed.\n\nSpecification: numpy.strings.rstrip removes trailing characters from each string in the vector.\n\nrstrip removes trailing characters from the end of each string. If chars is None, \nwhitespace characters are removed. If chars is provided, any combination of those \ncharacters is removed from the end.\n\nMathematical Properties:\n1. Element-wise transformation: Each string is processed independently\n2. Trailing character removal: Only characters at the end are removed\n3. Maximal stripping: Remove as many trailing characters as possible\n4. Character set filtering: Only characters in the specified set are removed\n5. Whitespace default: When chars is None, whitespace characters are removed\n\nFrom NumPy documentation:\n- Parameters: a (array_like) - Input array with string dtype\n              chars (optional) - Characters to remove, whitespace if None\n- Returns: out (ndarray) - Output array with trailing characters removed", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn rstrip(a: Vec<String>, chars: Option<String>) -> (result: Vec<String>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> #[trigger] result[i]@.len() <= a[i]@.len()", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0641", "language": "verus", "source": "numpy_triple", "source_id": "strings_split", "vc-description": "For each element in a vector of strings, return a list of the words in the string, using sep as the delimiter string.\nSpecification: split returns a vector where each string is split into a list of substrings based on the separator, with proper handling of maxsplit constraints and reconstruction properties.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn split(a: Vec<String>, sep: String, maxsplit: Option<usize>) -> (result: Vec<Vec<String>>)\n    requires\n        sep@ != Seq::<char>::empty(),\n        a.len() > 0,\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() as int ==> {\n            let parts = #[trigger] result[i]@;\n            let original = #[trigger] a[i]@;\n            (forall|j: int| 0 <= j < parts.len() as int ==> parts[j]@ != sep@) &&\n            (match maxsplit {\n                None => true,\n                Some(limit) => parts.len() <= limit + 1,\n            }) &&\n            parts.len() >= 1 &&\n            (original.len() == 0 ==> parts.len() == 1 && parts[0]@.len() == 0) &&\n            (original == sep@ ==> parts.len() == 2 && parts[0]@.len() == 0 && parts[1]@.len() == 0)\n        },", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "VT0642", "language": "verus", "source": "numpy_triple", "source_id": "strings_splitlines", "vc-description": "For each element in a, return a list of the lines in the element, breaking at line boundaries\n\nFor each element in a vector of strings, return a list of the lines in the element, breaking at line boundaries \n\nSpecification: splitlines returns a vector where each string is split into a list of lines\nbased on line boundaries, with proper handling of keepends and line break characters", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn splitlines(a: Vec<String>, keepends: bool) -> (result: Vec<Vec<String>>)\n    requires a@.len() > 0,\n    ensures \n        result@.len() == a@.len(),\n        forall|i: int| 0 <= i < result@.len() ==> #[trigger] result@[i]@.len() >= 1", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0643", "language": "verus", "source": "numpy_triple", "source_id": "strings_startswith", "vc-description": "Check if strings in array start with given prefixes\n\nSpecification: startswith returns boolean array indicating which strings start with corresponding prefixes", "vc-preamble": "use vstd::prelude::*;\nuse vstd::string::*;\n\nverus! {\nspec fn string_starts_with(s: Seq<char>, prefix: Seq<char>) -> bool {\n    prefix.len() <= s.len() && s.subrange(0, prefix.len() as int) == prefix\n}", "vc-helpers": "", "vc-spec": "fn startswith(a: Vec<String>, prefixes: Vec<String>) -> (result: Vec<bool>)\n    requires a.len() == prefixes.len(),\n    ensures \n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> {\n            &&& (result[i] == string_starts_with(a[i]@, prefixes[i]@))\n            &&& (result[i] ==> prefixes[i]@.len() <= a[i]@.len())\n            &&& (result[i] ==> a[i]@.subrange(0, prefixes[i]@.len() as int) == prefixes[i]@)\n            &&& (!result[i] ==> (prefixes[i]@.len() > a[i]@.len() || a[i]@.subrange(0, prefixes[i]@.len() as int) != prefixes[i]@))\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0644", "language": "verus", "source": "numpy_triple", "source_id": "strings_str_len", "vc-description": "Returns the length of each string element in the vector.\nFor Unicode strings, this counts the number of Unicode code points.\n\nSpecification: str_len returns the length (number of Unicode code points) of each string element.\n\nPreconditions: None (str_len is defined for all strings)\n\nPostconditions:\n- The result vector has the same size as the input vector\n- Each element in the result corresponds to the length of the corresponding input string\n- Length is always non-negative (natural number)\n- Empty strings have length 0\n- Length is measured in Unicode code points for Unicode strings", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn str_len(a: Vec<String>) -> (result: Vec<u8>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> {\n            &&& result[i] as nat == a[i]@.len()\n            &&& result[i] as nat >= 0\n            &&& (a[i]@.len() == 0 <==> a[i]@ == Seq::<char>::empty())\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0645", "language": "verus", "source": "numpy_triple", "source_id": "strings_strip", "vc-description": "numpy.strings.strip: For each element in a vector, return a copy with the leading and trailing characters removed.\n\nRemoves both leading and trailing characters from each string element in the input vector.\nThis is a combination of lstrip and rstrip operations. The behavior depends on the chars parameter:\n- If chars is None, whitespace characters are removed from both ends\n- If chars is provided, any combination of those characters is removed from both ends\n\nThe function preserves the shape of the input array and handles empty strings\nappropriately by returning them unchanged.\n\nFrom NumPy documentation:\n- Parameters: a (array_like) - Input array with string dtype\n              chars (optional) - Characters to remove from both ends\n- Returns: out (ndarray) - Output array with leading and trailing characters removed\n\nMathematical Properties:\n1. Element-wise transformation: result[i] = strip(a[i], chars) for all i\n2. Length preservation or reduction: result[i].length ≤ a[i].length for all i\n3. Substring property: result[i] is a substring of a[i] for all i\n4. Character set removal: only characters in chars are removed from both ends\n5. Preserves vector length: result.size = a.size\n6. Combination of lstrip and rstrip: strip(s) = rstrip(lstrip(s))", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn strip(a: Vec<String>, chars: Option<String>) -> (result: Vec<String>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() as int ==> {\n            #[trigger] result[i]@.len() <= a[i]@.len() &&\n            (a[i]@.len() == 0 ==> result[i]@.len() == 0)\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0646", "language": "verus", "source": "numpy_triple", "source_id": "strings_swapcase", "vc-description": "Return element-wise a copy of the string with uppercase characters converted to lowercase and vice versa\n\nReturn element-wise a copy of the string with uppercase characters converted to lowercase and vice versa\n\nSpecification: numpy.strings.swapcase returns a vector where each string element\nhas its case swapped (uppercase becomes lowercase and vice versa).\n\nMathematical Properties:\n1. Element-wise correctness: Each element has its alphabetic characters case-swapped\n2. Length preservation: Each transformed string has the same length as the original\n3. Case transformation: Uppercase→lowercase, lowercase→uppercase, non-alpha unchanged\n4. Involutive property: swapcase(swapcase(x)) = x\n5. Empty string handling: Empty strings remain empty\n6. Character-level correctness: Each character is correctly transformed\n\nPrecondition: True (no special preconditions for case swapping)\nPostcondition: For all indices i, result[i] is the case-swapped version of a[i]", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn char_swapcase(c: char) -> char;\n\nspec fn string_swapcase(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        Seq::<char>::empty()\n    } else {\n        seq![char_swapcase(s[0])] + string_swapcase(s.skip(1))\n    }\n}\n\nfn swapcase(a: Vec<String>) -> (result: Vec<String>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> result[i]@.len() == a[i]@.len(),\n        forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a[i]@.len() ==> \n            #[trigger] result[i]@[j] == char_swapcase(a[i]@[j])", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0648", "language": "verus", "source": "numpy_triple", "source_id": "strings_translate", "vc-description": "numpy.strings.translate: For each element in a, return a copy of the string where \nall characters occurring in deletechars are removed, and the remaining characters \nhave been mapped through the given translation table.\n\nThis function performs character-level transformation on byte strings by first\nremoving characters specified in deletechars, then translating each remaining\ncharacter using a 256-byte translation table.\n\nSpecification for numpy.strings.translate: Returns a vector where each element is \nthe result of character deletion followed by character translation.\n\nMathematical Properties:\n1. Element-wise transformation: Each result element is derived from the corresponding input\n2. Two-stage process: First deletion, then translation\n3. Deletion completeness: All occurrences of characters in deletechars are removed\n4. Translation mapping: Each remaining byte is mapped through the translation table\n5. Order preservation: Relative order of non-deleted characters is maintained\n6. Empty string handling: Empty strings remain empty after transformation\n\n// Length property: result length <= original length (due to deletion)\n\n// Deletion property: no character from deletechars appears in result\n\n// Translation property: each byte in result comes from table translation\n\n// The original character existed in input and wasn't deleted\n\n// Completeness property: all non-deleted characters are translated and included  \n\n// Identity on empty deletechars\n\n// Empty string preservation", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn translate(a: Vec<Vec<u8>>, table: Vec<u8>, deletechars: Vec<u8>) -> (result: Vec<Vec<u8>>)\n    requires\n        table.len() == 256,\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() ==> {\n\n            result[i].len() <= a[i].len() &&\n\n            (forall|c: u8| #[trigger] result[i]@.contains(c) ==> {\n                forall|j: int| 0 <= j < deletechars.len() ==> c != deletechars[j]\n            }) &&\n\n            (forall|k: int| 0 <= k < result[i].len() ==> {\n                exists|orig_char: u8, table_idx: int|\n                    0 <= table_idx < 256 &&\n                    orig_char == table_idx as u8 &&\n                    #[trigger] result[i][k] == table[table_idx as int] &&\n\n                    a[i]@.contains(orig_char) &&\n                    (forall|j: int| 0 <= j < deletechars.len() ==> orig_char != deletechars[j])\n            }) &&\n\n            (forall|orig_char: u8| #[trigger] a[i]@.contains(orig_char) ==> {\n                (forall|j: int| 0 <= j < deletechars.len() ==> orig_char != deletechars[j]) ==> {\n                    exists|translated_char: u8| result[i]@.contains(translated_char) &&\n                        exists|table_idx: int|\n                            0 <= table_idx < 256 &&\n                            orig_char as int == table_idx &&\n                            translated_char == table[table_idx as int]\n                }\n            }) &&\n\n            (deletechars.len() == 0 ==> {\n                result[i].len() == a[i].len() &&\n                (forall|k: int| 0 <= k < a[i].len() ==> {\n                    exists|table_idx: int|\n                        0 <= table_idx < 256 &&\n                        a[i][k] as int == table_idx &&\n                        #[trigger] result[i][k] == table[table_idx as int]\n                })\n            }) &&\n\n            (a[i].len() == 0 ==> result[i].len() == 0)\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0649", "language": "verus", "source": "numpy_triple", "source_id": "strings_upper", "vc-description": "numpy.strings.upper: Return an array with the elements converted to uppercase.\n\nConverts each string element in the input vector to uppercase. This transformation\napplies to all alphabetic characters while preserving non-alphabetic characters\n(digits, punctuation, whitespace) unchanged.\n\nThe function preserves the shape of the input array and handles empty strings\nappropriately by returning them unchanged.\n\nFrom NumPy documentation:\n- Parameters: a (array_like) - Input array with string dtype\n- Returns: out (ndarray) - Output array with elements converted to uppercase\n\nMathematical Properties:\n1. Element-wise transformation: result[i] = upper(a[i]) for all i\n2. Length preservation: result[i].length = a[i].length for all i\n3. Case transformation: lowercase letters become uppercase, others unchanged\n4. Idempotent: upper(upper(x)) = upper(x)\n5. Preserves vector length: result.size = a.size\n\nSpecification: numpy.strings.upper returns a vector where each string element\nis converted to uppercase.\n\nMathematical Properties:\n1. Element-wise correctness: Each element is correctly converted to uppercase\n2. Length preservation: Each transformed string has the same length as the original\n3. Case transformation: Lowercase letters become uppercase, others unchanged\n4. Idempotent property: Applying upper twice gives the same result as applying it once\n5. Empty string handling: Empty strings remain empty\n6. Character-level correctness: Each character is correctly transformed\n\nPrecondition: True (no special preconditions for uppercase conversion)\nPostcondition: For all indices i, result[i] is the uppercase version of a[i]", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn string_to_upper(s: Seq<char>) -> Seq<char> {\n    s\n}", "vc-helpers": "", "vc-spec": "fn upper(a: Vec<String>) -> (result: Vec<String>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < a.len() as int ==>\n            result@[i]@ == string_to_upper(a@[i]@) &&\n            result@[i]@.len() == a@[i]@.len()", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0650", "language": "verus", "source": "numpy_triple", "source_id": "strings_zfill", "vc-description": "numpy.strings.zfill: Return the numeric string left-filled with zeros.\n\nZero-fills each string in the input array by padding it with leading zeros\nto reach the specified width. If the original string is longer than or equal\nto the width, it remains unchanged. This function is specifically designed\nfor numeric strings and handles sign prefixes appropriately.\n\nThe function behaves like Python's str.zfill() method:\n- Pads strings with leading zeros to reach the target width\n- Preserves sign characters ('+' or '-') at the beginning\n- Returns original string if it's already >= target width\n\nFrom NumPy documentation:\n- Parameters: a (array_like) - Input array with string dtype\n              width (int) - Target width for zero-filling\n- Returns: out (ndarray) - Output array with zero-filled strings\n\nMathematical Properties:\n1. Length invariant: result length is max(original_length, width)\n2. Identity: strings already >= width remain unchanged\n3. Zero-padding: shorter strings get leading zeros\n4. Sign preservation: leading '+' or '-' characters are preserved\n5. Minimality: no over-padding beyond required width", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn is_sign_char(c: char) -> bool {\n    c == '+' || c == '-'\n}\n\nspec fn all_zeros(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> s[i] == '0'\n}\n\nspec fn max_usize(a: usize, b: usize) -> usize {\n    if a >= b { a } else { b }\n}\n\nfn zfill(a: Vec<Vec<char>>, width: usize) -> (result: Vec<Vec<char>>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> \n            #[trigger] result[i].len() == max_usize(a[i].len(), width),\n        forall|i: int| 0 <= i < result.len() && a[i].len() >= width ==> \n            #[trigger] result[i]@ == a[i]@,\n        forall|i: int| 0 <= i < result.len() && a[i].len() < width && a[i].len() > 0 && \n            !is_sign_char(a[i]@[0]) ==> \n            #[trigger] all_zeros(result[i]@.take((width - a[i].len()) as int)) &&\n            result[i]@.skip((width - a[i].len()) as int) == a[i]@,\n        forall|i: int| 0 <= i < result.len() && a[i].len() < width && a[i].len() > 0 && \n            is_sign_char(a[i]@[0]) ==> \n            #[trigger] result[i]@[0] == a[i]@[0] &&\n            result[i]@.skip(width as int) == a[i]@.skip(1),\n        forall|i: int| 0 <= i < result.len() && a[i].len() == 0 ==> \n            #[trigger] result[i].len() == width && \n            all_zeros(result[i]@),\n        forall|i: int| 0 <= i < result.len() && a[i].len() < width ==> \n            #[trigger] result[i].len() == width,\n        forall|i: int| 0 <= i < result.len() && a[i].len() < width ==> \n            #[trigger] all_zeros(result[i]@.take((width - a[i].len()) as int))", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0651", "language": "verus", "source": "numpy_triple", "source_id": "ufunc___call__", "vc-description": "Apply a binary universal function elementwise to two vectors.\nThis represents the core __call__ behavior for binary ufuncs like add, multiply, etc.\n\nSpecification: ufunc.__call__ applies the operation elementwise to input vectors.\nThe result has the same shape as the inputs (broadcasting to common shape) and\neach element is computed by applying the operation to corresponding elements.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn ufunc_call(op: spec_fn(f32, f32) -> f32, a: &Vec<f32>, b: &Vec<f32>) -> (result: Vec<f32>)\n    requires a@.len() == b@.len(),\n    ensures \n        result@.len() == a@.len(),\n        forall|i: int| 0 <= i < result@.len() ==> result@[i] == op(a@[i], b@[i])", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0652", "language": "verus", "source": "numpy_triple", "source_id": "ufunc_accumulate", "vc-description": "Universal function accumulate method: Accumulate the result of applying a binary operator\nto all elements in a vector.\n\nFor a binary operation `op` and input vector [a₁, a₂, a₃, ..., aₙ], returns:\n[a₁, op(a₁, a₂), op(op(a₁, a₂), a₃), ..., op(op(...op(a₁, a₂), a₃), ..., aₙ)]\n\nThis generalizes cumulative operations:\n- When op = (+), this becomes cumsum: [a₁, a₁+a₂, a₁+a₂+a₃, ...]\n- When op = (*), this becomes cumprod: [a₁, a₁*a₂, a₁*a₂*a₃, ...]\n\nThe result has the same shape as the input array.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn accumulate(a: Vec<i8>) -> (result: Vec<i8>)\n    ensures\n        result.len() == a.len(),\n        a.len() > 0 ==> result[0] == a[0],", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0654", "language": "verus", "source": "numpy_triple", "source_id": "ufunc_outer", "vc-description": "Universal function outer method: Apply a binary operator to all pairs (a, b) \nwith a in A and b in B.\n\nFor two 1-D vectors A = [a₁, a₂, ..., aₘ] and B = [b₁, b₂, ..., bₙ], \nthe outer product produces an m×n matrix where result[i,j] = op(A[i], B[j]).\n\nThis generalizes the concept of outer product beyond just multiplication:\n- When op = (*), this becomes the traditional outer product\n- When op = (+), this becomes the sum of all pairs\n- When op = (^), this becomes the power of all pairs\n\nThe result has shape (m, n) where m is the length of A and n is the length of B.\n\nSpecification: outer applies a binary operator to all pairs of elements\nfrom two input vectors, producing a matrix result.\n\nPrecondition: True (works for any two vectors and binary operation)\nPostcondition:\n- Result has dimensions m × n (outer dimensions of input vectors)\n- Each element result[i][j] equals op(a[i], b[j])\n- The result preserves the structure of the Cartesian product of the inputs\n- All pairs (i,j) with i ∈ [0..m-1] and j ∈ [0..n-1] are covered exactly once\n\nMathematical Properties:\n- result[i][j] = op(a[i], b[j]) for all valid i, j\n- The result matrix has the same number of rows as the first input vector\n- The result matrix has the same number of columns as the second input vector\n- For commutative operations: outer(op, a, b)[i][j] = outer(op, b, a)[j][i]\n- For associative operations: outer preserves the algebraic structure", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn outer(op: spec_fn(f64, f64) -> f64, a: Vec<f64>, b: Vec<f64>) -> (result: Vec<Vec<f64>>)\n    ensures\n        result.len() == a.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == b.len(),\n        forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < b.len() ==> \n            result[i][j] == op(a[i], b[j])", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0655", "language": "verus", "source": "numpy_triple", "source_id": "ufunc_reduce", "vc-description": "Reduces an array by applying a binary operation repeatedly along an axis.\nFor 1D arrays, this applies the operation successively to pairs of elements.\n\nSpecification: reduce applies a binary operation repeatedly to reduce an array to a single value.\nThe operation is applied left-associatively: ((a[0] op a[1]) op a[2]) op ... op a[n-1]\n\n/* Represents left-associative folding result at position index */\n\n/* Placeholder - actual implementation would apply operation */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn fold_left(arr: Seq<f64>, index: nat) -> f64\n    decreases index\n{\n    if index == 0 {\n        arr[0 as int]\n    } else {\n\n        arr[index as int]\n    }\n}\n\nfn reduce(arr: Vec<f64>) -> (result: f64)\n    requires arr.len() > 0,\n    ensures \n        arr.len() == 1 ==> result == arr[0],\n        arr.len() > 1 ==> result == fold_left(arr@, (arr.len() - 1) as nat)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0656", "language": "verus", "source": "numpy_triple", "source_id": "ufunc_reduceat", "vc-description": "Universal function reduceat method: Performs reductions on specified slices of an array.\n\nFor each index pair (indices[i], indices[i+1]), applies the reduction operation \nto the slice array[indices[i]:indices[i+1]].\n\nSpecial behavior:\n- For the last index, reduces from indices[i] to the end of the array\n- If indices[i] >= indices[i+1], uses only the element at indices[i]\n- Output length equals the number of indices provided\n\nExample: np.add.reduceat([1,2,3,4,5,6,7,8], [0,4,1,5]) applies addition to slices:\n- [1,2,3,4] -> 10\n- [2,3,4,5] -> 14  \n- [5,6,7,8] -> 26\nResult: [10, 14, 26]", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn slice_sum(arr: Seq<i32>, start: int, end: int) -> int\n    decreases (end - start)\n{\n    if start >= end || start < 0 || end > arr.len() {\n        0\n    } else if start + 1 == end {\n        arr[start] as int\n    } else {\n        (arr[start] as int) + slice_sum(arr, start + 1, end)\n    }\n}\n\nfn reduceat_add(arr: Vec<i32>, indices: Vec<usize>) -> (result: Vec<i32>)\n    requires \n        arr.len() > 0,\n        indices.len() > 0,\n        forall|i: int| 0 <= i < indices.len() ==> #[trigger] (indices[i] as int) < arr.len() as int,\n    ensures\n        result.len() == indices.len(),\n        forall|i: int| 0 <= i < indices.len() ==> {\n            let start_idx = indices[i] as int;\n            if i < indices.len() - 1 {\n                let end_idx = indices[(i + 1) as int] as int;\n                if start_idx < end_idx {\n                    /* Normal forward slice case */\n                    #[trigger] (result[i] as int) == slice_sum(arr@, start_idx, end_idx)\n                } else {\n                    /* Single element case when indices are non-increasing */\n                    #[trigger] result[i] == arr[start_idx]\n                }\n            } else {\n                /* Last index case - reduce to end of array */\n                #[trigger] (result[i] as int) == slice_sum(arr@, start_idx, arr.len() as int)\n            }\n        },", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0657", "language": "verus", "source": "numpy_triple", "source_id": "ufuncs_frompyfunc", "vc-description": "numpy.frompyfunc: Takes a function and returns a universal function that applies it element-wise.\n\nCreates a universal function (ufunc) from a Python function. The resulting ufunc\napplies the original function element-wise to input arrays. For simplicity, we\nmodel this for the common case of a unary function (nin=1, nout=1).\n\nIn our Vector-based model, this takes a function α → β and returns a function\nthat applies it element-wise to Vector α n, producing Vector β n.\n\nThis function enables the creation of vectorized operations from arbitrary functions,\nwhich is a core capability of NumPy's universal function system.\n\nSpecification: numpy.frompyfunc creates a vectorized version of a function\nthat applies the original function element-wise.\n\nPrecondition: True (any function can be vectorized)\nPostcondition: For all indices i, the result at index i equals func applied\nto the input at index i.\n\nThis captures the essential property that frompyfunc creates an element-wise\nmapping from the original function, preserving the functional behavior\nwhile extending it to work with vectors.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_frompyfunc(func: spec_fn(i8) -> i8, input: Vec<i8>) -> (result: Vec<i8>)\n    ensures\n        result.len() == input.len(),\n        forall|i: int| 0 <= i < input.len() ==> result[i] == func(input[i])", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0658", "language": "verus", "source": "numpy_triple", "source_id": "ufuncs_identity", "vc-description": "{\n  \"name\": \"identity\",\n  \"description\": \"The identity value for the ufunc\",\n  \"details\": \"Value such that func(x, identity) == x for all x\",\n  \"examples\": {\n    \"add.identity\": \"0\",\n    \"multiply.identity\": \"1\",\n    \"logical_and.identity\": \"True\",\n    \"logical_or.identity\": \"False\"\n  }\n}\n\nufunc.identity: Get the identity element for a ufunc operation.\n\nReturns the identity element for a given binary operation, which is the value\nthat when combined with any other value using that operation, leaves the other\nvalue unchanged. For example:\n- Addition: identity is 0 (x + 0 = x)\n- Multiplication: identity is 1 (x * 1 = x)\n- Logical AND: identity is True (x ∧ True = x)\n- Logical OR: identity is False (x ∨ False = x)\n\nSome operations may have no identity element, in which case None is returned.\n\nSpecification: ufunc_identity returns the identity element if it exists.\n\nPrecondition: The operation is a valid binary function\nPostcondition: If an identity element exists, applying the operation with\n               that element leaves any other element unchanged", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nenum OpType {\n    Add,\n    Multiply,\n    LogicalAnd,\n    LogicalOr,\n}\n\nspec fn apply_op(op: OpType, x: int, y: int) -> int {\n    match op {\n        OpType::Add => x + y,\n        OpType::Multiply => x * y,\n        OpType::LogicalAnd => if x != 0 && y != 0 { 1 } else { 0 },\n        OpType::LogicalOr => if x != 0 || y != 0 { 1 } else { 0 },\n    }\n}\n\nspec fn has_identity(op: OpType, id: int) -> bool {\n    forall|x: int| apply_op(op, x, id) == x && apply_op(op, id, x) == x\n}", "vc-helpers": "", "vc-spec": "fn ufunc_identity(op: OpType) -> (result: Option<i8>)\n    ensures\n        match result {\n            Some(id) => has_identity(op, id as int),\n            None => forall|id: int| !has_identity(op, id)\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    None\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0659", "language": "verus", "source": "numpy_triple", "source_id": "ufuncs_nargs", "vc-description": "The number of arguments the ufunc accepts. Equal to nin + nout.\n\nnumpy.ufunc.nargs: Returns the total number of arguments the ufunc accepts.\n\nThis attribute represents the sum of input and output arguments for a ufunc.\nFor example, np.add has nin=2, nout=1, so nargs=3.\n\nThis is a read-only attribute that provides metadata about the ufunc's signature.\n\nSpecification: numpy.ufunc.nargs returns nin + nout\n\nPrecondition: True (no special preconditions for reading metadata)\nPostcondition: The result equals the sum of input and output arguments", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* Structure representing a NumPy universal function (ufunc) with its metadata */\nstruct Ufunc {\n    /* Number of input arguments the ufunc accepts */\n    nin: nat,\n    /* Number of output arguments the ufunc produces */\n    nout: nat,\n}", "vc-helpers": "", "vc-spec": "fn numpy_nargs(ufunc: Ufunc) -> (result: u8)\n    ensures result as nat == ufunc.nin + ufunc.nout", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0661", "language": "verus", "source": "numpy_triple", "source_id": "ufuncs_nout", "vc-description": "The number of output arguments\n\nReturns the number of output arguments for a given ufunc.\nThis corresponds to the nout attribute of NumPy ufuncs.\n\nSpecification: nout returns the number of output arguments of the ufunc.\n\nThis specification captures the essential mathematical properties of the nout attribute:\n\n1. **Correctness**: The function returns exactly the nout_val field from the ufunc structure\n2. **Lower bound**: The result is always ≥ 1, since all ufuncs can produce at least one output\n3. **Type safety**: The result is a natural number representing a count\n4. **Determinism**: Given the same ufunc, nout always returns the same value\n\nMathematical properties:\n- ∀ ufunc : UFunc, nout(ufunc) = ufunc.nout_val  \n- ∀ ufunc : UFunc, nout(ufunc) ≥ 1\n- nout is a pure function (no side effects)\n\nExamples from NumPy documentation:\n- add.nout = 1 (binary operation with single output)\n- modf.nout = 2 (returns fractional and integral parts)\n- divmod.nout = 2 (returns quotient and remainder)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* Represents a universal function (ufunc) type that captures basic metadata about \n   the number of inputs and outputs. In NumPy, this would be the ufunc object itself. */\nstruct UFunc {\n    /* Number of input arguments the ufunc accepts */\n    nin: nat,\n    /* Number of output arguments the ufunc produces */\n    nout_val: nat,\n}", "vc-helpers": "", "vc-spec": "fn nout(ufunc: UFunc) -> (result: u8)\n    requires ufunc.nout_val >= 1,\n    ensures \n        result as nat == ufunc.nout_val,\n        result as nat >= 1", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0662", "language": "verus", "source": "numpy_triple", "source_id": "ufuncs_ntypes", "vc-description": "The number of supported input/output type combinations\n\nnumpy.ufunc.ntypes: Returns the number of supported input/output type combinations\nfor a universal function.\n\nThe ntypes attribute represents the number of numerical NumPy types on which\nthe ufunc can operate. This is a key characteristic that determines the\ntype flexibility of different NumPy universal functions.\n\nFor example:\n- np.add.ntypes returns around 22 (supports most numerical types)\n- np.exp.ntypes returns around 10 (fewer supported types)\n- np.remainder.ntypes returns around 16 (intermediate support)\n\nSpecification: ntypes returns the count of supported type combinations\nfor a ufunc, which must be a positive number for any valid ufunc.\n\nPrecondition: The input represents valid type combinations for a ufunc\nPostcondition: The result is the exact count of type combinations,\n              which is non-zero for any functional ufunc and equals\n              the length of the type combinations vector.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn ntypes(ufunc_type_combinations: Vec<String>) -> (result: usize)\n    requires ufunc_type_combinations@.len() > 0,\n    ensures \n        result == ufunc_type_combinations@.len(),\n        result > 0", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0663", "language": "verus", "source": "numpy_triple", "source_id": "ufuncs_signature", "vc-description": "Core signature for generalized ufuncs. Defines core dimensionality of inputs and outputs. Parse a ufunc signature string into a structured representation. Specification: parseSignature correctly parses ufunc signature strings.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* A signature represents the core dimensionality pattern for a generalized ufunc */\npub struct UfuncSignature {\n    /* Input dimension patterns as list of dimension lists */\n    pub inputs: Vec<Vec<String>>,\n    /* Output dimension patterns as list of dimension lists */\n    pub outputs: Vec<Vec<String>>,\n    /* All unique dimension names used in the signature */\n    pub dimension_names: Vec<String>,\n}", "vc-helpers": "", "vc-spec": "fn parse_signature(sig: Vec<String>) -> (result: UfuncSignature)\n    requires sig@.len() > 0,\n    ensures\n        result.inputs@.len() > 0 || result.outputs@.len() > 0,\n        result.inputs@.len() + result.outputs@.len() > 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0664", "language": "verus", "source": "numpy_triple", "source_id": "ufuncs_types", "vc-description": "List of supported data type signatures\nShows input->output type mappings for universal functions\nReturns formatted type signatures as strings", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n/* Data type character codes used in NumPy ufunc type signatures */\n#[derive(PartialEq, Eq)]\nenum TypeCode {\n    Bool,       // '?'\n    Byte,       // 'b' \n    UByte,      // 'B'\n    Short,      // 'h'\n    UShort,     // 'H'\n    Int,        // 'i'\n    UInt,       // 'I'\n    Long,       // 'l'\n    ULong,      // 'L'\n    LongLong,   // 'q'\n    ULongLong,  // 'Q'\n    Float32,    // 'f'\n    Float64,    // 'd'\n    LongDouble, // 'g'\n    Complex64,  // 'F'\n    Complex128, // 'D'\n    CLongDouble,// 'G'\n    Object,     // 'O'\n}\n\n/* Type signature representing input->output mapping for ufuncs */\nstruct TypeSignature {\n    input_types: Vec<TypeCode>,\n    output_type: TypeCode,\n}\n\n/* Convert TypeCode to character representation */\nspec fn type_code_to_char(tc: TypeCode) -> char {\n    match tc {\n        TypeCode::Bool => '?',\n        TypeCode::Byte => 'b',\n        TypeCode::UByte => 'B',\n        TypeCode::Short => 'h',\n        TypeCode::UShort => 'H',\n        TypeCode::Int => 'i',\n        TypeCode::UInt => 'I',\n        TypeCode::Long => 'l',\n        TypeCode::ULong => 'L',\n        TypeCode::LongLong => 'q',\n        TypeCode::ULongLong => 'Q',\n        TypeCode::Float32 => 'f',\n        TypeCode::Float64 => 'd',\n        TypeCode::LongDouble => 'g',\n        TypeCode::Complex64 => 'F',\n        TypeCode::Complex128 => 'D',\n        TypeCode::CLongDouble => 'G',\n        TypeCode::Object => 'O',\n    }\n}\n\n/* Format a type signature as a string (input1input2...->output) */\nspec fn format_type_signature(sig: TypeSignature) -> Seq<char> {\n    let input_chars = sig.input_types@.map(|i: int, tc: TypeCode| type_code_to_char(tc));\n    let arrow_chars = seq!['-', '>'];\n    let output_char = seq![type_code_to_char(sig.output_type)];\n    input_chars + arrow_chars + output_char\n}", "vc-helpers": "", "vc-spec": "fn types(ufunc_signatures: Vec<TypeSignature>) -> (result: Vec<String>)\n    ensures\n        result.len() == ufunc_signatures.len(),\n        forall|i: int| 0 <= i < result.len() ==>\n            result[i]@ == format_type_signature(ufunc_signatures[i]) &&\n            ufunc_signatures[i].input_types.len() > 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "VT0665", "language": "verus", "source": "numpy_triple", "source_id": "ufuncs_vectorize", "vc-description": "Generalized function class that converts a Python function into a vectorized function\n\nVectorizes a scalar function to operate element-wise on vectors.\nTakes a function f and applies it element-wise to input vectors,\nproducing a new vector with the same size.\n\nSpecification: vectorize applies the given function element-wise to the input vector.\nThe result vector has the same size and each element is the function applied to \nthe corresponding element of the input vector.\n\nProperties verified:\n1. Element-wise application: each output element equals f applied to corresponding input\n2. Size preservation: output vector has same size as input vector\n3. Order preservation: relative positions of elements are maintained\n4. Functional purity: result depends only on function f and input vector", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn vectorize<A, B>(f: spec_fn(A) -> B, arr: Vec<A>) -> (result: Vec<B>)\n    ensures\n        result.len() == arr.len(),\n        forall|i: int| 0 <= i < arr.len() ==> result[i] == f(arr[i])", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa_entry_metadata": {"issues": {"specs_with_default_values": 0, "execs_with_bodies": 0, "execs_with_ghost_types": 0, "near_duplicates": 0}, "individual_score": 1.0}}
