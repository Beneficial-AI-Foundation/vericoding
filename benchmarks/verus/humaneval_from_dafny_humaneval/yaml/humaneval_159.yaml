vc-description: |-
  This verification task involves implementing a method that calculates
  carrot consumption for a rabbit. Given the number of carrots already eaten, the
  number of additional carrots needed, and the number of carrots remaining in stock,
  the method should return the total carrots that will be eaten and how many carrots
  will be left. The rabbit will eat as many carrots as possible from the remaining
  stock, up to the number needed.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

  spec fn valid_input(number: int, need: int, remaining: int) -> bool
  {
      0 <= number <= 1000 && 0 <= need <= 1000 && 0 <= remaining <= 1000
  }

  spec fn can_eat(need: int, remaining: int) -> int
  {
      if need <= remaining { need } else { remaining }
  }

  spec fn total_eaten(number: int, need: int, remaining: int) -> int
  {
      number + can_eat(need, remaining)
  }

  spec fn carrots_left(need: int, remaining: int) -> int
  {
      remaining - can_eat(need, remaining)
  }

  spec fn valid_result(result: Seq<int>, number: int, need: int, remaining: int) -> bool
  {
      result.len() == 2 &&
      result[0] == total_eaten(number, need, remaining) &&
      result[1] == carrots_left(need, remaining) &&
      result[0] >= number &&
      result[1] >= 0 &&
      result[1] <= remaining
  }

vc-helpers: |-

vc-spec: |-
  fn eat(number: i8, need: i8, remaining: i8) -> (result: Vec<i8>)
      requires valid_input(number as int, need as int, remaining as int)
      ensures valid_result(result@.map(|i, x| x as int), number as int, need as int, remaining as int)

vc-code: |-
  {
      assume(false);
      Vec::new()
  }

vc-postamble: |-

  }

  fn main() {}