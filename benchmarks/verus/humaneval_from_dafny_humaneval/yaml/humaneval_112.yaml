vc-description: |-
  This task implements a string filtering and palindrome checking function.
  Given two strings s and c, it removes all characters from string s that appear anywhere
  in string c, then determines if the resulting string is a palindrome (reads the
  same forwards and backwards). The method returns a tuple containing the filtered
  string and a boolean indicating whether it's a palindrome.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

  spec fn filter_chars(s: Seq<char>, c: Seq<char>) -> Seq<char>
      decreases s.len()
  {
      if s.len() == 0 {
          Seq::empty()
      } else if c.contains(s[0]) {
          filter_chars(s.subrange(1, s.len() as int), c)
      } else {
          seq![s[0]].add(filter_chars(s.subrange(1, s.len() as int), c))
      }
  }

  spec fn reverse_seq(s: Seq<char>) -> Seq<char>
      decreases s.len()
  {
      if s.len() == 0 {
          Seq::empty()
      } else {
          reverse_seq(s.subrange(1, s.len() as int)).add(seq![s[0]])
      }
  }

vc-helpers: |-
  proof fn filter_chars_append_lemma(s: Seq<char>, ch: char, c: Seq<char>)
      ensures filter_chars(s.add(seq![ch]), c) == 
          (if c.contains(ch) { filter_chars(s, c) } else { filter_chars(s, c).add(seq![ch]) })
      decreases s.len()
  {
      assume(false); /* TODO: Remove this line and implement the proof */
  }

vc-spec: |-
  fn reverse_delete(s: Seq<char>, c: Seq<char>) -> (result: (Seq<char>, bool))
      ensures
          result.0 == filter_chars(s, c),
          result.1 == (result.0 == reverse_seq(result.0)),
          result.0.len() <= s.len(),
          forall|i: int| #![auto] 0 <= i < result.0.len() ==> !c.contains(result.0[i]),
          forall|i: int| #![auto] 0 <= i < result.0.len() ==> s.contains(result.0[i]),

vc-code: |-
  {
      // impl-start
      assume(false);
      unreached()
      // impl-end
  }

vc-postamble: |-

  }

  fn main() {}