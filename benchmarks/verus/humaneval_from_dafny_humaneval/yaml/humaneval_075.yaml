vc-description: |-
  This verification task implements a method to determine if a given
  integer (less than 100) is the product of exactly 3 prime numbers, counting repetitions.
  The method performs prime factorization and checks if exactly 3 prime factors (with
  repetitions) multiply to the original number.

  The expected implementation uses trial division to find all prime factors, starting
  with factors of 2, then checking odd numbers up to the square root, and finally
  handling any remaining prime factor greater than the square root.

vc-preamble: |-
  use vstd::prelude::*;

  verus! {

  spec fn is_prime_number(n: int) -> bool {
      n >= 2 && forall|k: int| #[trigger] (n % k) != 0 ==> (2 <= k < n ==> n % k != 0)
  }

  spec fn seq_product(factors: Seq<int>) -> int
      decreases factors.len()
  {
      if factors.len() == 0 { 
          1 
      } else { 
          factors[0] * seq_product(factors.subrange(1, factors.len() as int))
      }
  }

  spec fn power(base: int, exp: nat) -> int
      decreases exp
  {
      if exp == 0 { 
          1 
      } else { 
          base * power(base, (exp - 1) as nat)
      }
  }

  proof fn seq_product_append_lemma(s: Seq<int>, x: int)
      ensures seq_product(s.push(x)) == seq_product(s) * x
      decreases s.len()
  {
      assume(false); /* TODO: Remove this line and implement the proof */
  }

vc-helpers: |-

vc-spec: |-
  fn is_multiply_prime(a: int) -> (result: bool)
      requires 
          a >= 0 && a < 100
      ensures 
          a < 8 ==> result == false,
          result == true <==> (exists|p1: int, p2: int, p3: int|
              p1 >= 2 && p2 >= 2 && p3 >= 2 && 
              is_prime_number(p1) && is_prime_number(p2) && is_prime_number(p3) &&
              a == p1 * p2 * p3)

vc-code: |-
  {
      assume(false);
      false
  }

vc-postamble: |-

  }

  fn main() {}